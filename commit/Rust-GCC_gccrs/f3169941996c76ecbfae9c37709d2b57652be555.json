{"sha": "f3169941996c76ecbfae9c37709d2b57652be555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxNjk5NDE5OTZjNzZlY2JmYWU5YzM3NzA5ZDJiNTc2NTJiZTU1NQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-17T16:50:29Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-18T16:06:49Z"}, "message": "libstdc++: P1243R4 Rangify new algorithms\n\nThis adds rangified overloads for for_each_n, sample and clamp as per P1243R4.\n\nlibstdc++-v3/ChangeLog:\n\n\tP1243R4 Rangify new algorithms\n\t* include/bits/ranges_algo.h (for_each_n_result, __for_each_n_fn,\n\tfor_each_n, __sample_fn, sample, __clamp_fn, clamp): New.\n\t* testsuite/25_algorithms/clamp/constrained.cc: New test.\n\t* testsuite/25_algorithms/for_each/constrained.cc: Augment test.\n\t* testsuite/25_algorithms/sample/constrained.cc: New test.", "tree": {"sha": "e30850eec86962e35c48736205ccd960792c0c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e30850eec86962e35c48736205ccd960792c0c66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3169941996c76ecbfae9c37709d2b57652be555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3169941996c76ecbfae9c37709d2b57652be555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3169941996c76ecbfae9c37709d2b57652be555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3169941996c76ecbfae9c37709d2b57652be555/comments", "author": null, "committer": null, "parents": [{"sha": "06119d691e27e25fd4f4486467ad95f7b545fde3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06119d691e27e25fd4f4486467ad95f7b545fde3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06119d691e27e25fd4f4486467ad95f7b545fde3"}], "stats": {"total": 294, "additions": 294, "deletions": 0}, "files": [{"sha": "c230b2bae69ce22f07341b9e0fc1df7a53e5f5d0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f3169941996c76ecbfae9c37709d2b57652be555", "patch": "@@ -1,3 +1,12 @@\n+2020-02-17  Patrick Palka  <ppalka@redhat.com>\n+\n+\tP1243R4 Rangify new algorithms\n+\t* include/bits/ranges_algo.h (for_each_n_result, __for_each_n_fn,\n+\tfor_each_n, __sample_fn, sample, __clamp_fn, clamp): New.\n+\t* testsuite/25_algorithms/clamp/constrained.cc: New test.\n+\t* testsuite/25_algorithms/for_each/constrained.cc: Augment test.\n+\t* testsuite/25_algorithms/sample/constrained.cc: New test.\n+\n 2020-02-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \tP1964R2 Wording for boolean-testable"}, {"sha": "c50b369c6c02619afb7b085da6f1e1de5ddc3fb1", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=f3169941996c76ecbfae9c37709d2b57652be555", "patch": "@@ -195,6 +195,39 @@ namespace ranges\n \n   inline constexpr __for_each_fn for_each{};\n \n+  template<typename _Iter, typename _Fp>\n+    using for_each_n_result = for_each_result<_Iter, _Fp>;\n+\n+  struct __for_each_n_fn\n+  {\n+    template<input_iterator _Iter, typename _Proj = identity,\n+\t     indirectly_unary_invocable<projected<_Iter, _Proj>> _Fun>\n+      constexpr for_each_n_result<_Iter, _Fun>\n+      operator()(_Iter __first, iter_difference_t<_Iter> __n,\n+\t\t _Fun __f, _Proj __proj = {}) const\n+      {\n+\tif constexpr (random_access_iterator<_Iter>)\n+\t  {\n+\t    if (__n <= 0)\n+\t      return {std::move(__first), std::move(__f)};\n+\t    auto __last = __first + __n;\n+\t    return ranges::for_each(std::move(__first), std::move(__last),\n+\t\t\t\t    std::move(__f), std::move(__proj));\n+\t  }\n+\telse\n+\t  {\n+\t    while (__n-- > 0)\n+\t      {\n+\t\tstd::__invoke(__f, std::__invoke(__proj, *__first));\n+\t\t++__first;\n+\t      }\n+\t    return {std::move(__first), std::move(__f)};\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __for_each_n_fn for_each_n{};\n+\n   struct __find_fn\n   {\n     template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,\n@@ -1694,6 +1727,64 @@ namespace ranges\n \n   inline constexpr __rotate_copy_fn rotate_copy{};\n \n+  struct __sample_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     weakly_incrementable _Out, typename _Gen>\n+      requires (forward_iterator<_Iter> || random_access_iterator<_Out>)\n+\t&& indirectly_copyable<_Iter, _Out>\n+\t&& uniform_random_bit_generator<remove_reference_t<_Gen>>\n+      _Out\n+      operator()(_Iter __first, _Sent __last, _Out __out,\n+\t\t iter_difference_t<_Iter> __n, _Gen&& __g) const\n+      {\n+\tif constexpr (forward_iterator<_Iter>)\n+\t  {\n+\t    // FIXME: Forwarding to std::sample here requires computing __lasti\n+\t    // which may take linear time.\n+\t    auto __lasti = ranges::next(__first, __last);\n+\t    return std::sample(std::move(__first), std::move(__lasti),\n+\t\t\t       std::move(__out), __n, std::forward<_Gen>(__g));\n+\t  }\n+\telse\n+\t  {\n+\t    using __distrib_type\n+\t      = uniform_int_distribution<iter_difference_t<_Iter>>;\n+\t    using __param_type = typename __distrib_type::param_type;\n+\t    __distrib_type __d{};\n+\t    iter_difference_t<_Iter> __sample_sz = 0;\n+\t    while (__first != __last && __sample_sz != __n)\n+\t      {\n+\t\t__out[__sample_sz++] = *__first;\n+\t\t++__first;\n+\t      }\n+\t    for (auto __pop_sz = __sample_sz; __first != __last;\n+\t\t++__first, (void) ++__pop_sz)\n+\t      {\n+\t\tconst auto __k = __d(__g, __param_type{0, __pop_sz});\n+\t\tif (__k < __n)\n+\t\t  __out[__k] = *__first;\n+\t      }\n+\t    return __out + __sample_sz;\n+\t  }\n+      }\n+\n+    template<input_range _Range, weakly_incrementable _Out, typename _Gen>\n+      requires (forward_range<_Range> || random_access_iterator<_Out>)\n+\t&& indirectly_copyable<iterator_t<_Range>, _Out>\n+\t&& uniform_random_bit_generator<remove_reference_t<_Gen>>\n+      _Out\n+      operator()(_Range&& __r, _Out __out,\n+\t\t range_difference_t<_Range> __n, _Gen&& __g) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t       std::move(__out), __n,\n+\t\t       std::forward<_Gen>(__g));\n+      }\n+  };\n+\n+  inline constexpr __sample_fn sample{};\n+\n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n   struct __shuffle_fn\n   {\n@@ -3102,6 +3193,30 @@ namespace ranges\n \n   inline constexpr __max_fn max{};\n \n+  struct __clamp_fn\n+  {\n+    template<typename _Tp, typename _Proj = identity,\n+\t     indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp\n+\t       = ranges::less>\n+      constexpr const _Tp&\n+      operator()(const _Tp& __val, const _Tp& __lo, const _Tp& __hi,\n+\t\t _Comp __comp = {}, _Proj __proj = {}) const\n+      {\n+\t__glibcxx_assert(!(std::__invoke(__comp,\n+\t\t\t\t\t std::__invoke(__proj, __hi),\n+\t\t\t\t\t std::__invoke(__proj, __lo))));\n+\tauto&& __proj_val = std::__invoke(__proj, __val);\n+\tif (std::__invoke(__comp, __proj_val, std::__invoke(__proj, __lo)))\n+\t  return __lo;\n+\telse if (std::__invoke(__comp, std::__invoke(__proj, __hi), __proj_val))\n+\t  return __hi;\n+\telse\n+\t  return __val;\n+      }\n+  };\n+\n+  inline constexpr __clamp_fn clamp{};\n+\n   template<typename _Tp>\n     struct minmax_result\n     {"}, {"sha": "1964bb6035490cba8a3602fc91f69c133ea5b70d", "filename": "libstdc++-v3/testsuite/25_algorithms/clamp/constrained.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fclamp%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fclamp%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fclamp%2Fconstrained.cc?ref=f3169941996c76ecbfae9c37709d2b57652be555", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::test_range;\n+using __gnu_test::input_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test01()\n+{\n+  VERIFY( ranges::clamp(1, 2, 4) == 2 );\n+  VERIFY( ranges::clamp(3, 2, 4) == 3 );\n+  VERIFY( ranges::clamp(5, 2, 4) == 4 );\n+\n+  VERIFY( ranges::clamp(1, 4, 2, ranges::greater{}) == 2 );\n+  VERIFY( ranges::clamp(3, 4, 2, ranges::greater{}) == 3 );\n+  VERIFY( ranges::clamp(5, 4, 2, ranges::greater{}) == 4 );\n+\n+  VERIFY( ranges::clamp(1, 2, 4, ranges::greater{}, std::negate<>{}) == 2 );\n+  VERIFY( ranges::clamp(3, 2, 4, ranges::greater{}, std::negate<>{}) == 3 );\n+  VERIFY( ranges::clamp(5, 2, 4, ranges::greater{}, std::negate<>{}) == 4 );\n+\n+  static_assert(ranges::clamp(X{1,2}, X{1,3}, X{1,4}, {}, &X::i).j == 2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "31ca0a7046a01dfb2958e747e6ebdb58e07173d4", "filename": "libstdc++-v3/testsuite/25_algorithms/for_each/constrained.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffor_each%2Fconstrained.cc?ref=f3169941996c76ecbfae9c37709d2b57652be555", "patch": "@@ -26,6 +26,7 @@ using __gnu_test::test_container;\n using __gnu_test::test_range;\n using __gnu_test::input_iterator_wrapper;\n using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n \n namespace ranges = std::ranges;\n \n@@ -75,9 +76,52 @@ test02()\n   static_assert(f() == 6);\n }\n \n+template<template<typename> typename wrapper>\n+void\n+test03()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, wrapper> rx(x);\n+  int s = 0;\n+  auto func = [&s](int i){ s += i; };\n+  auto [i,f] = ranges::for_each_n(rx.begin(), 3, func);\n+  VERIFY( i.ptr = x+3 );\n+  VERIFY( s == 1+2+3 );\n+  f(1);\n+  VERIFY( s == 1+2+3+1 );\n+\n+  s = 0;\n+  rx.bounds.first = x;\n+  auto [j,g] = ranges::for_each_n(rx.begin(), -1, func);\n+  VERIFY( j.ptr == x );\n+  VERIFY( s == 0 );\n+  g(1);\n+  VERIFY( s == 1 );\n+\n+  s = 0;\n+  rx.bounds.first = x;\n+  auto [k,h] = ranges::for_each_n(rx.begin(), 5, func, std::negate<>{});\n+  VERIFY( k.ptr == x+5 );\n+  VERIFY( s == -(1+2+3+4+5) );\n+  h(-6);\n+  VERIFY( s == -(1+2+3+4+5+6) );\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  int x[] = {1,2,3,4,5};\n+  int p = 1;\n+  ranges::for_each_n(x+1, 4, [&p](int i){ p*=i; }, [](int i){ return i+1; });\n+  return p == 3*4*5*6;\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03<input_iterator_wrapper>();\n+  test03<random_access_iterator_wrapper>();\n+  static_assert(test04());\n }"}, {"sha": "7ed57e8aefcd6bab18d4b16adada2db0195020c4", "filename": "libstdc++-v3/testsuite/25_algorithms/sample/constrained.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsample%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3169941996c76ecbfae9c37709d2b57652be555/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsample%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsample%2Fconstrained.cc?ref=f3169941996c76ecbfae9c37709d2b57652be555", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-cstdint \"\" }\n+\n+#include <algorithm>\n+#include <random>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+\n+std::mt19937 rng;\n+\n+template<template<typename> typename in_wrapper,\n+\t template<typename> typename out_wrapper>\n+void\n+test01()\n+{\n+  const int x[] = {1,2,3,4,5,6,7,8,9,10};\n+  test_range<const int, in_wrapper> rx(x);\n+  int y[10];\n+  test_range<int, out_wrapper> ry(y);\n+  auto out = ranges::sample(rx.begin(), rx.end(), ry.begin(), 20, rng);\n+  VERIFY( out.ptr == y+10 );\n+  VERIFY( ranges::equal(x, y) );\n+\n+  for (int i = 0; i < 100; i++)\n+    {\n+      int z[5] = {0};\n+      test_range<int, out_wrapper> rz(z);\n+      rx.bounds.first = x;\n+      auto out = ranges::sample(rx, rz.begin(), 5, rng);\n+      VERIFY( out.ptr == z+5 );\n+      ranges::sort(z);\n+      VERIFY( ranges::adjacent_find(z) == out.ptr );\n+      VERIFY( ranges::includes(x, z) );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01<forward_iterator_wrapper, output_iterator_wrapper>();\n+  test01<input_iterator_wrapper, random_access_iterator_wrapper>();\n+}"}]}