{"sha": "81ee8129ce04a1de9ac27b841ae33ba50244b17f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFlZTgxMjljZTA0YTFkZTlhYzI3Yjg0MWFlMzNiYTUwMjQ0YjE3Zg==", "commit": {"author": {"name": "Scott Bambrough", "email": "scottb@netwinder.org", "date": "2000-02-09T20:53:35Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-09T20:53:35Z"}, "message": "In PIC mode, make sure that a constant source address is legitimate.\n\nFrom-SVN: r31873", "tree": {"sha": "180df80215f9e83fa56d47930fb2d307e2bfb0bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/180df80215f9e83fa56d47930fb2d307e2bfb0bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ee8129ce04a1de9ac27b841ae33ba50244b17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ee8129ce04a1de9ac27b841ae33ba50244b17f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ee8129ce04a1de9ac27b841ae33ba50244b17f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ee8129ce04a1de9ac27b841ae33ba50244b17f/comments", "author": null, "committer": null, "parents": [{"sha": "d53cc71518928c16354316fbd632e0a8679f6632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d53cc71518928c16354316fbd632e0a8679f6632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d53cc71518928c16354316fbd632e0a8679f6632"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "8c9a4a9cca8572f6a86040688e0eb4230068b833", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee8129ce04a1de9ac27b841ae33ba50244b17f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee8129ce04a1de9ac27b841ae33ba50244b17f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81ee8129ce04a1de9ac27b841ae33ba50244b17f", "patch": "@@ -1,3 +1,8 @@\n+2000-02-09  Scott Bambrough  <scottb@netwinder.org>\n+\n+        * config/arm/arm.md (movsi): In PIC mode, make sure that a\n+        constant source address is legitimate.\n+\n 2000-02-09  Philip Blundell  <pb@futuretv.com>\n \n         * config/arm/arm.c (legitimize_pic_address): Handle LABEL_REF"}, {"sha": "b1bd09e9ae0a579a33436f8d97d32bb31d15451f", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee8129ce04a1de9ac27b841ae33ba50244b17f/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee8129ce04a1de9ac27b841ae33ba50244b17f/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=81ee8129ce04a1de9ac27b841ae33ba50244b17f", "patch": "@@ -2935,7 +2935,10 @@\n \t\t\t   : preserve_subexpressions_p ()));\n       DONE;\n     }\n-  if (CONSTANT_P (operands[1]) && flag_pic)\n+  if (flag_pic\n+      && (CONSTANT_P (operands[1])\n+\t || symbol_mentioned_p (operands[1])\n+\t || label_mentioned_p (operands[1])))\n     operands[1] = legitimize_pic_address (operands[1], SImode,\n \t\t\t\t\t  ((reload_in_progress\n \t\t\t\t\t    || reload_completed)\n@@ -4505,18 +4508,33 @@\n (define_expand \"call\"\n   [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n \t            (match_operand 1 \"general_operand\" \"\"))\n+ \t      (use (match_operand 2 \"\" \"\"))\n \t      (clobber (reg:SI 14))])]\n   \"\"\n   \"\n   {\n-    if (TARGET_LONG_CALLS && GET_CODE (XEXP (operands[0], 0)) != REG)\n-      XEXP (operands[0], 0) = force_reg (Pmode, XEXP (operands[0], 0));\n+    rtx callee = XEXP (operands[0], 0);\n+    \n+    /* Decide if we need to generate an indirect call by loading the 32 bit\n+       address of the callee into a register and then jumping to the contents\n+       of that register.  operands[2] contains the long_call / short_call\n+       attribute.  The third parameter to arm_is_longcall_p tells it that it\n+       is being passed a (MEM) and not a SYMREF().  */\n+     \n+    /* In an untyped call, we can get NULL for operand 2.  */\n+    if (operands[2] == NULL_RTX)\n+      operands[2] = const0_rtx;\n+      \n+    if (GET_CODE (callee) != REG\n+       && arm_is_longcall_p (operands[0], INTVAL (operands[2]), 0))\n+      XEXP (operands[0], 0) = force_reg (Pmode, callee);\n   }\"\n )\n \n (define_insn \"*call_reg\"\n   [(call (mem:SI (match_operand:SI 0 \"s_register_operand\" \"r\"))\n          (match_operand 1 \"\" \"g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n\"))\n    (clobber (reg:SI 14))]\n   \"\"\n   \"*\n@@ -4529,6 +4547,7 @@\n (define_insn \"*call_mem\"\n   [(call (mem:SI (match_operand:SI 0 \"memory_operand\" \"m\"))\n \t (match_operand 1 \"general_operand\" \"g\"))\n+   (use (match_operand:SI 2 \"\" \"\"))\n    (clobber (reg:SI 14))]\n   \"\"\n   \"*\n@@ -4541,19 +4560,29 @@\n   [(parallel [(set (match_operand 0 \"\" \"=rf\")\n \t           (call (match_operand 1 \"memory_operand\" \"m\")\n \t\t         (match_operand 2 \"general_operand\" \"g\")))\n+\t      (use (match_operand:SI 3 \"\" \"\"))\n \t      (clobber (reg:SI 14))])]\n   \"\"\n   \"\n   {\n-    if (TARGET_LONG_CALLS && GET_CODE (XEXP (operands[1], 0)) != REG)\n-      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));\n+    rtx callee = XEXP (operands[1], 0);\n+    \n+    /* In an untyped call, we can get NULL for operand 2.  */\n+    if (operands[3] == 0)\n+      operands[3] = const0_rtx;\n+      \n+    /* See the comment in define_expand \\\"call\\\".  */\n+    if (GET_CODE (callee) != REG\n+\t&& arm_is_longcall_p (operands[1], INTVAL (operands[3]), 0))\n+       XEXP (operands[1], 0) = force_reg (Pmode, callee);\n   }\"\n )\n \n (define_insn \"*call_value_reg\"\n   [(set (match_operand 0 \"\" \"=rf\")\n         (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n \t      (match_operand 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI 14))]\n   \"\"\n   \"*\n@@ -4566,6 +4595,7 @@\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand 1 \"memory_operand\" \"m\"))\n \t(match_operand 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI 14))]\n   \"! CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\"\n   \"*\n@@ -4580,8 +4610,10 @@\n (define_insn \"*call_symbol\"\n   [(call (mem:SI (match_operand:SI 0 \"\" \"X\"))\n \t (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI 14))]\n-  \"! TARGET_LONG_CALLS && GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"! arm_is_longcall_p (operands[0], INTVAL (operands[2]), 1)\n+   && GET_CODE (operands[0]) == SYMBOL_REF\"\n   \"*\n   {\n     return NEED_PLT_RELOC ? \\\"bl%?\\\\t%a0(PLT)\\\" : \\\"bl%?\\\\t%a0\\\";\n@@ -4592,8 +4624,10 @@\n   [(set (match_operand 0 \"s_register_operand\" \"=rf\")\n \t(call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n \t(match_operand:SI 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI 14))]\n-  \"! TARGET_LONG_CALLS && GET_CODE(operands[1]) == SYMBOL_REF\"\n+  \"! arm_is_longcall_p (operands[1], INTVAL (operands[3]), 1)\n+   && GET_CODE (operands[1]) == SYMBOL_REF\"\n   \"*\n   {\n     return NEED_PLT_RELOC ? \\\"bl%?\\\\t%a1(PLT)\\\" : \\\"bl%?\\\\t%a1\\\";"}]}