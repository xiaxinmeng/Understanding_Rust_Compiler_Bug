{"sha": "337c80a6bcf248f021e9731bba7543fb5bfb3553", "node_id": "C_kwDOANBUbNoAKDMzN2M4MGE2YmNmMjQ4ZjAyMWU5NzMxYmJhNzU0M2ZiNWJmYjM1NTM", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2022-04-01T20:06:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-18T08:41:05Z"}, "message": "[Ada] Ada2022: AI12-0143 Index attribute for entry families\n\ngcc/ada/\n\n\t* snames.ads-tmpl (Name_Index): New attribute name.\n\t(Attribute_Id): Adding Attribute_Index as regular attribute.\n\t* sem_attr.adb (Attribute_22): Adding Attribute_Index as Ada\n\t2022 attribute.\n\t(Analyze_Index_Attribute): Check that 'Index appears in a\n\tpre-/postcondition aspect or pragma associated with an entry\n\tfamily.\n\t(Analyze_Attribute): Adding semantic analysis for 'Index.\n\t(Eval_Attribute): Register 'Index as can never be folded.\n\t(Resolve_Attribute): Resolve attribute 'Index.\n\t* sem_ch9.adb (Check_Wrong_Attribute_In_Postconditions): New\n\tsubprogram.\n\t(Analyze_Requeue): Check that the requeue target shall not have\n\tan applicable specific or class-wide postcondition which\n\tincludes an Index attribute reference.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Transform\n\tattribute Index into a renaming of the second formal of the\n\twrapper built for an entry family that has contract cases.\n\t* einfo.ads (Is_Entry_Wrapper): Complete documentation.", "tree": {"sha": "a6ea99d6150f44a042d63fdc207873b9f384599c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6ea99d6150f44a042d63fdc207873b9f384599c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/337c80a6bcf248f021e9731bba7543fb5bfb3553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337c80a6bcf248f021e9731bba7543fb5bfb3553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337c80a6bcf248f021e9731bba7543fb5bfb3553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337c80a6bcf248f021e9731bba7543fb5bfb3553/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c63f73051458b24298eb82ddd109bbc6a453464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c63f73051458b24298eb82ddd109bbc6a453464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c63f73051458b24298eb82ddd109bbc6a453464"}], "stats": {"total": 345, "additions": 344, "deletions": 1}, "files": [{"sha": "3f990c3b8312368a6034489a32595692dd159fe4", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=337c80a6bcf248f021e9731bba7543fb5bfb3553", "patch": "@@ -2599,7 +2599,8 @@ package Einfo is\n --       test for the need to replace references in Exp_Ch2.\n \n --    Is_Entry_Wrapper\n---       Defined on wrappers created for entries that have precondition aspects\n+--       Defined on wrappers created for entries that have precondition or\n+--       postcondition aspects.\n \n --    Is_Enumeration_Type (synthesized)\n --       Defined in all entities, true for enumeration types and subtypes"}, {"sha": "19aea23771ad83aa4ffd0846ef80fcc555c1a410", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=337c80a6bcf248f021e9731bba7543fb5bfb3553", "patch": "@@ -3995,6 +3995,24 @@ package body Exp_Attr is\n       when Attribute_Img =>\n          Exp_Imgv.Expand_Image_Attribute (N);\n \n+      -----------\n+      -- Index --\n+      -----------\n+\n+      --  Transforms 'Index attribute into a reference to the second formal of\n+      --  the wrapper built for an entry family that has contract cases (see\n+      --  Exp_Ch9.Build_Contract_Wrapper).\n+\n+      when Attribute_Index => Index : declare\n+         Entry_Id  : constant Entity_Id := Entity (Pref);\n+         Entry_Idx : constant Entity_Id :=\n+                       Next_Entity\n+                         (First_Entity (Contract_Wrapper (Entry_Id)));\n+      begin\n+         Rewrite (N, New_Occurrence_Of (Entry_Idx, Loc));\n+         Analyze_And_Resolve (N, Typ);\n+      end Index;\n+\n       -----------------\n       -- Initialized --\n       -----------------"}, {"sha": "4b00ea8f07d73c6238cd4292449002b4d914ca6c", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=337c80a6bcf248f021e9731bba7543fb5bfb3553", "patch": "@@ -176,6 +176,7 @@ package body Sem_Attr is\n    Attribute_22 : constant Attribute_Class_Array := Attribute_Class_Array'(\n       Attribute_Enum_Rep                     |\n       Attribute_Enum_Val                     => True,\n+      Attribute_Index                        => True,\n       Attribute_Preelaborable_Initialization => True,\n       others                                 => False);\n \n@@ -276,6 +277,15 @@ package body Sem_Attr is\n       --  sets the type of the attribute to the one specified by Str_Typ (e.g.\n       --  Standard_String for 'Image and Standard_Wide_String for 'Wide_Image).\n \n+      procedure Analyze_Index_Attribute\n+        (Legal   : out Boolean;\n+         Spec_Id : out Entity_Id);\n+      --  Processing for attribute 'Index. It checks that the attribute appears\n+      --  in a pre/postcondition-like aspect or pragma associated with an entry\n+      --  family. Flag Legal is set when the above criteria are met. Spec_Id\n+      --  denotes the entity of the wrapper of the entry family or Empty if\n+      --  the attribute is illegal.\n+\n       procedure Bad_Attribute_For_Predicate;\n       --  Output error message for use of a predicate (First, Last, Range) not\n       --  allowed with a type that has predicates. If the type is a generic\n@@ -1585,6 +1595,178 @@ package body Sem_Attr is\n          end if;\n       end Analyze_Image_Attribute;\n \n+      -----------------------------\n+      -- Analyze_Index_Attribute --\n+      -----------------------------\n+\n+      procedure Analyze_Index_Attribute\n+        (Legal   : out Boolean;\n+         Spec_Id : out Entity_Id)\n+      is\n+         procedure Check_Placement_In_Check (Prag : Node_Id);\n+         --  Verify that the attribute appears within pragma Check that mimics\n+         --  a postcondition.\n+\n+         procedure Placement_Error;\n+         pragma No_Return (Placement_Error);\n+         --  Emit a general error when the attributes does not appear in a\n+         --  precondition or postcondition aspect or pragma, and then raises\n+         --  Bad_Attribute to avoid any further semantic processing.\n+\n+         ------------------------------\n+         -- Check_Placement_In_Check --\n+         ------------------------------\n+\n+         procedure Check_Placement_In_Check (Prag : Node_Id) is\n+            Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+            Nam  : constant Name_Id := Chars (Get_Pragma_Arg (First (Args)));\n+\n+         begin\n+            --  The \"Name\" argument of pragma Check denotes a precondition or\n+            --  postcondition.\n+\n+            if Nam in Name_Post\n+                    | Name_Postcondition\n+                    | Name_Pre\n+                    | Name_Precondition\n+                    | Name_Refined_Post\n+            then\n+               null;\n+\n+            --  Otherwise the placement of the attribute is illegal\n+\n+            else\n+               Placement_Error;\n+            end if;\n+         end Check_Placement_In_Check;\n+\n+         ---------------------\n+         -- Placement_Error --\n+         ---------------------\n+\n+         procedure Placement_Error is\n+         begin\n+            Error_Attr\n+              (\"attribute % can only appear in pre- or postcondition\", P);\n+         end Placement_Error;\n+\n+         --  Local variables\n+\n+         Prag      : Node_Id;\n+         Prag_Nam  : Name_Id;\n+         Subp_Decl : Node_Id;\n+\n+      --  Start of processing for Analyze_Index_Attribute\n+\n+      begin\n+         --  Assume that the attribute is illegal\n+\n+         Legal   := False;\n+         Spec_Id := Empty;\n+\n+         --  Skip processing during preanalysis of class-wide preconditions and\n+         --  postconditions since at this stage the expression is not installed\n+         --  yet on its definite context.\n+\n+         if Inside_Class_Condition_Preanalysis then\n+            Legal   := True;\n+            Spec_Id := Current_Scope;\n+            return;\n+         end if;\n+\n+         --  Traverse the parent chain to find the aspect or pragma where the\n+         --  attribute resides.\n+\n+         Prag := N;\n+         while Present (Prag) loop\n+            if Nkind (Prag) in N_Aspect_Specification | N_Pragma then\n+               exit;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Prag) then\n+               exit;\n+            end if;\n+\n+            Prag := Parent (Prag);\n+         end loop;\n+\n+         --  The attribute is allowed to appear only in precondition and\n+         --  postcondition-like aspects or pragmas.\n+\n+         if Nkind (Prag) in N_Aspect_Specification | N_Pragma then\n+            if Nkind (Prag) = N_Aspect_Specification then\n+               Prag_Nam := Chars (Identifier (Prag));\n+            else\n+               Prag_Nam := Pragma_Name (Prag);\n+            end if;\n+\n+            if Prag_Nam = Name_Check then\n+               Check_Placement_In_Check (Prag);\n+\n+            elsif Prag_Nam in Name_Post\n+                            | Name_Postcondition\n+                            | Name_Pre\n+                            | Name_Precondition\n+                            | Name_Refined_Post\n+            then\n+               null;\n+\n+            else\n+               Placement_Error;\n+               return;\n+            end if;\n+\n+         --  Otherwise the placement of the attribute is illegal\n+\n+         else\n+            Placement_Error;\n+            return;\n+         end if;\n+\n+         --  Find the related subprogram subject to the aspect or pragma\n+\n+         if Nkind (Prag) = N_Aspect_Specification then\n+            Subp_Decl := Parent (Prag);\n+         else\n+            Subp_Decl := Find_Related_Declaration_Or_Body (Prag);\n+         end if;\n+\n+         --  The aspect or pragma where the attribute resides should be\n+         --  associated with a subprogram declaration or a body since the\n+         --  analysis of pre-/postconditions of entry and entry families is\n+         --  performed in their wrapper subprogram. If this is not the case,\n+         --  then the aspect or pragma is illegal and no further analysis is\n+         --  required.\n+\n+         if Nkind (Subp_Decl) not in N_Subprogram_Body\n+                                   | N_Subprogram_Declaration\n+         then\n+            return;\n+         end if;\n+\n+         Spec_Id := Unique_Defining_Entity (Subp_Decl);\n+\n+         --  If we get here and Spec_Id denotes the entity of the entry wrapper\n+         --  (or the postcondition procedure of the entry wrapper) then the\n+         --  attribute is legal.\n+\n+         if Is_Entry_Wrapper (Spec_Id) then\n+            Legal := True;\n+\n+         elsif Chars (Spec_Id) = Name_uPostconditions\n+           and then Is_Entry_Wrapper (Scope (Spec_Id))\n+         then\n+            Spec_Id := Scope (Spec_Id);\n+            Legal   := True;\n+\n+         --  Otherwise the attribute is illegal and we return Empty\n+\n+         else\n+            Spec_Id := Empty;\n+         end if;\n+      end Analyze_Index_Attribute;\n+\n       ---------------------------------\n       -- Bad_Attribute_For_Predicate --\n       ---------------------------------\n@@ -4279,6 +4461,55 @@ package body Sem_Attr is\n          Check_Object_Reference (E1);\n          Set_Etype (N, Standard_Boolean);\n \n+      -----------\n+      -- Index --\n+      -----------\n+\n+      when Attribute_Index => Index : declare\n+         Ent     : Entity_Id;\n+         Legal   : Boolean;\n+         Spec_Id : Entity_Id;\n+\n+      begin\n+         Check_E0;\n+         Analyze_Index_Attribute (Legal, Spec_Id);\n+\n+         if not Legal or else No (Spec_Id) then\n+            Error_Attr (\"attribute % must apply to entry family\", P);\n+            return;\n+         end if;\n+\n+         --  Legality checks\n+\n+         if Nkind (P) in N_Identifier | N_Expanded_Name then\n+            Ent := Entity (P);\n+\n+            if Ekind (Ent) /= E_Entry_Family then\n+               Error_Attr\n+                 (\"attribute % must apply to entry family\", P);\n+\n+            --  Analysis of pre/postconditions of an entry [family] occurs when\n+            --  the conditions are relocated to the contract wrapper procedure\n+            --  (see subprogram Build_Contract_Wrapper).\n+\n+            elsif Contract_Wrapper (Ent) /= Spec_Id then\n+               Error_Attr\n+                 (\"attribute % must apply to current entry family\", P);\n+            end if;\n+\n+         elsif Nkind (P) in N_Indexed_Component\n+                          | N_Selected_Component\n+         then\n+            Error_Attr\n+              (\"attribute % must apply to current entry family\", P);\n+\n+         else\n+            Error_Attr (\"invalid entry family name\", N);\n+         end if;\n+\n+         Set_Etype (N, Entry_Index_Type (Ent));\n+      end Index;\n+\n       -----------------------\n       -- Has_Tagged_Values --\n       -----------------------\n@@ -10595,6 +10826,7 @@ package body Sem_Attr is\n          | Attribute_First_Bit\n          | Attribute_Img\n          | Attribute_Input\n+         | Attribute_Index\n          | Attribute_Initialized\n          | Attribute_Last_Bit\n          | Attribute_Library_Level\n@@ -12087,6 +12319,24 @@ package body Sem_Attr is\n          when Attribute_Enabled =>\n             null;\n \n+         -----------\n+         -- Index --\n+         -----------\n+\n+         when Attribute_Index =>\n+            if Nkind (P) = N_Indexed_Component\n+              and then Is_Entity_Name (Prefix (P))\n+            then\n+               declare\n+                  Indx : constant Node_Id   := First (Expressions (P));\n+                  Fam  : constant Entity_Id := Entity (Prefix (P));\n+\n+               begin\n+                  Resolve (Indx, Entry_Index_Type (Fam));\n+                  Apply_Scalar_Range_Check (Indx, Entry_Index_Type (Fam));\n+               end;\n+            end if;\n+\n          ----------------\n          -- Loop_Entry --\n          ----------------"}, {"sha": "2f8f01bcc91850bc97a672099d4219964844e134", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=337c80a6bcf248f021e9731bba7543fb5bfb3553", "patch": "@@ -2293,6 +2293,64 @@ package body Sem_Ch9 is\n    ---------------------\n \n    procedure Analyze_Requeue (N : Node_Id) is\n+\n+      procedure Check_Wrong_Attribute_In_Postconditions\n+        (Entry_Id   : Entity_Id;\n+         Error_Node : Node_Id);\n+      --  Check that the requeue target Entry_Id does not have an specific or\n+      --  class-wide postcondition that references an Old or Index attribute.\n+\n+      ---------------------------------------------\n+      -- Check_Wrong_Attribute_In_Postconditions --\n+      ---------------------------------------------\n+\n+      procedure Check_Wrong_Attribute_In_Postconditions\n+        (Entry_Id   : Entity_Id;\n+         Error_Node : Node_Id)\n+      is\n+         function Check_Node (N : Node_Id) return Traverse_Result;\n+         --  Check that N is not a reference to attribute Index or Old; report\n+         --  an error otherwise.\n+\n+         ----------------\n+         -- Check_Node --\n+         ----------------\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Attribute_Reference\n+              and then Attribute_Name (N) in Name_Index\n+                                           | Name_Old\n+            then\n+               Error_Msg_Name_1 := Attribute_Name (N);\n+               Error_Msg_N\n+                 (\"target of requeue must not have references to attribute % \"\n+                  & \"in postcondition\",\n+                  Error_Node);\n+            end if;\n+\n+            return OK;\n+         end Check_Node;\n+\n+         procedure Check_Attr_Refs is new Traverse_Proc (Check_Node);\n+\n+         --  Local variables\n+\n+         Prag : Node_Id;\n+      begin\n+         Prag := Pre_Post_Conditions (Contract (Entry_Id));\n+\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Postcondition then\n+               Check_Attr_Refs (First (Pragma_Argument_Associations (Prag)));\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end Check_Wrong_Attribute_In_Postconditions;\n+\n+      --  Local variables\n+\n       Count       : Natural := 0;\n       Entry_Name  : Node_Id := Name (N);\n       Entry_Id    : Entity_Id;\n@@ -2305,6 +2363,8 @@ package body Sem_Ch9 is\n       Outer_Ent   : Entity_Id;\n       Synch_Type  : Entity_Id := Empty;\n \n+   --  Start of processing for Analyze_Requeue\n+\n    begin\n       --  Preserve relevant elaboration-related attributes of the context which\n       --  are no longer available or very expensive to recompute once analysis,\n@@ -2588,6 +2648,18 @@ package body Sem_Ch9 is\n            (\"target protected object of requeue must be a variable\", N);\n       end if;\n \n+      --  Ada 2022 (AI12-0143): The requeue target shall not have an\n+      --  applicable specific or class-wide postcondition which includes\n+      --  an Old or Index attribute reference.\n+\n+      if Ekind (Entry_Id) = E_Entry_Family\n+        and then Present (Contract (Entry_Id))\n+      then\n+         Check_Wrong_Attribute_In_Postconditions\n+           (Entry_Id   => Entry_Id,\n+            Error_Node => Entry_Name);\n+      end if;\n+\n       --  A requeue statement is treated as a call for purposes of ABE checks\n       --  and diagnostics. Annotate the tree by creating a call marker in case\n       --  the requeue statement is transformed by expansion."}, {"sha": "73e730446e402dd32295493c977bb4937548fbbf", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337c80a6bcf248f021e9731bba7543fb5bfb3553/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=337c80a6bcf248f021e9731bba7543fb5bfb3553", "patch": "@@ -958,6 +958,7 @@ package Snames is\n    Name_Has_Tagged_Values              : constant Name_Id := N + $; -- GNAT\n    Name_Identity                       : constant Name_Id := N + $;\n    Name_Implicit_Dereference           : constant Name_Id := N + $; -- GNAT\n+   Name_Index                          : constant Name_Id := N + $; -- Ada 22\n    Name_Initialized                    : constant Name_Id := N + $; -- GNAT\n    Name_Integer_Value                  : constant Name_Id := N + $; -- GNAT\n    Name_Invalid_Value                  : constant Name_Id := N + $; -- GNAT\n@@ -1480,6 +1481,7 @@ package Snames is\n       Attribute_Has_Tagged_Values,\n       Attribute_Identity,\n       Attribute_Implicit_Dereference,\n+      Attribute_Index,\n       Attribute_Initialized,\n       Attribute_Integer_Value,\n       Attribute_Invalid_Value,"}]}