{"sha": "2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVmNmNlMDZkMzM1ODEwZGQ4OTNjMmM2OTM1YmJmYzg0ZTg4ZGRhNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-03-21T21:38:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-03-21T21:38:56Z"}, "message": "expr.h (prepare_operand): Move to...\n\ngcc/\n2011-03-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\n\t* expr.h (prepare_operand): Move to...\n\t* optabs.h (prepare_operand): ...here and change the insn code\n\tparameter from \"int\" to \"enum insn_code\".\n\t(insn_operand_matches): Declare.\n\t* expr.c (init_expr_target): Use insn_operand_matches.\n\t(compress_float_constant): Likewise.\n\t* function.c (safe_insn_predicate, assign_parm_setup_reg): Likewise.\n\t* optabs.c (can_compare_p, prepare_cmp_insn): Likewise.\n\t(emit_cmp_and_jump_insn_1, gen_add2_insn, gen_add3_insn): Likewise.\n\t(have_add2_insn, gen_sub2_insn, gen_sub3_insn, have_sub2_insn): Likewise.\n\t(gen_cond_trap): Likewise.\n\t(prepare_operand): Likewise.  Change icode to an insn_code.\n\t(insn_operand_matches): New function.\n\t* reload.c (find_reloads_address_1): Use insn_operand_matches.\n\t* reload1.c (gen_reload): Likewise.\n\t* targhooks.c (default_secondary_reload): Likewise.\n\nFrom-SVN: r171270", "tree": {"sha": "0538178eac12adad63a9e0919a608a535b270ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0538178eac12adad63a9e0919a608a535b270ab9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/comments", "author": null, "committer": null, "parents": [{"sha": "9a96da32eb7370b930a170579725de2f2ee2f4e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a96da32eb7370b930a170579725de2f2ee2f4e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a96da32eb7370b930a170579725de2f2ee2f4e2"}], "stats": {"total": 172, "additions": 85, "deletions": 87}, "files": [{"sha": "4c0e0ca107e16659ba37ad2bef6497f0c9850631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -1,3 +1,22 @@\n+2011-03-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* expr.h (prepare_operand): Move to...\n+\t* optabs.h (prepare_operand): ...here and change the insn code\n+\tparameter from \"int\" to \"enum insn_code\".\n+\t(insn_operand_matches): Declare.\n+\t* expr.c (init_expr_target): Use insn_operand_matches.\n+\t(compress_float_constant): Likewise.\n+\t* function.c (safe_insn_predicate, assign_parm_setup_reg): Likewise.\n+\t* optabs.c (can_compare_p, prepare_cmp_insn): Likewise.\n+\t(emit_cmp_and_jump_insn_1, gen_add2_insn, gen_add3_insn): Likewise.\n+\t(have_add2_insn, gen_sub2_insn, gen_sub3_insn, have_sub2_insn): Likewise.\n+\t(gen_cond_trap): Likewise.\n+\t(prepare_operand): Likewise.  Change icode to an insn_code.\n+\t(insn_operand_matches): New function.\n+\t* reload.c (find_reloads_address_1): Use insn_operand_matches.\n+\t* reload1.c (gen_reload): Likewise.\n+\t* targhooks.c (default_secondary_reload): Likewise.\n+\n 2011-03-21  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.md (unspec): New define_c_enum."}, {"sha": "64ddde7a54f0dad812bfcc1ecfdb40c18b72cfdb", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -286,7 +286,7 @@ init_expr_target (void)\n \n \t  PUT_MODE (mem, srcmode);\n \n-\t  if ((*insn_data[ic].operand[1].predicate) (mem, srcmode))\n+\t  if (insn_operand_matches (ic, 1, mem))\n \t    float_extend_from_mem[mode][srcmode] = true;\n \t}\n     }\n@@ -3446,7 +3446,7 @@ compress_float_constant (rtx x, rtx y)\n \t{\n \t  /* Skip if the target needs extra instructions to perform\n \t     the extension.  */\n-\t  if (! (*insn_data[ic].operand[1].predicate) (trunc_y, srcmode))\n+\t  if (!insn_operand_matches (ic, 1, trunc_y))\n \t    continue;\n \t  /* This is valid, but may not be cheaper than the original. */\n \t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET, speed);"}, {"sha": "f770a35b6dec681823bcf2e42fd880cd211feb5e", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -173,9 +173,6 @@ extern rtx expand_simple_unop (enum machine_mode, enum rtx_code, rtx, rtx,\n    perform the operation described by CODE and MODE.  */\n extern int have_insn_for (enum rtx_code, enum machine_mode);\n \n-extern rtx prepare_operand (int, rtx, int, enum machine_mode, enum machine_mode,\n-\t\t\t    int);\n-\n /* Emit code to make a call to a constant function or a library call.  */\n extern void emit_libcall_block (rtx, rtx, rtx, rtx);\n "}, {"sha": "a1ea482acad636a6dbc4ab96e565d33772be141f", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -1493,16 +1493,7 @@ instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n static int\n safe_insn_predicate (int code, int operand, rtx x)\n {\n-  const struct insn_operand_data *op_data;\n-\n-  if (code < 0)\n-    return true;\n-\n-  op_data = &insn_data[code].operand[operand];\n-  if (op_data->predicate == NULL)\n-    return true;\n-\n-  return op_data->predicate (x, op_data->mode);\n+  return code < 0 || insn_operand_matches ((enum insn_code) code, operand, x);\n }\n \n /* A subroutine of instantiate_virtual_regs.  Instantiate any virtual\n@@ -3013,8 +3004,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n       op0 = parmreg;\n       op1 = validated_mem;\n       if (icode != CODE_FOR_nothing\n-\t  && insn_data[icode].operand[0].predicate (op0, promoted_nominal_mode)\n-\t  && insn_data[icode].operand[1].predicate (op1, data->passed_mode))\n+\t  && insn_operand_matches (icode, 0, op0)\n+\t  && insn_operand_matches (icode, 1, op1))\n \t{\n \t  enum rtx_code code = unsignedp ? ZERO_EXTEND : SIGN_EXTEND;\n \t  rtx insn, insns;"}, {"sha": "a874c427e43109887545ace43b8d3382c1a82562", "filename": "gcc/optabs.c", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -3943,15 +3943,15 @@ can_compare_p (enum rtx_code code, enum machine_mode mode,\n   test = gen_rtx_fmt_ee (code, mode, const0_rtx, const0_rtx);\n   do\n     {\n-      int icode;\n+      enum insn_code icode;\n \n       if (purpose == ccp_jump\n           && (icode = optab_handler (cbranch_optab, mode)) != CODE_FOR_nothing\n-          && insn_data[icode].operand[0].predicate (test, mode))\n+          && insn_operand_matches (icode, 0, test))\n         return 1;\n       if (purpose == ccp_store_flag\n           && (icode = optab_handler (cstore_optab, mode)) != CODE_FOR_nothing\n-          && insn_data[icode].operand[1].predicate (test, mode))\n+          && insn_operand_matches (icode, 1, test))\n         return 1;\n       if (purpose == ccp_cmov\n \t  && optab_handler (cmov_optab, mode) != CODE_FOR_nothing)\n@@ -4112,16 +4112,14 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n       enum insn_code icode;\n       icode = optab_handler (cbranch_optab, cmp_mode);\n       if (icode != CODE_FOR_nothing\n-\t  && insn_data[icode].operand[0].predicate (test, VOIDmode))\n+\t  && insn_operand_matches (icode, 0, test))\n \t{\n \t  rtx last = get_last_insn ();\n \t  rtx op0 = prepare_operand (icode, x, 1, mode, cmp_mode, unsignedp);\n \t  rtx op1 = prepare_operand (icode, y, 2, mode, cmp_mode, unsignedp);\n \t  if (op0 && op1\n-\t      && insn_data[icode].operand[1].predicate\n-\t\t (op0, insn_data[icode].operand[1].mode)\n-\t      && insn_data[icode].operand[2].predicate\n-\t\t (op1, insn_data[icode].operand[2].mode))\n+\t      && insn_operand_matches (icode, 1, op0)\n+\t      && insn_operand_matches (icode, 2, op1))\n \t    {\n \t      XEXP (test, 0) = op0;\n \t      XEXP (test, 1) = op1;\n@@ -4200,18 +4198,17 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n    that it is accepted by the operand predicate.  Return the new value.  */\n \n rtx\n-prepare_operand (int icode, rtx x, int opnum, enum machine_mode mode,\n+prepare_operand (enum insn_code icode, rtx x, int opnum, enum machine_mode mode,\n \t\t enum machine_mode wider_mode, int unsignedp)\n {\n   if (mode != wider_mode)\n     x = convert_modes (wider_mode, mode, x, unsignedp);\n \n-  if (!insn_data[icode].operand[opnum].predicate\n-      (x, insn_data[icode].operand[opnum].mode))\n+  if (!insn_operand_matches (icode, opnum, x))\n     {\n       if (reload_completed)\n \treturn NULL_RTX;\n-      x = copy_to_mode_reg (insn_data[icode].operand[opnum].mode, x);\n+      x = copy_to_mode_reg (insn_data[(int) icode].operand[opnum].mode, x);\n     }\n \n   return x;\n@@ -4232,7 +4229,7 @@ emit_cmp_and_jump_insn_1 (rtx test, enum machine_mode mode, rtx label)\n   icode = optab_handler (cbranch_optab, optab_mode);\n \n   gcc_assert (icode != CODE_FOR_nothing);\n-  gcc_assert (insn_data[icode].operand[0].predicate (test, VOIDmode));\n+  gcc_assert (insn_operand_matches (icode, 0, test));\n   emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0), XEXP (test, 1), label));\n }\n \n@@ -4699,14 +4696,11 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n rtx\n gen_add2_insn (rtx x, rtx y)\n {\n-  int icode = (int) optab_handler (add_optab, GET_MODE (x));\n+  enum insn_code icode = optab_handler (add_optab, GET_MODE (x));\n \n-  gcc_assert (insn_data[icode].operand[0].predicate\n-\t      (x, insn_data[icode].operand[0].mode));\n-  gcc_assert (insn_data[icode].operand[1].predicate\n-\t      (x, insn_data[icode].operand[1].mode));\n-  gcc_assert (insn_data[icode].operand[2].predicate\n-\t      (y, insn_data[icode].operand[2].mode));\n+  gcc_assert (insn_operand_matches (icode, 0, x));\n+  gcc_assert (insn_operand_matches (icode, 1, x));\n+  gcc_assert (insn_operand_matches (icode, 2, y));\n \n   return GEN_FCN (icode) (x, x, y);\n }\n@@ -4717,15 +4711,12 @@ gen_add2_insn (rtx x, rtx y)\n rtx\n gen_add3_insn (rtx r0, rtx r1, rtx c)\n {\n-  int icode = (int) optab_handler (add_optab, GET_MODE (r0));\n+  enum insn_code icode = optab_handler (add_optab, GET_MODE (r0));\n \n   if (icode == CODE_FOR_nothing\n-      || !(insn_data[icode].operand[0].predicate\n-\t   (r0, insn_data[icode].operand[0].mode))\n-      || !(insn_data[icode].operand[1].predicate\n-\t   (r1, insn_data[icode].operand[1].mode))\n-      || !(insn_data[icode].operand[2].predicate\n-\t   (c, insn_data[icode].operand[2].mode)))\n+      || !insn_operand_matches (icode, 0, r0)\n+      || !insn_operand_matches (icode, 1, r1)\n+      || !insn_operand_matches (icode, 2, c))\n     return NULL_RTX;\n \n   return GEN_FCN (icode) (r0, r1, c);\n@@ -4734,21 +4725,18 @@ gen_add3_insn (rtx r0, rtx r1, rtx c)\n int\n have_add2_insn (rtx x, rtx y)\n {\n-  int icode;\n+  enum insn_code icode;\n \n   gcc_assert (GET_MODE (x) != VOIDmode);\n \n-  icode = (int) optab_handler (add_optab, GET_MODE (x));\n+  icode = optab_handler (add_optab, GET_MODE (x));\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (!(insn_data[icode].operand[0].predicate\n-\t(x, insn_data[icode].operand[0].mode))\n-      || !(insn_data[icode].operand[1].predicate\n-\t   (x, insn_data[icode].operand[1].mode))\n-      || !(insn_data[icode].operand[2].predicate\n-\t   (y, insn_data[icode].operand[2].mode)))\n+  if (!insn_operand_matches (icode, 0, x)\n+      || !insn_operand_matches (icode, 1, x)\n+      || !insn_operand_matches (icode, 2, y))\n     return 0;\n \n   return 1;\n@@ -4759,14 +4747,11 @@ have_add2_insn (rtx x, rtx y)\n rtx\n gen_sub2_insn (rtx x, rtx y)\n {\n-  int icode = (int) optab_handler (sub_optab, GET_MODE (x));\n+  enum insn_code icode = optab_handler (sub_optab, GET_MODE (x));\n \n-  gcc_assert (insn_data[icode].operand[0].predicate\n-\t      (x, insn_data[icode].operand[0].mode));\n-  gcc_assert (insn_data[icode].operand[1].predicate\n-\t      (x, insn_data[icode].operand[1].mode));\n-  gcc_assert  (insn_data[icode].operand[2].predicate\n-\t       (y, insn_data[icode].operand[2].mode));\n+  gcc_assert (insn_operand_matches (icode, 0, x));\n+  gcc_assert (insn_operand_matches (icode, 1, x));\n+  gcc_assert (insn_operand_matches (icode, 2, y));\n \n   return GEN_FCN (icode) (x, x, y);\n }\n@@ -4777,15 +4762,12 @@ gen_sub2_insn (rtx x, rtx y)\n rtx\n gen_sub3_insn (rtx r0, rtx r1, rtx c)\n {\n-  int icode = (int) optab_handler (sub_optab, GET_MODE (r0));\n+  enum insn_code icode = optab_handler (sub_optab, GET_MODE (r0));\n \n   if (icode == CODE_FOR_nothing\n-      || !(insn_data[icode].operand[0].predicate\n-\t   (r0, insn_data[icode].operand[0].mode))\n-      || !(insn_data[icode].operand[1].predicate\n-\t   (r1, insn_data[icode].operand[1].mode))\n-      || !(insn_data[icode].operand[2].predicate\n-\t   (c, insn_data[icode].operand[2].mode)))\n+      || !insn_operand_matches (icode, 0, r0)\n+      || !insn_operand_matches (icode, 1, r1)\n+      || !insn_operand_matches (icode, 2, c))\n     return NULL_RTX;\n \n   return GEN_FCN (icode) (r0, r1, c);\n@@ -4794,21 +4776,18 @@ gen_sub3_insn (rtx r0, rtx r1, rtx c)\n int\n have_sub2_insn (rtx x, rtx y)\n {\n-  int icode;\n+  enum insn_code icode;\n \n   gcc_assert (GET_MODE (x) != VOIDmode);\n \n-  icode = (int) optab_handler (sub_optab, GET_MODE (x));\n+  icode = optab_handler (sub_optab, GET_MODE (x));\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (!(insn_data[icode].operand[0].predicate\n-\t(x, insn_data[icode].operand[0].mode))\n-      || !(insn_data[icode].operand[1].predicate\n-\t   (x, insn_data[icode].operand[1].mode))\n-      || !(insn_data[icode].operand[2].predicate\n-\t   (y, insn_data[icode].operand[2].mode)))\n+  if (!insn_operand_matches (icode, 0, x)\n+      || !insn_operand_matches (icode, 1, x)\n+      || !insn_operand_matches (icode, 2, y))\n     return 0;\n \n   return 1;\n@@ -6643,8 +6622,7 @@ gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n     return 0;\n \n   /* Some targets only accept a zero trap code.  */\n-  if (insn_data[icode].operand[3].predicate\n-      && !insn_data[icode].operand[3].predicate (tcode, VOIDmode))\n+  if (!insn_operand_matches (icode, 3, tcode))\n     return 0;\n \n   do_pending_stack_adjust ();\n@@ -7329,5 +7307,16 @@ expand_sync_lock_test_and_set (rtx mem, rtx val, rtx target)\n \n   return NULL_RTX;\n }\n+\f\n+/* Return true if OPERAND is suitable for operand number OPNO of\n+   instruction ICODE.  */\n+\n+bool\n+insn_operand_matches (enum insn_code icode, unsigned int opno, rtx operand)\n+{\n+  return (!insn_data[(int) icode].operand[opno].predicate\n+\t  || (insn_data[(int) icode].operand[opno].predicate\n+\t      (operand, insn_data[(int) icode].operand[opno].mode)));\n+}\n \n #include \"gt-optabs.h\""}, {"sha": "1849a30bfe5a9d40c1e1650738006b8a6c2944a1", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -923,4 +923,10 @@ set_direct_optab_handler (direct_optab op, enum machine_mode mode,\n extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n \t\t\t          enum machine_mode mode2);\n+\n+extern bool insn_operand_matches (enum insn_code icode, unsigned int opno,\n+\t\t\t\t  rtx operand);\n+extern rtx prepare_operand (enum insn_code, rtx, int, enum machine_mode,\n+\t\t\t    enum machine_mode, int);\n+\n #endif /* GCC_OPTABS_H */"}, {"sha": "7c8d78effd152178898e417466f67541e7c5db20", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -5819,17 +5819,15 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t      rtx equiv = (MEM_P (XEXP (x, 0))\n \t\t\t   ? XEXP (x, 0)\n \t\t\t   : reg_equiv_mem[regno]);\n-\t      int icode = (int) optab_handler (add_optab, GET_MODE (x));\n+\t      enum insn_code icode = optab_handler (add_optab, GET_MODE (x));\n \t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n #ifdef HAVE_cc0\n \t\t  && ! sets_cc0_p (PATTERN (insn))\n #endif\n \t\t  && ! (icode != CODE_FOR_nothing\n-\t\t\t&& ((*insn_data[icode].operand[0].predicate)\n-\t\t\t    (equiv, GET_MODE (x)))\n-\t\t\t&& ((*insn_data[icode].operand[1].predicate)\n-\t\t\t    (equiv, GET_MODE (x)))))\n+\t\t\t&& insn_operand_matches (icode, 0, equiv)\n+\t\t\t&& insn_operand_matches (icode, 1, equiv)))\n \t\t{\n \t\t  /* We use the original pseudo for loc, so that\n \t\t     emit_reload_insns() knows which pseudo this"}, {"sha": "9b2bc259c42615ae97399365fcf5d0a6a1eaea47", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -8479,7 +8479,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \t not valid than to dummy things up.  */\n \n       rtx op0, op1, tem, insn;\n-      int code;\n+      enum insn_code code;\n \n       op0 = find_replacement (&XEXP (in, 0));\n       op1 = find_replacement (&XEXP (in, 1));\n@@ -8517,14 +8517,13 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \t DEFINE_PEEPHOLE should be specified that recognizes the sequence\n \t we emit below.  */\n \n-      code = (int) optab_handler (add_optab, GET_MODE (out));\n+      code = optab_handler (add_optab, GET_MODE (out));\n \n       if (CONSTANT_P (op1) || MEM_P (op1) || GET_CODE (op1) == SUBREG\n \t  || (REG_P (op1)\n \t      && REGNO (op1) >= FIRST_PSEUDO_REGISTER)\n \t  || (code != CODE_FOR_nothing\n-\t      && ! ((*insn_data[code].operand[2].predicate)\n-\t\t    (op1, insn_data[code].operand[2].mode))))\n+\t      && !insn_operand_matches (code, 2, op1)))\n \ttem = op0, op0 = op1, op1 = tem;\n \n       gen_reload (out, op0, opnum, type);"}, {"sha": "6411973b8b98944f5def60ae9372c9e7e1c2d139", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ef6ce06d335810dd893c2c6935bbfc84e88dda7/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=2ef6ce06d335810dd893c2c6935bbfc84e88dda7", "patch": "@@ -893,8 +893,7 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t\t\t\treload_mode);\n \n       if (icode != CODE_FOR_nothing\n-\t  && insn_data[(int) icode].operand[in_p].predicate\n-\t  && ! insn_data[(int) icode].operand[in_p].predicate (x, reload_mode))\n+\t  && !insn_operand_matches (icode, in_p, x))\n \ticode = CODE_FOR_nothing;\n       else if (icode != CODE_FOR_nothing)\n \t{"}]}