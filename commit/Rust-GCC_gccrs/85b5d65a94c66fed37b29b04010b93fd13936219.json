{"sha": "85b5d65a94c66fed37b29b04010b93fd13936219", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViNWQ2NWE5NGM2NmZlZDM3YjI5YjA0MDEwYjkzZmQxMzkzNjIxOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-10-15T07:32:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-10-15T07:32:03Z"}, "message": "Implement C++11 inheriting constructors.\n\n\t* cp-tree.h (cpp0x_warn_str): Add CPP0X_INHERITING_CTORS.\n\t(DECL_INHERITED_CTOR_BASE, SET_DECL_INHERITED_CTOR_BASE): New.\n\t(special_function_kind): Add sfk_inheriting_constructor.\n\t* class.c (add_method): An inheriting ctor is hidden by a\n\tuser-declared one.\n\t(one_inheriting_sig, one_inherited_ctor): New.\n\t(add_implicitly_declared_members): Handle inheriting ctors.\n\t* error.c (maybe_warn_cpp0x): Handle CPP0X_INHERITING_CTORS.\n\t* init.c (emit_mem_initializers): Don't set LOOKUP_DEFAULTED\n\tfor an inheriting constructor.\n\t* method.c (type_has_trivial_fn): Handle sfk_inheriting_constructor.\n\t(type_set_nontrivial_flag): Likewise.\n\t(add_one_base_init): Split out from...\n\t(do_build_copy_constructor): ...here.  Handle inheriting constructors.\n\t(locate_fn_flags): Handle a list of arg types.\n\t(synthesized_method_walk): Handle inheriting constructors.\n\t(maybe_explain_implicit_delete): Likewise.\n\t(deduce_inheriting_ctor): New.\n\t(implicitly_declare_fn): Handle inheriting constructors.\n\t* name-lookup.c (push_class_level_binding_1): An inheriting constructor\n\tdoes not declare the base's name.\n\t(do_class_using_decl): Allow inheriting constructors.\n\t* pt.c (template_parms_to_args): Split from current_template_args.\n\t(add_inherited_template_parms): New.\n\t(tsubst_decl): Handle inheriting constructors.\n\t* tree.c (special_function_p): Handle inheriting constructors.\n\nCo-Authored-By: Ville Voutilainen <ville.voutilainen@gmail.com>\n\nFrom-SVN: r192448", "tree": {"sha": "8285868a5a9c87582ef3660e51cb5a55576cb450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8285868a5a9c87582ef3660e51cb5a55576cb450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85b5d65a94c66fed37b29b04010b93fd13936219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b5d65a94c66fed37b29b04010b93fd13936219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b5d65a94c66fed37b29b04010b93fd13936219", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b5d65a94c66fed37b29b04010b93fd13936219/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0d4f8c78e1b9d1038f0ec5fd0c59955dd1cc1f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d4f8c78e1b9d1038f0ec5fd0c59955dd1cc1f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d4f8c78e1b9d1038f0ec5fd0c59955dd1cc1f2"}], "stats": {"total": 684, "additions": 622, "deletions": 62}, "files": [{"sha": "6621c114899d6b98cf45704c398531780c593fd3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -1,3 +1,34 @@\n+2012-10-14  Jason Merrill  <jason@redhat.com>\n+\t    Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement C++11 inheriting constructors.\n+\t* cp-tree.h (cpp0x_warn_str): Add CPP0X_INHERITING_CTORS.\n+\t(DECL_INHERITED_CTOR_BASE, SET_DECL_INHERITED_CTOR_BASE): New.\n+\t(special_function_kind): Add sfk_inheriting_constructor.\n+\t* class.c (add_method): An inheriting ctor is hidden by a\n+\tuser-declared one.\n+\t(one_inheriting_sig, one_inherited_ctor): New.\n+\t(add_implicitly_declared_members): Handle inheriting ctors.\n+\t* error.c (maybe_warn_cpp0x): Handle CPP0X_INHERITING_CTORS.\n+\t* init.c (emit_mem_initializers): Don't set LOOKUP_DEFAULTED\n+\tfor an inheriting constructor.\n+\t* method.c (type_has_trivial_fn): Handle sfk_inheriting_constructor.\n+\t(type_set_nontrivial_flag): Likewise.\n+\t(add_one_base_init): Split out from...\n+\t(do_build_copy_constructor): ...here.  Handle inheriting constructors.\n+\t(locate_fn_flags): Handle a list of arg types.\n+\t(synthesized_method_walk): Handle inheriting constructors.\n+\t(maybe_explain_implicit_delete): Likewise.\n+\t(deduce_inheriting_ctor): New.\n+\t(implicitly_declare_fn): Handle inheriting constructors.\n+\t* name-lookup.c (push_class_level_binding_1): An inheriting constructor\n+\tdoes not declare the base's name.\n+\t(do_class_using_decl): Allow inheriting constructors.\n+\t* pt.c (template_parms_to_args): Split from current_template_args.\n+\t(add_inherited_template_parms): New.\n+\t(tsubst_decl): Handle inheriting constructors.\n+\t* tree.c (special_function_p): Handle inheriting constructors.\n+\n 2012-10-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/54381"}, {"sha": "a478de8056376268f2c44beee008ce7aad3b6af5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 85, "deletions": 5, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -132,7 +132,7 @@ static void finish_struct_methods (tree);\n static void maybe_warn_about_overly_private_class (tree);\n static int method_name_cmp (const void *, const void *);\n static int resort_method_name_cmp (const void *, const void *);\n-static void add_implicitly_declared_members (tree, int, int);\n+static void add_implicitly_declared_members (tree, tree*, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n static tree build_simple_base_path (tree expr, tree binfo);\n static tree build_vtbl_ref_1 (tree, tree);\n@@ -1087,6 +1087,20 @@ add_method (tree type, tree method, tree using_decl)\n \t      || same_type_p (TREE_TYPE (fn_type),\n \t\t\t      TREE_TYPE (method_type))))\n \t{\n+\t  if (DECL_INHERITED_CTOR_BASE (method))\n+\t    {\n+\t      if (DECL_INHERITED_CTOR_BASE (fn))\n+\t\t{\n+\t\t  error_at (DECL_SOURCE_LOCATION (method),\n+\t\t\t    \"%q#D inherited from %qT\", method,\n+\t\t\t    DECL_INHERITED_CTOR_BASE (method));\n+\t\t  error_at (DECL_SOURCE_LOCATION (fn),\n+\t\t\t    \"conflicts with version inherited from %qT\",\n+\t\t\t    DECL_INHERITED_CTOR_BASE (fn));\n+\t\t}\n+\t      /* Otherwise defer to the other function.  */\n+\t      return false;\n+\t    }\n \t  if (using_decl)\n \t    {\n \t      if (DECL_CONTEXT (fn) == type)\n@@ -2750,6 +2764,51 @@ declare_virt_assop_and_dtor (tree t)\n \t\tNULL, t);\n }\n \n+/* Declare the inheriting constructor for class T inherited from base\n+   constructor CTOR with the parameter array PARMS of size NPARMS.  */\n+\n+static void\n+one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n+{\n+  /* We don't declare an inheriting ctor that would be a default,\n+     copy or move ctor.  */\n+  if (nparms == 0\n+      || (nparms == 1\n+\t  && TREE_CODE (parms[0]) == REFERENCE_TYPE\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (parms[0])) == t))\n+    return;\n+  int i;\n+  tree parmlist = void_list_node;\n+  for (i = nparms - 1; i >= 0; i--)\n+    parmlist = tree_cons (NULL_TREE, parms[i], parmlist);\n+  tree fn = implicitly_declare_fn (sfk_inheriting_constructor,\n+\t\t\t\t   t, false, ctor, parmlist);\n+  if (add_method (t, fn, NULL_TREE))\n+    {\n+      DECL_CHAIN (fn) = TYPE_METHODS (t);\n+      TYPE_METHODS (t) = fn;\n+    }\n+}\n+\n+/* Declare all the inheriting constructors for class T inherited from base\n+   constructor CTOR.  */\n+\n+static void\n+one_inherited_ctor (tree ctor, tree t)\n+{\n+  tree parms = FUNCTION_FIRST_USER_PARMTYPE (ctor);\n+\n+  tree *new_parms = XALLOCAVEC (tree, list_length (parms));\n+  int i = 0;\n+  for (; parms && parms != void_list_node; parms = TREE_CHAIN (parms))\n+    {\n+      if (TREE_PURPOSE (parms))\n+\tone_inheriting_sig (t, ctor, new_parms, i);\n+      new_parms[i++] = TREE_VALUE (parms);\n+    }\n+  one_inheriting_sig (t, ctor, new_parms, i);\n+}\n+\n /* Create default constructors, assignment operators, and so forth for\n    the type indicated by T, if they are needed.  CANT_HAVE_CONST_CTOR,\n    and CANT_HAVE_CONST_ASSIGNMENT are nonzero if, for whatever reason,\n@@ -2758,7 +2817,7 @@ declare_virt_assop_and_dtor (tree t)\n    a const reference, respectively.  */\n \n static void\n-add_implicitly_declared_members (tree t,\n+add_implicitly_declared_members (tree t, tree* access_decls,\n \t\t\t\t int cant_have_const_cctor,\n \t\t\t\t int cant_have_const_assignment)\n {\n@@ -2826,6 +2885,26 @@ add_implicitly_declared_members (tree t,\n   /* We can't be lazy about declaring functions that might override\n      a virtual function from a base class.  */\n   declare_virt_assop_and_dtor (t);\n+\n+  while (*access_decls)\n+    {\n+      tree using_decl = TREE_VALUE (*access_decls);\n+      tree decl = USING_DECL_DECLS (using_decl);\n+      if (DECL_SELF_REFERENCE_P (decl))\n+\t{\n+\t  /* declare, then remove the decl */\n+\t  tree ctor_list = CLASSTYPE_CONSTRUCTORS (TREE_TYPE (decl));\n+\t  location_t loc = input_location;\n+\t  input_location = DECL_SOURCE_LOCATION (using_decl);\n+\t  if (ctor_list)\n+\t    for (; ctor_list; ctor_list = OVL_NEXT (ctor_list))\n+\t      one_inherited_ctor (OVL_CURRENT (ctor_list), t);\n+\t  *access_decls = TREE_CHAIN (*access_decls);\n+\t  input_location = loc;\n+\t}\n+      else\n+\taccess_decls = &TREE_CHAIN (*access_decls);\n+    }\n }\n \n /* Subroutine of insert_into_classtype_sorted_fields.  Recursively\n@@ -4342,7 +4421,8 @@ deduce_noexcept_on_destructor (tree dtor)\n     {\n       tree ctx = DECL_CONTEXT (dtor);\n       tree implicit_fn = implicitly_declare_fn (sfk_destructor, ctx,\n-\t\t\t\t\t\t/*const_p=*/false);\n+\t\t\t\t\t\t/*const_p=*/false,\n+\t\t\t\t\t\tNULL, NULL);\n       tree eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (implicit_fn));\n       TREE_TYPE (dtor) = build_exception_variant (TREE_TYPE (dtor), eh_spec);\n     }\n@@ -5135,14 +5215,14 @@ check_bases_and_members (tree t)\n     }\n \n   /* Synthesize any needed methods.  */\n-  add_implicitly_declared_members (t,\n+  add_implicitly_declared_members (t, &access_decls,\n \t\t\t\t   cant_have_const_ctor,\n \t\t\t\t   no_const_asn_ref);\n \n   /* Check defaulted declarations here so we have cant_have_const_ctor\n      and don't need to worry about clones.  */\n   for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n-    if (DECL_DEFAULTED_IN_CLASS_P (fn))\n+    if (!DECL_ARTIFICIAL (fn) && DECL_DEFAULTED_IN_CLASS_P (fn))\n       {\n \tint copy = copy_fn_p (fn);\n \tif (copy > 0)"}, {"sha": "7b4277b05b7f4e164d453a7d964a8d52b827e19d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -420,6 +420,8 @@ typedef enum cpp0x_warn_str\n   CPP0X_USER_DEFINED_LITERALS,\n   /* delegating constructors */\n   CPP0X_DELEGATING_CTORS,\n+  /* inheriting constructors */\n+  CPP0X_INHERITING_CTORS,\n   /* C++11 attributes */\n   CPP0X_ATTRIBUTES\n } cpp0x_warn_str;\n@@ -2384,6 +2386,15 @@ struct GTY((variable_size)) lang_decl {\n #define SET_DECL_THUNKS(NODE,THUNKS) \\\n   (LANG_DECL_FN_CHECK (NODE)->context = (THUNKS))\n \n+/* If NODE, a FUNCTION_DECL, is a C++11 inheriting constructor, then this\n+   is the base it inherits from.  */\n+#define DECL_INHERITED_CTOR_BASE(NODE) \\\n+  (DECL_CONSTRUCTOR_P (NODE) ? LANG_DECL_FN_CHECK (NODE)->context : NULL_TREE)\n+\n+/* Set the inherited base.  */\n+#define SET_DECL_INHERITED_CTOR_BASE(NODE,INH) \\\n+  (LANG_DECL_FN_CHECK (NODE)->context = (INH))\n+\n /* Nonzero if NODE is a thunk, rather than an ordinary function.  */\n #define DECL_THUNK_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == FUNCTION_DECL\t\t\\\n@@ -4142,7 +4153,8 @@ typedef enum special_function_kind {\n   sfk_deleting_destructor, /* A destructor for complete objects that\n \t\t\t      deletes the object after it has been\n \t\t\t      destroyed.  */\n-  sfk_conversion\t   /* A conversion operator.  */\n+  sfk_conversion,\t   /* A conversion operator.  */\n+  sfk_inheriting_constructor /* An inheriting constructor */\n } special_function_kind;\n \n /* The various kinds of linkage.  From [basic.link],\n@@ -5323,6 +5335,7 @@ extern void use_thunk\t\t\t\t(tree, bool);\n extern bool trivial_fn_p\t\t\t(tree);\n extern bool maybe_explain_implicit_delete\t(tree);\n extern void explain_implicit_non_constexpr\t(tree);\n+extern void deduce_inheriting_ctor\t\t(tree);\n extern void synthesize_method\t\t\t(tree);\n extern tree lazily_declare_fn\t\t\t(special_function_kind,\n \t\t\t\t\t\t tree);\n@@ -5335,7 +5348,7 @@ extern tree get_default_ctor\t\t\t(tree);\n extern tree get_dtor\t\t\t\t(tree, tsubst_flags_t);\n extern tree locate_ctor\t\t\t\t(tree);\n extern tree implicitly_declare_fn               (special_function_kind, tree,\n-\t\t\t\t\t\t bool);\n+\t\t\t\t\t\t bool, tree, tree);\n \n /* In optimize.c */\n extern bool maybe_clone_body\t\t\t(tree);\n@@ -5370,6 +5383,7 @@ extern tree maybe_update_decl_type\t\t(tree, tree);\n extern bool check_default_tmpl_args             (tree, tree, bool, bool, int);\n extern tree push_template_decl\t\t\t(tree);\n extern tree push_template_decl_real\t\t(tree, bool);\n+extern tree add_inherited_template_parms\t(tree, tree);\n extern bool redeclare_class_template\t\t(tree, tree);\n extern tree lookup_template_class\t\t(tree, tree, tree, tree,\n \t\t\t\t\t\t int, tsubst_flags_t);"}, {"sha": "76f939f1049708316175e0724564d42df3def493", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -3374,6 +3374,11 @@ maybe_warn_cpp0x (cpp0x_warn_str str)\n \t\t \"delegating constructors \"\n \t\t \"only available with -std=c++11 or -std=gnu++11\");\n         break;\n+      case CPP0X_INHERITING_CTORS:\n+\tpedwarn (input_location, 0,\n+\t\t \"inheriting constructors \"\n+\t\t \"only available with -std=c++11 or -std=gnu++11\");\n+        break;\n       case CPP0X_ATTRIBUTES:\n \tpedwarn (input_location, 0,\n \t\t \"c++11 attributes \""}, {"sha": "044603887e8a59a78e56c43e5a8a2e3b89941d1a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -1036,7 +1036,8 @@ emit_mem_initializers (tree mem_inits)\n       return;\n     }\n \n-  if (DECL_DEFAULTED_FN (current_function_decl))\n+  if (DECL_DEFAULTED_FN (current_function_decl)\n+      && ! DECL_INHERITED_CTOR_BASE (current_function_decl))\n     flags |= LOOKUP_DEFAULTED;\n \n   /* Sort the mem-initializers into the order in which the"}, {"sha": "4da5cc9ebcac0f3f1bed146252c1af42ff7d0970", "filename": "gcc/cp/method.c", "status": "modified", "additions": 172, "deletions": 40, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -429,6 +429,8 @@ type_has_trivial_fn (tree ctype, special_function_kind sfk)\n       return !TYPE_HAS_COMPLEX_MOVE_ASSIGN (ctype);\n     case sfk_destructor:\n       return !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (ctype);\n+    case sfk_inheriting_constructor:\n+      return false;\n     default:\n       gcc_unreachable ();\n     }\n@@ -460,6 +462,7 @@ type_set_nontrivial_flag (tree ctype, special_function_kind sfk)\n     case sfk_destructor:\n       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (ctype) = true;\n       return;\n+    case sfk_inheriting_constructor:\n     default:\n       gcc_unreachable ();\n     }\n@@ -478,16 +481,57 @@ trivial_fn_p (tree fn)\n   return type_has_trivial_fn (DECL_CONTEXT (fn), special_function_p (fn));\n }\n \n-/* Generate code for default X(X&) or X(X&&) constructor.  */\n+/* Subroutine of do_build_copy_constructor: Add a mem-initializer for BINFO\n+   given the parameter or parameters PARM, possibly inherited constructor\n+   base INH, or move flag MOVE_P.  */\n+\n+static tree\n+add_one_base_init (tree binfo, tree parm, bool move_p, tree inh,\n+\t\t   tree member_init_list)\n+{\n+  tree init;\n+  if (inh)\n+    {\n+      /* An inheriting constructor only has a mem-initializer for\n+\t the base it inherits from.  */\n+      if (BINFO_TYPE (binfo) != inh)\n+\treturn member_init_list;\n+\n+      tree *p = &init;\n+      init = NULL_TREE;\n+      for (; parm; parm = DECL_CHAIN (parm))\n+\t{\n+\t  tree exp = convert_from_reference (parm);\n+\t  if (TREE_CODE (TREE_TYPE (parm)) != REFERENCE_TYPE)\n+\t    exp = move (exp);\n+\t  *p = build_tree_list (NULL_TREE, exp);\n+\t  p = &TREE_CHAIN (*p);\n+\t}\n+    }\n+  else\n+    {\n+      init = build_base_path (PLUS_EXPR, parm, binfo, 1,\n+\t\t\t      tf_warning_or_error);\n+      if (move_p)\n+\tinit = move (init);\n+      init = build_tree_list (NULL_TREE, init);\n+    }\n+  return tree_cons (binfo, init, member_init_list);\n+}\n+\n+/* Generate code for default X(X&) or X(X&&) constructor or an inheriting\n+   constructor.  */\n \n static void\n do_build_copy_constructor (tree fndecl)\n {\n   tree parm = FUNCTION_FIRST_USER_PARM (fndecl);\n   bool move_p = DECL_MOVE_CONSTRUCTOR_P (fndecl);\n   bool trivial = trivial_fn_p (fndecl);\n+  tree inh = DECL_INHERITED_CTOR_BASE (fndecl);\n \n-  parm = convert_from_reference (parm);\n+  if (!inh)\n+    parm = convert_from_reference (parm);\n \n   if (trivial\n       && is_empty_class (current_class_type))\n@@ -516,30 +560,17 @@ do_build_copy_constructor (tree fndecl)\n       for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n \t   VEC_iterate (tree, vbases, i, binfo); i++)\n \t{\n-\t  init = build_base_path (PLUS_EXPR, parm, binfo, 1,\n-\t\t\t\t  tf_warning_or_error);\n-\t  if (move_p)\n-\t    init = move (init);\n-\t  member_init_list\n-\t    = tree_cons (binfo,\n-\t\t\t build_tree_list (NULL_TREE, init),\n-\t\t\t member_init_list);\n+\t  member_init_list = add_one_base_init (binfo, parm, move_p, inh,\n+\t\t\t\t\t\tmember_init_list);\n \t}\n \n       for (binfo = TYPE_BINFO (current_class_type), i = 0;\n \t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n \t  if (BINFO_VIRTUAL_P (base_binfo))\n \t    continue;\n-\n-\t  init = build_base_path (PLUS_EXPR, parm, base_binfo, 1,\n-\t\t\t\t  tf_warning_or_error);\n-\t  if (move_p)\n-\t    init = move (init);\n-\t  member_init_list\n-\t    = tree_cons (base_binfo,\n-\t\t\t build_tree_list (NULL_TREE, init),\n-\t\t\t member_init_list);\n+\t  member_init_list = add_one_base_init (base_binfo, parm, move_p,\n+\t\t\t\t\t\tinh, member_init_list);\n \t}\n \n       for (; fields; fields = DECL_CHAIN (fields))\n@@ -549,6 +580,8 @@ do_build_copy_constructor (tree fndecl)\n \n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n+\t  if (inh)\n+\t    continue;\n \n \t  expr_type = TREE_TYPE (field);\n \t  if (DECL_NAME (field))\n@@ -833,8 +866,23 @@ locate_fn_flags (tree type, tree name, tree argtype, int flags,\n   args = make_tree_vector ();\n   if (argtype)\n     {\n-      tree arg = build_stub_object (argtype);\n-      VEC_quick_push (tree, args, arg);\n+      if (TREE_CODE (argtype) == TREE_LIST)\n+\t{\n+\t  for (tree elt = argtype; elt != void_list_node;\n+\t       elt = TREE_CHAIN (elt))\n+\t    {\n+\t      tree type = TREE_VALUE (elt);\n+\t      if (TREE_CODE (type) != REFERENCE_TYPE)\n+\t\ttype = cp_build_reference_type (type, /*rval*/true);\n+\t      tree arg = build_stub_object (type);\n+\t      VEC_safe_push (tree, gc, args, arg);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree arg = build_stub_object (argtype);\n+\t  VEC_quick_push (tree, args, arg);\n+\t}\n     }\n \n   fns = lookup_fnfields (binfo, name, 0);\n@@ -1110,7 +1158,8 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n static void\n synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t tree *spec_p, bool *trivial_p, bool *deleted_p,\n-\t\t\t bool *constexpr_p, bool *no_implicit_p, bool diag)\n+\t\t\t bool *constexpr_p, bool *no_implicit_p, bool diag,\n+\t\t\t tree inherited_base, tree inherited_parms)\n {\n   tree binfo, base_binfo, scope, fnname, rval, argtype;\n   bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n@@ -1162,6 +1211,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     case sfk_constructor:\n     case sfk_move_constructor:\n     case sfk_copy_constructor:\n+    case sfk_inheriting_constructor:\n       ctor_p = true;\n       fnname = complete_ctor_identifier;\n       break;\n@@ -1170,6 +1220,9 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       gcc_unreachable ();\n     }\n \n+  gcc_assert ((sfk == sfk_inheriting_constructor)\n+\t      == (inherited_base != NULL_TREE));\n+\n   /* If that user-written default constructor would satisfy the\n      requirements of a constexpr constructor (7.1.5), the\n      implicitly-defined default constructor is constexpr.  */\n@@ -1181,6 +1234,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     {\n     case sfk_constructor:\n     case sfk_destructor:\n+    case sfk_inheriting_constructor:\n       copy_arg_p = false;\n       break;\n \n@@ -1231,7 +1285,9 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \n   scope = push_scope (ctype);\n \n-  flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE|LOOKUP_DEFAULTED;\n+  flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE;\n+  if (!inherited_base)\n+    flags |= LOOKUP_DEFAULTED;\n \n   complain = diag ? tf_warning_or_error : tf_none;\n \n@@ -1252,7 +1308,11 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \n       if (copy_arg_p)\n \targtype = build_stub_type (basetype, quals, move_p);\n+      else if (basetype == inherited_base)\n+\targtype = inherited_parms;\n       rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n+      if (inherited_base)\n+\targtype = NULL_TREE;\n \n       process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n \t\t\tconstexpr_p, no_implicit_p, diag, basetype);\n@@ -1405,14 +1465,16 @@ maybe_explain_implicit_delete (tree decl)\n \t}\n       if (!informed)\n \t{\n-\t  tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));\n+\t  tree parms = FUNCTION_FIRST_USER_PARMTYPE (decl);\n+\t  tree parm_type = TREE_VALUE (parms);\n \t  bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n \t  tree scope = push_scope (ctype);\n \t  inform (0, \"%q+#D is implicitly deleted because the default \"\n \t\t \"definition would be ill-formed:\", decl);\n \t  pop_scope (scope);\n \t  synthesized_method_walk (ctype, sfk, const_p,\n-\t\t\t\t   NULL, NULL, NULL, NULL, NULL, true);\n+\t\t\t\t   NULL, NULL, NULL, NULL, NULL, true,\n+\t\t\t\t   DECL_INHERITED_CTOR_BASE (decl), parms);\n \t}\n \n       input_location = loc;\n@@ -1432,7 +1494,27 @@ explain_implicit_non_constexpr (tree decl)\n   bool dummy;\n   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n \t\t\t   special_function_p (decl), const_p,\n-\t\t\t   NULL, NULL, NULL, &dummy, NULL, true);\n+\t\t\t   NULL, NULL, NULL, &dummy, NULL, true,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+}\n+\n+/* DECL is an instantiation of an inheriting constructor template.  Deduce\n+   the correct exception-specification and deletedness for this particular\n+   specialization.  */\n+\n+void\n+deduce_inheriting_ctor (tree decl)\n+{\n+  gcc_assert (DECL_INHERITED_CTOR_BASE (decl));\n+  tree spec;\n+  bool trivial, constexpr_, deleted, no_implicit;\n+  synthesized_method_walk (DECL_CONTEXT (decl), sfk_inheriting_constructor,\n+\t\t\t   false, &spec, &trivial, &deleted, &constexpr_,\n+\t\t\t   &no_implicit, /*diag*/false,\n+\t\t\t   DECL_INHERITED_CTOR_BASE (decl),\n+\t\t\t   FUNCTION_FIRST_USER_PARMTYPE (decl));\n+  DECL_DELETED_FN (decl) = deleted;\n+  TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);\n }\n \n /* Implicitly declare the special function indicated by KIND, as a\n@@ -1442,7 +1524,9 @@ explain_implicit_non_constexpr (tree decl)\n    FUNCTION_DECL for the implicitly declared function.  */\n \n tree\n-implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n+implicitly_declare_fn (special_function_kind kind, tree type,\n+\t\t       bool const_p, tree inherited_ctor,\n+\t\t       tree inherited_parms)\n {\n   tree fn;\n   tree parameter_types = void_list_node;\n@@ -1499,6 +1583,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     case sfk_copy_assignment:\n     case sfk_move_constructor:\n     case sfk_move_assignment:\n+    case sfk_inheriting_constructor:\n     {\n       bool move_p;\n       if (kind == sfk_copy_assignment\n@@ -1510,23 +1595,44 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       else\n \tname = constructor_name (type);\n \n-      if (const_p)\n-\trhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+      if (kind == sfk_inheriting_constructor)\n+\tparameter_types = inherited_parms;\n       else\n-\trhs_parm_type = type;\n-      move_p = (kind == sfk_move_assignment\n-\t\t|| kind == sfk_move_constructor);\n-      rhs_parm_type = cp_build_reference_type (rhs_parm_type, move_p);\n+\t{\n+\t  if (const_p)\n+\t    rhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+\t  else\n+\t    rhs_parm_type = type;\n+\t  move_p = (kind == sfk_move_assignment\n+\t\t    || kind == sfk_move_constructor);\n+\t  rhs_parm_type = cp_build_reference_type (rhs_parm_type, move_p);\n \n-      parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n+\t  parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n+\t}\n       break;\n     }\n     default:\n       gcc_unreachable ();\n     }\n \n-  synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n-\t\t\t   &deleted_p, &constexpr_p, &no_implicit_p, false);\n+  tree inherited_base = (inherited_ctor\n+\t\t\t ? DECL_CONTEXT (inherited_ctor)\n+\t\t\t : NULL_TREE);\n+  if (inherited_ctor && TREE_CODE (inherited_ctor) == TEMPLATE_DECL)\n+    {\n+      /* For an inheriting constructor template, just copy these flags from\n+\t the inherited constructor template for now.  */\n+      raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (inherited_ctor));\n+      trivial_p = false;\n+      deleted_p = DECL_DELETED_FN (DECL_TEMPLATE_RESULT (inherited_ctor));\n+      constexpr_p\n+\t= DECL_DECLARED_CONSTEXPR_P (DECL_TEMPLATE_RESULT (inherited_ctor));\n+      no_implicit_p = false;\n+    }\n+  else\n+    synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n+\t\t\t     &deleted_p, &constexpr_p, &no_implicit_p, false,\n+\t\t\t     inherited_base, inherited_parms);\n   /* Don't bother marking a deleted constructor as constexpr.  */\n   if (deleted_p)\n     constexpr_p = false;\n@@ -1544,9 +1650,10 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   if (raises)\n     fn_type = build_exception_variant (fn_type, raises);\n   fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n-  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (TYPE_NAME (type));\n+  if (kind != sfk_inheriting_constructor)\n+    DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (TYPE_NAME (type));\n   if (kind == sfk_constructor || kind == sfk_copy_constructor\n-      || kind == sfk_move_constructor)\n+      || kind == sfk_move_constructor || kind == sfk_inheriting_constructor)\n     DECL_CONSTRUCTOR_P (fn) = 1;\n   else if (kind == sfk_destructor)\n     DECL_DESTRUCTOR_P (fn) = 1;\n@@ -1575,6 +1682,27 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       DECL_PARM_INDEX (decl) = DECL_PARM_LEVEL (decl) = 1;\n       DECL_ARGUMENTS (fn) = decl;\n     }\n+  else if (kind == sfk_inheriting_constructor)\n+    {\n+      tree *p = &DECL_ARGUMENTS (fn);\n+      for (tree parm = inherited_parms; parm != void_list_node;\n+\t   parm = TREE_CHAIN (parm))\n+\t{\n+\t  *p = cp_build_parm_decl (NULL_TREE, TREE_VALUE (parm));\n+\t  DECL_CONTEXT (*p) = fn;\n+\t  p = &DECL_CHAIN (*p);\n+\t}\n+      SET_DECL_INHERITED_CTOR_BASE (fn, inherited_base);\n+      DECL_NONCONVERTING_P (fn) = DECL_NONCONVERTING_P (inherited_ctor);\n+      /* A constructor so declared has the same access as the corresponding\n+\t constructor in X.  */\n+      TREE_PRIVATE (fn) = TREE_PRIVATE (inherited_ctor);\n+      TREE_PROTECTED (fn) = TREE_PROTECTED (inherited_ctor);\n+      /* Copy constexpr from the inherited constructor even if the\n+\t inheriting constructor doesn't satisfy the requirements.  */\n+      constexpr_p\n+\t= DECL_DECLARED_CONSTEXPR_P (STRIP_TEMPLATE (inherited_ctor));\n+    }\n   /* Add the \"this\" parameter.  */\n   this_parm = build_this_parm (fn_type, TYPE_UNQUALIFIED);\n   DECL_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n@@ -1600,6 +1728,9 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   /* Restore PROCESSING_TEMPLATE_DECL.  */\n   processing_template_decl = saved_processing_template_decl;\n \n+  if (inherited_ctor && TREE_CODE (inherited_ctor) == TEMPLATE_DECL)\n+    fn = add_inherited_template_parms (fn, inherited_ctor);\n+\n   return fn;\n }\n \n@@ -1613,7 +1744,8 @@ defaulted_late_check (tree fn)\n   tree ctx = DECL_CONTEXT (fn);\n   special_function_kind kind = special_function_p (fn);\n   bool fn_const_p = (copy_fn_p (fn) == 2);\n-  tree implicit_fn = implicitly_declare_fn (kind, ctx, fn_const_p);\n+  tree implicit_fn = implicitly_declare_fn (kind, ctx, fn_const_p,\n+\t\t\t\t\t    NULL, NULL);\n \n   if (!same_type_p (TREE_TYPE (TREE_TYPE (fn)),\n \t\t    TREE_TYPE (TREE_TYPE (implicit_fn)))\n@@ -1766,7 +1898,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n     }\n \n   /* Declare the function.  */\n-  fn = implicitly_declare_fn (sfk, type, const_p);\n+  fn = implicitly_declare_fn (sfk, type, const_p, NULL, NULL);\n \n   /* [class.copy]/8 If the class definition declares a move constructor or\n      move assignment operator, the implicitly declared copy constructor is"}, {"sha": "f010560492110f0a524f47fabbb346cc845d7f74", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -3026,6 +3026,14 @@ push_class_level_binding_1 (tree name, tree x)\n       && TREE_TYPE (decl) == error_mark_node)\n     decl = TREE_VALUE (decl);\n \n+  if (TREE_CODE (decl) == USING_DECL\n+      && TREE_CODE (USING_DECL_SCOPE (decl)) == TEMPLATE_TYPE_PARM\n+      && DECL_NAME (decl) == TYPE_IDENTIFIER (USING_DECL_SCOPE (decl)))\n+    /* This using-declaration declares constructors that inherit from the\n+       constructors for the template parameter.  It does not redeclare the\n+       name of the template parameter.  */\n+    return true;\n+\n   if (!check_template_shadow (decl))\n     return false;\n \n@@ -3218,10 +3226,7 @@ do_class_using_decl (tree scope, tree name)\n       return NULL_TREE;\n     }\n   if (MAYBE_CLASS_TYPE_P (scope) && constructor_name_p (name, scope))\n-    {\n-      error (\"%<%T::%D%> names constructor\", scope, name);\n-      return NULL_TREE;\n-    }\n+    maybe_warn_cpp0x (CPP0X_INHERITING_CTORS);\n   if (constructor_name_p (name, current_class_type))\n     {\n       error (\"%<%T::%D%> names constructor in %qT\","}, {"sha": "7e8d8b0880d75ca4c0e9fd01d51f0ca7b36cdb00", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -3847,17 +3847,16 @@ arg_from_parm_pack_p (tree arg_pack, tree parm_pack)\n   return false;\n }\n \n-/* Within the declaration of a template, return all levels of template\n-   parameters that apply.  The template parameters are represented as\n-   a TREE_VEC, in the form documented in cp-tree.h for template\n-   arguments.  */\n+/* Given a set of template parameters, return them as a set of template\n+   arguments.  The template parameters are represented as a TREE_VEC, in\n+   the form documented in cp-tree.h for template arguments.  */\n \n static tree\n-current_template_args (void)\n+template_parms_to_args (tree parms)\n {\n   tree header;\n   tree args = NULL_TREE;\n-  int length = TMPL_PARMS_DEPTH (current_template_parms);\n+  int length = TMPL_PARMS_DEPTH (parms);\n   int l = length;\n \n   /* If there is only one level of template parameters, we do not\n@@ -3866,7 +3865,7 @@ current_template_args (void)\n   if (length > 1)\n     args = make_tree_vec (length);\n \n-  for (header = current_template_parms; header; header = TREE_CHAIN (header))\n+  for (header = parms; header; header = TREE_CHAIN (header))\n     {\n       tree a = copy_node (TREE_VALUE (header));\n       int i;\n@@ -3903,6 +3902,15 @@ current_template_args (void)\n   return args;\n }\n \n+/* Within the declaration of a template, return the currently active\n+   template parameters as an argument TREE_VEC.  */\n+\n+static tree\n+current_template_args (void)\n+{\n+  return template_parms_to_args (current_template_parms);\n+}\n+\n /* Update the declared TYPE by doing any lookups which were thought to be\n    dependent, but are not now that we know the SCOPE of the declarator.  */\n \n@@ -4904,6 +4912,29 @@ push_template_decl (tree decl)\n   return push_template_decl_real (decl, false);\n }\n \n+/* FN is an inheriting constructor that inherits from the constructor\n+   template INHERITED; turn FN into a constructor template with a matching\n+   template header.  */\n+\n+tree\n+add_inherited_template_parms (tree fn, tree inherited)\n+{\n+  tree inner_parms\n+    = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (inherited));\n+  inner_parms = copy_node (inner_parms);\n+  tree parms\n+    = tree_cons (size_int (processing_template_decl + 1),\n+\t\t inner_parms, current_template_parms);\n+  tree tmpl = build_template_decl (fn, parms, /*member*/true);\n+  tree args = template_parms_to_args (parms);\n+  DECL_TEMPLATE_INFO (fn) = build_template_info (tmpl, args);\n+  TREE_TYPE (tmpl) = TREE_TYPE (fn);\n+  DECL_TEMPLATE_RESULT (tmpl) = fn;\n+  DECL_ARTIFICIAL (tmpl) = true;\n+  DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n+  return tmpl;\n+}\n+\n /* Called when a class template TYPE is redeclared with the indicated\n    template PARMS, e.g.:\n \n@@ -10136,6 +10167,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    maybe_retrofit_in_chrg (r);\n \t    if (DECL_CONSTRUCTOR_P (r))\n \t      grok_ctor_properties (ctx, r);\n+\t    if (DECL_INHERITED_CTOR_BASE (r))\n+\t      deduce_inheriting_ctor (r);\n \t    /* If this is an instantiation of a member template, clone it.\n \t       If it isn't, that'll be handled by\n \t       clone_constructors_and_destructors.  */\n@@ -10336,9 +10369,14 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n       if (DECL_DEPENDENT_P (t)\n \t  || uses_template_parms (USING_DECL_SCOPE (t)))\n \t{\n-\t  r = do_class_using_decl\n-\t    (tsubst_copy (USING_DECL_SCOPE (t), args, complain, in_decl),\n-\t     tsubst_copy (DECL_NAME (t), args, complain, in_decl));\n+\t  tree scope = USING_DECL_SCOPE (t);\n+\t  tree inst_scope = tsubst_copy (USING_DECL_SCOPE (t), args,\n+\t\t\t\t\t complain, in_decl);\n+\t  tree name = tsubst_copy (DECL_NAME (t), args, complain, in_decl);\n+\t  if (TREE_CODE (scope) == TEMPLATE_TYPE_PARM\n+\t      && name == TYPE_IDENTIFIER (scope))\n+\t    name = TYPE_IDENTIFIER (inst_scope);\n+\t  r = do_class_using_decl (inst_scope, name);\n \t  if (!r)\n \t    r = error_mark_node;\n \t  else"}, {"sha": "8d555c2e2b1c4a4151a7712dc9d604637eb69029", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -3337,6 +3337,8 @@ special_function_p (const_tree decl)\n   /* Rather than doing all this stuff with magic names, we should\n      probably have a field of type `special_function_kind' in\n      DECL_LANG_SPECIFIC.  */\n+  if (DECL_INHERITED_CTOR_BASE (decl))\n+    return sfk_inheriting_constructor;\n   if (DECL_COPY_CONSTRUCTOR_P (decl))\n     return sfk_copy_constructor;\n   if (DECL_MOVE_CONSTRUCTOR_P (decl))"}, {"sha": "70e5b571efcb396529d68d1edba5706ecbedd318", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -1,3 +1,19 @@\n+2012-10-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/inh-ctor1.C: New.\n+\t* g++.dg/cpp0x/inh-ctor2.C: New.\n+\t* g++.dg/cpp0x/inh-ctor3.C: New.\n+\t* g++.dg/cpp0x/inh-ctor4.C: New.\n+\t* g++.dg/cpp0x/inh-ctor5.C: New.\n+\t* g++.dg/cpp0x/inh-ctor6.C: New.\n+\t* g++.dg/cpp0x/inh-ctor7.C: New.\n+\t* g++.dg/cpp0x/inh-ctor8.C: New.\n+\t* g++.dg/cpp0x/inh-ctor9.C: New.\n+\t* g++.dg/cpp0x/inh-ctor10.C: New.\n+\t* g++.dg/cpp0x/inh-ctor11.C: New.\n+\t* g++.dg/cpp0x/inh-ctor12.C: New.\n+\t* g++.dg/cpp0x/inh-ctor13.C: New.\n+\n 2012-10-14  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR rtl-optimization/54919"}, {"sha": "99603106512dc8c8ea7e2199005af6f02237ccaf", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor1.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++11 }\n+\n+struct A\n+{\n+  int i;\n+  constexpr A(int i): i(i) {}\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+constexpr B b(42);\n+\n+#define SA(X) static_assert((X),#X)\n+SA(b.i == 42);"}, {"sha": "de5745358ef65d4abc564773dd3609a4c8b0bd43", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor10.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor10.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++11\" }\n+\n+struct A\n+{\n+  template <class... Ts> A(Ts...);\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+B b1(42);\n+B b2(1.0, 42, (void*)0);"}, {"sha": "8e8ff010ffec31e56a298760131c2b857dc88b64", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor11.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor11.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++11\" }\n+\n+struct A\n+{\n+  A(int, ...);\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+B b1(42);\n+B b2(42, 1.0);\t\t\t// { dg-error \"no match\" }"}, {"sha": "257487efb112daec31d8ff065d8740bd8c2d0334", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor12.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor12.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-do run }\n+\n+struct A\n+{\n+  int i;\n+  template <class T>\n+  A(T t) noexcept : i(t) {}\n+};\n+\n+struct C\n+{\n+  C() { throw 42; }\n+};\n+\n+struct B: A, C\n+{\n+  using A::A;\n+};\n+\n+int main()\n+{\n+  try { B b(24); }\n+  catch (int) { return 0; }\n+  __builtin_abort();\n+}"}, {"sha": "2e18e5d62f370c0ced1f7ed62d580b3086e0da09", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor13.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor13.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-std=c++11\" }\n+\n+struct A\n+{\n+  int i;\n+  template <class T> A(T t);\n+};\n+\n+struct C\n+{\n+  C() = delete;\t\t\t// { dg-error \"declared here\" }\n+};\n+\n+struct B: A, C\n+{\n+  using A::A;\t\t\t// { dg-error \"C::C\" }\n+};\n+\n+int main()\n+{\n+  B b(24);\t\t\t// { dg-error \"B::B\" }\n+}"}, {"sha": "621ba604c2231850e2e00022afe8c67d6ea6324a", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor2.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options -std=c++11 }\n+\n+struct A\n+{\n+  int i;\n+  constexpr A(int, int i = num): i(i) {}\n+private:\n+  static const int num = 42;\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+constexpr B b(24);\n+\n+#define SA(X) static_assert((X),#X)\n+SA(b.i == 42);"}, {"sha": "7116e2f0700a2929cc076bc3e1654332fd269540", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor3.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++11 }\n+\n+struct B1 {\n+  B1(int);\n+};\n+struct B2 {\n+  B2(int);\n+};\n+struct D1 : B1, B2 {\n+  using B1::B1;\t\t\t// { dg-error \"inherited\" }\n+  using B2::B2;\t\t\t// { dg-error \"inherited\" }\n+};\t\t\t   // ill-formed: attempts to declare D1(int) twice\n+struct D2 : B1, B2 {\n+  using B1::B1;\n+  using B2::B2;\n+  D2(int);    // OK: user declaration supersedes both implicit declarations\n+};"}, {"sha": "b6754dc4a46795abe973ed36007fa28f445fdc57", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor4.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,18 @@\n+// From N3337\n+// { dg-options -std=c++11 }\n+\n+struct B1 {\n+  B1(int);\n+};\n+struct B2 {\n+  B2(int = 13, int = 42);\n+};\n+struct D1 : B1 {\n+  using B1::B1;\n+};\n+struct D2 : B2 {\n+  using B2::B2;\n+};\n+\n+D1 d1(1);\n+D2 d2a(2), d2b(3,4);"}, {"sha": "a8aa6d98ad9bde359eb22c0d5766695717b84ab6", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor5.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++11\" }\n+\n+struct B1 {\n+  B1(int) { }\n+};\n+struct B2 {\n+  B2(double) { }\n+};\n+struct D1 : B1 {    // { dg-error \"no match\" }\n+  using B1::B1;\t    // implicitly declares D1(int)\n+  int x;\n+};\n+void test() {\n+  D1 d(6);\t    // OK: d.x is not initialized\n+  D1 e;\t\t    // { dg-error \"deleted\" } D1 has no default constructor\n+}\n+struct D2 : B2 {\n+  using B2::B2;\t    // { dg-error \"no match\" } implicitly declares D2(double)\n+  B1 b;\n+};\n+D2 f(1.0);\t    // { dg-error \"deleted\" } B1 has no default constructor"}, {"sha": "5ac88d6b7db5c06932835fd74d247b6e1a5e13ff", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor6.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor6.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++11\" }\n+\n+extern \"C\" int printf (const char *, ...);\n+template< class T >\n+struct D : T {\n+  using T::T;\n+  // declares all constructors from class T\n+  ~D() { printf (\"Destroying wrapper\\n\"); }\n+};\n+\n+struct A {\n+  A(int);\n+};\n+\n+D<A> d(42);"}, {"sha": "22608246706d0b0494592fa075348e2bcb7fa4cc", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor7.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor7.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++11\" }\n+\n+struct A\n+{\n+  int i;\n+  template <class T>\n+  constexpr A(T t): i(t) {}\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+constexpr B b(42);\n+\n+#define SA(X) static_assert((X),#X)\n+SA(b.i == 42);"}, {"sha": "d55d3d2a5bfb32953e3ddec9f26800c8af6c1ec7", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor8.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor8.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-std=c++11\" }\n+\n+struct A\n+{\n+  int i;\n+  explicit A(int i): i(i) {}\n+};\n+\n+struct B: A\n+{\n+  using A::A;\n+};\n+\n+void f(B);\n+\n+int main()\n+{\n+  f(B(42));\t\t\t// OK\n+  f(42);\t\t\t// { dg-error \"could not convert\" }\n+}"}, {"sha": "dc5e86b634850668dffe70769e6286a668d334d8", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor9.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b5d65a94c66fed37b29b04010b93fd13936219/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor9.C?ref=85b5d65a94c66fed37b29b04010b93fd13936219", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++11\" }\n+\n+class A\n+{\n+  int i;\n+protected:\n+  A(int i): i(i) {}\n+};\n+\n+struct B: A\n+{\n+  using A::A;\t\t\t// { dg-error \"protected\" }\n+};\n+\n+B b(42);\t\t\t// { dg-error \"this context\" }"}]}