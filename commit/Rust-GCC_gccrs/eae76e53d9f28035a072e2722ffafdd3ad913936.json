{"sha": "eae76e53d9f28035a072e2722ffafdd3ad913936", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlNzZlNTNkOWYyODAzNWEwNzJlMjcyMmZmYWZkZDNhZDkxMzkzNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-10-31T13:57:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-10-31T13:57:05Z"}, "message": "tree.c (tree_ctz): New function.\n\n\t* tree.c (tree_ctz): New function.\n\t* tree.h (tree_ctz): New prototype.\n\t* tree-ssanames.h (get_range_info, get_nonzero_bits): Change\n\tfirst argument from tree to const_tree.\n\t* tree-ssanames.c (get_range_info, get_nonzero_bits): Likewise.\n\t* tree-vectorizer.h (vect_generate_tmps_on_preheader): New prototype.\n\t* tree-vect-loop-manip.c (vect_generate_tmps_on_preheader): No longer\n\tstatic.\n\t* expr.c (highest_pow2_factor): Reimplemented using tree_ctz.\n\t* tree-vect-loop.c (vect_analyze_loop_operations,\n\tvect_transform_loop): Don't force scalar loop for bound just because\n\tnumber of iterations is unknown, only do it if it is not known to be\n\ta multiple of vectorization_factor.\n\t* builtins.c (get_object_alignment_2): Use tree_ctz on offset.\n\nFrom-SVN: r204257", "tree": {"sha": "724d536345f0d153b316b5c50064d6336fea231b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/724d536345f0d153b316b5c50064d6336fea231b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eae76e53d9f28035a072e2722ffafdd3ad913936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae76e53d9f28035a072e2722ffafdd3ad913936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae76e53d9f28035a072e2722ffafdd3ad913936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae76e53d9f28035a072e2722ffafdd3ad913936/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c853f62af3d69969bfca8e29c2ee17cb77fc6b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c853f62af3d69969bfca8e29c2ee17cb77fc6b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c853f62af3d69969bfca8e29c2ee17cb77fc6b1a"}], "stats": {"total": 287, "additions": 165, "deletions": 122}, "files": [{"sha": "551b3031ea9d5f6ebaebe3911c85fce4e708e68d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -1,5 +1,20 @@\n 2013-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* tree.c (tree_ctz): New function.\n+\t* tree.h (tree_ctz): New prototype.\n+\t* tree-ssanames.h (get_range_info, get_nonzero_bits): Change\n+\tfirst argument from tree to const_tree.\n+\t* tree-ssanames.c (get_range_info, get_nonzero_bits): Likewise.\n+\t* tree-vectorizer.h (vect_generate_tmps_on_preheader): New prototype.\n+\t* tree-vect-loop-manip.c (vect_generate_tmps_on_preheader): No longer\n+\tstatic.\n+\t* expr.c (highest_pow2_factor): Reimplemented using tree_ctz.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations,\n+\tvect_transform_loop): Don't force scalar loop for bound just because\n+\tnumber of iterations is unknown, only do it if it is not known to be\n+\ta multiple of vectorization_factor.\n+\t* builtins.c (get_object_alignment_2): Use tree_ctz on offset.\n+\n \t* gimple-pretty-print.c (dump_ssaname_info): Print newline also\n \tin case of VR_VARYING.  Print get_nonzero_bits if not all ones.\n \t* tree-ssanames.h (struct range_info_def): Add nonzero_bits field."}, {"sha": "f84789e6a59f3d27acf7e6dab4e1e017dff82bd8", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -314,7 +314,7 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n   tree offset;\n   enum machine_mode mode;\n   int unsignedp, volatilep;\n-  unsigned int inner, align = BITS_PER_UNIT;\n+  unsigned int align = BITS_PER_UNIT;\n   bool known_alignment = false;\n \n   /* Get the innermost object and the constant (bitpos) and possibly\n@@ -423,50 +423,16 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n \n   /* If there is a non-constant offset part extract the maximum\n      alignment that can prevail.  */\n-  inner = ~0U;\n-  while (offset)\n+  if (offset)\n     {\n-      tree next_offset;\n-\n-      if (TREE_CODE (offset) == PLUS_EXPR)\n-\t{\n-\t  next_offset = TREE_OPERAND (offset, 0);\n-\t  offset = TREE_OPERAND (offset, 1);\n-\t}\n-      else\n-\tnext_offset = NULL;\n-      if (host_integerp (offset, 1))\n-\t{\n-\t  /* Any overflow in calculating offset_bits won't change\n-\t     the alignment.  */\n-\t  unsigned offset_bits\n-\t    = ((unsigned) tree_low_cst (offset, 1) * BITS_PER_UNIT);\n-\n-\t  if (offset_bits)\n-\t    inner = MIN (inner, (offset_bits & -offset_bits));\n-\t}\n-      else if (TREE_CODE (offset) == MULT_EXPR\n-\t       && host_integerp (TREE_OPERAND (offset, 1), 1))\n-\t{\n-\t  /* Any overflow in calculating offset_factor won't change\n-\t     the alignment.  */\n-\t  unsigned offset_factor\n-\t    = ((unsigned) tree_low_cst (TREE_OPERAND (offset, 1), 1)\n-\t       * BITS_PER_UNIT);\n-\n-\t  if (offset_factor)\n-\t    inner = MIN (inner, (offset_factor & -offset_factor));\n-\t}\n-      else\n+      int trailing_zeros = tree_ctz (offset);\n+      if (trailing_zeros < HOST_BITS_PER_INT)\n \t{\n-\t  inner = MIN (inner, BITS_PER_UNIT);\n-\t  break;\n+\t  unsigned int inner = (1U << trailing_zeros) * BITS_PER_UNIT;\n+\t  if (inner)\n+\t    align = MIN (align, inner);\n \t}\n-      offset = next_offset;\n     }\n-  /* Alignment is innermost object alignment adjusted by the constant\n-     and non-constant offset parts.  */\n-  align = MIN (align, inner);\n \n   *alignp = align;\n   *bitposp = bitpos & (*alignp - 1);"}, {"sha": "551a66059b9a034a922063df90c1b48e6241de57", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 68, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -7283,74 +7283,14 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n unsigned HOST_WIDE_INT\n highest_pow2_factor (const_tree exp)\n {\n-  unsigned HOST_WIDE_INT c0, c1;\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    case INTEGER_CST:\n-      /* We can find the lowest bit that's a one.  If the low\n-\t HOST_BITS_PER_WIDE_INT bits are zero, return BIGGEST_ALIGNMENT.\n-\t We need to handle this case since we can find it in a COND_EXPR,\n-\t a MIN_EXPR, or a MAX_EXPR.  If the constant overflows, we have an\n-\t erroneous program, so return BIGGEST_ALIGNMENT to avoid any\n-\t later ICE.  */\n-      if (TREE_OVERFLOW (exp))\n-\treturn BIGGEST_ALIGNMENT;\n-      else\n-\t{\n-\t  /* Note: tree_low_cst is intentionally not used here,\n-\t     we don't care about the upper bits.  */\n-\t  c0 = TREE_INT_CST_LOW (exp);\n-\t  c0 &= -c0;\n-\t  return c0 ? c0 : BIGGEST_ALIGNMENT;\n-\t}\n-      break;\n-\n-    case PLUS_EXPR:  case MINUS_EXPR:  case MIN_EXPR:  case MAX_EXPR:\n-      c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n-      c1 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n-      return MIN (c0, c1);\n-\n-    case MULT_EXPR:\n-      c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n-      c1 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n-      return c0 * c1;\n-\n-    case ROUND_DIV_EXPR:  case TRUNC_DIV_EXPR:  case FLOOR_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-      if (integer_pow2p (TREE_OPERAND (exp, 1))\n-\t  && host_integerp (TREE_OPERAND (exp, 1), 1))\n-\t{\n-\t  c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n-\t  c1 = tree_low_cst (TREE_OPERAND (exp, 1), 1);\n-\t  return MAX (1, c0 / c1);\n-\t}\n-      break;\n-\n-    case BIT_AND_EXPR:\n-      /* The highest power of two of a bit-and expression is the maximum of\n-\t that of its operands.  We typically get here for a complex LHS and\n-\t a constant negative power of two on the RHS to force an explicit\n-\t alignment, so don't bother looking at the LHS.  */\n-      return highest_pow2_factor (TREE_OPERAND (exp, 1));\n-\n-    CASE_CONVERT:\n-    case SAVE_EXPR:\n-      return highest_pow2_factor (TREE_OPERAND (exp, 0));\n-\n-    case COMPOUND_EXPR:\n-      return highest_pow2_factor (TREE_OPERAND (exp, 1));\n-\n-    case COND_EXPR:\n-      c0 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n-      c1 = highest_pow2_factor (TREE_OPERAND (exp, 2));\n-      return MIN (c0, c1);\n-\n-    default:\n-      break;\n-    }\n-\n-  return 1;\n+  unsigned HOST_WIDE_INT ret;\n+  int trailing_zeros = tree_ctz (exp);\n+  if (trailing_zeros >= HOST_BITS_PER_WIDE_INT)\n+    return BIGGEST_ALIGNMENT;\n+  ret = (unsigned HOST_WIDE_INT) 1 << trailing_zeros;\n+  if (ret > BIGGEST_ALIGNMENT)\n+    return BIGGEST_ALIGNMENT;\n+  return ret;\n }\n \n /* Similar, except that the alignment requirements of TARGET are"}, {"sha": "763589125695ce9f4402e58aa41162e9c3d08f97", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -221,7 +221,7 @@ set_range_info (tree name, double_int min, double_int max)\n    is used to determine if MIN and MAX are valid values.  */\n \n enum value_range_type\n-get_range_info (tree name, double_int *min, double_int *max)\n+get_range_info (const_tree name, double_int *min, double_int *max)\n {\n   enum value_range_type range_type;\n   gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n@@ -271,7 +271,7 @@ set_nonzero_bits (tree name, double_int mask)\n    NAME, or double_int_minus_one if unknown.  */\n \n double_int\n-get_nonzero_bits (tree name)\n+get_nonzero_bits (const_tree name)\n {\n   if (POINTER_TYPE_P (TREE_TYPE (name)))\n     {"}, {"sha": "d0a654252111eae6776d5487d3925454a74fecb1", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -72,9 +72,10 @@ enum value_range_type { VR_UNDEFINED, VR_RANGE, VR_ANTI_RANGE, VR_VARYING };\n /* Sets the value range to SSA.  */\n extern void set_range_info (tree, double_int, double_int);\n /* Gets the value range from SSA.  */\n-extern enum value_range_type get_range_info (tree, double_int *, double_int *);\n+extern enum value_range_type get_range_info (const_tree, double_int *,\n+\t\t\t\t\t     double_int *);\n extern void set_nonzero_bits (tree, double_int);\n-extern double_int get_nonzero_bits (tree);\n+extern double_int get_nonzero_bits (const_tree);\n extern void init_ssanames (struct function *, int);\n extern void fini_ssanames (void);\n extern void ssanames_print_statistics (void);"}, {"sha": "00a3661385e0ca7cf2a440f0cd8fbeb94e0ac1b5", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -1437,7 +1437,7 @@ vect_build_loop_niters (loop_vec_info loop_vinfo, gimple_seq seq)\n  and places them at the loop preheader edge or in COND_EXPR_STMT_LIST\n  if that is non-NULL.  */\n \n-static void\n+void\n vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n \t\t\t\t tree *ni_name_ptr,\n \t\t\t\t tree *ratio_mult_vf_name_ptr,"}, {"sha": "1da87c7201e6f55dd0ff1349ab67bb62d292b937", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -1586,9 +1586,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       return false;\n     }\n \n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n-      || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+      || ((int) tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n+\t  < exact_log2 (vectorization_factor)))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required.\\n\");\n@@ -5656,15 +5656,20 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      will remain scalar and will compute the remaining (n%VF) iterations.\n      (VF is the vectorization factor).  */\n \n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-       || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n-       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+  if ((int) tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n+      < exact_log2 (vectorization_factor)\n+      || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     vect_do_peeling_for_loop_bound (loop_vinfo, &ratio,\n \t\t\t\t    th, check_profitability);\n-  else\n+  else if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n \t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);\n+  else\n+    {\n+      tree ni_name, ratio_mult_vf;\n+      vect_generate_tmps_on_preheader (loop_vinfo, &ni_name, &ratio_mult_vf,\n+\t\t\t\t       &ratio, NULL);\n+    }\n \n   /* 1) Make sure the loop header has exactly two entries\n      2) Make sure we have a preheader basic block.  */"}, {"sha": "a2f482ddad522e39d1ca62ce6e559671d742d294", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -901,6 +901,8 @@ extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n+extern void vect_generate_tmps_on_preheader (loop_vec_info, tree *, tree *,\n+\t\t\t\t\t     tree *, gimple_seq);\n extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n \t\t\t\t\t    unsigned int, bool);\n extern void vect_do_peeling_for_alignment (loop_vec_info, unsigned int, bool);"}, {"sha": "332751a3a786cc7167b8272ee879155a23b7444f", "filename": "gcc/tree.c", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -2214,6 +2214,119 @@ tree_floor_log2 (const_tree expr)\n \t  : floor_log2 (low));\n }\n \n+/* Return number of known trailing zero bits in EXPR, or, if the value of\n+   EXPR is known to be zero, the precision of it's type.  */\n+\n+unsigned int\n+tree_ctz (const_tree expr)\n+{\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+      && !POINTER_TYPE_P (TREE_TYPE (expr)))\n+    return 0;\n+\n+  unsigned int ret1, ret2, prec = TYPE_PRECISION (TREE_TYPE (expr));\n+  switch (TREE_CODE (expr))\n+    {\n+    case INTEGER_CST:\n+      ret1 = tree_to_double_int (expr).trailing_zeros ();\n+      return MIN (ret1, prec);\n+    case SSA_NAME:\n+      ret1 = get_nonzero_bits (expr).trailing_zeros ();\n+      return MIN (ret1, prec);\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+      if (ret1 == 0)\n+\treturn ret1;\n+      ret2 = tree_ctz (TREE_OPERAND (expr, 1));\n+      return MIN (ret1, ret2);\n+    case POINTER_PLUS_EXPR:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+      ret2 = tree_ctz (TREE_OPERAND (expr, 1));\n+      /* Second operand is sizetype, which could be in theory\n+\t wider than pointer's precision.  Make sure we never\n+\t return more than prec.  */\n+      ret2 = MIN (ret2, prec);\n+      return MIN (ret1, ret2);\n+    case BIT_AND_EXPR:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+      ret2 = tree_ctz (TREE_OPERAND (expr, 1));\n+      return MAX (ret1, ret2);\n+    case MULT_EXPR:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+      ret2 = tree_ctz (TREE_OPERAND (expr, 1));\n+      return MIN (ret1 + ret2, prec);\n+    case LSHIFT_EXPR:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+      if (host_integerp (TREE_OPERAND (expr, 1), 1)\n+\t  && ((unsigned HOST_WIDE_INT) tree_low_cst (TREE_OPERAND (expr, 1), 1)\n+\t      < (unsigned HOST_WIDE_INT) prec))\n+\t{\n+\t  ret2 = tree_low_cst (TREE_OPERAND (expr, 1), 1);\n+\t  return MIN (ret1 + ret2, prec);\n+\t}\n+      return ret1;\n+    case RSHIFT_EXPR:\n+      if (host_integerp (TREE_OPERAND (expr, 1), 1)\n+\t  && ((unsigned HOST_WIDE_INT) tree_low_cst (TREE_OPERAND (expr, 1), 1)\n+\t      < (unsigned HOST_WIDE_INT) prec))\n+\t{\n+\t  ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+\t  ret2 = tree_low_cst (TREE_OPERAND (expr, 1), 1);\n+\t  if (ret1 > ret2)\n+\t    return ret1 - ret2;\n+\t}\n+      return 0;\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n+\t  && tree_int_cst_sgn (TREE_OPERAND (expr, 1)) == 1)\n+\t{\n+\t  int l = tree_log2 (TREE_OPERAND (expr, 1));\n+\t  if (l >= 0)\n+\t    {\n+\t      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+\t      ret2 = l;\n+\t      if (ret1 > ret2)\n+\t\treturn ret1 - ret2;\n+\t    }\n+\t}\n+      return 0;\n+    CASE_CONVERT:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 0));\n+      if (ret1 && ret1 == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\tret1 = prec;\n+      return MIN (ret1, prec);\n+    case SAVE_EXPR:\n+      return tree_ctz (TREE_OPERAND (expr, 0));\n+    case COND_EXPR:\n+      ret1 = tree_ctz (TREE_OPERAND (expr, 1));\n+      if (ret1 == 0)\n+\treturn 0;\n+      ret2 = tree_ctz (TREE_OPERAND (expr, 2));\n+      return MIN (ret1, ret2);\n+    case COMPOUND_EXPR:\n+      return tree_ctz (TREE_OPERAND (expr, 1));\n+    case ADDR_EXPR:\n+      ret1 = get_pointer_alignment (CONST_CAST_TREE (expr));\n+      if (ret1 > BITS_PER_UNIT)\n+\t{\n+\t  ret1 = ctz_hwi (ret1 / BITS_PER_UNIT);\n+\t  return MIN (ret1, prec);\n+\t}\n+      return 0;\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Return 1 if EXPR is the real constant zero.  Trailing zeroes matter for\n    decimal float constants, so don't return 1 for them.  */\n "}, {"sha": "920ad07aadde4345b1ec88bcc4ac6b1795239a2d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae76e53d9f28035a072e2722ffafdd3ad913936/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=eae76e53d9f28035a072e2722ffafdd3ad913936", "patch": "@@ -4564,6 +4564,7 @@ extern void get_type_static_bounds (const_tree, mpz_t, mpz_t);\n extern bool variably_modified_type_p (tree, tree);\n extern int tree_log2 (const_tree);\n extern int tree_floor_log2 (const_tree);\n+extern unsigned int tree_ctz (const_tree);\n extern int simple_cst_equal (const_tree, const_tree);\n extern hashval_t iterative_hash_expr (const_tree, hashval_t);\n extern hashval_t iterative_hash_exprs_commutative (const_tree,"}]}