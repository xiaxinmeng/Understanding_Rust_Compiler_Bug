{"sha": "5a0aa603b2452dca48ad86d97d4b918187d259fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEwYWE2MDNiMjQ1MmRjYTQ4YWQ4NmQ5N2Q0YjkxODE4N2QyNTlmYw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-02T11:29:22Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-03T23:26:20Z"}, "message": "d: Merge upstream dmd 3b808e838, druntime 483bc129, phobos f89dc217a\n\nD front-end changes:\n\n - Explicit package visibility attribute is now always applied to\n   introducing scopes.\n\n - Added `__traits(totype, string)' to convert mangled type string to an\n   existing type.\n\n - Printf-like and scanf-like functions are now detected by prefixing\n   them with `pragma(printf)' for printf-like functions or\n   `pragma(scanf)' for scanf-like functions.\n\n - Added `__c_wchar_t', `__c_complex_float', `__c_complex_double', and\n   `__c_complex_real' types for interfacing with C and C++.\n\n - Template alias parameters can now be instantiated with basic types,\n   such as `int` or `void function()`.\n\n - Mixins can now be used as types in the form `mixin(string) var'.\n\n - Mixin expressions can take an argument list, same as `pragma(msg)'.\n\n - Implement DIP1034, add `typeof(*null)' types to represent `noreturn'.\n\n - `pragma(msg)' can print expressions of type `void'.\n\n - It is now an error to use private variables selectively imported from\n   other modules.  Due to a bug, some imported private members were\n   visible from other modules, violating the specification.\n\n - Added new syntax to declare an alias to a function type using the\n   `alias' syntax based on the assignment operator.\n\n - Function literals can now return a value by reference.\n\nPhobos changes:\n\n - Synchronize C bindings with the latest port fixes in upstream druntime.\n\n - Added alias for a `noreturn' type in object.d\n\n - Make use of the new `pragma(printf)' and `pragma(scanf)' pragmas, fix\n   all code that got flagged as being incorrect.\n\n - Fixed code that relied on bugs in the D import package system.\n\nReviewed-on: https://github.com/dlang/dmd/pull/12339\n\t     https://github.com/dlang/druntime/pull/3422\n\t     https://github.com/dlang/phobos/pull/7932\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 3b808e838.\n\t* Make-lang.in (D_FRONTEND_OBJS): Add d/chkformat.o.\n\t* d-codegen.cc (build_struct_literal): Handle special enums.\n\t* d-convert.cc (convert_expr): Handle noreturn type.\n\t(convert_for_condition): Likewise.\n\t* d-target.cc (Target::_init): Set type for wchar_t.\n\t(TargetCPP::derivedClassOffset): New method.\n\t(Target::libraryObjectMonitors): New method.\n\t* decl.cc (get_symbol_decl): Set TREE_THIS_VOLATILE for functions of\n\ttype noreturn.\n\t* toir.cc (IRVisitor::visit (ReturnStatement *)): Handle returning\n\tnoreturn types.\n\t* types.cc (TypeVisitor::visit (TypeNoreturn *)): New method.\n\t(TypeVisitor::visit (TypeEnum *)): Handle special enums.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 483bc129.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES_DARWIN): Add\n\tcore/sys/darwin/fcntl.d.\n\t(DRUNTIME_DSOURCES_OPENBSD): Add core/sys/openbsd/unistd.d.\n\t(DRUNTIME_DSOURCES_WINDOWS): Add core/sys/windows/stdc/malloc.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos f89dc217a.\n\t* src/Makefile.am (PHOBOS_DSOURCES): Add std/regex/internal/tests2.d.\n\t* src/Makefile.in: Regenerate.\n\t* testsuite/libphobos.exceptions/chain.d: Fix format arguments.\n\t* testsuite/libphobos.exceptions/line_trace.d: Likewise.", "tree": {"sha": "67439099b8129248a45826b5791912b20ff3c3fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67439099b8129248a45826b5791912b20ff3c3fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a0aa603b2452dca48ad86d97d4b918187d259fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0aa603b2452dca48ad86d97d4b918187d259fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0aa603b2452dca48ad86d97d4b918187d259fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0aa603b2452dca48ad86d97d4b918187d259fc/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba0f6902666430e5d065a92b3d5292cba91813d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba0f6902666430e5d065a92b3d5292cba91813d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba0f6902666430e5d065a92b3d5292cba91813d3"}], "stats": {"total": 11757, "additions": 7657, "deletions": 4100}, "files": [{"sha": "b3c77a08f462c7acf559b9ac300c29e91c88e6ed", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -64,6 +64,7 @@ D_FRONTEND_OBJS = \\\n \td/blockexit.o \\\n \td/canthrow.o \\\n \td/checkedint.o \\\n+\td/chkformat.o \\\n \td/clone.o \\\n \td/cond.o \\\n \td/constfold.o \\"}, {"sha": "608abcd94f5ff6e39aba605f4c4f4d0f1eb9b19b", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1153,6 +1153,14 @@ build_struct_literal (tree type, vec <constructor_elt, va_gc> *init)\n   if (vec_safe_is_empty (init))\n     return build_constructor (type, NULL);\n \n+  /* Struct literals can be seen for special enums representing `_Complex',\n+     make sure to reinterpret the literal as the correct type.  */\n+  if (COMPLEX_FLOAT_TYPE_P (type))\n+    {\n+      gcc_assert (vec_safe_length (init) == 2);\n+      return build_complex (type, (*init)[0].value, (*init)[1].value);\n+    }\n+\n   vec <constructor_elt, va_gc> *ve = NULL;\n   HOST_WIDE_INT offset = 0;\n   bool constant_p = true;"}, {"sha": "3073edaae9f9c4f2f6409cc38012c6f9601c091e", "filename": "gcc/d/d-convert.cc", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fd-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fd-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-convert.cc?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -559,7 +559,9 @@ convert_expr (tree exp, Type *etype, Type *totype)\n       break;\n \n     case Tnull:\n-      /* Casting from typeof(null) is represented as all zeros.  */\n+    case Tnoreturn:\n+      /* Casting from `typeof(null)' for `null' expressions, or `typeof(*null)'\n+\t for `noreturn' expressions is represented as all zeros.  */\n       result = build_typeof_null_value (totype);\n \n       /* Make sure the expression is still evaluated if necessary.  */\n@@ -742,6 +744,16 @@ convert_for_condition (tree expr, Type *type)\n \tbreak;\n       }\n \n+    case Tnoreturn:\n+      /* Front-end allows conditionals that never return, represent the\n+\t conditional result value as all zeros.  */\n+      result = build_zero_cst (d_bool_type);\n+\n+      /* Make sure the expression is still evaluated if necessary.  */\n+      if (TREE_SIDE_EFFECTS (expr))\n+\tresult = compound_expr (expr, result);\n+      break;\n+\n     default:\n       result = expr;\n       break;"}, {"sha": "a1dc2ee286f0ec27a3c26e48cba226145b8f1a0d", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -164,6 +164,15 @@ Target::_init (const Param &)\n   this->c.longsize = int_size_in_bytes (long_integer_type_node);\n   this->c.long_doublesize = int_size_in_bytes (long_double_type_node);\n \n+  /* Define what type to use for wchar_t.  We don't want to support wide\n+     characters less than \"short\" in D.  */\n+  if (WCHAR_TYPE_SIZE == 32)\n+    this->c.twchar_t = Type::basic[Tdchar];\n+  else if (WCHAR_TYPE_SIZE == 16)\n+    this->c.twchar_t = Type::basic[Twchar];\n+  else\n+    sorry (\"D does not support wide characters on this target.\");\n+\n   /* Set-up target C++ ABI.  */\n   this->cpp.reverseOverloads = false;\n   this->cpp.exceptions = true;\n@@ -417,6 +426,15 @@ TargetCPP::fundamentalType (const Type *, bool &)\n   return false;\n }\n \n+/* Get the starting offset position for fields of an `extern(C++)` class\n+   that is derived from the given BASE_CLASS.  */\n+\n+unsigned\n+TargetCPP::derivedClassOffset(ClassDeclaration *base_class)\n+{\n+  return base_class->structsize;\n+}\n+\n /* Return the default system linkage for the target.  */\n \n LINK\n@@ -517,3 +535,13 @@ Target::getTargetInfo (const char *key, const Loc &loc)\n \n   return NULL;\n }\n+\n+/**\n+ * Returns true if the implementation for object monitors is always defined\n+ * in the D runtime library (rt/monitor_.d).  */\n+\n+bool\n+Target::libraryObjectMonitors (FuncDeclaration *, Statement *)\n+{\n+  return true;\n+}"}, {"sha": "0ec19345272e3e1e434b549af09546479827d56f", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1277,6 +1277,10 @@ get_symbol_decl (Declaration *decl)\n       if (decl->storage_class & STCfinal)\n \tDECL_FINAL_P (decl->csym) = 1;\n \n+      /* Function is of type `noreturn' or `typeof(*null)'.  */\n+      if (fd->type->nextOf ()->ty == Tnoreturn)\n+\tTREE_THIS_VOLATILE (decl->csym) = 1;\n+\n       /* Check whether this function is expanded by the frontend.  */\n       DECL_INTRINSIC_CODE (decl->csym) = INTRINSIC_NONE;\n       maybe_set_intrinsic (fd);"}, {"sha": "86475c80d35e6af1a8b0132a0ba4308adfc91381", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,4 +1,4 @@\n-a3c9bf422e7ff54d45846b8c577ee82da4234db1\n+3b808e838bb00f527eb4ed5281cd985756237b8f\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "a808b8a6c3fb722389cd2a054e629f0afa0eb49f", "filename": "gcc/d/dmd/attrib.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fattrib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fattrib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -80,8 +80,8 @@ Scope *AttribDeclaration::createNewScope(Scope *sc,\n     if (stc != sc->stc ||\n         linkage != sc->linkage ||\n         cppmangle != sc->cppmangle ||\n-        !protection.isSubsetOf(sc->protection) ||\n         explicitProtection != sc->explicitProtection ||\n+        !(protection == sc->protection) ||\n         aligndecl != sc->aligndecl ||\n         inlining != sc->inlining)\n     {\n@@ -552,10 +552,21 @@ void ProtDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n     if (protection.kind == Prot::package_ && protection.pkg && sc->_module)\n     {\n         Module *m = sc->_module;\n-        Package* pkg = m->parent ? m->parent->isPackage() : NULL;\n-        if (!pkg || !protection.pkg->isAncestorPackageOf(pkg))\n-            error(\"does not bind to one of ancestor packages of module `%s`\",\n-               m->toPrettyChars(true));\n+\n+        // While isAncestorPackageOf does an equality check, the fix for issue 17441 adds a check to see if\n+        // each package's .isModule() properites are equal.\n+        //\n+        // Properties generated from `package(foo)` i.e. protection.pkg have .isModule() == null.\n+        // This breaks package declarations of the package in question if they are declared in\n+        // the same package.d file, which _do_ have a module associated with them, and hence a non-null\n+        // isModule()\n+        if (!m->isPackage() || !protection.pkg->ident->equals(m->isPackage()->ident))\n+        {\n+            Package* pkg = m->parent ? m->parent->isPackage() : NULL;\n+            if (!pkg || !protection.pkg->isAncestorPackageOf(pkg))\n+                error(\"does not bind to one of ancestor packages of module `%s`\",\n+                      m->toPrettyChars(true));\n+        }\n     }\n \n     return AttribDeclaration::addMember(sc, sds);\n@@ -795,6 +806,18 @@ Scope *PragmaDeclaration::newScope(Scope *sc)\n             sc->protection, sc->explicitProtection, sc->aligndecl,\n             inlining);\n     }\n+    if (ident == Id::printf || ident == Id::scanf)\n+    {\n+        Scope *sc2 = sc->push();\n+\n+        if (ident == Id::printf)\n+            // Override previous setting, never let both be set\n+            sc2->flags = (sc2->flags & ~SCOPEscanf) | SCOPEprintf;\n+        else\n+            sc2->flags = (sc2->flags & ~SCOPEprintf) | SCOPEscanf;\n+\n+        return sc2;\n+    }\n     return sc;\n }\n \n@@ -1164,20 +1187,20 @@ void ForwardingAttribDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n \n // These are mixin declarations, like mixin(\"int x\");\n \n-CompileDeclaration::CompileDeclaration(Loc loc, Expression *exp)\n+CompileDeclaration::CompileDeclaration(Loc loc, Expressions *exps)\n     : AttribDeclaration(NULL)\n {\n     //printf(\"CompileDeclaration(loc = %d)\\n\", loc.linnum);\n     this->loc = loc;\n-    this->exp = exp;\n+    this->exps = exps;\n     this->scopesym = NULL;\n     this->compiled = false;\n }\n \n Dsymbol *CompileDeclaration::syntaxCopy(Dsymbol *)\n {\n     //printf(\"CompileDeclaration::syntaxCopy('%s')\\n\", toChars());\n-    return new CompileDeclaration(loc, exp->syntaxCopy());\n+    return new CompileDeclaration(loc, Expression::arraySyntaxCopy(exps));\n }\n \n void CompileDeclaration::addMember(Scope *, ScopeDsymbol *sds)"}, {"sha": "174d3c1ad5b0f2eba78ede0f55d52b8ad112854d", "filename": "gcc/d/dmd/attrib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fattrib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fattrib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -234,12 +234,12 @@ class ForwardingAttribDeclaration : public AttribDeclaration\n class CompileDeclaration : public AttribDeclaration\n {\n public:\n-    Expression *exp;\n+    Expressions *exps;\n \n     ScopeDsymbol *scopesym;\n     bool compiled;\n \n-    CompileDeclaration(Loc loc, Expression *exp);\n+    CompileDeclaration(Loc loc, Expressions *exps);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);"}, {"sha": "1895d36fb1ebcafa6301dddb3071e3eadf589a30", "filename": "gcc/d/dmd/blockexit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fblockexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fblockexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -62,6 +62,8 @@ int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow)\n                         return;\n                     }\n                 }\n+                if (s->exp->type->toBasetype()->isTypeNoreturn())\n+                    result = BEhalt;\n                 if (canThrow(s->exp, func, mustNotThrow))\n                     result |= BEthrow;\n             }"}, {"sha": "d00b658ca00d223583bb40c3a9f59f44dadcb5d3", "filename": "gcc/d/dmd/chkformat.c", "status": "added", "additions": 975, "deletions": 0, "changes": 975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fchkformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fchkformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,975 @@\n+\n+/* Compiler implementation of the D programming language\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * written by Walter Bright\n+ * http://www.digitalmars.com\n+ * Distributed under the Boost Software License, Version 1.0.\n+ * http://www.boost.org/LICENSE_1_0.txt\n+ */\n+\n+// Check the arguments to `printf` and `scanf` against the `format` string.\n+\n+#include \"root/dsystem.h\"\n+#include \"root/dcompat.h\"\n+\n+#include \"arraytypes.h\"\n+#include \"cond.h\"\n+#include \"errors.h\"\n+#include \"expression.h\"\n+#include \"globals.h\"\n+#include \"identifier.h\"\n+#include \"mtype.h\"\n+#include \"target.h\"\n+\n+\n+/* Different kinds of formatting specifications, variations we don't\n+   care about are merged. (Like we don't care about the difference between\n+   f, e, g, a, etc.)\n+\n+   For `scanf`, every format is a pointer.\n+ */\n+enum Format\n+{\n+    Format_d,          // int\n+    Format_hhd,        // signed char\n+    Format_hd,         // short int\n+    Format_ld,         // long int\n+    Format_lld,        // long long int\n+    Format_jd,         // intmax_t\n+    Format_zd,         // size_t\n+    Format_td,         // ptrdiff_t\n+    Format_u,          // unsigned int\n+    Format_hhu,        // unsigned char\n+    Format_hu,         // unsigned short int\n+    Format_lu,         // unsigned long int\n+    Format_llu,        // unsigned long long int\n+    Format_ju,         // uintmax_t\n+    Format_g,          // float (scanf) / double (printf)\n+    Format_lg,         // double (scanf)\n+    Format_Lg,         // long double (both)\n+    Format_s,          // char string (both)\n+    Format_ls,         // wchar_t string (both)\n+    Format_c,          // char (printf)\n+    Format_lc,         // wint_t (printf)\n+    Format_p,          // pointer\n+    Format_n,          // pointer to int\n+    Format_hhn,        // pointer to signed char\n+    Format_hn,         // pointer to short\n+    Format_ln,         // pointer to long int\n+    Format_lln,        // pointer to long long int\n+    Format_jn,         // pointer to intmax_t\n+    Format_zn,         // pointer to size_t\n+    Format_tn,         // pointer to ptrdiff_t\n+    Format_GNU_a,      // GNU ext. : address to a string with no maximum size (scanf)\n+    Format_GNU_m,      // GNU ext. : string corresponding to the error code in errno (printf) / length modifier (scanf)\n+    Format_percent,    // %% (i.e. no argument)\n+    Format_error,      // invalid format specification\n+};\n+\n+/**************************************\n+ * Parse the *length specifier* and the *specifier* of the following form:\n+ * `[length]specifier`\n+ *\n+ * Params:\n+ *      format = format string\n+ *      idx = index of of start of format specifier,\n+ *          which gets updated to index past the end of it,\n+ *          even if `Format_error` is returned\n+ *      genSpecifier = Generic specifier. For instance, it will be set to `d` if the\n+ *           format is `hdd`.\n+ * Returns:\n+ *      Format\n+ */\n+static Format parseGenericFormatSpecifier(const char *format,\n+            size_t &idx, char &genSpecifier, bool useGNUExts =\n+            findCondition(global.versionids, Identifier::idPool(\"CRuntime_Glibc\")))\n+{\n+    genSpecifier = 0;\n+\n+    const size_t length = strlen(format);\n+\n+    /* Read the `length modifier`\n+     */\n+    const char lm = format[idx];\n+    bool lm1= false;        // if jztL\n+    bool lm2= false;        // if `hh` or `ll`\n+    if (lm == 'j' ||\n+        lm == 'z' ||\n+        lm == 't' ||\n+        lm == 'L')\n+    {\n+        ++idx;\n+        if (idx == length)\n+            return Format_error;\n+        lm1 = true;\n+    }\n+    else if (lm == 'h' || lm == 'l')\n+    {\n+        ++idx;\n+        if (idx == length)\n+            return Format_error;\n+        lm2 = lm == format[idx];\n+        if (lm2)\n+        {\n+            ++idx;\n+            if (idx == length)\n+                return Format_error;\n+        }\n+    }\n+\n+    /* Read the `specifier`\n+     */\n+    Format specifier;\n+    const char sc = format[idx];\n+    genSpecifier = sc;\n+    switch (sc)\n+    {\n+        case 'd':\n+        case 'i':\n+            if (lm == 'L')\n+                specifier = Format_error;\n+            else\n+                specifier = lm == 'h' && lm2 ? Format_hhd :\n+                            lm == 'h'        ? Format_hd  :\n+                            lm == 'l' && lm2 ? Format_lld :\n+                            lm == 'l'        ? Format_ld  :\n+                            lm == 'j'        ? Format_jd  :\n+                            lm == 'z'        ? Format_zd  :\n+                            lm == 't'        ? Format_td  :\n+                                               Format_d;\n+            break;\n+\n+        case 'u':\n+        case 'o':\n+        case 'x':\n+        case 'X':\n+            if (lm == 'L')\n+                specifier = Format_error;\n+            else\n+                specifier = lm == 'h' && lm2 ? Format_hhu :\n+                            lm == 'h'        ? Format_hu  :\n+                            lm == 'l' && lm2 ? Format_llu :\n+                            lm == 'l'        ? Format_lu  :\n+                            lm == 'j'        ? Format_ju  :\n+                            lm == 'z'        ? Format_zd  :\n+                            lm == 't'        ? Format_td  :\n+                                               Format_u;\n+            break;\n+\n+        case 'a':\n+            if (useGNUExts)\n+            {\n+                // https://www.gnu.org/software/libc/manual/html_node/Dynamic-String-Input.html\n+                specifier = Format_GNU_a;\n+                break;\n+            }\n+            /* fall through */\n+\n+        case 'f':\n+        case 'F':\n+        case 'e':\n+        case 'E':\n+        case 'g':\n+        case 'G':\n+        case 'A':\n+            if (lm == 'L')\n+                specifier = Format_Lg;\n+            else if (lm1 || lm2 || lm == 'h')\n+                specifier = Format_error;\n+            else\n+                specifier = lm == 'l' ? Format_lg : Format_g;\n+            break;\n+\n+        case 'c':\n+            if (lm1 || lm2 || lm == 'h')\n+                specifier = Format_error;\n+            else\n+                specifier = lm == 'l' ? Format_lc : Format_c;\n+            break;\n+\n+        case 's':\n+            if (lm1 || lm2 || lm == 'h')\n+                specifier = Format_error;\n+            else\n+                specifier = lm == 'l' ? Format_ls : Format_s;\n+            break;\n+\n+        case 'p':\n+            if (lm1 || lm2 || lm == 'h' || lm == 'l')\n+                specifier = Format_error;\n+            else\n+                specifier = Format_p;\n+            break;\n+\n+        case 'n':\n+            if (lm == 'L')\n+                specifier = Format_error;\n+            else\n+                specifier = lm == 'l' && lm2 ? Format_lln :\n+                            lm == 'l'        ? Format_ln  :\n+                            lm == 'h' && lm2 ? Format_hhn :\n+                            lm == 'h'        ? Format_hn  :\n+                            lm == 'j'        ? Format_jn  :\n+                            lm == 'z'        ? Format_zn  :\n+                            lm == 't'        ? Format_tn  :\n+                                               Format_n;\n+            break;\n+\n+        case 'm':\n+            if (useGNUExts)\n+            {\n+                // http://www.gnu.org/software/libc/manual/html_node/Other-Output-Conversions.html\n+                specifier = Format_GNU_m;\n+                break;\n+            }\n+            goto Ldefault;\n+\n+        default:\n+        Ldefault:\n+            specifier = Format_error;\n+            break;\n+    }\n+\n+    ++idx;\n+    return specifier; // success\n+}\n+\n+Format formatError(size_t &idx, size_t i)\n+{\n+    idx = i;\n+    return Format_error;\n+}\n+\n+/**************************************\n+ * Parse the *format specifier* which is of the form:\n+ *\n+ * `%[*][width][length]specifier`\n+ *\n+ * Params:\n+ *      format = format string\n+ *      idx = index of `%` of start of format specifier,\n+ *          which gets updated to index past the end of it,\n+ *          even if `Format_error` is returned\n+ *      asterisk = set if there is a `*` sub-specifier\n+ * Returns:\n+ *      Format\n+ */\n+static Format parseScanfFormatSpecifier(const char *format, size_t &idx,\n+                bool &asterisk)\n+{\n+    asterisk = false;\n+\n+    size_t i = idx;\n+    assert(format[i] == '%');\n+    const size_t length = strlen(format);\n+\n+    ++i;\n+    if (i == length)\n+        return formatError(idx, i);\n+\n+    if (format[i] == '%')\n+    {\n+        idx = i + 1;\n+        return Format_percent;\n+    }\n+\n+    // * sub-specifier\n+    if (format[i] == '*')\n+    {\n+        ++i;\n+        if (i == length)\n+            return formatError(idx, i);\n+        asterisk = true;\n+    }\n+\n+    // fieldWidth\n+    while (isdigit(format[i]))\n+    {\n+        i++;\n+        if (i == length)\n+            return formatError(idx, i);\n+    }\n+\n+    /* Read the scanset\n+     * A scanset can be anything, so we just check that it is paired\n+     */\n+    if (format[i] == '[')\n+    {\n+        while (i < length)\n+        {\n+            if (format[i] == ']')\n+                break;\n+            ++i;\n+        }\n+\n+        // no `]` found\n+        if (i == length)\n+            return formatError(idx, i);\n+\n+        ++i;\n+        // no specifier after `]`\n+        // it could be mixed with the one above, but then idx won't have the right index\n+        if (i == length)\n+            return formatError(idx, i);\n+    }\n+\n+    /* Read the specifier\n+     */\n+    char genSpec;\n+    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n+    if (specifier == Format_error)\n+        return formatError(idx, i);\n+\n+    idx = i;\n+    return specifier;  // success\n+}\n+\n+/**************************************\n+ * Parse the *format specifier* which is of the form:\n+ *\n+ * `%[flags][field width][.precision][length modifier]specifier`\n+ *\n+ * Params:\n+ *      format = format string\n+ *      idx = index of `%` of start of format specifier,\n+ *          which gets updated to index past the end of it,\n+ *          even if `Format_error` is returned\n+ *      widthStar = set if * for width\n+ *      precisionStar = set if * for precision\n+ * Returns:\n+ *      Format\n+ */\n+static Format parsePrintfFormatSpecifier(const char *format, size_t &idx,\n+                bool &widthStar, bool &precisionStar)\n+{\n+    widthStar = false;\n+    precisionStar = false;\n+\n+    size_t i = idx;\n+    assert(format[i] == '%');\n+    const size_t format_length = strlen(format);\n+    const size_t length = format_length;\n+    bool hash = false;\n+    bool zero = false;\n+    bool flags = false;\n+    bool width = false;\n+    bool precision = false;\n+\n+    ++i;\n+    if (i == length)\n+        return formatError(idx, i);\n+\n+    if (format[i] == '%')\n+    {\n+        idx = i + 1;\n+        return Format_percent;\n+    }\n+\n+    /* Read the `flags`\n+     */\n+    while (1)\n+    {\n+        const char c = format[i];\n+        if (c == '-' ||\n+            c == '+' ||\n+            c == ' ')\n+        {\n+            flags = true;\n+        }\n+        else if (c == '#')\n+        {\n+            hash = true;\n+        }\n+        else if (c == '0')\n+        {\n+            zero = true;\n+        }\n+        else\n+            break;\n+        ++i;\n+        if (i == length)\n+            return formatError(idx, i);\n+    }\n+\n+    /* Read the `field width`\n+     */\n+    {\n+        const char c = format[i];\n+        if (c == '*')\n+        {\n+            width = true;\n+            widthStar = true;\n+            ++i;\n+            if (i == length)\n+                return formatError(idx, i);\n+        }\n+        else if ('1' <= c && c <= '9')\n+        {\n+            width = true;\n+            ++i;\n+            if (i == length)\n+                return formatError(idx, i);\n+            while ('0' <= format[i] && format[i] <= '9')\n+            {\n+               ++i;\n+               if (i == length)\n+                    return formatError(idx, i);\n+            }\n+        }\n+    }\n+\n+    /* Read the `precision`\n+     */\n+    if (format[i] == '.')\n+    {\n+        precision = true;\n+        ++i;\n+        if (i == length)\n+            return formatError(idx, i);\n+        const char c = format[i];\n+        if (c == '*')\n+        {\n+            precisionStar = true;\n+            ++i;\n+            if (i == length)\n+                return formatError(idx, i);\n+        }\n+        else if ('0' <= c && c <= '9')\n+        {\n+            ++i;\n+            if (i == length)\n+                return formatError(idx, i);\n+            while ('0' <= format[i] && format[i] <= '9')\n+            {\n+               ++i;\n+               if (i == length)\n+                    return formatError(idx, i);\n+            }\n+        }\n+    }\n+\n+    /* Read the specifier\n+     */\n+    char genSpec;\n+    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n+    if (specifier == Format_error)\n+        return formatError(idx, i);\n+\n+    switch (genSpec)\n+    {\n+        case 'c':\n+        case 's':\n+            if (hash || zero)\n+                return formatError(idx, i);\n+            break;\n+\n+        case 'd':\n+        case 'i':\n+            if (hash)\n+                return formatError(idx, i);\n+            break;\n+\n+        case 'n':\n+            if (hash || zero || precision || width || flags)\n+                return formatError(idx, i);\n+            break;\n+\n+        default:\n+            break;\n+    }\n+\n+    idx = i;\n+    return specifier;  // success\n+}\n+\n+/*******************************************/\n+\n+static Expression *getNextPrintfArg(const Loc &loc, Expressions &args, size_t &n,\n+                size_t gnu_m_count, bool &skip)\n+{\n+    if (n == args.length)\n+    {\n+        if (args.length < (n + 1) - gnu_m_count)\n+            deprecation(loc, \"more format specifiers than %d arguments\", (int)n);\n+        else\n+            skip = true;\n+        return NULL;\n+    }\n+    return args[n++];\n+}\n+\n+static void errorPrintfFormat(const char *prefix, DString &slice, Expression *arg,\n+                const char *texpect, Type *tactual)\n+{\n+    deprecation(arg->loc, \"%sargument `%s` for format specification `\\\"%.*s\\\"` must be `%s`, not `%s`\",\n+                prefix ? prefix : \"\", arg->toChars(), (int)slice.length, slice.ptr, texpect, tactual->toChars());\n+}\n+\n+/******************************************\n+ * Check that arguments to a printf format string are compatible\n+ * with that string. Issue errors for incompatibilities.\n+ *\n+ * Follows the C99 specification for printf.\n+ *\n+ * Takes a generous, rather than strict, view of compatiblity.\n+ * For example, an unsigned value can be formatted with a signed specifier.\n+ *\n+ * Diagnosed incompatibilities are:\n+ *\n+ * 1. incompatible sizes which will cause argument misalignment\n+ * 2. deferencing arguments that are not pointers\n+ * 3. insufficient number of arguments\n+ * 4. struct arguments\n+ * 5. array and slice arguments\n+ * 6. non-pointer arguments to `s` specifier\n+ * 7. non-standard formats\n+ * 8. undefined behavior per C99\n+ *\n+ * Per the C Standard, extra arguments are ignored.\n+ *\n+ * No attempt is made to fix the arguments or the format string.\n+ *\n+ * Params:\n+ *      loc = location for error messages\n+ *      format = format string\n+ *      args = arguments to match with format string\n+ *      isVa_list = if a \"v\" function (format check only)\n+ *\n+ * Returns:\n+ *      `true` if errors occurred\n+ * References:\n+ * C99 7.19.6.1\n+ * http://www.cplusplus.com/reference/cstdio/printf/\n+ */\n+bool checkPrintfFormat(const Loc &loc, const char *format, Expressions &args, bool isVa_list)\n+{\n+    //printf(\"checkPrintFormat('%s')\\n\", format);\n+    size_t n = 0;             // index in args\n+    size_t gnu_m_count = 0;   // number of Format_GNU_m\n+    const size_t format_length = strlen(format);\n+    for (size_t i = 0; i < format_length;)\n+    {\n+        if (format[i] != '%')\n+        {\n+            ++i;\n+            continue;\n+        }\n+        bool widthStar = false;\n+        bool precisionStar = false;\n+        size_t j = i;\n+        const Format fmt = parsePrintfFormatSpecifier(format, j, widthStar, precisionStar);\n+        DString slice = DString(j - i, format + i);\n+        i = j;\n+\n+        if (fmt == Format_percent)\n+            continue;                   // \"%%\", no arguments\n+\n+        if (isVa_list)\n+        {\n+            // format check only\n+            if (fmt == Format_error)\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n+            continue;\n+        }\n+\n+        if (fmt == Format_GNU_m)\n+            ++gnu_m_count;\n+\n+        if (widthStar)\n+        {\n+            bool skip = false;\n+            Expression *e = getNextPrintfArg(loc, args, n, gnu_m_count, skip);\n+            if (skip)\n+                continue;\n+            if (!e)\n+                return true;\n+            Type *t = e->type->toBasetype();\n+            if (t->ty != Tint32 && t->ty != Tuns32)\n+                errorPrintfFormat(\"width \", slice, e, \"int\", t);\n+        }\n+\n+        if (precisionStar)\n+        {\n+            bool skip = false;\n+            Expression *e = getNextPrintfArg(loc, args, n, gnu_m_count, skip);\n+            if (skip)\n+                continue;\n+            if (!e)\n+                return true;\n+            Type *t = e->type->toBasetype();\n+            if (t->ty != Tint32 && t->ty != Tuns32)\n+                errorPrintfFormat(\"precision \", slice, e, \"int\", t);\n+        }\n+\n+        bool skip = false;\n+        Expression *e = getNextPrintfArg(loc, args, n, gnu_m_count, skip);\n+        if (skip)\n+            continue;\n+        if (!e)\n+            return true;\n+        Type *t = e->type->toBasetype();\n+        Type *tnext = t->nextOf();\n+        const unsigned c_longsize = target.c.longsize;\n+        const bool is64bit = global.params.is64bit;\n+\n+        // Types which are promoted to int are allowed.\n+        // Spec: C99 6.5.2.2.7\n+        switch (fmt)\n+        {\n+            case Format_u:      // unsigned int\n+            case Format_d:      // int\n+                if (t->ty != Tint32 && t->ty != Tuns32)\n+                    errorPrintfFormat(NULL, slice, e, \"int\", t);\n+                break;\n+\n+            case Format_hhu:    // unsigned char\n+            case Format_hhd:    // signed char\n+                if (t->ty != Tint32 && t->ty != Tuns32 && t->ty != Tint8 && t->ty != Tuns8)\n+                    errorPrintfFormat(NULL, slice, e, \"byte\", t);\n+                break;\n+\n+            case Format_hu:     // unsigned short int\n+            case Format_hd:     // short int\n+                if (t->ty != Tint32 && t->ty != Tuns32 && t->ty != Tint16 && t->ty != Tuns16)\n+                    errorPrintfFormat(NULL, slice, e, \"short\", t);\n+                break;\n+\n+            case Format_lu:     // unsigned long int\n+            case Format_ld:     // long int\n+                if (!(t->isintegral() && t->size() == c_longsize))\n+                    errorPrintfFormat(NULL, slice, e, (c_longsize == 4 ? \"int\" : \"long\"), t);\n+                break;\n+\n+            case Format_llu:    // unsigned long long int\n+            case Format_lld:    // long long int\n+                if (t->ty != Tint64 && t->ty != Tuns64)\n+                    errorPrintfFormat(NULL, slice, e, \"long\", t);\n+                break;\n+\n+            case Format_ju:     // uintmax_t\n+            case Format_jd:     // intmax_t\n+                if (t->ty != Tint64 && t->ty != Tuns64)\n+                    errorPrintfFormat(NULL, slice, e, \"core.stdc.stdint.intmax_t\", t);\n+                break;\n+\n+            case Format_zd:     // size_t\n+                if (!(t->isintegral() && t->size() == (is64bit ? 8 : 4)))\n+                    errorPrintfFormat(NULL, slice, e, \"size_t\", t);\n+                break;\n+\n+            case Format_td:     // ptrdiff_t\n+                if (!(t->isintegral() && t->size() == (is64bit ? 8 : 4)))\n+                    errorPrintfFormat(NULL, slice, e, \"ptrdiff_t\", t);\n+                break;\n+\n+            case Format_GNU_a:  // Format_GNU_a is only for scanf\n+            case Format_lg:\n+            case Format_g:      // double\n+                if (t->ty != Tfloat64 && t->ty != Timaginary64)\n+                    errorPrintfFormat(NULL, slice, e, \"double\", t);\n+                break;\n+\n+            case Format_Lg:     // long double\n+                if (t->ty != Tfloat80 && t->ty != Timaginary80)\n+                    errorPrintfFormat(NULL, slice, e, \"real\", t);\n+                break;\n+\n+            case Format_p:      // pointer\n+                if (t->ty != Tpointer && t->ty != Tnull && t->ty != Tclass && t->ty != Tdelegate && t->ty != Taarray)\n+                    errorPrintfFormat(NULL, slice, e, \"void*\", t);\n+                break;\n+\n+            case Format_n:      // pointer to int\n+                if (!(t->ty == Tpointer && tnext->ty == Tint32))\n+                    errorPrintfFormat(NULL, slice, e, \"int*\", t);\n+                break;\n+\n+            case Format_ln:     // pointer to long int\n+                if (!(t->ty == Tpointer && tnext->isintegral() && tnext->size() == c_longsize))\n+                    errorPrintfFormat(NULL, slice, e, (c_longsize == 4 ? \"int*\" : \"long*\"), t);\n+                break;\n+\n+            case Format_lln:    // pointer to long long int\n+                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n+                    errorPrintfFormat(NULL, slice, e, \"long*\", t);\n+                break;\n+\n+            case Format_hn:     // pointer to short\n+                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n+                    errorPrintfFormat(NULL, slice, e, \"short*\", t);\n+                break;\n+\n+            case Format_hhn:    // pointer to signed char\n+                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n+                    errorPrintfFormat(NULL, slice, e, \"byte*\", t);\n+                break;\n+\n+            case Format_jn:     // pointer to intmax_t\n+                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n+                    errorPrintfFormat(NULL, slice, e, \"core.stdc.stdint.intmax_t*\", t);\n+                break;\n+\n+            case Format_zn:     // pointer to size_t\n+                if (!(t->ty == Tpointer && tnext->ty == (is64bit ? Tuns64 : Tuns32)))\n+                    errorPrintfFormat(NULL, slice, e, \"size_t*\", t);\n+                break;\n+\n+            case Format_tn:     // pointer to ptrdiff_t\n+                if (!(t->ty == Tpointer && tnext->ty == (is64bit ? Tint64 : Tint32)))\n+                    errorPrintfFormat(NULL, slice, e, \"ptrdiff_t*\", t);\n+                break;\n+\n+            case Format_c:      // char\n+                if (t->ty != Tint32 && t->ty != Tuns32)\n+                    errorPrintfFormat(NULL, slice, e, \"char\", t);\n+                break;\n+\n+            case Format_lc:     // wint_t\n+                if (t->ty != Tint32 && t->ty != Tuns32)\n+                    errorPrintfFormat(NULL, slice, e, \"wchar_t\", t);\n+                break;\n+\n+            case Format_s:      // pointer to char string\n+                if (!(t->ty == Tpointer && (tnext->ty == Tchar || tnext->ty == Tint8 || tnext->ty == Tuns8)))\n+                    errorPrintfFormat(NULL, slice, e, \"char*\", t);\n+                break;\n+\n+            case Format_ls:     // pointer to wchar_t string\n+            {\n+                if (!(t->ty == Tpointer && tnext == target.c.twchar_t))\n+                    errorPrintfFormat(NULL, slice, e, \"wchar_t*\", t);\n+                break;\n+            }\n+            case Format_error:\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n+                break;\n+\n+            case Format_GNU_m:\n+                break;  // not assert(0) because it may go through it if there are extra arguments\n+\n+            case Format_percent:\n+            default:\n+                assert(0);\n+        }\n+    }\n+    return false;\n+}\n+\n+/*******************************************/\n+\n+static Expression *getNextScanfArg(const Loc &loc, Expressions &args, size_t &n, bool asterisk)\n+{\n+    if (n == args.length)\n+    {\n+        if (!asterisk)\n+            deprecation(loc, \"more format specifiers than %d arguments\", (int)n);\n+        return NULL;\n+    }\n+    return args[n++];\n+}\n+\n+static void errorScanfFormat(const char *prefix, DString &slice,\n+                Expression *arg, const char *texpect, Type *tactual)\n+{\n+    deprecation(arg->loc, \"%sargument `%s` for format specification `\\\"%.*s\\\"` must be `%s`, not `%s`\",\n+                prefix ? prefix : \"\", arg->toChars(), (int)slice.length, slice.ptr, texpect, tactual->toChars());\n+}\n+\n+/******************************************\n+ * Check that arguments to a scanf format string are compatible\n+ * with that string. Issue errors for incompatibilities.\n+ *\n+ * Follows the C99 specification for scanf.\n+ *\n+ * Takes a generous, rather than strict, view of compatiblity.\n+ * For example, an unsigned value can be formatted with a signed specifier.\n+ *\n+ * Diagnosed incompatibilities are:\n+ *\n+ * 1. incompatible sizes which will cause argument misalignment\n+ * 2. deferencing arguments that are not pointers\n+ * 3. insufficient number of arguments\n+ * 4. struct arguments\n+ * 5. array and slice arguments\n+ * 6. non-standard formats\n+ * 7. undefined behavior per C99\n+ *\n+ * Per the C Standard, extra arguments are ignored.\n+ *\n+ * No attempt is made to fix the arguments or the format string.\n+ *\n+ * Params:\n+ *      loc = location for error messages\n+ *      format = format string\n+ *      args = arguments to match with format string\n+ *      isVa_list = if a \"v\" function (format check only)\n+ *\n+ * Returns:\n+ *      `true` if errors occurred\n+ * References:\n+ * C99 7.19.6.2\n+ * http://www.cplusplus.com/reference/cstdio/scanf/\n+ */\n+bool checkScanfFormat(const Loc &loc, const char *format, Expressions &args, bool isVa_list)\n+{\n+    size_t n = 0;\n+    const size_t format_length = strlen(format);\n+    for (size_t i = 0; i < format_length;)\n+    {\n+        if (format[i] != '%')\n+        {\n+            ++i;\n+            continue;\n+        }\n+        bool asterisk = false;\n+        size_t j = i;\n+        const Format fmt = parseScanfFormatSpecifier(format, j, asterisk);\n+        DString slice = DString(j - i, format + i);\n+        i = j;\n+\n+        if (fmt == Format_percent || asterisk)\n+            continue;   // \"%%\", \"%*\": no arguments\n+\n+        if (isVa_list)\n+        {\n+            // format check only\n+            if (fmt == Format_error)\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n+            continue;\n+        }\n+\n+        Expression *e = getNextScanfArg(loc, args, n, asterisk);\n+        if (!e)\n+            return true;\n+\n+        Type *t = e->type->toBasetype();\n+        Type *tnext = t->nextOf();\n+        const unsigned c_longsize = target.c.longsize;\n+        const bool is64bit = global.params.is64bit;\n+\n+        switch (fmt)\n+        {\n+            case Format_n:\n+            case Format_d:      // pointer to int\n+                if (!(t->ty == Tpointer && tnext->ty == Tint32))\n+                    errorScanfFormat(NULL, slice, e, \"int*\", t);\n+                break;\n+\n+            case Format_hhn:\n+            case Format_hhd:    // pointer to signed char\n+                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n+                    errorScanfFormat(NULL, slice, e, \"byte*\", t);\n+                break;\n+\n+            case Format_hn:\n+            case Format_hd:     // pointer to short\n+                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n+                    errorScanfFormat(NULL, slice, e, \"short*\", t);\n+                break;\n+\n+            case Format_ln:\n+            case Format_ld:     // pointer to long int\n+                if (!(t->ty == Tpointer && tnext->isintegral() && tnext->size() == c_longsize))\n+                    errorScanfFormat(NULL, slice, e, (c_longsize == 4 ? \"int*\" : \"long*\"), t);\n+                break;\n+\n+            case Format_lln:\n+            case Format_lld:    // pointer to long long int\n+                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n+                    errorScanfFormat(NULL, slice, e, \"long*\", t);\n+                break;\n+\n+            case Format_jn:\n+            case Format_jd:     // pointer to intmax_t\n+                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n+                    errorScanfFormat(NULL, slice, e, \"core.stdc.stdint.intmax_t*\", t);\n+                break;\n+\n+            case Format_zn:\n+            case Format_zd:     // pointer to size_t\n+                if (!(t->ty == Tpointer && tnext->ty == (is64bit ? Tuns64 : Tuns32)))\n+                    errorScanfFormat(NULL, slice, e, \"size_t*\", t);\n+                break;\n+\n+            case Format_tn:\n+            case Format_td:     // pointer to ptrdiff_t\n+                if (!(t->ty == Tpointer && tnext->ty == (is64bit ? Tint64 : Tint32)))\n+                    errorScanfFormat(NULL, slice, e, \"ptrdiff_t*\", t);\n+                break;\n+\n+            case Format_u:      // pointer to unsigned int\n+                if (!(t->ty == Tpointer && tnext->ty == Tuns32))\n+                    errorScanfFormat(NULL, slice, e, \"uint*\", t);\n+                break;\n+\n+            case Format_hhu:    // pointer to unsigned char\n+                if (!(t->ty == Tpointer && tnext->ty == Tuns8))\n+                    errorScanfFormat(NULL, slice, e, \"ubyte*\", t);\n+                break;\n+\n+            case Format_hu:     // pointer to unsigned short int\n+                if (!(t->ty == Tpointer && tnext->ty == Tuns16))\n+                    errorScanfFormat(NULL, slice, e, \"ushort*\", t);\n+                break;\n+\n+            case Format_lu:     // pointer to unsigned long int\n+                if (!(t->ty == Tpointer && tnext->ty == (is64bit ? Tuns64 : Tuns32)))\n+                    errorScanfFormat(NULL, slice, e, (c_longsize == 4 ? \"uint*\" : \"ulong*\"), t);\n+                break;\n+\n+            case Format_llu:    // pointer to unsigned long long int\n+                if (!(t->ty == Tpointer && tnext->ty == Tuns64))\n+                    errorScanfFormat(NULL, slice, e, \"ulong*\", t);\n+                break;\n+\n+            case Format_ju:     // pointer to uintmax_t\n+                if (!(t->ty == Tpointer && tnext->ty == (is64bit ? Tuns64 : Tuns32)))\n+                    errorScanfFormat(NULL, slice, e, \"ulong*\", t);\n+                break;\n+\n+            case Format_g:      // pointer to float\n+                if (!(t->ty == Tpointer && tnext->ty == Tfloat32))\n+                    errorScanfFormat(NULL, slice, e, \"float*\", t);\n+                break;\n+\n+            case Format_lg:     // pointer to double\n+                if (!(t->ty == Tpointer && tnext->ty == Tfloat64))\n+                    errorScanfFormat(NULL, slice, e, \"double*\", t);\n+                break;\n+\n+            case Format_Lg:     // pointer to long double\n+                if (!(t->ty == Tpointer && tnext->ty == Tfloat80))\n+                    errorScanfFormat(NULL, slice, e, \"real*\", t);\n+                break;\n+\n+            case Format_GNU_a:\n+            case Format_GNU_m:\n+            case Format_c:\n+            case Format_s:      // pointer to char string\n+                if (!(t->ty == Tpointer && (tnext->ty == Tchar || tnext->ty == Tint8 || tnext->ty == Tuns8)))\n+                    errorScanfFormat(NULL, slice, e, \"char*\", t);\n+                break;\n+\n+            case Format_lc:\n+            case Format_ls:     // pointer to wchar_t string\n+            {\n+                if (!(t->ty == Tpointer && tnext == target.c.twchar_t))\n+                    errorScanfFormat(NULL, slice, e, \"wchar_t*\", t);\n+                break;\n+            }\n+            case Format_p:      // double pointer\n+                if (!(t->ty == Tpointer && tnext->ty == Tpointer))\n+                    errorScanfFormat(NULL, slice, e, \"void**\", t);\n+                break;\n+\n+            case Format_error:\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n+                break;\n+\n+            case Format_percent:\n+            default:\n+                assert(0);\n+        }\n+    }\n+    return false;\n+}"}, {"sha": "baf64c5653e7d11fb207269a49e69b7e0318eae6", "filename": "gcc/d/dmd/cppmangle.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -806,6 +806,14 @@ class CppMangleVisitor : public Visitor\n         writeBasicType(t, 'D', 'n');\n     }\n \n+    void visit(TypeNoreturn *t)\n+    {\n+        if (t->isImmutable() || t->isShared())\n+            return error(t);\n+\n+        writeBasicType(t, 0, 'v');      // mangle like `void`\n+    }\n+\n     void visit(TypeBasic *t)\n     {\n         if (t->isImmutable() || t->isShared())\n@@ -1012,18 +1020,26 @@ class CppMangleVisitor : public Visitor\n         if (t->isImmutable() || t->isShared())\n             return error(t);\n \n-        /* __c_(u)long(long) get special mangling\n+        /* __c_(u)long(long) and others get special mangling\n          */\n         Identifier *id = t->sym->ident;\n         //printf(\"enum id = '%s'\\n\", id->toChars());\n         if (id == Id::__c_long)\n             return writeBasicType(t, 0, 'l');\n         else if (id == Id::__c_ulong)\n             return writeBasicType(t, 0, 'm');\n+        else if (id == Id::__c_wchar_t)\n+            return writeBasicType(t, 0, 'w');\n         else if (id == Id::__c_longlong)\n             return writeBasicType(t, 0, 'x');\n         else if (id == Id::__c_ulonglong)\n             return writeBasicType(t, 0, 'y');\n+        else if (id == Id::__c_complex_float)\n+            return writeBasicType(t, 'C', 'f');\n+        else if (id == Id::__c_complex_double)\n+            return writeBasicType(t, 'C', 'd');\n+        else if (id == Id::__c_complex_real)\n+            return writeBasicType(t, 'C', 'e');\n \n         doSymbol(t);\n     }"}, {"sha": "a8e97833ad023f529bebd623d246b3a896037235", "filename": "gcc/d/dmd/ctfeexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -162,7 +162,7 @@ const char *CTFEExp::toChars()\n     switch (op)\n     {\n         case TOKcantexp:    return \"<cant>\";\n-        case TOKvoidexp:    return \"<void>\";\n+        case TOKvoidexp:    return \"cast(void)0\";\n         case TOKbreak:      return \"<break>\";\n         case TOKcontinue:   return \"<continue>\";\n         case TOKgoto:       return \"<goto>\";"}, {"sha": "4dd648bcc48e03bd448c40aa347e786580214445", "filename": "gcc/d/dmd/dcast.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -26,6 +26,7 @@\n FuncDeclaration *isFuncAddress(Expression *e, bool *hasOverloads = NULL);\n bool isCommutative(TOK op);\n MOD MODmerge(MOD mod1, MOD mod2);\n+void toAutoQualChars(const char **result, Type *t1, Type *t2);\n \n /* ==================== implicitCast ====================== */\n \n@@ -90,8 +91,10 @@ Expression *implicitCastTo(Expression *e, Scope *sc, Type *t)\n                     //printf(\"type %p ty %d deco %p\\n\", type, type->ty, type->deco);\n                     //type = type->semantic(loc, sc);\n                     //printf(\"type %s t %s\\n\", type->deco, t->deco);\n+                    const char *ts[2];\n+                    toAutoQualChars(ts, e->type, t);\n                     e->error(\"cannot implicitly convert expression (%s) of type %s to %s\",\n-                        e->toChars(), e->type->toChars(), t->toChars());\n+                        e->toChars(), ts[0], ts[1]);\n                 }\n             }\n             result = new ErrorExp();"}, {"sha": "3f33014da9f59e5c8ff693cb20642f13d33cf511", "filename": "gcc/d/dmd/dclass.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -277,15 +277,10 @@ Scope *ClassDeclaration::newScope(Scope *sc)\n     Scope *sc2 = AggregateDeclaration::newScope(sc);\n     if (isCOMclass())\n     {\n-        if (global.params.isWindows)\n-            sc2->linkage = LINKwindows;\n-        else\n-        {\n-            /* This enables us to use COM objects under Linux and\n-             * work with things like XPCOM\n-             */\n-            sc2->linkage = LINKc;\n-        }\n+        /* This enables us to use COM objects under Linux and\n+         * work with things like XPCOM\n+         */\n+        sc2->linkage = target.systemLinkage();\n     }\n     return sc2;\n }\n@@ -491,9 +486,10 @@ void ClassDeclaration::finalizeSize()\n         assert(baseClass->sizeok == SIZEOKdone);\n \n         alignsize = baseClass->alignsize;\n-        structsize = baseClass->structsize;\n-        if (isCPPclass() && global.params.isWindows)\n-            structsize = (structsize + alignsize - 1) & ~(alignsize - 1);\n+        if (classKind == ClassKind::cpp)\n+            structsize = target.cpp.derivedClassOffset(baseClass);\n+        else\n+            structsize = baseClass->structsize;\n     }\n     else if (isInterfaceDeclaration())\n     {"}, {"sha": "55c814288e0592d786cf5cd51a71b058644626a9", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -118,7 +118,7 @@ struct Match\n     FuncDeclaration *anyf;      // pick a func, any func, to use for error recovery\n };\n \n-void functionResolve(Match *m, Dsymbol *fd, Loc loc, Scope *sc, Objects *tiargs, Type *tthis, Expressions *fargs);\n+void functionResolve(Match *m, Dsymbol *fd, Loc loc, Scope *sc, Objects *tiargs, Type *tthis, Expressions *fargs, const char **pMessage = NULL);\n int overloadApply(Dsymbol *fstart, void *param, int (*fp)(void *, Dsymbol *));\n void aliasSemantic(AliasDeclaration *ds, Scope *sc);\n \n@@ -551,6 +551,8 @@ void builtin_init();\n #define FUNCFLAGreturnInprocess 0x10    // working on inferring 'return' for parameters\n #define FUNCFLAGinlineScanned   0x20    // function has been scanned for inline possibilities\n #define FUNCFLAGinferScope      0x40    // infer 'scope' for parameters\n+#define FUNCFLAGprintf          0x200   // is a printf-like function\n+#define FUNCFLAGscanf           0x400   // is a scanf-like function\n \n class FuncDeclaration : public Declaration\n {"}, {"sha": "bfd3b7274f41da327f961143cc7482720f067d88", "filename": "gcc/d/dmd/denum.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdenum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdenum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -22,6 +22,19 @@\n #include \"declaration.h\"\n #include \"init.h\"\n \n+bool isSpecialEnumIdent(const Identifier *ident)\n+{\n+    return  ident == Id::__c_long ||\n+            ident == Id::__c_ulong ||\n+            ident == Id::__c_longlong ||\n+            ident == Id::__c_ulonglong ||\n+            ident == Id::__c_long_double ||\n+            ident == Id::__c_wchar_t ||\n+            ident == Id::__c_complex_float ||\n+            ident == Id::__c_complex_double ||\n+            ident == Id::__c_complex_real;\n+}\n+\n /********************************* EnumDeclaration ****************************/\n \n EnumDeclaration::EnumDeclaration(Loc loc, Identifier *id, Type *memtype)\n@@ -187,11 +200,7 @@ Expression *EnumDeclaration::getMaxMinValue(Loc loc, Identifier *id)\n  */\n bool EnumDeclaration::isSpecial() const\n {\n-    return (ident == Id::__c_long ||\n-            ident == Id::__c_ulong ||\n-            ident == Id::__c_longlong ||\n-            ident == Id::__c_ulonglong ||\n-            ident == Id::__c_long_double) && memtype;\n+    return isSpecialEnumIdent(ident) && memtype;\n }\n \n Expression *EnumDeclaration::getDefaultValue(Loc loc)"}, {"sha": "7b63a1865525093668a793d9e5e4cafed606f900", "filename": "gcc/d/dmd/dimport.c", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdimport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdimport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -161,37 +161,75 @@ void Import::load(Scope *sc)\n     if (mod && !mod->importedFrom)\n         mod->importedFrom = sc ? sc->_module->importedFrom : Module::rootModule;\n     if (!pkg)\n-        pkg = mod;\n+    {\n+        if (mod && mod->isPackageFile)\n+        {\n+            // one level depth package.d file (import pkg; ./pkg/package.d)\n+            // it's necessary to use the wrapping Package already created\n+            pkg = mod->pkg;\n+        }\n+        else\n+            pkg = mod;\n+    }\n \n     //printf(\"-Import::load('%s'), pkg = %p\\n\", toChars(), pkg);\n }\n \n void Import::importAll(Scope *sc)\n {\n-    if (!mod)\n+    if (mod) return; // Already done\n+    load(sc);\n+    if (!mod) return; // Failed\n+\n+    if (sc->stc & STCstatic)\n+        isstatic = true;\n+    mod->importAll(NULL);\n+    if (mod->md && mod->md->isdeprecated)\n     {\n-        load(sc);\n-        if (mod)                // if successfully loaded module\n-        {\n-            mod->importAll(NULL);\n-\n-            if (mod->md && mod->md->isdeprecated)\n-            {\n-                Expression *msg = mod->md->msg;\n-                if (StringExp *se = msg ? msg->toStringExp() : NULL)\n-                    mod->deprecation(loc, \"is deprecated - %s\", se->string);\n-                else\n-                    mod->deprecation(loc, \"is deprecated\");\n-            }\n+        Expression *msg = mod->md->msg;\n+        if (StringExp *se = msg ? msg->toStringExp() : NULL)\n+            mod->deprecation(loc, \"is deprecated - %s\", se->string);\n+        else\n+            mod->deprecation(loc, \"is deprecated\");\n+    }\n+    if (sc->explicitProtection)\n+        protection = sc->protection;\n+    if (!isstatic && !aliasId && !names.length)\n+        sc->scopesym->importScope(mod, protection);\n+    // Enable access to pkgs/mod as soon as posible, because compiler\n+    // can traverse them before the import gets semantic (Issue: 21501)\n+    if (!aliasId && !names.length)\n+        addPackageAccess(sc->scopesym);\n+}\n \n-            if (sc->explicitProtection)\n-                protection = sc->protection;\n-            if (!isstatic && !aliasId && !names.length)\n-            {\n-                sc->scopesym->importScope(mod, protection);\n-            }\n+/*******************************\n+ * Mark the imported packages as accessible from the current\n+ * scope. This access check is necessary when using FQN b/c\n+ * we're using a single global package tree.\n+ * https://issues.dlang.org/show_bug.cgi?id=313\n+ */\n+void Import::addPackageAccess(ScopeDsymbol *scopesym)\n+{\n+    //printf(\"Import::addPackageAccess('%s') %p\\n\", toPrettyChars(), this);\n+    if (packages)\n+    {\n+        // import a.b.c.d;\n+        Package *p = pkg; // a\n+        scopesym->addAccessiblePackage(p, protection);\n+        for (size_t i = 1; i < packages->length; i++) // [b, c]\n+        {\n+            Identifier *id = (*packages)[i];\n+            p = (Package *) p->symtab->lookup(id);\n+            // https://issues.dlang.org/show_bug.cgi?id=17991\n+            // An import of truly empty file/package can happen\n+            // https://issues.dlang.org/show_bug.cgi?id=20151\n+            // Package in the path conflicts with a module name\n+            if (p == NULL)\n+                return;\n+            scopesym->addAccessiblePackage(p, protection);\n         }\n     }\n+    scopesym->addAccessiblePackage(mod, protection); // d\n }\n \n Dsymbol *Import::toAlias()"}, {"sha": "83f4c18bee835ea87c68fb644c5e172734ba212f", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -82,6 +82,8 @@ void initTypeMangle()\n     mangleChar[Treturn] = \"@\";\n     mangleChar[Tvector] = \"@\";\n     mangleChar[Ttraits] = \"@\";\n+    mangleChar[Tmixin] = \"@\";\n+    mangleChar[Tnoreturn] = \"@\";    // becomes 'Nn'\n \n     mangleChar[Tnull] = \"n\";    // same as TypeNone\n \n@@ -150,7 +152,7 @@ class Mangler : public Visitor\n     *  using upper case letters for all digits but the last digit which uses\n     *  a lower case letter.\n     * The decoder has to look up the referenced position to determine\n-    *  whether the back reference is an identifer (starts with a digit)\n+    *  whether the back reference is an identifier (starts with a digit)\n     *  or a type (starts with a letter).\n     *\n     * Params:\n@@ -414,6 +416,11 @@ class Mangler : public Visitor\n         visit((Type *)t);\n     }\n \n+    void visit(TypeNoreturn *)\n+    {\n+        buf->writestring(\"Nn\");\n+    }\n+\n     ////////////////////////////////////////////////////////////////////////////\n \n     void mangleDecl(Declaration *sthis)\n@@ -1085,3 +1092,31 @@ void mangleToBuffer(TemplateInstance *ti, OutBuffer *buf)\n     Mangler v(buf);\n     v.mangleTemplateInstance(ti);\n }\n+\n+/**********************************************\n+ * Convert a string representing a type (the deco) and\n+ * return its equivalent Type.\n+ * Params:\n+ *      deco = string containing the deco\n+ * Returns:\n+ *      null for failed to convert\n+ *      Type for succeeded\n+ */\n+\n+Type *decoToType(const char *deco)\n+{\n+    if (!deco)\n+        return NULL;\n+\n+    //printf(\"decoToType(): %s\\n\", deco)\n+    if (StringValue *sv = Type::stringtable.lookup(deco, strlen(deco)))\n+    {\n+        if (sv->ptrvalue)\n+        {\n+            Type *t = (Type *)sv->ptrvalue;\n+            assert(t->deco);\n+            return t;\n+        }\n+    }\n+    return NULL;\n+}"}, {"sha": "472b2b9e7f89915a0fd1810eac1ddf7ddb9e2abf", "filename": "gcc/d/dmd/dmodule.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -52,6 +52,7 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do\n     members = NULL;\n     isDocFile = 0;\n     isPackageFile = false;\n+    pkg = NULL;\n     needmoduleinfo = 0;\n     selfimports = 0;\n     rootimports = 0;\n@@ -685,15 +686,27 @@ Module *Module::parse()\n          *\n          * To avoid the conflict:\n          * 1. If preceding package name insertion had occurred by Package::resolve,\n-         *    later package.d loading will change Package::isPkgMod to PKGmodule and set Package::mod.\n+         *    reuse the previous wrapping 'Package' if it exists\n          * 2. Otherwise, 'package.d' wrapped by 'Package' is inserted to the internal tree in here.\n+         *\n+         * Then change Package::isPkgMod to PKGmodule and set Package::mod.\n+         *\n+         * Note that the 'wrapping Package' is the Package that contains package.d and other submodules,\n+         * the one inserted to the symbol table.\n          */\n-        Package *p = new Package(ident);\n+        Dsymbol *ps = dst->lookup(ident);\n+        Package *p = ps ? ps->isPackage() : NULL;\n+        if (p == NULL)\n+        {\n+            p = new Package(ident);\n+            p->tag = this->tag; // reuse the same package tag\n+            p->symtab = new DsymbolTable();\n+        }\n+        this->tag= p->tag; // reuse the 'older' package tag\n+        this->pkg = p;\n         p->parent = this->parent;\n         p->isPkgMod = PKGmodule;\n         p->mod = this;\n-        p->tag = this->tag; // reuse the same package tag\n-        p->symtab = new DsymbolTable();\n         s = p;\n     }\n     if (!dst->insert(s))\n@@ -720,15 +733,9 @@ Module *Module::parse()\n         }\n         else if (Package *pkg = prev->isPackage())\n         {\n-            if (pkg->isPkgMod == PKGunknown && isPackageFile)\n-            {\n-                /* If the previous inserted Package is not yet determined as package.d,\n-                 * link it to the actual module.\n-                 */\n-                pkg->isPkgMod = PKGmodule;\n-                pkg->mod = this;\n-                pkg->tag = this->tag; // reuse the same package tag\n-            }\n+            // 'package.d' loaded after a previous 'Package' insertion\n+            if (isPackageFile)\n+                amodules.push(this); // Add to global array of all modules\n             else\n                 error(md ? md->loc : loc, \"from file %s conflicts with package name %s\",\n                     srcname, pkg->toChars());"}, {"sha": "e56f3936ee07eee24ee970785c888f71f9c5cc55", "filename": "gcc/d/dmd/dscope.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdscope.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdscope.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -24,6 +24,7 @@\n #include \"aggregate.h\"\n #include \"module.h\"\n #include \"id.h\"\n+#include \"target.h\"\n #include \"template.h\"\n \n Scope *Scope::freelist = NULL;\n@@ -155,7 +156,8 @@ Scope *Scope::push()\n     s->nofree = 0;\n     s->fieldinit = saveFieldInit();\n     s->flags = (flags & (SCOPEcontract | SCOPEdebug | SCOPEctfe | SCOPEcompile | SCOPEconstraint |\n-                         SCOPEnoaccesscheck | SCOPEignoresymbolvisibility));\n+                         SCOPEnoaccesscheck | SCOPEignoresymbolvisibility |\n+                         SCOPEprintf | SCOPEscanf));\n     s->lastdc = NULL;\n \n     assert(this != s);\n@@ -637,7 +639,7 @@ const char *Scope::search_correct_C(Identifier *ident)\n     else if (ident == Id::C_unsigned)\n         tok = TOKuns32;\n     else if (ident == Id::C_wchar_t)\n-        tok = global.params.isWindows ? TOKwchar : TOKdchar;\n+        tok = target.c.twchar_t->ty == Twchar ? TOKwchar : TOKdchar;\n     else\n         return NULL;\n     return Token::toChars(tok);"}, {"sha": "f0c1cf6d93cfe0e7b9052accd98cc81918872825", "filename": "gcc/d/dmd/dsymbol.c", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -515,7 +515,7 @@ Dsymbol *Dsymbol::search_correct(Identifier *ident)\n  * Returns:\n  *      symbol found, NULL if not\n  */\n-Dsymbol *Dsymbol::searchX(Loc loc, Scope *sc, RootObject *id)\n+Dsymbol *Dsymbol::searchX(Loc loc, Scope *sc, RootObject *id, int flags)\n {\n     //printf(\"Dsymbol::searchX(this=%p,%s, ident='%s')\\n\", this, toChars(), ident->toChars());\n     Dsymbol *s = toAlias();\n@@ -533,7 +533,7 @@ Dsymbol *Dsymbol::searchX(Loc loc, Scope *sc, RootObject *id)\n     switch (id->dyncast())\n     {\n         case DYNCAST_IDENTIFIER:\n-            sm = s->search(loc, (Identifier *)id);\n+            sm = s->search(loc, (Identifier *)id, flags);\n             break;\n \n         case DYNCAST_DSYMBOL:\n@@ -1801,31 +1801,3 @@ bool Prot::operator==(const Prot& other) const\n     }\n     return false;\n }\n-\n-/**\n- * Checks if parent defines different access restrictions than this one.\n- *\n- * Params:\n- *  parent = protection attribute for scope that hosts this one\n- *\n- * Returns:\n- *  'true' if parent is already more restrictive than this one and thus\n- *  no differentiation is needed.\n- */\n-bool Prot::isSubsetOf(const Prot& parent) const\n-{\n-    if (this->kind != parent.kind)\n-        return false;\n-\n-    if (this->kind == Prot::package_)\n-    {\n-        if (!this->pkg)\n-            return true;\n-        if (!parent.pkg)\n-            return false;\n-        if (parent.pkg->isAncestorPackageOf(this->pkg))\n-            return true;\n-    }\n-\n-    return true;\n-}"}, {"sha": "4aabb5d3c6c0099b640ce5cc8203a77010629670", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -107,7 +107,6 @@ struct Prot\n \n     bool isMoreRestrictiveThan(const Prot other) const;\n     bool operator==(const Prot& other) const;\n-    bool isSubsetOf(const Prot& other) const;\n };\n \n // in hdrgen.c\n@@ -207,7 +206,7 @@ class Dsymbol : public ASTNode\n     virtual void importAll(Scope *sc);\n     virtual Dsymbol *search(const Loc &loc, Identifier *ident, int flags = IgnoreNone);\n     Dsymbol *search_correct(Identifier *id);\n-    Dsymbol *searchX(Loc loc, Scope *sc, RootObject *id);\n+    Dsymbol *searchX(Loc loc, Scope *sc, RootObject *id, int flags);\n     virtual bool overloadInsert(Dsymbol *s);\n     virtual d_uns64 size(Loc loc);\n     virtual bool isforwardRef();"}, {"sha": "26e23e98587dc0abd1cc927f159008253e980495", "filename": "gcc/d/dmd/dsymbolsem.c", "status": "modified", "additions": 96, "deletions": 43, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdsymbolsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdsymbolsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -42,6 +42,8 @@ VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n Initializer *inferType(Initializer *init, Scope *sc);\n void MODtoBuffer(OutBuffer *buf, MOD mod);\n bool reliesOnTident(Type *t, TemplateParameters *tparams = NULL, size_t iStart = 0);\n+bool expressionsToString(OutBuffer &buf, Scope *sc, Expressions *exps);\n+bool symbolIsVisible(Scope *sc, Dsymbol *s);\n Objc *objc();\n \n static unsigned setMangleOverride(Dsymbol *s, char *sym)\n@@ -1098,22 +1100,7 @@ class DsymbolSemanticVisitor : public Visitor\n                     scopesym->importScope(imp->mod, imp->protection);\n                 }\n \n-                // Mark the imported packages as accessible from the current\n-                // scope. This access check is necessary when using FQN b/c\n-                // we're using a single global package tree. See Bugzilla 313.\n-                if (imp->packages)\n-                {\n-                    // import a.b.c.d;\n-                    Package *p = imp->pkg; // a\n-                    scopesym->addAccessiblePackage(p, imp->protection);\n-                    for (size_t i = 1; i < imp->packages->length; i++) // [b, c]\n-                    {\n-                        Identifier *id = (*imp->packages)[i];\n-                        p = (Package *) p->symtab->lookup(id);\n-                        scopesym->addAccessiblePackage(p, imp->protection);\n-                    }\n-                }\n-                scopesym->addAccessiblePackage(imp->mod, imp->protection); // d\n+                imp->addPackageAccess(scopesym);\n             }\n \n             dsymbolSemantic(imp->mod, NULL);\n@@ -1130,8 +1117,12 @@ class DsymbolSemanticVisitor : public Visitor\n             {\n                 AliasDeclaration *ad = imp->aliasdecls[i];\n                 //printf(\"\\tImport %s alias %s = %s, scope = %p\\n\", toPrettyChars(), imp->aliases[i]->toChars(), imp->names[i]->toChars(), ad->_scope);\n-                if (imp->mod->search(imp->loc, imp->names[i]))\n+                Dsymbol *sym = imp->mod->search(imp->loc, imp->names[i], IgnorePrivateImports);\n+                if (sym)\n                 {\n+                    if (!symbolIsVisible(sc, sym))\n+                        imp->mod->error(imp->loc, \"member `%s` is not visible from module `%s`\",\n+                            imp->names[i]->toChars(), sc->_module->toChars());\n                     dsymbolSemantic(ad, sc);\n                     // If the import declaration is in non-root module,\n                     // analysis of the aliased symbol is deferred.\n@@ -1141,7 +1132,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 {\n                     Dsymbol *s = imp->mod->search_correct(imp->names[i]);\n                     if (s)\n-                        imp->mod->error(imp->loc, \"import `%s` not found, did you mean %s `%s`?\", imp->names[i]->toChars(), s->kind(), s->toChars());\n+                        imp->mod->error(imp->loc, \"import `%s` not found, did you mean %s `%s`?\", imp->names[i]->toChars(), s->kind(), s->toPrettyChars());\n                     else\n                         imp->mod->error(imp->loc, \"import `%s` not found\", imp->names[i]->toChars());\n                     ad->type = Type::terror;\n@@ -1312,8 +1303,6 @@ class DsymbolSemanticVisitor : public Visitor\n                     e = expressionSemantic(e, sc);\n                     e = resolveProperties(sc, e);\n                     sc = sc->endCTFE();\n-\n-                    // pragma(msg) is allowed to contain types as well as expressions\n                     e = ctfeInterpretForPragmaMsg(e);\n                     if (e->op == TOKerror)\n                     {\n@@ -1458,6 +1447,12 @@ class DsymbolSemanticVisitor : public Visitor\n                 }\n             }\n         }\n+        else if (pd->ident == Id::printf || pd->ident == Id::scanf)\n+        {\n+            if (pd->args && pd->args->length != 0)\n+                pd->error(\"takes no argument\");\n+            goto Ldecl;\n+        }\n         else if (global.params.ignoreUnsupportedPragmas)\n         {\n             if (global.params.verbose)\n@@ -1547,13 +1542,14 @@ class DsymbolSemanticVisitor : public Visitor\n     Dsymbols *compileIt(CompileDeclaration *cd)\n     {\n         //printf(\"CompileDeclaration::compileIt(loc = %d) %s\\n\", cd->loc.linnum, cd->exp->toChars());\n-        StringExp *se = semanticString(sc, cd->exp, \"argument to mixin\");\n-        if (!se)\n+        OutBuffer buf;\n+        if (expressionsToString(buf, sc, cd->exps))\n             return NULL;\n-        se = se->toUTF8(sc);\n \n         unsigned errors = global.errors;\n-        Parser p(cd->loc, sc->_module, (utf8_t *)se->string, se->len, 0);\n+        const size_t len = buf.length();\n+        const char *str = buf.extractChars();\n+        Parser p(cd->loc, sc->_module, (const utf8_t *)str, len, false);\n         p.nextToken();\n \n         Dsymbols *d = p.parseDeclDefs(0);\n@@ -1562,7 +1558,7 @@ class DsymbolSemanticVisitor : public Visitor\n \n         if (p.token.value != TOKeof)\n         {\n-            cd->exp->error(\"incomplete mixin declaration (%s)\", se->toChars());\n+            cd->error(\"incomplete mixin declaration (%s)\", str);\n             return NULL;\n         }\n         return d;\n@@ -1637,7 +1633,7 @@ class DsymbolSemanticVisitor : public Visitor\n         Scope *sc = m->_scope;                  // see if already got one from importAll()\n         if (!sc)\n         {\n-            Scope::createGlobal(m);      // create root scope\n+            sc = Scope::createGlobal(m);      // create root scope\n         }\n \n         //printf(\"Module = %p, linkage = %d\\n\", sc->scopesym, sc->linkage);\n@@ -1735,7 +1731,7 @@ class DsymbolSemanticVisitor : public Visitor\n                     // memtype is forward referenced, so try again later\n                     ed->_scope = scx ? scx : sc->copy();\n                     ed->_scope->setNoFree();\n-                    ed->_scope->_module->addDeferredSemantic(ed);\n+                    Module::addDeferredSemantic(ed);\n                     Module::dprogress = dprogress_save;\n                     //printf(\"\\tdeferring %s\\n\", ed->toChars());\n                     ed->semanticRun = PASSinit;\n@@ -2233,7 +2229,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 //printf(\"forward reference - deferring\\n\");\n                 tm->_scope = scx ? scx : sc->copy();\n                 tm->_scope->setNoFree();\n-                tm->_scope->_module->addDeferredSemantic(tm);\n+                Module::addDeferredSemantic(tm);\n                 return;\n             }\n \n@@ -2457,6 +2453,23 @@ class DsymbolSemanticVisitor : public Visitor\n         ns->semanticRun = PASSsemanticdone;\n     }\n \n+\n+private:\n+    static bool isPointerToChar(Parameter *p)\n+    {\n+        if (TypePointer *tptr = p->type->isTypePointer())\n+        {\n+            return tptr->next->ty == Tchar;\n+        }\n+        return false;\n+    }\n+\n+    static bool isVa_list(Parameter *p, FuncDeclaration *funcdecl, Scope *sc)\n+    {\n+        return p->type->equals(target.va_listType(funcdecl->loc, sc));\n+    }\n+\n+public:\n     void funcDeclarationSemantic(FuncDeclaration *funcdecl)\n     {\n         TypeFunction *f;\n@@ -2771,6 +2784,45 @@ class DsymbolSemanticVisitor : public Visitor\n         if (funcdecl->isAbstract() && funcdecl->isFinalFunc())\n             funcdecl->error(\"cannot be both final and abstract\");\n \n+        if (const unsigned pors = sc->flags & (SCOPEprintf | SCOPEscanf))\n+        {\n+            /* printf/scanf-like functions must be of the form:\n+             *    extern (C/C++) T printf([parameters...], const(char)* format, ...);\n+             * or:\n+             *    extern (C/C++) T vprintf([parameters...], const(char)* format, va_list);\n+             */\n+            const size_t nparams = f->parameterList.length();\n+            if ((f->linkage == LINKc || f->linkage == LINKcpp) &&\n+\n+                ((f->parameterList.varargs == VARARGvariadic &&\n+                  nparams >= 1 &&\n+                  isPointerToChar(f->parameterList[nparams - 1])) ||\n+                 (f->parameterList.varargs == VARARGnone &&\n+                  nparams >= 2 &&\n+                  isPointerToChar(f->parameterList[nparams - 2]) &&\n+                  isVa_list(f->parameterList[nparams - 1], funcdecl, sc))\n+                )\n+               )\n+            {\n+                funcdecl->flags |= (pors == SCOPEprintf) ? FUNCFLAGprintf : FUNCFLAGscanf;\n+            }\n+            else\n+            {\n+                const char *p = (pors == SCOPEprintf ? Id::printf : Id::scanf)->toChars();\n+                if (f->parameterList.varargs == VARARGvariadic)\n+                {\n+                    funcdecl->error(\"`pragma(%s)` functions must be `extern(C) %s %s([parameters...], const(char)*, ...)`\"\n+                                    \" not `%s`\",\n+                        p, f->next->toChars(), funcdecl->toChars(), funcdecl->type->toChars());\n+                }\n+                else\n+                {\n+                    funcdecl->error(\"`pragma(%s)` functions must be `extern(C) %s %s([parameters...], const(char)*, va_list)`\",\n+                        p, f->next->toChars(), funcdecl->toChars());\n+                }\n+            }\n+        }\n+\n         id = parent->isInterfaceDeclaration();\n         if (id)\n         {\n@@ -3831,7 +3883,7 @@ class DsymbolSemanticVisitor : public Visitor\n \n             sd->_scope = scx ? scx : sc->copy();\n             sd->_scope->setNoFree();\n-            sd->_scope->_module->addDeferredSemantic(sd);\n+            Module::addDeferredSemantic(sd);\n \n             //printf(\"\\tdeferring %s\\n\", sd->toChars());\n             return;\n@@ -4079,7 +4131,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 {\n                     //printf(\"\\ttry later, forward reference of base class %s\\n\", tc->sym->toChars());\n                     if (tc->sym->_scope)\n-                        tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n+                        Module::addDeferredSemantic(tc->sym);\n                     cldec->baseok = BASEOKnone;\n                 }\n              L7: ;\n@@ -4131,7 +4183,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 {\n                     //printf(\"\\ttry later, forward reference of base %s\\n\", tc->sym->toChars());\n                     if (tc->sym->_scope)\n-                        tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n+                        Module::addDeferredSemantic(tc->sym);\n                     cldec->baseok = BASEOKnone;\n                 }\n                 i++;\n@@ -4141,7 +4193,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 // Forward referencee of one or more bases, try again later\n                 cldec->_scope = scx ? scx : sc->copy();\n                 cldec->_scope->setNoFree();\n-                cldec->_scope->_module->addDeferredSemantic(cldec);\n+                Module::addDeferredSemantic(cldec);\n                 //printf(\"\\tL%d semantic('%s') failed due to forward references\\n\", __LINE__, cldec->toChars());\n                 return;\n             }\n@@ -4254,8 +4306,8 @@ class DsymbolSemanticVisitor : public Visitor\n                 cldec->_scope = scx ? scx : sc->copy();\n                 cldec->_scope->setNoFree();\n                 if (tc->sym->_scope)\n-                    tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-                cldec->_scope->_module->addDeferredSemantic(cldec);\n+                    Module::addDeferredSemantic(tc->sym);\n+                Module::addDeferredSemantic(cldec);\n                 //printf(\"\\tL%d semantic('%s') failed due to forward references\\n\", __LINE__, cldec->toChars());\n                 return;\n             }\n@@ -4359,7 +4411,7 @@ class DsymbolSemanticVisitor : public Visitor\n \n             cldec->_scope = scx ? scx : sc->copy();\n             cldec->_scope->setNoFree();\n-            cldec->_scope->_module->addDeferredSemantic(cldec);\n+            Module::addDeferredSemantic(cldec);\n             //printf(\"\\tdeferring %s\\n\", cldec->toChars());\n             return;\n         }\n@@ -4628,7 +4680,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 {\n                     //printf(\"\\ttry later, forward reference of base %s\\n\", tc->sym->toChars());\n                     if (tc->sym->_scope)\n-                        tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n+                        Module::addDeferredSemantic(tc->sym);\n                     idec->baseok = BASEOKnone;\n                 }\n                 i++;\n@@ -4638,7 +4690,7 @@ class DsymbolSemanticVisitor : public Visitor\n                 // Forward referencee of one or more bases, try again later\n                 idec->_scope = scx ? scx : sc->copy();\n                 idec->_scope->setNoFree();\n-                idec->_scope->_module->addDeferredSemantic(idec);\n+                Module::addDeferredSemantic(idec);\n                 return;\n             }\n             idec->baseok = BASEOKdone;\n@@ -4682,8 +4734,8 @@ class DsymbolSemanticVisitor : public Visitor\n                 idec->_scope = scx ? scx : sc->copy();\n                 idec->_scope->setNoFree();\n                 if (tc->sym->_scope)\n-                    tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-                idec->_scope->_module->addDeferredSemantic(idec);\n+                    Module::addDeferredSemantic(tc->sym);\n+                Module::addDeferredSemantic(idec);\n                 return;\n             }\n         }\n@@ -5335,6 +5387,7 @@ void aliasSemantic(AliasDeclaration *ds, Scope *sc)\n     ds->userAttribDecl = sc->userAttribDecl;\n \n     // TypeTraits needs to know if it's located in an AliasDeclaration\n+    const unsigned oldflags = sc->flags;\n     sc->flags |= SCOPEalias;\n \n     if (ds->aliassym)\n@@ -5345,7 +5398,7 @@ void aliasSemantic(AliasDeclaration *ds, Scope *sc)\n         {\n             if (fd && fd->semanticRun >= PASSsemanticdone)\n             {\n-                sc->flags &= ~SCOPEalias;\n+                sc->flags = oldflags;\n                 return;\n             }\n \n@@ -5361,13 +5414,13 @@ void aliasSemantic(AliasDeclaration *ds, Scope *sc)\n                 ds->aliassym = NULL;\n                 ds->type = Type::terror;\n             }\n-            sc->flags &= ~SCOPEalias;\n+            sc->flags = oldflags;\n             return;\n         }\n \n         if (ds->aliassym->isTemplateInstance())\n             dsymbolSemantic(ds->aliassym, sc);\n-        sc->flags &= ~SCOPEalias;\n+        sc->flags = oldflags;\n         return;\n     }\n     ds->inuse = 1;\n@@ -5472,7 +5525,7 @@ void aliasSemantic(AliasDeclaration *ds, Scope *sc)\n         if (!ds->overloadInsert(sx))\n             ScopeDsymbol::multiplyDefined(Loc(), sx, ds);\n     }\n-    sc->flags &= ~SCOPEalias;\n+    sc->flags = oldflags;\n }\n \n "}, {"sha": "208b064aafbfb1396f10c98e47d2d105372ae9be", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 142, "deletions": 68, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -156,17 +156,14 @@ Dsymbol *getDsymbol(RootObject *oarg)\n     if (ea)\n     {\n         // Try to convert Expression to symbol\n-        if (ea->op == TOKvar)\n-            sa = ((VarExp *)ea)->var;\n-        else if (ea->op == TOKfunction)\n-        {\n-            if (((FuncExp *)ea)->td)\n-                sa = ((FuncExp *)ea)->td;\n-            else\n-                sa = ((FuncExp *)ea)->fd;\n-        }\n-        else if (ea->op == TOKtemplate)\n-            sa = ((TemplateExp *)ea)->td;\n+        if (VarExp *ve = ea->isVarExp())\n+            sa = ve->var;\n+        else if (FuncExp *fe = ea->isFuncExp())\n+            sa = fe->td ? (Dsymbol *)fe->td : (Dsymbol *)fe->fd;\n+        else if (TemplateExp *te = ea->isTemplateExp())\n+            sa = te->td;\n+        else if (ScopeExp *se = ea->isScopeExp())\n+            sa = se->sds;\n         else\n             sa = NULL;\n     }\n@@ -536,6 +533,7 @@ TemplateDeclaration::TemplateDeclaration(Loc loc, Identifier *id,\n     this->isstatic = true;\n     this->previous = NULL;\n     this->protection = Prot(Prot::undefined);\n+    this->inuse = 0;\n     this->instances = NULL;\n \n     // Compute in advance for Ddoc's use\n@@ -770,7 +768,9 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n         Declaration *sparam;\n \n         //printf(\"\\targument [%d]\\n\", i);\n+        inuse++;\n         m2 = tp->matchArg(ti->loc, paramscope, ti->tiargs, i, parameters, dedtypes, &sparam);\n+        inuse--;\n         //printf(\"\\tm2 = %d\\n\", m2);\n \n         if (m2 == MATCHnomatch)\n@@ -1397,7 +1397,9 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                         }\n                         else\n                         {\n+                            inuse++;\n                             oded = tparam->defaultArg(instLoc, paramscope);\n+                            inuse--;\n                             if (oded)\n                                 (*dedargs)[i] = declareParameter(paramscope, tparam, oded);\n                         }\n@@ -1771,7 +1773,9 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             }\n             else\n             {\n+                inuse++;\n                 oded = tparam->defaultArg(instLoc, paramscope);\n+                inuse--;\n                 if (!oded)\n                 {\n                     // if tuple parameter and\n@@ -1997,18 +2001,19 @@ bool TemplateDeclaration::isOverloadable()\n /*************************************************\n  * Given function arguments, figure out which template function\n  * to expand, and return matching result.\n- * Input:\n- *      m               matching result\n- *      dstart          the root of overloaded function templates\n- *      loc             instantiation location\n- *      sc              instantiation scope\n- *      tiargs          initial list of template arguments\n- *      tthis           if !NULL, the 'this' pointer argument\n- *      fargs           arguments to function\n+ * Params:\n+ *      m           = matching result\n+ *      dstart      = the root of overloaded function templates\n+ *      loc         = instantiation location\n+ *      sc          = instantiation scope\n+ *      tiargs      = initial list of template arguments\n+ *      tthis       = if !NULL, the 'this' pointer argument\n+ *      fargs       = arguments to function\n+ *      pMessage    = address to store error message, or null\n  */\n \n void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n-        Objects *tiargs, Type *tthis, Expressions *fargs)\n+    Objects *tiargs, Type *tthis, Expressions *fargs, const char **pMessage)\n {\n     struct ParamDeduce\n     {\n@@ -2018,6 +2023,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n         Type *tthis;\n         Objects *tiargs;\n         Expressions *fargs;\n+        const char **pMessage;\n         // result\n         Match *m;\n         int property;   // 0: unintialized\n@@ -2093,7 +2099,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n                 else\n                     return 0;   // MATCHnomatch\n             }\n-            MATCH mfa = tf->callMatch(tthis_fd, fargs);\n+            MATCH mfa = tf->callMatch(tthis_fd, fargs, 0, pMessage);\n             //printf(\"test1: mfa = %d\\n\", mfa);\n             if (mfa > MATCHnomatch)\n             {\n@@ -2180,8 +2186,12 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n         int applyTemplate(TemplateDeclaration *td)\n         {\n             //printf(\"applyTemplate()\\n\");\n-            // skip duplicates\n-            if (td == td_best)\n+            if (td->inuse)\n+            {\n+                td->error(loc, \"recursive template expansion\");\n+                return 1;\n+            }\n+            if (td == td_best)  // skip duplicates\n                 return 0;\n \n             if (!sc)\n@@ -2431,6 +2441,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n     p.tthis  = tthis;\n     p.tiargs = tiargs;\n     p.fargs  = fargs;\n+    p.pMessage = pMessage;\n \n     // result\n     p.m          = m;\n@@ -5165,6 +5176,16 @@ MATCH TemplateAliasParameter::matchArg(Scope *sc, RootObject *oarg,\n              *  template X(T) {}        // T => sa\n              */\n         }\n+        else if (ta && ta->ty != Tident)\n+        {\n+            /* Match any type that's not a TypeIdentifier to alias parameters,\n+             * but prefer type parameter.\n+             * template X(alias a) { }  // a == ta\n+             *\n+             * TypeIdentifiers are excluded because they might be not yet resolved aliases.\n+             */\n+            m = MATCHconvert;\n+        }\n         else\n             goto Lnomatch;\n     }\n@@ -5485,12 +5506,15 @@ RootObject *TemplateValueParameter::defaultArg(Loc instLoc, Scope *sc)\n     if (e)\n     {\n         e = e->syntaxCopy();\n+        unsigned olderrs = global.errors;\n         if ((e = expressionSemantic(e, sc)) == NULL)\n             return NULL;\n         if ((e = resolveProperties(sc, e)) == NULL)\n             return NULL;\n         e = e->resolveLoc(instLoc, sc);     // use the instantiated loc\n         e = e->optimize(WANTvalue);\n+        if (global.errors != olderrs)\n+            e = new ErrorExp();\n     }\n     return e;\n }\n@@ -6049,6 +6073,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n         if (ta)\n         {\n             //printf(\"type %s\\n\", ta->toChars());\n+\n             // It might really be an Expression or an Alias\n             ta->resolve(loc, sc, &ea, &ta, &sa, (flags & 1) != 0);\n             if (ea) goto Lexpr;\n@@ -6270,6 +6295,7 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n     }\n \n     unsigned errs = global.errors;\n+    TemplateDeclaration *td_last = NULL;\n \n   struct ParamBest\n   {\n@@ -6291,7 +6317,11 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n         TemplateDeclaration *td = s->isTemplateDeclaration();\n         if (!td)\n             return 0;\n-\n+        if (td->inuse)\n+        {\n+            td->error(ti->loc, \"recursive template expansion\");\n+            return 1;\n+        }\n         if (td == td_best)          // skip duplicates\n             return 0;\n \n@@ -6349,8 +6379,6 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n     /* Since there can be multiple TemplateDeclaration's with the same\n      * name, look for the best match.\n      */\n-    TemplateDeclaration *td_last = NULL;\n-\n     OverloadSet *tovers = tempdecl->isOverloadSet();\n     size_t overs_dim = tovers ? tovers->a.length : 1;\n     for (size_t oi = 0; oi < overs_dim; oi++)\n@@ -6359,7 +6387,9 @@ bool TemplateInstance::findBestMatch(Scope *sc, Expressions *fargs)\n         p.td_best  = NULL;\n         p.td_ambig = NULL;\n         p.m_best   = MATCHnomatch;\n-        overloadApply(tovers ? tovers->a[oi] : tempdecl, &p, &ParamBest::fp);\n+\n+        Dsymbol *dstart = tovers ? tovers->a[oi] : tempdecl;\n+        overloadApply(dstart, &p, &ParamBest::fp);\n \n         if (p.td_ambig)\n         {\n@@ -6481,8 +6511,11 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n     {\n         TemplateDeclaration *td = s->isTemplateDeclaration();\n         if (!td)\n-        {\n             return 0;\n+        if (td->inuse)\n+        {\n+            td->error(ti->loc, \"recursive template expansion\");\n+            return 1;\n         }\n \n         /* If any of the overloaded template declarations need inference,\n@@ -7128,6 +7161,68 @@ void unSpeculative(Scope *sc, RootObject *o)\n         unSpeculative(sc, ti);\n }\n \n+/**\n+    Returns: true if the instances' innards are discardable.\n+\n+    The idea of this function is to see if the template instantiation\n+    can be 100% replaced with its eponymous member. All other members\n+    can be discarded, even in the compiler to free memory (for example,\n+    the template could be expanded in a region allocator, deemed trivial,\n+    the end result copied back out independently and the entire region freed),\n+    and can be elided entirely from the binary.\n+\n+    The current implementation affects code that generally looks like:\n+\n+    ---\n+    template foo(args...) {\n+        some_basic_type_or_string helper() { .... }\n+        enum foo = helper();\n+    }\n+    ---\n+\n+    since it was the easiest starting point of implementation but it can and\n+    should be expanded more later.\n+*/\n+static bool isDiscardable(TemplateInstance *ti)\n+{\n+    if (ti->aliasdecl == NULL)\n+        return false;\n+\n+    VarDeclaration *v = ti->aliasdecl->isVarDeclaration();\n+    if (v == NULL)\n+        return false;\n+\n+    if (!(v->storage_class & STCmanifest))\n+        return false;\n+\n+    // Currently only doing basic types here because it is the easiest proof-of-concept\n+    // implementation with minimal risk of side effects, but it could likely be\n+    // expanded to any type that already exists outside this particular instance.\n+    if (!(v->type->equals(Type::tstring) || (v->type->isTypeBasic() != NULL)))\n+        return false;\n+\n+    // Static ctors and dtors, even in an eponymous enum template, are still run,\n+    // so if any of them are in here, we'd better not assume it is trivial lest\n+    // we break useful code\n+    for (size_t i = 0; i < ti->members->length; i++)\n+    {\n+        Dsymbol *member = (*ti->members)[i];\n+        if (member->hasStaticCtorOrDtor())\n+            return false;\n+        if (member->isStaticDtorDeclaration())\n+            return false;\n+        if (member->isStaticCtorDeclaration())\n+            return false;\n+    }\n+\n+    // but if it passes through this gauntlet... it should be fine. D code will\n+    // see only the eponymous member, outside stuff can never access it, even through\n+    // reflection; the outside world ought to be none the wiser. Even dmd should be\n+    // able to simply free the memory of everything except the final result.\n+\n+    return true;\n+}\n+\n /***********************************************\n  * Returns true if this is not instantiated in non-root module, and\n  * is a part of non-speculative instantiatiation.\n@@ -7137,38 +7232,6 @@ void unSpeculative(Scope *sc, RootObject *o)\n  */\n bool TemplateInstance::needsCodegen()\n {\n-    // Now -allInst is just for the backward compatibility.\n-    if (global.params.allInst)\n-    {\n-        //printf(\"%s minst = %s, enclosing (%s)->isNonRoot = %d\\n\",\n-        //    toPrettyChars(), minst ? minst->toChars() : NULL,\n-        //    enclosing ? enclosing->toPrettyChars() : NULL, enclosing && enclosing->inNonRoot());\n-        if (enclosing)\n-        {\n-            // Bugzilla 14588: If the captured context is not a function\n-            // (e.g. class), the instance layout determination is guaranteed,\n-            // because the semantic/semantic2 pass will be executed\n-            // even for non-root instances.\n-            if (!enclosing->isFuncDeclaration())\n-                return true;\n-\n-            // Bugzilla 14834: If the captured context is a function,\n-            // this excessive instantiation may cause ODR violation, because\n-            // -allInst and others doesn't guarantee the semantic3 execution\n-            // for that function.\n-\n-            // If the enclosing is also an instantiated function,\n-            // we have to rely on the ancestor's needsCodegen() result.\n-            if (TemplateInstance *ti = enclosing->isInstantiated())\n-                return ti->needsCodegen();\n-\n-            // Bugzilla 13415: If and only if the enclosing scope needs codegen,\n-            // this nested templates would also need code generation.\n-            return !enclosing->inNonRoot();\n-        }\n-        return true;\n-    }\n-\n     if (!minst)\n     {\n         // If this is a speculative instantiation,\n@@ -7185,13 +7248,21 @@ bool TemplateInstance::needsCodegen()\n         if (tinst && tinst->needsCodegen())\n         {\n             minst = tinst->minst;   // cache result\n+            if (global.params.allInst && minst)\n+            {\n+                return true;\n+            }\n             assert(minst);\n             assert(minst->isRoot() || minst->rootImports());\n             return true;\n         }\n         if (tnext && (tnext->needsCodegen() || tnext->minst))\n         {\n             minst = tnext->minst;   // cache result\n+            if (global.params.allInst && minst)\n+            {\n+                return true;\n+            }\n             assert(minst);\n             return minst->isRoot() || minst->rootImports();\n         }\n@@ -7200,6 +7271,16 @@ bool TemplateInstance::needsCodegen()\n         return false;\n     }\n \n+    if (global.params.allInst)\n+    {\n+        return true;\n+    }\n+\n+    if (isDiscardable(this))\n+    {\n+        return false;\n+    }\n+\n     /* Even when this is reached to the codegen pass,\n      * a non-root nested template should not generate code,\n      * due to avoid ODR violation.\n@@ -7221,14 +7302,7 @@ bool TemplateInstance::needsCodegen()\n         return false;\n     }\n \n-    /* The issue is that if the importee is compiled with a different -debug\n-     * setting than the importer, the importer may believe it exists\n-     * in the compiled importee when it does not, when the instantiation\n-     * is behind a conditional debug declaration.\n-     */\n-    // workaround for Bugzilla 11239\n-    if (global.params.useUnitTests ||\n-        global.params.debuglevel)\n+    if (global.params.useUnitTests)\n     {\n         // Prefer instantiations from root modules, to maximize link-ability.\n         if (minst->isRoot())"}, {"sha": "2592b38d961b74354fc292bb2853027bb75fae3c", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 208, "deletions": 2010, "changes": 2218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -43,110 +43,10 @@ VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n Expression *extractSideEffect(Scope *sc, const char *name, Expression **e0, Expression *e, bool alwaysCopy = false);\n char *MODtoChars(MOD mod);\n bool MODimplicitConv(MOD modfrom, MOD modto);\n-MOD MODmerge(MOD mod1, MOD mod2);\n void MODMatchToBuffer(OutBuffer *buf, unsigned char lhsMod, unsigned char rhsMod);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n bool checkUnsafeAccess(Scope *sc, Expression *e, bool readonly, bool printmsg);\n-\n-/*************************************************************\n- * Given var, we need to get the\n- * right 'this' pointer if var is in an outer class, but our\n- * existing 'this' pointer is in an inner class.\n- * Input:\n- *      e1      existing 'this'\n- *      ad      struct or class we need the correct 'this' for\n- *      var     the specific member of ad we're accessing\n- */\n-\n-Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad,\n-        Expression *e1, Declaration *var, int flag = 0)\n-{\n-    //printf(\"\\ngetRightThis(e1 = %s, ad = %s, var = %s)\\n\", e1->toChars(), ad->toChars(), var->toChars());\n- L1:\n-    Type *t = e1->type->toBasetype();\n-    //printf(\"e1->type = %s, var->type = %s\\n\", e1->type->toChars(), var->type->toChars());\n-\n-    /* If e1 is not the 'this' pointer for ad\n-     */\n-    if (ad &&\n-        !(t->ty == Tpointer && t->nextOf()->ty == Tstruct &&\n-          ((TypeStruct *)t->nextOf())->sym == ad)\n-        &&\n-        !(t->ty == Tstruct &&\n-          ((TypeStruct *)t)->sym == ad)\n-       )\n-    {\n-        ClassDeclaration *cd = ad->isClassDeclaration();\n-        ClassDeclaration *tcd = t->isClassHandle();\n-\n-        /* e1 is the right this if ad is a base class of e1\n-         */\n-        if (!cd || !tcd ||\n-            !(tcd == cd || cd->isBaseOf(tcd, NULL))\n-           )\n-        {\n-            /* Only classes can be inner classes with an 'outer'\n-             * member pointing to the enclosing class instance\n-             */\n-            if (tcd && tcd->isNested())\n-            {\n-                /* e1 is the 'this' pointer for an inner class: tcd.\n-                 * Rewrite it as the 'this' pointer for the outer class.\n-                 */\n-\n-                e1 = new DotVarExp(loc, e1, tcd->vthis);\n-                e1->type = tcd->vthis->type;\n-                e1->type = e1->type->addMod(t->mod);\n-                // Do not call checkNestedRef()\n-                //e1 = expressionSemantic(e1, sc);\n-\n-                // Skip up over nested functions, and get the enclosing\n-                // class type.\n-                int n = 0;\n-                Dsymbol *s;\n-                for (s = tcd->toParent();\n-                     s && s->isFuncDeclaration();\n-                     s = s->toParent())\n-                {\n-                    FuncDeclaration *f = s->isFuncDeclaration();\n-                    if (f->vthis)\n-                    {\n-                        //printf(\"rewriting e1 to %s's this\\n\", f->toChars());\n-                        n++;\n-                        e1 = new VarExp(loc, f->vthis);\n-                    }\n-                    else\n-                    {\n-                        e1->error(\"need `this` of type %s to access member %s\"\n-                                  \" from static function %s\",\n-                            ad->toChars(), var->toChars(), f->toChars());\n-                        e1 = new ErrorExp();\n-                        return e1;\n-                    }\n-                }\n-                if (s && s->isClassDeclaration())\n-                {\n-                    e1->type = s->isClassDeclaration()->type;\n-                    e1->type = e1->type->addMod(t->mod);\n-                    if (n > 1)\n-                        e1 = expressionSemantic(e1, sc);\n-                }\n-                else\n-                    e1 = expressionSemantic(e1, sc);\n-                goto L1;\n-            }\n-\n-            /* Can't find a path from e1 to ad\n-             */\n-            if (flag)\n-                return NULL;\n-            e1->error(\"this for %s needs to be type %s not type %s\",\n-                var->toChars(), ad->toChars(), t->toChars());\n-            return new ErrorExp();\n-        }\n-    }\n-    return e1;\n-}\n+void toAutoQualChars(const char **result, Type *t1, Type *t2);\n \n /*****************************************\n  * Determine if 'this' is available.\n@@ -230,817 +130,112 @@ bool isNeedThisScope(Scope *sc, Declaration *d)\n     return true;\n }\n \n-/***************************************\n- * Pull out any properties.\n+/******************************\n+ * check e is exp.opDispatch!(tiargs) or not\n+ * It's used to switch to UFCS the semantic analysis path\n  */\n \n-Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n+bool isDotOpDispatch(Expression *e)\n {\n-    //printf(\"resolvePropertiesX, e1 = %s %s, e2 = %s\\n\", Token::toChars(e1->op), e1->toChars(), e2 ? e2->toChars() : NULL);\n-    Loc loc = e1->loc;\n-\n-    OverloadSet *os;\n-    Dsymbol *s;\n-    Objects *tiargs;\n-    Type *tthis;\n-    if (e1->op == TOKdot)\n-    {\n-        DotExp *de = (DotExp *)e1;\n-        if (de->e2->op == TOKoverloadset)\n-        {\n-            tiargs = NULL;\n-            tthis  = de->e1->type;\n-            os = ((OverExp *)de->e2)->vars;\n-            goto Los;\n-        }\n-    }\n-    else if (e1->op == TOKoverloadset)\n-    {\n-        tiargs = NULL;\n-        tthis  = NULL;\n-        os = ((OverExp *)e1)->vars;\n-    Los:\n-        assert(os);\n-        FuncDeclaration *fd = NULL;\n-        if (e2)\n-        {\n-            e2 = expressionSemantic(e2, sc);\n-            if (e2->op == TOKerror)\n-                return new ErrorExp();\n-            e2 = resolveProperties(sc, e2);\n+    return e->op == TOKdotti &&\n+           ((DotTemplateInstanceExp *)e)->ti->name == Id::opDispatch;\n+}\n \n-            Expressions a;\n-            a.push(e2);\n+/****************************************\n+ * Expand tuples.\n+ * Input:\n+ *      exps    aray of Expressions\n+ * Output:\n+ *      exps    rewritten in place\n+ */\n \n-            for (size_t i = 0; i < os->a.length; i++)\n-            {\n-                FuncDeclaration *f = resolveFuncCall(loc, sc, os->a[i], tiargs, tthis, &a, 1);\n-                if (f)\n-                {\n-                    if (f->errors)\n-                        return new ErrorExp();\n-                    fd = f;\n-                    assert(fd->type->ty == Tfunction);\n-                }\n-            }\n-            if (fd)\n-            {\n-                Expression *e = new CallExp(loc, e1, e2);\n-                return expressionSemantic(e, sc);\n-            }\n-        }\n-        {\n-            for (size_t i = 0; i < os->a.length; i++)\n-            {\n-                FuncDeclaration *f = resolveFuncCall(loc, sc, os->a[i], tiargs, tthis, NULL, 1);\n-                if (f)\n-                {\n-                    if (f->errors)\n-                        return new ErrorExp();\n-                    fd = f;\n-                    assert(fd->type->ty == Tfunction);\n-                    TypeFunction *tf = (TypeFunction *)fd->type;\n-                    if (!tf->isref && e2)\n-                        goto Leproplvalue;\n-                }\n-            }\n-            if (fd)\n-            {\n-                Expression *e = new CallExp(loc, e1);\n-                if (e2)\n-                    e = new AssignExp(loc, e, e2);\n-                return expressionSemantic(e, sc);\n-            }\n-        }\n-        if (e2)\n-            goto Leprop;\n-    }\n-    else if (e1->op == TOKdotti)\n-    {\n-        DotTemplateInstanceExp* dti = (DotTemplateInstanceExp *)e1;\n-        if (!dti->findTempDecl(sc))\n-            goto Leprop;\n-        if (!dti->ti->semanticTiargs(sc))\n-            goto Leprop;\n-        tiargs = dti->ti->tiargs;\n-        tthis  = dti->e1->type;\n-        if ((os = dti->ti->tempdecl->isOverloadSet()) != NULL)\n-            goto Los;\n-        if ((s = dti->ti->tempdecl) != NULL)\n-            goto Lfd;\n-    }\n-    else if (e1->op == TOKdottd)\n-    {\n-        DotTemplateExp *dte = (DotTemplateExp *)e1;\n-        s      = dte->td;\n-        tiargs = NULL;\n-        tthis  = dte->e1->type;\n-        goto Lfd;\n-    }\n-    else if (e1->op == TOKscope)\n-    {\n-        s = ((ScopeExp *)e1)->sds;\n-        TemplateInstance *ti = s->isTemplateInstance();\n-        if (ti && !ti->semanticRun && ti->tempdecl)\n-        {\n-            //assert(ti->needsTypeInference(sc));\n-            if (!ti->semanticTiargs(sc))\n-                goto Leprop;\n-            tiargs = ti->tiargs;\n-            tthis  = NULL;\n-            if ((os = ti->tempdecl->isOverloadSet()) != NULL)\n-                goto Los;\n-            if ((s = ti->tempdecl) != NULL)\n-                goto Lfd;\n-        }\n-    }\n-    else if (e1->op == TOKtemplate)\n-    {\n-        s      = ((TemplateExp *)e1)->td;\n-        tiargs = NULL;\n-        tthis  = NULL;\n-        goto Lfd;\n-    }\n-    else if (e1->op == TOKdotvar && e1->type && e1->type->toBasetype()->ty == Tfunction)\n-    {\n-        DotVarExp *dve = (DotVarExp *)e1;\n-        s      = dve->var->isFuncDeclaration();\n-        tiargs = NULL;\n-        tthis  = dve->e1->type;\n-        goto Lfd;\n-    }\n-    else if (e1->op == TOKvar && e1->type && e1->type->toBasetype()->ty == Tfunction)\n+void expandTuples(Expressions *exps)\n+{\n+    //printf(\"expandTuples()\\n\");\n+    if (exps)\n     {\n-        s      = ((VarExp *)e1)->var->isFuncDeclaration();\n-        tiargs = NULL;\n-        tthis  = NULL;\n-    Lfd:\n-        assert(s);\n-        if (e2)\n+        for (size_t i = 0; i < exps->length; i++)\n         {\n-            e2 = expressionSemantic(e2, sc);\n-            if (e2->op == TOKerror)\n-                return new ErrorExp();\n-            e2 = resolveProperties(sc, e2);\n-\n-            Expressions a;\n-            a.push(e2);\n+            Expression *arg = (*exps)[i];\n+            if (!arg)\n+                continue;\n \n-            FuncDeclaration *fd = resolveFuncCall(loc, sc, s, tiargs, tthis, &a, 1);\n-            if (fd && fd->type)\n-            {\n-                if (fd->errors)\n-                    return new ErrorExp();\n-                assert(fd->type->ty == Tfunction);\n-                Expression *e = new CallExp(loc, e1, e2);\n-                return expressionSemantic(e, sc);\n-            }\n-        }\n-        {\n-            FuncDeclaration *fd = resolveFuncCall(loc, sc, s, tiargs, tthis, NULL, 1);\n-            if (fd && fd->type)\n+            // Look for tuple with 0 members\n+            if (arg->op == TOKtype)\n             {\n-                if (fd->errors)\n-                    return new ErrorExp();\n-                assert(fd->type->ty == Tfunction);\n-                TypeFunction *tf = (TypeFunction *)fd->type;\n-                if (!e2 || tf->isref)\n+                TypeExp *e = (TypeExp *)arg;\n+                if (e->type->toBasetype()->ty == Ttuple)\n                 {\n-                    Expression *e = new CallExp(loc, e1);\n-                    if (e2)\n-                        e = new AssignExp(loc, e, e2);\n-                    return expressionSemantic(e, sc);\n-                }\n-            }\n-        }\n-        if (FuncDeclaration *fd = s->isFuncDeclaration())\n-        {\n-            // Keep better diagnostic message for invalid property usage of functions\n-            assert(fd->type->ty == Tfunction);\n-            Expression *e = new CallExp(loc, e1, e2);\n-            return expressionSemantic(e, sc);\n-        }\n-        if (e2)\n-            goto Leprop;\n-    }\n-    if (e1->op == TOKvar)\n-    {\n-        VarExp *ve = (VarExp *)e1;\n-        VarDeclaration *v = ve->var->isVarDeclaration();\n-        if (v && ve->checkPurity(sc, v))\n-            return new ErrorExp();\n-    }\n-    if (e2)\n-        return NULL;\n-\n-    if (e1->type &&\n-        e1->op != TOKtype)      // function type is not a property\n-    {\n-        /* Look for e1 being a lazy parameter; rewrite as delegate call\n-         */\n-        if (e1->op == TOKvar)\n-        {\n-            VarExp *ve = (VarExp *)e1;\n+                    TypeTuple *tt = (TypeTuple *)e->type->toBasetype();\n \n-            if (ve->var->storage_class & STClazy)\n-            {\n-                Expression *e = new CallExp(loc, e1);\n-                return expressionSemantic(e, sc);\n+                    if (!tt->arguments || tt->arguments->length == 0)\n+                    {\n+                        exps->remove(i);\n+                        if (i == exps->length)\n+                            return;\n+                        i--;\n+                        continue;\n+                    }\n+                }\n             }\n-        }\n-        else if (e1->op == TOKdotvar)\n-        {\n-            // Check for reading overlapped pointer field in @safe code.\n-            if (checkUnsafeAccess(sc, e1, true, true))\n-                return new ErrorExp();\n-        }\n-        else if (e1->op == TOKdot)\n-        {\n-            e1->error(\"expression has no value\");\n-            return new ErrorExp();\n-        }\n-        else if (e1->op == TOKcall)\n-        {\n-            CallExp *ce = (CallExp *)e1;\n-            // Check for reading overlapped pointer field in @safe code.\n-            if (checkUnsafeAccess(sc, ce->e1, true, true))\n-                return new ErrorExp();\n-        }\n-    }\n-\n-    if (!e1->type)\n-    {\n-        error(loc, \"cannot resolve type for %s\", e1->toChars());\n-        e1 = new ErrorExp();\n-    }\n-    return e1;\n-\n-Leprop:\n-    error(loc, \"not a property %s\", e1->toChars());\n-    return new ErrorExp();\n-\n-Leproplvalue:\n-    error(loc, \"%s is not an lvalue\", e1->toChars());\n-    return new ErrorExp();\n-}\n-\n-Expression *resolveProperties(Scope *sc, Expression *e)\n-{\n-    //printf(\"resolveProperties(%s)\\n\", e->toChars());\n-\n-    e = resolvePropertiesX(sc, e);\n-    if (e->checkRightThis(sc))\n-        return new ErrorExp();\n-    return e;\n-}\n-\n-/******************************\n- * Check the tail CallExp is really property function call.\n- */\n-static bool checkPropertyCall(Expression *e)\n-{\n-    while (e->op == TOKcomma)\n-        e = ((CommaExp *)e)->e2;\n \n-    if (e->op == TOKcall)\n-    {\n-        CallExp *ce = (CallExp *)e;\n-        TypeFunction *tf;\n-        if (ce->f)\n-        {\n-            tf = (TypeFunction *)ce->f->type;\n-            /* If a forward reference to ce->f, try to resolve it\n-             */\n-            if (!tf->deco && ce->f->semanticRun < PASSsemanticdone)\n+            // Inline expand all the tuples\n+            while (arg->op == TOKtuple)\n             {\n-                dsymbolSemantic(ce->f, NULL);\n-                tf = (TypeFunction *)ce->f->type;\n+                TupleExp *te = (TupleExp *)arg;\n+                exps->remove(i);                // remove arg\n+                exps->insert(i, te->exps);      // replace with tuple contents\n+                if (i == exps->length)\n+                    return;             // empty tuple, no more arguments\n+                (*exps)[i] = Expression::combine(te->e0, (*exps)[i]);\n+                arg = (*exps)[i];\n             }\n         }\n-        else if (ce->e1->type->ty == Tfunction)\n-            tf = (TypeFunction *)ce->e1->type;\n-        else if (ce->e1->type->ty == Tdelegate)\n-            tf = (TypeFunction *)ce->e1->type->nextOf();\n-        else if (ce->e1->type->ty == Tpointer && ce->e1->type->nextOf()->ty == Tfunction)\n-            tf = (TypeFunction *)ce->e1->type->nextOf();\n-        else\n-            assert(0);\n     }\n-    return false;\n }\n \n-/******************************\n- * If e1 is a property function (template), resolve it.\n+/****************************************\n+ * Expand alias this tuples.\n  */\n \n-Expression *resolvePropertiesOnly(Scope *sc, Expression *e1)\n+TupleDeclaration *isAliasThisTuple(Expression *e)\n {\n-    //printf(\"e1 = %s %s\\n\", Token::toChars(e1->op), e1->toChars());\n-    OverloadSet *os;\n-    FuncDeclaration *fd;\n-    TemplateDeclaration *td;\n+    if (!e->type)\n+        return NULL;\n \n-    if (e1->op == TOKdot)\n-    {\n-        DotExp *de = (DotExp *)e1;\n-        if (de->e2->op == TOKoverloadset)\n-        {\n-            os = ((OverExp *)de->e2)->vars;\n-            goto Los;\n-        }\n-    }\n-    else if (e1->op == TOKoverloadset)\n-    {\n-        os = ((OverExp *)e1)->vars;\n-    Los:\n-        assert(os);\n-        for (size_t i = 0; i < os->a.length; i++)\n-        {\n-            Dsymbol *s = os->a[i];\n-            fd = s->isFuncDeclaration();\n-            td = s->isTemplateDeclaration();\n-            if (fd)\n-            {\n-                if (((TypeFunction *)fd->type)->isproperty)\n-                    return resolveProperties(sc, e1);\n-            }\n-            else if (td && td->onemember &&\n-                     (fd = td->onemember->isFuncDeclaration()) != NULL)\n-            {\n-                if (((TypeFunction *)fd->type)->isproperty ||\n-                    (fd->storage_class2 & STCproperty) ||\n-                    (td->_scope->stc & STCproperty))\n-                {\n-                    return resolveProperties(sc, e1);\n-                }\n-            }\n-        }\n-    }\n-    else if (e1->op == TOKdotti)\n-    {\n-        DotTemplateInstanceExp* dti = (DotTemplateInstanceExp *)e1;\n-        if (dti->ti->tempdecl && (td = dti->ti->tempdecl->isTemplateDeclaration()) != NULL)\n-            goto Ltd;\n-    }\n-    else if (e1->op == TOKdottd)\n-    {\n-        td = ((DotTemplateExp *)e1)->td;\n-        goto Ltd;\n-    }\n-    else if (e1->op == TOKscope)\n-    {\n-        Dsymbol *s = ((ScopeExp *)e1)->sds;\n-        TemplateInstance *ti = s->isTemplateInstance();\n-        if (ti && !ti->semanticRun && ti->tempdecl)\n-        {\n-            if ((td = ti->tempdecl->isTemplateDeclaration()) != NULL)\n-                goto Ltd;\n-        }\n-    }\n-    else if (e1->op == TOKtemplate)\n+    Type *t = e->type->toBasetype();\n+Lagain:\n+    if (Dsymbol *s = t->toDsymbol(NULL))\n     {\n-        td = ((TemplateExp *)e1)->td;\n-    Ltd:\n-        assert(td);\n-        if (td->onemember &&\n-            (fd = td->onemember->isFuncDeclaration()) != NULL)\n+        AggregateDeclaration *ad = s->isAggregateDeclaration();\n+        if (ad)\n         {\n-            if (((TypeFunction *)fd->type)->isproperty ||\n-                (fd->storage_class2 & STCproperty) ||\n-                (td->_scope->stc & STCproperty))\n+            s = ad->aliasthis;\n+            if (s && s->isVarDeclaration())\n             {\n-                return resolveProperties(sc, e1);\n+                TupleDeclaration *td = s->isVarDeclaration()->toAlias()->isTupleDeclaration();\n+                if (td && td->isexp)\n+                    return td;\n             }\n-        }\n-    }\n-    else if (e1->op == TOKdotvar && e1->type->ty == Tfunction)\n-    {\n-        DotVarExp *dve = (DotVarExp *)e1;\n-        fd = dve->var->isFuncDeclaration();\n-        goto Lfd;\n-    }\n-    else if (e1->op == TOKvar && e1->type->ty == Tfunction &&\n-        (sc->intypeof || !((VarExp *)e1)->var->needThis()))\n-    {\n-        fd = ((VarExp *)e1)->var->isFuncDeclaration();\n-    Lfd:\n-        assert(fd);\n-        if (((TypeFunction *)fd->type)->isproperty)\n-            return resolveProperties(sc, e1);\n-    }\n-    return e1;\n-}\n-\n-\n-// TODO: merge with Scope::search::searchScopes()\n-static Dsymbol *searchScopes(Scope *sc, Loc loc, Identifier *ident, int flags)\n-{\n-    Dsymbol *s = NULL;\n-    for (Scope *scx = sc; scx; scx = scx->enclosing)\n-    {\n-        if (!scx->scopesym)\n-            continue;\n-        if (scx->scopesym->isModule())\n-            flags |= SearchUnqualifiedModule;    // tell Module.search() that SearchLocalsOnly is to be obeyed\n-        s = scx->scopesym->search(loc, ident, flags);\n-        if (s)\n-        {\n-            // overload set contains only module scope symbols.\n-            if (s->isOverloadSet())\n-                break;\n-            // selective/renamed imports also be picked up\n-            if (AliasDeclaration *ad = s->isAliasDeclaration())\n+            if (Type *att = t->aliasthisOf())\n             {\n-                if (ad->_import)\n-                    break;\n+                t = att;\n+                goto Lagain;\n             }\n-            // See only module scope symbols for UFCS target.\n-            Dsymbol *p = s->toParent2();\n-            if (p && p->isModule())\n-                break;\n         }\n-        s = NULL;\n-\n-        // Stop when we hit a module, but keep going if that is not just under the global scope\n-        if (scx->scopesym->isModule() && !(scx->enclosing && !scx->enclosing->enclosing))\n-            break;\n     }\n-    return s;\n+    return NULL;\n }\n \n-/******************************\n- * Find symbol in accordance with the UFCS name look up rule\n- */\n-\n-static Expression *searchUFCS(Scope *sc, UnaExp *ue, Identifier *ident)\n+int expandAliasThisTuples(Expressions *exps, size_t starti)\n {\n-    //printf(\"searchUFCS(ident = %s)\\n\", ident->toChars());\n-    Loc loc = ue->loc;\n-    int flags = 0;\n-    Dsymbol *s = NULL;\n-\n-    if (sc->flags & SCOPEignoresymbolvisibility)\n-        flags |= IgnoreSymbolVisibility;\n-\n-    // First look in local scopes\n-    s = searchScopes(sc, loc, ident, flags | SearchLocalsOnly);\n-    if (!s)\n-    {\n-        // Second look in imported modules\n-        s = searchScopes(sc, loc, ident, flags | SearchImportsOnly);\n-    }\n-\n-    if (!s)\n-        return ue->e1->type->Type::getProperty(loc, ident, 0);\n+    if (!exps || exps->length == 0)\n+        return -1;\n \n-    FuncDeclaration *f = s->isFuncDeclaration();\n-    if (f)\n+    for (size_t u = starti; u < exps->length; u++)\n     {\n-        TemplateDeclaration *td = getFuncTemplateDecl(f);\n-        if (td)\n-        {\n-            if (td->overroot)\n-                td = td->overroot;\n-            s = td;\n-        }\n-    }\n-\n-    if (ue->op == TOKdotti)\n-    {\n-        DotTemplateInstanceExp *dti = (DotTemplateInstanceExp *)ue;\n-        TemplateInstance *ti = new TemplateInstance(loc, s->ident);\n-        ti->tiargs = dti->ti->tiargs;   // for better diagnostic message\n-        if (!ti->updateTempDecl(sc, s))\n-            return new ErrorExp();\n-        return new ScopeExp(loc, ti);\n-    }\n-    else\n-    {\n-        //printf(\"-searchUFCS() %s\\n\", s->toChars());\n-        return new DsymbolExp(loc, s);\n-    }\n-}\n-\n-/******************************\n- * check e is exp.opDispatch!(tiargs) or not\n- * It's used to switch to UFCS the semantic analysis path\n- */\n-\n-bool isDotOpDispatch(Expression *e)\n-{\n-    return e->op == TOKdotti &&\n-           ((DotTemplateInstanceExp *)e)->ti->name == Id::opDispatch;\n-}\n-\n-/******************************\n- * Pull out callable entity with UFCS.\n- */\n-\n-Expression *resolveUFCS(Scope *sc, CallExp *ce)\n-{\n-    Loc loc = ce->loc;\n-    Expression *eleft;\n-    Expression *e;\n-\n-    if (ce->e1->op == TOKdotid)\n-    {\n-        DotIdExp *die = (DotIdExp *)ce->e1;\n-        Identifier *ident = die->ident;\n-\n-        Expression *ex = semanticX(die, sc);\n-        if (ex != die)\n-        {\n-            ce->e1 = ex;\n-            return NULL;\n-        }\n-        eleft = die->e1;\n-\n-        Type *t = eleft->type->toBasetype();\n-        if (t->ty == Tarray || t->ty == Tsarray ||\n-            t->ty == Tnull  || (t->isTypeBasic() && t->ty != Tvoid))\n-        {\n-            /* Built-in types and arrays have no callable properties, so do shortcut.\n-             * It is necessary in: e.init()\n-             */\n-        }\n-        else if (t->ty == Taarray)\n-        {\n-            if (ident == Id::remove)\n-            {\n-                /* Transform:\n-                 *  aa.remove(arg) into delete aa[arg]\n-                 */\n-                if (!ce->arguments || ce->arguments->length != 1)\n-                {\n-                    ce->error(\"expected key as argument to aa.remove()\");\n-                    return new ErrorExp();\n-                }\n-                if (!eleft->type->isMutable())\n-                {\n-                    ce->error(\"cannot remove key from %s associative array %s\",\n-                            MODtoChars(t->mod), eleft->toChars());\n-                    return new ErrorExp();\n-                }\n-                Expression *key = (*ce->arguments)[0];\n-                key = expressionSemantic(key, sc);\n-                key = resolveProperties(sc, key);\n-\n-                TypeAArray *taa = (TypeAArray *)t;\n-                key = key->implicitCastTo(sc, taa->index);\n-\n-                if (key->checkValue())\n-                    return new ErrorExp();\n-\n-                semanticTypeInfo(sc, taa->index);\n-\n-                return new RemoveExp(loc, eleft, key);\n-            }\n-        }\n-        else\n-        {\n-            if (Expression *ey = semanticY(die, sc, 1))\n-            {\n-                if (ey->op == TOKerror)\n-                    return ey;\n-                ce->e1 = ey;\n-                if (isDotOpDispatch(ey))\n-                {\n-                    unsigned errors = global.startGagging();\n-                    e = expressionSemantic(ce->syntaxCopy(), sc);\n-                    if (!global.endGagging(errors))\n-                        return e;\n-                    /* fall down to UFCS */\n-                }\n-                else\n-                    return NULL;\n-            }\n-        }\n-        e = searchUFCS(sc, die, ident);\n-    }\n-    else if (ce->e1->op == TOKdotti)\n-    {\n-        DotTemplateInstanceExp *dti = (DotTemplateInstanceExp *)ce->e1;\n-        if (Expression *ey = semanticY(dti, sc, 1))\n-        {\n-            ce->e1 = ey;\n-            return NULL;\n-        }\n-        eleft = dti->e1;\n-        e = searchUFCS(sc, dti, dti->ti->name);\n-    }\n-    else\n-        return NULL;\n-\n-    // Rewrite\n-    ce->e1 = e;\n-    if (!ce->arguments)\n-        ce->arguments = new Expressions();\n-    ce->arguments->shift(eleft);\n-\n-    return NULL;\n-}\n-\n-/******************************\n- * Pull out property with UFCS.\n- */\n-\n-Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NULL)\n-{\n-    Loc loc = e1->loc;\n-    Expression *eleft;\n-    Expression *e;\n-\n-    if (e1->op == TOKdotid)\n-    {\n-        DotIdExp *die = (DotIdExp *)e1;\n-        eleft = die->e1;\n-        e = searchUFCS(sc, die, die->ident);\n-    }\n-    else if (e1->op == TOKdotti)\n-    {\n-        DotTemplateInstanceExp *dti;\n-        dti = (DotTemplateInstanceExp *)e1;\n-        eleft = dti->e1;\n-        e = searchUFCS(sc, dti, dti->ti->name);\n-    }\n-    else\n-        return NULL;\n-\n-    if (e == NULL)\n-        return NULL;\n-\n-    // Rewrite\n-    if (e2)\n-    {\n-        // run semantic without gagging\n-        e2 = expressionSemantic(e2, sc);\n-\n-        /* f(e1) = e2\n-         */\n-        Expression *ex = e->copy();\n-        Expressions *a1 = new Expressions();\n-        a1->setDim(1);\n-        (*a1)[0] = eleft;\n-        ex = new CallExp(loc, ex, a1);\n-        ex = trySemantic(ex, sc);\n-\n-        /* f(e1, e2)\n-         */\n-        Expressions *a2 = new Expressions();\n-        a2->setDim(2);\n-        (*a2)[0] = eleft;\n-        (*a2)[1] = e2;\n-        e = new CallExp(loc, e, a2);\n-        if (ex)\n-        {   // if fallback setter exists, gag errors\n-            e = trySemantic(e, sc);\n-            if (!e)\n-            {   checkPropertyCall(ex);\n-                ex = new AssignExp(loc, ex, e2);\n-                return expressionSemantic(ex, sc);\n-            }\n-        }\n-        else\n-        {   // strict setter prints errors if fails\n-            e = expressionSemantic(e, sc);\n-        }\n-        checkPropertyCall(e);\n-        return e;\n-    }\n-    else\n-    {\n-        /* f(e1)\n-         */\n-        Expressions *arguments = new Expressions();\n-        arguments->setDim(1);\n-        (*arguments)[0] = eleft;\n-        e = new CallExp(loc, e, arguments);\n-        e = expressionSemantic(e, sc);\n-        checkPropertyCall(e);\n-        return expressionSemantic(e, sc);\n-    }\n-}\n-\n-/******************************\n- * Perform semantic() on an array of Expressions.\n- */\n-\n-bool arrayExpressionSemantic(Expressions *exps, Scope *sc, bool preserveErrors)\n-{\n-    bool err = false;\n-    if (exps)\n-    {\n-        for (size_t i = 0; i < exps->length; i++)\n-        {\n-            Expression *e = (*exps)[i];\n-            if (e)\n-            {\n-                e = expressionSemantic(e, sc);\n-                if (e->op == TOKerror)\n-                    err = true;\n-                if (preserveErrors || e->op != TOKerror)\n-                    (*exps)[i] = e;\n-            }\n-        }\n-    }\n-    return err;\n-}\n-\n-/****************************************\n- * Expand tuples.\n- * Input:\n- *      exps    aray of Expressions\n- * Output:\n- *      exps    rewritten in place\n- */\n-\n-void expandTuples(Expressions *exps)\n-{\n-    //printf(\"expandTuples()\\n\");\n-    if (exps)\n-    {\n-        for (size_t i = 0; i < exps->length; i++)\n-        {\n-            Expression *arg = (*exps)[i];\n-            if (!arg)\n-                continue;\n-\n-            // Look for tuple with 0 members\n-            if (arg->op == TOKtype)\n-            {\n-                TypeExp *e = (TypeExp *)arg;\n-                if (e->type->toBasetype()->ty == Ttuple)\n-                {\n-                    TypeTuple *tt = (TypeTuple *)e->type->toBasetype();\n-\n-                    if (!tt->arguments || tt->arguments->length == 0)\n-                    {\n-                        exps->remove(i);\n-                        if (i == exps->length)\n-                            return;\n-                        i--;\n-                        continue;\n-                    }\n-                }\n-            }\n-\n-            // Inline expand all the tuples\n-            while (arg->op == TOKtuple)\n-            {\n-                TupleExp *te = (TupleExp *)arg;\n-                exps->remove(i);                // remove arg\n-                exps->insert(i, te->exps);      // replace with tuple contents\n-                if (i == exps->length)\n-                    return;             // empty tuple, no more arguments\n-                (*exps)[i] = Expression::combine(te->e0, (*exps)[i]);\n-                arg = (*exps)[i];\n-            }\n-        }\n-    }\n-}\n-\n-/****************************************\n- * Expand alias this tuples.\n- */\n-\n-TupleDeclaration *isAliasThisTuple(Expression *e)\n-{\n-    if (!e->type)\n-        return NULL;\n-\n-    Type *t = e->type->toBasetype();\n-Lagain:\n-    if (Dsymbol *s = t->toDsymbol(NULL))\n-    {\n-        AggregateDeclaration *ad = s->isAggregateDeclaration();\n-        if (ad)\n-        {\n-            s = ad->aliasthis;\n-            if (s && s->isVarDeclaration())\n-            {\n-                TupleDeclaration *td = s->isVarDeclaration()->toAlias()->isTupleDeclaration();\n-                if (td && td->isexp)\n-                    return td;\n-            }\n-            if (Type *att = t->aliasthisOf())\n-            {\n-                t = att;\n-                goto Lagain;\n-            }\n-        }\n-    }\n-    return NULL;\n-}\n-\n-int expandAliasThisTuples(Expressions *exps, size_t starti)\n-{\n-    if (!exps || exps->length == 0)\n-        return -1;\n-\n-    for (size_t u = starti; u < exps->length; u++)\n-    {\n-        Expression *exp = (*exps)[u];\n-        TupleDeclaration *td = isAliasThisTuple(exp);\n+        Expression *exp = (*exps)[u];\n+        TupleDeclaration *td = isAliasThisTuple(exp);\n         if (td)\n         {\n             exps->remove(u);\n@@ -1061,907 +256,130 @@ int expandAliasThisTuples(Expressions *exps, size_t starti)\n         }\n     }\n \n-    return -1;\n-}\n-\n-/****************************************\n- * The common type is determined by applying ?: to each pair.\n- * Output:\n- *      exps[]  properties resolved, implicitly cast to common type, rewritten in place\n- *      *pt     if pt is not NULL, set to the common type\n- * Returns:\n- *      true    a semantic error was detected\n- */\n-\n-bool arrayExpressionToCommonType(Scope *sc, Expressions *exps, Type **pt)\n-{\n-    /* Still have a problem with:\n-     *  ubyte[][] = [ cast(ubyte[])\"hello\", [1]];\n-     * which works if the array literal is initialized top down with the ubyte[][]\n-     * type, but fails with this function doing bottom up typing.\n-     */\n-    //printf(\"arrayExpressionToCommonType()\\n\");\n-    IntegerExp integerexp(0);\n-    CondExp condexp(Loc(), &integerexp, NULL, NULL);\n-\n-    Type *t0 = NULL;\n-    Expression *e0 = NULL;      // dead-store to prevent spurious warning\n-    size_t j0 = ~0;             // dead-store to prevent spurious warning\n-    bool foundType = false;\n-\n-    for (size_t i = 0; i < exps->length; i++)\n-    {\n-        Expression *e = (*exps)[i];\n-        if (!e)\n-            continue;\n-\n-        e = resolveProperties(sc, e);\n-        if (!e->type)\n-        {\n-            e->error(\"%s has no value\", e->toChars());\n-            t0 = Type::terror;\n-            continue;\n-        }\n-        if (e->op == TOKtype)\n-        {\n-            foundType = true;   // do not break immediately, there might be more errors\n-            e->checkValue();    // report an error \"type T has no value\"\n-            t0 = Type::terror;\n-            continue;\n-        }\n-        if (e->type->ty == Tvoid)\n-        {\n-            // void expressions do not concur to the determination of the common\n-            // type.\n-            continue;\n-        }\n-        if (checkNonAssignmentArrayOp(e))\n-        {\n-            t0 = Type::terror;\n-            continue;\n-        }\n-\n-        e = doCopyOrMove(sc, e);\n-\n-        if (!foundType && t0 && !t0->equals(e->type))\n-        {\n-            /* This applies ?: to merge the types. It's backwards;\n-             * ?: should call this function to merge types.\n-             */\n-            condexp.type = NULL;\n-            condexp.e1 = e0;\n-            condexp.e2 = e;\n-            condexp.loc = e->loc;\n-            Expression *ex = expressionSemantic(&condexp, sc);\n-            if (ex->op == TOKerror)\n-                e = ex;\n-            else\n-            {\n-                (*exps)[j0] = condexp.e1;\n-                e = condexp.e2;\n-            }\n-        }\n-        j0 = i;\n-        e0 = e;\n-        t0 = e->type;\n-        if (e->op != TOKerror)\n-            (*exps)[i] = e;\n-    }\n-\n-    if (!t0)\n-        t0 = Type::tvoid;               // [] is typed as void[]\n-    else if (t0->ty != Terror)\n-    {\n-        for (size_t i = 0; i < exps->length; i++)\n-        {\n-            Expression *e = (*exps)[i];\n-            if (!e)\n-                continue;\n-\n-            e = e->implicitCastTo(sc, t0);\n-            //assert(e->op != TOKerror);\n-            if (e->op == TOKerror)\n-            {\n-                /* Bugzilla 13024: a workaround for the bug in typeMerge -\n-                 * it should paint e1 and e2 by deduced common type,\n-                 * but doesn't in this particular case.\n-                 */\n-                t0 = Type::terror;\n-                break;\n-            }\n-            (*exps)[i] = e;\n-        }\n-    }\n-    if (pt)\n-        *pt = t0;\n-\n-    return (t0 == Type::terror);\n-}\n-\n-/****************************************\n- * Get TemplateDeclaration enclosing FuncDeclaration.\n- */\n-\n-TemplateDeclaration *getFuncTemplateDecl(Dsymbol *s)\n-{\n-    FuncDeclaration *f = s->isFuncDeclaration();\n-    if (f && f->parent)\n-    {\n-        TemplateInstance *ti = f->parent->isTemplateInstance();\n-        if (ti && !ti->isTemplateMixin() &&\n-            ti->tempdecl && ((TemplateDeclaration *)ti->tempdecl)->onemember &&\n-            ti->tempdecl->ident == f->ident)\n-        {\n-            return (TemplateDeclaration *)ti->tempdecl;\n-        }\n-    }\n-    return NULL;\n-}\n-\n-/************************************************\n- * If we want the value of this expression, but do not want to call\n- * the destructor on it.\n- */\n-\n-Expression *valueNoDtor(Expression *e)\n-{\n-    if (e->op == TOKcall)\n-    {\n-        /* The struct value returned from the function is transferred\n-         * so do not call the destructor on it.\n-         * Recognize:\n-         *       ((S _ctmp = S.init), _ctmp).this(...)\n-         * and make sure the destructor is not called on _ctmp\n-         * BUG: if e is a CommaExp, we should go down the right side.\n-         */\n-        CallExp *ce = (CallExp *)e;\n-        if (ce->e1->op == TOKdotvar)\n-        {\n-            DotVarExp *dve = (DotVarExp *)ce->e1;\n-            if (dve->var->isCtorDeclaration())\n-            {\n-                // It's a constructor call\n-                if (dve->e1->op == TOKcomma)\n-                {\n-                    CommaExp *comma = (CommaExp *)dve->e1;\n-                    if (comma->e2->op == TOKvar)\n-                    {\n-                        VarExp *ve = (VarExp *)comma->e2;\n-                        VarDeclaration *ctmp = ve->var->isVarDeclaration();\n-                        if (ctmp)\n-                        {\n-                            ctmp->storage_class |= STCnodtor;\n-                            assert(!ce->isLvalue());\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    else if (e->op == TOKvar)\n-    {\n-        VarDeclaration *vtmp = ((VarExp *)e)->var->isVarDeclaration();\n-        if (vtmp && vtmp->storage_class & STCrvalue)\n-        {\n-            vtmp->storage_class |= STCnodtor;\n-        }\n-    }\n-    return e;\n-}\n-\n-/********************************************\n- * Issue an error if default construction is disabled for type t.\n- * Default construction is required for arrays and 'out' parameters.\n- * Returns:\n- *      true    an error was issued\n- */\n-bool checkDefCtor(Loc loc, Type *t)\n-{\n-    t = t->baseElemOf();\n-    if (t->ty == Tstruct)\n-    {\n-        StructDeclaration *sd = ((TypeStruct *)t)->sym;\n-        if (sd->noDefaultCtor)\n-        {\n-            sd->error(loc, \"default construction is disabled\");\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-/*********************************************\n- * If e is an instance of a struct, and that struct has a copy constructor,\n- * rewrite e as:\n- *    (tmp = e),tmp\n- * Input:\n- *      sc      just used to specify the scope of created temporary variable\n- */\n-Expression *callCpCtor(Scope *sc, Expression *e)\n-{\n-    Type *tv = e->type->baseElemOf();\n-    if (tv->ty == Tstruct)\n-    {\n-        StructDeclaration *sd = ((TypeStruct *)tv)->sym;\n-        if (sd->postblit)\n-        {\n-            /* Create a variable tmp, and replace the argument e with:\n-             *      (tmp = e),tmp\n-             * and let AssignExp() handle the construction.\n-             * This is not the most efficent, ideally tmp would be constructed\n-             * directly onto the stack.\n-             */\n-            VarDeclaration *tmp = copyToTemp(STCrvalue, \"__copytmp\", e);\n-            tmp->storage_class |= STCnodtor;\n-            dsymbolSemantic(tmp, sc);\n-            Expression *de = new DeclarationExp(e->loc, tmp);\n-            Expression *ve = new VarExp(e->loc, tmp);\n-            de->type = Type::tvoid;\n-            ve->type = e->type;\n-            e = Expression::combine(de, ve);\n-        }\n-    }\n-    return e;\n-}\n-\n-/************************************************\n- * Handle the postblit call on lvalue, or the move of rvalue.\n- */\n-Expression *doCopyOrMove(Scope *sc, Expression *e)\n-{\n-    if (e->op == TOKquestion)\n-    {\n-        CondExp *ce = (CondExp *)e;\n-        ce->e1 = doCopyOrMove(sc, ce->e1);\n-        ce->e2 = doCopyOrMove(sc, ce->e2);\n-    }\n-    else\n-    {\n-        e = e->isLvalue() ? callCpCtor(sc, e) : valueNoDtor(e);\n-    }\n-    return e;\n-}\n-\n-/****************************************\n- * Now that we know the exact type of the function we're calling,\n- * the arguments[] need to be adjusted:\n- *      1. implicitly convert argument to the corresponding parameter type\n- *      2. add default arguments for any missing arguments\n- *      3. do default promotions on arguments corresponding to ...\n- *      4. add hidden _arguments[] argument\n- *      5. call copy constructor for struct value arguments\n- * Input:\n- *      tf      type of the function\n- *      fd      the function being called, NULL if called indirectly\n- * Output:\n- *      *prettype return type of function\n- *      *peprefix expression to execute before arguments[] are evaluated, NULL if none\n- * Returns:\n- *      true    errors happened\n- */\n-\n-bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n-        Type *tthis, Expressions *arguments, FuncDeclaration *fd, Type **prettype, Expression **peprefix)\n-{\n-    //printf(\"functionParameters()\\n\");\n-    assert(arguments);\n-    assert(fd || tf->next);\n-    size_t nargs = arguments ? arguments->length : 0;\n-    size_t nparams = tf->parameterList.length();\n-    unsigned olderrors = global.errors;\n-    bool err = false;\n-    *prettype = Type::terror;\n-    Expression *eprefix = NULL;\n-    *peprefix = NULL;\n-\n-    if (nargs > nparams && tf->parameterList.varargs == VARARGnone)\n-    {\n-        error(loc, \"expected %llu arguments, not %llu for non-variadic function type %s\", (ulonglong)nparams, (ulonglong)nargs, tf->toChars());\n-        return true;\n-    }\n-\n-    // If inferring return type, and semantic3() needs to be run if not already run\n-    if (!tf->next && fd->inferRetType)\n-    {\n-        fd->functionSemantic();\n-    }\n-    else if (fd && fd->parent)\n-    {\n-        TemplateInstance *ti = fd->parent->isTemplateInstance();\n-        if (ti && ti->tempdecl)\n-        {\n-            fd->functionSemantic3();\n-        }\n-    }\n-    bool isCtorCall = fd && fd->needThis() && fd->isCtorDeclaration();\n-\n-    size_t n = (nargs > nparams) ? nargs : nparams;   // n = max(nargs, nparams)\n-\n-    /* If the function return type has wildcards in it, we'll need to figure out the actual type\n-     * based on the actual argument types.\n-     */\n-    MOD wildmatch = 0;\n-    if (tthis && tf->isWild() && !isCtorCall)\n-    {\n-        Type *t = tthis;\n-        if (t->isImmutable())\n-            wildmatch = MODimmutable;\n-        else if (t->isWildConst())\n-            wildmatch = MODwildconst;\n-        else if (t->isWild())\n-            wildmatch = MODwild;\n-        else if (t->isConst())\n-            wildmatch = MODconst;\n-        else\n-            wildmatch = MODmutable;\n-    }\n-\n-    int done = 0;\n-    for (size_t i = 0; i < n; i++)\n-    {\n-        Expression *arg;\n-\n-        if (i < nargs)\n-            arg = (*arguments)[i];\n-        else\n-            arg = NULL;\n-\n-        if (i < nparams)\n-        {\n-            Parameter *p = tf->parameterList[i];\n-\n-            if (!arg)\n-            {\n-                if (!p->defaultArg)\n-                {\n-                    if (tf->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n-                        goto L2;\n-                    error(loc, \"expected %llu function arguments, not %llu\", (ulonglong)nparams, (ulonglong)nargs);\n-                    return true;\n-                }\n-                arg = p->defaultArg;\n-                arg = inlineCopy(arg, sc);\n-                // __FILE__, __LINE__, __MODULE__, __FUNCTION__, and __PRETTY_FUNCTION__\n-                arg = arg->resolveLoc(loc, sc);\n-                arguments->push(arg);\n-                nargs++;\n-            }\n-\n-            if (tf->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n-            {\n-                //printf(\"\\t\\tvarargs == 2, p->type = '%s'\\n\", p->type->toChars());\n-                {\n-                    MATCH m;\n-                    if ((m = arg->implicitConvTo(p->type)) > MATCHnomatch)\n-                    {\n-                        if (p->type->nextOf() && arg->implicitConvTo(p->type->nextOf()) >= m)\n-                            goto L2;\n-                        else if (nargs != nparams)\n-                        {   error(loc, \"expected %llu function arguments, not %llu\", (ulonglong)nparams, (ulonglong)nargs);\n-                            return true;\n-                        }\n-                        goto L1;\n-                    }\n-                }\n-             L2:\n-                Type *tb = p->type->toBasetype();\n-                Type *tret = p->isLazyArray();\n-                switch (tb->ty)\n-                {\n-                    case Tsarray:\n-                    case Tarray:\n-                    {\n-                        /* Create a static array variable v of type arg->type:\n-                         *  T[dim] __arrayArg = [ arguments[i], ..., arguments[nargs-1] ];\n-                         *\n-                         * The array literal in the initializer of the hidden variable\n-                         * is now optimized. See Bugzilla 2356.\n-                         */\n-                        Type *tbn = ((TypeArray *)tb)->next;\n-\n-                        Expressions *elements = new Expressions();\n-                        elements->setDim(nargs - i);\n-                        for (size_t u = 0; u < elements->length; u++)\n-                        {\n-                            Expression *a = (*arguments)[i + u];\n-                            if (tret && a->implicitConvTo(tret))\n-                            {\n-                                a = a->implicitCastTo(sc, tret);\n-                                a = a->optimize(WANTvalue);\n-                                a = toDelegate(a, a->type, sc);\n-                            }\n-                            else\n-                                a = a->implicitCastTo(sc, tbn);\n-                            (*elements)[u] = a;\n-                        }\n-                        // Bugzilla 14395: Convert to a static array literal, or its slice.\n-                        arg = new ArrayLiteralExp(loc, tbn->sarrayOf(nargs - i), elements);\n-                        if (tb->ty == Tarray)\n-                        {\n-                            arg = new SliceExp(loc, arg, NULL, NULL);\n-                            arg->type = p->type;\n-                        }\n-                        break;\n-                    }\n-                    case Tclass:\n-                    {\n-                        /* Set arg to be:\n-                         *      new Tclass(arg0, arg1, ..., argn)\n-                         */\n-                        Expressions *args = new Expressions();\n-                        args->setDim(nargs - i);\n-                        for (size_t u = i; u < nargs; u++)\n-                            (*args)[u - i] = (*arguments)[u];\n-                        arg = new NewExp(loc, NULL, NULL, p->type, args);\n-                        break;\n-                    }\n-                    default:\n-                        if (!arg)\n-                        {\n-                            error(loc, \"not enough arguments\");\n-                            return true;\n-                        }\n-                        break;\n-                }\n-                arg = expressionSemantic(arg, sc);\n-                //printf(\"\\targ = '%s'\\n\", arg->toChars());\n-                arguments->setDim(i + 1);\n-                (*arguments)[i] =  arg;\n-                nargs = i + 1;\n-                done = 1;\n-            }\n-\n-        L1:\n-            if (!(p->storageClass & STClazy && p->type->ty == Tvoid))\n-            {\n-                bool isRef = (p->storageClass & (STCref | STCout)) != 0;\n-                if (unsigned char wm = arg->type->deduceWild(p->type, isRef))\n-                {\n-                    if (wildmatch)\n-                        wildmatch = MODmerge(wildmatch, wm);\n-                    else\n-                        wildmatch = wm;\n-                    //printf(\"[%d] p = %s, a = %s, wm = %d, wildmatch = %d\\n\", i, p->type->toChars(), arg->type->toChars(), wm, wildmatch);\n-                }\n-            }\n-        }\n-        if (done)\n-            break;\n-    }\n-    if ((wildmatch == MODmutable || wildmatch == MODimmutable) &&\n-        tf->next->hasWild() &&\n-        (tf->isref || !tf->next->implicitConvTo(tf->next->immutableOf())))\n-    {\n-        if (fd)\n-        {\n-            /* If the called function may return the reference to\n-             * outer inout data, it should be rejected.\n-             *\n-             * void foo(ref inout(int) x) {\n-             *   ref inout(int) bar(inout(int)) { return x; }\n-             *   struct S { ref inout(int) bar() inout { return x; } }\n-             *   bar(int.init) = 1;  // bad!\n-             *   S().bar() = 1;      // bad!\n-             * }\n-             */\n-            Dsymbol *s = NULL;\n-            if (fd->isThis() || fd->isNested())\n-                s = fd->toParent2();\n-            for (; s; s = s->toParent2())\n-            {\n-                if (AggregateDeclaration *ad = s->isAggregateDeclaration())\n-                {\n-                    if (ad->isNested())\n-                        continue;\n-                    break;\n-                }\n-                if (FuncDeclaration *ff = s->isFuncDeclaration())\n-                {\n-                    if (((TypeFunction *)ff->type)->iswild)\n-                        goto Linouterr;\n-\n-                    if (ff->isNested() || ff->isThis())\n-                        continue;\n-                }\n-                break;\n-            }\n-        }\n-        else if (tf->isWild())\n-        {\n-        Linouterr:\n-            const char *s = wildmatch == MODmutable ? \"mutable\" : MODtoChars(wildmatch);\n-            error(loc, \"modify inout to %s is not allowed inside inout function\", s);\n-            return true;\n-        }\n-    }\n-\n-    assert(nargs >= nparams);\n-    for (size_t i = 0; i < nargs; i++)\n-    {\n-        Expression *arg = (*arguments)[i];\n-        assert(arg);\n-        if (i < nparams)\n-        {\n-            Parameter *p = tf->parameterList[i];\n-\n-            if (!(p->storageClass & STClazy && p->type->ty == Tvoid))\n-            {\n-                Type *tprm = p->type;\n-                if (p->type->hasWild())\n-                    tprm = p->type->substWildTo(wildmatch);\n-                if (!tprm->equals(arg->type))\n-                {\n-                    //printf(\"arg->type = %s, p->type = %s\\n\", arg->type->toChars(), p->type->toChars());\n-                    arg = arg->implicitCastTo(sc, tprm);\n-                    arg = arg->optimize(WANTvalue, (p->storageClass & (STCref | STCout)) != 0);\n-                }\n-            }\n-            if (p->storageClass & STCref)\n-            {\n-                arg = arg->toLvalue(sc, arg);\n-\n-                // Look for mutable misaligned pointer, etc., in @safe mode\n-                err |= checkUnsafeAccess(sc, arg, false, true);\n-            }\n-            else if (p->storageClass & STCout)\n-            {\n-                Type *t = arg->type;\n-                if (!t->isMutable() || !t->isAssignable())  // check blit assignable\n-                {\n-                    arg->error(\"cannot modify struct %s with immutable members\", arg->toChars());\n-                    err = true;\n-                }\n-                else\n-                {\n-                    // Look for misaligned pointer, etc., in @safe mode\n-                    err |= checkUnsafeAccess(sc, arg, false, true);\n-                    err |= checkDefCtor(arg->loc, t);   // t must be default constructible\n-                }\n-                arg = arg->toLvalue(sc, arg);\n-            }\n-            else if (p->storageClass & STClazy)\n-            {\n-                // Convert lazy argument to a delegate\n-                if (p->type->ty == Tvoid)\n-                    arg = toDelegate(arg, p->type, sc);\n-                else\n-                    arg = toDelegate(arg, arg->type, sc);\n-            }\n-\n-            //printf(\"arg: %s\\n\", arg->toChars());\n-            //printf(\"type: %s\\n\", arg->type->toChars());\n-            if (tf->parameterEscapes(p))\n-            {\n-                /* Argument value can escape from the called function.\n-                 * Check arg to see if it matters.\n-                 */\n-                if (global.params.vsafe)\n-                    err |= checkParamArgumentEscape(sc, fd, p->ident, arg, false);\n-            }\n-            else\n-            {\n-                /* Argument value cannot escape from the called function.\n-                 */\n-                Expression *a = arg;\n-                if (a->op == TOKcast)\n-                    a = ((CastExp *)a)->e1;\n-\n-                if (a->op == TOKfunction)\n-                {\n-                    /* Function literals can only appear once, so if this\n-                     * appearance was scoped, there cannot be any others.\n-                     */\n-                    FuncExp *fe = (FuncExp *)a;\n-                    fe->fd->tookAddressOf = 0;\n-                }\n-                else if (a->op == TOKdelegate)\n-                {\n-                    /* For passing a delegate to a scoped parameter,\n-                     * this doesn't count as taking the address of it.\n-                     * We only worry about 'escaping' references to the function.\n-                     */\n-                    DelegateExp *de = (DelegateExp *)a;\n-                    if (de->e1->op == TOKvar)\n-                    {   VarExp *ve = (VarExp *)de->e1;\n-                        FuncDeclaration *f = ve->var->isFuncDeclaration();\n-                        if (f)\n-                        {   f->tookAddressOf--;\n-                            //printf(\"tookAddressOf = %d\\n\", f->tookAddressOf);\n-                        }\n-                    }\n-                }\n-            }\n-            arg = arg->optimize(WANTvalue, (p->storageClass & (STCref | STCout)) != 0);\n-        }\n-        else\n-        {\n-            // These will be the trailing ... arguments\n-\n-            // If not D linkage, do promotions\n-            if (tf->linkage != LINKd)\n-            {\n-                // Promote bytes, words, etc., to ints\n-                arg = integralPromotions(arg, sc);\n-\n-                // Promote floats to doubles\n-                switch (arg->type->ty)\n-                {\n-                    case Tfloat32:\n-                        arg = arg->castTo(sc, Type::tfloat64);\n-                        break;\n-\n-                    case Timaginary32:\n-                        arg = arg->castTo(sc, Type::timaginary64);\n-                        break;\n-                }\n-\n-                if (tf->parameterList.varargs == VARARGvariadic)\n-                {\n-                    const char *p = tf->linkage == LINKc ? \"extern(C)\" : \"extern(C++)\";\n-                    if (arg->type->ty == Tarray)\n-                    {\n-                        arg->error(\"cannot pass dynamic arrays to %s vararg functions\", p);\n-                        err = true;\n-                    }\n-                    if (arg->type->ty == Tsarray)\n-                    {\n-                        arg->error(\"cannot pass static arrays to %s vararg functions\", p);\n-                        err = true;\n-                    }\n-                }\n-            }\n-\n-            // Do not allow types that need destructors\n-            if (arg->type->needsDestruction())\n-            {\n-                arg->error(\"cannot pass types that need destruction as variadic arguments\");\n-                err = true;\n-            }\n-\n-            // Convert static arrays to dynamic arrays\n-            // BUG: I don't think this is right for D2\n-            Type *tb = arg->type->toBasetype();\n-            if (tb->ty == Tsarray)\n-            {\n-                TypeSArray *ts = (TypeSArray *)tb;\n-                Type *ta = ts->next->arrayOf();\n-                if (ts->size(arg->loc) == 0)\n-                    arg = new NullExp(arg->loc, ta);\n-                else\n-                    arg = arg->castTo(sc, ta);\n-            }\n-            if (tb->ty == Tstruct)\n-            {\n-                //arg = callCpCtor(sc, arg);\n-            }\n-\n-            // Give error for overloaded function addresses\n-            if (arg->op == TOKsymoff)\n-            {   SymOffExp *se = (SymOffExp *)arg;\n-                if (se->hasOverloads &&\n-                    !se->var->isFuncDeclaration()->isUnique())\n-                {   arg->error(\"function %s is overloaded\", arg->toChars());\n-                    err = true;\n-                }\n-            }\n-            if (arg->checkValue())\n-                err = true;\n-            arg = arg->optimize(WANTvalue);\n-        }\n-        (*arguments)[i] = arg;\n-    }\n-\n-    /* Remaining problems:\n-     * 1. order of evaluation - some function push L-to-R, others R-to-L. Until we resolve what array assignment does (which is\n-     *    implemented by calling a function) we'll defer this for now.\n-     * 2. value structs (or static arrays of them) that need to be copy constructed\n-     * 3. value structs (or static arrays of them) that have destructors, and subsequent arguments that may throw before the\n-     *    function gets called (functions normally destroy their parameters)\n-     * 2 and 3 are handled by doing the argument construction in 'eprefix' so that if a later argument throws, they are cleaned\n-     * up properly. Pushing arguments on the stack then cannot fail.\n-     */\n-    if (1)\n-    {\n-        /* TODO: tackle problem 1)\n-         */\n-        const bool leftToRight = true; // TODO: something like !fd.isArrayOp\n-        if (!leftToRight)\n-            assert(nargs == nparams); // no variadics for RTL order, as they would probably be evaluated LTR and so add complexity\n+    return -1;\n+}\n \n-        const ptrdiff_t start = (leftToRight ? 0 : (ptrdiff_t)nargs - 1);\n-        const ptrdiff_t end = (leftToRight ? (ptrdiff_t)nargs : -1);\n-        const ptrdiff_t step = (leftToRight ? 1 : -1);\n+/****************************************\n+ * Get TemplateDeclaration enclosing FuncDeclaration.\n+ */\n \n-        /* Compute indices of last throwing argument and first arg needing destruction.\n-         * Used to not set up destructors unless an arg needs destruction on a throw\n-         * in a later argument.\n-         */\n-        ptrdiff_t lastthrow = -1;\n-        ptrdiff_t firstdtor = -1;\n-        for (ptrdiff_t i = start; i != end; i += step)\n+TemplateDeclaration *getFuncTemplateDecl(Dsymbol *s)\n+{\n+    FuncDeclaration *f = s->isFuncDeclaration();\n+    if (f && f->parent)\n+    {\n+        TemplateInstance *ti = f->parent->isTemplateInstance();\n+        if (ti && !ti->isTemplateMixin() &&\n+            ti->tempdecl && ((TemplateDeclaration *)ti->tempdecl)->onemember &&\n+            ti->tempdecl->ident == f->ident)\n         {\n-            Expression *arg = (*arguments)[i];\n-            if (canThrow(arg, sc->func, false))\n-                lastthrow = i;\n-            if (firstdtor == -1 && arg->type->needsDestruction())\n-            {\n-                Parameter *p = (i >= (ptrdiff_t)nparams ? NULL : tf->parameterList[i]);\n-                if (!(p && (p->storageClass & (STClazy | STCref | STCout))))\n-                    firstdtor = i;\n-            }\n+            return (TemplateDeclaration *)ti->tempdecl;\n         }\n+    }\n+    return NULL;\n+}\n \n-        /* Does problem 3) apply to this call?\n-         */\n-        const bool needsPrefix = (firstdtor >= 0 && lastthrow >= 0\n-            && (lastthrow - firstdtor) * step > 0);\n+/************************************************\n+ * If we want the value of this expression, but do not want to call\n+ * the destructor on it.\n+ */\n \n-        /* If so, initialize 'eprefix' by declaring the gate\n+Expression *valueNoDtor(Expression *e)\n+{\n+    if (e->op == TOKcall)\n+    {\n+        /* The struct value returned from the function is transferred\n+         * so do not call the destructor on it.\n+         * Recognize:\n+         *       ((S _ctmp = S.init), _ctmp).this(...)\n+         * and make sure the destructor is not called on _ctmp\n+         * BUG: if e is a CommaExp, we should go down the right side.\n          */\n-        VarDeclaration *gate = NULL;\n-        if (needsPrefix)\n-        {\n-            // eprefix => bool __gate [= false]\n-            Identifier *idtmp = Identifier::generateId(\"__gate\");\n-            gate = new VarDeclaration(loc, Type::tbool, idtmp, NULL);\n-            gate->storage_class |= STCtemp | STCctfe | STCvolatile;\n-            dsymbolSemantic(gate, sc);\n-\n-            Expression *ae = new DeclarationExp(loc, gate);\n-            eprefix = expressionSemantic(ae, sc);\n-        }\n-\n-        for (ptrdiff_t i = start; i != end; i += step)\n+        CallExp *ce = (CallExp *)e;\n+        if (ce->e1->op == TOKdotvar)\n         {\n-            Expression *arg = (*arguments)[i];\n-\n-            Parameter *parameter = (i >= (ptrdiff_t)nparams ? NULL : tf->parameterList[i]);\n-            const bool isRef = (parameter && (parameter->storageClass & (STCref | STCout)));\n-            const bool isLazy = (parameter && (parameter->storageClass & STClazy));\n-\n-            /* Skip lazy parameters\n-             */\n-            if (isLazy)\n-                continue;\n-\n-            /* Do we have a gate? Then we have a prefix and we're not yet past the last throwing arg.\n-             * Declare a temporary variable for this arg and append that declaration to 'eprefix',\n-             * which will implicitly take care of potential problem 2) for this arg.\n-             * 'eprefix' will therefore finally contain all args up to and including the last\n-             * potentially throwing arg, excluding all lazy parameters.\n-             */\n-            if (gate)\n+            DotVarExp *dve = (DotVarExp *)ce->e1;\n+            if (dve->var->isCtorDeclaration())\n             {\n-                const bool needsDtor = (!isRef && arg->type->needsDestruction() && i != lastthrow);\n-\n-                /* Declare temporary 'auto __pfx = arg' (needsDtor) or 'auto __pfy = arg' (!needsDtor)\n-                 */\n-                VarDeclaration *tmp = copyToTemp(0,\n-                    needsDtor ? \"__pfx\" : \"__pfy\",\n-                    !isRef ? arg : arg->addressOf());\n-                dsymbolSemantic(tmp, sc);\n-\n-                /* Modify the destructor so it only runs if gate==false, i.e.,\n-                 * only if there was a throw while constructing the args\n-                 */\n-                if (!needsDtor)\n+                // It's a constructor call\n+                if (dve->e1->op == TOKcomma)\n                 {\n-                    if (tmp->edtor)\n+                    CommaExp *comma = (CommaExp *)dve->e1;\n+                    if (comma->e2->op == TOKvar)\n                     {\n-                        assert(i == lastthrow);\n-                        tmp->edtor = NULL;\n+                        VarExp *ve = (VarExp *)comma->e2;\n+                        VarDeclaration *ctmp = ve->var->isVarDeclaration();\n+                        if (ctmp)\n+                        {\n+                            ctmp->storage_class |= STCnodtor;\n+                            assert(!ce->isLvalue());\n+                        }\n                     }\n                 }\n-                else\n-                {\n-                    // edtor => (__gate || edtor)\n-                    assert(tmp->edtor);\n-                    Expression *e = tmp->edtor;\n-                    e = new LogicalExp(e->loc, TOKoror, new VarExp(e->loc, gate), e);\n-                    tmp->edtor = expressionSemantic(e, sc);\n-                    //printf(\"edtor: %s\\n\", tmp->edtor->toChars());\n-                }\n-\n-                // eprefix => (eprefix, auto __pfx/y = arg)\n-                DeclarationExp *ae = new DeclarationExp(loc, tmp);\n-                eprefix = Expression::combine(eprefix, expressionSemantic(ae, sc));\n-\n-                // arg => __pfx/y\n-                arg = new VarExp(loc, tmp);\n-                arg = expressionSemantic(arg, sc);\n-                if (isRef)\n-                {\n-                    arg = new PtrExp(loc, arg);\n-                    arg = expressionSemantic(arg, sc);\n-                }\n-\n-                /* Last throwing arg? Then finalize eprefix => (eprefix, gate = true),\n-                 * i.e., disable the dtors right after constructing the last throwing arg.\n-                 * From now on, the callee will take care of destructing the args because\n-                 * the args are implicitly moved into function parameters.\n-                 *\n-                 * Set gate to null to let the next iterations know they don't need to\n-                 * append to eprefix anymore.\n-                 */\n-                if (i == lastthrow)\n-                {\n-                    Expression *e = new AssignExp(gate->loc, new VarExp(gate->loc, gate), new IntegerExp(gate->loc, 1, Type::tbool));\n-                    eprefix = Expression::combine(eprefix, expressionSemantic(e, sc));\n-                    gate = NULL;\n-                }\n-            }\n-            else\n-            {\n-                /* No gate, no prefix to append to.\n-                 * Handle problem 2) by calling the copy constructor for value structs\n-                 * (or static arrays of them) if appropriate.\n-                 */\n-                Type *tv = arg->type->baseElemOf();\n-                if (!isRef && tv->ty == Tstruct)\n-                    arg = doCopyOrMove(sc, arg);\n             }\n-\n-            (*arguments)[i] = arg;\n         }\n     }\n-    //if (eprefix) printf(\"eprefix: %s\\n\", eprefix->toChars());\n-\n-    // If D linkage and variadic, add _arguments[] as first argument\n-    if (tf->isDstyleVariadic())\n+    else if (e->op == TOKvar)\n     {\n-        assert(arguments->length >= nparams);\n-\n-        Parameters *args = new Parameters;\n-        args->setDim(arguments->length - nparams);\n-        for (size_t i = 0; i < arguments->length - nparams; i++)\n+        VarDeclaration *vtmp = ((VarExp *)e)->var->isVarDeclaration();\n+        if (vtmp && vtmp->storage_class & STCrvalue)\n         {\n-            Parameter *arg = new Parameter(STCin, (*arguments)[nparams + i]->type, NULL, NULL, NULL);\n-            (*args)[i] = arg;\n+            vtmp->storage_class |= STCnodtor;\n         }\n-\n-        TypeTuple *tup = new TypeTuple(args);\n-        Expression *e = new TypeidExp(loc, tup);\n-        e = expressionSemantic(e, sc);\n-        arguments->insert(0, e);\n     }\n+    return e;\n+}\n \n-    Type *tret = tf->next;\n-    if (isCtorCall)\n+/*********************************************\n+ * If e is an instance of a struct, and that struct has a copy constructor,\n+ * rewrite e as:\n+ *    (tmp = e),tmp\n+ * Input:\n+ *      sc      just used to specify the scope of created temporary variable\n+ */\n+Expression *callCpCtor(Scope *sc, Expression *e)\n+{\n+    Type *tv = e->type->baseElemOf();\n+    if (tv->ty == Tstruct)\n     {\n-        //printf(\"[%s] fd = %s %s, %d %d %d\\n\", loc.toChars(), fd->toChars(), fd->type->toChars(),\n-        //    wildmatch, tf->isWild(), fd->isolateReturn());\n-        if (!tthis)\n-        {\n-            assert(sc->intypeof || global.errors);\n-            tthis = fd->isThis()->type->addMod(fd->type->mod);\n-        }\n-        if (tf->isWild() && !fd->isolateReturn())\n+        StructDeclaration *sd = ((TypeStruct *)tv)->sym;\n+        if (sd->postblit)\n         {\n-            if (wildmatch)\n-                tret = tret->substWildTo(wildmatch);\n-            int offset;\n-            if (!tret->implicitConvTo(tthis) &&\n-                !(MODimplicitConv(tret->mod, tthis->mod) && tret->isBaseOf(tthis, &offset) && offset == 0))\n-            {\n-                const char* s1 = tret ->isNaked() ? \" mutable\" : tret ->modToChars();\n-                const char* s2 = tthis->isNaked() ? \" mutable\" : tthis->modToChars();\n-                ::error(loc, \"inout constructor %s creates%s object, not%s\",\n-                        fd->toPrettyChars(), s1, s2);\n-                err = true;\n-            }\n+            /* Create a variable tmp, and replace the argument e with:\n+             *      (tmp = e),tmp\n+             * and let AssignExp() handle the construction.\n+             * This is not the most efficent, ideally tmp would be constructed\n+             * directly onto the stack.\n+             */\n+            VarDeclaration *tmp = copyToTemp(STCrvalue, \"__copytmp\", e);\n+            tmp->storage_class |= STCnodtor;\n+            dsymbolSemantic(tmp, sc);\n+            Expression *de = new DeclarationExp(e->loc, tmp);\n+            Expression *ve = new VarExp(e->loc, tmp);\n+            de->type = Type::tvoid;\n+            ve->type = e->type;\n+            e = Expression::combine(de, ve);\n         }\n-        tret = tthis;\n     }\n-    else if (wildmatch && tret)\n+    return e;\n+}\n+\n+/************************************************\n+ * Handle the postblit call on lvalue, or the move of rvalue.\n+ */\n+Expression *doCopyOrMove(Scope *sc, Expression *e)\n+{\n+    if (e->op == TOKquestion)\n+    {\n+        CondExp *ce = (CondExp *)e;\n+        ce->e1 = doCopyOrMove(sc, ce->e1);\n+        ce->e2 = doCopyOrMove(sc, ce->e2);\n+    }\n+    else\n     {\n-        /* Adjust function return type based on wildmatch\n-         */\n-        //printf(\"wildmatch = x%x, tret = %s\\n\", wildmatch, tret->toChars());\n-        tret = tret->substWildTo(wildmatch);\n+        e = e->isLvalue() ? callCpCtor(sc, e) : valueNoDtor(e);\n     }\n-    *prettype = tret;\n-    *peprefix = eprefix;\n-    return (err || olderrors != global.errors);\n+    return e;\n }\n \n /******************************** Expression **************************/\n@@ -5288,8 +3706,10 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n     }\n     else if (!flag)\n     {\n+        const char *ts[2];\n+        toAutoQualChars(ts, tx, to);\n         error(\"cannot implicitly convert expression (%s) of type %s to %s\",\n-                toChars(), tx->toChars(), to->toChars());\n+                toChars(), ts[0], ts[1]);\n     }\n     return m;\n }\n@@ -5644,11 +4064,17 @@ Expression *BinExp::incompatibleTypes()\n         error(\"incompatible types for ((%s) %s (%s)): cannot use `%s` with types\",\n             e1->toChars(), Token::toChars(thisOp), e2->toChars(), Token::toChars(op));\n     }\n+    else if (e1->type->equals(e2->type))\n+    {\n+        error(\"incompatible types for ((%s) %s (%s)): both operands are of type `%s`\",\n+            e1->toChars(), Token::toChars(thisOp), e2->toChars(), e1->type->toChars());\n+    }\n     else\n     {\n+        const char *ts[2];\n+        toAutoQualChars(ts, e1->type, e2->type);\n         error(\"incompatible types for ((%s) %s (%s)): `%s` and `%s`\",\n-            e1->toChars(), Token::toChars(thisOp), e2->toChars(),\n-            e1->type->toChars(), e2->type->toChars());\n+            e1->toChars(), Token::toChars(thisOp), e2->toChars(), ts[0], ts[1]);\n     }\n     return new ErrorExp();\n }\n@@ -5693,9 +4119,36 @@ Expression *BinAssignExp::modifiableLvalue(Scope *sc, Expression *)\n \n /************************************************************/\n \n-CompileExp::CompileExp(Loc loc, Expression *e)\n-        : UnaExp(loc, TOKmixin, sizeof(CompileExp), e)\n+CompileExp::CompileExp(Loc loc, Expressions *exps)\n+    : Expression(loc, TOKmixin, sizeof(CompileExp))\n+{\n+    this->exps = exps;\n+}\n+\n+Expression *CompileExp::syntaxCopy()\n+{\n+    return new CompileExp(loc, arraySyntaxCopy(exps));\n+}\n+\n+bool CompileExp::equals(RootObject *o)\n {\n+    if (this == o)\n+        return true;\n+    if (o && o->dyncast() == DYNCAST_EXPRESSION && ((Expression *)o)->op == TOKmixin)\n+    {\n+        CompileExp *ce = (CompileExp *)o;\n+        if (exps->length != ce->exps->length)\n+            return false;\n+        for (size_t i = 0; i < exps->length; i++)\n+        {\n+            Expression *e1 = (*exps)[i];\n+            Expression *e2 = (*ce->exps)[i];\n+            if (e1 != e2 && (!e1 || !e2 || !e1->equals(e2)))\n+                return false;\n+        }\n+        return true;\n+    }\n+    return false;\n }\n \n /************************************************************/\n@@ -6362,64 +4815,6 @@ ArrayLengthExp::ArrayLengthExp(Loc loc, Expression *e1)\n {\n }\n \n-Expression *opAssignToOp(Loc loc, TOK op, Expression *e1, Expression *e2)\n-{   Expression *e;\n-\n-    switch (op)\n-    {\n-        case TOKaddass:   e = new AddExp(loc, e1, e2);  break;\n-        case TOKminass:   e = new MinExp(loc, e1, e2);  break;\n-        case TOKmulass:   e = new MulExp(loc, e1, e2);  break;\n-        case TOKdivass:   e = new DivExp(loc, e1, e2);  break;\n-        case TOKmodass:   e = new ModExp(loc, e1, e2);  break;\n-        case TOKandass:   e = new AndExp(loc, e1, e2);  break;\n-        case TOKorass:    e = new OrExp (loc, e1, e2);  break;\n-        case TOKxorass:   e = new XorExp(loc, e1, e2);  break;\n-        case TOKshlass:   e = new ShlExp(loc, e1, e2);  break;\n-        case TOKshrass:   e = new ShrExp(loc, e1, e2);  break;\n-        case TOKushrass:  e = new UshrExp(loc, e1, e2); break;\n-        default:        assert(0);\n-    }\n-    return e;\n-}\n-\n-/*********************\n- * Rewrite:\n- *    array.length op= e2\n- * as:\n- *    array.length = array.length op e2\n- * or:\n- *    auto tmp = &array;\n- *    (*tmp).length = (*tmp).length op e2\n- */\n-\n-Expression *ArrayLengthExp::rewriteOpAssign(BinExp *exp)\n-{\n-    Expression *e;\n-\n-    assert(exp->e1->op == TOKarraylength);\n-    ArrayLengthExp *ale = (ArrayLengthExp *)exp->e1;\n-    if (ale->e1->op == TOKvar)\n-    {\n-        e = opAssignToOp(exp->loc, exp->op, ale, exp->e2);\n-        e = new AssignExp(exp->loc, ale->syntaxCopy(), e);\n-    }\n-    else\n-    {\n-        /*    auto tmp = &array;\n-         *    (*tmp).length = (*tmp).length op e2\n-         */\n-        VarDeclaration *tmp = copyToTemp(0, \"__arraylength\", new AddrExp(ale->loc, ale->e1));\n-\n-        Expression *e1 = new ArrayLengthExp(ale->loc, new PtrExp(ale->loc, new VarExp(ale->loc, tmp)));\n-        Expression *elvalue = e1->syntaxCopy();\n-        e = opAssignToOp(exp->loc, exp->op, e1, exp->e2);\n-        e = new AssignExp(exp->loc, elvalue, e);\n-        e = new CommaExp(exp->loc, new DeclarationExp(ale->loc, tmp), e);\n-    }\n-    return e;\n-}\n-\n /*********************** IntervalExp ********************************/\n \n // Mainly just a placeholder\n@@ -7248,203 +5643,6 @@ Expression *PrettyFuncInitExp::resolveLoc(Loc loc, Scope *sc)\n     return e;\n }\n \n-/****************************************************************/\n-\n-Expression *extractOpDollarSideEffect(Scope *sc, UnaExp *ue)\n-{\n-    Expression *e0;\n-    Expression *e1 = Expression::extractLast(ue->e1, &e0);\n-    // Bugzilla 12585: Extract the side effect part if ue->e1 is comma.\n-\n-    if (!isTrivialExp(e1))\n-    {\n-        /* Even if opDollar is needed, 'e1' should be evaluate only once. So\n-         * Rewrite:\n-         *      e1.opIndex( ... use of $ ... )\n-         *      e1.opSlice( ... use of $ ... )\n-         * as:\n-         *      (ref __dop = e1, __dop).opIndex( ... __dop.opDollar ...)\n-         *      (ref __dop = e1, __dop).opSlice( ... __dop.opDollar ...)\n-         */\n-        e1 = extractSideEffect(sc, \"__dop\", &e0, e1, false);\n-        assert(e1->op == TOKvar);\n-        VarExp *ve = (VarExp *)e1;\n-        ve->var->storage_class |= STCexptemp;     // lifetime limited to expression\n-    }\n-    ue->e1 = e1;\n-    return e0;\n-}\n-\n-/**************************************\n- * Runs semantic on ae->arguments. Declares temporary variables\n- * if '$' was used.\n- */\n-Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n-{\n-    assert(!ae->lengthVar);\n-\n-    *pe0 = NULL;\n-\n-    AggregateDeclaration *ad = isAggregate(ae->e1->type);\n-    Dsymbol *slice = search_function(ad, Id::slice);\n-    //printf(\"slice = %s %s\\n\", slice->kind(), slice->toChars());\n-\n-    for (size_t i = 0; i < ae->arguments->length; i++)\n-    {\n-        if (i == 0)\n-            *pe0 = extractOpDollarSideEffect(sc, ae);\n-\n-        Expression *e = (*ae->arguments)[i];\n-        if (e->op == TOKinterval && !(slice && slice->isTemplateDeclaration()))\n-        {\n-        Lfallback:\n-            if (ae->arguments->length == 1)\n-                return NULL;\n-            ae->error(\"multi-dimensional slicing requires template opSlice\");\n-            return new ErrorExp();\n-        }\n-        //printf(\"[%d] e = %s\\n\", i, e->toChars());\n-\n-        // Create scope for '$' variable for this dimension\n-        ArrayScopeSymbol *sym = new ArrayScopeSymbol(sc, ae);\n-        sym->loc = ae->loc;\n-        sym->parent = sc->scopesym;\n-        sc = sc->push(sym);\n-        ae->lengthVar = NULL;       // Create it only if required\n-        ae->currentDimension = i;   // Dimension for $, if required\n-\n-        e = expressionSemantic(e, sc);\n-        e = resolveProperties(sc, e);\n-\n-        if (ae->lengthVar && sc->func)\n-        {\n-            // If $ was used, declare it now\n-            Expression *de = new DeclarationExp(ae->loc, ae->lengthVar);\n-            de = expressionSemantic(de, sc);\n-            *pe0 = Expression::combine(*pe0, de);\n-        }\n-        sc = sc->pop();\n-\n-        if (e->op == TOKinterval)\n-        {\n-            IntervalExp *ie = (IntervalExp *)e;\n-\n-            Objects *tiargs = new Objects();\n-            Expression *edim = new IntegerExp(ae->loc, i, Type::tsize_t);\n-            edim = expressionSemantic(edim, sc);\n-            tiargs->push(edim);\n-\n-            Expressions *fargs = new Expressions();\n-            fargs->push(ie->lwr);\n-            fargs->push(ie->upr);\n-\n-            unsigned xerrors = global.startGagging();\n-            sc = sc->push();\n-            FuncDeclaration *fslice = resolveFuncCall(ae->loc, sc, slice, tiargs, ae->e1->type, fargs, 1);\n-            sc = sc->pop();\n-            global.endGagging(xerrors);\n-            if (!fslice)\n-                goto Lfallback;\n-\n-            e = new DotTemplateInstanceExp(ae->loc, ae->e1, slice->ident, tiargs);\n-            e = new CallExp(ae->loc, e, fargs);\n-            e = expressionSemantic(e, sc);\n-        }\n-\n-        if (!e->type)\n-        {\n-            ae->error(\"%s has no value\", e->toChars());\n-            e = new ErrorExp();\n-        }\n-        if (e->op == TOKerror)\n-            return e;\n-\n-        (*ae->arguments)[i] = e;\n-    }\n-\n-    return ae;\n-}\n-\n-/***********************************************************\n- * Resolve `exp` as a compile-time known string.\n- * Params:\n- *  sc  = scope\n- *  exp = Expression which expected as a string\n- *  s   = What the string is expected for, will be used in error diagnostic.\n- * Returns:\n- *  String literal, or `null` if error happens.\n- */\n-StringExp *semanticString(Scope *sc, Expression *exp, const char *s)\n-{\n-    sc = sc->startCTFE();\n-    exp = expressionSemantic(exp, sc);\n-    exp = resolveProperties(sc, exp);\n-    sc = sc->endCTFE();\n-\n-    if (exp->op == TOKerror)\n-        return NULL;\n-\n-    Expression *e = exp;\n-    if (exp->type->isString())\n-    {\n-        e = e->ctfeInterpret();\n-        if (e->op == TOKerror)\n-            return NULL;\n-    }\n-\n-    StringExp *se = e->toStringExp();\n-    if (!se)\n-    {\n-        exp->error(\"string expected for %s, not (%s) of type %s\",\n-            s, exp->toChars(), exp->type->toChars());\n-        return NULL;\n-    }\n-    return se;\n-}\n-\n-/**************************************\n- * Runs semantic on se->lwr and se->upr. Declares a temporary variable\n- * if '$' was used.\n- */\n-Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, IntervalExp *ie, Expression **pe0)\n-{\n-    //assert(!ae->lengthVar);\n-    if (!ie)\n-        return ae;\n-\n-    VarDeclaration *lengthVar = ae->lengthVar;\n-\n-    // create scope for '$'\n-    ArrayScopeSymbol *sym = new ArrayScopeSymbol(sc, ae);\n-    sym->loc = ae->loc;\n-    sym->parent = sc->scopesym;\n-    sc = sc->push(sym);\n-\n-    for (size_t i = 0; i < 2; ++i)\n-    {\n-        Expression *e = i == 0 ? ie->lwr : ie->upr;\n-        e = expressionSemantic(e, sc);\n-        e = resolveProperties(sc, e);\n-        if (!e->type)\n-        {\n-            ae->error(\"%s has no value\", e->toChars());\n-            return new ErrorExp();\n-        }\n-        (i == 0 ? ie->lwr : ie->upr) = e;\n-    }\n-\n-    if (lengthVar != ae->lengthVar && sc->func)\n-    {\n-        // If $ was used, declare it now\n-        Expression *de = new DeclarationExp(ae->loc, ae->lengthVar);\n-        de = expressionSemantic(de, sc);\n-        *pe0 = Expression::combine(*pe0, de);\n-    }\n-    sc = sc->pop();\n-\n-    return ae;\n-}\n-\n Expression *BinExp::reorderSettingAAElem(Scope *sc)\n {\n     BinExp *be = this;"}, {"sha": "2ed8fac373ec6d7017ccdc5706e11d6a701a96be", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -883,10 +883,14 @@ class BinAssignExp : public BinExp\n \n /****************************************************************/\n \n-class CompileExp : public UnaExp\n+class CompileExp : public Expression\n {\n public:\n-    CompileExp(Loc loc, Expression *e);\n+    Expressions *exps;\n+\n+    CompileExp(Loc loc, Expressions *exps);\n+    Expression *syntaxCopy();\n+    bool equals(RootObject *o);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -1124,7 +1128,6 @@ class ArrayLengthExp : public UnaExp\n public:\n     ArrayLengthExp(Loc loc, Expression *e1);\n \n-    static Expression *rewriteOpAssign(BinExp *exp);\n     void accept(Visitor *v) { v->visit(this); }\n };\n "}, {"sha": "4a37d0fcba253cf93735042ffafcf3c14340793f", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 2021, "deletions": 70, "changes": 2091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -47,26 +47,1252 @@ bool symbolIsVisible(Scope *sc, Dsymbol *s);\n VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n Expression *extractSideEffect(Scope *sc, const char *name, Expression **e0, Expression *e, bool alwaysCopy = false);\n Type *getTypeInfoType(Loc loc, Type *t, Scope *sc);\n+char *MODtoChars(MOD mod);\n bool MODimplicitConv(MOD modfrom, MOD modto);\n+MOD MODmerge(MOD mod1, MOD mod2);\n MATCH MODmethodConv(MOD modfrom, MOD modto);\n void MODMatchToBuffer(OutBuffer *buf, unsigned char lhsMod, unsigned char rhsMod);\n \n void unSpeculative(Scope *sc, RootObject *o);\n-bool arrayExpressionToCommonType(Scope *sc, Expressions *exps, Type **pt);\n-bool checkDefCtor(Loc loc, Type *t);\n bool isDotOpDispatch(Expression *e);\n-bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf, Type *tthis, Expressions *arguments, FuncDeclaration *fd, Type **prettype, Expression **peprefix);\n-Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad, Expression *e1, Declaration *var, int flag = 0);\n bool isNeedThisScope(Scope *sc, Declaration *d);\n-Expression *resolveUFCS(Scope *sc, CallExp *ce);\n bool checkUnsafeAccess(Scope *sc, Expression *e, bool readonly, bool printmsg);\n bool isSafeCast(Expression *e, Type *tfrom, Type *tto);\n FuncDeclaration *isFuncAddress(Expression *e, bool *hasOverloads = NULL);\n Expression *callCpCtor(Scope *sc, Expression *e);\n \n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n-Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NULL);\n-Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL);\n+\n+bool checkPrintfFormat(const Loc &loc, const char *format, Expressions &args, bool isVa_list);\n+bool checkScanfFormat(const Loc &loc, const char *format, Expressions &args, bool isVa_list);\n+\n+/********************************************************\n+ * Perform semantic analysis and CTFE on expressions to produce\n+ * a string.\n+ * Params:\n+ *      buf = append generated string to buffer\n+ *      sc = context\n+ *      exps = array of Expressions\n+ * Returns:\n+ *      true on error\n+ */\n+bool expressionsToString(OutBuffer &buf, Scope *sc, Expressions *exps)\n+{\n+    if (!exps)\n+        return false;\n+\n+    for (size_t i = 0; i < exps->length; i++)\n+    {\n+        Expression *ex = (*exps)[i];\n+        if (!ex)\n+            continue;\n+        Scope *sc2 = sc->startCTFE();\n+        Expression *e2 = expressionSemantic(ex, sc2);\n+        Expression *e3 = resolveProperties(sc2, e2);\n+        sc2->endCTFE();\n+\n+        // allowed to contain types as well as expressions\n+        Expression *e4 = ctfeInterpretForPragmaMsg(e3);\n+        if (!e4 || e4->op == TOKerror)\n+            return true;\n+\n+        // expand tuple\n+        if (TupleExp *te = e4->isTupleExp())\n+        {\n+            if (expressionsToString(buf, sc, te->exps))\n+                return true;\n+            continue;\n+        }\n+        // char literals exp `.toStringExp` return `null` but we cant override it\n+        // because in most contexts we don't want the conversion to succeed.\n+        IntegerExp *ie = e4->isIntegerExp();\n+        const TY ty = (ie && ie->type) ? ie->type->ty : (TY)Terror;\n+        if (ty == Tchar || ty == Twchar || ty == Tdchar)\n+        {\n+            TypeSArray *tsa = new TypeSArray(ie->type, new IntegerExp(ex->loc, 1, Type::tint32));\n+            e4 = new ArrayLiteralExp(ex->loc, tsa, ie);\n+        }\n+\n+        if (StringExp *se = e4->toStringExp())\n+            buf.writestring(se->toUTF8(sc)->toPtr());\n+        else\n+            buf.writestring(e4->toChars());\n+    }\n+    return false;\n+}\n+\n+/***********************************************************\n+ * Resolve `exp` as a compile-time known string.\n+ * Params:\n+ *  sc  = scope\n+ *  exp = Expression which expected as a string\n+ *  s   = What the string is expected for, will be used in error diagnostic.\n+ * Returns:\n+ *  String literal, or `null` if error happens.\n+ */\n+StringExp *semanticString(Scope *sc, Expression *exp, const char *s)\n+{\n+    sc = sc->startCTFE();\n+    exp = expressionSemantic(exp, sc);\n+    exp = resolveProperties(sc, exp);\n+    sc = sc->endCTFE();\n+\n+    if (exp->op == TOKerror)\n+        return NULL;\n+\n+    Expression *e = exp;\n+    if (exp->type->isString())\n+    {\n+        e = e->ctfeInterpret();\n+        if (e->op == TOKerror)\n+            return NULL;\n+    }\n+\n+    StringExp *se = e->toStringExp();\n+    if (!se)\n+    {\n+        exp->error(\"string expected for %s, not (%s) of type %s\",\n+            s, exp->toChars(), exp->type->toChars());\n+        return NULL;\n+    }\n+    return se;\n+}\n+\n+/****************************************************************/\n+\n+static Expression *extractOpDollarSideEffect(Scope *sc, UnaExp *ue)\n+{\n+    Expression *e0;\n+    Expression *e1 = Expression::extractLast(ue->e1, &e0);\n+    // Bugzilla 12585: Extract the side effect part if ue->e1 is comma.\n+\n+    if (!isTrivialExp(e1))\n+    {\n+        /* Even if opDollar is needed, 'e1' should be evaluate only once. So\n+         * Rewrite:\n+         *      e1.opIndex( ... use of $ ... )\n+         *      e1.opSlice( ... use of $ ... )\n+         * as:\n+         *      (ref __dop = e1, __dop).opIndex( ... __dop.opDollar ...)\n+         *      (ref __dop = e1, __dop).opSlice( ... __dop.opDollar ...)\n+         */\n+        e1 = extractSideEffect(sc, \"__dop\", &e0, e1, false);\n+        assert(e1->op == TOKvar);\n+        VarExp *ve = (VarExp *)e1;\n+        ve->var->storage_class |= STCexptemp;     // lifetime limited to expression\n+    }\n+    ue->e1 = e1;\n+    return e0;\n+}\n+\n+/**************************************\n+ * Runs semantic on ae->arguments. Declares temporary variables\n+ * if '$' was used.\n+ */\n+Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n+{\n+    assert(!ae->lengthVar);\n+\n+    *pe0 = NULL;\n+\n+    AggregateDeclaration *ad = isAggregate(ae->e1->type);\n+    Dsymbol *slice = search_function(ad, Id::slice);\n+    //printf(\"slice = %s %s\\n\", slice->kind(), slice->toChars());\n+\n+    for (size_t i = 0; i < ae->arguments->length; i++)\n+    {\n+        if (i == 0)\n+            *pe0 = extractOpDollarSideEffect(sc, ae);\n+\n+        Expression *e = (*ae->arguments)[i];\n+        if (e->op == TOKinterval && !(slice && slice->isTemplateDeclaration()))\n+        {\n+        Lfallback:\n+            if (ae->arguments->length == 1)\n+                return NULL;\n+            ae->error(\"multi-dimensional slicing requires template opSlice\");\n+            return new ErrorExp();\n+        }\n+        //printf(\"[%d] e = %s\\n\", i, e->toChars());\n+\n+        // Create scope for '$' variable for this dimension\n+        ArrayScopeSymbol *sym = new ArrayScopeSymbol(sc, ae);\n+        sym->loc = ae->loc;\n+        sym->parent = sc->scopesym;\n+        sc = sc->push(sym);\n+        ae->lengthVar = NULL;       // Create it only if required\n+        ae->currentDimension = i;   // Dimension for $, if required\n+\n+        e = expressionSemantic(e, sc);\n+        e = resolveProperties(sc, e);\n+\n+        if (ae->lengthVar && sc->func)\n+        {\n+            // If $ was used, declare it now\n+            Expression *de = new DeclarationExp(ae->loc, ae->lengthVar);\n+            de = expressionSemantic(de, sc);\n+            *pe0 = Expression::combine(*pe0, de);\n+        }\n+        sc = sc->pop();\n+\n+        if (e->op == TOKinterval)\n+        {\n+            IntervalExp *ie = (IntervalExp *)e;\n+\n+            Objects *tiargs = new Objects();\n+            Expression *edim = new IntegerExp(ae->loc, i, Type::tsize_t);\n+            edim = expressionSemantic(edim, sc);\n+            tiargs->push(edim);\n+\n+            Expressions *fargs = new Expressions();\n+            fargs->push(ie->lwr);\n+            fargs->push(ie->upr);\n+\n+            unsigned xerrors = global.startGagging();\n+            sc = sc->push();\n+            FuncDeclaration *fslice = resolveFuncCall(ae->loc, sc, slice, tiargs, ae->e1->type, fargs, 1);\n+            sc = sc->pop();\n+            global.endGagging(xerrors);\n+            if (!fslice)\n+                goto Lfallback;\n+\n+            e = new DotTemplateInstanceExp(ae->loc, ae->e1, slice->ident, tiargs);\n+            e = new CallExp(ae->loc, e, fargs);\n+            e = expressionSemantic(e, sc);\n+        }\n+\n+        if (!e->type)\n+        {\n+            ae->error(\"%s has no value\", e->toChars());\n+            e = new ErrorExp();\n+        }\n+        if (e->op == TOKerror)\n+            return e;\n+\n+        (*ae->arguments)[i] = e;\n+    }\n+\n+    return ae;\n+}\n+\n+/**************************************\n+ * Runs semantic on se->lwr and se->upr. Declares a temporary variable\n+ * if '$' was used.\n+ */\n+Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, IntervalExp *ie, Expression **pe0)\n+{\n+    //assert(!ae->lengthVar);\n+    if (!ie)\n+        return ae;\n+\n+    VarDeclaration *lengthVar = ae->lengthVar;\n+\n+    // create scope for '$'\n+    ArrayScopeSymbol *sym = new ArrayScopeSymbol(sc, ae);\n+    sym->loc = ae->loc;\n+    sym->parent = sc->scopesym;\n+    sc = sc->push(sym);\n+\n+    for (size_t i = 0; i < 2; ++i)\n+    {\n+        Expression *e = i == 0 ? ie->lwr : ie->upr;\n+        e = expressionSemantic(e, sc);\n+        e = resolveProperties(sc, e);\n+        if (!e->type)\n+        {\n+            ae->error(\"%s has no value\", e->toChars());\n+            return new ErrorExp();\n+        }\n+        (i == 0 ? ie->lwr : ie->upr) = e;\n+    }\n+\n+    if (lengthVar != ae->lengthVar && sc->func)\n+    {\n+        // If $ was used, declare it now\n+        Expression *de = new DeclarationExp(ae->loc, ae->lengthVar);\n+        de = expressionSemantic(de, sc);\n+        *pe0 = Expression::combine(*pe0, de);\n+    }\n+    sc = sc->pop();\n+\n+    return ae;\n+}\n+\n+/******************************\n+ * Perform semantic() on an array of Expressions.\n+ */\n+\n+bool arrayExpressionSemantic(Expressions *exps, Scope *sc, bool preserveErrors)\n+{\n+    bool err = false;\n+    if (exps)\n+    {\n+        for (size_t i = 0; i < exps->length; i++)\n+        {\n+            Expression *e = (*exps)[i];\n+            if (e)\n+            {\n+                e = expressionSemantic(e, sc);\n+                if (e->op == TOKerror)\n+                    err = true;\n+                if (preserveErrors || e->op != TOKerror)\n+                    (*exps)[i] = e;\n+            }\n+        }\n+    }\n+    return err;\n+}\n+\n+/******************************\n+ * Check the tail CallExp is really property function call.\n+ */\n+static bool checkPropertyCall(Expression *e)\n+{\n+    while (e->op == TOKcomma)\n+        e = ((CommaExp *)e)->e2;\n+\n+    if (e->op == TOKcall)\n+    {\n+        CallExp *ce = (CallExp *)e;\n+        TypeFunction *tf;\n+        if (ce->f)\n+        {\n+            tf = (TypeFunction *)ce->f->type;\n+            /* If a forward reference to ce->f, try to resolve it\n+             */\n+            if (!tf->deco && ce->f->semanticRun < PASSsemanticdone)\n+            {\n+                dsymbolSemantic(ce->f, NULL);\n+                tf = (TypeFunction *)ce->f->type;\n+            }\n+        }\n+        else if (ce->e1->type->ty == Tfunction)\n+            tf = (TypeFunction *)ce->e1->type;\n+        else if (ce->e1->type->ty == Tdelegate)\n+            tf = (TypeFunction *)ce->e1->type->nextOf();\n+        else if (ce->e1->type->ty == Tpointer && ce->e1->type->nextOf()->ty == Tfunction)\n+            tf = (TypeFunction *)ce->e1->type->nextOf();\n+        else\n+            assert(0);\n+    }\n+    return false;\n+}\n+\n+// TODO: merge with Scope::search::searchScopes()\n+static Dsymbol *searchScopes(Scope *sc, Loc loc, Identifier *ident, int flags)\n+{\n+    Dsymbol *s = NULL;\n+    for (Scope *scx = sc; scx; scx = scx->enclosing)\n+    {\n+        if (!scx->scopesym)\n+            continue;\n+        if (scx->scopesym->isModule())\n+            flags |= SearchUnqualifiedModule;    // tell Module.search() that SearchLocalsOnly is to be obeyed\n+        s = scx->scopesym->search(loc, ident, flags);\n+        if (s)\n+        {\n+            // overload set contains only module scope symbols.\n+            if (s->isOverloadSet())\n+                break;\n+            // selective/renamed imports also be picked up\n+            if (AliasDeclaration *ad = s->isAliasDeclaration())\n+            {\n+                if (ad->_import)\n+                    break;\n+            }\n+            // See only module scope symbols for UFCS target.\n+            Dsymbol *p = s->toParent2();\n+            if (p && p->isModule())\n+                break;\n+        }\n+        s = NULL;\n+\n+        // Stop when we hit a module, but keep going if that is not just under the global scope\n+        if (scx->scopesym->isModule() && !(scx->enclosing && !scx->enclosing->enclosing))\n+            break;\n+    }\n+    return s;\n+}\n+\n+/******************************\n+ * Find symbol in accordance with the UFCS name look up rule\n+ */\n+\n+static Expression *searchUFCS(Scope *sc, UnaExp *ue, Identifier *ident)\n+{\n+    //printf(\"searchUFCS(ident = %s)\\n\", ident->toChars());\n+    Loc loc = ue->loc;\n+    int flags = 0;\n+    Dsymbol *s = NULL;\n+\n+    if (sc->flags & SCOPEignoresymbolvisibility)\n+        flags |= IgnoreSymbolVisibility;\n+\n+    // First look in local scopes\n+    s = searchScopes(sc, loc, ident, flags | SearchLocalsOnly);\n+    if (!s)\n+    {\n+        // Second look in imported modules\n+        s = searchScopes(sc, loc, ident, flags | SearchImportsOnly);\n+    }\n+\n+    if (!s)\n+        return ue->e1->type->Type::getProperty(loc, ident, 0);\n+\n+    FuncDeclaration *f = s->isFuncDeclaration();\n+    if (f)\n+    {\n+        TemplateDeclaration *td = getFuncTemplateDecl(f);\n+        if (td)\n+        {\n+            if (td->overroot)\n+                td = td->overroot;\n+            s = td;\n+        }\n+    }\n+\n+    if (ue->op == TOKdotti)\n+    {\n+        DotTemplateInstanceExp *dti = (DotTemplateInstanceExp *)ue;\n+        TemplateInstance *ti = new TemplateInstance(loc, s->ident);\n+        ti->tiargs = dti->ti->tiargs;   // for better diagnostic message\n+        if (!ti->updateTempDecl(sc, s))\n+            return new ErrorExp();\n+        return new ScopeExp(loc, ti);\n+    }\n+    else\n+    {\n+        //printf(\"-searchUFCS() %s\\n\", s->toChars());\n+        return new DsymbolExp(loc, s);\n+    }\n+}\n+\n+/******************************\n+ * Pull out callable entity with UFCS.\n+ */\n+\n+static Expression *resolveUFCS(Scope *sc, CallExp *ce)\n+{\n+    Loc loc = ce->loc;\n+    Expression *eleft;\n+    Expression *e;\n+\n+    if (ce->e1->op == TOKdotid)\n+    {\n+        DotIdExp *die = (DotIdExp *)ce->e1;\n+        Identifier *ident = die->ident;\n+\n+        Expression *ex = semanticX(die, sc);\n+        if (ex != die)\n+        {\n+            ce->e1 = ex;\n+            return NULL;\n+        }\n+        eleft = die->e1;\n+\n+        Type *t = eleft->type->toBasetype();\n+        if (t->ty == Tarray || t->ty == Tsarray ||\n+            t->ty == Tnull  || (t->isTypeBasic() && t->ty != Tvoid))\n+        {\n+            /* Built-in types and arrays have no callable properties, so do shortcut.\n+             * It is necessary in: e.init()\n+             */\n+        }\n+        else if (t->ty == Taarray)\n+        {\n+            if (ident == Id::remove)\n+            {\n+                /* Transform:\n+                 *  aa.remove(arg) into delete aa[arg]\n+                 */\n+                if (!ce->arguments || ce->arguments->length != 1)\n+                {\n+                    ce->error(\"expected key as argument to aa.remove()\");\n+                    return new ErrorExp();\n+                }\n+                if (!eleft->type->isMutable())\n+                {\n+                    ce->error(\"cannot remove key from %s associative array %s\",\n+                            MODtoChars(t->mod), eleft->toChars());\n+                    return new ErrorExp();\n+                }\n+                Expression *key = (*ce->arguments)[0];\n+                key = expressionSemantic(key, sc);\n+                key = resolveProperties(sc, key);\n+\n+                TypeAArray *taa = (TypeAArray *)t;\n+                key = key->implicitCastTo(sc, taa->index);\n+\n+                if (key->checkValue())\n+                    return new ErrorExp();\n+\n+                semanticTypeInfo(sc, taa->index);\n+\n+                return new RemoveExp(loc, eleft, key);\n+            }\n+        }\n+        else\n+        {\n+            if (Expression *ey = semanticY(die, sc, 1))\n+            {\n+                if (ey->op == TOKerror)\n+                    return ey;\n+                ce->e1 = ey;\n+                if (isDotOpDispatch(ey))\n+                {\n+                    unsigned errors = global.startGagging();\n+                    e = expressionSemantic(ce->syntaxCopy(), sc);\n+                    if (!global.endGagging(errors))\n+                        return e;\n+                    /* fall down to UFCS */\n+                }\n+                else\n+                    return NULL;\n+            }\n+        }\n+        e = searchUFCS(sc, die, ident);\n+    }\n+    else if (ce->e1->op == TOKdotti)\n+    {\n+        DotTemplateInstanceExp *dti = (DotTemplateInstanceExp *)ce->e1;\n+        if (Expression *ey = semanticY(dti, sc, 1))\n+        {\n+            ce->e1 = ey;\n+            return NULL;\n+        }\n+        eleft = dti->e1;\n+        e = searchUFCS(sc, dti, dti->ti->name);\n+    }\n+    else\n+        return NULL;\n+\n+    // Rewrite\n+    ce->e1 = e;\n+    if (!ce->arguments)\n+        ce->arguments = new Expressions();\n+    ce->arguments->shift(eleft);\n+\n+    return NULL;\n+}\n+\n+/******************************\n+ * Pull out property with UFCS.\n+ */\n+\n+static Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NULL)\n+{\n+    Loc loc = e1->loc;\n+    Expression *eleft;\n+    Expression *e;\n+\n+    if (e1->op == TOKdotid)\n+    {\n+        DotIdExp *die = (DotIdExp *)e1;\n+        eleft = die->e1;\n+        e = searchUFCS(sc, die, die->ident);\n+    }\n+    else if (e1->op == TOKdotti)\n+    {\n+        DotTemplateInstanceExp *dti;\n+        dti = (DotTemplateInstanceExp *)e1;\n+        eleft = dti->e1;\n+        e = searchUFCS(sc, dti, dti->ti->name);\n+    }\n+    else\n+        return NULL;\n+\n+    if (e == NULL)\n+        return NULL;\n+\n+    // Rewrite\n+    if (e2)\n+    {\n+        // run semantic without gagging\n+        e2 = expressionSemantic(e2, sc);\n+\n+        /* f(e1) = e2\n+         */\n+        Expression *ex = e->copy();\n+        Expressions *a1 = new Expressions();\n+        a1->setDim(1);\n+        (*a1)[0] = eleft;\n+        ex = new CallExp(loc, ex, a1);\n+        ex = trySemantic(ex, sc);\n+\n+        /* f(e1, e2)\n+         */\n+        Expressions *a2 = new Expressions();\n+        a2->setDim(2);\n+        (*a2)[0] = eleft;\n+        (*a2)[1] = e2;\n+        e = new CallExp(loc, e, a2);\n+        if (ex)\n+        {   // if fallback setter exists, gag errors\n+            e = trySemantic(e, sc);\n+            if (!e)\n+            {   checkPropertyCall(ex);\n+                ex = new AssignExp(loc, ex, e2);\n+                return expressionSemantic(ex, sc);\n+            }\n+        }\n+        else\n+        {   // strict setter prints errors if fails\n+            e = expressionSemantic(e, sc);\n+        }\n+        checkPropertyCall(e);\n+        return e;\n+    }\n+    else\n+    {\n+        /* f(e1)\n+         */\n+        Expressions *arguments = new Expressions();\n+        arguments->setDim(1);\n+        (*arguments)[0] = eleft;\n+        e = new CallExp(loc, e, arguments);\n+        e = expressionSemantic(e, sc);\n+        checkPropertyCall(e);\n+        return expressionSemantic(e, sc);\n+    }\n+}\n+\n+/******************************\n+ * If e1 is a property function (template), resolve it.\n+ */\n+\n+Expression *resolvePropertiesOnly(Scope *sc, Expression *e1)\n+{\n+    //printf(\"e1 = %s %s\\n\", Token::toChars(e1->op), e1->toChars());\n+    OverloadSet *os;\n+    FuncDeclaration *fd;\n+    TemplateDeclaration *td;\n+\n+    if (e1->op == TOKdot)\n+    {\n+        DotExp *de = (DotExp *)e1;\n+        if (de->e2->op == TOKoverloadset)\n+        {\n+            os = ((OverExp *)de->e2)->vars;\n+            goto Los;\n+        }\n+    }\n+    else if (e1->op == TOKoverloadset)\n+    {\n+        os = ((OverExp *)e1)->vars;\n+    Los:\n+        assert(os);\n+        for (size_t i = 0; i < os->a.length; i++)\n+        {\n+            Dsymbol *s = os->a[i];\n+            fd = s->isFuncDeclaration();\n+            td = s->isTemplateDeclaration();\n+            if (fd)\n+            {\n+                if (((TypeFunction *)fd->type)->isproperty)\n+                    return resolveProperties(sc, e1);\n+            }\n+            else if (td && td->onemember &&\n+                     (fd = td->onemember->isFuncDeclaration()) != NULL)\n+            {\n+                if (((TypeFunction *)fd->type)->isproperty ||\n+                    (fd->storage_class2 & STCproperty) ||\n+                    (td->_scope->stc & STCproperty))\n+                {\n+                    return resolveProperties(sc, e1);\n+                }\n+            }\n+        }\n+    }\n+    else if (e1->op == TOKdotti)\n+    {\n+        DotTemplateInstanceExp* dti = (DotTemplateInstanceExp *)e1;\n+        if (dti->ti->tempdecl && (td = dti->ti->tempdecl->isTemplateDeclaration()) != NULL)\n+            goto Ltd;\n+    }\n+    else if (e1->op == TOKdottd)\n+    {\n+        td = ((DotTemplateExp *)e1)->td;\n+        goto Ltd;\n+    }\n+    else if (e1->op == TOKscope)\n+    {\n+        Dsymbol *s = ((ScopeExp *)e1)->sds;\n+        TemplateInstance *ti = s->isTemplateInstance();\n+        if (ti && !ti->semanticRun && ti->tempdecl)\n+        {\n+            if ((td = ti->tempdecl->isTemplateDeclaration()) != NULL)\n+                goto Ltd;\n+        }\n+    }\n+    else if (e1->op == TOKtemplate)\n+    {\n+        td = ((TemplateExp *)e1)->td;\n+    Ltd:\n+        assert(td);\n+        if (td->onemember &&\n+            (fd = td->onemember->isFuncDeclaration()) != NULL)\n+        {\n+            if (((TypeFunction *)fd->type)->isproperty ||\n+                (fd->storage_class2 & STCproperty) ||\n+                (td->_scope->stc & STCproperty))\n+            {\n+                return resolveProperties(sc, e1);\n+            }\n+        }\n+    }\n+    else if (e1->op == TOKdotvar && e1->type->ty == Tfunction)\n+    {\n+        DotVarExp *dve = (DotVarExp *)e1;\n+        fd = dve->var->isFuncDeclaration();\n+        goto Lfd;\n+    }\n+    else if (e1->op == TOKvar && e1->type->ty == Tfunction &&\n+        (sc->intypeof || !((VarExp *)e1)->var->needThis()))\n+    {\n+        fd = ((VarExp *)e1)->var->isFuncDeclaration();\n+    Lfd:\n+        assert(fd);\n+        if (((TypeFunction *)fd->type)->isproperty)\n+            return resolveProperties(sc, e1);\n+    }\n+    return e1;\n+}\n+\n+/*************************************************************\n+ * Given var, we need to get the\n+ * right 'this' pointer if var is in an outer class, but our\n+ * existing 'this' pointer is in an inner class.\n+ * Input:\n+ *      e1      existing 'this'\n+ *      ad      struct or class we need the correct 'this' for\n+ *      var     the specific member of ad we're accessing\n+ */\n+\n+static Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad,\n+        Expression *e1, Declaration *var, int flag = 0)\n+{\n+    //printf(\"\\ngetRightThis(e1 = %s, ad = %s, var = %s)\\n\", e1->toChars(), ad->toChars(), var->toChars());\n+ L1:\n+    Type *t = e1->type->toBasetype();\n+    //printf(\"e1->type = %s, var->type = %s\\n\", e1->type->toChars(), var->type->toChars());\n+\n+    /* If e1 is not the 'this' pointer for ad\n+     */\n+    if (ad &&\n+        !(t->ty == Tpointer && t->nextOf()->ty == Tstruct &&\n+          ((TypeStruct *)t->nextOf())->sym == ad)\n+        &&\n+        !(t->ty == Tstruct &&\n+          ((TypeStruct *)t)->sym == ad)\n+       )\n+    {\n+        ClassDeclaration *cd = ad->isClassDeclaration();\n+        ClassDeclaration *tcd = t->isClassHandle();\n+\n+        /* e1 is the right this if ad is a base class of e1\n+         */\n+        if (!cd || !tcd ||\n+            !(tcd == cd || cd->isBaseOf(tcd, NULL))\n+           )\n+        {\n+            /* Only classes can be inner classes with an 'outer'\n+             * member pointing to the enclosing class instance\n+             */\n+            if (tcd && tcd->isNested())\n+            {\n+                /* e1 is the 'this' pointer for an inner class: tcd.\n+                 * Rewrite it as the 'this' pointer for the outer class.\n+                 */\n+\n+                e1 = new DotVarExp(loc, e1, tcd->vthis);\n+                e1->type = tcd->vthis->type;\n+                e1->type = e1->type->addMod(t->mod);\n+                // Do not call checkNestedRef()\n+                //e1 = expressionSemantic(e1, sc);\n+\n+                // Skip up over nested functions, and get the enclosing\n+                // class type.\n+                int n = 0;\n+                Dsymbol *s;\n+                for (s = tcd->toParent();\n+                     s && s->isFuncDeclaration();\n+                     s = s->toParent())\n+                {\n+                    FuncDeclaration *f = s->isFuncDeclaration();\n+                    if (f->vthis)\n+                    {\n+                        //printf(\"rewriting e1 to %s's this\\n\", f->toChars());\n+                        n++;\n+                        e1 = new VarExp(loc, f->vthis);\n+                    }\n+                    else\n+                    {\n+                        e1->error(\"need `this` of type %s to access member %s\"\n+                                  \" from static function %s\",\n+                            ad->toChars(), var->toChars(), f->toChars());\n+                        e1 = new ErrorExp();\n+                        return e1;\n+                    }\n+                }\n+                if (s && s->isClassDeclaration())\n+                {\n+                    e1->type = s->isClassDeclaration()->type;\n+                    e1->type = e1->type->addMod(t->mod);\n+                    if (n > 1)\n+                        e1 = expressionSemantic(e1, sc);\n+                }\n+                else\n+                    e1 = expressionSemantic(e1, sc);\n+                goto L1;\n+            }\n+\n+            /* Can't find a path from e1 to ad\n+             */\n+            if (flag)\n+                return NULL;\n+            e1->error(\"this for %s needs to be type %s not type %s\",\n+                var->toChars(), ad->toChars(), t->toChars());\n+            return new ErrorExp();\n+        }\n+    }\n+    return e1;\n+}\n+\n+/***************************************\n+ * Pull out any properties.\n+ */\n+\n+static Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n+{\n+    //printf(\"resolvePropertiesX, e1 = %s %s, e2 = %s\\n\", Token::toChars(e1->op), e1->toChars(), e2 ? e2->toChars() : NULL);\n+    Loc loc = e1->loc;\n+\n+    OverloadSet *os;\n+    Dsymbol *s;\n+    Objects *tiargs;\n+    Type *tthis;\n+    if (e1->op == TOKdot)\n+    {\n+        DotExp *de = (DotExp *)e1;\n+        if (de->e2->op == TOKoverloadset)\n+        {\n+            tiargs = NULL;\n+            tthis  = de->e1->type;\n+            os = ((OverExp *)de->e2)->vars;\n+            goto Los;\n+        }\n+    }\n+    else if (e1->op == TOKoverloadset)\n+    {\n+        tiargs = NULL;\n+        tthis  = NULL;\n+        os = ((OverExp *)e1)->vars;\n+    Los:\n+        assert(os);\n+        FuncDeclaration *fd = NULL;\n+        if (e2)\n+        {\n+            e2 = expressionSemantic(e2, sc);\n+            if (e2->op == TOKerror)\n+                return new ErrorExp();\n+            e2 = resolveProperties(sc, e2);\n+\n+            Expressions a;\n+            a.push(e2);\n+\n+            for (size_t i = 0; i < os->a.length; i++)\n+            {\n+                FuncDeclaration *f = resolveFuncCall(loc, sc, os->a[i], tiargs, tthis, &a, 1);\n+                if (f)\n+                {\n+                    if (f->errors)\n+                        return new ErrorExp();\n+                    fd = f;\n+                    assert(fd->type->ty == Tfunction);\n+                }\n+            }\n+            if (fd)\n+            {\n+                Expression *e = new CallExp(loc, e1, e2);\n+                return expressionSemantic(e, sc);\n+            }\n+        }\n+        {\n+            for (size_t i = 0; i < os->a.length; i++)\n+            {\n+                FuncDeclaration *f = resolveFuncCall(loc, sc, os->a[i], tiargs, tthis, NULL, 1);\n+                if (f)\n+                {\n+                    if (f->errors)\n+                        return new ErrorExp();\n+                    fd = f;\n+                    assert(fd->type->ty == Tfunction);\n+                    TypeFunction *tf = (TypeFunction *)fd->type;\n+                    if (!tf->isref && e2)\n+                        goto Leproplvalue;\n+                }\n+            }\n+            if (fd)\n+            {\n+                Expression *e = new CallExp(loc, e1);\n+                if (e2)\n+                    e = new AssignExp(loc, e, e2);\n+                return expressionSemantic(e, sc);\n+            }\n+        }\n+        if (e2)\n+            goto Leprop;\n+    }\n+    else if (e1->op == TOKdotti)\n+    {\n+        DotTemplateInstanceExp* dti = (DotTemplateInstanceExp *)e1;\n+        if (!dti->findTempDecl(sc))\n+            goto Leprop;\n+        if (!dti->ti->semanticTiargs(sc))\n+            goto Leprop;\n+        tiargs = dti->ti->tiargs;\n+        tthis  = dti->e1->type;\n+        if ((os = dti->ti->tempdecl->isOverloadSet()) != NULL)\n+            goto Los;\n+        if ((s = dti->ti->tempdecl) != NULL)\n+            goto Lfd;\n+    }\n+    else if (e1->op == TOKdottd)\n+    {\n+        DotTemplateExp *dte = (DotTemplateExp *)e1;\n+        s      = dte->td;\n+        tiargs = NULL;\n+        tthis  = dte->e1->type;\n+        goto Lfd;\n+    }\n+    else if (e1->op == TOKscope)\n+    {\n+        s = ((ScopeExp *)e1)->sds;\n+        TemplateInstance *ti = s->isTemplateInstance();\n+        if (ti && !ti->semanticRun && ti->tempdecl)\n+        {\n+            //assert(ti->needsTypeInference(sc));\n+            if (!ti->semanticTiargs(sc))\n+                goto Leprop;\n+            tiargs = ti->tiargs;\n+            tthis  = NULL;\n+            if ((os = ti->tempdecl->isOverloadSet()) != NULL)\n+                goto Los;\n+            if ((s = ti->tempdecl) != NULL)\n+                goto Lfd;\n+        }\n+    }\n+    else if (e1->op == TOKtemplate)\n+    {\n+        s      = ((TemplateExp *)e1)->td;\n+        tiargs = NULL;\n+        tthis  = NULL;\n+        goto Lfd;\n+    }\n+    else if (e1->op == TOKdotvar && e1->type && e1->type->toBasetype()->ty == Tfunction)\n+    {\n+        DotVarExp *dve = (DotVarExp *)e1;\n+        s      = dve->var->isFuncDeclaration();\n+        tiargs = NULL;\n+        tthis  = dve->e1->type;\n+        goto Lfd;\n+    }\n+    else if (e1->op == TOKvar && e1->type && e1->type->toBasetype()->ty == Tfunction)\n+    {\n+        s      = ((VarExp *)e1)->var->isFuncDeclaration();\n+        tiargs = NULL;\n+        tthis  = NULL;\n+    Lfd:\n+        assert(s);\n+        if (e2)\n+        {\n+            e2 = expressionSemantic(e2, sc);\n+            if (e2->op == TOKerror)\n+                return new ErrorExp();\n+            e2 = resolveProperties(sc, e2);\n+\n+            Expressions a;\n+            a.push(e2);\n+\n+            FuncDeclaration *fd = resolveFuncCall(loc, sc, s, tiargs, tthis, &a, 1);\n+            if (fd && fd->type)\n+            {\n+                if (fd->errors)\n+                    return new ErrorExp();\n+                assert(fd->type->ty == Tfunction);\n+                Expression *e = new CallExp(loc, e1, e2);\n+                return expressionSemantic(e, sc);\n+            }\n+        }\n+        {\n+            FuncDeclaration *fd = resolveFuncCall(loc, sc, s, tiargs, tthis, NULL, 1);\n+            if (fd && fd->type)\n+            {\n+                if (fd->errors)\n+                    return new ErrorExp();\n+                assert(fd->type->ty == Tfunction);\n+                TypeFunction *tf = (TypeFunction *)fd->type;\n+                if (!e2 || tf->isref)\n+                {\n+                    Expression *e = new CallExp(loc, e1);\n+                    if (e2)\n+                        e = new AssignExp(loc, e, e2);\n+                    return expressionSemantic(e, sc);\n+                }\n+            }\n+        }\n+        if (FuncDeclaration *fd = s->isFuncDeclaration())\n+        {\n+            // Keep better diagnostic message for invalid property usage of functions\n+            assert(fd->type->ty == Tfunction);\n+            Expression *e = new CallExp(loc, e1, e2);\n+            return expressionSemantic(e, sc);\n+        }\n+        if (e2)\n+            goto Leprop;\n+    }\n+    if (e1->op == TOKvar)\n+    {\n+        VarExp *ve = (VarExp *)e1;\n+        VarDeclaration *v = ve->var->isVarDeclaration();\n+        if (v && ve->checkPurity(sc, v))\n+            return new ErrorExp();\n+    }\n+    if (e2)\n+        return NULL;\n+\n+    if (e1->type &&\n+        e1->op != TOKtype)      // function type is not a property\n+    {\n+        /* Look for e1 being a lazy parameter; rewrite as delegate call\n+         */\n+        if (e1->op == TOKvar)\n+        {\n+            VarExp *ve = (VarExp *)e1;\n+\n+            if (ve->var->storage_class & STClazy)\n+            {\n+                Expression *e = new CallExp(loc, e1);\n+                return expressionSemantic(e, sc);\n+            }\n+        }\n+        else if (e1->op == TOKdotvar)\n+        {\n+            // Check for reading overlapped pointer field in @safe code.\n+            if (checkUnsafeAccess(sc, e1, true, true))\n+                return new ErrorExp();\n+        }\n+        else if (e1->op == TOKdot)\n+        {\n+            e1->error(\"expression has no value\");\n+            return new ErrorExp();\n+        }\n+        else if (e1->op == TOKcall)\n+        {\n+            CallExp *ce = (CallExp *)e1;\n+            // Check for reading overlapped pointer field in @safe code.\n+            if (checkUnsafeAccess(sc, ce->e1, true, true))\n+                return new ErrorExp();\n+        }\n+    }\n+\n+    if (!e1->type)\n+    {\n+        error(loc, \"cannot resolve type for %s\", e1->toChars());\n+        e1 = new ErrorExp();\n+    }\n+    return e1;\n+\n+Leprop:\n+    error(loc, \"not a property %s\", e1->toChars());\n+    return new ErrorExp();\n+\n+Leproplvalue:\n+    error(loc, \"%s is not an lvalue\", e1->toChars());\n+    return new ErrorExp();\n+}\n+\n+Expression *resolveProperties(Scope *sc, Expression *e)\n+{\n+    //printf(\"resolveProperties(%s)\\n\", e->toChars());\n+\n+    e = resolvePropertiesX(sc, e);\n+    if (e->checkRightThis(sc))\n+        return new ErrorExp();\n+    return e;\n+}\n+\n+/****************************************\n+ * The common type is determined by applying ?: to each pair.\n+ * Output:\n+ *      exps[]  properties resolved, implicitly cast to common type, rewritten in place\n+ *      *pt     if pt is not NULL, set to the common type\n+ * Returns:\n+ *      true    a semantic error was detected\n+ */\n+\n+static bool arrayExpressionToCommonType(Scope *sc, Expressions *exps, Type **pt)\n+{\n+    /* Still have a problem with:\n+     *  ubyte[][] = [ cast(ubyte[])\"hello\", [1]];\n+     * which works if the array literal is initialized top down with the ubyte[][]\n+     * type, but fails with this function doing bottom up typing.\n+     */\n+    //printf(\"arrayExpressionToCommonType()\\n\");\n+    IntegerExp integerexp(0);\n+    CondExp condexp(Loc(), &integerexp, NULL, NULL);\n+\n+    Type *t0 = NULL;\n+    Expression *e0 = NULL;      // dead-store to prevent spurious warning\n+    size_t j0 = ~0;             // dead-store to prevent spurious warning\n+    bool foundType = false;\n+\n+    for (size_t i = 0; i < exps->length; i++)\n+    {\n+        Expression *e = (*exps)[i];\n+        if (!e)\n+            continue;\n+\n+        e = resolveProperties(sc, e);\n+        if (!e->type)\n+        {\n+            e->error(\"%s has no value\", e->toChars());\n+            t0 = Type::terror;\n+            continue;\n+        }\n+        if (e->op == TOKtype)\n+        {\n+            foundType = true;   // do not break immediately, there might be more errors\n+            e->checkValue();    // report an error \"type T has no value\"\n+            t0 = Type::terror;\n+            continue;\n+        }\n+        if (e->type->ty == Tvoid)\n+        {\n+            // void expressions do not concur to the determination of the common\n+            // type.\n+            continue;\n+        }\n+        if (checkNonAssignmentArrayOp(e))\n+        {\n+            t0 = Type::terror;\n+            continue;\n+        }\n+\n+        e = doCopyOrMove(sc, e);\n+\n+        if (!foundType && t0 && !t0->equals(e->type))\n+        {\n+            /* This applies ?: to merge the types. It's backwards;\n+             * ?: should call this function to merge types.\n+             */\n+            condexp.type = NULL;\n+            condexp.e1 = e0;\n+            condexp.e2 = e;\n+            condexp.loc = e->loc;\n+            Expression *ex = expressionSemantic(&condexp, sc);\n+            if (ex->op == TOKerror)\n+                e = ex;\n+            else\n+            {\n+                (*exps)[j0] = condexp.e1;\n+                e = condexp.e2;\n+            }\n+        }\n+        j0 = i;\n+        e0 = e;\n+        t0 = e->type;\n+        if (e->op != TOKerror)\n+            (*exps)[i] = e;\n+    }\n+\n+    if (!t0)\n+        t0 = Type::tvoid;               // [] is typed as void[]\n+    else if (t0->ty != Terror)\n+    {\n+        for (size_t i = 0; i < exps->length; i++)\n+        {\n+            Expression *e = (*exps)[i];\n+            if (!e)\n+                continue;\n+\n+            e = e->implicitCastTo(sc, t0);\n+            //assert(e->op != TOKerror);\n+            if (e->op == TOKerror)\n+            {\n+                /* Bugzilla 13024: a workaround for the bug in typeMerge -\n+                 * it should paint e1 and e2 by deduced common type,\n+                 * but doesn't in this particular case.\n+                 */\n+                t0 = Type::terror;\n+                break;\n+            }\n+            (*exps)[i] = e;\n+        }\n+    }\n+    if (pt)\n+        *pt = t0;\n+\n+    return (t0 == Type::terror);\n+}\n+\n+static Expression *opAssignToOp(Loc loc, TOK op, Expression *e1, Expression *e2)\n+{   Expression *e;\n+\n+    switch (op)\n+    {\n+        case TOKaddass:   e = new AddExp(loc, e1, e2);  break;\n+        case TOKminass:   e = new MinExp(loc, e1, e2);  break;\n+        case TOKmulass:   e = new MulExp(loc, e1, e2);  break;\n+        case TOKdivass:   e = new DivExp(loc, e1, e2);  break;\n+        case TOKmodass:   e = new ModExp(loc, e1, e2);  break;\n+        case TOKandass:   e = new AndExp(loc, e1, e2);  break;\n+        case TOKorass:    e = new OrExp (loc, e1, e2);  break;\n+        case TOKxorass:   e = new XorExp(loc, e1, e2);  break;\n+        case TOKshlass:   e = new ShlExp(loc, e1, e2);  break;\n+        case TOKshrass:   e = new ShrExp(loc, e1, e2);  break;\n+        case TOKushrass:  e = new UshrExp(loc, e1, e2); break;\n+        default:        assert(0);\n+    }\n+    return e;\n+}\n+\n+/*********************\n+ * Rewrite:\n+ *    array.length op= e2\n+ * as:\n+ *    array.length = array.length op e2\n+ * or:\n+ *    auto tmp = &array;\n+ *    (*tmp).length = (*tmp).length op e2\n+ */\n+\n+static Expression *rewriteOpAssign(BinExp *exp)\n+{\n+    Expression *e;\n+\n+    assert(exp->e1->op == TOKarraylength);\n+    ArrayLengthExp *ale = (ArrayLengthExp *)exp->e1;\n+    if (ale->e1->op == TOKvar)\n+    {\n+        e = opAssignToOp(exp->loc, exp->op, ale, exp->e2);\n+        e = new AssignExp(exp->loc, ale->syntaxCopy(), e);\n+    }\n+    else\n+    {\n+        /*    auto tmp = &array;\n+         *    (*tmp).length = (*tmp).length op e2\n+         */\n+        VarDeclaration *tmp = copyToTemp(0, \"__arraylength\", new AddrExp(ale->loc, ale->e1));\n+\n+        Expression *e1 = new ArrayLengthExp(ale->loc, new PtrExp(ale->loc, new VarExp(ale->loc, tmp)));\n+        Expression *elvalue = e1->syntaxCopy();\n+        e = opAssignToOp(exp->loc, exp->op, e1, exp->e2);\n+        e = new AssignExp(exp->loc, elvalue, e);\n+        e = new CommaExp(exp->loc, new DeclarationExp(ale->loc, tmp), e);\n+    }\n+    return e;\n+}\n \n /****************************************\n  * Preprocess arguments to function.\n@@ -76,39 +1302,728 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n  *      true    a semantic error occurred\n  */\n \n-static bool preFunctionParameters(Scope *sc, Expressions *exps)\n-{\n-    bool err = false;\n-    if (exps)\n+static bool preFunctionParameters(Scope *sc, Expressions *exps)\n+{\n+    bool err = false;\n+    if (exps)\n+    {\n+        expandTuples(exps);\n+\n+        for (size_t i = 0; i < exps->length; i++)\n+        {\n+            Expression *arg = (*exps)[i];\n+\n+            arg = resolveProperties(sc, arg);\n+            if (arg->op == TOKtype)\n+            {\n+                arg->error(\"cannot pass type %s as a function argument\", arg->toChars());\n+                arg = new ErrorExp();\n+                err = true;\n+            }\n+            else if (arg->type->toBasetype()->ty == Tfunction)\n+            {\n+                arg->error(\"cannot pass type %s as a function argument\", arg->toChars());\n+                arg = new ErrorExp();\n+                err = true;\n+            }\n+            else if (checkNonAssignmentArrayOp(arg))\n+            {\n+                arg = new ErrorExp();\n+                err = true;\n+            }\n+            (*exps)[i] = arg;\n+        }\n+    }\n+    return err;\n+}\n+\n+/********************************************\n+ * Issue an error if default construction is disabled for type t.\n+ * Default construction is required for arrays and 'out' parameters.\n+ * Returns:\n+ *      true    an error was issued\n+ */\n+static bool checkDefCtor(Loc loc, Type *t)\n+{\n+    t = t->baseElemOf();\n+    if (t->ty == Tstruct)\n+    {\n+        StructDeclaration *sd = ((TypeStruct *)t)->sym;\n+        if (sd->noDefaultCtor)\n+        {\n+            sd->error(loc, \"default construction is disabled\");\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/****************************************\n+ * Now that we know the exact type of the function we're calling,\n+ * the arguments[] need to be adjusted:\n+ *      1. implicitly convert argument to the corresponding parameter type\n+ *      2. add default arguments for any missing arguments\n+ *      3. do default promotions on arguments corresponding to ...\n+ *      4. add hidden _arguments[] argument\n+ *      5. call copy constructor for struct value arguments\n+ * Input:\n+ *      tf      type of the function\n+ *      fd      the function being called, NULL if called indirectly\n+ * Output:\n+ *      *prettype return type of function\n+ *      *peprefix expression to execute before arguments[] are evaluated, NULL if none\n+ * Returns:\n+ *      true    errors happened\n+ */\n+\n+static bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n+        Type *tthis, Expressions *arguments, FuncDeclaration *fd, Type **prettype, Expression **peprefix)\n+{\n+    //printf(\"functionParameters()\\n\");\n+    assert(arguments);\n+    assert(fd || tf->next);\n+    size_t nargs = arguments ? arguments->length : 0;\n+    size_t nparams = tf->parameterList.length();\n+    unsigned olderrors = global.errors;\n+    bool err = false;\n+    *prettype = Type::terror;\n+    Expression *eprefix = NULL;\n+    *peprefix = NULL;\n+\n+    if (nargs > nparams && tf->parameterList.varargs == VARARGnone)\n+    {\n+        error(loc, \"expected %llu arguments, not %llu for non-variadic function type %s\", (ulonglong)nparams, (ulonglong)nargs, tf->toChars());\n+        return true;\n+    }\n+\n+    // If inferring return type, and semantic3() needs to be run if not already run\n+    if (!tf->next && fd->inferRetType)\n+    {\n+        fd->functionSemantic();\n+    }\n+    else if (fd && fd->parent)\n+    {\n+        TemplateInstance *ti = fd->parent->isTemplateInstance();\n+        if (ti && ti->tempdecl)\n+        {\n+            fd->functionSemantic3();\n+        }\n+    }\n+    bool isCtorCall = fd && fd->needThis() && fd->isCtorDeclaration();\n+\n+    size_t n = (nargs > nparams) ? nargs : nparams;   // n = max(nargs, nparams)\n+\n+    /* If the function return type has wildcards in it, we'll need to figure out the actual type\n+     * based on the actual argument types.\n+     */\n+    MOD wildmatch = 0;\n+    if (tthis && tf->isWild() && !isCtorCall)\n+    {\n+        Type *t = tthis;\n+        if (t->isImmutable())\n+            wildmatch = MODimmutable;\n+        else if (t->isWildConst())\n+            wildmatch = MODwildconst;\n+        else if (t->isWild())\n+            wildmatch = MODwild;\n+        else if (t->isConst())\n+            wildmatch = MODconst;\n+        else\n+            wildmatch = MODmutable;\n+    }\n+\n+    int done = 0;\n+    for (size_t i = 0; i < n; i++)\n+    {\n+        Expression *arg;\n+\n+        if (i < nargs)\n+            arg = (*arguments)[i];\n+        else\n+            arg = NULL;\n+\n+        if (i < nparams)\n+        {\n+            Parameter *p = tf->parameterList[i];\n+\n+            if (!arg)\n+            {\n+                if (!p->defaultArg)\n+                {\n+                    if (tf->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n+                        goto L2;\n+                    error(loc, \"expected %llu function arguments, not %llu\", (ulonglong)nparams, (ulonglong)nargs);\n+                    return true;\n+                }\n+                arg = p->defaultArg;\n+                arg = inlineCopy(arg, sc);\n+                // __FILE__, __LINE__, __MODULE__, __FUNCTION__, and __PRETTY_FUNCTION__\n+                arg = arg->resolveLoc(loc, sc);\n+                arguments->push(arg);\n+                nargs++;\n+            }\n+\n+            if (tf->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n+            {\n+                //printf(\"\\t\\tvarargs == 2, p->type = '%s'\\n\", p->type->toChars());\n+                {\n+                    MATCH m;\n+                    if ((m = arg->implicitConvTo(p->type)) > MATCHnomatch)\n+                    {\n+                        if (p->type->nextOf() && arg->implicitConvTo(p->type->nextOf()) >= m)\n+                            goto L2;\n+                        else if (nargs != nparams)\n+                        {   error(loc, \"expected %llu function arguments, not %llu\", (ulonglong)nparams, (ulonglong)nargs);\n+                            return true;\n+                        }\n+                        goto L1;\n+                    }\n+                }\n+             L2:\n+                Type *tb = p->type->toBasetype();\n+                Type *tret = p->isLazyArray();\n+                switch (tb->ty)\n+                {\n+                    case Tsarray:\n+                    case Tarray:\n+                    {\n+                        /* Create a static array variable v of type arg->type:\n+                         *  T[dim] __arrayArg = [ arguments[i], ..., arguments[nargs-1] ];\n+                         *\n+                         * The array literal in the initializer of the hidden variable\n+                         * is now optimized. See Bugzilla 2356.\n+                         */\n+                        Type *tbn = ((TypeArray *)tb)->next;\n+\n+                        Expressions *elements = new Expressions();\n+                        elements->setDim(nargs - i);\n+                        for (size_t u = 0; u < elements->length; u++)\n+                        {\n+                            Expression *a = (*arguments)[i + u];\n+                            if (tret && a->implicitConvTo(tret))\n+                            {\n+                                a = a->implicitCastTo(sc, tret);\n+                                a = a->optimize(WANTvalue);\n+                                a = toDelegate(a, a->type, sc);\n+                            }\n+                            else\n+                                a = a->implicitCastTo(sc, tbn);\n+                            (*elements)[u] = a;\n+                        }\n+                        // Bugzilla 14395: Convert to a static array literal, or its slice.\n+                        arg = new ArrayLiteralExp(loc, tbn->sarrayOf(nargs - i), elements);\n+                        if (tb->ty == Tarray)\n+                        {\n+                            arg = new SliceExp(loc, arg, NULL, NULL);\n+                            arg->type = p->type;\n+                        }\n+                        break;\n+                    }\n+                    case Tclass:\n+                    {\n+                        /* Set arg to be:\n+                         *      new Tclass(arg0, arg1, ..., argn)\n+                         */\n+                        Expressions *args = new Expressions();\n+                        args->setDim(nargs - i);\n+                        for (size_t u = i; u < nargs; u++)\n+                            (*args)[u - i] = (*arguments)[u];\n+                        arg = new NewExp(loc, NULL, NULL, p->type, args);\n+                        break;\n+                    }\n+                    default:\n+                        if (!arg)\n+                        {\n+                            error(loc, \"not enough arguments\");\n+                            return true;\n+                        }\n+                        break;\n+                }\n+                arg = expressionSemantic(arg, sc);\n+                //printf(\"\\targ = '%s'\\n\", arg->toChars());\n+                arguments->setDim(i + 1);\n+                (*arguments)[i] =  arg;\n+                nargs = i + 1;\n+                done = 1;\n+            }\n+\n+        L1:\n+            if (!(p->storageClass & STClazy && p->type->ty == Tvoid))\n+            {\n+                bool isRef = (p->storageClass & (STCref | STCout)) != 0;\n+                if (unsigned char wm = arg->type->deduceWild(p->type, isRef))\n+                {\n+                    if (wildmatch)\n+                        wildmatch = MODmerge(wildmatch, wm);\n+                    else\n+                        wildmatch = wm;\n+                    //printf(\"[%d] p = %s, a = %s, wm = %d, wildmatch = %d\\n\", i, p->type->toChars(), arg->type->toChars(), wm, wildmatch);\n+                }\n+            }\n+        }\n+        if (done)\n+            break;\n+    }\n+    if ((wildmatch == MODmutable || wildmatch == MODimmutable) &&\n+        tf->next->hasWild() &&\n+        (tf->isref || !tf->next->implicitConvTo(tf->next->immutableOf())))\n     {\n-        expandTuples(exps);\n+        if (fd)\n+        {\n+            /* If the called function may return the reference to\n+             * outer inout data, it should be rejected.\n+             *\n+             * void foo(ref inout(int) x) {\n+             *   ref inout(int) bar(inout(int)) { return x; }\n+             *   struct S { ref inout(int) bar() inout { return x; } }\n+             *   bar(int.init) = 1;  // bad!\n+             *   S().bar() = 1;      // bad!\n+             * }\n+             */\n+            Dsymbol *s = NULL;\n+            if (fd->isThis() || fd->isNested())\n+                s = fd->toParent2();\n+            for (; s; s = s->toParent2())\n+            {\n+                if (AggregateDeclaration *ad = s->isAggregateDeclaration())\n+                {\n+                    if (ad->isNested())\n+                        continue;\n+                    break;\n+                }\n+                if (FuncDeclaration *ff = s->isFuncDeclaration())\n+                {\n+                    if (((TypeFunction *)ff->type)->iswild)\n+                        goto Linouterr;\n \n-        for (size_t i = 0; i < exps->length; i++)\n+                    if (ff->isNested() || ff->isThis())\n+                        continue;\n+                }\n+                break;\n+            }\n+        }\n+        else if (tf->isWild())\n         {\n-            Expression *arg = (*exps)[i];\n+        Linouterr:\n+            const char *s = wildmatch == MODmutable ? \"mutable\" : MODtoChars(wildmatch);\n+            error(loc, \"modify inout to %s is not allowed inside inout function\", s);\n+            return true;\n+        }\n+    }\n \n-            arg = resolveProperties(sc, arg);\n-            if (arg->op == TOKtype)\n+    assert(nargs >= nparams);\n+    for (size_t i = 0; i < nargs; i++)\n+    {\n+        Expression *arg = (*arguments)[i];\n+        assert(arg);\n+        if (i < nparams)\n+        {\n+            Parameter *p = tf->parameterList[i];\n+\n+            if (!(p->storageClass & STClazy && p->type->ty == Tvoid))\n             {\n-                arg->error(\"cannot pass type %s as a function argument\", arg->toChars());\n-                arg = new ErrorExp();\n+                Type *tprm = p->type;\n+                if (p->type->hasWild())\n+                    tprm = p->type->substWildTo(wildmatch);\n+                if (!tprm->equals(arg->type))\n+                {\n+                    //printf(\"arg->type = %s, p->type = %s\\n\", arg->type->toChars(), p->type->toChars());\n+                    arg = arg->implicitCastTo(sc, tprm);\n+                    arg = arg->optimize(WANTvalue, (p->storageClass & (STCref | STCout)) != 0);\n+                }\n+            }\n+            if (p->storageClass & STCref)\n+            {\n+                arg = arg->toLvalue(sc, arg);\n+\n+                // Look for mutable misaligned pointer, etc., in @safe mode\n+                err |= checkUnsafeAccess(sc, arg, false, true);\n+            }\n+            else if (p->storageClass & STCout)\n+            {\n+                Type *t = arg->type;\n+                if (!t->isMutable() || !t->isAssignable())  // check blit assignable\n+                {\n+                    arg->error(\"cannot modify struct %s with immutable members\", arg->toChars());\n+                    err = true;\n+                }\n+                else\n+                {\n+                    // Look for misaligned pointer, etc., in @safe mode\n+                    err |= checkUnsafeAccess(sc, arg, false, true);\n+                    err |= checkDefCtor(arg->loc, t);   // t must be default constructible\n+                }\n+                arg = arg->toLvalue(sc, arg);\n+            }\n+            else if (p->storageClass & STClazy)\n+            {\n+                // Convert lazy argument to a delegate\n+                if (p->type->ty == Tvoid)\n+                    arg = toDelegate(arg, p->type, sc);\n+                else\n+                    arg = toDelegate(arg, arg->type, sc);\n+            }\n+\n+            //printf(\"arg: %s\\n\", arg->toChars());\n+            //printf(\"type: %s\\n\", arg->type->toChars());\n+            if (tf->parameterEscapes(p))\n+            {\n+                /* Argument value can escape from the called function.\n+                 * Check arg to see if it matters.\n+                 */\n+                if (global.params.vsafe)\n+                    err |= checkParamArgumentEscape(sc, fd, p->ident, arg, false);\n+            }\n+            else\n+            {\n+                /* Argument value cannot escape from the called function.\n+                 */\n+                Expression *a = arg;\n+                if (a->op == TOKcast)\n+                    a = ((CastExp *)a)->e1;\n+\n+                if (a->op == TOKfunction)\n+                {\n+                    /* Function literals can only appear once, so if this\n+                     * appearance was scoped, there cannot be any others.\n+                     */\n+                    FuncExp *fe = (FuncExp *)a;\n+                    fe->fd->tookAddressOf = 0;\n+                }\n+                else if (a->op == TOKdelegate)\n+                {\n+                    /* For passing a delegate to a scoped parameter,\n+                     * this doesn't count as taking the address of it.\n+                     * We only worry about 'escaping' references to the function.\n+                     */\n+                    DelegateExp *de = (DelegateExp *)a;\n+                    if (de->e1->op == TOKvar)\n+                    {   VarExp *ve = (VarExp *)de->e1;\n+                        FuncDeclaration *f = ve->var->isFuncDeclaration();\n+                        if (f)\n+                        {   f->tookAddressOf--;\n+                            //printf(\"tookAddressOf = %d\\n\", f->tookAddressOf);\n+                        }\n+                    }\n+                }\n+            }\n+            arg = arg->optimize(WANTvalue, (p->storageClass & (STCref | STCout)) != 0);\n+        }\n+        else\n+        {\n+            // These will be the trailing ... arguments\n+\n+            // If not D linkage, do promotions\n+            if (tf->linkage != LINKd)\n+            {\n+                // Promote bytes, words, etc., to ints\n+                arg = integralPromotions(arg, sc);\n+\n+                // Promote floats to doubles\n+                switch (arg->type->ty)\n+                {\n+                    case Tfloat32:\n+                        arg = arg->castTo(sc, Type::tfloat64);\n+                        break;\n+\n+                    case Timaginary32:\n+                        arg = arg->castTo(sc, Type::timaginary64);\n+                        break;\n+                }\n+\n+                if (tf->parameterList.varargs == VARARGvariadic)\n+                {\n+                    const char *p = tf->linkage == LINKc ? \"extern(C)\" : \"extern(C++)\";\n+                    if (arg->type->ty == Tarray)\n+                    {\n+                        arg->error(\"cannot pass dynamic arrays to %s vararg functions\", p);\n+                        err = true;\n+                    }\n+                    if (arg->type->ty == Tsarray)\n+                    {\n+                        arg->error(\"cannot pass static arrays to %s vararg functions\", p);\n+                        err = true;\n+                    }\n+                }\n+            }\n+\n+            // Do not allow types that need destructors\n+            if (arg->type->needsDestruction())\n+            {\n+                arg->error(\"cannot pass types that need destruction as variadic arguments\");\n                 err = true;\n             }\n-            else if (arg->type->toBasetype()->ty == Tfunction)\n+\n+            // Convert static arrays to dynamic arrays\n+            // BUG: I don't think this is right for D2\n+            Type *tb = arg->type->toBasetype();\n+            if (tb->ty == Tsarray)\n             {\n-                arg->error(\"cannot pass type %s as a function argument\", arg->toChars());\n-                arg = new ErrorExp();\n+                TypeSArray *ts = (TypeSArray *)tb;\n+                Type *ta = ts->next->arrayOf();\n+                if (ts->size(arg->loc) == 0)\n+                    arg = new NullExp(arg->loc, ta);\n+                else\n+                    arg = arg->castTo(sc, ta);\n+            }\n+            if (tb->ty == Tstruct)\n+            {\n+                //arg = callCpCtor(sc, arg);\n+            }\n+\n+            // Give error for overloaded function addresses\n+            if (arg->op == TOKsymoff)\n+            {   SymOffExp *se = (SymOffExp *)arg;\n+                if (se->hasOverloads &&\n+                    !se->var->isFuncDeclaration()->isUnique())\n+                {   arg->error(\"function %s is overloaded\", arg->toChars());\n+                    err = true;\n+                }\n+            }\n+            if (arg->checkValue())\n                 err = true;\n+            arg = arg->optimize(WANTvalue);\n+        }\n+        (*arguments)[i] = arg;\n+    }\n+\n+    /* If calling C scanf(), printf(), or any variants, check the format string against the arguments\n+     */\n+    const bool isVa_list = tf->parameterList.varargs == VARARGnone;\n+    if (fd && (fd->flags & FUNCFLAGprintf))\n+    {\n+        if (StringExp *se = (*arguments)[nparams - 1 - isVa_list]->isStringExp())\n+        {\n+            Expressions argslice;\n+            argslice.reserve(nargs - nparams);\n+            for (size_t i = nparams; i < nargs; i++)\n+                argslice.push((*arguments)[i]);\n+            checkPrintfFormat(se->loc, se->toPtr(), argslice, isVa_list);\n+        }\n+    }\n+    else if (fd && (fd->flags & FUNCFLAGscanf))\n+    {\n+        if (StringExp *se = (*arguments)[nparams - 1 - isVa_list]->isStringExp())\n+        {\n+            Expressions argslice;\n+            argslice.reserve(nargs - nparams);\n+            for (size_t i = nparams; i < nargs; i++)\n+                argslice.push((*arguments)[i]);\n+            checkPrintfFormat(se->loc, se->toPtr(), argslice, isVa_list);\n+        }\n+    }\n+\n+    /* Remaining problems:\n+     * 1. order of evaluation - some function push L-to-R, others R-to-L. Until we resolve what array assignment does (which is\n+     *    implemented by calling a function) we'll defer this for now.\n+     * 2. value structs (or static arrays of them) that need to be copy constructed\n+     * 3. value structs (or static arrays of them) that have destructors, and subsequent arguments that may throw before the\n+     *    function gets called (functions normally destroy their parameters)\n+     * 2 and 3 are handled by doing the argument construction in 'eprefix' so that if a later argument throws, they are cleaned\n+     * up properly. Pushing arguments on the stack then cannot fail.\n+     */\n+    if (1)\n+    {\n+        /* TODO: tackle problem 1)\n+         */\n+        const bool leftToRight = true; // TODO: something like !fd.isArrayOp\n+        if (!leftToRight)\n+            assert(nargs == nparams); // no variadics for RTL order, as they would probably be evaluated LTR and so add complexity\n+\n+        const ptrdiff_t start = (leftToRight ? 0 : (ptrdiff_t)nargs - 1);\n+        const ptrdiff_t end = (leftToRight ? (ptrdiff_t)nargs : -1);\n+        const ptrdiff_t step = (leftToRight ? 1 : -1);\n+\n+        /* Compute indices of last throwing argument and first arg needing destruction.\n+         * Used to not set up destructors unless an arg needs destruction on a throw\n+         * in a later argument.\n+         */\n+        ptrdiff_t lastthrow = -1;\n+        ptrdiff_t firstdtor = -1;\n+        for (ptrdiff_t i = start; i != end; i += step)\n+        {\n+            Expression *arg = (*arguments)[i];\n+            if (canThrow(arg, sc->func, false))\n+                lastthrow = i;\n+            if (firstdtor == -1 && arg->type->needsDestruction())\n+            {\n+                Parameter *p = (i >= (ptrdiff_t)nparams ? NULL : tf->parameterList[i]);\n+                if (!(p && (p->storageClass & (STClazy | STCref | STCout))))\n+                    firstdtor = i;\n             }\n-            else if (checkNonAssignmentArrayOp(arg))\n+        }\n+\n+        /* Does problem 3) apply to this call?\n+         */\n+        const bool needsPrefix = (firstdtor >= 0 && lastthrow >= 0\n+            && (lastthrow - firstdtor) * step > 0);\n+\n+        /* If so, initialize 'eprefix' by declaring the gate\n+         */\n+        VarDeclaration *gate = NULL;\n+        if (needsPrefix)\n+        {\n+            // eprefix => bool __gate [= false]\n+            Identifier *idtmp = Identifier::generateId(\"__gate\");\n+            gate = new VarDeclaration(loc, Type::tbool, idtmp, NULL);\n+            gate->storage_class |= STCtemp | STCctfe | STCvolatile;\n+            dsymbolSemantic(gate, sc);\n+\n+            Expression *ae = new DeclarationExp(loc, gate);\n+            eprefix = expressionSemantic(ae, sc);\n+        }\n+\n+        for (ptrdiff_t i = start; i != end; i += step)\n+        {\n+            Expression *arg = (*arguments)[i];\n+\n+            Parameter *parameter = (i >= (ptrdiff_t)nparams ? NULL : tf->parameterList[i]);\n+            const bool isRef = (parameter && (parameter->storageClass & (STCref | STCout)));\n+            const bool isLazy = (parameter && (parameter->storageClass & STClazy));\n+\n+            /* Skip lazy parameters\n+             */\n+            if (isLazy)\n+                continue;\n+\n+            /* Do we have a gate? Then we have a prefix and we're not yet past the last throwing arg.\n+             * Declare a temporary variable for this arg and append that declaration to 'eprefix',\n+             * which will implicitly take care of potential problem 2) for this arg.\n+             * 'eprefix' will therefore finally contain all args up to and including the last\n+             * potentially throwing arg, excluding all lazy parameters.\n+             */\n+            if (gate)\n             {\n-                arg = new ErrorExp();\n+                const bool needsDtor = (!isRef && arg->type->needsDestruction() && i != lastthrow);\n+\n+                /* Declare temporary 'auto __pfx = arg' (needsDtor) or 'auto __pfy = arg' (!needsDtor)\n+                 */\n+                VarDeclaration *tmp = copyToTemp(0,\n+                    needsDtor ? \"__pfx\" : \"__pfy\",\n+                    !isRef ? arg : arg->addressOf());\n+                dsymbolSemantic(tmp, sc);\n+\n+                /* Modify the destructor so it only runs if gate==false, i.e.,\n+                 * only if there was a throw while constructing the args\n+                 */\n+                if (!needsDtor)\n+                {\n+                    if (tmp->edtor)\n+                    {\n+                        assert(i == lastthrow);\n+                        tmp->edtor = NULL;\n+                    }\n+                }\n+                else\n+                {\n+                    // edtor => (__gate || edtor)\n+                    assert(tmp->edtor);\n+                    Expression *e = tmp->edtor;\n+                    e = new LogicalExp(e->loc, TOKoror, new VarExp(e->loc, gate), e);\n+                    tmp->edtor = expressionSemantic(e, sc);\n+                    //printf(\"edtor: %s\\n\", tmp->edtor->toChars());\n+                }\n+\n+                // eprefix => (eprefix, auto __pfx/y = arg)\n+                DeclarationExp *ae = new DeclarationExp(loc, tmp);\n+                eprefix = Expression::combine(eprefix, expressionSemantic(ae, sc));\n+\n+                // arg => __pfx/y\n+                arg = new VarExp(loc, tmp);\n+                arg = expressionSemantic(arg, sc);\n+                if (isRef)\n+                {\n+                    arg = new PtrExp(loc, arg);\n+                    arg = expressionSemantic(arg, sc);\n+                }\n+\n+                /* Last throwing arg? Then finalize eprefix => (eprefix, gate = true),\n+                 * i.e., disable the dtors right after constructing the last throwing arg.\n+                 * From now on, the callee will take care of destructing the args because\n+                 * the args are implicitly moved into function parameters.\n+                 *\n+                 * Set gate to null to let the next iterations know they don't need to\n+                 * append to eprefix anymore.\n+                 */\n+                if (i == lastthrow)\n+                {\n+                    Expression *e = new AssignExp(gate->loc, new VarExp(gate->loc, gate), new IntegerExp(gate->loc, 1, Type::tbool));\n+                    eprefix = Expression::combine(eprefix, expressionSemantic(e, sc));\n+                    gate = NULL;\n+                }\n+            }\n+            else\n+            {\n+                /* No gate, no prefix to append to.\n+                 * Handle problem 2) by calling the copy constructor for value structs\n+                 * (or static arrays of them) if appropriate.\n+                 */\n+                Type *tv = arg->type->baseElemOf();\n+                if (!isRef && tv->ty == Tstruct)\n+                    arg = doCopyOrMove(sc, arg);\n+            }\n+\n+            (*arguments)[i] = arg;\n+        }\n+    }\n+    //if (eprefix) printf(\"eprefix: %s\\n\", eprefix->toChars());\n+\n+    // If D linkage and variadic, add _arguments[] as first argument\n+    if (tf->isDstyleVariadic())\n+    {\n+        assert(arguments->length >= nparams);\n+\n+        Parameters *args = new Parameters;\n+        args->setDim(arguments->length - nparams);\n+        for (size_t i = 0; i < arguments->length - nparams; i++)\n+        {\n+            Parameter *arg = new Parameter(STCin, (*arguments)[nparams + i]->type, NULL, NULL, NULL);\n+            (*args)[i] = arg;\n+        }\n+\n+        TypeTuple *tup = new TypeTuple(args);\n+        Expression *e = new TypeidExp(loc, tup);\n+        e = expressionSemantic(e, sc);\n+        arguments->insert(0, e);\n+    }\n+\n+    Type *tret = tf->next;\n+    if (isCtorCall)\n+    {\n+        //printf(\"[%s] fd = %s %s, %d %d %d\\n\", loc.toChars(), fd->toChars(), fd->type->toChars(),\n+        //    wildmatch, tf->isWild(), fd->isolateReturn());\n+        if (!tthis)\n+        {\n+            assert(sc->intypeof || global.errors);\n+            tthis = fd->isThis()->type->addMod(fd->type->mod);\n+        }\n+        if (tf->isWild() && !fd->isolateReturn())\n+        {\n+            if (wildmatch)\n+                tret = tret->substWildTo(wildmatch);\n+            int offset;\n+            if (!tret->implicitConvTo(tthis) &&\n+                !(MODimplicitConv(tret->mod, tthis->mod) && tret->isBaseOf(tthis, &offset) && offset == 0))\n+            {\n+                const char* s1 = tret ->isNaked() ? \" mutable\" : tret ->modToChars();\n+                const char* s2 = tthis->isNaked() ? \" mutable\" : tthis->modToChars();\n+                ::error(loc, \"inout constructor %s creates%s object, not%s\",\n+                        fd->toPrettyChars(), s1, s2);\n                 err = true;\n             }\n-            (*exps)[i] = arg;\n         }\n+        tret = tthis;\n     }\n-    return err;\n+    else if (wildmatch && tret)\n+    {\n+        /* Adjust function return type based on wildmatch\n+         */\n+        //printf(\"wildmatch = x%x, tret = %s\\n\", wildmatch, tret->toChars());\n+        tret = tret->substWildTo(wildmatch);\n+    }\n+    *prettype = tret;\n+    *peprefix = eprefix;\n+    return (err || olderrors != global.errors);\n }\n \n /**\n@@ -134,13 +2049,34 @@ Package *resolveIsPackage(Dsymbol *sym)\n         }\n         pkg = imp->pkg;\n     }\n+    else if (Module *mod = sym->isModule())\n+        pkg = mod->isPackageFile ? mod->pkg : sym->isPackage();\n     else\n         pkg = sym->isPackage();\n     if (pkg)\n         pkg->resolvePKGunknown();\n     return pkg;\n }\n \n+static Module *loadStdMath()\n+{\n+  static Import *impStdMath = NULL;\n+  if (!impStdMath)\n+    {\n+      Identifiers *a = new Identifiers();\n+      a->push(Id::std);\n+      Import *s = new Import(Loc(), a, Id::math, NULL, false);\n+      s->load(NULL);\n+      if (s->mod)\n+      {\n+          s->mod->importAll(NULL);\n+          dsymbolSemantic(s->mod, NULL);\n+      }\n+      impStdMath = s;\n+    }\n+  return impStdMath->mod;\n+}\n+\n class ExpressionSemanticVisitor : public Visitor\n {\n public:\n@@ -1938,7 +3874,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n     void visit(HaltExp *e)\n     {\n-        e->type = Type::tvoid;\n+        e->type = Type::tnoreturn;\n         result = e;\n     }\n \n@@ -1959,7 +3895,9 @@ class ExpressionSemanticVisitor : public Visitor\n         Type *tded = NULL;\n         if (e->tok2 == TOKpackage || e->tok2 == TOKmodule) // These is() expressions are special because they can work on modules, not just types.\n         {\n+            const unsigned oldErrors = global.startGagging();\n             Dsymbol *sym = e->targ->toDsymbol(sc);\n+            global.endGagging(oldErrors);\n             if (sym == NULL)\n                 goto Lno;\n             Package *p = resolveIsPackage(sym);\n@@ -2292,7 +4230,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (exp->e1->op == TOKarraylength)\n         {\n             // arr.length op= e2;\n-            e = ArrayLengthExp::rewriteOpAssign(exp);\n+            e = rewriteOpAssign(exp);\n             e = expressionSemantic(e, sc);\n             result = e;\n             return;\n@@ -2382,27 +4320,39 @@ class ExpressionSemanticVisitor : public Visitor\n         result = ((BinExp *)e)->reorderSettingAAElem(sc);\n     }\n \n-    void visit(CompileExp *exp)\n+private:\n+    Expression *compileIt(CompileExp *exp)\n     {\n-        StringExp *se = semanticString(sc, exp->e1, \"argument to mixin\");\n-        if (!se)\n-            return setError();\n-        se = se->toUTF8(sc);\n+        OutBuffer buf;\n+        if (expressionsToString(buf, sc, exp->exps))\n+            return NULL;\n+\n         unsigned errors = global.errors;\n-        Parser p(exp->loc, sc->_module, (utf8_t *)se->string, se->len, 0);\n+        const size_t len = buf.length();\n+        const char *str = buf.extractChars();\n+        Parser p(exp->loc, sc->_module, (const utf8_t *)str, len, false);\n         p.nextToken();\n         //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n+\n         Expression *e = p.parseExpression();\n-        if (p.errors)\n-        {\n-            assert(global.errors != errors);        // should have caught all these cases\n-            return setError();\n-        }\n+        if (global.errors != errors)\n+            return NULL;\n+\n         if (p.token.value != TOKeof)\n         {\n-            exp->error(\"incomplete mixin expression (%s)\", se->toChars());\n-            return setError();\n+            exp->error(\"incomplete mixin expression (%s)\", str);\n+            return NULL;\n         }\n+        return e;\n+    }\n+\n+public:\n+    void visit(CompileExp *exp)\n+    {\n+        //printf(\"CompileExp::semantic('%s')\\n\", exp->toChars());\n+        Expression *e = compileIt(exp);\n+        if (!e)\n+            return setError();\n         result = expressionSemantic(e, sc);\n     }\n \n@@ -2508,6 +4458,8 @@ class ExpressionSemanticVisitor : public Visitor\n \n         if (exp->e1->isBool(false))\n         {\n+            /* This is an `assert(0)` which means halt program execution\n+             */\n             FuncDeclaration *fd = sc->parent->isFuncDeclaration();\n             if (fd)\n                 fd->hasReturnExp |= 4;\n@@ -2525,8 +4477,10 @@ class ExpressionSemanticVisitor : public Visitor\n                 result = e;\n                 return;\n             }\n+            exp->type = Type::tnoreturn;\n         }\n-        exp->type = Type::tvoid;\n+        else\n+            exp->type = Type::tvoid;\n         result = exp;\n     }\n \n@@ -3484,7 +5438,8 @@ class ExpressionSemanticVisitor : public Visitor\n                 return setError();\n             }\n \n-            if (!tf->callMatch(NULL, exp->arguments))\n+            const char *failMessage = NULL;\n+            if (!tf->callMatch(NULL, exp->arguments, 0, &failMessage))\n             {\n                 OutBuffer buf;\n \n@@ -3495,10 +5450,11 @@ class ExpressionSemanticVisitor : public Visitor\n                     tthis->modToBuffer(&buf);\n \n                 //printf(\"tf = %s, args = %s\\n\", tf->deco, (*exp->arguments)[0]->type->deco);\n-                ::error(exp->loc, \"%s %s %s is not callable using argument types %s\",\n+                ::error(exp->loc, \"%s `%s%s` is not callable using argument types `%s`\",\n                         p, exp->e1->toChars(), parametersTypeToChars(tf->parameterList),\n                         buf.peekChars());\n-\n+                if (failMessage)\n+                    errorSupplemental(exp->loc, failMessage);\n                 return setError();\n             }\n \n@@ -3553,13 +5509,14 @@ class ExpressionSemanticVisitor : public Visitor\n             assert(exp->f);\n             tiargs = NULL;\n \n-            if (ve->hasOverloads)\n+            if (exp->f->overnext)\n                 exp->f = resolveFuncCall(exp->loc, sc, exp->f, tiargs, NULL, exp->arguments, 2);\n             else\n             {\n                 exp->f = exp->f->toAliasFunc();\n                 TypeFunction *tf = (TypeFunction *)exp->f->type;\n-                if (!tf->callMatch(NULL, exp->arguments))\n+                const char *failMessage = NULL;\n+                if (!tf->callMatch(NULL, exp->arguments, 0, &failMessage))\n                 {\n                     OutBuffer buf;\n \n@@ -3568,10 +5525,11 @@ class ExpressionSemanticVisitor : public Visitor\n                     buf.writeByte(')');\n \n                     //printf(\"tf = %s, args = %s\\n\", tf->deco, (*exp->arguments)[0]->type->deco);\n-                    ::error(exp->loc, \"%s %s is not callable using argument types %s\",\n-                            exp->e1->toChars(), parametersTypeToChars(tf->parameterList),\n+                    ::error(exp->loc, \"%s `%s%s` is not callable using argument types `%s`\",\n+                            exp->f->kind(), exp->e1->toChars(), parametersTypeToChars(tf->parameterList),\n                             buf.peekChars());\n-\n+                    if (failMessage)\n+                        errorSupplemental(exp->loc, failMessage);\n                     exp->f = NULL;\n                 }\n             }\n@@ -3954,6 +5912,10 @@ class ExpressionSemanticVisitor : public Visitor\n                 exp->e1 = exp->e1->castTo(sc, exp->type->pointerTo());\n                 break;\n \n+            case Tnull:\n+                exp->type = Type::tnoreturn;    // typeof(*null) is bottom type\n+                break;\n+\n             default:\n                 exp->error(\"can only * a pointer, not a `%s`\", exp->e1->type->toChars());\n                 /* fall through */\n@@ -7109,25 +9071,6 @@ class ExpressionSemanticVisitor : public Visitor\n         result = exp;\n     }\n \n-    Module *loadStdMath()\n-    {\n-        static Import *impStdMath = NULL;\n-        if (!impStdMath)\n-        {\n-            Identifiers *a = new Identifiers();\n-            a->push(Id::std);\n-            Import *s = new Import(Loc(), a, Id::math, NULL, false);\n-            s->load(NULL);\n-            if (s->mod)\n-            {\n-                s->mod->importAll(NULL);\n-                dsymbolSemantic(s->mod, NULL);\n-            }\n-            impStdMath = s;\n-        }\n-        return impStdMath->mod;\n-    }\n-\n     void visit(PowExp *exp)\n     {\n         if (exp->type)\n@@ -7579,7 +9522,7 @@ class ExpressionSemanticVisitor : public Visitor\n             exp->error(\"%s is not an expression\", exp->e2->toChars());\n             return setError();\n         }\n-        if (e1x->op == TOKerror)\n+        if (e1x->op == TOKerror || e1x->type->ty == Tnoreturn)\n         {\n             result = e1x;\n             return;\n@@ -8032,10 +9975,18 @@ class ExpressionSemanticVisitor : public Visitor\n \n         Type *t1 = exp->e1->type;\n         Type *t2 = exp->e2->type;\n+        if (t1->ty == Tnoreturn)\n+        {\n+            exp->type = t2;\n+        }\n+        else if (t2->ty == Tnoreturn)\n+        {\n+            exp->type = t1;\n+        }\n         // If either operand is void the result is void, we have to cast both\n         // the expression to void so that we explicitly discard the expression\n         // value if any (bugzilla 16598)\n-        if (t1->ty == Tvoid || t2->ty == Tvoid)\n+        else if (t1->ty == Tvoid || t2->ty == Tvoid)\n         {\n             exp->type = Type::tvoid;\n             exp->e1 = exp->e1->castTo(sc, exp->type);"}, {"sha": "b8e1e3183760c98018fa588321dfcdadc0990d5b", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1473,7 +1473,8 @@ FuncDeclaration *resolveFuncCall(Loc loc, Scope *sc, Dsymbol *s,\n     memset(&m, 0, sizeof(m));\n     m.last = MATCHnomatch;\n \n-    functionResolve(&m, s, loc, sc, tiargs, tthis, fargs);\n+    const char *failMessage = NULL;\n+    functionResolve(&m, s, loc, sc, tiargs, tthis, fargs, &failMessage);\n \n     if (m.last > MATCHnomatch && m.lastf)\n     {\n@@ -1555,20 +1556,23 @@ FuncDeclaration *resolveFuncCall(Loc loc, Scope *sc, Dsymbol *s,\n                     ::error(loc, \"none of the overloads of `%s` are callable using a %sobject, candidates are:\",\n                         fd->ident->toChars(), thisBuf.peekChars());\n                 else\n-                    ::error(loc, \"%smethod %s is not callable using a %sobject\",\n+                    ::error(loc, \"%smethod `%s` is not callable using a %sobject\",\n                         funcBuf.peekChars(), fd->toPrettyChars(), thisBuf.peekChars());\n             }\n             else\n             {\n                 //printf(\"tf = %s, args = %s\\n\", tf->deco, (*fargs)[0]->type->deco);\n                 if (hasOverloads)\n-                    ::error(loc, \"none of the overloads of `%s` are callable using argument types %s, candidates are:\",\n+                    ::error(loc, \"none of the overloads of `%s` are callable using argument types `%s`, candidates are:\",\n                             fd->ident->toChars(), fargsBuf.peekChars());\n                 else\n-                    fd->error(loc, \"%s%s is not callable using argument types %s\",\n-                        parametersTypeToChars(tf->parameterList),\n-                        tf->modToChars(),\n-                        fargsBuf.peekChars());\n+                {\n+                    fd->error(loc, \"%s `%s%s%s` is not callable using argument types `%s`\",\n+                        fd->kind(), fd->toPrettyChars(), parametersTypeToChars(tf->parameterList),\n+                        tf->modToChars(), fargsBuf.peekChars());\n+                    if (failMessage)\n+                        errorSupplemental(loc, failMessage);\n+                }\n             }\n \n             // Display candidate functions"}, {"sha": "9eba88f1118db9c37aec276b31282d72580210ce", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -122,7 +122,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(CompileStatement *s)\n     {\n         buf->writestring(\"mixin(\");\n-        s->exp->accept(this);\n+        argsToBuffer(s->exps);\n         buf->writestring(\");\");\n         if (!hgs->forStmtInit)\n             buf->writenl();\n@@ -1104,6 +1104,18 @@ class PrettyPrintVisitor : public Visitor\n         buf->writestring(\"typeof(null)\");\n     }\n \n+    void visit(TypeMixin *t)\n+    {\n+        buf->writestring(\"mixin(\");\n+        argsToBuffer(t->exps);\n+        buf->writeByte(')');\n+    }\n+\n+    void visit(TypeNoreturn *)\n+    {\n+        buf->writestring(\"noreturn\");\n+    }\n+\n     ////////////////////////////////////////////////////////////////////////////\n \n     void visit(Dsymbol *s)\n@@ -1418,7 +1430,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(CompileDeclaration *d)\n     {\n         buf->writestring(\"mixin(\");\n-        d->exp->accept(this);\n+        argsToBuffer(d->exps);\n         buf->writestring(\");\");\n         buf->writenl();\n     }\n@@ -2408,8 +2420,15 @@ class PrettyPrintVisitor : public Visitor\n                     buf->writeByte(')');\n                     if (target.ptrsize == 8)\n                         goto L4;\n-                    else\n+                    else if (target.ptrsize == 4 ||\n+                             target.ptrsize == 2)\n                         goto L3;\n+                    else\n+                        assert(0);\n+\n+                case Tvoid:\n+                    buf->writestring(\"cast(void)0\");\n+                    break;\n \n                 default:\n                     /* This can happen if errors, such as\n@@ -2822,7 +2841,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(CompileExp *e)\n     {\n         buf->writestring(\"mixin(\");\n-        expToBuffer(e->e1, PREC_assign);\n+        argsToBuffer(e->exps);\n         buf->writeByte(')');\n     }\n \n@@ -3528,6 +3547,13 @@ void arrayObjectsToBuffer(OutBuffer *buf, Objects *objects)\n     }\n }\n \n+/*************************************************************\n+ * Pretty print function parameters.\n+ * Params:\n+ *  parameters = parameters to print, such as TypeFunction.parameters.\n+ *  varargs = kind of varargs, see TypeFunction.varargs.\n+ * Returns: Null-terminated string representing parameters.\n+ */\n const char *parametersTypeToChars(ParameterList pl)\n {\n     OutBuffer buf;\n@@ -3536,3 +3562,26 @@ const char *parametersTypeToChars(ParameterList pl)\n     v.parametersToBuffer(pl.parameters, pl.varargs);\n     return buf.extractChars();\n }\n+\n+/*************************************************************\n+ * Pretty print function parameter.\n+ * Params:\n+ *  parameter = parameter to print.\n+ *  tf = TypeFunction which holds parameter.\n+ *  fullQual = whether to fully qualify types.\n+ * Returns: Null-terminated string representing parameters.\n+ */\n+const char *parameterToChars(Parameter *parameter, TypeFunction *tf, bool fullQual)\n+{\n+    OutBuffer buf;\n+    HdrGenState hgs;\n+    hgs.fullQual = fullQual;\n+    PrettyPrintVisitor v(&buf, &hgs);\n+\n+    parameter->accept(&v);\n+    if (tf->parameterList.varargs == 2 && parameter == tf->parameterList[tf->parameterList.parameters->length - 1])\n+    {\n+        buf.writestring(\"...\");\n+    }\n+    return buf.extractChars();\n+}"}, {"sha": "6822aaf44a917e7f939ae390b5f6343bc878fc9c", "filename": "gcc/d/dmd/hdrgen.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fhdrgen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fhdrgen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -47,6 +47,7 @@ void arrayObjectsToBuffer(OutBuffer *buf, Objects *objects);\n void moduleToBuffer(OutBuffer *buf, Module *m);\n \n const char *parametersTypeToChars(ParameterList pl);\n+const char *parameterToChars(Parameter *parameter, TypeFunction *tf, bool fullQual);\n \n bool stcToBuffer(OutBuffer *buf, StorageClass stc);\n const char *stcToChars(StorageClass& stc);"}, {"sha": "0740653709ae37c5459ca69616f6c4c52ebfd820", "filename": "gcc/d/dmd/idgen.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fidgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fidgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidgen.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -86,10 +86,16 @@ Msgtable msgtable[] =\n     { \"__c_longlong\", NULL },\n     { \"__c_ulonglong\", NULL },\n     { \"__c_long_double\", NULL },\n+    { \"__c_wchar_t\", NULL },\n+    { \"__c_complex_float\", NULL },\n+    { \"__c_complex_double\", NULL },\n+    { \"__c_complex_real\", NULL },\n     { \"cpp_type_info_ptr\", \"__cpp_type_info_ptr\" },\n     { \"_assert\", \"assert\" },\n     { \"_unittest\", \"unittest\" },\n     { \"_body\", \"body\" },\n+    { \"printf\", NULL },\n+    { \"scanf\", NULL },\n \n     { \"TypeInfo\", NULL },\n     { \"TypeInfo_Class\", NULL },\n@@ -395,7 +401,6 @@ Msgtable msgtable[] =\n     { \"derivedMembers\", NULL },\n     { \"isSame\", NULL },\n     { \"compiles\", NULL },\n-    { \"parameters\", NULL },\n     { \"getAliasThis\", NULL },\n     { \"getAttributes\", NULL },\n     { \"getFunctionAttributes\", NULL },\n@@ -411,6 +416,7 @@ Msgtable msgtable[] =\n     { \"getLocation\", NULL },\n     { \"hasPostblit\", NULL },\n     { \"isCopyable\", NULL },\n+    { \"toType\", NULL },\n \n     // For C++ mangling\n     { \"allocator\", NULL },"}, {"sha": "07fb32aa0701f535a7be8dbb3be5371fc50e5411", "filename": "gcc/d/dmd/import.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimport.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -47,6 +47,7 @@ class Import : public Dsymbol\n     Dsymbol *syntaxCopy(Dsymbol *s);    // copy only syntax trees\n     void load(Scope *sc);\n     void importAll(Scope *sc);\n+    void addPackageAccess(ScopeDsymbol *scopesym);\n     Dsymbol *toAlias();\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope* sc);"}, {"sha": "1664492bc2d96c553440afa46434a4b4ed495bf7", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -75,6 +75,7 @@ class Module : public Package\n     unsigned numlines;  // number of lines in source file\n     int isDocFile;      // if it is a documentation input file, not D source\n     bool isPackageFile; // if it is a package.d\n+    Package *pkg;       // if isPackageFile is true, the Package that contains this package.d\n     Strings contentImportedFiles;  // array of files whose content was imported\n     int needmoduleinfo;\n "}, {"sha": "6b01999bc7cf213d1dfd644347c6cb5de7140666", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 269, "deletions": 13, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -39,6 +39,7 @@ Expression *extractSideEffect(Scope *sc, const char *name, Expression **e0, Expr\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n Expression *typeToExpression(Type *t);\n Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i = 0);\n+RootObject *compileTypeMixin(TypeMixin *tm, Loc loc, Scope *sc);\n \n /***************************** Type *****************************/\n \n@@ -93,6 +94,7 @@ Type *Type::tdchar;\n Type *Type::tshiftcnt;\n Type *Type::terror;\n Type *Type::tnull;\n+Type *Type::tnoreturn;\n \n Type *Type::tsize_t;\n Type *Type::tptrdiff_t;\n@@ -195,6 +197,8 @@ void Type::_init()\n     sizeTy[Tnull] = sizeof(TypeNull);\n     sizeTy[Tvector] = sizeof(TypeVector);\n     sizeTy[Ttraits] = sizeof(TypeTraits);\n+    sizeTy[Tmixin] = sizeof(TypeMixin);\n+    sizeTy[Tnoreturn] = sizeof(TypeNoreturn);\n \n     initTypeMangle();\n \n@@ -216,6 +220,10 @@ void Type::_init()\n     }\n     basic[Terror] = new TypeError();\n \n+    tnoreturn = new TypeNoreturn();\n+    tnoreturn->deco = tnoreturn->merge()->deco;\n+    basic[Tnoreturn] = tnoreturn;\n+\n     tvoid = basic[Tvoid];\n     tint8 = basic[Tint8];\n     tuns8 = basic[Tuns8];\n@@ -246,7 +254,7 @@ void Type::_init()\n \n     tshiftcnt = tint32;\n     terror = basic[Terror];\n-    tnull = basic[Tnull];\n+    tnoreturn = basic[Tnoreturn];\n     tnull = new TypeNull();\n     tnull->deco = tnull->merge()->deco;\n \n@@ -2079,7 +2087,7 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)\n         if (this != Type::terror)\n         {\n             if (s)\n-                error(loc, \"no property `%s` for type `%s`, did you mean `%s`?\", ident->toChars(), toChars(), s->toChars());\n+                error(loc, \"no property `%s` for type `%s`, did you mean `%s`?\", ident->toChars(), toChars(), s->toPrettyChars());\n             else\n                 error(loc, \"no property `%s` for type `%s`\", ident->toChars(), toChars());\n         }\n@@ -2413,6 +2421,16 @@ TypeTraits *Type::isTypeTraits()\n     return ty == Ttraits ? (TypeTraits *)this : NULL;\n }\n \n+TypeMixin *Type::isTypeMixin()\n+{\n+    return ty == Tmixin ? (TypeMixin *)this : NULL;\n+}\n+\n+TypeNoreturn *Type::isTypeNoreturn()\n+{\n+    return ty == Tnoreturn ? (TypeNoreturn *)this : NULL;\n+}\n+\n TypeFunction *Type::toTypeFunction()\n {\n     if (ty != Tfunction)\n@@ -5175,16 +5193,47 @@ void TypeFunction::purityLevel()\n     tf->purity = purity;\n }\n \n+// arguments get specially formatted\n+static const char *getParamError(TypeFunction *tf, Expression *arg, Parameter *par)\n+{\n+    if (global.gag && !global.params.showGaggedErrors)\n+        return NULL;\n+    // show qualification when toChars() is the same but types are different\n+    const char *at = arg->type->toChars();\n+    bool qual = !arg->type->equals(par->type) && strcmp(at, par->type->toChars()) == 0;\n+    if (qual)\n+        at = arg->type->toPrettyChars(true);\n+    OutBuffer buf;\n+    // only mention rvalue if it's relevant\n+    const bool rv = !arg->isLvalue() && (par->storageClass & (STCref | STCout)) != 0;\n+    buf.printf(\"cannot pass %sargument `%s` of type `%s` to parameter `%s`\",\n+        rv ? \"rvalue \" : \"\", arg->toChars(), at,\n+        parameterToChars(par, tf, qual));\n+    return buf.extractChars();\n+}\n+\n+static const char *getMatchError(const char *format, ...)\n+{\n+    if (global.gag && !global.params.showGaggedErrors)\n+        return NULL;\n+    OutBuffer buf;\n+    va_list ap;\n+    va_start(ap, format);\n+    buf.vprintf(format, ap);\n+    return buf.extractChars();\n+}\n+\n /********************************\n  * 'args' are being matched to function 'this'\n  * Determine match level.\n  * Input:\n  *      flag    1       performing a partial ordering match\n+ *      pMessage        address to store error message, or null\n  * Returns:\n  *      MATCHxxxx\n  */\n \n-MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n+MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag, const char **pMessage)\n {\n     //printf(\"TypeFunction::callMatch() %s\\n\", toChars());\n     MATCH match = MATCHexact;           // assume exact match\n@@ -5221,12 +5270,15 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n \n     size_t nparams = parameterList.length();\n     size_t nargs = args ? args->length : 0;\n-    if (nparams == nargs)\n-        ;\n-    else if (nargs > nparams)\n+    if (nargs > nparams)\n     {\n         if (parameterList.varargs == VARARGnone)\n-            goto Nomatch;               // too many args; no match\n+        {\n+            // suppress early exit if an error message is wanted,\n+            // so we can check any matching args are valid\n+            if (!pMessage)\n+                goto Nomatch;           // too many args; no match\n+        }\n         match = MATCHconvert;           // match ... with a \"conversion\" match level\n     }\n \n@@ -5309,7 +5361,10 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n                 if (m && !arg->isLvalue())\n                 {\n                     if (p->storageClass & STCout)\n+                    {\n+                        if (pMessage) *pMessage = getParamError(this, arg, p);\n                         goto Nomatch;\n+                    }\n \n                     if (arg->op == TOKstring && tp->ty == Tsarray)\n                     {\n@@ -5331,7 +5386,10 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n                         }\n                     }\n                     else\n+                    {\n+                        if (pMessage) *pMessage = getParamError(this, arg, p);\n                         goto Nomatch;\n+                    }\n                 }\n \n                 /* Find most derived alias this type being matched.\n@@ -5351,7 +5409,10 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n                  *  ref T[dim] <- an lvalue of const(T[dim]) argument\n                  */\n                 if (!ta->constConv(tp))\n+                {\n+                    if (pMessage) *pMessage = getParamError(this, arg, p);\n                     goto Nomatch;\n+                }\n             }\n         }\n \n@@ -5377,7 +5438,11 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n                     tsa = (TypeSArray *)tb;\n                     sz = tsa->dim->toInteger();\n                     if (sz != nargs - u)\n+                    {\n+                        if (pMessage)\n+                            *pMessage = getMatchError(\"expected %llu variadic argument(s), not %zu\", sz, nargs - u);\n                         goto Nomatch;\n+                    }\n                     /* fall through */\n                 case Tarray:\n                     {\n@@ -5408,7 +5473,10 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n                                 m = arg->implicitConvTo(ta->next);\n \n                             if (m == MATCHnomatch)\n+                            {\n+                                if (pMessage) *pMessage = getParamError(this, arg, p);\n                                 goto Nomatch;\n+                            }\n                             if (m < match)\n                                 match = m;\n                         }\n@@ -5420,16 +5488,27 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n                     goto Ldone;\n \n                 default:\n-                    goto Nomatch;\n+                    break;\n                 }\n             }\n+            if (pMessage && u < nargs)\n+                *pMessage = getParamError(this, (*args)[u], p);\n+            else if (pMessage)\n+                *pMessage = getMatchError(\"missing argument for parameter #%d: `%s`\",\n+                    u + 1, parameterToChars(p, this, false));\n             goto Nomatch;\n         }\n         if (m < match)\n             match = m;                  // pick worst match\n     }\n \n Ldone:\n+    if (pMessage && !parameterList.varargs && nargs > nparams)\n+    {\n+        // all parameters had a match, but there are surplus args\n+        *pMessage = getMatchError(\"expected %d argument(s), not %d\", nparams, nargs);\n+        goto Nomatch;\n+    }\n     //printf(\"match = %d\\n\", match);\n     return match;\n \n@@ -5797,6 +5876,20 @@ Type *TypeTraits::syntaxCopy()\n     return tt;\n }\n \n+Dsymbol *TypeTraits::toDsymbol(Scope *sc)\n+{\n+    Type *t = NULL;\n+    Expression *e = NULL;\n+    Dsymbol *s = NULL;\n+    resolve(loc, sc, &e, &t, &s);\n+    if (t && t->ty != Terror)\n+        s = t->toDsymbol(sc);\n+    else if (e)\n+        s = getDsymbol(e);\n+\n+    return s;\n+}\n+\n void TypeTraits::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool)\n {\n     *pt = NULL;\n@@ -5816,6 +5909,90 @@ d_uns64 TypeTraits::size(Loc)\n     return SIZE_INVALID;\n }\n \n+/***************************** TypeMixin *****************************/\n+\n+/******\n+ * Implements mixin types.\n+ *\n+ * Semantic analysis will convert it to a real type.\n+ */\n+TypeMixin::TypeMixin(const Loc &loc, Expressions *exps)\n+    : Type(Tmixin)\n+{\n+    this->loc = loc;\n+    this->exps = exps;\n+    this->obj = NULL; // cached result of semantic analysis.\n+}\n+\n+const char *TypeMixin::kind()\n+{\n+    return \"mixin\";\n+}\n+\n+Type *TypeMixin::syntaxCopy()\n+{\n+    return new TypeMixin(loc, Expression::arraySyntaxCopy(exps));\n+}\n+\n+Dsymbol *TypeMixin::toDsymbol(Scope *sc)\n+{\n+    Type *t = NULL;\n+    Expression *e = NULL;\n+    Dsymbol *s = NULL;\n+    resolve(loc, sc, &e, &t, &s);\n+    if (t)\n+        s = t->toDsymbol(sc);\n+    else if (e)\n+        s = getDsymbol(e);\n+\n+    return s;\n+}\n+\n+void TypeMixin::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid)\n+{\n+    // if already resolved just set pe/pt/ps and return.\n+    if (obj)\n+    {\n+        *pe = isExpression(obj);\n+        *pt = isType(obj);\n+        *ps = isDsymbol(obj);\n+        return;\n+    }\n+\n+    RootObject *o = compileTypeMixin(this, loc, sc);\n+    if (Type *t = isType(o))\n+    {\n+        t->resolve(loc, sc, pe, pt, ps, intypeid);\n+        if (*pt)\n+            (*pt) = (*pt)->addMod(mod);\n+    }\n+    else if (Expression *e = isExpression(o))\n+    {\n+        e = expressionSemantic(e, sc);\n+        if (TypeExp *et = e->isTypeExp())\n+        {\n+            *pe = NULL;\n+            *pt = et->type->addMod(mod);\n+            *ps = NULL;\n+        }\n+        else\n+        {\n+            *pe = e;\n+            *pt = NULL;\n+            *ps = NULL;\n+        }\n+    }\n+    else\n+    {\n+        *pe = NULL;\n+        *pt = Type::terror;\n+        *ps = NULL;\n+    }\n+\n+    // save the result\n+    obj = *pe ? (RootObject *)*pe : (*pt ? (RootObject *)*pt : (RootObject *)*ps);\n+}\n+\n /***************************** TypeQualified *****************************/\n \n TypeQualified::TypeQualified(TY ty, Loc loc)\n@@ -6003,11 +6180,25 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n \n             Type *t = s->getType();     // type symbol, type alias, or type tuple?\n             unsigned errorsave = global.errors;\n-            Dsymbol *sm = s->searchX(loc, sc, id);\n-            if (sm && !(sc->flags & SCOPEignoresymbolvisibility) && !symbolIsVisible(sc, sm))\n+            int flags = t == NULL ? SearchLocalsOnly : IgnorePrivateImports;\n+            Dsymbol *sm = s->searchX(loc, sc, id, flags);\n+            if (sm)\n             {\n-                ::error(loc, \"`%s` is not visible from module `%s`\", sm->toPrettyChars(), sc->_module->toChars());\n-                sm = NULL;\n+                if (!(sc->flags & SCOPEignoresymbolvisibility) && !symbolIsVisible(sc, sm))\n+                {\n+                    ::error(loc, \"`%s` is not visible from module `%s`\", sm->toPrettyChars(), sc->_module->toChars());\n+                    sm = NULL;\n+                }\n+                // Same check as in Expression::semanticY(DotIdExp)\n+                else if (sm->isPackage() && checkAccess(sc, (Package *)sm))\n+                {\n+                    // @@@DEPRECATED_2.096@@@\n+                    // Should be an error in 2.106. Just remove the deprecation call\n+                    // and uncomment the null assignment\n+                    ::deprecation(loc, \"%s %s is not accessible here, perhaps add 'static import %s;'\",\n+                         sm->kind(), sm->toPrettyChars(), sm->toPrettyChars());\n+                    //sm = null;\n+                }\n             }\n             if (global.errors != errorsave)\n             {\n@@ -6052,7 +6243,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n                     sm = t->toDsymbol(sc);\n                     if (sm && id->dyncast() == DYNCAST_IDENTIFIER)\n                     {\n-                        sm = sm->search(loc, (Identifier *)id);\n+                        sm = sm->search(loc, (Identifier *)id, IgnorePrivateImports);\n                         if (sm)\n                             goto L2;\n                     }\n@@ -8177,6 +8368,49 @@ Expression *TypeNull::defaultInit(Loc)\n     return new NullExp(Loc(), Type::tnull);\n }\n \n+/***************************** TypeNoreturn *****************************/\n+\n+TypeNoreturn::TypeNoreturn()\n+    : Type(Tnoreturn)\n+{\n+    //printf(\"TypeNoreturn %p\\n\", this);\n+}\n+\n+const char *TypeNoreturn::kind()\n+{\n+    return \"noreturn\";\n+}\n+\n+Type *TypeNoreturn::syntaxCopy()\n+{\n+    // No semantic analysis done, no need to copy\n+    return this;\n+}\n+\n+MATCH TypeNoreturn::implicitConvTo(Type *to)\n+{\n+    //printf(\"TypeNoreturn::implicitConvTo(this=%p, to=%p)\\n\", this, to);\n+    //printf(\"from: %s\\n\", toChars());\n+    //printf(\"to  : %s\\n\", to.toChars());\n+    MATCH m = Type::implicitConvTo(to);\n+    return (m == MATCHexact) ? MATCHexact : MATCHconvert;\n+}\n+\n+bool TypeNoreturn::isBoolean()\n+{\n+    return true;  // bottom type can be implicitly converted to any other type\n+}\n+\n+d_uns64 TypeNoreturn::size(Loc)\n+{\n+    return 0;\n+}\n+\n+unsigned TypeNoreturn::alignsize()\n+{\n+    return 0;\n+}\n+\n /***********************************************************\n  * Encapsulate Parameters* so .length and [i] can be used on it.\n  * https://dlang.org/spec/function.html#ParameterList\n@@ -8472,3 +8706,25 @@ bool Parameter::isCovariantScope(bool returnByRef, StorageClass from, StorageCla\n \n     return covariant[SR::buildSR(returnByRef, from)][SR::buildSR(returnByRef, to)];\n }\n+\n+/**\n+ * For printing two types with qualification when necessary.\n+ * Params:\n+ *    t1 = The first type to receive the type name for\n+ *    t2 = The second type to receive the type name for\n+ * Returns:\n+ *    The fully-qualified names of both types if the two type names are not the same,\n+ *    or the unqualified names of both types if the two type names are the same.\n+ */\n+void toAutoQualChars(const char **result, Type *t1, Type *t2)\n+{\n+    const char *s1 = t1->toChars();\n+    const char *s2 = t2->toChars();\n+    if (strcmp(s1, s2) == 0)\n+    {\n+        s1 = t1->toPrettyChars(true);\n+        s2 = t2->toPrettyChars(true);\n+    }\n+    result[0] = s1;\n+    result[1] = s2;\n+}"}, {"sha": "3687053488df85dea609aed22d601f7a161591c3", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -96,6 +96,8 @@ enum ENUMTY\n     Tint128,\n     Tuns128,\n     Ttraits,\n+    Tmixin,\n+    Tnoreturn,\n     TMAX\n };\n typedef unsigned char TY;       // ENUMTY\n@@ -201,6 +203,7 @@ class Type : public ASTNode\n     static Type *tdstring;              // immutable(dchar)[]\n     static Type *terror;                // for error recovery\n     static Type *tnull;                 // for null type\n+    static Type *tnoreturn;             // for bottom type typeof(*null)\n \n     static Type *tsize_t;               // matches size_t alias\n     static Type *tptrdiff_t;            // matches ptrdiff_t alias\n@@ -367,7 +370,9 @@ class Type : public ASTNode\n     TypeTuple *isTypeTuple();\n     TypeSlice *isTypeSlice();\n     TypeNull *isTypeNull();\n+    TypeMixin *isTypeMixin();\n     TypeTraits *isTypeTraits();\n+    TypeNoreturn *isTypeNoreturn();\n \n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -686,7 +691,7 @@ class TypeFunction : public TypeNext\n     int attributesApply(void *param, int (*fp)(void *, const char *), TRUSTformat trustFormat = TRUSTformatDefault);\n \n     Type *substWildTo(unsigned mod);\n-    MATCH callMatch(Type *tthis, Expressions *toargs, int flag = 0);\n+    MATCH callMatch(Type *tthis, Expressions *toargs, int flag = 0, const char **pMessage = NULL);\n     bool checkRetType(Loc loc);\n \n     Expression *defaultInit(Loc loc) /*const*/;\n@@ -726,11 +731,27 @@ class TypeTraits : public Type\n \n     TypeTraits(const Loc &loc, TraitsExp *exp);\n     Type *syntaxCopy();\n+    Dsymbol *toDsymbol(Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     d_uns64 size(Loc loc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n+class TypeMixin : public Type\n+{\n+public:\n+    Loc loc;\n+    Expressions *exps;\n+    RootObject *obj;\n+\n+    TypeMixin(const Loc &loc, Expressions *exps);\n+    const char *kind();\n+    Type *syntaxCopy();\n+    Dsymbol *toDsymbol(Scope *sc);\n+    void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n+    void accept(Visitor *v) { v->visit(this); }\n+};\n+\n class TypeQualified : public Type\n {\n public:\n@@ -966,6 +987,21 @@ class TypeNull : public Type\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n+class TypeNoreturn : public Type\n+{\n+public:\n+    TypeNoreturn();\n+    const char *kind();\n+\n+    Type *syntaxCopy();\n+    MATCH implicitConvTo(Type *to);\n+    bool isBoolean() /*const*/;\n+\n+    d_uns64 size(Loc loc) /*const*/;\n+    unsigned alignsize();\n+    void accept(Visitor *v) { v->visit(this); }\n+};\n+\n /**************************************************************/\n \n bool arrayTypeCompatible(Loc loc, Type *t1, Type *t2);"}, {"sha": "e1f13214d586204ba49d36b0ade2dd1cee30b463", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 152, "deletions": 65, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -328,11 +328,9 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                     {\n                         // mixin(string)\n                         nextToken();\n-                        check(TOKlparen, \"mixin\");\n-                        Expression *e = parseAssignExp();\n-                        check(TOKrparen);\n+                        Expressions *exps = parseArguments();\n                         check(TOKsemicolon);\n-                        s = new CompileDeclaration(loc, e);\n+                        s = new CompileDeclaration(loc, exps);\n                         break;\n                     }\n                     case TOKtemplate:\n@@ -1336,7 +1334,7 @@ LINK Parser::parseLinkage(Identifiers **pidents, CPPMANGLE *pcppmangle, bool *pc\n                             }\n                             else if (!Identifier::isValidIdentifier(name))\n                             {\n-                                error(\"expected valid identifer for C++ namespace but got `%s`\", name);\n+                                error(\"expected valid identifier for C++ namespace but got `%s`\", name);\n                                 idents = NULL;\n                                 break;\n                             }\n@@ -2922,6 +2920,18 @@ Objects *Parser::parseTemplateArguments()\n     return tiargs;\n }\n \n+/***************************************\n+ * Parse a Type or an Expression\n+ * Returns:\n+ *  RootObject representing the AST\n+ */\n+RootObject *Parser::parseTypeOrAssignExp(TOK endtoken)\n+{\n+    return isDeclaration(&token, 0, endtoken, NULL)\n+        ? (RootObject *)parseType()           // argument is a type\n+        : (RootObject *)parseAssignExp();     // argument is an expression\n+}\n+\n /******************************************\n  * Parse template argument list.\n  * Input:\n@@ -2942,20 +2952,10 @@ Objects *Parser::parseTemplateArgumentList()\n     // Get TemplateArgumentList\n     while (token.value != endtok)\n     {\n-            // See if it is an Expression or a Type\n-            if (isDeclaration(&token, 0, TOKreserved, NULL))\n-            {   // Template argument is a type\n-                Type *ta = parseType();\n-                tiargs->push(ta);\n-            }\n-            else\n-            {   // Template argument is an expression\n-                Expression *ea = parseAssignExp();\n-                tiargs->push(ea);\n-            }\n-            if (token.value != TOKcomma)\n-                break;\n-            nextToken();\n+        tiargs->push(parseTypeOrAssignExp());\n+        if (token.value != TOKcomma)\n+            break;\n+        nextToken();\n     }\n     check(endtok, \"template argument list\");\n     return tiargs;\n@@ -3288,6 +3288,15 @@ Type *Parser::parseBasicType(bool dontLookDotIdents)\n             }\n             break;\n \n+        case TOKmixin:\n+            // https://dlang.org/spec/expression.html#mixin_types\n+            loc = token.loc;\n+            nextToken();\n+            if (token.value != TOKlparen)\n+                error(\"found `%s` when expecting `%s` following %s\", token.toChars(), Token::toChars(TOKlparen), \"`mixin`\");\n+            t = new TypeMixin(loc, parseArguments());\n+            break;\n+\n         case TOKdot:\n             // Leading . as in .foo\n             t = parseBasicTypeStartingAt(new TypeIdentifier(token.loc, Id::empty), dontLookDotIdents);\n@@ -3602,7 +3611,7 @@ Type *Parser::parseDeclarator(Type *t, int *palt, Identifier **pident,\n             if (pident)\n                 *pident = token.ident;\n             else\n-                error(\"unexpected identifer `%s` in declarator\", token.ident->toChars());\n+                error(\"unexpected identifier `%s` in declarator\", token.ident->toChars());\n             ts = t;\n             nextToken();\n             break;\n@@ -3863,6 +3872,21 @@ void Parser::parseStorageClasses(StorageClass &storage_class, LINK &link,\n     }\n }\n \n+static void parseAttributes(Parser *p, bool &hasParsedAttributes,\n+    StorageClass &storage_class, LINK &link, bool &setAlignment,\n+    Expression *&ealign, Expressions *&udas)\n+{\n+    if (hasParsedAttributes) // only parse once\n+        return;\n+    hasParsedAttributes = true;\n+    udas = NULL;\n+    storage_class = STCundefined;\n+    link = p->linkage;\n+    setAlignment = false;\n+    ealign = NULL;\n+    p->parseStorageClasses(storage_class, link, setAlignment, ealign, udas);\n+}\n+\n /**********************************\n  * Parse Declarations.\n  * These can be:\n@@ -3936,35 +3960,59 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n                 bool hasParsedAttributes = false;\n                 if (token.value == TOKat)\n                 {\n-                    if (!hasParsedAttributes)\n-                    {\n-                        hasParsedAttributes = true;\n-                        storage_class = STCundefined;\n-                        link = linkage;\n-                        setAlignment = false;\n-                        ealign = NULL;\n-                        udas = NULL;\n-                        parseStorageClasses(storage_class, link, setAlignment, ealign, udas);\n-                    }\n+                    parseAttributes(this, hasParsedAttributes,\n+                        storage_class, link, setAlignment, ealign, udas);\n                 }\n \n                 Declaration *v;\n-                if (token.value == TOKfunction ||\n+                Dsymbol *s;\n+\n+                // try to parse function type:\n+                // TypeCtors? BasicType ( Parameters ) MemberFunctionAttributes\n+                bool attributesAppended = false;\n+                const StorageClass funcStc = parseTypeCtor();\n+                Token *tlu = &token;\n+                if (token.value != TOKfunction &&\n+                    token.value != TOKdelegate &&\n+                    isBasicType(&tlu) && tlu &&\n+                    tlu->value == TOKlparen)\n+                {\n+                    VarArg vargs;\n+                    Type *tret = parseBasicType();\n+                    Parameters *prms = parseParameters(&vargs);\n+                    ParameterList pl = ParameterList(prms, vargs);\n+\n+                    parseAttributes(this, hasParsedAttributes,\n+                        storage_class, link, setAlignment, ealign, udas);\n+                    if (udas)\n+                        error(\"user-defined attributes not allowed for `alias` declarations\");\n+\n+                    attributesAppended = true;\n+                    storage_class = appendStorageClass(storage_class, funcStc);\n+                    Type *tf = new TypeFunction(pl, tret, link, storage_class);\n+                    v = new AliasDeclaration(loc, ident, tf);\n+                }\n+                else if (token.value == TOKfunction ||\n                     token.value == TOKdelegate ||\n                     (token.value == TOKlparen &&\n                      skipAttributes(peekPastParen(&token), &tk) &&\n                      (tk->value == TOKgoesto || tk->value == TOKlcurly)) ||\n                     token.value == TOKlcurly ||\n-                    (token.value == TOKidentifier && peekNext() == TOKgoesto))\n+                    (token.value == TOKidentifier && peekNext() == TOKgoesto) ||\n+                    (token.value == TOKref && peekNext() == TOKlparen &&\n+                     skipAttributes(peekPastParen(peek(&token)), &tk) &&\n+                     (tk->value == TOKgoesto || tk->value == TOKlcurly)))\n                 {\n                     // function (parameters) { statements... }\n                     // delegate (parameters) { statements... }\n                     // (parameters) { statements... }\n                     // (parameters) => expression\n                     // { statements... }\n                     // identifier => expression\n+                    // ref (parameters) { statements... }\n+                    // ref (parameters) => expression\n \n-                    Dsymbol *s = parseFunctionLiteral();\n+                    s = parseFunctionLiteral();\n \n                     if (udas != NULL)\n                     {\n@@ -3985,26 +4033,19 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n                 else\n                 {\n                     // StorageClasses type\n-                    if (!hasParsedAttributes)\n-                    {\n-                        hasParsedAttributes = true;\n-                        storage_class = STCundefined;\n-                        link = linkage;\n-                        setAlignment = false;\n-                        ealign = NULL;\n-                        udas = NULL;\n-                        parseStorageClasses(storage_class, link, setAlignment, ealign, udas);\n-                    }\n-\n+                    parseAttributes(this, hasParsedAttributes,\n+                        storage_class, link, setAlignment, ealign, udas);\n                     if (udas)\n                         error(\"user-defined attributes not allowed for %s declarations\", Token::toChars(tok));\n \n                     t = parseType();\n                     v = new AliasDeclaration(loc, ident, t);\n                 }\n+                if (!attributesAppended)\n+                    storage_class = appendStorageClass(storage_class, funcStc);\n                 v->storage_class = storage_class;\n \n-                Dsymbol *s = v;\n+                s = v;\n                 if (tpl)\n                 {\n                     Dsymbols *a2 = new Dsymbols();\n@@ -4358,6 +4399,13 @@ Dsymbol *Parser::parseFunctionLiteral()\n         case TOKdelegate:\n             save = token.value;\n             nextToken();\n+            if (token.value == TOKref)\n+            {\n+                // function ref (parameters) { statements... }\n+                // delegate ref (parameters) { statements... }\n+                stc = STCref;\n+                nextToken();\n+            }\n             if (token.value != TOKlparen && token.value != TOKlcurly)\n             {\n                 // function type (parameters) { statements... }\n@@ -4377,14 +4425,22 @@ Dsymbol *Parser::parseFunctionLiteral()\n                 // delegate { statements... }\n                 break;\n             }\n-            /* fall through */\n+            goto LTOKlparen;\n+\n+        case TOKref:\n+            // ref (parameters) => expression\n+            // ref (parameters) { statements... }\n+            stc = STCref;\n+            nextToken();\n+            goto LTOKlparen;\n \n         case TOKlparen:\n+        LTOKlparen:\n         {\n             // (parameters) => expression\n             // (parameters) { statements... }\n             parameters = parseParameters(&varargs, &tpl);\n-            stc = parsePostfix(STCundefined, NULL);\n+            stc = parsePostfix(stc, NULL);\n             if (StorageClass modStc = stc & STC_TYPECTOR)\n             {\n                 if (save == TOKfunction)\n@@ -5093,7 +5149,7 @@ Statement *Parser::parseForeach(Loc loc, bool *isRange, bool isDecl)\n         check(TOKrparen);\n         Loc endloc;\n         Statement *body = (!isDecl) ? parseStatement(0, NULL, &endloc) : NULL;\n-        if (isRange) \n+        if (isRange)\n             *isRange = false;\n         return new ForeachStatement(loc, op, parameters, aggr, body, endloc);\n     }\n@@ -5378,15 +5434,19 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n         }\n \n         case TOKmixin:\n-        {   Token *t = peek(&token);\n+        {\n+            if (isDeclaration(&token, 3, TOKreserved, NULL))\n+                goto Ldeclaration;\n+            Token *t = peek(&token);\n             if (t->value == TOKlparen)\n-            {   // mixin(string)\n+            {\n+                // mixin(string)\n                 Expression *e = parseAssignExp();\n                 check(TOKsemicolon);\n                 if (e->op == TOKmixin)\n                 {\n                     CompileExp *cpe = (CompileExp *)e;\n-                    s = new CompileStatement(loc, cpe->e1);\n+                    s = new CompileStatement(loc, cpe->exps);\n                 }\n                 else\n                 {\n@@ -6332,6 +6392,7 @@ bool Parser::isBasicType(Token **pt)\n \n         case TOKtypeof:\n         case TOKvector:\n+        case TOKmixin:\n             /* typeof(exp).identifier...\n              */\n             t = peek(t);\n@@ -6592,16 +6653,24 @@ bool Parser::isDeclarator(Token **pt, int *haveId, int *haveTpl, TOK endtok, boo\n             case TOKin:\n             case TOKout:\n             case TOKdo:\n+            LTOKdo:\n                 // The !parens is to disallow unnecessary parentheses\n                 if (!parens && (endtok == TOKreserved || endtok == t->value))\n-                {   *pt = t;\n+                {\n+                    *pt = t;\n                     return true;\n                 }\n                 return false;\n \n             case TOKif:\n                 return haveTpl ? true : false;\n \n+            // Used for mixin type parsing\n+            case TOKeof:\n+                if (endtok == TOKeof)\n+                    goto LTOKdo;\n+                return false;\n+\n             default:\n             Ldefault:\n                 return false;\n@@ -7229,15 +7298,7 @@ Expression *Parser::parsePrimaryExp()\n         {\n             nextToken();\n             check(TOKlparen, \"typeid\");\n-            RootObject *o;\n-            if (isDeclaration(&token, 0, TOKreserved, NULL))\n-            {   // argument is a type\n-                o = parseType();\n-            }\n-            else\n-            {   // argument is an expression\n-                o = parseAssignExp();\n-            }\n+            RootObject *o = parseTypeOrAssignExp();\n             check(TOKrparen);\n             e = new TypeidExp(loc, o);\n             break;\n@@ -7279,6 +7340,14 @@ Expression *Parser::parsePrimaryExp()\n             if (token.value == TOKlparen)\n             {\n                 nextToken();\n+                if (token.value == TOKidentifier && peekNext() == TOKlparen)\n+                {\n+                    error(loc, \"unexpected `(` after `%s`, inside `is` expression. Try enclosing the contents of `is` with a `typeof` expression\", token.toChars());\n+                    nextToken();\n+                    Token *tempTok = peekPastParen(&token);\n+                    memcpy(&token, tempTok, sizeof(Token));\n+                    goto Lerr;\n+                }\n                 targ = parseType(&ident);\n                 if (token.value == TOKcolon || token.value == TOKequal)\n                 {\n@@ -7357,11 +7426,11 @@ Expression *Parser::parsePrimaryExp()\n \n         case TOKmixin:\n         {\n+            // https://dlang.org/spec/expression.html#mixin_expressions\n             nextToken();\n-            check(TOKlparen, \"mixin\");\n-            e = parseAssignExp();\n-            check(TOKrparen);\n-            e = new CompileExp(loc, e);\n+            if (token.value != TOKlparen)\n+                error(\"found `%s` when expecting `%s` following %s\", token.toChars(), Token::toChars(TOKlparen), \"`mixin`\");\n+            e = new CompileExp(loc, parseArguments());\n             break;\n         }\n \n@@ -7379,6 +7448,24 @@ Expression *Parser::parsePrimaryExp()\n             e = parseNewExp(NULL);\n             break;\n \n+        case TOKref:\n+        {\n+            if (peekNext() == TOKlparen)\n+            {\n+                Token *tk = peekPastParen(peek(&token));\n+                if (skipAttributes(tk, &tk) &&\n+                    (tk->value == TOKgoesto || tk->value == TOKlcurly))\n+                {\n+                    // ref (arguments) => expression\n+                    // ref (arguments) { statements... }\n+                    goto case_delegate;\n+                }\n+            }\n+            nextToken();\n+            error(\"found `%s` when expecting function literal following `ref`\", token.toChars());\n+            goto Lerr;\n+        }\n+\n         case TOKlparen:\n         {\n             Token *tk = peekPastParen(&token);"}, {"sha": "a2ad47882eff45a9e38c8d6b6dc4899600b2b297", "filename": "gcc/d/dmd/parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -83,6 +83,7 @@ class Parser : public Lexer\n     TemplateParameters *parseTemplateParameterList(int flag = 0);\n     Dsymbol *parseMixin();\n     Objects *parseTemplateArguments();\n+    RootObject *parseTypeOrAssignExp(TOK endtoken = TOKreserved);\n     Objects *parseTemplateArgumentList();\n     Objects *parseTemplateSingleArgument();\n     StaticAssert *parseStaticAssert();"}, {"sha": "ea3061b8fa6466e077ebd1028211c3ea5002e692", "filename": "gcc/d/dmd/scope.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fscope.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -66,6 +66,10 @@ enum PINLINE;\n #define SCOPEfullinst       0x10000 // fully instantiate templates\n #define SCOPEalias          0x20000 // inside alias declaration\n \n+// The following are mutually exclusive\n+#define SCOPEprintf         0x40000 // printf-style function\n+#define SCOPEscanf          0x80000 // scanf-style function\n+\n struct Scope\n {\n     Scope *enclosing;           // enclosing Scope"}, {"sha": "194a3fb96611c28646c35e653c83647ab49791e5", "filename": "gcc/d/dmd/semantic2.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fsemantic2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fsemantic2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -163,6 +163,15 @@ class Semantic2Visitor : public Visitor\n         if (vd->_init && !vd->toParent()->isFuncDeclaration())\n         {\n             vd->inuse++;\n+\n+            /* https://issues.dlang.org/show_bug.cgi?id=20280\n+             *\n+             * Template instances may import modules that have not\n+             * finished semantic1.\n+             */\n+            if (!vd->type)\n+                dsymbolSemantic(vd, sc);\n+\n             // Bugzilla 14166: Don't run CTFE for the temporary variables inside typeof\n             vd->_init = initializerSemantic(vd->_init, sc, vd->type, sc->intypeof == 1 ? INITnointerpret : INITinterpret);\n             vd->inuse--;\n@@ -265,6 +274,17 @@ class Semantic2Visitor : public Visitor\n     {\n         if (fd->semanticRun >= PASSsemantic2done)\n             return;\n+\n+        if (fd->semanticRun < PASSsemanticdone && !fd->errors)\n+        {\n+            /* https://issues.dlang.org/show_bug.cgi?id=21614\n+             *\n+             * Template instances may import modules that have not\n+             * finished semantic1.\n+             */\n+            dsymbolSemantic(fd, sc);\n+        }\n+\n         assert(fd->semanticRun <= PASSsemantic2);\n         fd->semanticRun = PASSsemantic2;\n "}, {"sha": "6bd9a6d2e27c6e266aad902757d823ce474a53c6", "filename": "gcc/d/dmd/semantic3.c", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fsemantic3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fsemantic3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -850,32 +850,18 @@ class Semantic3Visitor : public Visitor\n                     }\n                     assert(!funcdecl->returnLabel);\n                 }\n+                else if (f->next->ty == Tnoreturn)\n+                {\n+                }\n                 else\n                 {\n                     const bool inlineAsm = (funcdecl->hasReturnExp & 8) != 0;\n                     if ((blockexit & BEfallthru) && f->next->ty != Tvoid && !inlineAsm)\n                     {\n-                        Expression *e;\n                         if (!funcdecl->hasReturnExp)\n-                            funcdecl->error(\"has no return statement, but is expected to return a value of type %s\", f->next->toChars());\n-                        else\n-                            funcdecl->error(\"no return exp; or assert(0); at end of function\");\n-                        if (global.params.useAssert == CHECKENABLEon &&\n-                            !global.params.useInline)\n-                        {\n-                            /* Add an assert(0, msg); where the missing return\n-                             * should be.\n-                             */\n-                            e = new AssertExp(funcdecl->endloc,\n-                                              new IntegerExp(0),\n-                                              new StringExp(funcdecl->loc, const_cast<char *>(\"missing return expression\")));\n-                        }\n+                            funcdecl->error(\"has no `return` statement, but is expected to return a value of type `%s`\", f->next->toChars());\n                         else\n-                            e = new HaltExp(funcdecl->endloc);\n-                        e = new CommaExp(Loc(), e, f->next->defaultInit());\n-                        e = expressionSemantic(e, sc2);\n-                        Statement *s = new ExpStatement(Loc(), e);\n-                        funcdecl->fbody = new CompoundStatement(Loc(), funcdecl->fbody, s);\n+                            funcdecl->error(\"no `return exp;` or `assert(0);` at end of function\");\n                     }\n                 }\n \n@@ -1162,15 +1148,7 @@ class Semantic3Visitor : public Visitor\n \n                     if (cd)\n                     {\n-                        if (!global.params.is64bit &&\n-                            global.params.isWindows &&\n-                            !funcdecl->isStatic() && !sbody->usesEH() && !global.params.trace)\n-                        {\n-                            /* The back end uses the \"jmonitor\" hack for syncing;\n-                             * no need to do the sync at this level.\n-                             */\n-                        }\n-                        else\n+                        if (target.libraryObjectMonitors(funcdecl, sbody))\n                         {\n                             Expression *vsync;\n                             if (funcdecl->isStatic())"}, {"sha": "1f8e5122b1a72c829f686fbecff55406f6035dfc", "filename": "gcc/d/dmd/statement.c", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fstatement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fstatement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -31,6 +31,7 @@ StorageClass mergeFuncAttrs(StorageClass s1, FuncDeclaration *f);\n bool checkEscapeRef(Scope *sc, Expression *e, bool gag);\n VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n Statement *makeTupleForeachStatic(Scope *sc, ForeachStatement *fs, bool needExpansion);\n+bool expressionsToString(OutBuffer &buf, Scope *sc, Expressions *exps);\n \n Identifier *fixupLabelName(Scope *sc, Identifier *ident)\n {\n@@ -504,12 +505,19 @@ Statement *DtorExpStatement::syntaxCopy()\n CompileStatement::CompileStatement(Loc loc, Expression *exp)\n     : Statement(loc)\n {\n-    this->exp = exp;\n+    this->exps = new Expressions();\n+    this->exps->push(exp);\n+}\n+\n+CompileStatement::CompileStatement(Loc loc, Expressions *exps)\n+    : Statement(loc)\n+{\n+    this->exps = exps;\n }\n \n Statement *CompileStatement::syntaxCopy()\n {\n-    return new CompileStatement(loc, exp->syntaxCopy());\n+    return new CompileStatement(loc, Expression::arraySyntaxCopy(exps));\n }\n \n static Statements *errorStatements()\n@@ -519,32 +527,36 @@ static Statements *errorStatements()\n     return a;\n }\n \n-Statements *CompileStatement::flatten(Scope *sc)\n+static Statements *compileIt(CompileStatement *cs, Scope *sc)\n {\n-    //printf(\"CompileStatement::flatten() %s\\n\", exp->toChars());\n-    StringExp *se = semanticString(sc, exp, \"argument to mixin\");\n-    if (!se)\n+    //printf(\"CompileStatement::compileIt() %s\\n\", exp->toChars());\n+    OutBuffer buf;\n+    if (expressionsToString(buf, sc, cs->exps))\n         return errorStatements();\n-    se = se->toUTF8(sc);\n \n     unsigned errors = global.errors;\n-    Parser p(loc, sc->_module, (utf8_t *)se->string, se->len, 0);\n+    const size_t len = buf.length();\n+    const char *str = buf.extractChars();\n+    Parser p(cs->loc, sc->_module, (const utf8_t *)str, len, false);\n     p.nextToken();\n \n     Statements *a = new Statements();\n     while (p.token.value != TOKeof)\n     {\n         Statement *s = p.parseStatement(PSsemi | PScurlyscope);\n-        if (!s || p.errors)\n-        {\n-            assert(!p.errors || global.errors != errors); // make sure we caught all the cases\n+        if (!s || global.errors != errors)\n             return errorStatements();\n-        }\n         a->push(s);\n     }\n     return a;\n }\n \n+Statements *CompileStatement::flatten(Scope *sc)\n+{\n+    //printf(\"CompileStatement::flatten() %s\\n\", exp->toChars());\n+    return compileIt(this, sc);\n+}\n+\n /******************************** CompoundStatement ***************************/\n \n CompoundStatement::CompoundStatement(Loc loc, Statements *s)"}, {"sha": "c64e51a5be7d5e4854f25a90cec34c13170dc93a", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -173,9 +173,10 @@ class DtorExpStatement : public ExpStatement\n class CompileStatement : public Statement\n {\n public:\n-    Expression *exp;\n+    Expressions *exps;\n \n     CompileStatement(Loc loc, Expression *exp);\n+    CompileStatement(Loc loc, Expressions *exps);\n     Statement *syntaxCopy();\n     Statements *flatten(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }"}, {"sha": "491d9c9bce995727b45f7566b57065bb5a694cd6", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -581,7 +581,7 @@ class StatementSemanticVisitor : public Visitor\n                         {\n                             fs->error(\"constant value %s cannot be ref\", ie->toChars());\n                         }\n-                        else \n+                        else\n                         {\n                             fs->error(\"constant value %s cannot be ref\", ident->toChars());\n                         }"}, {"sha": "f8f977c9aeac90e0f10ec20fb9372d21e84ce0ec", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -21,6 +21,7 @@ class Dsymbol;\n class Expression;\n class FuncDeclaration;\n class Parameter;\n+class Statement;\n class Type;\n class TypeFunction;\n class TypeTuple;\n@@ -30,6 +31,7 @@ struct TargetC\n {\n     unsigned longsize;            // size of a C 'long' or 'unsigned long' type\n     unsigned long_doublesize;     // size of a C 'long double'\n+    Type *twchar_t;               // C 'wchar_t' type\n };\n \n struct TargetCPP\n@@ -44,6 +46,7 @@ struct TargetCPP\n     const char *typeMangle(Type *t);\n     Type *parameterType(Parameter *p);\n     bool fundamentalType(const Type *t, bool& isFundamental);\n+    unsigned derivedClassOffset(ClassDeclaration *baseClass);\n };\n \n struct TargetObjC\n@@ -108,6 +111,7 @@ struct Target\n     TypeTuple *toArgTypes(Type *t);\n     bool isReturnOnStack(TypeFunction *tf, bool needsThis);\n     Expression *getTargetInfo(const char* name, const Loc& loc);\n+    bool libraryObjectMonitors(FuncDeclaration *fd, Statement *fbody);\n };\n \n extern Target target;"}, {"sha": "fb842ac5b76b6420b662bb81ff93ab3fb759741e", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -78,6 +78,7 @@ class TemplateDeclaration : public ScopeDsymbol\n     bool ismixin;               // template declaration is only to be used as a mixin\n     bool isstatic;              // this is static template declaration\n     Prot protection;\n+    int inuse;                  // for recursive expansion detection\n \n     TemplatePrevious *previous;         // threaded list of previous instantiation attempts on stack\n "}, {"sha": "d3e9b2390e924c1f5ae09c6605f33ae507ad9adb", "filename": "gcc/d/dmd/templateparamsem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -25,7 +25,7 @@ class TemplateParameterSemanticVisitor : public Visitor\n     {\n         this->sc = sc;\n         this->parameters = parameters;\n-\tthis->result = false;\n+        this->result = false;\n     }\n \n     void visit(TemplateTypeParameter *ttp)"}, {"sha": "99b5457f031ea8885807bef95c86e492c85faf83", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 83, "deletions": 20, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -40,6 +40,8 @@ void freeFieldinit(Scope *sc);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n Package *resolveIsPackage(Dsymbol *sym);\n Expression *typeToExpression(Type *t);\n+Type *decoToType(const char *deco);\n+bool expressionsToString(OutBuffer &buf, Scope *sc, Expressions *exps);\n \n \n /************************************************\n@@ -442,7 +444,6 @@ TraitsInitializer::TraitsInitializer()\n         \"derivedMembers\",\n         \"isSame\",\n         \"compiles\",\n-        \"parameters\",\n         \"getAliasThis\",\n         \"getAttributes\",\n         \"getFunctionAttributes\",\n@@ -1032,6 +1033,34 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         ex = expressionSemantic(ex, sc);\n         return ex;\n     }\n+    else if (e->ident == Id::toType)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        Expression *ex = isExpression((*e->args)[0]);\n+        if (!ex)\n+        {\n+            e->error(\"expression expected as second argument of __traits `%s`\", e->ident->toChars());\n+            return new ErrorExp();\n+        }\n+        ex = ex->ctfeInterpret();\n+\n+        StringExp *se = semanticString(sc, ex, \"__traits(toType, string)\");\n+        if (!se)\n+        {\n+            return new ErrorExp();\n+        }\n+        Type *t = decoToType(se->toUTF8(sc)->toPtr());\n+        if (!t)\n+        {\n+            e->error(\"cannot determine `%s`\", e->toChars());\n+            return new ErrorExp();\n+        }\n+        ex = new TypeExp(e->loc, t);\n+        ex = expressionSemantic(ex, sc);\n+        return ex;\n+    }\n     else if (e->ident == Id::hasMember ||\n              e->ident == Id::getMember ||\n              e->ident == Id::getOverloads ||\n@@ -1674,33 +1703,67 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n             RootObject *o = (*e->args)[i];\n             Type *t = isType(o);\n-            Expression *ex = t ? typeToExpression(t) : isExpression(o);\n-            if (!ex && t)\n+            while (t)\n             {\n-                Dsymbol *s;\n-                t->resolve(e->loc, sc2, &ex, &t, &s);\n-                if (t)\n+                if (TypeMixin *tm = t->isTypeMixin())\n                 {\n-                    typeSemantic(t, e->loc, sc2);\n-                    if (t->ty == Terror)\n+                    /* The mixin string could be a type or an expression.\n+                     * Have to try compiling it to see.\n+                     */\n+                    OutBuffer buf;\n+                    if (expressionsToString(buf, sc, tm->exps))\n+                    {\n+                        err = true;\n+                        break;\n+                    }\n+                    const size_t len = buf.length();\n+                    const char *str = buf.extractChars();\n+                    Parser p(e->loc, sc->_module, (const utf8_t *)str, len, false);\n+                    p.nextToken();\n+                    //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n+\n+                    o = p.parseTypeOrAssignExp(TOKeof);\n+                    if (p.errors || p.token.value != TOKeof)\n+                    {\n                         err = true;\n+                        break;\n+                    }\n+                    t = isType(o);\n                 }\n-                else if (s && s->errors)\n-                    err = true;\n+                else\n+                    break;\n             }\n-            if (ex)\n+\n+            if (!err)\n             {\n-                ex = expressionSemantic(ex, sc2);\n-                ex = resolvePropertiesOnly(sc2, ex);\n-                ex = ex->optimize(WANTvalue);\n-                if (sc2->func && sc2->func->type->ty == Tfunction)\n+                Expression *ex = t ? typeToExpression(t) : isExpression(o);\n+                if (!ex && t)\n                 {\n-                    TypeFunction *tf = (TypeFunction *)sc2->func->type;\n-                    canThrow(ex, sc2->func, tf->isnothrow);\n+                    Dsymbol *s;\n+                    t->resolve(e->loc, sc2, &ex, &t, &s);\n+                    if (t)\n+                    {\n+                        typeSemantic(t, e->loc, sc2);\n+                        if (t->ty == Terror)\n+                            err = true;\n+                    }\n+                    else if (s && s->errors)\n+                        err = true;\n+                }\n+                if (ex)\n+                {\n+                    ex = expressionSemantic(ex, sc2);\n+                    ex = resolvePropertiesOnly(sc2, ex);\n+                    ex = ex->optimize(WANTvalue);\n+                    if (sc2->func && sc2->func->type->ty == Tfunction)\n+                    {\n+                        TypeFunction *tf = (TypeFunction *)sc2->func->type;\n+                        canThrow(ex, sc2->func, tf->isnothrow);\n+                    }\n+                    ex = checkGC(sc2, ex);\n+                    if (ex->op == TOKerror)\n+                        err = true;\n                 }\n-                ex = checkGC(sc2, ex);\n-                if (ex->op == TOKerror)\n-                    err = true;\n             }\n \n             // Carefully detach the scope from the parent and throw it away as"}, {"sha": "670144d1282f4a5fa7be6aec6ddc507d1c0d8f6e", "filename": "gcc/d/dmd/typesem.c", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftypesem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Ftypesem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.c?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -18,13 +18,15 @@\n #include \"hdrgen.h\"\n #include \"id.h\"\n #include \"init.h\"\n+#include \"parse.h\"\n #include \"scope.h\"\n #include \"target.h\"\n #include \"template.h\"\n #include \"visitor.h\"\n \n Expression *typeToExpression(Type *t);\n Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i = 0);\n+bool expressionsToString(OutBuffer &buf, Scope *sc, Expressions *exps);\n char *MODtoChars(MOD mod);\n \n class TypeToExpressionVisitor : public Visitor\n@@ -76,6 +78,11 @@ class TypeToExpressionVisitor : public Visitor\n     {\n         result = typeToExpressionHelper(t, new ScopeExp(t->loc, t->tempinst));\n     }\n+\n+    void visit(TypeMixin *t)\n+    {\n+        result = new TypeExp(t->loc, t);\n+    }\n };\n \n /* We've mistakenly parsed this as a type.\n@@ -84,6 +91,8 @@ class TypeToExpressionVisitor : public Visitor\n  */\n Expression *typeToExpression(Type *t)\n {\n+    if (t->mod)\n+        return NULL;\n     TypeToExpressionVisitor v = TypeToExpressionVisitor(t);\n     t->accept(&v);\n     return v.result;\n@@ -177,6 +186,48 @@ static Expression *semanticLength(Scope *sc, TupleDeclaration *s, Expression *ex\n     return exp;\n }\n \n+/******************************************\n+ * Compile the MixinType, returning the type or expression AST.\n+ *\n+ * Doesn't run semantic() on the returned object.\n+ * Params:\n+ *      tm = mixin to compile as a type or expression\n+ *      loc = location for error messages\n+ *      sc = context\n+ * Return:\n+ *      null if error, else RootObject AST as parsed\n+ */\n+RootObject *compileTypeMixin(TypeMixin *tm, Loc loc, Scope *sc)\n+{\n+    OutBuffer buf;\n+    if (expressionsToString(buf, sc, tm->exps))\n+        return NULL;\n+\n+    const unsigned errors = global.errors;\n+    const size_t len = buf.length();\n+    const char *str = buf.extractChars();\n+    Parser p(loc, sc->_module, (const utf8_t *)str, len, false);\n+    p.nextToken();\n+    //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n+\n+    RootObject *o = p.parseTypeOrAssignExp(TOKeof);\n+    if (errors != global.errors)\n+    {\n+        assert(global.errors != errors); // should have caught all these cases\n+        return NULL;\n+    }\n+    if (p.token.value != TOKeof)\n+    {\n+        ::error(loc, \"incomplete mixin type `%s`\", str);\n+        return NULL;\n+    }\n+\n+    Type *t = isType(o);\n+    Expression *e = t ? typeToExpression(t) : isExpression(o);\n+\n+    return (!e && t) ? (RootObject *)t : (RootObject *)e;\n+}\n+\n /******************************************\n  * Perform semantic analysis on a type.\n  * Params:\n@@ -440,7 +491,7 @@ Type *typeSemantic(Type *type, const Loc &loc, Scope *sc)\n             // Deal with the case where we thought the index was a type, but\n             // in reality it was an expression.\n             if (mtype->index->ty == Tident || mtype->index->ty == Tinstance || mtype->index->ty == Tsarray ||\n-                mtype->index->ty == Ttypeof || mtype->index->ty == Treturn)\n+                mtype->index->ty == Ttypeof || mtype->index->ty == Treturn || mtype->index->ty == Tmixin)\n             {\n                 Expression *e;\n                 Type *t;\n@@ -1072,6 +1123,7 @@ Type *typeSemantic(Type *type, const Loc &loc, Scope *sc)\n                 mtype->exp->ident != Id::getMember &&\n                 mtype->exp->ident != Id::parent &&\n                 mtype->exp->ident != Id::child &&\n+                mtype->exp->ident != Id::toType &&\n                 mtype->exp->ident != Id::getOverloads &&\n                 mtype->exp->ident != Id::getVirtualFunctions &&\n                 mtype->exp->ident != Id::getVirtualMethods &&\n@@ -1275,7 +1327,7 @@ Type *typeSemantic(Type *type, const Loc &loc, Scope *sc)\n \n         void visit(TypeStruct *mtype)\n         {\n-            //printf(\"TypeStruct::semantic('%s')\\n\", mtype->sym->toChars());\n+            //printf(\"TypeStruct::semantic('%s')\\n\", mtype->toChars());\n             if (mtype->deco)\n             {\n                 if (sc && sc->cppmangle != CPPMANGLEdefault)\n@@ -1304,7 +1356,7 @@ Type *typeSemantic(Type *type, const Loc &loc, Scope *sc)\n \n         void visit(TypeClass *mtype)\n         {\n-            //printf(\"TypeClass::semantic(%s)\\n\", mtype->sym->toChars());\n+            //printf(\"TypeClass::semantic(%s)\\n\", mtype->toChars());\n             if (mtype->deco)\n             {\n                 if (sc && sc->cppmangle != CPPMANGLEdefault)\n@@ -1386,6 +1438,25 @@ Type *typeSemantic(Type *type, const Loc &loc, Scope *sc)\n             Type *t = new TypeTuple(args);\n             result = typeSemantic(t, loc, sc);\n         }\n+\n+        void visit(TypeMixin *mtype)\n+        {\n+            //printf(\"TypeMixin::semantic() %s\\n\", mtype->toChars());\n+\n+            Expression *e = NULL;\n+            Type *t = NULL;\n+            Dsymbol *s = NULL;\n+            mtype->resolve(loc, sc, &e, &t, &s);\n+\n+            if (t && t->ty != Terror)\n+            {\n+                result = t;\n+                return;\n+            }\n+\n+            ::error(mtype->loc, \"`mixin(%s)` does not give a valid type\", mtype->obj->toChars());\n+            return error();\n+        }\n     };\n     TypeSemanticVisitor v(loc, sc);\n     type->accept(&v);"}, {"sha": "09ba2024e3019cae50b61b90490ddb1f8e734ad9", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -81,7 +81,9 @@ class TypeClass;\n class TypeTuple;\n class TypeSlice;\n class TypeNull;\n+class TypeNoreturn;\n class TypeTraits;\n+class TypeMixin;\n \n class Dsymbol;\n \n@@ -374,7 +376,9 @@ class Visitor\n     virtual void visit(TypeTuple *t) { visit((Type *)t); }\n     virtual void visit(TypeSlice *t) { visit((TypeNext *)t); }\n     virtual void visit(TypeNull *t) { visit((Type *)t); }\n+    virtual void visit(TypeNoreturn *t) { visit((Type *)t); }\n     virtual void visit(TypeTraits *t) { visit((Type *)t); }\n+    virtual void visit(TypeMixin *t) { visit((Type *)t); }\n \n     virtual void visit(Dsymbol *) { assert(0); }\n "}, {"sha": "41d07a7b70e52798c6ee8b34e47e1019f29a44ae", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1068,6 +1068,13 @@ class IRVisitor : public Visitor\n \n \tadd_stmt (return_expr (decl));\n       }\n+    else if (tf->next->ty == Tnoreturn)\n+      {\n+\t/* Returning an expression that has no value, but has a side effect\n+\t   that should never return.  */\n+\tadd_stmt (build_expr_dtor (s->exp));\n+\tadd_stmt (return_expr (NULL_TREE));\n+      }\n     else\n       {\n \t/* Convert for initializing the DECL_RESULT.  */"}, {"sha": "924d829821198b6a7ac3e03863b165dc12b5e73e", "filename": "gcc/d/types.cc", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -603,6 +603,12 @@ class TypeVisitor : public Visitor\n     t->ctype = ptr_type_node;\n   }\n \n+  /* Bottom type used for functions that never return.  */\n+\n+  void visit (TypeNoreturn *t)\n+  {\n+    t->ctype = void_type_node;\n+  }\n \n   /* Basic Data Types.  */\n \n@@ -852,7 +858,46 @@ class TypeVisitor : public Visitor\n     tree basetype = (t->sym->memtype)\n       ? build_ctype (t->sym->memtype) : void_type_node;\n \n-    if (!INTEGRAL_TYPE_P (basetype) || TREE_CODE (basetype) == BOOLEAN_TYPE)\n+    if (t->sym->isSpecial ())\n+      {\n+\t/* Special enums are opaque types that bind to C types.  */\n+\tconst char *ident = t->toChars ();\n+\tType *underlying = NULL;\n+\n+\t/* Skip over the prefixing `__c_'.  */\n+\tgcc_assert (strncmp (ident, \"__c_\", strlen (\"__c_\")) == 0);\n+\tident = ident + strlen (\"__c_\");\n+\n+\t/* To keep things compatible within the code generation we stick to\n+\t   mapping to equivalent D types.  However it should be OK to use the\n+\t   GCC provided C types here as the front-end enforces that everything\n+\t   must be explicitly cast from a D type to any of the opaque types.  */\n+\tif (strcmp (ident, \"long\") == 0)\n+\t  underlying = build_frontend_type (long_integer_type_node);\n+\telse if (strcmp (ident, \"ulong\") == 0)\n+\t  underlying = build_frontend_type (long_unsigned_type_node);\n+\telse if (strcmp (ident, \"wchar_t\") == 0)\n+\t  underlying = target.c.twchar_t;\n+\telse if (strcmp (ident, \"longlong\") == 0)\n+\t  underlying = build_frontend_type (long_long_integer_type_node);\n+\telse if (strcmp (ident, \"ulonglong\") == 0)\n+\t  underlying = build_frontend_type (long_long_unsigned_type_node);\n+\telse if (strcmp (ident, \"long_double\") == 0)\n+\t  underlying = build_frontend_type (long_double_type_node);\n+\telse if (strcmp (ident, \"complex_real\") == 0)\n+\t  underlying = build_frontend_type (complex_long_double_type_node);\n+\telse if (strcmp (ident, \"complex_float\") == 0)\n+\t  underlying = build_frontend_type (complex_float_type_node);\n+\telse if (strcmp (ident, \"complex_double\") == 0)\n+\t  underlying = build_frontend_type (complex_double_type_node);\n+\n+\t/* Conversion failed or there's an unhandled special type.  */\n+\tgcc_assert (underlying != NULL);\n+\n+\tt->ctype = build_variant_type_copy (build_ctype (underlying));\n+\tbuild_type_decl (t->ctype, t->sym);\n+      }\n+    else if (!INTEGRAL_TYPE_P (basetype) || TREE_CODE (basetype) == BOOLEAN_TYPE)\n       {\n \t/* Enums in D2 can have a base type that is not necessarily integral.\n \t   For these, we simplify this a little by using the base type directly"}, {"sha": "00d00c840c4f81755ecc8676a52d129cd8aa5346", "filename": "gcc/testsuite/gdc.test/compilable/bug20796.d", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fbug20796.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fbug20796.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fbug20796.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,2 @@\n+// EXTRA_SOURCES: protection/issue20796/package.d\n+// https://issues.dlang.org/show_bug.cgi?id=20796"}, {"sha": "954a9bee72e16353d800f44834d92cb918e52aa5", "filename": "gcc/testsuite/gdc.test/compilable/cppmangle.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -372,3 +372,21 @@ version (Posix)\n     static assert(T.boo.mangleof == \"_ZN1T3booE\");\n }\n \n+/*****************************************/\n+\n+alias noreturn = typeof(*null);\n+\n+extern (C++)\n+{\n+    alias fpcpp = noreturn function();\n+    int funccpp(fpcpp);\n+\n+    version (Posix)\n+        static assert(funccpp.mangleof == \"_Z7funccppPFvvE\");\n+\n+    version (Win32)\n+        static assert(funccpp.mangleof == \"?funccpp@@YAHP6AXXZ@Z\");\n+\n+    version (Win64)\n+        static assert(funccpp.mangleof == \"?funccpp@@YAHP6AXXZ@Z\");\n+}"}, {"sha": "8c691b6ffd9f2ddc08f4b5f2a5b33157d3f280bb", "filename": "gcc/testsuite/gdc.test/compilable/ddocunittest.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddocunittest.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddocunittest.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddocunittest.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -357,6 +357,7 @@ auto redBlackTree(bool allowDuplicates, E)(E[] elems...)\n }\n /// ditto\n auto redBlackTree(alias less, E)(E[] elems...)\n+if (__traits(compiles, (E a, E b) => mixin(less)))\n {\n     return 3;\n }"}, {"sha": "62de518aa99f4c3645911c010412d3f8ad627acc", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/serenity7190/core/Controller.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fserenity7190%2Fcore%2FController.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fserenity7190%2Fcore%2FController.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fserenity7190%2Fcore%2FController.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -3,6 +3,12 @@ class Controller {\n         enum _s_pkg = __traits(parent, __traits(parent, __traits(parent, T))).stringof[\"package \".length .. $];\n \n         enum _s_model = T.stringof[0 .. $-`Controller`.length] ~ `Model`;\n+\n+        import serenity7190.core.Model;\n+        // expands to \"import example7190.models.HomeModel;\"\n+        mixin(q{import } ~ _s_pkg ~ q{.models.} ~ _s_model ~ q{;});\n+\n+        // \"enum _ = is(example7190.models.HomeModel.HomeModel : serenity7190.core.Model.Model);\"\n         mixin(q{enum _ = is(} ~ _s_pkg ~ q{.models.} ~ _s_model ~ q{.} ~ _s_model ~ q{ : serenity7190.core.Model.Model);});\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "edb409540c7600985262b2abd7c85d2a40310b91", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/test20280a.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest20280a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest20280a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Ftest20280a.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,12 @@\n+module test20280a;\n+\n+struct Alpha(uint _)\n+{\n+    import test20280a;\n+}\n+\n+struct Foxtrot(uint _)\n+{\n+    alias Attributes = Alpha!10;\n+    enum A = 10;\n+}"}, {"sha": "a83fb899708ffbbaed64bfc40e64931bff2f3687", "filename": "gcc/testsuite/gdc.test/compilable/fix21585.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21585.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21585.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21585.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,24 @@\n+/* TEST_OUTPUT:\n+---\n+i int\n+d double\n+Pi int*\n+---\n+*/\n+\n+pragma(msg, 1.mangleof, \" \", __traits(toType, 1.mangleof));\n+pragma(msg, (1.0).mangleof, \" \", __traits(toType, (1.0).mangleof));\n+pragma(msg, (int*).mangleof, \" \", __traits(toType, (int*).mangleof));\n+\n+template Type(T) { alias Type = T; }\n+\n+Type!(__traits(toType, 1.mangleof)) j = 3;\n+\n+alias T = Type!(__traits(toType, 1.mangleof));\n+static assert(is(T == int));\n+\n+__traits(toType, \"i\") x = 7;\n+\n+static assert(is(Type!(__traits(toType, 1.mangleof)) == int));\n+static assert(is(Type!(__traits(toType, (1.0).mangleof)) == double));\n+static assert(is(Type!(__traits(toType, (int*).mangleof)) == int*));"}, {"sha": "c129fa013a14794cf74cad0de205a4326d29d33c", "filename": "gcc/testsuite/gdc.test/compilable/fix21647.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21647.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21647.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21647.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,30 @@\n+/*\n+REQUIRED_ARGS:\n+TEST_OUTPUT:\n+---\n+cast(void)0\n+cast(void)0\n+void\n+cast(void)0\n+cast(void)0\n+cast(void)0\n+void\n+---\n+*/\n+\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21647\n+\n+void foo() { return cast(void)1; }\n+\n+void main(){}\n+\n+alias V = void;\n+\n+void test1() { pragma(msg, foo()); }\n+void test2() { pragma(msg, main()); }\n+void test3() { pragma(msg, V); }\n+\n+pragma(msg, foo());\n+pragma(msg, main());\n+pragma(msg, V);"}, {"sha": "58a7c3be5f5f2eede64965d0758ae7b15633793e", "filename": "gcc/testsuite/gdc.test/compilable/ice10598.d", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0f6902666430e5d065a92b3d5292cba91813d3/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice10598.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0f6902666430e5d065a92b3d5292cba91813d3/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice10598.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice10598.d?ref=ba0f6902666430e5d065a92b3d5292cba91813d3", "patch": "@@ -1,3 +0,0 @@\n-// EXTRA_SOURCES: imports/ice10598a.d imports/ice10598b.d\n-\n-void main() {}"}, {"sha": "ee3c9eb2965142008cba91e4de0f868c39832dd7", "filename": "gcc/testsuite/gdc.test/compilable/imports/issue21614a.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fissue21614a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fissue21614a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fissue21614a.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,22 @@\n+module imports.issue21614a;\n+\n+struct FormatSpec(Char)\n+{\n+    import imports.issue21614a;\n+}\n+\n+template Tuple(Specs...)\n+{\n+    struct Tuple\n+    {\n+        alias spec = FormatSpec!char();\n+        this(Specs)\n+        {\n+        }\n+    }\n+}\n+\n+auto findRoot(T)(T)\n+{\n+    return Tuple!(T)();\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/pkg20537/package.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkg20537%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkg20537%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkg20537%2Fpackage.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/test17991a/a.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest17991a%2Fa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest17991a%2Fa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest17991a%2Fa.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/test17991a/package.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest17991a%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest17991a%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest17991a%2Fpackage.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/test20151a/b/c/c.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest20151a%2Fb%2Fc%2Fc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest20151a%2Fb%2Fc%2Fc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest20151a%2Fb%2Fc%2Fc.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/test20530a.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest20530a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest20530a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest20530a.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc"}, {"sha": "c1f8fab982f3601dd6d6790f7c7a3ba2b283565d", "filename": "gcc/testsuite/gdc.test/compilable/imports/test21501b.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest21501b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest21501b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest21501b.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,7 @@\n+module imports.test21501b;\n+import test21501a;\n+\n+struct B\n+{\n+    A data;\n+}"}, {"sha": "cc1f95f3fc963ca086ef72a91b9e02a73a1ff7b6", "filename": "gcc/testsuite/gdc.test/compilable/imports/test21501c.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest21501c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest21501c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest21501c.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,4 @@\n+module imports.test21501c;\n+\n+alias C = int;\n+const D = 1;"}, {"sha": "cfd078cdcd1189fd6e47310159489a4b88a5b3ea", "filename": "gcc/testsuite/gdc.test/compilable/issue16020.d", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue16020.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue16020.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue16020.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,39 @@\n+module issue16020;\n+\n+alias F1 = const(int)(); const(int) f1(){return 42;}\n+static assert (is(F1 == typeof(f1)));\n+\n+alias F2 = float(float); float f2(float p){return p;}\n+static assert (is(F2 == typeof(f2)));\n+\n+alias F3 = void(); void f3(){}\n+static assert (is(F3 == typeof(f3)));\n+\n+alias void F41() @safe;\n+alias F42 = void() @safe;\n+alias F43 = @safe void();\n+static assert (is(F41 == F42));\n+static assert (is(F43 == F42));\n+\n+alias void F51() @system;\n+alias F52 = void() @safe;\n+static assert (!is(F51 == F52));\n+\n+alias F61 = int() const shared;\n+alias int F62() const shared ;\n+alias F63 = const shared int();\n+static assert (is(F61 == F62));\n+static assert (is(F63 == F62));\n+\n+alias F71 = int() immutable inout;\n+alias int F72() immutable inout;\n+alias F73 = immutable inout int();\n+static assert (is(F71 == F72));\n+static assert (is(F73 == F72));\n+\n+alias FunTemplate(T) = void(T t);\n+alias Specialized = FunTemplate!int;\n+alias Compared = void(int);\n+static assert(is(Specialized == Compared));\n+\n+void main() {}"}, {"sha": "1843fe6ec36cc592712ca78d42a4fe66698a7904", "filename": "gcc/testsuite/gdc.test/compilable/issue21614.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21614.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21614.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21614.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,10 @@\n+// EXTRA_FILES: imports/issue21614a.d\n+// REQUIRED_ARGS: -i\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21614\n+\n+void logmdigammaInverse(real y)\n+{\n+    import imports.issue21614a;\n+    findRoot(y);\n+}"}, {"sha": "c8a86752a56c0525d9cc9f7edb883e8f6eb92d68", "filename": "gcc/testsuite/gdc.test/compilable/issue21726.d", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21726.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21726.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21726.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,2 @@\n+// EXTRA_SOURCES: protection/issue21726/typecons.d\n+// https://issues.dlang.org/show_bug.cgi?id=21726"}, {"sha": "abbf85a9528539d54135e061fab1ef8a4a26192b", "filename": "gcc/testsuite/gdc.test/compilable/mixintype.d", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,55 @@\n+\n+alias Int = mixin(\"int\");\n+alias Lint = mixin(\"Int\");\n+\n+int test1(mixin(\"int\")* p)\n+{\n+    mixin(\"int\")[] a;\n+    mixin(\"int[]\") b;\n+    mixin(\"int[] c;\");\n+    mixin(\"*p = c[0];\");\n+    *p = mixin(\"c[0]\");\n+    return *p + a[0] + b[0] + c[0];\n+}\n+\n+/******************************************/\n+\n+void test2()\n+{\n+    auto a = __traits(allMembers, mixin(__MODULE__));\n+}\n+\n+/*****************************************/\n+\n+void test3()\n+{\n+    char val;\n+    int mod;\n+    enum b = __traits(compiles, mixin(\"*cast(int*)&val + mod\"));\n+    static assert(b == true);\n+}\n+\n+/********************************************/\n+\n+\n+struct S\n+{\n+    int fielda;\n+    int fieldb;\n+}\n+\n+template Foo4(alias T)\n+{\n+    enum Foo4 = true;\n+}\n+\n+void test4()\n+{\n+    S sa;\n+    auto a = Foo4!( __traits(getMember,sa,\"fielda\") );\n+\n+    S sb;\n+    enum getStuff = q{ __traits(getMember,sb,\"fieldb\") };\n+    auto b = Foo4!(mixin(getStuff));\n+}\n+"}, {"sha": "43803df12cf8b9da5cc1d4787860693cabccae1f", "filename": "gcc/testsuite/gdc.test/compilable/mixintype2.d", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,68 @@\n+\n+alias fun = mixin(\"(){}\");\n+\n+void test1()\n+{\n+    int x = 1;\n+    static immutable c = 2;\n+\n+    fun();\n+    foo!(mixin(\"int\"))();\n+    foo!(mixin(\"long*\"))();\n+    foo!(mixin(\"ST!(int, S.T)\"))();\n+    foo!(mixin(ST!(int, S.T)))();\n+\n+    int[mixin(\"string\")] a1;\n+    int[mixin(\"5\")] a2;\n+    int[mixin(\"c\")] a3;\n+    int[] v1 = new int[mixin(\"3\")];\n+    auto v2 = new int[mixin(\"x\")];\n+\n+    mixin(q{__traits(getMember, S, \"T\")}) ftv;\n+\n+    alias T = int*;\n+    static assert(__traits(compiles, mixin(\"int\")));\n+    static assert(__traits(compiles, mixin(q{int[mixin(\"string\")]})));\n+    static assert(__traits(compiles, mixin(q{int[mixin(\"2\")]})));\n+    static assert(__traits(compiles, mixin(T)));\n+    static assert(__traits(compiles, mixin(\"int*\")));\n+    static assert(__traits(compiles, mixin(typeof(0))));\n+}\n+\n+struct S { alias T = float*; }\n+\n+struct ST(X,Y) {}\n+\n+void foo(alias t)() {}\n+\n+/**************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=21074\n+\n+alias Byte = ubyte;\n+alias Byte2(A) = ubyte;\n+alias T0 = mixin(q{const(Byte)})*;\n+alias T1 = mixin(q{const(Byte[1])})*;\n+alias T2 = mixin(q{const(Byte2!int)})*;\n+alias T3 = mixin(q{const(mixin(Byte2!int))})*;\n+alias T4 = mixin(q{const(mixin(\"__traits(getMember, S, \\\"T\\\")\"))})*;\n+alias T5 = const(mixin(q{Byte}))*;\n+alias T6 = const(mixin(q{immutable(Byte)}))*;\n+alias T7 = const(mixin(q{shared(Byte)}))*;\n+alias T8 = const(mixin(q{Byte*}));\n+\n+// the following tests now work\n+static assert(is(T0 == const(ubyte)*));\n+static assert(is(T1 == const(ubyte[1])*));\n+static assert(is(T2 == const(ubyte)*));\n+static assert(is(T3 == const(ubyte)*));\n+static assert(is(T4 == const(float*)*));\n+static assert(is(T5 == const(ubyte)*));\n+static assert(is(T6 == immutable(ubyte)*));\n+static assert(is(T7 == const(shared(ubyte))*));\n+static assert(is(T8 == const(ubyte*)));\n+\n+// this doesn't work but I'll file a new issue\n+/*\n+alias T8 = mixin(q{immutable(__traits(getMember, S, \"T\"))})*;\n+static assert(is(T8 == immutable(float*)*));\n+*/"}, {"sha": "e21adc476c940255dd4f05085de022cea56b4f19", "filename": "gcc/testsuite/gdc.test/compilable/noreturn1.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,21 @@\n+/*\n+TEST_OUTPUT:\n+---\n+noreturn\n+---\n+*/\n+\n+alias noreturn = typeof(*null);\n+pragma(msg, noreturn);\n+\n+noreturn exits(int* p) { *p = 3; }\n+\n+noreturn exit();\n+\n+int test1(int i)\n+{\n+    if (exit())\n+        return i + 1;\n+    return i - 1;\n+}\n+"}, {"sha": "d0b5f5a786052890e98c96d62cdb9cc5c2688485", "filename": "gcc/testsuite/gdc.test/compilable/protection/issue20796/package.d", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue20796%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue20796%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue20796%2Fpackage.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,5 @@\n+module issue20796;\n+\n+package(issue20796) void foo()\n+{\n+}"}, {"sha": "e0f6ba7d263d0714175445e412157d8f6c490aa1", "filename": "gcc/testsuite/gdc.test/compilable/protection/issue21726/format/package.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Fformat%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Fformat%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Fformat%2Fpackage.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,7 @@\n+module protection.issue21726.format;\n+\n+package(protection.issue21726.format):\n+\n+package(protection.issue21726) int issuePkgSym;\n+package(protection) int protectionPkgSym();\n+int formatPkgSym;"}, {"sha": "f8986c949bd8141e0905ae8122458a3275fc1959", "filename": "gcc/testsuite/gdc.test/compilable/protection/issue21726/package.d", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Fpackage.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1 @@\n+module protection.issue21726;"}, {"sha": "faed95e5f5e03faf08d055fdf272255a4d26e4b2", "filename": "gcc/testsuite/gdc.test/compilable/protection/issue21726/typecons.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fprotection%2Fissue21726%2Ftypecons.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,6 @@\n+module protection.issue21726.typecons;\n+\n+import protection.issue21726.format : issuePkgSym;\n+import protection.issue21726.format : protectionPkgSym;\n+static assert(!__traits(compiles,\n+                        { import protection.issue21726.format : formatPkgSym; }));"}, {"sha": "f7b4c2e96a8c9ccf778640ab485b968fb70a4b9b", "filename": "gcc/testsuite/gdc.test/compilable/test16002.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16002.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16002.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16002.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -22,3 +22,6 @@ static assert(is(b == module));\n // This is supposed to work even though we haven't directly imported imports.pkgmodule.\n static assert(is(imports.pkgmodule == module));\n static assert(!is(MyStruct == module));\n+\n+static assert(!is(imports.nonexistent == package));\n+static assert(!is(imports.nonexistent == module));"}, {"sha": "8bc9fa94f5fc14452691e7145b3ff19f96289eed", "filename": "gcc/testsuite/gdc.test/compilable/test17991.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17991.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17991.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17991.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,3 @@\n+// https://issues.dlang.org/show_bug.cgi?id=17991\n+// EXTRA_FILES: imports/test17991a/package.d imports/test17991a/a.d\n+import imports.test17991a, imports.test17991a.a;"}, {"sha": "8122851c6ca1927c648a6aaa5934085fb5f40556", "filename": "gcc/testsuite/gdc.test/compilable/test19292.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19292.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19292.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19292.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,15 @@\n+// https://issues.dlang.org/show_bug.cgi?id=19292\n+\n+mixin(\"enum a = \", 87, \";\");\n+static assert(a == 87);\n+\n+int test()\n+{\n+    mixin(\"enum x = \", 7, \";\");\n+    return mixin(\"1\", x, 2U);\n+}\n+\n+void testit()\n+{\n+    static assert(test() == 172);\n+}"}, {"sha": "d9ae28fabe1a7cf454296139cb11bb0392658df6", "filename": "gcc/testsuite/gdc.test/compilable/test20151a.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20151a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20151a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20151a.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,3 @@\n+// EXTRA_FILES: imports/test20151a/b/c/c.d\n+module imports.test20151a;\n+import imports.test20151a.b.c.c;"}, {"sha": "76a10823e49729638756d38e8f44e4f4457a2016", "filename": "gcc/testsuite/gdc.test/compilable/test20280.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20280.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20280.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20280.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,8 @@\n+// PERMUTE_ARGS:\n+// REQUIRED_ARGS: -Icompilable/extra-files\n+// EXTRA_FILES: extra-files/test20280a.d\n+module test20280;\n+\n+import test20280a;\n+\n+alias Charlie = Foxtrot!(0);"}, {"sha": "be80dbb34d124e9aa48f4544c91d7375ab7ddd06", "filename": "gcc/testsuite/gdc.test/compilable/test20530.d", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20530.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20530.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20530.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,46 @@\n+// EXTRA_FILES: imports/test20530a.d imports/plainpackage/plainmodule.d imports/pkgmodule/package.d imports/pkgmodule/plainmodule.d\n+module mod;\n+static assert(is(mod == module));\n+static assert(is(mixin(\"mod\") == module));\n+static assert(!is(mod == package));\n+static assert(!is(mixin(\"mod\") == package));\n+\n+import imports.test20530a;\n+static assert(is(imports == package));\n+static assert(is(mixin(\"imports\") == package));\n+static assert(!is(imports == module));\n+static assert(!is(mixin(\"imports\") == module));\n+\n+import imports.plainpackage.plainmodule;\n+import imports.pkgmodule.plainmodule;\n+\n+struct MyStruct;\n+\n+alias a = mixin(\"imports.plainpackage\");\n+alias b = mixin(\"imports.pkgmodule.plainmodule\");\n+\n+static assert(is(mixin(\"imports.plainpackage\") == package));\n+static assert(is(mixin(\"a\") == package));\n+static assert(!is(mixin(\"imports.plainpackage.plainmodule\") == package));\n+static assert(!is(mixin(\"b\") == package));\n+static assert(is(mixin(\"imports.pkgmodule\") == package));\n+mixin(\"static assert(is(imports.pkgmodule == package));\");\n+\n+static assert(!is(mixin(\"MyStruct\") == package));\n+\n+static assert(!is(mixin(\"imports.plainpackage\") == module));\n+static assert(!is(mixin(\"a\") == module));\n+static assert(is(mixin(\"imports.plainpackage.plainmodule\") == module));\n+static assert(is(mixin(\"b\") == module));\n+static assert(is(mixin(\"imports.pkgmodule\") == module));\n+mixin(\"static assert(is(imports.pkgmodule == module));\");\n+\n+static assert(!is(mixin(\"MyStruct\") == module));\n+\n+static assert(!is(mixin(\"imports.nonexistent\") == package));\n+static assert(!is(mixin(\"imports.nonexistent\") == module));\n+\n+// this won't work due to mixin argument .stringof expansion,\n+// it will expand to mixin(package imports.pkgmodule). Issue 20519.\n+//static assert(is(mixin(imports.pkgmodule) == package));\n+//static assert(is(mixin(imports.pkgmodule) == module));"}, {"sha": "f2d05d26fee8eb14d6e0cdb5b681f662dd91d2a9", "filename": "gcc/testsuite/gdc.test/compilable/test20537.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20537.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20537.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20537.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,10 @@\n+// REQUIRED_ARGS: -Icompilable/imports\n+// EXTRA_FILES: imports/pkg20537/package.d\n+import pkg20537;\n+\n+static assert(is(pkg20537 == module));\n+static assert(__traits(isModule, pkg20537));\n+static assert(is(mixin(\"pkg20537\") == module));\n+static assert(is(pkg20537 == package));\n+static assert(__traits(isPackage, pkg20537));\n+static assert(is(mixin(\"pkg20537\") == package));"}, {"sha": "2d67211c74d4ad927bcd6dfb35370d84cd2513fe", "filename": "gcc/testsuite/gdc.test/compilable/test20692.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20692.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20692.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20692.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,18 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20692\n+\n+struct S() {\n+    void fun() {\n+        gun(\"\");\n+    }\n+    void gun(T)(T) {\n+        alias buggy = bug;\n+    }\n+}\n+\n+alias X = S!();\n+\n+void main() {\n+    X().gun(0);\n+}\n+\n+alias bug =  __traits(getMember, X, \"fun\");"}, {"sha": "096fd51b6534e2c3f07d31e5878437a3f8ba56ca", "filename": "gcc/testsuite/gdc.test/compilable/test21501a.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21501a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21501a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21501a.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,19 @@\n+// EXTRA_SOURCES: imports/test21501b.d imports/test21501c.d\n+// https://issues.dlang.org/show_bug.cgi?id=21501\n+\n+module test21501a;\n+import imports.test21501b;\n+import imports.test21501c;\n+\n+alias Identity(alias T) = T;\n+\n+struct A\n+{\n+    alias     a = imports.test21501c.C;\n+    const int b = imports.test21501c.D; // fixed\n+    alias     c = Identity!(mixin(q{imports.test21501c.C})); // fixed\n+    const int d = Identity!(mixin(q{imports.test21501c.D})); // fixed\n+\n+    static assert(is(a == c) && is(a == int));\n+    static assert(b == d && b == 1);\n+}"}, {"sha": "bbbd98a729ceb95d0d443af36a963aeb5441d9bf", "filename": "gcc/testsuite/gdc.test/compilable/test9029.d", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9029.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9029.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9029.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,39 @@\n+// https://issues.dlang.org/show_bug.cgi?id=9029\n+enum NameOf(alias S) = S.stringof;\n+\n+static assert(NameOf!int == \"int\");\n+\n+enum BothMatch(alias S) = \"alias\";\n+enum BothMatch(T) = \"type\";\n+\n+void foo9029() { }\n+\n+struct Struct { }\n+\n+static assert(BothMatch!int == \"type\");\n+static assert(BothMatch!(void function()) == \"type\");\n+static assert(BothMatch!BothMatch == \"alias\");\n+static assert(BothMatch!Struct == \"type\");\n+static assert(BothMatch!foo9029 == \"alias\");\n+static assert(BothMatch!5 == \"alias\");\n+\n+// https://issues.dlang.org/show_bug.cgi?id=19884\n+mixin template genCtEvaluate()\n+{\n+    void evaluate(alias op)() { }\n+}\n+struct S\n+{\n+    mixin genCtEvaluate!() mixinEval;\n+    alias evaluate = mixinEval.evaluate;\n+    void evaluate() { }\n+}\n+alias List(Ops...) = Ops;\n+void main()\n+{\n+    S g;\n+    foreach (op; List!(0))\n+    {\n+        g.evaluate!op();\n+    }\n+}"}, {"sha": "e8072fdbaf872426422abadaa715b5059803085c", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug15613.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug15613.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug15613.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug15613.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,18 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/bug15613.d(16): Error: function `bug15613.f(int...)` is not callable using argument types `(typeof(null))`\n+fail_compilation/bug15613.d(16):        cannot pass argument `null` of type `typeof(null)` to parameter `int...`\n+fail_compilation/bug15613.d(17): Error: function `bug15613.g(Object, ...)` is not callable using argument types `(int)`\n+fail_compilation/bug15613.d(17):        cannot pass argument `8` of type `int` to parameter `Object`\n+---\n+*/\n+\n+void f(int...);\n+void g(Object, ...);\n+\n+void main()\n+{\n+    f(null);\n+    g(8);\n+}"}, {"sha": "fdfbf73f41562e4b87fd244fabd0fa41e3e59b15", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug16165.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug16165.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug16165.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug16165.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,18 @@\n+void f(int x, Object y);\n+\n+void g()\n+{\n+       Object o;\n+       f(o, o, 404);\n+       f(5, 6, 404);\n+}\n+\n+/* \n+TEST_OUTPUT:\n+---\n+fail_compilation/bug16165.d(6): Error: function `bug16165.f(int x, Object y)` is not callable using argument types `(Object, Object, int)`\n+fail_compilation/bug16165.d(6):        cannot pass argument `o` of type `object.Object` to parameter `int x`\n+fail_compilation/bug16165.d(7): Error: function `bug16165.f(int x, Object y)` is not callable using argument types `(int, int, int)`\n+fail_compilation/bug16165.d(7):        cannot pass argument `6` of type `int` to parameter `Object y`\n+---\n+ */"}, {"sha": "852eaae7479904d6fb4ce4165fb921c66dcb624a", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug9631.d", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,100 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/bug9631.d(20): Error: cannot implicitly convert expression `F()` of type `bug9631.T1!().F` to `bug9631.T2!().F`\n+---\n+*/\n+\n+template T1()\n+{\n+    struct F { }\n+}\n+\n+template T2()\n+{\n+    struct F { }\n+}\n+\n+void main()\n+{\n+    T2!().F x = T1!().F();\n+}\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/bug9631.d(41): Error: incompatible types for ((x) == (y)): 'bug9631.S' and 'bug9631.tem!\n+).S'\n+---\n+*/\n+\n+struct S { char c; }\n+\n+template tem()\n+{\n+    struct S { int i; }\n+}\n+\n+void equal()\n+{\n+    S x;\n+    auto y = tem!().S();\n+    bool b = x == y;\n+}\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/bug9631.d(79): Error: function `bug9631.arg.f(int i, S s)` is not callable using argumen\n+ types `(int, S)`\n+fail_compilation/bug9631.d(79):        cannot pass argument `y` of type `bug9631.tem!().S` to parameter `\n+ug9631.S s`\n+fail_compilation/bug9631.d(80): Error: function literal `__lambda2(S s)` is not callable using argument t\n+pes `(S)`\n+fail_compilation/bug9631.d(80):        cannot pass argument `x` of type `bug9631.S` to parameter `bug9631\n+tem!().S s`\n+fail_compilation/bug9631.d(86): Error: constructor `bug9631.arg.A.this(S _param_0)` is not callable using\n+argument types `(S)`\n+fail_compilation/bug9631.d(86):        cannot pass argument `S(0)` of type `bug9631.tem!().S` to paramete\n+ `bug9631.S _param_0`\n+---\n+*/\n+void arg()\n+{\n+    S x;\n+    tem!().S y;\n+\n+    void f(int i, S s);\n+    f(4, y);\n+    (tem!().S s){}(x);\n+\n+    struct A\n+    {\n+        this(S){}\n+    }\n+    A(tem!().S());\n+}\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/bug9631.d(106): Error: function `bug9631.targ.ft!().ft(S _param_0)` is not callable using argument types `(S)`\n+fail_compilation/bug9631.d(106):        cannot pass argument `x` of type `bug9631.S` to parameter `bug9631.tem!().S _param_0`\n+fail_compilation/bug9631.d(107): Error: template `bug9631.targ.ft` cannot deduce function from argument types `!()(S)`, candidates are:\n+fail_compilation/bug9631.d(105):        `bug9631.targ.ft()(tem!().S)`\n+fail_compilation/bug9631.d(109): Error: template `bug9631.targ.ft2` cannot deduce function from argument types `!()(S, int)`, candidates are:\n+fail_compilation/bug9631.d(108):        `bug9631.targ.ft2(T)(S, T)`\n+---\n+*/\n+void targ()\n+{\n+    S x;\n+    tem!().S y;\n+\n+    void ft()(tem!().S){}\n+    ft!()(x);\n+    ft(x);\n+    void ft2(T)(S, T){}\n+    ft2(y, 1);\n+}\n+"}, {"sha": "7451b3f506bf9c73c634fa48f59599d904f96099", "filename": "gcc/testsuite/gdc.test/fail_compilation/chkformat.d", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fchkformat.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,139 @@\n+/*\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/chkformat.d(101): Deprecation: width argument `0L` for format specification `\"%*.*d\"` must be `int`, not `long`\n+fail_compilation/chkformat.d(101): Deprecation: precision argument `1L` for format specification `\"%*.*d\"` must be `int`, not `long`\n+fail_compilation/chkformat.d(101): Deprecation: argument `2L` for format specification `\"%*.*d\"` must be `int`, not `long`\n+fail_compilation/chkformat.d(104): Deprecation: argument `4` for format specification `\"%lld\"` must be `long`, not `int`\n+fail_compilation/chkformat.d(105): Deprecation: argument `5` for format specification `\"%jd\"` must be `core.stdc.stdint.intmax_t`, not `int`\n+fail_compilation/chkformat.d(106): Deprecation: argument `6.0` for format specification `\"%zd\"` must be `size_t`, not `double`\n+fail_compilation/chkformat.d(107): Deprecation: argument `7.0` for format specification `\"%td\"` must be `ptrdiff_t`, not `double`\n+fail_compilation/chkformat.d(108): Deprecation: argument `8.0L` for format specification `\"%g\"` must be `double`, not `real`\n+fail_compilation/chkformat.d(109): Deprecation: argument `9.0` for format specification `\"%Lg\"` must be `real`, not `double`\n+fail_compilation/chkformat.d(110): Deprecation: argument `10` for format specification `\"%p\"` must be `void*`, not `int`\n+fail_compilation/chkformat.d(111): Deprecation: argument `& u` for format specification `\"%n\"` must be `int*`, not `uint*`\n+fail_compilation/chkformat.d(113): Deprecation: argument `& u` for format specification `\"%lln\"` must be `long*`, not `int*`\n+fail_compilation/chkformat.d(114): Deprecation: argument `& u` for format specification `\"%hn\"` must be `short*`, not `int*`\n+fail_compilation/chkformat.d(115): Deprecation: argument `& u` for format specification `\"%hhn\"` must be `byte*`, not `int*`\n+fail_compilation/chkformat.d(116): Deprecation: argument `16L` for format specification `\"%c\"` must be `char`, not `long`\n+fail_compilation/chkformat.d(117): Deprecation: argument `17L` for format specification `\"%c\"` must be `char`, not `long`\n+fail_compilation/chkformat.d(118): Deprecation: argument `& u` for format specification `\"%s\"` must be `char*`, not `int*`\n+fail_compilation/chkformat.d(119): Deprecation: argument `& u` for format specification `\"%ls\"` must be `wchar_t*`, not `int*`\n+fail_compilation/chkformat.d(201): Deprecation: argument `0L` for format specification `\"%d\"` must be `int*`, not `long`\n+fail_compilation/chkformat.d(202): Deprecation: more format specifiers than 1 arguments\n+fail_compilation/chkformat.d(203): Deprecation: argument `0L` for format specification `\"%d\"` must be `int*`, not `long`\n+fail_compilation/chkformat.d(204): Deprecation: argument `0L` for format specification `\"%3u\"` must be `uint*`, not `long`\n+fail_compilation/chkformat.d(205): Deprecation: argument `u` for format specification `\"%200u\"` must be `uint*`, not `uint`\n+fail_compilation/chkformat.d(206): Deprecation: argument `3.0` for format specification `\"%hhd\"` must be `byte*`, not `double`\n+fail_compilation/chkformat.d(207): Deprecation: argument `4` for format specification `\"%hd\"` must be `short*`, not `int`\n+fail_compilation/chkformat.d(209): Deprecation: argument `4` for format specification `\"%lld\"` must be `long*`, not `int`\n+fail_compilation/chkformat.d(210): Deprecation: argument `5` for format specification `\"%jd\"` must be `core.stdc.stdint.intmax_t*`, not `int`\n+fail_compilation/chkformat.d(211): Deprecation: argument `6.0` for format specification `\"%zd\"` must be `size_t*`, not `double`\n+fail_compilation/chkformat.d(212): Deprecation: argument `7.0` for format specification `\"%td\"` must be `ptrdiff_t*`, not `double`\n+fail_compilation/chkformat.d(213): Deprecation: format specifier `\"%Ld\"` is invalid\n+fail_compilation/chkformat.d(214): Deprecation: argument `0` for format specification `\"%u\"` must be `uint*`, not `int`\n+fail_compilation/chkformat.d(215): Deprecation: argument `0` for format specification `\"%hhu\"` must be `ubyte*`, not `int`\n+fail_compilation/chkformat.d(216): Deprecation: argument `0` for format specification `\"%hu\"` must be `ushort*`, not `int`\n+fail_compilation/chkformat.d(218): Deprecation: argument `0` for format specification `\"%llu\"` must be `ulong*`, not `int`\n+fail_compilation/chkformat.d(219): Deprecation: argument `0` for format specification `\"%ju\"` must be `ulong*`, not `int`\n+fail_compilation/chkformat.d(220): Deprecation: argument `0` for format specification `\"%zu\"` must be `size_t*`, not `int`\n+fail_compilation/chkformat.d(221): Deprecation: argument `0` for format specification `\"%tu\"` must be `ptrdiff_t*`, not `int`\n+fail_compilation/chkformat.d(222): Deprecation: argument `8.0L` for format specification `\"%g\"` must be `float*`, not `real`\n+fail_compilation/chkformat.d(223): Deprecation: argument `8.0L` for format specification `\"%lg\"` must be `double*`, not `real`\n+fail_compilation/chkformat.d(224): Deprecation: argument `9.0` for format specification `\"%Lg\"` must be `real*`, not `double`\n+fail_compilation/chkformat.d(225): Deprecation: argument `& u` for format specification `\"%s\"` must be `char*`, not `int*`\n+fail_compilation/chkformat.d(226): Deprecation: argument `& u` for format specification `\"%ls\"` must be `wchar_t*`, not `int*`\n+fail_compilation/chkformat.d(227): Deprecation: argument `v` for format specification `\"%p\"` must be `void**`, not `void*`\n+fail_compilation/chkformat.d(228): Deprecation: argument `& u` for format specification `\"%n\"` must be `int*`, not `ushort*`\n+fail_compilation/chkformat.d(229): Deprecation: argument `& u` for format specification `\"%hhn\"` must be `byte*`, not `int*`\n+fail_compilation/chkformat.d(230): Deprecation: format specifier `\"%[n\"` is invalid\n+fail_compilation/chkformat.d(231): Deprecation: format specifier `\"%]\"` is invalid\n+fail_compilation/chkformat.d(232): Deprecation: argument `& u` for format specification `\"%90s\"` must be `char*`, not `int*`\n+fail_compilation/chkformat.d(233): Deprecation: argument `0L` for format specification `\"%d\"` must be `int*`, not `long`\n+fail_compilation/chkformat.d(234): Deprecation: argument `0L` for format specification `\"%d\"` must be `int*`, not `long`\n+---\n+*/\n+\n+\n+import core.stdc.stdio;\n+\n+#line 100\n+\n+void test1() {  printf(\"%*.*d\\n\", 0L, 1L, 2L); }\n+//void test2() { }\n+//void test3() {  printf(\"%ld\\n\", 3.0); }\n+void test4() {  printf(\"%lld\\n\", 4); }\n+void test5() {  printf(\"%jd\\n\", 5); }\n+void test6() {  printf(\"%zd\\n\", 6.0); }\n+void test7() {  printf(\"%td\\n\", 7.0); }\n+void test8() {  printf(\"%g\\n\", 8.0L); }\n+void test9() {  printf(\"%Lg\\n\", 9.0); }\n+void test10() {  printf(\"%p\\n\", 10); }\n+void test11() { uint u; printf(\"%n\\n\", &u); }\n+//void test12() { ushort u; printf(\"%ln\\n\", &u); }\n+void test13() { int u; printf(\"%lln\\n\", &u); }\n+void test14() { int u; printf(\"%hn\\n\", &u); }\n+void test15() { int u; printf(\"%hhn\\n\", &u); }\n+void test16() { printf(\"%c\\n\", 16L); }\n+void test17() { printf(\"%c\\n\", 17L); }\n+void test18() { int u; printf(\"%s\\n\", &u); }\n+void test19() { int u; printf(\"%ls\\n\", &u); }\n+//void test20() { int u; char[] s; sprintf(&s[0], \"%d\\n\", &u); }\n+//void test21() { int u; fprintf(null, \"%d\\n\", &u); }\n+\n+#line 200\n+\n+void test31() {  scanf(\"%d\\n\", 0L); }\n+void test32() {  int i; scanf(\"%d %d\\n\", &i); }\n+void test33() {  scanf(\"%d%*c\\n\", 0L); }\n+void test34() {  scanf(\"%3u\\n\", 0L); }\n+void test35() {  uint u; scanf(\"%200u%*s\\n\", u); }\n+void test36() {  scanf(\"%hhd\\n\", 3.0); }\n+void test37() {  scanf(\"%hd\\n\", 4); }\n+//void test38() {  scanf(\"%ld\\n\", 3.0); }\n+void test39() {  scanf(\"%lld\\n\", 4); }\n+void test40() { scanf(\"%jd\\n\", 5); }\n+void test41() { scanf(\"%zd\\n\", 6.0); }\n+void test42() { scanf(\"%td\\n\", 7.0); }\n+void test43() { scanf(\"%Ld\\n\", 0); }\n+void test44() { scanf(\"%u\\n\", 0); }\n+void test45() { scanf(\"%hhu\\n\", 0); }\n+void test46() { scanf(\"%hu\\n\", 0); }\n+//void test47() { scanf(\"%lu\\n\", 0); }\n+void test48() { scanf(\"%llu\\n\", 0); }\n+void test49() { scanf(\"%ju\\n\", 0); }\n+void test50() { scanf(\"%zu\\n\", 0); }\n+void test51() { scanf(\"%tu\\n\", 0); }\n+void test52() { scanf(\"%g\\n\", 8.0L); }\n+void test53() { scanf(\"%lg\\n\", 8.0L); }\n+void test54() { scanf(\"%Lg\\n\", 9.0); }\n+void test55() { int u; scanf(\"%s\\n\", &u); }\n+void test56() { int u; scanf(\"%ls\\n\", &u); }\n+void test57() { void* v; scanf(\"%p\\n\", v); }\n+void test58() { ushort u; scanf(\"%n\\n\", &u); }\n+void test59() { int u; scanf(\"%hhn\\n\", &u); }\n+void test60() { int u; scanf(\"%[n\", &u); }\n+void test61() { int u; scanf(\"%]\\n\", &u); }\n+void test62() { int u; scanf(\"%90s\\n\", &u); }\n+void test63() { sscanf(\"1234\", \"%d\\n\", 0L); }\n+void test64() { fscanf(null, \"%d\\n\", 0L); }\n+\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/chkformat.d(301): Deprecation: format specifier `\"%K\"` is invalid\n+fail_compilation/chkformat.d(302): Deprecation: format specifier `\"%Q\"` is invalid\n+---\n+*/\n+\n+import core.stdc.stdarg;\n+\n+#line 300\n+\n+void test301() { va_list vargs; vprintf(\"%K\", vargs); }\n+void test302() { va_list vargs; vscanf(\"%Q\", vargs); }\n+\n+// TODO - C++ 11 only:\n+//void test() { vscanf(); }\n+//void test() { vfscanf(); }\n+//void test() { vsscanf(); }"}, {"sha": "ca9ed9a71a709f5fce455b41f7d0984f825ef2fe", "filename": "gcc/testsuite/gdc.test/fail_compilation/cppmangle.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcppmangle.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/cppmangle.d(10): Error: invalid zero length C++ namespace\n-fail_compilation/cppmangle.d(14): Error: expected valid identifer for C++ namespace but got `0num`\n+fail_compilation/cppmangle.d(14): Error: expected valid identifier for C++ namespace but got `0num`\n fail_compilation/cppmangle.d(18): Error: string expected following `,` for C++ namespace, not `)`\n ---\n */"}, {"sha": "a5d6a14212ef081360a6a4bc1d5f774af6dd458c", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag11819b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11819b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11819b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11819b.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -14,7 +14,7 @@ fail_compilation/diag11819b.d(37): Error: unrecognized trait `AllMembers`, did y\n fail_compilation/diag11819b.d(38): Error: unrecognized trait `DerivedMembers`, did you mean `derivedMembers`?\n fail_compilation/diag11819b.d(39): Error: unrecognized trait `IsSame`, did you mean `isSame`?\n fail_compilation/diag11819b.d(40): Error: unrecognized trait `Compiles`, did you mean `compiles`?\n-fail_compilation/diag11819b.d(41): Error: unrecognized trait `Parameters`, did you mean `parameters`?\n+fail_compilation/diag11819b.d(41): Error: unrecognized trait `Parameters`\n fail_compilation/diag11819b.d(42): Error: unrecognized trait `GetAliasThis`, did you mean `getAliasThis`?\n fail_compilation/diag11819b.d(43): Error: unrecognized trait `GetAttributes`, did you mean `getAttributes`?\n fail_compilation/diag11819b.d(44): Error: unrecognized trait `GetFunctionAttributes`, did you mean `getFunctionAttributes`?"}, {"sha": "7360a3df62f20158b6b78b438030778e77cb4cfe", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag13082.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13082.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13082.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13082.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,8 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag13082.d(22): Error: constructor diag13082.C.this (int a) is not callable using argument types (string)\n-fail_compilation/diag13082.d(23): Error: constructor diag13082.S.this (int a) is not callable using argument types (string)\n+fail_compilation/diag13082.d(24): Error: constructor `diag13082.C.this(int a)` is not callable using argument types `(string)`\n+fail_compilation/diag13082.d(24):        cannot pass argument `b` of type `string` to parameter `int a`\n+fail_compilation/diag13082.d(25): Error: constructor `diag13082.S.this(int a)` is not callable using argument types `(string)`\n+fail_compilation/diag13082.d(25):        cannot pass argument `b` of type `string` to parameter `int a`\n ---\n */\n "}, {"sha": "b85dc8d21bb48edbb0fe32255383c9bd8a9eefdc", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag16271.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,12 @@\n+/*\n+TEST_OUTPUT\n+---\n+fail_compilation/diag16271.d(10): Error: found `x` when expecting function literal following `ref`\n+---\n+*/\n+\n+void main()\n+{\n+    auto fun = ref x;\n+}\n+"}, {"sha": "3b2401ad8cf575eab8e32d12de38d5dbde3b1f70", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8101.d", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,29 +1,30 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag8101.d(56): Error: function diag8101.f_0 (int) is not callable using argument types ()\n-fail_compilation/diag8101.d(57): Error: none of the overloads of 'f_1' are callable using argument types (), candidates are:\n-fail_compilation/diag8101.d(32):        diag8101.f_1(int)\n-fail_compilation/diag8101.d(33):        diag8101.f_1(int, int)\n-fail_compilation/diag8101.d(58): Error: none of the overloads of 'f_2' are callable using argument types (), candidates are:\n-fail_compilation/diag8101.d(35):        diag8101.f_2(int)\n-fail_compilation/diag8101.d(36):        diag8101.f_2(int, int)\n-fail_compilation/diag8101.d(37):        diag8101.f_2(int, int, int)\n-fail_compilation/diag8101.d(38):        diag8101.f_2(int, int, int, int)\n-fail_compilation/diag8101.d(39):        diag8101.f_2(int, int, int, int, int)\n-fail_compilation/diag8101.d(58):        ... (1 more, -v to show) ...\n-fail_compilation/diag8101.d(60): Error: template diag8101.t_0 cannot deduce function from argument types !()(), candidates are:\n-fail_compilation/diag8101.d(42):        diag8101.t_0(T1)()\n-fail_compilation/diag8101.d(61): Error: template diag8101.t_1 cannot deduce function from argument types !()(), candidates are:\n-fail_compilation/diag8101.d(44):        diag8101.t_1(T1)()\n-fail_compilation/diag8101.d(45):        diag8101.t_1(T1, T2)()\n-fail_compilation/diag8101.d(62): Error: template diag8101.t_2 cannot deduce function from argument types !()(), candidates are:\n-fail_compilation/diag8101.d(47):        diag8101.t_2(T1)()\n-fail_compilation/diag8101.d(48):        diag8101.t_2(T1, T2)()\n-fail_compilation/diag8101.d(49):        diag8101.t_2(T1, T2, T3)()\n-fail_compilation/diag8101.d(50):        diag8101.t_2(T1, T2, T3, T4)()\n-fail_compilation/diag8101.d(51):        diag8101.t_2(T1, T2, T3, T4, T5)()\n-fail_compilation/diag8101.d(62):        ... (1 more, -v to show) ...\n+fail_compilation/diag8101.d(57): Error: function `diag8101.f_0(int)` is not callable using argument types `()`\n+fail_compilation/diag8101.d(57):        missing argument for parameter #1: `int`\n+fail_compilation/diag8101.d(58): Error: none of the overloads of `f_1` are callable using argument types `()`, candidates are:\n+fail_compilation/diag8101.d(33):        `diag8101.f_1(int)`\n+fail_compilation/diag8101.d(34):        `diag8101.f_1(int, int)`\n+fail_compilation/diag8101.d(59): Error: none of the overloads of `f_2` are callable using argument types `()`, candidates are:\n+fail_compilation/diag8101.d(36):        `diag8101.f_2(int)`\n+fail_compilation/diag8101.d(37):        `diag8101.f_2(int, int)`\n+fail_compilation/diag8101.d(38):        `diag8101.f_2(int, int, int)`\n+fail_compilation/diag8101.d(39):        `diag8101.f_2(int, int, int, int)`\n+fail_compilation/diag8101.d(40):        `diag8101.f_2(int, int, int, int, int)`\n+fail_compilation/diag8101.d(59):        ... (1 more, -v to show) ...\n+fail_compilation/diag8101.d(61): Error: template `diag8101.t_0` cannot deduce function from argument types `!()()`, candidates are:\n+fail_compilation/diag8101.d(43):        `diag8101.t_0(T1)()`\n+fail_compilation/diag8101.d(62): Error: template `diag8101.t_1` cannot deduce function from argument types `!()()`, candidates are:\n+fail_compilation/diag8101.d(45):        `diag8101.t_1(T1)()`\n+fail_compilation/diag8101.d(46):        `diag8101.t_1(T1, T2)()`\n+fail_compilation/diag8101.d(63): Error: template `diag8101.t_2` cannot deduce function from argument types `!()()`, candidates are:\n+fail_compilation/diag8101.d(48):        `diag8101.t_2(T1)()`\n+fail_compilation/diag8101.d(49):        `diag8101.t_2(T1, T2)()`\n+fail_compilation/diag8101.d(50):        `diag8101.t_2(T1, T2, T3)()`\n+fail_compilation/diag8101.d(51):        `diag8101.t_2(T1, T2, T3, T4)()`\n+fail_compilation/diag8101.d(52):        `diag8101.t_2(T1, T2, T3, T4, T5)()`\n+fail_compilation/diag8101.d(63):        ... (1 more, -v to show) ...\n ---\n */\n "}, {"sha": "228ba169e8e5f13ab2b63203e3c8643ad303d5f3", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8101b.d", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101b.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,14 +1,15 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag8101b.d(26): Error: none of the overloads of 'foo' are callable using argument types (double), candidates are:\n-fail_compilation/diag8101b.d(17):        diag8101b.S.foo(int _param_0)\n-fail_compilation/diag8101b.d(18):        diag8101b.S.foo(int _param_0, int _param_1)\n-fail_compilation/diag8101b.d(28): Error: function diag8101b.S.bar (int _param_0) is not callable using argument types (double)\n-fail_compilation/diag8101b.d(31): Error: none of the overloads of 'foo' are callable using a const object, candidates are:\n-fail_compilation/diag8101b.d(17):        diag8101b.S.foo(int _param_0)\n-fail_compilation/diag8101b.d(18):        diag8101b.S.foo(int _param_0, int _param_1)\n-fail_compilation/diag8101b.d(33): Error: mutable method diag8101b.S.bar is not callable using a const object\n+fail_compilation/diag8101b.d(27): Error: none of the overloads of `foo` are callable using argument types `(double)`, candidates are:\n+fail_compilation/diag8101b.d(18):        `diag8101b.S.foo(int _param_0)`\n+fail_compilation/diag8101b.d(19):        `diag8101b.S.foo(int _param_0, int _param_1)`\n+fail_compilation/diag8101b.d(29): Error: function `diag8101b.S.bar(int _param_0)` is not callable using argument types `(double)`\n+fail_compilation/diag8101b.d(29):        cannot pass argument `1.00000` of type `double` to parameter `int _param_0`\n+fail_compilation/diag8101b.d(32): Error: none of the overloads of `foo` are callable using a `const` object, candidates are:\n+fail_compilation/diag8101b.d(18):        `diag8101b.S.foo(int _param_0)`\n+fail_compilation/diag8101b.d(19):        `diag8101b.S.foo(int _param_0, int _param_1)`\n+fail_compilation/diag8101b.d(34): Error: mutable method `diag8101b.S.bar` is not callable using a `const` object\n ---\n */\n "}, {"sha": "6b2577d910e3ba01aca75fe2cf1bb80269faab3f", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag9420.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9420.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9420.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9420.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT\n ---\n-fail_compilation/diag9420.d(20): Error: function diag9420.S.t3!().tx () is not callable using argument types (int)\n+fail_compilation/diag9420.d(21): Error: function `diag9420.S.t3!().tx()` is not callable using argument types `(int)`\n+fail_compilation/diag9420.d(21):        expected 0 argument(s), not 1\n ---\n */\n "}, {"sha": "8f39ccc51eb257536adee2dc0905567847347311", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11038.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11038.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11038.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11038.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,17 @@\n+// https://issues.dlang.org/show_bug.cgi?id=11038\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail11038.d(16): Error: `writeln` is not defined, perhaps `import std.stdio;` is needed?\n+---\n+*/\n+\n+static\n+{\n+    import std.stdio;\n+}\n+\n+void main()\n+{\n+    writeln(\"foo\");  // compiles\n+}"}, {"sha": "ed3f226e4f209e3fdb7759788b5acd3e4a2005f1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11445.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11445.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11445.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11445.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail11445.d(11): Error: incompatible types for ((a) + (b)): 'double[string]' and 'double[string]'\n+fail_compilation/fail11445.d(11): Error: incompatible types for ((a) + (b)): both operands are of type 'double[string]'\n ---\n */\n "}, {"sha": "8e5f9800a816e7e3050fce80b35fdea12f00a62b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15361.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15361.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15361.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15361.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,8 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail15361.d(8): Error: unexpected `(` after `errorize`, inside `is` expression. Try enclosing the contents of `is` with a `typeof` expression\n+---\n+*/\n+\n+enum isErrorizable(T) = is(errorize(T.init));"}, {"sha": "e52503d0975c11e95239869240d538eae2d062d1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15896.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15896.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15896.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15896.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,18 @@\n+// REQUIRED_ARGS: -de\n+// EXTRA_FILES: imports/imp15896.d\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail15896.d(11): Error: module `imports.imp15896` member `thebar` is not visible from module `fail15896`\n+fail_compilation/fail15896.d(11): Error: module `imports.imp15896` member `packagebar` is not visible from module `fail15896`\n+---\n+*/\n+\n+import imports.imp15896 : thebar, packagebar;\n+\n+int func()\n+{\n+    thebar +=1;\n+    packagebar += 1;\n+    return 0;\n+}"}, {"sha": "9b6ed82d4b34b25a484ee80a3c28244269673d92", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17630.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17630.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17630.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17630.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,15 @@\n+// REQUIRED_ARGS: -de\n+// EXTRA_FILES: imports/a17630.d\n+// EXTRA_SOURCES: imports/b17630.d\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail17630.d(13): Error: module `a17630` import `Erase` not found, did you mean variable `b17630.Erase`?\n+---\n+*/\n+\n+void main()\n+{\n+    import imports.a17630 : Erase;\n+    assert(Erase == 2);\n+}"}, {"sha": "f3ec6806f6b97af18327bddec4f0e1d22819d529", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18219.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18219.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18219.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18219.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,20 @@\n+// EXTRA_SOURCES: imports/b18219.d\n+// EXTRA_FILES: imports/a18219.d\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail18219.d(16): Error: no property `Foobar` for type `AST`, did you mean `b18219.Foobar`?\n+fail_compilation/fail18219.d(17): Error: no property `Bar` for type `a18219.AST`\n+fail_compilation/fail18219.d(18): Error: no property `fun` for type `AST`, did you mean `b18219.fun`?\n+fail_compilation/fail18219.d(19): Error: no property `Foobar` for type `AST`, did you mean `b18219.Foobar`?\n+---\n+*/\n+import imports.a18219;\n+\n+void main()\n+{\n+    AST.Foobar t;\n+    AST.Bar l;\n+    AST.fun();\n+    AST.Foobar.smeth();\n+}"}, {"sha": "c748650b2e4177e5d44d3c7f73887b6b1c50aa3e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19107.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19107.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19107.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19107.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,21 @@\n+// REQUIRED_ARGS:\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test19107.d(20): Error: template `test19107.all` cannot deduce function from argument types `!((c) => c)(string[])`, candidates are:\n+fail_compilation/test19107.d(14):        `test19107.all(alias pred, T)(T t) if (is(typeof(I!pred(t))))`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=19107\n+\n+import imports.test19107b;\n+\n+void all(alias pred, T)(T t)\n+    if (is(typeof(I!pred(t))))\n+{ }\n+\n+void main(string[] args)\n+{\n+    args.all!(c => c);\n+}"}, {"sha": "8cf9b20ac2bba50aecc9930c1b438dee9d7a04bd", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail263.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail263.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail263.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail263.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail263.d(18): Error: function fail263.f (byte* p) is not callable using argument types (const(byte)*)\n+fail_compilation/fail263.d(19): Error: function `fail263.f(byte* p)` is not callable using argument types `(const(byte)*)`\n+fail_compilation/fail263.d(19):        cannot pass argument `cast(const(byte)*)A` of type `const(byte)*` to parameter `byte* p`\n ---\n */\n "}, {"sha": "0b7516cbc06c42e91a0bbe1824c8ccf298c4d00e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail3.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail3.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail3.d(40): Error: incompatible types for ((a) + (b)): 'vec2' and 'vec2'\n+fail_compilation/fail3.d(41): Error: incompatible types for ((a) + (b)): both operands are of type 'vec2'\n ---\n */\n \n@@ -14,6 +14,7 @@ template vector(T)\n         T x, y;\n     }\n \n+    // not struct member\n     vec2 opAdd(vec2 a, vec2 b)\n     {\n         vec2 r;"}, {"sha": "491111fe610200c021aeb0a81f75141e11702d05", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail322.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail322.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail322.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail322.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,13 +1,18 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail322.d(10): Error: function fail322.digestToString2 (ref char[16] digest) is not callable using argument types (string)\n+fail_compilation/fail322.d(13): Error: function `fail322.digestToString2(ref char[16] digest)` is not callable using argument types `(string)`\n+fail_compilation/fail322.d(13):        cannot pass rvalue argument `\"1234567890123456\"` of type `string` to parameter `ref char[16] digest`\n+fail_compilation/fail322.d(15): Error: function `fail322.digestToString2(ref char[16] digest)` is not callable using argument types `(const(char[16]))`\n+fail_compilation/fail322.d(15):        cannot pass argument `s` of type `const(char[16])` to parameter `ref char[16] digest`\n ---\n */\n \n void main()\n {\n     digestToString2(\"1234567890123456\");\n+    const char[16] s;\n+    digestToString2(s);\n }\n \n void digestToString2(ref char[16] digest)"}, {"sha": "91f8046470564ed893e1a25eb3e2e205b8fb71cf", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail332.d", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail332.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail332.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail332.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,15 +1,56 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail332.d(14): Error: function fail332.foo (int _param_0, ...) is not callable using argument types ()\n+fail_compilation/fail332.d(22): Error: function `fail332.foo(int _param_0, ...)` is not callable using argument types `()`\n+fail_compilation/fail332.d(22):        missing argument for parameter #1: `int _param_0`\n+fail_compilation/fail332.d(23): Error: function `fail332.foo(int _param_0, ...)` is not callable using argument types `(typeof(null))`\n+fail_compilation/fail332.d(23):        cannot pass argument `null` of type `typeof(null)` to parameter `int _param_0`\n+fail_compilation/fail332.d(25): Error: function `fail332.baz(int[] _param_0...)` is not callable using argument types `(string)`\n+fail_compilation/fail332.d(25):        cannot pass argument `\"\"` of type `string` to parameter `int[] _param_0...`\n+fail_compilation/fail332.d(26): Error: function `fail332.baz(int[] _param_0...)` is not callable using argument types `(int, typeof(null))`\n+fail_compilation/fail332.d(26):        cannot pass argument `null` of type `typeof(null)` to parameter `int[] _param_0...`\n ---\n */\n \n import core.vararg;\n \n void foo(int, ...) {}\n+void baz(int[]...) {}\n \n-void bar()\n+void test()\n {\n     foo();\n+    foo(null);\n+\n+    baz(\"\");\n+    baz(3, null);\n+}\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail332.d(50): Error: function `fail332.bar(Object, int[2]...)` is not callable using argument types `()`\n+fail_compilation/fail332.d(50):        missing argument for parameter #1: `Object`\n+fail_compilation/fail332.d(51): Error: function `fail332.bar(Object, int[2]...)` is not callable using argument types `(int)`\n+fail_compilation/fail332.d(51):        cannot pass argument `4` of type `int` to parameter `Object`\n+fail_compilation/fail332.d(52): Error: function `fail332.bar(Object, int[2]...)` is not callable using argument types `(typeof(null))`\n+fail_compilation/fail332.d(52):        expected 2 variadic argument(s), not 0\n+fail_compilation/fail332.d(53): Error: function `fail332.bar(Object, int[2]...)` is not callable using argument types `(typeof(null), int)`\n+fail_compilation/fail332.d(53):        expected 2 variadic argument(s), not 1\n+fail_compilation/fail332.d(54): Error: function `fail332.bar(Object, int[2]...)` is not callable using argument types `(typeof(null), int, string)`\n+fail_compilation/fail332.d(54):        cannot pass argument `\"\"` of type `string` to parameter `int[2]...`\n+fail_compilation/fail332.d(55): Error: function `fail332.bar(Object, int[2]...)` is not callable using argument types `(typeof(null), int, int, int)`\n+fail_compilation/fail332.d(55):        expected 2 variadic argument(s), not 3\n+---\n+*/\n+void bar(Object, int[2]...);\n+\n+void test2()\n+{\n+    bar();\n+    bar(4);\n+    bar(null);\n+    bar(null, 2);\n+    bar(null, 2, \"\");\n+    bar(null, 2,3,4);\n }"}, {"sha": "61718df59e28fb7197a1acb83ad2a861f524b8bc", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail347.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail347.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail347.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail347.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail347.d(21): Error: undefined identifier `bbr`, did you mean variable `bar`?\n-fail_compilation/fail347.d(22): Error: no property 'ofo' for type 'S', did you mean 'foo'?\n+fail_compilation/fail347.d(22): Error: no property 'ofo' for type 'S', did you mean 'fail347.S.foo'?\n fail_compilation/fail347.d(23): Error: undefined identifier `strlenx`, did you mean function `strlen`?\n ---\n */"}, {"sha": "556896c76c35134bc16a58a21b947a1633a9ca5c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail53.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail53.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail53.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail53.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail53.d(25): Error: function object.Object.opEquals (Object o) is not callable using argument types (int)\n+fail_compilation/fail53.d(26): Error: function `object.Object.opEquals(Object o)` is not callable using argument types `(int)`\n+fail_compilation/fail53.d(26):        cannot pass argument `i` of type `int` to parameter `Object o`\n ---\n */\n "}, {"sha": "290c2b6695f09fd6b87c5992d5af5f0a2d2db51f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail55.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail55.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail55.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail55.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail55.d(22): Error: function object.Object.opCmp (Object o) is not callable using argument types (int)\n+fail_compilation/fail55.d(23): Error: function `object.Object.opCmp(Object o)` is not callable using argument types `(int)`\n+fail_compilation/fail55.d(23):        cannot pass argument `0` of type `int` to parameter `Object o`\n ---\n */\n "}, {"sha": "da06984e9ef05ddc044be417181e155f14fc3e16", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail79.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail79.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail79.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail79.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail79.d(13): Error: incompatible types for ((& a) + (& b)): 'int*' and 'int*'\n+fail_compilation/fail79.d(13): Error: incompatible types for ((& a) + (& b)): both operands are of type 'int*'\n ---\n */\n "}, {"sha": "c147b810ee6754654d36c23e90c3339770ffaa15", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail99.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail99.d(12): Error: delegate dg (int) is not callable using argument types ()\n+fail_compilation/fail99.d(13): Error: delegate `dg(int)` is not callable using argument types `()`\n+fail_compilation/fail99.d(13):        missing argument for parameter #1: `int`\n ---\n */\n "}, {"sha": "48c74cb3698be6b308c2ce65216f662a28c56df7", "filename": "gcc/testsuite/gdc.test/fail_compilation/fix21585.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix21585.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix21585.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix21585.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,19 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=21585\n+TEST_OUTPUT:\n+---\n+fail_compilation/fix21585.d(103): Error: expected 1 arguments for `toType` but had 0\n+fail_compilation/fix21585.d(104): Error: expression expected as second argument of __traits `toType`\n+fail_compilation/fix21585.d(105): Error: `string` expected for __traits(toType, string), not `(1)` of type `int`\n+fail_compilation/fix21585.d(106): Error: cannot determine `__traits(toType, \"hello betty\")`\n+---\n+*/\n+\n+#line 100\n+\n+template Type(T) { alias Type = T; }\n+\n+alias T1 = Type!(__traits(toType));\n+alias T2 = Type!(__traits(toType, int));\n+alias T3 = Type!(__traits(toType, 1));\n+alias T4 = Type!(__traits(toType, \"hello betty\"));\n+"}, {"sha": "3a2422791f7efc082fd532876380cdb2dce52bfd", "filename": "gcc/testsuite/gdc.test/fail_compilation/format.d", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fformat.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,44 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/format.d(101): Error: function `format.printf1` `pragma(printf)` functions must be `extern(C) void printf1([parameters...], const(char)*, ...)` not `void(const(char)*, ...)`\n+fail_compilation/format.d(102): Error: function `format.printf2` `pragma(printf)` functions must be `extern(C) int printf2([parameters...], const(char)*, ...)` not `extern (C) int(const(int)*, ...)`\n+fail_compilation/format.d(103): Error: function `format.printf3` `pragma(printf)` functions must be `extern(C) int printf3([parameters...], const(char)*, va_list)`\n+fail_compilation/format.d(104): Error: function `format.printf4` `pragma(printf)` functions must be `extern(C) int printf4([parameters...], const(char)*, ...)` not `extern (C) int(const(char)*, int, ...)`\n+---\n+ */\n+\n+#line 100\n+\n+pragma(printf)           void printf1(const(char)*, ...);\n+pragma(printf) extern (C) int printf2(const(int )*, ...);\n+pragma(printf) extern (C) int printf3(const(char)*);\n+pragma(printf) extern (C) int printf4(const(char)*, int, ...);\n+\n+pragma(printf) extern (C) int printf5(const(char)*, ...);\n+pragma(printf) extern (C) int printf6(immutable(char)*, ...);\n+pragma(printf) extern (C) int printf7(char*, ...);\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/format.d(203): Error: function `format.vprintf1` `pragma(printf)` functions must be `extern(C) void vprintf1([parameters...], const(char)*, va_list)`\n+fail_compilation/format.d(204): Error: function `format.vprintf2` `pragma(printf)` functions must be `extern(C) int vprintf2([parameters...], const(char)*, va_list)`\n+fail_compilation/format.d(205): Error: function `format.vprintf3` `pragma(printf)` functions must be `extern(C) int vprintf3([parameters...], const(char)*, va_list)`\n+fail_compilation/format.d(206): Error: function `format.vprintf4` `pragma(printf)` functions must be `extern(C) int vprintf4([parameters...], const(char)*, va_list)`\n+---\n+ */\n+\n+#line 200\n+\n+import core.stdc.stdarg;\n+\n+pragma(printf)           void vprintf1(const(char)*, va_list);\n+pragma(printf) extern (C) int vprintf2(const(int )*, va_list);\n+pragma(printf) extern (C) int vprintf3(const(char)*);\n+pragma(printf) extern (C) int vprintf4(const(char)*, int, va_list);\n+\n+pragma(printf) extern (C) int vprintf5(const(char)*, va_list);\n+pragma(printf) extern (C) int vprintf6(immutable(char)*, va_list);\n+pragma(printf) extern (C) int vprintf7(char*, va_list);\n+"}, {"sha": "ba6cdf73211eed13e4c18e0b5c561ed04b4ce2c8", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10598.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10598.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10598.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10598.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,10 @@\n+// REQUIRED_ARGS: -de\n+// EXTRA_SOURCES: imports/ice10598a.d imports/ice10598b.d\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/imports/ice10598a.d(5): Deprecation: module imports.ice10598b is not accessible here, perhaps add 'static import imports.ice10598b;'\n+fail_compilation/imports/ice10598a.d(5): Deprecation: module imports.ice10598b is not accessible here, perhaps add 'static import imports.ice10598b;'\n+---\n+*/\n+\n+void main() {}"}, {"sha": "9eeb622300a4e06a18592569a79a3d8e87f165c8", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10922.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice10922.d(9): Error: function ice10922.__lambda4 (const(uint) n) is not callable using argument types ()\n+fail_compilation/ice10922.d(10): Error: function `ice10922.__lambda4(const(uint) n)` is not callable using argument types `()`\n+fail_compilation/ice10922.d(10):        missing argument for parameter #1: `const(uint) n`\n ---\n */\n "}, {"sha": "ab95e81d5b7ef3fdf5ea210176c8c255bf482851", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice12497.d", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0f6902666430e5d065a92b3d5292cba91813d3/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12497.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0f6902666430e5d065a92b3d5292cba91813d3/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12497.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12497.d?ref=ba0f6902666430e5d065a92b3d5292cba91813d3", "patch": "@@ -1,18 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/ice12497.d(15): Error: string expected for argument to mixin, not (foo()) of type void\n-fail_compilation/ice12497.d(17): Error: string expected for argument to mixin, not (foo()) of type void\n----\n-*/\n-\n-void foo() {}\n-\n-void main()\n-{\n-    struct S\n-    {\n-        mixin(foo());   // MixinDeclaration\n-    }\n-    mixin(foo());       // MixinStatement\n-}"}, {"sha": "2c45c8a359daff644682534b16b20c597dfdbd52", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice12501.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12501.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12501.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12501.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,9 +1,11 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice12501.d(29): Error: function ice12501.foo (int value) is not callable using argument types (int, int)\n-fail_compilation/ice12501.d(29): Error: function ice12501.foo (int value) is not callable using argument types (int, int)\n-fail_compilation/ice12501.d(43): Error: template instance ice12501.reduce!(foo, foo).reduce!(Tuple!(int, int), int[]) error instantiating\n+fail_compilation/ice12501.d(31): Error: function `ice12501.foo(int value)` is not callable using argument types `(int, int)`\n+fail_compilation/ice12501.d(31):        expected 1 argument(s), not 2\n+fail_compilation/ice12501.d(31): Error: function `ice12501.foo(int value)` is not callable using argument types `(int, int)`\n+fail_compilation/ice12501.d(31):        expected 1 argument(s), not 2\n+fail_compilation/ice12501.d(45): Error: template instance `ice12501.reduce!(foo, foo).reduce!(Tuple!(int, int), int[])` error instantiating\n ---\n */\n "}, {"sha": "6d9edf0c9039308edb43b5ce38426b0201e5f364", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice14907.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14907.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14907.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14907.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,22 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/ice14907.d(14): Error: struct ice14907.S(int v = S) recursive template expansion\n+fail_compilation/ice14907.d(19):        while looking for match for `S!()`\n+fail_compilation/ice14907.d(15): Error: template ice14907.f(int v = f)() recursive template expansion\n+fail_compilation/ice14907.d(20):        while looking for match for `f!()`\n+fail_compilation/ice14907.d(15): Error: template ice14907.f(int v = f)() recursive template expansion\n+fail_compilation/ice14907.d(21): Error: template `ice14907.f` cannot deduce function from argument types `!()()`, candidates are:\n+fail_compilation/ice14907.d(15):        `ice14907.f(int v = f)()`\n+---\n+*/\n+\n+struct S(int v = S) {}\n+void f(int v = f)() {}\n+\n+void main()\n+{\n+    S!() s;     // OK <- ICE\n+    f!()();     // OK <- ICE\n+    f();        // OK <- ICE\n+}"}, {"sha": "e3b677e2cdb3d31c1adc861e71e1a591f27fcf2c", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice14923.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14923.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14923.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14923.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,8 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice14923.d(21): Error: function ice14923.parse (C a) is not callable using argument types (A)\n-fail_compilation/ice14923.d(21):        instantiated from here: bar!((b) => parse(b))\n+fail_compilation/ice14923.d(22): Error: function `ice14923.parse(C a)` is not callable using argument types `(A)`\n+fail_compilation/ice14923.d(22):        cannot pass argument `b` of type `ice14923.A` to parameter `C a`\n+fail_compilation/ice14923.d(22):        instantiated from here: `bar!((b) => parse(b))`\n ---\n */\n "}, {"sha": "0db3abc395fcf4c80ec03d0bcd50444bc365da03", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice8255.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice8255.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice8255.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice8255.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,8 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice8255.d(10): Error: function ice8255.F!(G).F.f (ref G _param_0) is not callable using argument types (G)\n-fail_compilation/ice8255.d(10):        while evaluating pragma(msg, F().f(G()))\n+fail_compilation/ice8255.d(11): Error: function `ice8255.F!(G).F.f(ref G _param_0)` is not callable using argument types `(G)`\n+fail_compilation/ice8255.d(11):        cannot pass rvalue argument `G()` of type `G` to parameter `ref G _param_0`\n+fail_compilation/ice8255.d(11):        while evaluating `pragma(msg, F().f(G()))`\n ---\n */\n struct G {}"}, {"sha": "f95cb974c79b11ad5bd863903507303727a6f8f4", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice9540.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,8 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice9540.d(34): Error: function ice9540.A.test.AddFront!(this, f).AddFront.dg (int _param_0) is not callable using argument types ()\n-fail_compilation/ice9540.d(25): Error: template instance ice9540.A.test.AddFront!(this, f) error instantiating\n+fail_compilation/ice9540.d(35): Error: function `ice9540.A.test.AddFront!(this, f).AddFront.dg(int _param_0)` is not callable using argument types `()`\n+fail_compilation/ice9540.d(35):        missing argument for parameter #1: `int _param_0`\n+fail_compilation/ice9540.d(26): Error: template instance `ice9540.A.test.AddFront!(this, f)` error instantiating\n ---\n */\n "}, {"sha": "c10484175d4124ddb4991bb520370ef4e4383679", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/a17630.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fa17630.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fa17630.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fa17630.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,3 @@\n+module a17630;\n+\n+import b17630;"}, {"sha": "1a88493ef15eb3339d1b2fd11a55400f57fa8cf4", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/a18219.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fa18219.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fa18219.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fa18219.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,6 @@\n+module a18219;\n+\n+struct AST\n+{\n+    import b18219;\n+}"}, {"sha": "5ad5f9917f7139ebf3e9ea4ee9dc1f6866b9fd3a", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/b17630.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fb17630.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fb17630.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fb17630.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,3 @@\n+module b17630;\n+\n+int Erase;"}, {"sha": "6008c8a1e21587479a0ba55d64231183577edbba", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/b18219.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fb18219.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fb18219.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fb18219.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,15 @@\n+module b18219;\n+\n+class Foobar\n+{\n+    int a;\n+    this(int a)\n+    {\n+        this.a = a;\n+    }\n+    static int smeth()\n+    {\n+        return 1;\n+    }\n+}\n+void fun() {}"}, {"sha": "b0e9c3b99a32694c3e64b0036452c37b06eec77e", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/ice10598a.d", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fice10598a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fice10598a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fice10598a.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "previous_filename": "gcc/testsuite/gdc.test/compilable/imports/ice10598a.d"}, {"sha": "de5078709fca724e42254ce792c4c6e59b105144", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/ice10598b.d", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fice10598b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fice10598b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fice10598b.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "previous_filename": "gcc/testsuite/gdc.test/compilable/imports/ice10598b.d"}, {"sha": "d7edcc1bcc115a45609528ed5f5415fb787f6b23", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/imp15896.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp15896.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp15896.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp15896.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,4 @@\n+module imports.imp15896;\n+\n+private int thebar=4;\n+package int packagebar=3;"}, {"sha": "4c85aade3bc249ca025c5156afe136ce02220c12", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/test21651b.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ftest21651b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ftest21651b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ftest21651b.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,3 @@\n+module imports.test21651b;\n+\n+alias T = int;"}, {"sha": "75e3b9f0b81029b51d8e397f7ef17532511ed094", "filename": "gcc/testsuite/gdc.test/fail_compilation/issue16020.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue16020.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue16020.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue16020.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,13 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/issue16020.d(12): Error: user-defined attributes not allowed for `alias` declarations\n+fail_compilation/issue16020.d(13): Error: semicolon expected to close `alias` declaration\n+fail_compilation/issue16020.d(13): Error: declaration expected, not `(`\n+---\n+*/\n+module issue16020;\n+\n+struct UDA{}\n+alias Fun = @UDA void();\n+alias FunTemplate = void(T)(T t);"}, {"sha": "b18627dd879281cbe0ce2759d29863c64959735e", "filename": "gcc/testsuite/gdc.test/fail_compilation/mixintype2.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixintype2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixintype2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixintype2.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,16 @@\n+\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/mixintype2.d(10): Error: alias `mixintype2.Foo.T` recursive alias declaration\n+fail_compilation/mixintype2.d(16): Error: `mixin(0)` does not give a valid type\n+---\n+*/\n+\n+struct Foo {\n+    alias T = mixin(\"T2\");\n+}\n+alias T1 = mixin(\"Foo.T\");\n+alias T2 = mixin(\"T1\");\n+void func (T2 p) {}\n+\n+enum mixin(0) a = 0;"}, {"sha": "80ae40b6b88b0a9d838a1a40af7bc9465c3261cc", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16002.d", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0f6902666430e5d065a92b3d5292cba91813d3/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16002.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0f6902666430e5d065a92b3d5292cba91813d3/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16002.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16002.d?ref=ba0f6902666430e5d065a92b3d5292cba91813d3", "patch": "@@ -1,15 +0,0 @@\n-/*\n-REQUIRED_ARGS:\n-PERMUTE_ARGS:\n-TEST_OUTPUT:\n----\n-fail_compilation/test16002.d(100): Error: undefined identifier `imports.nonexistent`\n-fail_compilation/test16002.d(101): Error: undefined identifier `imports.nonexistent`\n----\n-*/\n-\n-module test.fail_compilation.test16002;\n-\n-#line 100\n-enum A = is(imports.nonexistent == package);\n-enum B = is(imports.nonexistent == module);"}, {"sha": "a4d959f4626fc079aad6cb666e6c70558cb4cf29", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21651.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21651.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21651.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21651.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,11 @@\n+// REQUIRED_ARGS: -de\n+// EXTRA_SOURCES: imports/test21651b.d\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test21651.d(11): Deprecation: module imports.test21651b is not accessible here, perhaps add 'static import imports.test21651b;'\n+---\n+*/\n+\n+module imports.test21651;\n+\n+imports.test21651b.T a;"}, {"sha": "06c998d60052e18d40fa806fa61b8c8f7f5be445", "filename": "gcc/testsuite/gdc.test/fail_compilation/warn12809.d", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fwarn12809.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fwarn12809.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fwarn12809.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -32,3 +32,44 @@ void test_unrachable3()\n \n     int x = 1;      // unreachable\n }\n+\n+/********************************************/\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/warn12809.d(108): Warning: statement is not reachable\n+fail_compilation/warn12809.d(115): Warning: statement is not reachable\n+fail_compilation/warn12809.d(122): Warning: statement is not reachable\n+Error: warnings are treated as errors\n+       Use -wi if you wish to treat warnings only as informational.\n+---\n+*/\n+\n+#line 100\n+\n+alias noreturn = typeof(*null);\n+\n+noreturn foo();\n+\n+void test1(ref int i)\n+{\n+    foo();\n+    i = 3;\n+}\n+\n+void test2()\n+{\n+    try foo();\n+    finally { }\n+    int x = 1;\n+}\n+\n+void test3()\n+{\n+    try { }\n+    finally foo();\n+    int x = 1;\n+}\n+\n+"}, {"sha": "c299badec1564e053eec7c4ecf6533e9c22500aa", "filename": "gcc/testsuite/gdc.test/runnable/funclit.d", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffunclit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffunclit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffunclit.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1241,6 +1241,66 @@ void test15794()\n     gun15794!(() => 0)(); // Line 26\n }\n \n+/***************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=16271\n+\n+ref auto funa16271(alias dg, T)(ref T a)\n+{\n+    return dg(a);\n+}\n+\n+ref auto func16271(alias dg)()\n+{\n+    return dg();\n+}\n+\n+void assign16271(T)(ref T a, T b)\n+{\n+    alias fun = ref (ref a) => a;\n+    fun(a) = b;\n+}\n+\n+void test16271()\n+{\n+    int x;\n+    (ref () => x )() = 1;           assert(x == 1);\n+    func16271!(ref () => x) = 2;    assert(x == 2);\n+    assign16271(x, 3);              assert(x == 3);\n+\n+    alias alx = func16271!(ref () => x);\n+    alx = 4;    assert(x == 4);\n+\n+    alias alf = ref (ref a) => a;\n+    auto  auf = ref (ref int a) => a;\n+    alf(x) = 5;    assert(x == 5);\n+    auf(x) = 6;    assert(x == 6);\n+\n+    assert((funa16271!(         ref    (ref a) => a)(x) += 1) == 7 );\n+    assert((funa16271!(function ref    (ref a) => a)(x) += 1) == 8 );\n+    assert((funa16271!(function ref int(ref a) => a)(x) += 1) == 9 );\n+    assert((funa16271!(delegate ref    (ref a) => a)(x) += 1) == 10);\n+    assert((funa16271!(delegate ref int(ref a) => a)(x) += 1) == 11);\n+    assert(x == 11);\n+\n+    alias aldc  = ref () @trusted @nogc { return x; };\n+    auto  audc  = ref () @safe nothrow  { return x; };\n+    alias alfuc = function ref (ref x) @trusted { return x; };\n+    alias aldec = delegate ref () @trusted { return x; };\n+    aldc()   = 12;    assert(x == 12);\n+    audc()   = 13;    assert(x == 13);\n+    alfuc(x) = 14;    assert(x == 14);\n+    aldec()  = 15;    assert(x == 15);\n+\n+    template T()\n+    {\n+        int x;\n+        alias alf = ref () => x;\n+        auto auf = ref () => x;\n+    }\n+    T!().alf() = 1;  assert(T!().x == 1);\n+    T!().auf() = 2;  assert(T!().x == 2);\n+}\n+\n /***************************************************/\n \n int main()\n@@ -1299,6 +1359,7 @@ int main()\n     test13879();\n     test14745();\n     test15794();\n+    test16271();\n \n     printf(\"Success\\n\");\n     return 0;"}, {"sha": "9a8420aa20bda49f0b97d17ee115774d0c788b79", "filename": "gcc/testsuite/gdc.test/runnable/mangle.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmangle.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -599,6 +599,12 @@ void fooB(void delegate (void delegate()) scope dg)\n //pragma(msg, fooB.mangleof);\n static assert(typeof(fooA).mangleof != typeof(fooB).mangleof);\n \n+/***************************************************/\n+\n+alias noreturn = typeof(*null);\n+alias fpd = noreturn function();\n+int funcd(fpd);\n+static assert(funcd.mangleof == \"_D6mangle5funcdFPFZNnZi\");\n \n /***************************************************/\n "}, {"sha": "447ea28294c39618539c85455d0df39efdd9ff7f", "filename": "gcc/testsuite/gdc.test/runnable/noreturn1.d", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,74 @@\n+alias noreturn = typeof(*null);\n+\n+extern (C) noreturn exit();\n+\n+/*****************************************/\n+\n+bool testf(int i)\n+{\n+    return i && assert(0);\n+}\n+\n+bool testt(int i)\n+{\n+    return i || assert(0);\n+}\n+\n+int testa(int i)\n+{\n+    if (i && exit())\n+        return i + 1;\n+    return i - 1;\n+}\n+\n+int testb(int i)\n+{\n+    if (i || exit())\n+        return i + 1;\n+    return i - 1;\n+}\n+\n+void test1()\n+{\n+    assert(testf(0) == false);\n+    assert(testt(1) == true);\n+\n+    assert(testa(0) == -1);\n+    assert(testb(3) == 4);\n+}\n+\n+/*****************************************/\n+\n+noreturn exit1() { assert(0); }\n+noreturn exit2() { assert(0); }\n+\n+\n+int heli1(int i)\n+{\n+    return i ? exit1() : i - 1;\n+}\n+\n+int heli2(int i)\n+{\n+    return i ? i - 1 : exit1();\n+}\n+\n+noreturn heli3(int i)\n+{\n+    return i ? exit1() : exit2();\n+}\n+\n+void test2()\n+{\n+    assert(heli1(0) == -1);\n+    assert(heli2(1) == 0);\n+}\n+\n+/*****************************************/\n+\n+int main()\n+{\n+    test1();\n+    test2();\n+    return 0;\n+}"}, {"sha": "cb576ba59a89a86edea723920f3ca9ccaeddba50", "filename": "gcc/testsuite/gdc.test/runnable_cxx/cppa.d", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -571,18 +571,20 @@ void test13289()\n     assert(f13289_cpp_test());\n }\n \n+version(Posix)\n+{\n+    enum __c_wchar_t : dchar;\n+}\n+else version(Windows)\n+{\n+    enum __c_wchar_t : wchar;\n+}\n+alias wchar_t = __c_wchar_t;\n extern(C++)\n {\n     bool f13289_cpp_test();\n \n-    version(Posix)\n-    {\n-        dchar f13289_cpp_wchar_t(dchar);\n-    }\n-    else version(Windows)\n-    {\n-        wchar f13289_cpp_wchar_t(wchar);\n-    }\n+    wchar_t f13289_cpp_wchar_t(wchar_t);\n \n     wchar f13289_d_wchar(wchar ch)\n     {\n@@ -606,6 +608,17 @@ extern(C++)\n             return ch;\n         }\n     }\n+    wchar_t f13289_d_wchar_t(wchar_t ch)\n+    {\n+        if (ch <= 'z' && ch >= 'a')\n+        {\n+            return cast(wchar_t)(ch - ('a' - 'A'));\n+        }\n+        else\n+        {\n+            return ch;\n+        }\n+    }\n }\n \n /****************************************/"}, {"sha": "823c6603878e00352c90151b62e26e315a8b3dbd", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/cppb.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcppb.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcppb.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcppb.cpp?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -412,8 +412,12 @@ wchar_t f13289_d_wchar(wchar_t ch);\n unsigned int f13289_d_dchar(unsigned int ch);\n #endif\n \n+wchar_t f13289_d_wchar_t(wchar_t ch);\n+\n bool f13289_cpp_test()\n {\n+    if (!(f13289_d_wchar_t(L'e') == L'E')) return false;\n+    if (!(f13289_d_wchar_t(L'F') == L'F')) return false;\n #if __linux__ || __APPLE__ || __FreeBSD__ || __OpenBSD__ || __sun || __NetBSD__\n     if (!(f13289_d_wchar((unsigned short)'c') == (unsigned short)'C')) return false;\n     if (!(f13289_d_wchar((unsigned short)'D') == (unsigned short)'D')) return false;"}, {"sha": "076777a268b11a966cc1a7f465e671c04b07292b", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/test21515.cpp", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest21515.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest21515.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest21515.cpp?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,82 @@\n+#include <assert.h>\n+#include <complex.h>\n+\n+// Use custom types for inspecting parts instead of including tgmath.h\n+union cfloat_t { _Complex float z; struct { float re; float im; }; };\n+union cdouble_t { _Complex double z; struct { double re; double im; }; };\n+union creal_t { _Complex long double z; struct { long double re; long double im; }; };\n+\n+// extern(C) tests\n+extern \"C\" _Complex float ccomplexf() { return 2.0f+I; }\n+extern \"C\" _Complex double ccomplex() { return 2.0+I; }\n+extern \"C\" _Complex long double ccomplexl() { return 2.0L+I; }\n+extern \"C\" void ccomplexf2(_Complex float c) { cfloat_t z = {c}; assert(z.re == 2 && z.im == 1); }\n+extern \"C\" void ccomplex2(_Complex double c) { cdouble_t z = {c}; assert(z.re == 2 && z.im == 1); }\n+extern \"C\" void ccomplexl2(_Complex long double c) { creal_t z = {c}; assert(z.re == 2 && z.im == 1); }\n+\n+// extern(C++) tests\n+_Complex float cpcomplexf() { return 2.0f+I; }\n+_Complex double cpcomplex() { return 2.0+I; }\n+_Complex long double cpcomplexl() { return 2.0L+I; }\n+void cpcomplexf(_Complex float c) { cfloat_t z = {c}; assert(z.re == 2 && z.im == 1); }\n+void cpcomplex(_Complex double c) { cdouble_t z = {c}; assert(z.re == 2 && z.im == 1); }\n+void cpcomplexl(_Complex long double c) { creal_t z = {c}; assert(z.re == 2 && z.im == 1); }\n+\n+// Struct tests\n+struct wrap_complexf { _Complex float c; };\n+struct wrap_complex { _Complex double c; };\n+struct wrap_complexl { _Complex long double c; };\n+\n+wrap_complexf wcomplexf()\n+{\n+    wrap_complexf s;\n+    s.c = 2.0f+I;\n+    return s;\n+}\n+\n+wrap_complex wcomplex()\n+{\n+    wrap_complex s;\n+    s.c = 2.0+I;\n+    return s;\n+}\n+\n+wrap_complexl wcomplexl()\n+{\n+    wrap_complexl s;\n+    s.c = 2.0L+I;\n+    return s;\n+}\n+\n+void wcomplexf(wrap_complexf s) { cfloat_t z = {s.c}; assert(z.re == 2 && z.im == 1); }\n+void wcomplex(wrap_complex s)   { cdouble_t z = {s.c}; assert(z.re == 2 && z.im == 1); }\n+void wcomplexl(wrap_complexl s) { creal_t z = {s.c}; assert(z.re == 2 && z.im == 1); }\n+\n+struct soft_complexf { float re; float im; };\n+struct soft_complex { double re; double im; };\n+struct soft_complexl { long double re; long double im; };\n+\n+soft_complexf scomplexf()\n+{\n+    soft_complexf s;\n+    s.re = 2.0f; s.im = 1.0f;\n+    return s;\n+}\n+\n+soft_complex scomplex()\n+{\n+    soft_complex s;\n+    s.re = 2.0; s.im = 1.0;\n+    return s;\n+}\n+\n+soft_complexl scomplexl()\n+{\n+    soft_complexl s;\n+    s.re = 2.0L; s.im = 1.0L;\n+    return s;\n+}\n+\n+void scomplexf(soft_complexf s) { assert(s.re == 2 && s.im == 1); }\n+void scomplex(soft_complex s)   { assert(s.re == 2 && s.im == 1); }\n+void scomplexl(soft_complexl s) { assert(s.re == 2 && s.im == 1); }"}, {"sha": "cc4420734a63bdb2fea3314ff352ffd75b6869f4", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test21515.d", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest21515.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest21515.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest21515.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,104 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21515\n+// EXTRA_CPP_SOURCES: test21515.cpp\n+// DISABLED: win32 win64\n+\n+// ABI layout of native complex\n+struct _Complex(T) { T re; T im; }\n+\n+// Special enum definitions.\n+version (Posix)\n+{\n+    align(float.alignof)  enum __c_complex_float : _Complex!float;\n+    align(double.alignof) enum __c_complex_double : _Complex!double;\n+    align(real.alignof)   enum __c_complex_real : _Complex!real;\n+}\n+else\n+{\n+    align(float.sizeof * 2)  enum __c_complex_float : _Complex!float;\n+    align(double.sizeof * 2) enum __c_complex_double : _Complex!double;\n+    align(real.alignof)      enum __c_complex_real : _Complex!real;\n+}\n+alias complex_float = __c_complex_float;\n+alias complex_double = __c_complex_double;\n+alias complex_real = __c_complex_real;\n+\n+extern(C) complex_float  ccomplexf();\n+extern(C) complex_double ccomplex();\n+extern(C) complex_real   ccomplexl();\n+extern(C) void           ccomplexf2(complex_float c);\n+extern(C) void           ccomplex2(complex_double c);\n+extern(C) void           ccomplexl2(complex_real c);\n+\n+extern(C++) complex_float  cpcomplexf();\n+extern(C++) complex_double cpcomplex();\n+extern(C++) complex_real   cpcomplexl();\n+extern(C++) void           cpcomplexf(complex_float c);\n+extern(C++) void           cpcomplex(complex_double c);\n+extern(C++) void           cpcomplexl(complex_real c);\n+\n+struct wrap_complexf { complex_float c; alias c this; };\n+struct wrap_complex  { complex_double c; alias c this; };\n+struct wrap_complexl { complex_real c; alias c this; };\n+\n+extern(C++) wrap_complexf wcomplexf();\n+extern(C++) wrap_complex  wcomplex();\n+extern(C++) wrap_complexl wcomplexl();\n+extern(C++) void          wcomplexf(wrap_complexf c);\n+extern(C++) void          wcomplex(wrap_complex c);\n+extern(C++) void          wcomplexl(wrap_complexl c);\n+\n+struct soft_complexf { float re; float im; };\n+struct soft_complex  { double re; double im; };\n+struct soft_complexl { real re; real im; };\n+\n+extern(C++) soft_complexf scomplexf();\n+extern(C++) soft_complex  scomplex();\n+extern(C++) soft_complexl scomplexl();\n+extern(C++) void          scomplexf(soft_complexf c);\n+extern(C++) void          scomplex(soft_complex c);\n+extern(C++) void          scomplexl(soft_complexl c);\n+\n+int main()\n+{\n+    auto a1 = ccomplexf();\n+    auto b1 = ccomplex();\n+    auto c1 = ccomplexl();\n+    assert(a1.re == 2 && a1.im == 1);\n+    assert(b1.re == 2 && b1.im == 1);\n+    assert(c1.re == 2 && c1.im == 1);\n+    ccomplexf2(a1);\n+    ccomplex2(b1);\n+    ccomplexl2(c1);\n+\n+    auto a2 = cpcomplexf();\n+    auto b2 = cpcomplex();\n+    auto c2 = cpcomplexl();\n+    assert(a2.re == 2 && a2.im == 1);\n+    assert(b2.re == 2 && b2.im == 1);\n+    assert(c2.re == 2 && c2.im == 1);\n+    cpcomplexf(a2);\n+    cpcomplex(b2);\n+    cpcomplexl(c2);\n+\n+    auto a3 = wcomplexf();\n+    auto b3 = wcomplex();\n+    auto c3 = wcomplexl();\n+    assert(a3.re == 2 && a3.im == 1);\n+    assert(b3.re == 2 && b3.im == 1);\n+    assert(c3.re == 2 && c3.im == 1);\n+    wcomplexf(a3);\n+    wcomplex(b3);\n+    wcomplexl(c3);\n+\n+    auto a4 = scomplexf();\n+    auto b4 = scomplex();\n+    auto c4 = scomplexl();\n+    assert(a4.re == 2 && a4.im == 1);\n+    assert(b4.re == 2 && b4.im == 1);\n+    assert(c4.re == 2 && c4.im == 1);\n+    scomplexf(a4);\n+    scomplex(b4);\n+    scomplexl(c4);\n+\n+    return 0;\n+}"}, {"sha": "b797682a4d93bb77db888e77b12ca713dad10f88", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,4 +1,4 @@\n-0fd4364c4a4eb2ce0ebb8f613092c5bed7a63bf9\n+483bc12977af3c1288fd52e7b4fa14b716896c5a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "2a5c793d7c11353e7ddbb40a48be8b856d7ee7c9", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -208,16 +208,17 @@ DRUNTIME_DSOURCES_BIONIC = core/sys/bionic/err.d \\\n \n DRUNTIME_DSOURCES_DARWIN = core/sys/darwin/crt_externs.d \\\n \tcore/sys/darwin/dlfcn.d core/sys/darwin/err.d \\\n-\tcore/sys/darwin/execinfo.d core/sys/darwin/ifaddrs.d \\\n-\tcore/sys/darwin/mach/dyld.d core/sys/darwin/mach/getsect.d \\\n-\tcore/sys/darwin/mach/kern_return.d core/sys/darwin/mach/loader.d \\\n-\tcore/sys/darwin/mach/nlist.d core/sys/darwin/mach/port.d \\\n-\tcore/sys/darwin/mach/semaphore.d core/sys/darwin/mach/stab.d \\\n-\tcore/sys/darwin/mach/thread_act.d core/sys/darwin/netinet/in_.d \\\n-\tcore/sys/darwin/pthread.d core/sys/darwin/stdlib.d \\\n-\tcore/sys/darwin/string.d core/sys/darwin/sys/attr.d \\\n-\tcore/sys/darwin/sys/cdefs.d core/sys/darwin/sys/event.d \\\n-\tcore/sys/darwin/sys/mman.d core/sys/darwin/sys/sysctl.d\n+\tcore/sys/darwin/execinfo.d core/sys/darwin/fcntl.d \\\n+\tcore/sys/darwin/ifaddrs.d core/sys/darwin/mach/dyld.d \\\n+\tcore/sys/darwin/mach/getsect.d core/sys/darwin/mach/kern_return.d \\\n+\tcore/sys/darwin/mach/loader.d core/sys/darwin/mach/nlist.d \\\n+\tcore/sys/darwin/mach/port.d core/sys/darwin/mach/semaphore.d \\\n+\tcore/sys/darwin/mach/stab.d core/sys/darwin/mach/thread_act.d \\\n+\tcore/sys/darwin/netinet/in_.d core/sys/darwin/pthread.d \\\n+\tcore/sys/darwin/stdlib.d core/sys/darwin/string.d \\\n+\tcore/sys/darwin/sys/attr.d core/sys/darwin/sys/cdefs.d \\\n+\tcore/sys/darwin/sys/event.d core/sys/darwin/sys/mman.d \\\n+\tcore/sys/darwin/sys/sysctl.d\n \n DRUNTIME_DSOURCES_DRAGONFLYBSD = core/sys/dragonflybsd/dlfcn.d \\\n \tcore/sys/dragonflybsd/err.d core/sys/dragonflybsd/execinfo.d \\\n@@ -275,7 +276,8 @@ DRUNTIME_DSOURCES_OPENBSD = core/sys/openbsd/dlfcn.d \\\n \tcore/sys/openbsd/sys/elf.d core/sys/openbsd/sys/elf32.d \\\n \tcore/sys/openbsd/sys/elf64.d core/sys/openbsd/sys/elf_common.d \\\n \tcore/sys/openbsd/sys/link_elf.d core/sys/openbsd/sys/mman.d \\\n-\tcore/sys/openbsd/sys/sysctl.d core/sys/openbsd/time.d\n+\tcore/sys/openbsd/sys/sysctl.d core/sys/openbsd/time.d \\\n+\tcore/sys/openbsd/unistd.d\n \n DRUNTIME_DSOURCES_POSIX = core/sys/posix/aio.d \\\n \tcore/sys/posix/arpa/inet.d core/sys/posix/config.d \\\n@@ -382,22 +384,22 @@ DRUNTIME_DSOURCES_WINDOWS = core/sys/windows/accctrl.d \\\n \tcore/sys/windows/sqlext.d core/sys/windows/sqltypes.d \\\n \tcore/sys/windows/sqlucode.d core/sys/windows/sspi.d \\\n \tcore/sys/windows/stacktrace.d core/sys/windows/stat.d \\\n-\tcore/sys/windows/stdc/time.d core/sys/windows/subauth.d \\\n-\tcore/sys/windows/threadaux.d core/sys/windows/tlhelp32.d \\\n-\tcore/sys/windows/tmschema.d core/sys/windows/unknwn.d \\\n-\tcore/sys/windows/uuid.d core/sys/windows/vfw.d \\\n-\tcore/sys/windows/w32api.d core/sys/windows/winbase.d \\\n-\tcore/sys/windows/winber.d core/sys/windows/wincon.d \\\n-\tcore/sys/windows/wincrypt.d core/sys/windows/windef.d \\\n-\tcore/sys/windows/windows.d core/sys/windows/winerror.d \\\n-\tcore/sys/windows/wingdi.d core/sys/windows/winhttp.d \\\n-\tcore/sys/windows/wininet.d core/sys/windows/winioctl.d \\\n-\tcore/sys/windows/winldap.d core/sys/windows/winnetwk.d \\\n-\tcore/sys/windows/winnls.d core/sys/windows/winnt.d \\\n-\tcore/sys/windows/winperf.d core/sys/windows/winreg.d \\\n-\tcore/sys/windows/winsock2.d core/sys/windows/winspool.d \\\n-\tcore/sys/windows/winsvc.d core/sys/windows/winuser.d \\\n-\tcore/sys/windows/winver.d core/sys/windows/wtsapi32.d \\\n-\tcore/sys/windows/wtypes.d\n+\tcore/sys/windows/stdc/malloc.d core/sys/windows/stdc/time.d \\\n+\tcore/sys/windows/subauth.d core/sys/windows/threadaux.d \\\n+\tcore/sys/windows/tlhelp32.d core/sys/windows/tmschema.d \\\n+\tcore/sys/windows/unknwn.d core/sys/windows/uuid.d \\\n+\tcore/sys/windows/vfw.d core/sys/windows/w32api.d \\\n+\tcore/sys/windows/winbase.d core/sys/windows/winber.d \\\n+\tcore/sys/windows/wincon.d core/sys/windows/wincrypt.d \\\n+\tcore/sys/windows/windef.d core/sys/windows/windows.d \\\n+\tcore/sys/windows/winerror.d core/sys/windows/wingdi.d \\\n+\tcore/sys/windows/winhttp.d core/sys/windows/wininet.d \\\n+\tcore/sys/windows/winioctl.d core/sys/windows/winldap.d \\\n+\tcore/sys/windows/winnetwk.d core/sys/windows/winnls.d \\\n+\tcore/sys/windows/winnt.d core/sys/windows/winperf.d \\\n+\tcore/sys/windows/winreg.d core/sys/windows/winsock2.d \\\n+\tcore/sys/windows/winspool.d core/sys/windows/winsvc.d \\\n+\tcore/sys/windows/winuser.d core/sys/windows/winver.d \\\n+\tcore/sys/windows/wtsapi32.d core/sys/windows/wtypes.d\n \n DRUNTIME_DISOURCES = __entrypoint.di __main.di"}, {"sha": "b00fe022cfa1bb15f3fc996717c65fa046391e12", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -256,8 +256,9 @@ am__objects_3 = core/sys/posix/aio.lo core/sys/posix/arpa/inet.lo \\\n @DRUNTIME_OS_POSIX_TRUE@am__objects_4 = $(am__objects_3)\n am__objects_5 = core/sys/darwin/crt_externs.lo \\\n \tcore/sys/darwin/dlfcn.lo core/sys/darwin/err.lo \\\n-\tcore/sys/darwin/execinfo.lo core/sys/darwin/ifaddrs.lo \\\n-\tcore/sys/darwin/mach/dyld.lo core/sys/darwin/mach/getsect.lo \\\n+\tcore/sys/darwin/execinfo.lo core/sys/darwin/fcntl.lo \\\n+\tcore/sys/darwin/ifaddrs.lo core/sys/darwin/mach/dyld.lo \\\n+\tcore/sys/darwin/mach/getsect.lo \\\n \tcore/sys/darwin/mach/kern_return.lo \\\n \tcore/sys/darwin/mach/loader.lo core/sys/darwin/mach/nlist.lo \\\n \tcore/sys/darwin/mach/port.lo core/sys/darwin/mach/semaphore.lo \\\n@@ -322,7 +323,8 @@ am__objects_15 = core/sys/openbsd/dlfcn.lo core/sys/openbsd/err.lo \\\n \tcore/sys/openbsd/sys/elf32.lo core/sys/openbsd/sys/elf64.lo \\\n \tcore/sys/openbsd/sys/elf_common.lo \\\n \tcore/sys/openbsd/sys/link_elf.lo core/sys/openbsd/sys/mman.lo \\\n-\tcore/sys/openbsd/sys/sysctl.lo core/sys/openbsd/time.lo\n+\tcore/sys/openbsd/sys/sysctl.lo core/sys/openbsd/time.lo \\\n+\tcore/sys/openbsd/unistd.lo\n @DRUNTIME_OS_OPENBSD_TRUE@am__objects_16 = $(am__objects_15)\n am__objects_17 = core/sys/linux/config.lo core/sys/linux/dlfcn.lo \\\n \tcore/sys/linux/elf.lo core/sys/linux/epoll.lo \\\n@@ -408,23 +410,24 @@ am__objects_19 = core/sys/windows/accctrl.lo \\\n \tcore/sys/windows/sql.lo core/sys/windows/sqlext.lo \\\n \tcore/sys/windows/sqltypes.lo core/sys/windows/sqlucode.lo \\\n \tcore/sys/windows/sspi.lo core/sys/windows/stacktrace.lo \\\n-\tcore/sys/windows/stat.lo core/sys/windows/stdc/time.lo \\\n-\tcore/sys/windows/subauth.lo core/sys/windows/threadaux.lo \\\n-\tcore/sys/windows/tlhelp32.lo core/sys/windows/tmschema.lo \\\n-\tcore/sys/windows/unknwn.lo core/sys/windows/uuid.lo \\\n-\tcore/sys/windows/vfw.lo core/sys/windows/w32api.lo \\\n-\tcore/sys/windows/winbase.lo core/sys/windows/winber.lo \\\n-\tcore/sys/windows/wincon.lo core/sys/windows/wincrypt.lo \\\n-\tcore/sys/windows/windef.lo core/sys/windows/windows.lo \\\n-\tcore/sys/windows/winerror.lo core/sys/windows/wingdi.lo \\\n-\tcore/sys/windows/winhttp.lo core/sys/windows/wininet.lo \\\n-\tcore/sys/windows/winioctl.lo core/sys/windows/winldap.lo \\\n-\tcore/sys/windows/winnetwk.lo core/sys/windows/winnls.lo \\\n-\tcore/sys/windows/winnt.lo core/sys/windows/winperf.lo \\\n-\tcore/sys/windows/winreg.lo core/sys/windows/winsock2.lo \\\n-\tcore/sys/windows/winspool.lo core/sys/windows/winsvc.lo \\\n-\tcore/sys/windows/winuser.lo core/sys/windows/winver.lo \\\n-\tcore/sys/windows/wtsapi32.lo core/sys/windows/wtypes.lo\n+\tcore/sys/windows/stat.lo core/sys/windows/stdc/malloc.lo \\\n+\tcore/sys/windows/stdc/time.lo core/sys/windows/subauth.lo \\\n+\tcore/sys/windows/threadaux.lo core/sys/windows/tlhelp32.lo \\\n+\tcore/sys/windows/tmschema.lo core/sys/windows/unknwn.lo \\\n+\tcore/sys/windows/uuid.lo core/sys/windows/vfw.lo \\\n+\tcore/sys/windows/w32api.lo core/sys/windows/winbase.lo \\\n+\tcore/sys/windows/winber.lo core/sys/windows/wincon.lo \\\n+\tcore/sys/windows/wincrypt.lo core/sys/windows/windef.lo \\\n+\tcore/sys/windows/windows.lo core/sys/windows/winerror.lo \\\n+\tcore/sys/windows/wingdi.lo core/sys/windows/winhttp.lo \\\n+\tcore/sys/windows/wininet.lo core/sys/windows/winioctl.lo \\\n+\tcore/sys/windows/winldap.lo core/sys/windows/winnetwk.lo \\\n+\tcore/sys/windows/winnls.lo core/sys/windows/winnt.lo \\\n+\tcore/sys/windows/winperf.lo core/sys/windows/winreg.lo \\\n+\tcore/sys/windows/winsock2.lo core/sys/windows/winspool.lo \\\n+\tcore/sys/windows/winsvc.lo core/sys/windows/winuser.lo \\\n+\tcore/sys/windows/winver.lo core/sys/windows/wtsapi32.lo \\\n+\tcore/sys/windows/wtypes.lo\n @DRUNTIME_OS_MINGW_TRUE@am__objects_20 = $(am__objects_19)\n am__objects_21 = core/sys/solaris/dlfcn.lo core/sys/solaris/elf.lo \\\n \tcore/sys/solaris/err.lo core/sys/solaris/execinfo.lo \\\n@@ -837,16 +840,17 @@ DRUNTIME_DSOURCES_BIONIC = core/sys/bionic/err.d \\\n \n DRUNTIME_DSOURCES_DARWIN = core/sys/darwin/crt_externs.d \\\n \tcore/sys/darwin/dlfcn.d core/sys/darwin/err.d \\\n-\tcore/sys/darwin/execinfo.d core/sys/darwin/ifaddrs.d \\\n-\tcore/sys/darwin/mach/dyld.d core/sys/darwin/mach/getsect.d \\\n-\tcore/sys/darwin/mach/kern_return.d core/sys/darwin/mach/loader.d \\\n-\tcore/sys/darwin/mach/nlist.d core/sys/darwin/mach/port.d \\\n-\tcore/sys/darwin/mach/semaphore.d core/sys/darwin/mach/stab.d \\\n-\tcore/sys/darwin/mach/thread_act.d core/sys/darwin/netinet/in_.d \\\n-\tcore/sys/darwin/pthread.d core/sys/darwin/stdlib.d \\\n-\tcore/sys/darwin/string.d core/sys/darwin/sys/attr.d \\\n-\tcore/sys/darwin/sys/cdefs.d core/sys/darwin/sys/event.d \\\n-\tcore/sys/darwin/sys/mman.d core/sys/darwin/sys/sysctl.d\n+\tcore/sys/darwin/execinfo.d core/sys/darwin/fcntl.d \\\n+\tcore/sys/darwin/ifaddrs.d core/sys/darwin/mach/dyld.d \\\n+\tcore/sys/darwin/mach/getsect.d core/sys/darwin/mach/kern_return.d \\\n+\tcore/sys/darwin/mach/loader.d core/sys/darwin/mach/nlist.d \\\n+\tcore/sys/darwin/mach/port.d core/sys/darwin/mach/semaphore.d \\\n+\tcore/sys/darwin/mach/stab.d core/sys/darwin/mach/thread_act.d \\\n+\tcore/sys/darwin/netinet/in_.d core/sys/darwin/pthread.d \\\n+\tcore/sys/darwin/stdlib.d core/sys/darwin/string.d \\\n+\tcore/sys/darwin/sys/attr.d core/sys/darwin/sys/cdefs.d \\\n+\tcore/sys/darwin/sys/event.d core/sys/darwin/sys/mman.d \\\n+\tcore/sys/darwin/sys/sysctl.d\n \n DRUNTIME_DSOURCES_DRAGONFLYBSD = core/sys/dragonflybsd/dlfcn.d \\\n \tcore/sys/dragonflybsd/err.d core/sys/dragonflybsd/execinfo.d \\\n@@ -904,7 +908,8 @@ DRUNTIME_DSOURCES_OPENBSD = core/sys/openbsd/dlfcn.d \\\n \tcore/sys/openbsd/sys/elf.d core/sys/openbsd/sys/elf32.d \\\n \tcore/sys/openbsd/sys/elf64.d core/sys/openbsd/sys/elf_common.d \\\n \tcore/sys/openbsd/sys/link_elf.d core/sys/openbsd/sys/mman.d \\\n-\tcore/sys/openbsd/sys/sysctl.d core/sys/openbsd/time.d\n+\tcore/sys/openbsd/sys/sysctl.d core/sys/openbsd/time.d \\\n+\tcore/sys/openbsd/unistd.d\n \n DRUNTIME_DSOURCES_POSIX = core/sys/posix/aio.d \\\n \tcore/sys/posix/arpa/inet.d core/sys/posix/config.d \\\n@@ -1011,23 +1016,23 @@ DRUNTIME_DSOURCES_WINDOWS = core/sys/windows/accctrl.d \\\n \tcore/sys/windows/sqlext.d core/sys/windows/sqltypes.d \\\n \tcore/sys/windows/sqlucode.d core/sys/windows/sspi.d \\\n \tcore/sys/windows/stacktrace.d core/sys/windows/stat.d \\\n-\tcore/sys/windows/stdc/time.d core/sys/windows/subauth.d \\\n-\tcore/sys/windows/threadaux.d core/sys/windows/tlhelp32.d \\\n-\tcore/sys/windows/tmschema.d core/sys/windows/unknwn.d \\\n-\tcore/sys/windows/uuid.d core/sys/windows/vfw.d \\\n-\tcore/sys/windows/w32api.d core/sys/windows/winbase.d \\\n-\tcore/sys/windows/winber.d core/sys/windows/wincon.d \\\n-\tcore/sys/windows/wincrypt.d core/sys/windows/windef.d \\\n-\tcore/sys/windows/windows.d core/sys/windows/winerror.d \\\n-\tcore/sys/windows/wingdi.d core/sys/windows/winhttp.d \\\n-\tcore/sys/windows/wininet.d core/sys/windows/winioctl.d \\\n-\tcore/sys/windows/winldap.d core/sys/windows/winnetwk.d \\\n-\tcore/sys/windows/winnls.d core/sys/windows/winnt.d \\\n-\tcore/sys/windows/winperf.d core/sys/windows/winreg.d \\\n-\tcore/sys/windows/winsock2.d core/sys/windows/winspool.d \\\n-\tcore/sys/windows/winsvc.d core/sys/windows/winuser.d \\\n-\tcore/sys/windows/winver.d core/sys/windows/wtsapi32.d \\\n-\tcore/sys/windows/wtypes.d\n+\tcore/sys/windows/stdc/malloc.d core/sys/windows/stdc/time.d \\\n+\tcore/sys/windows/subauth.d core/sys/windows/threadaux.d \\\n+\tcore/sys/windows/tlhelp32.d core/sys/windows/tmschema.d \\\n+\tcore/sys/windows/unknwn.d core/sys/windows/uuid.d \\\n+\tcore/sys/windows/vfw.d core/sys/windows/w32api.d \\\n+\tcore/sys/windows/winbase.d core/sys/windows/winber.d \\\n+\tcore/sys/windows/wincon.d core/sys/windows/wincrypt.d \\\n+\tcore/sys/windows/windef.d core/sys/windows/windows.d \\\n+\tcore/sys/windows/winerror.d core/sys/windows/wingdi.d \\\n+\tcore/sys/windows/winhttp.d core/sys/windows/wininet.d \\\n+\tcore/sys/windows/winioctl.d core/sys/windows/winldap.d \\\n+\tcore/sys/windows/winnetwk.d core/sys/windows/winnls.d \\\n+\tcore/sys/windows/winnt.d core/sys/windows/winperf.d \\\n+\tcore/sys/windows/winreg.d core/sys/windows/winsock2.d \\\n+\tcore/sys/windows/winspool.d core/sys/windows/winsvc.d \\\n+\tcore/sys/windows/winuser.d core/sys/windows/winver.d \\\n+\tcore/sys/windows/wtsapi32.d core/sys/windows/wtypes.d\n \n DRUNTIME_DISOURCES = __entrypoint.di __main.di\n all: all-am\n@@ -1346,6 +1351,7 @@ core/sys/darwin/crt_externs.lo: core/sys/darwin/$(am__dirstamp)\n core/sys/darwin/dlfcn.lo: core/sys/darwin/$(am__dirstamp)\n core/sys/darwin/err.lo: core/sys/darwin/$(am__dirstamp)\n core/sys/darwin/execinfo.lo: core/sys/darwin/$(am__dirstamp)\n+core/sys/darwin/fcntl.lo: core/sys/darwin/$(am__dirstamp)\n core/sys/darwin/ifaddrs.lo: core/sys/darwin/$(am__dirstamp)\n core/sys/darwin/mach/$(am__dirstamp):\n \t@$(MKDIR_P) core/sys/darwin/mach\n@@ -1510,6 +1516,7 @@ core/sys/openbsd/sys/link_elf.lo:  \\\n core/sys/openbsd/sys/mman.lo: core/sys/openbsd/sys/$(am__dirstamp)\n core/sys/openbsd/sys/sysctl.lo: core/sys/openbsd/sys/$(am__dirstamp)\n core/sys/openbsd/time.lo: core/sys/openbsd/$(am__dirstamp)\n+core/sys/openbsd/unistd.lo: core/sys/openbsd/$(am__dirstamp)\n core/sys/linux/$(am__dirstamp):\n \t@$(MKDIR_P) core/sys/linux\n \t@: > core/sys/linux/$(am__dirstamp)\n@@ -1690,6 +1697,8 @@ core/sys/windows/stat.lo: core/sys/windows/$(am__dirstamp)\n core/sys/windows/stdc/$(am__dirstamp):\n \t@$(MKDIR_P) core/sys/windows/stdc\n \t@: > core/sys/windows/stdc/$(am__dirstamp)\n+core/sys/windows/stdc/malloc.lo:  \\\n+\tcore/sys/windows/stdc/$(am__dirstamp)\n core/sys/windows/stdc/time.lo: core/sys/windows/stdc/$(am__dirstamp)\n core/sys/windows/subauth.lo: core/sys/windows/$(am__dirstamp)\n core/sys/windows/threadaux.lo: core/sys/windows/$(am__dirstamp)"}, {"sha": "b84651f3f15f630909172ef9626553a82c936556", "filename": "libphobos/libdruntime/core/stdc/complex.d", "status": "modified", "additions": 2, "deletions": 68, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fcomplex.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -19,163 +19,97 @@ extern (C):\n nothrow:\n @nogc:\n \n-///\n+// @@@DEPRECATED_2.105@@@\n+deprecated:\n alias creal complex;\n-///\n alias ireal imaginary;\n-///\n cdouble cacos(cdouble z);\n-///\n cfloat  cacosf(cfloat z);\n-///\n creal   cacosl(creal z);\n \n-///\n cdouble casin(cdouble z);\n-///\n cfloat  casinf(cfloat z);\n-///\n creal   casinl(creal z);\n \n-///\n cdouble catan(cdouble z);\n-///\n cfloat  catanf(cfloat z);\n-///\n creal   catanl(creal z);\n \n-///\n cdouble ccos(cdouble z);\n-///\n cfloat  ccosf(cfloat z);\n-///\n creal   ccosl(creal z);\n \n-///\n cdouble csin(cdouble z);\n-///\n cfloat  csinf(cfloat z);\n-///\n creal   csinl(creal z);\n \n-///\n cdouble ctan(cdouble z);\n-///\n cfloat  ctanf(cfloat z);\n-///\n creal   ctanl(creal z);\n \n-///\n cdouble cacosh(cdouble z);\n-///\n cfloat  cacoshf(cfloat z);\n-///\n creal   cacoshl(creal z);\n \n-///\n cdouble casinh(cdouble z);\n-///\n cfloat  casinhf(cfloat z);\n-///\n creal   casinhl(creal z);\n \n-///\n cdouble catanh(cdouble z);\n-///\n cfloat  catanhf(cfloat z);\n-///\n creal   catanhl(creal z);\n \n-///\n cdouble ccosh(cdouble z);\n-///\n cfloat  ccoshf(cfloat z);\n-///\n creal   ccoshl(creal z);\n \n-///\n cdouble csinh(cdouble z);\n-///\n cfloat  csinhf(cfloat z);\n-///\n creal   csinhl(creal z);\n \n-///\n cdouble ctanh(cdouble z);\n-///\n cfloat  ctanhf(cfloat z);\n-///\n creal   ctanhl(creal z);\n \n-///\n cdouble cexp(cdouble z);\n-///\n cfloat  cexpf(cfloat z);\n-///\n creal   cexpl(creal z);\n \n-///\n cdouble clog(cdouble z);\n-///\n cfloat  clogf(cfloat z);\n-///\n creal   clogl(creal z);\n \n-///\n  double cabs(cdouble z);\n- ///\n  float  cabsf(cfloat z);\n- ///\n  real   cabsl(creal z);\n \n- ///\n cdouble cpow(cdouble x, cdouble y);\n-///\n cfloat  cpowf(cfloat x, cfloat y);\n-///\n creal   cpowl(creal x, creal y);\n \n-///\n cdouble csqrt(cdouble z);\n-///\n cfloat  csqrtf(cfloat z);\n-///\n creal   csqrtl(creal z);\n \n-///\n  double carg(cdouble z);\n- ///\n  float  cargf(cfloat z);\n- ///\n  real   cargl(creal z);\n \n-///\n pragma(inline, true) double cimag(cdouble z) { return z.im; }\n-///\n pragma(inline, true) float  cimagf(cfloat z) { return z.im; }\n-///\n pragma(inline, true) real   cimagl(creal z)  { return z.im; }\n \n-///\n cdouble conj(cdouble z);\n-///\n cfloat  conjf(cfloat z);\n-///\n creal   conjl(creal z);\n \n-///\n cdouble cproj(cdouble z);\n-///\n cfloat  cprojf(cfloat z);\n-///\n creal   cprojl(creal z);\n \n // Note: `creal` is a keyword in D and so this function is inaccessible, use `creald` instead\n //pragma(inline, true) double creal(cdouble z) { return z.re; }\n \n-///\n pragma(inline, true) double creald(cdouble z) { return z.re; }\n-///\n pragma(inline, true) float  crealf(cfloat z) { return z.re; }\n-///\n pragma(inline, true) real   creall(creal z)  { return z.re; }"}, {"sha": "802f5b6fb21470bf6b385cbaf9599ef3ebf98fb9", "filename": "libphobos/libdruntime/core/stdc/config.d", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -34,6 +34,7 @@ version (StdDdoc)\n             alias ddoc_long = int;\n             alias ddoc_ulong = uint;\n         }\n+        struct ddoc_complex(T) { T re; T im; };\n     }\n \n     /***\n@@ -89,6 +90,24 @@ version (StdDdoc)\n      * C++ compiler's `ptrdiff_t` type.\n      */\n     alias cpp_ptrdiff_t = ptrdiff_t;\n+\n+    /***\n+     * Used for a complex floating point type that corresponds in size and ABI to the associated\n+     * C compiler's `_Complex float` type.\n+     */\n+    alias c_complex_float = ddoc_complex!float;\n+\n+    /***\n+     * Used for a complex floating point type that corresponds in size and ABI to the associated\n+     * C compiler's `_Complex double` type.\n+     */\n+    alias c_complex_double = ddoc_complex!double;\n+\n+    /***\n+     * Used for a complex floating point type that corresponds in size and ABI to the associated\n+     * C compiler's `_Complex long double` type.\n+     */\n+    alias c_complex_real = ddoc_complex!real;\n }\n else\n {\n@@ -230,4 +249,28 @@ else\n     alias cpp_size_t = size_t;\n     alias cpp_ptrdiff_t = ptrdiff_t;\n }\n+\n+// ABI layout of native complex types.\n+private struct _Complex(T)\n+{\n+    T re;\n+    T im;\n+}\n+\n+version (Posix)\n+{\n+    align(float.alignof)  enum __c_complex_float : _Complex!float;\n+    align(double.alignof) enum __c_complex_double : _Complex!double;\n+    align(real.alignof)   enum __c_complex_real : _Complex!real;\n+}\n+else\n+{\n+    align(float.sizeof * 2)  enum __c_complex_float : _Complex!float;\n+    align(double.sizeof * 2) enum __c_complex_double : _Complex!double;\n+    align(real.alignof)      enum __c_complex_real : _Complex!real;\n+}\n+\n+alias c_complex_float = __c_complex_float;\n+alias c_complex_double = __c_complex_double;\n+alias c_complex_real = __c_complex_real;\n }"}, {"sha": "57bc15da6eb81c133df159e757f53ba2c54a1900", "filename": "libphobos/libdruntime/core/stdc/errno.d", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ferrno.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ferrno.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ferrno.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -156,15 +156,9 @@ else version (Haiku)\n else\n {\n     ///\n-    @property int errno() { return getErrno(); }\n+    extern(C) pragma(mangle, \"getErrno\") @property int errno();\n     ///\n-    @property int errno(int n) { return setErrno(n); }\n-\n-    extern (C)\n-    {\n-        private int getErrno();      // for internal use\n-        private int setErrno(int);   // for internal use\n-    }\n+    extern(C) pragma(mangle, \"setErrno\") @property int errno(int n);\n }\n \n extern (C):\n@@ -1532,7 +1526,11 @@ else version (OpenBSD)\n     enum EIDRM              = 89;       /// Identifier removed\n     enum ENOMSG             = 90;       /// No message of desired type\n     enum ENOTSUP            = 91;       /// Not supported\n-    enum ELAST              = 91;       /// Must be equal largest errno\n+    enum EBADMSG            = 92;       /// Bad message\n+    enum ENOTRECOVERABLE    = 93;       /// State not recoverable\n+    enum EOWNERDEAD         = 94;       /// Previous owner died\n+    enum EPROTO             = 95;       /// Protocol error\n+    enum ELAST              = 95;       /// Must be equal largest errno\n }\n else version (DragonFlyBSD)\n {"}, {"sha": "fba78ee233a2dac51428db56b9bb18802857b689", "filename": "libphobos/libdruntime/core/stdc/math.d", "status": "modified", "additions": 160, "deletions": 240, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -319,16 +319,12 @@ version (CRuntime_DigitalMars)\n   {\n     //int fpclassify(real-floating x);\n     ///\n-    pure int fpclassify(float x)     { return __fpclassify_f(x); }\n+    extern(C) pragma(mangle, \"__fpclassify_f\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassify_d(x); }\n+    extern(C) pragma(mangle, \"__fpclassify_d\") pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __fpclassify_d(x)\n-            : __fpclassify_ld(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassify_d\" : \"__fpclassify_ld\")\n+    pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n@@ -442,24 +438,18 @@ else version (CRuntime_Microsoft) // fully supported since MSVCRT 12 (VS 2013) o\n         FP_NAN       =  2,\n     }\n \n-    pure private short _fdclass(float x);\n-    pure private short _dclass(double x);\n-\n-    pure private int _fdsign(float x);\n-    pure private int _dsign(double x);\n-\n   extern(D)\n   {\n     //int fpclassify(real-floating x);\n     ///\n-    pure int fpclassify()(float x)   { return _fdclass(x); }\n+    extern(C) pragma(mangle, \"_fdclass\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify()(double x)  { return _dclass(x);  }\n+    extern(C) pragma(mangle, \"_dclass\")  pure int fpclassify(double x);\n     ///\n     pure int fpclassify()(real x)\n     {\n         static if (real.sizeof == double.sizeof)\n-            return _dclass(cast(double) x);\n+            return fpclassify(cast(double) x);\n         else\n             static assert(false, \"fpclassify(real) not supported by MS C runtime\");\n     }\n@@ -495,7 +485,7 @@ else version (CRuntime_Microsoft) // fully supported since MSVCRT 12 (VS 2013) o\n         ///\n         pure int isnan(float x)      { version (Win64) return _isnanf(x); else return _isnan(cast(double) x); }\n         ///\n-        pure int isnan(double x)     { return _isnan(x); }\n+        extern(C) pragma(mangle, \"_isnan\") pure int isnan(double x);\n         ///\n         pure int isnan(real x)       { return _isnan(cast(double) x); }\n     }\n@@ -510,14 +500,14 @@ else version (CRuntime_Microsoft) // fully supported since MSVCRT 12 (VS 2013) o\n \n     //int signbit(real-floating x);\n     ///\n-    pure int signbit()(float x)   { return _fdsign(x); }\n+    extern(C) pragma(mangle, \"_fdsign\") pure int signbit(float x);\n     ///\n-    pure int signbit()(double x)  { return _dsign(x);  }\n+    extern(C) pragma(mangle, \"_dsign\")  pure int signbit(double x);\n     ///\n     pure int signbit()(real x)\n     {\n         static if (real.sizeof == double.sizeof)\n-            return _dsign(cast(double) x);\n+            return signbit(cast(double) x);\n         else\n             return (cast(short*)&(x))[4] & 0x8000;\n     }\n@@ -573,55 +563,39 @@ else version (CRuntime_Glibc)\n   {\n     //int fpclassify(real-floating x);\n       ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassify(x);  }\n+    extern(C) pragma(mangle, \"__fpclassify\")  pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __fpclassify(x)\n-            : __fpclassifyl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassify\" : \"__fpclassifyl\")\n+    pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n-    pure int isfinite(float x)       { return __finitef(x); }\n+    extern(C) pragma(mangle, \"__finitef\") pure int isfinite(float x);\n     ///\n-    pure int isfinite(double x)      { return __finite(x);  }\n+    extern(C) pragma(mangle, \"__finite\")  pure int isfinite(double x);\n     ///\n-    pure int isfinite(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __finite(x)\n-            : __finitel(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__finite\" : \"__finitel\")\n+    pure int isfinite(real x);\n \n     //int isinf(real-floating x);\n     ///\n-    pure int isinf(float x)          { return __isinff(x);  }\n+    extern(C) pragma(mangle, \"__isinff\") pure int isinf(float x);\n     ///\n-    pure int isinf(double x)         { return __isinf(x);   }\n+    extern(C) pragma(mangle, \"__isinf\")  pure int isinf(double x);\n     ///\n-    pure int isinf(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __isinf(x)\n-            : __isinfl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__isinf\" : \"__isinfl\")\n+    pure int isinf(real x);\n \n     //int isnan(real-floating x);\n     ///\n-    pure int isnan(float x)          { return __isnanf(x);  }\n+    extern(C) pragma(mangle, \"__isnanf\") pure int isnan(float x);\n     ///\n-    pure int isnan(double x)         { return __isnan(x);   }\n+    extern(C) pragma(mangle, \"__isnan\")  pure int isnan(double x);\n     ///\n-    pure int isnan(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __isnan(x)\n-            : __isnanl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__isnan\" : \"__isnanl\")\n+    pure int isnan(real x);\n \n     //int isnormal(real-floating x);\n     ///\n@@ -633,16 +607,12 @@ else version (CRuntime_Glibc)\n \n     //int signbit(real-floating x);\n     ///\n-    pure int signbit(float x)     { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    pure int signbit(double x)    { return __signbit(x);  }\n+    extern(C) pragma(mangle, \"__signbit\")  pure int signbit(double x);\n     ///\n-    pure int signbit(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __signbit(x)\n-            : __signbitl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__signbit\" : \"__signbitl\")\n+    pure int signbit(real x);\n   }\n }\n else version (CRuntime_Musl)\n@@ -685,16 +655,12 @@ else version (CRuntime_Musl)\n   {\n     //int fpclassify(real-floating x);\n       ///\n-    int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") int fpclassify(float x);\n     ///\n-    int fpclassify(double x)    { return __fpclassify(x);  }\n+    extern(C) pragma(mangle, \"__fpclassify\")  int fpclassify(double x);\n     ///\n-    int fpclassify(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __fpclassify(x)\n-            : __fpclassifyl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassify\" : \"__fpclassifyl\")\n+    int fpclassify(real x);\n     private uint __FLOAT_BITS(float __f)\n     {\n         union __u_t {\n@@ -765,16 +731,12 @@ else version (CRuntime_Musl)\n \n     //int signbit(real-floating x);\n     ///\n-    int signbit(float x)     { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") int signbit(float x);\n     ///\n-    int signbit(double x)    { return __signbit(x);  }\n+    extern(C) pragma(mangle, \"__signbit\")  int signbit(double x);\n     ///\n-    int signbit(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __signbit(x)\n-            : __signbitl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__signbit\" : \"__signbitl\")\n+    int signbit(real x);\n   }\n }\n else version (CRuntime_UClibc)\n@@ -826,52 +788,36 @@ else version (CRuntime_UClibc)\n   extern (D)\n   {\n     ///\n-    int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") int fpclassify(float x);\n     ///\n-    int fpclassify(double x)    { return __fpclassify(x);  }\n+    extern(C) pragma(mangle, \"__fpclassify\")  int fpclassify(double x);\n     ///\n-    int fpclassify(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __fpclassify(x)\n-            : __fpclassifyl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassify\" : \"__fpclassifyl\")\n+    int fpclassify(real x);\n \n     ///\n-    int isfinite(float x)       { return __finitef(x); }\n+    extern(C) pragma(mangle, \"__finitef\") int isfinite(float x);\n     ///\n-    int isfinite(double x)      { return __finite(x);  }\n+    extern(C) pragma(mangle, \"__finite\")  int isfinite(double x);\n     ///\n-    int isfinite(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __finite(x)\n-            : __finitel(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__finite\" : \"__finitel\")\n+    int isfinite(real x);\n \n     ///\n-    int isinf(float x)          { return __isinff(x);  }\n+    extern(C) pragma(mangle, \"__isinff\") int isinf(float x);\n     ///\n-    int isinf(double x)         { return __isinf(x);   }\n+    extern(C) pragma(mangle, \"__isinf\")  int isinf(double x);\n     ///\n-    int isinf(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __isinf(x)\n-            : __isinfl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__isinf\" : \"__isinfl\")\n+    int isinf(real x);\n \n     ///\n-    int isnan(float x)          { return __isnanf(x);  }\n+    extern(C) pragma(mangle, \"__isnanf\") int isnan(float x);\n     ///\n-    int isnan(double x)         { return __isnan(x);   }\n+    extern(C) pragma(mangle, \"__isnan\")  int isnan(double x);\n     ///\n-    int isnan(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __isnan(x)\n-            : __isnanl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__isnan\" : \"__isnanl\")\n+    int isnan(real x);\n \n     ///\n     int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }\n@@ -881,16 +827,12 @@ else version (CRuntime_UClibc)\n     int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }\n \n     ///\n-    int signbit(float x)     { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") int signbit(float x);\n     ///\n-    int signbit(double x)    { return __signbit(x);  }\n+    extern(C) pragma(mangle, \"__signbit\")  int signbit(double x);\n     ///\n-    int signbit(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __signbit(x)\n-            : __signbitl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__signbit\" : \"__signbitl\")\n+    int signbit(real x);\n   }\n }\n else version (MinGW)\n@@ -925,16 +867,12 @@ else version (MinGW)\n   {\n     //int fpclassify(real-floating x);\n       ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassify(x);  }\n+    extern(C) pragma(mangle, \"__fpclassify\")  pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __fpclassify(x)\n-            : __fpclassifyl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassify\" : \"__fpclassifyl\")\n+    pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n@@ -954,16 +892,12 @@ else version (MinGW)\n \n     //int isnan(real-floating x);\n     ///\n-    pure int isnan(float x)          { return __isnanf(x);  }\n+    extern(C) pragma(mangle, \"__isnanf\") pure int isnan(float x);\n     ///\n-    pure int isnan(double x)         { return __isnan(x);   }\n+    extern(C) pragma(mangle, \"__isnan\")  pure int isnan(double x);\n     ///\n-    pure int isnan(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __isnan(x)\n-            : __isnanl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__isnan\" : \"__isnanl\")\n+    pure int isnan(real x);\n \n     //int isnormal(real-floating x);\n     ///\n@@ -975,16 +909,12 @@ else version (MinGW)\n \n     //int signbit(real-floating x);\n     ///\n-    int signbit(float x)     { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    int signbit(double x)    { return __signbit(x);  }\n+    extern(C) pragma(mangle, \"__signbit\")  pure int signbit(double x);\n     ///\n-    int signbit(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __signbit(x)\n-            : __signbitl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__signbit\" : \"__signbitl\")\n+    int signbit(real x);\n   }\n }\n else version (Darwin)\n@@ -1070,35 +1000,35 @@ else version (Darwin)\n   {\n     //int fpclassify(real-floating x);\n     ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassifyd(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyd\") pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)      { return __fpclassifyl(x); }\n+    extern(C) pragma(mangle, __fpclassifyl.mangleof) pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n-    pure int isfinite(float x)       { return __isfinitef(x); }\n+    extern(C) pragma(mangle, \"__isfinitef\") pure int isfinite(float x);\n     ///\n-    pure int isfinite(double x)      { return __isfinited(x); }\n+    extern(C) pragma(mangle, \"__isfinited\") pure int isfinite(double x);\n     ///\n-    pure int isfinite(real x)        { return __isfinitel(x); }\n+    extern(C) pragma(mangle, __isfinitel.mangleof) pure int isfinite(real x);\n \n     //int isinf(real-floating x);\n     ///\n-    pure int isinf(float x)          { return __isinff(x); }\n+    extern(C) pragma(mangle, \"__isinff\") pure int isinf(float x);\n     ///\n-    pure int isinf(double x)         { return __isinfd(x); }\n+    extern(C) pragma(mangle, \"__isinfd\") pure int isinf(double x);\n     ///\n-    pure int isinf(real x)           { return __isinfl(x); }\n+    extern(C) pragma(mangle, __isinfl.mangleof) pure int isinf(real x);\n \n     //int isnan(real-floating x);\n     ///\n-    pure int isnan(float x)          { return __isnanf(x); }\n+    extern(C) pragma(mangle, \"__isnanf\") pure int isnan(float x);\n     ///\n-    pure int isnan(double x)         { return __isnand(x); }\n+    extern(C) pragma(mangle, \"__isnand\") pure int isnan(double x);\n     ///\n-    pure int isnan(real x)           { return __isnanl(x); }\n+    extern(C) pragma(mangle, __isnanl.mangleof) pure int isnan(real x);\n \n     //int isnormal(real-floating x);\n     ///\n@@ -1110,11 +1040,11 @@ else version (Darwin)\n \n     //int signbit(real-floating x);\n     ///\n-    pure int signbit(float x)     { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    pure int signbit(double x)    { return __signbitd(x); }\n+    extern(C) pragma(mangle, \"__signbitd\") pure int signbit(double x);\n     ///\n-    pure int signbit(real x)      { return __signbitl(x); }\n+    extern(C) pragma(mangle, \"__signbitl\") pure int signbit(real x);\n   }\n }\n else version (FreeBSD)\n@@ -1163,49 +1093,49 @@ else version (FreeBSD)\n   {\n     //int fpclassify(real-floating x);\n       ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassifyd(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyd\") pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)      { return __fpclassifyl(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyl\") pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n-    pure int isfinite(float x)       { return __isfinitef(x); }\n+    extern(C) pragma(mangle, \"__isfinitef\") pure int isfinite(float x);\n     ///\n-    pure int isfinite(double x)      { return __isfinite(x); }\n+    extern(C) pragma(mangle, \"__isfinite\")  pure int isfinite(double x);\n     ///\n-    pure int isfinite(real x)        { return __isfinitel(x); }\n+    extern(C) pragma(mangle, \"__isfinitel\") pure int isfinite(real x);\n \n     //int isinf(real-floating x);\n     ///\n-    pure int isinf(float x)          { return __isinff(x); }\n+    extern(C) pragma(mangle, \"__isinff\") pure int isinf(float x);\n     ///\n     pure int isinf(double x)         { return __isinfl(x); }\n     ///\n-    pure int isinf(real x)           { return __isinfl(x); }\n+    extern(C) pragma(mangle, \"__isinfl\") pure int isinf(real x);\n \n     //int isnan(real-floating x);\n     ///\n     pure int isnan(float x)          { return __isnanl(x); }\n     ///\n     pure int isnan(double x)         { return __isnanl(x); }\n     ///\n-    pure int isnan(real x)           { return __isnanl(x); }\n+    extern(C) pragma(mangle, \"__isnanl\") pure int isnan(real x);\n \n     //int isnormal(real-floating x);\n     ///\n-    pure int isnormal(float x)       { return __isnormalf(x); }\n+    extern(C) pragma(mangle, \"__isnormalf\") pure int isnormal(float x);\n     ///\n-    pure int isnormal(double x)      { return __isnormal(x); }\n+    extern(C) pragma(mangle, \"__isnormal\")  pure int isnormal(double x);\n     ///\n-    pure int isnormal(real x)        { return __isnormall(x); }\n+    extern(C) pragma(mangle, \"__isnormall\") pure int isnormal(real x);\n \n     //int signbit(real-floating x);\n     ///\n-    pure int signbit(float x)        { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    pure int signbit(double x)       { return __signbit(x); }\n+    extern(C) pragma(mangle, \"__signbit\")  pure int signbit(double x);\n     ///\n     pure int signbit(real x)         { return __signbit(x); }\n   }\n@@ -1256,49 +1186,49 @@ else version (OpenBSD)\n   {\n     //int fpclassify(real-floating x);\n       ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassifyd(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyd\") pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)      { return __fpclassifyl(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyl\") pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n-    pure int isfinite(float x)       { return __isfinitef(x); }\n+    extern(C) pragma(mangle, \"__isfinitef\") pure int isfinite(float x);\n     ///\n-    pure int isfinite(double x)      { return __isfinite(x); }\n+    extern(C) pragma(mangle, \"__isfinite\")  pure int isfinite(double x);\n     ///\n-    pure int isfinite(real x)        { return __isfinitel(x); }\n+    extern(C) pragma(mangle, \"__isfinitel\") pure int isfinite(real x);\n \n     //int isinf(real-floating x);\n     ///\n-    pure int isinf(float x)          { return __isinff(x); }\n+    extern(C) pragma(mangle, \"__isinff\") pure int isinf(float x);\n     ///\n     pure int isinf(double x)         { return __isinfl(x); }\n     ///\n-    pure int isinf(real x)           { return __isinfl(x); }\n+    extern(C) pragma(mangle, \"__isinfl\") pure int isinf(real x);\n \n     //int isnan(real-floating x);\n     ///\n     pure int isnan(float x)          { return __isnanl(x); }\n     ///\n     pure int isnan(double x)         { return __isnanl(x); }\n     ///\n-    pure int isnan(real x)           { return __isnanl(x); }\n+    extern(C) pragma(mangle, \"__isnanl\") pure int isnan(real x);\n \n     //int isnormal(real-floating x);\n     ///\n-    pure int isnormal(float x)       { return __isnormalf(x); }\n+    extern(C) pragma(mangle, \"__isnormalf\") pure int isnormal(float x);\n     ///\n-    pure int isnormal(double x)      { return __isnormal(x); }\n+    extern(C) pragma(mangle, \"__isnormal\")  pure int isnormal(double x);\n     ///\n-    pure int isnormal(real x)        { return __isnormall(x); }\n+    extern(C) pragma(mangle, \"__isnormall\") pure int isnormal(real x);\n \n     //int signbit(real-floating x);\n     ///\n-    pure int signbit(float x)        { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    pure int signbit(double x)       { return __signbit(x); }\n+    extern(C) pragma(mangle, \"__signbit\")  pure int signbit(double x);\n     ///\n     pure int signbit(real x)         { return __signbit(x); }\n   }\n@@ -1337,16 +1267,12 @@ else version (NetBSD)\n   {\n     //int fpclassify(real-floating x);\n     ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassifyd(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyd\") pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __fpclassifyd(x)\n-            : __fpclassifyl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassifyd\" : \"__fpclassifyl\")\n+    pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n@@ -1433,29 +1359,29 @@ else version (DragonFlyBSD)\n \n   extern (D)\n   {\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n-    pure int fpclassify(double x)    { return __fpclassifyd(x); }\n-    pure int fpclassify(real x)      { return __fpclassifyl(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n+    extern(C) pragma(mangle, \"__fpclassifyd\") pure int fpclassify(double x);\n+    extern(C) pragma(mangle, \"__fpclassifyl\") pure int fpclassify(real x);\n \n-    pure int isfinite(float x)       { return __isfinitef(x); }\n-    pure int isfinite(double x)      { return __isfinite(x); }\n-    pure int isfinite(real x)        { return __isfinitel(x); }\n+    extern(C) pragma(mangle, \"__isfinitef\") pure int isfinite(float x);\n+    extern(C) pragma(mangle, \"__isfinite\")  pure int isfinite(double x);\n+    extern(C) pragma(mangle, \"__isfinitel\") pure int isfinite(real x);\n \n-    pure int isinf(float x)          { return __isinff(x); }\n-    pure int isinf(double x)         { return __isinf(x); }\n-    pure int isinf(real x)           { return __isinfl(x); }\n+    extern(C) pragma(mangle, \"__isinff\") pure int isinf(float x);\n+    extern(C) pragma(mangle, \"__isinf\")  pure int isinf(double x);\n+    extern(C) pragma(mangle, \"__isinfl\") pure int isinf(real x);\n \n-    pure int isnan(float x)          { return __isnanf(x); }\n-    pure int isnan(double x)         { return __isnan(x); }\n-    pure int isnan(real x)           { return __isnanl(x); }\n+    extern(C) pragma(mangle, \"__isnanf\") pure int isnan(float x);\n+    extern(C) pragma(mangle, \"__isnan\")  pure int isnan(double x);\n+    extern(C) pragma(mangle, \"__isnanl\") pure int isnan(real x);\n \n-    pure int isnormal(float x)       { return __isnormalf(x); }\n-    pure int isnormal(double x)      { return __isnormal(x); }\n-    pure int isnormal(real x)        { return __isnormall(x); }\n+    extern(C) pragma(mangle, \"__isnormalf\") pure int isnormal(float x);\n+    extern(C) pragma(mangle, \"__isnormal\")  pure int isnormal(double x);\n+    extern(C) pragma(mangle, \"__isnormall\") pure int isnormal(real x);\n \n-    pure int signbit(float x)        { return __signbitf(x); }\n-    pure int signbit(double x)       { return __signbit(x); }\n-    pure int signbit(real x)         { return __signbitl(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n+    extern(C) pragma(mangle, \"__signbit\")  pure int signbit(double x);\n+    extern(C) pragma(mangle, \"__signbitl\") pure int signbit(real x);\n   }\n }\n else version (Solaris)\n@@ -1468,16 +1394,12 @@ else version (Solaris)\n   {\n     //int isnan(real-floating x);\n       ///\n-    pure int isnan(float x)          { return __isnanf(x);  }\n+    extern(C) pragma(mangle, \"__isnanf\") pure int isnan(float x);\n     ///\n-    pure int isnan(double x)         { return __isnan(x);   }\n+    extern(C) pragma(mangle, \"__isnan\")  pure int isnan(double x);\n     ///\n-    pure int isnan(real x)\n-    {\n-        return (real.sizeof == double.sizeof)\n-            ? __isnan(x)\n-            : __isnanl(x);\n-    }\n+    extern(C) pragma(mangle, real.sizeof == double.sizeof ? \"__isnan\" : \"__isnanl\")\n+    pure int isnan(real x);\n   }\n }\n else version (CRuntime_Bionic)\n@@ -1527,49 +1449,49 @@ else version (CRuntime_Bionic)\n   {\n     //int fpclassify(real-floating x);\n       ///\n-    pure int fpclassify(float x)     { return __fpclassifyf(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pure int fpclassify(double x)    { return __fpclassifyd(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyd\") pure int fpclassify(double x);\n     ///\n-    pure int fpclassify(real x)      { return __fpclassifyl(x); }\n+    extern(C) pragma(mangle, \"__fpclassifyl\") pure int fpclassify(real x);\n \n     //int isfinite(real-floating x);\n     ///\n-    pure int isfinite(float x)       { return __isfinitef(x); }\n+    extern(C) pragma(mangle, \"__isfinitef\") pure int isfinite(float x);\n     ///\n-    pure int isfinite(double x)      { return __isfinite(x); }\n+    extern(C) pragma(mangle, \"__isfinite\")  pure int isfinite(double x);\n     ///\n-    pure int isfinite(real x)        { return __isfinitel(x); }\n+    extern(C) pragma(mangle, \"__isfinitel\") pure int isfinite(real x);\n \n     //int isinf(real-floating x);\n     ///\n-    pure int isinf(float x)          { return __isinff(x); }\n+    extern(C) pragma(mangle, \"__isinff\") pure int isinf(float x);\n     ///\n-    pure int isinf(double x)         { return __isinf(x); }\n+    extern(C) pragma(mangle, \"__isinf\")  pure int isinf(double x);\n     ///\n-    pure int isinf(real x)           { return __isinfl(x); }\n+    extern(C) pragma(mangle, \"__isinfl\") pure int isinf(real x);\n \n     //int isnan(real-floating x);\n     ///\n-    pure int isnan(float x)          { return isnanf(x); }\n+    extern(C) pragma(mangle, \"isnanf\")   pure int isnan(float x);\n     ///\n-    pure int isnan(real x)           { return __isnanl(x); }\n+    extern(C) pragma(mangle, \"__isnanl\") pure int isnan(real x);\n \n     //int isnormal(real-floating x);\n     ///\n-    pure int isnormal(float x)       { return __isnormalf(x); }\n+    extern(C) pragma(mangle, \"__isnormalf\") pure int isnormal(float x);\n     ///\n-    pure int isnormal(double x)      { return __isnormal(x); }\n+    extern(C) pragma(mangle, \"__isnormal\")  pure int isnormal(double x);\n     ///\n-    pure int isnormal(real x)        { return __isnormall(x); }\n+    extern(C) pragma(mangle, \"__isnormall\") pure int isnormal(real x);\n \n     //int signbit(real-floating x);\n     ///\n-    pure int signbit(float x)        { return __signbitf(x); }\n+    extern(C) pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    pure int signbit(double x)       { return __signbit(x); }\n+    extern(C) pragma(mangle, \"__signbit\")  pure int signbit(double x);\n     ///\n-    pure int signbit(real x)         { return __signbitl(x); }\n+    extern(C) pragma(mangle, \"__signbitl\") pure int signbit(real x);\n   }\n }\n \n@@ -1841,14 +1763,12 @@ version (CRuntime_Microsoft) // fully supported since MSVCRT 12 (VS 2013) only\n     ///\n     extern(D) pure real  fabsl()(real x)  { return fabs(cast(double) x); }\n \n-    private double _hypot(double x, double y);\n-    private float  _hypotf(float x, float y);\n     ///\n-    extern(D) double hypot(double x, double y) { return _hypot(x, y); }\n+    extern(C) pragma(mangle, \"_hypot\")  double hypot(double x, double y);\n     ///\n-    extern(D) float  hypotf(float x, float y)  { return _hypotf(x, y); }\n+    extern(C) pragma(mangle, \"_hypotf\") float  hypotf(float x, float y);\n     ///\n-    extern(D) real   hypotl(real x, real y)    { return _hypot(cast(double) x, cast(double) y); }\n+    extern(D) real   hypotl(real x, real y)    { return hypot(cast(double) x, cast(double) y); }\n \n     ///\n     double  pow(double x, double y);"}, {"sha": "532a0803f55428a16ef8c45b9f4eef53a8378383", "filename": "libphobos/libdruntime/core/stdc/stdio.d", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1166,90 +1166,114 @@ version (MinGW)\n     // Prefer the MinGW versions over the MSVC ones, as the latter don't handle\n     // reals at all.\n     ///\n+    pragma(printf)\n     int __mingw_fprintf(FILE* stream, scope const char* format, scope const ...);\n     ///\n     alias __mingw_fprintf fprintf;\n \n     ///\n+    pragma(scanf)\n     int __mingw_fscanf(FILE* stream, scope const char* format, scope ...);\n     ///\n     alias __mingw_fscanf fscanf;\n \n     ///\n+    pragma(printf)\n     int __mingw_sprintf(scope char* s, scope const char* format, scope const ...);\n     ///\n     alias __mingw_sprintf sprintf;\n \n     ///\n+    pragma(scanf)\n     int __mingw_sscanf(scope const char* s, scope const char* format, scope ...);\n     ///\n     alias __mingw_sscanf sscanf;\n \n     ///\n+    pragma(printf)\n     int __mingw_vfprintf(FILE* stream, scope const char* format, va_list arg);\n     ///\n     alias __mingw_vfprintf vfprintf;\n \n     ///\n+    pragma(scanf)\n     int __mingw_vfscanf(FILE* stream, scope const char* format, va_list arg);\n     ///\n     alias __mingw_vfscanf vfscanf;\n \n     ///\n+    pragma(printf)\n     int __mingw_vsprintf(scope char* s, scope const char* format, va_list arg);\n     ///\n     alias __mingw_vsprintf vsprintf;\n \n     ///\n+    pragma(scanf)\n     int __mingw_vsscanf(scope const char* s, scope const char* format, va_list arg);\n     ///\n     alias __mingw_vsscanf vsscanf;\n \n     ///\n+    pragma(printf)\n     int __mingw_vprintf(scope const char* format, va_list arg);\n     ///\n     alias __mingw_vprintf vprintf;\n \n     ///\n+    pragma(scanf)\n     int __mingw_vscanf(scope const char* format, va_list arg);\n     ///\n     alias __mingw_vscanf vscanf;\n \n     ///\n+    pragma(printf)\n     int __mingw_printf(scope const char* format, scope const ...);\n     ///\n     alias __mingw_printf printf;\n \n     ///\n+    pragma(scanf)\n     int __mingw_scanf(scope const char* format, scope ...);\n     ///\n     alias __mingw_scanf scanf;\n }\n else\n {\n     ///\n+    pragma(printf)\n     int fprintf(FILE* stream, scope const char* format, scope const ...);\n     ///\n+    pragma(scanf)\n     int fscanf(FILE* stream, scope const char* format, scope ...);\n     ///\n+    pragma(printf)\n     int sprintf(scope char* s, scope const char* format, scope const ...);\n     ///\n+    pragma(scanf)\n     int sscanf(scope const char* s, scope const char* format, scope ...);\n     ///\n+    pragma(printf)\n     int vfprintf(FILE* stream, scope const char* format, va_list arg);\n     ///\n+    pragma(scanf)\n     int vfscanf(FILE* stream, scope const char* format, va_list arg);\n     ///\n+    pragma(printf)\n     int vsprintf(scope char* s, scope const char* format, va_list arg);\n     ///\n+    pragma(scanf)\n     int vsscanf(scope const char* s, scope const char* format, va_list arg);\n     ///\n+    pragma(printf)\n     int vprintf(scope const char* format, va_list arg);\n     ///\n+    pragma(scanf)\n     int vscanf(scope const char* format, va_list arg);\n     ///\n+    pragma(printf)\n     int printf(scope const char* format, scope const ...);\n     ///\n+    pragma(scanf)\n     int scanf(scope const char* format, scope ...);\n }\n \n@@ -1278,12 +1302,13 @@ extern (D) @trusted\n     int getchar()()                 { return getc(stdin);     }\n     ///\n     int putchar()(int c)            { return putc(c,stdout);  }\n-    ///\n-    int getc()(FILE* stream)        { return fgetc(stream);   }\n-    ///\n-    int putc()(int c, FILE* stream) { return fputc(c,stream); }\n }\n \n+///\n+alias getc = fgetc;\n+///\n+alias putc = fputc;\n+\n ///\n @trusted int ungetc(int c, FILE* stream); // No unsafe pointer manipulation.\n \n@@ -1323,11 +1348,13 @@ version (CRuntime_DigitalMars)\n     pure int  fileno()(FILE* stream)   { return stream._file; }\n   }\n   ///\n+    pragma(printf)\n     int   _snprintf(scope char* s, size_t n, scope const char* fmt, scope const ...);\n     ///\n     alias _snprintf snprintf;\n \n     ///\n+    pragma(printf)\n     int   _vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n     ///\n     alias _vsnprintf vsnprintf;\n@@ -1351,13 +1378,15 @@ else version (CRuntime_Microsoft)\n \n   version (MinGW)\n   {\n+    pragma(printf)\n     int   __mingw_snprintf(scope char* s, size_t n, scope const char* fmt, scope const ...);\n     ///\n     alias __mingw_snprintf _snprintf;\n     ///\n     alias __mingw_snprintf snprintf;\n \n     ///\n+    pragma(printf)\n     int   __mingw_vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n     ///\n     alias __mingw_vsnprintf _vsnprintf;\n@@ -1367,13 +1396,17 @@ else version (CRuntime_Microsoft)\n   else\n   {\n     ///\n+    pragma(printf)\n     int _snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n \n     ///\n+    pragma(printf)\n     int _vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n   }\n \n@@ -1410,8 +1443,10 @@ else version (CRuntime_Glibc)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (Darwin)\n@@ -1432,8 +1467,10 @@ else version (Darwin)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (FreeBSD)\n@@ -1454,8 +1491,10 @@ else version (FreeBSD)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (NetBSD)\n@@ -1476,8 +1515,10 @@ else version (NetBSD)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(char* s, size_t n, const scope char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(char* s, size_t n, const scope char* format, va_list arg);\n }\n else version (OpenBSD)\n@@ -1567,8 +1608,10 @@ else version (OpenBSD)\n     }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (DragonFlyBSD)\n@@ -1599,7 +1642,9 @@ else version (DragonFlyBSD)\n   enum __SALC = 0x4000;\n   enum __SIGN = 0x8000;\n \n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (Solaris)\n@@ -1620,8 +1665,10 @@ else version (Solaris)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (CRuntime_Bionic)\n@@ -1642,8 +1689,10 @@ else version (CRuntime_Bionic)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (CRuntime_Musl)\n@@ -1663,8 +1712,10 @@ else version (CRuntime_Musl)\n     }\n \n     ///\n+    pragma(printf)\n     int snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else version (CRuntime_UClibc)\n@@ -1685,8 +1736,10 @@ else version (CRuntime_UClibc)\n   }\n \n     ///\n+    pragma(printf)\n     int  snprintf(scope char* s, size_t n, scope const char* format, scope const ...);\n     ///\n+    pragma(printf)\n     int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);\n }\n else"}, {"sha": "5d69b880bc8b2dd05ee8c0261cc8134a716a842a", "filename": "libphobos/libdruntime/core/stdc/stdlib.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -164,13 +164,13 @@ void*   realloc(void* ptr, size_t size);\n void    free(void* ptr);\n \n ///\n-void    abort() @safe;\n+noreturn abort() @safe;\n ///\n-void    exit(int status);\n+noreturn exit(int status);\n ///\n int     atexit(void function() func);\n ///\n-void    _Exit(int status);\n+noreturn _Exit(int status);\n \n ///\n char*   getenv(scope const char* name);"}, {"sha": "2ff1522fd81be0cd287aacd0daa09f4b9684faff", "filename": "libphobos/libdruntime/core/stdc/tgmath.d", "status": "modified", "additions": 254, "deletions": 399, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ftgmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ftgmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ftgmath.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -32,12 +32,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.acosl         acos;\n \n-    ///\n-    alias core.stdc.complex.cacos      acos;\n-    ///\n-    alias core.stdc.complex.cacosf     acos;\n-    ///\n-    alias core.stdc.complex.cacosl     acos;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cacos      acos;\n+    deprecated alias core.stdc.complex.cacosf     acos;\n+    deprecated alias core.stdc.complex.cacosl     acos;\n \n     ///\n     alias core.stdc.math.asin          asin;\n@@ -46,12 +44,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.asinl         asin;\n \n-    ///\n-    alias core.stdc.complex.casin      asin;\n-    ///\n-    alias core.stdc.complex.casinf     asin;\n-    ///\n-    alias core.stdc.complex.casinl     asin;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.casin      asin;\n+    deprecated alias core.stdc.complex.casinf     asin;\n+    deprecated alias core.stdc.complex.casinl     asin;\n \n     ///\n     alias core.stdc.math.atan          atan;\n@@ -60,12 +56,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.atanl         atan;\n \n-    ///\n-    alias core.stdc.complex.catan      atan;\n-    ///\n-    alias core.stdc.complex.catanf     atan;\n-    ///\n-    alias core.stdc.complex.catanl     atan;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.catan      atan;\n+    deprecated alias core.stdc.complex.catanf     atan;\n+    deprecated alias core.stdc.complex.catanl     atan;\n \n     ///\n     alias core.stdc.math.atan2         atan2;\n@@ -81,12 +75,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.cosl          cos;\n \n-    ///\n-    alias core.stdc.complex.ccos       cos;\n-    ///\n-    alias core.stdc.complex.ccosf      cos;\n-    ///\n-    alias core.stdc.complex.ccosl      cos;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ccos       cos;\n+    deprecated alias core.stdc.complex.ccosf      cos;\n+    deprecated alias core.stdc.complex.ccosl      cos;\n \n     ///\n     alias core.stdc.math.sin           sin;\n@@ -95,12 +87,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.sinl          sin;\n \n-    ///\n-    alias core.stdc.complex.csin       csin;\n-    ///\n-    alias core.stdc.complex.csinf      csin;\n-    ///\n-    alias core.stdc.complex.csinl      csin;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csin       csin;\n+    deprecated alias core.stdc.complex.csinf      csin;\n+    deprecated alias core.stdc.complex.csinl      csin;\n \n     ///\n     alias core.stdc.math.tan           tan;\n@@ -109,12 +99,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.tanl          tan;\n \n-    ///\n-    alias core.stdc.complex.ctan       tan;\n-    ///\n-    alias core.stdc.complex.ctanf      tan;\n-    ///\n-    alias core.stdc.complex.ctanl      tan;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ctan       tan;\n+    deprecated alias core.stdc.complex.ctanf      tan;\n+    deprecated alias core.stdc.complex.ctanl      tan;\n \n     ///\n     alias core.stdc.math.acosh         acosh;\n@@ -123,12 +111,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.acoshl        acosh;\n \n-    ///\n-    alias core.stdc.complex.cacosh     acosh;\n-    ///\n-    alias core.stdc.complex.cacoshf    acosh;\n-    ///\n-    alias core.stdc.complex.cacoshl    acosh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cacosh     acosh;\n+    deprecated alias core.stdc.complex.cacoshf    acosh;\n+    deprecated alias core.stdc.complex.cacoshl    acosh;\n \n     ///\n     alias core.stdc.math.asinh         asinh;\n@@ -137,12 +123,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.asinhl        asinh;\n \n-    ///\n-    alias core.stdc.complex.casinh     asinh;\n-    ///\n-    alias core.stdc.complex.casinhf    asinh;\n-    ///\n-    alias core.stdc.complex.casinhl    asinh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.casinh     asinh;\n+    deprecated alias core.stdc.complex.casinhf    asinh;\n+    deprecated alias core.stdc.complex.casinhl    asinh;\n \n     ///\n     alias core.stdc.math.atanh         atanh;\n@@ -151,12 +135,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.atanhl        atanh;\n \n-    ///\n-    alias core.stdc.complex.catanh     atanh;\n-    ///\n-    alias core.stdc.complex.catanhf    atanh;\n-    ///\n-    alias core.stdc.complex.catanhl    atanh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.catanh     atanh;\n+    deprecated alias core.stdc.complex.catanhf    atanh;\n+    deprecated alias core.stdc.complex.catanhl    atanh;\n \n     ///\n     alias core.stdc.math.cosh          cosh;\n@@ -165,12 +147,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.coshl         cosh;\n \n-    ///\n-    alias core.stdc.complex.ccosh      cosh;\n-    ///\n-    alias core.stdc.complex.ccoshf     cosh;\n-    ///\n-    alias core.stdc.complex.ccoshl     cosh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ccosh      cosh;\n+    deprecated alias core.stdc.complex.ccoshf     cosh;\n+    deprecated alias core.stdc.complex.ccoshl     cosh;\n \n     ///\n     alias core.stdc.math.sinh          sinh;\n@@ -179,12 +159,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.sinhl         sinh;\n \n-    ///\n-    alias core.stdc.complex.csinh      sinh;\n-    ///\n-    alias core.stdc.complex.csinhf     sinh;\n-    ///\n-    alias core.stdc.complex.csinhl     sinh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csinh      sinh;\n+    deprecated alias core.stdc.complex.csinhf     sinh;\n+    deprecated alias core.stdc.complex.csinhl     sinh;\n \n     ///\n     alias core.stdc.math.tanh          tanh;\n@@ -193,12 +171,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.tanhl         tanh;\n \n-    ///\n-    alias core.stdc.complex.ctanh      tanh;\n-    ///\n-    alias core.stdc.complex.ctanhf     tanh;\n-    ///\n-    alias core.stdc.complex.ctanhl     tanh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ctanh      tanh;\n+    deprecated alias core.stdc.complex.ctanhf     tanh;\n+    deprecated alias core.stdc.complex.ctanhl     tanh;\n \n     ///\n     alias core.stdc.math.exp           exp;\n@@ -207,12 +183,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.expl          exp;\n \n-    ///\n-    alias core.stdc.complex.cexp       exp;\n-    ///\n-    alias core.stdc.complex.cexpf      exp;\n-    ///\n-    alias core.stdc.complex.cexpl      exp;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cexp       exp;\n+    deprecated alias core.stdc.complex.cexpf      exp;\n+    deprecated alias core.stdc.complex.cexpl      exp;\n \n     ///\n     alias core.stdc.math.exp2          exp2;\n@@ -256,12 +230,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.logl          log;\n \n-    ///\n-    alias core.stdc.complex.clog       log;\n-    ///\n-    alias core.stdc.complex.clogf      log;\n-    ///\n-    alias core.stdc.complex.clogl      log;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.clog       log;\n+    deprecated alias core.stdc.complex.clogf      log;\n+    deprecated alias core.stdc.complex.clogl      log;\n \n     ///\n     alias core.stdc.math.log10         log10;\n@@ -325,12 +297,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.fabsl         fabs;\n \n-    ///\n-    alias core.stdc.complex.cabs       fabs;\n-    ///\n-    alias core.stdc.complex.cabsf      fabs;\n-    ///\n-    alias core.stdc.complex.cabsl      fabs;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cabs       fabs;\n+    deprecated alias core.stdc.complex.cabsf      fabs;\n+    deprecated alias core.stdc.complex.cabsl      fabs;\n \n     ///\n     alias core.stdc.math.hypot         hypot;\n@@ -346,12 +316,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.powl          pow;\n \n-    ///\n-    alias core.stdc.complex.cpow       pow;\n-    ///\n-    alias core.stdc.complex.cpowf      pow;\n-    ///\n-    alias core.stdc.complex.cpowl      pow;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cpow       pow;\n+    deprecated alias core.stdc.complex.cpowf      pow;\n+    deprecated alias core.stdc.complex.cpowl      pow;\n \n     ///\n     alias core.stdc.math.sqrt          sqrt;\n@@ -360,12 +328,10 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.sqrtl         sqrt;\n \n-    ///\n-    alias core.stdc.complex.csqrt      sqrt;\n-    ///\n-    alias core.stdc.complex.csqrtf     sqrt;\n-    ///\n-    alias core.stdc.complex.csqrtl     sqrt;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csqrt      sqrt;\n+    deprecated alias core.stdc.complex.csqrtf     sqrt;\n+    deprecated alias core.stdc.complex.csqrtl     sqrt;\n \n     ///\n     alias core.stdc.math.erf           erf;\n@@ -539,37 +505,23 @@ version (NetBSD)\n     ///\n     alias core.stdc.math.fmal          fma;\n \n-    ///\n-    alias core.stdc.complex.carg       carg;\n-    ///\n-    alias core.stdc.complex.cargf      carg;\n-    ///\n-    alias core.stdc.complex.cargl      carg;\n-\n-    ///\n-    alias core.stdc.complex.cimag      cimag;\n-    ///\n-    alias core.stdc.complex.cimagf     cimag;\n-    ///\n-    alias core.stdc.complex.cimagl     cimag;\n-\n-    ///\n-    alias core.stdc.complex.conj       conj;\n-    ///\n-    alias core.stdc.complex.conjf      conj;\n-    ///\n-    alias core.stdc.complex.conjl      conj;\n-\n-    ///\n-    alias core.stdc.complex.cproj      cproj;\n-    ///\n-    alias core.stdc.complex.cprojf     cproj;\n-    ///\n-    alias core.stdc.complex.cprojl     cproj;\n-\n-//  alias core.stdc.complex.creal      creal;\n-//  alias core.stdc.complex.crealf     creal;\n-//  alias core.stdc.complex.creall     creal;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.carg       carg;\n+    deprecated alias core.stdc.complex.cargf      carg;\n+    deprecated alias core.stdc.complex.cargl      carg;\n+    deprecated alias core.stdc.complex.cimag      cimag;\n+    deprecated alias core.stdc.complex.cimagf     cimag;\n+    deprecated alias core.stdc.complex.cimagl     cimag;\n+    deprecated alias core.stdc.complex.conj       conj;\n+    deprecated alias core.stdc.complex.conjf      conj;\n+    deprecated alias core.stdc.complex.conjl      conj;\n+    deprecated alias core.stdc.complex.cproj      cproj;\n+    deprecated alias core.stdc.complex.cprojf     cproj;\n+    deprecated alias core.stdc.complex.cprojl     cproj;\n+\n+//  deprecated alias core.stdc.complex.creal      creal;\n+//  deprecated alias core.stdc.complex.crealf     creal;\n+//  deprecated alias core.stdc.complex.creall     creal;\n }\n else version (OpenBSD)\n {\n@@ -580,12 +532,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.acosl         acos;\n \n-    ///\n-    alias core.stdc.complex.cacos      acos;\n-    ///\n-    alias core.stdc.complex.cacosf     acos;\n-    ///\n-    alias core.stdc.complex.cacosl     acos;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cacos      acos;\n+    deprecated alias core.stdc.complex.cacosf     acos;\n+    deprecated alias core.stdc.complex.cacosl     acos;\n \n     ///\n     alias core.stdc.math.asin          asin;\n@@ -594,12 +544,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.asinl         asin;\n \n-    ///\n-    alias core.stdc.complex.casin      asin;\n-    ///\n-    alias core.stdc.complex.casinf     asin;\n-    ///\n-    alias core.stdc.complex.casinl     asin;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.casin      asin;\n+    deprecated alias core.stdc.complex.casinf     asin;\n+    deprecated alias core.stdc.complex.casinl     asin;\n \n     ///\n     alias core.stdc.math.atan          atan;\n@@ -608,12 +556,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.atanl         atan;\n \n-    ///\n-    alias core.stdc.complex.catan      atan;\n-    ///\n-    alias core.stdc.complex.catanf     atan;\n-    ///\n-    alias core.stdc.complex.catanl     atan;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.catan      atan;\n+    deprecated alias core.stdc.complex.catanf     atan;\n+    deprecated alias core.stdc.complex.catanl     atan;\n \n     ///\n     alias core.stdc.math.atan2         atan2;\n@@ -629,12 +575,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.cosl          cos;\n \n-    ///\n-    alias core.stdc.complex.ccos       cos;\n-    ///\n-    alias core.stdc.complex.ccosf      cos;\n-    ///\n-    alias core.stdc.complex.ccosl      cos;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ccos       cos;\n+    deprecated alias core.stdc.complex.ccosf      cos;\n+    deprecated alias core.stdc.complex.ccosl      cos;\n \n     ///\n     alias core.stdc.math.sin           sin;\n@@ -643,12 +587,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.sinl          sin;\n \n-    ///\n-    alias core.stdc.complex.csin       csin;\n-    ///\n-    alias core.stdc.complex.csinf      csin;\n-    ///\n-    alias core.stdc.complex.csinl      csin;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csin       csin;\n+    deprecated alias core.stdc.complex.csinf      csin;\n+    deprecated alias core.stdc.complex.csinl      csin;\n \n     ///\n     alias core.stdc.math.tan           tan;\n@@ -657,12 +599,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.tanl          tan;\n \n-    ///\n-    alias core.stdc.complex.ctan       tan;\n-    ///\n-    alias core.stdc.complex.ctanf      tan;\n-    ///\n-    alias core.stdc.complex.ctanl      tan;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ctan       tan;\n+    deprecated alias core.stdc.complex.ctanf      tan;\n+    deprecated alias core.stdc.complex.ctanl      tan;\n \n     ///\n     alias core.stdc.math.acosh         acosh;\n@@ -671,12 +611,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.acoshl        acosh;\n \n-    ///\n-    alias core.stdc.complex.cacosh     acosh;\n-    ///\n-    alias core.stdc.complex.cacoshf    acosh;\n-    ///\n-    alias core.stdc.complex.cacoshl    acosh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cacosh     acosh;\n+    deprecated alias core.stdc.complex.cacoshf    acosh;\n+    deprecated alias core.stdc.complex.cacoshl    acosh;\n \n     ///\n     alias core.stdc.math.asinh         asinh;\n@@ -685,12 +623,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.asinhl        asinh;\n \n-    ///\n-    alias core.stdc.complex.casinh     asinh;\n-    ///\n-    alias core.stdc.complex.casinhf    asinh;\n-    ///\n-    alias core.stdc.complex.casinhl    asinh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.casinh     asinh;\n+    deprecated alias core.stdc.complex.casinhf    asinh;\n+    deprecated alias core.stdc.complex.casinhl    asinh;\n \n     ///\n     alias core.stdc.math.atanh         atanh;\n@@ -699,12 +635,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.atanhl        atanh;\n \n-    ///\n-    alias core.stdc.complex.catanh     atanh;\n-    ///\n-    alias core.stdc.complex.catanhf    atanh;\n-    ///\n-    alias core.stdc.complex.catanhl    atanh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.catanh     atanh;\n+    deprecated alias core.stdc.complex.catanhf    atanh;\n+    deprecated alias core.stdc.complex.catanhl    atanh;\n \n     ///\n     alias core.stdc.math.cosh          cosh;\n@@ -713,12 +647,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.coshl         cosh;\n \n-    ///\n-    alias core.stdc.complex.ccosh      cosh;\n-    ///\n-    alias core.stdc.complex.ccoshf     cosh;\n-    ///\n-    alias core.stdc.complex.ccoshl     cosh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ccosh      cosh;\n+    deprecated alias core.stdc.complex.ccoshf     cosh;\n+    deprecated alias core.stdc.complex.ccoshl     cosh;\n \n     ///\n     alias core.stdc.math.sinh          sinh;\n@@ -727,12 +659,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.sinhl         sinh;\n \n-    ///\n-    alias core.stdc.complex.csinh      sinh;\n-    ///\n-    alias core.stdc.complex.csinhf     sinh;\n-    ///\n-    alias core.stdc.complex.csinhl     sinh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csinh      sinh;\n+    deprecated alias core.stdc.complex.csinhf     sinh;\n+    deprecated alias core.stdc.complex.csinhl     sinh;\n \n     ///\n     alias core.stdc.math.tanh          tanh;\n@@ -741,12 +671,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.tanhl         tanh;\n \n-    ///\n-    alias core.stdc.complex.ctanh      tanh;\n-    ///\n-    alias core.stdc.complex.ctanhf     tanh;\n-    ///\n-    alias core.stdc.complex.ctanhl     tanh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ctanh      tanh;\n+    deprecated alias core.stdc.complex.ctanhf     tanh;\n+    deprecated alias core.stdc.complex.ctanhl     tanh;\n \n     ///\n     alias core.stdc.math.exp           exp;\n@@ -755,12 +683,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.expl          exp;\n \n-    ///\n-    alias core.stdc.complex.cexp       exp;\n-    ///\n-    alias core.stdc.complex.cexpf      exp;\n-    ///\n-    alias core.stdc.complex.cexpl      exp;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cexp       exp;\n+    deprecated alias core.stdc.complex.cexpf      exp;\n+    deprecated alias core.stdc.complex.cexpl      exp;\n \n     ///\n     alias core.stdc.math.exp2          exp2;\n@@ -804,12 +730,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.logl          log;\n \n-    ///\n-    alias core.stdc.complex.clog       log;\n-    ///\n-    alias core.stdc.complex.clogf      log;\n-    ///\n-    alias core.stdc.complex.clogl      log;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.clog       log;\n+    deprecated alias core.stdc.complex.clogf      log;\n+    deprecated alias core.stdc.complex.clogl      log;\n \n     ///\n     alias core.stdc.math.log10         log10;\n@@ -874,12 +798,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.fabsl         fabs;\n \n-    ///\n-    alias core.stdc.complex.cabs       fabs;\n-    ///\n-    alias core.stdc.complex.cabsf      fabs;\n-    ///\n-    alias core.stdc.complex.cabsl      fabs;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cabs       fabs;\n+    deprecated alias core.stdc.complex.cabsf      fabs;\n+    deprecated alias core.stdc.complex.cabsl      fabs;\n \n     ///\n     alias core.stdc.math.hypot         hypot;\n@@ -895,12 +817,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.powl          pow;\n \n-    ///\n-    alias core.stdc.complex.cpow       pow;\n-    ///\n-    alias core.stdc.complex.cpowf      pow;\n-    ///\n-    alias core.stdc.complex.cpowl      pow;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cpow       pow;\n+    deprecated alias core.stdc.complex.cpowf      pow;\n+    deprecated alias core.stdc.complex.cpowl      pow;\n \n     ///\n     alias core.stdc.math.sqrt          sqrt;\n@@ -909,12 +829,10 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.sqrtl         sqrt;\n \n-    ///\n-    alias core.stdc.complex.csqrt      sqrt;\n-    ///\n-    alias core.stdc.complex.csqrtf     sqrt;\n-    ///\n-    alias core.stdc.complex.csqrtl     sqrt;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csqrt      sqrt;\n+    deprecated alias core.stdc.complex.csqrtf     sqrt;\n+    deprecated alias core.stdc.complex.csqrtl     sqrt;\n \n     ///\n     alias core.stdc.math.erf           erf;\n@@ -1077,37 +995,23 @@ else version (OpenBSD)\n     ///\n     alias core.stdc.math.fmal          fma;\n \n-    ///\n-    alias core.stdc.complex.carg       carg;\n-    ///\n-    alias core.stdc.complex.cargf      carg;\n-    ///\n-    alias core.stdc.complex.cargl      carg;\n-\n-    ///\n-    alias core.stdc.complex.cimag      cimag;\n-    ///\n-    alias core.stdc.complex.cimagf     cimag;\n-    ///\n-    alias core.stdc.complex.cimagl     cimag;\n-\n-    ///\n-    alias core.stdc.complex.conj       conj;\n-    ///\n-    alias core.stdc.complex.conjf      conj;\n-    ///\n-    alias core.stdc.complex.conjl      conj;\n-\n-    ///\n-    alias core.stdc.complex.cproj      cproj;\n-    ///\n-    alias core.stdc.complex.cprojf     cproj;\n-    ///\n-    alias core.stdc.complex.cprojl     cproj;\n-\n-//  alias core.stdc.complex.creal      creal;\n-//  alias core.stdc.complex.crealf     creal;\n-//  alias core.stdc.complex.creall     creal;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.carg       carg;\n+    deprecated alias core.stdc.complex.cargf      carg;\n+    deprecated alias core.stdc.complex.cargl      carg;\n+    deprecated alias core.stdc.complex.cimag      cimag;\n+    deprecated alias core.stdc.complex.cimagf     cimag;\n+    deprecated alias core.stdc.complex.cimagl     cimag;\n+    deprecated alias core.stdc.complex.conj       conj;\n+    deprecated alias core.stdc.complex.conjf      conj;\n+    deprecated alias core.stdc.complex.conjl      conj;\n+    deprecated alias core.stdc.complex.cproj      cproj;\n+    deprecated alias core.stdc.complex.cprojf     cproj;\n+    deprecated alias core.stdc.complex.cprojl     cproj;\n+\n+//  deprecated alias core.stdc.complex.creal      creal;\n+//  deprecated alias core.stdc.complex.crealf     creal;\n+//  deprecated alias core.stdc.complex.creall     creal;\n }\n else\n {\n@@ -1118,12 +1022,10 @@ else\n     ///\n     alias core.stdc.math.acosl         acos;\n \n-    ///\n-    alias core.stdc.complex.cacos      acos;\n-    ///\n-    alias core.stdc.complex.cacosf     acos;\n-    ///\n-    alias core.stdc.complex.cacosl     acos;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cacos      acos;\n+    deprecated alias core.stdc.complex.cacosf     acos;\n+    deprecated alias core.stdc.complex.cacosl     acos;\n \n     ///\n     alias core.stdc.math.asin          asin;\n@@ -1132,12 +1034,10 @@ else\n     ///\n     alias core.stdc.math.asinl         asin;\n \n-    ///\n-    alias core.stdc.complex.casin      asin;\n-    ///\n-    alias core.stdc.complex.casinf     asin;\n-    ///\n-    alias core.stdc.complex.casinl     asin;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.casin      asin;\n+    deprecated alias core.stdc.complex.casinf     asin;\n+    deprecated alias core.stdc.complex.casinl     asin;\n \n     ///\n     alias core.stdc.math.atan          atan;\n@@ -1146,12 +1046,10 @@ else\n     ///\n     alias core.stdc.math.atanl         atan;\n \n-    ///\n-    alias core.stdc.complex.catan      atan;\n-    ///\n-    alias core.stdc.complex.catanf     atan;\n-    ///\n-    alias core.stdc.complex.catanl     atan;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.catan      atan;\n+    deprecated alias core.stdc.complex.catanf     atan;\n+    deprecated alias core.stdc.complex.catanl     atan;\n \n     ///\n     alias core.stdc.math.atan2         atan2;\n@@ -1167,12 +1065,10 @@ else\n     ///\n     alias core.stdc.math.cosl          cos;\n \n-    ///\n-    alias core.stdc.complex.ccos       cos;\n-    ///\n-    alias core.stdc.complex.ccosf      cos;\n-    ///\n-    alias core.stdc.complex.ccosl      cos;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ccos       cos;\n+    deprecated alias core.stdc.complex.ccosf      cos;\n+    deprecated alias core.stdc.complex.ccosl      cos;\n \n     ///\n     alias core.stdc.math.sin           sin;\n@@ -1181,12 +1077,10 @@ else\n     ///\n     alias core.stdc.math.sinl          sin;\n \n-    ///\n-    alias core.stdc.complex.csin       csin;\n-    ///\n-    alias core.stdc.complex.csinf      csin;\n-    ///\n-    alias core.stdc.complex.csinl      csin;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csin       csin;\n+    deprecated alias core.stdc.complex.csinf      csin;\n+    deprecated alias core.stdc.complex.csinl      csin;\n \n     ///\n     alias core.stdc.math.tan           tan;\n@@ -1195,12 +1089,10 @@ else\n     ///\n     alias core.stdc.math.tanl          tan;\n \n-    ///\n-    alias core.stdc.complex.ctan       tan;\n-    ///\n-    alias core.stdc.complex.ctanf      tan;\n-    ///\n-    alias core.stdc.complex.ctanl      tan;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ctan       tan;\n+    deprecated alias core.stdc.complex.ctanf      tan;\n+    deprecated alias core.stdc.complex.ctanl      tan;\n \n     ///\n     alias core.stdc.math.acosh         acosh;\n@@ -1209,12 +1101,10 @@ else\n     ///\n     alias core.stdc.math.acoshl        acosh;\n \n-    ///\n-    alias core.stdc.complex.cacosh     acosh;\n-    ///\n-    alias core.stdc.complex.cacoshf    acosh;\n-    ///\n-    alias core.stdc.complex.cacoshl    acosh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cacosh     acosh;\n+    deprecated alias core.stdc.complex.cacoshf    acosh;\n+    deprecated alias core.stdc.complex.cacoshl    acosh;\n \n     ///\n     alias core.stdc.math.asinh         asinh;\n@@ -1223,12 +1113,10 @@ else\n     ///\n     alias core.stdc.math.asinhl        asinh;\n \n-    ///\n-    alias core.stdc.complex.casinh     asinh;\n-    ///\n-    alias core.stdc.complex.casinhf    asinh;\n-    ///\n-    alias core.stdc.complex.casinhl    asinh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.casinh     asinh;\n+    deprecated alias core.stdc.complex.casinhf    asinh;\n+    deprecated alias core.stdc.complex.casinhl    asinh;\n \n     ///\n     alias core.stdc.math.atanh         atanh;\n@@ -1237,12 +1125,10 @@ else\n     ///\n     alias core.stdc.math.atanhl        atanh;\n \n-    ///\n-    alias core.stdc.complex.catanh     atanh;\n-    ///\n-    alias core.stdc.complex.catanhf    atanh;\n-    ///\n-    alias core.stdc.complex.catanhl    atanh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.catanh     atanh;\n+    deprecated alias core.stdc.complex.catanhf    atanh;\n+    deprecated alias core.stdc.complex.catanhl    atanh;\n \n     ///\n     alias core.stdc.math.cosh          cosh;\n@@ -1251,12 +1137,10 @@ else\n     ///\n     alias core.stdc.math.coshl         cosh;\n \n-    ///\n-    alias core.stdc.complex.ccosh      cosh;\n-    ///\n-    alias core.stdc.complex.ccoshf     cosh;\n-    ///\n-    alias core.stdc.complex.ccoshl     cosh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ccosh      cosh;\n+    deprecated alias core.stdc.complex.ccoshf     cosh;\n+    deprecated alias core.stdc.complex.ccoshl     cosh;\n \n     ///\n     alias core.stdc.math.sinh          sinh;\n@@ -1265,12 +1149,10 @@ else\n     ///\n     alias core.stdc.math.sinhl         sinh;\n \n-    ///\n-    alias core.stdc.complex.csinh      sinh;\n-    ///\n-    alias core.stdc.complex.csinhf     sinh;\n-    ///\n-    alias core.stdc.complex.csinhl     sinh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csinh      sinh;\n+    deprecated alias core.stdc.complex.csinhf     sinh;\n+    deprecated alias core.stdc.complex.csinhl     sinh;\n \n     ///\n     alias core.stdc.math.tanh          tanh;\n@@ -1279,12 +1161,10 @@ else\n     ///\n     alias core.stdc.math.tanhl         tanh;\n \n-    ///\n-    alias core.stdc.complex.ctanh      tanh;\n-    ///\n-    alias core.stdc.complex.ctanhf     tanh;\n-    ///\n-    alias core.stdc.complex.ctanhl     tanh;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.ctanh      tanh;\n+    deprecated alias core.stdc.complex.ctanhf     tanh;\n+    deprecated alias core.stdc.complex.ctanhl     tanh;\n \n     ///\n     alias core.stdc.math.exp           exp;\n@@ -1293,12 +1173,10 @@ else\n     ///\n     alias core.stdc.math.expl          exp;\n \n-    ///\n-    alias core.stdc.complex.cexp       exp;\n-    ///\n-    alias core.stdc.complex.cexpf      exp;\n-    ///\n-    alias core.stdc.complex.cexpl      exp;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cexp       exp;\n+    deprecated alias core.stdc.complex.cexpf      exp;\n+    deprecated alias core.stdc.complex.cexpl      exp;\n \n     ///\n     alias core.stdc.math.exp2          exp2;\n@@ -1342,12 +1220,10 @@ else\n     ///\n     alias core.stdc.math.logl          log;\n \n-    ///\n-    alias core.stdc.complex.clog       log;\n-    ///\n-    alias core.stdc.complex.clogf      log;\n-    ///\n-    alias core.stdc.complex.clogl      log;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.clog       log;\n+    deprecated alias core.stdc.complex.clogf      log;\n+    deprecated alias core.stdc.complex.clogl      log;\n \n     ///\n     alias core.stdc.math.log10         log10;\n@@ -1418,12 +1294,10 @@ else\n         alias core.stdc.math.fabsl         fabs;\n     }\n \n-    ///\n-    alias core.stdc.complex.cabs       fabs;\n-    ///\n-    alias core.stdc.complex.cabsf      fabs;\n-    ///\n-    alias core.stdc.complex.cabsl      fabs;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cabs       fabs;\n+    deprecated alias core.stdc.complex.cabsf      fabs;\n+    deprecated alias core.stdc.complex.cabsl      fabs;\n \n     ///\n     alias core.stdc.math.hypot         hypot;\n@@ -1439,12 +1313,10 @@ else\n     ///\n     alias core.stdc.math.powl          pow;\n \n-    ///\n-    alias core.stdc.complex.cpow       pow;\n-    ///\n-    alias core.stdc.complex.cpowf      pow;\n-    ///\n-    alias core.stdc.complex.cpowl      pow;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.cpow       pow;\n+    deprecated alias core.stdc.complex.cpowf      pow;\n+    deprecated alias core.stdc.complex.cpowl      pow;\n \n     ///\n     alias core.stdc.math.sqrt          sqrt;\n@@ -1453,12 +1325,10 @@ else\n     ///\n     alias core.stdc.math.sqrtl         sqrt;\n \n-    ///\n-    alias core.stdc.complex.csqrt      sqrt;\n-    ///\n-    alias core.stdc.complex.csqrtf     sqrt;\n-    ///\n-    alias core.stdc.complex.csqrtl     sqrt;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.csqrt      sqrt;\n+    deprecated alias core.stdc.complex.csqrtf     sqrt;\n+    deprecated alias core.stdc.complex.csqrtl     sqrt;\n \n     ///\n     alias core.stdc.math.erf           erf;\n@@ -1635,35 +1505,20 @@ else\n     ///\n     alias core.stdc.math.fmal          fma;\n \n-    ///\n-    alias core.stdc.complex.carg       carg;\n-    ///\n-    alias core.stdc.complex.cargf      carg;\n-    ///\n-    alias core.stdc.complex.cargl      carg;\n-\n-    ///\n-    alias core.stdc.complex.cimag      cimag;\n-    ///\n-    alias core.stdc.complex.cimagf     cimag;\n-    ///\n-    alias core.stdc.complex.cimagl     cimag;\n-\n-    ///\n-    alias core.stdc.complex.conj       conj;\n-    ///\n-    alias core.stdc.complex.conjf      conj;\n-    ///\n-    alias core.stdc.complex.conjl      conj;\n-\n-    ///\n-    alias core.stdc.complex.cproj      cproj;\n-    ///\n-    alias core.stdc.complex.cprojf     cproj;\n-    ///\n-    alias core.stdc.complex.cprojl     cproj;\n-\n-//  alias core.stdc.complex.creal      creal;\n-//  alias core.stdc.complex.crealf     creal;\n-//  alias core.stdc.complex.creall     creal;\n+    // @@@DEPRECATED_2.105@@@\n+    deprecated alias core.stdc.complex.carg       carg;\n+    deprecated alias core.stdc.complex.cargf      carg;\n+    deprecated alias core.stdc.complex.cargl      carg;\n+    deprecated alias core.stdc.complex.cimag      cimag;\n+    deprecated alias core.stdc.complex.cimagf     cimag;\n+    deprecated alias core.stdc.complex.cimagl     cimag;\n+    deprecated alias core.stdc.complex.conj       conj;\n+    deprecated alias core.stdc.complex.conjf      conj;\n+    deprecated alias core.stdc.complex.conjl      conj;\n+    deprecated alias core.stdc.complex.cproj      cproj;\n+    deprecated alias core.stdc.complex.cprojf     cproj;\n+    deprecated alias core.stdc.complex.cprojl     cproj;\n+//  deprecated alias core.stdc.complex.creal      creal;\n+//  deprecated alias core.stdc.complex.crealf     creal;\n+//  deprecated alias core.stdc.complex.creall     creal;\n }"}, {"sha": "6da5618ada652c89be4e44b0bdb4b6207301ef73", "filename": "libphobos/libdruntime/core/stdc/wchar_.d", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -173,12 +173,13 @@ extern (D) @trusted\n     wint_t getwchar()                     { return fgetwc(stdin);     }\n     ///\n     wint_t putwchar(wchar_t c)            { return fputwc(c,stdout);  }\n-    ///\n-    wint_t getwc(FILE* stream)            { return fgetwc(stream);    }\n-    ///\n-    wint_t putwc(wchar_t c, FILE* stream) { return fputwc(c, stream); }\n }\n \n+///\n+alias getwc = fgetwc;\n+///\n+alias putwc = fputwc;\n+\n // No unsafe pointer manipulation.\n @trusted\n {"}, {"sha": "47d895ad6cb95880443444955dd9ebcaf43b0cbf", "filename": "libphobos/libdruntime/core/sys/darwin/fcntl.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Ffcntl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Ffcntl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Ffcntl.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,20 @@\n+module core.sys.darwin.fcntl;\n+\n+public import core.sys.posix.fcntl;\n+\n+version (OSX)\n+    version = Darwin;\n+else version (iOS)\n+    version = Darwin;\n+else version (TVOS)\n+    version = Darwin;\n+else version (WatchOS)\n+    version = Darwin;\n+\n+version (Darwin):\n+extern (C):\n+nothrow:\n+@nogc:\n+@system:\n+\n+enum F_FULLFSYNC = 51;"}, {"sha": "f5ff7dba0f803c06c71a3b212f8c1c65eed71d9b", "filename": "libphobos/libdruntime/core/sys/linux/epoll.d", "status": "modified", "additions": 84, "deletions": 4, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fepoll.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fepoll.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fepoll.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -10,6 +10,8 @@ module core.sys.linux.epoll;\n \n version (linux):\n \n+import core.sys.posix.signal : sigset_t;\n+\n extern (C):\n @system:\n @nogc:\n@@ -52,16 +54,19 @@ enum\n     EPOLLHUP    = 0x010,\n     EPOLLRDHUP  = 0x2000, // since Linux 2.6.17\n     EPOLLEXCLUSIVE = 1u << 28, // since Linux 4.5\n+    EPOLLWAKEUP = 1u << 29,\n     EPOLLONESHOT = 1u << 30,\n     EPOLLET     = 1u << 31\n }\n \n-/* Valid opcodes ( \"op\" parameter ) to issue to epoll_ctl().  */\n+/**\n+ * Valid opcodes ( \"op\" parameter ) to issue to epoll_ctl().\n+ */\n enum\n {\n-    EPOLL_CTL_ADD = 1, // Add a file descriptor to the interface.\n-    EPOLL_CTL_DEL = 2, // Remove a file descriptor from the interface.\n-    EPOLL_CTL_MOD = 3, // Change file descriptor epoll_event structure.\n+    EPOLL_CTL_ADD = 1, /// Add a file descriptor to the interface.\n+    EPOLL_CTL_DEL = 2, /// Remove a file descriptor from the interface.\n+    EPOLL_CTL_MOD = 3, /// Change file descriptor epoll_event structure.\n }\n \n version (X86_Any)\n@@ -142,7 +147,82 @@ union epoll_data_t\n     ulong u64;\n }\n \n+/**\n+ * Creates an epoll instance.\n+ *\n+ * Params:\n+ *   size = a hint specifying the number of file descriptors to be associated\n+ *          with the new instance.  T\n+ * Returns: an fd for the new instance. The fd returned by epoll_create() should\n+ *          be closed with close().\n+ * See_also: epoll_create1 (int flags)\n+ */\n int epoll_create (int size);\n+\n+/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE\n+   parameter has been dropped.  */\n+\n+/**\n+ * Creates an epoll instance.\n+ *\n+ * Params:\n+ *   flags = a specified flag. If flags is 0, then, other than the fact that the\n+ *           obsolete size argument is dropped, epoll_create1() is the same as\n+ *           epoll_create().\n+ * Returns: an fd for the new instance. The fd returned by epoll_create() should\n+ *          be closed with close().\n+ * See_also: epoll_create (int size)\n+ */\n int epoll_create1 (int flags);\n+\n+/**\n+ * Manipulate an epoll instance\n+ *\n+ * Params:\n+ *   epfd = an epoll file descriptor instance\n+ *   op = one of the EPOLL_CTL_* constants\n+ *   fd = target file descriptor of the operation\n+ *   event = describes which events the caller is interested in and any\n+ *           associated user dat\n+ * Returns: 0 in case of success, -1 in case of error ( the \"errno\" variable\n+ *          will contain the specific error code )\n+ */\n int epoll_ctl (int epfd, int op, int fd, epoll_event *event);\n+\n+\n+/**\n+ * Wait for events on an epoll instance.\n+ *\n+ *\n+ * Params:\n+ *   epfd = an epoll file descriptor instance\n+ *   events = a buffer that will contain triggered events\n+ *   maxevents = the maximum number of events to be returned ( usually size of\n+ *               \"events\" )\n+ *   timeout = specifies the maximum wait time in milliseconds (-1 == infinite)\n+ *\n+ * Returns: the number of triggered events returned in \"events\" buffer. Or -1 in\n+ *          case of error with the \"errno\" variable set to the specific error\n+ *          code.\n+ */\n int epoll_wait (int epfd, epoll_event *events, int maxevents, int timeout);\n+\n+/**\n+ * Wait for events on an epoll instance\n+ *\n+ *\n+ * Params:\n+ *   epfd = an epoll file descriptor instance\n+ *   events = a buffer that will contain triggered events\n+ *   maxevents = the maximum number of events to be returned ( usually size of\n+ *               \"events\" )\n+ *   timeout = specifies the maximum wait time in milliseconds (-1 == infinite)\n+ *   ss = a signal set. May be specified as `null`, in which case epoll_pwait() is\n+ *        equivalent to epoll_wait().\n+ *\n+ * Returns: the number of triggered events returned in \"events\" buffer. Or -1 in\n+ *          case of error with the \"errno\" variable set to the specific error\n+ *          code.\n+ */\n+int epoll_pwait (int epfd, epoll_event *events, int maxevents, int timeout,\n+    const sigset_t *ss);"}, {"sha": "cb978c8249ba4a3eb9a91dff83e2f8d3681e17cc", "filename": "libphobos/libdruntime/core/sys/openbsd/string.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -18,4 +18,6 @@ nothrow:\n static if (__BSD_VISIBLE)\n {\n     pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure int timingsafe_bcmp(scope const void*, scope const void*, size_t);\n+    pure int timingsafe_memcmp(scope const void*, scope const void*, size_t);\n }"}, {"sha": "ddd102cdeaedc41df9e9c6e46a3edcea780066e3", "filename": "libphobos/libdruntime/core/sys/openbsd/unistd.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Funistd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Funistd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Funistd.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,17 @@\n+/**\n+  * D header file for OpenBSD unistd.h.\n+  *\n+  * Copyright: Copyright \u00a9 2021, The D Language Foundation\n+  * License: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n+  * Authors: Brian Callahan\n+  */\n+module core.sys.openbsd.unistd;\n+public import core.sys.posix.unistd;\n+\n+version (OpenBSD):\n+extern (C):\n+nothrow:\n+@nogc:\n+\n+int pledge(const scope char*, const scope char*);\n+int unveil(const scope char*, const scope char*);"}, {"sha": "3b575fa5b48d705373d23e4712a0285f2037078c", "filename": "libphobos/libdruntime/core/sys/posix/config.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fconfig.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -117,6 +117,7 @@ else version (CRuntime_UClibc)\n else version (CRuntime_Bionic)\n {\n     enum _GNU_SOURCE         = false;\n+    enum __USE_FILE_OFFSET64 = false; // see https://android.googlesource.com/platform/bionic/+/master/docs/32-bit-abi.md\n     enum __USE_GNU           = _GNU_SOURCE;\n \n     version (D_LP64)"}, {"sha": "2477e26dc53df080d4a9e9129cd6eafb3951b40b", "filename": "libphobos/libdruntime/core/sys/posix/dlfcn.d", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -139,7 +139,7 @@ else version (Darwin)\n     char* dlerror();\n     void* dlopen(const scope char*, int);\n     void* dlsym(void*, const scope char*);\n-    int   dladdr(void* addr, Dl_info* info);\n+    int   dladdr(scope const void* addr, Dl_info* info);\n \n     struct Dl_info\n     {\n@@ -294,6 +294,15 @@ else version (CRuntime_Musl)\n     const(char)* dlerror();\n     void*        dlopen(const scope char*, int);\n     void*        dlsym(void*, const scope char*);\n+\n+    int dladdr(scope const void *addr, Dl_info *info);\n+    struct Dl_info\n+    {\n+        const(char)* dli_fname;\n+        void*        dli_fbase;\n+        const(char)* dli_sname;\n+        void*        dli_saddr;\n+    }\n }\n else version (CRuntime_UClibc)\n {"}, {"sha": "0dce8c53f31e416421e554b69d61ca3d5c44ff86", "filename": "libphobos/libdruntime/core/sys/posix/signal.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -3503,7 +3503,7 @@ struct sigevent\n     pthread_attr_t* sigev_notify_attributes;\n }\n \n-int sigqueue(pid_t, int, in sigval);\n+int sigqueue(pid_t, int, const sigval);\n int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n */\n@@ -3543,7 +3543,7 @@ version (CRuntime_Glibc)\n         } _sigev_un_t _sigev_un;\n     }\n \n-    int sigqueue(pid_t, int, in sigval);\n+    int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n@@ -3566,7 +3566,7 @@ else version (FreeBSD)\n         }\n     }\n \n-    int sigqueue(pid_t, int, in sigval);\n+    int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n@@ -3581,7 +3581,7 @@ else version (NetBSD)\n         void /* pthread_attr_t */*sigev_notify_attributes;\n     }\n \n-    int sigqueue(pid_t, int, in sigval);\n+    int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n@@ -3613,7 +3613,7 @@ else version (DragonFlyBSD)\n         void function(_sigval_t)  sigev_notify_function;\n     }\n \n-    int sigqueue(pid_t, int, in sigval);\n+    int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n@@ -3640,7 +3640,7 @@ else version (Solaris)\n         int __sigev_pad2;\n     }\n \n-    int sigqueue(pid_t, int, in sigval);\n+    int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n@@ -3717,7 +3717,7 @@ else version (CRuntime_UClibc)\n     @property void function(sigval) sigev_notify_function(ref sigevent _sigevent) { return _sigevent._sigev_un._sigev_thread._function; }\n     @property void* sigev_notify_attributes(ref sigevent _sigevent) { return  _sigevent._sigev_un._sigev_thread._attribute; }\n \n-    int sigqueue(pid_t, int, in sigval);\n+    int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }"}, {"sha": "d996556fca0c42b49c03f61d1f8a0425b9e4a770", "filename": "libphobos/libdruntime/core/sys/posix/unistd.d", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Funistd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Funistd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Funistd.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -2722,3 +2722,51 @@ else version (CRuntime_UClibc)\n     int        truncate(const scope char*, off_t);\n   }\n }\n+\n+// Non-standard definition to access user process environment\n+version (CRuntime_Glibc)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (Darwin)\n+{\n+    extern (D) @property const(char**) environ()()\n+    {\n+        pragma (inline, true);\n+        import core.sys.darwin.crt_externs : _NSGetEnviron;\n+        return *_NSGetEnviron();\n+    }\n+}\n+else version (FreeBSD)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (NetBSD)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (OpenBSD)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (DragonFlyBSD)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (CRuntime_Bionic)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (CRuntime_Musl)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (Solaris)\n+{\n+    extern __gshared const char** environ;\n+}\n+else version (CRuntime_UClibc)\n+{\n+    extern __gshared const char** __environ;\n+    alias environ = __environ;\n+}"}, {"sha": "88007adb1416a20b9a88833f64d414d64f93686a", "filename": "libphobos/libdruntime/core/sys/windows/com.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcom.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcom.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcom.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -39,16 +39,16 @@ public import core.sys.windows.winerror :\n     RPC_E_CHANGED_MODE;\n \n public import core.sys.windows.wtypes :\n-    OLECHAR, LPOLESTR, LPCOLESTR;\n-\n-alias CLSCTX_INPROC_SERVER     = core.sys.windows.wtypes.CLSCTX.CLSCTX_INPROC_SERVER    ;\n-alias CLSCTX_INPROC_HANDLER    = core.sys.windows.wtypes.CLSCTX.CLSCTX_INPROC_HANDLER   ;\n-alias CLSCTX_LOCAL_SERVER      = core.sys.windows.wtypes.CLSCTX.CLSCTX_LOCAL_SERVER     ;\n-alias CLSCTX_INPROC_SERVER16   = core.sys.windows.wtypes.CLSCTX.CLSCTX_INPROC_SERVER16  ;\n-alias CLSCTX_REMOTE_SERVER     = core.sys.windows.wtypes.CLSCTX.CLSCTX_REMOTE_SERVER    ;\n-alias CLSCTX_INPROC_HANDLER16  = core.sys.windows.wtypes.CLSCTX.CLSCTX_INPROC_HANDLER16 ;\n-alias CLSCTX_INPROC_SERVERX86  = core.sys.windows.wtypes.CLSCTX.CLSCTX_INPROC_SERVERX86 ;\n-alias CLSCTX_INPROC_HANDLERX86 = core.sys.windows.wtypes.CLSCTX.CLSCTX_INPROC_HANDLERX86;\n+    CLSCTX, OLECHAR, LPOLESTR, LPCOLESTR;\n+\n+alias CLSCTX_INPROC_SERVER     = CLSCTX.CLSCTX_INPROC_SERVER    ;\n+alias CLSCTX_INPROC_HANDLER    = CLSCTX.CLSCTX_INPROC_HANDLER   ;\n+alias CLSCTX_LOCAL_SERVER      = CLSCTX.CLSCTX_LOCAL_SERVER     ;\n+alias CLSCTX_INPROC_SERVER16   = CLSCTX.CLSCTX_INPROC_SERVER16  ;\n+alias CLSCTX_REMOTE_SERVER     = CLSCTX.CLSCTX_REMOTE_SERVER    ;\n+alias CLSCTX_INPROC_HANDLER16  = CLSCTX.CLSCTX_INPROC_HANDLER16 ;\n+alias CLSCTX_INPROC_SERVERX86  = CLSCTX.CLSCTX_INPROC_SERVERX86 ;\n+alias CLSCTX_INPROC_HANDLERX86 = CLSCTX.CLSCTX_INPROC_HANDLERX86;\n \n alias COINIT_APARTMENTTHREADED   = COINIT.COINIT_APARTMENTTHREADED;\n alias COINIT_MULTITHREADED       = COINIT.COINIT_MULTITHREADED    ;"}, {"sha": "3df0d7fd41b01a32f9ea22218e8b0e4c9bbc6e90", "filename": "libphobos/libdruntime/core/sys/windows/dll.d", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdll.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdll.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdll.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -31,17 +31,7 @@ public import core.sys.windows.threadaux;\n //  not access tls_array[tls_index] as needed for thread local _tlsstart and _tlsend\n extern (C)\n {\n-        version (MinGW)\n-        {\n-            extern __gshared void* _tls_start;\n-            extern __gshared void* _tls_end;\n-            extern __gshared void* __xl_a;\n-\n-            alias _tls_start _tlsstart;\n-            alias _tls_end   _tlsend;\n-            alias __xl_a     _tls_callbacks_a;\n-        }\n-        else version (Win32)\n+    version (Win32)\n     {\n         version (CRuntime_DigitalMars)\n         {"}, {"sha": "f52ba37f27efdf4245765f59b068622198dfabe7", "filename": "libphobos/libdruntime/core/sys/windows/stdc/malloc.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstdc%2Fmalloc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstdc%2Fmalloc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstdc%2Fmalloc.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,26 @@\n+/**\n+  * D header file for Windows malloc.h.\n+ *\n+ * Translated from MinGW Windows headers\n+ *\n+ * Authors: Iain Buclaw\n+ * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source: $(DRUNTIMESRC src/core/sys/windows/stdc/_malloc.d)\n+ */\n+module core.sys.windows.stdc.malloc;\n+version (CRuntime_Microsoft):\n+extern (C):\n+@system:\n+nothrow:\n+@nogc:\n+\n+export void* _recalloc(void*, size_t, size_t);\n+\n+export void _aligned_free(void*);\n+export void* _aligned_malloc(size_t, size_t);\n+\n+export void* _aligned_offset_malloc(size_t, size_t, size_t);\n+export void* _aligned_realloc(void*, size_t, size_t);\n+export void* _aligned_recalloc(void*, size_t, size_t, size_t);\n+export void* _aligned_offset_realloc(void*, size_t, size_t, size_t);\n+export void* _aligned_offset_recalloc(void*, size_t, size_t, size_t, size_t);"}, {"sha": "300a32ad2b0dad21666f9890083152ca9469fea5", "filename": "libphobos/libdruntime/gc/impl/conservative/gc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgc%2Fimpl%2Fconservative%2Fgc.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -76,7 +76,7 @@ debug(PRINTF_TO_FILE)\n                 gcStartTick = MonoTime.currTime;\n             immutable timeElapsed = MonoTime.currTime - gcStartTick;\n             immutable secondsAsDouble = timeElapsed.total!\"hnsecs\" / cast(double)convert!(\"seconds\", \"hnsecs\")(1);\n-            len = fprintf(gcx_fh, \"%10.6lf: \", secondsAsDouble);\n+            len = fprintf(gcx_fh, \"%10.6f: \", secondsAsDouble);\n         }\n         len += fprintf(gcx_fh, fmt, args);\n         fflush(gcx_fh);\n@@ -159,7 +159,7 @@ debug (LOGGING)\n             printf(\"    p = %p, size = %zd, parent = %p \", p, size, parent);\n             if (file)\n             {\n-                printf(\"%s(%u)\", file, line);\n+                printf(\"%s(%u)\", file, cast(uint)line);\n             }\n             printf(\"\\n\");\n         }"}, {"sha": "c05643bf36dd6969641c85f5098b56bc38aebcbe", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -19,10 +19,11 @@ private\n alias size_t = typeof(int.sizeof);\n alias ptrdiff_t = typeof(cast(void*)0 - cast(void*)0);\n \n-alias sizediff_t = ptrdiff_t; //For backwards compatibility only.\n+alias sizediff_t = ptrdiff_t; // For backwards compatibility only.\n+alias noreturn = typeof(*null);  /// bottom type\n \n-alias hash_t = size_t; //For backwards compatibility only.\n-alias equals_t = bool; //For backwards compatibility only.\n+alias hash_t = size_t; // For backwards compatibility only.\n+alias equals_t = bool; // For backwards compatibility only.\n \n alias string  = immutable(char)[];\n alias wstring = immutable(wchar)[];"}, {"sha": "4f6a168350b7dd2631584fe952d2ac2049599c65", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1,4 +1,4 @@\n-9d575282edeccecbc061e615bf2486fd07e8c084\n+f89dc217a680fa1a83f2999fea04b7c562f705ee\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "2dedc740f16149fd57c256a7d836df367366dff0", "filename": "libphobos/src/Makefile.am", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.am?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -135,11 +135,11 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/sqlite3.d etc/c/zlib.d \\\n \tstd/regex/internal/backtracking.d std/regex/internal/generator.d \\\n \tstd/regex/internal/ir.d std/regex/internal/kickstart.d \\\n \tstd/regex/internal/parser.d std/regex/internal/tests.d \\\n-\tstd/regex/internal/thompson.d std/regex/package.d std/signals.d \\\n-\tstd/socket.d std/stdint.d std/stdio.d std/string.d std/system.d \\\n-\tstd/traits.d std/typecons.d std/typetuple.d std/uni.d std/uri.d \\\n-\tstd/utf.d std/uuid.d std/variant.d std/windows/charset.d \\\n-\tstd/windows/registry.d std/windows/syserror.d std/xml.d std/zip.d \\\n-\tstd/zlib.d\n+\tstd/regex/internal/tests2.d std/regex/internal/thompson.d \\\n+\tstd/regex/package.d std/signals.d std/socket.d std/stdint.d \\\n+\tstd/stdio.d std/string.d std/system.d std/traits.d std/typecons.d \\\n+\tstd/typetuple.d std/uni.d std/uri.d std/utf.d std/uuid.d std/variant.d \\\n+\tstd/windows/charset.d std/windows/registry.d std/windows/syserror.d \\\n+\tstd/xml.d std/zip.d std/zlib.d\n \n endif"}, {"sha": "9e410e5b642e31e503337e458ae31386b6b26878", "filename": "libphobos/src/Makefile.in", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.in?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -249,6 +249,7 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/kickstart.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/parser.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/tests.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/tests2.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/thompson.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/package.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/signals.lo std/socket.lo \\\n@@ -572,12 +573,12 @@ libgphobos_la_LINK = $(LIBTOOL) --tag=D $(libgphobos_la_LIBTOOLFLAGS) \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/backtracking.d std/regex/internal/generator.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/ir.d std/regex/internal/kickstart.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/parser.d std/regex/internal/tests.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/thompson.d std/regex/package.d std/signals.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/socket.d std/stdint.d std/stdio.d std/string.d std/system.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/traits.d std/typecons.d std/typetuple.d std/uni.d std/uri.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/utf.d std/uuid.d std/variant.d std/windows/charset.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/registry.d std/windows/syserror.d std/xml.d std/zip.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/zlib.d\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/internal/tests2.d std/regex/internal/thompson.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/regex/package.d std/signals.d std/socket.d std/stdint.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/stdio.d std/string.d std/system.d std/traits.d std/typecons.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/typetuple.d std/uni.d std/uri.d std/utf.d std/uuid.d std/variant.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/charset.d std/windows/registry.d std/windows/syserror.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/xml.d std/zip.d std/zlib.d\n \n \n # Source file definitions. Boring stuff, auto-generated with\n@@ -851,6 +852,7 @@ std/regex/internal/ir.lo: std/regex/internal/$(am__dirstamp)\n std/regex/internal/kickstart.lo: std/regex/internal/$(am__dirstamp)\n std/regex/internal/parser.lo: std/regex/internal/$(am__dirstamp)\n std/regex/internal/tests.lo: std/regex/internal/$(am__dirstamp)\n+std/regex/internal/tests2.lo: std/regex/internal/$(am__dirstamp)\n std/regex/internal/thompson.lo: std/regex/internal/$(am__dirstamp)\n std/regex/$(am__dirstamp):\n \t@$(MKDIR_P) std/regex"}, {"sha": "19cfb77053d29bdb34a56371f14a9fbfc2b3dd39", "filename": "libphobos/src/std/algorithm/iteration.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -769,9 +769,9 @@ private struct MapResult(alias fun, Range)\n     string  s1 = \"hello world!\";\n     dstring s2 = \"\u65e5\u672c\u8a9e\";\n     dstring s3 = \"hello world!\"d;\n-    auto ms1 = map!(std.ascii.toUpper)(s1);\n-    auto ms2 = map!(std.ascii.toUpper)(s2);\n-    auto ms3 = map!(std.ascii.toUpper)(s3);\n+    auto ms1 = map!(toUpper)(s1);\n+    auto ms2 = map!(toUpper)(s2);\n+    auto ms3 = map!(toUpper)(s3);\n     static assert(!is(ms1[0])); //narrow strings can't be indexed\n     assert(ms2[0] == '\u65e5');\n     assert(ms3[0] == 'H');\n@@ -4450,7 +4450,7 @@ private struct SplitterResult(alias isTerminator, Range)\n         [\"l\u00e0\", \"dove\", \"terminava\", \"quella\", \"valle\"]\n     ));\n     assert(equal(\n-        splitter!(std.uni.isWhite)(\"l\u00e0 dove terminava quella valle\"),\n+        splitter!(isWhite)(\"l\u00e0 dove terminava quella valle\"),\n         [\"l\u00e0\", \"dove\", \"terminava\", \"quella\", \"valle\"]\n     ));\n     assert(equal(splitter!\"a=='\u672c'\"(\"\u65e5\u672c\u8a9e\"), [\"\u65e5\", \"\u8a9e\"]));"}, {"sha": "09073f6d1aa10f069586b3474118fdb818f51d9d", "filename": "libphobos/src/std/algorithm/searching.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -959,8 +959,8 @@ if (isInputRange!R &&\n     import std.ascii : isDigit;\n     import std.uni : isWhite;\n \n-    assert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\n-    assert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\n+    assert(countUntil!(isWhite)(\"hello world\") == 5);\n+    assert(countUntil!(isDigit)(\"hello world\") == -1);\n     assert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n }\n "}, {"sha": "5e31ac2989b1317767d67f707baf95207db0ba1e", "filename": "libphobos/src/std/container/rbtree.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -1814,8 +1814,8 @@ assert(equal(rbt[], [5]));\n     test!byte();\n }\n \n-import std.range.primitives : isInputRange, isSomeString, ElementType;\n-import std.traits : isArray;\n+import std.range.primitives : isInputRange, ElementType;\n+import std.traits : isArray, isSomeString;\n \n /++\n     Convenience function for creating a $(D RedBlackTree!E) from a list of"}, {"sha": "3560d134f58468eab47dfb093ccd49676003a0f3", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -3967,7 +3967,7 @@ if (isOctalLiteral(num))\n \n /// Ditto\n template octal(alias decimalInteger)\n-if (isIntegral!(typeof(decimalInteger)))\n+if (is(typeof(decimalInteger)) && isIntegral!(typeof(decimalInteger)))\n {\n     enum octal = octal!(typeof(decimalInteger))(to!string(decimalInteger));\n }"}, {"sha": "913d360c655bccec174b5bdf978e50a098b5fcb7", "filename": "libphobos/src/std/datetime/systime.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -9569,7 +9569,7 @@ afterMon: stripAndCheckLen(value[3 .. value.length], \"1200:00A\".length);\n     }\n \n     // year\n-    auto found = value[2 .. value.length].find!(not!(std.ascii.isDigit))();\n+    auto found = value[2 .. value.length].find!(not!(isDigit))();\n     size_t yearLen = value.length - found.length;\n     if (found.length == 0)\n         throw new DateTimeException(\"Invalid year\");\n@@ -9659,7 +9659,7 @@ afterMon: stripAndCheckLen(value[3 .. value.length], \"1200:00A\".length);\n             case \"J\": case \"j\": throw new DateTimeException(\"Invalid timezone\");\n             default:\n             {\n-                if (all!(std.ascii.isAlpha)(value[0 .. tzLen]))\n+                if (all!(isAlpha)(value[0 .. tzLen]))\n                 {\n                     tz = new immutable SimpleTimeZone(Duration.zero);\n                     break;"}, {"sha": "0c55377d0f9de6ccb7e9398871b79fc491fff713", "filename": "libphobos/src/std/experimental/logger/nulllogger.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fnulllogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fnulllogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fnulllogger.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -31,7 +31,7 @@ class NullLogger : Logger\n ///\n @safe unittest\n {\n-    import std.experimental.logger.nulllogger : LogLevel;\n+    import std.experimental.logger.core : LogLevel;\n \n     auto nl1 = new NullLogger(LogLevel.all);\n     nl1.info(\"You will never read this.\");"}, {"sha": "07eed8fad6969836d125f9b723d9403e2a6babc2", "filename": "libphobos/src/std/experimental/typecons.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fexperimental%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fexperimental%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Ftypecons.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -23,8 +23,7 @@ module std.experimental.typecons;\n import std.meta; // : AliasSeq, allSatisfy;\n import std.traits;\n \n-import std.typecons : Tuple, tuple, Bind, DerivedFunctionType,\n-       isImplicitlyConvertible, mixinAll, staticIota,\n+import std.typecons : Tuple, tuple, Bind, DerivedFunctionType, mixinAll, staticIota,\n        GetOverloadedMethods;\n \n private\n@@ -113,7 +112,8 @@ if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))\n             else\n             {\n                 enum foundFunc = findCovariantFunction!(TargetMembers[i], Source, SourceMembers);\n-                debug\n+                version (unittest) {}\n+                else debug\n                 {\n                     static if (foundFunc == -1)\n                         pragma(msg, \"Could not locate matching function for: \","}, {"sha": "99530cbbeb0bb517d73396d125f893b6558f3ce4", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -2301,7 +2301,7 @@ if (isConvertibleToString!R)\n \n @safe unittest\n {\n-    import std.path : mkdir;\n+    import std.file : mkdir;\n     static assert(__traits(compiles, mkdir(TestAliasedString(null))));\n }\n \n@@ -4112,7 +4112,8 @@ auto dirEntries(string path, SpanMode mode, bool followSymlink = true)\n     import std.algorithm.searching : startsWith;\n     import std.array : array;\n     import std.conv : to;\n-    import std.path : dirEntries, buildPath, absolutePath;\n+    import std.path : buildPath, absolutePath;\n+    import std.file : dirEntries;\n     import std.process : thisProcessID;\n     import std.range.primitives : walkLength;\n "}, {"sha": "17e5906baf71385cc1404955eeabcc061c0bdf6b", "filename": "libphobos/src/std/format.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -5199,7 +5199,7 @@ body\n     }\n     debug (unformatRange) printf(\"\\t\");\n     debug (unformatRange) if (!input.empty) printf(\"input.front = %c, \", input.front);\n-    debug (unformatRange) printf(\"cont = %.*s\\n\", cont);\n+    debug (unformatRange) printf(\"cont = %.*s\\n\", cast(int) cont.length, cont.ptr);\n \n     bool checkEnd()\n     {\n@@ -5246,7 +5246,7 @@ body\n             auto sep = spec.sep !is null ? spec.sep\n                          : fmt.trailing;\n             debug (unformatRange) {\n-            if (!sep.empty && !input.empty) printf(\"-> %c, sep = %.*s\\n\", input.front, sep);\n+            if (!sep.empty && !input.empty) printf(\"-> %c, sep = %.*s\\n\", input.front, cast(int) sep.length, sep.ptr);\n             else                            printf(\"\\n\");\n             }\n "}, {"sha": "6fc2d16734f633efc544d0ac09446df3ae7b8dae", "filename": "libphobos/src/std/internal/math/biguintcore.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintcore.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -2503,13 +2503,13 @@ pure nothrow\n     void printBiguint(const uint [] data)\n     {\n         char [] buff = biguintToHex(new char[data.length*9], data, '_');\n-        printf(\"%.*s\\n\", buff.length, buff.ptr);\n+        printf(\"%.*s\\n\", cast(int) buff.length, buff.ptr);\n     }\n \n     void printDecimalBigUint(BigUint data)\n     {\n         auto str = data.toDecimalString(0);\n-        printf(\"%.*s\\n\", str.length, str.ptr);\n+        printf(\"%.*s\\n\", cast(int) str.length, str.ptr);\n     }\n \n     uint [] a, b;"}, {"sha": "336c11a55e2a19504c2b47d619c6be0131fe70f3", "filename": "libphobos/src/std/math.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -263,8 +263,8 @@ version (unittest)\n             alias real_t = double;\n         else\n             alias real_t = real;\n-        ix = sprintf(bufx.ptr, \"%.*Lg\", ndigits, cast(real_t) x);\n-        iy = sprintf(bufy.ptr, \"%.*Lg\", ndigits, cast(real_t) y);\n+        ix = sprintf(bufx.ptr, is(real_t == real) ? \"%.*Lg\" : \"%.*g\", ndigits, cast(real_t) x);\n+        iy = sprintf(bufy.ptr, is(real_t == real) ? \"%.*Lg\" : \"%.*g\", ndigits, cast(real_t) y);\n         assert(ix < bufx.length && ix > 0);\n         assert(ix < bufy.length && ix > 0);\n "}, {"sha": "61d5cea55f9a5b04078357e9f5f51034b8b158e2", "filename": "libphobos/src/std/parallelism.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fparallelism.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fparallelism.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fparallelism.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -4000,7 +4000,7 @@ version (unittest)\n     import std.array : split;\n     import std.conv : text;\n     import std.exception : assertThrown;\n-    import std.math : approxEqual, sqrt, log;\n+    import std.math : approxEqual, sqrt, log, abs;\n     import std.range : indexed, iota, join;\n     import std.typecons : Tuple, tuple;\n \n@@ -4329,7 +4329,7 @@ version (unittest)\n \n     assert(equal(iota(1_000_000), bufTrickTest));\n \n-    auto myTask = task!(std.math.abs)(-1);\n+    auto myTask = task!(abs)(-1);\n     taskPool.put(myTask);\n     assert(myTask.spinForce == 1);\n "}, {"sha": "deedb689974bcc165750201b4a485dd58c4bab7c", "filename": "libphobos/src/std/range/package.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -11379,7 +11379,6 @@ if (isInputRange!R && isIntegral!(ElementType!R))\n         bw.popFront();\n         assert(bw[2 * bitsNum - 3] == true);\n \n-        import core.exception : Error;\n         import std.exception : assertThrown;\n \n         // Check out of bounds error"}, {"sha": "fe75ce03c0acb621e249a3c8cc836cc0ad759a08", "filename": "libphobos/src/std/regex/internal/tests.d", "status": "modified", "additions": 1, "deletions": 652, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Ftests.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Ftests.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Ftests.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -8,7 +8,7 @@ package(std.regex):\n import std.conv, std.exception, std.meta, std.range,\n     std.typecons, std.regex;\n \n-import std.regex.internal.parser : Escapables; // characters that need escaping\n+import std.regex.internal.ir : Escapables; // characters that need escaping\n \n alias Sequence(int B, int E) = staticIota!(B, E);\n \n@@ -467,654 +467,3 @@ alias Sequence(int B, int E) = staticIota!(B, E);\n     run_tests!match(); //thompson VM\n }\n \n-@safe unittest\n-{\n-    auto cr = ctRegex!(\"abc\");\n-    assert(bmatch(\"abc\",cr).hit == \"abc\");\n-    auto cr2 = ctRegex!(\"ab*c\");\n-    assert(bmatch(\"abbbbc\",cr2).hit == \"abbbbc\");\n-}\n-@safe unittest\n-{\n-    auto cr3 = ctRegex!(\"^abc$\");\n-    assert(bmatch(\"abc\",cr3).hit == \"abc\");\n-    auto cr4 = ctRegex!(`\\b(a\\B[a-z]b)\\b`);\n-    assert(array(match(\"azb\",cr4).captures) == [\"azb\", \"azb\"]);\n-}\n-\n-@safe unittest\n-{\n-    auto cr5 = ctRegex!(\"(?:a{2,4}b{1,3}){1,2}\");\n-    assert(bmatch(\"aaabaaaabbb\", cr5).hit == \"aaabaaaabbb\");\n-    auto cr6 = ctRegex!(\"(?:a{2,4}b{1,3}){1,2}?\"w);\n-    assert(bmatch(\"aaabaaaabbb\"w,  cr6).hit == \"aaab\"w);\n-}\n-\n-@safe unittest\n-{\n-    auto cr7 = ctRegex!(`\\r.*?$`,\"sm\");\n-    assert(bmatch(\"abc\\r\\nxy\",  cr7).hit == \"\\r\\nxy\");\n-    auto greed =  ctRegex!(\"<packet.*?/packet>\");\n-    assert(bmatch(\"<packet>text</packet><packet>text</packet>\", greed).hit\n-            == \"<packet>text</packet>\");\n-}\n-\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    auto cr8 = ctRegex!(\"^(a)(b)?(c*)\");\n-    auto m8 = bmatch(\"abcc\",cr8);\n-    assert(m8);\n-    assert(m8.captures[1] == \"a\");\n-    assert(m8.captures[2] == \"b\");\n-    assert(m8.captures[3] == \"cc\");\n-    auto cr9 = ctRegex!(\"q(a|b)*q\");\n-    auto m9 = match(\"xxqababqyy\",cr9);\n-    assert(m9);\n-    assert(equal(bmatch(\"xxqababqyy\",cr9).captures, [\"qababq\", \"b\"]));\n-}\n-\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    auto rtr = regex(\"a|b|c\");\n-    enum ctr = regex(\"a|b|c\");\n-    assert(equal(rtr.ir,ctr.ir));\n-    //CTFE parser BUG is triggered by group\n-    //in the middle of alternation (at least not first and not last)\n-    enum testCT = regex(`abc|(edf)|xyz`);\n-    auto testRT = regex(`abc|(edf)|xyz`);\n-    assert(equal(testCT.ir,testRT.ir));\n-}\n-\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    import std.algorithm.iteration : map;\n-    enum cx = ctRegex!\"(A|B|C)\";\n-    auto mx = match(\"B\",cx);\n-    assert(mx);\n-    assert(equal(mx.captures, [ \"B\", \"B\"]));\n-    enum cx2 = ctRegex!\"(A|B)*\";\n-    assert(match(\"BAAA\",cx2));\n-\n-    enum cx3 = ctRegex!(\"a{3,4}\",\"i\");\n-    auto mx3 = match(\"AaA\",cx3);\n-    assert(mx3);\n-    assert(mx3.captures[0] == \"AaA\");\n-    enum cx4 = ctRegex!(`^a{3,4}?[a-zA-Z0-9~]{1,2}`,\"i\");\n-    auto mx4 = match(\"aaaabc\", cx4);\n-    assert(mx4);\n-    assert(mx4.captures[0] == \"aaaab\");\n-    auto cr8 = ctRegex!(\"(a)(b)?(c*)\");\n-    auto m8 = bmatch(\"abcc\",cr8);\n-    assert(m8);\n-    assert(m8.captures[1] == \"a\");\n-    assert(m8.captures[2] == \"b\");\n-    assert(m8.captures[3] == \"cc\");\n-    auto cr9 = ctRegex!(\".*$\", \"gm\");\n-    auto m9 = match(\"First\\rSecond\", cr9);\n-    assert(m9);\n-    assert(equal(map!\"a.hit\"(m9), [\"First\", \"\", \"Second\"]));\n-}\n-\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    import std.algorithm.iteration : map;\n-//global matching\n-    void test_body(alias matchFn)()\n-    {\n-        string s = \"a quick brown fox jumps over a lazy dog\";\n-        auto r1 = regex(\"\\\\b[a-z]+\\\\b\",\"g\");\n-        string[] test;\n-        foreach (m; matchFn(s, r1))\n-            test ~= m.hit;\n-        assert(equal(test, [ \"a\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"a\", \"lazy\", \"dog\"]));\n-        auto free_reg = regex(`\n-\n-            abc\n-            \\s+\n-            \"\n-            (\n-                    [^\"]+\n-                |   \\\\ \"\n-            )+\n-            \"\n-            z\n-        `, \"x\");\n-        auto m = match(`abc  \"quoted string with \\\" inside\"z`,free_reg);\n-        assert(m);\n-        string mails = \" hey@you.com no@spam.net \";\n-        auto rm = regex(`@(?<=\\S+@)\\S+`,\"g\");\n-        assert(equal(map!\"a[0]\"(matchFn(mails, rm)), [\"@you.com\", \"@spam.net\"]));\n-        auto m2 = matchFn(\"First line\\nSecond line\",regex(\".*$\",\"gm\"));\n-        assert(equal(map!\"a[0]\"(m2), [\"First line\", \"\", \"Second line\"]));\n-        auto m2a = matchFn(\"First line\\nSecond line\",regex(\".+$\",\"gm\"));\n-        assert(equal(map!\"a[0]\"(m2a), [\"First line\", \"Second line\"]));\n-        auto m2b = matchFn(\"First line\\nSecond line\",regex(\".+?$\",\"gm\"));\n-        assert(equal(map!\"a[0]\"(m2b), [\"First line\", \"Second line\"]));\n-        debug(std_regex_test) writeln(\"!!! FReD FLAGS test done \"~matchFn.stringof~\" !!!\");\n-    }\n-    test_body!bmatch();\n-    test_body!match();\n-}\n-\n-//tests for accumulated std.regex issues and other regressions\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    import std.algorithm.iteration : map;\n-    void test_body(alias matchFn)()\n-    {\n-        //issue 5857\n-        //matching goes out of control if ... in (...){x} has .*/.+\n-        auto c = matchFn(\"axxxzayyyyyzd\",regex(\"(a.*z){2}d\")).captures;\n-        assert(c[0] == \"axxxzayyyyyzd\");\n-        assert(c[1] == \"ayyyyyz\");\n-        auto c2 = matchFn(\"axxxayyyyyd\",regex(\"(a.*){2}d\")).captures;\n-        assert(c2[0] == \"axxxayyyyyd\");\n-        assert(c2[1] == \"ayyyyy\");\n-        //issue 2108\n-        //greedy vs non-greedy\n-        auto nogreed = regex(\"<packet.*?/packet>\");\n-        assert(matchFn(\"<packet>text</packet><packet>text</packet>\", nogreed).hit\n-               == \"<packet>text</packet>\");\n-        auto greed =  regex(\"<packet.*/packet>\");\n-        assert(matchFn(\"<packet>text</packet><packet>text</packet>\", greed).hit\n-               == \"<packet>text</packet><packet>text</packet>\");\n-        //issue 4574\n-        //empty successful match still advances the input\n-        string[] pres, posts, hits;\n-        foreach (m; matchFn(\"abcabc\", regex(\"\",\"g\")))\n-        {\n-            pres ~= m.pre;\n-            posts ~= m.post;\n-            assert(m.hit.empty);\n-\n-        }\n-        auto heads = [\n-            \"abcabc\",\n-            \"abcab\",\n-            \"abca\",\n-            \"abc\",\n-            \"ab\",\n-            \"a\",\n-            \"\"\n-        ];\n-        auto tails = [\n-            \"abcabc\",\n-             \"bcabc\",\n-              \"cabc\",\n-               \"abc\",\n-                \"bc\",\n-                 \"c\",\n-                  \"\"\n-        ];\n-        assert(pres == array(retro(heads)));\n-        assert(posts == tails);\n-        //issue 6076\n-        //regression on .*\n-        auto re = regex(\"c.*|d\");\n-        auto m = matchFn(\"mm\", re);\n-        assert(!m);\n-        debug(std_regex_test) writeln(\"!!! FReD REGRESSION test done \"~matchFn.stringof~\" !!!\");\n-        auto rprealloc = regex(`((.){5}.{1,10}){5}`);\n-        auto arr = array(repeat('0',100));\n-        auto m2 = matchFn(arr, rprealloc);\n-        assert(m2);\n-        assert(collectException(\n-                regex(r\"^(import|file|binary|config)\\s+([^\\(]+)\\(?([^\\)]*)\\)?\\s*$\")\n-                ) is null);\n-        foreach (ch; [Escapables])\n-        {\n-            assert(match(to!string(ch),regex(`[\\`~ch~`]`)));\n-            assert(!match(to!string(ch),regex(`[^\\`~ch~`]`)));\n-            assert(match(to!string(ch),regex(`[\\`~ch~`-\\`~ch~`]`)));\n-        }\n-        //bugzilla 7718\n-        string strcmd = \"./myApp.rb -os OSX -path \\\"/GIT/Ruby Apps/sec\\\" -conf 'notimer'\";\n-        auto reStrCmd = regex (`(\".*\")|('.*')`, \"g\");\n-        assert(equal(map!\"a[0]\"(matchFn(strcmd, reStrCmd)),\n-                     [`\"/GIT/Ruby Apps/sec\"`, `'notimer'`]));\n-    }\n-    test_body!bmatch();\n-    test_body!match();\n-}\n-\n-// tests for replace\n-@safe unittest\n-{\n-    void test(alias matchFn)()\n-    {\n-        import std.uni : toUpper;\n-\n-        foreach (i, v; AliasSeq!(string, wstring, dstring))\n-        {\n-            auto baz(Cap)(Cap m)\n-            if (is(Cap == Captures!(Cap.String)))\n-            {\n-                return toUpper(m.hit);\n-            }\n-            alias String = v;\n-            assert(std.regex.replace!(matchFn)(to!String(\"ark rapacity\"), regex(to!String(\"r\")), to!String(\"c\"))\n-                   == to!String(\"ack rapacity\"));\n-            assert(std.regex.replace!(matchFn)(to!String(\"ark rapacity\"), regex(to!String(\"r\"), \"g\"), to!String(\"c\"))\n-                   == to!String(\"ack capacity\"));\n-            assert(std.regex.replace!(matchFn)(to!String(\"noon\"), regex(to!String(\"^n\")), to!String(\"[$&]\"))\n-                   == to!String(\"[n]oon\"));\n-            assert(std.regex.replace!(matchFn)(\n-                to!String(\"test1 test2\"), regex(to!String(`\\w+`),\"g\"), to!String(\"$`:$'\")\n-            ) == to!String(\": test2 test1 :\"));\n-            auto s = std.regex.replace!(baz!(Captures!(String)))(to!String(\"Strap a rocket engine on a chicken.\"),\n-                    regex(to!String(\"[ar]\"), \"g\"));\n-            assert(s == \"StRAp A Rocket engine on A chicken.\");\n-        }\n-        debug(std_regex_test) writeln(\"!!! Replace test done \"~matchFn.stringof~\"  !!!\");\n-    }\n-    test!(bmatch)();\n-    test!(match)();\n-}\n-\n-// tests for splitter\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    auto s1 = \", abc, de,     fg, hi, \";\n-    auto sp1 = splitter(s1, regex(\", *\"));\n-    auto w1 = [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"];\n-    assert(equal(sp1, w1));\n-\n-    auto s2 = \", abc, de,  fg, hi\";\n-    auto sp2 = splitter(s2, regex(\", *\"));\n-    auto w2 = [\"\", \"abc\", \"de\", \"fg\", \"hi\"];\n-\n-    uint cnt;\n-    foreach (e; sp2)\n-    {\n-        assert(w2[cnt++] == e);\n-    }\n-    assert(equal(sp2, w2));\n-}\n-\n-@safe unittest\n-{\n-    char[] s1 = \", abc, de,  fg, hi, \".dup;\n-    auto sp2 = splitter(s1, regex(\", *\"));\n-}\n-\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    auto s1 = \", abc, de,  fg, hi, \";\n-    auto w1 = [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"];\n-    assert(equal(split(s1, regex(\", *\")), w1[]));\n-}\n-\n-@safe unittest\n-{ // bugzilla 7141\n-    string pattern = `[a\\--b]`;\n-    assert(match(\"-\", pattern));\n-    assert(match(\"b\", pattern));\n-    string pattern2 = `[&-z]`;\n-    assert(match(\"b\", pattern2));\n-}\n-@safe unittest\n-{//bugzilla 7111\n-    assert(match(\"\", regex(\"^\")));\n-}\n-@safe unittest\n-{//bugzilla 7300\n-    assert(!match(\"a\"d, \"aa\"d));\n-}\n-\n-// bugzilla 7551\n-@safe unittest\n-{\n-    auto r = regex(\"[]abc]*\");\n-    assert(\"]ab\".matchFirst(r).hit == \"]ab\");\n-    assertThrown(regex(\"[]\"));\n-    auto r2 = regex(\"[]abc--ab]*\");\n-    assert(\"]ac\".matchFirst(r2).hit == \"]\");\n-}\n-\n-@safe unittest\n-{//bugzilla 7674\n-    assert(\"1234\".replace(regex(\"^\"), \"$$\") == \"$1234\");\n-    assert(\"hello?\".replace(regex(r\"\\?\", \"g\"), r\"\\?\") == r\"hello\\?\");\n-    assert(\"hello?\".replace(regex(r\"\\?\", \"g\"), r\"\\\\?\") != r\"hello\\?\");\n-}\n-@safe unittest\n-{// bugzilla 7679\n-    import std.algorithm.comparison : equal;\n-    foreach (S; AliasSeq!(string, wstring, dstring))\n-    (){ // avoid slow optimizations for large functions @@@BUG@@@ 2396\n-        enum re = ctRegex!(to!S(r\"\\.\"));\n-        auto str = to!S(\"a.b\");\n-        assert(equal(std.regex.splitter(str, re), [to!S(\"a\"), to!S(\"b\")]));\n-        assert(split(str, re) == [to!S(\"a\"), to!S(\"b\")]);\n-    }();\n-}\n-@safe unittest\n-{//bugzilla 8203\n-    string data = \"\n-    NAME   = XPAW01_STA:STATION\n-    NAME   = XPAW01_STA\n-    \";\n-    auto uniFileOld = data;\n-    auto r = regex(\n-       r\"^NAME   = (?P<comp>[a-zA-Z0-9_]+):*(?P<blk>[a-zA-Z0-9_]*)\",\"gm\");\n-    auto uniCapturesNew = match(uniFileOld, r);\n-    for (int i = 0; i < 20; i++)\n-        foreach (matchNew; uniCapturesNew) {}\n-    //a second issue with same symptoms\n-    auto r2 = regex(`([\u0430-\u044f\u0410-\u042f\\-_]+\\s*)+(?<=[\\s\\.,\\^])`);\n-    match(\"\u0430\u043b\u043b\u0435\u044f \u0422\u0435\u0430\u0442\u0440\u0430\u043b\u044c\u043d\u0430\u044f\", r2);\n-}\n-@safe unittest\n-{// bugzilla 8637 purity of enforce\n-    auto m = match(\"hello world\", regex(\"world\"));\n-    enforce(m);\n-}\n-\n-// bugzilla 8725\n-@safe unittest\n-{\n-  static italic = regex( r\"\\*\n-                (?!\\s+)\n-                (.*?)\n-                (?!\\s+)\n-                \\*\", \"gx\" );\n-  string input = \"this * is* interesting, *very* interesting\";\n-  assert(replace(input, italic, \"<i>$1</i>\") ==\n-      \"this * is* interesting, <i>very</i> interesting\");\n-}\n-\n-// bugzilla 8349\n-@safe unittest\n-{\n-    enum peakRegexStr = r\"\\>(wgEncode.*Tfbs.*\\.(?:narrow)|(?:broad)Peak.gz)</a>\";\n-    enum peakRegex = ctRegex!(peakRegexStr);\n-    //note that the regex pattern itself is probably bogus\n-    assert(match(r\"\\>wgEncode-blah-Tfbs.narrow</a>\", peakRegex));\n-}\n-\n-// bugzilla 9211\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    auto rx_1 =  regex(r\"^(\\w)*(\\d)\");\n-    auto m = match(\"1234\", rx_1);\n-    assert(equal(m.front, [\"1234\", \"3\", \"4\"]));\n-    auto rx_2 = regex(r\"^([0-9])*(\\d)\");\n-    auto m2 = match(\"1234\", rx_2);\n-    assert(equal(m2.front, [\"1234\", \"3\", \"4\"]));\n-}\n-\n-// bugzilla 9280\n-@safe unittest\n-{\n-    string tomatch = \"a!b@c\";\n-    static r = regex(r\"^(?P<nick>.*?)!(?P<ident>.*?)@(?P<host>.*?)$\");\n-    auto nm = match(tomatch, r);\n-    assert(nm);\n-    auto c = nm.captures;\n-    assert(c[1] == \"a\");\n-    assert(c[\"nick\"] == \"a\");\n-}\n-\n-\n-// bugzilla 9579\n-@safe unittest\n-{\n-    char[] input = ['a', 'b', 'c'];\n-    string format = \"($1)\";\n-    // used to give a compile error:\n-    auto re = regex(`(a)`, \"g\");\n-    auto r = replace(input, re, format);\n-    assert(r == \"(a)bc\");\n-}\n-\n-// bugzilla 9634\n-@safe unittest\n-{\n-    auto re = ctRegex!\"(?:a+)\";\n-    assert(match(\"aaaa\", re).hit == \"aaaa\");\n-}\n-\n-//bugzilla 10798\n-@safe unittest\n-{\n-    auto cr = ctRegex!(\"[abcd--c]*\");\n-    auto m  = \"abc\".match(cr);\n-    assert(m);\n-    assert(m.hit == \"ab\");\n-}\n-\n-// bugzilla 10913\n-@system unittest\n-{\n-    @system static string foo(const(char)[] s)\n-    {\n-        return s.dup;\n-    }\n-    @safe static string bar(const(char)[] s)\n-    {\n-        return s.dup;\n-    }\n-    () @system {\n-        replace!((a) => foo(a.hit))(\"blah\", regex(`a`));\n-    }();\n-    () @safe {\n-        replace!((a) => bar(a.hit))(\"blah\", regex(`a`));\n-    }();\n-}\n-\n-// bugzilla 11262\n-@safe unittest\n-{\n-    enum reg = ctRegex!(r\",\", \"g\");\n-    auto str = \"This,List\";\n-    str = str.replace(reg, \"-\");\n-    assert(str == \"This-List\");\n-}\n-\n-// bugzilla 11775\n-@safe unittest\n-{\n-    assert(collectException(regex(\"a{1,0}\")));\n-}\n-\n-// bugzilla 11839\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    assert(regex(`(?P<var1>\\w+)`).namedCaptures.equal([\"var1\"]));\n-    assert(collectException(regex(`(?P<1>\\w+)`)));\n-    assert(regex(`(?P<v1>\\w+)`).namedCaptures.equal([\"v1\"]));\n-    assert(regex(`(?P<__>\\w+)`).namedCaptures.equal([\"__\"]));\n-    assert(regex(`(?P<\u044f>\\w+)`).namedCaptures.equal([\"\u044f\"]));\n-}\n-\n-// bugzilla 12076\n-@safe unittest\n-{\n-    auto RE = ctRegex!(r\"(?<!x[a-z]+)\\s([a-z]+)\");\n-    string s = \"one two\";\n-    auto m = match(s, RE);\n-}\n-\n-// bugzilla 12105\n-@safe unittest\n-{\n-    auto r = ctRegex!`.*?(?!a)`;\n-    assert(\"aaab\".matchFirst(r).hit == \"aaa\");\n-    auto r2 = ctRegex!`.*(?!a)`;\n-    assert(\"aaab\".matchFirst(r2).hit == \"aaab\");\n-}\n-\n-//bugzilla 11784\n-@safe unittest\n-{\n-    assert(\"abcdefghijklmnopqrstuvwxyz\"\n-        .matchFirst(\"[a-z&&[^aeiuo]]\").hit == \"b\");\n-}\n-\n-//bugzilla 12366\n-@safe unittest\n-{\n-     auto re = ctRegex!(`^((?=(xx+?)\\2+$)((?=\\2+$)(?=(x+)(\\4+$))\\5){2})*x?$`);\n-     assert(\"xxxxxxxx\".match(re).empty);\n-     assert(!\"xxxx\".match(re).empty);\n-}\n-\n-// bugzilla 12582\n-@safe unittest\n-{\n-    auto r = regex(`(?P<a>abc)`);\n-    assert(collectException(\"abc\".matchFirst(r)[\"b\"]));\n-}\n-\n-// bugzilla 12691\n-@safe unittest\n-{\n-    assert(bmatch(\"e@\", \"^([a-z]|)*$\").empty);\n-    assert(bmatch(\"e@\", ctRegex!`^([a-z]|)*$`).empty);\n-}\n-\n-//bugzilla  12713\n-@safe unittest\n-{\n-    assertThrown(regex(\"[[a-z]([a-z]|(([[a-z])))\"));\n-}\n-\n-//bugzilla 12747\n-@safe unittest\n-{\n-    assertThrown(regex(`^x(\\1)`));\n-    assertThrown(regex(`^(x(\\1))`));\n-    assertThrown(regex(`^((x)(?=\\1))`));\n-}\n-\n-// bugzilla 14504\n-@safe unittest\n-{\n-    auto p = ctRegex!(\"a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?\" ~\n-            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n-}\n-\n-// bugzilla 14529\n-@safe unittest\n-{\n-    auto ctPat2 = regex(r\"^[CDF]$\", \"i\");\n-    foreach (v; [\"C\", \"c\", \"D\", \"d\", \"F\", \"f\"])\n-        assert(matchAll(v, ctPat2).front.hit == v);\n-}\n-\n-// bugzilla 14615\n-@safe unittest\n-{\n-    import std.array : appender;\n-    import std.regex : replaceFirst, replaceFirstInto, regex;\n-    import std.stdio : writeln;\n-\n-    auto example = \"Hello, world!\";\n-    auto pattern = regex(\"^Hello, (bug)\");  // won't find this one\n-    auto result = replaceFirst(example, pattern, \"$1 Sponge Bob\");\n-    assert(result == \"Hello, world!\");  // Ok.\n-\n-    auto sink = appender!string;\n-    replaceFirstInto(sink, example, pattern, \"$1 Sponge Bob\");\n-    assert(sink.data == \"Hello, world!\");\n-    replaceAllInto(sink, example, pattern, \"$1 Sponge Bob\");\n-    assert(sink.data == \"Hello, world!Hello, world!\");\n-}\n-\n-// bugzilla 15573\n-@safe unittest\n-{\n-    auto rx = regex(\"[c d]\", \"x\");\n-    assert(\"a b\".matchFirst(rx));\n-}\n-\n-// bugzilla 15864\n-@safe unittest\n-{\n-    regex(`(<a (?:(?:\\w+=\\\"[^\"]*\\\")?\\s*)*href=\"\\.\\.?)\"`);\n-}\n-\n-@safe unittest\n-{\n-    auto r = regex(\"(?# comment)abc(?# comment2)\");\n-    assert(\"abc\".matchFirst(r));\n-    assertThrown(regex(\"(?#...\"));\n-}\n-\n-// bugzilla 17075\n-@safe unittest\n-{\n-    enum titlePattern = `<title>(.+)</title>`;\n-    static titleRegex = ctRegex!titlePattern;\n-    string input = \"<title>\" ~ \"<\".repeat(100_000).join;\n-    assert(input.matchFirst(titleRegex).empty);\n-}\n-\n-// bugzilla 17212\n-@safe unittest\n-{\n-    auto r = regex(\" [a] \", \"x\");\n-    assert(\"a\".matchFirst(r));\n-}\n-\n-// bugzilla 17157\n-@safe unittest\n-{\n-    import std.algorithm.comparison : equal;\n-    auto ctr = ctRegex!\"(a)|(b)|(c)|(d)\";\n-    auto r = regex(\"(a)|(b)|(c)|(d)\", \"g\");\n-    auto s = \"--a--b--c--d--\";\n-    auto outcomes = [\n-        [\"a\", \"a\", \"\", \"\", \"\"],\n-        [\"b\", \"\", \"b\", \"\", \"\"],\n-        [\"c\", \"\", \"\", \"c\", \"\"],\n-        [\"d\", \"\", \"\", \"\", \"d\"]\n-    ];\n-    assert(equal!equal(s.matchAll(ctr), outcomes));\n-    assert(equal!equal(s.bmatch(r), outcomes));\n-}\n-\n-// bugzilla 17667\n-@safe unittest\n-{\n-    import std.algorithm.searching : canFind;\n-    void willThrow(T, size_t line = __LINE__)(T arg, string msg)\n-    {\n-        auto e = collectException(regex(arg));\n-        assert(e.msg.canFind(msg), to!string(line) ~ \": \" ~ e.msg);\n-    }\n-    willThrow([r\".\", r\"[\\(\\{[\\]\\}\\)]\"], \"no matching ']' found while parsing character class\");\n-    willThrow([r\"[\\\", r\"123\"], \"no matching ']' found while parsing character class\");\n-    willThrow([r\"[a-\", r\"123\"], \"no matching ']' found while parsing character class\");\n-    willThrow([r\"[a-\\\", r\"123\"], \"invalid escape sequence\");\n-    willThrow([r\"\\\", r\"123\"], \"invalid escape sequence\");\n-}\n-\n-// bugzilla 17668\n-@safe unittest\n-{\n-    import std.algorithm.searching;\n-    auto e = collectException!RegexException(regex(q\"<[^]>\"));\n-    assert(e.msg.canFind(\"no operand for '^'\"));\n-}\n-\n-// bugzilla 17673\n-@safe unittest\n-{\n-    string str = `<\">`;\n-    string[] regexps = [\"abc\", \"\\\"|x\"];\n-    auto regexp = regex(regexps);\n-    auto c = matchFirst(str, regexp);\n-    assert(c);\n-    assert(c.whichPattern == 2);\n-}\n-"}, {"sha": "420f8d3d6cccdca66b538178e9014b658d53d822", "filename": "libphobos/src/std/regex/internal/tests2.d", "status": "added", "additions": 662, "deletions": 0, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Ftests2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Ftests2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Ftests2.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -0,0 +1,662 @@\n+// Split-up due to DMD's enormous memory consumption\n+\n+module std.regex.internal.tests2;\n+\n+package(std.regex):\n+\n+import std.conv, std.exception, std.meta, std.range,\n+    std.typecons, std.regex;\n+\n+import std.regex.internal.ir : Escapables; // characters that need escaping\n+\n+@safe unittest\n+{\n+    auto cr = ctRegex!(\"abc\");\n+    assert(bmatch(\"abc\",cr).hit == \"abc\");\n+    auto cr2 = ctRegex!(\"ab*c\");\n+    assert(bmatch(\"abbbbc\",cr2).hit == \"abbbbc\");\n+}\n+@safe unittest\n+{\n+    auto cr3 = ctRegex!(\"^abc$\");\n+    assert(bmatch(\"abc\",cr3).hit == \"abc\");\n+    auto cr4 = ctRegex!(`\\b(a\\B[a-z]b)\\b`);\n+    assert(array(match(\"azb\",cr4).captures) == [\"azb\", \"azb\"]);\n+}\n+\n+@safe unittest\n+{\n+    auto cr5 = ctRegex!(\"(?:a{2,4}b{1,3}){1,2}\");\n+    assert(bmatch(\"aaabaaaabbb\", cr5).hit == \"aaabaaaabbb\");\n+    auto cr6 = ctRegex!(\"(?:a{2,4}b{1,3}){1,2}?\"w);\n+    assert(bmatch(\"aaabaaaabbb\"w,  cr6).hit == \"aaab\"w);\n+}\n+\n+@safe unittest\n+{\n+    auto cr7 = ctRegex!(`\\r.*?$`,\"sm\");\n+    assert(bmatch(\"abc\\r\\nxy\",  cr7).hit == \"\\r\\nxy\");\n+    auto greed =  ctRegex!(\"<packet.*?/packet>\");\n+    assert(bmatch(\"<packet>text</packet><packet>text</packet>\", greed).hit\n+            == \"<packet>text</packet>\");\n+}\n+\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    auto cr8 = ctRegex!(\"^(a)(b)?(c*)\");\n+    auto m8 = bmatch(\"abcc\",cr8);\n+    assert(m8);\n+    assert(m8.captures[1] == \"a\");\n+    assert(m8.captures[2] == \"b\");\n+    assert(m8.captures[3] == \"cc\");\n+    auto cr9 = ctRegex!(\"q(a|b)*q\");\n+    auto m9 = match(\"xxqababqyy\",cr9);\n+    assert(m9);\n+    assert(equal(bmatch(\"xxqababqyy\",cr9).captures, [\"qababq\", \"b\"]));\n+}\n+\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    auto rtr = regex(\"a|b|c\");\n+    enum ctr = regex(\"a|b|c\");\n+    assert(equal(rtr.ir,ctr.ir));\n+    //CTFE parser BUG is triggered by group\n+    //in the middle of alternation (at least not first and not last)\n+    enum testCT = regex(`abc|(edf)|xyz`);\n+    auto testRT = regex(`abc|(edf)|xyz`);\n+    assert(equal(testCT.ir,testRT.ir));\n+}\n+\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    import std.algorithm.iteration : map;\n+    enum cx = ctRegex!\"(A|B|C)\";\n+    auto mx = match(\"B\",cx);\n+    assert(mx);\n+    assert(equal(mx.captures, [ \"B\", \"B\"]));\n+    enum cx2 = ctRegex!\"(A|B)*\";\n+    assert(match(\"BAAA\",cx2));\n+\n+    enum cx3 = ctRegex!(\"a{3,4}\",\"i\");\n+    auto mx3 = match(\"AaA\",cx3);\n+    assert(mx3);\n+    assert(mx3.captures[0] == \"AaA\");\n+    enum cx4 = ctRegex!(`^a{3,4}?[a-zA-Z0-9~]{1,2}`,\"i\");\n+    auto mx4 = match(\"aaaabc\", cx4);\n+    assert(mx4);\n+    assert(mx4.captures[0] == \"aaaab\");\n+    auto cr8 = ctRegex!(\"(a)(b)?(c*)\");\n+    auto m8 = bmatch(\"abcc\",cr8);\n+    assert(m8);\n+    assert(m8.captures[1] == \"a\");\n+    assert(m8.captures[2] == \"b\");\n+    assert(m8.captures[3] == \"cc\");\n+    auto cr9 = ctRegex!(\".*$\", \"gm\");\n+    auto m9 = match(\"First\\rSecond\", cr9);\n+    assert(m9);\n+    assert(equal(map!\"a.hit\"(m9), [\"First\", \"\", \"Second\"]));\n+}\n+\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    import std.algorithm.iteration : map;\n+//global matching\n+    void test_body(alias matchFn)()\n+    {\n+        string s = \"a quick brown fox jumps over a lazy dog\";\n+        auto r1 = regex(\"\\\\b[a-z]+\\\\b\",\"g\");\n+        string[] test;\n+        foreach (m; matchFn(s, r1))\n+            test ~= m.hit;\n+        assert(equal(test, [ \"a\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"a\", \"lazy\", \"dog\"]));\n+        auto free_reg = regex(`\n+\n+            abc\n+            \\s+\n+            \"\n+            (\n+                    [^\"]+\n+                |   \\\\ \"\n+            )+\n+            \"\n+            z\n+        `, \"x\");\n+        auto m = match(`abc  \"quoted string with \\\" inside\"z`,free_reg);\n+        assert(m);\n+        string mails = \" hey@you.com no@spam.net \";\n+        auto rm = regex(`@(?<=\\S+@)\\S+`,\"g\");\n+        assert(equal(map!\"a[0]\"(matchFn(mails, rm)), [\"@you.com\", \"@spam.net\"]));\n+        auto m2 = matchFn(\"First line\\nSecond line\",regex(\".*$\",\"gm\"));\n+        assert(equal(map!\"a[0]\"(m2), [\"First line\", \"\", \"Second line\"]));\n+        auto m2a = matchFn(\"First line\\nSecond line\",regex(\".+$\",\"gm\"));\n+        assert(equal(map!\"a[0]\"(m2a), [\"First line\", \"Second line\"]));\n+        auto m2b = matchFn(\"First line\\nSecond line\",regex(\".+?$\",\"gm\"));\n+        assert(equal(map!\"a[0]\"(m2b), [\"First line\", \"Second line\"]));\n+        debug(std_regex_test) writeln(\"!!! FReD FLAGS test done \"~matchFn.stringof~\" !!!\");\n+    }\n+    test_body!bmatch();\n+    test_body!match();\n+}\n+\n+//tests for accumulated std.regex issues and other regressions\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    import std.algorithm.iteration : map;\n+    void test_body(alias matchFn)()\n+    {\n+        //issue 5857\n+        //matching goes out of control if ... in (...){x} has .*/.+\n+        auto c = matchFn(\"axxxzayyyyyzd\",regex(\"(a.*z){2}d\")).captures;\n+        assert(c[0] == \"axxxzayyyyyzd\");\n+        assert(c[1] == \"ayyyyyz\");\n+        auto c2 = matchFn(\"axxxayyyyyd\",regex(\"(a.*){2}d\")).captures;\n+        assert(c2[0] == \"axxxayyyyyd\");\n+        assert(c2[1] == \"ayyyyy\");\n+        //issue 2108\n+        //greedy vs non-greedy\n+        auto nogreed = regex(\"<packet.*?/packet>\");\n+        assert(matchFn(\"<packet>text</packet><packet>text</packet>\", nogreed).hit\n+               == \"<packet>text</packet>\");\n+        auto greed =  regex(\"<packet.*/packet>\");\n+        assert(matchFn(\"<packet>text</packet><packet>text</packet>\", greed).hit\n+               == \"<packet>text</packet><packet>text</packet>\");\n+        //issue 4574\n+        //empty successful match still advances the input\n+        string[] pres, posts, hits;\n+        foreach (m; matchFn(\"abcabc\", regex(\"\",\"g\")))\n+        {\n+            pres ~= m.pre;\n+            posts ~= m.post;\n+            assert(m.hit.empty);\n+\n+        }\n+        auto heads = [\n+            \"abcabc\",\n+            \"abcab\",\n+            \"abca\",\n+            \"abc\",\n+            \"ab\",\n+            \"a\",\n+            \"\"\n+        ];\n+        auto tails = [\n+            \"abcabc\",\n+             \"bcabc\",\n+              \"cabc\",\n+               \"abc\",\n+                \"bc\",\n+                 \"c\",\n+                  \"\"\n+        ];\n+        assert(pres == array(retro(heads)));\n+        assert(posts == tails);\n+        //issue 6076\n+        //regression on .*\n+        auto re = regex(\"c.*|d\");\n+        auto m = matchFn(\"mm\", re);\n+        assert(!m);\n+        debug(std_regex_test) writeln(\"!!! FReD REGRESSION test done \"~matchFn.stringof~\" !!!\");\n+        auto rprealloc = regex(`((.){5}.{1,10}){5}`);\n+        auto arr = array(repeat('0',100));\n+        auto m2 = matchFn(arr, rprealloc);\n+        assert(m2);\n+        assert(collectException(\n+                regex(r\"^(import|file|binary|config)\\s+([^\\(]+)\\(?([^\\)]*)\\)?\\s*$\")\n+                ) is null);\n+        foreach (ch; [Escapables])\n+        {\n+            assert(match(to!string(ch),regex(`[\\`~ch~`]`)));\n+            assert(!match(to!string(ch),regex(`[^\\`~ch~`]`)));\n+            assert(match(to!string(ch),regex(`[\\`~ch~`-\\`~ch~`]`)));\n+        }\n+        //bugzilla 7718\n+        string strcmd = \"./myApp.rb -os OSX -path \\\"/GIT/Ruby Apps/sec\\\" -conf 'notimer'\";\n+        auto reStrCmd = regex (`(\".*\")|('.*')`, \"g\");\n+        assert(equal(map!\"a[0]\"(matchFn(strcmd, reStrCmd)),\n+                     [`\"/GIT/Ruby Apps/sec\"`, `'notimer'`]));\n+    }\n+    test_body!bmatch();\n+    test_body!match();\n+}\n+\n+// tests for replace\n+@safe unittest\n+{\n+    void test(alias matchFn)()\n+    {\n+        import std.uni : toUpper;\n+\n+        foreach (i, v; AliasSeq!(string, wstring, dstring))\n+        {\n+            auto baz(Cap)(Cap m)\n+            if (is(Cap == Captures!(Cap.String)))\n+            {\n+                return toUpper(m.hit);\n+            }\n+            alias String = v;\n+            assert(std.regex.replace!(matchFn)(to!String(\"ark rapacity\"), regex(to!String(\"r\")), to!String(\"c\"))\n+                   == to!String(\"ack rapacity\"));\n+            assert(std.regex.replace!(matchFn)(to!String(\"ark rapacity\"), regex(to!String(\"r\"), \"g\"), to!String(\"c\"))\n+                   == to!String(\"ack capacity\"));\n+            assert(std.regex.replace!(matchFn)(to!String(\"noon\"), regex(to!String(\"^n\")), to!String(\"[$&]\"))\n+                   == to!String(\"[n]oon\"));\n+            assert(std.regex.replace!(matchFn)(\n+                to!String(\"test1 test2\"), regex(to!String(`\\w+`),\"g\"), to!String(\"$`:$'\")\n+            ) == to!String(\": test2 test1 :\"));\n+            auto s = std.regex.replace!(baz!(Captures!(String)))(to!String(\"Strap a rocket engine on a chicken.\"),\n+                    regex(to!String(\"[ar]\"), \"g\"));\n+            assert(s == \"StRAp A Rocket engine on A chicken.\");\n+        }\n+        debug(std_regex_test) writeln(\"!!! Replace test done \"~matchFn.stringof~\"  !!!\");\n+    }\n+    test!(bmatch)();\n+    test!(match)();\n+}\n+\n+// tests for splitter\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    auto s1 = \", abc, de,     fg, hi, \";\n+    auto sp1 = splitter(s1, regex(\", *\"));\n+    auto w1 = [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"];\n+    assert(equal(sp1, w1));\n+\n+    auto s2 = \", abc, de,  fg, hi\";\n+    auto sp2 = splitter(s2, regex(\", *\"));\n+    auto w2 = [\"\", \"abc\", \"de\", \"fg\", \"hi\"];\n+\n+    uint cnt;\n+    foreach (e; sp2)\n+    {\n+        assert(w2[cnt++] == e);\n+    }\n+    assert(equal(sp2, w2));\n+}\n+\n+@safe unittest\n+{\n+    char[] s1 = \", abc, de,  fg, hi, \".dup;\n+    auto sp2 = splitter(s1, regex(\", *\"));\n+}\n+\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    auto s1 = \", abc, de,  fg, hi, \";\n+    auto w1 = [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"];\n+    assert(equal(split(s1, regex(\", *\")), w1[]));\n+}\n+\n+@safe unittest\n+{ // bugzilla 7141\n+    string pattern = `[a\\--b]`;\n+    assert(match(\"-\", pattern));\n+    assert(match(\"b\", pattern));\n+    string pattern2 = `[&-z]`;\n+    assert(match(\"b\", pattern2));\n+}\n+@safe unittest\n+{//bugzilla 7111\n+    assert(match(\"\", regex(\"^\")));\n+}\n+@safe unittest\n+{//bugzilla 7300\n+    assert(!match(\"a\"d, \"aa\"d));\n+}\n+\n+// bugzilla 7551\n+@safe unittest\n+{\n+    auto r = regex(\"[]abc]*\");\n+    assert(\"]ab\".matchFirst(r).hit == \"]ab\");\n+    assertThrown(regex(\"[]\"));\n+    auto r2 = regex(\"[]abc--ab]*\");\n+    assert(\"]ac\".matchFirst(r2).hit == \"]\");\n+}\n+\n+@safe unittest\n+{//bugzilla 7674\n+    assert(\"1234\".replace(regex(\"^\"), \"$$\") == \"$1234\");\n+    assert(\"hello?\".replace(regex(r\"\\?\", \"g\"), r\"\\?\") == r\"hello\\?\");\n+    assert(\"hello?\".replace(regex(r\"\\?\", \"g\"), r\"\\\\?\") != r\"hello\\?\");\n+}\n+@safe unittest\n+{// bugzilla 7679\n+    import std.algorithm.comparison : equal;\n+    foreach (S; AliasSeq!(string, wstring, dstring))\n+    (){ // avoid slow optimizations for large functions @@@BUG@@@ 2396\n+        enum re = ctRegex!(to!S(r\"\\.\"));\n+        auto str = to!S(\"a.b\");\n+        assert(equal(std.regex.splitter(str, re), [to!S(\"a\"), to!S(\"b\")]));\n+        assert(split(str, re) == [to!S(\"a\"), to!S(\"b\")]);\n+    }();\n+}\n+@safe unittest\n+{//bugzilla 8203\n+    string data = \"\n+    NAME   = XPAW01_STA:STATION\n+    NAME   = XPAW01_STA\n+    \";\n+    auto uniFileOld = data;\n+    auto r = regex(\n+       r\"^NAME   = (?P<comp>[a-zA-Z0-9_]+):*(?P<blk>[a-zA-Z0-9_]*)\",\"gm\");\n+    auto uniCapturesNew = match(uniFileOld, r);\n+    for (int i = 0; i < 20; i++)\n+        foreach (matchNew; uniCapturesNew) {}\n+    //a second issue with same symptoms\n+    auto r2 = regex(`([\u0430-\u044f\u0410-\u042f\\-_]+\\s*)+(?<=[\\s\\.,\\^])`);\n+    match(\"\u0430\u043b\u043b\u0435\u044f \u0422\u0435\u0430\u0442\u0440\u0430\u043b\u044c\u043d\u0430\u044f\", r2);\n+}\n+@safe unittest\n+{// bugzilla 8637 purity of enforce\n+    auto m = match(\"hello world\", regex(\"world\"));\n+    enforce(m);\n+}\n+\n+// bugzilla 8725\n+@safe unittest\n+{\n+  static italic = regex( r\"\\*\n+                (?!\\s+)\n+                (.*?)\n+                (?!\\s+)\n+                \\*\", \"gx\" );\n+  string input = \"this * is* interesting, *very* interesting\";\n+  assert(replace(input, italic, \"<i>$1</i>\") ==\n+      \"this * is* interesting, <i>very</i> interesting\");\n+}\n+\n+// bugzilla 8349\n+@safe unittest\n+{\n+    enum peakRegexStr = r\"\\>(wgEncode.*Tfbs.*\\.(?:narrow)|(?:broad)Peak.gz)</a>\";\n+    enum peakRegex = ctRegex!(peakRegexStr);\n+    //note that the regex pattern itself is probably bogus\n+    assert(match(r\"\\>wgEncode-blah-Tfbs.narrow</a>\", peakRegex));\n+}\n+\n+// bugzilla 9211\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    auto rx_1 =  regex(r\"^(\\w)*(\\d)\");\n+    auto m = match(\"1234\", rx_1);\n+    assert(equal(m.front, [\"1234\", \"3\", \"4\"]));\n+    auto rx_2 = regex(r\"^([0-9])*(\\d)\");\n+    auto m2 = match(\"1234\", rx_2);\n+    assert(equal(m2.front, [\"1234\", \"3\", \"4\"]));\n+}\n+\n+// bugzilla 9280\n+@safe unittest\n+{\n+    string tomatch = \"a!b@c\";\n+    static r = regex(r\"^(?P<nick>.*?)!(?P<ident>.*?)@(?P<host>.*?)$\");\n+    auto nm = match(tomatch, r);\n+    assert(nm);\n+    auto c = nm.captures;\n+    assert(c[1] == \"a\");\n+    assert(c[\"nick\"] == \"a\");\n+}\n+\n+\n+// bugzilla 9579\n+@safe unittest\n+{\n+    char[] input = ['a', 'b', 'c'];\n+    string format = \"($1)\";\n+    // used to give a compile error:\n+    auto re = regex(`(a)`, \"g\");\n+    auto r = replace(input, re, format);\n+    assert(r == \"(a)bc\");\n+}\n+\n+// bugzilla 9634\n+@safe unittest\n+{\n+    auto re = ctRegex!\"(?:a+)\";\n+    assert(match(\"aaaa\", re).hit == \"aaaa\");\n+}\n+\n+//bugzilla 10798\n+@safe unittest\n+{\n+    auto cr = ctRegex!(\"[abcd--c]*\");\n+    auto m  = \"abc\".match(cr);\n+    assert(m);\n+    assert(m.hit == \"ab\");\n+}\n+\n+// bugzilla 10913\n+@system unittest\n+{\n+    @system static string foo(const(char)[] s)\n+    {\n+        return s.dup;\n+    }\n+    @safe static string bar(const(char)[] s)\n+    {\n+        return s.dup;\n+    }\n+    () @system {\n+        replace!((a) => foo(a.hit))(\"blah\", regex(`a`));\n+    }();\n+    () @safe {\n+        replace!((a) => bar(a.hit))(\"blah\", regex(`a`));\n+    }();\n+}\n+\n+// bugzilla 11262\n+@safe unittest\n+{\n+    enum reg = ctRegex!(r\",\", \"g\");\n+    auto str = \"This,List\";\n+    str = str.replace(reg, \"-\");\n+    assert(str == \"This-List\");\n+}\n+\n+// bugzilla 11775\n+@safe unittest\n+{\n+    assert(collectException(regex(\"a{1,0}\")));\n+}\n+\n+// bugzilla 11839\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    assert(regex(`(?P<var1>\\w+)`).namedCaptures.equal([\"var1\"]));\n+    assert(collectException(regex(`(?P<1>\\w+)`)));\n+    assert(regex(`(?P<v1>\\w+)`).namedCaptures.equal([\"v1\"]));\n+    assert(regex(`(?P<__>\\w+)`).namedCaptures.equal([\"__\"]));\n+    assert(regex(`(?P<\u044f>\\w+)`).namedCaptures.equal([\"\u044f\"]));\n+}\n+\n+// bugzilla 12076\n+@safe unittest\n+{\n+    auto RE = ctRegex!(r\"(?<!x[a-z]+)\\s([a-z]+)\");\n+    string s = \"one two\";\n+    auto m = match(s, RE);\n+}\n+\n+// bugzilla 12105\n+@safe unittest\n+{\n+    auto r = ctRegex!`.*?(?!a)`;\n+    assert(\"aaab\".matchFirst(r).hit == \"aaa\");\n+    auto r2 = ctRegex!`.*(?!a)`;\n+    assert(\"aaab\".matchFirst(r2).hit == \"aaab\");\n+}\n+\n+//bugzilla 11784\n+@safe unittest\n+{\n+    assert(\"abcdefghijklmnopqrstuvwxyz\"\n+        .matchFirst(\"[a-z&&[^aeiuo]]\").hit == \"b\");\n+}\n+\n+//bugzilla 12366\n+@safe unittest\n+{\n+     auto re = ctRegex!(`^((?=(xx+?)\\2+$)((?=\\2+$)(?=(x+)(\\4+$))\\5){2})*x?$`);\n+     assert(\"xxxxxxxx\".match(re).empty);\n+     assert(!\"xxxx\".match(re).empty);\n+}\n+\n+// bugzilla 12582\n+@safe unittest\n+{\n+    auto r = regex(`(?P<a>abc)`);\n+    assert(collectException(\"abc\".matchFirst(r)[\"b\"]));\n+}\n+\n+// bugzilla 12691\n+@safe unittest\n+{\n+    assert(bmatch(\"e@\", \"^([a-z]|)*$\").empty);\n+    assert(bmatch(\"e@\", ctRegex!`^([a-z]|)*$`).empty);\n+}\n+\n+//bugzilla  12713\n+@safe unittest\n+{\n+    assertThrown(regex(\"[[a-z]([a-z]|(([[a-z])))\"));\n+}\n+\n+//bugzilla 12747\n+@safe unittest\n+{\n+    assertThrown(regex(`^x(\\1)`));\n+    assertThrown(regex(`^(x(\\1))`));\n+    assertThrown(regex(`^((x)(?=\\1))`));\n+}\n+\n+// bugzilla 14504\n+@safe unittest\n+{\n+    auto p = ctRegex!(\"a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?\" ~\n+            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n+}\n+\n+// bugzilla 14529\n+@safe unittest\n+{\n+    auto ctPat2 = regex(r\"^[CDF]$\", \"i\");\n+    foreach (v; [\"C\", \"c\", \"D\", \"d\", \"F\", \"f\"])\n+        assert(matchAll(v, ctPat2).front.hit == v);\n+}\n+\n+// bugzilla 14615\n+@safe unittest\n+{\n+    import std.array : appender;\n+    import std.regex : replaceFirst, replaceFirstInto, regex;\n+    import std.stdio : writeln;\n+\n+    auto example = \"Hello, world!\";\n+    auto pattern = regex(\"^Hello, (bug)\");  // won't find this one\n+    auto result = replaceFirst(example, pattern, \"$1 Sponge Bob\");\n+    assert(result == \"Hello, world!\");  // Ok.\n+\n+    auto sink = appender!string;\n+    replaceFirstInto(sink, example, pattern, \"$1 Sponge Bob\");\n+    assert(sink.data == \"Hello, world!\");\n+    replaceAllInto(sink, example, pattern, \"$1 Sponge Bob\");\n+    assert(sink.data == \"Hello, world!Hello, world!\");\n+}\n+\n+// bugzilla 15573\n+@safe unittest\n+{\n+    auto rx = regex(\"[c d]\", \"x\");\n+    assert(\"a b\".matchFirst(rx));\n+}\n+\n+// bugzilla 15864\n+@safe unittest\n+{\n+    regex(`(<a (?:(?:\\w+=\\\"[^\"]*\\\")?\\s*)*href=\"\\.\\.?)\"`);\n+}\n+\n+@safe unittest\n+{\n+    auto r = regex(\"(?# comment)abc(?# comment2)\");\n+    assert(\"abc\".matchFirst(r));\n+    assertThrown(regex(\"(?#...\"));\n+}\n+\n+// bugzilla 17075\n+@safe unittest\n+{\n+    enum titlePattern = `<title>(.+)</title>`;\n+    static titleRegex = ctRegex!titlePattern;\n+    string input = \"<title>\" ~ \"<\".repeat(100_000).join;\n+    assert(input.matchFirst(titleRegex).empty);\n+}\n+\n+// bugzilla 17212\n+@safe unittest\n+{\n+    auto r = regex(\" [a] \", \"x\");\n+    assert(\"a\".matchFirst(r));\n+}\n+\n+// bugzilla 17157\n+@safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    auto ctr = ctRegex!\"(a)|(b)|(c)|(d)\";\n+    auto r = regex(\"(a)|(b)|(c)|(d)\", \"g\");\n+    auto s = \"--a--b--c--d--\";\n+    auto outcomes = [\n+        [\"a\", \"a\", \"\", \"\", \"\"],\n+        [\"b\", \"\", \"b\", \"\", \"\"],\n+        [\"c\", \"\", \"\", \"c\", \"\"],\n+        [\"d\", \"\", \"\", \"\", \"d\"]\n+    ];\n+    assert(equal!equal(s.matchAll(ctr), outcomes));\n+    assert(equal!equal(s.bmatch(r), outcomes));\n+}\n+\n+// bugzilla 17667\n+@safe unittest\n+{\n+    import std.algorithm.searching : canFind;\n+    void willThrow(T, size_t line = __LINE__)(T arg, string msg)\n+    {\n+        auto e = collectException(regex(arg));\n+        assert(e.msg.canFind(msg), to!string(line) ~ \": \" ~ e.msg);\n+    }\n+    willThrow([r\".\", r\"[\\(\\{[\\]\\}\\)]\"], \"no matching ']' found while parsing character class\");\n+    willThrow([r\"[\\\", r\"123\"], \"no matching ']' found while parsing character class\");\n+    willThrow([r\"[a-\", r\"123\"], \"no matching ']' found while parsing character class\");\n+    willThrow([r\"[a-\\\", r\"123\"], \"invalid escape sequence\");\n+    willThrow([r\"\\\", r\"123\"], \"invalid escape sequence\");\n+}\n+\n+// bugzilla 17668\n+@safe unittest\n+{\n+    import std.algorithm.searching;\n+    auto e = collectException!RegexException(regex(q\"<[^]>\"));\n+    assert(e.msg.canFind(\"no operand for '^'\"));\n+}\n+\n+// bugzilla 17673\n+@safe unittest\n+{\n+    string str = `<\">`;\n+    string[] regexps = [\"abc\", \"\\\"|x\"];\n+    auto regexp = regex(regexps);\n+    auto c = matchFirst(str, regexp);\n+    assert(c);\n+    assert(c.whichPattern == 2);\n+}\n+"}, {"sha": "d7de153063f6e988cf8418ef97294315f834468f", "filename": "libphobos/src/std/socket.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsocket.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -85,10 +85,10 @@ else version (Posix)\n         }\n     }\n \n+    public import core.sys.posix.netinet.in_;\n     import core.sys.posix.arpa.inet;\n     import core.sys.posix.fcntl;\n     import core.sys.posix.netdb;\n-    import core.sys.posix.netinet.in_;\n     import core.sys.posix.netinet.tcp;\n     import core.sys.posix.sys.select;\n     import core.sys.posix.sys.socket;"}, {"sha": "55119fc2780a173bed475d65568107ffe6ee1688", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -4204,10 +4204,11 @@ package template OverloadSet(string nam, T...)\n /*\n Used by MemberFunctionGenerator.\n  */\n-package template FuncInfo(alias func, /+[BUG 4217 ?]+/ T = typeof(&func))\n+package template FuncInfo(alias func)\n+if (is(typeof(&func)))\n {\n-    alias RT = ReturnType!T;\n-    alias PT = Parameters!T;\n+    alias RT = ReturnType!(typeof(&func));\n+    alias PT = Parameters!(typeof(&func));\n }\n package template FuncInfo(Func)\n {\n@@ -4248,6 +4249,7 @@ private static:\n     // Internal stuffs\n     //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://\n     import std.format;\n+    alias format = std.format.format;\n \n     enum CONSTRUCTOR_NAME = \"__ctor\";\n \n@@ -5024,7 +5026,7 @@ package template GetOverloadedMethods(T)\n                     enum isMethod = false;\n             }\n             alias follows = AliasSeq!(\n-                std.meta.Filter!(isMethod, __traits(getOverloads, T, name)),\n+                Filter!(isMethod, __traits(getOverloads, T, name)),\n                 follows!(i + 1));\n         }\n     }"}, {"sha": "9e55d199a9b5ce4d131bd414c90a993124edf361", "filename": "libphobos/src/std/zip.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fzip.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Fsrc%2Fstd%2Fzip.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fzip.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -263,8 +263,8 @@ final class ArchiveMember\n     {\n     void print()\n     {\n-        printf(\"name = '%.*s'\\n\", name.length, name.ptr);\n-        printf(\"\\tcomment = '%.*s'\\n\", comment.length, comment.ptr);\n+        printf(\"name = '%.*s'\\n\", cast(int) name.length, name.ptr);\n+        printf(\"\\tcomment = '%.*s'\\n\", cast(int) comment.length, comment.ptr);\n         printf(\"\\tmadeVersion = x%04x\\n\", _madeVersion);\n         printf(\"\\textractVersion = x%04x\\n\", extractVersion);\n         printf(\"\\tflags = x%04x\\n\", flags);\n@@ -348,7 +348,7 @@ final class ZipArchive\n         printf(\"\\tdiskStartDir = %u\\n\", diskStartDir);\n         printf(\"\\tnumEntries = %u\\n\", numEntries);\n         printf(\"\\ttotalEntries = %u\\n\", totalEntries);\n-        printf(\"\\tcomment = '%.*s'\\n\", comment.length, comment.ptr);\n+        printf(\"\\tcomment = '%.*s'\\n\", cast(int) comment.length, comment.ptr);\n     }\n     }\n "}, {"sha": "0305707fc62aea6cad941b58a1b9e5ba9b5f0af3", "filename": "libphobos/testsuite/libphobos.exceptions/chain.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Ftestsuite%2Flibphobos.exceptions%2Fchain.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Ftestsuite%2Flibphobos.exceptions%2Fchain.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.exceptions%2Fchain.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -65,14 +65,14 @@ void main()\n         string prefix = \"\";\n         for ({ size_t i; Throwable ex = original; } ex; ex = ex.next, ++i)\n         {\n-            printf(\"%.*s%.*s\\n\", prefix.length, prefix.ptr, ex.msg.length, ex.msg.ptr);\n+            printf(\"%.*s%.*s\\n\", cast(int)prefix.length, prefix.ptr, cast(int)ex.msg.length, ex.msg.ptr);\n             prefix = prefix~\" \";\n         }\n         printf(\"Bypassed chain was:\\n\");\n         prefix = \"\";\n         for ({ size_t i; Throwable ex = original.bypassedException; } ex; ex = ex.next, ++i)\n         {\n-            printf(\"%.*s%.*s\\n\", prefix.length, prefix.ptr, ex.msg.length, ex.msg.ptr);\n+            printf(\"%.*s%.*s\\n\", cast(int)prefix.length, prefix.ptr, cast(int)ex.msg.length, ex.msg.ptr);\n             prefix = prefix~\" \";\n         }\n     }"}, {"sha": "70762ff227c597aeec8265399cbff8b4cb6d1ed3", "filename": "libphobos/testsuite/libphobos.exceptions/line_trace.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Ftestsuite%2Flibphobos.exceptions%2Fline_trace.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aa603b2452dca48ad86d97d4b918187d259fc/libphobos%2Ftestsuite%2Flibphobos.exceptions%2Fline_trace.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.exceptions%2Fline_trace.d?ref=5a0aa603b2452dca48ad86d97d4b918187d259fc", "patch": "@@ -9,7 +9,7 @@ void main()\n     {\n         import core.stdc.stdio;\n         auto str = e.toString();\n-        printf(\"%.*s\\n\", str.length, str.ptr);\n+        printf(\"%.*s\\n\", cast(int)str.length, str.ptr);\n     }\n }\n "}]}