{"sha": "bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYwZTk3NGJkM2VmOTczZjAyZjgyZDNkMjE4MGY3NzgzYjNlOTJlZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-11-14T15:28:18Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-11-14T15:28:18Z"}, "message": "dsp16xx.c: Fix comment formatting.\n\n\t* config/dsp16xx/dsp16xx.c: Fix comment formatting.\n\t* config/dsp16xx/dsp16xx.h: Likewise.\n\t* config/dsp16xx/dsp16xx.md: Likewise.\n\nFrom-SVN: r47015", "tree": {"sha": "dc53f9914d22fc1e8be6fedc474fbd20ccc939ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc53f9914d22fc1e8be6fedc474fbd20ccc939ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/comments", "author": null, "committer": null, "parents": [{"sha": "a77b1dbce6273d7618085c60ab4bdc4579420c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77b1dbce6273d7618085c60ab4bdc4579420c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a77b1dbce6273d7618085c60ab4bdc4579420c39"}], "stats": {"total": 144, "additions": 75, "deletions": 69}, "files": [{"sha": "25ffd6655c50b82a459eafedcfb119fa6e058f00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "patch": "@@ -1,3 +1,9 @@\n+2001-11-14  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/dsp16xx/dsp16xx.c: Fix comment formatting.\n+\t* config/dsp16xx/dsp16xx.h: Likewise.\n+\t* config/dsp16xx/dsp16xx.md: Likewise.\n+\n 2001-11-14  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.c (get_shift_alg): Reorganize the code"}, {"sha": "a0a80452b40bbed6cdd8f7eab146ddf9323359b8", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "patch": "@@ -494,7 +494,7 @@ preferred_reload_class (x, class)\n     }\n \n   /* If x is not an accumulator or a ybase register, restrict the class of registers\n-     we can copy the register into.   */\n+     we can copy the register into.  */\n \n   if (REG_P (x) && !IS_ACCUM_REG (REGNO (x)) && !IS_YBASE_REGISTER_WINDOW (REGNO (x)))\n     {"}, {"sha": "19a270cea6973804046cde4e433b4ac1479a4380", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "patch": "@@ -94,7 +94,7 @@ extern struct rtx_def *dsp16xx_lshrhi3_libcall;\n    circumstances */\n #define LIB_SPEC \"-lc\"\n \n-/* Specify the startup file to link with. */\n+/* Specify the startup file to link with.  */\n #define STARTFILE_SPEC \"%{mmap1:m1_crt0.o%s}  \\\n %{mmap2:m2_crt0.o%s}                          \\\n %{mmap3:m3_crt0.o%s}                          \\\n@@ -182,7 +182,7 @@ extern int target_flags;\n #define TARGET_NEAR_JUMP (target_flags & MASK_NEAR_JUMP)\n \n /* Generate shift instructions to use the 1610 Bit Manipulation\n-   Unit. */\n+   Unit.  */\n #define TARGET_BMU (target_flags & MASK_BMU)\n \n #define TARGET_YBASE_HIGH (target_flags & MASK_YBASE_HIGH)\n@@ -313,7 +313,7 @@ extern int target_flags;\n \n /* Define if you don't want extended real, but do want to use the\n    software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n+   decimal <-> binary conversion.  */\n #define REAL_ARITHMETIC\n \n /* Define this if most significant bit is lowest numbered\n@@ -323,11 +323,11 @@ extern int target_flags;\n \n /* Define this if most significant byte of a word is the lowest numbered.\n    We define big-endian, but since the 1600 series cannot address bytes\n-   it does not matter. */\n+   it does not matter.  */\n #define BYTES_BIG_ENDIAN 1\n \n /* Define this if most significant word of a multiword number is numbered.\n-   For the 1600 we can decide arbitrarily since there are no machine instructions for them. */\n+   For the 1600 we can decide arbitrarily since there are no machine instructions for them.  */\n #define WORDS_BIG_ENDIAN 1\n \n /* number of bits in an addressable storage unit */\n@@ -339,7 +339,7 @@ extern int target_flags;\n    But on a machine with 16-bit registers, this would be 16.  */\n #define BITS_PER_WORD 16\n \n-/* Maximum number of bits in a word. */\n+/* Maximum number of bits in a word.  */\n #define MAX_BITS_PER_WORD 16\n \n /* Width of a word, in units (bytes).  */\n@@ -380,7 +380,7 @@ extern int target_flags;\n \n /* An integer expression for the size in bits of the largest integer machine mode that\n    should actually be used. All integer machine modes of this size or smaller can be\n-   used for structures and unions with the appropriate sizes. */\n+   used for structures and unions with the appropriate sizes.  */\n #define MAX_FIXED_MODE_SIZE 32\n \f\n /* LAYOUT OF SOURCE LANGUAGE DATA TYPES */\n@@ -395,19 +395,19 @@ extern int target_flags;\n #define LONG_DOUBLE_TYPE_SIZE  32\n \n /* An expression whose value is 1 or 0, according to whether the type char should be\n-   signed or unsigned by default. */\n+   signed or unsigned by default.  */\n \n #define DEFAULT_SIGNED_CHAR 1\n \n /* A C expression to determine whether to give an enum type only as many bytes\n    as it takes to represent the range of possible values of that type. A nonzero\n    value means to do that; a zero value means all enum types should be allocated\n-   like int. */\n+   like int.  */\n \n #define DEFAULT_SHORT_ENUMS 0\n \n /* A C expression for a string describing the name of the data type to use for\n-   size values. */\n+   size values.  */\n \n #define SIZE_TYPE    \"unsigned int\"\n \n@@ -440,7 +440,7 @@ extern int target_flags;\n \n    We reserve r2 for the Stack Pointer.\n    We specify r3 for the Frame Pointer but allow the compiler\n-   to omit it when possible since we have so few pointer registers. */\n+   to omit it when possible since we have so few pointer registers.  */\n \n #define REG_A0     0\n #define REG_A0L    1\n@@ -644,12 +644,12 @@ while (0)\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers. */\n+   but can be less for certain modes in special long registers.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)                                 \\\n   (GET_MODE_SIZE(MODE))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok(REGNO, MODE)\n \n@@ -789,7 +789,7 @@ enum reg_class\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.   */\n+/* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES        \\\n {                              \\\n@@ -946,7 +946,7 @@ enum reg_class\n #define INDEX_REG_CLASS NO_REGS\n #define BASE_REG_CLASS  Y_ADDR_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description. */\n+/* Get reg_class from a letter such as appears in the machine description.  */\n \n #define REG_CLASS_FROM_LETTER(C) \\\n   dsp16xx_reg_class_from_letter(C)\n@@ -956,7 +956,7 @@ enum reg_class\n \n /* When defined, the compiler allows registers explicitly used in the\n    rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers. */\n+   extending the lifetime of these registers.  */\n \n #define SMALL_REGISTER_CLASSES 1\n \n@@ -1012,7 +1012,7 @@ enum reg_class\n      smaller class.\n \n      Don't define this macro unless the target machine has limitations\n-     which require the macro to do something nontrivial. */\n+     which require the macro to do something nontrivial.  */\n \n #if 0\n #define LIMIT_RELOAD_CLASS(MODE, CLASS) dsp16xx_limit_reload_class (MODE, CLASS)\n@@ -1085,7 +1085,7 @@ enum reg_class\n /* We use post decrement on the 1600 because there isn't\n    a pre-decrement addressing mode. This means that we\n    assume the stack pointer always points at the next\n-   FREE location on the stack. */\n+   FREE location on the stack.  */\n #define STACK_PUSH_CODE POST_INC\n \n /* Offset within stack frame to start allocating local variables at.\n@@ -1095,7 +1095,7 @@ enum reg_class\n #define STARTING_FRAME_OFFSET  0\n \n /* Offset from the stack pointer register to the first\n-   location at which outgoing arguments are placed. */\n+   location at which outgoing arguments are placed.  */\n #define STACK_POINTER_OFFSET (0)\n \n struct dsp16xx_frame_info\n@@ -1118,7 +1118,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n #define RETURN_ADDR_OFF current_frame_info.pr_save_offset\n \n /* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by. */\n+   this says how many the stack pointer really advances by.  */\n /* #define PUSH_ROUNDING(BYTES) ((BYTES)) */\n \n /* If defined, the maximum amount of space required for outgoing\n@@ -1128,19 +1128,19 @@ extern struct dsp16xx_frame_info current_frame_info;\n    increase the stack frame size by this amount.\n \n    It is not proper to define both 'PUSH_ROUNDING' and\n-   'ACCUMULATE_OUTGOING_ARGS'. */\n+   'ACCUMULATE_OUTGOING_ARGS'.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer\n-   register value. */\n+   register value.  */\n \n #define FIRST_PARM_OFFSET(FNDECL)   (0)\n \n /* Value is 1 if returning from a function call automatically\n    pops the arguments described by the number-of-args field in the call.\n    FUNDECL is the declaration node of the function (as a tree),\n    FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name. */\n+   or for a library call it is an identifier node for the subroutine name.  */\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n@@ -1149,7 +1149,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0. On the 1610 all function return their values\n    in a0 (i.e. the upper 16 bits). If the return value is 32-bits the\n-   entire register is significant. */\n+   entire register is significant.  */\n \n #define VALUE_REGNO(MODE)  (REG_Y)\n \n@@ -1160,7 +1160,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, VALUE_REGNO(MODE))\n \n-/* 1 if N is a possible register number for a function value. */\n+/* 1 if N is a possible register number for a function value.  */\n #define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_Y)\n \f\n \n@@ -1178,7 +1178,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n /* On the 1610 all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in a0, a1. */\n+   then the first two words of arguments are passed in a0, a1.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   dsp16xx_function_arg (CUM, MODE, TYPE, NAMED)\n \n@@ -1188,7 +1188,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n /* Define the profitability of saving registers around calls.\n    NOTE: For now we turn this off because of a bug in the\n    caller-saves code and also because i'm not sure it is helpful\n-   on the 1610. */\n+   on the 1610.  */\n \n #define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n \n@@ -1210,12 +1210,12 @@ extern struct dsp16xx_frame_info current_frame_info;\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go. */\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n #define CUMULATIVE_ARGS int\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0. */\n+   For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)  ((CUM) = 0)\n \n /* Update the data in CUM to advance over an argument\n@@ -1225,23 +1225,23 @@ extern struct dsp16xx_frame_info current_frame_info;\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   dsp16xx_function_arg_advance (&CUM, MODE,TYPE, NAMED)\n \n-/* 1 if N is a possible register number for function argument passing. */\n+/* 1 if N is a possible register number for function argument passing.  */\n #define FUNCTION_ARG_REGNO_P(N)   \\\n   ((N) == REG_Y || (N) == REG_YL || (N) == REG_PROD || (N) == REG_PRODL)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry. */\n+   for profiling a function entry.  */\n \n #define FUNCTION_PROFILER(FILE, LABELNO)        \\\n   internal_error (\"Profiling not implemented yet.\")\n \n /* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done. */\n+   basic block profiling info, if that has not already been done.  */\n #define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n   internal_error (\"Profiling not implemented yet.\")\n \n /* Output assembler code to FILE to increment the entry-count for\n-   the BLOCKNO'th basic block in this source file. */\n+   the BLOCKNO'th basic block in this source file.  */\n #define BLOCK_PROFILER(FILE, BLOCKNO)\t        \\\n   internal_error (\"Profiling not implemented yet.\")\n \n@@ -1263,19 +1263,19 @@ extern struct dsp16xx_frame_info current_frame_info;\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function. */\n+   CXT is an RTX for the static chain value for the function.  */\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n   internal_error (\"Trampolines not yet implemented\");\n \n /* A C expression which is nonzero if a function must have and use a\n    frame pointer. If its value is nonzero the functions will have a\n-   frame pointer. */\n+   frame pointer.  */\n #define FRAME_POINTER_REQUIRED  (current_function_calls_alloca)\n \n /* A C statement to store in the variable 'DEPTH' the difference\n    between the frame pointer and the stack pointer values immediately\n-   after the function prologue. */\n+   after the function prologue.  */\n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH)                     \\\n {  (DEPTH) = initial_frame_pointer_offset();\t                \\\n }\n@@ -1307,7 +1307,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n #define LSHLHI3_LIBCALL     \"__Emulate_lshlhi3\"   /* NOT USED */\n \n /* Define this macro if calls to the ANSI C library functions memcpy and\n-   memset should be generated instead of the BSD function bcopy & bzero. */\n+   memset should be generated instead of the BSD function bcopy & bzero.  */\n #define TARGET_MEM_FUNCTIONS\n \n \f\n@@ -1456,7 +1456,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n /* Store in cc_status the expressions\n    that the condition codes will describe\n    after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's. */\n+   Do not alter them if the instruction would not alter the cc's.  */\n \n #define NOTICE_UPDATE_CC(EXP, INSN) \\\n    notice_update_cc( (EXP) )\n@@ -1466,7 +1466,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,\n-   return it with a return statement. */\n+   return it with a return statement.  */\n #define CONST_COSTS(RTX,CODE,OUTER_CODE)                                \\\n   case CONST_INT:\t\t\t\t\t\t        \\\n     return (unsigned) INTVAL (RTX) < 65536 ? 0 : 2;                     \\\n@@ -1480,7 +1480,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n \n /* Like CONST_COSTS but applies to nonconstant RTL expressions.\n    This can be used, for example to indicate how costly a multiply\n-   instruction is. */\n+   instruction is.  */\n #define RTX_COSTS(X,CODE,OUTER_CODE)                            \\\n   case MEM:                                                     \\\n     return GET_MODE (X) == QImode ? COSTS_N_INSNS (2) :         \\\n@@ -1534,17 +1534,17 @@ extern struct dsp16xx_frame_info current_frame_info;\n       return COSTS_N_INSNS (15);\n \n /* An expression giving the cost of an addressing mode that contains\n-   address. */\n+   address.  */\n #define ADDRESS_COST(ADDR)  dsp16xx_address_cost (ADDR)\n \n /* A c expression for the cost of moving data from a register in\n    class FROM to one in class TO. The classes are expressed using\n    the enumeration values such as GENERAL_REGS. A value of 2 is\n-   the default. */\n+   the default.  */\n #define REGISTER_MOVE_COST(MODE,FROM,TO)  dsp16xx_register_move_cost (FROM, TO)\n \n /* A C expression for the cost of moving data of mode MODE between\n-   a register and memory. A value of 2 is the default. */\n+   a register and memory. A value of 2 is the default.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,IN)                          \\\n   (GET_MODE_CLASS(MODE) == MODE_INT && MODE == QImode ? 12       \\\n    : 16)\n@@ -1555,18 +1555,18 @@ extern struct dsp16xx_frame_info current_frame_info;\n \f\n \n /* Define this because otherwise gcc will try to put the function address\n-   in any old pseudo register. We can only use pt. */\n+   in any old pseudo register. We can only use pt.  */\n #define NO_FUNCTION_CSE\n \n /* Define this macro as a C expression which is nonzero if accessing less\n    than a word of memory (i.e a char or short) is no faster than accessing\n    a word of memory, i.e if such access require more than one instruction\n    or if ther is no difference in cost between byte and (aligned) word\n-   loads. */\n+   loads.  */\n #define SLOW_BYTE_ACCESS 1\n \n /* Define this macro if zero-extension (of a char or short to an int) can\n-   be done faster if the destination is a register that is know to be zero. */\n+   be done faster if the destination is a register that is know to be zero.  */\n /* #define SLOW_ZERO_EXTEND */\n \n /* Define this macro if unaligned accesses have a cost many times greater than\n@@ -1596,11 +1596,11 @@ extern struct dsp16xx_frame_info current_frame_info;\n #define BSS_SECTION_ASM_OP rsect_bss\n \n /* We will default to using 1610 if the user doesn't\n-   specify it. */\n+   specify it.  */\n #define DEFAULT_CHIP_NAME \"1610\"\n \n /* A list of names for sections other than the standard ones, which are\n-   'in_text' and 'in_data' (and .bss if BSS_SECTION_ASM_OP is defined). */\n+   'in_text' and 'in_data' (and .bss if BSS_SECTION_ASM_OP is defined).  */\n #define EXTRA_SECTIONS in_const\n \n #define EXTRA_SECTION_FUNCTIONS  \\\n@@ -1624,7 +1624,7 @@ const_section ()                                                   \\\n #define ASM_IDENTIFY_GCC(FILE)   \n \n /* A C string constant describing how to begin a comment in the target\n-   assembler language. */\n+   assembler language.  */\n #define ASM_COMMENT_START \"\"\n #define ASM_COMMENT_END \"\"\n \n@@ -1645,7 +1645,7 @@ const_section ()                                                   \\\n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  asm_output_float (FILE, VALUE)\n \n /* This is how to output an assembler line defining a 'float' constant of\n-   size HFmode. */\n+   size HFmode.  */\n #define ASM_OUTPUT_SHORT_FLOAT(FILE,VALUE)  asm_output_float (FILE, VALUE)\n \n /* This is how to output an assembler line defining an `char' constant.  */\n@@ -1657,7 +1657,7 @@ const_section ()                                                   \\\n /* This is how to output an assembler line defining an `short' constant.  */\n #define ASM_OUTPUT_SHORT(FILE,EXP)   asm_output_long(FILE,INTVAL(EXP))\n \n-/* This is how to output an assembler line defining a 'int' constant. */\n+/* This is how to output an assembler line defining a 'int' constant.  */\n #define ASM_OUTPUT_INT(FILE, EXP)    asm_output_long(FILE,INTVAL(EXP))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n@@ -1723,7 +1723,7 @@ const_section ()                                                   \\\n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable or function\n    named NAME. LABELNO is an integer which is different for\n-   each call. */\n+   each call.  */\n \n #define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -1766,7 +1766,7 @@ const_section ()                                                   \\\n \n /* A C statement to output to the stdio stream any text necessary\n    for declaring the name of an external symbol named name which\n-   is referenced in this compilation but not defined. */\n+   is referenced in this compilation but not defined.  */\n \n #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)   \\\n {\t\t\t\t\t\\\n@@ -1775,7 +1775,7 @@ const_section ()                                                   \\\n \tfprintf (FILE, \"\\n\");\t\t\\\n }\n /* A C statement to output on stream an assembler pseudo-op to\n-   declare a library function named external. */\n+   declare a library function named external.  */\n \n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)    \\\n {\t\t\t\t\t\t\\\n@@ -1784,7 +1784,7 @@ const_section ()                                                   \\\n \tfprintf (FILE, \"\\n\");\t\t\t\\\n }\n \n-/* The prefix to add to user-visible assembler symbols. */\n+/* The prefix to add to user-visible assembler symbols.  */\n \n #define USER_LABEL_PREFIX \"_\"\n \n@@ -1848,7 +1848,7 @@ const_section ()                                                   \\\n #define PRINT_OPERAND(FILE, X, CODE) print_operand(FILE, X, CODE)\n \n \n-/* Print a memory address as an operand to reference that memory location. */\n+/* Print a memory address as an operand to reference that memory location.  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address (FILE, ADDR)\n \n@@ -1865,24 +1865,24 @@ const_section ()                                                   \\\n /* OUTPUT OF DISPATCH TABLES */\n \n /* This macro should be provided on machines where the addresses in a dispatch\n-   table are relative to the table's own address. */\n+   table are relative to the table's own address.  */\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\tint L%d-L%d\\n\", VALUE, REL)\n \n /* This macro should be provided on machines where the addresses in a dispatch\n-   table are absolute. */\n+   table are absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\tint L%d\\n\", VALUE)\n \n /* ASSEMBLER COMMANDS FOR ALIGNMENT */\n \n /* This is how to output an assembler line that says to advance \n    the location counter to a multiple of 2**LOG bytes. We should\n-   not have to do any alignment since the 1610 is a word machine. */\n+   not have to do any alignment since the 1610 is a word machine.  */\n #define ASM_OUTPUT_ALIGN(FILE,LOG)\n \n /* Define this macro if ASM_OUTPUT_SKIP should not be used in the text section\n-   because it fails to put zero1 in the bytes that are skipped. */\n+   because it fails to put zero1 in the bytes that are skipped.  */\n #define ASM_NO_SKIP_IN_TEXT 1\n \n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n@@ -1913,7 +1913,7 @@ const_section ()                                                   \\\n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n    table.\n-   Do not define this if the table should contain absolute addresses. */\n+   Do not define this if the table should contain absolute addresses.  */\n /* #define CASE_VECTOR_PC_RELATIVE 1 */\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n@@ -1930,7 +1930,7 @@ const_section ()                                                   \\\n    or bitwise 'and' instruction that truncates the count of a shift operation\n    to a width equal to the number of bits needed to represent the size of the\n    object being shifted. Do not define this macro unless the truncation applies\n-   to both shift operations and bit-field operations (if any). */\n+   to both shift operations and bit-field operations (if any).  */\n /* #define SHIFT_COUNT_TRUNCATED */\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n@@ -1961,6 +1961,6 @@ const_section ()                                                   \\\n #define DEFAULT_SIGNED_CHAR 1\n \n /* Define this so gcc does not output a call to __main, since we\n-   are not currently supporting c++. */\n+   are not currently supporting c++.  */\n #define INIT_SECTION_ASM_OP  1\n "}, {"sha": "408e6a737c0da110b543f23f73eeb5d4748dce14", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf0e974bd3ef973f02f82d3d2180f7783b3e92ee/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=bf0e974bd3ef973f02f82d3d2180f7783b3e92ee", "patch": "@@ -1571,7 +1571,7 @@\n {\n   /* Check for an overlap of operand 2 (an accumulator) with\n      the msw of operand 0. If we have an overlap we must reverse\n-     the order of the moves. */\n+     the order of the moves.  */\n \n   if (REGNO(operands[2]) == REGNO(operands[0]))\n     {\n@@ -1707,7 +1707,7 @@\n {\n   /* Check for an overlap of operand 2 (an accumulator) with\n      the msw of operand 0. If we have an overlap we must reverse\n-     the order of the moves. */\n+     the order of the moves.  */\n \n   if (REGNO(operands[2]) == REGNO(operands[0]))\n     {\n@@ -2015,7 +2015,7 @@\n   {\n       /* If we are shifting by a constant we can do it in 1 or more\n \t 1600 core shift instructions. The core instructions can\n-\t shift by 1, 4, 8, or 16. */\n+\t shift by 1, 4, 8, or 16.  */\n       \n       if (GET_CODE(operands[2]) == CONST_INT)\n \t;\n@@ -2141,7 +2141,7 @@\n     {\n       /* If we are shifting by a constant we can do it in 1 or more\n \t 1600 core shift instructions. The core instructions can\n-\t shift by 1, 4, 8, or 16. */\n+\t shift by 1, 4, 8, or 16.  */\n       \n       if (GET_CODE(operands[2]) == CONST_INT)\n \temit_insn (gen_match_lshrhi3_nobmu (operands[0], operands[1], operands[2]));\t\n@@ -2276,7 +2276,7 @@\n   {\n       /* If we are shifting by a constant we can do it in 1 or more\n \t 1600 core shift instructions. The core instructions can\n-\t shift by 1, 4, 8, or 16. */\n+\t shift by 1, 4, 8, or 16.  */\n       \n       if (GET_CODE(operands[2]) == CONST_INT)\n \t;"}]}