{"sha": "09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlkZmE0OTUxYWE5Yjg3MDBjOWQzMDQ3ZTcxMjA1MGQ3YzFlNGU5NA==", "commit": {"author": {"name": "Bingfeng Mei", "email": "bmei@broadcom.com", "date": "2013-12-20T13:46:01Z"}, "committer": {"name": "Bingfeng Mei", "email": "meibf@gcc.gnu.org", "date": "2013-12-20T13:46:01Z"}, "message": "re PR tree-optimization/59544 (Vectorizing store with negative step)\n\n2013-12-20  Bingfeng Mei  <bmei@broadcom.com>\n\n\tPR tree-optimization/59544\n\t* tree-vect-stmts.c (perm_mask_for_reverse): Move before\n\tvectorizable_store. \n\t(vectorizable_store): Handle negative step.\n\n\t* gcc.target/i386/pr59544.c: New test.\n\nFrom-SVN: r206148", "tree": {"sha": "80c9cee1e5490b99e947f1d357a1fa73a7eb85a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80c9cee1e5490b99e947f1d357a1fa73a7eb85a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/comments", "author": null, "committer": null, "parents": [{"sha": "fc4f394b22144fd86324bec3c0566ad6a548bc9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4f394b22144fd86324bec3c0566ad6a548bc9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc4f394b22144fd86324bec3c0566ad6a548bc9b"}], "stats": {"total": 120, "additions": 96, "deletions": 24}, "files": [{"sha": "8442c7f07a12a85a869fb141cede1a90ffba9d44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "patch": "@@ -1,3 +1,10 @@\n+2013-12-20  Bingfeng Mei  <bmei@broadcom.com>\n+\n+\tPR tree-optimization/59544\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Move before\n+\tvectorizable_store. \n+\t(vectorizable_store): Handle negative step.\n+\n 2013-12-20  Tocar Ilya  <ilya.tocar@intel.com>\n \n \t* config.gcc: Support march=broadwell."}, {"sha": "fbc6244d4dec81321b607ee2966d748cde0cebdc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "patch": "@@ -1,3 +1,8 @@\n+2013-12-20  Bingfeng Mei  <bmei@broadcom.com>\n+\n+\tPR tree-optimization/59544\n+\t* gcc.target/i386/pr59544.c: New test.\n+\n 2013-12-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/59413"}, {"sha": "5499a53d954b2bbd7233d20cd9f278cf38f2e36f", "filename": "gcc/testsuite/gcc.target/i386/pr59544.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59544.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59544.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59544.c?ref=09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx -ftree-vectorize -fdump-tree-vect-details\" } */\n+\n+void test1(short * __restrict__ x, short * __restrict__ y, short * __restrict__ z)\n+{\n+    int i;\n+    for (i=127; i>=0; i--) {\n+\tx[i] = y[127-i] + z[127-i];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3056c2ede0089068c9c3003ec36a3eef3b4de3af", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09dfa4951aa9b8700c9d3047e712050d7c1e4e94/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=09dfa4951aa9b8700c9d3047e712050d7c1e4e94", "patch": "@@ -4859,6 +4859,25 @@ ensure_base_align (stmt_vec_info stmt_info, struct data_reference *dr)\n }\n \n \n+/* Given a vector type VECTYPE returns the VECTOR_CST mask that implements\n+   reversal of the vector elements.  If that is impossible to do,\n+   returns NULL.  */\n+\n+static tree\n+perm_mask_for_reverse (tree vectype)\n+{\n+  int i, nunits;\n+  unsigned char *sel;\n+\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  sel = XALLOCAVEC (unsigned char, nunits);\n+\n+  for (i = 0; i < nunits; ++i)\n+    sel[i] = nunits - 1 - i;\n+\n+  return vect_gen_perm_mask (vectype, sel);\n+}\n+\n /* Function vectorizable_store.\n \n    Check if STMT defines a non scalar data-ref (array/pointer/structure) that\n@@ -4902,6 +4921,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   vec<tree> oprnds = vNULL;\n   vec<tree> result_chain = vNULL;\n   bool inv_p;\n+  bool negative = false;\n+  tree offset = NULL_TREE;\n   vec<tree> vec_oprnds = vNULL;\n   bool slp = (slp_node != NULL);\n   unsigned int vec_num;\n@@ -4976,16 +4997,39 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  if (tree_int_cst_compare (loop && nested_in_vect_loop_p (loop, stmt)\n-\t\t\t    ? STMT_VINFO_DR_STEP (stmt_info) : DR_STEP (dr),\n-\t\t\t    size_zero_node) < 0)\n+  negative = \n+    tree_int_cst_compare (loop && nested_in_vect_loop_p (loop, stmt)\n+\t\t\t  ? STMT_VINFO_DR_STEP (stmt_info) : DR_STEP (dr),\n+\t\t\t  size_zero_node) < 0;\n+  if (negative && ncopies > 1)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"negative step for store.\\n\");\n+\t\t\t \"multiple types with negative step.\");\n       return false;\n     }\n \n+  if (negative)\n+    {\n+      gcc_assert (!grouped_store);\n+      alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+      if (alignment_support_scheme != dr_aligned\n+\t  && alignment_support_scheme != dr_unaligned_supported)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"negative step but alignment required.\");\n+\t  return false;\n+\t}\n+      if (!perm_mask_for_reverse (vectype))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"negative step and reversing not supported.\");\n+\t  return false;\n+\t}\n+    }\n+\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       grouped_store = true;\n@@ -5090,6 +5134,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      || alignment_support_scheme == dr_aligned\n \t      || alignment_support_scheme == dr_unaligned_supported);\n \n+  if (negative)\n+    offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n+\n   if (store_lanes_p)\n     aggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n   else\n@@ -5200,7 +5247,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    dataref_ptr\n \t      = vect_create_data_ref_ptr (first_stmt, aggr_type,\n \t\t\t\t\t  simd_lane_access_p ? loop : NULL,\n-\t\t\t\t\t  NULL_TREE, &dummy, gsi, &ptr_incr,\n+\t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n \t\t\t\t\t  simd_lane_access_p, &inv_p);\n \t  gcc_assert (bb_vinfo || !inv_p);\n \t}\n@@ -5306,6 +5353,25 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\tset_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n \t\t\t\t\tmisalign);\n \n+\t      if (negative)\n+\t\t{\n+\t\t  tree perm_mask = perm_mask_for_reverse (vectype);\n+\t\t  tree perm_dest \n+\t\t    = vect_create_destination_var (gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t\t   vectype);\n+\t\t  tree new_temp = make_ssa_name (perm_dest, NULL);\n+\n+\t\t  /* Generate the permute statement.  */\n+\t\t  gimple perm_stmt \n+\t\t    = gimple_build_assign_with_ops (VEC_PERM_EXPR, new_temp,\n+\t\t\t\t\t\t    vec_oprnd, vec_oprnd,\n+\t\t\t\t\t\t    perm_mask);\n+\t\t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\n+\t\t  perm_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t\t  vec_oprnd = new_temp;\n+\t\t}\n+\n \t      /* Arguments are ready.  Create the new vector stmt.  */\n \t      new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -5363,25 +5429,6 @@ vect_gen_perm_mask (tree vectype, unsigned char *sel)\n   return mask_vec;\n }\n \n-/* Given a vector type VECTYPE returns the VECTOR_CST mask that implements\n-   reversal of the vector elements.  If that is impossible to do,\n-   returns NULL.  */\n-\n-static tree\n-perm_mask_for_reverse (tree vectype)\n-{\n-  int i, nunits;\n-  unsigned char *sel;\n-\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  sel = XALLOCAVEC (unsigned char, nunits);\n-\n-  for (i = 0; i < nunits; ++i)\n-    sel[i] = nunits - 1 - i;\n-\n-  return vect_gen_perm_mask (vectype, sel);\n-}\n-\n /* Given a vector variable X and Y, that was generated for the scalar\n    STMT, generate instructions to permute the vector elements of X and Y\n    using permutation mask MASK_VEC, insert them at *GSI and return the"}]}