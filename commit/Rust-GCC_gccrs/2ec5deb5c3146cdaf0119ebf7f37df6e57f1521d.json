{"sha": "2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjNWRlYjVjMzE0NmNkYWYwMTE5ZWJmN2YzN2RmNmU1N2YxNTIxZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-03-29T18:26:43Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-03-29T18:26:43Z"}, "message": "c-common.c (c_expand_expr, c_staticp): Remove.\n\n2009-03-28  Paolo Bonzini  <bonzini@gnu.org>\n\n        * c-common.c (c_expand_expr, c_staticp): Remove.\n        * c-common.def (COMPOUND_LITERAL_EXPR): Delete.\n        * c-common.h (emit_local_var, c_staticp, COMPOUND_LITERAL_EXPR_DECL,\n        COMPOUND_LITERAL_EXPR_DECL_EXPR): Remove.\n        * c-gimplify.c (gimplify_compound_literal_expr,\n        optimize_compound_literals_in_ctor): Remove.\n        (c_gimplify_expr): Remove COMPOUND_LITERAL_EXPR handling.\n        * c-objc-common.h (LANG_HOOKS_STATICP): Remove.\n        * c-semantics.c (emit_local_var): Remove.\n\n        * langhooks-def.h (lhd_expand_expr): Remove.\n        * langhooks.c (lhd_expand_expr): Remove.\n        * langhooks.h (LANG_HOOKS_DEF): Remove LANG_HOOKS_EXPAND_EXPR.\n\n        * expr.c (expand_expr_real_1): Move COMPOUND_LITERAL_EXPR\n        handling from c-semantics.c; don't call into langhook.\n        (expand_expr_addr_expr_1): Check that we don't get non-GENERIC trees.\n        * gimplify.c (gimplify_compound_literal_expr,\n        optimize_compound_literals_in_ctor): Move from c-gimplify.c.\n        (gimplify_init_constructor): Call optimize_compound_literals_in_ctor.\n        (gimplify_modify_expr_rhs, gimplify_expr): Handle COMPOUND_LITERAL_EXPR\n        as was done in c-gimplify.c.\n        * tree.c (staticp): Move COMPOUND_LITERAL_EXPR handling from c_staticp.\n        * tree.h (COMPOUND_LITERAL_EXPR_DECL, COMPOUND_LITERAL_EXPR_DECL_EXPR):\n        Move from c-common.h.\n        * tree.def (COMPOUND_LITERAL_EXPR): Move from c-common.def.\n\n\t* tree.c (staticp): Do not call langhook.\n\t* langhooks.c (lhd_staticp): Delete.\n\t* langhooks-def.h (lhd_staticp): Delete prototype.\n\t(LANG_HOOKS_STATICP): Delete.\n\t(LANG_HOOKS_INITIALIZER): Delete LANG_HOOKS_STATICP.\n\n        * doc/c-tree.texi (Expression nodes): Refer to DECL_EXPRs\n        instead of DECL_STMTs.\n\ncp:\n2009-03-28  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* cp/cp-objcp-common.h (LANG_HOOKS_STATICP): Remove.\n\t* cp/cp-objcp-common.c (cxx_staticp): Remove.\n\t* cp/cp-tree.h (cxx_staticp): Remove.\n\nFrom-SVN: r145256", "tree": {"sha": "526edb481d86189b52a2f69267f299aba9085156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/526edb481d86189b52a2f69267f299aba9085156"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "928c19bbb001967c7ab83a9f856c740680b6661f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928c19bbb001967c7ab83a9f856c740680b6661f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928c19bbb001967c7ab83a9f856c740680b6661f"}], "stats": {"total": 493, "additions": 210, "deletions": 283}, "files": [{"sha": "4c39a9bfc0d417d5b9bb4f6e6972ba6bcbda0538", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -1,3 +1,41 @@\n+2009-03-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * c-common.c (c_expand_expr, c_staticp): Remove.\n+        * c-common.def (COMPOUND_LITERAL_EXPR): Delete.\n+        * c-common.h (emit_local_var, c_staticp, COMPOUND_LITERAL_EXPR_DECL,\n+        COMPOUND_LITERAL_EXPR_DECL_EXPR): Remove.\n+        * c-gimplify.c (gimplify_compound_literal_expr,\n+        optimize_compound_literals_in_ctor): Remove.\n+        (c_gimplify_expr): Remove COMPOUND_LITERAL_EXPR handling.\n+        * c-objc-common.h (LANG_HOOKS_STATICP): Remove.\n+        * c-semantics.c (emit_local_var): Remove.\n+\n+        * langhooks-def.h (lhd_expand_expr): Remove.\n+        * langhooks.c (lhd_expand_expr): Remove.\n+        * langhooks.h (LANG_HOOKS_DEF): Remove LANG_HOOKS_EXPAND_EXPR.\n+\n+        * expr.c (expand_expr_real_1): Move COMPOUND_LITERAL_EXPR\n+        handling from c-semantics.c; don't call into langhook.\n+        (expand_expr_addr_expr_1): Check that we don't get non-GENERIC trees.\n+        * gimplify.c (gimplify_compound_literal_expr,\n+        optimize_compound_literals_in_ctor): Move from c-gimplify.c.\n+        (gimplify_init_constructor): Call optimize_compound_literals_in_ctor.\n+        (gimplify_modify_expr_rhs, gimplify_expr): Handle COMPOUND_LITERAL_EXPR\n+        as was done in c-gimplify.c.\n+        * tree.c (staticp): Move COMPOUND_LITERAL_EXPR handling from c_staticp.\n+        * tree.h (COMPOUND_LITERAL_EXPR_DECL, COMPOUND_LITERAL_EXPR_DECL_EXPR):\n+        Move from c-common.h.\n+        * tree.def (COMPOUND_LITERAL_EXPR): Move from c-common.def.\n+\n+\t* tree.c (staticp): Do not call langhook.\n+\t* langhooks.c (lhd_staticp): Delete.\n+\t* langhooks-def.h (lhd_staticp): Delete prototype.\n+\t(LANG_HOOKS_STATICP): Delete.\n+\t(LANG_HOOKS_INITIALIZER): Delete LANG_HOOKS_STATICP.\n+\n+        * doc/c-tree.texi (Expression nodes): Refer to DECL_EXPRs\n+        instead of DECL_STMTs.\n+\n 2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/456"}, {"sha": "8450cc9860514a1df4010d7508597beff972a109", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -5444,43 +5444,6 @@ finish_label_address_expr (tree label, location_t loc)\n \n   return result;\n }\n-\n-/* Hook used by expand_expr to expand language-specific tree codes.  */\n-/* The only things that should go here are bits needed to expand\n-   constant initializers.  Everything else should be handled by the\n-   gimplification routines.  */\n-\n-rtx\n-c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n-\t       int modifiera /* Actually enum expand_modifier.  */,\n-\t       rtx *alt_rtl)\n-{\n-  enum expand_modifier modifier = (enum expand_modifier) modifiera;\n-  switch (TREE_CODE (exp))\n-    {\n-    case COMPOUND_LITERAL_EXPR:\n-      {\n-\t/* Initialize the anonymous variable declared in the compound\n-\t   literal, then return the variable.  */\n-\ttree decl = COMPOUND_LITERAL_EXPR_DECL (exp);\n-\temit_local_var (decl);\n-\treturn expand_expr_real (decl, target, tmode, modifier, alt_rtl);\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Hook used by staticp to handle language-specific tree codes.  */\n-\n-tree\n-c_staticp (tree exp)\n-{\n-  return (TREE_CODE (exp) == COMPOUND_LITERAL_EXPR\n-\t  && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp))\n-\t  ? exp : NULL);\n-}\n \f\n \n /* Given a boolean expression ARG, return a tree representing an increment"}, {"sha": "c4027f7dbed317f8f8e0c27b135c53721fdcc431", "filename": "gcc/c-common.def", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -24,13 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Tree nodes used in the C frontend.  These are also shared with the\n    C++ and Objective C frontends.  */\n \n-/* A COMPOUND_LITERAL_EXPR represents a C99 compound literal.  The\n-   COMPOUND_LITERAL_EXPR_DECL_STMT is the a DECL_STMT containing the decl\n-   for the anonymous object represented by the COMPOUND_LITERAL;\n-   the DECL_INITIAL of that decl is the CONSTRUCTOR that initializes\n-   the compound literal.  */\n-DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", tcc_expression, 1)\n-\n /* A C_MAYBE_CONST_EXPR, currently only used for C and Objective C,\n    tracks information about constancy of an expression and VLA type\n    sizes or VM expressions from typeof that need to be evaluated"}, {"sha": "6b5fb94ad8f7bf43753d2efc25808acfeb4e0113", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -798,12 +798,6 @@ extern void finish_file\t(void);\n #define STATEMENT_LIST_HAS_LABEL(NODE) \\\n   TREE_LANG_FLAG_3 (STATEMENT_LIST_CHECK (NODE))\n \n-/* COMPOUND_LITERAL_EXPR accessors.  */\n-#define COMPOUND_LITERAL_EXPR_DECL_STMT(NODE)\t\t\\\n-  TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)\n-#define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n-  DECL_EXPR_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n-\n /* C_MAYBE_CONST_EXPR accessors.  */\n #define C_MAYBE_CONST_EXPR_PRE(NODE)\t\t\t\\\n   TREE_OPERAND (C_MAYBE_CONST_EXPR_CHECK (NODE), 0)\n@@ -827,7 +821,6 @@ extern void finish_file\t(void);\n #define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n   (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n \n-extern void emit_local_var (tree);\n extern tree do_case (tree, tree);\n extern tree build_stmt (enum tree_code, ...);\n extern tree build_case_label (tree, tree, tree);\n@@ -876,8 +869,6 @@ extern bool vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_\n \n extern rtx c_expand_expr (tree, rtx, enum machine_mode, int, rtx *);\n \n-extern tree c_staticp (tree);\n-\n extern void init_c_lex (void);\n \n extern void c_cpp_builtins (cpp_reader *);"}, {"sha": "9cb4a0b2d17bbfe9750b5f63d7b5744286493941", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 13, "deletions": 133, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -176,145 +176,25 @@ c_build_bind_expr (tree block, tree body)\n \n /* Gimplification of expression trees.  */\n \n-/* Gimplify a C99 compound literal expression.  This just means adding\n-   the DECL_EXPR before the current statement and using its anonymous\n-   decl instead.  */\n-\n-static enum gimplify_status\n-gimplify_compound_literal_expr (tree *expr_p, gimple_seq *pre_p)\n-{\n-  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (*expr_p);\n-  tree decl = DECL_EXPR_DECL (decl_s);\n-  /* Mark the decl as addressable if the compound literal\n-     expression is addressable now, otherwise it is marked too late\n-     after we gimplify the initialization expression.  */\n-  if (TREE_ADDRESSABLE (*expr_p))\n-    TREE_ADDRESSABLE (decl) = 1;\n-\n-  /* Preliminarily mark non-addressed complex variables as eligible\n-     for promotion to gimple registers.  We'll transform their uses\n-     as we find them.  */\n-  if ((TREE_CODE (TREE_TYPE (decl)) == COMPLEX_TYPE\n-       || TREE_CODE (TREE_TYPE (decl)) == VECTOR_TYPE)\n-      && !TREE_THIS_VOLATILE (decl)\n-      && !needs_to_live_in_memory (decl))\n-    DECL_GIMPLE_REG_P (decl) = 1;\n-\n-  /* This decl isn't mentioned in the enclosing block, so add it to the\n-     list of temps.  FIXME it seems a bit of a kludge to say that\n-     anonymous artificial vars aren't pushed, but everything else is.  */\n-  if (DECL_NAME (decl) == NULL_TREE && !DECL_SEEN_IN_BIND_EXPR_P (decl))\n-    gimple_add_tmp_var (decl);\n-\n-  gimplify_and_add (decl_s, pre_p);\n-  *expr_p = decl;\n-  return GS_OK;\n-}\n-\n-/* Optimize embedded COMPOUND_LITERAL_EXPRs within a CONSTRUCTOR,\n-   return a new CONSTRUCTOR if something changed.  */\n-\n-static tree\n-optimize_compound_literals_in_ctor (tree orig_ctor)\n-{\n-  tree ctor = orig_ctor;\n-  VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (ctor);\n-  unsigned int idx, num = VEC_length (constructor_elt, elts);\n-\n-  for (idx = 0; idx < num; idx++)\n-    {\n-      tree value = VEC_index (constructor_elt, elts, idx)->value;\n-      tree newval = value;\n-      if (TREE_CODE (value) == CONSTRUCTOR)\n-\tnewval = optimize_compound_literals_in_ctor (value);\n-      else if (TREE_CODE (value) == COMPOUND_LITERAL_EXPR)\n-\t{\n-\t  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (value);\n-\t  tree decl = DECL_EXPR_DECL (decl_s);\n-\t  tree init = DECL_INITIAL (decl);\n-\n-\t  if (!TREE_ADDRESSABLE (value)\n-\t      && !TREE_ADDRESSABLE (decl)\n-\t      && init)\n-\t    newval = init;\n-\t}\n-      if (newval == value)\n-\tcontinue;\n-\n-      if (ctor == orig_ctor)\n-\t{\n-\t  ctor = copy_node (orig_ctor);\n-\t  CONSTRUCTOR_ELTS (ctor) = VEC_copy (constructor_elt, gc, elts);\n-\t  elts = CONSTRUCTOR_ELTS (ctor);\n-\t}\n-      VEC_index (constructor_elt, elts, idx)->value = newval;\n-    }\n-  return ctor;\n-}\n-\n /* Do C-specific gimplification on *EXPR_P.  PRE_P and POST_P are as in\n    gimplify_expr.  */\n \n int\n-c_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n+c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n \t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*expr_p);\n \n-  switch (code)\n-    {\n-    case DECL_EXPR:\n-      /* This is handled mostly by gimplify.c, but we have to deal with\n-\t not warning about int x = x; as it is a GCC extension to turn off\n-\t this warning but only if warn_init_self is zero.  */\n-      if (TREE_CODE (DECL_EXPR_DECL (*expr_p)) == VAR_DECL\n-\t  && !DECL_EXTERNAL (DECL_EXPR_DECL (*expr_p))\n-\t  && !TREE_STATIC (DECL_EXPR_DECL (*expr_p))\n-\t  && (DECL_INITIAL (DECL_EXPR_DECL (*expr_p))\n-\t      == DECL_EXPR_DECL (*expr_p))\n-\t  && !warn_init_self)\n-\tTREE_NO_WARNING (DECL_EXPR_DECL (*expr_p)) = 1;\n-      return GS_UNHANDLED;\n-\n-    case COMPOUND_LITERAL_EXPR:\n-      return gimplify_compound_literal_expr (expr_p, pre_p);\n-\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == COMPOUND_LITERAL_EXPR)\n-\t{\n-\t  tree complit = TREE_OPERAND (*expr_p, 1);\n-\t  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (complit);\n-\t  tree decl = DECL_EXPR_DECL (decl_s);\n-\t  tree init = DECL_INITIAL (decl);\n-\n-\t  /* struct T x = (struct T) { 0, 1, 2 } can be optimized\n-\t     into struct T x = { 0, 1, 2 } if the address of the\n-\t     compound literal has never been taken.  */\n-\t  if (!TREE_ADDRESSABLE (complit)\n-\t      && !TREE_ADDRESSABLE (decl)\n-\t      && init)\n-\t    {\n-\t      *expr_p = copy_node (*expr_p);\n-\t      TREE_OPERAND (*expr_p, 1) = init;\n-\t      return GS_OK;\n-\t    }\n-\t}\n-      else if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == CONSTRUCTOR)\n-\t{\n-\t  tree ctor\n-\t    = optimize_compound_literals_in_ctor (TREE_OPERAND (*expr_p, 1));\n-\n-\t  if (ctor != TREE_OPERAND (*expr_p, 1))\n-\t    {\n-\t      *expr_p = copy_node (*expr_p);\n-\t      TREE_OPERAND (*expr_p, 1) = ctor;\n-\t      return GS_OK;\n-\t    }\n-\t}\n-      return GS_UNHANDLED;\n-\n-    default:\n-      return GS_UNHANDLED;\n-    }\n+  /* This is handled mostly by gimplify.c, but we have to deal with\n+     not warning about int x = x; as it is a GCC extension to turn off\n+     this warning but only if warn_init_self is zero.  */\n+  if (code == DECL_EXPR\n+      && TREE_CODE (DECL_EXPR_DECL (*expr_p)) == VAR_DECL\n+      && !DECL_EXTERNAL (DECL_EXPR_DECL (*expr_p))\n+      && !TREE_STATIC (DECL_EXPR_DECL (*expr_p))\n+      && (DECL_INITIAL (DECL_EXPR_DECL (*expr_p)) == DECL_EXPR_DECL (*expr_p))\n+      && !warn_init_self)\n+    TREE_NO_WARNING (DECL_EXPR_DECL (*expr_p)) = 1;\n+\n+  return GS_UNHANDLED;\n }"}, {"sha": "6ef98febfb5b19a73cfc562dd42fca661a4af746", "filename": "gcc/c-objc-common.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -43,16 +43,12 @@ extern void c_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_POST_OPTIONS c_common_post_options\n #undef LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET c_common_get_alias_set\n-#undef LANG_HOOKS_EXPAND_EXPR\n-#define LANG_HOOKS_EXPAND_EXPR c_expand_expr\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE c_mark_addressable\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE c_common_parse_file\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL c_finish_incomplete_decl\n-#undef LANG_HOOKS_STATICP\n-#define LANG_HOOKS_STATICP c_staticp\n #undef LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL c_warn_unused_global_decl\n #undef LANG_HOOKS_PRINT_IDENTIFIER"}, {"sha": "3c7b241b999b75edf74704065193993708d6c270", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -1,6 +1,4 @@\n-/* This file contains the definitions and documentation for the common\n-   tree codes used in the GNU C and C++ compilers (see c-common.def\n-   for the standard codes).\n+/* This file contains subroutine used by the C front-end to construct GENERIC.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Written by Benjamin Chelf (chelf@codesourcery.com).\n@@ -145,23 +143,6 @@ build_stmt (enum tree_code code, ...)\n   return ret;\n }\n \n-/* Let the back-end know about DECL.  */\n-\n-void\n-emit_local_var (tree decl)\n-{\n-  /* Create RTL for this variable.  */\n-  if (!DECL_RTL_SET_P (decl))\n-    {\n-      if (DECL_HARD_REGISTER (decl))\n-\t/* The user specified an assembler name for this variable.\n-\t   Set that up now.  */\n-\trest_of_decl_compilation (decl, 0, 0);\n-      else\n-\texpand_decl (decl);\n-    }\n-}\n-\n /* Create a CASE_LABEL_EXPR tree node and return it.  */\n \n tree"}, {"sha": "5bcd13e1c7d064d4f84da477127c0dee3609861c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -1,3 +1,9 @@\n+2009-03-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* cp/cp-objcp-common.h (LANG_HOOKS_STATICP): Remove.\n+\t* cp/cp-objcp-common.c (cxx_staticp): Remove.\n+\t* cp/cp-tree.h (cxx_staticp): Remove.\n+\n 2009-03-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/39554"}, {"sha": "2363cd7abdbe747a85abd0b69d7b4b894d7b68a2", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -188,21 +188,6 @@ cxx_types_compatible_p (tree x, tree y)\n   return same_type_ignoring_top_level_qualifiers_p (x, y);\n }\n \n-tree\n-cxx_staticp (tree arg)\n-{\n-  switch (TREE_CODE (arg))\n-    {\n-    case BASELINK:\n-      return staticp (BASELINK_FUNCTIONS (arg));\n-\n-    default:\n-      break;\n-    }\n-  \n-  return NULL_TREE;\n-}\n-\n /* Return true if DECL is explicit member function.  */\n \n bool"}, {"sha": "1ce9d36a6529da18fae80cdb425500f41b9b173d", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -52,12 +52,8 @@ extern bool cp_function_decl_explicit_p (tree decl);\n #define LANG_HOOKS_POST_OPTIONS c_common_post_options\n #undef LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET cxx_get_alias_set\n-#undef LANG_HOOKS_EXPAND_EXPR\n-#define LANG_HOOKS_EXPAND_EXPR c_expand_expr\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE c_common_parse_file\n-#undef LANG_HOOKS_STATICP\n-#define LANG_HOOKS_STATICP cxx_staticp\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL cxx_dup_lang_specific_decl\n #undef LANG_HOOKS_SET_DECL_ASSEMBLER_NAME"}, {"sha": "a4871e90f157f734b9418f8c6bb00ffec246514c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -5053,7 +5053,6 @@ extern bool cp_var_mod_type_p\t\t\t(tree, tree);\n extern void cxx_initialize_diagnostics\t\t(struct diagnostic_context *);\n extern int cxx_types_compatible_p\t\t(tree, tree);\n extern void init_shadowed_var_for_decl\t\t(void);\n-extern tree cxx_staticp                         (tree);\n \n /* in cp-gimplify.c */\n extern int cp_gimplify_expr\t\t\t(tree *, gimple_seq *,"}, {"sha": "0039228f18bf907e2e15100788eef5959550f055", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -2636,10 +2636,10 @@ declaration order.  You should not assume that all fields will be\n represented.  Unrepresented fields will be set to zero.\n \n @item COMPOUND_LITERAL_EXPR\n-@findex COMPOUND_LITERAL_EXPR_DECL_STMT\n+@findex COMPOUND_LITERAL_EXPR_DECL_EXPR\n @findex COMPOUND_LITERAL_EXPR_DECL\n These nodes represent ISO C99 compound literals.  The\n-@code{COMPOUND_LITERAL_EXPR_DECL_STMT} is a @code{DECL_STMT}\n+@code{COMPOUND_LITERAL_EXPR_DECL_EXPR} is a @code{DECL_EXPR}\n containing an anonymous @code{VAR_DECL} for\n the unnamed object represented by the compound literal; the\n @code{DECL_INITIAL} of that @code{VAR_DECL} is a @code{CONSTRUCTOR}"}, {"sha": "11c2a477b84ca619e11040b0be9fe4cfd086dede", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -248,7 +248,7 @@ expr_size (tree exp)\n     {\n       size = lang_hooks.expr_size (exp);\n       gcc_assert (size);\n-      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, exp);\n+      gcc_assert (size == SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, exp));\n     }\n \n   return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype), EXPAND_NORMAL);"}, {"sha": "ff3867e59ecc4813970408701c8d622080dc44f0", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -6821,9 +6821,10 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \t CONSTRUCTORs too, which should yield a memory reference for the\n \t constructor's contents.  Assume language specific tree nodes can\n \t be expanded in some interesting way.  */\n+      gcc_assert (TREE_CODE (exp) < LAST_AND_UNUSED_TREE_CODE);\n       if (DECL_P (exp)\n \t  || TREE_CODE (exp) == CONSTRUCTOR\n-\t  || TREE_CODE (exp) >= LAST_AND_UNUSED_TREE_CODE)\n+\t  || TREE_CODE (exp) == COMPOUND_LITERAL_EXPR)\n \t{\n \t  result = expand_expr (exp, target, tmode,\n \t\t\t\tmodifier == EXPAND_INITIALIZER\n@@ -8069,11 +8070,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t/* Check for a built-in function.  */\n \tif (fndecl && DECL_BUILT_IN (fndecl))\n \t  {\n-\t    if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_FRONTEND)\n-\t      return lang_hooks.expand_expr (exp, original_target,\n-\t\t\t\t\t     tmode, modifier, alt_rtl);\n-\t    else\n-\t      return expand_builtin (exp, target, subtarget, tmode, ignore);\n+\t    gcc_assert (DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_FRONTEND);\n+\t    return expand_builtin (exp, target, subtarget, tmode, ignore);\n \t  }\n       }\n       return expand_call (exp, target, ignore);\n@@ -9460,9 +9458,29 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       goto binop;\n \n+    case COMPOUND_LITERAL_EXPR:\n+      {\n+\t/* Initialize the anonymous variable declared in the compound\n+\t   literal, then return the variable.  */\n+\ttree decl = COMPOUND_LITERAL_EXPR_DECL (exp);\n+\n+\t/* Create RTL for this variable.  */\n+\tif (!DECL_RTL_SET_P (decl))\n+\t  {\n+\t    if (DECL_HARD_REGISTER (decl))\n+\t      /* The user specified an assembler name for this variable.\n+\t         Set that up now.  */\n+\t      rest_of_decl_compilation (decl, 0, 0);\n+\t    else\n+\t      expand_decl (decl);\n+\t  }\n+\n+\treturn expand_expr_real (decl, original_target, tmode,\n+\t\t\t\t modifier, alt_rtl);\n+      }\n+\n     default:\n-      return lang_hooks.expand_expr (exp, original_target, tmode,\n-\t\t\t\t     modifier, alt_rtl);\n+      gcc_unreachable ();\n     }\n \n   /* Here to do an ordinary binary operator.  */"}, {"sha": "bd82051d158951754764ef441dc3a41e696cc86a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 104, "deletions": 2, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -3456,6 +3456,83 @@ rhs_predicate_for (tree lhs)\n     return is_gimple_mem_or_call_rhs;\n }\n \n+/* Gimplify a C99 compound literal expression.  This just means adding\n+   the DECL_EXPR before the current statement and using its anonymous\n+   decl instead.  */\n+\n+static enum gimplify_status\n+gimplify_compound_literal_expr (tree *expr_p, gimple_seq *pre_p)\n+{\n+  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_EXPR (*expr_p);\n+  tree decl = DECL_EXPR_DECL (decl_s);\n+  /* Mark the decl as addressable if the compound literal\n+     expression is addressable now, otherwise it is marked too late\n+     after we gimplify the initialization expression.  */\n+  if (TREE_ADDRESSABLE (*expr_p))\n+    TREE_ADDRESSABLE (decl) = 1;\n+\n+  /* Preliminarily mark non-addressed complex variables as eligible\n+     for promotion to gimple registers.  We'll transform their uses\n+     as we find them.  */\n+  if ((TREE_CODE (TREE_TYPE (decl)) == COMPLEX_TYPE\n+       || TREE_CODE (TREE_TYPE (decl)) == VECTOR_TYPE)\n+      && !TREE_THIS_VOLATILE (decl)\n+      && !needs_to_live_in_memory (decl))\n+    DECL_GIMPLE_REG_P (decl) = 1;\n+\n+  /* This decl isn't mentioned in the enclosing block, so add it to the\n+     list of temps.  FIXME it seems a bit of a kludge to say that\n+     anonymous artificial vars aren't pushed, but everything else is.  */\n+  if (DECL_NAME (decl) == NULL_TREE && !DECL_SEEN_IN_BIND_EXPR_P (decl))\n+    gimple_add_tmp_var (decl);\n+\n+  gimplify_and_add (decl_s, pre_p);\n+  *expr_p = decl;\n+  return GS_OK;\n+}\n+\n+/* Optimize embedded COMPOUND_LITERAL_EXPRs within a CONSTRUCTOR,\n+   return a new CONSTRUCTOR if something changed.  */\n+\n+static tree\n+optimize_compound_literals_in_ctor (tree orig_ctor)\n+{\n+  tree ctor = orig_ctor;\n+  VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (ctor);\n+  unsigned int idx, num = VEC_length (constructor_elt, elts);\n+\n+  for (idx = 0; idx < num; idx++)\n+    {\n+      tree value = VEC_index (constructor_elt, elts, idx)->value;\n+      tree newval = value;\n+      if (TREE_CODE (value) == CONSTRUCTOR)\n+\tnewval = optimize_compound_literals_in_ctor (value);\n+      else if (TREE_CODE (value) == COMPOUND_LITERAL_EXPR)\n+\t{\n+\t  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_EXPR (value);\n+\t  tree decl = DECL_EXPR_DECL (decl_s);\n+\t  tree init = DECL_INITIAL (decl);\n+\n+\t  if (!TREE_ADDRESSABLE (value)\n+\t      && !TREE_ADDRESSABLE (decl)\n+\t      && init)\n+\t    newval = optimize_compound_literals_in_ctor (init);\n+\t}\n+      if (newval == value)\n+\tcontinue;\n+\n+      if (ctor == orig_ctor)\n+\t{\n+\t  ctor = copy_node (orig_ctor);\n+\t  CONSTRUCTOR_ELTS (ctor) = VEC_copy (constructor_elt, gc, elts);\n+\t  elts = CONSTRUCTOR_ELTS (ctor);\n+\t}\n+      VEC_index (constructor_elt, elts, idx)->value = newval;\n+    }\n+  return ctor;\n+}\n+\n+\n \n /* A subroutine of gimplify_modify_expr.  Break out elements of a\n    CONSTRUCTOR used as an initializer into separate MODIFY_EXPRs.\n@@ -3474,7 +3551,7 @@ static enum gimplify_status\n gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t\t   bool want_value, bool notify_temp_creation)\n {\n-  tree object;\n+  tree object, new_ctor;\n   tree ctor = TREE_OPERAND (*expr_p, 1);\n   tree type = TREE_TYPE (ctor);\n   enum gimplify_status ret;\n@@ -3492,7 +3569,8 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     }\n \n   object = TREE_OPERAND (*expr_p, 0);\n-  elts = CONSTRUCTOR_ELTS (ctor);\n+  new_ctor = optimize_compound_literals_in_ctor (ctor);\n+  elts = CONSTRUCTOR_ELTS (new_ctor);\n   ret = GS_ALL_DONE;\n \n   switch (TREE_CODE (type))\n@@ -4099,6 +4177,26 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \t  return GS_OK;\n \t}\n \t\n+      case COMPOUND_LITERAL_EXPR:\n+\t{\n+\t  tree complit = TREE_OPERAND (*expr_p, 1);\n+\t  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_EXPR (complit);\n+\t  tree decl = DECL_EXPR_DECL (decl_s);\n+\t  tree init = DECL_INITIAL (decl);\n+\n+\t  /* struct T x = (struct T) { 0, 1, 2 } can be optimized\n+\t     into struct T x = { 0, 1, 2 } if the address of the\n+\t     compound literal has never been taken.  */\n+\t  if (!TREE_ADDRESSABLE (complit)\n+\t      && !TREE_ADDRESSABLE (decl)\n+\t      && init)\n+\t    {\n+\t      *expr_p = copy_node (*expr_p);\n+\t      TREE_OPERAND (*expr_p, 1) = init;\n+\t      return GS_OK;\n+\t    }\n+\t}\n+\n       default:\n \tret = GS_UNHANDLED;\n \tbreak;\n@@ -6361,6 +6459,10 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = gimplify_compound_expr (expr_p, pre_p, fallback != fb_none);\n \t  break;\n \n+\tcase COMPOUND_LITERAL_EXPR:\n+\t  ret = gimplify_compound_literal_expr (expr_p, pre_p);\n+\t  break;\n+\n \tcase MODIFY_EXPR:\n \tcase INIT_EXPR:\n \t  ret = gimplify_modify_expr (expr_p, pre_p, post_p,"}, {"sha": "4b6ce274c00f3b07c1a1320a1884b21791d09b15", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -46,12 +46,10 @@ extern tree lhd_return_null_tree_v (void);\n extern tree lhd_return_null_tree (tree);\n extern tree lhd_return_null_const_tree (const_tree);\n extern tree lhd_do_nothing_iii_return_null_tree (int, int, int);\n-extern tree lhd_staticp (tree);\n extern void lhd_print_tree_nothing (FILE *, tree, int);\n extern const char *lhd_decl_printable_name (tree, int);\n extern const char *lhd_dwarf_name (tree, int);\n extern int lhd_types_compatible_p (tree, tree);\n-extern rtx lhd_expand_expr (tree, rtx, enum machine_mode, int, rtx *);\n extern void lhd_print_error_function (struct diagnostic_context *,\n \t\t\t\t      const char *, struct diagnostic_info *);\n extern void lhd_set_decl_assembler_name (tree);\n@@ -92,9 +90,7 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n #define LANG_HOOKS_POST_OPTIONS\t\tlhd_post_options\n #define LANG_HOOKS_MISSING_NORETURN_OK_P hook_bool_tree_true\n #define LANG_HOOKS_GET_ALIAS_SET\tlhd_get_alias_set\n-#define LANG_HOOKS_EXPAND_EXPR\t\tlhd_expand_expr\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL lhd_do_nothing_t\n-#define LANG_HOOKS_STATICP\t\tlhd_staticp\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n #define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n@@ -241,10 +237,8 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_PARSE_FILE, \\\n   LANG_HOOKS_MISSING_NORETURN_OK_P, \\\n   LANG_HOOKS_GET_ALIAS_SET, \\\n-  LANG_HOOKS_EXPAND_EXPR, \\\n   LANG_HOOKS_FINISH_INCOMPLETE_DECL, \\\n   LANG_HOOKS_MARK_ADDRESSABLE, \\\n-  LANG_HOOKS_STATICP, \\\n   LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\\n   LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n   LANG_HOOKS_PRINT_STATISTICS, \\"}, {"sha": "bd01c3fb95ab876e0b163fde3139a4d0ee9afc01", "filename": "gcc/langhooks.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -117,14 +117,6 @@ lhd_print_tree_nothing (FILE * ARG_UNUSED (file),\n {\n }\n \n-/* Called from staticp.  */\n-\n-tree\n-lhd_staticp (tree ARG_UNUSED (exp))\n-{\n-  return NULL;\n-}\n-\n /* Called from check_global_declarations.  */\n \n bool\n@@ -216,17 +208,6 @@ lhd_get_alias_set (tree ARG_UNUSED (t))\n   return -1;\n }\n \n-/* This is the default expand_expr function.  */\n-\n-rtx\n-lhd_expand_expr (tree ARG_UNUSED (t), rtx ARG_UNUSED (r),\n-\t\t enum machine_mode ARG_UNUSED (mm),\n-\t\t int ARG_UNUSED (em),\n-\t\t rtx * ARG_UNUSED (a))\n-{\n-  gcc_unreachable ();\n-}\n-\n /* This is the default decl_printable_name function.  */\n \n const char *"}, {"sha": "6c57ca2599e8ea417a2eb042a90a2b7b49bf787e", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -293,10 +293,6 @@ struct lang_hooks\n      Returns -1 if the language does nothing special for it.  */\n   alias_set_type (*get_alias_set) (tree);\n \n-  /* Called by expand_expr for language-specific tree codes.\n-     Fourth argument is actually an enum expand_modifier.  */\n-  rtx (*expand_expr) (tree, rtx, enum machine_mode, int, rtx *);\n-\n   /* Function to finish handling an incomplete decl at the end of\n      compilation.  Default hook is does nothing.  */\n   void (*finish_incomplete_decl) (tree);\n@@ -306,9 +302,6 @@ struct lang_hooks\n      successful.  */\n   bool (*mark_addressable) (tree);\n \n-  /* Hook called by staticp for language-specific tree codes.  */\n-  tree (*staticp) (tree);\n-\n   /* Replace the DECL_LANG_SPECIFIC data, which may be NULL, of the\n      DECL_NODE with a newly GC-allocated copy.  */\n   void (*dup_lang_specific_decl) (tree);"}, {"sha": "9a6e00029408b24b60c6f9fa9dcca5410757dff4", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -2098,8 +2098,7 @@ staticp (tree arg)\n     case COMPONENT_REF:\n       /* If the thing being referenced is not a field, then it is\n \t something language specific.  */\n-      if (TREE_CODE (TREE_OPERAND (arg, 1)) != FIELD_DECL)\n-\treturn (*lang_hooks.staticp) (arg);\n+      gcc_assert (TREE_CODE (TREE_OPERAND (arg, 1)) == FIELD_DECL);\n \n       /* If we are referencing a bitfield, we can't evaluate an\n \t ADDR_EXPR at compile time and so it isn't a constant.  */\n@@ -2122,14 +2121,13 @@ staticp (tree arg)\n \t  && TREE_CODE (TREE_OPERAND (arg, 1)) == INTEGER_CST)\n \treturn staticp (TREE_OPERAND (arg, 0));\n       else\n-\treturn false;\n+\treturn NULL;\n+\n+    case COMPOUND_LITERAL_EXPR:\n+      return TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (arg)) ? arg : NULL;\n \n     default:\n-      if ((unsigned int) TREE_CODE (arg)\n-\t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE)\n-\treturn lang_hooks.staticp (arg);\n-      else\n-\treturn NULL;\n+      return NULL;\n     }\n }\n "}, {"sha": "21f4db02d1fe96d79a7604a52e91b75e10225236", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -786,6 +786,13 @@ DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", tcc_unary, 1)\n    generating insns.  */\n DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", tcc_reference, 1)\n \n+/* A COMPOUND_LITERAL_EXPR represents a literal that is placed in a DECL.  The\n+   COMPOUND_LITERAL_EXPR_DECL_EXPR is the a DECL_EXPR containing the decl\n+   for the anonymous object represented by the COMPOUND_LITERAL;\n+   the DECL_INITIAL of that decl is the CONSTRUCTOR that initializes\n+   the compound literal.  */\n+DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", tcc_expression, 1)\n+\n /* Represents something we computed once and will use multiple times.\n    First operand is that expression.  After it is evaluated once, it\n    will be replaced by the temporary variable that holds the value.  */"}, {"sha": "0eb2dc6449b02b1fa4040e349977f3f13729d81b", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2ec5deb5c3146cdaf0119ebf7f37df6e57f1521d", "patch": "@@ -1590,6 +1590,12 @@ extern void protected_set_expr_location (tree, location_t);\n \n #define EXIT_EXPR_COND(NODE)\t     TREE_OPERAND (EXIT_EXPR_CHECK (NODE), 0)\n \n+/* COMPOUND_LITERAL_EXPR accessors.  */\n+#define COMPOUND_LITERAL_EXPR_DECL_EXPR(NODE)\t\t\\\n+  TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)\n+#define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n+  DECL_EXPR_DECL (COMPOUND_LITERAL_EXPR_DECL_EXPR (NODE))\n+\n /* SWITCH_EXPR accessors. These give access to the condition, body and\n    original condition type (before any compiler conversions)\n    of the switch statement, respectively.  */"}]}