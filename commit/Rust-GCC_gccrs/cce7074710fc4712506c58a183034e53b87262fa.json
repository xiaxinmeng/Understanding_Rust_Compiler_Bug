{"sha": "cce7074710fc4712506c58a183034e53b87262fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlNzA3NDcxMGZjNDcxMjUwNmM1OGExODMwMzRlNTNiODcyNjJmYQ==", "commit": {"author": {"name": "Josh Conner", "email": "jconner@apple.com", "date": "2005-06-01T21:34:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-01T21:34:27Z"}, "message": "re PR middle-end/21478 (Improve initialization of sparse local arrays)\n\n        PR 21478\n        * gimplify.c (gimplify_init_constructor): Don't spill initializer\n        to read-only memory if it's sparse.\n\nFrom-SVN: r100465", "tree": {"sha": "4cd171969e80360cd12c1c99748d1ceb8a5c5763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cd171969e80360cd12c1c99748d1ceb8a5c5763"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cce7074710fc4712506c58a183034e53b87262fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce7074710fc4712506c58a183034e53b87262fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce7074710fc4712506c58a183034e53b87262fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce7074710fc4712506c58a183034e53b87262fa/comments", "author": null, "committer": null, "parents": [{"sha": "03569a404774d982edf655c0bc8a3616ed3d1f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03569a404774d982edf655c0bc8a3616ed3d1f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03569a404774d982edf655c0bc8a3616ed3d1f3c"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "1531a27861718b850acfbac445da140ad73a9ff6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce7074710fc4712506c58a183034e53b87262fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce7074710fc4712506c58a183034e53b87262fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cce7074710fc4712506c58a183034e53b87262fa", "patch": "@@ -1,3 +1,9 @@\n+2005-06-01  Josh Conner <jconner@apple.com>\n+\n+\tPR 21478\n+\t* gimplify.c (gimplify_init_constructor): Don't spill initializer\n+\tto read-only memory if it's sparse.\n+\n 2005-06-01  Ramana Radhakrishnan  <ramana@codito.com>\n \n \t* doc/rtl.texi: Remove references to NOTE_INSN_SETJMP. "}, {"sha": "a659e77bb8362a94291c727aa28a2e6a4162aed3", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce7074710fc4712506c58a183034e53b87262fa/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce7074710fc4712506c58a183034e53b87262fa/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=cce7074710fc4712506c58a183034e53b87262fa", "patch": "@@ -2649,10 +2649,35 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    break;\n \t  }\n \n+\t/* If there are \"lots\" of initialized elements, even discounting\n+\t   those that are not address constants (and thus *must* be\n+\t   computed at runtime), then partition the constructor into\n+\t   constant and non-constant parts.  Block copy the constant\n+\t   parts in, then generate code for the non-constant parts.  */\n+\t/* TODO.  There's code in cp/typeck.c to do this.  */\n+\n+\tnum_type_elements = count_type_elements (TREE_TYPE (ctor));\n+\n+\t/* If there are \"lots\" of zeros, then block clear the object first.  */\n+\tif (num_type_elements - num_nonzero_elements > CLEAR_RATIO\n+\t    && num_nonzero_elements < num_type_elements/4)\n+\t  cleared = true;\n+\n+\t/* ??? This bit ought not be needed.  For any element not present\n+\t   in the initializer, we should simply set them to zero.  Except\n+\t   we'd need to *find* the elements that are not present, and that\n+\t   requires trickery to avoid quadratic compile-time behavior in\n+\t   large cases or excessive memory use in small cases.  */\n+\telse if (num_ctor_elements < num_type_elements)\n+\t  cleared = true;\n+\n \t/* If there are \"lots\" of initialized elements, and all of them\n \t   are valid address constants, then the entire initializer can\n-\t   be dropped to memory, and then memcpy'd out.  */\n-\tif (num_nonconstant_elements == 0)\n+\t   be dropped to memory, and then memcpy'd out.  Don't do this\n+\t   for sparse arrays, though, as it's more efficient to follow\n+\t   the standard CONSTRUCTOR behavior of memset followed by\n+\t   individual element initialization.  */\n+\tif (num_nonconstant_elements == 0 && !cleared)\n \t  {\n \t    HOST_WIDE_INT size = int_size_in_bytes (type);\n \t    unsigned int align;\n@@ -2698,28 +2723,6 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t      }\n \t  }\n \n-\t/* If there are \"lots\" of initialized elements, even discounting\n-\t   those that are not address constants (and thus *must* be\n-\t   computed at runtime), then partition the constructor into\n-\t   constant and non-constant parts.  Block copy the constant\n-\t   parts in, then generate code for the non-constant parts.  */\n-\t/* TODO.  There's code in cp/typeck.c to do this.  */\n-\n-\tnum_type_elements = count_type_elements (TREE_TYPE (ctor));\n-\n-\t/* If there are \"lots\" of zeros, then block clear the object first.  */\n-\tif (num_type_elements - num_nonzero_elements > CLEAR_RATIO\n-\t    && num_nonzero_elements < num_type_elements/4)\n-\t  cleared = true;\n-\n-\t/* ??? This bit ought not be needed.  For any element not present\n-\t   in the initializer, we should simply set them to zero.  Except\n-\t   we'd need to *find* the elements that are not present, and that\n-\t   requires trickery to avoid quadratic compile-time behavior in\n-\t   large cases or excessive memory use in small cases.  */\n-\telse if (num_ctor_elements < num_type_elements)\n-\t  cleared = true;\n-\n \tif (cleared)\n \t  {\n \t    /* Zap the CONSTRUCTOR element list, which simplifies this case."}]}