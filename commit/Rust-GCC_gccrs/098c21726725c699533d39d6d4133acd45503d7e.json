{"sha": "098c21726725c699533d39d6d4133acd45503d7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk4YzIxNzI2NzI1YzY5OTUzM2QzOWQ2ZDQxMzNhY2Q0NTUwM2Q3ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-08-16T20:58:26Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-08-16T20:58:26Z"}, "message": "runtime: better implementation of netpoll for AIX\n    \n    Reviewed-on: https://go-review.googlesource.com/54170\n\nFrom-SVN: r251133", "tree": {"sha": "cc34bf64f3bee80c10d284a97cc18426ee21de3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc34bf64f3bee80c10d284a97cc18426ee21de3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/098c21726725c699533d39d6d4133acd45503d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/098c21726725c699533d39d6d4133acd45503d7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/098c21726725c699533d39d6d4133acd45503d7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/098c21726725c699533d39d6d4133acd45503d7e/comments", "author": null, "committer": null, "parents": [{"sha": "8cca6c95d2b196afbb85f69c0798f3061169fb12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cca6c95d2b196afbb85f69c0798f3061169fb12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cca6c95d2b196afbb85f69c0798f3061169fb12"}], "stats": {"total": 163, "additions": 97, "deletions": 66}, "files": [{"sha": "3490c562fcc4127370d8c095a74f026db56f358a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/098c21726725c699533d39d6d4133acd45503d7e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/098c21726725c699533d39d6d4133acd45503d7e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=098c21726725c699533d39d6d4133acd45503d7e", "patch": "@@ -1,4 +1,4 @@\n-f02183eb66f5718769f3f6541dcc6744ae1771c0\n+152164a7249ecc5c2bfd4a091450dc7c2855f609\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8c8e1882219f2cb87aac7ca561b932791aeb5c5a", "filename": "libgo/go/runtime/netpoll_aix.go", "status": "modified", "additions": 96, "deletions": 65, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/098c21726725c699533d39d6d4133acd45503d7e/libgo%2Fgo%2Fruntime%2Fnetpoll_aix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/098c21726725c699533d39d6d4133acd45503d7e/libgo%2Fgo%2Fruntime%2Fnetpoll_aix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_aix.go?ref=098c21726725c699533d39d6d4133acd45503d7e", "patch": "@@ -7,10 +7,10 @@ package runtime\n import \"unsafe\"\n \n // This is based on the former libgo/runtime/netpoll_select.c implementation\n-// except that it uses poll instead of select and is written in Go.\n+// except that it uses AIX pollset_poll instead of select and is written in Go.\n+\n+type pollset_t int32\n \n-// These definitions should come from sysinfo.go as they may be OS-dependent.\n-// These are the definitions for the AIX operating system.\n type pollfd struct {\n \tfd      int32\n \tevents  int16\n@@ -22,69 +22,124 @@ const _POLLOUT = 0x0002\n const _POLLHUP = 0x2000\n const _POLLERR = 0x4000\n \n-//extern poll\n-func libc_poll(pfds *pollfd, npfds uintptr, timeout uintptr) int32\n+type poll_ctl struct {\n+\tcmd    int16\n+\tevents int16\n+\tfd     int32\n+}\n+\n+const _PS_ADD = 0x0\n+const _PS_DELETE = 0x2\n+\n+//extern pollset_create\n+func pollset_create(maxfd int32) pollset_t\n+\n+//extern pollset_ctl\n+func pollset_ctl(ps pollset_t, pollctl_array *poll_ctl, array_length int32) int32\n+\n+//extern pollset_poll\n+func pollset_poll(ps pollset_t, polldata_array *pollfd, array_length int32, timeout int32) int32\n \n //extern pipe\n func libc_pipe(fd *int32) int32\n \n //extern __go_fcntl_uintptr\n func fcntlUintptr(fd, cmd, arg uintptr) (uintptr, uintptr)\n \n-func closeonexec(fd int32) {\n-\tfcntlUintptr(uintptr(fd), _F_SETFD, _FD_CLOEXEC)\n+func fcntl(fd, cmd int32, arg uintptr) uintptr {\n+\tr, _ := fcntlUintptr(uintptr(fd), uintptr(cmd), arg)\n+\treturn r\n }\n \n var (\n-\tallocated int\n-\tpfds      []pollfd\n-\tmpfds     map[uintptr]*pollDesc\n-\tpmtx      mutex\n-\trdwake    int32\n-\twrwake    int32\n+\tps          pollset_t = -1\n+\tmpfds       map[int32]*pollDesc\n+\tpmtx        mutex\n+\trdwake      int32\n+\twrwake      int32\n+\tneedsUpdate bool\n )\n \n func netpollinit() {\n \tvar p [2]int32\n \n-\t// Create the pipe we use to wakeup poll.\n+\tif ps = pollset_create(-1); ps < 0 {\n+\t\tthrow(\"netpollinit: failed to create pollset\")\n+\t}\n+\t// It is not possible to add or remove descriptors from\n+\t// the pollset while pollset_poll is active.\n+\t// We use a pipe to wakeup pollset_poll when the pollset\n+\t// needs to be updated.\n \tif err := libc_pipe(&p[0]); err < 0 {\n \t\tthrow(\"netpollinit: failed to create pipe\")\n \t}\n \trdwake = p[0]\n \twrwake = p[1]\n \n-\tcloseonexec(rdwake)\n-\tcloseonexec(wrwake)\n-\n-\t// Pre-allocate array of pollfd structures for poll.\n-\tallocated = 128\n-\tpfds = make([]pollfd, allocated)\n+\tfl := fcntl(rdwake, _F_GETFL, 0)\n+\tfcntl(rdwake, _F_SETFL, fl|_O_NONBLOCK)\n+\tfcntl(rdwake, _F_SETFD, _FD_CLOEXEC)\n+\n+\tfl = fcntl(wrwake, _F_GETFL, 0)\n+\tfcntl(wrwake, _F_SETFL, fl|_O_NONBLOCK)\n+\tfcntl(wrwake, _F_SETFD, _FD_CLOEXEC)\n+\n+\t// Add the read side of the pipe to the pollset.\n+\tvar pctl poll_ctl\n+\tpctl.cmd = _PS_ADD\n+\tpctl.fd = rdwake\n+\tpctl.events = _POLLIN\n+\tif pollset_ctl(ps, &pctl, 1) != 0 {\n+\t\tthrow(\"netpollinit: failed to register pipe\")\n+\t}\n \n-\tmpfds = make(map[uintptr]*pollDesc)\n+\tmpfds = make(map[int32]*pollDesc)\n }\n \n func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\t// pollset_ctl will block if pollset_poll is active\n+\t// so wakeup pollset_poll first.\n \tlock(&pmtx)\n-\tmpfds[fd] = pd\n+\tneedsUpdate = true\n \tunlock(&pmtx)\n-\n-\t// Wakeup poll.\n \tb := [1]byte{0}\n \twrite(uintptr(wrwake), unsafe.Pointer(&b[0]), 1)\n \n+\tvar pctl poll_ctl\n+\tpctl.cmd = _PS_ADD\n+\tpctl.fd = int32(fd)\n+\tpctl.events = _POLLIN | _POLLOUT\n+\tif pollset_ctl(ps, &pctl, 1) != 0 {\n+\t\treturn int32(errno())\n+\t}\n+\tlock(&pmtx)\n+\tmpfds[int32(fd)] = pd\n+\tneedsUpdate = false\n+\tunlock(&pmtx)\n+\n \treturn 0\n }\n \n func netpollclose(fd uintptr) int32 {\n+\t// pollset_ctl will block if pollset_poll is active\n+\t// so wakeup pollset_poll first.\n \tlock(&pmtx)\n-\tdelete(mpfds, fd)\n+\tneedsUpdate = true\n \tunlock(&pmtx)\n-\n-\t// Wakeup poll.\n \tb := [1]byte{0}\n \twrite(uintptr(wrwake), unsafe.Pointer(&b[0]), 1)\n \n+\tvar pctl poll_ctl\n+\tpctl.cmd = _PS_DELETE\n+\tpctl.fd = int32(fd)\n+\tif pollset_ctl(ps, &pctl, 1) != 0 {\n+\t\treturn int32(errno())\n+\t}\n+\tlock(&pmtx)\n+\tdelete(mpfds, int32(fd))\n+\tneedsUpdate = false\n+\tunlock(&pmtx)\n+\n \treturn 0\n }\n \n@@ -93,62 +148,39 @@ func netpollarm(pd *pollDesc, mode int) {\n }\n \n func netpoll(block bool) *g {\n-\tif allocated == 0 {\n+\tif ps == -1 {\n \t\treturn nil\n \t}\n-\ttimeout := ^uintptr(0)\n+\ttimeout := int32(-1)\n \tif !block {\n \t\ttimeout = 0\n \t}\n+\tvar pfds [128]pollfd\n retry:\n \tlock(&pmtx)\n-\tnpfds := len(mpfds) + 1\n-\tunlock(&pmtx)\n-\n-\tif npfds > allocated {\n-\t\tfor npfds > allocated {\n-\t\t\tallocated *= 2\n-\t\t}\n-\t\tpfds = make([]pollfd, allocated)\n-\t}\n-\n-\t// Poll the read side of the pipe.\n-\tpfds[0].fd = rdwake\n-\tpfds[0].events = _POLLIN\n-\tlock(&pmtx)\n-\t// Notice that npfds may have changed since we released the lock.\n-\t// Just copy what we can, new descriptors will be added at next\n-\t// iteration.\n-\ti := 1\n-\tfor fd := range mpfds {\n-\t\tif i >= allocated {\n-\t\t\tbreak\n-\t\t}\n-\t\tpfds[i].fd = int32(fd)\n-\t\tpfds[i].events = _POLLIN | _POLLOUT\n-\t\ti++\n+\tif needsUpdate {\n+\t\tunlock(&pmtx)\n+\t\tosyield()\n+\t\tgoto retry\n \t}\n-\tnpfds = i\n \tunlock(&pmtx)\n-\n-\tn := libc_poll(&pfds[0], uintptr(npfds), timeout)\n-\tif n < 0 {\n+\tnfound := pollset_poll(ps, &pfds[0], int32(len(pfds)), timeout)\n+\tif nfound < 0 {\n \t\te := errno()\n \t\tif e != _EINTR {\n-\t\t\tthrow(\"poll failed\")\n+\t\t\tthrow(\"pollset_poll failed\")\n \t\t}\n \t\tgoto retry\n \t}\n \tvar gp guintptr\n-\tfor i = 0; i < npfds && n > 0; i++ {\n-\t\tpfd := pfds[i]\n+\tfor i := int32(0); i < nfound; i++ {\n+\t\tpfd := &pfds[i]\n \n \t\tvar mode int32\n \t\tif pfd.revents&(_POLLIN|_POLLHUP|_POLLERR) != 0 {\n-\t\t\tif i == 0 {\n+\t\t\tif pfd.fd == rdwake {\n \t\t\t\tvar b [1]byte\n \t\t\t\tread(pfd.fd, unsafe.Pointer(&b[0]), 1)\n-\t\t\t\tn--\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tmode += 'r'\n@@ -158,12 +190,11 @@ retry:\n \t\t}\n \t\tif mode != 0 {\n \t\t\tlock(&pmtx)\n-\t\t\tpd := mpfds[uintptr(pfd.fd)]\n+\t\t\tpd := mpfds[pfd.fd]\n \t\t\tunlock(&pmtx)\n \t\t\tif pd != nil {\n \t\t\t\tnetpollready(&gp, pd, mode)\n \t\t\t}\n-\t\t\tn--\n \t\t}\n \t}\n \tif block && gp == 0 {"}]}