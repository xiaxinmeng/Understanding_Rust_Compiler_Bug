{"sha": "dd7a40e14c20495d719ad715de00cff5c490fd07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ3YTQwZTE0YzIwNDk1ZDcxOWFkNzE1ZGUwMGNmZjVjNDkwZmQwNw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-07-23T21:19:03Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-07-23T21:19:03Z"}, "message": "vector.md (xor<mode>3): Move 128-bit boolean expanders to rs6000.md.\n\n[gcc]\n2013-07-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vector.md (xor<mode>3): Move 128-bit boolean\n\texpanders to rs6000.md.\n\t(ior<mode>3): Likewise.\n\t(and<mode>3): Likewise.\n\t(one_cmpl<mode>2): Likewise.\n\t(nor<mode>3): Likewise.\n\t(andc<mode>3): Likewise.\n\t(eqv<mode>3): Likewise.\n\t(nand<mode>3): Likewise.\n\t(orc<mode>3): Likewise.\n\n\t* config/rs6000/rs6000-protos.h (rs6000_split_logical): New\n\tdeclaration.\n\n\t* config/rs6000/rs6000.c (rs6000_split_logical_inner): Add support\n\tto split multi-word logical operations.\n\t(rs6000_split_logical_di): Likewise.\n\t(rs6000_split_logical): Likewise.\n\n\t* config/rs6000/vsx.md (VSX_L2): Delete, no longer used.\n\t(vsx_and<mode>3_32bit): Move 128-bit logical insns to rs6000.md,\n\tand allow TImode operations in 32-bit.\n\t(vsx_and<mode>3_64bit): Likewise.\n\t(vsx_ior<mode>3_32bit): Likewise.\n\t(vsx_ior<mode>3_64bit): Likewise.\n\t(vsx_xor<mode>3_32bit): Likewise.\n\t(vsx_xor<mode>3_64bit): Likewise.\n\t(vsx_one_cmpl<mode>2_32bit): Likewise.\n\t(vsx_one_cmpl<mode>2_64bit): Likewise.\n\t(vsx_nor<mode>3_32bit): Likewise.\n\t(vsx_nor<mode>3_64bit): Likewise.\n\t(vsx_andc<mode>3_32bit): Likewise.\n\t(vsx_andc<mode>3_64bit): Likewise.\n\t(vsx_eqv<mode>3_32bit): Likewise.\n\t(vsx_eqv<mode>3_64bit): Likewise.\n\t(vsx_nand<mode>3_32bit): Likewise.\n\t(vsx_nand<mode>3_64bit): Likewise.\n\t(vsx_orc<mode>3_32bit): Likewise.\n\t(vsx_orc<mode>3_64bit): Likewise.\n\n\t* config/rs6000/rs6000.h (VLOGICAL_REGNO_P): Always allow vector\n\tlogical types in GPRs.\n\n\t* config/rs6000/altivec.md (altivec_and<mode>3): Move 128-bit\n\tlogical insns to rs6000.md, and allow TImode operations in\n\t32-bit.\n\t(altivec_ior<mode>3): Likewise.\n\t(altivec_xor<mode>3): Likewise.\n\t(altivec_one_cmpl<mode>2): Likewise.\n\t(altivec_nor<mode>3): Likewise.\n\t(altivec_andc<mode>3): Likewise.\n\n\t* config/rs6000/rs6000.md (BOOL_128): New mode iterators and mode\n\tattributes for moving the 128-bit logical operations into\n\trs6000.md.\n\t(BOOL_REGS_OUTPUT): Likewise.\n\t(BOOL_REGS_OP1): Likewise.\n\t(BOOL_REGS_OP2): Likewise.\n\t(BOOL_REGS_UNARY): Likewise.\n\t(BOOL_REGS_AND_CR0): Likewise.\n\t(one_cmpl<mode>2): Add support for DI logical operations on\n\t32-bit, splitting the operations to 32-bit.\n\t(anddi3): Likewise.\n\t(iordi3): Likewise.\n\t(xordi3): Likewise.\n\t(and<mode>3, 128-bit types): Rewrite 2013-06-06 logical operator\n\tchanges to combine the 32/64-bit code, allow logical operations on\n\tTI mode in 32-bit, and to use similar match_operator patterns like\n\tscalar mode uses.  Combine the Altivec and VSX code for logical\n\toperations, and move it here.\n\t(ior<mode>3, 128-bit types): Likewise.\n\t(xor<mode>3, 128-bit types): Likewise.\n\t(one_cmpl<mode>3, 128-bit types): Likewise.\n\t(nor<mode>3, 128-bit types): Likewise.\n\t(andc<mode>3, 128-bit types): Likewise.\n\t(eqv<mode>3, 128-bit types): Likewise.\n\t(nand<mode>3, 128-bit types): Likewise.\n\t(orc<mode>3, 128-bit types): Likewise.\n\t(and<mode>3_internal): Likewise.\n\t(bool<mode>3_internal): Likewise.\n\t(boolc<mode>3_internal1): Likewise.\n\t(boolc<mode>3_internal2): Likewise.\n\t(boolcc<mode>3_internal1): Likewise.\n\t(boolcc<mode>3_internal2): Likewise.\n\t(eqv<mode>3_internal1): Likewise.\n\t(eqv<mode>3_internal2): Likewise.\n\t(one_cmpl1<mode>3_internal): Likewise.\n\n[gcc/testsuite]\n2013-07-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/bool2.h: New file, test the code generation\n\tof logical operations for power5, altivec, power7, and power8\n\tsystems.\n\t* gcc.target/powerpc/bool2-p5.c: Likewise.\n\t* gcc.target/powerpc/bool2-av.c: Likewise.\n\t* gcc.target/powerpc/bool2-p7.c: Likewise.\n\t* gcc.target/powerpc/bool2-p8.c: Likewise.\n\t* gcc.target/powerpc/bool3.h: Likewise.\n\t* gcc.target/powerpc/bool3-av.c: Likewise.\n\t* gcc.target/powerpc/bool2-p7.c: Likewise.\n\t* gcc.target/powerpc/bool2-p8.c: Likewise.\n\nFrom-SVN: r201187", "tree": {"sha": "4be2fc98c8c716b2df4e89663232a6e68dd2e07a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4be2fc98c8c716b2df4e89663232a6e68dd2e07a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd7a40e14c20495d719ad715de00cff5c490fd07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd7a40e14c20495d719ad715de00cff5c490fd07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd7a40e14c20495d719ad715de00cff5c490fd07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd7a40e14c20495d719ad715de00cff5c490fd07/comments", "author": null, "committer": null, "parents": [{"sha": "9b69d4b4b1e85af14c9ff6fcfce6834284a288b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b69d4b4b1e85af14c9ff6fcfce6834284a288b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b69d4b4b1e85af14c9ff6fcfce6834284a288b8"}], "stats": {"total": 1841, "additions": 1319, "deletions": 522}, "files": [{"sha": "fe3e041a00485d0fb56df6c99dc985e82f52537d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -1,3 +1,93 @@\n+2013-07-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vector.md (xor<mode>3): Move 128-bit boolean\n+\texpanders to rs6000.md.\n+\t(ior<mode>3): Likewise.\n+\t(and<mode>3): Likewise.\n+\t(one_cmpl<mode>2): Likewise.\n+\t(nor<mode>3): Likewise.\n+\t(andc<mode>3): Likewise.\n+\t(eqv<mode>3): Likewise.\n+\t(nand<mode>3): Likewise.\n+\t(orc<mode>3): Likewise.\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_logical): New\n+\tdeclaration.\n+\n+\t* config/rs6000/rs6000.c (rs6000_split_logical_inner): Add support\n+\tto split multi-word logical operations.\n+\t(rs6000_split_logical_di): Likewise.\n+\t(rs6000_split_logical): Likewise.\n+\n+\t* config/rs6000/vsx.md (VSX_L2): Delete, no longer used.\n+\t(vsx_and<mode>3_32bit): Move 128-bit logical insns to rs6000.md,\n+\tand allow TImode operations in 32-bit.\n+\t(vsx_and<mode>3_64bit): Likewise.\n+\t(vsx_ior<mode>3_32bit): Likewise.\n+\t(vsx_ior<mode>3_64bit): Likewise.\n+\t(vsx_xor<mode>3_32bit): Likewise.\n+\t(vsx_xor<mode>3_64bit): Likewise.\n+\t(vsx_one_cmpl<mode>2_32bit): Likewise.\n+\t(vsx_one_cmpl<mode>2_64bit): Likewise.\n+\t(vsx_nor<mode>3_32bit): Likewise.\n+\t(vsx_nor<mode>3_64bit): Likewise.\n+\t(vsx_andc<mode>3_32bit): Likewise.\n+\t(vsx_andc<mode>3_64bit): Likewise.\n+\t(vsx_eqv<mode>3_32bit): Likewise.\n+\t(vsx_eqv<mode>3_64bit): Likewise.\n+\t(vsx_nand<mode>3_32bit): Likewise.\n+\t(vsx_nand<mode>3_64bit): Likewise.\n+\t(vsx_orc<mode>3_32bit): Likewise.\n+\t(vsx_orc<mode>3_64bit): Likewise.\n+\n+\t* config/rs6000/rs6000.h (VLOGICAL_REGNO_P): Always allow vector\n+\tlogical types in GPRs.\n+\n+\t* config/rs6000/altivec.md (altivec_and<mode>3): Move 128-bit\n+\tlogical insns to rs6000.md, and allow TImode operations in\n+\t32-bit.\n+\t(altivec_ior<mode>3): Likewise.\n+\t(altivec_xor<mode>3): Likewise.\n+\t(altivec_one_cmpl<mode>2): Likewise.\n+\t(altivec_nor<mode>3): Likewise.\n+\t(altivec_andc<mode>3): Likewise.\n+\n+\t* config/rs6000/rs6000.md (BOOL_128): New mode iterators and mode\n+\tattributes for moving the 128-bit logical operations into\n+\trs6000.md.\n+\t(BOOL_REGS_OUTPUT): Likewise.\n+\t(BOOL_REGS_OP1): Likewise.\n+\t(BOOL_REGS_OP2): Likewise.\n+\t(BOOL_REGS_UNARY): Likewise.\n+\t(BOOL_REGS_AND_CR0): Likewise.\n+\t(one_cmpl<mode>2): Add support for DI logical operations on\n+\t32-bit, splitting the operations to 32-bit.\n+\t(anddi3): Likewise.\n+\t(iordi3): Likewise.\n+\t(xordi3): Likewise.\n+\t(and<mode>3, 128-bit types): Rewrite 2013-06-06 logical operator\n+\tchanges to combine the 32/64-bit code, allow logical operations on\n+\tTI mode in 32-bit, and to use similar match_operator patterns like\n+\tscalar mode uses.  Combine the Altivec and VSX code for logical\n+\toperations, and move it here.\n+\t(ior<mode>3, 128-bit types): Likewise.\n+\t(xor<mode>3, 128-bit types): Likewise.\n+\t(one_cmpl<mode>3, 128-bit types): Likewise.\n+\t(nor<mode>3, 128-bit types): Likewise.\n+\t(andc<mode>3, 128-bit types): Likewise.\n+\t(eqv<mode>3, 128-bit types): Likewise.\n+\t(nand<mode>3, 128-bit types): Likewise.\n+\t(orc<mode>3, 128-bit types): Likewise.\n+\t(and<mode>3_internal): Likewise.\n+\t(bool<mode>3_internal): Likewise.\n+\t(boolc<mode>3_internal1): Likewise.\n+\t(boolc<mode>3_internal2): Likewise.\n+\t(boolcc<mode>3_internal1): Likewise.\n+\t(boolcc<mode>3_internal2): Likewise.\n+\t(eqv<mode>3_internal1): Likewise.\n+\t(eqv<mode>3_internal2): Likewise.\n+\t(one_cmpl1<mode>3_internal): Likewise.\n+\n 2013-07-23  David Holsgrove <david.holsgrove@xilinx.com>\n \n \t* config/microblaze/microblaze.c (microblaze_expand_prologue):"}, {"sha": "db2e93a168a51d1be1e23cf6421a5b2747ced376", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -1040,59 +1040,7 @@\n   [(set_attr \"type\" \"veccomplex\")])\n \n \n-;; logical ops.  Have the logical ops follow the memory ops in\n-;; terms of whether to prefer VSX or Altivec\n-\n-;; AND has a clobber to be consistant with VSX, which adds splitters for using\n-;; the GPR registers.\n-(define_insn \"*altivec_and<mode>3\"\n-  [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-        (and:VM (match_operand:VM 1 \"register_operand\" \"v\")\n-\t\t(match_operand:VM 2 \"register_operand\" \"v\")))\n-   (clobber (match_scratch:CC 3 \"=X\"))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vand %0,%1,%2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*altivec_ior<mode>3\"\n-  [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-        (ior:VM (match_operand:VM 1 \"register_operand\" \"v\")\n-\t\t(match_operand:VM 2 \"register_operand\" \"v\")))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vor %0,%1,%2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*altivec_xor<mode>3\"\n-  [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-        (xor:VM (match_operand:VM 1 \"register_operand\" \"v\")\n-\t\t(match_operand:VM 2 \"register_operand\" \"v\")))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vxor %0,%1,%2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*altivec_one_cmpl<mode>2\"\n-  [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-        (not:VM (match_operand:VM 1 \"register_operand\" \"v\")))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vnor %0,%1,%1\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-  \n-(define_insn \"*altivec_nor<mode>3\"\n-  [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-\t(and:VM (not:VM (match_operand:VM 1 \"register_operand\" \"v\"))\n-\t\t(not:VM (match_operand:VM 2 \"register_operand\" \"v\"))))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vnor %0,%1,%2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n-(define_insn \"*altivec_andc<mode>3\"\n-  [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-        (and:VM (not:VM (match_operand:VM 2 \"register_operand\" \"v\"))\n-\t\t(match_operand:VM 1 \"register_operand\" \"v\")))]\n-  \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n-  \"vandc %0,%1,%2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n-\n+;; Vector pack/unpack\n (define_insn \"altivec_vpkpx\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"v\")"}, {"sha": "3a7b37a827063c1182abb7dee88ab045a3f3c793", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -138,6 +138,7 @@ extern rtx rs6000_address_for_fpconvert (rtx);\n extern rtx rs6000_address_for_altivec (rtx);\n extern rtx rs6000_allocate_stack_temp (enum machine_mode, bool, bool);\n extern int rs6000_loop_align (rtx);\n+extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool, rtx);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "8c3cf97faa3a993f2c386905172500eb2182d77f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -30139,6 +30139,280 @@ rs6000_set_up_by_prologue (struct hard_reg_set_container *set)\n     add_to_hard_reg_set (&set->set, Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n }\n \n+\f\n+/* Helper function for rs6000_split_logical to emit a logical instruction after\n+   spliting the operation to single GPR registers.\n+\n+   DEST is the destination register.\n+   OP1 and OP2 are the input source registers.\n+   CODE is the base operation (AND, IOR, XOR, NOT).\n+   MODE is the machine mode.\n+   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n+   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n+   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n+   formation of the AND instructions.  */\n+\n+static void\n+rs6000_split_logical_inner (rtx dest,\n+\t\t\t    rtx op1,\n+\t\t\t    rtx op2,\n+\t\t\t    enum rtx_code code,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    bool complement_final_p,\n+\t\t\t    bool complement_op1_p,\n+\t\t\t    bool complement_op2_p,\n+\t\t\t    rtx clobber_reg)\n+{\n+  rtx bool_rtx;\n+  rtx set_rtx;\n+\n+  /* Optimize AND of 0/0xffffffff and IOR/XOR of 0.  */\n+  if (op2 && GET_CODE (op2) == CONST_INT\n+      && (mode == SImode || (mode == DImode && TARGET_POWERPC64))\n+      && !complement_final_p && !complement_op1_p && !complement_op2_p)\n+    {\n+      HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n+      HOST_WIDE_INT value = INTVAL (op2) & mask;\n+\n+      /* Optimize AND of 0 to just set 0.  Optimize AND of -1 to be a move.  */\n+      if (code == AND)\n+\t{\n+\t  if (value == 0)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest, const0_rtx));\n+\t      return;\n+\t    }\n+\n+\t  else if (value == mask)\n+\t    {\n+\t      if (!rtx_equal_p (dest, op1))\n+\t\temit_insn (gen_rtx_SET (VOIDmode, dest, op1));\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Optimize IOR/XOR of 0 to be a simple move.  Split large operations\n+\t into separate ORI/ORIS or XORI/XORIS instrucitons.  */\n+      else if (code == IOR || code == XOR)\n+\t{\n+\t  if (value == 0)\n+\t    {\n+\t      if (!rtx_equal_p (dest, op1))\n+\t\temit_insn (gen_rtx_SET (VOIDmode, dest, op1));\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  if (complement_op1_p)\n+    op1 = gen_rtx_NOT (mode, op1);\n+\n+  if (complement_op2_p)\n+    op2 = gen_rtx_NOT (mode, op2);\n+\n+  bool_rtx = ((code == NOT)\n+\t      ? gen_rtx_NOT (mode, op1)\n+\t      : gen_rtx_fmt_ee (code, mode, op1, op2));\n+\n+  if (complement_final_p)\n+    bool_rtx = gen_rtx_NOT (mode, bool_rtx);\n+\n+  set_rtx = gen_rtx_SET (VOIDmode, dest, bool_rtx);\n+\n+  /* Is this AND with an explicit clobber?  */\n+  if (clobber_reg)\n+    {\n+      rtx clobber = gen_rtx_CLOBBER (VOIDmode, clobber_reg);\n+      set_rtx = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set_rtx, clobber));\n+    }\n+\n+  emit_insn (set_rtx);\n+  return;\n+}\n+\n+/* Split a DImode AND/IOR/XOR with a constant on a 32-bit system.  These\n+   operations are split immediately during RTL generation to allow for more\n+   optimizations of the AND/IOR/XOR.\n+\n+   OPERANDS is an array containing the destination and two input operands.\n+   CODE is the base operation (AND, IOR, XOR, NOT).\n+   MODE is the machine mode.\n+   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n+   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n+   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n+   formation of the AND instructions.  */\n+\n+static void\n+rs6000_split_logical_di (rtx operands[3],\n+\t\t\t enum rtx_code code,\n+\t\t\t bool complement_final_p,\n+\t\t\t bool complement_op1_p,\n+\t\t\t bool complement_op2_p,\n+\t\t\t rtx clobber_reg)\n+{\n+  const HOST_WIDE_INT lower_32bits = HOST_WIDE_INT_C(0xffffffff);\n+  const HOST_WIDE_INT upper_32bits = ~ lower_32bits;\n+  const HOST_WIDE_INT sign_bit = HOST_WIDE_INT_C(0x80000000);\n+  enum hi_lo { hi = 0, lo = 1 };\n+  rtx op0_hi_lo[2], op1_hi_lo[2], op2_hi_lo[2];\n+  size_t i;\n+\n+  op0_hi_lo[hi] = gen_highpart (SImode, operands[0]);\n+  op1_hi_lo[hi] = gen_highpart (SImode, operands[1]);\n+  op0_hi_lo[lo] = gen_lowpart (SImode, operands[0]);\n+  op1_hi_lo[lo] = gen_lowpart (SImode, operands[1]);\n+\n+  if (code == NOT)\n+    op2_hi_lo[hi] = op2_hi_lo[lo] = NULL_RTX;\n+  else\n+    {\n+      if (GET_CODE (operands[2]) != CONST_INT)\n+\t{\n+\t  op2_hi_lo[hi] = gen_highpart_mode (SImode, DImode, operands[2]);\n+\t  op2_hi_lo[lo] = gen_lowpart (SImode, operands[2]);\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT value = INTVAL (operands[2]);\n+\t  HOST_WIDE_INT value_hi_lo[2];\n+\n+\t  gcc_assert (!complement_final_p);\n+\t  gcc_assert (!complement_op1_p);\n+\t  gcc_assert (!complement_op2_p);\n+\n+\t  value_hi_lo[hi] = value >> 32;\n+\t  value_hi_lo[lo] = value & lower_32bits;\n+\n+\t  for (i = 0; i < 2; i++)\n+\t    {\n+\t      HOST_WIDE_INT sub_value = value_hi_lo[i];\n+\n+\t      if (sub_value & sign_bit)\n+\t\tsub_value |= upper_32bits;\n+\n+\t      op2_hi_lo[i] = GEN_INT (sub_value);\n+\n+\t      /* If this is an AND instruction, check to see if we need to load\n+\t\t the value in a register.  */\n+\t      if (code == AND && sub_value != -1 && sub_value != 0\n+\t\t  && !and_operand (op2_hi_lo[i], SImode))\n+\t\top2_hi_lo[i] = force_reg (SImode, op2_hi_lo[i]);\n+\t    }\n+\t}\n+    }\n+\n+  for (i = 0; i < 2; i++)\n+    {\n+      /* Split large IOR/XOR operations.  */\n+      if ((code == IOR || code == XOR)\n+\t  && GET_CODE (op2_hi_lo[i]) == CONST_INT\n+\t  && !complement_final_p\n+\t  && !complement_op1_p\n+\t  && !complement_op2_p\n+\t  && clobber_reg == NULL_RTX\n+\t  && !logical_const_operand (op2_hi_lo[i], SImode))\n+\t{\n+\t  HOST_WIDE_INT value = INTVAL (op2_hi_lo[i]);\n+\t  HOST_WIDE_INT hi_16bits = value & HOST_WIDE_INT_C(0xffff0000);\n+\t  HOST_WIDE_INT lo_16bits = value & HOST_WIDE_INT_C(0x0000ffff);\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\n+\t  /* Make sure the constant is sign extended.  */\n+\t  if ((hi_16bits & sign_bit) != 0)\n+\t    hi_16bits |= upper_32bits;\n+\n+\t  rs6000_split_logical_inner (tmp, op1_hi_lo[i], GEN_INT (hi_16bits),\n+\t\t\t\t      code, SImode, false, false, false,\n+\t\t\t\t      NULL_RTX);\n+\n+\t  rs6000_split_logical_inner (op0_hi_lo[i], tmp, GEN_INT (lo_16bits),\n+\t\t\t\t      code, SImode, false, false, false,\n+\t\t\t\t      NULL_RTX);\n+\t}\n+      else\n+\trs6000_split_logical_inner (op0_hi_lo[i], op1_hi_lo[i], op2_hi_lo[i],\n+\t\t\t\t    code, SImode, complement_final_p,\n+\t\t\t\t    complement_op1_p, complement_op2_p,\n+\t\t\t\t    clobber_reg);\n+    }\n+\n+  return;\n+}\n+\n+/* Split the insns that make up boolean operations operating on multiple GPR\n+   registers.  The boolean MD patterns ensure that the inputs either are\n+   exactly the same as the output registers, or there is no overlap.\n+\n+   OPERANDS is an array containing the destination and two input operands.\n+   CODE is the base operation (AND, IOR, XOR, NOT).\n+   MODE is the machine mode.\n+   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n+   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n+   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n+   formation of the AND instructions.  */\n+\n+void\n+rs6000_split_logical (rtx operands[3],\n+\t\t      enum rtx_code code,\n+\t\t      bool complement_final_p,\n+\t\t      bool complement_op1_p,\n+\t\t      bool complement_op2_p,\n+\t\t      rtx clobber_reg)\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  enum machine_mode sub_mode;\n+  rtx op0, op1, op2;\n+  int sub_size, regno0, regno1, nregs, i;\n+\n+  /* If this is DImode, use the specialized version that can run before\n+     register allocation.  */\n+  if (mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical_di (operands, code, complement_final_p,\n+\t\t\t       complement_op1_p, complement_op2_p,\n+\t\t\t       clobber_reg);\n+      return;\n+    }\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+  op2 = (code == NOT) ? NULL_RTX : operands[2];\n+  sub_mode = (TARGET_POWERPC64) ? DImode : SImode;\n+  sub_size = GET_MODE_SIZE (sub_mode);\n+  regno0 = REGNO (op0);\n+  regno1 = REGNO (op1);\n+\n+  gcc_assert (reload_completed);\n+  gcc_assert (IN_RANGE (regno0, FIRST_GPR_REGNO, LAST_GPR_REGNO));\n+  gcc_assert (IN_RANGE (regno1, FIRST_GPR_REGNO, LAST_GPR_REGNO));\n+\n+  nregs = rs6000_hard_regno_nregs[(int)mode][regno0];\n+  gcc_assert (nregs > 1);\n+\n+  if (op2 && REG_P (op2))\n+    gcc_assert (IN_RANGE (REGNO (op2), FIRST_GPR_REGNO, LAST_GPR_REGNO));\n+\n+  for (i = 0; i < nregs; i++)\n+    {\n+      int offset = i * sub_size;\n+      rtx sub_op0 = simplify_subreg (sub_mode, op0, mode, offset);\n+      rtx sub_op1 = simplify_subreg (sub_mode, op1, mode, offset);\n+      rtx sub_op2 = ((code == NOT)\n+\t\t     ? NULL_RTX\n+\t\t     : simplify_subreg (sub_mode, op2, mode, offset));\n+\n+      rs6000_split_logical_inner (sub_op0, sub_op1, sub_op2, code, sub_mode,\n+\t\t\t\t  complement_final_p, complement_op1_p,\n+\t\t\t\t  complement_op2_p, clobber_reg);\n+    }\n+\n+  return;\n+}\n+\n+\f\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rs6000.h\""}, {"sha": "e5a6abd6d0d140ff409b2fb01bcb3379c906ed5a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -1121,14 +1121,11 @@ enum data_align { align_abi, align_opt, align_both };\n #define VINT_REGNO_P(N) ALTIVEC_REGNO_P (N)\n \n /* Alternate name for any vector register supporting logical operations, no\n-   matter which instruction set(s) are available.  For 64-bit mode, we also\n-   allow logical operations in the GPRS.  This is to allow atomic quad word\n-   builtins not to need the VSX registers for lqarx/stqcx.  It also helps with\n-   __int128_t arguments that are passed in GPRs.  */\n+   matter which instruction set(s) are available.  Allow GPRs as well as the\n+   vector registers.  */\n #define VLOGICAL_REGNO_P(N)\t\t\t\t\t\t\\\n-  (ALTIVEC_REGNO_P (N)\t\t\t\t\t\t\t\\\n-   || (TARGET_VSX && FP_REGNO_P (N))\t\t\t\t\t\\\n-   || (TARGET_VSX && TARGET_POWERPC64 && INT_REGNO_P (N)))\n+  (INT_REGNO_P (N) || ALTIVEC_REGNO_P (N)\t\t\t\t\\\n+   || (TARGET_VSX && FP_REGNO_P (N)))\t\t\t\t\t\\\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.  */"}, {"sha": "064a51da608248c9a59d3aa0dfd37815e8eea19c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 483, "deletions": 13, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -391,6 +391,77 @@\n \n (define_mode_attr TARGET_FLOAT [(SF \"TARGET_SINGLE_FLOAT\")\n \t\t\t\t(DF \"TARGET_DOUBLE_FLOAT\")])\n+\n+;; Mode iterator for logical operations on 128-bit types\n+(define_mode_iterator BOOL_128\t\t[TI\n+\t\t\t\t\t PTI\n+\t\t\t\t\t (V16QI\t\"TARGET_ALTIVEC\")\n+\t\t\t\t\t (V8HI\t\"TARGET_ALTIVEC\")\n+\t\t\t\t\t (V4SI\t\"TARGET_ALTIVEC\")\n+\t\t\t\t\t (V4SF\t\"TARGET_ALTIVEC\")\n+\t\t\t\t\t (V2DI\t\"TARGET_ALTIVEC\")\n+\t\t\t\t\t (V2DF\t\"TARGET_ALTIVEC\")])\n+\n+;; For the GPRs we use 3 constraints for register outputs, two that are the\n+;; same as the output register, and a third where the output register is an\n+;; early clobber, so we don't have to deal with register overlaps.  For the\n+;; vector types, we prefer to use the vector registers.  For TI mode, allow\n+;; either.\n+\n+;; Mode attribute for boolean operation register constraints for output\n+(define_mode_attr BOOL_REGS_OUTPUT\t[(TI\t\"&r,r,r,wa,v\")\n+\t\t\t\t\t (PTI\t\"&r,r,r\")\n+\t\t\t\t\t (V16QI\t\"wa,v,&?r,?r,?r\")\n+\t\t\t\t\t (V8HI\t\"wa,v,&?r,?r,?r\")\n+\t\t\t\t\t (V4SI\t\"wa,v,&?r,?r,?r\")\n+\t\t\t\t\t (V4SF\t\"wa,v,&?r,?r,?r\")\n+\t\t\t\t\t (V2DI\t\"wa,v,&?r,?r,?r\")\n+\t\t\t\t\t (V2DF\t\"wa,v,&?r,?r,?r\")])\n+\n+;; Mode attribute for boolean operation register constraints for operand1\n+(define_mode_attr BOOL_REGS_OP1\t\t[(TI\t\"r,0,r,wa,v\")\n+\t\t\t\t\t (PTI\t\"r,0,r\")\n+\t\t\t\t\t (V16QI\t\"wa,v,r,0,r\")\n+\t\t\t\t\t (V8HI\t\"wa,v,r,0,r\")\n+\t\t\t\t\t (V4SI\t\"wa,v,r,0,r\")\n+\t\t\t\t\t (V4SF\t\"wa,v,r,0,r\")\n+\t\t\t\t\t (V2DI\t\"wa,v,r,0,r\")\n+\t\t\t\t\t (V2DF\t\"wa,v,r,0,r\")])\n+\n+;; Mode attribute for boolean operation register constraints for operand2\n+(define_mode_attr BOOL_REGS_OP2\t\t[(TI\t\"r,r,0,wa,v\")\n+\t\t\t\t\t (PTI\t\"r,r,0\")\n+\t\t\t\t\t (V16QI\t\"wa,v,r,r,0\")\n+\t\t\t\t\t (V8HI\t\"wa,v,r,r,0\")\n+\t\t\t\t\t (V4SI\t\"wa,v,r,r,0\")\n+\t\t\t\t\t (V4SF\t\"wa,v,r,r,0\")\n+\t\t\t\t\t (V2DI\t\"wa,v,r,r,0\")\n+\t\t\t\t\t (V2DF\t\"wa,v,r,r,0\")])\n+\n+;; Mode attribute for boolean operation register constraints for operand1\n+;; for one_cmpl.  To simplify things, we repeat the constraint where 0\n+;; is used for operand1 or operand2\n+(define_mode_attr BOOL_REGS_UNARY\t[(TI\t\"r,0,0,wa,v\")\n+\t\t\t\t\t (PTI\t\"r,0,0\")\n+\t\t\t\t\t (V16QI\t\"wa,v,r,0,0\")\n+\t\t\t\t\t (V8HI\t\"wa,v,r,0,0\")\n+\t\t\t\t\t (V4SI\t\"wa,v,r,0,0\")\n+\t\t\t\t\t (V4SF\t\"wa,v,r,0,0\")\n+\t\t\t\t\t (V2DI\t\"wa,v,r,0,0\")\n+\t\t\t\t\t (V2DF\t\"wa,v,r,0,0\")])\n+\n+;; Mode attribute for the clobber of CC0 for AND expansion.\n+;; For the 128-bit types, we never do AND immediate, but we need to\n+;; get the correct number of X's for the number of operands.\n+(define_mode_attr BOOL_REGS_AND_CR0\t[(TI\t\"X,X,X,X,X\")\n+\t\t\t\t\t (PTI\t\"X,X,X\")\n+\t\t\t\t\t (V16QI\t\"X,X,X,X,X\")\n+\t\t\t\t\t (V8HI\t\"X,X,X,X,X\")\n+\t\t\t\t\t (V4SI\t\"X,X,X,X,X\")\n+\t\t\t\t\t (V4SF\t\"X,X,X,X,X\")\n+\t\t\t\t\t (V2DI\t\"X,X,X,X,X\")\n+\t\t\t\t\t (V2DF\t\"X,X,X,X,X\")])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -1840,7 +1911,19 @@\n     FAIL;\n })\n \n-(define_insn \"one_cmpl<mode>2\"\n+(define_expand \"one_cmpl<mode>2\"\n+  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n+\t(not:SDI (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+  \"\"\n+{\n+  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical (operands, NOT, false, false, false, NULL_RTX);\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*one_cmpl<mode>2\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(not:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")))]\n   \"\"\n@@ -7962,10 +8045,19 @@\n   [(parallel\n     [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t  (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"and64_2_operand\" \"\")))\n+\t\t  (match_operand:DI 2 \"reg_or_cint_operand\" \"\")))\n      (clobber (match_scratch:CC 3 \"\"))])]\n-  \"TARGET_POWERPC64\"\n-  \"\")\n+  \"\"\n+{\n+  if (!TARGET_POWERPC64)\n+    {\n+      rtx cc = gen_rtx_SCRATCH (CCmode);\n+      rs6000_split_logical (operands, AND, false, false, false, cc);\n+      DONE;\n+    }\n+  else if (!and64_2_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n+})\n \n (define_insn \"anddi3_mc\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r\")\n@@ -8146,11 +8238,17 @@\n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_logical_cint_operand\" \"\")))]\n-  \"TARGET_POWERPC64\"\n-  \"\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"\"\n {\n-  if (non_logical_cint_operand (operands[2], DImode))\n+  if (!TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical (operands, IOR, false, false, false, NULL_RTX);\n+      DONE;\n+    }\n+  else if (!reg_or_logical_cint_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  else if (non_logical_cint_operand (operands[2], DImode))\n     {\n       HOST_WIDE_INT value;\n       rtx tmp = ((!can_create_pseudo_p ()\n@@ -8164,15 +8262,21 @@\n       emit_insn (gen_iordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n-}\")\n+})\n \n (define_expand \"xordi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_logical_cint_operand\" \"\")))]\n-  \"TARGET_POWERPC64\"\n-  \"\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"\"\n {\n+  if (!TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical (operands, XOR, false, false, false, NULL_RTX);\n+      DONE;\n+    }\n+  else if (!reg_or_logical_cint_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n   if (non_logical_cint_operand (operands[2], DImode))\n     {\n       HOST_WIDE_INT value;\n@@ -8187,7 +8291,7 @@\n       emit_insn (gen_xordi3 (operands[0], tmp, GEN_INT (value & 0xffff)));\n       DONE;\n     }\n-}\")\n+})\n \n (define_insn \"*booldi3_internal1\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n@@ -8424,6 +8528,372 @@\n   [(set_attr \"type\" \"integer\")\n    (set_attr \"length\" \"4\")])\n \n+\f\n+;; 128-bit logical operations expanders\n+\n+(define_expand \"and<mode>3\"\n+  [(parallel [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+\t\t   (and:BOOL_128\n+\t\t    (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")\n+\t\t    (match_operand:BOOL_128 2 \"vlogical_operand\" \"\")))\n+\t      (clobber (match_scratch:CC 3 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"ior<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+        (ior:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")\n+\t\t      (match_operand:BOOL_128 2 \"vlogical_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"xor<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+        (xor:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")\n+\t\t      (match_operand:BOOL_128 2 \"vlogical_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"one_cmpl<mode>2\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+        (not:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"nor<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+\t(and:BOOL_128\n+\t (not:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\"))\n+\t (not:BOOL_128 (match_operand:BOOL_128 2 \"vlogical_operand\" \"\"))))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"andc<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+        (and:BOOL_128\n+\t (not:BOOL_128 (match_operand:BOOL_128 2 \"vlogical_operand\" \"\"))\n+\t (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+;; Power8 vector logical instructions.\n+(define_expand \"eqv<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+\t(not:BOOL_128\n+\t (xor:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")\n+\t\t       (match_operand:BOOL_128 2 \"vlogical_operand\" \"\"))))]\n+  \"<MODE>mode == TImode || <MODE>mode == PTImode || TARGET_P8_VECTOR\"\n+  \"\")\n+\n+;; Rewrite nand into canonical form\n+(define_expand \"nand<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+\t(ior:BOOL_128\n+\t (not:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\" \"\"))\n+\t (not:BOOL_128 (match_operand:BOOL_128 2 \"vlogical_operand\" \"\"))))]\n+  \"<MODE>mode == TImode || <MODE>mode == PTImode || TARGET_P8_VECTOR\"\n+  \"\")\n+\n+;; The canonical form is to have the negated element first, so we need to\n+;; reverse arguments.\n+(define_expand \"orc<mode>3\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"\")\n+\t(ior:BOOL_128\n+\t (not:BOOL_128 (match_operand:BOOL_128 2 \"vlogical_operand\" \"\"))\n+\t (match_operand:BOOL_128 1 \"vlogical_operand\" \"\")))]\n+  \"<MODE>mode == TImode || <MODE>mode == PTImode || TARGET_P8_VECTOR\"\n+  \"\")\n+\n+;; 128-bit logical operations insns and split operations\n+(define_insn_and_split \"*and<mode>3_internal\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n+        (and:BOOL_128\n+\t (match_operand:BOOL_128 1 \"vlogical_operand\" \"%<BOOL_REGS_OP1>\")\n+\t (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP2>\")))\n+   (clobber (match_scratch:CC 3 \"<BOOL_REGS_AND_CR0>\"))]\n+  \"\"\n+{\n+  if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))\n+    return \"xxland %x0,%x1,%x2\";\n+\n+  if (TARGET_ALTIVEC && altivec_register_operand (operands[0], <MODE>mode))\n+    return \"vand %0,%1,%2\";\n+\n+  return \"#\";\n+}\n+  \"reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, AND, false, false, false, operands[3]);\n+  DONE;\n+}\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"vecsimple\")\n+\t(const_string \"integer\")))\n+   (set (attr \"length\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"4\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\"))))])\n+\n+;; 128-bit IOR/XOR\n+(define_insn_and_split \"*bool<mode>3_internal\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n+\t(match_operator:BOOL_128 3 \"boolean_or_operator\"\n+\t [(match_operand:BOOL_128 1 \"vlogical_operand\" \"%<BOOL_REGS_OP1>\")\n+\t  (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP2>\")]))]\n+  \"\"\n+{\n+  if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))\n+    return \"xxl%q3 %x0,%x1,%x2\";\n+\n+  if (TARGET_ALTIVEC && altivec_register_operand (operands[0], <MODE>mode))\n+    return \"v%q3 %0,%1,%2\";\n+\n+  return \"#\";\n+}\n+  \"reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, false, false,\n+\t\t\tNULL_RTX);\n+  DONE;\n+}\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"vecsimple\")\n+\t(const_string \"integer\")))\n+   (set (attr \"length\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"4\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\"))))])\n+\n+;; 128-bit ANDC/ORC\n+(define_insn_and_split \"*boolc<mode>3_internal1\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n+\t(match_operator:BOOL_128 3 \"boolean_operator\"\n+\t [(not:BOOL_128\n+\t   (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP1>\"))\n+\t  (match_operand:BOOL_128 1 \"vlogical_operand\" \"<BOOL_REGS_OP2>\")]))]\n+  \"TARGET_P8_VECTOR || (GET_CODE (operands[3]) == AND)\"\n+{\n+  if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))\n+    return \"xxl%q3 %x0,%x1,%x2\";\n+\n+  if (TARGET_ALTIVEC && altivec_register_operand (operands[0], <MODE>mode))\n+    return \"v%q3 %0,%1,%2\";\n+\n+  return \"#\";\n+}\n+  \"(TARGET_P8_VECTOR || (GET_CODE (operands[3]) == AND))\n+   && reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false,\n+\t\t\tNULL_RTX);\n+  DONE;\n+}\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"vecsimple\")\n+\t(const_string \"integer\")))\n+   (set (attr \"length\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"4\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\"))))])\n+\n+(define_insn_and_split \"*boolc<mode>3_internal2\"\n+  [(set (match_operand:TI2 0 \"int_reg_operand\" \"=&r,r,r\")\n+\t(match_operator:TI2 3 \"boolean_operator\"\n+\t [(not:TI2\n+\t   (match_operand:TI2 1 \"int_reg_operand\" \"r,0,r\"))\n+\t  (match_operand:TI2 2 \"int_reg_operand\" \"r,r,0\")]))]\n+  \"!TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)\"\n+  \"#\"\n+  \"reload_completed && !TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false,\n+\t\t\tNULL_RTX);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"integer\")\n+   (set (attr \"length\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\")))])\n+\n+;; 128-bit NAND/NOR\n+(define_insn_and_split \"*boolcc<mode>3_internal1\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n+\t(match_operator:BOOL_128 3 \"boolean_operator\"\n+\t [(not:BOOL_128\n+\t   (match_operand:BOOL_128 1 \"vlogical_operand\" \"<BOOL_REGS_OP1>\"))\n+\t  (not:BOOL_128\n+\t   (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP2>\"))]))]\n+  \"TARGET_P8_VECTOR || (GET_CODE (operands[3]) == AND)\"\n+{\n+  if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))\n+    return \"xxl%q3 %x0,%x1,%x2\";\n+\n+  if (TARGET_ALTIVEC && altivec_register_operand (operands[0], <MODE>mode))\n+    return \"v%q3 %0,%1,%2\";\n+\n+  return \"#\";\n+}\n+  \"(TARGET_P8_VECTOR || (GET_CODE (operands[3]) == AND))\n+   && reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, true,\n+\t\t\tNULL_RTX);\n+  DONE;\n+}\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"vecsimple\")\n+\t(const_string \"integer\")))\n+   (set (attr \"length\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"4\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\"))))])\n+\n+(define_insn_and_split \"*boolcc<mode>3_internal2\"\n+  [(set (match_operand:TI2 0 \"int_reg_operand\" \"=&r,r,r\")\n+\t(match_operator:TI2 3 \"boolean_operator\"\n+\t [(not:TI2\n+\t   (match_operand:TI2 1 \"int_reg_operand\" \"r,0,r\"))\n+\t  (not:TI2\n+\t   (match_operand:TI2 2 \"int_reg_operand\" \"r,r,0\"))]))]\n+  \"!TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)\"\n+  \"#\"\n+  \"reload_completed && !TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, true,\n+\t\t\tNULL_RTX);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"integer\")\n+   (set (attr \"length\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\")))])\n+\n+\n+;; 128-bit EQV\n+(define_insn_and_split \"*eqv<mode>3_internal1\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n+\t(not:BOOL_128\n+\t (xor:BOOL_128\n+\t  (match_operand:BOOL_128 1 \"vlogical_operand\" \"<BOOL_REGS_OP1>\")\n+\t  (match_operand:BOOL_128 2 \"vlogical_operand\" \"<BOOL_REGS_OP2>\"))))]\n+  \"TARGET_P8_VECTOR\"\n+{\n+  if (vsx_register_operand (operands[0], <MODE>mode))\n+    return \"xxleqv %x0,%x1,%x2\";\n+\n+  return \"#\";\n+}\n+  \"TARGET_P8_VECTOR && reload_completed\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, XOR, true, false, false, NULL_RTX);\n+  DONE;\n+}\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"vecsimple\")\n+\t(const_string \"integer\")))\n+   (set (attr \"length\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"4\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\"))))])\n+\n+(define_insn_and_split \"*eqv<mode>3_internal2\"\n+  [(set (match_operand:TI2 0 \"int_reg_operand\" \"=&r,r,r\")\n+\t(not:TI2\n+\t (xor:TI2\n+\t  (match_operand:TI2 1 \"int_reg_operand\" \"r,0,r\")\n+\t  (match_operand:TI2 2 \"int_reg_operand\" \"r,r,0\"))))]\n+  \"!TARGET_P8_VECTOR\"\n+  \"#\"\n+  \"reload_completed && !TARGET_P8_VECTOR\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, XOR, true, false, false, NULL_RTX);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"integer\")\n+   (set (attr \"length\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\")))])\n+\n+;; 128-bit one's complement\n+(define_insn_and_split \"*one_cmpl<mode>3_internal\"\n+  [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n+\t(not:BOOL_128\n+\t  (match_operand:BOOL_128 1 \"vlogical_operand\" \"<BOOL_REGS_UNARY>\")))]\n+  \"\"\n+{\n+  if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))\n+    return \"xxlnor %x0,%x1,%x1\";\n+\n+  if (TARGET_ALTIVEC && altivec_register_operand (operands[0], <MODE>mode))\n+    return \"vnor %0,%1,%1\";\n+\n+  return \"#\";\n+}\n+  \"reload_completed && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_logical (operands, NOT, false, false, false, NULL_RTX);\n+  DONE;\n+}\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"vecsimple\")\n+\t(const_string \"integer\")))\n+   (set (attr \"length\")\n+      (if_then_else\n+\t(match_test \"vsx_register_operand (operands[0], <MODE>mode)\")\n+\t(const_string \"4\")\n+\t(if_then_else\n+\t (match_test \"TARGET_POWERPC64\")\n+\t (const_string \"8\")\n+\t (const_string \"16\"))))])\n+\n \f\n ;; Now define ways of moving data around.\n "}, {"sha": "2eaa2d325c3566a2452b3d175089658f3284582c", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -710,87 +710,6 @@\n   \"\")\n \n \f\n-;; Vector logical instructions\n-;; Do not support TImode logical instructions on 32-bit at present, because the\n-;; compiler will see that we have a TImode and when it wanted DImode, and\n-;; convert the DImode to TImode, store it on the stack, and load it in a VSX\n-;; register.\n-(define_expand \"xor<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-        (xor:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n-\t\t   (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"\")\n-\n-(define_expand \"ior<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-        (ior:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n-\t\t   (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"\")\n-\n-(define_expand \"and<mode>3\"\n-  [(parallel [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-\t\t   (and:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n-\t\t\t      (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))\n-\t      (clobber (match_scratch:CC 3 \"\"))])]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"\")\n-\n-(define_expand \"one_cmpl<mode>2\"\n-  [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-        (not:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"\")\n-\n-(define_expand \"nor<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-\t(and:VEC_L (not:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\"))\n-\t\t   (not:VEC_L (match_operand:VEC_L 2 \"vlogical_operand\" \"\"))))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"\")\n-\n-(define_expand \"andc<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-        (and:VEC_L (not:VEC_L (match_operand:VEC_L 2 \"vlogical_operand\" \"\"))\n-\t\t   (match_operand:VEC_L 1 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"\")\n-\n-;; Power8 vector logical instructions.\n-(define_expand \"eqv<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"register_operand\" \"\")\n-\t(not:VEC_L\n-\t (xor:VEC_L (match_operand:VEC_L 1 \"register_operand\" \"\")\n-\t\t    (match_operand:VEC_L 2 \"register_operand\" \"\"))))]\n-  \"TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\")\n-\n-;; Rewrite nand into canonical form\n-(define_expand \"nand<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"register_operand\" \"\")\n-\t(ior:VEC_L\n-\t (not:VEC_L (match_operand:VEC_L 1 \"register_operand\" \"\"))\n-\t (not:VEC_L (match_operand:VEC_L 2 \"register_operand\" \"\"))))]\n-  \"TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\")\n-\n-;; The canonical form is to have the negated elment first, so we need to\n-;; reverse arguments.\n-(define_expand \"orc<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"register_operand\" \"\")\n-\t(ior:VEC_L\n-\t (not:VEC_L (match_operand:VEC_L 1 \"register_operand\" \"\"))\n-\t (match_operand:VEC_L 2 \"register_operand\" \"\")))]\n-  \"TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\")\n-\n ;; Vector count leading zeros\n (define_expand \"clz<mode>2\"\n   [(set (match_operand:VEC_I 0 \"register_operand\" \"\")"}, {"sha": "5e6f397031ccf95ce2ce9b8579e8e8d5d05a6a89", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -36,10 +36,6 @@\n ;; Iterator for logical types supported by VSX\n (define_mode_iterator VSX_L [V16QI V8HI V4SI V2DI V4SF V2DF TI])\n \n-;; Like VSX_L, but don't support TImode for doing logical instructions in\n-;; 32-bit\n-(define_mode_iterator VSX_L2 [V16QI V8HI V4SI V2DI V4SF V2DF])\n-\n ;; Iterator for memory move.  Handle TImode specially to allow\n ;; it to use gprs as well as vsx registers.\n (define_mode_iterator VSX_M [V16QI V8HI V4SI V2DI V4SF V2DF])\n@@ -1046,370 +1042,6 @@\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n-\f\n-;; Logical operations.  Do not support TImode logical instructions on 32-bit at\n-;; present, because the compiler will see that we have a TImode and when it\n-;; wanted DImode, and convert the DImode to TImode, store it on the stack, and\n-;; load it in a VSX register or generate extra logical instructions in GPR\n-;; registers.\n-\n-;; When we are splitting the operations to GPRs, we use three alternatives, two\n-;; where the first/second inputs and output are in the same register, and the\n-;; third where the output specifies an early clobber so that we don't have to\n-;; worry about overlapping registers.\n-\n-(define_insn \"*vsx_and<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-        (and:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"%wa\")\n-\t\t    (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))\n-   (clobber (match_scratch:CC 3 \"X\"))]\n-  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxland %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_and<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r\")\n-        (and:VSX_L\n-\t (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r\")\n-\t (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\")))\n-   (clobber (match_scratch:CC 3 \"X,X,X,X\"))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxland %x0,%x1,%x2\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(parallel [(set (match_dup 4) (and:DI (match_dup 5) (match_dup 6)))\n-\t      (clobber (match_dup 3))])\n-   (parallel [(set (match_dup 7) (and:DI (match_dup 8) (match_dup 9)))\n-\t      (clobber (match_dup 3))])]\n-{\n-  operands[4] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[7] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[9] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two\")\n-   (set_attr \"length\" \"4,8,8,8\")])\n-\n-(define_insn \"*vsx_ior<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-        (ior:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"%wa\")\n-\t\t    (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))]\n-  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxlor %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_ior<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r,?r,&?r\")\n-        (ior:VSX_L\n-\t (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r,0,r\")\n-\t (match_operand:VSX_L 2 \"vsx_reg_or_cint_operand\" \"wa,r,0,r,n,n\")))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlor %x0,%x1,%x2\n-   #\n-   #\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(const_int 0)]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-\n-  if (operands[5] == constm1_rtx)\n-    emit_move_insn (operands[3], constm1_rtx);\n-\n-  else if (operands[5] == const0_rtx)\n-    {\n-      if (!rtx_equal_p (operands[3], operands[4]))\n-\temit_move_insn (operands[3], operands[4]);\n-    }\n-  else\n-    emit_insn (gen_iordi3 (operands[3], operands[4], operands[5]));\n-\n-  if (operands[8] == constm1_rtx)\n-    emit_move_insn (operands[8], constm1_rtx);\n-\n-  else if (operands[8] == const0_rtx)\n-    {\n-      if (!rtx_equal_p (operands[6], operands[7]))\n-\temit_move_insn (operands[6], operands[7]);\n-    }\n-  else\n-    emit_insn (gen_iordi3 (operands[6], operands[7], operands[8]));\n-  DONE;\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two,three,three\")\n-   (set_attr \"length\" \"4,8,8,8,16,16\")])\n-\n-(define_insn \"*vsx_xor<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-        (xor:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"%wa\")\n-\t\t    (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && !TARGET_POWERPC64\"\n-  \"xxlxor %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_xor<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r,?r,&?r\")\n-        (xor:VSX_L\n-\t (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r,0,r\")\n-\t (match_operand:VSX_L 2 \"vsx_reg_or_cint_operand\" \"wa,r,0,r,n,n\")))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlxor %x0,%x1,%x2\n-   #\n-   #\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 3) (xor:DI (match_dup 4) (match_dup 5)))\n-   (set (match_dup 6) (xor:DI (match_dup 7) (match_dup 8)))]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two,three,three\")\n-   (set_attr \"length\" \"4,8,8,8,16,16\")])\n-\n-(define_insn \"*vsx_one_cmpl<mode>2_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-        (not:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\")))]\n-  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxlnor %x0,%x1,%x1\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_one_cmpl<mode>2_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,&?r\")\n-        (not:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,0,r\")))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlnor %x0,%x1,%x1\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 2) (not:DI (match_dup 3)))\n-   (set (match_dup 4) (not:DI (match_dup 5)))]\n-{\n-  operands[2] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[3] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[5] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two\")\n-   (set_attr \"length\" \"4,8,8\")])\n-  \n-(define_insn \"*vsx_nor<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-\t(and:VSX_L2\n-\t (not:VSX_L2 (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa\"))\n-\t (not:VSX_L2 (match_operand:VSX_L 2 \"vlogical_operand\" \"wa\"))))]\n-  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxlnor %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_nor<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r\")\n-\t(and:VSX_L\n-\t (not:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r\"))\n-\t (not:VSX_L (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\"))))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlnor %x0,%x1,%x2\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 3) (and:DI (not:DI (match_dup 4)) (not:DI (match_dup 5))))\n-   (set (match_dup 6) (and:DI (not:DI (match_dup 7)) (not:DI (match_dup 8))))]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two\")\n-   (set_attr \"length\" \"4,8,8,8\")])\n-\n-(define_insn \"*vsx_andc<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-        (and:VSX_L2\n-\t (not:VSX_L2\n-\t  (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\"))\n-\t (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\")))]\n-  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxlandc %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_andc<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,?r\")\n-        (and:VSX_L\n-\t (not:VSX_L\n-\t  (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,0,r,r\"))\n-\t (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,r,0,r\")))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlandc %x0,%x1,%x2\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 3) (and:DI (not:DI (match_dup 4)) (match_dup 5)))\n-   (set (match_dup 6) (and:DI (not:DI (match_dup 7)) (match_dup 8)))]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two\")\n-   (set_attr \"length\" \"4,8,8,8\")])\n-\n-;; Power8 vector logical instructions.\n-(define_insn \"*vsx_eqv<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-\t(not:VSX_L2\n-\t (xor:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\")\n-\t\t     (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\"))))]\n-  \"!TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxleqv %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_eqv<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,?r\")\n-\t(not:VSX_L\n-\t (xor:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,0,r,r\")\n-\t\t    (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\"))))]\n-  \"TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxleqv %x0,%x1,%x2\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && TARGET_P8_VECTOR\n-   && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 3) (not:DI (xor:DI (match_dup 4) (match_dup 5))))\n-   (set (match_dup 6) (not:DI (xor:DI (match_dup 7) (match_dup 8))))]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two\")\n-   (set_attr \"length\" \"4,8,8,8\")])\n-\n-;; Rewrite nand into canonical form\n-(define_insn \"*vsx_nand<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-\t(ior:VSX_L2\n-\t (not:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\"))\n-\t (not:VSX_L2 (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\"))))]\n-  \"!TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxlnand %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_nand<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"register_operand\" \"=wa,?r,?r,?r\")\n-\t(ior:VSX_L\n-\t (not:VSX_L (match_operand:VSX_L 1 \"register_operand\" \"wa,0,r,r\"))\n-\t (not:VSX_L (match_operand:VSX_L 2 \"register_operand\" \"wa,r,0,r\"))))]\n-  \"TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlnand %x0,%x1,%x2\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && TARGET_P8_VECTOR\n-   && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 3) (ior:DI (not:DI (match_dup 4)) (not:DI (match_dup 5))))\n-   (set (match_dup 6) (ior:DI (not:DI (match_dup 7)) (not:DI (match_dup 8))))]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two\")\n-   (set_attr \"length\" \"4,8,8,8\")])\n-\n-;; Rewrite or complement into canonical form, by reversing the arguments\n-(define_insn \"*vsx_orc<mode>3_32bit\"\n-  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n-\t(ior:VSX_L2\n-\t (not:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\"))\n-\t (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))]\n-  \"!TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"xxlorc %x0,%x2,%x1\"\n-  [(set_attr \"type\" \"vecsimple\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn_and_split \"*vsx_orc<mode>3_64bit\"\n-  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,?r\")\n-\t(ior:VSX_L\n-\t (not:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,0,r,r\"))\n-\t (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\")))]\n-  \"TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n-  \"@\n-   xxlorc %x0,%x2,%x1\n-   #\n-   #\n-   #\"\n-  \"reload_completed && TARGET_POWERPC64 && TARGET_P8_VECTOR\n-   && VECTOR_MEM_VSX_P (<MODE>mode)\n-   && int_reg_operand (operands[0], <MODE>mode)\"\n-  [(set (match_dup 3) (ior:DI (not:DI (match_dup 4)) (match_dup 5)))\n-   (set (match_dup 6) (ior:DI (not:DI (match_dup 7)) (match_dup 8)))]\n-{\n-  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n-  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n-  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n-  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n-  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n-  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n-}\n-  [(set_attr \"type\" \"vecsimple,two,two,two\")\n-   (set_attr \"length\" \"4,8,8,8\")])\n-\n \f\n ;; Permute operations\n "}, {"sha": "7b24942e113538ee3e3d04da131583b6ee1907f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -1,3 +1,17 @@\n+2013-07-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/bool2.h: New file, test the code generation\n+\tof logical operations for power5, altivec, power7, and power8\n+\tsystems.\n+\t* gcc.target/powerpc/bool2-p5.c: Likewise.\n+\t* gcc.target/powerpc/bool2-av.c: Likewise.\n+\t* gcc.target/powerpc/bool2-p7.c: Likewise.\n+\t* gcc.target/powerpc/bool2-p8.c: Likewise.\n+\t* gcc.target/powerpc/bool3.h: Likewise.\n+\t* gcc.target/powerpc/bool3-av.c: Likewise.\n+\t* gcc.target/powerpc/bool2-p7.c: Likewise.\n+\t* gcc.target/powerpc/bool2-p8.c: Likewise.\n+\n 2013-07-23  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* gcc.target/aarch64/vect_smlal_1.c: Replace 'long' with 'long long'."}, {"sha": "fc56ce261c84f7daedd65717576104d8d99da5b4", "filename": "gcc/testsuite/gcc.target/powerpc/bool2-av.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-av.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-av.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-av.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-O2 -mcpu=power6 -maltivec\" } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]eqv \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]orc \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]nand \"    } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]vandc \"   } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnand \" } } */\n+\n+#ifndef TYPE\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+\n+#include \"bool2.h\""}, {"sha": "e4810d00d88a2e0e482a651ee5d644c846c38e5f", "filename": "gcc/testsuite/gcc.target/powerpc/bool2-p5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p5.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-O2 -mcpu=power5 -mabi=altivec -mno-altivec -mno-vsx\" } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]eqv \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]orc \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]nand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vandc \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnand \" } } */\n+\n+#ifndef TYPE\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+\n+#include \"bool2.h\""}, {"sha": "274fcb090e2d7bb6446426f77e0dff908c746125", "filename": "gcc/testsuite/gcc.target/powerpc/bool2-p7.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p7.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]eqv \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]orc \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]nand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnand \" } } */\n+\n+#ifndef TYPE\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+\n+#include \"bool2.h\""}, {"sha": "34f4d2df8b2046c08350ad515ceb2700c32a4c76", "filename": "gcc/testsuite/gcc.target/powerpc/bool2-p8.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2-p8.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]eqv \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]orc \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]nand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vandc \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxlnand \" } } */\n+\n+#ifndef TYPE\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+\n+#include \"bool2.h\""}, {"sha": "4513944c2983b0945dbd4b982df60683fda99d4a", "filename": "gcc/testsuite/gcc.target/powerpc/bool2.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool2.h?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,29 @@\n+/* Test various logical operations.  */\n+\n+TYPE arg1 (TYPE p, TYPE q) { return p & q; }\t\t/* AND  */\n+TYPE arg2 (TYPE p, TYPE q) { return p | q; }\t\t/* OR   */\n+TYPE arg3 (TYPE p, TYPE q) { return p ^ q; }\t\t/* XOR  */\n+TYPE arg4 (TYPE p)\t   { return ~ p; }\t\t/* NOR  */\n+TYPE arg5 (TYPE p, TYPE q) { return ~(p & q); }\t\t/* NAND */\n+TYPE arg6 (TYPE p, TYPE q) { return ~(p | q); }\t\t/* NOR  */\n+TYPE arg7 (TYPE p, TYPE q) { return ~(p ^ q); }\t\t/* EQV  */\n+TYPE arg8 (TYPE p, TYPE q) { return (~p) & q; }\t\t/* ANDC */\n+TYPE arg9 (TYPE p, TYPE q) { return (~p) | q; }\t\t/* ORC  */\n+TYPE arg10(TYPE p, TYPE q) { return (~p) ^ q; }\t\t/* EQV  */\n+TYPE arg11(TYPE p, TYPE q) { return p & (~q); }\t\t/* ANDC */\n+TYPE arg12(TYPE p, TYPE q) { return p | (~q); }\t\t/* ORC  */\n+TYPE arg13(TYPE p, TYPE q) { return p ^ (~q); }\t\t/* EQV  */\n+\n+void ptr1 (TYPE *p) { p[0] = p[1] & p[2]; }\t\t/* AND  */\n+void ptr2 (TYPE *p) { p[0] = p[1] | p[2]; }\t\t/* OR   */\n+void ptr3 (TYPE *p) { p[0] = p[1] ^ p[2]; }\t\t/* XOR  */\n+void ptr4 (TYPE *p) { p[0] = ~p[1]; }\t\t\t/* NOR  */\n+void ptr5 (TYPE *p) { p[0] = ~(p[1] & p[2]); }\t\t/* NAND */\n+void ptr6 (TYPE *p) { p[0] = ~(p[1] | p[2]); }\t\t/* NOR  */\n+void ptr7 (TYPE *p) { p[0] = ~(p[1] ^ p[2]); }\t\t/* EQV  */\n+void ptr8 (TYPE *p) { p[0] = ~(p[1]) & p[2]; }\t\t/* ANDC */\n+void ptr9 (TYPE *p) { p[0] = (~p[1]) | p[2]; }\t\t/* ORC  */\n+void ptr10(TYPE *p) { p[0] = (~p[1]) ^ p[2]; }\t\t/* EQV  */\n+void ptr11(TYPE *p) { p[0] = p[1] & (~p[2]); }\t\t/* ANDC */\n+void ptr12(TYPE *p) { p[0] = p[1] | (~p[2]); }\t\t/* ORC  */\n+void ptr13(TYPE *p) { p[0] = p[1] ^ (~p[2]); }\t\t/* EQV  */"}, {"sha": "4ef82c8cd970696f817ac6e229c062543905d884", "filename": "gcc/testsuite/gcc.target/powerpc/bool3-av.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-av.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-av.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-av.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-O2 -mcpu=power6 -mabi=altivec -maltivec -mno-vsx\" } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vandc \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnand \" } } */\n+\n+/* On altivec, for 128-bit types, ORC/ANDC/EQV might not show up, since the\n+   vector unit doesn't support these, so the appropriate combine patterns may\n+   not be generated.  */\n+\n+#ifndef TYPE\n+#ifdef _ARCH_PPC64\n+#define TYPE __int128_t\n+#else\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+#endif\n+\n+#include \"bool3.h\""}, {"sha": "a077ba5aea7c839fadb187dbb17b88203056f69d", "filename": "gcc/testsuite/gcc.target/powerpc/bool3-p7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-p7.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vandc \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnand \" } } */\n+\n+/* On power7, for 128-bit types, ORC/ANDC/EQV might not show up, since the\n+   vector unit doesn't support these, so the appropriate combine patterns may\n+   not be generated.  */\n+\n+#ifndef TYPE\n+#ifdef _ARCH_PPC64\n+#define TYPE __int128_t\n+#else\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+#endif\n+\n+#include \"bool3.h\""}, {"sha": "361a0452d7da3bc9c223549a3276387e952803da", "filename": "gcc/testsuite/gcc.target/powerpc/bool3-p8.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3-p8.c?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]and \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]or \"      } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]xor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]nor \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]andc \"    } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]eqv \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]orc \"     } } */\n+/* { dg-final { scan-assembler\t   \"\\[ \\t\\]nand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vand \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vandc \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vor \"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vxor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]vnor \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxland \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlor \"   } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlxor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnor \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlandc \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxleqv \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlorc \"  } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]xxlnand \" } } */\n+\n+#ifndef TYPE\n+#ifdef _ARCH_PPC64\n+#define TYPE __int128_t\n+#else\n+typedef int v4si __attribute__ ((vector_size (16)));\n+#define TYPE v4si\n+#endif\n+#endif\n+\n+#include \"bool3.h\""}, {"sha": "7b99a4a6103de6cc5735284565dad889342f4487", "filename": "gcc/testsuite/gcc.target/powerpc/bool3.h", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7a40e14c20495d719ad715de00cff5c490fd07/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool3.h?ref=dd7a40e14c20495d719ad715de00cff5c490fd07", "patch": "@@ -0,0 +1,186 @@\n+/* Test forcing 128-bit logical types into GPR registers.  */\n+\n+#if defined(NO_ASM)\n+#define FORCE_REG1(X)\n+#define FORCE_REG2(X,Y)\n+\n+#else\n+#if defined(USE_ALTIVEC)\n+#define REG_CLASS \"+v\"\n+#define PRINT_REG1 \"# altivec reg %0\"\n+#define PRINT_REG2 \"# altivec reg %0, %1\"\n+\n+#elif defined(USE_FPR)\n+#define REG_CLASS \"+d\"\n+#define PRINT_REG1 \"# fpr reg %0\"\n+#define PRINT_REG2 \"# fpr reg %0, %1\"\n+\n+#elif defined(USE_VSX)\n+#define REG_CLASS \"+wa\"\n+#define PRINT_REG1 \"# vsx reg %x0\"\n+#define PRINT_REG2 \"# vsx reg %x0, %x1\"\n+\n+#else\n+#define REG_CLASS \"+r\"\n+#define PRINT_REG1 \"# gpr reg %0\"\n+#define PRINT_REG2 \"# gpr reg %0, %1\"\n+#endif\n+\n+#define FORCE_REG1(X) __asm__ (PRINT_REG1 : REG_CLASS (X))\n+#define FORCE_REG2(X,Y) __asm__ (PRINT_REG2 : REG_CLASS (X), REG_CLASS (Y))\n+#endif\n+\n+void ptr1 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = a & b;\t\t\t\t\t/* AND */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr2 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = a | b;\t\t\t\t\t/* OR */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr3 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = a ^ b;\t\t\t\t\t/* XOR */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr4 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b;\n+\n+  FORCE_REG1 (a);\n+  b = ~a;\t\t\t\t\t/* NOR */\n+  FORCE_REG1 (b);\n+  p[0] = b;\n+}\n+\n+void ptr5 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = ~(a & b);\t\t\t\t\t   /* NAND */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr6 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = ~(a | b);\t\t\t\t\t   /* AND */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr7 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = ~(a ^ b);\t\t\t\t\t   /* EQV */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr8 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = (~a) & b;\t\t\t\t\t   /* ANDC */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr9 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = (~a) | b;\t\t\t\t\t   /* ORC */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr10 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = (~a) ^ b;\t\t\t\t\t   /* EQV */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr11 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = a & (~b);\t\t\t\t\t   /* ANDC */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr12 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = a | (~b);\t\t\t\t\t   /* ORC */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}\n+\n+void ptr13 (TYPE *p)\n+{\n+  TYPE a = p[1];\n+  TYPE b = p[2];\n+  TYPE c;\n+\n+  FORCE_REG2 (a, b);\n+  c = a ^ (~b);\t\t\t\t\t   /* AND */\n+  FORCE_REG1 (c);\n+  p[0] = c;\n+}"}]}