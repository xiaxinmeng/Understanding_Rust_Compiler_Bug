{"sha": "809d661aff99ae0287baf4a52269425de62381e6", "node_id": "C_kwDOANBUbNoAKDgwOWQ2NjFhZmY5OWFlMDI4N2JhZjRhNTIyNjk0MjVkZTYyMzgxZTY", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-01-17T16:14:41Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-01-31T14:56:27Z"}, "message": "Utilize op1 == op2 when invoking range-ops folding.\n\nIf there exists an equivalence relationship between op1 and op2,\nany binary operation can be broken into individual operations and\nunioned if there are sufficently few elements in the set.\n\n\tPR tree-optimization/108359\n\tgcc/\n\t* range-op.cc (range_operator::wi_fold_in_parts_equiv): New.\n\t(range_operator::fold_range): If op1 is equivalent to op2 then\n\tinvoke new fold_in_parts_equiv to operate on sub-components.\n\t* range-op.h (wi_fold_in_parts_equiv): New prototype.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr108359.c: New.", "tree": {"sha": "d3242765ab5da0909362f483e452c6e763bf942c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3242765ab5da0909362f483e452c6e763bf942c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/809d661aff99ae0287baf4a52269425de62381e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809d661aff99ae0287baf4a52269425de62381e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809d661aff99ae0287baf4a52269425de62381e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809d661aff99ae0287baf4a52269425de62381e6/comments", "author": null, "committer": null, "parents": [{"sha": "99fda5de368d84d97eb29a9f03e0d6039068f8b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fda5de368d84d97eb29a9f03e0d6039068f8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99fda5de368d84d97eb29a9f03e0d6039068f8b9"}], "stats": {"total": 112, "additions": 112, "deletions": 0}, "files": [{"sha": "f7c1e84e0bdbdd43423365bd62a32a18bcfde132", "filename": "gcc/range-op.cc", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d661aff99ae0287baf4a52269425de62381e6/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d661aff99ae0287baf4a52269425de62381e6/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=809d661aff99ae0287baf4a52269425de62381e6", "patch": "@@ -160,6 +160,38 @@ range_operator::wi_fold (irange &r, tree type,\n   r.set_varying (type);\n }\n \n+// Call wi_fold when both op1 and op2 are equivalent. Further split small\n+// subranges into constants.  This can provide better precision.\n+// For x + y,  when x == y with a range of [0,4] instead of [0, 8] produce\n+// [0,0][2, 2][4,4][6, 6][8, 8]\n+// LIMIT is the maximum number of elements in range allowed before we\n+// do not processs them individually.\n+\n+void\n+range_operator::wi_fold_in_parts_equiv (irange &r, tree type,\n+\t\t\t\t\tconst wide_int &lh_lb,\n+\t\t\t\t\tconst wide_int &lh_ub,\n+\t\t\t\t\tunsigned limit) const\n+{\n+  int_range_max tmp;\n+  widest_int lh_range = wi::sub (widest_int::from (lh_ub, TYPE_SIGN (type)),\n+\t\t\t\t widest_int::from (lh_lb, TYPE_SIGN (type)));\n+  // if there are 1 to 8 values in the LH range, split them up.\n+  r.set_undefined ();\n+  if (lh_range >= 0 && lh_range < limit)\n+    {\n+      for (unsigned x = 0; x <= lh_range; x++)\n+\t{\n+\t  wide_int val = lh_lb + x;\n+\t  wi_fold (tmp, type, val, val, val, val);\n+\t  r.union_ (tmp);\n+\t}\n+    }\n+  // Otherwise just call wi_fold.\n+  else\n+    wi_fold (r, type, lh_lb, lh_ub, lh_lb, lh_ub);\n+}\n+\n // Call wi_fold, except further split small subranges into constants.\n // This can provide better precision. For something   8 >> [0,1]\n // Instead of [8, 16], we will produce [8,8][16,16]\n@@ -234,6 +266,28 @@ range_operator::fold_range (irange &r, tree type,\n   unsigned num_lh = lh.num_pairs ();\n   unsigned num_rh = rh.num_pairs ();\n \n+  // If op1 and op2 are equivalences, then we don't need a complete cross\n+  // product, just pairs of matching elements.\n+  if (relation_equiv_p (rel) && lh == rh)\n+    {\n+      int_range_max tmp;\n+      r.set_undefined ();\n+      for (unsigned x = 0; x < num_lh; ++x)\n+\t{\n+\t  // If the number of subranges is too high, limit subrange creation.\n+\t  unsigned limit = (r.num_pairs () > 32) ? 0 : 8;\n+\t  wide_int lh_lb = lh.lower_bound (x);\n+\t  wide_int lh_ub = lh.upper_bound (x);\n+\t  wi_fold_in_parts_equiv (tmp, type, lh_lb, lh_ub, limit);\n+\t  r.union_ (tmp);\n+\t  if (r.varying_p ())\n+\t    break;\n+\t}\n+      op1_op2_relation_effect (r, type, lh, rh, rel);\n+      update_known_bitmask (r, m_code, lh, rh);\n+      return true;\n+    }\n+\n   // If both ranges are single pairs, fold directly into the result range.\n   // If the number of subranges grows too high, produce a summary result as the\n   // loop becomes exponential with little benefit.  See PR 103821."}, {"sha": "f00b747f08a1fa8404c63bfe5a931b4048008b03", "filename": "gcc/range-op.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d661aff99ae0287baf4a52269425de62381e6/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d661aff99ae0287baf4a52269425de62381e6/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=809d661aff99ae0287baf4a52269425de62381e6", "patch": "@@ -109,6 +109,12 @@ class range_operator\n \t\t\t const wide_int &rh_lb,\n \t\t\t const wide_int &rh_ub) const;\n \n+  // Called by fold range to split small subranges into parts when op1 == op2\n+  void wi_fold_in_parts_equiv (irange &r, tree type,\n+\t\t\t       const wide_int &lb,\n+\t\t\t       const wide_int &ub,\n+\t\t\t       unsigned limit) const;\n+\n   // Tree code of the range operator or ERROR_MARK if unknown.\n   tree_code m_code;\n };"}, {"sha": "7cf04f7413286e86e21261d18e9e8ae686c18aa5", "filename": "gcc/testsuite/gcc.dg/pr108359.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809d661aff99ae0287baf4a52269425de62381e6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108359.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809d661aff99ae0287baf4a52269425de62381e6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108359.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108359.c?ref=809d661aff99ae0287baf4a52269425de62381e6", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+/* PR test case.  */\n+int b = 10;\n+int c;\n+char e;\n+void foo();\n+static char(a)(char f, char g) { return f && g == 1 ? 0 : f % g; }\n+short(d)(short f, short g) { return f * g; }\n+int main() {\n+  short h;\n+  int i;\n+  unsigned j;\n+  h = d(b && c, 5);\n+  j = h;\n+  i = a(h, 237);\n+  unsigned k = i;\n+  e = i < 0 || k >= 32 ? 0 : i >> k;\n+  if (e) {\n+    c = 0;\n+    foo();\n+  }\n+}\n+\n+\n+/* Also Check that small ranges are broken down and optimized properly\n+   This function should never call foo ().  */\n+\n+int otherfunc (int x, int z) {\n+  if (x < 1 || x > 6 )\n+    return 0;\n+\n+  if (x == z)\n+    {\n+    if (x >> z > 0)\n+      foo ();\n+    if (x * z > 26 && x * z < 35)\n+      foo ();\n+    if (x + z == 5)\n+      foo ();\n+    if ((x + z) % 2 == 1)\n+      foo ();\n+    if (x / z != 1)\n+      foo ();\n+\n+    }\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-not \"foo\" \"optimized\" } } */"}]}