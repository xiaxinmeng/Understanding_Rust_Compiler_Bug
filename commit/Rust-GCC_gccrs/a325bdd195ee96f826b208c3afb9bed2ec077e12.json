{"sha": "a325bdd195ee96f826b208c3afb9bed2ec077e12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMyNWJkZDE5NWVlOTZmODI2YjIwOGMzYWZiOWJlZDJlYzA3N2UxMg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-06-10T18:54:12Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-06-10T21:55:24Z"}, "message": "i386: Add V8QI and other 64bit vector permutations [PR89021]\n\nIn addition to V8QI permutations, several other missing permutations are\nadded for 64bit vector modes for TARGET_SSSE3 and TARGET_SSE4_1 targets.\n\n2021-06-10  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/\n\tPR target/89021\n\t* config/i386/i386-expand.c (ix86_split_mmx_punpck):\n\tHandle V2SF mode.  Emit SHUFPS to fixup unpack-high for V2SF mode.\n\t(expand_vec_perm_blend): Handle 64bit modes for TARGET_SSE4_1.\n\t(expand_vec_perm_pshufb): Handle 64bit modes for TARGET_SSSE3.\n\t(expand_vec_perm_pblendv): Handle 64bit modes for TARGET_SSE4_1.\n\t(expand_vec_perm_interleave2): Handle 64bit modes.\n\t(expand_vec_perm_even_odd_pack): Handle V8QI mode.\n\t(expand_vec_perm_even_odd_1): Ditto.\n\t(ix86_vectorize_vec_perm_const): Ditto.\n\t* config/i386/i386.md (UNSPEC_PSHUFB): Move from ...\n\t* config/i386/sse.md: ... here.\n\t* config/i386/mmx.md (*vec_interleave_lowv2sf):\n\tNew insn_and_split pattern.\n\t(*vec_interleave_highv2sf): Ditto.\n\t(mmx_pshufbv8qi3): New insn pattern.\n\t(*mmx_pblendw): Ditto.", "tree": {"sha": "670cc674c19e2ee2dce4997fac7bb19472b25bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/670cc674c19e2ee2dce4997fac7bb19472b25bd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a325bdd195ee96f826b208c3afb9bed2ec077e12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a325bdd195ee96f826b208c3afb9bed2ec077e12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a325bdd195ee96f826b208c3afb9bed2ec077e12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a325bdd195ee96f826b208c3afb9bed2ec077e12/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee52bf609bac45b3c251858a69071262f46ee89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee52bf609bac45b3c251858a69071262f46ee89c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee52bf609bac45b3c251858a69071262f46ee89c"}], "stats": {"total": 279, "additions": 246, "deletions": 33}, "files": [{"sha": "9ee5257adf9d1fac44f24c7c29c943b1207c69ee", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 167, "deletions": 24, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=a325bdd195ee96f826b208c3afb9bed2ec077e12", "patch": "@@ -798,6 +798,15 @@ ix86_split_mmx_punpck (rtx operands[], bool high_p)\n \t\t\t\t\t  GEN_INT (1), GEN_INT (5)));\n       break;\n \n+    case E_V2SFmode:\n+      sse_mode = V4SFmode;\n+      double_sse_mode = V8SFmode;\n+      mask = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t       gen_rtvec (4,\n+\t\t\t\t\t  GEN_INT (0), GEN_INT (4),\n+\t\t\t\t\t  GEN_INT (1), GEN_INT (5)));\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -812,14 +821,26 @@ ix86_split_mmx_punpck (rtx operands[], bool high_p)\n   rtx insn = gen_rtx_SET (dest, op2);\n   emit_insn (insn);\n \n+  /* Move bits 64:127 to bits 0:63.  */\n   if (high_p)\n     {\n-      /* Move bits 64:127 to bits 0:63.  */\n-      mask = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t       gen_rtvec (4, GEN_INT (2), GEN_INT (3),\n-\t\t\t\t\t  GEN_INT (0), GEN_INT (0)));\n-      dest = lowpart_subreg (V4SImode, dest, GET_MODE (dest));\n-      op1 = gen_rtx_VEC_SELECT (V4SImode, dest, mask);\n+      if (sse_mode == V4SFmode)\n+\t{\n+\t  mask = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t   gen_rtvec (4, GEN_INT (2), GEN_INT (3),\n+\t\t\t\t\t      GEN_INT (4), GEN_INT (5)));\n+\t  op2 = gen_rtx_VEC_CONCAT (V8SFmode, dest, dest);\n+\t  op1 = gen_rtx_VEC_SELECT (V4SFmode, op2, mask);\n+\t}\n+      else\n+\t{\n+\t  mask = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t   gen_rtvec (4, GEN_INT (2), GEN_INT (3),\n+\t\t\t\t\t      GEN_INT (0), GEN_INT (1)));\n+\t  dest = lowpart_subreg (V4SImode, dest, GET_MODE (dest));\n+\t  op1 = gen_rtx_VEC_SELECT (V4SImode, dest, mask);\n+\t}\n+\n       insn = gen_rtx_SET (dest, op1);\n       emit_insn (insn);\n     }\n@@ -17062,7 +17083,8 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n     ;\n   else if (TARGET_AVX && (vmode == V4DFmode || vmode == V8SFmode))\n     ;\n-  else if (TARGET_SSE4_1 && GET_MODE_SIZE (vmode) == 16)\n+  else if (TARGET_SSE4_1 && (GET_MODE_SIZE (vmode) == 16\n+\t\t\t     || GET_MODE_SIZE (vmode) == 8))\n     ;\n   else\n     return false;\n@@ -17095,6 +17117,7 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n     case E_V8SFmode:\n     case E_V2DFmode:\n     case E_V4SFmode:\n+    case E_V4HImode:\n     case E_V8HImode:\n     case E_V8SImode:\n     case E_V32HImode:\n@@ -17111,6 +17134,12 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n       vmode = V8HImode;\n       goto do_subreg;\n \n+    case E_V2SImode:\n+      for (i = 0; i < 2; ++i)\n+\tmask |= (d->perm[i] >= 2 ? 3 : 0) << (i * 2);\n+      vmode = V4HImode;\n+      goto do_subreg;\n+\n     case E_V4SImode:\n       for (i = 0; i < 4; ++i)\n \tmask |= (d->perm[i] >= 4 ? 3 : 0) << (i * 2);\n@@ -17132,7 +17161,9 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n \t    vperm = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rperm));\n \t    vperm = force_reg (vmode, vperm);\n \n-\t    if (GET_MODE_SIZE (vmode) == 16)\n+\t    if (GET_MODE_SIZE (vmode) == 8)\n+\t      emit_insn (gen_mmx_pblendvb64 (target, op0, op1, vperm));\n+\t    else if (GET_MODE_SIZE (vmode) == 16)\n \t      emit_insn (gen_sse4_1_pblendvb (target, op0, op1, vperm));\n \t    else\n \t      emit_insn (gen_avx2_pblendvb (target, op0, op1, vperm));\n@@ -17152,6 +17183,16 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n       op1 = gen_lowpart (vmode, op1);\n       break;\n \n+    case E_V8QImode:\n+      for (i = 0; i < 8; i += 2)\n+\tif (d->perm[i] + 1 != d->perm[i + 1])\n+\t  goto use_pblendvb;\n+\n+      for (i = 0; i < 4; ++i)\n+\tmask |= (d->perm[i * 2] >= 8) << i;\n+      vmode = V4HImode;\n+      goto do_subreg;\n+\n     case E_V32QImode:\n       /* See if bytes move in pairs.  If not, vpblendvb must be used.  */\n       for (i = 0; i < 32; i += 2)\n@@ -17384,7 +17425,13 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n     }\n   else\n     {\n-      if (GET_MODE_SIZE (d->vmode) == 16)\n+      if (GET_MODE_SIZE (d->vmode) == 8)\n+\t{\n+\t  if (!TARGET_SSSE3)\n+\t    return false;\n+\t  vmode = V8QImode;\n+\t}\n+      else if (GET_MODE_SIZE (d->vmode) == 16)\n \t{\n \t  if (!TARGET_SSSE3)\n \t    return false;\n@@ -17506,12 +17553,12 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n       eltsz = GET_MODE_UNIT_SIZE (d->vmode);\n       if (!d->one_operand_p)\n \tmask = 2 * nelt - 1;\n-      else if (vmode == V16QImode)\n-\tmask = nelt - 1;\n       else if (vmode == V64QImode)\n \tmask = nelt / 4 - 1;\n-      else\n+      else if (vmode == V32QImode)\n \tmask = nelt / 2 - 1;\n+      else\n+\tmask = nelt - 1;\n \n       for (i = 0; i < nelt; ++i)\n \t{\n@@ -17521,17 +17568,28 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \t}\n     }\n \n-  vperm = gen_rtx_CONST_VECTOR (vmode,\n-\t\t\t\tgen_rtvec_v (GET_MODE_NUNITS (vmode), rperm));\n-  vperm = force_reg (vmode, vperm);\n+  machine_mode vpmode = vmode;\n+\n+  if (vmode == V8QImode)\n+    {\n+      for (i = nelt; i < 16; ++i)\n+\trperm[i] = constm1_rtx;\n+      vpmode = V16QImode;\n+    }\n+\n+  vperm = gen_rtx_CONST_VECTOR (vpmode,\n+\t\t\t\tgen_rtvec_v (GET_MODE_NUNITS (vpmode), rperm));\n+  vperm = force_reg (vpmode, vperm);\n \n   target = d->target;\n   if (d->vmode != vmode)\n     target = gen_reg_rtx (vmode);\n   op0 = gen_lowpart (vmode, d->op0);\n   if (d->one_operand_p)\n     {\n-      if (vmode == V16QImode)\n+      if (vmode == V8QImode)\n+\temit_insn (gen_mmx_pshufbv8qi3 (target, op0, vperm));\n+      else if (vmode == V16QImode)\n \temit_insn (gen_ssse3_pshufbv16qi3 (target, op0, vperm));\n       else if (vmode == V32QImode)\n \temit_insn (gen_avx2_pshufbv32qi3 (target, op0, vperm));\n@@ -18041,7 +18099,8 @@ expand_vec_perm_pblendv (struct expand_vec_perm_d *d)\n     ;\n   else if (TARGET_AVX && (vmode == V4DFmode || vmode == V8SFmode))\n     ;\n-  else if (TARGET_SSE4_1 && GET_MODE_SIZE (vmode) == 16)\n+  else if (TARGET_SSE4_1 && (GET_MODE_SIZE (vmode) == 8\n+\t\t\t     || GET_MODE_SIZE (vmode) == 16))\n     ;\n   else\n     return false;\n@@ -18120,7 +18179,8 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n   rtx_insn *seq;\n   bool ok, same_halves = false;\n \n-  if (GET_MODE_SIZE (d->vmode) == 16)\n+  if (GET_MODE_SIZE (d->vmode) == 8\n+      || GET_MODE_SIZE (d->vmode) == 16)\n     {\n       if (d->one_operand_p)\n \treturn false;\n@@ -18155,7 +18215,44 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n   memset (remap, 0xff, sizeof (remap));\n   dremap = *d;\n \n-  if (GET_MODE_SIZE (d->vmode) == 16)\n+  if (GET_MODE_SIZE (d->vmode) == 8)\n+    {\n+      unsigned HOST_WIDE_INT h1, h2, h3, h4;\n+\n+      /* Split the two input vectors into 4 halves.  */\n+      h1 = (HOST_WIDE_INT_1U << nelt2) - 1;\n+      h2 = h1 << nelt2;\n+      h3 = h2 << nelt2;\n+      h4 = h3 << nelt2;\n+\n+      /* If the elements from the low halves use interleave low,\n+\t and similarly for interleave high.  */\n+      if ((contents & (h1 | h3)) == contents)\n+\t{\n+\t  /* punpckl* */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i] = i * 2;\n+\t      remap[i + nelt] = i * 2 + 1;\n+\t      dremap.perm[i * 2] = i;\n+\t      dremap.perm[i * 2 + 1] = i + nelt;\n+\t    }\n+\t}\n+      else if ((contents & (h2 | h4)) == contents)\n+\t{\n+\t  /* punpckh* */\n+\t  for (i = 0; i < nelt2; ++i)\n+\t    {\n+\t      remap[i + nelt2] = i * 2;\n+\t      remap[i + nelt + nelt2] = i * 2 + 1;\n+\t      dremap.perm[i * 2] = i + nelt2;\n+\t      dremap.perm[i * 2 + 1] = i + nelt + nelt2;\n+\t    }\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else if (GET_MODE_SIZE (d->vmode) == 16)\n     {\n       unsigned HOST_WIDE_INT h1, h2, h3, h4;\n \n@@ -19328,9 +19425,9 @@ expand_vec_perm_vpshufb2_vpermq_even_odd (struct expand_vec_perm_d *d)\n }\n \n /* A subroutine of expand_vec_perm_even_odd_1.  Implement extract-even\n-   and extract-odd permutations of two V16QI, V8HI, V16HI or V32QI operands\n-   with two \"and\" and \"pack\" or two \"shift\" and \"pack\" insns.  We should\n-   have already failed all two instruction sequences.  */\n+   and extract-odd permutations of two V8QI, V8HI, V16QI, V16HI or V32QI\n+   operands with two \"and\" and \"pack\" or two \"shift\" and \"pack\" insns.\n+   We should have already failed all two instruction sequences.  */\n \n static bool\n expand_vec_perm_even_odd_pack (struct expand_vec_perm_d *d)\n@@ -19359,6 +19456,15 @@ expand_vec_perm_even_odd_pack (struct expand_vec_perm_d *d)\n       gen_pack = gen_sse4_1_packusdw;\n       gen_shift = gen_lshrv4si3;\n       break;\n+    case E_V8QImode:\n+      /* No check as all instructions are SSE2.  */\n+      c = 0xff;\n+      s = 8;\n+      half_mode = V4HImode;\n+      gen_and = gen_andv4hi3;\n+      gen_pack = gen_mmx_packuswb;\n+      gen_shift = gen_lshrv4hi3;\n+      break;\n     case E_V16QImode:\n       /* No check as all instructions are SSE2.  */\n       c = 0xff;\n@@ -19391,8 +19497,8 @@ expand_vec_perm_even_odd_pack (struct expand_vec_perm_d *d)\n       end_perm = true;\n       break;\n     default:\n-      /* Only V8HI, V16QI, V16HI and V32QI modes are more profitable than\n-\t general shuffles.  */\n+      /* Only V8QI, V8HI, V16QI, V16HI and V32QI modes\n+\t are more profitable than general shuffles.  */\n       return false;\n     }\n \n@@ -19621,6 +19727,7 @@ expand_vec_perm_even_odd_1 (struct expand_vec_perm_d *d, unsigned odd)\n \t}\n       break;\n \n+    case E_V8QImode:\n     case E_V16QImode:\n       return expand_vec_perm_even_odd_pack (d);\n \n@@ -19786,6 +19893,41 @@ expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n       /* These are always implementable using standard shuffle patterns.  */\n       gcc_unreachable ();\n \n+    case E_V8QImode:\n+      /* These can be implemented via interleave.  We save one insn by\n+\t stopping once we have promoted to V2SImode and then use pshufd.  */\n+      if (d->testing_p)\n+\treturn true;\n+      do\n+\t{\n+\t  rtx dest;\n+\t  rtx (*gen) (rtx, rtx, rtx)\n+\t    = vmode == V8QImode ? gen_mmx_punpcklbw\n+\t\t\t\t: gen_mmx_punpcklwd;\n+\n+\t  if (elt >= nelt2)\n+\t    {\n+\t      gen = vmode == V8QImode ? gen_mmx_punpckhbw\n+\t\t\t\t      : gen_mmx_punpckhwd;\n+\t      elt -= nelt2;\n+\t    }\n+\t  nelt2 /= 2;\n+\n+\t  dest = gen_reg_rtx (vmode);\n+\t  emit_insn (gen (dest, op0, op0));\n+\t  vmode = get_mode_wider_vector (vmode);\n+\t  op0 = gen_lowpart (vmode, dest);\n+\t}\n+      while (vmode != V2SImode);\n+\n+      memset (perm2, elt, 2);\n+      dest = gen_reg_rtx (V2SImode);\n+      ok = expand_vselect (dest, op0, perm2, 2, d->testing_p);\n+      gcc_assert (ok);\n+      if (!d->testing_p)\n+\temit_move_insn (d->target, gen_lowpart (d->vmode, dest));\n+      return true;\n+\n     case E_V8HImode:\n     case E_V16QImode:\n       /* These can be implemented via interleave.  We save one insn by\n@@ -20289,6 +20431,7 @@ ix86_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n     case E_V2SFmode:\n     case E_V2SImode:\n     case E_V4HImode:\n+    case E_V8QImode:\n       if (!TARGET_MMX_WITH_SSE)\n \treturn false;\n       break;"}, {"sha": "7743c61ec865493dde5736a9d4c2ff426492cb34", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a325bdd195ee96f826b208c3afb9bed2ec077e12", "patch": "@@ -119,6 +119,7 @@\n   UNSPEC_MASKMOV\n   UNSPEC_MOVMSK\n   UNSPEC_BLENDV\n+  UNSPEC_PSHUFB\n   UNSPEC_RCP\n   UNSPEC_RSQRT\n   UNSPEC_PSADBW"}, {"sha": "f9e7d2786c6c2e1340d8d4a597379ba9d8eef168", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=a325bdd195ee96f826b208c3afb9bed2ec077e12", "patch": "@@ -1198,6 +1198,40 @@\n    (set_attr \"prefix\" \"maybe_vex,orig\")\n    (set_attr \"mode\" \"V4SF\")])\n \n+(define_insn_and_split \"*vec_interleave_lowv2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"=x,v\")\n+\t(vec_select:V2SF\n+\t  (vec_concat:V4SF\n+\t    (match_operand:V2SF 1 \"register_operand\" \"0,v\")\n+\t    (match_operand:V2SF 2 \"register_operand\" \"x,v\"))\n+\t  (parallel [(const_int 0) (const_int 2)])))]\n+  \"TARGET_MMX_WITH_SSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_mmx_punpck (operands, false); DONE;\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix\" \"orig,maybe_evex\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn_and_split \"*vec_interleave_highv2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"=x,v\")\n+\t(vec_select:V2SF\n+\t  (vec_concat:V4SF\n+\t    (match_operand:V2SF 1 \"register_operand\" \"0,v\")\n+\t    (match_operand:V2SF 2 \"register_operand\" \"x,v\"))\n+\t  (parallel [(const_int 1) (const_int 3)])))]\n+  \"TARGET_MMX_WITH_SSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_mmx_punpck (operands, true); DONE;\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n (define_insn \"*vec_dupv2sf\"\n   [(set (match_operand:V2SF 0 \"register_operand\" \"=y,Yv,x\")\n \t(vec_duplicate:V2SF\n@@ -2415,7 +2449,7 @@\n    pack<s_trunsuffix>swb\\t{%2, %0|%0, %2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_pack (operands, <any_s_truncate:CODE>); DONE;\"\n@@ -2435,7 +2469,7 @@\n    packssdw\\t{%2, %0|%0, %2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_pack (operands, SS_TRUNCATE); DONE;\"\n@@ -2458,7 +2492,7 @@\n    punpckhbw\\t{%2, %0|%0, %2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_punpck (operands, true); DONE;\"\n@@ -2481,7 +2515,7 @@\n    punpcklbw\\t{%2, %0|%0, %k2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_punpck (operands, false); DONE;\"\n@@ -2502,7 +2536,7 @@\n    punpckhwd\\t{%2, %0|%0, %2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_punpck (operands, true); DONE;\"\n@@ -2523,7 +2557,7 @@\n    punpcklwd\\t{%2, %0|%0, %k2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_punpck (operands, false); DONE;\"\n@@ -2544,7 +2578,7 @@\n    punpckhdq\\t{%2, %0|%0, %2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_punpck (operands, true); DONE;\"\n@@ -2565,7 +2599,7 @@\n    punpckldq\\t{%2, %0|%0, %k2}\n    #\n    #\"\n-  \"TARGET_SSE2 && reload_completed\n+  \"&& reload_completed\n    && SSE_REGNO_P (REGNO (operands[0]))\"\n   [(const_int 0)]\n   \"ix86_split_mmx_punpck (operands, false); DONE;\"\n@@ -2756,6 +2790,24 @@\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_insn \"mmx_pshufbv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=x,Yw\")\n+\t(unspec:V8QI\n+\t  [(match_operand:V8QI 1 \"register_operand\" \"0,Yw\")\n+\t   (match_operand:V16QI 2 \"vector_operand\" \"xBm,Ywm\")]\n+\t  UNSPEC_PSHUFB))]\n+  \"TARGET_SSSE3 && TARGET_MMX_WITH_SSE\"\n+  \"@\n+   pshufb\\t{%2, %0|%0, %2}\n+   vpshufb\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_data16\" \"1,*\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"prefix\" \"orig,maybe_evex\")\n+   (set_attr \"btver2_decode\" \"vector\")\n+   (set_attr \"mode\" \"TI\")])\n+\n (define_expand \"mmx_pshufw\"\n   [(match_operand:V4HI 0 \"register_operand\")\n    (match_operand:V4HI 1 \"register_mmxmem_operand\")\n@@ -2828,6 +2880,24 @@\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_insn \"*mmx_pblendw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=Yr,*x,x\")\n+\t(vec_merge:V4HI\n+\t  (match_operand:V4HI 2 \"register_operand\" \"Yr,*x,x\")\n+\t  (match_operand:V4HI 1 \"register_operand\" \"0,0,x\")\n+\t  (match_operand:SI 3 \"const_0_to_63_operand\" \"n,n,n\")))]\n+  \"TARGET_SSE4_1 && TARGET_MMX_WITH_SSE\"\n+  \"@\n+   pblendw\\t{%3, %2, %0|%0, %2, %3}\n+   pblendw\\t{%3, %2, %0|%0, %2, %3}\n+   vpblendw\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"isa\" \"noavx,noavx,avx\")\n+   (set_attr \"type\" \"ssemov\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"orig,orig,vex\")\n+   (set_attr \"mode\" \"TI\")])\n+\n ;; Optimize V2SImode load from memory, swapping the elements and\n ;; storing back into the memory into DImode rotate of the memory by 32.\n (define_split"}, {"sha": "8403a07839f64a814f7c5d3fda279f4062d080b9", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a325bdd195ee96f826b208c3afb9bed2ec077e12/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=a325bdd195ee96f826b208c3afb9bed2ec077e12", "patch": "@@ -28,7 +28,6 @@\n   UNSPEC_LDDQU\n \n   ;; SSSE3\n-  UNSPEC_PSHUFB\n   UNSPEC_PSIGN\n   UNSPEC_PALIGNR\n "}]}