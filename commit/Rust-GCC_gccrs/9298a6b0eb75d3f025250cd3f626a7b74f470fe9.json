{"sha": "9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI5OGE2YjBlYjc1ZDNmMDI1MjUwY2QzZjYyNmE3Yjc0ZjQ3MGZlOQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-15T21:56:13Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-15T21:56:13Z"}, "message": "sched.c (reemit_notes): Add prototype.\n\n\t* sched.c (reemit_notes): Add prototype.\n\t(sched_analyze_2): Reorganize comments.  Call prev_nonnote_insn.\n\t(sched_analyze): Add abort call.\n\t(schedule_block): Undo last patch.  Call prev_nonnote_insn.\n\tMove call of reemit_notes to after SCHED_GROUP_P scheduling.\n\tSet `head' to `last'.\n\nFrom-SVN: r10998", "tree": {"sha": "de7952d56c213a49c5ea70b5a8ba9ec83b60f099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de7952d56c213a49c5ea70b5a8ba9ec83b60f099"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9298a6b0eb75d3f025250cd3f626a7b74f470fe9/comments", "author": null, "committer": null, "parents": [{"sha": "0f6453027705a3eeafe0a6b521624a75d7a7f58b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6453027705a3eeafe0a6b521624a75d7a7f58b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f6453027705a3eeafe0a6b521624a75d7a7f58b"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "99c9e026ef84cbd55499fc1b90b3cd61a5ed6734", "filename": "gcc/sched.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9298a6b0eb75d3f025250cd3f626a7b74f470fe9/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9298a6b0eb75d3f025250cd3f626a7b74f470fe9/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "patch": "@@ -333,6 +333,7 @@ static rtx unlink_notes\t\t\tPROTO((rtx, rtx));\n static int new_sometimes_live\t\tPROTO((struct sometimes *, int, int,\n \t\t\t\t\t       int));\n static void finish_sometimes_live\tPROTO((struct sometimes *, int));\n+static rtx reemit_notes\t\t\tPROTO((rtx, rtx));\n static void schedule_block\t\tPROTO((int, FILE *));\n static rtx regno_use_in\t\t\tPROTO((int, rtx));\n static void split_hard_reg_notes\tPROTO((rtx, rtx, rtx, rtx));\n@@ -1843,22 +1844,19 @@ sched_analyze_2 (x, insn)\n       {\n \trtx link, prev;\n \n+\t/* User of CC0 depends on immediately preceding insn.  */\n+\tSCHED_GROUP_P (insn) = 1;\n+\n \t/* There may be a note before this insn now, but all notes will\n \t   be removed before we actually try to schedule the insns, so\n \t   it won't cause a problem later.  We must avoid it here though.  */\n-\n-\t/* User of CC0 depends on immediately preceding insn.  */\n-\tSCHED_GROUP_P (insn) = 1;\n+\tprev = prev_nonnote_insn (insn);\n \n \t/* Make a copy of all dependencies on the immediately previous insn,\n \t   and add to this insn.  This is so that all the dependencies will\n \t   apply to the group.  Remove an explicit dependence on this insn\n \t   as SCHED_GROUP_P now represents it.  */\n \n-\tprev = PREV_INSN (insn);\n-\twhile (GET_CODE (prev) == NOTE)\n-\t  prev = PREV_INSN (prev);\n-\n \tif (find_insn_list (prev, LOG_LINKS (insn)))\n \t  remove_dependence (insn, prev);\n \n@@ -2288,6 +2286,8 @@ sched_analyze (head, tail)\n       if (insn == tail)\n \treturn n_insns;\n     }\n+\n+  abort ();\n }\n \f\n /* Called when we see a set of a register.  If death is true, then we are\n@@ -3168,7 +3168,7 @@ schedule_block (b, file)\n {\n   rtx insn, last;\n   rtx *ready, link;\n-  int i, j, n_ready = 0, new_ready, n_insns = 0;\n+  int i, j, n_ready = 0, new_ready, n_insns;\n   int sched_n_insns = 0;\n   int clock;\n #define NEED_NOTHING\t0\n@@ -3285,7 +3285,7 @@ schedule_block (b, file)\n \n   LOG_LINKS (sched_before_next_call) = 0;\n \n-  n_insns += sched_analyze (head, tail);\n+  n_insns = sched_analyze (head, tail);\n   if (n_insns == 0)\n     {\n       free_pending_lists ();\n@@ -3379,9 +3379,7 @@ schedule_block (b, file)\n \t    {\n \t      while (SCHED_GROUP_P (insn))\n \t\t{\n-\t\t  insn = PREV_INSN (insn);\n-\t\t  while (GET_CODE (insn) == NOTE)\n-\t\t    insn = PREV_INSN (insn);\n+\t\t  insn = prev_nonnote_insn (insn);\n \t\t  priority (insn);\n \t\t}\n \t      continue;\n@@ -3910,18 +3908,6 @@ schedule_block (b, file)\n       NEXT_INSN (insn) = last;\n       PREV_INSN (last) = insn;\n \n-      /* Maintain a valid chain so emit_note_before works.\n-\t This is necessary because PREV_INSN (insn) isn't valid and\n-\t if it points to an insn already scheduled, a circularity\n-\t will result.  */\n-      NEXT_INSN (prev_head) = insn;\n-      PREV_INSN (insn) = prev_head;\n-\n-      last = insn;\n-\n-      /* Check to see if we need to re-emit any notes here.  */\n-      last = reemit_notes (insn, last);\n-\n       /* Everything that precedes INSN now either becomes \"ready\", if\n \t it can execute immediately before INSN, or \"pending\", if\n \t there must be a delay.  Give INSN high enough priority that\n@@ -3947,30 +3933,42 @@ schedule_block (b, file)\n \n \t  /* Now handle each group insn like the main insn was handled\n \t     above.  */\n-\t  while (SCHED_GROUP_P (insn))\n+\t  link = insn;\n+\t  while (SCHED_GROUP_P (link))\n \t    {\n-\t      insn = PREV_INSN (insn);\n+\t      link = PREV_INSN (link);\n \n \t      sched_n_insns += 1;\n-\t      NEXT_INSN (insn) = last;\n-\t      PREV_INSN (last) = insn;\n \n-\t      /* Maintain a valid chain so emit_note_before works.\n-\t\t This is necessary because PREV_INSN (insn) isn't valid and\n-\t\t if it points to an insn already scheduled, a circularity\n-\t\t will result.  */\n-\t      NEXT_INSN (prev_head) = insn;\n-\t      PREV_INSN (insn) = prev_head;\n+\t      /* ??? Why don't we set LAUNCH_PRIORITY here?  */\n+\t      new_ready = schedule_insn (link, ready, new_ready, clock);\n+\t      INSN_PRIORITY (link) = DONE_PRIORITY;\n+\t    }\n+\t}\n \n-\t      last = insn;\n+      /* Put back NOTE_INSN_SETJMP, NOTE_INSN_LOOP_BEGIN, and\n+\t NOTE_INSN_LOOP_END notes.  */\n \n-\t      last = reemit_notes (insn, last);\n+      /* To prime the loop.  We need to handle INSN and all the insns in the\n+         sched group.  */\n+      last = NEXT_INSN (insn);\n+      do\n+\t{\n+\t  insn = PREV_INSN (last);\n \n-\t      /* ??? Why don't we set LAUNCH_PRIORITY here?  */\n-\t      new_ready = schedule_insn (insn, ready, new_ready, clock);\n-\t      INSN_PRIORITY (insn) = DONE_PRIORITY;\n+\t  /* Maintain a valid chain so emit_note_before works.\n+\t     This is necessary because PREV_INSN (insn) isn't valid\n+\t     (if ! SCHED_GROUP_P) and if it points to an insn already\n+\t     scheduled, a circularity will result.  */\n+\t  if (! SCHED_GROUP_P (insn))\n+\t    {\n+\t      NEXT_INSN (prev_head) = insn;\n+\t      PREV_INSN (insn) = prev_head;\n \t    }\n+\n+\t  last = reemit_notes (insn, insn);\n \t}\n+      while (SCHED_GROUP_P (insn));\n     }\n   if (q_size != 0)\n     abort ();\n@@ -3981,7 +3979,7 @@ schedule_block (b, file)\n   /* HEAD is now the first insn in the chain of insns that\n      been scheduled by the loop above.\n      TAIL is the last of those insns.  */\n-  head = insn;\n+  head = last;\n \n   /* NOTE_LIST is the end of a chain of notes previously found\n      among the insns.  Insert them at the beginning of the insns.  */\n@@ -4802,6 +4800,8 @@ schedule_insns (dump_file)\n \n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n      known why this is done.  */\n+  /* ??? Perhaps it's done to ensure NEXT_TAIL in schedule_block is a\n+     valid insn.  */\n \n   insn = basic_block_end[n_basic_blocks-1];\n   if (NEXT_INSN (insn) == 0"}]}