{"sha": "6578c101b5225a13cb0ab326fd5246eaea01962b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU3OGMxMDFiNTIyNWExM2NiMGFiMzI2ZmQ1MjQ2ZWFlYTAxOTYyYg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-03-01T12:44:57Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-03-01T12:44:57Z"}, "message": "tree-vrp.c (extract_range_from_assert): Remove special handling for types with super-types.\n\n\n\t* tree-vrp.c (extract_range_from_assert): Remove special\n\thandling for types with super-types.\n\nFrom-SVN: r111600", "tree": {"sha": "db6d871810628421ff378265e3d4e200cc4c4b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db6d871810628421ff378265e3d4e200cc4c4b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6578c101b5225a13cb0ab326fd5246eaea01962b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6578c101b5225a13cb0ab326fd5246eaea01962b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6578c101b5225a13cb0ab326fd5246eaea01962b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6578c101b5225a13cb0ab326fd5246eaea01962b/comments", "author": null, "committer": null, "parents": [{"sha": "c1fa1ae9be95a9d02b0f584387cbfb646f7383cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fa1ae9be95a9d02b0f584387cbfb646f7383cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fa1ae9be95a9d02b0f584387cbfb646f7383cd"}], "stats": {"total": 65, "additions": 5, "deletions": 60}, "files": [{"sha": "b141b3ede910bc5137f3bd9e5305d3849cfcba9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6578c101b5225a13cb0ab326fd5246eaea01962b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6578c101b5225a13cb0ab326fd5246eaea01962b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6578c101b5225a13cb0ab326fd5246eaea01962b", "patch": "@@ -1,3 +1,8 @@\n+2006-03-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-vrp.c (extract_range_from_assert): Remove special\n+\thandling for types with super-types.\n+\n 2006-03-01  Ben Elliston  <bje@au.ibm.com>\n \n \t* config.gcc: Add t-dfprules to $tmake_file for powerpc-*-linux*"}, {"sha": "96a18277349735cd0b09d13c644abb744972efa1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6578c101b5225a13cb0ab326fd5246eaea01962b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6578c101b5225a13cb0ab326fd5246eaea01962b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6578c101b5225a13cb0ab326fd5246eaea01962b", "patch": "@@ -826,66 +826,6 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  || symbolic_range_p (limit_vr)))\n     limit_vr = NULL;\n \n-  /* Special handling for integral types with super-types.  Some FEs\n-     construct integral types derived from other types and restrict\n-     the range of values these new types may take.\n-\n-     It may happen that LIMIT is actually smaller than TYPE's minimum\n-     value.  For instance, the Ada FE is generating code like this\n-     during bootstrap:\n-\n-\t    D.1480_32 = nam_30 - 300000361;\n-\t    if (D.1480_32 <= 1) goto <L112>; else goto <L52>;\n-\t    <L112>:;\n-\t    D.1480_94 = ASSERT_EXPR <D.1480_32, D.1480_32 <= 1>;\n-\n-     All the names are of type types__name_id___XDLU_300000000__399999999\n-     which has min == 300000000 and max == 399999999.  This means that\n-     the ASSERT_EXPR would try to create the range [3000000, 1] which\n-     is invalid.\n-\n-     The fact that the type specifies MIN and MAX values does not\n-     automatically mean that every variable of that type will always\n-     be within that range, so the predicate may well be true at run\n-     time.  If we had symbolic -INF and +INF values, we could\n-     represent this range, but we currently represent -INF and +INF\n-     using the type's min and max values.\n-\t \n-     So, the only sensible thing we can do for now is set the\n-     resulting range to VR_VARYING.  TODO, would having symbolic -INF\n-     and +INF values be worth the trouble?  */\n-  if (TREE_CODE (limit) != SSA_NAME\n-      && INTEGRAL_TYPE_P (type)\n-      && TREE_TYPE (type))\n-    {\n-      if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n-\t{\n-\t  tree type_min = TYPE_MIN_VALUE (type);\n-\t  int cmp = compare_values (limit, type_min);\n-\n-\t  /* For < or <= comparisons, if LIMIT is smaller than\n-\t     TYPE_MIN, set the range to VR_VARYING.  */\n-\t  if (cmp == -1 || cmp == 0)\n-\t    {\n-\t      set_value_range_to_varying (vr_p);\n-\t      return;\n-\t    }\n-\t}\n-      else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n-\t{\n-\t  tree type_max = TYPE_MIN_VALUE (type);\n-\t  int cmp = compare_values (limit, type_max);\n-\n-\t  /* For > or >= comparisons, if LIMIT is bigger than\n-\t     TYPE_MAX, set the range to VR_VARYING.  */\n-\t  if (cmp == 1 || cmp == 0)\n-\t    {\n-\t      set_value_range_to_varying (vr_p);\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n   /* Initially, the new range has the same set of equivalences of\n      VAR's range.  This will be revised before returning the final\n      value.  Since assertions may be chained via mutually exclusive"}]}