{"sha": "2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVhODQ0ZDM5NGEyZjFjYzFjNGNiY2I0M2RiYWYwNjhiOGRiZDlhNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-10-16T01:23:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-10-16T01:23:23Z"}, "message": "alpha.c (final_prescan_insn): Gut, remove and transform to ...\n\n        * alpha.c (final_prescan_insn): Gut, remove and transform to ...\n        (alpha_handle_trap_shadows): ... a new function.  Handle the entire\n        function in one go.  Emit RTL for trapb, instead of printf directly.\n        (alpha_reorg): New function.  Call alpha_handle_trap_shadows.\n        (trap_pending): Kill global variable.\n        (output_epilog): Don't call final_prescan_insn.\n        (struct shadow_summary): Elide $31 and $f31; now it fits in a word.\n        * alpha.h (FINAL_PRESCAN_INSN): Remove.\n        (MACHINE_DEPENENT_REORG): Define.\n        * alpha.md (jsr patterns with trapb): Stupid and useless.  Kill.\n        (trapb): New insn.\n\nFrom-SVN: r15917", "tree": {"sha": "3c5866969f731e54eba0b87c2304d5ce11eb5d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c5866969f731e54eba0b87c2304d5ce11eb5d0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/comments", "author": null, "committer": null, "parents": [{"sha": "74835ed802e467c2459e3cf289494358ecf65c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74835ed802e467c2459e3cf289494358ecf65c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74835ed802e467c2459e3cf289494358ecf65c56"}], "stats": {"total": 303, "additions": 163, "deletions": 140}, "files": [{"sha": "368d21281dfc90eac101087d1738fdf8cb06af80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "patch": "@@ -1,3 +1,17 @@\n+Wed Oct 15 18:21:46 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (final_prescan_insn): Gut, remove and transform to ...\n+\t(alpha_handle_trap_shadows): ... a new function.  Handle the entire\n+\tfunction in one go.  Emit RTL for trapb, instead of printf directly.\n+\t(alpha_reorg): New function.  Call alpha_handle_trap_shadows.\n+\t(trap_pending): Kill global variable.\n+\t(output_epilog): Don't call final_prescan_insn.\n+\t(struct shadow_summary): Elide $31 and $f31; now it fits in a word.\n+\t* alpha.h (FINAL_PRESCAN_INSN): Remove.\n+\t(MACHINE_DEPENENT_REORG): Define.\n+\t* alpha.md (jsr patterns with trapb): Stupid and useless.  Kill.\n+\t(trapb): New insn.\n+\n Wed Oct 15 18:16:05 1997  Richard Henderson  <rth@cygnus.com>\n \n \tTune Haifa scheduler for Alpha:"}, {"sha": "28435f955f78d69a6707e3607acecf1edac290dc", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 138, "deletions": 106, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "patch": "@@ -75,10 +75,6 @@ char *alpha_function_name;\n \n static int inside_function = FALSE;\n \n-/* Non-zero if an instruction that may cause a trap is pending.  */\n-\n-static int trap_pending = 0;\n-\n /* Nonzero if the current function needs gp.  */\n \n int alpha_function_needs_gp;\n@@ -2599,8 +2595,6 @@ output_epilog (file, size)\n       int fp_offset = 0;\n       int sa_reg;\n \n-      final_prescan_insn (NULL_RTX, NULL_PTR, 0);\n-\n       /* If we have a frame pointer, restore SP from it.  */\n       if (frame_pointer_needed)\n \tfprintf (file, \"\\tbis $15,$15,$30\\n\");\n@@ -2791,8 +2785,8 @@ alpha_output_lineno (stream, line)\n struct shadow_summary\n {\n   struct {\n-    unsigned long i     : 32;\t/* Mask of int regs */\n-    unsigned long fp    : 32;\t/* Mask of fp regs */\n+    unsigned long i     : 31;\t/* Mask of int regs */\n+    unsigned long fp    : 31;\t/* Mask of fp regs */\n     unsigned long mem   :  1;\t/* mem == imem | fpmem */\n   } used, defd;\n };\n@@ -2915,19 +2909,9 @@ summarize_insn (x, sum, set)\n \t  }\n     }\n }\n-\f\n-/* This function is executed just prior to the output of assembler code for\n-   INSN to modify the extracted operands so they will be output differently.\n-\n-   OPVEC is the vector containing the operands extracted from INSN, and\n-   NOPERANDS is the number of elements of the vector which contain meaningful\n-   data for this insn.  The contents of this vector are what will be used to\n-   convert the insn template into assembler code, so you can change the\n-   assembler output by changing the contents of the vector.\n \n-   We use this function to ensure a sufficient number of `trapb' instructions\n-   are in the code when the user requests code with a trap precision of\n-   functions or instructions.\n+/* Ensure a sufficient number of `trapb' insns are in the code when the user\n+   requests code with a trap precision of functions or instructions.\n \n    In naive mode, when the user requests a trap-precision of \"instruction\", a\n    trapb is needed after every instruction that may generate a trap (and after\n@@ -2953,103 +2937,151 @@ summarize_insn (x, sum, set)\n    (c) Within the trap shadow, no register may be used more than once as a\n    destination register.  (This is to make life easier for the trap-handler.)\n \n-   (d) The trap shadow may not include any branch instructions.\n-\n-     */\n+   (d) The trap shadow may not include any branch instructions.  */\n \n-void\n-final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx *opvec;\n-     int noperands;\n+static void\n+alpha_handle_trap_shadows (insns)\n+     rtx insns;\n {\n-  static struct shadow_summary shadow = {0, 0, 0, 0, 0};\n+  struct shadow_summary shadow;\n+  int trap_pending, exception_nesting;\n+  rtx i;\n \n-#define CLOSE_SHADOW\t\t\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fputs (\"\\ttrapb\\n\", asm_out_file);\t\\\n-      trap_pending = 0;\t\t\t\t\\\n-      bzero ((char *) &shadow,  sizeof shadow);\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-  if (alpha_tp == ALPHA_TP_PROG)\n+  if (alpha_tp == ALPHA_TP_PROG && !flag_exceptions)\n     return;\n \n-  if (trap_pending)\n-    switch (alpha_tp)\n-      {\n-      case ALPHA_TP_FUNC:\n-\t/* Generate one trapb before epilogue (indicated by INSN==0) */\n-\tif (insn == 0)\n-\t  CLOSE_SHADOW;\n-\tbreak;\n-\n-      case ALPHA_TP_INSN:\n-\tif (optimize && insn != 0)\n-\t  {\n-\t    struct shadow_summary sum = {0, 0, 0};\n-\n-\t    switch (GET_CODE(insn))\n-\t      {\n-\t      case INSN:\n-\t\tsummarize_insn (PATTERN (insn), &sum, 0);\n-\n-\t\tif ((sum.defd.i & shadow.defd.i)\n-\t\t    || (sum.defd.fp & shadow.defd.fp))\n-\t\t  {\n-\t\t    /* (c) would be violated */\n-\t\t    CLOSE_SHADOW;\n-\t\t    break;\n-\t\t  }\n-\n-\t\t/* Combine shadow with summary of current insn: */\n-\t\tshadow.used.i     |= sum.used.i;\n-\t\tshadow.used.fp    |= sum.used.fp;\n-\t\tshadow.used.mem   |= sum.used.mem;\n-\t\tshadow.defd.i     |= sum.defd.i;\n-\t\tshadow.defd.fp    |= sum.defd.fp;\n-\t\tshadow.defd.mem   |= sum.defd.mem;\n-\n-\t\tif ((sum.defd.i & shadow.used.i)\n-\t\t    || (sum.defd.fp & shadow.used.fp)\n-\t\t    || (sum.defd.mem & shadow.used.mem))\n-\t\t  {\n-\t\t    /* (a) would be violated (also takes care of (b)).  */\n-\t\t    if (get_attr_trap (insn) == TRAP_YES\n-\t\t\t&& ((sum.defd.i & sum.used.i)\n-\t\t\t    || (sum.defd.fp & sum.used.fp)))\n+  trap_pending = 0;\n+  exception_nesting = 0;\n+  shadow.used.i = 0;\n+  shadow.used.fp = 0;\n+  shadow.used.mem = 0;\n+  shadow.defd = shadow.used;\n+  \n+  for (i = insns; i ; i = NEXT_INSN (i))\n+    {\n+      if (GET_CODE (i) == NOTE)\n+\t{\n+\t  switch (NOTE_LINE_NUMBER (i))\n+\t    {\n+\t    case NOTE_INSN_EH_REGION_BEG:\n+\t      exception_nesting++;\n+\t      if (trap_pending)\n+\t\tgoto close_shadow;\n+\t      break;\n+\n+\t    case NOTE_INSN_EH_REGION_END:\n+\t      exception_nesting--;\n+\t      if (trap_pending)\n+\t\tgoto close_shadow;\n+\t      break;\n+\n+\t    case NOTE_INSN_EPILOGUE_BEG:\n+\t      if (trap_pending && alpha_tp >= ALPHA_TP_FUNC)\n+\t\tgoto close_shadow;\n+\t      break;\n+\t    }\n+\t}\n+      else if (trap_pending)\n+\t{\n+\t  if (alpha_tp == ALPHA_TP_FUNC)\n+\t    {\n+\t      if (GET_CODE (i) == JUMP_INSN\n+\t\t  && GET_CODE (PATTERN (i)) == RETURN)\n+\t\tgoto close_shadow;\n+\t    }\n+\t  else if (alpha_tp == ALPHA_TP_INSN)\n+\t    {\n+\t      if (optimize > 0)\n+\t\t{\n+\t\t  struct shadow_summary sum;\n+\n+\t\t  sum.used.i = 0;\n+\t\t  sum.used.fp = 0;\n+\t\t  sum.used.mem = 0;\n+\t\t  sum.defd = shadow.used;\n+\n+\t\t  switch (GET_CODE (i))\n+\t\t    {\n+\t\t    case INSN:\n+\t\t      /* Annoyingly, get_attr_trap will abort on USE.  */\n+\t\t      if (GET_CODE (PATTERN (i)) == USE)\n+\t\t\tbreak;\n+\n+\t\t      summarize_insn (PATTERN (i), &sum, 0);\n+\n+\t\t      if ((sum.defd.i & shadow.defd.i)\n+\t\t\t  || (sum.defd.fp & shadow.defd.fp))\n+\t\t\t{\n+\t\t\t  /* (c) would be violated */\n+\t\t\t  goto close_shadow;\n+\t\t\t}\n+\n+\t\t      /* Combine shadow with summary of current insn: */\n+\t\t      shadow.used.i   |= sum.used.i;\n+\t\t      shadow.used.fp  |= sum.used.fp;\n+\t\t      shadow.used.mem |= sum.used.mem;\n+\t\t      shadow.defd.i   |= sum.defd.i;\n+\t\t      shadow.defd.fp  |= sum.defd.fp;\n+\t\t      shadow.defd.mem |= sum.defd.mem;\n+\n+\t\t      if ((sum.defd.i & shadow.used.i)\n+\t\t\t  || (sum.defd.fp & shadow.used.fp)\n+\t\t\t  || (sum.defd.mem & shadow.used.mem))\n+\t\t\t{\n+\t\t\t  /* (a) would be violated (also takes care of (b))  */\n+\t\t\t  if (get_attr_trap (i) == TRAP_YES\n+\t\t\t      && ((sum.defd.i & sum.used.i)\n+\t\t\t\t  || (sum.defd.fp & sum.used.fp)))\n+\t\t\t    abort ();\n+\n+\t\t\t  goto close_shadow;\n+\t\t\t}\n+\t\t      break;\n+\n+\t\t    case JUMP_INSN:\n+\t\t    case CALL_INSN:\n+\t\t    case CODE_LABEL:\n+\t\t      goto close_shadow;\n+\n+\t\t    default:\n \t\t      abort ();\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\tclose_shadow:\n+\t\t  emit_insn_before (gen_trapb (), i);\n+\t\t  trap_pending = 0;\n+\t\t  shadow.used.i = 0;\n+\t\t  shadow.used.fp = 0;\n+\t\t  shadow.used.mem = 0;\n+\t\t  shadow.defd = shadow.used;\n+\t\t}\n+\t    }\n+\t}\n \n-\t\t    CLOSE_SHADOW;\n-\t\t    break;\n-\t\t  }\n-\t\tbreak;\n-\n-\t      case JUMP_INSN:\n-\t      case CALL_INSN:\n-\t      case CODE_LABEL:\n-\t\tCLOSE_SHADOW;\n-\t\tbreak;\n-\n-\t      default:\n-\t\tabort ();\n-\t      }\n+      if (exception_nesting > 0 || alpha_tp >= ALPHA_TP_FUNC)\n+\tif (GET_CODE (i) == INSN\n+\t    && GET_CODE (PATTERN (i)) != USE\n+\t    && get_attr_trap (i) == TRAP_YES)\n+\t  {\n+\t    if (optimize && !trap_pending)\n+\t      summarize_insn (PATTERN (i), &shadow, 0);\n+\t    trap_pending = 1;\n \t  }\n-\telse\n-\t  CLOSE_SHADOW;\n-\tbreak;\n-      }\n-\n-  if (insn != 0 && get_attr_trap (insn) == TRAP_YES)\n-    {\n-      if (optimize && !trap_pending && GET_CODE (insn) == INSN)\n-\tsummarize_insn (PATTERN (insn), &shadow, 0);\n-      trap_pending = 1;\n     }\n }\n \n+/* Machine dependant reorg pass.  */\n+\n+void\n+alpha_reorg (insns)\n+     rtx insns;\n+{\n+  alpha_handle_trap_shadows (insns);\n+}\n+\n+\f\n /* Check a floating-point value for validity for a particular machine mode.  */\n \n static char *float_strings[] ="}, {"sha": "8c8cf5c45e8fa9a1a1be7aaacab3aa33331e045c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "patch": "@@ -1463,15 +1463,8 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n \n #define ADDRESS_COST(X)  0\n \n-/* Define this if some processing needs to be done immediately before\n-   emitting code for an insn.  */\n-\n-extern void final_prescan_insn ();\n-#define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) \\\n-  final_prescan_insn ((INSN), (OPERANDS), (NOPERANDS))\n-\n-/* Define this if FINAL_PRESCAN_INSN should be called for a CODE_LABEL.  */\n-#define FINAL_PRESCAN_LABEL\n+/* Machine-dependent reorg pass.   */\n+#define MACHINE_DEPENDENT_REORG(X)\talpha_reorg(X)\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}, {"sha": "1240d562cd0d5a2bb6b99f4ed8e36813999699ac", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=2ea844d394a2f1cc1c4cbcb43dbaf068b8dbd9a6", "patch": "@@ -3279,18 +3279,6 @@\n     }\n }\")\n \n-(define_insn \"\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:DI 27))\n-   (clobber (reg:DI 26))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && alpha_tp == ALPHA_TP_INSN\"\n-  \"@\n-   jsr $26,($27),0\\;trapb\\;ldgp $29,4($26)\n-   bsr $26,%0..ng\\;trapb\n-   jsr $26,%0\\;trapb\\;ldgp $29,4($26)\"\n-  [(set_attr \"type\" \"jsr,jsr,ibr\")])\n-      \n (define_insn \"\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -3326,19 +3314,6 @@\n    ldq $27,%2\\;jsr $26,%0\\;ldq $27,0($29)\"\n   [(set_attr \"type\" \"jsr\")])\n \n-(define_insn \"\"\n-  [(set (match_operand 0 \"register_operand\" \"=rf,rf,rf\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,R,i\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:DI 27))\n-   (clobber (reg:DI 26))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && alpha_tp == ALPHA_TP_INSN\"\n-  \"@\n-   jsr $26,($27),0\\;trapb\\;ldgp $29,4($26)\n-   bsr $26,%1..ng\\;trapb\n-   jsr $26,%1\\;trapb\\;ldgp $29,4($26)\"\n-  [(set_attr \"type\" \"jsr,jsr,ibr\")])\n-\n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=rf,rf,rf\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,R,i\"))\n@@ -4513,3 +4488,12 @@\n    (clobber (reg:DI 0))]\n   \"TARGET_OPEN_VMS\"\n   \"lda $0,ots$home_args\\;ldq $0,8($0)\\;jsr $0,ots$home_args\")\n+\n+;; Close the trap shadow of preceeding instructions.  This is generated\n+;; by alpha_reorg.\n+\n+(define_insn \"trapb\"\n+  [(unspec_volatile [(const_int 0)] 3)]\n+  \"\"\n+  \"trapb\"\n+  [(set_attr \"type\" \"misc\")])"}]}