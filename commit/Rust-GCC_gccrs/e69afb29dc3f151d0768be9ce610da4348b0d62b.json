{"sha": "e69afb29dc3f151d0768be9ce610da4348b0d62b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY5YWZiMjlkYzNmMTUxZDA3NjhiZTljZTYxMGRhNDM0OGIwZDYyYg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2010-11-02T17:09:58Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-11-02T17:09:58Z"}, "message": "2010-11-02 Steven G.\n\n2010-11-02  Steven G. Kargl  < kargl@gcc.gnu.org>\n            Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45170\n        * array.c (gfc_match_array_constructor): Reject deferred type\n        parameter (DTP) in type-spec.\n        * decl.c (char_len_param_value, match_char_length,\n        gfc_match_char_spec, build_sym, variable_decl,\n        enumerator_decl): Support DTP.\n        * expr.c (check_inquiry): Fix check due to support for DTP.\n        * gfortran.h (gfc_typespec): Add Boolean 'deferred'.\n        * misc.c (gfc_clear_ts): Set it to false.\n        * match.c (gfc_match_allocate): Support DTP.\n        * resolve.c (resolve_allocate_expr): Not-implemented error for\n        * DTP.\n        (resolve_fl_variable): Add DTP constraint check.\n        * trans-decl.c (gfc_trans_deferred_vars): Add not-implemented\n        error for DTP.\n\n2010-11-02  Steven G. Kargl  < kargl@gcc.gnu.org>\n            Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45170\n        * gfortran.dg/deferred_type_param_1.f90: New.\n        * gfortran.dg/deferred_type_param_2.f90: New.\n        * gfortran.dg/initialization_1.f90: Update dg-errors.\n        * gfortran.dg/initialization_9.f90: Update dg-errors.\n\n\nCo-Authored-By: Tobias Burnus <burnus@net-b.de>\n\nFrom-SVN: r166205", "tree": {"sha": "a9c5829a131f0881ac6b0d89cb235321f6bb720c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c5829a131f0881ac6b0d89cb235321f6bb720c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e69afb29dc3f151d0768be9ce610da4348b0d62b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69afb29dc3f151d0768be9ce610da4348b0d62b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69afb29dc3f151d0768be9ce610da4348b0d62b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69afb29dc3f151d0768be9ce610da4348b0d62b/comments", "author": null, "committer": null, "parents": [{"sha": "343b2efcd766d7d56016c0ae85b6eb13d9597b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/343b2efcd766d7d56016c0ae85b6eb13d9597b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/343b2efcd766d7d56016c0ae85b6eb13d9597b9e"}], "stats": {"total": 235, "additions": 205, "deletions": 30}, "files": [{"sha": "05cab00e362a5163f2cc6b29b7caa00ddbd064db", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -1,3 +1,21 @@\n+2010-11-02  Steven G. Kargl  < kargl@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45170\n+\t* array.c (gfc_match_array_constructor): Reject deferred type\n+\tparameter (DTP) in type-spec.\n+\t* decl.c (char_len_param_value, match_char_length,\n+\tgfc_match_char_spec, build_sym, variable_decl,\n+\tenumerator_decl): Support DTP.\n+\t* expr.c (check_inquiry): Fix check due to support for DTP.\n+\t* gfortran.h (gfc_typespec): Add Boolean 'deferred'.\n+\t* misc.c (gfc_clear_ts): Set it to false.\n+\t* match.c (gfc_match_allocate): Support DTP.\n+\t* resolve.c (resolve_allocate_expr): Not-implemented error for DTP.\n+\t(resolve_fl_variable): Add DTP constraint check.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Add not-implemented\n+\terror for DTP.\n+\n 2010-11-01  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/46152"}, {"sha": "ff0977a5dfec80ed39713e129b8a575304bfc3b6", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -1035,6 +1035,13 @@ gfc_match_array_constructor (gfc_expr **result)\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Array constructor \"\n \t\t\t      \"including type specification at %C\") == FAILURE)\n \t    goto cleanup;\n+\n+\t  if (ts.deferred)\n+\t    {\n+\t      gfc_error (\"Type-spec at %L cannot contain a deferred \"\n+\t\t\t \"type parameter\", &where);\n+\t      goto cleanup;\n+\t    }\n \t}\n     }\n "}, {"sha": "14575dec89875bf1483eed0113b42a5bfd0508da", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -647,16 +647,27 @@ match_intent_spec (void)\n \n \n /* Matches a character length specification, which is either a\n-   specification expression or a '*'.  */\n+   specification expression, '*', or ':'.  */\n \n static match\n-char_len_param_value (gfc_expr **expr)\n+char_len_param_value (gfc_expr **expr, bool *deferred)\n {\n   match m;\n \n+  *expr = NULL;\n+  *deferred = false;\n+\n   if (gfc_match_char ('*') == MATCH_YES)\n+    return MATCH_YES;\n+\n+  if (gfc_match_char (':') == MATCH_YES)\n     {\n-      *expr = NULL;\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: deferred type \"\n+\t\t\t  \"parameter at %C\") == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      *deferred = true;\n+\n       return MATCH_YES;\n     }\n \n@@ -697,11 +708,12 @@ char_len_param_value (gfc_expr **expr)\n    char_len_param_value in parenthesis.  */\n \n static match\n-match_char_length (gfc_expr **expr)\n+match_char_length (gfc_expr **expr, bool *deferred)\n {\n   int length;\n   match m;\n \n+  *deferred = false; \n   m = gfc_match_char ('*');\n   if (m != MATCH_YES)\n     return m;\n@@ -722,7 +734,7 @@ match_char_length (gfc_expr **expr)\n   if (gfc_match_char ('(') == MATCH_NO)\n     goto syntax;\n \n-  m = char_len_param_value (expr);\n+  m = char_len_param_value (expr, deferred);\n   if (m != MATCH_YES && gfc_matching_function)\n     {\n       gfc_undo_symbols ();\n@@ -1086,7 +1098,7 @@ verify_c_interop_param (gfc_symbol *sym)\n /* Function called by variable_decl() that adds a name to the symbol table.  */\n \n static gfc_try\n-build_sym (const char *name, gfc_charlen *cl,\n+build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n \t   gfc_array_spec **as, locus *var_locus)\n {\n   symbol_attribute attr;\n@@ -1103,7 +1115,10 @@ build_sym (const char *name, gfc_charlen *cl,\n     return FAILURE;\n \n   if (sym->ts.type == BT_CHARACTER)\n-    sym->ts.u.cl = cl;\n+    {\n+      sym->ts.u.cl = cl;\n+      sym->ts.deferred = cl_deferred;\n+    }\n \n   /* Add dimension attribute if present.  */\n   if (gfc_set_array_spec (sym, *as, var_locus) == FAILURE)\n@@ -1710,6 +1725,7 @@ variable_decl (int elem)\n   gfc_array_spec *as;\n   gfc_array_spec *cp_as; /* Extra copy for Cray Pointees.  */\n   gfc_charlen *cl;\n+  bool cl_deferred;\n   locus var_locus;\n   match m;\n   gfc_try t;\n@@ -1770,10 +1786,11 @@ variable_decl (int elem)\n \n   char_len = NULL;\n   cl = NULL;\n+  cl_deferred = false;\n \n   if (current_ts.type == BT_CHARACTER)\n     {\n-      switch (match_char_length (&char_len))\n+      switch (match_char_length (&char_len, &cl_deferred))\n \t{\n \tcase MATCH_YES:\n \t  cl = gfc_new_charlen (gfc_current_ns, NULL);\n@@ -1794,6 +1811,8 @@ variable_decl (int elem)\n \t  else\n \t    cl = current_ts.u.cl;\n \n+\t  cl_deferred = current_ts.deferred;\n+\n \t  break;\n \n \tcase MATCH_ERROR:\n@@ -1869,7 +1888,7 @@ variable_decl (int elem)\n      create a symbol for those yet.  If we fail to create the symbol,\n      bail out.  */\n   if (gfc_current_state () != COMP_DERIVED\n-      && build_sym (name, cl, &as, &var_locus) == FAILURE)\n+      && build_sym (name, cl, cl_deferred, &as, &var_locus) == FAILURE)\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -2277,16 +2296,18 @@ gfc_match_char_spec (gfc_typespec *ts)\n   gfc_charlen *cl;\n   gfc_expr *len;\n   match m;\n+  bool deferred;\n \n   len = NULL;\n   seen_length = 0;\n   kind = 0;\n   is_iso_c = 0;\n+  deferred = false;\n \n   /* Try the old-style specification first.  */\n   old_char_selector = 0;\n \n-  m = match_char_length (&len);\n+  m = match_char_length (&len, &deferred);\n   if (m != MATCH_NO)\n     {\n       if (m == MATCH_YES)\n@@ -2315,7 +2336,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n       if (gfc_match (\" , len =\") == MATCH_NO)\n \tgoto rparen;\n \n-      m = char_len_param_value (&len);\n+      m = char_len_param_value (&len, &deferred);\n       if (m == MATCH_NO)\n \tgoto syntax;\n       if (m == MATCH_ERROR)\n@@ -2328,7 +2349,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n   /* Try to match \"LEN = <len-param>\" or \"LEN = <len-param>, KIND = <int>\".  */\n   if (gfc_match (\" len =\") == MATCH_YES)\n     {\n-      m = char_len_param_value (&len);\n+      m = char_len_param_value (&len, &deferred);\n       if (m == MATCH_NO)\n \tgoto syntax;\n       if (m == MATCH_ERROR)\n@@ -2348,7 +2369,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n     }\n \n   /* Try to match ( <len-param> ) or ( <len-param> , [ KIND = ] <int> ).  */\n-  m = char_len_param_value (&len);\n+  m = char_len_param_value (&len, &deferred);\n   if (m == MATCH_NO)\n     goto syntax;\n   if (m == MATCH_ERROR)\n@@ -2407,6 +2428,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n \n   ts->u.cl = cl;\n   ts->kind = kind == 0 ? gfc_default_character_kind : kind;\n+  ts->deferred = deferred;\n \n   /* We have to know if it was a c interoperable kind so we can\n      do accurate type checking of bind(c) procs, etc.  */\n@@ -7449,7 +7471,7 @@ enumerator_decl (void)\n   /* OK, we've successfully matched the declaration.  Now put the\n      symbol in the current namespace. If we fail to create the symbol,\n      bail out.  */\n-  if (build_sym (name, NULL, &as, &var_locus) == FAILURE)\n+  if (build_sym (name, NULL, false, &as, &var_locus) == FAILURE)\n     {\n       m = MATCH_ERROR;\n       goto cleanup;"}, {"sha": "8dfbf7393d3948b5ee81a49eef3e3785abe96346", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -2292,10 +2292,13 @@ check_inquiry (gfc_expr *e, int not_restricted)\n \t   with LEN, as required by the standard.  */\n \tif (i == 5 && not_restricted\n \t    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER\n-\t    && ap->expr->symtree->n.sym->ts.u.cl->length == NULL)\n+\t    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL\n+\t\t|| ap->expr->symtree->n.sym->ts.deferred))\n \t  {\n-\t    gfc_error (\"Assumed character length variable '%s' in constant \"\n-\t\t       \"expression at %L\", e->symtree->n.sym->name, &e->where);\n+\t    gfc_error (\"Assumed or deferred character length variable '%s' \"\n+\t\t\t\" in constant expression at %L\",\n+\t\t\tap->expr->symtree->n.sym->name,\n+\t\t\t&ap->expr->where);\n \t      return MATCH_ERROR;\n \t  }\n \telse if (not_restricted && check_init_expr (ap->expr) == FAILURE)"}, {"sha": "2d0d4ebf53772d790eee6f020aa664f8dfb6f988", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -885,7 +885,7 @@ typedef struct gfc_charlen\n   struct gfc_charlen *next;\n   bool length_from_typespec; /* Length from explicit array ctor typespec?  */\n   tree backend_decl;\n-  tree passed_length; /* Length argument explicitelly passed.  */\n+  tree passed_length; /* Length argument explicitly passed.  */\n \n   int resolved;\n }\n@@ -910,7 +910,8 @@ typedef struct\n   struct gfc_symbol *interface;\t/* For PROCEDURE declarations.  */\n   int is_c_interop;\n   int is_iso_c;\n-  bt f90_type; \n+  bt f90_type;\n+  bool deferred;\n }\n gfc_typespec;\n "}, {"sha": "41818e9defaf7fb637d10b2fca525919a833945b", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -2845,12 +2845,12 @@ gfc_match_allocate (void)\n   gfc_typespec ts;\n   gfc_symbol *sym;\n   match m;\n-  locus old_locus;\n-  bool saw_stat, saw_errmsg, saw_source, saw_mold, b1, b2, b3;\n+  locus old_locus, deferred_locus;\n+  bool saw_stat, saw_errmsg, saw_source, saw_mold, saw_deferred, b1, b2, b3;\n \n   head = tail = NULL;\n   stat = errmsg = source = mold = tmp = NULL;\n-  saw_stat = saw_errmsg = saw_source = saw_mold = false;\n+  saw_stat = saw_errmsg = saw_source = saw_mold = saw_deferred = false;\n \n   if (gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n@@ -2879,6 +2879,13 @@ gfc_match_allocate (void)\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: typespec in \"\n \t\t\t      \"ALLOCATE at %L\", &old_locus) == FAILURE)\n \t    goto cleanup;\n+\n+\t  if (ts.deferred)\n+\t    {\n+\t      gfc_error (\"Type-spec at %L cannot contain a deferred \"\n+\t\t\t \"type parameter\", &old_locus);\n+\t      goto cleanup;\n+\t    }\n \t}\n       else\n \t{\n@@ -2912,6 +2919,12 @@ gfc_match_allocate (void)\n \t  goto cleanup;\n \t}\n \n+      if (tail->expr->ts.deferred)\n+\t{\n+\t  saw_deferred = true;\n+\t  deferred_locus = tail->expr->where;\n+\t}\n+\n       /* The ALLOCATE statement had an optional typespec.  Check the\n \t constraints.  */\n       if (ts.type != BT_UNKNOWN)\n@@ -3095,7 +3108,6 @@ gfc_match_allocate (void)\n \t  break;\n     }\n \n-\n   if (gfc_match (\" )%t\") != MATCH_YES)\n     goto syntax;\n \n@@ -3106,6 +3118,14 @@ gfc_match_allocate (void)\n \t\t  &mold->where, &source->where);\n       goto cleanup;\n     }\n+\n+  /* Check F03:C623,  */\n+  if (saw_deferred && ts.type == BT_UNKNOWN && !source)\n+    {\n+      gfc_error (\"Allocate-object at %L with a deferred type parameter \"\n+\t\t \"requires either a type-spec or SOURCE tag\", &deferred_locus);\n+      goto cleanup;\n+    }\n   \n   new_st.op = EXEC_ALLOCATE;\n   new_st.expr1 = stat;"}, {"sha": "397c87291126d257030cf1dc07fb7283a90bf710", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -77,6 +77,7 @@ gfc_clear_ts (gfc_typespec *ts)\n   ts->f90_type = BT_UNKNOWN;\n   /* flag that says whether it's from iso_c_binding or not */\n   ts->is_iso_c = 0;\n+  ts->deferred = false;\n }\n \n "}, {"sha": "6e71e13f5d1965aee51dcbb833a2257b92bf6a6d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -6856,6 +6856,12 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n     }\n \n success:\n+  if (e->ts.deferred)\n+    {\n+      gfc_error (\"Support for entity at %L with deferred type parameter \"\n+\t\t \"not yet implemented\", &e->where);\n+      return FAILURE;\n+    }\n   return SUCCESS;\n \n failure:\n@@ -9371,6 +9377,7 @@ resolve_index_expr (gfc_expr *e)\n   return SUCCESS;\n }\n \n+\n /* Resolve a charlen structure.  */\n \n static gfc_try\n@@ -9684,6 +9691,7 @@ apply_default_init_local (gfc_symbol *sym)\n   build_init_assign (sym, init);\n }\n \n+\n /* Resolution of common features of flavors variable and procedure.  */\n \n static gfc_try\n@@ -9847,12 +9855,22 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n       return FAILURE;\n     }\n \n+  /* Constraints on deferred type parameter.  */\n+  if (sym->ts.deferred && !(sym->attr.pointer || sym->attr.allocatable))\n+    {\n+      gfc_error (\"Entity '%s' at %L has a deferred type parameter and \"\n+\t\t \"requires either the pointer or allocatable attribute\",\n+\t\t     sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       /* Make sure that character string variables with assumed length are\n \t dummy arguments.  */\n       e = sym->ts.u.cl->length;\n-      if (e == NULL && !sym->attr.dummy && !sym->attr.result)\n+      if (e == NULL && !sym->attr.dummy && !sym->attr.result\n+\t  && !sym->ts.deferred)\n \t{\n \t  gfc_error (\"Entity with assumed character length at %L must be a \"\n \t\t     \"dummy argument or a PARAMETER\", &sym->declared_at);"}, {"sha": "4b668c8782c7db5004670c41a112e4072ed257b0", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -3416,6 +3416,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n \t    }\n \t}\n+      else if (sym->ts.deferred)\n+\tgfc_fatal_error (\"Deferred type parameter not yet supported\");\n       else if (sym_has_alloc_comp)\n \tgfc_trans_deferred_array (sym, block);\n       else if (sym->ts.type == BT_CHARACTER)"}, {"sha": "2fcf2b22c14312ae07a1ab5e8e007fd075a369e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -1,3 +1,12 @@\n+2010-11-02  Steven G. Kargl  < kargl@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45170\n+\t* gfortran.dg/deferred_type_param_1.f90: New.\n+\t* gfortran.dg/deferred_type_param_2.f90: New.\n+\t* gfortran.dg/initialization_1.f90: Update dg-errors.\n+\t* gfortran.dg/initialization_9.f90: Update dg-errors.\n+\n 2010-11-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46149"}, {"sha": "13a1596bf693d7fe35b02a3867674d460de90098", "filename": "gcc/testsuite/gfortran.dg/allocate_with_typespec_3.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_typespec_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_typespec_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_typespec_3.f90?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -23,7 +23,7 @@ subroutine implicit_none_test1\n    allocate(real(8) :: x4(1))      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(real(4) :: x8(1))      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(double :: d1(1))       ! { dg-error \"Error in type-spec at\" }\n-   allocate(character(:) :: c1(1)) ! { dg-error \"Syntax error in CHARACTER declaration\" }\n+   allocate(character(:) :: c1(1)) ! { dg-error \"cannot contain a deferred type parameter\" }\n    allocate(real :: b(1))          ! { dg-error \"is type incompatible\" }\n \n end subroutine implicit_none_test1\n@@ -50,7 +50,7 @@ subroutine implicit_none_test2\n    allocate(real(8) :: x4)      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(real(4) :: x8)      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(double :: d1)       ! { dg-error \"Error in type-spec at\" }\n-   allocate(character(:) :: c1) ! { dg-error \"Syntax error in CHARACTER declaration\" }\n+   allocate(character(:) :: c1) ! { dg-error \"cannot contain a deferred type parameter\" }\n    allocate(real :: b)          ! { dg-error \"is type incompatible\" }\n \n end subroutine implicit_none_test2\n@@ -76,7 +76,7 @@ subroutine implicit_test3\n    allocate(real(8) :: x4(1))      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(real(4) :: x8(1))      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(double :: d1(1))       ! { dg-error \"Error in type-spec\" }\n-   allocate(character(:) :: c1(1)) ! { dg-error \"Syntax error in CHARACTER declaration\" }\n+   allocate(character(:) :: c1(1)) ! { dg-error \"cannot contain a deferred type parameter\" }\n    allocate(real :: b(1))          ! { dg-error \"is type incompatible\" }\n \n end subroutine implicit_test3\n@@ -101,7 +101,7 @@ subroutine implicit_test4\n    allocate(real(8) :: x4)      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(real(4) :: x8)      ! { dg-error \"differs from the kind type parameter\" }\n    allocate(double :: d1)       ! { dg-error \"Error in type-spec at\" }\n-   allocate(character(:) :: c1) ! { dg-error \"Syntax error in CHARACTER declaration\" }\n+   allocate(character(:) :: c1) ! { dg-error \"cannot contain a deferred type parameter\" }\n    allocate(real :: b)          ! { dg-error \"is type incompatible\" }\n \n end subroutine implicit_test4"}, {"sha": "4382fae51f04e988884dd3969f4517318ddd45b7", "filename": "gcc/testsuite/gfortran.dg/deferred_type_param_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_1.f90?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! PR fortran/45170\n+!\n+! Character deferred type parameter\n+!\n+implicit none\n+character(len=:), allocatable :: str(:) ! { dg-error \"Fortran 2003: deferred type parameter\" }\n+\n+character(len=4) :: str2*(:) ! { dg-error \"Fortran 2003: deferred type parameter\" }\n+end"}, {"sha": "7bfd2a6ece0b73b11a3045227105a9af346bd06c", "filename": "gcc/testsuite/gfortran.dg/deferred_type_param_2.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_2.f90?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n+! PR fortran/45170\n+!\n+! Character deferred type parameter\n+!\n+\n+subroutine one(x, y) ! { dg-error \"Entity .y. at .1. has a deferred type parameter\" }\n+  implicit none\n+  character(len=:), pointer :: x\n+  character(len=:) :: y\n+  character(len=:), allocatable, target :: str2\n+  character(len=:), target :: str ! { dg-error \"deferred type parameter\" }\n+end subroutine one\n+\n+subroutine two()\n+  implicit none\n+  character(len=:), allocatable, target :: str1(:)\n+  character(len=5), save, target :: str2\n+  character(len=:), pointer :: pstr => str2\n+  character(len=:), pointer :: pstr2(:)\n+end subroutine two\n+\n+subroutine three()\n+!  implicit none  ! Disabled because of PR 46152\n+  character(len=:), allocatable, target :: str1(:)\n+  character(len=5), save, target :: str2\n+  character(len=:), pointer :: pstr\n+  character(len=:), pointer :: pstr2(:)\n+\n+  pstr => str2\n+  pstr2 => str1\n+  str1 = [\"abc\"]\n+  pstr2 => str1\n+\n+  allocate (character(len=77) :: str1(1)) ! OK ! { dg-error \"not yet implemented\" }\n+  allocate (pstr, source=str2)  ! OK  ! { dg-error \"not yet implemented\" }\n+  allocate (pstr, mold=str2) ! { dg-error \"requires either a type-spec or SOURCE tag\" }\n+  allocate (pstr) ! { dg-error \"requires either a type-spec or SOURCE tag\" }\n+  allocate (character(len=:) :: str1(1)) ! { dg-error \"cannot contain a deferred type parameter\" }\n+\n+  str1 = [ character(len=2) :: \"abc\" ]\n+  str1 = [ character(len=:) :: \"abc\" ] ! { dg-error \"cannot contain a deferred type parameter\" }\n+end subroutine three\n+\n+subroutine four()\n+  implicit none\n+  character(len=:), allocatable, target :: str\n+  character(len=:), pointer :: pstr\n+  pstr => str\n+  str = \"abc\"\n+  if(len(pstr) /= len(str) .or. len(str)/= 3) call abort()\n+  str = \"abcd\"\n+  if(len(pstr) /= len(str) .or. len(str)/= 4) call abort()\n+end subroutine four\n+\n+subroutine five()\n+character(len=4) :: str*(:)\n+allocatable :: str\n+end subroutine five\n+"}, {"sha": "3ca20ac715c176d656be611a6411c910bfc30d61", "filename": "gcc/testsuite/gfortran.dg/initialization_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -24,7 +24,7 @@ subroutine foo(ch1, x, y)\n     real :: z(2, 2)\n \n ! However, this gives a warning because it is an initialization expression.\n-    integer :: l1 = len (ch1)     ! { dg-warning \"Assumed character length variable\" }\n+    integer :: l1 = len (ch1)     ! { dg-warning \"Assumed or deferred character length variable\" }\n \n ! These are warnings because they are gfortran extensions.\n     integer :: m3 = size (x, 1)   ! { dg-error \"Assumed size array\" }"}, {"sha": "d90404748803b2defed8b2e00c878a36cad86fd0", "filename": "gcc/testsuite/gfortran.dg/initialization_9.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69afb29dc3f151d0768be9ce610da4348b0d62b/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_9.f90?ref=e69afb29dc3f151d0768be9ce610da4348b0d62b", "patch": "@@ -5,7 +5,7 @@\n \n    integer function xstrcmp(s1)\n      character*(*), intent(in) :: s1\n-     integer :: n1 = len(s1)            ! { dg-error \"Assumed character length variable\" }\n+     integer :: n1 = len(s1)  ! { dg-error \"Assumed or deferred character length variable\" }\n      n1 = 1\n      return\n    end function xstrcmp"}]}