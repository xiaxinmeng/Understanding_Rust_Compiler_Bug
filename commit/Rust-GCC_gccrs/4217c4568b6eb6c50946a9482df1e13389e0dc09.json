{"sha": "4217c4568b6eb6c50946a9482df1e13389e0dc09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIxN2M0NTY4YjZlYjZjNTA5NDZhOTQ4MmRmMWUxMzM4OWUwZGMwOQ==", "commit": {"author": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-10-24T00:45:39Z"}, "committer": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-10-24T00:45:39Z"}, "message": "Initial check in.  Preliminary development stage.\n\nFrom-SVN: r46", "tree": {"sha": "d303476694562f2e4e7621266d27f4e1fb3ac692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d303476694562f2e4e7621266d27f4e1fb3ac692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4217c4568b6eb6c50946a9482df1e13389e0dc09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4217c4568b6eb6c50946a9482df1e13389e0dc09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4217c4568b6eb6c50946a9482df1e13389e0dc09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4217c4568b6eb6c50946a9482df1e13389e0dc09/comments", "author": null, "committer": null, "parents": [{"sha": "e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e545f2b026512dd56e91a89a0b6951ab4a58a8b7"}], "stats": {"total": 371, "additions": 371, "deletions": 0}, "files": [{"sha": "80719ce8058c3617c43fabc16b67e3bad2e3709d", "filename": "gcc/objc/hash.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4217c4568b6eb6c50946a9482df1e13389e0dc09/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4217c4568b6eb6c50946a9482df1e13389e0dc09/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=4217c4568b6eb6c50946a9482df1e13389e0dc09", "patch": "@@ -0,0 +1,237 @@\n+/* -*-c-*-\n+ * This file contains the hashing implementation.\n+ *\n+  $Header$\n+  $Author$\n+  $Date$\n+  $Log$\n+*/\n+ \n+\n+#include  <hash.h>\n+#include  <ObjC.h>\n+\n+#include  <assert.h>\n+#include  <libc.h>\n+#include  <math.h>\n+\n+\n+                                                /* Local forward decl. */\n+  u_int hashValue( Cache_t, void* );\n+\n+\n+Cache_t hash_new( u_int numberOfBuckets ) {\n+\n+  Cache_t retCache;\n+  int     i;\n+\n+\n+  assert( numberOfBuckets );\n+\n+                                                /* Allocate the cache \n+                                                  structure.  calloc() insures\n+                                                  its initialization for\n+                                                  default values. */\n+  retCache = calloc( 1, sizeof( Cache ));\n+  assert( retCache );\n+  \n+                                                /* Allocate the array of \n+                                                  buckets for the cache.  \n+                                                  calloc() initializes all of \n+                                                  the pointers to NULL. */\n+  retCache->theNodeTable = calloc( numberOfBuckets, sizeof( CacheNode_t ));\n+  assert( retCache->theNodeTable );\n+  \n+  retCache->numberOfBuckets = numberOfBuckets;\n+\n+                                                /* Calculate the number of \n+                                                  bits required to represent \n+                                                  the hash mask. */\n+  retCache->numberOfMaskBits = \n+    ceil( log( retCache->numberOfBuckets ) / log( 2 ));\n+\n+                                                /* Form a bit mask for the \n+                                                  hash. */\n+  for( i = 0; i < retCache->numberOfMaskBits; ++i )\n+    retCache->mask = ( retCache->mask << 1 ) | 0x01 ;\n+\n+  assert( retCache->numberOfMaskBits );\n+  assert( retCache->mask );\n+\n+  return retCache;\n+}\n+\n+\n+void hash_delete( Cache_t theCache ) {\n+\n+  void* aNode;\n+  \n+\n+                                                /* Purge all key/value pairs \n+                                                  from the table. */\n+  while( aNode = hash_next( theCache, NULL ))\n+    hash_remove( theCache, aNode );\n+\n+                                                /* Release the array of nodes \n+                                                  and the cache itself. */\n+  free( theCache->theNodeTable );\n+  free( theCache );\n+}\n+\n+\n+void hash_add( Cache_t theCache, void* aKey, void* aValue ) {\n+\n+  u_int       indx = hashValue( theCache, aKey );\n+  CacheNode_t aCacheNode = calloc( 1, sizeof( CacheNode ));\n+\n+\n+  assert( aCacheNode );\n+  \n+                                                /* Initialize the new node. */\n+  aCacheNode->theKey    = aKey;\n+  aCacheNode->theValue  = aValue;\n+  aCacheNode->nextNode  = ( *theCache->theNodeTable )[ indx ];\n+  \n+                                                /* Debugging.\n+                                                \n+                                                  Check the list for another \n+                                                  key. */\n+#ifdef DEBUG\n+    { CacheNode_t checkHashNode = ( *theCache->theNodeTable )[ indx ];\n+    \n+      while( checkHashNode ) {\n+    \n+        assert( checkHashNode->theKey != aKey );\n+        checkHashNode = checkHashNode->nextNode;\n+      }\n+    }\n+\n+                                                /* Install the node as the\n+                                                  first element on the list. */\n+  ( *theCache->theNodeTable )[ indx ] = aCacheNode;\n+\n+#endif\n+}\n+\n+\n+void hash_remove( Cache_t theCache, void* aKey ) {\n+\n+  u_int       indx = hashValue( theCache, aKey );\n+  CacheNode_t aCacheNode = ( *theCache->theNodeTable )[ indx ];\n+  \n+  \n+                                                /* We assume there is an entry \n+                                                  in the table.  Error if it \n+                                                  is not. */\n+  assert( aCacheNode );\n+  \n+                                                /* Special case.  First element \n+                                                  is the key/value pair to be \n+                                                  removed. */\n+  if( aCacheNode->theKey == aKey ) {\n+    ( *theCache->theNodeTable )[ indx ] = aCacheNode->nextNode;\n+    free( aCacheNode );\n+  } else {\n+                                                /* Otherwise, find the hash \n+                                                  entry. */\n+    CacheNode_t prevHashNode = aCacheNode;\n+    BOOL        removed = NO;\n+    \n+    do {\n+    \n+      if( aCacheNode->theKey == aKey ) {\n+        prevHashNode->nextNode = aCacheNode->nextNode, removed = YES;\n+        free( aCacheNode );\n+      } else\n+        prevHashNode = aCacheNode, aCacheNode = aCacheNode->nextNode;\n+    } while( !removed && aCacheNode );\n+    assert( removed );\n+  }\n+}\n+\n+\n+void* hash_value_for_key( Cache_t theCache, void* aKey ) {\n+\n+  u_int       indx = hashValue( theCache, aKey );\n+  CacheNode_t aCacheNode = ( *theCache->theNodeTable )[ indx ];\n+  void*       retVal = NULL;\n+  \n+\n+  if( aCacheNode ) {\n+    BOOL  found = NO;\n+  \n+    do {\n+      if( aCacheNode->theKey == aKey )\n+        retVal = aCacheNode->theValue, found = YES;\n+      else\n+        aCacheNode = aCacheNode->nextNode;\n+    } while( !found && aCacheNode );\n+  }\n+  \n+  return retVal;\n+}\n+\n+\n+CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode ) {\n+\n+  CacheNode_t theCacheNode = aCacheNode;\n+  \n+  \n+                                                /* If the scan is being started\n+                                                  then reset the last node \n+                                                  visitied pointer and bucket \n+                                                  index. */\n+  if( !theCacheNode )\n+    theCache->lastBucket  = 0;\n+  \n+                                                /* If there is a node visited\n+                                                  last then check for another \n+                                                  entry in the same bucket; \n+                                                  Otherwise step to the next \n+                                                  bucket. */\n+  if( theCacheNode )\n+    if( theCacheNode->nextNode )\n+                                                /* There is a node which \n+                                                  follows the last node \n+                                                  returned.  Step to that node \n+                                                  and retun it. */\n+      return theCacheNode->nextNode;\n+    else\n+      ++theCache->lastBucket;\n+\n+                                                /* If the list isn't exhausted \n+                                                  then search the buckets for \n+                                                  other nodes. */\n+  if( theCache->lastBucket < theCache->numberOfBuckets ) {\n+                                                /*  Scan the remainder of the \n+                                                  buckets looking for an entry\n+                                                  at the head of the list.  \n+                                                  Return the first item \n+                                                  found. */\n+    while( theCache->lastBucket < theCache->numberOfBuckets )\n+      if(( *theCache->theNodeTable )[ theCache->lastBucket ])\n+        return ( *theCache->theNodeTable )[ theCache->lastBucket ];\n+      else\n+        ++theCache->lastBucket;\n+  \n+                                                /* No further nodes were found\n+                                                  in the hash table. */\n+    return NULL;\n+  } else\n+    return NULL;\n+}\n+\n+\n+u_int hashValue( Cache_t theCache, void* aKey ) {\n+\n+  u_int hash = 0;\n+  int   i;\n+  \n+  \n+  assert( theCache->numberOfMaskBits );\n+  for( i = 0; i < ( sizeof( aKey ) * 8 ); i += theCache->numberOfMaskBits )\n+    hash ^= (( u_int )aKey ) >> i ;\n+\n+  return ( hash & theCache->mask ) % theCache->numberOfBuckets;\n+}\n+"}, {"sha": "34c77dcfa3ecbb9b375c98e4457767bb935a2fd8", "filename": "gcc/objc/hash.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4217c4568b6eb6c50946a9482df1e13389e0dc09/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4217c4568b6eb6c50946a9482df1e13389e0dc09/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=4217c4568b6eb6c50946a9482df1e13389e0dc09", "patch": "@@ -0,0 +1,134 @@\n+/* -*-c-*-\n+ * This is a general purpose hash object.\n+ *\n+ * The hash object used throughout the run-time\n+ *  is an integer hash.  The key and data is of type\n+ *  void*.  The hashing function converts the key to\n+ *  an integer and computes it hash value.\n+ *\n+  $Header$\n+  $Author$\n+  $Date$\n+  $Log$\n+*/\n+ \n+\n+#ifndef _hash_INCLUDE_GNU\n+#define _hash_INCLUDE_GNU\n+\n+                                                /* If someone is using a c++\n+                                                  compiler then adjust the \n+                                                  types in the file back \n+                                                  to C. */\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include  <sys/types.h>\n+\n+\n+/*\n+ * This data structure is used to hold items\n+ *  stored in a hash table.  Each node holds \n+ *  a key/value pair.\n+ *\n+ * Items in the cache are really of type void*.\n+ */\n+typedef struct cache_node {\n+  struct cache_node*  nextNode;                   /* Pointer to next entry on\n+                                                    the list.  NULL indicates\n+                                                    end of list. */\n+  void*               theKey;                     /* Key used to locate the\n+                                                    value.  Used to locate\n+                                                    value when more than one\n+                                                    key computes the same hash\n+                                                    value. */\n+  void*               theValue;                   /* Value stored for the\n+                                                    key. */\n+} CacheNode, *CacheNode_t;\n+\n+\n+/*\n+ * This data structure is the cache.\n+ *\n+ * It must be passed to all of the hashing routines\n+ *  (except for new).\n+ */\n+typedef struct cache {\n+  /*\n+   * Variables used to implement the\n+   *  hash itself.\n+   */\n+  CacheNode_t (* theNodeTable )[];                /* Pointer to an array of\n+                                                    hash nodes. */\n+  u_int       numberOfBuckets,                    /* Number of buckets \n+                                                    allocated for the hash\n+                                                    table (number of array\n+                                                    entries allocated for\n+                                                    \"theCache\"). */\n+              mask,                               /* Mask used when computing\n+                                                    a hash value.  The number\n+                                                    of bits set in the mask\n+                                                    is contained in the next\n+                                                    member variable. */\n+              numberOfMaskBits;                   /* Number of bits used for\n+                                                    the mask.  Useful for \n+                                                    efficient hash value\n+                                                    calculation. */\n+  /*\n+   * Variables used to implement indexing\n+   *  through the hash table.\n+   */\n+  u_int       lastBucket;                         /* Tracks which entry in the\n+                                                    array where the last value\n+                                                    was returned. */\n+} Cache, *Cache_t;\n+\n+\n+                                                /* Prototypes for hash\n+                                                  functions. */\n+                                                /* Allocate and initialize \n+                                                  a hash table.  Hash table \n+                                                  size taken as a parameter. \n+                                                    A value of 0 is not \n+                                                  allowed. */ \n+Cache_t hash_new( u_int numberOfBuckets );\n+                                                /* Deallocate all of the\n+                                                  hash nodes and the cache\n+                                                  itself. */\n+void hash_delete( Cache_t theCache );\n+                                                /* Add the key/value pair\n+                                                  to the hash table.  assert()\n+                                                  if the key is already in\n+                                                  the hash. */\n+void hash_add( Cache_t theCache, void* aKey, void* aValue );\n+                                                /* Remove the key/value pair\n+                                                  from the hash table.  \n+                                                  assert() if the key isn't \n+                                                  in the table. */\n+void hash_remove( Cache_t theCache, void* aKey );\n+                                                /* Given key, return its \n+                                                  value.  Return NULL if the\n+                                                  key/value pair isn't in\n+                                                  the hash. */\n+void* hash_value_for_key( Cache_t theCache, void* aKey );\n+                                                /* Used to index through the\n+                                                  hash table.  Start with NULL\n+                                                  to get the first entry.\n+                                                  \n+                                                  Successive calls pass the\n+                                                  value returned previously.\n+                                                  ** Don't modify the hash\n+                                                  during this operation *** \n+                                                  \n+                                                  Cache nodes are returned\n+                                                  such that key or value can\n+                                                  ber extracted. */\n+CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode );\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}]}