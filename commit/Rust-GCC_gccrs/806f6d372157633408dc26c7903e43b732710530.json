{"sha": "806f6d372157633408dc26c7903e43b732710530", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA2ZjZkMzcyMTU3NjMzNDA4ZGMyNmM3OTAzZTQzYjczMjcxMDUzMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T08:13:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T08:13:21Z"}, "message": "[multiple changes]\n\n2011-08-02  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch6.adb (Can_Override_Operator): New function.\n\t(Verify_Overriding_Indicator): Add missing code to check overriding\n\tindicator in operators. Fixes regression.\n\t(Check_Overriding_Indicator): Minor reformating after replacing the\n\tcode that evaluates if the subprogram can override an operator by\n\tinvocations to the above new function.\n\t* einfo.adb\n\t(Write_Field26_Name): Add missing code to ensure that, following\n\tthe documentation in einfo.ads, this field is not shown as attribute\n\t\"Static_Initialization\" on non-dispatching functions.\n\n2011-08-02  Jose Ruiz  <ruiz@adacore.com>\n\n\t* sem_res.adb (Resolve_Call): A call to\n\tAda.Real_Time.Timing_Events.Set_Handler violates restriction\n\tNo_Relative_Delay (AI-0211) only when it sets a relative timing event,\n\ti.e., when the second parameter is of type Time_Span.\n\n2011-08-02  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Gnatmake): use <library dir>/lib<library name>.a to link\n\twith an archive instead of -L<library dir> -l<library name>.\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Use_Type): If the clause is being re-analyzed,\n\tmark the base types In_Use in addition to making the operations\n\tuse_visible.\n\n2011-08-02  Ed Falis  <falis@adacore.com>\n\n\t* init.c: add and setup __gnat_signal_mask for the exception signals\n\t* s-inmaop-vxworks.adb: new file.\n\t* s-intman-vxworks.adb: remove unnecessary initializations and\n\tsimplify remaining\n\t* s-intman-vxworks.ads: remove unnecessary variable\n\t* s-taprop-vxworks.adb: simplify signal initialization\n\nFrom-SVN: r177092", "tree": {"sha": "d10af131f48cfe83e17d537c53b5f2c9bdf5aaa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d10af131f48cfe83e17d537c53b5f2c9bdf5aaa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/806f6d372157633408dc26c7903e43b732710530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806f6d372157633408dc26c7903e43b732710530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806f6d372157633408dc26c7903e43b732710530", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806f6d372157633408dc26c7903e43b732710530/comments", "author": null, "committer": null, "parents": [{"sha": "780d052e3446d6bc848a173d70db8b7160d52fa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780d052e3446d6bc848a173d70db8b7160d52fa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780d052e3446d6bc848a173d70db8b7160d52fa9"}], "stats": {"total": 645, "additions": 490, "deletions": 155}, "files": [{"sha": "5155a79c3bf28ef8e42187511ddeb51a2451bc12", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -1,3 +1,43 @@\n+2011-08-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch6.adb (Can_Override_Operator): New function.\n+\t(Verify_Overriding_Indicator): Add missing code to check overriding\n+\tindicator in operators. Fixes regression.\n+\t(Check_Overriding_Indicator): Minor reformating after replacing the\n+\tcode that evaluates if the subprogram can override an operator by\n+\tinvocations to the above new function.\n+\t* einfo.adb\n+\t(Write_Field26_Name): Add missing code to ensure that, following\n+\tthe documentation in einfo.ads, this field is not shown as attribute\n+\t\"Static_Initialization\" on non-dispatching functions.\n+\n+2011-08-02  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Call): A call to\n+\tAda.Real_Time.Timing_Events.Set_Handler violates restriction\n+\tNo_Relative_Delay (AI-0211) only when it sets a relative timing event,\n+\ti.e., when the second parameter is of type Time_Span.\n+\n+2011-08-02  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb (Gnatmake): use <library dir>/lib<library name>.a to link\n+\twith an archive instead of -L<library dir> -l<library name>.\n+\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Use_Type): If the clause is being re-analyzed,\n+\tmark the base types In_Use in addition to making the operations\n+\tuse_visible.\n+\n+2011-08-02  Ed Falis  <falis@adacore.com>\n+\n+\t* init.c: add and setup __gnat_signal_mask for the exception signals\n+\t* s-inmaop-vxworks.adb: new file.\n+\t* s-intman-vxworks.adb: remove unnecessary initializations and\n+\tsimplify remaining\n+\t* s-intman-vxworks.ads: remove unnecessary variable\n+\t* s-taprop-vxworks.adb: simplify signal initialization\n+\n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch8.adb: Minor code reorganization, comment updates."}, {"sha": "499db134ec8be74ec1ac6180791dcdeab38ab17e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -8497,10 +8497,12 @@ package body Einfo is\n \n          when E_Procedure                                  |\n               E_Function                                   =>\n-            if Is_Dispatching_Operation (Id) then\n-               Write_Str (\"Overridden_Operation\");\n-            else\n+            if Ekind (Id) = E_Procedure\n+              and then not Is_Dispatching_Operation (Id)\n+            then\n                Write_Str (\"Static_Initialization\");\n+            else\n+               Write_Str (\"Overridden_Operation\");\n             end if;\n \n          when E_Record_Type                                |"}, {"sha": "53d72d9dbe9c97674e666ed6b722b54d3da9b945", "filename": "gcc/ada/init.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -1975,20 +1975,23 @@ __gnat_map_signal (int sig)\n /* Tasking and Non-tasking signal handler.  Map SIGnal to Ada exception\n    propagation after the required low level adjustments.  */\n \n+sigset_t __gnat_signal_mask;\n+\n+  /* VxWorks will always mask out the signal during the signal handler and\n+     will reenable it on a longjmp.  GNAT does not generate a longjmp to\n+     return from a signal handler so exception signals will still be masked\n+     unless we unmask it. __gnat_signal mask tells sigaction to block the\n+     exception signals and sigprocmask to unblock them. */\n+\n void\n __gnat_error_handler (int sig,\n \t\t      void *si ATTRIBUTE_UNUSED,\n \t\t      struct sigcontext *sc ATTRIBUTE_UNUSED)\n {\n-  sigset_t mask;\n \n-  /* VxWorks will always mask out the signal during the signal handler and\n-     will reenable it on a longjmp.  GNAT does not generate a longjmp to\n-     return from a signal handler so the signal will still be masked unless\n-     we unmask it.  */\n-  sigprocmask (SIG_SETMASK, NULL, &mask);\n-  sigdelset (&mask, sig);\n-  sigprocmask (SIG_SETMASK, &mask, NULL);\n+  /* This routine handles the exception signals for all tasks */\n+\n+  sigprocmask (SIG_UNBLOCK, &__gnat_signal_mask, NULL);\n \n   __gnat_map_signal (sig);\n }\n@@ -2000,14 +2003,24 @@ __gnat_install_handler (void)\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event!  */\n+     signal that might cause a scheduling event! This routine is called\n+     only once, for the environment task. Other tasks are set up in the\n+     System.Interrupt_Manager package. */\n+\n+  sigemptyset (&__gnat_signal_mask);\n+  sigaddset (SIGBUS, &__gnat_signal_mask);\n+  sigaddset (SIGFPE, &__gnat_signal_mask);\n+  sigaddset (SIGILL, &__gnat_signal_mask);\n+  sigaddset (SIGSEGV, &__gnat_signal_mask);\n \n   act.sa_handler = __gnat_error_handler;\n   act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n-  sigemptyset (&act.sa_mask);\n+  act.sa_mask = __gnat_signal_mask;\n+\n+  /* For VxWorks, unconditionally install the exception signal handlers, since\n+     pragma Interrupt_State applies to vectored hardware interrupts, not\n+     signals.  */\n \n-  /* For VxWorks, install all signal handlers, since pragma Interrupt_State\n-     applies to vectored hardware interrupts, not signals.  */\n   sigaction (SIGFPE,  &act, NULL);\n   sigaction (SIGILL,  &act, NULL);\n   sigaction (SIGSEGV, &act, NULL);\n@@ -2027,6 +2040,7 @@ __gnat_init_float (void)\n      below have no effect.  */\n #if defined (_ARCH_PPC) && !defined (_SOFT_FLOAT) && !defined (VTHREADS)\n #if defined (__SPE__)\n+  /* VxWorks 6 */\n   {\n      const unsigned long spefscr_mask = 0xfffffff3;\n      unsigned long spefscr;\n@@ -2035,14 +2049,15 @@ __gnat_init_float (void)\n      asm (\"mtspr 512, %0\\n\\tisync\" : : \"r\" (spefscr));\n   }\n #else\n+  /* all except VxWorks 653 and MILS */\n   asm (\"mtfsb0 25\");\n   asm (\"mtfsb0 26\");\n #endif\n #endif\n \n #if (defined (__i386__) || defined (i386)) && !defined (VTHREADS)\n   /* This is used to properly initialize the FPU on an x86 for each\n-     process thread.  */\n+     process thread. For all except VxWorks 653 */\n   asm (\"finit\");\n #endif\n "}, {"sha": "6051c794d0ee9c65d05491a9f4a39306472c7b7c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -6066,24 +6066,41 @@ package body Make is\n                      end loop;\n \n                      for Index in 1 .. Library_Projs.Last loop\n+                        if\n+                          Library_Projs.Table (Index).Library_Kind = Static\n+                        then\n+                           Linker_Switches.Increment_Last;\n+                           Linker_Switches.Table (Linker_Switches.Last) :=\n+                             new String'\n+                               (Get_Name_String\n+                                    (Library_Projs.Table (Index).\n+                                       Library_Dir.Display_Name) &\n+                                Directory_Separator &\n+                                \"lib\" &\n+                                Get_Name_String\n+                                    (Library_Projs.Table (Index).\n+                                     Library_Name) &\n+                                \".a\");\n \n-                        --  Add the -L switch\n-\n-                        Linker_Switches.Increment_Last;\n-                        Linker_Switches.Table (Linker_Switches.Last) :=\n-                          new String'(\"-L\" &\n-                                      Get_Name_String\n-                                        (Library_Projs.Table (Index).\n-                                            Library_Dir.Display_Name));\n-\n-                        --  Add the -l switch\n-\n-                        Linker_Switches.Increment_Last;\n-                        Linker_Switches.Table (Linker_Switches.Last) :=\n-                          new String'(\"-l\" &\n-                                      Get_Name_String\n-                                        (Library_Projs.Table (Index).\n-                                           Library_Name));\n+                        else\n+                           --  Add the -L switch\n+\n+                           Linker_Switches.Increment_Last;\n+                           Linker_Switches.Table (Linker_Switches.Last) :=\n+                             new String'(\"-L\" &\n+                               Get_Name_String\n+                                 (Library_Projs.Table (Index).\n+                                    Library_Dir.Display_Name));\n+\n+                           --  Add the -l switch\n+\n+                           Linker_Switches.Increment_Last;\n+                           Linker_Switches.Table (Linker_Switches.Last) :=\n+                             new String'(\"-l\" &\n+                               Get_Name_String\n+                                 (Library_Projs.Table (Index).\n+                                    Library_Name));\n+                        end if;\n                      end loop;\n                   end if;\n "}, {"sha": "fe3b741712010c28145e2b3f2c7af2a15b8c8a58", "filename": "gcc/ada/s-inmaop-vxworks.adb", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-inmaop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-inmaop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-vxworks.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -0,0 +1,255 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                  SYSTEM.INTERRUPT_MANAGEMENT.OPERATIONS                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--             Copyright (C) 1991-1994, Florida State University            --\n+--                     Copyright (C) 1995-2010, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a VxWorks version of this package. Many operations are null as this\n+--  package supports the use of Ada interrupt handling facilities for signals,\n+--  while those facilities are used for hardware interrupts on these targets.\n+\n+with Ada.Exceptions;\n+\n+with Interfaces.C;\n+\n+with System.OS_Interface;\n+\n+package body System.Interrupt_Management.Operations is\n+\n+   use Ada.Exceptions;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+\n+   ----------------------------\n+   -- Thread_Block_Interrupt --\n+   ----------------------------\n+\n+   procedure Thread_Block_Interrupt\n+     (Interrupt : Interrupt_ID)\n+   is\n+      pragma Unreferenced (Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Thread_Block_Interrupt unimplemented\");\n+   end Thread_Block_Interrupt;\n+\n+   ------------------------------\n+   -- Thread_Unblock_Interrupt --\n+   ------------------------------\n+\n+   procedure Thread_Unblock_Interrupt\n+     (Interrupt : Interrupt_ID)\n+   is\n+      pragma Unreferenced (Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Thread_Unblock_Interrupt unimplemented\");\n+   end Thread_Unblock_Interrupt;\n+\n+   ------------------------\n+   -- Set_Interrupt_Mask --\n+   ------------------------\n+\n+   procedure Set_Interrupt_Mask (Mask : access Interrupt_Mask) is\n+      pragma Unreferenced (Mask);\n+   begin\n+      null;\n+   end Set_Interrupt_Mask;\n+\n+   procedure Set_Interrupt_Mask\n+     (Mask  : access Interrupt_Mask;\n+      OMask : access Interrupt_Mask)\n+   is\n+      pragma Unreferenced (Mask, OMask);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Set_Interrupt_Mask unimplemented\");\n+   end Set_Interrupt_Mask;\n+\n+   ------------------------\n+   -- Get_Interrupt_Mask --\n+   ------------------------\n+\n+   procedure Get_Interrupt_Mask (Mask : access Interrupt_Mask) is\n+      pragma Unreferenced (Mask);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Get_Interrupt_Mask unimplemented\");\n+   end Get_Interrupt_Mask;\n+\n+   --------------------\n+   -- Interrupt_Wait --\n+   --------------------\n+\n+   function Interrupt_Wait\n+     (Mask : access Interrupt_Mask) return Interrupt_ID\n+   is\n+      pragma Unreferenced (Mask);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Interrupt_Wait unimplemented\");\n+      return 0;\n+   end Interrupt_Wait;\n+\n+   ----------------------------\n+   -- Install_Default_Action --\n+   ----------------------------\n+\n+   procedure Install_Default_Action (Interrupt : Interrupt_ID) is\n+      pragma Unreferenced (Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Install_Default_Action unimplemented\");\n+   end Install_Default_Action;\n+\n+   ---------------------------\n+   -- Install_Ignore_Action --\n+   ---------------------------\n+\n+   procedure Install_Ignore_Action (Interrupt : Interrupt_ID) is\n+      pragma Unreferenced (Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Install_Ignore_Action unimplemented\");\n+   end Install_Ignore_Action;\n+\n+   -------------------------\n+   -- Fill_Interrupt_Mask --\n+   -------------------------\n+\n+   procedure Fill_Interrupt_Mask (Mask : access Interrupt_Mask) is\n+      pragma Unreferenced (Mask);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Fill_Interrupt_Mask unimplemented\");\n+   end Fill_Interrupt_Mask;\n+\n+   --------------------------\n+   -- Empty_Interrupt_Mask --\n+   --------------------------\n+\n+   procedure Empty_Interrupt_Mask (Mask : access Interrupt_Mask) is\n+      pragma Unreferenced (Mask);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Empty_Interrupt_Mask unimplemented\");\n+   end Empty_Interrupt_Mask;\n+\n+   ---------------------------\n+   -- Add_To_Interrupt_Mask --\n+   ---------------------------\n+\n+   procedure Add_To_Interrupt_Mask\n+     (Mask      : access Interrupt_Mask;\n+      Interrupt : Interrupt_ID)\n+   is\n+      pragma Unreferenced (Mask, Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Add_To_Interrupt_Mask unimplemented\");\n+   end Add_To_Interrupt_Mask;\n+\n+   --------------------------------\n+   -- Delete_From_Interrupt_Mask --\n+   --------------------------------\n+\n+   procedure Delete_From_Interrupt_Mask\n+     (Mask      : access Interrupt_Mask;\n+      Interrupt : Interrupt_ID)\n+   is\n+      pragma Unreferenced (Mask, Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Delete_From_Interrupt_Mask unimplemented\");\n+   end Delete_From_Interrupt_Mask;\n+\n+   ---------------\n+   -- Is_Member --\n+   ---------------\n+\n+   function Is_Member\n+     (Mask      : access Interrupt_Mask;\n+      Interrupt : Interrupt_ID) return Boolean\n+   is\n+      pragma Unreferenced (Mask, Interrupt);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Is_Member unimplemented\");\n+      return False;\n+   end Is_Member;\n+\n+   -------------------------\n+   -- Copy_Interrupt_Mask --\n+   -------------------------\n+\n+   procedure Copy_Interrupt_Mask\n+     (X : out Interrupt_Mask;\n+      Y : Interrupt_Mask) is\n+      pragma Unreferenced (X, Y);\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Copy_Interrupt_Mask unimplemented\");\n+   end Copy_Interrupt_Mask;\n+\n+   ----------------------------\n+   -- Interrupt_Self_Process --\n+   ----------------------------\n+\n+   procedure Interrupt_Self_Process (Interrupt : Interrupt_ID) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := kill (getpid, Signal (Interrupt));\n+      pragma Assert (Result = 0);\n+   end Interrupt_Self_Process;\n+\n+   --------------------------\n+   -- Setup_Interrupt_Mask --\n+   --------------------------\n+\n+   procedure Setup_Interrupt_Mask is\n+   begin\n+      Raise_Exception\n+        (Program_Error'Identity,\n+         \"Setup_Interrupt_Mask unimplemented\");\n+   end Setup_Interrupt_Mask;\n+\n+end System.Interrupt_Management.Operations;"}, {"sha": "853d746d137dc027e74ac79e88e284a12a7c1551", "filename": "gcc/ada/s-intman-vxworks.adb", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-intman-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-intman-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,8 @@\n \n --  This is the VxWorks version of this package\n \n---  Make a careful study of all signals available under the OS, to see which\n---  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n---  the lookout for special signals that may be used by the thread library.\n+--  It is simpler than other versions because the Ada interrupt handling\n+--  mechanisms are used for hardware interrupts rather than signals.\n \n package body System.Interrupt_Management is\n \n@@ -45,15 +44,21 @@ package body System.Interrupt_Management is\n                          (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n \n    Exception_Action : aliased struct_sigaction;\n-   --  Keep this variable global so that it is initialized only once\n+   --  Keep this a variable global so that it is initialized only once\n+\n+   Signal_Mask : aliased sigset_t;\n+   pragma Import (C, Signal_Mask, \"__gnat_signal_mask\");\n+   --  Mask indicating that all exception signals are to be masked\n+   --  when a signal is propagated.\n \n    procedure Notify_Exception\n      (signo      : Signal;\n       siginfo    : System.Address;\n       sigcontext : System.Address);\n    pragma Import (C, Notify_Exception, \"__gnat_error_handler\");\n-   --  Map signal to Ada exception and raise it.  Different versions\n-   --  of VxWorks need different mappings.\n+   --  Map a signal to Ada exception and raise it.  Different versions\n+   --  of VxWorks need different mappings. This is addressed in init.c in\n+   --  __gnat_map_signal.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -62,7 +67,7 @@ package body System.Interrupt_Management is\n    function State (Int : Interrupt_ID) return Character;\n    pragma Import (C, State, \"__gnat_get_interrupt_state\");\n    --  Get interrupt state. Defined in init.c The input argument is the\n-   --  interrupt number, and the result is one of the following:\n+   --  hardware interrupt number, and the result is one of the following:\n \n    Runtime : constant Character := 'r';\n    Default : constant Character := 's';\n@@ -100,8 +105,6 @@ package body System.Interrupt_Management is\n    --  Set to True once Initialize is called, further calls have no effect\n \n    procedure Initialize is\n-      mask   : aliased sigset_t;\n-      Result : int;\n \n    begin\n       if Initialized then\n@@ -115,17 +118,11 @@ package body System.Interrupt_Management is\n \n       Abort_Task_Interrupt := SIGABRT;\n \n+      --  Signal_Mask was initialized in __gnat_install_handler\n+\n       Exception_Action.sa_handler := Notify_Exception'Address;\n       Exception_Action.sa_flags := SA_ONSTACK + SA_SIGINFO;\n-      Result := sigemptyset (mask'Access);\n-      pragma Assert (Result = 0);\n-\n-      for J in Exception_Signals'Range loop\n-         Result := sigaddset (mask'Access, Signal (Exception_Signals (J)));\n-         pragma Assert (Result = 0);\n-      end loop;\n-\n-      Exception_Action.sa_mask := mask;\n+      Exception_Action.sa_mask := Signal_Mask;\n \n       --  Initialize hardware interrupt handling\n \n@@ -139,15 +136,6 @@ package body System.Interrupt_Management is\n          end if;\n       end loop;\n \n-      --  Add exception signals to the set of unmasked signals\n-\n-      for J in Exception_Signals'Range loop\n-         Keep_Unmasked (Exception_Signals (J)) := True;\n-      end loop;\n-\n-      --  The abort signal must also be unmasked\n-\n-      Keep_Unmasked (Abort_Task_Interrupt) := True;\n    end Initialize;\n \n end System.Interrupt_Management;"}, {"sha": "c86410a8695d590565912f9a7dce622ba6523075", "filename": "gcc/ada/s-intman-vxworks.ads", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-intman-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-intman-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.ads?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -80,14 +80,6 @@ package System.Interrupt_Management is\n    --  The signal that is used to implement task abort if an interrupt is used\n    --  for that purpose. This is one of the reserved signals.\n \n-   Keep_Unmasked : Signal_Set := (others => False);\n-   --  Keep_Unmasked (I) is true iff the signal I is one that must that must\n-   --  be kept unmasked at all times, except (perhaps) for short critical\n-   --  sections. This includes signals that are mapped to exceptions, but may\n-   --  also include interrupts (e.g. timer) that need to be kept unmasked for\n-   --  other reasons. Where signal masking is per-task, the signal should be\n-   --  unmasked in ALL TASKS.\n-\n    Reserve : Interrupt_Set := (others => False);\n    --  Reserve (I) is true iff the interrupt I is one that cannot be permitted\n    --  to be attached to a user handler. The possible reasons are many. For"}, {"sha": "207b465c5792d5380feab418b5aaa34c6c67131c", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -78,40 +78,34 @@ package body System.Task_Primitives.Operations is\n    --  The followings are logically constants, but need to be initialized at\n    --  run time.\n \n-   Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at a\n-   --  time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n-\n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n \n-   Unblocked_Signal_Mask : aliased sigset_t;\n-   --  The set of signals that should unblocked in all tasks\n-\n    --  The followings are internal configuration constants needed\n \n-   Time_Slice_Val : Integer;\n-   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+   Dispatching_Policy : Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   Foreign_Task_Elaborated : aliased Boolean := True;\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n \n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n \n-   Dispatching_Policy : Character;\n-   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n-\n    Mutex_Protocol : Priority_Type;\n \n-   Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads)\n+   Signal_Mask : aliased sigset_t;\n+   pragma Import (C, Signal_Mask, \"__gnat_signal_mask\");\n+   --  Mask indicating that all exception signals are to be masked\n+   --  when a signal is propagated.\n \n-   type Set_Stack_Limit_Proc_Acc is access procedure;\n-   pragma Convention (C, Set_Stack_Limit_Proc_Acc);\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at a\n+   --  time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n-   Set_Stack_Limit_Hook : Set_Stack_Limit_Proc_Acc;\n-   pragma Import (C, Set_Stack_Limit_Hook, \"__gnat_set_stack_limit_hook\");\n-   --  Procedure to be called when a task is created to set stack\n-   --  limit.\n+   Time_Slice_Val : Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n \n    --------------------\n    -- Local Packages --\n@@ -168,6 +162,14 @@ package body System.Task_Primitives.Operations is\n    --  This function returns True if the current execution is in the context\n    --  of a task, and False if it is an interrupt context.\n \n+   type Set_Stack_Limit_Proc_Acc is access procedure;\n+   pragma Convention (C, Set_Stack_Limit_Proc_Acc);\n+\n+   Set_Stack_Limit_Hook : Set_Stack_Limit_Proc_Acc;\n+   pragma Import (C, Set_Stack_Limit_Hook, \"__gnat_set_stack_limit_hook\");\n+   --  Procedure to be called when a task is created to set stack\n+   --  limit. Used only for VxWorks 5 and VxWorks MILS guest OS.\n+\n    function To_Address is\n      new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n@@ -180,7 +182,6 @@ package body System.Task_Primitives.Operations is\n \n       Self_ID : constant Task_Id := Self;\n       Old_Set : aliased sigset_t;\n-\n       Result : int;\n       pragma Warnings (Off, Result);\n \n@@ -198,12 +199,12 @@ package body System.Task_Primitives.Operations is\n       then\n          Self_ID.Aborting := True;\n \n-         --  Make sure signals used for RTS internal purpose are unmasked\n+         --  Make sure signals used for RTS internal purposes are unmasked\n \n          Result :=\n            pthread_sigmask\n              (SIG_UNBLOCK,\n-              Unblocked_Signal_Mask'Access,\n+              Signal_Mask'Access,\n               Old_Set'Access);\n          pragma Assert (Result = 0);\n \n@@ -1380,16 +1381,6 @@ package body System.Task_Primitives.Operations is\n \n       end if;\n \n-      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n-      pragma Assert (Result = 0);\n-\n-      for J in Interrupt_Management.Signal_ID loop\n-         if System.Interrupt_Management.Keep_Unmasked (J) then\n-            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n-            pragma Assert (Result = 0);\n-         end if;\n-      end loop;\n-\n       --  Initialize the lock used to synchronize chain of all ATCBs\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);"}, {"sha": "3dc7ee8dd85a045fae83709087e42f424ce5be75", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -128,6 +128,9 @@ package body Sem_Ch6 is\n    --  If proper warnings are enabled and the subprogram contains a construct\n    --  that cannot be inlined, the offending construct is flagged accordingly.\n \n+   function Can_Override_Operator (Subp : Entity_Id) return Boolean;\n+   --  Returns true if Subp can override a predefined operator.\n+\n    procedure Check_Conformance\n      (New_Id                   : Entity_Id;\n       Old_Id                   : Entity_Id;\n@@ -2099,11 +2102,19 @@ package body Sem_Ch6 is\n                   Body_Spec);\n             end if;\n \n-         elsif Style_Check --  ??? incorrect use of Style_Check!\n+         elsif Style_Check\n            and then Present (Overridden_Operation (Spec_Id))\n          then\n             pragma Assert (Unit_Declaration_Node (Body_Id) = N);\n             Style.Missing_Overriding (N, Body_Id);\n+\n+         elsif Style_Check\n+           and then Can_Override_Operator (Spec_Id)\n+           and then not Is_Predefined_File_Name\n+                          (Unit_File_Name (Get_Source_Unit (Spec_Id)))\n+         then\n+            pragma Assert (Unit_Declaration_Node (Body_Id) = N);\n+            Style.Missing_Overriding (N, Body_Id);\n          end if;\n       end Verify_Overriding_Indicator;\n \n@@ -4854,61 +4865,50 @@ package body Sem_Ch6 is\n       --  explicit overridden operation.\n \n       elsif Nkind (Subp) = N_Defining_Operator_Symbol then\n-         declare\n-            Typ : constant Entity_Id :=\n-                    Base_Type (Etype (First_Formal (Subp)));\n-\n-            Can_Override : constant Boolean :=\n-                             Operator_Matches_Spec (Subp, Subp)\n-                               and then Scope (Subp) = Scope (Typ)\n-                               and then not Is_Class_Wide_Type (Typ);\n+         if Must_Not_Override (Spec) then\n \n-         begin\n-            if Must_Not_Override (Spec) then\n+            --  If this is not a primitive or a protected subprogram, then\n+            --  \"not overriding\" is illegal.\n \n-               --  If this is not a primitive or a protected subprogram, then\n-               --  \"not overriding\" is illegal.\n+            if not Is_Primitive\n+              and then Ekind (Scope (Subp)) /= E_Protected_Type\n+            then\n+               Error_Msg_N\n+                 (\"overriding indicator only allowed \"\n+                  & \"if subprogram is primitive\", Subp);\n \n-               if not Is_Primitive\n-                 and then Ekind (Scope (Subp)) /= E_Protected_Type\n-               then\n-                  Error_Msg_N\n-                    (\"overriding indicator only allowed \"\n-                     & \"if subprogram is primitive\", Subp);\n+            elsif Can_Override_Operator (Subp) then\n+               Error_Msg_NE\n+                 (\"subprogram& overrides predefined operator \", Spec, Subp);\n+            end if;\n \n-               elsif Can_Override then\n-                  Error_Msg_NE\n-                    (\"subprogram& overrides predefined operator \", Spec, Subp);\n-               end if;\n+         elsif Must_Override (Spec) then\n+            if No (Overridden_Operation (Subp))\n+              and then not Can_Override_Operator (Subp)\n+            then\n+               Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n+            end if;\n \n-            elsif Must_Override (Spec) then\n-               if No (Overridden_Operation (Subp))\n-                 and then not Can_Override\n-               then\n-                  Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n-               end if;\n+         elsif not Error_Posted (Subp)\n+           and then Style_Check\n+           and then Can_Override_Operator (Subp)\n+           and then\n+             not Is_Predefined_File_Name\n+                   (Unit_File_Name (Get_Source_Unit (Subp)))\n+         then\n+            --  If style checks are enabled, indicate that the indicator is\n+            --  missing. However, at the point of declaration, the type of\n+            --  which this is a primitive operation may be private, in which\n+            --  case the indicator would be premature.\n \n-            elsif not Error_Posted (Subp)\n-              and then Style_Check\n-              and then Can_Override\n-              and then\n-                not Is_Predefined_File_Name\n-                      (Unit_File_Name (Get_Source_Unit (Subp)))\n+            if Has_Private_Declaration (Etype (Subp))\n+              or else Has_Private_Declaration (Etype (First_Formal (Subp)))\n             then\n-               --  If style checks are enabled, indicate that the indicator is\n-               --  missing. However, at the point of declaration, the type of\n-               --  which this is a primitive operation may be private, in which\n-               --  case the indicator would be premature.\n-\n-               if Has_Private_Declaration (Etype (Subp))\n-                 or else Has_Private_Declaration (Etype (First_Formal (Subp)))\n-               then\n-                  null;\n-               else\n-                  Style.Missing_Overriding (Decl, Subp);\n-               end if;\n+               null;\n+            else\n+               Style.Missing_Overriding (Decl, Subp);\n             end if;\n-         end;\n+         end if;\n \n       elsif Must_Override (Spec) then\n          if Ekind (Subp) = E_Entry then\n@@ -5442,6 +5442,25 @@ package body Sem_Ch6 is\n         (New_Id, Old_Id, Type_Conformant, True, Result, Err_Loc);\n    end Check_Type_Conformant;\n \n+   ---------------------------\n+   -- Can_Override_Operator --\n+   ---------------------------\n+\n+   function Can_Override_Operator (Subp : Entity_Id) return Boolean is\n+      Typ : Entity_Id;\n+   begin\n+      if Nkind (Subp) /= N_Defining_Operator_Symbol then\n+         return False;\n+\n+      else\n+         Typ := Base_Type (Etype (First_Formal (Subp)));\n+\n+         return Operator_Matches_Spec (Subp, Subp)\n+           and then Scope (Subp) = Scope (Typ)\n+           and then not Is_Class_Wide_Type (Typ);\n+      end if;\n+   end Can_Override_Operator;\n+\n    ----------------------\n    -- Conforming_Types --\n    ----------------------"}, {"sha": "32d4002034355b8bae8b72e3d83a4da945c5e4b8", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -2683,12 +2683,24 @@ package body Sem_Ch8 is\n       --  been analyzed previously, and it is begin reinstalled, for example\n       --  when the clause appears in a package spec and we are compiling the\n       --  corresponding package body. In that case, make the entities on the\n-      --  existing list use-visible.\n+      --  existing list use_visible, and mark the corresponding types In_Use.\n \n       if Present (Used_Operations (N)) then\n          declare\n+            Mark : Node_Id;\n             Elmt : Elmt_Id;\n+\n          begin\n+            Mark := First (Subtype_Marks (N));\n+            while Present (Mark) loop\n+               if not In_Use (Entity (Mark))\n+                 and then not Is_Potentially_Use_Visible (Entity (Mark))\n+               then\n+                  Set_In_Use (Base_Type (Entity (Mark)));\n+               end if;\n+               Next (Mark);\n+            end loop;\n+\n             Elmt := First_Elmt (Used_Operations (N));\n             while Present (Elmt) loop\n                Set_Is_Potentially_Use_Visible (Node (Elmt));"}, {"sha": "d40ad9b2b6e29ce02868846147389328423bbb80", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f6d372157633408dc26c7903e43b732710530/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=806f6d372157633408dc26c7903e43b732710530", "patch": "@@ -5648,10 +5648,14 @@ package body Sem_Res is\n          Check_Potentially_Blocking_Operation (N);\n       end if;\n \n-      --  A call to Ada.Real_Time.Timing_Events.Set_Handler violates\n-      --  restriction No_Relative_Delay (AI-0211).\n+      --  A call to Ada.Real_Time.Timing_Events.Set_Handler to set a relative\n+      --  timing event violates restriction No_Relative_Delay (AI-0211). We\n+      --  need to check the second argument to determine whether it is an\n+      --  absolute or relative timing event.\n \n-      if Is_RTE (Nam, RE_Set_Handler) then\n+      if Is_RTE (Nam, RE_Set_Handler)\n+        and then Is_RTE (Etype (Next_Actual (First_Actual (N))), RE_Time_Span)\n+      then\n          Check_Restriction (No_Relative_Delay, N);\n       end if;\n "}]}