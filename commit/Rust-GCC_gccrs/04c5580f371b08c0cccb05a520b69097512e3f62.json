{"sha": "04c5580f371b08c0cccb05a520b69097512e3f62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRjNTU4MGYzNzFiMDhjMGNjY2IwNWE1MjBiNjkwOTc1MTJlM2Y2Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-04-17T23:31:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-04-17T23:31:41Z"}, "message": "emit-rtl.c (subreg_hard_regno): Check that register is representable.\n\n\n\n\t* emit-rtl.c (subreg_hard_regno):  Check that register is representable.\n\t* reload.c (reload_inner_reg_of_subreg):  When register is not\n\trepresentable, reload the whole thing.\n\t(find_reloads): Likewsie.\n\t* rtlanal.c (subreg_representable_p):  New function.\n\n\t* profile.c (compute_branch_probabilities):  Cleanup sanity checking;\n\tallow negative probabilities for edges from the call to exit.\n\t(branch_prob): Do not add fake edges for functions that may return twice\n\nFrom-SVN: r65757", "tree": {"sha": "0bb84f63ed128b54b740a46b5532d57a1116b085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bb84f63ed128b54b740a46b5532d57a1116b085"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04c5580f371b08c0cccb05a520b69097512e3f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c5580f371b08c0cccb05a520b69097512e3f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04c5580f371b08c0cccb05a520b69097512e3f62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c5580f371b08c0cccb05a520b69097512e3f62/comments", "author": null, "committer": null, "parents": [{"sha": "c409ea0d30ef28e68ff6b4fcb699ba013ee947f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c409ea0d30ef28e68ff6b4fcb699ba013ee947f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c409ea0d30ef28e68ff6b4fcb699ba013ee947f1"}], "stats": {"total": 214, "additions": 154, "deletions": 60}, "files": [{"sha": "7c393c51660885ebd55fb9afaa3547d59122312a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04c5580f371b08c0cccb05a520b69097512e3f62", "patch": "@@ -1,3 +1,15 @@\n+Fri Apr 18 01:28:51 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* emit-rtl.c (subreg_hard_regno):  Check that register is representable.\n+\t* reload.c (reload_inner_reg_of_subreg):  When register is not\n+\trepresentable, reload the whole thing.\n+\t(find_reloads): Likewsie.\n+\t* rtlanal.c (subreg_representable_p):  New function.\n+\n+\t* profile.c (compute_branch_probabilities):  Cleanup sanity checking;\n+\tallow negative probabilities for edges from the call to exit.\n+\t(branch_prob): Do not add fake edges for functions that may return twice\n+\n 2003-04-17  DJ Delorie  <dj@redhat.com>\n \n \t* toplev.c (target_options): Add value field."}, {"sha": "7048aee61dfe5fefa3ea557f481b1635e9151981", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=04c5580f371b08c0cccb05a520b69097512e3f62", "patch": "@@ -1081,7 +1081,11 @@ subreg_hard_regno (x, check_mode)\n     abort ();\n   if (check_mode && ! HARD_REGNO_MODE_OK (base_regno, GET_MODE (reg)))\n     abort ();\n-\n+#ifdef ENABLE_CHECKING\n+  if (!subreg_offset_representable_p (REGNO (reg), GET_MODE (reg),\n+\t\t\t  \t      SUBREG_BYTE (x), mode))\n+    abort ();\n+#endif\n   /* Catch non-congruent offsets too.  */\n   byte_offset = SUBREG_BYTE (x);\n   if ((byte_offset % GET_MODE_SIZE (mode)) != 0)"}, {"sha": "afabe20a42f95036a33134a169b3afc28b05185b", "filename": "gcc/profile.c", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=04c5580f371b08c0cccb05a520b69097512e3f62", "patch": "@@ -674,22 +674,47 @@ compute_branch_probabilities ()\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n       edge e;\n-      gcov_type total;\n       rtx note;\n \n-      total = bb->count;\n-      if (total)\n+      if (bb->count < 0)\n \t{\n-\t  for (e = bb->succ; e; e = e->succ_next)\n+\t  error (\"corrupted profile info: number of iterations for basic block %d thought to be %i\",\n+\t\t bb->index, (int)bb->count);\n+\t  bb->count = 0;\n+\t}\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  /* Function may return twice in the cased the called fucntion is\n+\t     setjmp or calls fork, but we can't represent this by extra\n+\t     edge from the entry, since extra edge from the exit is\n+\t     already present.  We get negative frequency from the entry\n+\t     point.  */\n+\t  if ((e->count < 0\n+\t       && e->dest == EXIT_BLOCK_PTR)\n+\t      || (e->count > bb->count\n+\t\t  && e->dest != EXIT_BLOCK_PTR))\n \t    {\n-\t\te->probability = (e->count * REG_BR_PROB_BASE + total / 2) / total;\n-\t\tif (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n-\t\t  {\n-\t\t    error (\"corrupted profile info: prob for %d-%d thought to be %d\",\n-\t\t\t   e->src->index, e->dest->index, e->probability);\n-\t\t    e->probability = REG_BR_PROB_BASE / 2;\n-\t\t  }\n+\t      rtx insn = bb->end;\n+\n+\t      while (GET_CODE (insn) != CALL_INSN\n+\t\t     && insn != bb->head\n+\t\t     && keep_with_call_p (insn))\n+\t\tinsn = PREV_INSN (insn);\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\te->count = e->count < 0 ? 0 : bb->count;\n \t    }\n+\t  if (e->count < 0 || e->count > bb->count)\n+\t    {\n+\t      error (\"corrupted profile info: number of executions for edge %d-%d thought to be %i\",\n+\t\t     e->src->index, e->dest->index,\n+\t\t     (int)e->count);\n+\t      e->count = bb->count / 2;\n+\t    }\n+\t}\n+      if (bb->count)\n+\t{\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    e->probability = (e->count * REG_BR_PROB_BASE + bb->count / 2) / bb->count;\n \t  if (bb->index >= 0\n \t      && any_condjump_p (bb->end)\n \t      && bb->succ->succ_next)\n@@ -730,6 +755,8 @@ compute_branch_probabilities ()\n \t calls).  */\n       else\n \t{\n+\t  int total = 0;\n+\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    if (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n \t      total ++;\n@@ -873,36 +900,13 @@ branch_prob ()\n     {\n       int need_exit_edge = 0, need_entry_edge = 0;\n       int have_exit_edge = 0, have_entry_edge = 0;\n-      rtx insn;\n       edge e;\n \n-      /* Add fake edges from entry block to the call insns that may return\n-\t twice.  The CFG is not quite correct then, as call insn plays more\n-\t role of CODE_LABEL, but for our purposes, everything should be OK,\n-\t as we never insert code to the beginning of basic block.  */\n-      for (insn = bb->head; insn != NEXT_INSN (bb->end);\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == CALL_INSN\n-\t      && find_reg_note (insn, REG_SETJMP, NULL))\n-\t    {\n-\t      if (GET_CODE (bb->head) == CODE_LABEL\n-\t\t  || insn != NEXT_INSN (bb->head))\n-\t\t{\n-\t\t  e = split_block (bb, PREV_INSN (insn));\n-\t\t  make_edge (ENTRY_BLOCK_PTR, e->dest, EDGE_FAKE);\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* We should not get abort here, as call to setjmp should not\n-\t\t     be the very first instruction of function.  */\n-\t\t  if (bb == ENTRY_BLOCK_PTR)\n-\t\t    abort ();\n-\t\t  make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n-\t\t}\n-\t    }\n-\t}\n+      /* Functions returning multiple times are not handled by extra edges.\n+         Instead we simply allow negative counts on edges from exit to the\n+         block past call and corresponding probabilities.  We can't go\n+         with the extra edges because that would result in flowgraph that\n+\t needs to have fake edges outside the spanning tree.  */\n \n       for (e = bb->succ; e; e = e->succ_next)\n \t{"}, {"sha": "bc3c1771d972ca38cc2ea4492cd3a411a47286e4", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=04c5580f371b08c0cccb05a520b69097512e3f62", "patch": "@@ -2880,6 +2880,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      if (GET_CODE (SUBREG_REG (operand)) == REG\n \t\t  && REGNO (SUBREG_REG (operand)) < FIRST_PSEUDO_REGISTER)\n \t\t{\n+\t\t  if (!subreg_offset_representable_p\n+\t\t\t(REGNO (SUBREG_REG (operand)),\n+\t\t\t GET_MODE (SUBREG_REG (operand)),\n+\t\t\t SUBREG_BYTE (operand),\n+\t\t\t GET_MODE (operand)))\n+\t\t     force_reload = 1;\n \t\t  offset += subreg_regno_offset (REGNO (SUBREG_REG (operand)),\n \t\t\t\t\t\t GET_MODE (SUBREG_REG (operand)),\n \t\t\t\t\t\t SUBREG_BYTE (operand),\n@@ -2935,26 +2941,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t  )\n #endif\n \t\t      )\n-\t\t  /* This following hunk of code should no longer be\n-\t\t     needed at all with SUBREG_BYTE.  If you need this\n-\t\t     code back, please explain to me why so I can\n-\t\t     fix the real problem.  -DaveM */\n-#if 0\n-\t\t  /* Subreg of a hard reg which can't handle the subreg's mode\n-\t\t     or which would handle that mode in the wrong number of\n-\t\t     registers for subregging to work.  */\n-\t\t  || (GET_CODE (operand) == REG\n-\t\t      && REGNO (operand) < FIRST_PSEUDO_REGISTER\n-\t\t      && ((GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t\t\t   && (GET_MODE_SIZE (GET_MODE (operand))\n-\t\t\t       > UNITS_PER_WORD)\n-\t\t\t   && ((GET_MODE_SIZE (GET_MODE (operand))\n-\t\t\t\t/ UNITS_PER_WORD)\n-\t\t\t       != HARD_REGNO_NREGS (REGNO (operand),\n-\t\t\t\t\t\t    GET_MODE (operand))))\n-\t\t\t  || ! HARD_REGNO_MODE_OK (REGNO (operand) + offset,\n-\t\t\t\t\t\t   operand_mode[i])))\n-#endif\n \t\t  )\n \t\tforce_reload = 1;\n \t    }\n@@ -5272,6 +5258,19 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t\t\t       SUBREG_BYTE (orig_op1),\n \t\t\t\t\t\t       GET_MODE (orig_op1))));\n \t  }\n+\t/* Plus in the index register may be created only as a result of\n+\t   register remateralization for expresion like &localvar*4.  Reload it.\n+\t   It may be possible to combine the displacement on the outer level,\n+\t   but it is probably not worthwhile to do so.  */\n+\tif (context)\n+\t  {\n+\t    find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n+\t\t\t\t  opnum, ADDR_TYPE (type), ind_levels, insn);\n+\t    push_reload (*loc, NULL_RTX, loc, (rtx*) 0,\n+\t\t\t (context ? INDEX_REG_CLASS : MODE_BASE_REG_CLASS (mode)),\n+\t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t    return 1;\n+\t  }\n \n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n \t    || code0 == ZERO_EXTEND || code1 == MEM)"}, {"sha": "b78e9e78db38881075e17ee7afdbe1ac550931c7", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=04c5580f371b08c0cccb05a520b69097512e3f62", "patch": "@@ -1038,6 +1038,10 @@ extern unsigned int subreg_regno_offset \tPARAMS ((unsigned int,\n \t\t\t\t\t\t\t enum machine_mode, \n \t\t\t\t\t\t\t unsigned int, \n \t\t\t\t\t\t\t enum machine_mode));\n+extern bool subreg_offset_representable_p \tPARAMS ((unsigned int, \n+\t\t\t\t\t\t\t enum machine_mode, \n+\t\t\t\t\t\t\t unsigned int, \n+\t\t\t\t\t\t\t enum machine_mode));\n extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n /* 1 if RTX is a subreg containing a reg that is already known to be"}, {"sha": "3b024adc89d0402dba162b420c19a858b27dc72e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c5580f371b08c0cccb05a520b69097512e3f62/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=04c5580f371b08c0cccb05a520b69097512e3f62", "patch": "@@ -3387,6 +3387,77 @@ subreg_regno_offset (xregno, xmode, offset, ymode)\n   return (y_offset / (mode_multiple / nregs_multiple)) * nregs_ymode;\n }\n \n+/* This function returns true when the offset is representable via\n+   subreg_offset in the given regno.\n+   xregno - A regno of an inner hard subreg_reg (or what will become one).\n+   xmode  - The mode of xregno.\n+   offset - The byte offset.\n+   ymode  - The mode of a top level SUBREG (or what may become one).\n+   RETURN - The regno offset which would be used.  */\n+bool\n+subreg_offset_representable_p (xregno, xmode, offset, ymode)\n+     unsigned int xregno;\n+     enum machine_mode xmode;\n+     unsigned int offset;\n+     enum machine_mode ymode;\n+{\n+  int nregs_xmode, nregs_ymode;\n+  int mode_multiple, nregs_multiple;\n+  int y_offset;\n+\n+  if (xregno >= FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n+  nregs_xmode = HARD_REGNO_NREGS (xregno, xmode);\n+  nregs_ymode = HARD_REGNO_NREGS (xregno, ymode);\n+\n+  /* paradoxical subregs are always valid.  */\n+  if (offset == 0\n+      && nregs_ymode > nregs_xmode\n+      && (GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n+\t  ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n+    return true;\n+\n+  /* Lowpart subregs are always valid.  */\n+  if (offset == subreg_lowpart_offset (ymode, xmode))\n+    return true;\n+\n+#ifdef ENABLE_CHECKING\n+  /* This should always pass, otherwise we don't know how to verify the\n+     constraint. \n+\n+     These conditions may be relaxed but subreg_offset would need to be\n+     redesigned.  */\n+  if (GET_MODE_SIZE (xmode) % GET_MODE_SIZE (ymode)\n+      || GET_MODE_SIZE (ymode) % nregs_ymode\n+      || mode_for_size (GET_MODE_SIZE (ymode) / nregs_ymode,\n+\t      \t\tMODE_INT, 0) == VOIDmode\n+      || nregs_xmode % nregs_ymode)\n+    abort ();\n+#endif\n+\n+  /* The XMODE value can be seen as an vector of NREGS_XMODE\n+     values.  The subreg must represent an lowpart of given field.\n+     Compute what field it is.  */\n+  offset -= subreg_lowpart_offset (mode_for_size (GET_MODE_SIZE (ymode)\n+\t\t\t  \t\t\t  / nregs_ymode,\n+\t\t\t\t\t\t  MODE_INT, 0), xmode);\n+\n+  /* size of ymode must not be greater than the size of xmode.  */\n+  mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n+  if (mode_multiple == 0)\n+    abort ();\n+\n+  y_offset = offset / GET_MODE_SIZE (ymode);\n+  nregs_multiple =  nregs_xmode / nregs_ymode;\n+#ifdef ENABLE_CHECKING\n+  if (offset % GET_MODE_SIZE (ymode)\n+      || mode_multiple % nregs_multiple)\n+    abort ();\n+#endif\n+  return (!(y_offset % (mode_multiple / nregs_multiple)));\n+}\n+\n /* Return the final regno that a subreg expression refers to.  */\n unsigned int\n subreg_regno (x)"}]}