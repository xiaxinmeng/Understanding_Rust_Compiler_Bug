{"sha": "2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRmYzBmMjIwM2U4NzU2MjFmNGFlYjJlMjQ5NmFhZWI5YTJkYzA1Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-29T09:30:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-29T11:10:36Z"}, "message": "Refactor SLP permute opt propagation\n\nThis rewrites the SLP permute opt propagation to elide the visited\nbit for an incoming permute of -1 as well as allowing the initial\npropagation to take more than one iteration before starting on\nmaterialization.  As we still lack propagation in the reverse\ndirection I've added gcc.dg/vect/bb-slp-71.c and a stopgap to\nrestrict \"any\" permute handling to the supported cases.\n\n2021-06-29  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (slpg_vertex::visited): Remove.\n\t(vect_slp_perms_eq): Handle -1 permutes.\n\t(vect_optimize_slp): Rewrite permute propagation.\n\n\t* gcc.dg/vect/pr67790.c: Un-XFAIL.\n\t* gcc.dg/vect/bb-slp-71.c: New testcase.", "tree": {"sha": "0553703f170aca29424a56eeeafa18adb0efd02f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0553703f170aca29424a56eeeafa18adb0efd02f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53fd7544aff6d0a18869017cb9bb921a7f5dcd04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fd7544aff6d0a18869017cb9bb921a7f5dcd04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53fd7544aff6d0a18869017cb9bb921a7f5dcd04"}], "stats": {"total": 174, "additions": 120, "deletions": 54}, "files": [{"sha": "6816511cd0fe7ba9e76a8e13a8e0df8b24e9184a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-71.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-71.c?ref=2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+int a[4], b[4];\n+\n+void __attribute__((noipa))\n+foo(int x, int y)\n+{\n+  int tem0 = x + 1;\n+  int tem1 = y + 2;\n+  int tem2 = x + 3;\n+  int tem3 = y + 4;\n+  a[0] = tem0 + b[1];\n+  a[1] = tem1 + b[0];\n+  a[2] = tem2 + b[2];\n+  a[3] = tem3 + b[3];\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  b[0] = 10;\n+  b[1] = 14;\n+  b[2] = 18;\n+  b[3] = 22;\n+  foo (-1, -3);\n+  if (a[0] != 14 || a[1] != 9 || a[2] != 20 || a[3] != 23)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "32eacd91fdaa209dc04efe934798e524ac5fea8d", "filename": "gcc/testsuite/gcc.dg/vect/pr67790.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c?ref=2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "patch": "@@ -38,4 +38,4 @@ int main()\n }\n \n /* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 0 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 0 \"vect\" } } */"}, {"sha": "524bfaa1c7f5c415abe0320348a5cd901eeb2d25", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 87, "deletions": 53, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2dfc0f2203e875621f4aeb2e2496aaeb9a2dc05b", "patch": "@@ -3470,12 +3470,11 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n struct slpg_vertex\n {\n   slpg_vertex (slp_tree node_)\n-    : node (node_), visited (0), perm_out (0), materialize (0) {}\n+    : node (node_), perm_out (-1), materialize (0) {}\n \n   int get_perm_in () const { return materialize ? materialize : perm_out; }\n \n   slp_tree node;\n-  unsigned visited : 1;\n   /* The permutation on the outgoing lanes (towards SLP parents).  */\n   int perm_out;\n   /* The permutation that is applied by this node.  perm_out is\n@@ -3567,7 +3566,8 @@ vect_slp_perms_eq (const vec<vec<unsigned> > &perms,\n \t\t   int perm_a, int perm_b)\n {\n   return (perm_a == perm_b\n-\t  || (perms[perm_a].length () == perms[perm_b].length ()\n+\t  || (perm_a != -1 && perm_b != -1\n+\t      && perms[perm_a].length () == perms[perm_b].length ()\n \t      && memcmp (&perms[perm_a][0], &perms[perm_b][0],\n \t\t\t sizeof (unsigned) * perms[perm_a].length ()) == 0));\n }\n@@ -3614,7 +3614,7 @@ vect_optimize_slp (vec_info *vinfo)\n       /* Leafs do not change across iterations.  Note leafs also double\n \t as entries to the reverse graph.  */\n       if (!slpg->vertices[idx].succ)\n-\tvertices[idx].visited = 1;\n+\tvertices[idx].perm_out = 0;\n       /* Loads are the only thing generating permutes.  */\n       if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \tcontinue;\n@@ -3668,12 +3668,17 @@ vect_optimize_slp (vec_info *vinfo)\n \n   /* Propagate permutes along the graph and compute materialization points.  */\n   bool changed;\n+  bool do_materialization = false;\n   unsigned iteration = 0;\n   do\n     {\n       changed = false;\n       ++iteration;\n \n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"SLP optimize iteration %d\\n\", iteration);\n+\n       for (i = vertices.length (); i > 0 ; --i)\n \t{\n \t  int idx = ipo[i-1];\n@@ -3685,19 +3690,21 @@ vect_optimize_slp (vec_info *vinfo)\n \t      || SLP_TREE_DEF_TYPE (node) == vect_constant_def)\n \t    continue;\n \n-\t  vertices[idx].visited = 1;\n-\n \t  /* We still eventually have failed backedge SLP nodes in the\n \t     graph, those are only cancelled when analyzing operations.\n \t     Simply treat them as transparent ops, propagating permutes\n \t     through them.  */\n \t  if (SLP_TREE_DEF_TYPE (node) == vect_internal_def)\n \t    {\n-\t      /* We do not handle stores with a permutation.  */\n+\t      /* We do not handle stores with a permutation, so all\n+\t\t incoming permutes must have been materialized.  */\n \t      stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node);\n \t      if (STMT_VINFO_DATA_REF (rep)\n \t\t  && DR_IS_WRITE (STMT_VINFO_DATA_REF (rep)))\n-\t\tcontinue;\n+\t\t{\n+\t\t  vertices[idx].perm_out = 0;\n+\t\t  continue;\n+\t\t}\n \t      /* We cannot move a permute across an operation that is\n \t\t not independent on lanes.  Note this is an explicit\n \t\t negative list since that's much shorter than the respective\n@@ -3710,63 +3717,82 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t  case CFN_COMPLEX_MUL:\n \t\t  case CFN_COMPLEX_MUL_CONJ:\n \t\t  case CFN_VEC_ADDSUB:\n+\t\t    vertices[idx].perm_out = 0;\n \t\t    continue;\n \t\t  default:;\n \t\t  }\n \t    }\n \n-\t  int perm = -1;\n-\t  for (graph_edge *succ = slpg->vertices[idx].succ;\n-\t       succ; succ = succ->succ_next)\n-\t    {\n-\t      int succ_idx = succ->dest;\n-\t      /* Handle unvisited nodes optimistically.  */\n-\t      /* ???  But for constants once we want to handle non-bijective\n-\t\t permutes we have to verify the permute, when unifying lanes,\n-\t\t will not unify different constants.  For example see\n-\t\t gcc.dg/vect/bb-slp-14.c for a case that would break.  */\n-\t      if (!vertices[succ_idx].visited)\n-\t\tcontinue;\n-\t      int succ_perm = vertices[succ_idx].perm_out;\n-\t      if (perm == -1)\n-\t\tperm = succ_perm;\n-\t      else if (succ_perm == 0)\n-\t\t{\n-\t\t  perm = 0;\n-\t\t  break;\n-\t\t}\n-\t      else if (!vect_slp_perms_eq (perms, perm, succ_perm))\n-\t\t{\n-\t\t  perm = 0;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (perm == -1)\n+\t  int perm;\n+\t  if (!slpg->vertices[idx].succ)\n \t    /* Pick up pre-computed leaf values.  */\n \t    perm = vertices[idx].perm_out;\n-\t  else if (!vect_slp_perms_eq (perms, perm,\n-\t\t\t\t       vertices[idx].get_perm_in ()))\n+\t  else\n \t    {\n-\t      if (iteration > 1)\n-\t\t/* Make sure we eventually converge.  */\n-\t\tgcc_checking_assert (perm == 0);\n-\t      if (perm == 0)\n+\t      perm = -1;\n+\t      bool all_constant = true;\n+\t      for (graph_edge *succ = slpg->vertices[idx].succ;\n+\t\t   succ; succ = succ->succ_next)\n \t\t{\n-\t\t  vertices[idx].perm_out = 0;\n-\t\t  vertices[idx].materialize = 0;\n+\t\t  int succ_idx = succ->dest;\n+\t\t  slp_tree succ_node = vertices[succ_idx].node;\n+\t\t  if (SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n+\t\t      && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n+\t\t    all_constant = false;\n+\t\t  int succ_perm = vertices[succ_idx].perm_out;\n+\t\t  /* Handle unvisited (and constant) nodes optimistically.  */\n+\t\t  /* ???  But for constants once we want to handle\n+\t\t     non-bijective permutes we have to verify the permute,\n+\t\t     when unifying lanes, will not unify different constants.\n+\t\t     For example see gcc.dg/vect/bb-slp-14.c for a case\n+\t\t     that would break.  */\n+\t\t  if (succ_perm == -1)\n+\t\t    continue;\n+\t\t  if (perm == -1)\n+\t\t    perm = succ_perm;\n+\t\t  else if (succ_perm == 0)\n+\t\t    {\n+\t\t      perm = 0;\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (!vect_slp_perms_eq (perms, perm, succ_perm))\n+\t\t    {\n+\t\t      perm = 0;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      /* We still lack a forward propagation of materializations\n+\t\t and thus only allow \"any\" permutes on constant or external\n+\t\t nodes which we handle during materialization by looking\n+\t\t at SLP children.  So avoid having internal \"any\" permutes\n+\t\t for now, see gcc.dg/vect/bb-slp-71.c for a testcase that\n+\t\t breaks when removing this restriction.  */\n+\t      if (perm == -1 && all_constant)\n+\t\tperm = 0;\n+\n+\t      if (!vect_slp_perms_eq (perms, perm,\n+\t\t\t\t      vertices[idx].get_perm_in ()))\n+\t\t{\n+\t\t  /* Make sure we eventually converge.  */\n+\t\t  gcc_checking_assert (vertices[idx].get_perm_in () == -1\n+\t\t\t\t       || perm == 0);\n+\t\t  if (perm == 0)\n+\t\t    {\n+\t\t      vertices[idx].perm_out = 0;\n+\t\t      vertices[idx].materialize = 0;\n+\t\t    }\n+\t\t  if (!vertices[idx].materialize)\n+\t\t    vertices[idx].perm_out = perm;\n+\t\t  changed = true;\n \t\t}\n-\t      if (!vertices[idx].materialize)\n-\t\tvertices[idx].perm_out = perm;\n-\t      changed = true;\n \t    }\n \n-\t  if (perm == 0)\n+\t  /* Elide pruning at materialization points in the first\n+\t     iteration phase.  */\n+\t  if (!do_materialization)\n \t    continue;\n \n-\t  /* Elide pruning at materialization points in the first\n-\t     iteration so every node was visited once at least.  */\n-\t  if (iteration == 1)\n+\t  if (perm == 0 || perm == -1)\n \t    continue;\n \n \t  /* Decide on permute materialization.  Look whether there's\n@@ -3784,8 +3810,8 @@ vect_optimize_slp (vec_info *vinfo)\n \t    for (graph_edge *pred = slpg->vertices[idx].pred;\n \t\t pred; pred = pred->pred_next)\n \t      {\n-\t\tgcc_checking_assert (vertices[pred->src].visited);\n \t\tint pred_perm = vertices[pred->src].get_perm_in ();\n+\t\tgcc_checking_assert (pred_perm != -1);\n \t\tif (!vect_slp_perms_eq (perms, perm, pred_perm))\n \t\t  {\n \t\t    all_preds_permuted = false;\n@@ -3800,8 +3826,16 @@ vect_optimize_slp (vec_info *vinfo)\n \t      vertices[idx].perm_out = 0;\n \t    }\n \t}\n+\n+      /* If the initial propagation converged, switch on materialization\n+\t and re-propagate.  */\n+      if (!changed && !do_materialization)\n+\t{\n+\t  do_materialization = true;\n+\t  changed = true;\n+\t}\n     }\n-  while (changed || iteration == 1);\n+  while (changed);\n \n   /* Materialize.  */\n   for (i = 0; i < vertices.length (); ++i)"}]}