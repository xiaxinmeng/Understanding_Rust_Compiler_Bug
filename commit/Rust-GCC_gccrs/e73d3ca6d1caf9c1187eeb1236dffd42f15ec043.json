{"sha": "e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczZDNjYTZkMWNhZjljMTE4N2VlYjEyMzZkZmZkNDJmMTVlYzA0Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-08-31T05:36:22Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-08-31T05:36:22Z"}, "message": "[multiple changes]\n\n2016-08-31  Paul Thomas  <pault@gcc.gnu.org>\n\tJerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/48298\n\n\t* decl.c (access_attr_decl): Include case INTERFACE_DTIO as\n\tappropriate.\n\t* gfortran.h : Add INTRINSIC_FORMATTED and\n\tINTRINSIC_UNFORMATTED to gfc_intrinsic_op. Add INTERFACE_DTIO\n\tto interface type. Add new enum 'dtio_codes'. Add bitfield\n\t'has_dtio_procs' to symbol_attr. Add prototypes\n\t'gfc_check_dtio_interfaces' and 'gfc_find_specific_dtio_proc'.\n\t* interface.c (dtio_op): New function.\n\t(gfc_match_generic_spec): Match generic DTIO interfaces.\n\t(gfc_match_interface): Treat DTIO interfaces in the same way as\n\t(gfc_current_interface_head): Add INTERFACE_DTIO appropriately.\n\t(check_dtio_arg_TKR_intent): New function.\n\t(check_dtio_interface1): New function.\n\t(gfc_check_dtio_interfaces): New function.\n\t(gfc_find_specific_dtio_proc): New function.\n\t* io.c : Add FMT_DT to format_token.\n\t(format_lex): Handle DTIO formatting.\n\t* match.c (gfc_op2string): Add DTIO operators.\n\t* resolve.c (derived_inaccessible): Ignore pointer components\n\tto enclosing derived type.\n\t(resolve_transfer): Resolve transfers that involve DTIO.\n\tprocedures. Find the specific subroutine for the transfer and\n\tuse its existence to over-ride some of the constraints on\n\tderived types. If the transfer is recursive, require that the\n\tsubroutine be so qualified.\n\t(dtio_procs_present): New function.\n\t(resolve_fl_namelist): Remove inhibition of polymorphic objects\n\tin namelists if DTIO read and write subroutines exist. Likewise\n\tfor derived types.\n\t(resolve_types): Invoke 'gfc_verify_dtio_procedures'.\n\t* symbol.c : Set 'dtio_procs' using 'minit'.\n\t* trans-decl.c (gfc_finish_var_decl): If a derived-type/class\n\tobject is associated with DTIO procedures, make it TREE_STATIC.\n\t* trans-expr.c (gfc_get_vptr_from_expr): If the expression\n\tdrills down to a PARM_DECL, extract the vptr correctly.\n\t(gfc_conv_derived_to_class): Check 'info' in the test for\n\t'useflags'. If the se expression exists and is a pointer, use\n\tit as the class _data.\n\t* trans-io.c : Add IOCALL_X_DERIVED to iocall and the function\n\tprototype. Likewise for IOCALL_SET_NML_DTIO_VAL.\n\t(set_parameter_tree): Renamed from 'set_parameter_const', now\n\treturns void and has new tree argument. Calls modified to match\n\tnew interface.\n\t(transfer_namelist_element): Transfer DTIO procedure pointer\n\tand vpointer using the new function IOCALL_SET_NML_DTIO_VAL.\n\t(get_dtio_proc): New function.\n\t(transfer_expr): Add new argument for the vptr field of class\n\tobjects. Add the code to call the specific DTIO proc, convert\n\tderived types to class and call IOCALL_X_DERIVED.\n\t(trans_transfer): Add BT_CLASS to structures for treatment by\n\tthe scalarizer. Obtain the vptr for the dynamic type, both for\n\tscalar and array transfer.\n\n2016-08-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\tPaul Thomas  <pault@gcc.gnu.org>\n\n\tPR libgfortran/48298\n\t* gfortran.map : Flag _st_set_nml_dtio_var and\n\t_gfortran_transfer_derived.\n\t* io/format.c (format_lex): Detect DTIO formatting.\n\t(parse_format_list): Parse the DTIO format.\n\t(next_format): Include FMT_DT.\n\t* io/format.h : Likewise. Add structure 'udf' to structure\n\t'fnode' to carry the IOTYPE string and the 'vlist'.\n\t* io/io.h : Add prototypes for the two types of DTIO subroutine\n\tand a typedef for gfc_class. Also, add to 'namelist_type'\n\tfields for the pointer to the DTIO procedure and the vtable.\n\tAdd fields to struct st_parameter_dt for pointers to the two\n\ttypes of DTIO subroutine. Add to gfc_unit DTIO specific fields.\n\t(internal_proto): Add prototype for 'read_user_defined' and\n\t'write_user_defined'.\n\t* io/list_read.c (check_buffers): Use the 'current_unit' field.\n\t(unget_char): Likewise.\n\t(eat_spaces): Likewise.\n\t(list_formatted_read_scalar): For case BT_CLASS, call the DTIO\n\tprocedure.\n\t(nml_get_obj_data): Likewise when DTIO procedure is present,.\n\t* io/transfer.c : Export prototypes for 'transfer_derived' and\n\t'transfer_derived_write'.\n\t(unformatted_read): For case BT_CLASS, call the DTIO procedure.\n\t(unformatted_write): Likewise.\n\t(formatted_transfer_scalar_read): Likewise.\n\t(formatted_transfer_scalar_write: Likewise.\n\t(transfer_derived): New function.\n\t(data_transfer_init): Set last_char if no child_dtio.\n\t(finalize_transfer): Return if child_dtio set.\n\t(st_write_done): Add condition for child_dtio not set.\n\tAdd extra arguments for st_set_nml_var prototype.\n\t(set_nml_var): New function that contains the contents of the\n\told version of st_set_nml_var. Also sets the 'dtio_sub' and\n\t'vtable' fields of the 'nml' structure.\n\t(st_set_nml_var): Now just calls set_nml_var with 'dtio_sub'\n\tand 'vtable' NULL.\n\t(st_set_nml_dtio_var): New function that calls set_nml_var.\n\t* io/unit.c (get_external_unit): If the found unit child_dtio\n\tis non zero, don't do any mutex locking/unlocking.  Just\n\treturn the unit.\n\t* io/unix.c (tempfile_open): Revert to C style comment.\n\t* io/write.c (list_formatted_write_scalar): Do the DTIO call.\n\t(nml_write_obj): Add BT_CLASS and do the DTIO call.\n\n2016-08-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\tPaul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/48298\n\t* gfortran.dg/dtio_1.f90: New test.\n\t* gfortran.dg/dtio_2.f90: New test.\n\t* gfortran.dg/dtio_3.f90: New test.\n\t* gfortran.dg/dtio_4.f90: New test.\n\t* gfortran.dg/dtio_5.f90: New test.\n\t* gfortran.dg/dtio_6.f90: New test.\n\t* gfortran.dg/dtio_7.f90: New test.\n\t* gfortran.dg/dtio_8.f90: New test.\n\t* gfortran.dg/dtio_9.f90: New test.\n\t* gfortran.dg/dtio_10.f90: New test.\n\nFrom-SVN: r239880", "tree": {"sha": "ce325707843eb632b75074b035f68aa4267822d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce325707843eb632b75074b035f68aa4267822d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/comments", "author": null, "committer": null, "parents": [{"sha": "b816477a5ad7277b3a588e9a58cbcd764152b8d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b816477a5ad7277b3a588e9a58cbcd764152b8d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b816477a5ad7277b3a588e9a58cbcd764152b8d2"}], "stats": {"total": 3182, "additions": 2895, "deletions": 287}, "files": [{"sha": "62bdd9e387be7e874ecf39f1f5821596e96c179a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -1,3 +1,61 @@\n+2016-08-31  Paul Thomas  <pault@gcc.gnu.org>\n+\tJerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/48298\n+\n+\t* decl.c (access_attr_decl): Include case INTERFACE_DTIO as\n+\tappropriate.\n+\t* gfortran.h : Add INTRINSIC_FORMATTED and\n+\tINTRINSIC_UNFORMATTED to gfc_intrinsic_op. Add INTERFACE_DTIO\n+\tto interface type. Add new enum 'dtio_codes'. Add bitfield\n+\t'has_dtio_procs' to symbol_attr. Add prototypes\n+\t'gfc_check_dtio_interfaces' and 'gfc_find_specific_dtio_proc'.\n+\t* interface.c (dtio_op): New function.\n+\t(gfc_match_generic_spec): Match generic DTIO interfaces.\n+\t(gfc_match_interface): Treat DTIO interfaces in the same way as\n+\t(gfc_current_interface_head): Add INTERFACE_DTIO appropriately.\n+\t(check_dtio_arg_TKR_intent): New function.\n+\t(check_dtio_interface1): New function.\n+\t(gfc_check_dtio_interfaces): New function.\n+\t(gfc_find_specific_dtio_proc): New function.\n+\t* io.c : Add FMT_DT to format_token.\n+\t(format_lex): Handle DTIO formatting.\n+\t* match.c (gfc_op2string): Add DTIO operators.\n+\t* resolve.c (derived_inaccessible): Ignore pointer components\n+\tto enclosing derived type.\n+\t(resolve_transfer): Resolve transfers that involve DTIO.\n+\tprocedures. Find the specific subroutine for the transfer and\n+\tuse its existence to over-ride some of the constraints on\n+\tderived types. If the transfer is recursive, require that the\n+\tsubroutine be so qualified.\n+\t(dtio_procs_present): New function.\n+\t(resolve_fl_namelist): Remove inhibition of polymorphic objects\n+\tin namelists if DTIO read and write subroutines exist. Likewise\n+\tfor derived types.\n+\t(resolve_types): Invoke 'gfc_verify_dtio_procedures'.\n+\t* symbol.c : Set 'dtio_procs' using 'minit'.\n+\t* trans-decl.c (gfc_finish_var_decl): If a derived-type/class\n+\tobject is associated with DTIO procedures, make it TREE_STATIC.\n+\t* trans-expr.c (gfc_get_vptr_from_expr): If the expression\n+\tdrills down to a PARM_DECL, extract the vptr correctly.\n+\t(gfc_conv_derived_to_class): Check 'info' in the test for\n+\t'useflags'. If the se expression exists and is a pointer, use\n+\tit as the class _data.\n+\t* trans-io.c : Add IOCALL_X_DERIVED to iocall and the function\n+\tprototype. Likewise for IOCALL_SET_NML_DTIO_VAL.\n+\t(set_parameter_tree): Renamed from 'set_parameter_const', now\n+\treturns void and has new tree argument. Calls modified to match\n+\tnew interface.\n+\t(transfer_namelist_element): Transfer DTIO procedure pointer\n+\tand vpointer using the new function IOCALL_SET_NML_DTIO_VAL.\n+\t(get_dtio_proc): New function.\n+\t(transfer_expr): Add new argument for the vptr field of class\n+\tobjects. Add the code to call the specific DTIO proc, convert\n+\tderived types to class and call IOCALL_X_DERIVED.\n+\t(trans_transfer): Add BT_CLASS to structures for treatment by\n+\tthe scalarizer. Obtain the vptr for the dynamic type, both for\n+\tscalar and array transfer.\n+\n 2016-08-30  Fritz Reese  <fritzoreese@gmail.com>\n \n \t* gfortran.texi: Fix typo in STRUCTURE documentation."}, {"sha": "b5242394cefc65cae27b142fee6b97bca21e08f3", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -7469,6 +7469,7 @@ access_attr_decl (gfc_statement st)\n \t  goto syntax;\n \n \tcase INTERFACE_GENERIC:\n+\tcase INTERFACE_DTIO:\n \t  if (gfc_get_symbol (name, NULL, &sym))\n \t    goto done;\n \n@@ -9378,6 +9379,7 @@ gfc_match_generic (void)\n   switch (op_type)\n     {\n     case INTERFACE_GENERIC:\n+    case INTERFACE_DTIO:\n       snprintf (bind_name, sizeof (bind_name), \"%s\", name);\n       break;\n \n@@ -9413,6 +9415,7 @@ gfc_match_generic (void)\n \n   switch (op_type)\n     {\n+    case INTERFACE_DTIO:\n     case INTERFACE_USER_OP:\n     case INTERFACE_GENERIC:\n       {\n@@ -9467,6 +9470,7 @@ gfc_match_generic (void)\n \n       switch (op_type)\n \t{\n+\tcase INTERFACE_DTIO:\n \tcase INTERFACE_GENERIC:\n \tcase INTERFACE_USER_OP:\n \t  {"}, {"sha": "2acf64c7b7d97453d158b8e3406bf7f714a2a1bc", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -177,8 +177,10 @@ enum gfc_intrinsic_op\n   /* .EQ., .NE., .GT., .GE., .LT., .LE. (OS = Old-Style)  */\n   INTRINSIC_EQ_OS, INTRINSIC_NE_OS, INTRINSIC_GT_OS, INTRINSIC_GE_OS,\n   INTRINSIC_LT_OS, INTRINSIC_LE_OS,\n-  INTRINSIC_NOT, INTRINSIC_USER, INTRINSIC_ASSIGN,\n-  INTRINSIC_PARENTHESES, GFC_INTRINSIC_END /* Sentinel */\n+  INTRINSIC_NOT, INTRINSIC_USER, INTRINSIC_ASSIGN, INTRINSIC_PARENTHESES,\n+  /* User defined derived type pseudo operator.  */\n+  INTRINSIC_FORMATTED, INTRINSIC_UNFORMATTED,\n+  GFC_INTRINSIC_END /* Sentinel */\n };\n \n /* This macro is the number of intrinsic operators that exist.\n@@ -261,7 +263,8 @@ enum gfc_statement\n enum interface_type\n {\n   INTERFACE_NAMELESS = 1, INTERFACE_GENERIC,\n-  INTERFACE_INTRINSIC_OP, INTERFACE_USER_OP, INTERFACE_ABSTRACT\n+  INTERFACE_INTRINSIC_OP, INTERFACE_USER_OP, INTERFACE_ABSTRACT,\n+  INTERFACE_DTIO\n };\n \n /* Symbol flavors: these are all mutually exclusive.\n@@ -313,6 +316,12 @@ extern const mstring access_types[];\n extern const mstring ifsrc_types[];\n extern const mstring save_status[];\n \n+/* Strings for DTIO procedure names.  In symbol.c.  */\n+extern const mstring dtio_procs[];\n+\n+enum dtio_codes\n+{ DTIO_RF = 0, DTIO_WF, DTIO_RUF, DTIO_WUF };\n+\n /* Enumeration of all the generic intrinsic functions.  Used by the\n    backend for identification of a function.  */\n \n@@ -784,7 +793,7 @@ typedef struct\n   unsigned implicit_pure:1;\n \n   /* This is set for a procedure that contains expressions referencing\n-     arrays coming from outside its namespace.  \n+     arrays coming from outside its namespace.\n      This is used to force the creation of a temporary when the LHS of\n      an array assignment may be used by an elemental procedure appearing\n      on the RHS.  */\n@@ -841,7 +850,8 @@ typedef struct\n      entities.  */\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n \t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,\n-\t   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1;\n+\t   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1,\n+\t   has_dtio_procs:1;\n \n   /* This is a temporary selector for SELECT TYPE or an associate\n      variable for SELECT_TYPE or ASSOCIATE.  */\n@@ -3170,6 +3180,9 @@ bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n int gfc_has_vector_subscript (gfc_expr*);\n gfc_intrinsic_op gfc_equivalent_op (gfc_intrinsic_op);\n bool gfc_check_typebound_override (gfc_symtree*, gfc_symtree*);\n+void gfc_check_dtio_interfaces (gfc_symbol*);\n+gfc_symbol* gfc_find_specific_dtio_proc (gfc_symbol*, bool, bool);\n+\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "fece3168dc75667ed2df4bd6138a98147b7324fd", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 376, "deletions": 17, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -115,6 +115,19 @@ fold_unary_intrinsic (gfc_intrinsic_op op)\n }\n \n \n+/* Return the operator depending on the DTIO moded string.  */\n+\n+static gfc_intrinsic_op\n+dtio_op (char* mode)\n+{\n+  if (strncmp (mode, \"formatted\", 9) == 0)\n+    return INTRINSIC_FORMATTED;\n+  if (strncmp (mode, \"unformatted\", 9) == 0)\n+    return INTRINSIC_UNFORMATTED;\n+  return INTRINSIC_NONE;\n+}\n+\n+\n /* Match a generic specification.  Depending on which type of\n    interface is found, the 'name' or 'op' pointers may be set.\n    This subroutine doesn't return MATCH_NO.  */\n@@ -162,6 +175,40 @@ gfc_match_generic_spec (interface_type *type,\n       return MATCH_YES;\n     }\n \n+  if (gfc_match (\" read ( %n )\", buffer) == MATCH_YES)\n+    {\n+      *op = dtio_op (buffer);\n+      if (*op == INTRINSIC_FORMATTED)\n+\t{\n+\t  strcpy (name, gfc_code2string (dtio_procs, DTIO_RF));\n+\t  *type = INTERFACE_DTIO;\n+\t}\n+      if (*op == INTRINSIC_UNFORMATTED)\n+\t{\n+\t  strcpy (name, gfc_code2string (dtio_procs, DTIO_RUF));\n+\t  *type = INTERFACE_DTIO;\n+\t}\n+      if (*op != INTRINSIC_NONE)\n+\treturn MATCH_YES;\n+    }\n+\n+  if (gfc_match (\" write ( %n )\", buffer) == MATCH_YES)\n+    {\n+      *op = dtio_op (buffer);\n+      if (*op == INTRINSIC_FORMATTED)\n+\t{\n+\t  strcpy (name, gfc_code2string (dtio_procs, DTIO_WF));\n+\t  *type = INTERFACE_DTIO;\n+\t}\n+      if (*op == INTRINSIC_UNFORMATTED)\n+\t{\n+\t  strcpy (name, gfc_code2string (dtio_procs, DTIO_WUF));\n+\t  *type = INTERFACE_DTIO;\n+\t}\n+      if (*op != INTRINSIC_NONE)\n+\treturn MATCH_YES;\n+    }\n+\n   if (gfc_match_name (buffer) == MATCH_YES)\n     {\n       strcpy (name, buffer);\n@@ -209,6 +256,7 @@ gfc_match_interface (void)\n \n   switch (type)\n     {\n+    case INTERFACE_DTIO:\n     case INTERFACE_GENERIC:\n       if (gfc_get_symbol (name, NULL, &sym))\n \treturn MATCH_ERROR;\n@@ -349,7 +397,7 @@ gfc_match_end_interface (void)\n \t      if (strcmp(s2, \"none\") == 0)\n \t\tgfc_error (\"Expecting %<END INTERFACE OPERATOR (%s)%> \"\n \t\t\t   \"at %C, \", s1);\n-\t      else\t\t\n+\t      else\n \t\tgfc_error (\"Expecting %<END INTERFACE OPERATOR (%s)%> at %C, \"\n \t\t\t   \"but got %s\", s1, s2);\n \t    }\n@@ -371,6 +419,7 @@ gfc_match_end_interface (void)\n \n       break;\n \n+    case INTERFACE_DTIO:\n     case INTERFACE_GENERIC:\n       if (type != current_interface.type\n \t  || strcmp (current_interface.sym->name, name) != 0)\n@@ -3957,7 +4006,7 @@ gfc_extend_expr (gfc_expr *e)\n       else\n \treturn MATCH_YES;\n     }\n- \n+\n   if (i == INTRINSIC_USER)\n     {\n       for (ns = gfc_current_ns; ns; ns = ns->parent)\n@@ -4148,60 +4197,60 @@ gfc_add_interface (gfc_symbol *new_sym)\n \t  {\n \t    case INTRINSIC_EQ:\n \t    case INTRINSIC_EQ_OS:\n-\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_EQ], new_sym, \n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_EQ], new_sym,\n \t\t\t\t\t    gfc_current_locus)\n-\t          || !gfc_check_new_interface (ns->op[INTRINSIC_EQ_OS], \n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_EQ_OS],\n \t\t\t\t\t       new_sym, gfc_current_locus))\n \t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_NE:\n \t    case INTRINSIC_NE_OS:\n-\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_NE], new_sym, \n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_NE], new_sym,\n \t\t\t\t\t    gfc_current_locus)\n-\t          || !gfc_check_new_interface (ns->op[INTRINSIC_NE_OS], \n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_NE_OS],\n \t\t\t\t\t       new_sym, gfc_current_locus))\n \t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_GT:\n \t    case INTRINSIC_GT_OS:\n-\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_GT], \n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_GT],\n \t\t\t\t\t    new_sym, gfc_current_locus)\n-\t          || !gfc_check_new_interface (ns->op[INTRINSIC_GT_OS], \n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_GT_OS],\n \t\t\t\t\t       new_sym, gfc_current_locus))\n \t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_GE:\n \t    case INTRINSIC_GE_OS:\n-\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_GE], \n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_GE],\n \t\t\t\t\t    new_sym, gfc_current_locus)\n-\t          || !gfc_check_new_interface (ns->op[INTRINSIC_GE_OS], \n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_GE_OS],\n \t\t\t\t\t       new_sym, gfc_current_locus))\n \t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_LT:\n \t    case INTRINSIC_LT_OS:\n-\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_LT], \n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_LT],\n \t\t\t\t\t    new_sym, gfc_current_locus)\n-\t          || !gfc_check_new_interface (ns->op[INTRINSIC_LT_OS], \n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_LT_OS],\n \t\t\t\t\t       new_sym, gfc_current_locus))\n \t\treturn false;\n \t      break;\n \n \t    case INTRINSIC_LE:\n \t    case INTRINSIC_LE_OS:\n-\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_LE], \n+\t      if (!gfc_check_new_interface (ns->op[INTRINSIC_LE],\n \t\t\t\t\t    new_sym, gfc_current_locus)\n-\t          || !gfc_check_new_interface (ns->op[INTRINSIC_LE_OS], \n+\t          || !gfc_check_new_interface (ns->op[INTRINSIC_LE_OS],\n \t\t\t\t\t       new_sym, gfc_current_locus))\n \t\treturn false;\n \t      break;\n \n \t    default:\n-\t      if (!gfc_check_new_interface (ns->op[current_interface.op], \n+\t      if (!gfc_check_new_interface (ns->op[current_interface.op],\n \t\t\t\t\t    new_sym, gfc_current_locus))\n \t\treturn false;\n \t  }\n@@ -4210,13 +4259,14 @@ gfc_add_interface (gfc_symbol *new_sym)\n       break;\n \n     case INTERFACE_GENERIC:\n+    case INTERFACE_DTIO:\n       for (ns = current_interface.ns; ns; ns = ns->parent)\n \t{\n \t  gfc_find_symbol (current_interface.sym->name, ns, 0, &sym);\n \t  if (sym == NULL)\n \t    continue;\n \n-\t  if (!gfc_check_new_interface (sym->generic, \n+\t  if (!gfc_check_new_interface (sym->generic,\n \t\t\t\t\tnew_sym, gfc_current_locus))\n \t    return false;\n \t}\n@@ -4225,7 +4275,7 @@ gfc_add_interface (gfc_symbol *new_sym)\n       break;\n \n     case INTERFACE_USER_OP:\n-      if (!gfc_check_new_interface (current_interface.uop->op, \n+      if (!gfc_check_new_interface (current_interface.uop->op,\n \t\t\t\t    new_sym, gfc_current_locus))\n \treturn false;\n \n@@ -4257,6 +4307,7 @@ gfc_current_interface_head (void)\n \tbreak;\n \n       case INTERFACE_GENERIC:\n+      case INTERFACE_DTIO:\n \treturn current_interface.sym->generic;\n \tbreak;\n \n@@ -4280,6 +4331,7 @@ gfc_set_current_interface_head (gfc_interface *i)\n \tbreak;\n \n       case INTERFACE_GENERIC:\n+      case INTERFACE_DTIO:\n \tcurrent_interface.sym->generic = i;\n \tbreak;\n \n@@ -4496,3 +4548,310 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \n   return true;\n }\n+\n+\n+/* The following three functions check that the formal arguments\n+   of user defined derived type IO procedures are compliant with\n+   the requirements of the standard.  */\n+\n+static void\n+check_dtio_arg_TKR_intent (gfc_symbol *fsym, bool typebound, bt type,\n+\t\t\t   int kind, int rank, sym_intent intent)\n+{\n+  if (fsym->ts.type != type)\n+    gfc_error (\"DTIO dummy argument at %L must be of type %s\",\n+\t       &fsym->declared_at, gfc_basic_typename (type));\n+\n+  if (fsym->ts.type != BT_CLASS && fsym->ts.type != BT_DERIVED\n+      && fsym->ts.kind != kind)\n+    gfc_error (\"DTIO dummy argument at %L must be of KIND = %d\",\n+\t       &fsym->declared_at, kind);\n+\n+  if (!typebound\n+      && rank == 0\n+      && (((type == BT_CLASS) && CLASS_DATA (fsym)->attr.dimension)\n+\t  || ((type != BT_CLASS) && fsym->attr.dimension)))\n+    gfc_error (\"DTIO dummy argument at %L be a scalar\",\n+\t       &fsym->declared_at);\n+  else if (rank == 1\n+\t   && (fsym->as == NULL || fsym->as->type != AS_ASSUMED_SHAPE))\n+    gfc_error (\"DTIO dummy argument at %L must be an \"\n+\t       \"ASSUMED SHAPE ARRAY\", &fsym->declared_at);\n+\n+  if (fsym->attr.intent != intent)\n+    gfc_error (\"DTIO dummy argument at %L must have intent %s\",\n+\t       &fsym->declared_at, gfc_code2string (intents, (int)intent));\n+  return;\n+}\n+\n+\n+static void\n+check_dtio_interface1 (gfc_symbol *derived, gfc_symtree *tb_io_st,\n+\t\t       bool typebound, bool formatted, int code)\n+{\n+  gfc_symbol *dtio_sub, *generic_proc, *fsym;\n+  gfc_typebound_proc *tb_io_proc, *specific_proc;\n+  gfc_interface *intr;\n+  gfc_formal_arglist *formal;\n+  int arg_num;\n+\n+  bool read = ((dtio_codes)code == DTIO_RF)\n+\t       || ((dtio_codes)code == DTIO_RUF);\n+  bt type;\n+  sym_intent intent;\n+  int kind;\n+\n+  dtio_sub = NULL;\n+  if (typebound)\n+    {\n+      /* Typebound DTIO binding.  */\n+      tb_io_proc = tb_io_st->n.tb;\n+      gcc_assert (tb_io_proc != NULL);\n+      gcc_assert (tb_io_proc->is_generic);\n+      gcc_assert (tb_io_proc->u.generic->next == NULL);\n+\n+      specific_proc = tb_io_proc->u.generic->specific;\n+      gcc_assert (!specific_proc->is_generic);\n+\n+      dtio_sub = specific_proc->u.specific->n.sym;\n+    }\n+  else\n+    {\n+      generic_proc = tb_io_st->n.sym;\n+      gcc_assert (generic_proc);\n+      gcc_assert (generic_proc->generic);\n+\n+      for (intr = tb_io_st->n.sym->generic; intr; intr = intr->next)\n+\t{\n+\t  if (intr->sym && intr->sym->formal\n+\t      && ((intr->sym->formal->sym->ts.type == BT_CLASS\n+\t           && CLASS_DATA (intr->sym->formal->sym)->ts.u.derived\n+\t\t\t\t\t\t\t     == derived)\n+\t\t  || (intr->sym->formal->sym->ts.type == BT_DERIVED\n+\t\t      && intr->sym->formal->sym->ts.u.derived == derived)))\n+\t    {\n+\t      dtio_sub = intr->sym;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (dtio_sub == NULL)\n+\treturn;\n+    }\n+\n+  gcc_assert (dtio_sub);\n+  if (!dtio_sub->attr.subroutine)\n+    gfc_error (\"DTIO procedure %s at %L must be a subroutine\",\n+\t       dtio_sub->name, &dtio_sub->declared_at);\n+\n+  /* Now go through the formal arglist.  */\n+  arg_num = 1;\n+  for (formal = dtio_sub->formal; formal; formal = formal->next, arg_num++)\n+    {\n+      if (!formatted && arg_num == 3)\n+\targ_num = 5;\n+      fsym = formal->sym;\n+      switch (arg_num)\n+\t{\n+\tcase(1):\t\t\t/* DTV  */\n+\t  type = derived->attr.sequence || derived->attr.is_bind_c ?\n+\t\t BT_DERIVED : BT_CLASS;\n+\t  kind = 0;\n+\t  intent = read ? INTENT_INOUT : INTENT_IN;\n+\t  check_dtio_arg_TKR_intent (fsym, typebound, type, kind,\n+\t\t\t\t     0, intent);\n+\t  break;\n+\n+\tcase(2):\t\t\t/* UNIT  */\n+\t  type = BT_INTEGER;\n+\t  kind = gfc_default_integer_kind;\n+\t  intent = INTENT_IN;\n+\t  check_dtio_arg_TKR_intent (fsym, typebound, type, kind,\n+\t\t\t\t     0, intent);\n+\t  break;\n+\tcase(3):\t\t\t/* IOTYPE  */\n+\t  type = BT_CHARACTER;\n+\t  kind = gfc_default_character_kind;\n+\t  intent = INTENT_IN;\n+\t  check_dtio_arg_TKR_intent (fsym, typebound, type, kind,\n+\t\t\t\t     0, intent);\n+\t  break;\n+\tcase(4):\t\t\t/* VLIST  */\n+\t  type = BT_INTEGER;\n+\t  kind = gfc_default_integer_kind;\n+\t  intent = INTENT_IN;\n+\t  check_dtio_arg_TKR_intent (fsym, typebound, type, kind,\n+\t\t\t\t     1, intent);\n+\t  break;\n+\tcase(5):\t\t\t/* IOSTAT  */\n+\t  type = BT_INTEGER;\n+\t  kind = gfc_default_integer_kind;\n+\t  intent = INTENT_OUT;\n+\t  check_dtio_arg_TKR_intent (fsym, typebound, type, kind,\n+\t\t\t\t     0, intent);\n+\t  break;\n+\tcase(6):\t\t\t/* IOMSG  */\n+\t  type = BT_CHARACTER;\n+\t  kind = gfc_default_character_kind;\n+\t  intent = INTENT_INOUT;\n+\t  check_dtio_arg_TKR_intent (fsym, typebound, type, kind,\n+\t\t\t\t     0, intent);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  derived->attr.has_dtio_procs = 1;\n+  return;\n+}\n+\n+void\n+gfc_check_dtio_interfaces (gfc_symbol *derived)\n+{\n+  gfc_symtree *tb_io_st;\n+  bool t = false;\n+  int code;\n+  bool formatted;\n+\n+  if (derived->attr.is_class == 1 || derived->attr.vtype == 1)\n+    return;\n+\n+  /* Check typebound DTIO bindings.  */\n+  for (code = 0; code < 4; code++)\n+    {\n+      formatted = ((dtio_codes)code == DTIO_RF)\n+\t\t   || ((dtio_codes)code == DTIO_WF);\n+\n+      tb_io_st = gfc_find_typebound_proc (derived, &t,\n+\t\t\t\t\t  gfc_code2string (dtio_procs, code),\n+\t\t\t\t\t  true, &derived->declared_at);\n+      if (tb_io_st != NULL)\n+\tcheck_dtio_interface1 (derived, tb_io_st, true, formatted, code);\n+    }\n+\n+  /* Check generic DTIO interfaces.  */\n+  for (code = 0; code < 4; code++)\n+    {\n+      formatted = ((dtio_codes)code == DTIO_RF)\n+\t\t   || ((dtio_codes)code == DTIO_WF);\n+\n+      tb_io_st = gfc_find_symtree (derived->ns->sym_root,\n+\t\t\t\t   gfc_code2string (dtio_procs, code));\n+      if (tb_io_st != NULL)\n+\tcheck_dtio_interface1 (derived, tb_io_st, false, formatted, code);\n+    }\n+}\n+\n+\n+gfc_symbol *\n+gfc_find_specific_dtio_proc (gfc_symbol *derived, bool write, bool formatted)\n+{\n+  gfc_symtree *tb_io_st = NULL;\n+  gfc_symbol *dtio_sub = NULL;\n+  gfc_symbol *extended;\n+  gfc_typebound_proc *tb_io_proc, *specific_proc;\n+  bool t = false;\n+\n+  /* Try to find a typebound DTIO binding.  */\n+  if (formatted == true)\n+    {\n+      if (write == true)\n+        tb_io_st = gfc_find_typebound_proc (derived, &t,\n+\t\t\t\t\t    gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t     DTIO_WF),\n+\t\t\t\t\t    true,\n+\t\t\t\t\t    &derived->declared_at);\n+      else\n+        tb_io_st = gfc_find_typebound_proc (derived, &t,\n+\t\t\t\t\t    gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t     DTIO_RF),\n+\t\t\t\t\t    true,\n+\t\t\t\t\t    &derived->declared_at);\n+    }\n+  else\n+    {\n+      if (write == true)\n+        tb_io_st = gfc_find_typebound_proc (derived, &t,\n+\t\t\t\t\t    gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t     DTIO_WUF),\n+\t\t\t\t\t    true,\n+\t\t\t\t\t    &derived->declared_at);\n+      else\n+        tb_io_st = gfc_find_typebound_proc (derived, &t,\n+\t\t\t\t\t    gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t     DTIO_RUF),\n+\t\t\t\t\t    true,\n+\t\t\t\t\t    &derived->declared_at);\n+    }\n+\n+  if (tb_io_st != NULL)\n+    {\n+      tb_io_proc = tb_io_st->n.tb;\n+      gcc_assert (tb_io_proc != NULL);\n+      gcc_assert (tb_io_proc->is_generic);\n+      gcc_assert (tb_io_proc->u.generic->next == NULL);\n+\n+      specific_proc = tb_io_proc->u.generic->specific;\n+      gcc_assert (!specific_proc->is_generic);\n+\n+      dtio_sub = specific_proc->u.specific->n.sym;\n+    }\n+\n+  if (tb_io_st != NULL)\n+    goto finish;\n+\n+  /* If there is not a typebound binding, look for a generic\n+     DTIO interface.  */\n+  for (extended = derived; extended;\n+       extended = gfc_get_derived_super_type (extended))\n+    {\n+      if (formatted == true)\n+\t{\n+\t  if (write == true)\n+\t    tb_io_st = gfc_find_symtree (extended->ns->sym_root,\n+\t\t\t\t\t gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t  DTIO_WF));\n+\t  else\n+\t    tb_io_st = gfc_find_symtree (extended->ns->sym_root,\n+\t\t\t\t\t gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t  DTIO_RF));\n+\t}\n+      else\n+\t{\n+\t  if (write == true)\n+\t    tb_io_st = gfc_find_symtree (extended->ns->sym_root,\n+\t\t\t\t\t gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t  DTIO_WUF));\n+\t  else\n+\t    tb_io_st = gfc_find_symtree (extended->ns->sym_root,\n+\t\t\t\t\t gfc_code2string (dtio_procs,\n+\t\t\t\t\t\t\t  DTIO_RUF));\n+\t}\n+\n+      if (tb_io_st != NULL\n+\t  && tb_io_st->n.sym\n+\t  && tb_io_st->n.sym->generic)\n+\t{\n+\t  gfc_interface *intr;\n+\t  for (intr = tb_io_st->n.sym->generic; intr; intr = intr->next)\n+\t    {\n+\t      gfc_symbol *fsym = intr->sym->formal->sym;\n+\t      if (intr->sym && intr->sym->formal\n+\t\t  && ((fsym->ts.type == BT_CLASS\n+\t\t      && CLASS_DATA (fsym)->ts.u.derived == extended)\n+\t\t    || (fsym->ts.type == BT_DERIVED\n+\t\t\t&& fsym->ts.u.derived == extended)))\n+\t\t{\n+\t\t  dtio_sub = intr->sym;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+finish:\n+  if (dtio_sub && derived != CLASS_DATA (dtio_sub->formal->sym)->ts.u.derived)\n+    gfc_find_derived_vtab (derived);\n+\n+  return dtio_sub;\n+}"}, {"sha": "53037e22a1bb4738d7d6ab01b644a517a0a6513d", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -113,7 +113,7 @@ enum format_token\n   FMT_RPAREN, FMT_X, FMT_SIGN, FMT_BLANK, FMT_CHAR, FMT_P, FMT_IBOZ, FMT_F,\n   FMT_E, FMT_EN, FMT_ES, FMT_G, FMT_L, FMT_A, FMT_D, FMT_H, FMT_END,\n   FMT_ERROR, FMT_DC, FMT_DP, FMT_T, FMT_TR, FMT_TL, FMT_STAR, FMT_RC,\n-  FMT_RD, FMT_RN, FMT_RP, FMT_RU, FMT_RZ\n+  FMT_RD, FMT_RN, FMT_RP, FMT_RU, FMT_RZ, FMT_DT\n };\n \n /* Local variables for checking format strings.  The saved_token is\n@@ -463,6 +463,44 @@ format_lex (void)\n \t    return FMT_ERROR;\n \t  token = FMT_DC;\n \t}\n+      else if (c == 'T')\n+\t{\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DT format \"\n+\t      \"specifier not allowed at %C\"))\n+\t    return FMT_ERROR;\n+\t  token = FMT_DT;\n+\t  c = next_char_not_space (&error);\n+\t  if (c == '\\'' || c == '\"')\n+\t    {\n+\t      delim = c;\n+\t      value = 0;\n+\n+\t      for (;;)\n+\t\t{\n+\t\t  c = next_char (INSTRING_WARN);\n+\t\t  if (c == '\\0')\n+\t\t    {\n+\t\t      token = FMT_END;\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (c == delim)\n+\t\t    {\n+\t\t      c = next_char (NONSTRING);\n+\n+\t\t      if (c == '\\0')\n+\t\t\t{\n+\t\t\t  token = FMT_END;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      unget_char ();\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    unget_char ();\n+\t}\n       else\n \t{\n \t  token = FMT_D;\n@@ -652,6 +690,54 @@ check_format (bool is_input)\n \treturn false;\n       goto between_desc;\n \n+    case FMT_DT:\n+      t = format_lex ();\n+      if (t == FMT_ERROR)\n+\tgoto fail;\n+      switch (t)\n+\t{\n+\tcase FMT_RPAREN:\n+\t  level--;\n+\t  if (level < 0)\n+\t    goto finished;\n+\t  goto between_desc;\n+\n+\tcase FMT_COMMA:\n+\t  goto format_item;\n+\n+\tcase FMT_LPAREN:\n+\n+  dtio_vlist:\n+\t  t = format_lex ();\n+\t  if (t == FMT_ERROR)\n+\t    goto fail;\n+\n+\t  if (t != FMT_POSINT)\n+\t    {\n+\t      error = posint_required;\n+\t      goto syntax;\n+\t    }\n+\n+\t  t = format_lex ();\n+\t  if (t == FMT_ERROR)\n+\t    goto fail;\n+\n+\t  if (t == FMT_COMMA)\n+\t    goto dtio_vlist;\n+\t  if (t != FMT_RPAREN)\n+\t    {\n+\t      error = _(\"Right parenthesis expected at %C\");\n+\t      goto syntax;\n+\t    }\n+\t  goto between_desc;\n+\n+\tdefault:\n+\t  error = unexpected_element;\n+\t  goto syntax;\n+\t}\n+\n+      goto format_item;\n+\n     case FMT_SIGN:\n     case FMT_BLANK:\n     case FMT_DP:"}, {"sha": "9056cb75dacbda676f3aeec95cdaabb44118841d", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -102,6 +102,12 @@ gfc_op2string (gfc_intrinsic_op op)\n     case INTRINSIC_NONE:\n       return \"none\";\n \n+    /* DTIO  */\n+    case INTRINSIC_FORMATTED:\n+      return \"formatted\";\n+    case INTRINSIC_UNFORMATTED:\n+      return \"unformatted\";\n+\n     default:\n       break;\n     }"}, {"sha": "72be6e57330fec15e666503111981058222b7b6b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 117, "deletions": 19, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -6689,6 +6689,11 @@ derived_inaccessible (gfc_symbol *sym)\n \n   for (c = sym->components; c; c = c->next)\n     {\n+\t/* Prevent an infinite loop through this function.  */\n+\tif (c->ts.type == BT_DERIVED && c->attr.pointer\n+\t    && sym == c->ts.u.derived)\n+\t  continue;\n+\n \tif (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.u.derived))\n \t  return 1;\n     }\n@@ -8642,9 +8647,13 @@ static void\n resolve_transfer (gfc_code *code)\n {\n   gfc_typespec *ts;\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *derived;\n   gfc_ref *ref;\n   gfc_expr *exp;\n+  bool write = false;\n+  bool formatted = false;\n+  gfc_dt *dt = code->ext.dt;\n+  gfc_symbol *dtio_sub = NULL;\n \n   exp = code->expr1;\n \n@@ -8668,7 +8677,7 @@ resolve_transfer (gfc_code *code)\n   /* If we are reading, the variable will be changed.  Note that\n      code->ext.dt may be NULL if the TRANSFER is related to\n      an INQUIRE statement -- but in this case, we are not reading, either.  */\n-  if (code->ext.dt && code->ext.dt->dt_io_kind->value.iokind == M_READ\n+  if (dt && dt->dt_io_kind->value.iokind == M_READ\n       && !gfc_check_vardef_context (exp, false, false, false,\n \t\t\t\t    _(\"item in READ\")))\n     return;\n@@ -8680,9 +8689,53 @@ resolve_transfer (gfc_code *code)\n     if (ref->type == REF_COMPONENT)\n       ts = &ref->u.c.component->ts;\n \n-  if (ts->type == BT_CLASS)\n+  if (dt && dt->dt_io_kind->value.iokind != M_INQUIRE\n+      && (ts->type == BT_DERIVED || ts->type == BT_CLASS))\n+    {\n+      if (ts->type == BT_DERIVED)\n+\tderived = ts->u.derived;\n+      else\n+\tderived = ts->u.derived->components->ts.u.derived;\n+\n+      if (dt->format_expr)\n+\t{\n+\t  char *fmt;\n+\t  fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,\n+\t\t\t\t      -1);\n+\t  if (strtok (fmt, \"DT\") != NULL)\n+\t    formatted = true;\n+\t}\n+      else if (dt->format_label == &format_asterisk)\n+\t{\n+\t  /* List directed io must call the formatted DTIO procedure.  */\n+\t  formatted = true;\n+\t}\n+\n+      write = dt->dt_io_kind->value.iokind == M_WRITE\n+\t      || dt->dt_io_kind->value.iokind == M_PRINT;\n+      dtio_sub = gfc_find_specific_dtio_proc (derived, write, formatted);\n+\n+      if (dtio_sub != NULL && exp->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  sym = exp->symtree->n.sym->ns->proc_name;\n+\t  /* Check to see if this is a nested DTIO call, with the\n+\t     dummy as the io-list object.  */\n+\t  if (sym && sym == dtio_sub && sym->formal\n+\t      && sym->formal->sym == exp->symtree->n.sym\n+\t      && exp->ref == NULL)\n+\t    {\n+\t      if (!sym->attr.recursive)\n+\t\t{\n+\t\t  gfc_error (\"DTIO %s procedure at %L must be recursive\",\n+\t\t\t     sym->name, &sym->declared_at);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (ts->type == BT_CLASS && dtio_sub == NULL)\n     {\n-      /* FIXME: Test for defined input/output.  */\n       gfc_error (\"Data transfer element at %L cannot be polymorphic unless \"\n                 \"it is processed by a defined input/output procedure\",\n                 &code->loc);\n@@ -8692,8 +8745,9 @@ resolve_transfer (gfc_code *code)\n   if (ts->type == BT_DERIVED)\n     {\n       /* Check that transferred derived type doesn't contain POINTER\n-\t components.  */\n-      if (ts->u.derived->attr.pointer_comp)\n+\t components unless it is processed by a defined input/output\n+\t procedure\".  */\n+      if (ts->u.derived->attr.pointer_comp && dtio_sub == NULL)\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have POINTER \"\n \t\t     \"components unless it is processed by a defined \"\n@@ -8709,7 +8763,7 @@ resolve_transfer (gfc_code *code)\n \t  return;\n \t}\n \n-      if (ts->u.derived->attr.alloc_comp)\n+      if (ts->u.derived->attr.alloc_comp && dtio_sub == NULL)\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have ALLOCATABLE \"\n \t\t     \"components unless it is processed by a defined \"\n@@ -8726,10 +8780,11 @@ resolve_transfer (gfc_code *code)\n \t\t\t       \"cannot have PRIVATE components\", &code->loc))\n \t    return;\n \t}\n-      else if (derived_inaccessible (ts->u.derived))\n+      else if (derived_inaccessible (ts->u.derived) && dtio_sub == NULL)\n \t{\n \t  gfc_error (\"Data transfer element at %L cannot have \"\n-\t\t     \"PRIVATE components\",&code->loc);\n+\t\t     \"PRIVATE components unless it is processed by \"\n+\t\t     \"a defined input/output procedure\", &code->loc);\n \t  return;\n \t}\n     }\n@@ -10901,6 +10956,21 @@ resolve_bind_c_derived_types (gfc_symbol *derived_sym)\n }\n \n \n+/* Check the interfaces of DTIO procedures associated with derived\n+   type 'sym'.  These procedures can either have typebound bindings or\n+   can appear in DTIO generic interfaces.  */\n+\n+static void\n+gfc_verify_DTIO_procedures (gfc_symbol *sym)\n+{\n+  if (!sym || sym->attr.flavor != FL_DERIVED)\n+    return;\n+\n+  gfc_check_dtio_interfaces (sym);\n+\n+  return;\n+}\n+\n /* Verify that any binding labels used in a given namespace do not collide\n    with the names or binding labels of any global symbols.  Multiple INTERFACE\n    for the same procedure are permitted.  */\n@@ -13421,11 +13491,31 @@ resolve_fl_derived (gfc_symbol *sym)\n }\n \n \n+/* Check for formatted read and write DTIO procedures.  */\n+\n+static bool\n+dtio_procs_present (gfc_symbol *sym)\n+{\n+  gfc_symbol *derived;\n+\n+  if (sym->ts.type == BT_CLASS)\n+    derived = CLASS_DATA (sym)->ts.u.derived;\n+  else if (sym->ts.type == BT_DERIVED)\n+    derived = sym->ts.u.derived;\n+  else\n+    return false;\n+\n+  return gfc_find_specific_dtio_proc (derived, true, true) != NULL\n+\t && gfc_find_specific_dtio_proc (derived, false, true) != NULL;\n+}\n+\n+\n static bool\n resolve_fl_namelist (gfc_symbol *sym)\n {\n   gfc_namelist *nl;\n   gfc_symbol *nlsym;\n+  bool dtio;\n \n   for (nl = sym->namelist; nl; nl = nl->next)\n     {\n@@ -13459,9 +13549,9 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t\t\t      sym->name, &sym->declared_at))\n \treturn false;\n \n-      /* FIXME: Once UDDTIO is implemented, the following can be\n-\t removed.  */\n-      if (nl->sym->ts.type == BT_CLASS)\n+      dtio = dtio_procs_present (nl->sym);\n+\n+      if (nl->sym->ts.type == BT_CLASS && !dtio)\n \t{\n \t  gfc_error (\"NAMELIST object %qs in namelist %qs at %L is \"\n \t\t     \"polymorphic and requires a defined input/output \"\n@@ -13479,13 +13569,14 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t\t\t       sym->name, &sym->declared_at))\n \t    return false;\n \n-\t /* FIXME: Once UDDTIO is implemented, the following can be\n-\t    removed.  */\n-\t  gfc_error (\"NAMELIST object %qs in namelist %qs at %L has \"\n-\t\t     \"ALLOCATABLE or POINTER components and thus requires \"\n-\t\t     \"a defined input/output procedure\", nl->sym->name,\n-\t\t     sym->name, &sym->declared_at);\n-\t  return false;\n+\t  if (!dtio)\n+\t    {\n+\t      gfc_error (\"NAMELIST object %qs in namelist %qs at %L has \"\n+\t\t\t\"ALLOCATABLE or POINTER components and thus requires \"\n+\t\t\t\"a defined input/output procedure\", nl->sym->name,\n+\t\t\tsym->name, &sym->declared_at);\n+\t      return false;\n+\t    }\n \t}\n     }\n \n@@ -13504,6 +13595,11 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t      return false;\n \t    }\n \n+\t  /* If the derived type has specific DTIO procedures for both read and\n+\t     write then namelist objects with private components are OK.  */\n+\t  if (dtio_procs_present (nl->sym))\n+\t    continue;\n+\n \t  /* Types with private components that came here by USE-association.  */\n \t  if (nl->sym->ts.type == BT_DERIVED\n \t      && derived_inaccessible (nl->sym->ts.u.derived))\n@@ -15527,6 +15623,8 @@ resolve_types (gfc_namespace *ns)\n \n   gfc_resolve_uops (ns->uop_root);\n \n+  gfc_traverse_ns (ns, gfc_verify_DTIO_procedures);\n+\n   gfc_resolve_omp_declare_simd (ns);\n \n   gfc_resolve_omp_udrs (ns->omp_udr_root);"}, {"sha": "1b94622bf4b3a48c1c8e5c47f5c9d1624c85c7d7", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -87,6 +87,15 @@ const mstring save_status[] =\n     minit (\"IMPLICIT-SAVE\", SAVE_IMPLICIT),\n };\n \n+/* Set the mstrings for DTIO procedure names.  */\n+const mstring dtio_procs[] =\n+{\n+    minit (\"_dtio_formatted_read\", DTIO_RF),\n+    minit (\"_dtio_formatted_write\", DTIO_WF),\n+    minit (\"_dtio_unformatted_read\", DTIO_RUF),\n+    minit (\"_dtio_unformatted_write\", DTIO_WUF),\n+};\n+\n /* This is to make sure the backend generates setup code in the correct\n    order.  */\n "}, {"sha": "5bae8ca2b19d064ddc0be3796b77acaa1cad35af", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -638,6 +638,16 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n \t\t&& sym->attr.codimension && !sym->attr.allocatable)))\n     TREE_STATIC (decl) = 1;\n \n+  /* If derived-type variables with DTIO procedures are not made static\n+     some bits of code referencing them get optimized away.\n+     TODO Understand why this is so and fix it.  */\n+  if (!sym->attr.use_assoc\n+      && ((sym->ts.type == BT_DERIVED\n+           && sym->ts.u.derived->attr.has_dtio_procs)\n+\t  || (sym->ts.type == BT_CLASS\n+\t      && CLASS_DATA (sym)->ts.u.derived->attr.has_dtio_procs)))\n+    TREE_STATIC (decl) = 1;\n+\n   if (sym->attr.volatile_)\n     {\n       TREE_THIS_VOLATILE (decl) = 1;"}, {"sha": "19239fb51f2fc16579b1fef99e1642da6d0c26f3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -430,9 +430,17 @@ gfc_get_vptr_from_expr (tree expr)\n \t  else\n \t    type = NULL_TREE;\n \t}\n-      if (TREE_CODE (tmp) == VAR_DECL)\n+      if (TREE_CODE (tmp) == VAR_DECL\n+\t  || TREE_CODE (tmp) == PARM_DECL)\n \tbreak;\n     }\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (tmp)))\n+    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\n+  if (GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+    return gfc_class_vptr_get (tmp);\n+\n   return NULL_TREE;\n }\n \n@@ -511,7 +519,14 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n   if (optional)\n     cond_optional = gfc_conv_expr_present (e->symtree->n.sym);\n \n-  if (parmse->ss && parmse->ss->info->useflags)\n+  if (parmse->expr && POINTER_TYPE_P (TREE_TYPE (parmse->expr)))\n+    {\n+      /* If there is a ready made pointer to a derived type, use it\n+\t rather than evaluating the expression again.  */\n+      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+      gfc_add_modify (&parmse->pre, ctree, tmp);\n+    }\n+  else if (parmse->ss && parmse->ss->info && parmse->ss->info->useflags)\n     {\n       /* For an array reference in an elemental procedure call we need\n \t to retain the ss to provide the scalarized array reference.  */\n@@ -522,7 +537,6 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t\t  cond_optional, tmp,\n \t\t\t  fold_convert (TREE_TYPE (tmp), null_pointer_node));\n       gfc_add_modify (&parmse->pre, ctree, tmp);\n-\n     }\n   else\n     {\n@@ -2319,7 +2333,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n      On the other hand, if the context is a UNION or a MAP (a\n      RECORD_TYPE within a UNION_TYPE) always use the given FIELD_DECL.  */\n \n-  if (context != TREE_TYPE (decl) \n+  if (context != TREE_TYPE (decl)\n       && !(   TREE_CODE (TREE_TYPE (field)) == UNION_TYPE /* Field is union */\n            || TREE_CODE (context) == UNION_TYPE))         /* Field is map */\n     {"}, {"sha": "2c843497295703fd9d753a1a3a658a09d2619603", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 206, "deletions": 60, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -132,6 +132,7 @@ enum iocall\n   IOCALL_X_COMPLEX128_WRITE,\n   IOCALL_X_ARRAY,\n   IOCALL_X_ARRAY_WRITE,\n+  IOCALL_X_DERIVED,\n   IOCALL_OPEN,\n   IOCALL_CLOSE,\n   IOCALL_INQUIRE,\n@@ -142,6 +143,7 @@ enum iocall\n   IOCALL_ENDFILE,\n   IOCALL_FLUSH,\n   IOCALL_SET_NML_VAL,\n+  IOCALL_SET_NML_DTIO_VAL,\n   IOCALL_SET_NML_VAL_DIM,\n   IOCALL_WAIT,\n   IOCALL_NUM\n@@ -397,6 +399,10 @@ gfc_build_io_library_fndecls (void)\n \tvoid_type_node, 4, dt_parm_type, pvoid_type_node,\n \tinteger_type_node, gfc_charlen_type_node);\n \n+  iocall[IOCALL_X_DERIVED] = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"transfer_derived\")), \".wrR\",\n+\tvoid_type_node, 2, dt_parm_type, pvoid_type_node, pchar_type_node);\n+\n   /* Library entry points */\n \n   iocall[IOCALL_READ] = gfc_build_library_function_decl_with_spec (\n@@ -468,19 +474,21 @@ gfc_build_io_library_fndecls (void)\n \tvoid_type_node, 6, dt_parm_type, pvoid_type_node, pvoid_type_node,\n \tgfc_int4_type_node, gfc_charlen_type_node, gfc_int4_type_node);\n \n+  iocall[IOCALL_SET_NML_DTIO_VAL] = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"st_set_nml_dtio_var\")), \".w.R\",\n+\tvoid_type_node, 8, dt_parm_type, pvoid_type_node, pvoid_type_node,\n+\tgfc_int4_type_node, gfc_charlen_type_node, gfc_int4_type_node,\n+\tpvoid_type_node, pvoid_type_node);\n+\n   iocall[IOCALL_SET_NML_VAL_DIM] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"st_set_nml_var_dim\")), \".w\",\n \tvoid_type_node, 5, dt_parm_type, gfc_int4_type_node,\n \tgfc_array_index_type, gfc_array_index_type, gfc_array_index_type);\n }\n \n \n-/* Generate code to store an integer constant into the\n-   st_parameter_XXX structure.  */\n-\n-static unsigned int\n-set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n-\t\t     unsigned int val)\n+static void\n+set_parameter_tree (stmtblock_t *block, tree var, enum iofield type, tree value)\n {\n   tree tmp;\n   gfc_st_parameter_field *p = &st_parameter_field[type];\n@@ -491,7 +499,21 @@ set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n \t\t\t   var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n   tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n \t\t\t var, p->field, NULL_TREE);\n-  gfc_add_modify (block, tmp, build_int_cst (TREE_TYPE (p->field), val));\n+  gfc_add_modify (block, tmp, value);\n+}\n+\n+\n+/* Generate code to store an integer constant into the\n+   st_parameter_XXX structure.  */\n+\n+static unsigned int\n+set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n+\t\t     unsigned int val)\n+{\n+  gfc_st_parameter_field *p = &st_parameter_field[type];\n+\n+  set_parameter_tree (block, var, type,\n+\t\t      build_int_cst (TREE_TYPE (p->field), val));\n   return p->mask;\n }\n \n@@ -637,7 +659,7 @@ set_parameter_value_inquire (stmtblock_t *block, tree var,\n \n       body = gfc_finish_block (&newblock);\n \n-      cond3 = gfc_unlikely (cond3, PRED_FORTRAN_FAIL_IO);    \n+      cond3 = gfc_unlikely (cond3, PRED_FORTRAN_FAIL_IO);\n       var = build3_v (COND_EXPR, cond3, body, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&se.pre, var);\n     }\n@@ -697,13 +719,7 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n       gfc_add_modify (postblock, se.expr, tmp);\n      }\n \n-  if (p->param_type == IOPARM_ptype_common)\n-    var = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t   st_parameter[IOPARM_ptype_common].type,\n-\t\t\t   var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t\t var, p->field, NULL_TREE);\n-  gfc_add_modify (block, tmp, addr);\n+  set_parameter_tree (block, var, type, addr);\n   return p->mask;\n }\n \n@@ -1618,6 +1634,8 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   tree dt_parm_addr;\n   tree decl = NULL_TREE;\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n+  tree dtio_proc = null_pointer_node;\n+  tree vtable = null_pointer_node;\n   int n_dim;\n   int itype;\n   int rank = 0;\n@@ -1659,15 +1677,45 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n \n   dt_parm_addr = gfc_build_addr_expr (NULL_TREE, dt_parm);\n \n+  /* Check if the derived type has a specific DTIO for the mode.\n+     Note that although namelist io is forbidden to have a format\n+     list, the specific subroutine is of the formatted kind.  */\n+  if (ts->type == BT_DERIVED)\n+    {\n+      gfc_symbol *dtio_sub = NULL;\n+      gfc_symbol *vtab;\n+      dtio_sub = gfc_find_specific_dtio_proc (ts->u.derived,\n+\t\t\t\t\t      last_dt == WRITE,\n+\t\t\t\t\t      true);\n+      if (dtio_sub != NULL)\n+\t{\n+\t  dtio_proc = gfc_get_symbol_decl (dtio_sub);\n+\t  dtio_proc = gfc_build_addr_expr (NULL, dtio_proc);\n+\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n+\t  vtable = vtab->backend_decl;\n+\t  if (vtable == NULL_TREE)\n+\t    vtable = gfc_get_symbol_decl (vtab);\n+\t  vtable = gfc_build_addr_expr (pvoid_type_node, vtable);\n+\t}\n+    }\n+\n   if (ts->type == BT_CHARACTER)\n     tmp = ts->u.cl->backend_decl;\n   else\n     tmp = build_int_cst (gfc_charlen_type_node, 0);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t iocall[IOCALL_SET_NML_VAL], 6,\n-\t\t\t dt_parm_addr, addr_expr, string,\n-\t\t\t build_int_cst (gfc_int4_type_node, ts->kind),\n-\t\t\t tmp, dtype);\n+\n+  if (dtio_proc == NULL_TREE)\n+    tmp = build_call_expr_loc (input_location,\n+\t\t\t   iocall[IOCALL_SET_NML_VAL], 6,\n+\t\t\t   dt_parm_addr, addr_expr, string,\n+\t\t\t   build_int_cst (gfc_int4_type_node, ts->kind),\n+\t\t\t   tmp, dtype);\n+  else\n+    tmp = build_call_expr_loc (input_location,\n+\t\t\t   iocall[IOCALL_SET_NML_DTIO_VAL], 8,\n+\t\t\t   dt_parm_addr, addr_expr, string,\n+\t\t\t   build_int_cst (gfc_int4_type_node, ts->kind),\n+\t\t\t   tmp, dtype, dtio_proc, vtable);\n   gfc_add_expr_to_block (block, tmp);\n \n   /* If the object is an array, transfer rank times:\n@@ -1685,7 +1733,8 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n-  if (gfc_bt_struct (ts->type) && ts->u.derived->components)\n+  if (gfc_bt_struct (ts->type) && ts->u.derived->components\n+      && dtio_proc == null_pointer_node)\n     {\n       gfc_component *cmp;\n \n@@ -1995,7 +2044,8 @@ gfc_trans_dt_end (gfc_code * code)\n }\n \n static void\n-transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code);\n+transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr,\n+\t       gfc_code * code, tree vptr);\n \n /* Given an array field in a derived type variable, generate the code\n    for the loop that iterates over array elements, and the code that\n@@ -2061,7 +2111,7 @@ transfer_array_component (tree expr, gfc_component * cm, locus * where)\n   /* Now se.expr contains an element of the array.  Take the address and pass\n      it to the IO routines.  */\n   tmp = gfc_build_addr_expr (NULL_TREE, se.expr);\n-  transfer_expr (&se, &cm->ts, tmp, NULL);\n+  transfer_expr (&se, &cm->ts, tmp, NULL, NULL_TREE);\n \n   /* We are done now with the loop body.  Wrap up the scalarizer and\n      return.  */\n@@ -2081,10 +2131,53 @@ transfer_array_component (tree expr, gfc_component * cm, locus * where)\n   return gfc_finish_block (&block);\n }\n \n+\n+/* Helper function for transfer_expr that looks for the DTIO procedure\n+   either as a typebound binding or in a generic interface. If present,\n+   the address expression of the procedure is returned. It is assumed\n+   that the procedure interface has been checked during resolution.  */\n+\n+static tree\n+get_dtio_proc (gfc_typespec * ts, gfc_code * code, gfc_symbol **dtio_sub)\n+{\n+  gfc_symbol *derived;\n+  bool formatted = false;\n+  gfc_dt *dt = code->ext.dt;\n+\n+  if (dt && dt->format_expr)\n+    {\n+      char *fmt;\n+      fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,\n+\t\t\t\t  -1);\n+      if (strtok (fmt, \"DT\") != NULL)\n+\tformatted = true;\n+    }\n+  else if (dt && dt->format_label == &format_asterisk)\n+    {\n+      /* List directed io must call the formatted DTIO procedure.  */\n+      formatted = true;\n+    }\n+\n+  if (ts->type == BT_DERIVED)\n+    derived = ts->u.derived;\n+  else\n+    derived = ts->u.derived->components->ts.u.derived;\n+\n+  *dtio_sub = gfc_find_specific_dtio_proc (derived, last_dt == WRITE,\n+\t\t\t\t\t   formatted);\n+\n+  if (*dtio_sub)\n+    return gfc_build_addr_expr (NULL, gfc_get_symbol_decl (*dtio_sub));\n+\n+  return NULL_TREE;\n+\n+}\n+\n /* Generate the call for a scalar transfer node.  */\n \n static void\n-transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n+transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr,\n+\t       gfc_code * code, tree vptr)\n {\n   tree tmp, function, arg2, arg3, field, expr;\n   gfc_component *c;\n@@ -2212,43 +2305,81 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n       break;\n \n     case_bt_struct:\n+    case BT_CLASS:\n       if (ts->u.derived->components == NULL)\n \treturn;\n+      if (ts->type == BT_DERIVED || ts->type == BT_CLASS)\n+\t{\n+\t  gfc_symbol *derived;\n+\t  gfc_symbol *dtio_sub = NULL;\n+\t  /* Test for a specific DTIO subroutine.  */\n+\t  if (ts->type == BT_DERIVED)\n+\t    derived = ts->u.derived;\n+\t  else\n+\t    derived = ts->u.derived->components->ts.u.derived;\n \n-      /* Recurse into the elements of the derived type.  */\n-      expr = gfc_evaluate_now (addr_expr, &se->pre);\n-      expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t      expr);\n+\t  if (derived->attr.has_dtio_procs)\n+\t    arg2 = get_dtio_proc (ts, code, &dtio_sub);\n \n-      /* Make sure that the derived type has been built.  An external\n-\t function, if only referenced in an io statement, requires this\n-\t check (see PR58771).  */\n-      if (ts->u.derived->backend_decl == NULL_TREE)\n-\t(void) gfc_typenode_for_spec (ts);\n+\t  if (dtio_sub != NULL)\n+\t    {\n+\t      tree decl;\n+\t      decl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t  se->expr);\n+\t      /* Remember that the first dummy of the DTIO subroutines\n+\t\t is CLASS(derived) for extensible derived types, so the\n+\t\t conversion must be done here for derived type and for\n+\t\t scalarized CLASS array element io-list objects.  */\n+\t      if ((ts->type == BT_DERIVED\n+\t\t   && !(ts->u.derived->attr.sequence\n+\t\t\t|| ts->u.derived->attr.is_bind_c))\n+\t\t  || (ts->type == BT_CLASS\n+\t\t      && !GFC_CLASS_TYPE_P (TREE_TYPE (decl))))\n+\t\tgfc_conv_derived_to_class (se, code->expr1,\n+\t\t\t\t\t   dtio_sub->formal->sym->ts,\n+\t\t\t\t\t   vptr, false, false);\n+\t      addr_expr = se->expr;\n+\t      function = iocall[IOCALL_X_DERIVED];\n+\t      break;\n+\t    }\n+\t  else if (ts->type == BT_DERIVED)\n+\t    {\n+\t      /* Recurse into the elements of the derived type.  */\n+\t      expr = gfc_evaluate_now (addr_expr, &se->pre);\n+\t      expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t      expr);\n \n-      for (c = ts->u.derived->components; c; c = c->next)\n-\t{\n-\t  field = c->backend_decl;\n-\t  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n-\n-\t  tmp = fold_build3_loc (UNKNOWN_LOCATION,\n-\t\t\t     COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t     expr, field, NULL_TREE);\n-\n-          if (c->attr.dimension)\n-            {\n-              tmp = transfer_array_component (tmp, c, & code->loc);\n-              gfc_add_expr_to_block (&se->pre, tmp);\n-            }\n-          else\n-            {\n-              if (!c->attr.pointer)\n-                tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n-              transfer_expr (se, &c->ts, tmp, code);\n-            }\n+\t      /* Make sure that the derived type has been built.  An external\n+\t\t function, if only referenced in an io statement, requires this\n+\t\t check (see PR58771).  */\n+\t      if (ts->u.derived->backend_decl == NULL_TREE)\n+\t\t(void) gfc_typenode_for_spec (ts);\n+\n+\t      for (c = ts->u.derived->components; c; c = c->next)\n+\t\t{\n+\t\t  field = c->backend_decl;\n+\t\t  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n+\n+\t\t  tmp = fold_build3_loc (UNKNOWN_LOCATION,\n+\t\t\t\t\t COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t\t\t expr, field, NULL_TREE);\n+\n+\t\t  if (c->attr.dimension)\n+\t\t    {\n+\t\t      tmp = transfer_array_component (tmp, c, & code->loc);\n+\t\t      gfc_add_expr_to_block (&se->pre, tmp);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (!c->attr.pointer)\n+\t\t\ttmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t\t      transfer_expr (se, &c->ts, tmp, code, NULL_TREE);\n+\t\t   }\n+\t\t}\n+\t      return;\n+\t    }\n+\t  /* If a CLASS object gets through to here, fall through and ICE.  */\n \t}\n-      return;\n-\n     default:\n       gfc_internal_error (\"Bad IO basetype (%d)\", ts->type);\n     }\n@@ -2303,6 +2434,7 @@ gfc_trans_transfer (gfc_code * code)\n   gfc_ss *ss;\n   gfc_se se;\n   tree tmp;\n+  tree vptr;\n   int n;\n \n   gfc_start_block (&block);\n@@ -2315,8 +2447,18 @@ gfc_trans_transfer (gfc_code * code)\n   if (expr->rank == 0)\n     {\n       /* Transfer a scalar value.  */\n-      gfc_conv_expr_reference (&se, expr);\n-      transfer_expr (&se, &expr->ts, se.expr, code);\n+      if (expr->ts.type == BT_CLASS)\n+\t{\n+\t  se.want_pointer = 1;\n+\t  gfc_conv_expr (&se, expr);\n+\t  vptr = gfc_get_vptr_from_expr (se.expr);\n+\t}\n+      else\n+\t{\n+\t  vptr = NULL_TREE;\n+\t  gfc_conv_expr_reference (&se, expr);\n+\t}\n+      transfer_expr (&se, &expr->ts, se.expr, code, vptr);\n     }\n   else\n     {\n@@ -2330,7 +2472,8 @@ gfc_trans_transfer (gfc_code * code)\n \t  gcc_assert (ref && ref->type == REF_ARRAY);\n \t}\n \n-      if (!gfc_bt_struct (expr->ts.type)\n+      if (!(gfc_bt_struct (expr->ts.type)\n+\t      || expr->ts.type == BT_CLASS)\n \t    && ref && ref->next == NULL\n \t    && !is_subref_array (expr))\n \t{\n@@ -2378,9 +2521,12 @@ gfc_trans_transfer (gfc_code * code)\n \n       gfc_copy_loopinfo_to_se (&se, &loop);\n       se.ss = ss;\n-\n       gfc_conv_expr_reference (&se, expr);\n-      transfer_expr (&se, &expr->ts, se.expr, code);\n+      if (expr->ts.type == BT_CLASS)\n+\tvptr = gfc_get_vptr_from_expr (ss->info->data.array.descriptor);\n+      else\n+\tvptr = NULL_TREE;\n+      transfer_expr (&se, &expr->ts, se.expr, code, vptr);\n     }\n \n  finish_block_label:"}, {"sha": "3d385bdc38b9c4f233663ac21d74e5be5d5f356a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -1,3 +1,18 @@\n+2016-08-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\tPaul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/48298\n+\t* gfortran.dg/dtio_1.f90: New test.\n+\t* gfortran.dg/dtio_2.f90: New test.\n+\t* gfortran.dg/dtio_3.f90: New test.\n+\t* gfortran.dg/dtio_4.f90: New test.\n+\t* gfortran.dg/dtio_5.f90: New test.\n+\t* gfortran.dg/dtio_6.f90: New test.\n+\t* gfortran.dg/dtio_7.f90: New test.\n+\t* gfortran.dg/dtio_8.f90: New test.\n+\t* gfortran.dg/dtio_9.f90: New test.\n+\t* gfortran.dg/dtio_10.f90: New test.\n+\n 2016-08-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c"}, {"sha": "f5b526393f32e7cb658f725ce055e5f2d9967825", "filename": "gcc/testsuite/gfortran.dg/dtio_1.f90", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_1.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,164 @@\n+! { dg-do run  }\n+!\n+! Functional test of User Defined Derived Type IO, Formatted WRITE/READ\n+!\n+! 1) Tests passing of iostat out of the user procedure.\n+! 2) Tests parsing of the DT optional string and passing in and using\n+!    to control execution.\n+! 3) Tests parsing of the optional vlist, passing in and using it to\n+!    generate a user defined format string.\n+! 4) Tests passing an iostat or iomsg out of libgfortranthe child procedure back to\n+!    the parent.\n+!\n+MODULE p\n+  USE ISO_FORTRAN_ENV\n+  TYPE :: person\n+    CHARACTER (LEN=20) :: name\n+    INTEGER(4) :: age\n+    CONTAINS\n+      procedure :: pwf\n+      procedure :: prf\n+      GENERIC :: WRITE(FORMATTED) => pwf\n+      GENERIC :: READ(FORMATTED) => prf\n+  END TYPE person\n+CONTAINS\n+  SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)\n+    CLASS(person), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    CHARACTER (LEN=30) :: udfmt\n+    INTEGER :: myios\n+\n+    udfmt='(*(g0))'\n+    iomsg = \"SUCCESS\"\n+    iostat=0\n+    if (iotype.eq.\"DT\") then\n+      if (size(vlist).ne.0) print *, 36\n+      WRITE(unit, FMT = '(a,5x,i2)', IOSTAT=iostat, advance='no') trim(dtv%name), dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF DT\"\n+    endif\n+    if (iotype.eq.\"DTzeroth\") then\n+      if (size(vlist).ne.0) print *, 40\n+      WRITE(unit, FMT = '(g0,g0)', advance='no') dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTzeroth\"\n+    endif\n+    if (iotype.eq.\"DTtwo\") then\n+      if (size(vlist).ne.2) call abort\n+      WRITE(udfmt,'(A,A,I1,A,I1,A)') '(', 'A', vlist(1),',I', vlist(2), ')'\n+      WRITE(unit, FMT='(A8,I2)') dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTtwo\"\n+    endif\n+    if (iotype.eq.\"DTthree\") then\n+      WRITE(udfmt,'(2A,I2,A,I1,A,I2,A)',iostat=myios) '(', 'A', vlist(1),',I', vlist(2), ',F', vlist(3), '.2)'\n+      WRITE(unit, FMT=udfmt, IOSTAT=iostat, advance='no') trim(dtv%name), dtv%age, 3.14\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTthree\"\n+    endif\n+    if (iotype.eq.\"LISTDIRECTED\") then\n+      if (size(vlist).ne.0) print *, 55\n+      WRITE(unit, FMT = *) dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF LISTDIRECTED\"\n+    endif\n+    if (iotype.eq.\"NAMELIST\") then\n+      if (size(vlist).ne.0) print *, 59\n+      iostat=6000\n+    endif\n+  END SUBROUTINE pwf\n+\n+  SUBROUTINE prf (dtv,unit,iotype,vlist,iostat,iomsg)\n+    CLASS(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    CHARACTER (LEN=30) :: udfmt\n+    INTEGER :: myios\n+    real :: areal\n+    udfmt='(*(g0))'\n+    iomsg = \"SUCCESS\"\n+    iostat=0\n+    if (iotype.eq.\"DT\") then\n+      if (size(vlist).ne.0) print *, 36\n+      READ(unit, FMT = '(a,5x,i2)', IOSTAT=iostat, advance='no') dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF DT\"\n+    endif\n+    if (iotype.eq.\"DTzeroth\") then\n+      if (size(vlist).ne.0) print *, 40\n+      READ(unit, FMT = '(a,I2)', advance='no') dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTzeroth\"\n+    endif\n+    if (iotype.eq.\"DTtwo\") then\n+      if (size(vlist).ne.2) call abort\n+      WRITE(udfmt,'(A,A,I1,A,I1,A)') '(', 'A', vlist(1),',I', vlist(2), ')'\n+      READ(unit, FMT='(A8,I2)') dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTtwo\"\n+    endif\n+    if (iotype.eq.\"DTthree\") then\n+      WRITE(udfmt,'(2A,I2,A,I1,A,I2,A)',iostat=myios) '(', 'A', vlist(1),',I', vlist(2), ',F', vlist(3), '.2)'\n+      READ(unit, FMT=udfmt, IOSTAT=iostat, advance='no') dtv%name, dtv%age, areal\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTthree\"\n+    endif\n+    if (iotype.eq.\"LISTDIRECTED\") then\n+      if (size(vlist).ne.0) print *, 55\n+      READ(unit, FMT = *) dtv%name, dtv%age\n+      if (iostat.ne.0) iomsg = \"Fail PWF LISTDIRECTED\"\n+    endif\n+    if (iotype.eq.\"NAMELIST\") then\n+      if (size(vlist).ne.0) print *, 59\n+      iostat=6000\n+    endif\n+    !READ (UNIT = UNIT, FMT = *) dtv%name, dtv%age\n+  END SUBROUTINE prf\n+\n+END MODULE p\n+\n+PROGRAM test\n+  USE p\n+  TYPE (person), SAVE :: chairman\n+  TYPE (person), SAVE :: member\n+  character(80) :: astring\n+  integer :: thelength\n+\n+  chairman%name=\"Charlie\"\n+  chairman%age=62\n+  member%name=\"George\"\n+  member%age=42\n+  astring = \"FAILURE\"\n+  write (10, \"(DT'zeroth',3x, DT'three'(11,4,10),11x,DT'two'(8,2))\", &\n+         & iostat=myiostat, iomsg=astring) member, chairman, member\n+  if (myiostat.ne.0) call abort\n+  if (astring.ne.\"SUCCESS\") call abort\n+  astring = \"FAILURE\"\n+  write (10, *, iostat=myiostat, iomsg=astring) member, chairman, member\n+  if (myiostat.ne.0) call abort\n+  if (astring.ne.\"SUCCESS\") call abort\n+  write(10,*) ! See note below\n+  rewind(10)\n+  chairman%name=\"bogus1\"\n+  chairman%age=99\n+  member%name=\"bogus2\"\n+  member%age=66\n+  astring = \"FAILURE\"\n+  read(10,\"(DT'zeroth',3x, DT'three'(11,4,10),11x,DT'two'(8,2))\") member, chairman, member\n+  if (member%name.ne.\"George\") call abort\n+  if (chairman%name.ne.\"    Charlie\") call abort\n+  if (member%age.ne.42) call abort\n+  if (chairman%age.ne.62) call abort\n+  chairman%name=\"bogus1\"\n+  chairman%age=99\n+  member%name=\"bogus2\"\n+  member%age=66\n+  astring = \"FAILURE\"\n+  read (10, *, iostat=myiostat, iomsg=astring) member, chairman, member\n+  ! The user defined procedure reads to the end of the line/file, then finalizing the parent\n+  ! reads past, so we wrote a blank line above. User needs to address these nuances in their\n+  ! procedures. (subject to interpretation)\n+  if (astring.ne.\"SUCCESS\") call abort\n+  if (member%name.ne.\"George\") call abort\n+  if (chairman%name.ne.\"Charlie\") call abort\n+  if (member%age.ne.42) call abort\n+  if (chairman%age.ne.62) call abort\n+END PROGRAM test"}, {"sha": "71354b7876f8d3e686cdb8958d6c63dbebb1f7de", "filename": "gcc/testsuite/gfortran.dg/dtio_10.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_10.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+!\n+! Tests runtime check of the required type in dtio formatted read.\n+!\n+module usertypes\n+  type udt\n+     integer :: myarray(15)\n+  end type udt\n+  type, extends(udt) :: more\n+    integer :: itest = -25\n+  end type\n+\n+end  module usertypes\n+\n+program test1\n+  use usertypes\n+  type (udt) :: udt1\n+  type (more) :: more1\n+  class (more), allocatable :: somemore\n+  integer  :: thesize, i, ios\n+  character(100) :: errormsg\n+\n+  read (10, fmt='(dt)', advance='no', size=thesize, iostat=ios, &\n+            & iomsg=errormsg) i, udt1\n+  if (ios.ne.5006) call abort\n+  if (errormsg(1:25).ne.\"Expected CLASS or DERIVED\") call abort\n+end program test1"}, {"sha": "2041c5ec608a123a5ea58832c331c604925995f2", "filename": "gcc/testsuite/gfortran.dg/dtio_2.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_2.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run  }\n+!\n+! Functional test of User Defined DT IO, unformatted WRITE/READ\n+!\n+! 1) Tests unformatted DTV write with other variables in the record\n+! 2) Tests reading back the recods written.\n+!\n+module p\n+  type :: person\n+    character (len=20) :: name\n+    integer(4) :: age\n+    contains\n+      procedure :: pwuf\n+      procedure :: pruf\n+      generic :: write(unformatted) => pwuf\n+      generic :: read(unformatted) => pruf\n+  end type person\n+contains\n+  subroutine pwuf (dtv,unit,iostat,iomsg)\n+    class(person), intent(in) :: dtv\n+    integer, intent(in) :: unit\n+    integer, intent(out) :: iostat\n+    character (len=*), intent(inout) :: iomsg\n+    write (unit=unit, iostat=iostat, iomsg=iomsg) dtv%name, dtv%age\n+  end subroutine pwuf\n+\n+  subroutine pruf (dtv,unit,iostat,iomsg)\n+    class(person), intent(inout) :: dtv\n+    integer, intent(in) :: unit\n+    integer, intent(out) :: iostat\n+    character (len=*), intent(inout) :: iomsg\n+    read (unit = unit) dtv%name, dtv%age\n+  end subroutine pruf\n+\n+end module p\n+\n+program test\n+  use p\n+  type (person), save :: chairman\n+  character(3) :: tmpstr1, tmpstr2\n+  chairman%name=\"charlie\"\n+  chairman%age=62\n+\n+  open (unit=71, file='myunformatted_data.dat', form='unformatted')\n+  write (71) \"abc\", chairman, \"efg\"\n+  write (71) \"hij\", chairman, \"klm\"\n+  write (71) \"nop\", chairman, \"qrs\"\n+  rewind (unit = 71)\n+  chairman%name=\"boggle\"\n+  chairman%age=1234\n+  read (71) tmpstr1, chairman, tmpstr2\n+  if (tmpstr1.ne.\"abc\") call abort\n+  if (tmpstr2.ne.\"efg\") call abort\n+  if (chairman%name.ne.\"charlie\") call abort\n+  if (chairman%age.ne.62) call abort\n+  chairman%name=\"boggle\"\n+  chairman%age=1234\n+  read (71) tmpstr1, chairman, tmpstr2\n+  if (tmpstr1.ne.\"hij\") call abort\n+  if (tmpstr2.ne.\"klm\") call abort\n+  if (chairman%name.ne.\"charlie\") call abort\n+  if (chairman%age.ne.62) call abort\n+  chairman%name=\"boggle\"\n+  chairman%age=1234\n+  read (71) tmpstr1, chairman, tmpstr2\n+  if (tmpstr1.ne.\"nop\") call abort\n+  if (tmpstr2.ne.\"qrs\") call abort\n+  if (chairman%name.ne.\"charlie\") call abort\n+  if (chairman%age.ne.62) call abort\n+  close (unit = 71, status='delete')\n+end program test"}, {"sha": "d6b992aaf40ab9de302d279c5812dfbd91575cc6", "filename": "gcc/testsuite/gfortran.dg/dtio_3.f90", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_3.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,172 @@\n+! { dg-do run }\r\n+!\r\n+! Functional test of User Defined Derived Type IO.\r\n+!\r\n+! This tests recursive calls where a derived type has a member that is\r\n+! itself.\r\n+!\r\n+MODULE p\r\n+  USE ISO_FORTRAN_ENV\r\n+  TYPE :: person\r\n+    CHARACTER (LEN=20) :: name\r\n+    INTEGER(4) :: age\r\n+    type(person), pointer :: next => NULL()\r\n+    CONTAINS\r\n+      procedure :: pwf\r\n+      procedure :: prf\r\n+      GENERIC :: WRITE(FORMATTED) => pwf\r\n+      GENERIC :: READ(FORMATTED) => prf\r\n+  END TYPE person\r\n+CONTAINS\r\n+  RECURSIVE SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)\r\n+    CLASS(person), INTENT(IN) :: dtv\r\n+    INTEGER, INTENT(IN) :: unit\r\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\r\n+    INTEGER, INTENT(IN) :: vlist(:)\r\n+    INTEGER, INTENT(OUT) :: iostat\r\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\r\n+    CHARACTER (LEN=30) :: udfmt\r\n+    INTEGER :: myios\r\n+\r\n+    udfmt='(*(g0))'\r\n+    iomsg = \"SUCCESS\"\r\n+    iostat=0\r\n+    if (iotype.eq.\"DT\") then\r\n+      if (size(vlist).ne.0) print *, 36\r\n+      if (associated(dtv%next)) then\r\n+        WRITE(unit, FMT = '(a20,i2, DT)', IOSTAT=iostat, advance='no') dtv%name, dtv%age, dtv%next\r\n+      else\r\n+        WRITE(unit, FMT = '(a20,i2)', IOSTAT=iostat, advance='no') dtv%name, dtv%age\r\n+      endif\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DT\"\r\n+    endif\r\n+    if (iotype.eq.\"DTzeroth\") then\r\n+      if (size(vlist).ne.0) print *, 40\r\n+      WRITE(unit, FMT = '(g0,g0)', advance='no') dtv%name, dtv%age\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTzeroth\"\r\n+    endif\r\n+    if (iotype.eq.\"DTtwo\") then\r\n+      if (size(vlist).ne.2) call abort\r\n+      WRITE(udfmt,'(A,A,I1,A,I1,A)') '(', 'A', vlist(1),',I', vlist(2), ')'\r\n+      WRITE(unit, FMT='(A8,I2)') dtv%name, dtv%age\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTtwo\"\r\n+    endif\r\n+    if (iotype.eq.\"DTthree\") then\r\n+      WRITE(udfmt,'(2A,I2,A,I1,A,I2,A)',iostat=myios) '(', 'A', vlist(1),',I', vlist(2), ',F', vlist(3), '.2)'\r\n+      WRITE(unit, FMT=udfmt, IOSTAT=iostat, advance='no') trim(dtv%name), dtv%age, 3.14\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTthree\"\r\n+    endif\r\n+    if (iotype.eq.\"LISTDIRECTED\") then\r\n+      if (size(vlist).ne.0) print *, 55\r\n+      if (associated(dtv%next)) then\r\n+        WRITE(unit, FMT = *) dtv%name, dtv%age, dtv%next\r\n+      else\r\n+        WRITE(unit, FMT = *) dtv%name, dtv%age\r\n+      endif\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF LISTDIRECTED\"\r\n+    endif\r\n+    if (iotype.eq.\"NAMELIST\") then\r\n+      if (size(vlist).ne.0) print *, 59\r\n+      iostat=6000\r\n+    endif\r\n+    if (associated (dtv%next) .and. (iotype.eq.\"LISTDIRECTED\")) write(unit, fmt = *) dtv%next\r\n+  END SUBROUTINE pwf\r\n+\r\n+  RECURSIVE SUBROUTINE prf (dtv,unit,iotype,vlist,iostat,iomsg)\r\n+    CLASS(person), INTENT(INOUT) :: dtv\r\n+    INTEGER, INTENT(IN) :: unit\r\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\r\n+    INTEGER, INTENT(IN) :: vlist(:)\r\n+    INTEGER, INTENT(OUT) :: iostat\r\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\r\n+    CHARACTER (LEN=30) :: udfmt\r\n+    INTEGER :: myios\r\n+    real :: areal\r\n+    udfmt='(*(g0))'\r\n+    iomsg = \"SUCCESS\"\r\n+    iostat=0\r\n+    if (iotype.eq.\"DT\") then\r\n+      if (size(vlist).ne.0) print *, 36\r\n+      if (associated(dtv%next)) then\r\n+        READ(unit, FMT = '(a20,i2, DT)', IOSTAT=iostat, advance='no') dtv%name, dtv%age, dtv%next\r\n+      else\r\n+        READ(unit, FMT = '(a20,i2)', IOSTAT=iostat, advance='no') dtv%name, dtv%age\r\n+      endif\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DT\"\r\n+    endif\r\n+    if (iotype.eq.\"DTzeroth\") then\r\n+      if (size(vlist).ne.0) print *, 40\r\n+      READ(unit, FMT = '(a,I2)', advance='no') dtv%name, dtv%age\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTzeroth\"\r\n+    endif\r\n+    if (iotype.eq.\"DTtwo\") then\r\n+      if (size(vlist).ne.2) call abort\r\n+      WRITE(udfmt,'(A,A,I1,A,I1,A)') '(', 'A', vlist(1),',I', vlist(2), ')'\r\n+      READ(unit, FMT='(A8,I2)') dtv%name, dtv%age\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTtwo\"\r\n+    endif\r\n+    if (iotype.eq.\"DTthree\") then\r\n+      WRITE(udfmt,'(2A,I2,A,I1,A,I2,A)',iostat=myios) '(', 'A', vlist(1),',I', vlist(2), ',F', vlist(3), '.2)'\r\n+      READ(unit, FMT=udfmt, IOSTAT=iostat, advance='no') dtv%name, dtv%age, areal\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF DTthree\"\r\n+    endif\r\n+    if (iotype.eq.\"LISTDIRECTED\") then\r\n+      if (size(vlist).ne.0) print *, 55\r\n+      READ(unit, FMT = *) dtv%name, dtv%age\r\n+      if (iostat.ne.0) iomsg = \"Fail PWF LISTDIRECTED\"\r\n+    endif\r\n+    if (iotype.eq.\"NAMELIST\") then\r\n+      if (size(vlist).ne.0) print *, 59\r\n+      iostat=6000\r\n+    endif\r\n+    !READ (UNIT = UNIT, FMT = *) dtv%name, dtv%age\r\n+  END SUBROUTINE prf\r\n+\r\n+END MODULE p\r\n+\r\n+PROGRAM test\r\n+  USE p\r\n+  TYPE (person) :: chairman\r\n+  TYPE (person), target :: member\r\n+  character(80) :: astring\r\n+  integer :: thelength\r\n+\r\n+  chairman%name=\"Charlie\"\r\n+  chairman%age=62\r\n+  member%name=\"George\"\r\n+  member%age=42\r\n+  astring = \"FAILURE\"\r\n+  ! At this point, next is NULL as defined up in the type block.\r\n+  open(10, status = \"scratch\")\r\n+  write (10, *, iostat=myiostat, iomsg=astring) member, chairman\r\n+  write(10,*)\r\n+  rewind(10)\r\n+  chairman%name=\"bogus1\"\r\n+  chairman%age=99\r\n+  member%name=\"bogus2\"\r\n+  member%age=66\r\n+  read (10, *, iostat=myiostat, iomsg=astring) member, chairman\r\n+  if (astring.ne.\"SUCCESS\") print *, astring\r\n+  if (member%name.ne.\"George\") call abort\r\n+  if (chairman%name.ne.\"Charlie\") call abort\r\n+  if (member%age.ne.42) call abort\r\n+  if (chairman%age.ne.62) call abort\r\n+  close(10, status='delete')\r\n+  ! Now we set next to point to member. This changes the code path\r\n+  ! in the pwf and prf procedures.\r\n+  chairman%next => member\r\n+  open(10, status = \"scratch\")\r\n+  write (10,\"(DT)\") chairman\r\n+  rewind(10)\r\n+  chairman%name=\"bogus1\"\r\n+  chairman%age=99\r\n+  member%name=\"bogus2\"\r\n+  member%age=66\r\n+  read (10,\"(DT)\", iomsg=astring) chairman\r\n+  !print *, trim(astring)\r\n+  if (member%name.ne.\"George\") call abort\r\n+  if (chairman%name.ne.\"Charlie\") call abort\r\n+  if (member%age.ne.42) call abort\r\n+  if (chairman%age.ne.62) call abort\r\n+  close(10)\r\n+END PROGRAM test\r"}, {"sha": "5323194af801e60d56ac2753dd79cdbc21421478", "filename": "gcc/testsuite/gfortran.dg/dtio_4.f90", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_4.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,107 @@\n+! { dg-do run }\r\n+!\r\n+! Functional test of User Defined Derived Type IO.\r\n+!\r\n+! This tests a combination of module procedure and generic procedure\r\n+! and performs reading and writing an array with a pseudo user defined\r\n+! tag at the beginning of the file.\r\n+!\r\n+module usertypes\r\n+  type udt\r\n+     integer :: myarray(15)\r\n+   contains\r\n+     procedure :: user_defined_read\r\n+     generic :: read (formatted) => user_defined_read\r\n+  end type udt\r\n+  type, extends(udt) :: more\r\n+    integer :: someinteger = -25\r\n+  end type\r\n+\r\n+  interface write(formatted)\r\n+    module procedure user_defined_write\r\n+  end interface\r\n+\r\n+  integer :: result_array(15)\r\n+contains\r\n+  subroutine user_defined_read (dtv, unit, iotype, v_list, iostat, iomsg)\r\n+    class(udt), intent(inout)   :: dtv\r\n+    integer, intent(in)         :: unit\r\n+    character(*), intent(in)    :: iotype\r\n+    integer, intent(in)         :: v_list (:)\r\n+    integer, intent(out)        :: iostat\r\n+    character(*), intent(inout) :: iomsg\r\n+    character(10)               :: typestring\r\n+\r\n+    iomsg = 'SUCCESS'\r\n+    read (unit, '(a6)',  iostat=iostat, iomsg=iomsg) typestring\r\n+    typestring = trim(typestring)\r\n+    select type (dtv)\r\n+      type is (udt)\r\n+        if (typestring.eq.' UDT:     ') then\r\n+          read (unit, fmt=*,  iostat=iostat, iomsg=iomsg) dtv%myarray\r\n+        else\r\n+          iostat = 6000\r\n+          iomsg = 'FAILURE'\r\n+        end if\r\n+      type is (more)\r\n+        if (typestring.eq.' MORE:    ') then\r\n+          read (unit, fmt=*,  iostat=iostat, iomsg=iomsg) dtv%myarray\r\n+        else\r\n+          iostat = 6000\r\n+          iomsg = 'FAILUREwhat'\r\n+        end if\r\n+    end select\r\n+  end subroutine user_defined_read\r\n+\r\n+  subroutine user_defined_write (dtv, unit, iotype, v_list, iostat, iomsg)\r\n+    class(udt), intent(in)      :: dtv\r\n+    integer, intent(in)         :: unit\r\n+    character(*), intent(in)    :: iotype\r\n+    integer, intent(in)         :: v_list (:)\r\n+    integer, intent(out)        :: iostat\r\n+    character(*), intent(inout) :: iomsg\r\n+    character(10)               :: typestring\r\n+    select type (dtv)\r\n+      type is (udt)\r\n+        write (unit, fmt=*, iostat=iostat, iomsg=iomsg)  \"UDT:  \"\r\n+        write (unit, fmt=*, iostat=iostat, iomsg=iomsg)  dtv%myarray\r\n+      type is (more)\r\n+        write (unit, fmt=*, iostat=iostat, iomsg=iomsg)  \"MORE: \"\r\n+        write (unit, fmt=*, iostat=iostat, iomsg=iomsg)  dtv%myarray\r\n+    end select\r\n+    write (unit,*)\r\n+  end subroutine user_defined_write\r\n+end  module usertypes\r\n+\r\n+program test1\r\n+  use usertypes\r\n+  type (udt) :: udt1\r\n+  type (more) :: more1\r\n+  class (more), allocatable :: somemore\r\n+  integer  :: thesize, i, ios\r\n+  character(25):: iomsg\r\n+\r\n+! Create a file that contains some data for testing.\r\n+  open (10, form='formatted', status='scratch')\r\n+  write(10, '(a)') ' UDT: '\r\n+  do i = 1, 15\r\n+    write(10,'(i5)', advance='no') i\r\n+  end do\r\n+  write(10,*)\r\n+  rewind(10)\r\n+  udt1%myarray = 99\r\n+  result_array = (/ (i, i = 1, 15) /)\r\n+  more1%myarray = result_array\r\n+  read (10, fmt='(dt)', advance='no', iomsg=iomsg) udt1\r\n+  if (iomsg.ne.'SUCCESS') call abort\r\n+  if (any(udt1%myarray.ne.result_array)) call abort\r\n+  close(10)\r\n+  open (10, form='formatted')\r\n+  write (10, '(dt)') more1\r\n+  rewind(10)\r\n+  more1%myarray = 99\r\n+  read (10, '(dt)', iostat=ios, iomsg=iomsg) more1\r\n+  if (iomsg.ne.'SUCCESS') call abort\r\n+  if (any(more1%myarray.ne.result_array)) call abort\r\n+  close (10)\r\n+end program test1\r"}, {"sha": "6381d4ddd985e30fa698ca9ae9e75018a68f0653", "filename": "gcc/testsuite/gfortran.dg/dtio_5.f90", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_5.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,278 @@\n+! { dg-do run }\n+!\n+! This test is based on the second case in the PGInsider article at\n+! https://www.pgroup.com/lit/articles/insider/v6n2a3.htm\n+!\n+! The complete original code is at:\n+! https://www.pgroup.com/lit/samples/pginsider/stack.f90\n+!\n+! Thanks to Mark LeAir.\n+!\n+!     Copyright (c) 2015, NVIDIA CORPORATION.  All rights reserved.\n+!\n+! NVIDIA CORPORATION and its licensors retain all intellectual property\n+! and proprietary rights in and to this software, related documentation\n+! and any modifications thereto.  Any use, reproduction, disclosure or\n+! distribution of this software and related documentation without an express\n+! license agreement from NVIDIA CORPORATION is strictly prohibited.\n+!\n+\n+!          THIS CODE AND INFORMATION ARE PROVIDED \"AS IS\" WITHOUT\n+!   WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT\n+!   NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR\n+!   FITNESS FOR A PARTICULAR PURPOSE.\n+!\n+\n+module stack_mod\n+\n+  type, abstract :: stack\n+     private\n+     class(*), allocatable :: item           ! an item on the stack\n+     class(stack), pointer :: next=>null()   ! next item on the stack\n+   contains\n+     procedure :: empty                      ! returns true if stack is empty\n+     procedure :: delete                     ! empties the stack\n+  end type stack\n+\n+type, extends(stack) :: integer_stack\n+contains\n+  procedure :: push => push_integer ! add integer item to stack\n+  procedure :: pop => pop_integer   ! remove integer item from stack\n+  procedure :: compare => compare_integer   ! compare with an integer array\n+end type integer_stack\n+\n+type, extends(integer_stack) :: io_stack\n+contains\n+  procedure,private :: wio_stack\n+  procedure,private :: rio_stack\n+  procedure,private :: dump_stack\n+  generic :: write(unformatted) => wio_stack ! write stack item to file\n+  generic :: read(unformatted) => rio_stack  ! push item from file\n+  generic :: write(formatted) => dump_stack  ! print all items from stack\n+end type io_stack\n+\n+contains\n+\n+  subroutine rio_stack (dtv, unit, iostat, iomsg)\n+\n+    ! read item from file and add it to stack\n+\n+    class(io_stack), intent(inout) :: dtv\n+    integer, intent(in) :: unit\n+    integer, intent(out) :: iostat\n+    character(len=*), intent(inout) :: iomsg\n+\n+    integer :: item\n+\n+    read(unit,IOSTAT=iostat,IOMSG=iomsg) item\n+\n+    if (iostat .ne. 0) then\n+      call dtv%push(item)\n+    endif\n+\n+  end subroutine rio_stack\n+\n+  subroutine wio_stack(dtv, unit, iostat, iomsg)\n+\n+    ! pop an item from stack and write it to file\n+\n+    class(io_stack), intent(in) :: dtv\n+    integer, intent(in) :: unit\n+    integer, intent(out) :: iostat\n+    character(len=*), intent(inout) :: iomsg\n+    integer :: item\n+\n+    item = dtv%pop()\n+    write(unit,IOSTAT=iostat,IOMSG=iomsg) item\n+\n+  end subroutine wio_stack\n+\n+  subroutine dump_stack(dtv, unit, iotype, v_list, iostat, iomsg)\n+\n+    ! Pop all items off stack and write them out to unit\n+    ! Assumes default LISTDIRECTED output\n+\n+    class(io_stack), intent(in) :: dtv\n+    integer, intent(in) :: unit\n+    character(len=*), intent(in) :: iotype\n+    integer, intent(in) :: v_list(:)\n+    integer, intent(out) :: iostat\n+    character(len=*), intent(inout) :: iomsg\n+    character(len=80) :: buffer\n+    integer :: item\n+\n+    if (iotype .ne. 'LISTDIRECTED') then\n+       ! Error\n+       iomsg = 'dump_stack: unsupported iotype'\n+       iostat = 1\n+    else\n+       iostat = 0\n+       do while( (.not. dtv%empty()) .and. (iostat .eq. 0) )\n+         item = dtv%pop()\n+          write(unit, '(I6/)',IOSTAT=iostat,IOMSG=iomsg) item\n+       enddo\n+    endif\n+  end subroutine dump_stack\n+\n+  logical function empty(this)\n+    class(stack) :: this\n+    if (.not.associated(this%next)) then\n+       empty = .true.\n+    else\n+       empty = .false.\n+    end if\n+  end function empty\n+\n+  subroutine push_integer(this,item)\n+    class(integer_stack) :: this\n+    integer :: item\n+    type(integer_stack), allocatable :: new_item\n+\n+    allocate(new_item)\n+    allocate(new_item%item, source=item)\n+    new_item%next => this%next\n+    allocate(this%next, source=new_item)\n+  end subroutine push_integer\n+\n+  function pop_integer(this) result(item)\n+    class(integer_stack) :: this\n+    integer item\n+\n+    if (this%empty()) then\n+       stop 'Error! pop_integer invoked on empty stack'\n+    endif\n+    select type(top=>this%next)\n+    type is (integer_stack)\n+       select type(i => top%item)\n+       type is(integer)\n+          item = i\n+          class default\n+          stop 'Error #1! pop_integer encountered non-integer stack item'\n+       end select\n+       this%next => top%next\n+       deallocate(top)\n+       class default\n+       stop 'Error #2! pop_integer encountered non-integer_stack item'\n+    end select\n+  end function pop_integer\n+\n+! gfortran addition to check read/write\n+  logical function compare_integer (this, array, error)\n+    class(integer_stack), target :: this\n+    class(stack), pointer :: ptr, next\n+    integer :: array(:), i, j, error\n+    compare_integer = .true.\n+    ptr => this\n+    do j = 0, size (array, 1)\n+      if (compare_integer .eqv. .false.) return\n+      select type (ptr)\n+        type is (integer_stack)\n+          select type(k => ptr%item)\n+            type is(integer)\n+              if (k .ne. array(j)) error = 1\n+            class default\n+              error = 2\n+              compare_integer = .false.\n+          end select\n+        class default\n+          if (j .ne. 0) then\n+            error = 3\n+            compare_integer = .false.\n+          end if\n+      end select\n+      next => ptr%next\n+      if (associated (next)) then\n+        ptr => next\n+      else if (j .ne. size (array, 1)) then\n+        error = 4\n+        compare_integer = .false.\n+      end if\n+    end do\n+  end function\n+\n+  subroutine delete (this)\n+    class(stack), target :: this\n+    class(stack), pointer :: ptr1, ptr2\n+    ptr1 => this%next\n+    ptr2 => ptr1%next\n+    do while (associated (ptr1))\n+      deallocate (ptr1)\n+      ptr1 => ptr2\n+      if (associated (ptr1)) ptr2 => ptr1%next\n+    end do\n+  end subroutine\n+\n+end module stack_mod\n+\n+program stack_demo\n+\n+  use stack_mod\n+  implicit none\n+\n+  integer i, k(10), error\n+  class(io_stack), allocatable :: stk\n+  allocate(stk)\n+\n+  k = [3,1,7,0,2,9,4,8,5,6]\n+\n+  ! step 1: set up an 'output' file > changed to 'scratch'\n+\n+  open(10, status='scratch', form='unformatted')\n+\n+  ! step 2: add values to stack\n+\n+  do i=1,10\n+!     write(*,*) 'Adding ',i,' to the stack'\n+     call stk%push(k(i))\n+  enddo\n+\n+  ! step 3: pop values from stack and write them to file\n+\n+!  write(*,*)\n+!  write(*,*) 'Removing each item from stack and writing it to file.'\n+!  write(*,*)\n+  do while(.not.stk%empty())\n+     write(10) stk\n+  enddo\n+\n+  ! step 4: close file and reopen it for read > changed to rewind.\n+\n+  rewind(10)\n+\n+  ! step 5: read values back into stack\n+!  write(*,*) 'Reading each value from file and adding it to stack:'\n+  do while(.true.)\n+     read(10,END=9999) i\n+!     write(*,*), 'Reading ',i,' from file. Adding it to stack'\n+     call stk%push(i)\n+  enddo\n+\n+9999 continue\n+\n+  ! step 6: Dump stack to standard out\n+\n+!  write(*,*)\n+!  write(*,*), 'Removing every element from stack and writing it to screen:'\n+!  write(*,*) stk\n+\n+! gfortran addition to check read/write\n+  if (.not. stk%compare (k, error)) then\n+    select case (error)\n+      case(1)\n+        print *, \"values do not match\"\n+      case(2)\n+        print *, \"non integer found in stack\"\n+      case(3)\n+        print *, \"type mismatch in stack\"\n+      case(4)\n+        print *, \"too few values in stack\"\n+    end select\n+    call abort\n+  end if\n+\n+  close(10)\n+\n+! Clean up - valgrind indicates no leaks.\n+  call stk%delete\n+  deallocate (stk)\n+end program stack_demo"}, {"sha": "089db6facf0b5889c65d52f5cbe299a3cbec20f4", "filename": "gcc/testsuite/gfortran.dg/dtio_6.f90", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_6.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,98 @@\n+! { dg-do compile }\n+!\n+! Tests the checks for interface compliance.\n+!\n+!\n+MODULE p\n+  USE ISO_C_BINDING\n+\n+  TYPE :: person\n+    CHARACTER (LEN=20) :: name\n+    INTEGER(4) :: age\n+    CONTAINS\n+      procedure :: pwf ! { dg-error \"Non-polymorphic passed-object\" }\n+      procedure :: pwuf\n+      GENERIC :: WRITE(FORMATTED) => pwf\n+      GENERIC :: WRITE(UNFORMATTED) => pwuf\n+  END TYPE person\n+  INTERFACE READ(FORMATTED)\n+    MODULE PROCEDURE prf\n+  END INTERFACE\n+  INTERFACE READ(UNFORMATTED)\n+    MODULE PROCEDURE pruf\n+  END INTERFACE\n+\n+  TYPE :: seq_type\n+    sequence\n+    INTEGER(4) :: i\n+  END TYPE seq_type\n+  INTERFACE WRITE(FORMATTED)\n+    MODULE PROCEDURE pwf_seq\n+  END INTERFACE\n+\n+  TYPE, BIND(C) :: bindc_type\n+    INTEGER(C_INT) :: i\n+  END TYPE bindc_type\n+\n+  INTERFACE WRITE(FORMATTED)\n+    MODULE PROCEDURE pwf_bindc\n+  END INTERFACE\n+\n+CONTAINS\n+  SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg) ! { dg-error \"must be of type CLASS\" }\n+    type(person), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE(unit, FMT = *, IOSTAT=iostat) dtv%name, dtv%age\n+  END SUBROUTINE pwf\n+\n+  SUBROUTINE prf (dtv,unit,iotype,vlist,iostat,iomsg) ! { dg-error \"must be an ASSUMED SHAPE ARRAY\" }\n+    CLASS(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    READ (UNIT = UNIT, FMT = *) dtv%name, dtv%age\n+  END SUBROUTINE prf\n+\n+  SUBROUTINE pwuf (dtv,unit,iostat,iomsg)  ! { dg-error \"must have intent IN\" }\n+    CLASS(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE (UNIT=UNIT, FMT = *) DTV%name, DTV%age\n+  END SUBROUTINE pwuf\n+\n+  SUBROUTINE pruf (dtv,unit,iostat,iomsg)  ! { dg-error \"must be of KIND = 4\" }\n+    CLASS(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    INTEGER(8), INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    READ (UNIT = UNIT, FMT = *) dtv%name, dtv%age\n+  END SUBROUTINE pruf\n+\n+  SUBROUTINE pwf_seq (dtv,unit,iotype,vlist,iostat,iomsg) ! { dg-error \"not extensible|DERIVED\" }\n+    class(seq_type), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE(unit, FMT = *, IOSTAT=iostat) dtv%i\n+  END SUBROUTINE pwf_seq\n+\n+  SUBROUTINE pwf_bindc (dtv,unit,iotype,vlist,iostat,iomsg) ! { dg-error \"not extensible|DERIVED\" }\n+    class(bindc_type), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE(unit, FMT = *, IOSTAT=iostat) dtv%i\n+  END SUBROUTINE pwf_bindc\n+\n+END MODULE p"}, {"sha": "33518667488322bd6e9cea4f58f7bcf13b73cc89", "filename": "gcc/testsuite/gfortran.dg/dtio_7.f90", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_7.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,139 @@\n+! { dg-do run }\n+!\n+! Tests dtio transfer of arrays of derived types and classes\n+!\n+MODULE p\n+  TYPE :: person\n+    CHARACTER (LEN=20) :: name\n+    INTEGER(4) :: age\n+    CONTAINS\n+      procedure :: pwf\n+      procedure :: prf\n+      GENERIC :: WRITE(FORMATTED) => pwf\n+      GENERIC :: READ(FORMATTED) => prf\n+  END TYPE person\n+  type, extends(person) :: employee\n+    character(20) :: job_title\n+  end type\n+  type, extends(person) :: officer\n+    character(20) :: position\n+  end type\n+  type, extends(person) :: member\n+    integer :: membership_number\n+  end type\n+  type :: club\n+    type(employee), allocatable :: staff(:)\n+    class(person), allocatable :: committee(:)\n+    class(person), allocatable :: membership(:)\n+  end type\n+CONTAINS\n+  SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)\n+    CLASS(person), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    select type (dtv)\n+      type is (employee)\n+        WRITE(unit, FMT = \"(A/)\", IOSTAT=iostat) \"Employee\"\n+        WRITE(unit, FMT = \"(A20,I4,A20/)\", IOSTAT=iostat) dtv%name, dtv%age, dtv%job_title\n+      type is (officer)\n+        WRITE(unit, FMT = \"(A/)\", IOSTAT=iostat) \"Officer\"\n+        WRITE(unit, FMT = \"(A20,I4,A20/)\", IOSTAT=iostat) dtv%name, dtv%age, dtv%position\n+      type is (member)\n+        WRITE(unit, FMT = \"(A/)\", IOSTAT=iostat) \"Member\"\n+        WRITE(unit, FMT = \"(A20,I4,I4/)\", IOSTAT=iostat) dtv%name, dtv%age, dtv%membership_number\n+      class default\n+        WRITE(unit, FMT = \"(A/)\", IOSTAT=iostat) \"Ugggh!\"\n+        WRITE(unit, FMT = \"(A20,I4,' '/)\", IOSTAT=iostat) dtv%name, dtv%age\n+    end select\n+  END SUBROUTINE pwf\n+\n+  SUBROUTINE prf (dtv,unit,iotype,vlist,iostat,iomsg)\n+    CLASS(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER (LEN=*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: vlist(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    character (20) :: header, rname, jtitle, oposition\n+    integer :: i\n+    integer :: no\n+    integer :: age\n+    iostat = 0\n+    select type (dtv)\n+\n+      type is (employee)\n+        read (unit = unit, fmt = *) header\n+        READ (UNIT = UNIT, FMT = \"(A20,I4,A20)\") rname, age, jtitle\n+        if (trim (rname) .ne. dtv%name) iostat = 1\n+        if (age .ne. dtv%age) iostat = 2\n+        if (trim (jtitle) .ne. dtv%job_title) iostat = 3\n+        if (iotype .ne. \"DTstaff\") iostat = 4\n+\n+      type is (officer)\n+        read (unit = unit, fmt = *) header\n+        READ (UNIT = UNIT, FMT = \"(A20,I4,A20)\") rname, age, oposition\n+        if (trim (rname) .ne. dtv%name) iostat = 1\n+        if (age .ne. dtv%age) iostat = 2\n+        if (trim (oposition) .ne. dtv%position) iostat = 3\n+        if (iotype .ne. \"DTofficers\") iostat = 4\n+\n+      type is (member)\n+        read (unit = unit, fmt = *) header\n+        READ (UNIT = UNIT, FMT = \"(A20,I4,I4)\") rname, age, no\n+        if (trim (rname) .ne. dtv%name) iostat = 1\n+        if (age .ne. dtv%age) iostat = 2\n+        if (no .ne. dtv%membership_number) iostat = 3\n+        if (iotype .ne. \"DTmembers\") iostat = 4\n+\n+      class default\n+        call abort\n+    end select\n+  end subroutine\n+END MODULE p\n+\n+PROGRAM test\n+  USE p\n+\n+  type (club) :: social_club\n+  TYPE (person) :: chairman\n+  CLASS (person), allocatable :: president(:)\n+  character (40) :: line\n+  integer :: i, j\n+\n+  allocate (social_club%staff, source = [employee (\"Bert\",25,\"Barman\"), &\n+                                         employee (\"Joy\",16,\"Auditor\")])\n+\n+  allocate (social_club%committee, source = [officer (\"Hank\",32, \"Chair\"), &\n+                                             officer (\"Ann\", 29, \"Secretary\")])\n+\n+  allocate (social_club%membership, source = [member (\"Dan\",52,1), &\n+                                              member (\"Sue\",39,2)])\n+\n+  chairman%name=\"Charlie\"\n+  chairman%age=62\n+\n+  open (7, status = \"scratch\")\n+  write (7,*) social_club%staff                ! Tests array of derived types\n+  write (7,*) social_club%committee            ! Tests class array\n+  do i = 1, size (social_club%membership, 1)\n+    write (7,*) social_club%membership(i)      ! Tests class array elements\n+  end do\n+\n+  rewind (7)\n+  read (7, \"(DT'staff')\", iostat = i) social_club%staff\n+  if (i .ne. 0) call abort\n+\n+  social_club%committee(2)%age = 33            ! Introduce an error\n+\n+  read (7, \"(DT'officers')\", iostat = i) social_club%committee\n+  if (i .ne. 2) call abort                     ! Pick up error\n+\n+  do j = 1, size (social_club%membership, 1)\n+    read (7, \"(DT'members')\", iostat = i) social_club%membership(j)\n+    if (i .ne. 0) call abort\n+  end do\n+  close (7)\n+END PROGRAM test"}, {"sha": "6e9f841fe896e47a2227c79f42a4682950edad3b", "filename": "gcc/testsuite/gfortran.dg/dtio_8.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_8.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+!\n+! Tests dtio transfer sequence types.\n+!\n+! Note difficulty at end with comparisons at any level of optimization.\n+!\n+MODULE p\n+  TYPE :: person\n+    sequence\n+    CHARACTER (LEN=20) :: name\n+    INTEGER(4) :: age\n+  END TYPE person\n+  INTERFACE WRITE(UNFORMATTED)\n+    MODULE PROCEDURE pwuf\n+  END INTERFACE\n+  INTERFACE READ(UNFORMATTED)\n+    MODULE PROCEDURE pruf\n+  END INTERFACE\n+\n+CONTAINS\n+\n+  SUBROUTINE pwuf (dtv,unit,iostat,iomsg)\n+    type(person), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE (UNIT=UNIT) DTV%name, DTV%age\n+  END SUBROUTINE pwuf\n+\n+  SUBROUTINE pruf (dtv,unit,iostat,iomsg)\n+    type(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    READ (UNIT = UNIT) dtv%name, dtv%age\n+  END SUBROUTINE pruf\n+\n+END MODULE p\n+\n+PROGRAM test\n+  USE p\n+  TYPE (person) :: chairman\n+  character(10) :: line\n+\n+  chairman%name=\"Charlie\"\n+  chairman%age=62\n+\n+  OPEN (UNIT=71, status = 'scratch', FORM='UNFORMATTED')\n+  write (71) chairman\n+  rewind (71)\n+\n+  chairman%name = \"Charles\"\n+  chairman%age = 0\n+\n+  read (71) chairman\n+  close (unit = 71)\n+\n+! Straight comparisons fail at any level of optimization.\n+\n+  write(line, \"(A7)\") chairman%name\n+  if (trim (line) .ne. \"Charlie\") call abort\n+  line = \"          \"\n+  write(line, \"(I4)\") chairman%age\n+  if (trim (line) .eq. \"   62\") print *, trim(line)\n+END PROGRAM test"}, {"sha": "a6ddea8dce25d35b57e5612188e104743532625b", "filename": "gcc/testsuite/gfortran.dg/dtio_9.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_9.f90?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+!\n+! Tests dtio of transfer bind-C types.\n+!\n+! Note difficulties with c_char at -O1. This is why no character field is used.\n+!\n+MODULE p\n+  USE ISO_C_BINDING\n+  TYPE, BIND(C) :: person\n+    integer(c_int) :: id_no\n+    INTEGER(c_int) :: age\n+  END TYPE person\n+  INTERFACE WRITE(UNFORMATTED)\n+    MODULE PROCEDURE pwuf\n+  END INTERFACE\n+  INTERFACE READ(UNFORMATTED)\n+    MODULE PROCEDURE pruf\n+  END INTERFACE\n+\n+CONTAINS\n+\n+  SUBROUTINE pwuf (dtv,unit,iostat,iomsg)\n+    type(person), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    WRITE (UNIT=UNIT) DTV%id_no, DTV%age\n+  END SUBROUTINE pwuf\n+\n+  SUBROUTINE pruf (dtv,unit,iostat,iomsg)\n+    type(person), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg\n+    READ (UNIT = UNIT) dtv%id_no, dtv%age\n+  END SUBROUTINE pruf\n+\n+END MODULE p\n+\n+PROGRAM test\n+  USE p\n+  TYPE (person) :: chairman\n+  CHARACTER (kind=c_char) :: cname(20)\n+  integer (c_int) :: cage, cid_no\n+  character(10) :: line\n+\n+  cid_no = 1\n+  cage = 62\n+  chairman%id_no = cid_no\n+  chairman%age = cage\n+\n+  OPEN (UNIT=71, status = 'scratch', FORM='UNFORMATTED')\n+  write (71) chairman\n+  rewind (71)\n+\n+  chairman%id_no = 0\n+  chairman%age = 0\n+\n+  read (71) chairman\n+  close (unit = 71)\n+\n+  write(line, \"(I4)\") chairman%id_no\n+  if (trim (line) .ne. \"   1\") call abort\n+  write(line, \"(I4)\") chairman%age\n+  if (trim (line) .ne. \"  62\") call abort\n+end program"}, {"sha": "394f7d35e7b01d90f75d765e8ccc96d5b3cecb86", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -1,3 +1,51 @@\n+2016-08-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\tPaul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR libgfortran/48298\n+\t* gfortran.map : Flag _st_set_nml_dtio_var and\n+\t_gfortran_transfer_derived.\n+\t* io/format.c (format_lex): Detect DTIO formatting.\n+\t(parse_format_list): Parse the DTIO format.\n+\t(next_format): Include FMT_DT.\n+\t* io/format.h : Likewise. Add structure 'udf' to structure\n+\t'fnode' to carry the IOTYPE string and the 'vlist'.\n+\t* io/io.h : Add prototypes for the two types of DTIO subroutine\n+\tand a typedef for gfc_class. Also, add to 'namelist_type'\n+\tfields for the pointer to the DTIO procedure and the vtable.\n+\tAdd fields to struct st_parameter_dt for pointers to the two\n+\ttypes of DTIO subroutine. Add to gfc_unit DTIO specific fields.\n+\t(internal_proto): Add prototype for 'read_user_defined' and\n+\t'write_user_defined'.\n+\t* io/list_read.c (check_buffers): Use the 'current_unit' field.\n+\t(unget_char): Likewise.\n+\t(eat_spaces): Likewise.\n+\t(list_formatted_read_scalar): For case BT_CLASS, call the DTIO\n+\tprocedure.\n+\t(nml_get_obj_data): Likewise when DTIO procedure is present,.\n+\t* io/transfer.c : Export prototypes for 'transfer_derived' and\n+\t'transfer_derived_write'.\n+\t(unformatted_read): For case BT_CLASS, call the DTIO procedure.\n+\t(unformatted_write): Likewise.\n+\t(formatted_transfer_scalar_read): Likewise.\n+\t(formatted_transfer_scalar_write: Likewise.\n+\t(transfer_derived): New function.\n+\t(data_transfer_init): Set last_char if no child_dtio.\n+\t(finalize_transfer): Return if child_dtio set.\n+\t(st_write_done): Add condition for child_dtio not set.\n+\tAdd extra arguments for st_set_nml_var prototype.\n+\t(set_nml_var): New function that contains the contents of the\n+\told version of st_set_nml_var. Also sets the 'dtio_sub' and\n+\t'vtable' fields of the 'nml' structure.\n+\t(st_set_nml_var): Now just calls set_nml_var with 'dtio_sub'\n+\tand 'vtable' NULL.\n+\t(st_set_nml_dtio_var): New function that calls set_nml_var.\n+\t* io/unit.c (get_external_unit): If the found unit child_dtio\n+\tis non zero, don't do any mutex locking/unlocking.  Just\n+\treturn the unit.\n+\t* io/unix.c (tempfile_open): Revert to C style comment.\n+\t* io/write.c (list_formatted_write_scalar): Do the DTIO call.\n+\t(nml_write_obj): Add BT_CLASS and do the DTIO call.\n+\n 2016-08-29  Nathan Sidwell  <nathan@acm.org>\n \n \t* configure.ac (nvptx-*): Hardwire newlib.\n@@ -120,7 +168,7 @@\n \t(read_character): Remove condition testing c = '!' which is now inside\n \tthe is_separator macro. (parse_real): Reject '!' unless in namelist mode.\n \t(read_complex): Reject '!' unless in namelist mode. (read_real): Likewise\n-\treject '!'. \n+\treject '!'.\n \n 2016-02-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n "}, {"sha": "ba01f254c806d1c397e8f1285f72144b46ce9310", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -1091,20 +1091,20 @@ GFORTRAN_1.1 {\n     _gfortran_transpose_char4;\n     _gfortran_unpack0_char4;\n     _gfortran_unpack1_char4;\n-} GFORTRAN_1.0; \n+} GFORTRAN_1.0;\n \n \n GFORTRAN_1.2 {\n   global:\n     _gfortran_clz128;\n     _gfortran_ctz128;\n     _gfortran_is_extension_of;\n-} GFORTRAN_1.1; \n+} GFORTRAN_1.1;\n \n GFORTRAN_1.3 {\n   global:\n     _gfortran_error_stop_string;\n-} GFORTRAN_1.2; \n+} GFORTRAN_1.2;\n \n GFORTRAN_1.4 {\n   global:\n@@ -1187,13 +1187,13 @@ GFORTRAN_1.4 {\n     _gfortran_cshift0_16_char4;\n     _gfortran_eoshift0_16_char4;\n     _gfortran_eoshift2_16_char4;\n-} GFORTRAN_1.3; \n+} GFORTRAN_1.3;\n \n GFORTRAN_1.5 {\n   global:\n     _gfortran_ftell2;\n     _gfortran_backtrace;\n-} GFORTRAN_1.4; \n+} GFORTRAN_1.4;\n \n GFORTRAN_1.6 {\n   global:\n@@ -1274,7 +1274,7 @@ GFORTRAN_1.6 {\n     __ieee_exceptions_MOD_ieee_support_flag_noarg;\n     __ieee_exceptions_MOD_ieee_support_halting;\n     __ieee_exceptions_MOD_ieee_usual;\n-} GFORTRAN_1.5; \n+} GFORTRAN_1.5;\n \n GFORTRAN_1.7 {\n   global:\n@@ -1287,7 +1287,13 @@ GFORTRAN_1.7 {\n     _gfortran_mvbits_i16;\n     _gfortran_shape_1;\n     _gfortran_shape_2;\n-} GFORTRAN_1.6; \n+} GFORTRAN_1.6;\n+\n+GFORTRAN_1.8 {\n+  global:\n+    _gfortran_st_set_nml_dtio_var;\n+    _gfortran_transfer_derived;\n+} GFORTRAN_1.7;\n \n F2C_1.0 {\n   global:"}, {"sha": "31bc642910a9dbdfa44d4d5ecb64f33faea38f8a", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 79, "deletions": 8, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -70,7 +70,7 @@ free_format_hash_table (gfc_unit *u)\n \t  free (u->format_hash_table[i].key);\n \t}\n       u->format_hash_table[i].key = NULL;\n-      u->format_hash_table[i].key_len = 0;      \n+      u->format_hash_table[i].key_len = 0;\n       u->format_hash_table[i].hashed_fmt = NULL;\n     }\n }\n@@ -84,7 +84,7 @@ reset_node (fnode *fn)\n \n   fn->count = 0;\n   fn->current = NULL;\n-  \n+\n   if (fn->format != FMT_LPAREN)\n     return;\n \n@@ -261,11 +261,20 @@ void\n free_format_data (format_data *fmt)\n {\n   fnode_array *fa, *fa_next;\n-\n+  fnode *fnp;\n \n   if (fmt == NULL)\n     return;\n \n+  /* Free vlist descriptors in the fnode_array if one was allocated.  */\n+  for (fnp = fmt->array.array; fnp->format != FMT_NONE; fnp++)\n+    if (fnp->format == FMT_DT)\n+\t{\n+\t  if (GFC_DESCRIPTOR_DATA(fnp->u.udf.vlist))\n+\t    free (GFC_DESCRIPTOR_DATA(fnp->u.udf.vlist));\n+\t  free (fnp->u.udf.vlist);\n+\t}\n+\n   for (fa = fmt->array.next; fa; fa = fa_next)\n     {\n       fa_next = fa->next;\n@@ -545,6 +554,9 @@ format_lex (format_data *fmt)\n \tcase 'C':\n \t  token = FMT_DC;\n \t  break;\n+\tcase 'T':\n+\t  token = FMT_DT;\n+\t  break;\n \tdefault:\n \t  token = FMT_D;\n \t  unget_char (fmt);\n@@ -740,7 +752,7 @@ parse_format_list (st_parameter_dt *dtp, bool *seen_dd)\n       tail->u.string.length = fmt->value;\n       tail->repeat = 1;\n       goto optional_comma;\n-      \n+\n     case FMT_RC:\n     case FMT_RD:\n     case FMT_RN:\n@@ -806,6 +818,7 @@ parse_format_list (st_parameter_dt *dtp, bool *seen_dd)\n     case FMT_EN:\n     case FMT_ES:\n     case FMT_D:\n+    case FMT_DT:\n     case FMT_L:\n     case FMT_A:\n     case FMT_F:\n@@ -849,6 +862,7 @@ parse_format_list (st_parameter_dt *dtp, bool *seen_dd)\n   /* In this state, t must currently be a data descriptor.  Deal with\n      things that can/must follow the descriptor */\n  data_desc:\n+\n   switch (t)\n     {\n     case FMT_L:\n@@ -997,7 +1011,57 @@ parse_format_list (st_parameter_dt *dtp, bool *seen_dd)\n \t}\n \n       break;\n+    case FMT_DT:\n+      *seen_dd = true;\n+      get_fnode (fmt, &head, &tail, t);\n+      tail->repeat = repeat;\n+\n+      t = format_lex (fmt);\n+\n+      /* Initialize the vlist to a zero size array.  */\n+      tail->u.udf.vlist= xmalloc (sizeof(gfc_array_i4));\n+      GFC_DESCRIPTOR_DATA(tail->u.udf.vlist) = NULL;\n+      GFC_DIMENSION_SET(tail->u.udf.vlist->dim[0],1, 0, 0);\n \n+      if (t == FMT_STRING)\n+        {\n+\t  /* Get pointer to the optional format string.  */\n+\t  tail->u.udf.string = fmt->string;\n+\t  tail->u.udf.string_len = fmt->value;\n+\t  t = format_lex (fmt);\n+\t}\n+      if (t == FMT_LPAREN)\n+        {\n+\t  /* Temporary buffer to hold the vlist values.  */\n+\t  GFC_INTEGER_4 temp[FARRAY_SIZE];\n+\t  int i = 0;\n+\tloop:\n+\t  t = format_lex (fmt);\n+\t  if (t != FMT_POSINT)\n+\t    {\n+\t      fmt->error = posint_required;\n+\t      goto finished;\n+\t    }\n+\t  /* Save the positive integer value.  */\n+\t  temp[i++] = fmt->value;\n+\t  t = format_lex (fmt);\n+\t  if (t == FMT_COMMA)\n+\t    goto loop;\n+\t  if (t == FMT_RPAREN)\n+\t    {\n+\t      /* We have parsed the complete vlist so initialize the\n+\t         array descriptor and save it in the format node.  */\n+\t      gfc_array_i4 *vp = tail->u.udf.vlist;\n+\t      GFC_DESCRIPTOR_DATA(vp) = xmalloc (i * sizeof(GFC_INTEGER_4));\n+\t      GFC_DIMENSION_SET(vp->dim[0],1, i, 1);\n+\t      memcpy (GFC_DESCRIPTOR_DATA(vp), temp, i * sizeof(GFC_INTEGER_4));\n+\t      break;\n+\t    }\n+\t  fmt->error = unexpected_element;\n+\t  goto finished;\n+\t}\n+      fmt->saved_token = t;\n+      break;\n     case FMT_H:\n       if (repeat > fmt->format_string_len)\n \t{\n@@ -1219,9 +1283,12 @@ parse_format (st_parameter_dt *dtp)\n   format_data *fmt;\n   bool format_cache_ok, seen_data_desc = false;\n \n-  /* Don't cache for internal units and set an arbitrary limit on the size of\n-     format strings we will cache.  (Avoids memory issues.)  */\n-  format_cache_ok = !is_internal_unit (dtp);\n+  /* Don't cache for internal units and set an arbitrary limit on the\n+     size of format strings we will cache.  (Avoids memory issues.)\n+     Also, the format_hash_table resides in the current_unit, so\n+     child_dtio procedures would overwrite the parent table  */\n+  format_cache_ok = !is_internal_unit (dtp)\n+\t\t    && (dtp->u.p.current_unit->child_dtio == 0);\n \n   /* Lookup format string to see if it has already been parsed.  */\n   if (format_cache_ok)\n@@ -1257,6 +1324,10 @@ parse_format (st_parameter_dt *dtp)\n   fmt->reversion_ok = 0;\n   fmt->saved_format = NULL;\n \n+  /* Initialize the fnode_array.  */\n+\n+  memset (&(fmt->array), 0, sizeof(fmt->array));\n+\n   /* Allocate the first format node as the root of the tree.  */\n \n   fmt->last = &fmt->array;\n@@ -1392,7 +1463,7 @@ next_format (st_parameter_dt *dtp)\n   if (!fmt->reversion_ok &&\n       (t == FMT_I || t == FMT_B || t == FMT_O || t == FMT_Z || t == FMT_F ||\n        t == FMT_E || t == FMT_EN || t == FMT_ES || t == FMT_G || t == FMT_L ||\n-       t == FMT_A || t == FMT_D))\n+       t == FMT_A || t == FMT_D || t == FMT_DT))\n     fmt->reversion_ok = 1;\n   return f;\n }"}, {"sha": "3a63e53ea460816782cce00a06616cc7ab437f94", "filename": "libgfortran/io/format.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fformat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fformat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.h?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -38,7 +38,7 @@ typedef enum\n   FMT_LPAREN, FMT_RPAREN, FMT_X, FMT_S, FMT_SS, FMT_SP, FMT_STRING,\n   FMT_BADSTRING, FMT_P, FMT_I, FMT_B, FMT_BN, FMT_BZ, FMT_O, FMT_Z, FMT_F,\n   FMT_E, FMT_EN, FMT_ES, FMT_G, FMT_L, FMT_A, FMT_D, FMT_H, FMT_END, FMT_DC,\n-  FMT_DP, FMT_STAR, FMT_RC, FMT_RD, FMT_RN, FMT_RP, FMT_RU, FMT_RZ\n+  FMT_DP, FMT_STAR, FMT_RC, FMT_RD, FMT_RN, FMT_RP, FMT_RU, FMT_RZ, FMT_DT\n }\n format_token;\n \n@@ -74,6 +74,14 @@ struct fnode\n     }\n     integer;\n \n+    struct\n+    {\n+      char *string;\n+      int string_len;\n+      gfc_array_i4 *vlist;\n+    }\n+    udf;  /* User Defined Format.  */\n+\n     int w;\n     int k;\n     int r;"}, {"sha": "ff75741effda84083c09d873e6e3bd3e54440be9", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -94,6 +94,30 @@ typedef struct array_loop_spec\n }\n array_loop_spec;\n \n+/* User defined input/output iomsg length. */\n+\n+#define IOMSG_LEN 256\n+\n+/* Subroutine formatted_dtio (struct, unit, iotype, v_list, iostat,\n+\t\t\t      iomsg, (_iotype), (_iomsg))  */\n+typedef void (*formatted_dtio)(void *, GFC_INTEGER_4 *, char *, gfc_array_i4 *,\n+\t\t\t       GFC_INTEGER_4 *, char *,\n+\t\t\t       gfc_charlen_type, gfc_charlen_type);\n+\n+/* Subroutine unformatted_dtio (struct, unit, iostat, iomsg, (_iomsg))  */\n+typedef void (*unformatted_dtio)(void *, GFC_INTEGER_4 *, GFC_INTEGER_4 *,\n+\t\t\t\t char *, gfc_charlen_type);\n+\n+/* The dtio calls for namelist require a CLASS object to be built.  */\n+typedef struct gfc_class\n+{\n+  void *data;\n+  void *vptr;\n+  index_type len;\n+}\n+gfc_class;\n+\n+\n /* A structure to build a hash table for format data.  */\n \n #define FORMAT_HASH_SIZE 16\n@@ -136,6 +160,12 @@ typedef struct namelist_type\n   /* Address for the start of the object's data.  */\n   void * mem_pos;\n \n+  /* Address of specific DTIO subroutine.  */\n+  void * dtio_sub;\n+\n+  /* Address of vtable if dtio_sub non-null.  */\n+  void * vtable;\n+\n   /* Flag to show that a read is to be attempted for this node.  */\n   int touched;\n \n@@ -462,7 +492,7 @@ typedef struct st_parameter_dt\n \t  /* Used for ungetc() style functionality. Possible values\n \t     are an unsigned char, EOF, or EOF - 1 used to mark the\n \t     field as not valid.  */\n-\t  int last_char;\n+\t  int last_char; /* No longer used, moved to gfc_unit.  */\n \t  char nml_delim;\n \n \t  int repeat_count;\n@@ -484,6 +514,8 @@ typedef struct st_parameter_dt\n \t     largest kind.  */\n \t  char value[32];\n \t  GFC_IO_INT size_used;\n+\t  formatted_dtio fdtio_ptr;\n+\t  unformatted_dtio ufdtio_ptr;\n \t} p;\n       /* This pad size must be equal to the pad_size declared in\n \t trans-io.c (gfc_build_io_library_fndecls).  The above structure\n@@ -607,6 +639,10 @@ typedef struct gfc_unit\n   /* Function pointer, points to list_read worker functions.  */\n   int (*next_char_fn_ptr) (st_parameter_dt *);\n   void (*push_char_fn_ptr) (st_parameter_dt *, int);\n+\n+  /* DTIO Parent/Child procedure, 0 = parent, >0 = child level.  */\n+  int child_dtio;\n+  int last_char;\n }\n gfc_unit;\n \n@@ -728,6 +764,12 @@ internal_proto(read_radix);\n extern void read_decimal (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_decimal);\n \n+extern void read_user_defined (st_parameter_dt *, void *);\n+internal_proto(read_user_defined);\n+\n+extern void read_user_defined (st_parameter_dt *, void *);\n+internal_proto(read_user_defined);\n+\n /* list_read.c */\n \n extern void list_formatted_read (st_parameter_dt *, bt, void *, int, size_t,\n@@ -790,6 +832,12 @@ internal_proto(write_x);\n extern void write_z (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_z);\n \n+extern void write_user_defined (st_parameter_dt *, void *);\n+internal_proto(write_user_defined);\n+\n+extern void write_user_defined (st_parameter_dt *, void *);\n+internal_proto(write_user_defined);\n+\n extern void list_formatted_write (st_parameter_dt *, bt, void *, int, size_t,\n \t\t\t\t  size_t);\n internal_proto(list_formatted_write);"}, {"sha": "a42f12b72692a360741ad21c74bb816e2de5e934", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 93, "deletions": 6, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -84,7 +84,7 @@ push_char_default (st_parameter_dt *dtp, int c)\n \n   if (dtp->u.p.saved_string == NULL)\n     {\n-      // Plain malloc should suffice here, zeroing not needed?\n+      /* Plain malloc should suffice here, zeroing not needed?  */\n       dtp->u.p.saved_string = xcalloc (SCRATCH_SIZE, 1);\n       dtp->u.p.saved_length = SCRATCH_SIZE;\n       dtp->u.p.saved_used = 0;\n@@ -170,11 +170,11 @@ check_buffers (st_parameter_dt *dtp)\n   int c;\n \n   c = '\\0';\n-  if (dtp->u.p.last_char != EOF - 1)\n+  if (dtp->u.p.current_unit->last_char != EOF - 1)\n     {\n       dtp->u.p.at_eol = 0;\n-      c = dtp->u.p.last_char;\n-      dtp->u.p.last_char = EOF - 1;\n+      c = dtp->u.p.current_unit->last_char;\n+      dtp->u.p.current_unit->last_char = EOF - 1;\n       goto done;\n     }\n \n@@ -369,7 +369,7 @@ next_char_utf8 (st_parameter_dt *dtp)\n static void\n unget_char (st_parameter_dt *dtp, int c)\n {\n-  dtp->u.p.last_char = c;\n+  dtp->u.p.current_unit->last_char = c;\n }\n \n \n@@ -385,7 +385,7 @@ eat_spaces (st_parameter_dt *dtp)\n      This is an optimization unique to character arrays with large\n      character lengths (PR38199).  This code eliminates numerous calls\n      to next_character.  */\n-  if (is_array_io (dtp) && (dtp->u.p.last_char == EOF - 1))\n+  if (is_array_io (dtp) && (dtp->u.p.current_unit->last_char == EOF - 1))\n     {\n       gfc_offset offset = stell (dtp->u.p.current_unit->s);\n       gfc_offset i;\n@@ -2167,6 +2167,46 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n       if (dtp->u.p.repeat_count > 0)\n \tmemcpy (dtp->u.p.value, p, size);\n       break;\n+    case BT_CLASS:\n+      {\n+\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t  char iotype[] = \"LISTDIRECTED\";\n+          gfc_charlen_type iotype_len = 12;\n+\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t  char *child_iomsg;\n+\t  gfc_charlen_type child_iomsg_len;\n+\t  int noiostat;\n+\t  int *child_iostat = NULL;\n+\t  gfc_array_i4 vlist;\n+\n+\t  GFC_DESCRIPTOR_DATA(&vlist) = NULL;\n+\t  GFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n+\n+\t  /* Set iostat, intent(out).  */\n+\t  noiostat = 0;\n+\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t  /* Set iomsge, intent(inout).  */\n+\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t    {\n+\t      child_iomsg = dtp->common.iomsg;\n+\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      child_iomsg = tmp_iomsg;\n+\t      child_iomsg_len = IOMSG_LEN;\n+\t    }\n+\n+\t  /* Call the user defined formatted READ procedure.  */\n+\t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.fdtio_ptr (p, &unit, iotype, &vlist,\n+\t\t\t      child_iostat, child_iomsg,\n+\t\t\t      iotype_len, child_iomsg_len);\n+\t  dtp->u.p.current_unit->child_dtio--;\n+      }\n+      break;\n     default:\n       internal_error (&dtp->common, \"Bad type for list read\");\n     }\n@@ -3206,6 +3246,53 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       goto nml_err_ret;\n     }\n+  else if (nl->dtio_sub != NULL)\n+    {\n+      int unit = dtp->u.p.current_unit->unit_number;\n+      char iotype[] = \"NAMELIST\";\n+      gfc_charlen_type iotype_len = 8;\n+      char tmp_iomsg[IOMSG_LEN] = \"\";\n+      char *child_iomsg;\n+      gfc_charlen_type child_iomsg_len;\n+      int noiostat;\n+      int *child_iostat = NULL;\n+      gfc_array_i4 vlist;\n+      gfc_class list_obj;\n+      formatted_dtio dtio_ptr = (formatted_dtio)nl->dtio_sub;\n+\n+      GFC_DESCRIPTOR_DATA(&vlist) = NULL;\n+      GFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n+\n+      list_obj.data = (void *)nl->mem_pos;\n+      list_obj.vptr = nl->vtable;\n+      list_obj.len = 0;\n+\n+      /* Set iostat, intent(out).  */\n+      noiostat = 0;\n+      child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t      dtp->common.iostat : &noiostat;\n+\n+      /* Set iomsg, intent(inout).  */\n+      if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t{\n+\t  child_iomsg = dtp->common.iomsg;\n+\t  child_iomsg_len = dtp->common.iomsg_len;\n+\t}\n+      else\n+\t{\n+\t  child_iomsg = tmp_iomsg;\n+\t  child_iomsg_len = IOMSG_LEN;\n+\t}\n+\n+      /* Call the user defined formatted READ procedure.  */\n+      dtp->u.p.current_unit->child_dtio++;\n+      dtio_ptr ((void *)&list_obj, &unit, iotype, &vlist,\n+\t\tchild_iostat, child_iomsg,\n+\t\tiotype_len, child_iomsg_len);\n+      dtp->u.p.current_unit->child_dtio--;\n+\n+      return true;\n+    }\n \n   /* Get the length, data length, base pointer and rank of the variable.\n      Set the default loop specification first.  */"}, {"sha": "98072d0b889de12823c3f81ea3831a1aeaaa986a", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 353, "deletions": 104, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -57,7 +57,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n       transfer_complex\n       transfer_real128\n       transfer_complex128\n-   \n+\n     and for WRITE\n \n       transfer_integer_write\n@@ -122,6 +122,15 @@ extern void transfer_array_write (st_parameter_dt *, gfc_array_char *, int,\n \t\t\t    gfc_charlen_type);\n export_proto(transfer_array_write);\n \n+/* User defined derived type input/output.  */\n+extern void\n+transfer_derived (st_parameter_dt *dtp, void *dtio_source, void *dtio_proc);\n+export_proto(transfer_derived);\n+\n+extern void\n+transfer_derived_write (st_parameter_dt *dtp, void *dtio_source, void *dtio_proc);\n+export_proto(transfer_derived_write);\n+\n static void us_read (st_parameter_dt *, int);\n static void us_write (st_parameter_dt *, int);\n static void next_record_r_unf (st_parameter_dt *, int);\n@@ -315,7 +324,7 @@ read_sf (st_parameter_dt *dtp, int * length)\n \t     the rest of the I/O statement.  Set the corresponding flag.  */\n \t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n \t    dtp->u.p.eor_condition = 1;\n-\t    \n+\n \t  /* If we encounter a CR, it might be a CRLF.  */\n \t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n@@ -548,15 +557,15 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \n   if (is_stream_io (dtp))\n     {\n-      have_read_record = sread (dtp->u.p.current_unit->s, buf, \n+      have_read_record = sread (dtp->u.p.current_unit->s, buf,\n \t\t\t\tnbytes);\n       if (unlikely (have_read_record < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_read_record; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_read_record;\n \n       if (unlikely ((ssize_t) nbytes != have_read_record))\n \t{\n@@ -590,7 +599,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \t  return;\n \t}\n \n-      if (to_read_record != (ssize_t) nbytes)  \n+      if (to_read_record != (ssize_t) nbytes)\n \t{\n \t  /* Short read, e.g. if we hit EOF.  Apparently, we read\n \t   more than was written to the last record.  */\n@@ -639,7 +648,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \n       dtp->u.p.current_unit->bytes_left_subrecord -= to_read_subrecord;\n \n-      have_read_subrecord = sread (dtp->u.p.current_unit->s, \n+      have_read_subrecord = sread (dtp->u.p.current_unit->s,\n \t\t\t\t   buf + have_read_record, to_read_subrecord);\n       if (unlikely (have_read_subrecord < 0))\n \t{\n@@ -760,7 +769,7 @@ write_block (st_parameter_dt *dtp, int length)\n \t  return NULL;\n \t}\n     }\n-    \n+\n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n     dtp->u.p.size_used += (GFC_IO_INT) length;\n \n@@ -793,7 +802,7 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \t  return false;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written;\n \n       return true;\n     }\n@@ -811,7 +820,7 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (buf == NULL && nbytes == 0)\n \treturn true;\n \n-      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes); \n+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes);\n       if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n@@ -849,15 +858,15 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       dtp->u.p.current_unit->bytes_left_subrecord -=\n \t(gfc_offset) to_write_subrecord;\n \n-      to_write_subrecord = swrite (dtp->u.p.current_unit->s, \n+      to_write_subrecord = swrite (dtp->u.p.current_unit->s,\n \t\t\t\t   buf + have_written, to_write_subrecord);\n       if (unlikely (to_write_subrecord < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return false;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) to_write_subrecord; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) to_write_subrecord;\n       nbytes -= to_write_subrecord;\n       have_written += to_write_subrecord;\n \n@@ -903,7 +912,7 @@ reverse_memcpy (void *dest, const void *src, size_t n)\n static void\n bswap_array (void *dest, const void *src, size_t size, size_t nelems)\n {\n-  const char *ps; \n+  const char *ps;\n   char *pd;\n \n   switch (size)\n@@ -988,6 +997,40 @@ static void\n unformatted_read (st_parameter_dt *dtp, bt type,\n \t\t  void *dest, int kind, size_t size, size_t nelems)\n {\n+  if (type == BT_CLASS)\n+    {\n+\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t  char *child_iomsg;\n+\t  gfc_charlen_type child_iomsg_len;\n+\t  int noiostat;\n+\t  int *child_iostat = NULL;\n+\n+\t  /* Set iostat, intent(out).  */\n+\t  noiostat = 0;\n+\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t  /* Set iomsg, intent(inout).  */\n+\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t    {\n+\t      child_iomsg = dtp->common.iomsg;\n+\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      child_iomsg = tmp_iomsg;\n+\t      child_iomsg_len = IOMSG_LEN;\n+\t    }\n+\n+\t  /* Call the user defined unformatted READ procedure.  */\n+\t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.ufdtio_ptr (dest, &unit, child_iostat, child_iomsg,\n+\t\t\t      child_iomsg_len);\n+\t  dtp->u.p.current_unit->child_dtio--;\n+\t  return;\n+    }\n+\n   if (type == BT_CHARACTER)\n     size *= GFC_SIZE_OF_CHAR_KIND(kind);\n   read_block_direct (dtp, dest, size * nelems);\n@@ -1016,13 +1059,47 @@ unformatted_read (st_parameter_dt *dtp, bt type,\n /* Master function for unformatted writes.  NOTE: For kind=10 the size is 16\n    bytes on 64 bit machines.  The unused bytes are not initialized and never\n    used, which can show an error with memory checking analyzers like\n-   valgrind.  */\n+   valgrind.  We us BT_CLASS to denote a User Defined I/O call.  */\n \n static void\n unformatted_write (st_parameter_dt *dtp, bt type,\n \t\t   void *source, int kind, size_t size, size_t nelems)\n {\n-  if (likely (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE) \n+  if (type == BT_CLASS)\n+    {\n+\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t  char *child_iomsg;\n+\t  gfc_charlen_type child_iomsg_len;\n+\t  int noiostat;\n+\t  int *child_iostat = NULL;\n+\n+\t  /* Set iostat, intent(out).  */\n+\t  noiostat = 0;\n+\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t  /* Set iomsg, intent(inout).  */\n+\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t    {\n+\t      child_iomsg = dtp->common.iomsg;\n+\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      child_iomsg = tmp_iomsg;\n+\t      child_iomsg_len = IOMSG_LEN;\n+\t    }\n+\n+\t  /* Call the user defined unformatted WRITE procedure.  */\n+\t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.ufdtio_ptr (source, &unit, child_iostat, child_iomsg,\n+\t\t\t      child_iomsg_len);\n+\t  dtp->u.p.current_unit->child_dtio--;\n+\t  return;\n+    }\n+\n+  if (likely (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE)\n       || kind == 1)\n     {\n       size_t stride = type == BT_CHARACTER ?\n@@ -1045,13 +1122,13 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n \t  nelems *= size;\n \t  size = kind;\n \t}\n-  \n+\n       /* Break up complex into its constituent reals.  */\n       if (type == BT_COMPLEX)\n \t{\n \t  nelems *= 2;\n \t  size /= 2;\n-\t}      \n+\t}\n \n       /* By now, all complex variables have been split into their\n \t constituent reals.  */\n@@ -1099,6 +1176,9 @@ type_name (bt type)\n     case BT_COMPLEX:\n       p = \"COMPLEX\";\n       break;\n+    case BT_CLASS:\n+      p = \"CLASS or DERIVED\";\n+      break;\n     default:\n       internal_error (NULL, \"type_name(): Bad type\");\n     }\n@@ -1115,7 +1195,7 @@ static void\n write_constant_string (st_parameter_dt *dtp, const fnode *f)\n {\n   char c, delimiter, *p, *q;\n-  int length; \n+  int length;\n \n   length = f->u.string.length;\n   if (length == 0)\n@@ -1124,7 +1204,7 @@ write_constant_string (st_parameter_dt *dtp, const fnode *f)\n   p = write_block (dtp, length);\n   if (p == NULL)\n     return;\n-    \n+\n   q = f->u.string.p;\n   delimiter = q[-1];\n \n@@ -1151,7 +1231,7 @@ require_type (st_parameter_dt *dtp, bt expected, bt actual, const fnode *f)\n     return 0;\n \n   /* Adjust item_count before emitting error message.  */\n-  snprintf (buffer, BUFLEN, \n+  snprintf (buffer, BUFLEN,\n \t    \"Expected %s for item %d in formatted transfer, got %s\",\n \t   type_name (expected), dtp->u.p.item_count - 1, type_name (actual));\n \n@@ -1170,7 +1250,7 @@ require_numeric_type (st_parameter_dt *dtp, bt actual, const fnode *f)\n     return 0;\n \n   /* Adjust item_count before emitting error message.  */\n-  snprintf (buffer, BUFLEN, \n+  snprintf (buffer, BUFLEN,\n \t    \"Expected numeric type for item %d in formatted transfer, got %s\",\n \t    dtp->u.p.item_count - 1, type_name (actual));\n \n@@ -1273,7 +1353,7 @@ formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind\n \n \tcase FMT_O:\n \t  if (n == 0)\n-\t    goto need_read_data; \n+\t    goto need_read_data;\n \t  if (!(compile_options.allow_std & GFC_STD_GNU)\n \t      && require_numeric_type (dtp, type, f))\n \t    return;\n@@ -1322,6 +1402,65 @@ formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind\n \t  read_f (dtp, f, p, kind);\n \t  break;\n \n+\tcase FMT_DT:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_CLASS, type, f))\n+\t    return;\n+\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t  char dt[] = \"DT\";\n+\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t  char *child_iomsg;\n+\t  gfc_charlen_type child_iomsg_len;\n+\t  int noiostat;\n+\t  int *child_iostat = NULL;\n+\t  char *iotype = f->u.udf.string;\n+\t  gfc_charlen_type iotype_len = f->u.udf.string_len;\n+\n+\t  /* Build the iotype string.  */\n+\t  if (iotype_len == 0)\n+\t    {\n+\t      iotype_len = 2;\n+\t      iotype = dt;\n+\t    }\n+\t  else\n+\t    {\n+\t      iotype_len += 2;\n+\t      iotype = xmalloc (iotype_len);\n+\t      iotype[0] = dt[0];\n+\t      iotype[1] = dt[1];\n+\t      memcpy (iotype + 2, f->u.udf.string, f->u.udf.string_len);\n+\t    }\n+\n+\t  /* Set iostat, intent(out).  */\n+\t  noiostat = 0;\n+\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t  /* Set iomsg, intent(inout).  */\n+\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t    {\n+\t      child_iomsg = dtp->common.iomsg;\n+\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      child_iomsg = tmp_iomsg;\n+\t      child_iomsg_len = IOMSG_LEN;\n+\t    }\n+\n+\t  /* Call the user defined formatted READ procedure.  */\n+\t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.fdtio_ptr (p, &unit, iotype, f->u.udf.vlist,\n+\t\t\t      child_iostat, child_iomsg,\n+\t\t\t      iotype_len, child_iomsg_len);\n+\t  dtp->u.p.current_unit->child_dtio--;\n+\n+\t  if (f->u.udf.string_len != 0)\n+\t    free (iotype);\n+\t  /* Note: vlist is freed in free_format_data.  */\n+\t  break;\n+\n \tcase FMT_E:\n \t  if (n == 0)\n \t    goto need_read_data;\n@@ -1438,7 +1577,7 @@ formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind\n \t    }\n \t  if (dtp->u.p.skips < 0)\n \t    {\n-              if (is_internal_unit (dtp))  \n+              if (is_internal_unit (dtp))\n                 sseek (dtp->u.p.current_unit->s, dtp->u.p.skips, SEEK_CUR);\n               else\n                 fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n@@ -1624,13 +1763,14 @@ formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kin\n \n       /* Now discharge T, TR and X movements to the right.  This is delayed\n \t until a data producing format to suppress trailing spaces.  */\n-\t \n+\n       t = f->format;\n       if (dtp->u.p.mode == WRITING && dtp->u.p.skips != 0\n \t&& ((n>0 && (  t == FMT_I  || t == FMT_B  || t == FMT_O\n \t\t    || t == FMT_Z  || t == FMT_F  || t == FMT_E\n \t\t    || t == FMT_EN || t == FMT_ES || t == FMT_G\n-\t\t    || t == FMT_L  || t == FMT_A  || t == FMT_D))\n+\t\t    || t == FMT_L  || t == FMT_A  || t == FMT_D\n+\t\t    || t == FMT_DT))\n \t    || t == FMT_STRING))\n \t{\n \t  if (dtp->u.p.skips > 0)\n@@ -1639,13 +1779,13 @@ formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kin\n \t      write_x (dtp, dtp->u.p.skips, dtp->u.p.pending_spaces);\n \t      tmp = (int)(dtp->u.p.current_unit->recl\n \t\t\t  - dtp->u.p.current_unit->bytes_left);\n-\t      dtp->u.p.max_pos = \n+\t      dtp->u.p.max_pos =\n \t\tdtp->u.p.max_pos > tmp ? dtp->u.p.max_pos : tmp;\n \t      dtp->u.p.skips = 0;\n \t    }\n \t  if (dtp->u.p.skips < 0)\n \t    {\n-              if (is_internal_unit (dtp))  \n+              if (is_internal_unit (dtp))\n \t        sseek (dtp->u.p.current_unit->s, dtp->u.p.skips, SEEK_CUR);\n               else\n                 fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n@@ -1684,7 +1824,7 @@ formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kin\n \n \tcase FMT_O:\n \t  if (n == 0)\n-\t    goto need_data; \n+\t    goto need_data;\n \t  if (!(compile_options.allow_std & GFC_STD_GNU)\n \t      && require_numeric_type (dtp, type, f))\n \t    return;\n@@ -1733,6 +1873,63 @@ formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kin\n \t  write_d (dtp, f, p, kind);\n \t  break;\n \n+\tcase FMT_DT:\n+\t  if (n == 0)\n+\t    goto need_data;\n+\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t  char dt[] = \"DT\";\n+\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t  char *child_iomsg;\n+\t  gfc_charlen_type child_iomsg_len;\n+\t  int noiostat;\n+\t  int *child_iostat = NULL;\n+\t  char *iotype = f->u.udf.string;\n+\t  gfc_charlen_type iotype_len = f->u.udf.string_len;\n+\n+\t  /* Build the iotype string.  */\n+\t  if (iotype_len == 0)\n+\t    {\n+\t      iotype_len = 2;\n+\t      iotype = dt;\n+\t    }\n+\t  else\n+\t    {\n+\t      iotype_len += 2;\n+\t      iotype = xmalloc (iotype_len);\n+\t      iotype[0] = dt[0];\n+\t      iotype[1] = dt[1];\n+\t      memcpy (iotype + 2, f->u.udf.string, f->u.udf.string_len);\n+\t    }\n+\n+\t  /* Set iostat, intent(out).  */\n+\t  noiostat = 0;\n+\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t  /* Set iomsg, intent(inout).  */\n+\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t    {\n+\t      child_iomsg = dtp->common.iomsg;\n+\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      child_iomsg = tmp_iomsg;\n+\t      child_iomsg_len = IOMSG_LEN;\n+\t    }\n+\n+\t  /* Call the user defined formatted WRITE procedure.  */\n+\t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.fdtio_ptr (p, &unit, iotype, f->u.udf.vlist,\n+\t\t\t      child_iostat, child_iomsg,\n+\t\t\t      iotype_len, child_iomsg_len);\n+\t  dtp->u.p.current_unit->child_dtio--;\n+\n+\t  if (f->u.udf.string_len != 0)\n+\t    free (iotype);\n+\t  /* Note: vlist is freed in free_format_data.  */\n+\t  break;\n+\n \tcase FMT_E:\n \t  if (n == 0)\n \t    goto need_data;\n@@ -2198,6 +2395,25 @@ transfer_array_write (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n   transfer_array (dtp, desc, kind, charlen);\n }\n \n+\n+/* User defined input/output iomsg. */\n+\n+#define IOMSG_LEN 256\n+\n+void\n+transfer_derived (st_parameter_dt *parent, void *dtio_source, void *dtio_proc)\n+{\n+  if (parent->u.p.current_unit)\n+    {\n+      if (parent->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tparent->u.p.ufdtio_ptr = (unformatted_dtio) dtio_proc;\n+      else\n+\tparent->u.p.fdtio_ptr = (formatted_dtio) dtio_proc;\n+    }\n+  parent->u.p.transfer (parent, BT_CLASS, dtio_source, 0, 0, 1);\n+}\n+\n+\n /* Preposition a sequential unformatted file while reading.  */\n \n static void\n@@ -2340,7 +2556,7 @@ pre_position (st_parameter_dt *dtp)\n \t was specified, we continue from where we last left off.  I.e.\n \t there is nothing to do here.  */\n       break;\n-    \n+\n     case UNFORMATTED_SEQUENTIAL:\n       if (dtp->u.p.mode == READING)\n \tus_read (dtp, 0);\n@@ -2384,6 +2600,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     dtp->u.p.size_used = 0;  /* Initialize the count.  */\n \n   dtp->u.p.current_unit = get_unit (dtp, 1);\n+\n   if (dtp->u.p.current_unit->s == NULL)\n     {  /* Open the unit with some default flags.  */\n        st_parameter_open opp;\n@@ -2431,15 +2648,15 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \tcase GFC_CONVERT_NATIVE:\n \tcase GFC_CONVERT_SWAP:\n \t  break;\n-\t \n+\n \tcase GFC_CONVERT_BIG:\n \t  conv = big_endian ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n \t  break;\n-      \n+\n \tcase GFC_CONVERT_LITTLE:\n \t  conv = big_endian ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n \t  break;\n-\t \n+\n \tdefault:\n \t  internal_error (&opp.common, \"Illegal value for CONVERT\");\n \t  break;\n@@ -2542,7 +2759,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t\t\t\"EOF marker, possibly use REWIND or BACKSPACE\");\n \t  return;\n \t}\n-\n     }\n   /* Process the ADVANCE option.  */\n \n@@ -2589,7 +2805,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  return;\n \t}\n \n-      if ((cf & IOPARM_DT_HAS_SIZE) != 0 \n+      if ((cf & IOPARM_DT_HAS_SIZE) != 0\n \t  && dtp->u.p.advance_status != ADVANCE_NO)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_MISSING_OPTION,\n@@ -2653,7 +2869,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t= !(cf & IOPARM_DT_HAS_SIGN) ? SIGN_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->sign, dtp->sign_len, sign_opt,\n \t\t\t\"Bad SIGN parameter in data transfer statement\");\n-  \n+\n   if (dtp->u.p.sign_status == SIGN_UNSPECIFIED)\n \tdtp->u.p.sign_status = dtp->u.p.current_unit->flags.sign;\n \n@@ -2663,7 +2879,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  find_option (&dtp->common, dtp->blank, dtp->blank_len,\n \t\t\tblank_opt,\n \t\t\t\"Bad BLANK parameter in data transfer statement\");\n-  \n+\n   if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n \tdtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n \n@@ -2703,36 +2919,36 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   /* Check the POS= specifier: that it is in range and that it is used with a\n      unit that has been connected for STREAM access. F2003 9.5.1.10.  */\n-  \n+\n   if (((cf & IOPARM_DT_HAS_POS) != 0))\n     {\n       if (is_stream_io (dtp))\n         {\n-          \n+\n           if (dtp->pos <= 0)\n             {\n               generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n                               \"POS=specifier must be positive\");\n               return;\n             }\n-          \n+\n           if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n             {\n               generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n                               \"POS=specifier too large\");\n               return;\n             }\n-          \n+\n           dtp->rec = dtp->pos;\n-          \n+\n           if (dtp->u.p.mode == READING)\n             {\n               /* Reset the endfile flag; if we hit EOF during reading\n                  we'll set the flag and generate an error at that point\n                  rather than worrying about it here.  */\n               dtp->u.p.current_unit->endfile = NO_ENDFILE;\n             }\n-         \n+\n           if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n             {\n               fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n@@ -2752,7 +2968,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n           return;\n         }\n     }\n-  \n+\n \n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n@@ -2789,11 +3005,11 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n       /* Position the file.  */\n       if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n-                 * dtp->u.p.current_unit->recl, SEEK_SET) < 0)\n-        {\n-          generate_error (&dtp->common, LIBERROR_OS, NULL);\n-          return;\n-        }\n+\t\t * dtp->u.p.current_unit->recl, SEEK_SET) < 0)\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  return;\n+\t}\n \n       /* TODO: This is required to maintain compatibility between\n          4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n@@ -2822,7 +3038,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   dtp->u.p.max_pos = dtp->u.p.current_unit->saved_pos;\n \n   pre_position (dtp);\n-  \n+\n \n   /* Set up the subroutine that will handle the transfers.  */\n \n@@ -2834,8 +3050,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t{\n \t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n \t    {\n-\t        dtp->u.p.last_char = EOF - 1;\n-\t\tdtp->u.p.transfer = list_formatted_read;\n+\t      if (dtp->u.p.current_unit->child_dtio  == 0)\n+\t        dtp->u.p.current_unit->last_char = EOF - 1;\n+\t      dtp->u.p.transfer = list_formatted_read;\n \t    }\n \t  else\n \t    dtp->u.p.transfer = formatted_transfer;\n@@ -2896,14 +3113,14 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n    returns the index of the last element of the array, and also returns\n    starting record, where the first I/O goes to (necessary in case of\n    negative strides).  */\n-   \n+\n gfc_offset\n init_loop_spec (gfc_array_char *desc, array_loop_spec *ls,\n \t\tgfc_offset *start_record)\n {\n   int rank = GFC_DESCRIPTOR_RANK(desc);\n   int i;\n-  gfc_offset index; \n+  gfc_offset index;\n   int empty;\n \n   empty = 0;\n@@ -2916,7 +3133,7 @@ init_loop_spec (gfc_array_char *desc, array_loop_spec *ls,\n       ls[i].start = GFC_DESCRIPTOR_LBOUND(desc,i);\n       ls[i].end = GFC_DESCRIPTOR_UBOUND(desc,i);\n       ls[i].step = GFC_DESCRIPTOR_STRIDE(desc,i);\n-      empty = empty || (GFC_DESCRIPTOR_UBOUND(desc,i) \n+      empty = empty || (GFC_DESCRIPTOR_UBOUND(desc,i)\n \t\t\t< GFC_DESCRIPTOR_LBOUND(desc,i));\n \n       if (GFC_DESCRIPTOR_STRIDE(desc,i) > 0)\n@@ -2941,13 +3158,13 @@ init_loop_spec (gfc_array_char *desc, array_loop_spec *ls,\n \n /* Determine the index to the next record in an internal unit array by\n    by incrementing through the array_loop_spec.  */\n-   \n+\n gfc_offset\n next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n {\n   int i, carry;\n   gfc_offset index;\n-  \n+\n   carry = 1;\n   index = 0;\n \n@@ -2992,13 +3209,13 @@ skip_record (st_parameter_dt *dtp, ssize_t bytes)\n \n   /* Direct access files do not generate END conditions,\n      only I/O errors.  */\n-  if (sseek (dtp->u.p.current_unit->s, \n+  if (sseek (dtp->u.p.current_unit->s,\n \t     dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)\n     {\n       /* Seeking failed, fall back to seeking by reading data.  */\n       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n \t{\n-\t  rlength = \n+\t  rlength =\n \t    (MAX_READ < dtp->u.p.current_unit->bytes_left_subrecord) ?\n \t    MAX_READ : dtp->u.p.current_unit->bytes_left_subrecord;\n \n@@ -3066,7 +3283,7 @@ next_record_r (st_parameter_dt *dtp, int done)\n     /* No records in unformatted STREAM I/O.  */\n     case UNFORMATTED_STREAM:\n       return;\n-    \n+\n     case UNFORMATTED_SEQUENTIAL:\n       next_record_r_unf (dtp, 1);\n       dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n@@ -3107,30 +3324,30 @@ next_record_r (st_parameter_dt *dtp, int done)\n \t\t}\n \t      dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t    }\n-\t  else  \n+\t  else\n \t    {\n \t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n-\t      bytes_left = min_off (bytes_left, \n+\t      bytes_left = min_off (bytes_left,\n \t\t      ssize (dtp->u.p.current_unit->s)\n \t\t      - stell (dtp->u.p.current_unit->s));\n-\t      if (sseek (dtp->u.p.current_unit->s, \n+\t      if (sseek (dtp->u.p.current_unit->s,\n \t\t\t bytes_left, SEEK_CUR) < 0)\n \t        {\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n \t\t}\n \t      dtp->u.p.current_unit->bytes_left\n \t\t= dtp->u.p.current_unit->recl;\n-\t    } \n+\t    }\n \t  break;\n \t}\n-      else \n+      else\n \t{\n \t  do\n \t    {\n               errno = 0;\n               cc = fbuf_getc (dtp->u.p.current_unit);\n-\t      if (cc == EOF) \n+\t      if (cc == EOF)\n \t\t{\n                   if (errno != 0)\n                     generate_error (&dtp->common, LIBERROR_OS, NULL);\n@@ -3144,10 +3361,10 @@ next_record_r (st_parameter_dt *dtp, int done)\n \t\t    }\n \t\t  break;\n                 }\n-\t      \n+\n \t      if (is_stream_io (dtp))\n \t\tdtp->u.p.current_unit->strm_pos++;\n-              \n+\n               p = (char) cc;\n \t    }\n \t  while (p != '\\n');\n@@ -3240,7 +3457,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Seek to the head and overwrite the bogus length with the real\n      length.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, - m - record_marker, \n+  if (unlikely (sseek (dtp->u.p.current_unit->s, - m - record_marker,\n \t\t       SEEK_CUR) < 0))\n     goto io_error;\n \n@@ -3301,7 +3518,7 @@ sset (stream * s, int c, ssize_t nbyte)\n \treturn trans;\n       bytes_left -= trans;\n     }\n-\t       \n+\n   return nbyte - bytes_left;\n }\n \n@@ -3330,8 +3547,8 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n       fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n       fbuf_flush (dtp->u.p.current_unit, WRITING);\n-      if (sset (dtp->u.p.current_unit->s, ' ', \n-\t\tdtp->u.p.current_unit->bytes_left) \n+      if (sset (dtp->u.p.current_unit->s, ' ',\n+\t\tdtp->u.p.current_unit->bytes_left)\n \t  != dtp->u.p.current_unit->bytes_left)\n \tgoto io_error;\n \n@@ -3362,7 +3579,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t      int finished;\n \n \t      length = (int) dtp->u.p.current_unit->bytes_left;\n-\t      \n+\n \t      /* If the farthest position reached is greater than current\n \t      position, adjust the position and set length to pad out\n \t      whats left.  Otherwise just pad whats left.\n@@ -3372,7 +3589,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t      if (max_pos > m)\n \t\t{\n \t\t  length = (int) (max_pos - m);\n-\t\t  if (sseek (dtp->u.p.current_unit->s, \n+\t\t  if (sseek (dtp->u.p.current_unit->s,\n \t\t\t     length, SEEK_CUR) < 0)\n \t\t    {\n \t\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n@@ -3399,7 +3616,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t\t\t\t  &finished);\n \t      if (finished)\n \t\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      \n+\n \t      /* Now seek to this record */\n \t      record = record * dtp->u.p.current_unit->recl;\n \n@@ -3425,7 +3642,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t  if (max_pos > m)\n \t\t    {\n \t\t      length = (int) (max_pos - m);\n-\t\t      if (sseek (dtp->u.p.current_unit->s, \n+\t\t      if (sseek (dtp->u.p.current_unit->s,\n \t\t\t\t length, SEEK_CUR) < 0)\n \t\t        {\n \t\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n@@ -3540,6 +3757,18 @@ finalize_transfer (st_parameter_dt *dtp)\n {\n   GFC_INTEGER_4 cf = dtp->common.flags;\n \n+  if ((dtp->u.p.ionml != NULL)\n+      && (cf & IOPARM_DT_HAS_NAMELIST_NAME) != 0)\n+    {\n+       if ((cf & IOPARM_DT_NAMELIST_READ_MODE) != 0)\n+\t namelist_read (dtp);\n+       else\n+\t namelist_write (dtp);\n+    }\n+\n+  if (dtp->u.p.current_unit && (dtp->u.p.current_unit->child_dtio  > 0))\n+    return;\n+\n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n     *dtp->size = dtp->u.p.size_used;\n \n@@ -3556,15 +3785,6 @@ finalize_transfer (st_parameter_dt *dtp)\n       goto done;\n     }\n \n-  if ((dtp->u.p.ionml != NULL)\n-      && (cf & IOPARM_DT_HAS_NAMELIST_NAME) != 0)\n-    {\n-       if ((cf & IOPARM_DT_NAMELIST_READ_MODE) != 0)\n-\t namelist_read (dtp);\n-       else\n-\t namelist_write (dtp);\n-    }\n-\n   dtp->u.p.transfer = NULL;\n   if (dtp->u.p.current_unit == NULL)\n     goto done;\n@@ -3607,7 +3827,7 @@ finalize_transfer (st_parameter_dt *dtp)\n \t  write_x (dtp, dtp->u.p.skips, dtp->u.p.pending_spaces);\n \t  tmp = (int)(dtp->u.p.current_unit->recl\n \t\t      - dtp->u.p.current_unit->bytes_left);\n-\t  dtp->u.p.max_pos = \n+\t  dtp->u.p.max_pos =\n \t    dtp->u.p.max_pos > tmp ? dtp->u.p.max_pos : tmp;\n \t  dtp->u.p.skips = 0;\n \t}\n@@ -3618,9 +3838,9 @@ finalize_transfer (st_parameter_dt *dtp)\n       fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n       goto done;\n     }\n-  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED \n+  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED\n            && dtp->u.p.mode == WRITING && !is_internal_unit (dtp))\n-      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);    \n+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n \n   dtp->u.p.current_unit->saved_pos = 0;\n \n@@ -3648,9 +3868,9 @@ finalize_transfer (st_parameter_dt *dtp)\n    data transfer, it just updates the length counter.  */\n \n static void\n-iolength_transfer (st_parameter_dt *dtp, bt type __attribute__((unused)), \n+iolength_transfer (st_parameter_dt *dtp, bt type __attribute__((unused)),\n \t\t   void *dest __attribute__ ((unused)),\n-\t\t   int kind __attribute__((unused)), \n+\t\t   int kind __attribute__((unused)),\n \t\t   size_t size, size_t nelems)\n {\n   if ((dtp->common.flags & IOPARM_DT_HAS_IOLENGTH) != 0)\n@@ -3722,7 +3942,7 @@ void\n st_read_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n-  \n+\n   if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n     {\n       free_format_data (dtp->u.p.fmt);\n@@ -3735,7 +3955,7 @@ st_read_done (st_parameter_dt *dtp)\n     unlock_unit (dtp->u.p.current_unit);\n \n   free_internal_unit (dtp);\n-  \n+\n   library_end ();\n }\n \n@@ -3759,8 +3979,9 @@ st_write_done (st_parameter_dt *dtp)\n \n   /* Deal with endfile conditions associated with sequential files.  */\n \n-  if (dtp->u.p.current_unit != NULL \n-      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+  if (dtp->u.p.current_unit != NULL\n+      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n+      && dtp->u.p.current_unit->child_dtio == 0)\n     switch (dtp->u.p.current_unit->endfile)\n       {\n       case AT_ENDFILE:\t\t/* Remain at the endfile record.  */\n@@ -3773,7 +3994,7 @@ st_write_done (st_parameter_dt *dtp)\n       case NO_ENDFILE:\n \t/* Get rid of whatever is after this record.  */\n         if (!is_internal_unit (dtp))\n-          unit_truncate (dtp->u.p.current_unit, \n+          unit_truncate (dtp->u.p.current_unit,\n                          stell (dtp->u.p.current_unit->s),\n                          &dtp->common);\n \tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n@@ -3790,7 +4011,7 @@ st_write_done (st_parameter_dt *dtp)\n \n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n-  \n+\n   free_internal_unit (dtp);\n \n   library_end ();\n@@ -3807,15 +4028,10 @@ st_wait (st_parameter_wait *wtp __attribute__((unused)))\n /* Receives the scalar information for namelist objects and stores it\n    in a linked list of namelist_info types.  */\n \n-extern void st_set_nml_var (st_parameter_dt *dtp, void *, char *,\n-\t\t\t    GFC_INTEGER_4, gfc_charlen_type, GFC_INTEGER_4);\n-export_proto(st_set_nml_var);\n-\n-\n-void\n-st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n-\t\tGFC_INTEGER_4 len, gfc_charlen_type string_length,\n-\t\tGFC_INTEGER_4 dtype)\n+static void\n+set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+\t     GFC_INTEGER_4 len, gfc_charlen_type string_length,\n+\t     GFC_INTEGER_4 dtype, void *dtio_sub, void *vtable)\n {\n   namelist_info *t1 = NULL;\n   namelist_info *nml;\n@@ -3824,6 +4040,8 @@ st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n   nml = (namelist_info*) xmalloc (sizeof (namelist_info));\n \n   nml->mem_pos = var_addr;\n+  nml->dtio_sub = dtio_sub;\n+  nml->vtable = vtable;\n \n   nml->var_name = (char*) xmalloc (var_name_len + 1);\n   memcpy (nml->var_name, var_name, var_name_len);\n@@ -3863,6 +4081,37 @@ st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n     }\n }\n \n+extern void st_set_nml_var (st_parameter_dt *dtp, void *, char *,\n+\t\t\t    GFC_INTEGER_4, gfc_charlen_type, GFC_INTEGER_4);\n+export_proto(st_set_nml_var);\n+\n+void\n+st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+\t\tGFC_INTEGER_4 len, gfc_charlen_type string_length,\n+\t\tGFC_INTEGER_4 dtype)\n+{\n+  set_nml_var (dtp, var_addr, var_name, len, string_length,\n+\t       dtype, NULL, NULL);\n+}\n+\n+\n+/* Essentially the same as previous but carrying the dtio procedure\n+   and the vtable as additional arguments.  */\n+extern void st_set_nml_dtio_var (st_parameter_dt *dtp, void *, char *,\n+\t\t\t\t GFC_INTEGER_4, gfc_charlen_type, GFC_INTEGER_4,\n+\t\t\t\t void *, void *);\n+export_proto(st_set_nml_dtio_var);\n+\n+\n+void\n+st_set_nml_dtio_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+\t\t     GFC_INTEGER_4 len, gfc_charlen_type string_length,\n+\t\t     GFC_INTEGER_4 dtype, void *dtio_sub, void *vtable)\n+{\n+  set_nml_var (dtp, var_addr, var_name, len, string_length,\n+\t       dtype, dtio_sub, vtable);\n+}\n+\n /* Store the dimensional information for the namelist object.  */\n extern void st_set_nml_var_dim (st_parameter_dt *, GFC_INTEGER_4,\n \t\t\t\tindex_type, index_type,\n@@ -3911,7 +4160,7 @@ hit_eof (st_parameter_dt * dtp)\n         else\n           dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;\n-        \n+\n       case AFTER_ENDFILE:\n \tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n \tdtp->u.p.current_unit->current_record = 0;"}, {"sha": "fde9ac752d42cdc295ee55d173882909d0d76c2d", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -348,7 +348,7 @@ get_external_unit (int n, int do_create)\n     }\n \n found:\n-  if (p != NULL)\n+  if (p != NULL && (p->child_dtio == 0))\n     {\n       /* Fast path.  */\n       if (! __gthread_mutex_trylock (&p->lock))\n@@ -363,7 +363,7 @@ get_external_unit (int n, int do_create)\n \n   __gthread_mutex_unlock (&unit_lock);\n \n-  if (p != NULL)\n+  if (p != NULL && (p->child_dtio == 0))\n     {\n       __gthread_mutex_lock (&p->lock);\n       if (p->closed)\n@@ -464,7 +464,7 @@ get_internal_unit (st_parameter_dt *dtp)\n       else\n \t  len = string_len_trim_char4 (dtp->internal_unit_len,\n \t\t\t      (const gfc_char4_t*) dtp->internal_unit);\n-      dtp->internal_unit_len = len; \n+      dtp->internal_unit_len = len;\n       iunit->recl = dtp->internal_unit_len;\n     }\n \n@@ -524,7 +524,7 @@ get_internal_unit (st_parameter_dt *dtp)\n   dtp->u.p.at_eof = 0;\n \n   /* This flag tells us the unit is assigned to internal I/O.  */\n-  \n+\n   dtp->u.p.unit_is_internal = 1;\n \n   return iunit;\n@@ -544,13 +544,13 @@ free_internal_unit (st_parameter_dt *dtp)\n   if (dtp->u.p.current_unit != NULL)\n     {\n       free (dtp->u.p.current_unit->ls);\n-  \n+\n       free (dtp->u.p.current_unit->s);\n-  \n+\n       destroy_unit_mutex (dtp->u.p.current_unit);\n     }\n }\n-      \n+\n \n \n /* get_unit()-- Returns the unit structure associated with the integer\n@@ -612,14 +612,14 @@ init_units (void)\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n       u->flags.round = ROUND_UNSPECIFIED;\n-     \n+\n       u->recl = options.default_recl;\n       u->endfile = NO_ENDFILE;\n \n       u->filename = strdup (stdin_name);\n \n       fbuf_init (u, 0);\n-    \n+\n       __gthread_mutex_unlock (&u->lock);\n     }\n \n@@ -644,9 +644,9 @@ init_units (void)\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;\n-    \n+\n       u->filename = strdup (stdout_name);\n-      \n+\n       fbuf_init (u, 0);\n \n       __gthread_mutex_unlock (&u->lock);\n@@ -674,7 +674,7 @@ init_units (void)\n       u->endfile = AT_ENDFILE;\n \n       u->filename = strdup (stderr_name);\n-      \n+\n       fbuf_init (u, 256);  /* 256 bytes should be enough, probably not doing\n                               any kind of exotic formatting to stderr.  */\n \n@@ -694,7 +694,7 @@ static int\n close_unit_1 (gfc_unit *u, int locked)\n {\n   int i, rc;\n-  \n+\n   /* If there are previously written bytes from a write with ADVANCE=\"no\"\n      Reposition the buffer before closing.  */\n   if (u->previous_nonadvancing_write)\n@@ -715,7 +715,7 @@ close_unit_1 (gfc_unit *u, int locked)\n   free (u->filename);\n   u->filename = NULL;\n \n-  free_format_hash_table (u);  \n+  free_format_hash_table (u);\n   fbuf_destroy (u);\n \n   if (!locked)\n@@ -788,7 +788,7 @@ unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)\n       else\n \tfbuf_flush (u, u->mode);\n     }\n-  \n+\n   /* struncate() should flush the stream buffer if necessary, so don't\n      bother calling sflush() here.  */\n   ret = struncate (u->s, pos);\n@@ -838,7 +838,7 @@ filename_from_unit (int n)\n void\n finish_last_advance_record (gfc_unit *u)\n {\n-  \n+\n   if (u->saved_pos > 0)\n     fbuf_seek (u, u->saved_pos, SEEK_CUR);\n "}, {"sha": "29818cd7a1401557fb5c697946ba00375e43286b", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -1121,7 +1121,7 @@ tempfile_open (const char *tempdir, char **fname)\n      )\n     slash = \"\";\n \n-  // Take care that the template is longer in the mktemp() branch.\n+  /* Take care that the template is longer in the mktemp() branch.  */\n   char * template = xmalloc (tempdirlen + 23);\n \n #ifdef HAVE_MKSTEMP"}, {"sha": "15f7158dbb764fa11b413b32a53354a852d5a6f7", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 122, "deletions": 36, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d3ca6d1caf9c1187eeb1236dffd42f15ec043/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=e73d3ca6d1caf9c1187eeb1236dffd42f15ec043", "patch": "@@ -44,7 +44,7 @@ static void\n memcpy4 (gfc_char4_t *dest, const char *source, int k)\n {\n   int j;\n-  \n+\n   const char *p = source;\n   for (j = 0; j < k; j++)\n     *dest++ = (gfc_char4_t) *p++;\n@@ -63,7 +63,7 @@ write_default_char4 (st_parameter_dt *dtp, const gfc_char4_t *source,\n   int j, k = 0;\n   gfc_char4_t c;\n   uchar d;\n-      \n+\n   /* Take care of preceding blanks.  */\n   if (w_len > src_len)\n     {\n@@ -153,7 +153,7 @@ write_utf8_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n   static const uchar masks[6] =  { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n   static const uchar limits[6] = { 0x80, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };\n   int nbytes;\n-  uchar buf[6], d, *q; \n+  uchar buf[6], d, *q;\n \n   /* Take care of preceding blanks.  */\n   if (w_len > src_len)\n@@ -273,7 +273,7 @@ write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n \t\t  bytes = 0;\n \t\t}\n \n-\t      /* Write out the CR_LF sequence.  */ \n+\t      /* Write out the CR_LF sequence.  */\n \t      q++;\n \t      p = write_block (dtp, 2);\n               if (p == NULL)\n@@ -381,7 +381,7 @@ write_a_char4 (st_parameter_dt *dtp, const fnode *f, const char *source, int len\n \t\t  bytes = 0;\n \t\t}\n \n-\t      /* Write out the CR_LF sequence.  */ \n+\t      /* Write out the CR_LF sequence.  */\n \t      write_default_char4 (dtp, crlf, 2, 0);\n \t    }\n \t  else\n@@ -528,7 +528,7 @@ write_l (st_parameter_dt *dtp, const fnode *f, char *source, int len)\n   GFC_INTEGER_LARGEST n;\n \n   wlen = (f->format == FMT_G && f->u.w == 0) ? 1 : f->u.w;\n-  \n+\n   p = write_block (dtp, wlen);\n   if (p == NULL)\n     return;\n@@ -694,7 +694,7 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n   if (n < 0)\n     n = -n;\n   nsign = sign == S_NONE ? 0 : 1;\n-  \n+\n   /* conv calls itoa which sets the negative sign needed\n      by write_integer. The sign '+' or '-' is set below based on sign\n      calculated above, so we just point past the sign in the string\n@@ -847,7 +847,7 @@ btoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n {\n   char *q;\n   int i, j;\n-  \n+\n   q = buffer;\n   if (big_endian)\n     {\n@@ -893,7 +893,7 @@ btoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n   if (*n == 0)\n     return \"0\";\n \n-  /* Move past any leading zeros.  */  \n+  /* Move past any leading zeros.  */\n   while (*buffer == '0')\n     buffer++;\n \n@@ -968,7 +968,7 @@ otoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n   if (*n == 0)\n     return \"0\";\n \n-  /* Move past any leading zeros.  */  \n+  /* Move past any leading zeros.  */\n   while (*q == '0')\n     q++;\n \n@@ -986,9 +986,9 @@ ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n   char *q;\n   uint8_t h, l;\n   int i;\n-  \n+\n   q = buffer;\n-  \n+\n   if (big_endian)\n     {\n       const char *p = s;\n@@ -1021,11 +1021,11 @@ ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n     }\n \n   *q = '\\0';\n-  \n+\n   if (*n == 0)\n     return \"0\";\n-    \n-  /* Move past any leading zeros.  */  \n+\n+  /* Move past any leading zeros.  */\n   while (*buffer == '0')\n     buffer++;\n \n@@ -1067,7 +1067,7 @@ write_o (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n   const char *p;\n   char itoa_buf[GFC_OTOA_BUF_SIZE];\n   GFC_UINTEGER_LARGEST n = 0;\n-  \n+\n   if (len > (int) sizeof (GFC_UINTEGER_LARGEST))\n     {\n       p = otoa_big (source, itoa_buf, len, &n);\n@@ -1407,12 +1407,12 @@ write_float_0 (st_parameter_dt *dtp, const fnode *f, const char *source, int kin\n \n   /* Precision for snprintf call.  */\n   int precision = get_precision (dtp, f, source, kind);\n-  \n+\n   /* String buffer to hold final result.  */\n   result = select_string (f, str_buf, &res_len);\n-  \n+\n   buffer = select_buffer (precision, buf_stack, &buf_size);\n-  \n+\n   get_float_string (dtp, f, source , kind, 0, buffer,\n                            precision, buf_size, result, &res_len);\n   write_float_string (dtp, result, res_len);\n@@ -1525,13 +1525,13 @@ write_real (st_parameter_dt *dtp, const char *source, int kind)\n \n   /* Precision for snprintf call.  */\n   int precision = get_precision (dtp, &f, source, kind);\n-  \n+\n   /* String buffer to hold final result.  */\n   result = select_string (&f, str_buf, &res_len);\n \n   /* scratch buffer to hold final result.  */\n   buffer = select_buffer (precision, buf_stack, &buf_size);\n-  \n+\n   get_float_string (dtp, &f, source , kind, 1, buffer,\n                            precision, buf_size, result, &res_len);\n   write_float_string (dtp, result, res_len);\n@@ -1554,7 +1554,7 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int kind, int d)\n   char str_buf[BUF_STACK_SZ];\n   char *buffer, *result;\n   size_t buf_size, res_len;\n-  int comp_d; \n+  int comp_d;\n   set_fnode_default (dtp, &f, kind);\n \n   if (d > 0)\n@@ -1570,7 +1570,7 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int kind, int d)\n \n   /* Precision for snprintf call.  */\n   int precision = get_precision (dtp, &f, source, kind);\n-  \n+\n   /* String buffer to hold final result.  */\n   result = select_string (&f, str_buf, &res_len);\n \n@@ -1608,36 +1608,36 @@ write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)\n \n   dtp->u.p.scale_factor = 1;\n   set_fnode_default (dtp, &f, kind);\n-  \n+\n   /* Set width for two values, parenthesis, and comma.  */\n   width = 2 * f.u.real.w + 3;\n \n   /* Set for no blanks so we get a string result with no leading\n      blanks.  We will pad left later.  */\n   dtp->u.p.g0_no_blanks = 1;\n-  \n+\n   /* Precision for snprintf call.  */\n   int precision = get_precision (dtp, &f, source, kind);\n-  \n+\n   /* String buffers to hold final result.  */\n   result1 = select_string (&f, str1_buf, &res_len1);\n   result2 = select_string (&f, str2_buf, &res_len2);\n \n   buffer = select_buffer (precision, buf_stack, &buf_size);\n-  \n+\n   get_float_string (dtp, &f, source , kind, 0, buffer,\n                            precision, buf_size, result1, &res_len1);\n   get_float_string (dtp, &f, source + size / 2 , kind, 0, buffer,\n                            precision, buf_size, result2, &res_len2);\n   lblanks = width - res_len1 - res_len2 - 3;\n-  \n+\n   write_x (dtp, lblanks, lblanks);\n   write_char (dtp, '(');\n   write_float_string (dtp, result1, res_len1);\n   write_char (dtp, semi_comma);\n   write_float_string (dtp, result2, res_len2);\n   write_char (dtp, ')');\n-  \n+\n   dtp->u.p.scale_factor = orig_scale;\n   dtp->u.p.g0_no_blanks = 0;\n   if (buf_size > BUF_STACK_SZ)\n@@ -1710,6 +1710,46 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n     case BT_COMPLEX:\n       write_complex (dtp, p, kind, size);\n       break;\n+    case BT_CLASS:\n+      {\n+\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t  char iotype[] = \"LISTDIRECTED\";\n+\t  gfc_charlen_type iotype_len = 12;\n+\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t  char *child_iomsg;\n+\t  gfc_charlen_type child_iomsg_len;\n+\t  int noiostat;\n+\t  int *child_iostat = NULL;\n+\t  gfc_array_i4 vlist;\n+\n+\t  GFC_DESCRIPTOR_DATA(&vlist) = NULL;\n+\t  GFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n+\n+\t  /* Set iostat, intent(out).  */\n+\t  noiostat = 0;\n+\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t  /* Set iomsge, intent(inout).  */\n+\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t    {\n+\t      child_iomsg = dtp->common.iomsg;\n+\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      child_iomsg = tmp_iomsg;\n+\t      child_iomsg_len = IOMSG_LEN;\n+\t    }\n+\n+\t  /* Call the user defined formatted WRITE procedure.  */\n+\t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.fdtio_ptr (p, &unit, iotype, &vlist,\n+\t\t\t      child_iostat, child_iomsg,\n+\t\t\t      iotype_len, child_iomsg_len);\n+\t  dtp->u.p.current_unit->child_dtio--;\n+      }\n+      break;\n     default:\n       internal_error (&dtp->common, \"list_formatted_write(): Bad type\");\n     }\n@@ -1844,7 +1884,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   size_t base_name_len;\n   size_t base_var_name_len;\n   size_t tot_len;\n-  \n+\n   /* Set the character to be used to separate values\n      to a comma or semi-colon.  */\n \n@@ -1903,7 +1943,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n       break;\n \n     default:\n-      obj_size = len;      \n+      obj_size = len;\n     }\n \n   if (obj->var_rank)\n@@ -1985,7 +2025,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n               break;\n \n \t    case BT_DERIVED:\n-\n+\t    case BT_CLASS:\n \t      /* To treat a derived type, we need to build two strings:\n \t\t ext_name = the name, including qualifiers that prepends\n \t\t\t    component names in the output - passed to\n@@ -1995,19 +2035,65 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t\t\t    components.  */\n \n \t      /* First ext_name => get length of all possible components  */\n+\t      if (obj->dtio_sub != NULL)\n+\t\t{\n+\t\t  int unit = dtp->u.p.current_unit->unit_number;\n+\t\t  char iotype[] = \"NAMELIST\";\n+\t\t  gfc_charlen_type iotype_len = 8;\n+\t\t  char tmp_iomsg[IOMSG_LEN] = \"\";\n+\t\t  char *child_iomsg;\n+\t\t  gfc_charlen_type child_iomsg_len;\n+\t\t  int noiostat;\n+\t\t  int *child_iostat = NULL;\n+\t\t  gfc_array_i4 vlist;\n+\t\t  gfc_class list_obj;\n+\t\t  formatted_dtio dtio_ptr = (formatted_dtio)obj->dtio_sub;\n+\n+\t\t  GFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n+\n+\t\t  list_obj.data = p;\n+\t\t  list_obj.vptr = obj->vtable;\n+\t\t  list_obj.len = 0;\n+\n+\t\t  /* Set iostat, intent(out).  */\n+\t\t  noiostat = 0;\n+\t\t  child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t\t  dtp->common.iostat : &noiostat;\n+\n+\t\t  /* Set iomsg, intent(inout).  */\n+\t\t  if (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t\t    {\n+\t\t      child_iomsg = dtp->common.iomsg;\n+\t\t      child_iomsg_len = dtp->common.iomsg_len;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      child_iomsg = tmp_iomsg;\n+\t\t      child_iomsg_len = IOMSG_LEN;\n+\t\t    }\n+\t\t  namelist_write_newline (dtp);\n+\t\t  /* Call the user defined formatted WRITE procedure.  */\n+\t\t  dtp->u.p.current_unit->child_dtio++;\n+\t\t  dtio_ptr ((void *)&list_obj, &unit, iotype, &vlist,\n+\t\t\t    child_iostat, child_iomsg,\n+\t\t\t    iotype_len, child_iomsg_len);\n+\t\t  dtp->u.p.current_unit->child_dtio--;\n+\n+\t\t  goto obj_loop;\n+\t\t}\n \n \t      base_name_len = base_name ? strlen (base_name) : 0;\n \t      base_var_name_len = base ? strlen (base->var_name) : 0;\n-\t      ext_name_len = base_name_len + base_var_name_len \n+\t      ext_name_len = base_name_len + base_var_name_len\n \t\t+ strlen (obj->var_name) + obj->var_rank * NML_DIGITS + 1;\n \t      ext_name = xmalloc (ext_name_len);\n \n \t      if (base_name)\n \t\tmemcpy (ext_name, base_name, base_name_len);\n \t      clen = strlen (obj->var_name + base_var_name_len);\n-\t      memcpy (ext_name + base_name_len, \n+\t      memcpy (ext_name + base_name_len,\n \t\t      obj->var_name + base_var_name_len, clen);\n-\t      \n+\n \t      /* Append the qualifier.  */\n \n \t      tot_len = base_name_len + clen;\n@@ -2018,7 +2104,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t\t      ext_name[tot_len] = '(';\n \t\t      tot_len++;\n \t\t    }\n-\t\t  snprintf (ext_name + tot_len, ext_name_len - tot_len, \"%d\", \n+\t\t  snprintf (ext_name + tot_len, ext_name_len - tot_len, \"%d\",\n \t\t\t    (int) obj->ls[dim_i].idx);\n \t\t  tot_len += strlen (ext_name + tot_len);\n \t\t  ext_name[tot_len] = ((int) dim_i == obj->var_rank - 1) ? ')' : ',';"}]}