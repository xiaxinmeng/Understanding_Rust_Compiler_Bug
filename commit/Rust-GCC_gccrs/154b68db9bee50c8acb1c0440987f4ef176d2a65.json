{"sha": "154b68db9bee50c8acb1c0440987f4ef176d2a65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU0YjY4ZGI5YmVlNTBjOGFjYjFjMDQ0MDk4N2Y0ZWYxNzZkMmE2NQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2011-11-10T16:39:32Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2011-11-10T16:39:32Z"}, "message": "re PR rtl-optimization/51040 (ICE: RTL check: access of elt 1 of 'not' with last elt 0 in gen_rtx_fmt_ee_stat, at ./genrtl.h:33 with __atomic_nand_fetch())\n\n\tPR rtl-optimization/51040\n\t* optabs.c (expand_atomic_fetch_op): Patchup code for NAND should be AND\n\tfollowed by NOT.\n\t* builtins.c (expand_builtin_atomic_fetch_op): Patchup code for NAND\n\tshould be AND followed by NOT.\n\t* testsuite/gcc.dg/atomic-noinline[-aux].c: Test no-inline NAND and\n\tpatchup code.\n\nFrom-SVN: r181259", "tree": {"sha": "b11770e605e88e4c894d09421e2b55b78d37b982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b11770e605e88e4c894d09421e2b55b78d37b982"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/154b68db9bee50c8acb1c0440987f4ef176d2a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154b68db9bee50c8acb1c0440987f4ef176d2a65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/154b68db9bee50c8acb1c0440987f4ef176d2a65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154b68db9bee50c8acb1c0440987f4ef176d2a65/comments", "author": null, "committer": null, "parents": [{"sha": "c8bf99b4e84b9b0783aca23ecc85425cb3569f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8bf99b4e84b9b0783aca23ecc85425cb3569f16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8bf99b4e84b9b0783aca23ecc85425cb3569f16"}], "stats": {"total": 56, "additions": 51, "deletions": 5}, "files": [{"sha": "fa7cbeb1bb55a0968ae4c4553457e0a901142f5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=154b68db9bee50c8acb1c0440987f4ef176d2a65", "patch": "@@ -1,3 +1,13 @@\n+2011-11-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR rtl-optimization/51040\n+\t* optabs.c (expand_atomic_fetch_op): Patchup code for NAND should be AND\n+\tfollowed by NOT.\n+\t* builtins.c (expand_builtin_atomic_fetch_op): Patchup code for NAND\n+\tshould be AND followed by NOT.\n+\t* testsuite/gcc.dg/atomic-noinline[-aux].c: Test no-inline NAND and\n+\tpatchup code.\n+\n 2011-11-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* vec.h (VEC_BASE): If base is at offset 0 in the structure,"}, {"sha": "d949dbb632f5ecdfa094691a9a5a107fceeca600", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=154b68db9bee50c8acb1c0440987f4ef176d2a65", "patch": "@@ -5460,8 +5460,17 @@ expand_builtin_atomic_fetch_op (enum machine_mode mode, tree exp, rtx target,\n \n   /* Then issue the arithmetic correction to return the right result.  */\n   if (!ignore)\n-    ret = expand_simple_binop (mode, code, ret, val, NULL_RTX, true,\n-\t\t\t       OPTAB_LIB_WIDEN);\n+    {\n+      if (code == NOT)\n+\t{\n+\t  ret = expand_simple_binop (mode, AND, ret, val, NULL_RTX, true,\n+\t\t\t\t     OPTAB_LIB_WIDEN);\n+\t  ret = expand_simple_unop (mode, NOT, ret, target, true);\n+\t}\n+      else\n+\tret = expand_simple_binop (mode, code, ret, val, target, true,\n+\t\t\t\t   OPTAB_LIB_WIDEN);\n+    }\n   return ret;\n }\n "}, {"sha": "c87f5cd84ad4594e4ad6c43a400dd90437997c72", "filename": "gcc/optabs.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=154b68db9bee50c8acb1c0440987f4ef176d2a65", "patch": "@@ -7875,8 +7875,15 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \t     Fetch_before == after REVERSE_OP val.  */\n \t  if (!after)\n \t    code = optab.reverse_code;\n-\t  result = expand_simple_binop (mode, code, result, val, target, true,\n-\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t  if (code == NOT)\n+\t    {\n+\t      result = expand_simple_binop (mode, AND, result, val, NULL_RTX,\n+\t\t\t\t\t    true, OPTAB_LIB_WIDEN);\n+\t      result = expand_simple_unop (mode, NOT, result, target, true);\n+\t    }\n+\t  else\n+\t    result = expand_simple_binop (mode, code, result, val, target,\n+\t\t\t\t\t  true, OPTAB_LIB_WIDEN);\n \t  return result;\n \t}\n     }"}, {"sha": "b05460e469b92e36b9c7b940ca281e177bffa41e", "filename": "gcc/testsuite/gcc.dg/atomic-noinline-aux.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline-aux.c?ref=154b68db9bee50c8acb1c0440987f4ef176d2a65", "patch": "@@ -40,11 +40,24 @@ char __atomic_fetch_add_1 (char *p, char v, int i)\n   *p = 1;\n }\n \n-short __atomic_fetch_add_2 (short *p, short v, short i)\n+short __atomic_fetch_add_2 (short *p, short v, int i)\n {\n   *p = 1;\n }\n \n+/* Really perform a NAND.  PR51040 showed incorrect calculation of a \n+   non-inlined fetch_nand.  */\n+unsigned char \n+__atomic_fetch_nand_1 (unsigned char *p, unsigned char v, int i)\n+{\n+  unsigned char ret;\n+\n+  ret = *p;\n+  *p = ~(*p & v);\n+\n+  return ret;\n+}\n+\n int __atomic_is_lock_free (int i, void *p)\n {\n   return 10;"}, {"sha": "eb0866e549ef87ff72c8df40ede47098bf7ca006", "filename": "gcc/testsuite/gcc.dg/atomic-noinline.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154b68db9bee50c8acb1c0440987f4ef176d2a65/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-noinline.c?ref=154b68db9bee50c8acb1c0440987f4ef176d2a65", "patch": "@@ -49,6 +49,13 @@ main ()\n   if (__atomic_is_lock_free (4, 0) != 10)\n     abort ();\n    \n+  /* PR 51040 was caused by arithmetic code not patching up nand_fetch properly\n+     when used an an external function.  Look for proper return value here.  */\n+  ac = 0x3C;\n+  bc = __atomic_nand_fetch (&ac, 0x0f, __ATOMIC_RELAXED);\n+  if (bc != ac)\n+    abort ();\n+\n   return 0;\n }\n "}]}