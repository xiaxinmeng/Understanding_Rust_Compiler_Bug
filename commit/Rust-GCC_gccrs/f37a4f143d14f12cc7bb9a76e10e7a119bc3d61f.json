{"sha": "f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3YTRmMTQzZDE0ZjEyY2M3YmI5YTc2ZTEwZTdhMTE5YmMzZDYxZg==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2004-10-18T05:31:28Z"}, "committer": {"name": "Mostafa Hagog", "email": "hagog@gcc.gnu.org", "date": "2004-10-18T05:31:28Z"}, "message": "Makefile.in (loop-unroll.o): Add VARRAY_H dependency.\n\n2004-10-18  Revital Eres  <eres@il.ibm.com>\n\n        * Makefile.in (loop-unroll.o): Add VARRAY_H dependency.\n        * loop-unroll.c: Include varray.h.\n        (struct var_to_expand, struct opt_info): Rename split_ivs_info to\n        opt_info and expand it to support variable expansion.\n        (analyze_insns_in_loop): Rename analyze_ivs_to_split and\n        expand it to support variable expansion.\n        (pt_info_start_duplication): Rename si_info_start_duplication.\n        (apply_opt_in_copies): Rename split_ivs_in_copies and add support\n        to the variable expansion optimization.\n        (free_opt_info): Rename free_si_info.\n        (analyze_insn_to_expand_var, referenced_in_one_insn_in_loop_p,\n        expand_var_during_unrolling, insert_var_expansion_initialization,\n        combine_var_copies_in_loop_exit, release_var_copies,\n        get_expansion): New functions.\n        (peel_loop_completely, unroll_loop_constant_iterations,\n        unroll_loop_runtime_iterations, peel_loop_simple,\n        unroll_loop_stupid): Change uses of struct si_info\n        to struct opt_info\n        and add uses of fvariable-expansion-in-unroller flag.\n        * params.def: Add parameter to restrict the number of expansions.\n        * params.h: (MAX_VARIABLE_EXPANSIONS): New define to restrict\n        the number of expansions.\n        * common.opt: (fvariable-expansion-in-unroller): New flag.\n        * doc/invoke.texi: (fvariable-expansion-in-unroller): Document.\n\nFrom-SVN: r89197", "tree": {"sha": "659451af0eb92e8412fce0e70aaf671611d128e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/659451af0eb92e8412fce0e70aaf671611d128e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "535306d0decc4821b3c4b896d5e7b837428c5160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535306d0decc4821b3c4b896d5e7b837428c5160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535306d0decc4821b3c4b896d5e7b837428c5160"}], "stats": {"total": 812, "additions": 636, "deletions": 176}, "files": [{"sha": "b8d7baed41e54e0feaa7fdf2dea5d1b544303253", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -1,3 +1,30 @@\n+2004-10-18  Revital Eres  <eres@il.ibm.com>\n+\n+\t* Makefile.in (loop-unroll.o): Add VARRAY_H dependency.\n+\t* loop-unroll.c: Include varray.h.\n+\t(struct var_to_expand, struct opt_info): Rename split_ivs_info to\n+\topt_info and expand it to support variable expansion.\n+\t(analyze_insns_in_loop): Rename analyze_ivs_to_split and\n+\texpand it to support variable expansion.\n+\t(pt_info_start_duplication): Rename si_info_start_duplication.\n+\t(apply_opt_in_copies): Rename split_ivs_in_copies and add support\n+\tto the variable expansion optimization.\n+\t(free_opt_info): Rename free_si_info.\n+\t(analyze_insn_to_expand_var, referenced_in_one_insn_in_loop_p,\n+\texpand_var_during_unrolling, insert_var_expansion_initialization,\n+\tcombine_var_copies_in_loop_exit, release_var_copies,\n+\tget_expansion): New functions.\n+\t(peel_loop_completely, unroll_loop_constant_iterations,\n+\tunroll_loop_runtime_iterations, peel_loop_simple,\n+\tunroll_loop_stupid): Change uses of struct si_info\n+\tto struct opt_info\n+\tand add uses of fvariable-expansion-in-unroller flag.\n+\t* params.def: Add parameter to restrict the number of expansions.\n+\t* params.h: (MAX_VARIABLE_EXPANSIONS): New define to restrict\n+\tthe number of expansions.\n+\t* common.opt: (fvariable-expansion-in-unroller): New flag. \n+\t* doc/invoke.texi: (fvariable-expansion-in-unroller): Document.\n+\n 2004-10-18  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* config/i386/cygming.h (TARGET_OS_CPP_BUILTINS): Define"}, {"sha": "87837ae0f3402dd32dc40786e86fddb894977af0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -2037,7 +2037,7 @@ loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    output.h $(EXPR_H) coretypes.h $(TM_H)\n loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n-   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H)\n+   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) $(VARRAY_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h"}, {"sha": "4d9f184a74317c74c2a8c6bf41e7bde358247f2e", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -748,6 +748,10 @@ fsplit-ivs-in-unroller\n Common Report Var(flag_split_ivs_in_unroller) Init(1)\n Split lifetimes of induction variables when loops are unrolled.\n \n+fvariable-expansion-in-unroller\n+Common Report Var(flag_variable_expansion_in_unroller) \n+Apply variable expansion when loops are unrolled.\n+\n ; Emit code to probe the stack, to help detect stack overflow; also\n ; may cause large objects to be allocated dynamically.\n fstack-check"}, {"sha": "66e87a15990e1062cbf58073c93fc29acbe19a23", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -316,6 +316,7 @@ Objective-C and Objective-C++ Dialects}.\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -fsplit-ivs-in-unroller -funswitch-loops @gol\n+-fvariable-expansion-in-unroller @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n@@ -4728,6 +4729,11 @@ on some of the architectures due to restrictions in the CSE pass.\n \n This optimization is enabled by default.\n \n+@item -fvariable-expansion-in-unroller\n+@opindex -fvariable-expansion-in-unroller\n+With this option, the compiler will create multiple copies of some \n+local variables when unrolling a loop which can result in superior code.\n+\n @item -fprefetch-loop-arrays\n @opindex fprefetch-loop-arrays\n If supported by the target machine, generate instructions to prefetch"}, {"sha": "1d1eb4d48654b01469d9bced1ebca4d291e5e5d7", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 587, "deletions": 175, "changes": 762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -31,7 +31,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"expr.h\"\n #include \"hashtab.h\"\n-#include \"recog.h\"\n+#include \"recog.h\"    \n+#include \"varray.h\"                        \n \n /* This pass performs loop unrolling and peeling.  We only perform these\n    optimizations on innermost loops (with single exception) because\n@@ -83,11 +84,34 @@ struct iv_to_split\n \t\t\t   XEXP (XEXP (single_set, loc[0]), loc[1]).  */ \n };\n \n-struct split_ivs_info\n+/* Information about accumulators to expand.  */\n+\n+struct var_to_expand\n+{\n+  rtx insn;\t\t           /* The insn in that the variable expansion occurs.  */\n+  rtx reg;                         /* The accumulator which is expanded. */\n+  varray_type var_expansions;      /* The copies of the accumulator which is expanded.  */ \n+  enum rtx_code op;                /* The type of the accumulation - addition, subtraction \n+                                      or multiplication.  */\n+  int expansion_count;             /* Count the number of expansions generated so far.  */\n+  int reuse_expansion;             /* The expansion we intend to reuse to expand\n+                                      the accumulator.  If REUSE_EXPANSION is 0 reuse \n+                                      the original accumulator.  Else use \n+                                      var_expansions[REUSE_EXPANSION - 1].  */\n+};\n+\n+/* Information about optimization applied in\n+   the unrolled loop.  */\n+\n+struct opt_info\n {\n-  htab_t insns_to_split;\t/* A hashtable of insns to split.  */\n-  unsigned first_new_block;\t/* The first basic block that was\n-\t\t\t\t   duplicated.  */\n+  htab_t insns_to_split;           /* A hashtable of insns to split.  */\n+  htab_t insns_with_var_to_expand; /* A hashtable of insns with accumulators\n+                                      to expand.  */\n+  unsigned first_new_block;        /* The first basic block that was\n+                                      duplicated.  */\n+  basic_block loop_exit;           /* The loop exit basic block.  */\n+  basic_block loop_preheader;      /* The loop preheader basic block.  */\n };\n \n static void decide_unrolling_and_peeling (struct loops *, int);\n@@ -103,10 +127,18 @@ static void peel_loop_completely (struct loops *, struct loop *);\n static void unroll_loop_stupid (struct loops *, struct loop *);\n static void unroll_loop_constant_iterations (struct loops *, struct loop *);\n static void unroll_loop_runtime_iterations (struct loops *, struct loop *);\n-static struct split_ivs_info *analyze_ivs_to_split (struct loop *);\n-static void si_info_start_duplication (struct split_ivs_info *);\n-static void split_ivs_in_copies (struct split_ivs_info *, unsigned, bool, bool);\n-static void free_si_info (struct split_ivs_info *);\n+static struct opt_info *analyze_insns_in_loop (struct loop *);\n+static void opt_info_start_duplication (struct opt_info *);\n+static void apply_opt_in_copies (struct opt_info *, unsigned, bool, bool);\n+static void free_opt_info (struct opt_info *);\n+static struct var_to_expand *analyze_insn_to_expand_var (struct loop*, rtx);\n+static bool referenced_in_one_insn_in_loop_p (struct loop *, rtx);\n+static struct iv_to_split *analyze_iv_to_split_insn (rtx);\n+static void expand_var_during_unrolling (struct var_to_expand *, rtx);\n+static int insert_var_expansion_initialization (void **, void *);\n+static int combine_var_copies_in_loop_exit (void **, void *);\n+static int release_var_copies (void **, void *);\n+static rtx get_expansion (struct var_to_expand *);\n \n /* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n void\n@@ -456,8 +488,8 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n   unsigned n_remove_edges, i;\n   edge *remove_edges, ein;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n-  struct split_ivs_info *si_info = NULL;\n-\n+  struct opt_info *opt_info = NULL;\n+  \n   npeel = desc->niter;\n \n   if (npeel)\n@@ -472,22 +504,22 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n       n_remove_edges = 0;\n \n       if (flag_split_ivs_in_unroller)\n-\tsi_info = analyze_ivs_to_split (loop);\n-\n-      si_info_start_duplication (si_info);\n+        opt_info = analyze_insns_in_loop (loop);\n+      \n+      opt_info_start_duplication (opt_info);\n       if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\tloops, npeel,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n \tabort ();\n \n       free (wont_exit);\n-\n-      if (si_info)\n-\t{\n-\t  split_ivs_in_copies (si_info, npeel, false, true);\n-\t  free_si_info (si_info);\n-\t}\n+      \n+      if (opt_info)\n+ \t{\n+ \t  apply_opt_in_copies (opt_info, npeel, false, true);\n+ \t  free_opt_info (opt_info);\n+ \t}\n \n       /* Remove the exit edges.  */\n       for (i = 0; i < n_remove_edges; i++)\n@@ -636,8 +668,8 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n-  struct split_ivs_info *si_info = NULL;\n-\n+  struct opt_info *opt_info = NULL;\n+  \n   niter = desc->niter;\n \n   /* Should not get here (such loop should be peeled instead).  */\n@@ -650,10 +682,10 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \n   remove_edges = xcalloc (max_unroll + exit_mod + 1, sizeof (edge));\n   n_remove_edges = 0;\n-\n-  if (flag_split_ivs_in_unroller)\n-    si_info = analyze_ivs_to_split (loop);\n-\n+  if (flag_split_ivs_in_unroller \n+      || flag_variable_expansion_in_unroller)\n+    opt_info = analyze_insns_in_loop (loop);\n+  \n   if (!exit_at_end)\n     {\n       /* The exit is not at the end of the loop; leave exit test\n@@ -670,17 +702,17 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \n       if (exit_mod)\n \t{\n-\t  si_info_start_duplication (si_info);\n-\t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t  opt_info_start_duplication (opt_info);\n+          if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t      loops, exit_mod,\n \t\t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ))\n \t    abort ();\n \n-\t  if (si_info && exit_mod > 1)\n-\t    split_ivs_in_copies (si_info, exit_mod, false, false);\n-\n+          if (opt_info && exit_mod > 1)\n+ \t    apply_opt_in_copies (opt_info, exit_mod, false, false); \n+          \n \t  desc->noloop_assumptions = NULL_RTX;\n \t  desc->niter -= exit_mod;\n \t  desc->niter_max -= exit_mod;\n@@ -705,16 +737,16 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \t  RESET_BIT (wont_exit, 0);\n \t  if (desc->noloop_assumptions)\n \t    RESET_BIT (wont_exit, 1);\n-\n-\t  si_info_start_duplication (si_info);\n+         \n+          opt_info_start_duplication (opt_info);\n \t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\tloops, exit_mod + 1,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n \t    abort ();\n-\n-\t  if (si_info && exit_mod > 0)\n-\t    split_ivs_in_copies (si_info, exit_mod + 1, false, false);\n+ \n+          if (opt_info && exit_mod > 0)\n+  \t    apply_opt_in_copies (opt_info, exit_mod + 1, false, false);\n \n \t  desc->niter -= exit_mod + 1;\n \t  desc->niter_max -= exit_mod + 1;\n@@ -728,17 +760,18 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n     }\n \n   /* Now unroll the loop.  */\n-  si_info_start_duplication (si_info);\n+  \n+  opt_info_start_duplication (opt_info);\n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n \t\tloops, max_unroll,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n \n-  if (si_info)\n+  if (opt_info)\n     {\n-      split_ivs_in_copies (si_info, max_unroll, true, true);\n-      free_si_info (si_info);\n+      apply_opt_in_copies (opt_info, max_unroll, true, true);\n+      free_opt_info (opt_info);\n     }\n \n   free (wont_exit);\n@@ -900,11 +933,12 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n-  struct split_ivs_info *si_info = NULL;\n-\n-  if (flag_split_ivs_in_unroller)\n-    si_info = analyze_ivs_to_split (loop);\n-\n+  struct opt_info *opt_info = NULL;\n+  \n+  if (flag_split_ivs_in_unroller\n+      || flag_variable_expansion_in_unroller)\n+    opt_info = analyze_insns_in_loop (loop);\n+  \n   /* Remember blocks whose dominators will have to be updated.  */\n   dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n   n_dom_bbs = 0;\n@@ -1040,18 +1074,18 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n \n   sbitmap_ones (wont_exit);\n   RESET_BIT (wont_exit, may_exit_copy);\n-\n-  si_info_start_duplication (si_info);\n+  opt_info_start_duplication (opt_info);\n+  \n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n \t\tloops, max_unroll,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n-\n-  if (si_info)\n+  \n+  if (opt_info)\n     {\n-      split_ivs_in_copies (si_info, max_unroll, true, true);\n-      free_si_info (si_info);\n+      apply_opt_in_copies (opt_info, max_unroll, true, true);\n+      free_opt_info (opt_info);\n     }\n \n   free (wont_exit);\n@@ -1206,26 +1240,27 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned npeel = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n-  struct split_ivs_info *si_info = NULL;\n-\n+  struct opt_info *opt_info = NULL;\n+  \n   if (flag_split_ivs_in_unroller && npeel > 1)\n-    si_info = analyze_ivs_to_split (loop);\n-\n+    opt_info = analyze_insns_in_loop (loop);\n+  \n   wont_exit = sbitmap_alloc (npeel + 1);\n   sbitmap_zero (wont_exit);\n-\n-  si_info_start_duplication (si_info);\n+  \n+  opt_info_start_duplication (opt_info);\n+  \n   if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\tloops, npeel, wont_exit, NULL, NULL, NULL,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n \n   free (wont_exit);\n-\n-  if (si_info)\n+  \n+  if (opt_info)\n     {\n-      split_ivs_in_copies (si_info, npeel, false, false);\n-      free_si_info (si_info);\n+      apply_opt_in_copies (opt_info, npeel, false, false);\n+      free_opt_info (opt_info);\n     }\n \n   if (desc->simple_p)\n@@ -1350,24 +1385,26 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned nunroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n-  struct split_ivs_info *si_info = NULL;\n-\n-  if (flag_split_ivs_in_unroller)\n-    si_info = analyze_ivs_to_split (loop);\n-\n+  struct opt_info *opt_info = NULL;\n+  \n+  if (flag_split_ivs_in_unroller\n+      || flag_variable_expansion_in_unroller)\n+    opt_info = analyze_insns_in_loop (loop);\n+  \n+  \n   wont_exit = sbitmap_alloc (nunroll + 1);\n   sbitmap_zero (wont_exit);\n-\n-  si_info_start_duplication (si_info);\n+  opt_info_start_duplication (opt_info);\n+  \n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n \t\tloops, nunroll, wont_exit, NULL, NULL, NULL,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n-\n-  if (si_info)\n+  \n+  if (opt_info)\n     {\n-      split_ivs_in_copies (si_info, nunroll, true, true);\n-      free_si_info (si_info);\n+      apply_opt_in_copies (opt_info, nunroll, true, true);\n+      free_opt_info (opt_info);\n     }\n \n   free (wont_exit);\n@@ -1407,10 +1444,152 @@ si_info_eq (const void *ivts1, const void *ivts2)\n   return i1->insn == i2->insn;\n }\n \n+/* Return a hash for VES, which is really a \"var_to_expand *\".  */\n+\n+static hashval_t\n+ve_info_hash (const void *ves)\n+{\n+  return htab_hash_pointer (((struct var_to_expand *) ves)->insn);\n+}\n+\n+/* Return true if IVTS1 and IVTS2 (which are really both of type \n+   \"var_to_expand *\") refer to the same instruction. */\n+\n+static int\n+ve_info_eq (const void *ivts1, const void *ivts2)\n+{\n+  const struct var_to_expand *i1 = ivts1;\n+  const struct var_to_expand *i2 = ivts2;\n+  \n+  return i1->insn == i2->insn;\n+}\n+\n+/* Returns true if REG is referenced in one insn in LOOP. */\n+\n+bool\n+referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg)\n+{\n+  basic_block *body, bb;\n+  unsigned i;\n+  int count_ref = 0;\n+  rtx insn;\n+  \n+  body = get_loop_body (loop); \n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+      \n+      FOR_BB_INSNS (bb, insn)\n+      {\n+        if (rtx_referenced_p (reg, insn))\n+          count_ref++;\n+      }\n+    }\n+  return (count_ref  == 1);\n+}\n+\n+/* Determine whether INSN contains an accumulator\n+   which can be expanded into separate copies, \n+   one for each copy of the LOOP body.\n+   \n+   for (i = 0 ; i < n; i++)\n+     sum += a[i];\n+   \n+   ==>\n+     \n+   sum += a[i]\n+   ....\n+   i = i+1;\n+   sum1 += a[i]\n+   ....\n+   i = i+1\n+   sum2 += a[i];\n+   ....\n+\n+   Return NULL if INSN contains no opportunity for expansion of accumulator.  \n+   Otherwise, allocate a VAR_TO_EXPAND structure, fill it with the relevant \n+   information and return a pointer to it.\n+*/\n+\n+static struct var_to_expand *\n+analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n+{\n+  rtx set, dest, src, op1;\n+  struct var_to_expand *ves;\n+  enum machine_mode mode1, mode2;\n+  \n+  set = single_set (insn);\n+  if (!set)\n+    return NULL;\n+  \n+  dest = SET_DEST (set);\n+  src = SET_SRC (set);\n+  \n+  if (GET_CODE (src) != PLUS\n+      && GET_CODE (src) != MINUS\n+      && GET_CODE (src) != MULT)\n+    return NULL;\n+  \n+  if (!XEXP (src, 0))\n+    return NULL;\n+  \n+  op1 = XEXP (src, 0);\n+  \n+  if (!REG_P (dest)\n+      && !(GET_CODE (dest) == SUBREG\n+           && REG_P (SUBREG_REG (dest))))\n+    return NULL;\n+  \n+  if (!rtx_equal_p (dest, op1))\n+    return NULL;      \n+  \n+  if (!referenced_in_one_insn_in_loop_p (loop, dest))\n+    return NULL;\n+  \n+  if (rtx_referenced_p (dest, XEXP (src, 1)))\n+    return NULL;\n+  \n+  mode1 = GET_MODE (dest); \n+  mode2 = GET_MODE (XEXP (src, 1));\n+  if ((FLOAT_MODE_P (mode1) \n+       || FLOAT_MODE_P (mode2)) \n+      && !flag_unsafe_math_optimizations) \n+    return NULL;\n+  \n+  /* Record the accumulator to expand.  */\n+  ves = xmalloc (sizeof (struct var_to_expand));\n+  ves->insn = insn;\n+  VARRAY_RTX_INIT (ves->var_expansions, 1, \"var_expansions\");\n+  ves->reg = copy_rtx (dest);\n+  ves->op = GET_CODE (src);\n+  ves->expansion_count = 0;\n+  ves->reuse_expansion = 0;\n+  return ves; \n+}\n+\n /* Determine whether there is an induction variable in INSN that\n-   we would like to split during unrolling.  Return NULL if INSN\n-   contains no interesting IVs.  Otherwise, allocate an IV_TO_SPLIT\n-   structure, fill it with the relevant information and return a\n+   we would like to split during unrolling.  \n+\n+   I.e. replace\n+\n+   i = i + 1;\n+   ...\n+   i = i + 1;\n+   ...\n+   i = i + 1;\n+   ...\n+\n+   type chains by\n+\n+   i0 = i + 1\n+   ...\n+   i = i0 + 1\n+   ...\n+   i = i0 + 2\n+   ...\n+\n+   Return NULL if INSN contains no interesting IVs.  Otherwise, allocate \n+   an IV_TO_SPLIT structure, fill it with the relevant information and return a\n    pointer to it.  */\n \n static struct iv_to_split *\n@@ -1451,61 +1630,101 @@ analyze_iv_to_split_insn (rtx insn)\n   return ivts;\n }\n \n-/* Determines which of induction variables in LOOP to split.\n-   Return a SPLIT_IVS_INFO struct with the hash table filled\n-   with all insns to split IVs in.  The FIRST_NEW_BLOCK field\n+/* Determines which of insns in LOOP can be optimized.\n+   Return a OPT_INFO struct with the relevant hash tables filled\n+   with all insns to be optimized.  The FIRST_NEW_BLOCK field\n    is undefined for the return value.  */\n \n-static struct split_ivs_info *\n-analyze_ivs_to_split (struct loop *loop)\n+static struct opt_info *\n+analyze_insns_in_loop (struct loop *loop)\n {\n   basic_block *body, bb;\n-  unsigned i;\n-  struct split_ivs_info *si_info = xcalloc (1, sizeof (struct split_ivs_info));\n+  unsigned i, n_edges = 0;\n+  struct opt_info *opt_info = xcalloc (1, sizeof (struct opt_info));\n   rtx insn;\n-  struct iv_to_split *ivts;\n-  PTR *slot;\n-\n-  si_info->insns_to_split = htab_create (5 * loop->num_nodes,\n-\t\t\t\t\t si_info_hash, si_info_eq, free);\n-\n+  struct iv_to_split *ivts = NULL;\n+  struct var_to_expand *ves = NULL;\n+  PTR *slot1;\n+  PTR *slot2;\n+  edge *edges = get_loop_exit_edges (loop, &n_edges);\n+  basic_block preheader;\n+  bool can_apply = false;\n+  \n   iv_analysis_loop_init (loop);\n \n   body = get_loop_body (loop);\n+\n+  if (flag_split_ivs_in_unroller)\n+    opt_info->insns_to_split = htab_create (5 * loop->num_nodes,\n+                                            si_info_hash, si_info_eq, free);\n+  \n+  /* Record the loop exit bb and loop preheader before the unrolling.  */\n+  if (!loop_preheader_edge (loop)->src)\n+    {\n+      preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+      opt_info->loop_preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+    }\n+  else\n+    opt_info->loop_preheader = loop_preheader_edge (loop)->src;\n+  \n+  if (n_edges == 1\n+      && !(edges[0]->flags & EDGE_COMPLEX)\n+      && (edges[0]->flags & EDGE_LOOP_EXIT))\n+    {\n+      opt_info->loop_exit = loop_split_edge_with (edges[0], NULL_RTX);\n+      can_apply = true;\n+    }\n+  \n+  if (flag_variable_expansion_in_unroller\n+      && can_apply)\n+    opt_info->insns_with_var_to_expand = htab_create (5 * loop->num_nodes,\n+\t\t\t\t\t\t      ve_info_hash, ve_info_eq, free);\n+  \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       bb = body[i];\n       if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n \tcontinue;\n \n       FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  if (!INSN_P (insn))\n-\t    continue;\n-\n-\t  ivts = analyze_iv_to_split_insn (insn);\n-\n-\t  if (!ivts)\n-\t    continue;\n-\n-\t  slot = htab_find_slot (si_info->insns_to_split, ivts, INSERT);\n-\t  *slot = ivts;\n-\t}\n+      {\n+        if (!INSN_P (insn))\n+          continue;\n+        \n+        if (opt_info->insns_to_split)\n+          ivts = analyze_iv_to_split_insn (insn);\n+        \n+        if (ivts)\n+          {\n+            slot1 = htab_find_slot (opt_info->insns_to_split, ivts, INSERT);\n+            *slot1 = ivts;\n+            continue;\n+          }\n+        \n+        if (opt_info->insns_with_var_to_expand)\n+          ves = analyze_insn_to_expand_var (loop, insn);\n+        \n+        if (ves)\n+          {\n+            slot2 = htab_find_slot (opt_info->insns_with_var_to_expand, ves, INSERT);\n+            *slot2 = ves;\n+          }\n+      }\n     }\n-\n+  \n+  free (edges);\n   free (body);\n-\n-  return si_info;\n+  return opt_info;\n }\n \n /* Called just before loop duplication.  Records start of duplicated area\n-   to SI_INFO.  */\n+   to OPT_INFO.  */\n \n static void \n-si_info_start_duplication (struct split_ivs_info *si_info)\n+opt_info_start_duplication (struct opt_info *opt_info)\n {\n-  if (si_info)\n-    si_info->first_new_block = last_basic_block;\n+  if (opt_info)\n+    opt_info->first_new_block = last_basic_block;\n }\n \n /* Determine the number of iterations between initialization of the base\n@@ -1641,121 +1860,314 @@ split_iv (struct iv_to_split *ivts, rtx insn, unsigned delta)\n   delete_insn (insn);\n }\n \n-/* Splits induction variables (that are marked in SI_INFO) in copies of loop.\n-   I.e. replace\n \n-   i = i + 1;\n-   ...\n-   i = i + 1;\n-   ...\n-   i = i + 1;\n-   ...\n+/* Return one expansion of the accumulator recoreded \n+   in struct VE.  */\n \n-   type chains by\n+static rtx\n+get_expansion (struct var_to_expand *ve)\n+{\n+  rtx reg;\n+  \n+  if (ve->reuse_expansion == 0)\n+    reg = ve->reg;\n+  else\n+    reg = VARRAY_RTX (ve->var_expansions,  ve->reuse_expansion - 1);\n+  \n+  if (VARRAY_ACTIVE_SIZE (ve->var_expansions) == (unsigned) ve->reuse_expansion)\n+    ve->reuse_expansion = 0;\n+  else \n+    ve->reuse_expansion++;\n+  \n+  return reg;\n+}\n \n-   i0 = i + 1\n-   ...\n-   i = i0 + 1\n-   ...\n-   i = i0 + 2\n-   ...\n \n+/* Given INSN replace the uses of the accumulator recorded in VE \n+   with a new register.  */\n+\n+static void\n+expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n+{\n+  rtx new_reg, set;\n+  bool really_new_expansion = false;\n+  \n+  set = single_set (insn);\n+  if (!set)\n+    abort ();\n+  \n+  /* Generate a new register only if the expansion limit has not been\n+     reached.  Else reuse an already existing expansion.  */\n+  if (PARAM_VALUE (PARAM_MAX_VARIABLE_EXPANSIONS) > ve->expansion_count)\n+    {\n+      really_new_expansion = true;\n+      new_reg = gen_reg_rtx (GET_MODE (ve->reg));\n+    }\n+  else\n+    new_reg = get_expansion (ve);\n+\n+  validate_change (insn, &SET_DEST (set), new_reg, 1);\n+  validate_change (insn, &XEXP (SET_SRC (set), 0), new_reg, 1);\n+  \n+  if (apply_change_group ())\n+    if (really_new_expansion)\n+      {\n+        VARRAY_PUSH_RTX (ve->var_expansions, new_reg);\n+        ve->expansion_count++;\n+      }\n+}\n+\n+/* Initialize the variable expansions in loop preheader.  \n+   Callbacks for htab_traverse.  PLACE_P is the loop-preheader \n+   basic block where the initializtion of the expansions \n+   should take place.  */\n+\n+static int\n+insert_var_expansion_initialization (void **slot, void *place_p)\n+{\n+  struct var_to_expand *ve = *slot;\n+  basic_block place = (basic_block)place_p;\n+  rtx seq, var, zero_init, insn;\n+  unsigned i;\n+  \n+  if (VARRAY_ACTIVE_SIZE (ve->var_expansions) == 0)\n+    return 1;\n+  \n+  start_sequence ();\n+  if (ve->op == PLUS || ve->op == MINUS) \n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+      {\n+        var = VARRAY_RTX (ve->var_expansions, i);\n+        zero_init =  CONST0_RTX (GET_MODE (var));\n+        emit_move_insn (var, zero_init);\n+      }\n+  else if (ve->op == MULT)\n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+      {\n+        var = VARRAY_RTX (ve->var_expansions, i);\n+        zero_init =  CONST1_RTX (GET_MODE (var));\n+        emit_move_insn (var, zero_init);\n+      }\n+  \n+  seq = get_insns ();\n+  end_sequence ();\n+  \n+  insn = BB_HEAD (place);\n+  while (!NOTE_INSN_BASIC_BLOCK_P (insn))\n+    insn = NEXT_INSN (insn);\n+  \n+  emit_insn_after (seq, insn); \n+  /* Continue traversing the hash table.  */\n+  return 1;   \n+}\n+\n+/*  Combine the variable expansions at the loop exit.  \n+    Callbacks for htab_traverse.  PLACE_P is the loop exit\n+    basic block where the summation of the expansions should \n+    take place.  */\n+\n+static int\n+combine_var_copies_in_loop_exit (void **slot, void *place_p)\n+{\n+  struct var_to_expand *ve = *slot;\n+  basic_block place = (basic_block)place_p;\n+  rtx sum = ve->reg;\n+  rtx expr, seq, var, insn;\n+  unsigned i;\n+\n+  if (VARRAY_ACTIVE_SIZE (ve->var_expansions) == 0)\n+    return 1;\n+  \n+  start_sequence ();\n+  if (ve->op == PLUS || ve->op == MINUS)\n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+      {\n+        var = VARRAY_RTX (ve->var_expansions, i);\n+        sum = simplify_gen_binary (PLUS, GET_MODE (ve->reg),\n+                                   var, sum);\n+      }\n+  else if (ve->op == MULT)\n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+      {\n+        var = VARRAY_RTX (ve->var_expansions, i);\n+        sum = simplify_gen_binary (MULT, GET_MODE (ve->reg),\n+                                   var, sum);\n+      }\n+  \n+  expr = force_operand (sum, ve->reg);\n+  if (expr != ve->reg)\n+    emit_move_insn (ve->reg, expr);\n+  seq = get_insns ();\n+  end_sequence ();\n+  \n+  insn = BB_HEAD (place);\n+  while (!NOTE_INSN_BASIC_BLOCK_P (insn))\n+    insn = NEXT_INSN (insn);\n+\n+  emit_insn_after (seq, insn);\n+  \n+  /* Continue traversing the hash table.  */\n+  return 1;\n+}\n+\n+/* Apply loop optimizations in loop copies using the \n+   data which gathered during the unrolling.  Structure \n+   OPT_INFO record that data.\n+   \n    UNROLLING is true if we unrolled (not peeled) the loop.\n    REWRITE_ORIGINAL_BODY is true if we should also rewrite the original body of\n    the loop (as it should happen in complete unrolling, but not in ordinary\n    peeling of the loop).  */\n \n static void\n-split_ivs_in_copies (struct split_ivs_info *si_info, unsigned n_copies,\n-\t\t     bool unrolling, bool rewrite_original_loop)\n+apply_opt_in_copies (struct opt_info *opt_info, \n+                     unsigned n_copies, bool unrolling, \n+                     bool rewrite_original_loop)\n {\n   unsigned i, delta;\n   basic_block bb, orig_bb;\n   rtx insn, orig_insn, next;\n   struct iv_to_split ivts_templ, *ivts;\n-\n+  struct var_to_expand ve_templ, *ves;\n+  \n   /* Sanity check -- we need to put initialization in the original loop\n      body.  */\n   gcc_assert (!unrolling || rewrite_original_loop);\n-\n+  \n   /* Allocate the basic variables (i0).  */\n-  htab_traverse (si_info->insns_to_split, allocate_basic_variable, NULL);\n-\n-  for (i = si_info->first_new_block; i < (unsigned) last_basic_block; i++)\n+  if (opt_info->insns_to_split)\n+    htab_traverse (opt_info->insns_to_split, allocate_basic_variable, NULL);\n+  \n+  for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n     {\n       bb = BASIC_BLOCK (i);\n       orig_bb = bb->rbi->original;\n-\n+      \n       delta = determine_split_iv_delta (bb->rbi->copy_number, n_copies,\n \t\t\t\t\tunrolling);\n       orig_insn = BB_HEAD (orig_bb);\n       for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); insn = next)\n-\t{\n-\t  next = NEXT_INSN (insn);\n-\t  if (!INSN_P (insn))\n-\t    continue;\n-\n-\t  while (!INSN_P (orig_insn))\n-\t    orig_insn = NEXT_INSN (orig_insn);\n-\n-\t  ivts_templ.insn = orig_insn;\n-\t  ivts = htab_find (si_info->insns_to_split, &ivts_templ);\n-\t  if (ivts)\n-\t    {\n-\n+        {\n+          next = NEXT_INSN (insn);\n+          if (!INSN_P (insn))\n+            continue;\n+          \n+          while (!INSN_P (orig_insn))\n+            orig_insn = NEXT_INSN (orig_insn);\n+          \n+          ivts_templ.insn = orig_insn;\n+          ve_templ.insn = orig_insn;\n+          \n+          /* Apply splitting iv optimization.  */\n+          if (opt_info->insns_to_split)\n+            {\n+              ivts = htab_find (opt_info->insns_to_split, &ivts_templ);\n+              \n+              if (ivts)\n+                {\n #ifdef ENABLE_CHECKING\n-\t      if (!rtx_equal_p (PATTERN (insn), PATTERN (orig_insn)))\n-\t\tabort ();\n+\t\t  gcc_assert (rtx_equal_p (PATTERN (insn), PATTERN (orig_insn)));\n #endif\n-\n-\t      if (!delta)\n-\t\tinsert_base_initialization (ivts, insn);\n-\t      split_iv (ivts, insn, delta);\n-\t    }\n-\t  orig_insn = NEXT_INSN (orig_insn);\n-\t}\n+                  \n+                  if (!delta)\n+                    insert_base_initialization (ivts, insn);\n+                  split_iv (ivts, insn, delta);\n+                }\n+            }\n+          /* Apply variable expansion optimization.  */\n+          if (unrolling && opt_info->insns_with_var_to_expand)\n+            {\n+              ves = htab_find (opt_info->insns_with_var_to_expand, &ve_templ);\n+              if (ves)\n+                { \n+#ifdef ENABLE_CHECKING\n+                  gcc_assert (rtx_equal_p (PATTERN (insn), PATTERN (orig_insn)));\n+#endif\n+                  expand_var_during_unrolling (ves, insn);\n+                }\n+            }\n+          orig_insn = NEXT_INSN (orig_insn);\n+        }\n     }\n \n   if (!rewrite_original_loop)\n     return;\n-\n+  \n+  /* Initialize the variable expansions in the loop preheader\n+     and take care of combining them at the loop exit.  */ \n+  if (opt_info->insns_with_var_to_expand)\n+    {\n+      htab_traverse (opt_info->insns_with_var_to_expand, \n+                     insert_var_expansion_initialization, \n+                     opt_info->loop_preheader);\n+      htab_traverse (opt_info->insns_with_var_to_expand, \n+                     combine_var_copies_in_loop_exit, \n+                     opt_info->loop_exit);\n+    }\n+  \n   /* Rewrite also the original loop body.  Find them as originals of the blocks\n      in the last copied iteration, i.e. those that have\n      bb->rbi->original->copy == bb.  */\n-  for (i = si_info->first_new_block; i < (unsigned) last_basic_block; i++)\n+  for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n     {\n       bb = BASIC_BLOCK (i);\n       orig_bb = bb->rbi->original;\n       if (orig_bb->rbi->copy != bb)\n \tcontinue;\n-\n+      \n       delta = determine_split_iv_delta (0, n_copies, unrolling);\n       for (orig_insn = BB_HEAD (orig_bb);\n-\t   orig_insn != NEXT_INSN (BB_END (bb));\n-\t   orig_insn = next)\n-\t{\n-\t  next = NEXT_INSN (orig_insn);\n-\n-\t  if (!INSN_P (orig_insn))\n-\t    continue;\n+           orig_insn != NEXT_INSN (BB_END (bb));\n+           orig_insn = next)\n+        {\n+          next = NEXT_INSN (orig_insn);\n+          \n+          if (!INSN_P (orig_insn))\n+ \t    continue;\n+          \n+          ivts_templ.insn = orig_insn;\n+          if (opt_info->insns_to_split)\n+            {\n+              ivts = htab_find (opt_info->insns_to_split, &ivts_templ);\n+              if (ivts)\n+                {\n+                  if (!delta)\n+                    insert_base_initialization (ivts, orig_insn);\n+                  split_iv (ivts, orig_insn, delta);\n+                  continue;\n+                }\n+            }\n+          \n+        }\n+    }\n+}\n \n-\t  ivts_templ.insn = orig_insn;\n-\t  ivts = htab_find (si_info->insns_to_split, &ivts_templ);\n-\t  if (!ivts)\n-\t    continue;\n+/*  Release the data structures used for the variable expansion\n+    optimization.  Callbacks for htab_traverse.  */\n \n-\t  if (!delta)\n-\t    insert_base_initialization (ivts, orig_insn);\n-\t  split_iv (ivts, orig_insn, delta);\n-\t}\n-    }\n+static int\n+release_var_copies (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  struct var_to_expand *ve = *slot;\n+  \n+  VARRAY_CLEAR (ve->var_expansions);\n+  \n+  /* Continue traversing the hash table.  */\n+  return 1;\n }\n \n-/* Release SI_INFO.  */\n+/* Release OPT_INFO.  */\n \n static void\n-free_si_info (struct split_ivs_info *si_info)\n+free_opt_info (struct opt_info *opt_info)\n {\n-  htab_delete (si_info->insns_to_split);\n-  free (si_info);\n+  if (opt_info->insns_to_split)\n+    htab_delete (opt_info->insns_to_split);\n+  if (opt_info->insns_with_var_to_expand)\n+    {\n+      htab_traverse (opt_info->insns_with_var_to_expand, \n+                     release_var_copies, NULL);\n+      htab_delete (opt_info->insns_with_var_to_expand);\n+    }\n+  free (opt_info);\n }"}, {"sha": "79c55bcd2c1bf27b2a8cddba74ffdeb97ff62d8f", "filename": "gcc/params.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -95,6 +95,15 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_RTL,\n \t  \"The maximum number of instructions for the RTL inliner\",\n \t  600)\n \n+/* Limit the number of expansions created by the variable expansion\n+   optimization to avoid register pressure.  */\n+DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,\n+\t  \"max-variable-expansions-in-unroller\",\n+\t  \"If -fvariable-expansion-in-unroller is used, the maximum number of \\\n+           times that an individual variable will be expanded \\\n+           during loop unrolling\",\n+          1)\n+     \n /* The maximum number of instructions to consider when looking for an\n    instruction to fill a delay slot.  If more than this arbitrary\n    number of instructions is searched, the time savings from filling"}, {"sha": "b17625ea86f40c387e9b0b4823eb09a6895e59b7", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=f37a4f143d14f12cc7bb9a76e10e7a119bc3d61f", "patch": "@@ -94,6 +94,8 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO)\n #define MAX_INLINE_INSNS_RTL \\\n   PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RTL)\n+#define MAX_VARIABLE_EXPANSIONS \\\n+  PARAM_VALUE (PARAM_MAX_VARIABLE_EXPANSIONS)\n #define MAX_DELAY_SLOT_INSN_SEARCH \\\n   PARAM_VALUE (PARAM_MAX_DELAY_SLOT_INSN_SEARCH)\n #define MAX_DELAY_SLOT_LIVE_SEARCH \\"}]}