{"sha": "6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ2NGJjMzc4YzZkNWY5NWY1Zjc2ZWEzZTQyZThjMDA5ZjRiOWI0ZA==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2007-08-14T08:50:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:50:30Z"}, "message": "tracebak.c: Use tb-ivms.c on OpenVMS Itanium.\n\n2007-08-14  Tristan Gingold  <gingold@adacore.com>\n\n\t* tracebak.c: Use tb-ivms.c on OpenVMS Itanium.\n\n\t* tb-ivms.c: New file.\n\n\t* g-trasym-vms-ia64.adb: Fixed for OpenVMS version 8.2\n\nFrom-SVN: r127466", "tree": {"sha": "849f88caeb2a633fbc35009e4a4dfde0e91da326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/849f88caeb2a633fbc35009e4a4dfde0e91da326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6027ad8b260a9d274fb366a3fa45dcad67241f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6027ad8b260a9d274fb366a3fa45dcad67241f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6027ad8b260a9d274fb366a3fa45dcad67241f59"}], "stats": {"total": 371, "additions": 237, "deletions": 134}, "files": [{"sha": "374b0ae0c292f1e10f9d04666fce22825ce61766", "filename": "gcc/ada/g-trasym-vms-ia64.adb", "status": "modified", "additions": 142, "deletions": 133, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/gcc%2Fada%2Fg-trasym-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/gcc%2Fada%2Fg-trasym-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym-vms-ia64.adb?ref=6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2005-2006, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2005-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,6 @@\n --  Run-time symbolic traceback support for IA64/VMS\n \n with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n-with Interfaces.C;\n with System;\n with System.Aux_DEC;\n with System.Soft_Links;\n@@ -45,57 +44,50 @@ package body GNAT.Traceback.Symbolic is\n    pragma Warnings (Off);\n    pragma Linker_Options (\"--for-linker=sys$library:trace.exe\");\n \n-   use Interfaces.C;\n    use System;\n    use System.Aux_DEC;\n    use System.Traceback_Entries;\n \n-   subtype User_Arg_Type is Unsigned_Longword;\n-   subtype Cond_Value_Type is Unsigned_Longword;\n+   subtype Var_String_Buf is String (1 .. 254);\n \n-   type ASCIC is record\n-      Count : unsigned_char;\n-      Data  : char_array (1 .. 255);\n+   type Var_String is record\n+      Curlen : Unsigned_Word := 0;\n+      Buf    : Var_String_Buf;\n    end record;\n-   pragma Convention (C, ASCIC);\n-\n-   for ASCIC use record\n-      Count at 0 range 0 .. 7;\n-      Data  at 1 range 0 .. 8 * 255 - 1;\n+   pragma Convention (C, Var_String);\n+   for Var_String'Size use 8 * 256;\n+\n+   type Descriptor64 is record\n+      Mbo       : Unsigned_Word;\n+      Dtype     : Unsigned_Byte;\n+      Class     : Unsigned_Byte;\n+      Mbmo      : Unsigned_Longword;\n+      Maxstrlen : Integer_64;\n+      Pointer   : Address;\n    end record;\n-   for ASCIC'Size use 8 * 256;\n-\n-   function Fetch_ASCIC is new Fetch_From_Address (ASCIC);\n-\n-   procedure Symbolize\n-     (Status         : out Cond_Value_Type;\n-      Current_PC     : Address;\n-      Filename_Name  : out Address;\n-      Library_Name   : out Address;\n-      Record_Number  : out Integer;\n-      Image_Name     : out Address;\n-      Module_Name    : out Address;\n-      Routine_Name   : out Address;\n-      Line_Number    : out Integer;\n-      Relative_PC    : out Address);\n-\n-   pragma Interface (External, Symbolize);\n-\n-   pragma Import_Valued_Procedure\n-     (Symbolize, \"TBK$I64_SYMBOLIZE\",\n-      (Cond_Value_Type, Address,\n-       Address, Address, Integer,\n-       Address, Address, Address, Integer,\n-       Address),\n-      (Value, Value,\n-       Reference, Reference, Reference,\n-       Reference, Reference, Reference, Reference,\n-       Reference));\n+   pragma Convention (C, Descriptor64);\n+\n+   subtype Cond_Value_Type is Unsigned_Longword;\n+\n+   function Symbolize\n+     (Current_PC    : Address;\n+      Filename_Dsc  : Address;\n+      Library_Dsc   : Address;\n+      Record_Number : Address;\n+      Image_Dsc     : Address;\n+      Module_Dsc    : Address;\n+      Routine_Dsc   : Address;\n+      Line_Number   : Address;\n+      Relative_PC   : Address) return Cond_Value_Type;\n+   pragma Import (C, Symbolize, \"TBK$I64_SYMBOLIZE\");\n \n    function Decode_Ada_Name (Encoded_Name : String) return String;\n    --  Decodes an Ada identifier name. Removes leading \"_ada_\" and trailing\n    --  __{DIGIT}+ or ${DIGIT}+, converts other \"__\" to '.'\n \n+   procedure Setup_Descriptor64_Vs (Desc : out Descriptor64; Var : Address);\n+   --  Setup descriptor Desc for address Var\n+\n    ---------------------\n    -- Decode_Ada_Name --\n    ---------------------\n@@ -126,14 +118,17 @@ package body GNAT.Traceback.Symbolic is\n             case Encoded_Name (J) is\n                when '0' .. '9' =>\n                   null;\n+\n                when '$' =>\n                   Last := J - 1;\n                   exit;\n+\n                when '_' =>\n                   if Encoded_Name (J - 1) = '_' then\n                      Last := J - 2;\n                   end if;\n                   exit;\n+\n                when others =>\n                   exit;\n             end case;\n@@ -148,7 +143,6 @@ package body GNAT.Traceback.Symbolic is\n          then\n             Decoded_Name (DPos) := '.';\n             Pos := Pos + 2;\n-\n          else\n             Decoded_Name (DPos) := Encoded_Name (Pos);\n             Pos := Pos + 1;\n@@ -160,106 +154,121 @@ package body GNAT.Traceback.Symbolic is\n       return Decoded_Name (1 .. DPos - 1);\n    end Decode_Ada_Name;\n \n+   ---------------------------\n+   -- Setup_Descriptor64_Vs --\n+   ---------------------------\n+\n+   procedure Setup_Descriptor64_Vs (Desc : out Descriptor64; Var : Address) is\n+      K_Dtype_Vt : constant Unsigned_Byte := 37;\n+      K_Class_Vs : constant Unsigned_Byte := 11;\n+   begin\n+      Desc.Mbo := 1;\n+      Desc.Dtype := K_Dtype_Vt;\n+      Desc.Class := K_Class_Vs;\n+      Desc.Mbmo := -1;\n+      Desc.Maxstrlen := Integer_64 (Var_String_Buf'Length);\n+      Desc.Pointer := Var;\n+   end Setup_Descriptor64_Vs;\n+\n    ------------------------\n    -- Symbolic_Traceback --\n    ------------------------\n \n    function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n-      Status             : Cond_Value_Type;\n-      Filename_Name_Addr : Address;\n-      Library_Name_Addr  : Address;\n-      Record_Number      : Integer;\n-      Image_Name         : ASCIC;\n-      Image_Name_Addr    : Address;\n-      Module_Name        : ASCIC;\n-      Module_Name_Addr   : Address;\n-      Routine_Name       : ASCIC;\n-      Routine_Name_Addr  : Address;\n-      Line_Number        : Integer;\n-      Relative_PC        : Address;\n-      Res                : String (1 .. 256 * Traceback'Length);\n-      Len                : Integer;\n+      Status        : Cond_Value_Type;\n+      Filename_Name : Var_String;\n+      Filename_Dsc  : Descriptor64;\n+      Library_Name  : Var_String;\n+      Library_Dsc   : Descriptor64;\n+      Record_Number : Integer_64;\n+      Image_Name    : Var_String;\n+      Image_Dsc     : Descriptor64;\n+      Module_Name   : Var_String;\n+      Module_Dsc    : Descriptor64;\n+      Routine_Name  : Var_String;\n+      Routine_Dsc   : Descriptor64;\n+      Line_Number   : Integer_64;\n+      Relative_PC   : Integer_64;\n+      Res           : String (1 .. 256 * Traceback'Length);\n+      Len           : Integer;\n \n    begin\n-      if Traceback'Length > 0 then\n-         Len := 0;\n-\n-         --  Since image computation is not thread-safe we need task lockout\n-\n-         System.Soft_Links.Lock_Task.all;\n-\n-         for J in Traceback'Range loop\n-\n-            Symbolize\n-              (Status,\n-               PC_For (Traceback (J)),\n-               Filename_Name_Addr,\n-               Library_Name_Addr,\n-               Record_Number,\n-               Image_Name_Addr,\n-               Module_Name_Addr,\n-               Routine_Name_Addr,\n-               Line_Number,\n-               Relative_PC);\n-\n-            Image_Name   := Fetch_ASCIC (Image_Name_Addr);\n-            Module_Name  := Fetch_ASCIC (Module_Name_Addr);\n-            Routine_Name := Fetch_ASCIC (Routine_Name_Addr);\n-\n-            declare\n-               First : Integer := Len + 1;\n-               Last  : Integer := First + 80 - 1;\n-               Pos   : Integer;\n-               Routine_Name_D : String := Decode_Ada_Name\n-                 (To_Ada\n-                    (Routine_Name.Data (1 .. size_t (Routine_Name.Count)),\n-                     False));\n-\n-            begin\n-               Res (First .. Last) := (others => ' ');\n-\n-               Res (First .. First + Integer (Image_Name.Count) - 1) :=\n-                 To_Ada\n-                  (Image_Name.Data (1 .. size_t (Image_Name.Count)),\n-                   False);\n-\n-               Res (First + 10 ..\n-                    First + 10 + Integer (Module_Name.Count) - 1) :=\n-                 To_Ada\n-                  (Module_Name.Data (1 .. size_t (Module_Name.Count)),\n-                   False);\n-\n-               Res (First + 30 ..\n-                    First + 30 + Routine_Name_D'Length - 1) :=\n-                 Routine_Name_D;\n-\n-               --  If routine name doesn't fit 20 characters, output\n-               --  the line number on next line at 50th position\n-\n-               if Routine_Name_D'Length > 20 then\n-                  Pos := First + 30 + Routine_Name_D'Length;\n-                  Res (Pos) := ASCII.LF;\n-                  Last := Pos + 80;\n-                  Res (Pos + 1 .. Last) := (others => ' ');\n-                  Pos := Pos + 51;\n-               else\n-                  Pos := First + 50;\n-               end if;\n-\n-               Res (Pos .. Pos + Integer'Image (Line_Number)'Length - 1) :=\n-                 Integer'Image (Line_Number);\n-\n-               Res (Last) := ASCII.LF;\n-               Len := Last;\n-            end;\n-         end loop;\n-\n-         System.Soft_Links.Unlock_Task.all;\n-         return Res (1 .. Len);\n-\n-      else\n+      if Traceback'Length = 0 then\n          return \"\";\n       end if;\n+\n+      Len := 0;\n+\n+      --  Since image computation is not thread-safe we need task lockout\n+\n+      System.Soft_Links.Lock_Task.all;\n+\n+      Setup_Descriptor64_Vs (Filename_Dsc, Filename_Name'Address);\n+      Setup_Descriptor64_Vs (Library_Dsc, Library_Name'Address);\n+      Setup_Descriptor64_Vs (Image_Dsc, Image_Name'Address);\n+      Setup_Descriptor64_Vs (Module_Dsc, Module_Name'Address);\n+      Setup_Descriptor64_Vs (Routine_Dsc, Routine_Name'Address);\n+\n+      for J in Traceback'Range loop\n+         Status := Symbolize\n+           (PC_For (Traceback (J)),\n+            Filename_Dsc'Address,\n+            Library_Dsc'Address,\n+            Record_Number'Address,\n+            Image_Dsc'Address,\n+            Module_Dsc'Address,\n+            Routine_Dsc'Address,\n+            Line_Number'Address,\n+            Relative_PC'Address);\n+\n+         declare\n+            First : Integer := Len + 1;\n+            Last  : Integer := First + 80 - 1;\n+            Pos   : Integer;\n+\n+            Routine_Name_D : String :=\n+                               Decode_Ada_Name\n+                                 (Routine_Name.Buf\n+                                    (1 .. Natural (Routine_Name.Curlen)));\n+\n+         begin\n+            Res (First .. Last) := (others => ' ');\n+\n+            Res (First .. First + Natural (Image_Name.Curlen) - 1) :=\n+              Image_Name.Buf (1 .. Natural (Image_Name.Curlen));\n+\n+            Res (First + 10 ..\n+                 First + 10 + Natural (Module_Name.Curlen) - 1) :=\n+              Module_Name.Buf (1 .. Natural (Module_Name.Curlen));\n+\n+            Res (First + 30 ..\n+                 First + 30 + Routine_Name_D'Length - 1) :=\n+              Routine_Name_D;\n+\n+            --  If routine name doesn't fit 20 characters, output\n+            --  the line number on next line at 50th position\n+\n+            if Routine_Name_D'Length > 20 then\n+               Pos := First + 30 + Routine_Name_D'Length;\n+               Res (Pos) := ASCII.LF;\n+               Last := Pos + 80;\n+               Res (Pos + 1 .. Last) := (others => ' ');\n+               Pos := Pos + 51;\n+            else\n+               Pos := First + 50;\n+            end if;\n+\n+            Res (Pos ..\n+                 Pos + Integer_64'Image (Line_Number)'Length - 1) :=\n+              Integer_64'Image (Line_Number);\n+\n+            Res (Last) := ASCII.LF;\n+            Len := Last;\n+         end;\n+      end loop;\n+\n+      System.Soft_Links.Unlock_Task.all;\n+      return Res (1 .. Len);\n    end Symbolic_Traceback;\n \n    function Symbolic_Traceback (E : Exception_Occurrence) return String is"}, {"sha": "24afdb54e057d7f7ed3d20b31ba430e0927cff7c", "filename": "gcc/ada/tb-ivms.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/gcc%2Fada%2Ftb-ivms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/gcc%2Fada%2Ftb-ivms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-ivms.c?ref=6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "patch": "@@ -0,0 +1,89 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                 T R A C E B A C K - I t a n i u m  / V M S               *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                     Copyright (C) 2007, AdaCore                          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Itanium Open/VMS implementation of backtrace.  Use ICB (Invocation\n+   Context Block) routines.  */\n+#include <stdlib.h>\n+#include <vms/libicb.h>\n+\n+/* Declare libicb routines.  */\n+extern INVO_CONTEXT_BLK *LIB$I64_CREATE_INVO_CONTEXT (void *(*)(size_t),\n+\t\t\t\t\t\t      void (*)(void *),\n+\t\t\t\t\t\t      int);\n+extern void LIB$I64_FREE_INVO_CONTEXT (INVO_CONTEXT_BLK *);\n+extern int LIB$I64_GET_CURR_INVO_CONTEXT(INVO_CONTEXT_BLK *);\n+extern int LIB$I64_GET_PREV_INVO_CONTEXT(INVO_CONTEXT_BLK *);\n+\n+/* Gcc internal headers poison malloc.  So use xmalloc() when building the\n+   compiler.  */\n+#ifdef IN_RTS\n+#define BT_MALLOC malloc\n+#else\n+#define BT_MALLOC xmalloc\n+#endif\n+\n+int\n+__gnat_backtrace (void **array, int size,\n+                  void *exclude_min, void *exclude_max, int skip_frames)\n+{\n+  INVO_CONTEXT_BLK *ctxt;\n+  int res = 0;\n+  int n = 0;\n+\n+  /* Create the context.  */\n+  ctxt = LIB$I64_CREATE_INVO_CONTEXT (BT_MALLOC, free, 0);\n+  if (ctxt == NULL)\n+    return 0;\n+\n+  LIB$I64_GET_CURR_INVO_CONTEXT (ctxt);\n+\n+  while (1)\n+    {\n+      void *pc = (void *)ctxt->libicb$ih_pc;\n+      if (pc == (void *)0)\n+\tbreak;\n+      if (ctxt->libicb$v_bottom_of_stack)\n+\tbreak;\n+      if (n >= skip_frames && (pc < exclude_min || pc > exclude_max))\n+\t{\n+\t  array[res++] = (void *)(ctxt->libicb$ih_pc);\n+\t  if (res == size)\n+\t    break;\n+\t}\n+      n++;\n+      LIB$I64_GET_PREV_INVO_CONTEXT (ctxt);\n+    }\n+\n+  /* Free the context.  */\n+  LIB$I64_FREE_INVO_CONTEXT (ctxt);\n+  return res;\n+}"}, {"sha": "ba0381e051f4a5f74bcfa23fff3acd23e0b5cb55", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=6d64bc378c6d5f95f5f76ea3e42e8c009f4b9b4d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *                     Copyright (C) 2000-2006, AdaCore                     *\n+ *                     Copyright (C) 2000-2007, AdaCore                     *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -97,7 +97,12 @@ extern void (*Unlock_Task) (void);\n \n #include \"tb-alvms.c\"\n \n+#elif defined (__ia64__) && defined (__VMS__)\n+\n+#include \"tb-ivms.c\"\n+\n #else\n+\n /* No target specific implementation.  */\n \n /*----------------------------------------------------------------*"}]}