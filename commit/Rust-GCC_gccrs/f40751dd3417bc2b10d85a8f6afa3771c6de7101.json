{"sha": "f40751dd3417bc2b10d85a8f6afa3771c6de7101", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwNzUxZGQzNDE3YmMyYjEwZDg1YThmNmFmYTM3NzFjNmRlNzEwMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-31T09:44:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-31T09:44:25Z"}, "message": "fwprop.c (should_replace_address): Add speed attribute.\n\n\n\t* fwprop.c (should_replace_address): Add speed attribute.\n\t(PR_OPTIMIZE_FOR_SPEED): New flag.\n\t(propagate_rtx_1): Use it.\n\t(propagate_rtx): Set it.\n\t(try_fwprop_subst): Update call of rtx_costs.\n\t(forward_propagate_and_simplify): LIkewise.\n\t* hooks.c (hook_int_rtx_bool_0): New\n\t(hook_bool_rtx_int_int_intp_false): Replace by ...\n\t(hook_bool_rtx_int_int_intp_bool_false): .. thisone.\n\t* hooks.h (hook_int_rtx_bool_0): New\n\t(hook_bool_rtx_int_int_intp_false): Replace by ...\n\t(hook_bool_rtx_int_int_intp_bool_false): .. thisone.\n\t* optabs.c (avoid_expensive_constant): UPdate call of rtx_cost.\n\t(prepare_cmp_insn): UPdate call of rtx_cost.\n\t* postreload.c (reload_cse_simplify_set): Update call of rtx_cost.\n\t(reload_cse_simplify_operands): Update call of rtx_cost.\n\t(reload_cse_move2add): call of rtx_cost.\n\t* target.h (struct gcc_target): Update rtx_costs and address_costs.\n\t* rtlanal.c (rtx_cost): Add speed argument.\n\t(address_cost): Add speed argument\n\t(default_address_cost): Likewise.\n\t(insn_rtx_cost): Likewise.\n\t* cfgloopanal.c (seq_cost): Add speed argument.\n\t(target_reg_cost, target_spill_cost): Turn to array.\n\t(init_set_costs): Update for speed.\n\t(estimate_reg_pressure_cost): Add speed argument.\n\t* auto-inc-dec.c (attempt_change): Update call of rtx_cost.\n\t* dojump.c (prefer_and_bit_test): UPdate call of rtx_cost.\n\t* tree-ssa-loop-ivopts.c (struct ivopts_data): New field speed.\n\t(seq_cost): Add speed argument.\n\t(computation_cost): Add speed arugment.\n\t(add_cost, multiply_by_const, get_address_cost): add speed argument.\n\t(force_expr_to_var_cost): Update for profile info.\n\t(force_var_cost): Likewise.\n\t(split_address_cost): Likewise.\n\t(ptr_difference_cost): Likewise.\n\t(difference_cost): Likewise.\n\t(get_computation_cost_at): Likewise.\n\t(determine_iv_cost): Likewise.\n\t(ivopts_global_cost_for_size): Likewise.\n\t(rewrite_use_address): Likewise.\n\t(tree_ssa_iv_optimize_loop): Initialize speed field.\n\t* cse.c (optimize_this_for_speed_p): New static var.\n\t(notreg_cost): Update call of rtx_cost.\n\t(cse_extended_basic_block): set optimize_this_for_speed_p.\n\t* ifcvt.c (cheap_bb_rtx_cost_p): Update call of rtx_cost.\n\t(noce_try_cmove_arith): Likewise.\n\t(noce_try_sign_mask): LIkewise.\n\t* expr.c (compress_float_constant): Update rtx_cost calls.\n\t* tree-ssa-address.c (most_expensive_mult_to_index): Add speed argument.\n\t(addr_to_parts): Likewise.\n\t(create_mem_ref): Likewise.\n\t* dse.c (find_shift_sequence): Add speed argument.\n\t(replace_read): Update call.\n\t* calls.c (precompute_register_parameters): Update call of rtx_cost.\n\t* expmed.c (sdiv_pow2_cheap, smod_pow2_cheap, zero_cost, add_cost,\n\t* neg_cost, shift_cost, shiftadd_cost,\n\tshiftsub_cost, mul_cost, sdiv_cost, udiv_cost ,mul_widen_cost,\n\tmul_highpart_cost): Increase dimension.\n\t(init_expmed): Initialize for both size and speed.\n\t(expand_shift): Use profile.\n\t(synth_mult): Use profile.\n\t(choose_mult_variant): Use profile.\n\t(expand_mult): Use profile.\n\t(expand_mult_highpart_optab): Use profile.\n\t(expand_mult_highpart): Use profile.\n\t(expand_smod_pow2): Use profile.\n\t(expand_divmod): Use profile.\n\t* simplify-rtx.c (simplify_binary_operation_1): Update call of rtx_cost.\n\t* loop-invariant.c (create_new_invariant): Use profile.\n\t(gain_for_invariant): Add speed parameter.\n\t(best_gain_for_invariant): Likewise.\n\t(find_invariants_to_move): Likewise.\n\t(move_single_loop_invariants): Set it.\n\t* target-def.h (TARGET_RTX_COSTS): Use hook.\n\t* rtl.h (rtx_cost, address_cost, insn_rtx_cost): Update prototpe.\n\t(optimize_insn_for_size_p, optimize_insn_for_speed_p): Declare.\n\t* output.h (default_address_cost): Update prototype.\n\t* combine.c (optimize_this_for_speed_p): New static var.\n\t(combine_validate_cost): Update call of rtx_cost.\n\t(combine_instructions): Set optimize_this_for_speed_p.\n\t(expand_compound_operation): Update call of rtx_cost.\n\t(make_extraction):Update call of rtx_cost.\n\t(force_to_mode):Update call of rtx_cost.\n\t(distribute_and_simplify_rtx):Update call of rtx_cost.\n\t* cfgloop.h (target_reg_cost, target_spill_cost): Turn to array.\n\t(estimate_reg_pressure_cost): Update prototype.\n\t* tree-flow.h (multiply_by_cost, create_mem_ref): Update prototype.\n\t* basic-block.h (optimize_insn_for_size_p, optimize_insn_for_speed_p):\n\tRemove.\n\t* config/alpha/alpha.c (alpha_rtx_costs): Update.\n\t(alpha_rtx_costs): Update.\n\t* config/frv/frv.c (frv_rtx_costs): Update.\n\t* config/s390/s390.c (s390_rtx_costs): Update.\n\t* config/m32c/m32c.c (m32c_memory_move_cost): Update.\n\t(m32c_rtx_costs): Update.\n\t* config/spu/spu.c (TARGET_ADDRESS_COST): Upate.\n\t(spu_rtx_costs): Update.\n\t* config/sparc/sparc.c (sparc_rtx_costs): Update.\n\t* config/m32r/m32r.c (m32r_rtx_costs): Update.\n\t* config/i386/i386.c (:ix86_address_cost): Update.\n\t(ix86_rtx_costs): Update.\n\t* config/sh/sh.c (sh_rtx_costs, sh_address_cost): Update.\n\t* config/pdp11/pdp11.c (pdp11_rtx_costs): Update.\n\t* config/avr/avr.c (avr_rtx_costs, avr_address_cost): Update.\n\t* config/crx/crx.c (crx_address_cost): Update.\n\t* config/xtensa/xtensa.c (xtensa_rtx_costs): Update.\n\t* config/stormy16/stormy16.c\n\t(xstormy16_address_cost, xstormy16_rtx_costs): Update.\n\t* config/m68hc11/m68hc11.c\n\t(m68hc11_address_cost, m68hc11_rtx_costs): Update.\n\t* config/cris/cris.c (cris_rtx_costs, cris_address_cost): Update.\n\t* config/iq2000/iq2000.c (iq2000_rtx_costs, iq2000_address_cost): Update.\n\t* config/mn10300/mn10300.c (mn10300_address_cost, mn10300_rtx_costs): Update\n\t* config/ia64/ia64.c (ia64_rtx_costs): Update.\n\t* config/m68k/m68k.c (m68k_rtx_costs): Update.\n\t* config/rs6000/rs6000.c (rs6000_rtx_costs): Update.\n\t* config/arc/arc.c (arc_rtx_costs, arc_address_cost): Update.\n\t* config/mcore/mcore.c (TARGET_ADDRESS_COST): Update.\n\t(mcore_rtx_costs): update.\n\t* config/score/score3.c (score3_rtx_costs): Update.\n\t* config/score/score7.c (score7_rtx_costs): Update.\n\t* config/score/score3.h (score3_rtx_costs):Update.\n\t* config/score/score7.h (score7_rtx_costs): Update.\n\t* config/score/score.c (score_rtx_costs): Update.\n\t* config/arm/arm.c (arm_address_cost): Update.\n\t(arm_rtx_costs_1): Update.\n\t(arm_rtx_costs_1): Update.\n\t(arm_size_rtx_costs): Update.\n\t(arm_size_rtx_costs): Update.\n\t(arm_size_rtx_costs): Update.\n\t(arm_xscale_rtx_costs): Update.\n\t(arm_thumb_address_cost): Update.\n\t* config/pa/pa.c (hppa_address_cost): Update.\n\t* config/mips/mips.c (mips_rtx_costs): Update.\n\t* config/vax/vax.c (vax_address_cost): Update.\n\t* config/h8300/h8300.c (h8300_shift_costs): Update.\n\t(h8300_rtx_costs): Update.\n\t* config/v850/v850.c (TARGET_ADDRESS_COST): Update.\n\t(v850_rtx_costs): Update.\n\t* config/mmix/mmix.c (mmix_rtx_costs, mmix_rtx_costs): Update.\n\t* config/bfin/bfin.c\n\t(bfin_address_cost): Update.\n\t(bfin_rtx_costs): Update.\n\t* stmt.c (lshift_cheap_p): Update.\n\nFrom-SVN: r139821", "tree": {"sha": "09cc5dfcaa392f3934a1edc839c165e824b37e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09cc5dfcaa392f3934a1edc839c165e824b37e01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f40751dd3417bc2b10d85a8f6afa3771c6de7101", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40751dd3417bc2b10d85a8f6afa3771c6de7101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40751dd3417bc2b10d85a8f6afa3771c6de7101", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40751dd3417bc2b10d85a8f6afa3771c6de7101/comments", "author": null, "committer": null, "parents": [{"sha": "6aebac53f319408518584e434538b66bb8f03176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aebac53f319408518584e434538b66bb8f03176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aebac53f319408518584e434538b66bb8f03176"}], "stats": {"total": 1412, "additions": 853, "deletions": 559}, "files": [{"sha": "742e28abe1ff138fe36ff554ca438e98377a6aae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1,3 +1,151 @@\n+2008-08-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* fwprop.c (should_replace_address): Add speed attribute.\n+\t(PR_OPTIMIZE_FOR_SPEED): New flag.\n+\t(propagate_rtx_1): Use it.\n+\t(propagate_rtx): Set it.\n+\t(try_fwprop_subst): Update call of rtx_costs.\n+\t(forward_propagate_and_simplify): LIkewise.\n+\t* hooks.c (hook_int_rtx_bool_0): New\n+\t(hook_bool_rtx_int_int_intp_false): Replace by ...\n+\t(hook_bool_rtx_int_int_intp_bool_false): .. thisone.\n+\t* hooks.h (hook_int_rtx_bool_0): New\n+\t(hook_bool_rtx_int_int_intp_false): Replace by ...\n+\t(hook_bool_rtx_int_int_intp_bool_false): .. thisone.\n+\t* optabs.c (avoid_expensive_constant): UPdate call of rtx_cost.\n+\t(prepare_cmp_insn): UPdate call of rtx_cost.\n+\t* postreload.c (reload_cse_simplify_set): Update call of rtx_cost.\n+\t(reload_cse_simplify_operands): Update call of rtx_cost.\n+\t(reload_cse_move2add): call of rtx_cost.\n+\t* target.h (struct gcc_target): Update rtx_costs and address_costs.\n+\t* rtlanal.c (rtx_cost): Add speed argument.\n+\t(address_cost): Add speed argument\n+\t(default_address_cost): Likewise.\n+\t(insn_rtx_cost): Likewise.\n+\t* cfgloopanal.c (seq_cost): Add speed argument.\n+\t(target_reg_cost, target_spill_cost): Turn to array.\n+\t(init_set_costs): Update for speed.\n+\t(estimate_reg_pressure_cost): Add speed argument.\n+\t* auto-inc-dec.c (attempt_change): Update call of rtx_cost.\n+\t* dojump.c (prefer_and_bit_test): UPdate call of rtx_cost.\n+\t* tree-ssa-loop-ivopts.c (struct ivopts_data): New field speed.\n+\t(seq_cost): Add speed argument.\n+\t(computation_cost): Add speed arugment.\n+\t(add_cost, multiply_by_const, get_address_cost): add speed argument.\n+\t(force_expr_to_var_cost): Update for profile info.\n+\t(force_var_cost): Likewise.\n+\t(split_address_cost): Likewise.\n+\t(ptr_difference_cost): Likewise.\n+\t(difference_cost): Likewise.\n+\t(get_computation_cost_at): Likewise.\n+\t(determine_iv_cost): Likewise.\n+\t(ivopts_global_cost_for_size): Likewise.\n+\t(rewrite_use_address): Likewise.\n+\t(tree_ssa_iv_optimize_loop): Initialize speed field.\n+\t* cse.c (optimize_this_for_speed_p): New static var.\n+\t(notreg_cost): Update call of rtx_cost.\n+\t(cse_extended_basic_block): set optimize_this_for_speed_p.\n+\t* ifcvt.c (cheap_bb_rtx_cost_p): Update call of rtx_cost.\n+\t(noce_try_cmove_arith): Likewise.\n+\t(noce_try_sign_mask): LIkewise.\n+\t* expr.c (compress_float_constant): Update rtx_cost calls.\n+\t* tree-ssa-address.c (most_expensive_mult_to_index): Add speed argument.\n+\t(addr_to_parts): Likewise.\n+\t(create_mem_ref): Likewise.\n+\t* dse.c (find_shift_sequence): Add speed argument.\n+\t(replace_read): Update call.\n+\t* calls.c (precompute_register_parameters): Update call of rtx_cost.\n+\t* expmed.c (sdiv_pow2_cheap, smod_pow2_cheap, zero_cost, add_cost,\n+\t* neg_cost, shift_cost, shiftadd_cost,\n+\tshiftsub_cost, mul_cost, sdiv_cost, udiv_cost ,mul_widen_cost,\n+\tmul_highpart_cost): Increase dimension.\n+\t(init_expmed): Initialize for both size and speed.\n+\t(expand_shift): Use profile.\n+\t(synth_mult): Use profile.\n+\t(choose_mult_variant): Use profile.\n+\t(expand_mult): Use profile.\n+\t(expand_mult_highpart_optab): Use profile.\n+\t(expand_mult_highpart): Use profile.\n+\t(expand_smod_pow2): Use profile.\n+\t(expand_divmod): Use profile.\n+\t* simplify-rtx.c (simplify_binary_operation_1): Update call of rtx_cost.\n+\t* loop-invariant.c (create_new_invariant): Use profile.\n+\t(gain_for_invariant): Add speed parameter.\n+\t(best_gain_for_invariant): Likewise.\n+\t(find_invariants_to_move): Likewise.\n+\t(move_single_loop_invariants): Set it.\n+\t* target-def.h (TARGET_RTX_COSTS): Use hook.\n+\t* rtl.h (rtx_cost, address_cost, insn_rtx_cost): Update prototpe.\n+\t(optimize_insn_for_size_p, optimize_insn_for_speed_p): Declare.\n+\t* output.h (default_address_cost): Update prototype.\n+\t* combine.c (optimize_this_for_speed_p): New static var.\n+\t(combine_validate_cost): Update call of rtx_cost.\n+\t(combine_instructions): Set optimize_this_for_speed_p.\n+\t(expand_compound_operation): Update call of rtx_cost.\n+\t(make_extraction):Update call of rtx_cost.\n+\t(force_to_mode):Update call of rtx_cost.\n+\t(distribute_and_simplify_rtx):Update call of rtx_cost.\n+\t* cfgloop.h (target_reg_cost, target_spill_cost): Turn to array.\n+\t(estimate_reg_pressure_cost): Update prototype.\n+\t* tree-flow.h (multiply_by_cost, create_mem_ref): Update prototype.\n+\t* basic-block.h (optimize_insn_for_size_p, optimize_insn_for_speed_p):\n+\tRemove.\n+\t* config/alpha/alpha.c (alpha_rtx_costs): Update.\n+\t(alpha_rtx_costs): Update.\n+\t* config/frv/frv.c (frv_rtx_costs): Update.\n+\t* config/s390/s390.c (s390_rtx_costs): Update.\n+\t* config/m32c/m32c.c (m32c_memory_move_cost): Update.\n+\t(m32c_rtx_costs): Update.\n+\t* config/spu/spu.c (TARGET_ADDRESS_COST): Upate.\n+\t(spu_rtx_costs): Update.\n+\t* config/sparc/sparc.c (sparc_rtx_costs): Update.\n+\t* config/m32r/m32r.c (m32r_rtx_costs): Update.\n+\t* config/i386/i386.c (:ix86_address_cost): Update.\n+\t(ix86_rtx_costs): Update.\n+\t* config/sh/sh.c (sh_rtx_costs, sh_address_cost): Update.\n+\t* config/pdp11/pdp11.c (pdp11_rtx_costs): Update.\n+\t* config/avr/avr.c (avr_rtx_costs, avr_address_cost): Update.\n+\t* config/crx/crx.c (crx_address_cost): Update.\n+\t* config/xtensa/xtensa.c (xtensa_rtx_costs): Update.\n+\t* config/stormy16/stormy16.c\n+\t(xstormy16_address_cost, xstormy16_rtx_costs): Update.\n+\t* config/m68hc11/m68hc11.c\n+\t(m68hc11_address_cost, m68hc11_rtx_costs): Update.\n+\t* config/cris/cris.c (cris_rtx_costs, cris_address_cost): Update.\n+\t* config/iq2000/iq2000.c (iq2000_rtx_costs, iq2000_address_cost): Update.\n+\t* config/mn10300/mn10300.c (mn10300_address_cost, mn10300_rtx_costs): Update\n+\t* config/ia64/ia64.c (ia64_rtx_costs): Update.\n+\t* config/m68k/m68k.c (m68k_rtx_costs): Update.\n+\t* config/rs6000/rs6000.c (rs6000_rtx_costs): Update.\n+\t* config/arc/arc.c (arc_rtx_costs, arc_address_cost): Update.\n+\t* config/mcore/mcore.c (TARGET_ADDRESS_COST): Update.\n+\t(mcore_rtx_costs): update.\n+\t* config/score/score3.c (score3_rtx_costs): Update.\n+\t* config/score/score7.c (score7_rtx_costs): Update.\n+\t* config/score/score3.h (score3_rtx_costs):Update.\n+\t* config/score/score7.h (score7_rtx_costs): Update.\n+\t* config/score/score.c (score_rtx_costs): Update.\n+\t* config/arm/arm.c (arm_address_cost): Update.\n+\t(arm_rtx_costs_1): Update.\n+\t(arm_rtx_costs_1): Update.\n+\t(arm_size_rtx_costs): Update.\n+\t(arm_size_rtx_costs): Update.\n+\t(arm_size_rtx_costs): Update.\n+\t(arm_xscale_rtx_costs): Update.\n+\t(arm_thumb_address_cost): Update.\n+\t* config/pa/pa.c (hppa_address_cost): Update.\n+\t* config/mips/mips.c (mips_rtx_costs): Update.\n+\t* config/vax/vax.c (vax_address_cost): Update.\n+\t* config/h8300/h8300.c (h8300_shift_costs): Update.\n+\t(h8300_rtx_costs): Update.\n+\t* config/v850/v850.c (TARGET_ADDRESS_COST): Update.\n+\t(v850_rtx_costs): Update.\n+\t* config/mmix/mmix.c (mmix_rtx_costs, mmix_rtx_costs): Update.\n+\t* config/bfin/bfin.c\n+\t(bfin_address_cost): Update.\n+\t(bfin_rtx_costs): Update.\n+\t* stmt.c (lshift_cheap_p): Update.\n+\n 2008-08-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR middle-end/36444"}, {"sha": "6db9c7ef1f45197b3e768a47b10b138d7968c3ae", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -515,13 +515,14 @@ attempt_change (rtx new_addr, rtx inc_reg)\n   rtx new_mem;\n   int old_cost = 0;\n   int new_cost = 0;\n+  bool speed = optimize_bb_for_speed_p (bb);\n \n   PUT_MODE (mem_tmp, mode);\n   XEXP (mem_tmp, 0) = new_addr;\n \n-  old_cost = rtx_cost (mem, 0) \n-    + rtx_cost (PATTERN (inc_insn.insn), 0);\n-  new_cost = rtx_cost (mem_tmp, 0);\n+  old_cost = rtx_cost (mem, 0, speed) \n+    + rtx_cost (PATTERN (inc_insn.insn), 0, speed);\n+  new_cost = rtx_cost (mem_tmp, 0, speed);\n   \n   /* The first item of business is to see if this is profitable.  */\n   if (old_cost < new_cost)"}, {"sha": "59a6f4aca9cba6687a4fbd70215e253f2c83607d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -835,8 +835,6 @@ extern bool optimize_bb_for_size_p (const_basic_block);\n extern bool optimize_bb_for_speed_p (const_basic_block);\n extern bool optimize_edge_for_size_p (edge);\n extern bool optimize_edge_for_speed_p (edge);\n-extern bool optimize_insn_for_size_p (void);\n-extern bool optimize_insn_for_speed_p (void);\n extern bool optimize_function_for_size_p (struct function *);\n extern bool optimize_function_for_speed_p (struct function *);\n extern bool optimize_loop_for_size_p (struct loop *);"}, {"sha": "96d05eaf50228454b54911e25b9de7c53cbbe1ca", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -713,7 +713,8 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n \t\t     || (GET_CODE (args[i].value) == SUBREG\n \t\t\t && REG_P (SUBREG_REG (args[i].value)))))\n \t\t && args[i].mode != BLKmode\n-\t\t && rtx_cost (args[i].value, SET) > COSTS_N_INSNS (1)\n+\t\t && rtx_cost (args[i].value, SET, optimize_insn_for_speed_p ())\n+\t\t    > COSTS_N_INSNS (1)\n \t\t && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)\n \t\t     || optimize))\n \t  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);"}, {"sha": "842ebb5d5a4c46d33a06f3b6f4ff54b245e00da8", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -610,12 +610,12 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \n extern unsigned target_avail_regs;\n extern unsigned target_res_regs;\n-extern unsigned target_reg_cost;\n-extern unsigned target_spill_cost;\n+extern unsigned target_reg_cost [2];\n+extern unsigned target_spill_cost [2];\n \n /* Register pressure estimation for induction variable optimizations & loop\n    invariant motion.  */\n-extern unsigned estimate_reg_pressure_cost (unsigned, unsigned);\n+extern unsigned estimate_reg_pressure_cost (unsigned, unsigned, bool);\n extern void init_set_costs (void);\n \n /* Loop optimizer initialization.  */"}, {"sha": "d59fa2fb50597ff6d9c1ca5637e3552d71ad1001", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -295,7 +295,7 @@ get_loop_level (const struct loop *loop)\n /* Returns estimate on cost of computing SEQ.  */\n \n static unsigned\n-seq_cost (const_rtx seq)\n+seq_cost (const_rtx seq, bool speed)\n {\n   unsigned cost = 0;\n   rtx set;\n@@ -304,7 +304,7 @@ seq_cost (const_rtx seq)\n     {\n       set = single_set (seq);\n       if (set)\n-\tcost += rtx_cost (set, SET);\n+\tcost += rtx_cost (set, SET, speed);\n       else\n \tcost++;\n     }\n@@ -317,17 +317,18 @@ seq_cost (const_rtx seq)\n unsigned target_avail_regs;\t/* Number of available registers.  */\n unsigned target_res_regs;\t/* Number of registers reserved for temporary\n \t\t\t\t   expressions.  */\n-unsigned target_reg_cost;\t/* The cost for register when there still\n+unsigned target_reg_cost[2];\t/* The cost for register when there still\n \t\t\t\t   is some reserve, but we are approaching\n \t\t\t\t   the number of available registers.  */\n-unsigned target_spill_cost;\t/* The cost for register when we need\n+unsigned target_spill_cost[2];\t/* The cost for register when we need\n \t\t\t\t   to spill.  */\n \n /* Initialize the constants for computing set costs.  */\n \n void\n init_set_costs (void)\n {\n+  int speed;\n   rtx seq;\n   rtx reg1 = gen_raw_REG (SImode, FIRST_PSEUDO_REGISTER);\n   rtx reg2 = gen_raw_REG (SImode, FIRST_PSEUDO_REGISTER + 1);\n@@ -343,35 +344,40 @@ init_set_costs (void)\n \n   target_res_regs = 3;\n \n-  /* Set up the costs for using extra registers:\n-\n-     1) If not many free registers remain, we should prefer having an\n-\tadditional move to decreasing the number of available registers.\n-\t(TARGET_REG_COST).\n-     2) If no registers are available, we need to spill, which may require\n-\tstoring the old value to memory and loading it back\n-\t(TARGET_SPILL_COST).  */\n-\n-  start_sequence ();\n-  emit_move_insn (reg1, reg2);\n-  seq = get_insns ();\n-  end_sequence ();\n-  target_reg_cost = seq_cost (seq);\n-\n-  start_sequence ();\n-  emit_move_insn (mem, reg1);\n-  emit_move_insn (reg2, mem);\n-  seq = get_insns ();\n-  end_sequence ();\n-  target_spill_cost = seq_cost (seq);\n+  for (speed = 0; speed < 2; speed++)\n+     {\n+      crtl->maybe_hot_insn_p = speed;\n+      /* Set up the costs for using extra registers:\n+\n+\t 1) If not many free registers remain, we should prefer having an\n+\t    additional move to decreasing the number of available registers.\n+\t    (TARGET_REG_COST).\n+\t 2) If no registers are available, we need to spill, which may require\n+\t    storing the old value to memory and loading it back\n+\t    (TARGET_SPILL_COST).  */\n+\n+      start_sequence ();\n+      emit_move_insn (reg1, reg2);\n+      seq = get_insns ();\n+      end_sequence ();\n+      target_reg_cost [speed] = seq_cost (seq, speed);\n+\n+      start_sequence ();\n+      emit_move_insn (mem, reg1);\n+      emit_move_insn (reg2, mem);\n+      seq = get_insns ();\n+      end_sequence ();\n+      target_spill_cost [speed] = seq_cost (seq, speed);\n+    }\n+  default_rtl_profile ();\n }\n \n /* Estimates cost of increased register pressure caused by making N_NEW new\n    registers live around the loop.  N_OLD is the number of registers live\n    around the loop.  */\n \n unsigned\n-estimate_reg_pressure_cost (unsigned n_new, unsigned n_old)\n+estimate_reg_pressure_cost (unsigned n_new, unsigned n_old, bool speed)\n {\n   unsigned cost;\n   unsigned regs_needed = n_new + n_old;\n@@ -384,11 +390,11 @@ estimate_reg_pressure_cost (unsigned n_new, unsigned n_old)\n   if (regs_needed <= target_avail_regs)\n     /* If we are close to running out of registers, try to preserve\n        them.  */\n-    cost = target_reg_cost * n_new;\n+    cost = target_reg_cost [speed] * n_new;\n   else\n     /* If we run out of registers, it is very expensive to add another\n        one.  */\n-    cost = target_spill_cost * n_new;\n+    cost = target_spill_cost [speed] * n_new;\n \n   if (optimize && flag_ira && (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n \t\t\t       || flag_ira_algorithm == IRA_ALGORITHM_MIXED)"}, {"sha": "30ec0809625626cdbc6cc785c959529ba28f524e", "filename": "gcc/combine.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -297,6 +297,7 @@ static rtx added_links_insn;\n \n /* Basic block in which we are performing combines.  */\n static basic_block this_basic_block;\n+static bool optimize_this_for_speed_p;\n \n \f\n /* Length of the currently allocated uid_insn_cost array.  */\n@@ -793,10 +794,10 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat,\n     }\n \n   /* Calculate the replacement insn_rtx_costs.  */\n-  new_i3_cost = insn_rtx_cost (newpat);\n+  new_i3_cost = insn_rtx_cost (newpat, optimize_this_for_speed_p);\n   if (newi2pat)\n     {\n-      new_i2_cost = insn_rtx_cost (newi2pat);\n+      new_i2_cost = insn_rtx_cost (newi2pat, optimize_this_for_speed_p);\n       new_cost = (new_i2_cost > 0 && new_i3_cost > 0)\n \t\t ? new_i2_cost + new_i3_cost : 0;\n     }\n@@ -811,7 +812,7 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat,\n       int old_other_cost, new_other_cost;\n \n       old_other_cost = INSN_COST (undobuf.other_insn);\n-      new_other_cost = insn_rtx_cost (newotherpat);\n+      new_other_cost = insn_rtx_cost (newotherpat, optimize_this_for_speed_p);\n       if (old_other_cost > 0 && new_other_cost > 0)\n \t{\n \t  old_cost += old_other_cost;\n@@ -1068,6 +1069,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   create_log_links ();\n   FOR_EACH_BB (this_basic_block)\n     {\n+      optimize_this_for_speed_p = optimize_bb_for_speed_p (this_basic_block);\n       last_call_luid = 0;\n       mem_last_set = -1;\n       label_tick++;\n@@ -1090,7 +1092,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \n \t    /* Record the current insn_rtx_cost of this instruction.  */\n \t    if (NONJUMP_INSN_P (insn))\n-\t      INSN_COST (insn) = insn_rtx_cost (PATTERN (insn));\n+\t      INSN_COST (insn) = insn_rtx_cost (PATTERN (insn),\n+\t      \t\t\t\t\toptimize_this_for_speed_p);\n \t    if (dump_file)\n \t      fprintf(dump_file, \"insn_cost %d: %d\\n\",\n \t\t    INSN_UID (insn), INSN_COST (insn));\n@@ -6107,9 +6110,11 @@ expand_compound_operation (rtx x)\n       rtx temp2 = expand_compound_operation (temp);\n \n       /* Make sure this is a profitable operation.  */\n-      if (rtx_cost (x, SET) > rtx_cost (temp2, SET))\n+      if (rtx_cost (x, SET, optimize_this_for_speed_p)\n+          > rtx_cost (temp2, SET, optimize_this_for_speed_p))\n        return temp2;\n-      else if (rtx_cost (x, SET) > rtx_cost (temp, SET))\n+      else if (rtx_cost (x, SET, optimize_this_for_speed_p)\n+               > rtx_cost (temp, SET, optimize_this_for_speed_p))\n        return temp;\n       else\n        return x;\n@@ -6534,7 +6539,8 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n-\t  if (rtx_cost (temp, SET) <= rtx_cost (temp1, SET))\n+\t  if (rtx_cost (temp, SET, optimize_this_for_speed_p)\n+\t      <= rtx_cost (temp1, SET, optimize_this_for_speed_p))\n \t    return temp;\n \t  return temp1;\n \t}\n@@ -6728,7 +6734,8 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n-\t  if (rtx_cost (temp1, SET) < rtx_cost (temp, SET))\n+\t  if (rtx_cost (temp1, SET, optimize_this_for_speed_p)\n+\t      < rtx_cost (temp, SET, optimize_this_for_speed_p))\n \t    temp = temp1;\n \t}\n       pos_rtx = temp;\n@@ -7377,7 +7384,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n \t      y = simplify_gen_binary (AND, GET_MODE (x),\n \t\t\t\t       XEXP (x, 0), GEN_INT (cval));\n-\t      if (rtx_cost (y, SET) < rtx_cost (x, SET))\n+\t      if (rtx_cost (y, SET, optimize_this_for_speed_p)\n+\t          < rtx_cost (x, SET, optimize_this_for_speed_p))\n \t\tx = y;\n \t    }\n \n@@ -8521,7 +8529,8 @@ distribute_and_simplify_rtx (rtx x, int n)\n   tmp = apply_distributive_law (simplify_gen_binary (inner_code, mode,\n \t\t\t\t\t\t     new_op0, new_op1));\n   if (GET_CODE (tmp) != outer_code\n-      && rtx_cost (tmp, SET) < rtx_cost (x, SET))\n+      && rtx_cost (tmp, SET, optimize_this_for_speed_p)\n+         < rtx_cost (x, SET, optimize_this_for_speed_p))\n     return tmp;\n \n   return NULL_RTX;"}, {"sha": "cad90e1adcef5ced54dd76345ceed6fd8fb8436e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1260,13 +1260,14 @@ alpha_legitimize_reload_address (rtx x,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n+alpha_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t bool speed)\n {\n   enum machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n   const struct alpha_rtx_cost_data *cost_data;\n \n-  if (optimize_size)\n+  if (!speed)\n     cost_data = &alpha_rtx_cost_size;\n   else\n     cost_data = &alpha_rtx_cost_data[alpha_tune];\n@@ -1311,7 +1312,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t*total = COSTS_N_INSNS (15);\n       else\n \t/* Otherwise we do a load from the GOT.  */\n-\t*total = COSTS_N_INSNS (optimize_size ? 1 : alpha_memory_latency);\n+\t*total = COSTS_N_INSNS (!speed ? 1 : alpha_memory_latency);\n       return true;\n \n     case HIGH:\n@@ -1326,8 +1327,8 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n       else if (GET_CODE (XEXP (x, 0)) == MULT\n \t       && const48_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n \t{\n-\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0), outer_code)\n-\t\t    + rtx_cost (XEXP (x, 1), outer_code) + COSTS_N_INSNS (1));\n+\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0), outer_code, speed)\n+\t\t    + rtx_cost (XEXP (x, 1), outer_code, speed) + COSTS_N_INSNS (1));\n \t  return true;\n \t}\n       return false;\n@@ -1375,7 +1376,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case MEM:\n-      *total = COSTS_N_INSNS (optimize_size ? 1 : alpha_memory_latency);\n+      *total = COSTS_N_INSNS (!speed ? 1 : alpha_memory_latency);\n       return true;\n \n     case NEG:\n@@ -10657,7 +10658,7 @@ alpha_init_libfuncs (void)\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS alpha_rtx_costs\n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG alpha_reorg"}, {"sha": "891b8efefba25cd9fa864567dd4eb4a4540d6f44", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -92,8 +92,8 @@ static void arc_internal_label (FILE *, const char *, unsigned long);\n static void arc_va_start (tree, rtx);\n static void arc_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\ttree, int *, int);\n-static bool arc_rtx_costs (rtx, int, int, int *);\n-static int arc_address_cost (rtx);\n+static bool arc_rtx_costs (rtx, int, int, int *, bool);\n+static int arc_address_cost (rtx, bool);\n static void arc_external_libcall (rtx);\n static bool arc_return_in_memory (const_tree, const_tree);\n static bool arc_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -830,7 +830,8 @@ arc_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-arc_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n+arc_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n+\t       bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -884,7 +885,7 @@ arc_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n static int\n-arc_address_cost (rtx addr)\n+arc_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (addr))\n     {"}, {"sha": "6a4b3ef11cde0195dc306b25c32df66570a56afc", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -131,7 +131,8 @@ static bool arm_slowmul_rtx_costs (rtx, int, int, int *);\n static bool arm_fastmul_rtx_costs (rtx, int, int, int *);\n static bool arm_xscale_rtx_costs (rtx, int, int, int *);\n static bool arm_9e_rtx_costs (rtx, int, int, int *);\n-static int arm_address_cost (rtx);\n+static bool arm_rtx_costs (rtx, int, int, int *, bool);\n+static int arm_address_cost (rtx, bool);\n static bool arm_memory_load_p (rtx);\n static bool arm_cirrus_insn_p (rtx);\n static void cirrus_reorg (rtx);\n@@ -256,9 +257,8 @@ static bool arm_allocate_stack_slots_for_args (void);\n #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n-/* This will be overridden in arm_override_options.  */\n #undef  TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS arm_slowmul_rtx_costs\n+#define TARGET_RTX_COSTS arm_rtx_costs\n #undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST arm_address_cost\n \n@@ -1185,10 +1185,6 @@ arm_override_options (void)\n   gcc_assert (arm_tune != arm_none);\n \n   tune_flags = all_cores[(int)arm_tune].flags;\n-  if (optimize_size)\n-    targetm.rtx_costs = arm_size_rtx_costs;\n-  else\n-    targetm.rtx_costs = all_cores[(int)arm_tune].rtx_costs;\n \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n@@ -4920,7 +4916,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n     case MINUS:\n       if (GET_CODE (XEXP (x, 1)) == MULT && mode == SImode && arm_arch_thumb2)\n \t{\n-\t  extra_cost = rtx_cost (XEXP (x, 1), code);\n+\t  extra_cost = rtx_cost (XEXP (x, 1), code, true);\n \t  if (!REG_OR_SUBREG_REG (XEXP (x, 0)))\n \t    extra_cost += 4 * ARM_NUM_REGS (mode);\n \t  return extra_cost;\n@@ -4969,7 +4965,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \n       if (GET_CODE (XEXP (x, 0)) == MULT)\n \t{\n-\t  extra_cost = rtx_cost (XEXP (x, 0), code);\n+\t  extra_cost = rtx_cost (XEXP (x, 0), code, true);\n \t  if (!REG_OR_SUBREG_REG (XEXP (x, 1)))\n \t    extra_cost += 4 * ARM_NUM_REGS (mode);\n \t  return extra_cost;\n@@ -5168,7 +5164,7 @@ arm_size_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case ROTATE:\n       if (mode == SImode && GET_CODE (XEXP (x, 1)) == REG)\n \t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code);\n+\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, false);\n \t  return true;\n \t}\n       /* Fall through */\n@@ -5178,15 +5174,15 @@ arm_size_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case ASHIFTRT:\n       if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n-\t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), code);\n+\t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), code, false);\n \t  return true;\n \t}\n       else if (mode == SImode)\n \t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code);\n+\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, false);\n \t  /* Slightly disparage register shifts, but not by much.  */\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-\t    *total += 1 + rtx_cost (XEXP (x, 1), code);\n+\t    *total += 1 + rtx_cost (XEXP (x, 1), code, false);\n \t  return true;\n \t}\n \n@@ -5354,6 +5350,16 @@ arm_size_rtx_costs (rtx x, int code, int outer_code, int *total)\n     }\n }\n \n+/* RTX costs when optimizing for size.  */\n+static bool\n+arm_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n+{\n+  if (!speed)\n+    return arm_size_rtx_costs (x, code, outer_code, total);\n+  else\n+    return all_cores[(int)arm_tune].rtx_costs;\n+}\n+\n /* RTX costs for cores with a slow MUL implementation.  Thumb-2 is not\n    supported on any \"slowmul\" cores, so it can be ignored.  */\n \n@@ -5546,7 +5552,7 @@ arm_xscale_rtx_costs (rtx x, int code, int outer_code, int *total)\n       /* A COMPARE of a MULT is slow on XScale; the muls instruction\n \t will stall until the multiplication is complete.  */\n       if (GET_CODE (XEXP (x, 0)) == MULT)\n-\t*total = 4 + rtx_cost (XEXP (x, 0), code);\n+\t*total = 4 + rtx_cost (XEXP (x, 0), code, true);\n       else\n \t*total = arm_rtx_costs_1 (x, code, outer_code);\n       return true;\n@@ -5666,7 +5672,7 @@ arm_thumb_address_cost (rtx x)\n }\n \n static int\n-arm_address_cost (rtx x)\n+arm_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   return TARGET_32BIT ? arm_arm_address_cost (x) : arm_thumb_address_cost (x);\n }"}, {"sha": "ed8c97729a469db621349a4351d74e700b637e88", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -81,8 +81,8 @@ static void avr_reorg (void);\n static void avr_asm_out_ctor (rtx, int);\n static void avr_asm_out_dtor (rtx, int);\n static int avr_operand_rtx_cost (rtx, enum machine_mode, enum rtx_code);\n-static bool avr_rtx_costs (rtx, int, int, int *);\n-static int avr_address_cost (rtx);\n+static bool avr_rtx_costs (rtx, int, int, int *, bool);\n+static int avr_address_cost (rtx, bool);\n static bool avr_return_in_memory (const_tree, const_tree);\n static struct machine_function * avr_init_machine_status (void);\n static rtx avr_builtin_setjmp_frame_value (void);\n@@ -1562,7 +1562,7 @@ final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n       fprintf (asm_out_file, \"/*DEBUG: 0x%x\\t\\t%d\\t%d */\\n\",\n \t       INSN_ADDRESSES (uid),\n                INSN_ADDRESSES (uid) - last_insn_address,\n-\t       rtx_cost (PATTERN (insn), INSN));\n+\t       rtx_cost (PATTERN (insn), INSN, !optimize_size));\n     }\n   last_insn_address = INSN_ADDRESSES (uid);\n }\n@@ -4991,7 +4991,8 @@ order_regs_for_local_alloc (void)\n    operand's parent operator.  */\n \n static int\n-avr_operand_rtx_cost (rtx x, enum machine_mode mode, enum rtx_code outer)\n+avr_operand_rtx_cost (rtx x, enum machine_mode mode, enum rtx_code outer,\n+\t\t      bool speed ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n   int total;\n@@ -5021,7 +5022,8 @@ avr_operand_rtx_cost (rtx x, enum machine_mode mode, enum rtx_code outer)\n    case, *TOTAL contains the cost result.  */\n \n static bool\n-avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n+avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n+\t       bool speed)\n {\n   enum machine_mode mode = GET_MODE (x);\n   HOST_WIDE_INT val;\n@@ -5153,17 +5155,17 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t{\n \tcase QImode:\n \t  if (AVR_HAVE_MUL)\n-\t    *total = COSTS_N_INSNS (optimize_size ? 3 : 4);\n-\t  else if (optimize_size)\n+\t    *total = COSTS_N_INSNS (!speed ? 3 : 4);\n+\t  else if (!speed)\n \t    *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);\n \t  else\n \t    return false;\n \t  break;\n \n \tcase HImode:\n \t  if (AVR_HAVE_MUL)\n-\t    *total = COSTS_N_INSNS (optimize_size ? 7 : 10);\n-\t  else if (optimize_size)\n+\t    *total = COSTS_N_INSNS (!speed ? 7 : 10);\n+\t  else if (!speed)\n \t    *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);\n \t  else\n \t    return false;\n@@ -5180,7 +5182,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n     case MOD:\n     case UDIV:\n     case UMOD:\n-      if (optimize_size)\n+      if (!speed)\n \t*total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);\n       else\n \treturn false;\n@@ -5194,7 +5196,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \tcase QImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 4 : 17);\n+\t      *total = COSTS_N_INSNS (!speed ? 4 : 17);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5212,7 +5214,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \tcase HImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 5 : 41);\n+\t      *total = COSTS_N_INSNS (!speed ? 5 : 41);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5240,24 +5242,24 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t\t*total = COSTS_N_INSNS (5);\n \t\tbreak;\n \t      case 4:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 5 : 8);\n+\t\t*total = COSTS_N_INSNS (!speed ? 5 : 8);\n \t\tbreak;\n \t      case 6:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 5 : 9);\n+\t\t*total = COSTS_N_INSNS (ptimize_size ? 5 : 9);\n \t\tbreak;\n \t      case 5:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 5 : 10);\n+\t\t*total = COSTS_N_INSNS (!speed ? 5 : 10);\n \t\tbreak;\n \t      default:\n-\t        *total = COSTS_N_INSNS (optimize_size ? 5 : 41);\n+\t        *total = COSTS_N_INSNS (!speed ? 5 : 41);\n \t        *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t      }\n \t  break;\n \n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 7 : 113);\n+\t      *total = COSTS_N_INSNS (!speed ? 7 : 113);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5278,10 +5280,10 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t\t*total = COSTS_N_INSNS (6);\n \t\tbreak;\n \t      case 2:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 7 : 8);\n+\t\t*total = COSTS_N_INSNS (!speed ? 7 : 8);\n \t\tbreak;\n \t      default:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 7 : 113);\n+\t\t*total = COSTS_N_INSNS (!speed ? 7 : 113);\n \t\t*total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t      }\n \t  break;\n@@ -5298,7 +5300,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \tcase QImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 4 : 17);\n+\t      *total = COSTS_N_INSNS (!speed ? 4 : 17);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5318,7 +5320,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \tcase HImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 5 : 41);\n+\t      *total = COSTS_N_INSNS (!speed ? 5 : 41);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5344,25 +5346,25 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t\t*total = COSTS_N_INSNS (5);\n \t\tbreak;\n               case 11:\n-                *total = COSTS_N_INSNS (optimize_size ? 5 : 6);\n+                *total = COSTS_N_INSNS (!speed ? 5 : 6);\n \t\tbreak;\n               case 12:\n-                *total = COSTS_N_INSNS (optimize_size ? 5 : 7);\n+                *total = COSTS_N_INSNS (!speed ? 5 : 7);\n \t\tbreak;\n               case 6:\n \t      case 13:\n-                *total = COSTS_N_INSNS (optimize_size ? 5 : 8);\n+                *total = COSTS_N_INSNS (!speed ? 5 : 8);\n \t\tbreak;\n \t      default:\n-\t        *total = COSTS_N_INSNS (optimize_size ? 5 : 41);\n+\t        *total = COSTS_N_INSNS (!speed ? 5 : 41);\n \t        *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t      }\n \t  break;\n \n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 7 : 113);\n+\t      *total = COSTS_N_INSNS (!speed ? 7 : 113);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5380,13 +5382,13 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t\t*total = COSTS_N_INSNS (6);\n \t\tbreak;\n \t      case 2:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 7 : 8);\n+\t\t*total = COSTS_N_INSNS (!speed ? 7 : 8);\n \t\tbreak;\n \t      case 31:\n \t\t*total = COSTS_N_INSNS (AVR_HAVE_MOVW ? 4 : 5);\n \t\tbreak;\n \t      default:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 7 : 113);\n+\t\t*total = COSTS_N_INSNS (!speed ? 7 : 113);\n \t\t*total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t      }\n \t  break;\n@@ -5403,7 +5405,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \tcase QImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 4 : 17);\n+\t      *total = COSTS_N_INSNS (!speed ? 4 : 17);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5421,7 +5423,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \tcase HImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 5 : 41);\n+\t      *total = COSTS_N_INSNS (!speed ? 5 : 41);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5450,25 +5452,25 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t      case 12:\n \t      case 13:\n \t      case 14:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 5 : 6);\n+\t\t*total = COSTS_N_INSNS (!speed ? 5 : 6);\n \t\tbreak;\n \t      case 4:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 5 : 7);\n+\t\t*total = COSTS_N_INSNS (!speed ? 5 : 7);\n \t\tbreak;\n \t      case 5:\n \t      case 6:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 5 : 9);\n+\t\t*total = COSTS_N_INSNS (!speed ? 5 : 9);\n \t\tbreak;\n \t      default:\n-\t        *total = COSTS_N_INSNS (optimize_size ? 5 : 41);\n+\t        *total = COSTS_N_INSNS (!speed ? 5 : 41);\n \t        *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t      }\n \t  break;\n \n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n-\t      *total = COSTS_N_INSNS (optimize_size ? 7 : 113);\n+\t      *total = COSTS_N_INSNS (!speed ? 7 : 113);\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t    }\n \t  else\n@@ -5481,7 +5483,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t\t*total = COSTS_N_INSNS (4);\n \t\tbreak;\n \t      case 2:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 7 : 8);\n+\t\t*total = COSTS_N_INSNS (!speed ? 7 : 8);\n \t\tbreak;\n \t      case 8:\n \t      case 16:\n@@ -5492,7 +5494,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n \t\t*total = COSTS_N_INSNS (6);\n \t\tbreak;\n \t      default:\n-\t\t*total = COSTS_N_INSNS (optimize_size ? 7 : 113);\n+\t\t*total = COSTS_N_INSNS (!speed ? 7 : 113);\n \t\t*total += avr_operand_rtx_cost (XEXP (x, 1), mode, code);\n \t      }\n \t  break;\n@@ -5543,7 +5545,7 @@ avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n /* Calculate the cost of a memory address.  */\n \n static int\n-avr_address_cost (rtx x)\n+avr_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x,1)) == CONST_INT"}, {"sha": "6ff1093de8cc81e2484ec315e77322c3aa22bd91", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1378,7 +1378,7 @@ bfin_dsp_memref_p (rtx x)\n    All addressing modes are equally cheap on the Blackfin.  */\n \n static int\n-bfin_address_cost (rtx addr ATTRIBUTE_UNUSED)\n+bfin_address_cost (rtx addr ATTRIBUTE_UNUSED, bool speed ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n@@ -2871,7 +2871,7 @@ bfin_legitimate_constant_p (rtx x)\n }\n \n static bool\n-bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n+bfin_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n {\n   int cost2 = COSTS_N_INSNS (1);\n   rtx op0, op1;\n@@ -2919,30 +2919,30 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      if (val == 2 || val == 4)\n \t\t{\n \t\t  *total = cost2;\n-\t\t  *total += rtx_cost (XEXP (op0, 0), outer_code);\n-\t\t  *total += rtx_cost (op1, outer_code);\n+\t\t  *total += rtx_cost (XEXP (op0, 0), outer_code, speed);\n+\t\t  *total += rtx_cost (op1, outer_code, speed);\n \t\t  return true;\n \t\t}\n \t    }\n \t  *total = cost2;\n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += rtx_cost (op0, SET);\n+\t    *total += rtx_cost (op0, SET, speed);\n #if 0 /* We'd like to do this for accuracy, but it biases the loop optimizer\n \t towards creating too many induction variables.  */\n \t  if (!reg_or_7bit_operand (op1, SImode))\n-\t    *total += rtx_cost (op1, SET);\n+\t    *total += rtx_cost (op1, SET, speed);\n #endif\n \t}\n       else if (GET_MODE (x) == DImode)\n \t{\n \t  *total = 6 * cost2;\n \t  if (GET_CODE (op1) != CONST_INT\n \t      || !satisfies_constraint_Ks7 (op1))\n-\t    *total += rtx_cost (op1, PLUS);\n+\t    *total += rtx_cost (op1, PLUS, speed);\n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += rtx_cost (op0, PLUS);\n+\t    *total += rtx_cost (op0, PLUS, speed);\n \t}\n       return true;\n \n@@ -2965,7 +2965,7 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n       op1 = XEXP (x, 1);\n       if (GET_CODE (op0) != REG\n \t  && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t*total += rtx_cost (op0, code);\n+\t*total += rtx_cost (op0, code, speed);\n \n       return true;\n \t  \n@@ -2990,7 +2990,7 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n       if (GET_CODE (op0) != REG\n \t  && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t*total += rtx_cost (op0, code);\n+\t*total += rtx_cost (op0, code, speed);\n \n       if (GET_MODE (x) == DImode)\n \t{\n@@ -3004,12 +3004,12 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n       if (code == AND)\n \t{\n \t  if (! rhs_andsi3_operand (XEXP (x, 1), SImode))\n-\t    *total += rtx_cost (XEXP (x, 1), code);\n+\t    *total += rtx_cost (XEXP (x, 1), code, speed);\n \t}\n       else\n \t{\n \t  if (! regorlog2_operand (XEXP (x, 1), SImode))\n-\t    *total += rtx_cost (XEXP (x, 1), code);\n+\t    *total += rtx_cost (XEXP (x, 1), code, speed);\n \t}\n \n       return true;\n@@ -3042,17 +3042,17 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      op0 = XEXP (op0, 0);\n \t      op1 = XEXP (op1, 0);\n \t    }\n-\t  else if (optimize_size)\n+\t  else if (!speed)\n \t    *total = COSTS_N_INSNS (1);\n \t  else\n \t    *total = COSTS_N_INSNS (3);\n \n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += rtx_cost (op0, MULT);\n+\t    *total += rtx_cost (op0, MULT, speed);\n \t  if (GET_CODE (op1) != REG\n \t      && (GET_CODE (op1) != SUBREG || GET_CODE (SUBREG_REG (op1)) != REG))\n-\t    *total += rtx_cost (op1, MULT);\n+\t    *total += rtx_cost (op1, MULT, speed);\n \t}\n       return true;\n "}, {"sha": "ff177f41f04289bf7008b94c7e4e4bfdc3075288", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -112,8 +112,8 @@ static void cris_asm_output_mi_thunk\n static void cris_file_start (void);\n static void cris_init_libfuncs (void);\n \n-static bool cris_rtx_costs (rtx, int, int, int *);\n-static int cris_address_cost (rtx);\n+static bool cris_rtx_costs (rtx, int, int, int *, bool);\n+static int cris_address_cost (rtx, bool);\n static bool cris_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n static int cris_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -1756,7 +1756,8 @@ cris_expand_return (bool on_stack)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n+cris_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed)\n {\n   switch (code)\n     {\n@@ -1840,7 +1841,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case ZERO_EXTEND: case SIGN_EXTEND:\n-      *total = rtx_cost (XEXP (x, 0), outer_code);\n+      *total = rtx_cost (XEXP (x, 0), outer_code, speed);\n       return true;\n \n     default:\n@@ -1851,7 +1852,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n /* The ADDRESS_COST worker.  */\n \n static int\n-cris_address_cost (rtx x)\n+cris_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   /* The metric to use for the cost-macros is unclear.\n      The metric used here is (the number of cycles needed) / 2,"}, {"sha": "1ae1bcfcd46043ed2ffd2c78ef0a1da13baea3f5", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -136,7 +136,7 @@ static bool crx_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static rtx crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n \t\t\t\t int incoming ATTRIBUTE_UNUSED);\n static bool crx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED);\n-static int crx_address_cost (rtx);\n+static int crx_address_cost (rtx, bool);\n \n /*****************************************************************************/\n /* STACK LAYOUT AND CALLING CONVENTIONS\t\t\t\t\t     */\n@@ -800,7 +800,7 @@ crx_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Return cost of the memory address x. */\n \n static int\n-crx_address_cost (rtx addr)\n+crx_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   enum crx_addrtype addrtype;\n   struct crx_address address;"}, {"sha": "4a57486a566fff99201fa76b2b4a87cf233169cb", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -9471,7 +9471,8 @@ static bool\n frv_rtx_costs (rtx x,\n                int code ATTRIBUTE_UNUSED,\n                int outer_code ATTRIBUTE_UNUSED,\n-               int *total)\n+               int *total,\n+\t       bool speed ATTRIBUTE_UNUSED)\n {\n   if (outer_code == MEM)\n     {"}, {"sha": "992c73a4c1b32454897d0c165a803ccf7307cf5e", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1152,7 +1152,7 @@ h8300_shift_costs (rtx x)\n /* Worker function for TARGET_RTX_COSTS.  */\n \n static bool\n-h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n+h8300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n {\n   if (TARGET_H8300SX && outer_code == MEM)\n     {\n@@ -1178,7 +1178,7 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  {\n \t    /* Constant operands need the same number of processor\n \t       states as register operands.  Although we could try to\n-\t       use a size-based cost for optimize_size, the lack of\n+\t       use a size-based cost for !speed, the lack of\n \t       of a mode makes the results very unpredictable.  */\n \t    *total = 0;\n \t    return true;\n@@ -1243,11 +1243,11 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  {\n \t  case QImode:\n \t  case HImode:\n-\t    *total = COSTS_N_INSNS (optimize_size ? 4 : 10);\n+\t    *total = COSTS_N_INSNS (!speed ? 4 : 10);\n \t    return false;\n \n \t  case SImode:\n-\t    *total = COSTS_N_INSNS (optimize_size ? 4 : 18);\n+\t    *total = COSTS_N_INSNS (!speed ? 4 : 18);\n \t    return false;\n \n \t  default:"}, {"sha": "025eee6a99c88bb620c8f47b6490e0abfeae2bc2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -8491,7 +8491,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n    requires to two regs - that would mean more pseudos with longer\n    lifetimes.  */\n static int\n-ix86_address_cost (rtx x)\n+ix86_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   struct ix86_address parts;\n   int cost = 1;\n@@ -25244,10 +25244,11 @@ ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n+ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total, bool speed)\n {\n   enum rtx_code outer_code = (enum rtx_code) outer_code_i;\n   enum machine_mode mode = GET_MODE (x);\n+  const struct processor_costs *cost = speed ? ix86_cost : &ix86_size_cost;\n \n   switch (code)\n     {\n@@ -25299,13 +25300,13 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t  && GET_MODE (XEXP (x, 0)) == SImode)\n \t*total = 1;\n       else if (TARGET_ZERO_EXTEND_WITH_AND)\n-\t*total = ix86_cost->add;\n+\t*total = cost->add;\n       else\n-\t*total = ix86_cost->movzx;\n+\t*total = cost->movzx;\n       return false;\n \n     case SIGN_EXTEND:\n-      *total = ix86_cost->movsx;\n+      *total = cost->movsx;\n       return false;\n \n     case ASHIFT:\n@@ -25315,13 +25316,13 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t  HOST_WIDE_INT value = INTVAL (XEXP (x, 1));\n \t  if (value == 1)\n \t    {\n-\t      *total = ix86_cost->add;\n+\t      *total = cost->add;\n \t      return false;\n \t    }\n \t  if ((value == 2 || value == 3)\n-\t      && ix86_cost->lea <= ix86_cost->shift_const)\n+\t      && cost->lea <= cost->shift_const)\n \t    {\n-\t      *total = ix86_cost->lea;\n+\t      *total = cost->lea;\n \t      return false;\n \t    }\n \t}\n@@ -25336,43 +25337,43 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t  if (CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      if (INTVAL (XEXP (x, 1)) > 32)\n-\t\t*total = ix86_cost->shift_const + COSTS_N_INSNS (2);\n+\t\t*total = cost->shift_const + COSTS_N_INSNS (2);\n \t      else\n-\t\t*total = ix86_cost->shift_const * 2;\n+\t\t*total = cost->shift_const * 2;\n \t    }\n \t  else\n \t    {\n \t      if (GET_CODE (XEXP (x, 1)) == AND)\n-\t\t*total = ix86_cost->shift_var * 2;\n+\t\t*total = cost->shift_var * 2;\n \t      else\n-\t\t*total = ix86_cost->shift_var * 6 + COSTS_N_INSNS (2);\n+\t\t*total = cost->shift_var * 6 + COSTS_N_INSNS (2);\n \t    }\n \t}\n       else\n \t{\n \t  if (CONST_INT_P (XEXP (x, 1)))\n-\t    *total = ix86_cost->shift_const;\n+\t    *total = cost->shift_const;\n \t  else\n-\t    *total = ix86_cost->shift_var;\n+\t    *total = cost->shift_var;\n \t}\n       return false;\n \n     case MULT:\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t{\n \t  /* ??? SSE scalar cost should be used here.  */\n-\t  *total = ix86_cost->fmul;\n+\t  *total = cost->fmul;\n \t  return false;\n \t}\n       else if (X87_FLOAT_MODE_P (mode))\n \t{\n-\t  *total = ix86_cost->fmul;\n+\t  *total = cost->fmul;\n \t  return false;\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n \t  /* ??? SSE vector cost should be used here.  */\n-\t  *total = ix86_cost->fmul;\n+\t  *total = cost->fmul;\n \t  return false;\n \t}\n       else\n@@ -25413,9 +25414,9 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t        op0 = XEXP (op0, 0), mode = GET_MODE (op0);\n \t    }\n \n-  \t  *total = (ix86_cost->mult_init[MODE_INDEX (mode)]\n-\t\t    + nbits * ix86_cost->mult_bit\n-\t            + rtx_cost (op0, outer_code) + rtx_cost (op1, outer_code));\n+  \t  *total = (cost->mult_init[MODE_INDEX (mode)]\n+\t\t    + nbits * cost->mult_bit\n+\t            + rtx_cost (op0, outer_code, speed) + rtx_cost (op1, outer_code, speed));\n \n           return true;\n \t}\n@@ -25426,14 +25427,14 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n     case UMOD:\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t/* ??? SSE cost should be used here.  */\n-\t*total = ix86_cost->fdiv;\n+\t*total = cost->fdiv;\n       else if (X87_FLOAT_MODE_P (mode))\n-\t*total = ix86_cost->fdiv;\n+\t*total = cost->fdiv;\n       else if (FLOAT_MODE_P (mode))\n \t/* ??? SSE vector cost should be used here.  */\n-\t*total = ix86_cost->fdiv;\n+\t*total = cost->fdiv;\n       else\n-\t*total = ix86_cost->divide[MODE_INDEX (mode)];\n+\t*total = cost->divide[MODE_INDEX (mode)];\n       return false;\n \n     case PLUS:\n@@ -25448,11 +25449,11 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1));\n \t      if (val == 2 || val == 4 || val == 8)\n \t\t{\n-\t\t  *total = ix86_cost->lea;\n-\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code);\n+\t\t  *total = cost->lea;\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code, speed);\n \t\t  *total += rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0),\n-\t\t\t\t      outer_code);\n-\t\t  *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t\t\t\t      outer_code, speed);\n+\t\t  *total += rtx_cost (XEXP (x, 1), outer_code, speed);\n \t\t  return true;\n \t\t}\n \t    }\n@@ -25462,18 +25463,18 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (x, 0), 1));\n \t      if (val == 2 || val == 4 || val == 8)\n \t\t{\n-\t\t  *total = ix86_cost->lea;\n-\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n-\t\t  *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t\t  *total = cost->lea;\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code, speed);\n+\t\t  *total += rtx_cost (XEXP (x, 1), outer_code, speed);\n \t\t  return true;\n \t\t}\n \t    }\n \t  else if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t    {\n-\t      *total = ix86_cost->lea;\n-\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n-\t      *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code);\n-\t      *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t      *total = cost->lea;\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code, speed);\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 1), outer_code, speed);\n+\t      *total += rtx_cost (XEXP (x, 1), outer_code, speed);\n \t      return true;\n \t    }\n \t}\n@@ -25483,18 +25484,18 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t{\n \t  /* ??? SSE cost should be used here.  */\n-\t  *total = ix86_cost->fadd;\n+\t  *total = cost->fadd;\n \t  return false;\n \t}\n       else if (X87_FLOAT_MODE_P (mode))\n \t{\n-\t  *total = ix86_cost->fadd;\n+\t  *total = cost->fadd;\n \t  return false;\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n \t  /* ??? SSE vector cost should be used here.  */\n-\t  *total = ix86_cost->fadd;\n+\t  *total = cost->fadd;\n \t  return false;\n \t}\n       /* FALLTHRU */\n@@ -25504,10 +25505,10 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n     case XOR:\n       if (!TARGET_64BIT && mode == DImode)\n \t{\n-\t  *total = (ix86_cost->add * 2\n-\t\t    + (rtx_cost (XEXP (x, 0), outer_code)\n+\t  *total = (cost->add * 2\n+\t\t    + (rtx_cost (XEXP (x, 0), outer_code, speed)\n \t\t       << (GET_MODE (XEXP (x, 0)) != DImode))\n-\t\t    + (rtx_cost (XEXP (x, 1), outer_code)\n+\t\t    + (rtx_cost (XEXP (x, 1), outer_code, speed)\n \t               << (GET_MODE (XEXP (x, 1)) != DImode)));\n \t  return true;\n \t}\n@@ -25517,27 +25518,27 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t{\n \t  /* ??? SSE cost should be used here.  */\n-\t  *total = ix86_cost->fchs;\n+\t  *total = cost->fchs;\n \t  return false;\n \t}\n       else if (X87_FLOAT_MODE_P (mode))\n \t{\n-\t  *total = ix86_cost->fchs;\n+\t  *total = cost->fchs;\n \t  return false;\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n \t  /* ??? SSE vector cost should be used here.  */\n-\t  *total = ix86_cost->fchs;\n+\t  *total = cost->fchs;\n \t  return false;\n \t}\n       /* FALLTHRU */\n \n     case NOT:\n       if (!TARGET_64BIT && mode == DImode)\n-\t*total = ix86_cost->add * 2;\n+\t*total = cost->add * 2;\n       else\n-\t*total = ix86_cost->add;\n+\t*total = cost->add;\n       return false;\n \n     case COMPARE:\n@@ -25548,9 +25549,9 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n \t{\n \t  /* This kind of construct is implemented using test[bwl].\n \t     Treat it as if we had an AND.  */\n-\t  *total = (ix86_cost->add\n-\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), outer_code)\n-\t\t    + rtx_cost (const1_rtx, outer_code));\n+\t  *total = (cost->add\n+\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), outer_code, speed)\n+\t\t    + rtx_cost (const1_rtx, outer_code, speed));\n \t  return true;\n \t}\n       return false;\n@@ -25563,23 +25564,23 @@ ix86_rtx_costs (rtx x, int code, int outer_code_i, int *total)\n     case ABS:\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t/* ??? SSE cost should be used here.  */\n-\t*total = ix86_cost->fabs;\n+\t*total = cost->fabs;\n       else if (X87_FLOAT_MODE_P (mode))\n-\t*total = ix86_cost->fabs;\n+\t*total = cost->fabs;\n       else if (FLOAT_MODE_P (mode))\n \t/* ??? SSE vector cost should be used here.  */\n-\t*total = ix86_cost->fabs;\n+\t*total = cost->fabs;\n       return false;\n \n     case SQRT:\n       if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t/* ??? SSE cost should be used here.  */\n-\t*total = ix86_cost->fsqrt;\n+\t*total = cost->fsqrt;\n       else if (X87_FLOAT_MODE_P (mode))\n-\t*total = ix86_cost->fsqrt;\n+\t*total = cost->fsqrt;\n       else if (FLOAT_MODE_P (mode))\n \t/* ??? SSE vector cost should be used here.  */\n-\t*total = ix86_cost->fsqrt;\n+\t*total = cost->fsqrt;\n       return false;\n \n     case UNSPEC:"}, {"sha": "c16ecc7e3c3221059d9b159b5aafb451e3ed715b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -202,7 +202,7 @@ static int ia64_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t   tree, bool);\n static bool ia64_function_ok_for_sibcall (tree, tree);\n static bool ia64_return_in_memory (const_tree, const_tree);\n-static bool ia64_rtx_costs (rtx, int, int, int *);\n+static bool ia64_rtx_costs (rtx, int, int, int *, bool);\n static int ia64_unspec_may_trap_p (const_rtx, unsigned);\n static void fix_range (const char *);\n static bool ia64_handle_option (size_t, const char *, int);\n@@ -4810,7 +4810,8 @@ ia64_print_operand (FILE * file, rtx x, int code)\n /* ??? This is incomplete.  */\n \n static bool\n-ia64_rtx_costs (rtx x, int code, int outer_code, int *total)\n+ia64_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "a716e7295320c4cacd7932d3ed344707122bc202", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -161,8 +161,8 @@ static bool iq2000_return_in_memory   (const_tree, const_tree);\n static void iq2000_setup_incoming_varargs (CUMULATIVE_ARGS *,\n \t\t\t\t\t   enum machine_mode, tree, int *,\n \t\t\t\t\t   int);\n-static bool iq2000_rtx_costs          (rtx, int, int, int *);\n-static int  iq2000_address_cost       (rtx);\n+static bool iq2000_rtx_costs          (rtx, int, int, int *, bool);\n+static int  iq2000_address_cost       (rtx, bool);\n static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n@@ -744,7 +744,7 @@ iq2000_move_1word (rtx operands[], rtx insn, int unsignedp)\n /* Provide the costs of an addressing mode that contains ADDR.  */\n \n static int\n-iq2000_address_cost (rtx addr)\n+iq2000_address_cost (rtx addr, bool speec ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -3203,7 +3203,7 @@ print_operand (FILE *file, rtx op, int letter)\n }\n \n static bool\n-iq2000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int * total)\n+iq2000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int * total, bool speed)\n {\n   enum machine_mode mode = GET_MODE (x);\n "}, {"sha": "3fda87bcf0f5bd1c594c81e3f5a597e33dd242c6", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -2119,7 +2119,8 @@ m32c_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m32c_rtx_costs\n static bool\n-m32c_rtx_costs (rtx x, int code, int outer_code, int *total)\n+m32c_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -2198,7 +2199,7 @@ m32c_rtx_costs (rtx x, int code, int outer_code, int *total)\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST m32c_address_cost\n static int\n-m32c_address_cost (rtx addr)\n+m32c_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   int i;\n   /*  fprintf(stderr, \"\\naddress_cost\\n\");"}, {"sha": "790eeef12328e631c5b87789273c416f7ec4d1d5", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -85,7 +85,7 @@ static bool m32r_return_in_memory (const_tree, const_tree);\n static void m32r_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static void init_idents (void);\n-static bool m32r_rtx_costs (rtx, int, int, int *);\n+static bool m32r_rtx_costs (rtx, int, int, int *, bool speed);\n static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n static int m32r_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -126,7 +126,7 @@ static int m32r_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n #undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m32r_rtx_costs\n #undef  TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef  TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n@@ -1092,7 +1092,8 @@ m32r_issue_rate (void)\n /* Cost functions.  */\n \n static bool\n-m32r_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n+m32r_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "b19f1e7c4b8f875db69ba9baf5ef09f5a6ab14d2", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -67,10 +67,10 @@ static void m68hc11_reorg (void);\n static int go_if_legitimate_address_internal (rtx, enum machine_mode, int);\n static rtx m68hc11_expand_compare (enum rtx_code, rtx, rtx);\n static int must_parenthesize (rtx);\n-static int m68hc11_address_cost (rtx);\n+static int m68hc11_address_cost (rtx, bool);\n static int m68hc11_shift_cost (enum machine_mode, rtx, int);\n static int m68hc11_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n-static bool m68hc11_rtx_costs (rtx, int, int, int *);\n+static bool m68hc11_rtx_costs (rtx, int, int, int *, bool);\n static tree m68hc11_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n const struct attribute_spec m68hc11_attribute_table[];\n \n@@ -5145,7 +5145,7 @@ m68hc11_register_move_cost (enum machine_mode mode, enum reg_class from,\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n static int\n-m68hc11_address_cost (rtx addr)\n+m68hc11_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   int cost = 4;\n \n@@ -5230,7 +5230,7 @@ m68hc11_shift_cost (enum machine_mode mode, rtx x, int shift)\n {\n   int total;\n \n-  total = rtx_cost (x, SET);\n+  total = rtx_cost (x, SET, !optimize_size);\n   if (mode == QImode)\n     total += m68hc11_cost->shiftQI_const[shift % 8];\n   else if (mode == HImode)\n@@ -5274,14 +5274,14 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n           return m68hc11_shift_cost (mode, XEXP (x, 0), INTVAL (XEXP (x, 1)));\n \t}\n \n-      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total = rtx_cost (XEXP (x, 0), code, !optimize_size) + rtx_cost (XEXP (x, 1), code, !optimize_size);\n       total += m68hc11_cost->shift_var;\n       return total;\n \n     case AND:\n     case XOR:\n     case IOR:\n-      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total = rtx_cost (XEXP (x, 0), code, !optimize_size) + rtx_cost (XEXP (x, 1), code, !optimize_size);\n       total += m68hc11_cost->logical;\n \n       /* Logical instructions are byte instructions only.  */\n@@ -5290,7 +5290,7 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n \n     case MINUS:\n     case PLUS:\n-      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total = rtx_cost (XEXP (x, 0), code, !optimize_size) + rtx_cost (XEXP (x, 1), code, !optimize_size);\n       total += m68hc11_cost->add;\n       if (GET_MODE_SIZE (mode) > 2)\n \t{\n@@ -5301,7 +5301,7 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n     case UDIV:\n     case DIV:\n     case MOD:\n-      total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n+      total = rtx_cost (XEXP (x, 0), code, !optimize_size) + rtx_cost (XEXP (x, 1), code, !optimize_size);\n       switch (mode)\n         {\n         case QImode:\n@@ -5324,16 +5324,16 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n       if (mode == HImode && GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n           && GET_CODE (XEXP (x, 1)) == ZERO_EXTEND)\n         return m68hc11_cost->multQI\n-          + rtx_cost (XEXP (XEXP (x, 0), 0), code)\n-          + rtx_cost (XEXP (XEXP (x, 1), 0), code);\n+          + rtx_cost (XEXP (XEXP (x, 0), 0), code, !optimize_size)\n+          + rtx_cost (XEXP (XEXP (x, 1), 0), code, !optimize_size);\n \n       /* emul instruction produces 32-bit result for 68HC12.  */\n       if (TARGET_M6812 && mode == SImode\n           && GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n           && GET_CODE (XEXP (x, 1)) == ZERO_EXTEND)\n         return m68hc11_cost->multHI\n-          + rtx_cost (XEXP (XEXP (x, 0), 0), code)\n-          + rtx_cost (XEXP (XEXP (x, 1), 0), code);\n+          + rtx_cost (XEXP (XEXP (x, 0), 0), code, !optimize_size)\n+          + rtx_cost (XEXP (XEXP (x, 1), 0), code, !optimize_size);\n \n       total = rtx_cost (XEXP (x, 0), code) + rtx_cost (XEXP (x, 1), code);\n       switch (mode)\n@@ -5362,7 +5362,7 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n     case COMPARE:\n     case ABS:\n     case ZERO_EXTEND:\n-      total = extra_cost + rtx_cost (XEXP (x, 0), code);\n+      total = extra_cost + rtx_cost (XEXP (x, 0), code, !optimize_size);\n       if (mode == QImode)\n \t{\n \t  return total + COSTS_N_INSNS (1);\n@@ -5389,7 +5389,8 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n }\n \n static bool\n-m68hc11_rtx_costs (rtx x, int code, int outer_code, int *total)\n+m68hc11_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t   bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "46647ea9b972618047138a6326498e86e9cf0d4c", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -146,7 +146,7 @@ static tree m68k_handle_fndecl_attribute (tree *node, tree name,\n static void m68k_compute_frame_layout (void);\n static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static bool m68k_ok_for_sibcall_p (tree, tree);\n-static bool m68k_rtx_costs (rtx, int, int, int *);\n+static bool m68k_rtx_costs (rtx, int, int, int *, bool);\n #if M68K_HONOR_TARGET_STRICT_ALIGNMENT\n static bool m68k_return_in_memory (const_tree, const_tree);\n #endif\n@@ -2205,7 +2205,8 @@ const_int_cost (HOST_WIDE_INT i)\n }\n \n static bool\n-m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n+m68k_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "229b32eab6db6ff4e06fbbad8b776790f4270302", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -182,7 +182,7 @@ static int        mcore_arg_partial_bytes       (CUMULATIVE_ARGS *,\n #undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS \t\tmcore_rtx_costs\n #undef  TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST \t\thook_int_rtx_0\n+#define TARGET_ADDRESS_COST \t\thook_int_rtx_bool_0\n #undef  TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG\tmcore_reorg\n \n@@ -479,7 +479,8 @@ mcore_ior_cost (rtx x)\n }\n \n static bool\n-mcore_rtx_costs (rtx x, int code, int outer_code, int * total)\n+mcore_rtx_costs (rtx x, int code, int outer_code, int * total,\n+\t\t bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "dea7ffe57fabeb9ba1fd1f6e070a50ea84f506e1", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -3225,8 +3225,8 @@ mips_binary_cost (rtx x, int single_cost, int double_cost)\n   else\n     cost = single_cost;\n   return (cost\n-\t  + rtx_cost (XEXP (x, 0), 0)\n-\t  + rtx_cost (XEXP (x, 1), GET_CODE (x)));\n+\t  + rtx_cost (XEXP (x, 0), 0, !optimize_size)\n+\t  + rtx_cost (XEXP (x, 1), GET_CODE (x), !optimize_size));\n }\n \n /* Return the cost of floating-point multiplications of mode MODE.  */\n@@ -3296,7 +3296,8 @@ mips_zero_extend_cost (enum machine_mode mode, rtx op)\n /* Implement TARGET_RTX_COSTS.  */\n \n static bool\n-mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n+mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed)\n {\n   enum machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n@@ -3443,7 +3444,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  && UINTVAL (XEXP (x, 1)) == 0xffffffff)\n \t{\n \t  *total = (mips_zero_extend_cost (mode, XEXP (x, 0))\n-\t\t    + rtx_cost (XEXP (x, 0), 0));\n+\t\t    + rtx_cost (XEXP (x, 0), 0, speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -3475,7 +3476,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case LO_SUM:\n       /* Low-part immediates need an extended MIPS16 instruction.  */\n       *total = (COSTS_N_INSNS (TARGET_MIPS16 ? 2 : 1)\n-\t\t+ rtx_cost (XEXP (x, 0), 0));\n+\t\t+ rtx_cost (XEXP (x, 0), 0, speed));\n       return true;\n \n     case LT:\n@@ -3515,17 +3516,17 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  if (GET_CODE (op0) == MULT && GET_CODE (XEXP (op0, 0)) == NEG)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op0, 0), 0), 0)\n-\t\t\t+ rtx_cost (XEXP (op0, 1), 0)\n-\t\t\t+ rtx_cost (op1, 0));\n+\t\t\t+ rtx_cost (XEXP (XEXP (op0, 0), 0), 0, speed)\n+\t\t\t+ rtx_cost (XEXP (op0, 1), 0, speed)\n+\t\t\t+ rtx_cost (op1, 0, speed));\n \t      return true;\n \t    }\n \t  if (GET_CODE (op1) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (op0, 0)\n-\t\t\t+ rtx_cost (XEXP (op1, 0), 0)\n-\t\t\t+ rtx_cost (XEXP (op1, 1), 0));\n+\t\t\t+ rtx_cost (op0, 0, speed)\n+\t\t\t+ rtx_cost (XEXP (op1, 0), 0, speed)\n+\t\t\t+ rtx_cost (XEXP (op1, 1), 0, speed));\n \t      return true;\n \t    }\n \t}\n@@ -3566,9 +3567,9 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      && GET_CODE (XEXP (op, 0)) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 0), 0)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 1), 0)\n-\t\t\t+ rtx_cost (XEXP (op, 1), 0));\n+\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 0), 0, speed)\n+\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 1), 0, speed)\n+\t\t\t+ rtx_cost (XEXP (op, 1), 0, speed));\n \t      return true;\n \t    }\n \t}\n@@ -3606,9 +3607,9 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  if (outer_code == SQRT || GET_CODE (XEXP (x, 1)) == SQRT)\n \t    /* An rsqrt<mode>a or rsqrt<mode>b pattern.  Count the\n \t       division as being free.  */\n-\t    *total = rtx_cost (XEXP (x, 1), 0);\n+\t    *total = rtx_cost (XEXP (x, 1), 0, speed);\n \t  else\n-\t    *total = mips_fp_div_cost (mode) + rtx_cost (XEXP (x, 1), 0);\n+\t    *total = mips_fp_div_cost (mode) + rtx_cost (XEXP (x, 1), 0, speed);\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -3636,7 +3637,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      && CONST_INT_P (XEXP (x, 1))\n \t      && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t    {\n-\t      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), 0);\n+\t      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), 0, speed);\n \t      return true;\n \t    }\n \t  *total = COSTS_N_INSNS (mips_idiv_insns ());\n@@ -3671,7 +3672,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n /* Implement TARGET_ADDRESS_COST.  */\n \n static int\n-mips_address_cost (rtx addr)\n+mips_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   return mips_address_insns (addr, SImode, false);\n }"}, {"sha": "53cb8f6007f0e3e4fd823c8debf2fea8d051e33c", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -132,7 +132,7 @@ static void mmix_setup_incoming_varargs\n   (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n static void mmix_file_start (void);\n static void mmix_file_end (void);\n-static bool mmix_rtx_costs (rtx, int, int, int *);\n+static bool mmix_rtx_costs (rtx, int, int, int *, bool);\n static rtx mmix_struct_value_rtx (tree, int);\n static bool mmix_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, const_tree, bool);\n@@ -181,7 +181,7 @@ static bool mmix_pass_by_reference (CUMULATIVE_ARGS *,\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS mmix_rtx_costs\n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG mmix_reorg\n@@ -1106,7 +1106,8 @@ static bool\n mmix_rtx_costs (rtx x ATTRIBUTE_UNUSED,\n \t\tint code ATTRIBUTE_UNUSED,\n \t\tint outer_code ATTRIBUTE_UNUSED,\n-\t\tint *total ATTRIBUTE_UNUSED)\n+\t\tint *total ATTRIBUTE_UNUSED,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   /* For the time being, this is just a stub and we'll accept the\n      generic calculations, until we can do measurements, at least."}, {"sha": "277497075b1c8e473d23e877b3e943d64b82b3e6", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -70,8 +70,8 @@ enum processor_type mn10300_processor = PROCESSOR_DEFAULT;\n \n static bool mn10300_handle_option (size_t, const char *, int);\n static int mn10300_address_cost_1 (rtx, int *);\n-static int mn10300_address_cost (rtx);\n-static bool mn10300_rtx_costs (rtx, int, int, int *);\n+static int mn10300_address_cost (rtx, bool);\n+static bool mn10300_rtx_costs (rtx, int, int, int *, bool);\n static void mn10300_file_start (void);\n static bool mn10300_return_in_memory (const_tree, const_tree);\n static rtx mn10300_builtin_saveregs (void);\n@@ -1942,7 +1942,7 @@ legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n }\n \n static int\n-mn10300_address_cost_1 (rtx x, int *unsig)\n+mn10300_address_cost_1 (rtx x, int *unsig, bool speed ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2008,14 +2008,14 @@ mn10300_address_cost_1 (rtx x, int *unsig)\n }\n \n static int\n-mn10300_address_cost (rtx x)\n+mn10300_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   int s = 0;\n   return mn10300_address_cost_1 (x, &s);\n }\n \n static bool\n-mn10300_rtx_costs (rtx x, int code, int outer_code, int *total)\n+mn10300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "c9c6525c91d4bbc32b023e8c43761dcc341ae3b2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -86,8 +86,8 @@ hppa_fpstore_bypass_p (rtx out_insn, rtx in_insn)\n static void copy_reg_pointer (rtx, rtx);\n static void fix_range (const char *);\n static bool pa_handle_option (size_t, const char *, int);\n-static int hppa_address_cost (rtx);\n-static bool hppa_rtx_costs (rtx, int, int, int *);\n+static int hppa_address_cost (rtx, bool);\n+static bool hppa_rtx_costs (rtx, int, int, int *, bool);\n static inline rtx force_mode (enum machine_mode, rtx);\n static void pa_reorg (void);\n static void pa_combine_instructions (void);\n@@ -1279,7 +1279,8 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n    as GO_IF_LEGITIMATE_ADDRESS.  */\n \n static int\n-hppa_address_cost (rtx X)\n+hppa_address_cost (rtx X,\n+\t\t   bool speed ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (X))\n     {\n@@ -1299,7 +1300,8 @@ hppa_address_cost (rtx X)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-hppa_rtx_costs (rtx x, int code, int outer_code, int *total)\n+hppa_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "52167974c81623102fdf8716536ae896fcbcc9a4", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -149,7 +149,7 @@ static const char *singlemove_string (rtx *);\n static bool pdp11_assemble_integer (rtx, unsigned int, int);\n static void pdp11_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void pdp11_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static bool pdp11_rtx_costs (rtx, int, int, int *);\n+static bool pdp11_rtx_costs (rtx, int, int, int *, bool);\n static bool pdp11_return_in_memory (const_tree, const_tree);\n \f\n /* Initialize the GCC target structure.  */\n@@ -1094,7 +1094,8 @@ register_move_cost(enum reg_class c1, enum reg_class c2)\n }\n \n static bool\n-pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n+pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n+\t\t bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "e2743edce294f8a07b017f544a827e57ac0c5fdc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -829,7 +829,7 @@ static void rs6000_xcoff_file_start (void);\n static void rs6000_xcoff_file_end (void);\n #endif\n static int rs6000_variable_issue (FILE *, int, rtx, int);\n-static bool rs6000_rtx_costs (rtx, int, int, int *);\n+static bool rs6000_rtx_costs (rtx, int, int, int *, bool);\n static int rs6000_adjust_cost (rtx, rtx, rtx, int);\n static void rs6000_sched_init (FILE *, int, int);\n static bool is_microcoded_insn (rtx);\n@@ -1180,7 +1180,7 @@ static const char alt_reg_names[][8] =\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS rs6000_rtx_costs\n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef TARGET_VECTOR_OPAQUE_P\n #define TARGET_VECTOR_OPAQUE_P rs6000_is_opaque_type\n@@ -21456,7 +21456,8 @@ rs6000_xcoff_file_end (void)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n+rs6000_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t  bool speed)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n@@ -21555,7 +21556,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n       /* When optimizing for size, MEM should be slightly more expensive\n \t than generating address, e.g., (plus (reg) (const)).\n \t L1 cache latency is about two instructions.  */\n-      *total = optimize_size ? COSTS_N_INSNS (1) + 1 : COSTS_N_INSNS (2);\n+      *total = !speed ? COSTS_N_INSNS (1) + 1 : COSTS_N_INSNS (2);\n       return true;\n \n     case LABEL_REF:\n@@ -21766,7 +21767,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case CALL:\n     case IF_THEN_ELSE:\n-      if (optimize_size)\n+      if (!speed)\n \t{\n \t  *total = COSTS_N_INSNS (1);\n \t  return true;"}, {"sha": "d15ed2af14e6644184b0c17ce71025f3f6528ac4", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -2298,7 +2298,8 @@ s390_float_const_zero_p (rtx value)\n    of the superexpression of x.  */\n \n static bool\n-s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n+s390_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\tbool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -2336,9 +2337,9 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t    *total = s390_cost->madbr;\n \t  else\n \t    *total = s390_cost->maebr;\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), MULT) \n-\t    + rtx_cost (XEXP (XEXP (x, 0), 1), MULT) \n-\t    + rtx_cost (XEXP (x, 1), code);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), MULT, speed) \n+\t    + rtx_cost (XEXP (XEXP (x, 0), 1), MULT, speed) \n+\t    + rtx_cost (XEXP (x, 1), code, speed);\n \t  return true;  /* Do not do an additional recursive descent.  */\n \t}\n       *total = COSTS_N_INSNS (1);\n@@ -2492,7 +2493,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n /* Return the cost of an address rtx ADDR.  */\n \n static int\n-s390_address_cost (rtx addr)\n+s390_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   struct s390_address ad;\n   if (!s390_decompose_address (addr, &ad))"}, {"sha": "4c7963ffb2fbf101eabe1c0ecbd335bec82f9487", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -85,7 +85,7 @@ extern const char * score_select (rtx *ops, const char *inst_pre, bool commu,\n extern const char * score_output_casesi (rtx *operands);\n extern const char * score_rpush (rtx *ops);\n extern const char * score_rpop (rtx *ops);\n-extern bool score_rtx_costs (rtx x, int code, int outer_code, int *total);\n+extern bool score_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed);\n \n #ifdef RTX_CODE\n extern enum machine_mode score_select_cc_mode (enum rtx_code op, rtx x, rtx y);"}, {"sha": "861e5ba37c40d88cba556e37c68e608c0db98c1f", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -569,7 +569,8 @@ score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n /* Implement TARGET_RTX_COSTS macro.  */\n bool\n-score_rtx_costs (rtx x, int code, int outer_code, int *total)\n+score_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t bool speed ATTRIBUTE_UNUSED)\n {\n   if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_rtx_costs (x, code, outer_code, total);\n@@ -581,7 +582,8 @@ score_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n /* Implement TARGET_ADDRESS_COST macro.  */\n int\n-score_address_cost (rtx addr)\n+score_address_cost (rtx addr,\n+\t\t    bool speed ATTRIBUTE_UNUSED)\n {\n   if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_address_cost (addr);"}, {"sha": "3392c417c5ca32c3b5fce2fe68192df109dfb05a", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1000,7 +1000,8 @@ score3_address_insns (rtx x, enum machine_mode mode)\n \n /* Implement TARGET_RTX_COSTS macro.  */\n bool\n-score3_rtx_costs (rtx x, int code, int outer_code, int *total)\n+score3_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t  bool speed ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n@@ -1154,7 +1155,7 @@ score3_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n /* Implement TARGET_ADDRESS_COST macro.  */\n int\n-score3_address_cost (rtx addr)\n+score3_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n {\n   return score3_address_insns (addr, SImode);\n }"}, {"sha": "2585df9cfa206885e4b0ce970b46a45f38867bbf", "filename": "gcc/config/score/score3.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -126,7 +126,7 @@ extern int score3_address_p (enum machine_mode mode, rtx x, int strict);\n extern int score3_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                                       enum reg_class from,\n                                       enum reg_class to);\n-extern bool score3_rtx_costs (rtx x, int code, int outer_code, int *total);\n+extern bool score3_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed);\n extern int score3_address_cost (rtx addr);\n extern int score3_output_external (FILE *file ATTRIBUTE_UNUSED,\n                                    tree decl,"}, {"sha": "52234fd270c7ffd21ee9234d4a76e90364735c97", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -991,7 +991,8 @@ score7_address_insns (rtx x, enum machine_mode mode)\n \n /* Implement TARGET_RTX_COSTS macro.  */\n bool\n-score7_rtx_costs (rtx x, int code, int outer_code, int *total)\n+score7_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t  bool speed ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n@@ -1145,7 +1146,8 @@ score7_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n /* Implement TARGET_ADDRESS_COST macro.  */\n int\n-score7_address_cost (rtx addr)\n+score7_address_cost (rtx addr,\n+\t\t     bool speed ATTRIBUTE_UNUSED)\n {\n   return score7_address_insns (addr, SImode);\n }"}, {"sha": "ab2c7b0af88bb7fe330249dfaebf15a0b1dd8e69", "filename": "gcc/config/score/score7.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -126,7 +126,7 @@ extern int score7_address_p (enum machine_mode mode, rtx x, int strict);\n extern int score7_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                                       enum reg_class from,\n                                       enum reg_class to);\n-extern bool score7_rtx_costs (rtx x, int code, int outer_code, int *total);\n+extern bool score7_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed);\n extern int score7_address_cost (rtx addr);\n extern int score7_output_external (FILE *file ATTRIBUTE_UNUSED,\n                                    tree decl,"}, {"sha": "fdd98937f8c494fc6e9522d8431c7a0ebfc5c627", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -241,8 +241,8 @@ static int addsubcosts (rtx);\n static int multcosts (rtx);\n static bool unspec_caller_rtx_p (rtx);\n static bool sh_cannot_copy_insn_p (rtx);\n-static bool sh_rtx_costs (rtx, int, int, int *);\n-static int sh_address_cost (rtx);\n+static bool sh_rtx_costs (rtx, int, int, int *, bool);\n+static int sh_address_cost (rtx, bool);\n static int sh_pr_n_sets (void);\n static rtx sh_allocate_initial_value (rtx);\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n@@ -2361,7 +2361,7 @@ andcosts (rtx x)\n \t  || satisfies_constraint_J16 (XEXP (x, 1)))\n \treturn 1;\n       else\n-\treturn 1 + rtx_cost (XEXP (x, 1), AND);\n+\treturn 1 + rtx_cost (XEXP (x, 1), AND, !optimize_size);\n     }\n \n   /* These constants are single cycle extu.[bw] instructions.  */\n@@ -2461,7 +2461,8 @@ multcosts (rtx x ATTRIBUTE_UNUSED)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n+sh_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t      bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -2587,7 +2588,8 @@ sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n    since it increases pressure on r0.  */\n \n static int\n-sh_address_cost (rtx X)\n+sh_address_cost (rtx X,\n+\t         bool speed ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (X) == PLUS\n \t  && ! CONSTANT_P (XEXP (X, 1))"}, {"sha": "0852cd94e7961530b6ee33cfa1cd83f9772f3e7c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -404,7 +404,7 @@ static rtx sparc_tls_get_addr (void);\n static rtx sparc_tls_got (void);\n static const char *get_some_local_dynamic_name (void);\n static int get_some_local_dynamic_name_1 (rtx *, void *);\n-static bool sparc_rtx_costs (rtx, int, int, int *);\n+static bool sparc_rtx_costs (rtx, int, int, int *, bool);\n static bool sparc_promote_prototypes (const_tree);\n static rtx sparc_struct_value_rtx (tree, int);\n static bool sparc_return_in_memory (const_tree, const_tree);\n@@ -513,7 +513,7 @@ static bool fpu_option_set = false;\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS sparc_rtx_costs\n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n /* This is only needed for TARGET_ARCH64, but since PROMOTE_FUNCTION_MODE is a\n    no-op for TARGET_ARCH32 this is ok.  Otherwise we'd need to add a runtime\n@@ -8401,7 +8401,8 @@ sparc_extra_constraint_check (rtx op, int c, int strict)\n    ??? the latencies and then CSE will just use that.  */\n \n static bool\n-sparc_rtx_costs (rtx x, int code, int outer_code, int *total)\n+sparc_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t bool speed ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);"}, {"sha": "e22513ffd8a1ff3088397c61c837244aff046ada", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -208,7 +208,7 @@ tree spu_builtin_types[SPU_BTI_MAX];\n #define TARGET_RTX_COSTS spu_rtx_costs\n \n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE spu_sched_issue_rate\n@@ -4209,7 +4209,8 @@ spu_asm_globalize_label (FILE * file, const char *name)\n }\n \n static bool\n-spu_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n+spu_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n+\t       bool speed ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (x);\n   int cost = COSTS_N_INSNS (2);"}, {"sha": "dd42fc833d06a19de4ac6184daae06279be5b0a0", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -57,8 +57,8 @@ static void xstormy16_asm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \n static void xstormy16_init_builtins (void);\n static rtx xstormy16_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-static bool xstormy16_rtx_costs (rtx, int, int, int *);\n-static int xstormy16_address_cost (rtx);\n+static bool xstormy16_rtx_costs (rtx, int, int, int *, bool);\n+static int xstormy16_address_cost (rtx, bool);\n static bool xstormy16_return_in_memory (const_tree, const_tree);\n \n /* Define the information needed to generate branch and scc insns.  This is\n@@ -74,7 +74,7 @@ static GTY(()) section *bss100_section;\n \n static bool\n xstormy16_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n-\t\t     int *total)\n+\t\t     int *total, bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -107,7 +107,7 @@ xstormy16_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n }\n \n static int\n-xstormy16_address_cost (rtx x)\n+xstormy16_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (x) == CONST_INT ? 2\n \t  : GET_CODE (x) == PLUS ? 7"}, {"sha": "d46197976963501985c112bd471ebf84ef6b194b", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -137,7 +137,7 @@ static GTY(()) section *zbss_section;\n #define TARGET_RTX_COSTS v850_rtx_costs\n \n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG v850_reorg\n@@ -422,7 +422,7 @@ static bool\n v850_rtx_costs (rtx x,\n                 int code,\n                 int outer_code ATTRIBUTE_UNUSED,\n-                int * total)\n+                int * total, bool speed)\n {\n   switch (code)\n     {\n@@ -438,7 +438,7 @@ v850_rtx_costs (rtx x,\n     case DIV:\n     case UMOD:\n     case UDIV:\n-      if (TARGET_V850E && optimize_size)\n+      if (TARGET_V850E && !speed)\n         *total = 6;\n       else\n \t*total = 60;"}, {"sha": "173799ebc65cb79272c002732af7329341f9c0c4", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -49,8 +49,8 @@ static void vax_init_libfuncs (void);\n static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, tree);\n static int vax_address_cost_1 (rtx);\n-static int vax_address_cost (rtx);\n-static bool vax_rtx_costs (rtx, int, int, int *);\n+static int vax_address_cost (rtx, bool);\n+static bool vax_rtx_costs (rtx, int, int, int *, bool);\n static rtx vax_struct_value_rtx (tree, int);\n \f\n /* Initialize the GCC target structure.  */\n@@ -520,7 +520,7 @@ vax_address_cost_1 (rtx addr)\n }\n \n static int\n-vax_address_cost (rtx x)\n+vax_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   return (1 + (REG_P (x) ? 0 : vax_address_cost_1 (x)));\n }\n@@ -534,7 +534,8 @@ vax_address_cost (rtx x)\n    costs on a per cpu basis.  */\n \n static bool\n-vax_rtx_costs (rtx x, int code, int outer_code, int *total)\n+vax_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t       bool speed ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = GET_MODE (x);\n   int i = 0;\t\t\t\t   /* may be modified in switch */"}, {"sha": "3bb71eb5c1308414aa4870fb07de93f8b07bd2b9", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -139,7 +139,7 @@ static unsigned int xtensa_multibss_section_type_flags (tree, const char *,\n \t\t\t\t\t\t\tint) ATTRIBUTE_UNUSED;\n static section *xtensa_select_rtx_section (enum machine_mode, rtx,\n \t\t\t\t\t   unsigned HOST_WIDE_INT);\n-static bool xtensa_rtx_costs (rtx, int, int, int *);\n+static bool xtensa_rtx_costs (rtx, int, int, int *, bool);\n static tree xtensa_build_builtin_va_list (void);\n static bool xtensa_return_in_memory (const_tree, const_tree);\n static tree xtensa_gimplify_va_arg_expr (tree, tree, gimple_seq *,\n@@ -177,7 +177,7 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS xtensa_rtx_costs\n #undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST xtensa_build_builtin_va_list\n@@ -2947,7 +2947,8 @@ xtensa_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-xtensa_rtx_costs (rtx x, int code, int outer_code, int *total)\n+xtensa_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t  bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {"}, {"sha": "d586c6c26df56f9e4fbff8fad88d8df853218ad7", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -283,6 +283,7 @@ static enum machine_mode this_insn_cc0_mode, prev_insn_cc0_mode;\n /* Insn being scanned.  */\n \n static rtx this_insn;\n+static bool optimize_this_for_speed_p;\n \n /* Index by register number, gives the number of the next (or\n    previous) register in the chain of registers sharing the same\n@@ -752,7 +753,7 @@ notreg_cost (rtx x, enum rtx_code outer)\n \t   && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE (x)),\n \t\t\t\t     GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))))\n \t  ? 0\n-\t  : rtx_cost (x, outer) * 2);\n+\t  : rtx_cost (x, outer, optimize_this_for_speed_p) * 2);\n }\n \n \f\n@@ -5970,6 +5971,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n+\t  optimize_this_for_speed_p = optimize_bb_for_speed_p (bb);\n \t  /* If we have processed 1,000 insns, flush the hash table to\n \t     avoid extreme quadratic behavior.  We must not include NOTEs\n \t     in the count since there may be more of them when generating"}, {"sha": "0ff5395293817801e73e24b4df6e46ee62edee9c", "filename": "gcc/dojump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -144,8 +144,8 @@ prefer_and_bit_test (enum machine_mode mode, int bitnum)\n   XEXP (and_test, 1) = GEN_INT ((unsigned HOST_WIDE_INT) 1 << bitnum);\n   XEXP (XEXP (shift_test, 0), 1) = GEN_INT (bitnum);\n \n-  return (rtx_cost (and_test, IF_THEN_ELSE)\n-\t  <= rtx_cost (shift_test, IF_THEN_ELSE));\n+  return (rtx_cost (and_test, IF_THEN_ELSE, optimize_insn_for_speed_p ())\n+\t  <= rtx_cost (shift_test, IF_THEN_ELSE, optimize_insn_for_speed_p ()));\n }\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if"}, {"sha": "7283bbe67e4abf1f5b0315778e44dabec5ab797f", "filename": "gcc/dse.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1424,7 +1424,8 @@ static rtx\n find_shift_sequence (int access_size,\n \t\t     store_info_t store_info,\n \t\t     read_info_t read_info,\n-\t\t     int shift)\n+\t\t     int shift,\n+\t\t     bool speed)\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n@@ -1483,7 +1484,7 @@ find_shift_sequence (int access_size,\n       cost = 0;\n       for (insn = shift_seq; insn != NULL_RTX; insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n-\t  cost += insn_rtx_cost (PATTERN (insn));\n+\t  cost += insn_rtx_cost (PATTERN (insn), speed);\n \n       /* The computation up to here is essentially independent\n \t of the arguments and could be precomputed.  It may\n@@ -1582,7 +1583,8 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t     GET_MODE_NAME (store_mode), INSN_UID (store_insn->insn));\n   start_sequence ();\n   if (shift)\n-    read_reg = find_shift_sequence (access_size, store_info, read_info, shift);\n+    read_reg = find_shift_sequence (access_size, store_info, read_info, shift,\n+    \t\t\t\t    optimize_bb_for_speed_p (BLOCK_FOR_INSN (read_insn->insn)));\n   else\n     read_reg = extract_low_bits (read_mode, store_mode,\n \t\t\t\t copy_rtx (store_info->rhs));"}, {"sha": "d4306f41a812f7673ed4966a4eee7a5a74e79fe3", "filename": "gcc/expmed.c", "status": "modified", "additions": 141, "deletions": 118, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -64,8 +64,8 @@ static rtx expand_sdiv_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n    Usually, this will mean that the MD file will emit non-branch\n    sequences.  */\n \n-static bool sdiv_pow2_cheap[NUM_MACHINE_MODES];\n-static bool smod_pow2_cheap[NUM_MACHINE_MODES];\n+static bool sdiv_pow2_cheap[2][NUM_MACHINE_MODES];\n+static bool smod_pow2_cheap[2][NUM_MACHINE_MODES];\n \n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n@@ -98,17 +98,17 @@ static bool smod_pow2_cheap[NUM_MACHINE_MODES];\n \n /* Cost of various pieces of RTL.  Note that some of these are indexed by\n    shift count and some by mode.  */\n-static int zero_cost;\n-static int add_cost[NUM_MACHINE_MODES];\n-static int neg_cost[NUM_MACHINE_MODES];\n-static int shift_cost[NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-static int shiftadd_cost[NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-static int shiftsub_cost[NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-static int mul_cost[NUM_MACHINE_MODES];\n-static int sdiv_cost[NUM_MACHINE_MODES];\n-static int udiv_cost[NUM_MACHINE_MODES];\n-static int mul_widen_cost[NUM_MACHINE_MODES];\n-static int mul_highpart_cost[NUM_MACHINE_MODES];\n+static int zero_cost[2];\n+static int add_cost[2][NUM_MACHINE_MODES];\n+static int neg_cost[2][NUM_MACHINE_MODES];\n+static int shift_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int shiftadd_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int shiftsub_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int mul_cost[2][NUM_MACHINE_MODES];\n+static int sdiv_cost[2][NUM_MACHINE_MODES];\n+static int udiv_cost[2][NUM_MACHINE_MODES];\n+static int mul_widen_cost[2][NUM_MACHINE_MODES];\n+static int mul_highpart_cost[2][NUM_MACHINE_MODES];\n \n void\n init_expmed (void)\n@@ -137,15 +137,14 @@ init_expmed (void)\n   rtx cint[MAX_BITS_PER_WORD];\n   int m, n;\n   enum machine_mode mode, wider_mode;\n+  int speed;\n \n-  zero_cost = rtx_cost (const0_rtx, 0);\n \n   for (m = 1; m < MAX_BITS_PER_WORD; m++)\n     {\n       pow2[m] = GEN_INT ((HOST_WIDE_INT) 1 << m);\n       cint[m] = GEN_INT (m);\n     }\n-\n   memset (&all, 0, sizeof all);\n \n   PUT_CODE (&all.reg, REG);\n@@ -206,61 +205,71 @@ init_expmed (void)\n   XEXP (&all.shift_sub, 0) = &all.shift_mult;\n   XEXP (&all.shift_sub, 1) = &all.reg;\n \n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n+  for (speed = 0; speed < 2; speed++)\n     {\n-      PUT_MODE (&all.reg, mode);\n-      PUT_MODE (&all.plus, mode);\n-      PUT_MODE (&all.neg, mode);\n-      PUT_MODE (&all.mult, mode);\n-      PUT_MODE (&all.sdiv, mode);\n-      PUT_MODE (&all.udiv, mode);\n-      PUT_MODE (&all.sdiv_32, mode);\n-      PUT_MODE (&all.smod_32, mode);\n-      PUT_MODE (&all.wide_trunc, mode);\n-      PUT_MODE (&all.shift, mode);\n-      PUT_MODE (&all.shift_mult, mode);\n-      PUT_MODE (&all.shift_add, mode);\n-      PUT_MODE (&all.shift_sub, mode);\n-\n-      add_cost[mode] = rtx_cost (&all.plus, SET);\n-      neg_cost[mode] = rtx_cost (&all.neg, SET);\n-      mul_cost[mode] = rtx_cost (&all.mult, SET);\n-      sdiv_cost[mode] = rtx_cost (&all.sdiv, SET);\n-      udiv_cost[mode] = rtx_cost (&all.udiv, SET);\n-\n-      sdiv_pow2_cheap[mode] = (rtx_cost (&all.sdiv_32, SET)\n-\t\t\t       <= 2 * add_cost[mode]);\n-      smod_pow2_cheap[mode] = (rtx_cost (&all.smod_32, SET)\n-\t\t\t       <= 4 * add_cost[mode]);\n-\n-      wider_mode = GET_MODE_WIDER_MODE (mode);\n-      if (wider_mode != VOIDmode)\n-\t{\n-\t  PUT_MODE (&all.zext, wider_mode);\n-\t  PUT_MODE (&all.wide_mult, wider_mode);\n-\t  PUT_MODE (&all.wide_lshr, wider_mode);\n-\t  XEXP (&all.wide_lshr, 1) = GEN_INT (GET_MODE_BITSIZE (mode));\n+      crtl->maybe_hot_insn_p = speed;\n+      zero_cost[speed] = rtx_cost (const0_rtx, 0, speed);\n \n-\t  mul_widen_cost[wider_mode] = rtx_cost (&all.wide_mult, SET);\n-\t  mul_highpart_cost[mode] = rtx_cost (&all.wide_trunc, SET);\n-\t}\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t{\n+\t  PUT_MODE (&all.reg, mode);\n+\t  PUT_MODE (&all.plus, mode);\n+\t  PUT_MODE (&all.neg, mode);\n+\t  PUT_MODE (&all.mult, mode);\n+\t  PUT_MODE (&all.sdiv, mode);\n+\t  PUT_MODE (&all.udiv, mode);\n+\t  PUT_MODE (&all.sdiv_32, mode);\n+\t  PUT_MODE (&all.smod_32, mode);\n+\t  PUT_MODE (&all.wide_trunc, mode);\n+\t  PUT_MODE (&all.shift, mode);\n+\t  PUT_MODE (&all.shift_mult, mode);\n+\t  PUT_MODE (&all.shift_add, mode);\n+\t  PUT_MODE (&all.shift_sub, mode);\n+\n+\t  add_cost[speed][mode] = rtx_cost (&all.plus, SET, speed);\n+\t  neg_cost[speed][mode] = rtx_cost (&all.neg, SET, speed);\n+\t  mul_cost[speed][mode] = rtx_cost (&all.mult, SET, speed);\n+\t  sdiv_cost[speed][mode] = rtx_cost (&all.sdiv, SET, speed);\n+\t  udiv_cost[speed][mode] = rtx_cost (&all.udiv, SET, speed);\n+\n+\t  sdiv_pow2_cheap[speed][mode] = (rtx_cost (&all.sdiv_32, SET, speed)\n+\t\t\t\t          <= 2 * add_cost[speed][mode]);\n+\t  smod_pow2_cheap[speed][mode] = (rtx_cost (&all.smod_32, SET, speed)\n+\t\t\t\t          <= 4 * add_cost[speed][mode]);\n+\n+\t  wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t  if (wider_mode != VOIDmode)\n+\t    {\n+\t      PUT_MODE (&all.zext, wider_mode);\n+\t      PUT_MODE (&all.wide_mult, wider_mode);\n+\t      PUT_MODE (&all.wide_lshr, wider_mode);\n+\t      XEXP (&all.wide_lshr, 1) = GEN_INT (GET_MODE_BITSIZE (mode));\n+\n+\t      mul_widen_cost[speed][wider_mode]\n+\t        = rtx_cost (&all.wide_mult, SET, speed);\n+\t      mul_highpart_cost[speed][mode]\n+\t        = rtx_cost (&all.wide_trunc, SET, speed);\n+\t    }\n \n-      shift_cost[mode][0] = 0;\n-      shiftadd_cost[mode][0] = shiftsub_cost[mode][0] = add_cost[mode];\n+\t  shift_cost[speed][mode][0] = 0;\n+\t  shiftadd_cost[speed][mode][0] = shiftsub_cost[speed][mode][0]\n+\t    = add_cost[speed][mode];\n \n-      n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n-      for (m = 1; m < n; m++)\n-\t{\n-\t  XEXP (&all.shift, 1) = cint[m];\n-\t  XEXP (&all.shift_mult, 1) = pow2[m];\n+\t  n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n+\t  for (m = 1; m < n; m++)\n+\t    {\n+\t      XEXP (&all.shift, 1) = cint[m];\n+\t      XEXP (&all.shift_mult, 1) = pow2[m];\n \n-\t  shift_cost[mode][m] = rtx_cost (&all.shift, SET);\n-\t  shiftadd_cost[mode][m] = rtx_cost (&all.shift_add, SET);\n-\t  shiftsub_cost[mode][m] = rtx_cost (&all.shift_sub, SET);\n+\t      shift_cost[speed][mode][m] = rtx_cost (&all.shift, SET, speed);\n+\t      shiftadd_cost[speed][mode][m] = rtx_cost (&all.shift_add, SET, speed);\n+\t      shiftsub_cost[speed][mode][m] = rtx_cost (&all.shift_sub, SET, speed);\n+\t    }\n \t}\n     }\n+  default_rtl_profile ();\n }\n \n /* Return an rtx representing minus the value of X.\n@@ -2057,6 +2066,7 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   optab rrotate_optab = rotr_optab;\n   enum machine_mode op1_mode;\n   int attempt;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   op1 = expand_normal (amount);\n   op1_mode = GET_MODE (op1);\n@@ -2098,8 +2108,8 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n       && INTVAL (op1) > 0\n       && INTVAL (op1) < GET_MODE_BITSIZE (mode)\n       && INTVAL (op1) < MAX_BITS_PER_WORD\n-      && shift_cost[mode][INTVAL (op1)] > INTVAL (op1) * add_cost[mode]\n-      && shift_cost[mode][INTVAL (op1)] != MAX_COST)\n+      && shift_cost[speed][mode][INTVAL (op1)] > INTVAL (op1) * add_cost[speed][mode]\n+      && shift_cost[speed][mode][INTVAL (op1)] != MAX_COST)\n     {\n       int i;\n       for (i = 0; i < INTVAL (op1); i++)\n@@ -2293,6 +2303,9 @@ struct alg_hash_entry {\n      Otherwise, the cost within which multiplication by T is\n      impossible.  */\n   struct mult_cost cost;\n+ \n+  /* OPtimized for speed? */\n+  bool speed;\n };\n \n /* The number of cache/hash entries.  */\n@@ -2346,6 +2359,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   int hash_index;\n   bool cache_hit = false;\n   enum alg_code cache_alg = alg_zero;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n@@ -2373,13 +2387,13 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n      fail now.  */\n   if (t == 0)\n     {\n-      if (MULT_COST_LESS (cost_limit, zero_cost))\n+      if (MULT_COST_LESS (cost_limit, zero_cost[speed]))\n \treturn;\n       else\n \t{\n \t  alg_out->ops = 1;\n-\t  alg_out->cost.cost = zero_cost;\n-\t  alg_out->cost.latency = zero_cost;\n+\t  alg_out->cost.cost = zero_cost[speed];\n+\t  alg_out->cost.latency = zero_cost[speed];\n \t  alg_out->op[0] = alg_zero;\n \t  return;\n \t}\n@@ -2392,11 +2406,13 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   best_cost = *cost_limit;\n \n   /* Compute the hash index.  */\n-  hash_index = (t ^ (unsigned int) mode) % NUM_ALG_HASH_ENTRIES;\n+  hash_index = (t ^ (unsigned int) mode ^ (speed * 256)) % NUM_ALG_HASH_ENTRIES;\n \n   /* See if we already know what to do for T.  */\n   if (alg_hash[hash_index].t == t\n       && alg_hash[hash_index].mode == mode\n+      && alg_hash[hash_index].mode == mode\n+      && alg_hash[hash_index].speed == speed\n       && alg_hash[hash_index].alg != alg_unknown)\n     {\n       cache_alg = alg_hash[hash_index].alg;\n@@ -2465,10 +2481,10 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  q = t >> m;\n \t  /* The function expand_shift will choose between a shift and\n \t     a sequence of additions, so the observed cost is given as\n-\t     MIN (m * add_cost[mode], shift_cost[mode][m]).  */\n-\t  op_cost = m * add_cost[mode];\n-\t  if (shift_cost[mode][m] < op_cost)\n-\t    op_cost = shift_cost[mode][m];\n+\t     MIN (m * add_cost[speed][mode], shift_cost[speed][mode][m]).  */\n+\t  op_cost = m * add_cost[speed][mode];\n+\t  if (shift_cost[speed][mode][m] < op_cost)\n+\t    op_cost = shift_cost[speed][mode][m];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, q, &new_limit, mode);\n@@ -2509,7 +2525,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n \n-\t  op_cost = add_cost[mode];\n+\t  op_cost = add_cost[speed][mode];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, t + 1, &new_limit, mode);\n@@ -2529,7 +2545,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n \n-\t  op_cost = add_cost[mode];\n+\t  op_cost = add_cost[speed][mode];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, t - 1, &new_limit, mode);\n@@ -2574,14 +2590,14 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t     equal to its cost, otherwise assume that on superscalar\n \t     hardware the shift may be executed concurrently with the\n \t     earlier steps in the algorithm.  */\n-\t  op_cost = add_cost[mode] + shift_cost[mode][m];\n-\t  if (shiftadd_cost[mode][m] < op_cost)\n+\t  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];\n+\t  if (shiftadd_cost[speed][mode][m] < op_cost)\n \t    {\n-\t      op_cost = shiftadd_cost[mode][m];\n+\t      op_cost = shiftadd_cost[speed][mode][m];\n \t      op_latency = op_cost;\n \t    }\n \t  else\n-\t    op_latency = add_cost[mode];\n+\t    op_latency = add_cost[speed][mode];\n \n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_latency;\n@@ -2613,14 +2629,14 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t     equal to it's cost, otherwise assume that on superscalar\n \t     hardware the shift may be executed concurrently with the\n \t     earlier steps in the algorithm.  */\n-\t  op_cost = add_cost[mode] + shift_cost[mode][m];\n-\t  if (shiftsub_cost[mode][m] < op_cost)\n+\t  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];\n+\t  if (shiftsub_cost[speed][mode][m] < op_cost)\n \t    {\n-\t      op_cost = shiftsub_cost[mode][m];\n+\t      op_cost = shiftsub_cost[speed][mode][m];\n \t      op_latency = op_cost;\n \t    }\n \t  else\n-\t    op_latency = add_cost[mode];\n+\t    op_latency = add_cost[speed][mode];\n \n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_latency;\n@@ -2654,7 +2670,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  op_cost = shiftadd_cost[mode][m];\n+\t  op_cost = shiftadd_cost[speed][mode][m];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, (t - 1) >> m, &new_limit, mode);\n@@ -2679,7 +2695,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  op_cost = shiftsub_cost[mode][m];\n+\t  op_cost = shiftsub_cost[speed][mode][m];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, (t + 1) >> m, &new_limit, mode);\n@@ -2710,6 +2726,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t caller.  */\n       alg_hash[hash_index].t = t;\n       alg_hash[hash_index].mode = mode;\n+      alg_hash[hash_index].speed = speed;\n       alg_hash[hash_index].alg = alg_impossible;\n       alg_hash[hash_index].cost = *cost_limit;\n       return;\n@@ -2720,6 +2737,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n     {\n       alg_hash[hash_index].t = t;\n       alg_hash[hash_index].mode = mode;\n+      alg_hash[hash_index].speed = speed;\n       alg_hash[hash_index].alg = best_alg->op[best_alg->ops];\n       alg_hash[hash_index].cost.cost = best_cost.cost;\n       alg_hash[hash_index].cost.latency = best_cost.latency;\n@@ -2759,6 +2777,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n   struct algorithm alg2;\n   struct mult_cost limit;\n   int op_cost;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   /* Fail quickly for impossible bounds.  */\n   if (mult_cost < 0)\n@@ -2767,7 +2786,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n   /* Ensure that mult_cost provides a reasonable upper bound.\n      Any constant multiplication can be performed with less\n      than 2 * bits additions.  */\n-  op_cost = 2 * GET_MODE_BITSIZE (mode) * add_cost[mode];\n+  op_cost = 2 * GET_MODE_BITSIZE (mode) * add_cost[speed][mode];\n   if (mult_cost > op_cost)\n     mult_cost = op_cost;\n \n@@ -2780,7 +2799,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n      `unsigned int' */\n   if (HOST_BITS_PER_INT >= GET_MODE_BITSIZE (mode))\n     {\n-      op_cost = neg_cost[mode];\n+      op_cost = neg_cost[speed][mode];\n       if (MULT_COST_LESS (&alg->cost, mult_cost))\n \t{\n \t  limit.cost = alg->cost.cost - op_cost;\n@@ -2800,7 +2819,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n     }\n \n   /* This proves very useful for division-by-constant.  */\n-  op_cost = add_cost[mode];\n+  op_cost = add_cost[speed][mode];\n   if (MULT_COST_LESS (&alg->cost, mult_cost))\n     {\n       limit.cost = alg->cost.cost - op_cost;\n@@ -2988,6 +3007,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n   enum mult_variant variant;\n   struct algorithm algorithm;\n   int max_cost;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   /* Handling const0_rtx here allows us to use zero as a rogue value for\n      coeff below.  */\n@@ -3029,8 +3049,8 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t result is interpreted as an unsigned coefficient.\n \t\t Exclude cost of op0 from max_cost to match the cost\n \t\t calculation of the synth_mult.  */\n-\t      max_cost = rtx_cost (gen_rtx_MULT (mode, fake_reg, op1), SET)\n-\t\t\t - neg_cost[mode];\n+\t      max_cost = rtx_cost (gen_rtx_MULT (mode, fake_reg, op1), SET, speed)\n+\t\t\t - neg_cost[speed][mode];\n \t      if (max_cost > 0\n \t\t  && choose_mult_variant (mode, -INTVAL (op1), &algorithm,\n \t\t\t\t\t  &variant, max_cost))\n@@ -3074,7 +3094,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \n \t  /* Exclude cost of op0 from max_cost to match the cost\n \t     calculation of the synth_mult.  */\n-\t  max_cost = rtx_cost (gen_rtx_MULT (mode, fake_reg, op1), SET);\n+\t  max_cost = rtx_cost (gen_rtx_MULT (mode, fake_reg, op1), SET, speed);\n \t  if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n \t\t\t\t   max_cost))\n \t    return expand_mult_const (mode, op0, coeff, target,\n@@ -3317,6 +3337,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   optab moptab;\n   rtx tem;\n   int size;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n \n@@ -3325,7 +3346,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Firstly, try using a multiplication insn that only generates the needed\n      high part of the product, and in the sign flavor of unsignedp.  */\n-  if (mul_highpart_cost[mode] < max_cost)\n+  if (mul_highpart_cost[speed][mode] < max_cost)\n     {\n       moptab = unsignedp ? umul_highpart_optab : smul_highpart_optab;\n       tem = expand_binop (mode, moptab, op0, narrow_op1, target,\n@@ -3337,8 +3358,8 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n      Need to adjust the result after the multiplication.  */\n   if (size - 1 < BITS_PER_WORD\n-      && (mul_highpart_cost[mode] + 2 * shift_cost[mode][size-1]\n-\t  + 4 * add_cost[mode] < max_cost))\n+      && (mul_highpart_cost[speed][mode] + 2 * shift_cost[speed][mode][size-1]\n+\t  + 4 * add_cost[speed][mode] < max_cost))\n     {\n       moptab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n       tem = expand_binop (mode, moptab, op0, narrow_op1, target,\n@@ -3352,7 +3373,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n   if (optab_handler (moptab, wider_mode)->insn_code != CODE_FOR_nothing\n-      && mul_widen_cost[wider_mode] < max_cost)\n+      && mul_widen_cost[speed][wider_mode] < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1, 0,\n \t\t\t  unsignedp, OPTAB_WIDEN);\n@@ -3363,7 +3384,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Try widening the mode and perform a non-widening multiplication.  */\n   if (optab_handler (smul_optab, wider_mode)->insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && mul_cost[wider_mode] + shift_cost[mode][size-1] < max_cost)\n+      && mul_cost[speed][wider_mode] + shift_cost[speed][mode][size-1] < max_cost)\n     {\n       rtx insns, wop0, wop1;\n \n@@ -3390,8 +3411,8 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n   if (optab_handler (moptab, wider_mode)->insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && (mul_widen_cost[wider_mode] + 2 * shift_cost[mode][size-1]\n-\t  + 4 * add_cost[mode] < max_cost))\n+      && (mul_widen_cost[speed][wider_mode] + 2 * shift_cost[speed][mode][size-1]\n+\t  + 4 * add_cost[speed][mode] < max_cost))\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1,\n \t\t\t  NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n@@ -3429,6 +3450,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n   enum mult_variant variant;\n   struct algorithm alg;\n   rtx tem;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   gcc_assert (!SCALAR_FLOAT_MODE_P (mode));\n   /* We can't support modes wider than HOST_BITS_PER_INT.  */\n@@ -3444,13 +3466,13 @@ expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n     return expand_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t       unsignedp, max_cost);\n \n-  extra_cost = shift_cost[mode][GET_MODE_BITSIZE (mode) - 1];\n+  extra_cost = shift_cost[speed][mode][GET_MODE_BITSIZE (mode) - 1];\n \n   /* Check whether we try to multiply by a negative constant.  */\n   if (!unsignedp && ((cnst1 >> (GET_MODE_BITSIZE (mode) - 1)) & 1))\n     {\n       sign_adjust = true;\n-      extra_cost += add_cost[mode];\n+      extra_cost += add_cost[speed][mode];\n     }\n \n   /* See whether shift/add multiplication is cheap enough.  */\n@@ -3510,7 +3532,7 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n \t  temp = gen_rtx_LSHIFTRT (mode, result, shift);\n \t  if (optab_handler (lshr_optab, mode)->insn_code == CODE_FOR_nothing\n-\t      || rtx_cost (temp, SET) > COSTS_N_INSNS (2))\n+\t      || rtx_cost (temp, SET, optimize_insn_for_speed_p ()) > COSTS_N_INSNS (2))\n \t    {\n \t      temp = expand_binop (mode, xor_optab, op0, signmask,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -3641,7 +3663,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n       temp = gen_reg_rtx (mode);\n       temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, -1);\n-      if (shift_cost[mode][ushift] > COSTS_N_INSNS (1))\n+      if (shift_cost[optimize_insn_for_speed_p ()][mode][ushift] > COSTS_N_INSNS (1))\n \ttemp = expand_binop (mode, and_optab, temp, GEN_INT (d - 1),\n \t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n       else\n@@ -3714,6 +3736,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   int max_cost, extra_cost;\n   static HOST_WIDE_INT last_div_const = 0;\n   static HOST_WIDE_INT ext_op1;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   op1_is_constant = GET_CODE (op1) == CONST_INT;\n   if (op1_is_constant)\n@@ -3844,10 +3867,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   /* Only deduct something for a REM if the last divide done was\n      for a different constant.   Then set the constant of the last\n      divide.  */\n-  max_cost = unsignedp ? udiv_cost[compute_mode] : sdiv_cost[compute_mode];\n+  max_cost = unsignedp ? udiv_cost[speed][compute_mode] : sdiv_cost[speed][compute_mode];\n   if (rem_flag && ! (last_div_const != 0 && op1_is_constant\n \t\t     && INTVAL (op1) == last_div_const))\n-    max_cost -= mul_cost[compute_mode] + add_cost[compute_mode];\n+    max_cost -= mul_cost[speed][compute_mode] + add_cost[speed][compute_mode];\n \n   last_div_const = ! rem_flag && op1_is_constant ? INTVAL (op1) : 0;\n \n@@ -3966,9 +3989,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      goto fail1;\n \n \t\t\t    extra_cost\n-\t\t\t      = (shift_cost[compute_mode][post_shift - 1]\n-\t\t\t\t + shift_cost[compute_mode][1]\n-\t\t\t\t + 2 * add_cost[compute_mode]);\n+\t\t\t      = (shift_cost[speed][compute_mode][post_shift - 1]\n+\t\t\t\t + shift_cost[speed][compute_mode][1]\n+\t\t\t\t + 2 * add_cost[speed][compute_mode]);\n \t\t\t    t1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -4002,8 +4025,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t       build_int_cst (NULL_TREE, pre_shift),\n \t\t\t       NULL_RTX, 1);\n \t\t\t    extra_cost\n-\t\t\t      = (shift_cost[compute_mode][pre_shift]\n-\t\t\t\t + shift_cost[compute_mode][post_shift]);\n+\t\t\t      = (shift_cost[speed][compute_mode][pre_shift]\n+\t\t\t\t + shift_cost[speed][compute_mode][post_shift]);\n \t\t\t    t2 = expand_mult_highpart (compute_mode, t1, ml,\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -4133,9 +4156,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    || size - 1 >= BITS_PER_WORD)\n \t\t\t  goto fail1;\n \n-\t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n-\t\t\t\t      + shift_cost[compute_mode][size - 1]\n-\t\t\t\t      + add_cost[compute_mode]);\n+\t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n+\t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n+\t\t\t\t      + add_cost[speed][compute_mode]);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, mlr,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -4170,9 +4193,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n \t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n \t\t\tmlr = gen_int_mode (ml, compute_mode);\n-\t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n-\t\t\t\t      + shift_cost[compute_mode][size - 1]\n-\t\t\t\t      + 2 * add_cost[compute_mode]);\n+\t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n+\t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n+\t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, mlr,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -4265,9 +4288,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t   NULL_RTX, 0);\n \t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n-\t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n-\t\t\t\t      + shift_cost[compute_mode][size - 1]\n-\t\t\t\t      + 2 * add_cost[compute_mode]);\n+\t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n+\t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n+\t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n \t\t\tt3 = expand_mult_highpart (compute_mode, t2, ml,\n \t\t\t\t\t\t   NULL_RTX, 1,\n \t\t\t\t\t\t   max_cost - extra_cost);"}, {"sha": "07685b228995688438df276777751ed201ddd5d6", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -3458,13 +3458,14 @@ compress_float_constant (rtx x, rtx y)\n   enum machine_mode srcmode;\n   REAL_VALUE_TYPE r;\n   int oldcost, newcost;\n+  bool speed = optimize_insn_for_speed_p ();\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, y);\n \n   if (LEGITIMATE_CONSTANT_P (y))\n-    oldcost = rtx_cost (y, SET);\n+    oldcost = rtx_cost (y, SET, speed);\n   else\n-    oldcost = rtx_cost (force_const_mem (dstmode, y), SET);\n+    oldcost = rtx_cost (force_const_mem (dstmode, y), SET, speed);\n \n   for (srcmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_srcmode));\n        srcmode != orig_srcmode;\n@@ -3491,15 +3492,15 @@ compress_float_constant (rtx x, rtx y)\n \t  if (! (*insn_data[ic].operand[1].predicate) (trunc_y, srcmode))\n \t    continue;\n \t  /* This is valid, but may not be cheaper than the original. */\n-\t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET);\n+\t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET, speed);\n \t  if (oldcost < newcost)\n \t    continue;\n \t}\n       else if (float_extend_from_mem[dstmode][srcmode])\n \t{\n \t  trunc_y = force_const_mem (srcmode, trunc_y);\n \t  /* This is valid, but may not be cheaper than the original. */\n-\t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET);\n+\t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET, speed);\n \t  if (oldcost < newcost)\n \t    continue;\n \t  trunc_y = validize_mem (trunc_y);"}, {"sha": "c546f3e15a135976650d3cd9d4956bcd3f9172f2", "filename": "gcc/fwprop.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -184,7 +184,8 @@ canonicalize_address (rtx x)\n    for a memory access in the given MODE.  */\n \n static bool\n-should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode)\n+should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode,\n+\t\t\tbool speed)\n {\n   int gain;\n \n@@ -196,14 +197,14 @@ should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode)\n     return true;\n \n   /* Prefer the new address if it is less expensive.  */\n-  gain = address_cost (old_rtx, mode) - address_cost (new_rtx, mode);\n+  gain = address_cost (old_rtx, mode, speed) - address_cost (new_rtx, mode, speed);\n \n   /* If the addresses have equivalent cost, prefer the new address\n      if it has the highest `rtx_cost'.  That has the potential of\n      eliminating the most insns without additional costs, and it\n      is the same that cse.c used to do.  */\n   if (gain == 0)\n-    gain = rtx_cost (new_rtx, SET) - rtx_cost (old_rtx, SET);\n+    gain = rtx_cost (new_rtx, SET, speed) - rtx_cost (old_rtx, SET, speed);\n \n   return (gain > 0);\n }\n@@ -231,7 +232,10 @@ enum {\n      PR_HANDLE_MEM is set when the source of the propagation was not\n      another MEM.  Then, it is safe not to treat non-read-only MEMs as\n      ``opaque'' objects.  */\n-  PR_HANDLE_MEM = 2\n+  PR_HANDLE_MEM = 2,\n+\n+  /* Set when costs should be optimized for speed.  */\n+  PR_OPTIMIZE_FOR_SPEED = 4\n };\n \n \n@@ -360,7 +364,8 @@ propagate_rtx_1 (rtx *px, rtx old_rtx, rtx new_rtx, int flags)\n \n \t  /* Copy propagations are always ok.  Otherwise check the costs.  */\n \t  if (!(REG_P (old_rtx) && REG_P (new_rtx))\n-\t      && !should_replace_address (op0, new_op0, GET_MODE (x)))\n+\t      && !should_replace_address (op0, new_op0, GET_MODE (x),\n+\t      \t\t\t \t  flags & PR_OPTIMIZE_FOR_SPEED))\n \t    return true;\n \n \t  tem = replace_equiv_address_nv (x, new_op0);\n@@ -438,7 +443,8 @@ varying_mem_p (rtx *body, void *data ATTRIBUTE_UNUSED)\n    Otherwise, we accept simplifications that have a lower or equal cost.  */\n \n static rtx\n-propagate_rtx (rtx x, enum machine_mode mode, rtx old_rtx, rtx new_rtx)\n+propagate_rtx (rtx x, enum machine_mode mode, rtx old_rtx, rtx new_rtx,\n+\t       bool speed)\n {\n   rtx tem;\n   bool collapsed;\n@@ -453,6 +459,9 @@ propagate_rtx (rtx x, enum machine_mode mode, rtx old_rtx, rtx new_rtx)\n   if (!for_each_rtx (&new_rtx, varying_mem_p, NULL))\n     flags |= PR_HANDLE_MEM;\n \n+  if (speed)\n+    flags |= PR_OPTIMIZE_FOR_SPEED;\n+\n   tem = x;\n   collapsed = propagate_rtx_1 (&tem, old_rtx, copy_rtx (new_rtx), flags);\n   if (tem == x || !collapsed)\n@@ -728,7 +737,8 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new_rtx, rtx def_insn, bool\n   enum df_ref_type type = DF_REF_TYPE (use);\n   int flags = DF_REF_FLAGS (use);\n   rtx set = single_set (insn);\n-  int old_cost = rtx_cost (SET_SRC (set), SET);\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+  int old_cost = rtx_cost (SET_SRC (set), SET, speed);\n   bool ok;\n \n   if (dump_file)\n@@ -750,7 +760,7 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new_rtx, rtx def_insn, bool\n     }\n \n   else if (DF_REF_TYPE (use) == DF_REF_REG_USE\n-\t   && rtx_cost (SET_SRC (set), SET) > old_cost)\n+\t   && rtx_cost (SET_SRC (set), SET, speed) > old_cost)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Changes to insn %d not profitable\\n\",\n@@ -928,7 +938,8 @@ forward_propagate_and_simplify (struct df_ref *use, rtx def_insn, rtx def_set)\n   else\n     mode = GET_MODE (*loc);\n \n-  new_rtx = propagate_rtx (*loc, mode, reg, src);\n+  new_rtx = propagate_rtx (*loc, mode, reg, src,\n+  \t\t\t   optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn)));\n \n   if (!new_rtx)\n     return false;"}, {"sha": "04dbd3eab2abd1d1c61de9fd4ef4833baf1fde20", "filename": "gcc/hooks.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -153,6 +153,12 @@ hook_int_rtx_0 (rtx a ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n+int\n+hook_int_rtx_bool_0 (rtx a ATTRIBUTE_UNUSED, bool b ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n int\n hook_int_size_t_constcharptr_int_0 (size_t a ATTRIBUTE_UNUSED,\n \t\t\t\t    const char *b ATTRIBUTE_UNUSED,\n@@ -233,10 +239,11 @@ hook_bool_uintp_uintp_false (unsigned int *a ATTRIBUTE_UNUSED,\n }\n \n bool\n-hook_bool_rtx_int_int_intp_false (rtx a ATTRIBUTE_UNUSED,\n-\t\t\t\t  int b ATTRIBUTE_UNUSED,\n-\t\t\t\t  int c ATTRIBUTE_UNUSED,\n-\t\t\t\t  int *d ATTRIBUTE_UNUSED)\n+hook_bool_rtx_int_int_intp_bool_false (rtx a ATTRIBUTE_UNUSED,\n+\t\t\t\t       int b ATTRIBUTE_UNUSED,\n+\t\t\t\t       int c ATTRIBUTE_UNUSED,\n+\t\t\t\t       int *d ATTRIBUTE_UNUSED,\n+\t\t\t\t       bool speed_p ATTRIBUTE_UNUSED)\n {\n   return false;\n }"}, {"sha": "9d7e56a3589d8e5e8256e21017a45d0fe5425b5c", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -44,7 +44,7 @@ extern bool hook_bool_const_tree_hwi_hwi_const_tree_true (const_tree,\n \t\t\t\t\t\t\t  const_tree);\n extern bool hook_bool_rtx_false (rtx);\n extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n-extern bool hook_bool_rtx_int_int_intp_false (rtx, int, int, int *);\n+extern bool hook_bool_rtx_int_int_intp_bool_false (rtx, int, int, int *, bool);\n extern bool hook_bool_constcharptr_size_t_false (const char *, size_t);\n extern bool hook_bool_size_t_constcharptr_int_true (size_t, const char *, int);\n extern bool hook_bool_tree_tree_false (tree, tree);\n@@ -59,6 +59,7 @@ extern void hook_void_tree_treeptr (tree, tree *);\n extern int hook_int_const_tree_0 (const_tree);\n extern int hook_int_const_tree_const_tree_1 (const_tree, const_tree);\n extern int hook_int_rtx_0 (rtx);\n+extern int hook_int_rtx_bool_0 (rtx, bool);\n extern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);\n extern int hook_int_void_no_regs (void);\n "}, {"sha": "845fa2104c2b93b206d2371a409379449a9d1468", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -143,12 +143,13 @@ cheap_bb_rtx_cost_p (const_basic_block bb, int max_cost)\n {\n   int count = 0;\n   rtx insn = BB_HEAD (bb);\n+  bool speed = optimize_bb_for_speed_p (bb);\n \n   while (1)\n     {\n       if (NONJUMP_INSN_P (insn))\n \t{\n-\t  int cost = insn_rtx_cost (PATTERN (insn));\n+\t  int cost = insn_rtx_cost (PATTERN (insn), speed);\n \t  if (cost == 0)\n \t    return false;\n \n@@ -1351,7 +1352,8 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n      if insn_rtx_cost can't be estimated.  */\n   if (insn_a)\n     {\n-      insn_cost = insn_rtx_cost (PATTERN (insn_a));\n+      insn_cost = insn_rtx_cost (PATTERN (insn_a),\n+      \t\t\t\t optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_a)));\n       if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n \treturn FALSE;\n     }\n@@ -1360,7 +1362,8 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \n   if (insn_b)\n     {\n-      insn_cost += insn_rtx_cost (PATTERN (insn_b));\n+      insn_cost += insn_rtx_cost (PATTERN (insn_b),\n+      \t\t\t\t optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn_b)));\n       if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n         return FALSE;\n     }\n@@ -1901,7 +1904,8 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n      INSN_B which can happen for e.g. conditional stores to memory.  */\n   b_unconditional = (if_info->insn_b == NULL_RTX\n \t\t     || BLOCK_FOR_INSN (if_info->insn_b) == if_info->test_bb);\n-  if (rtx_cost (t, SET) >= COSTS_N_INSNS (2)\n+  if (rtx_cost (t, SET, optimize_bb_for_speed_p (BLOCK_FOR_INSN (if_info->insn_b)))\n+      >= COSTS_N_INSNS (2)\n       && (!b_unconditional\n           || t != if_info->b))\n     return FALSE;"}, {"sha": "a039f367925541536adedda7503f5a56cc46b036", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -586,7 +586,8 @@ doloop_optimize (struct loop *loop)\n \n   max_cost\n     = COSTS_N_INSNS (PARAM_VALUE (PARAM_MAX_ITERATIONS_COMPUTATION_COST));\n-  if (rtx_cost (desc->niter_expr, SET) > max_cost)\n+  if (rtx_cost (desc->niter_expr, SET, optimize_loop_for_speed_p (loop))\n+      > max_cost)\n     {\n       if (dump_file)\n \tfprintf (dump_file,"}, {"sha": "524727e9a379df641b2ab8bccf549c48a8ea5a27", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -668,6 +668,7 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n {\n   struct invariant *inv = XNEW (struct invariant);\n   rtx set = single_set (insn);\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n \n   inv->def = def;\n   inv->always_executed = always_executed;\n@@ -676,9 +677,9 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n   /* If the set is simple, usually by moving it we move the whole store out of\n      the loop.  Otherwise we save only cost of the computation.  */\n   if (def)\n-    inv->cost = rtx_cost (set, SET);\n+    inv->cost = rtx_cost (set, SET, speed);\n   else\n-    inv->cost = rtx_cost (SET_SRC (set), SET);\n+    inv->cost = rtx_cost (SET_SRC (set), SET, speed);\n \n   inv->move = false;\n   inv->reg = NULL_RTX;\n@@ -1048,15 +1049,15 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \n static int\n gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n-\t\t    unsigned new_regs, unsigned regs_used)\n+\t\t    unsigned new_regs, unsigned regs_used, bool speed)\n {\n   int comp_cost, size_cost;\n \n   get_inv_cost (inv, &comp_cost, regs_needed);\n   actual_stamp++;\n \n-  size_cost = (estimate_reg_pressure_cost (new_regs + *regs_needed, regs_used)\n-\t       - estimate_reg_pressure_cost (new_regs, regs_used));\n+  size_cost = (estimate_reg_pressure_cost (new_regs + *regs_needed, regs_used, speed)\n+\t       - estimate_reg_pressure_cost (new_regs, regs_used, speed));\n \n   return comp_cost - size_cost;\n }\n@@ -1069,7 +1070,7 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \n static int\n best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n-\t\t\t unsigned new_regs, unsigned regs_used)\n+\t\t\t unsigned new_regs, unsigned regs_used, bool speed)\n {\n   struct invariant *inv;\n   int gain = 0, again;\n@@ -1084,7 +1085,8 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n       if (inv->eqto != inv->invno)\n \tcontinue;\n \n-      again = gain_for_invariant (inv, &aregs_needed, new_regs, regs_used);\n+      again = gain_for_invariant (inv, &aregs_needed, new_regs, regs_used,\n+      \t\t\t\t  speed);\n       if (again > gain)\n \t{\n \t  gain = again;\n@@ -1123,7 +1125,7 @@ set_move_mark (unsigned invno)\n /* Determines which invariants to move.  */\n \n static void\n-find_invariants_to_move (void)\n+find_invariants_to_move (bool speed)\n {\n   unsigned i, regs_used, regs_needed = 0, new_regs;\n   struct invariant *inv = NULL;\n@@ -1147,7 +1149,7 @@ find_invariants_to_move (void)\n     }\n \n   new_regs = 0;\n-  while (best_gain_for_invariant (&inv, &regs_needed, new_regs, regs_used) > 0)\n+  while (best_gain_for_invariant (&inv, &regs_needed, new_regs, regs_used, speed) > 0)\n     {\n       set_move_mark (inv->invno);\n       new_regs += regs_needed;\n@@ -1314,7 +1316,7 @@ move_single_loop_invariants (struct loop *loop)\n   init_inv_motion_data ();\n \n   find_invariants (loop);\n-  find_invariants_to_move ();\n+  find_invariants_to_move (optimize_loop_for_speed_p (loop));\n   move_invariants (loop);\n \n   free_inv_motion_data ();"}, {"sha": "127310390919babb6fb4a49368a1107d50a81633", "filename": "gcc/optabs.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1414,7 +1414,8 @@ avoid_expensive_constant (enum machine_mode mode, optab binoptab,\n   if (mode != VOIDmode\n       && optimize\n       && CONSTANT_P (x)\n-      && rtx_cost (x, binoptab->code) > COSTS_N_INSNS (1))\n+      && rtx_cost (x, binoptab->code, optimize_insn_for_speed_p ())\n+                   > COSTS_N_INSNS (1))\n     {\n       if (GET_CODE (x) == CONST_INT)\n \t{\n@@ -4037,11 +4038,13 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n   /* If we are inside an appropriately-short loop and we are optimizing,\n      force expensive constants into a register.  */\n   if (CONSTANT_P (x) && optimize\n-      && rtx_cost (x, COMPARE) > COSTS_N_INSNS (1))\n+      && (rtx_cost (x, COMPARE, optimize_insn_for_speed_p ())\n+          > COSTS_N_INSNS (1)))\n     x = force_reg (mode, x);\n \n   if (CONSTANT_P (y) && optimize\n-      && rtx_cost (y, COMPARE) > COSTS_N_INSNS (1))\n+      && (rtx_cost (y, COMPARE, optimize_insn_for_speed_p ())\n+          > COSTS_N_INSNS (1)))\n     y = force_reg (mode, y);\n \n #ifdef HAVE_cc0"}, {"sha": "51adcd22648b0f72a6d8bac179a4eddc8f0bcc67", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -621,7 +621,7 @@ extern void default_elf_asm_output_external (FILE *file, tree,\n \t\t\t\t\t     const char *);\n extern int maybe_assemble_visibility (tree);\n \n-extern int default_address_cost (rtx);\n+extern int default_address_cost (rtx, bool);\n \n /* dbxout helper functions */\n #if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO"}, {"sha": "8abc90f83d9acb2b8693057e090cdf7f12499dd7", "filename": "gcc/postreload.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -233,6 +233,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n #ifdef LOAD_EXTEND_OP\n   enum rtx_code extend_op = UNKNOWN;\n #endif\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n \n   dreg = true_regnum (SET_DEST (set));\n   if (dreg < 0)\n@@ -267,7 +268,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n     old_cost = REGISTER_MOVE_COST (GET_MODE (src),\n \t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n   else\n-    old_cost = rtx_cost (src, SET);\n+    old_cost = rtx_cost (src, SET, speed);\n \n   for (l = val->locs; l; l = l->next)\n     {\n@@ -302,15 +303,15 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \t      this_rtx = GEN_INT (this_val);\n \t    }\n #endif\n-\t  this_cost = rtx_cost (this_rtx, SET);\n+\t  this_cost = rtx_cost (this_rtx, SET, speed);\n \t}\n       else if (REG_P (this_rtx))\n \t{\n #ifdef LOAD_EXTEND_OP\n \t  if (extend_op != UNKNOWN)\n \t    {\n \t      this_rtx = gen_rtx_fmt_e (extend_op, word_mode, this_rtx);\n-\t      this_cost = rtx_cost (this_rtx, SET);\n+\t      this_cost = rtx_cost (this_rtx, SET, speed);\n \t    }\n \t  else\n #endif\n@@ -570,8 +571,10 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t  if (op_alt_regno[i][j] == -1\n \t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n \t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n-\t\t\t  || (rtx_cost (recog_data.operand[i], SET)\n-\t\t\t      > rtx_cost (testreg, SET))))\n+\t\t\t  || (rtx_cost (recog_data.operand[i], SET,\n+\t\t\t  \t\toptimize_bb_for_speed_p (BLOCK_FOR_INSN (insn)))\n+\t\t\t      > rtx_cost (testreg, SET,\n+\t\t\t  \t\toptimize_bb_for_speed_p (BLOCK_FOR_INSN (insn))))))\n \t\t    {\n \t\t      alternative_nregs[j]++;\n \t\t      op_alt_regno[i][j] = regno;\n@@ -1240,6 +1243,8 @@ reload_cse_move2add (rtx first)\n \t\t{\n \t\t  rtx new_src = gen_int_mode (INTVAL (src) - reg_offset[regno],\n \t\t\t\t\t      GET_MODE (reg));\n+\t\t  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+\n \t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n \t\t     use (set (reg) (reg)) instead.\n \t\t     We don't delete this insn, nor do we convert it into a\n@@ -1255,7 +1260,7 @@ reload_cse_move2add (rtx first)\n \t\t      if (INTVAL (src) == reg_offset [regno])\n \t\t\tvalidate_change (insn, &SET_SRC (pat), reg, 0);\n \t\t    }\n-\t\t  else if (rtx_cost (new_src, PLUS) < rtx_cost (src, SET)\n+\t\t  else if (rtx_cost (new_src, PLUS, speed) < rtx_cost (src, SET, speed)\n \t\t\t   && have_add2_insn (reg, new_src))\n \t\t    {\n \t\t      rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n@@ -1331,14 +1336,15 @@ reload_cse_move2add (rtx first)\n \t\t\t\t      + base_offset\n \t\t\t\t      - regno_offset,\n \t\t\t\t      GET_MODE (reg));\n-\t\t      int success = 0;\n+\t\t      bool success = false;\n+\t\t      bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n \n \t\t      if (new_src == const0_rtx)\n \t\t\t/* See above why we create (set (reg) (reg)) here.  */\n \t\t\tsuccess\n \t\t\t  = validate_change (next, &SET_SRC (set), reg, 0);\n-\t\t      else if ((rtx_cost (new_src, PLUS)\n-\t\t\t\t< COSTS_N_INSNS (1) + rtx_cost (src3, SET))\n+\t\t      else if ((rtx_cost (new_src, PLUS, speed)\n+\t\t\t\t< COSTS_N_INSNS (1) + rtx_cost (src3, SET, speed))\n \t\t\t       && have_add2_insn (reg, new_src))\n \t\t\t{\n \t\t\t  rtx newpat = gen_rtx_SET (VOIDmode,"}, {"sha": "8b6478984bb9acd10910aad8ad50f6cfb7d636eb", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1074,8 +1074,8 @@ rhs_regno (const_rtx x)\n #define MAX_COST INT_MAX\n \n extern void init_rtlanal (void);\n-extern int rtx_cost (rtx, enum rtx_code);\n-extern int address_cost (rtx, enum machine_mode);\n+extern int rtx_cost (rtx, enum rtx_code, bool);\n+extern int address_cost (rtx, enum machine_mode, bool);\n extern unsigned int subreg_lsb (const_rtx);\n extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,\n \t\t\t\t  unsigned int);\n@@ -1784,7 +1784,7 @@ extern int loc_mentioned_in_p (rtx *, const_rtx);\n extern rtx find_first_parameter_load (rtx, rtx);\n extern bool keep_with_call_p (const_rtx);\n extern bool label_is_jump_target_p (const_rtx, const_rtx);\n-extern int insn_rtx_cost (rtx);\n+extern int insn_rtx_cost (rtx, bool);\n \n /* Given an insn and condition, return a canonical description of\n    the test being made.  */\n@@ -2339,5 +2339,7 @@ extern void insn_locators_finalize (void);\n extern void set_curr_insn_source_location (location_t);\n extern void set_curr_insn_block (tree);\n extern int curr_insn_locator (void);\n+extern bool optimize_insn_for_size_p (void);\n+extern bool optimize_insn_for_speed_p (void);\n \n #endif /* ! GCC_RTL_H */"}, {"sha": "b2038aa840fc902b8ccd5ac30c9f99f5540411fe", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -3501,10 +3501,13 @@ label_is_jump_target_p (const_rtx label, const_rtx jump_insn)\n /* Return an estimate of the cost of computing rtx X.\n    One use is in cse, to decide which expression to keep in the hash table.\n    Another is in rtl generation, to pick the cheapest way to multiply.\n-   Other uses like the latter are expected in the future.  */\n+   Other uses like the latter are expected in the future. \n+\n+   SPEED parameter specify whether costs optimized for speed or size should\n+   be returned.  */\n \n int\n-rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n+rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED, bool speed)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -3552,7 +3555,7 @@ rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n       break;\n \n     default:\n-      if (targetm.rtx_costs (x, code, outer_code, &total))\n+      if (targetm.rtx_costs (x, code, outer_code, &total, speed))\n \treturn total;\n       break;\n     }\n@@ -3563,19 +3566,22 @@ rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      total += rtx_cost (XEXP (x, i), code);\n+      total += rtx_cost (XEXP (x, i), code, speed);\n     else if (fmt[i] == 'E')\n       for (j = 0; j < XVECLEN (x, i); j++)\n-\ttotal += rtx_cost (XVECEXP (x, i, j), code);\n+\ttotal += rtx_cost (XVECEXP (x, i, j), code, speed);\n \n   return total;\n }\n \f\n /* Return cost of address expression X.\n-   Expect that X is properly formed address reference.  */\n+   Expect that X is properly formed address reference.  \n+\n+   SPEED parameter specify whether costs optimized for speed or size should\n+   be returned.  */\n \n int\n-address_cost (rtx x, enum machine_mode mode)\n+address_cost (rtx x, enum machine_mode mode, bool speed)\n {\n   /* We may be asked for cost of various unusual addresses, such as operands\n      of push instruction.  It is not worthwhile to complicate writing\n@@ -3584,15 +3590,15 @@ address_cost (rtx x, enum machine_mode mode)\n   if (!memory_address_p (mode, x))\n     return 1000;\n \n-  return targetm.address_cost (x);\n+  return targetm.address_cost (x, speed);\n }\n \n /* If the target doesn't override, compute the cost as with arithmetic.  */\n \n int\n-default_address_cost (rtx x)\n+default_address_cost (rtx x, bool speed)\n {\n-  return rtx_cost (x, MEM);\n+  return rtx_cost (x, MEM, speed);\n }\n \f\n \n@@ -4563,7 +4569,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n    zero indicates an instruction pattern without a known cost.  */\n \n int\n-insn_rtx_cost (rtx pat)\n+insn_rtx_cost (rtx pat, bool speed)\n {\n   int i, cost;\n   rtx set;\n@@ -4591,7 +4597,7 @@ insn_rtx_cost (rtx pat)\n   else\n     return 0;\n \n-  cost = rtx_cost (SET_SRC (set), SET);\n+  cost = rtx_cost (SET_SRC (set), SET, speed);\n   return cost > 0 ? cost : COSTS_N_INSNS (1);\n }\n "}, {"sha": "30bafea8ab19f665510e956e789df4fdde05af53", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1665,12 +1665,13 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      rtx coeff;\n \t      unsigned HOST_WIDE_INT l;\n \t      HOST_WIDE_INT h;\n+\t      bool speed = optimize_function_for_speed_p (cfun);\n \n \t      add_double (coeff0l, coeff0h, coeff1l, coeff1h, &l, &h);\n \t      coeff = immed_double_const (l, h, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n-\t      return rtx_cost (tem, SET) <= rtx_cost (orig, SET)\n+\t      return rtx_cost (tem, SET, speed) <= rtx_cost (orig, SET, speed)\n \t\t? tem : 0;\n \t    }\n \t}\n@@ -1859,12 +1860,13 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      rtx coeff;\n \t      unsigned HOST_WIDE_INT l;\n \t      HOST_WIDE_INT h;\n+\t      bool speed = optimize_function_for_speed_p (cfun);\n \n \t      add_double (coeff0l, coeff0h, negcoeff1l, negcoeff1h, &l, &h);\n \t      coeff = immed_double_const (l, h, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n-\t      return rtx_cost (tem, SET) <= rtx_cost (orig, SET)\n+\t      return rtx_cost (tem, SET, speed) <= rtx_cost (orig, SET, speed)\n \t\t? tem : 0;\n \t    }\n \t}"}, {"sha": "ee880964fe10976dcb0b13c74fb6922bce77a4ac", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -2125,7 +2125,8 @@ bool lshift_cheap_p (void)\n   if (!init)\n     {\n       rtx reg = gen_rtx_REG (word_mode, 10000);\n-      int cost = rtx_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg), SET);\n+      int cost = rtx_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg), SET,\n+      \t\t\t   optimize_insn_for_speed_p ());\n       cheap = cost < COSTS_N_INSNS (3);\n       init = true;\n     }"}, {"sha": "740efc557030c3b68089e4818f902ec76706fda5", "filename": "gcc/target-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -481,7 +481,7 @@\n #define TARGET_MS_BITFIELD_LAYOUT_P hook_bool_const_tree_false\n #define TARGET_ALIGN_ANON_BITFIELD hook_bool_void_false\n #define TARGET_NARROW_VOLATILE_BITFIELD hook_bool_void_false\n-#define TARGET_RTX_COSTS hook_bool_rtx_int_int_intp_false\n+#define TARGET_RTX_COSTS hook_bool_rtx_int_int_intp_bool_false\n #define TARGET_MANGLE_TYPE hook_constcharptr_const_tree_null\n #define TARGET_ALLOCATE_INITIAL_VALUE NULL\n "}, {"sha": "69b270fc43a6832eb6c112aaa7be5c9d40645939", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -648,11 +648,11 @@ struct gcc_target\n      scanned.  In either case, *TOTAL contains the cost result.  */\n   /* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n      not necessarily defined at this point.  */\n-  bool (* rtx_costs) (rtx x, int code, int outer_code, int *total);\n+  bool (* rtx_costs) (rtx x, int code, int outer_code, int *total, bool speed);\n \n   /* Compute the cost of X, used as an address.  Never called with\n      invalid addresses.  */\n-  int (* address_cost) (rtx x);\n+  int (* address_cost) (rtx x, bool speed);\n \n   /* Return where to allocate pseudo for a given hard register initial\n      value.  */"}, {"sha": "eec48d9183ecd39fceeb9c77a768ad0f8c5a8c9c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -1124,7 +1124,7 @@ extern void tree_check_data_deps (void);\n bool expr_invariant_in_loop_p (struct loop *, tree);\n bool stmt_invariant_in_loop_p (struct loop *, gimple);\n bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode);\n-unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode);\n+unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode, bool);\n \n /* In tree-ssa-threadupdate.c.  */\n extern bool thread_through_all_blocks (bool);\n@@ -1155,7 +1155,7 @@ struct mem_address\n \n struct affine_tree_combination;\n tree create_mem_ref (gimple_stmt_iterator *, tree, \n-\t\t     struct affine_tree_combination *);\n+\t\t     struct affine_tree_combination *, bool);\n rtx addr_for_mem_ref (struct mem_address *, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);"}, {"sha": "df4f5c9296f38baf3ca2e698994959986337d4db", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -437,7 +437,8 @@ add_to_parts (struct mem_address *parts, tree elt)\n    element(s) to PARTS.  */\n \n static void\n-most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr)\n+most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,\n+\t\t\t      bool speed)\n {\n   HOST_WIDE_INT coef;\n   double_int best_mult, amult, amult_neg;\n@@ -459,7 +460,7 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr)\n \t  || !multiplier_allowed_in_address_p (coef, Pmode))\n \tcontinue;\n \n-      acost = multiply_by_cost (coef, Pmode);\n+      acost = multiply_by_cost (coef, Pmode, speed);\n \n       if (acost > best_mult_cost)\n \t{\n@@ -512,7 +513,7 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr)\n    addressing modes is useless.  */\n \n static void\n-addr_to_parts (aff_tree *addr, struct mem_address *parts)\n+addr_to_parts (aff_tree *addr, struct mem_address *parts, bool speed)\n {\n   tree part;\n   unsigned i;\n@@ -532,7 +533,7 @@ addr_to_parts (aff_tree *addr, struct mem_address *parts)\n \n   /* First move the most expensive feasible multiplication\n      to index.  */\n-  most_expensive_mult_to_index (parts, addr);\n+  most_expensive_mult_to_index (parts, addr, speed);\n \n   /* Try to find a base of the reference.  Since at the moment\n      there is no reliable way how to distinguish between pointer and its\n@@ -573,13 +574,14 @@ gimplify_mem_ref_parts (gimple_stmt_iterator *gsi, struct mem_address *parts)\n    of created memory reference.  */\n \n tree\n-create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr)\n+create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n+\t\tbool speed)\n {\n   tree mem_ref, tmp;\n   tree atype;\n   struct mem_address parts;\n \n-  addr_to_parts (addr, &parts);\n+  addr_to_parts (addr, &parts, speed);\n   gimplify_mem_ref_parts (gsi, &parts);\n   mem_ref = create_mem_ref_raw (type, &parts);\n   if (mem_ref)"}, {"sha": "8fbb27a5667054855b7853653c9de0d58c456d6f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 81, "deletions": 63, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40751dd3417bc2b10d85a8f6afa3771c6de7101/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f40751dd3417bc2b10d85a8f6afa3771c6de7101", "patch": "@@ -219,6 +219,9 @@ struct ivopts_data\n   /* The currently optimized loop.  */\n   struct loop *current_loop;\n \n+  /* Are we optimizing for speed?  */\n+  bool speed;\n+\n   /* Number of registers used in it.  */\n   unsigned regs_used;\n \n@@ -2539,7 +2542,7 @@ get_use_iv_cost (struct ivopts_data *data, struct iv_use *use,\n /* Returns estimate on cost of computing SEQ.  */\n \n static unsigned\n-seq_cost (rtx seq)\n+seq_cost (rtx seq, bool speed)\n {\n   unsigned cost = 0;\n   rtx set;\n@@ -2548,7 +2551,7 @@ seq_cost (rtx seq)\n     {\n       set = single_set (seq);\n       if (set)\n-\tcost += rtx_cost (set, SET);\n+\tcost += rtx_cost (set, SET,speed);\n       else\n \tcost++;\n     }\n@@ -2641,23 +2644,28 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n /* Determines cost of the computation of EXPR.  */\n \n static unsigned\n-computation_cost (tree expr)\n+computation_cost (tree expr, bool speed)\n {\n   rtx seq, rslt;\n   tree type = TREE_TYPE (expr);\n   unsigned cost;\n   /* Avoid using hard regs in ways which may be unsupported.  */\n   int regno = LAST_VIRTUAL_REGISTER + 1;\n+  enum function_frequency real_frequency = cfun->function_frequency;\n \n+  cfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n+  crtl->maybe_hot_insn_p = speed;\n   walk_tree (&expr, prepare_decl_rtl, &regno, NULL);\n   start_sequence ();\n   rslt = expand_expr (expr, NULL_RTX, TYPE_MODE (type), EXPAND_NORMAL);\n   seq = get_insns ();\n   end_sequence ();\n+  default_rtl_profile ();\n+  cfun->function_frequency = real_frequency;\n \n-  cost = seq_cost (seq);\n+  cost = seq_cost (seq, speed);\n   if (MEM_P (rslt))\n-    cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type));\n+    cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type), speed);\n \n   return cost;\n }\n@@ -2833,7 +2841,7 @@ get_computation (struct loop *loop, struct iv_use *use, struct iv_cand *cand)\n /* Returns cost of addition in MODE.  */\n \n static unsigned\n-add_cost (enum machine_mode mode)\n+add_cost (enum machine_mode mode, bool speed)\n {\n   static unsigned costs[NUM_MACHINE_MODES];\n   rtx seq;\n@@ -2850,7 +2858,7 @@ add_cost (enum machine_mode mode)\n   seq = get_insns ();\n   end_sequence ();\n \n-  cost = seq_cost (seq);\n+  cost = seq_cost (seq, speed);\n   if (!cost)\n     cost = 1;\n \n@@ -2895,7 +2903,7 @@ mbc_entry_eq (const void *entry1, const void *entry2)\n /* Returns cost of multiplication by constant CST in MODE.  */\n \n unsigned\n-multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n+multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode, bool speed)\n {\n   static htab_t costs;\n   struct mbc_entry **cached, act;\n@@ -2921,7 +2929,7 @@ multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n   seq = get_insns ();\n   end_sequence ();\n   \n-  cost = seq_cost (seq);\n+  cost = seq_cost (seq, speed);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Multiplication by %d in %s costs %d\\n\",\n@@ -2984,7 +2992,8 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n static comp_cost\n get_address_cost (bool symbol_present, bool var_present,\n \t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,\n-\t\t  enum machine_mode mem_mode)\n+\t\t  enum machine_mode mem_mode,\n+\t\t  bool speed)\n {\n   static bool initialized[MAX_MACHINE_MODE];\n   static HOST_WIDE_INT rat[MAX_MACHINE_MODE], off[MAX_MACHINE_MODE];\n@@ -3100,8 +3109,8 @@ get_address_cost (bool symbol_present, bool var_present,\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  acost = seq_cost (seq);\n-\t  acost += address_cost (addr, mem_mode);\n+\t  acost = seq_cost (seq, speed);\n+\t  acost += address_cost (addr, mem_mode, speed);\n \n \t  if (!acost)\n \t    acost = 1;\n@@ -3120,7 +3129,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t If VAR_PRESENT is true, try whether the mode with\n \t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n \t if this is the case, use it.  */\n-      add_c = add_cost (Pmode);\n+      add_c = add_cost (Pmode, speed);\n       for (i = 0; i < 8; i++)\n \t{\n \t  var_p = i & 1;\n@@ -3178,10 +3187,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \t     && multiplier_allowed_in_address_p (ratio, mem_mode));\n \n   if (ratio != 1 && !ratio_p)\n-    cost += multiply_by_cost (ratio, Pmode);\n+    cost += multiply_by_cost (ratio, Pmode, speed);\n \n   if (s_offset && !offset_p && !symbol_present)\n-    cost += add_cost (Pmode);\n+    cost += add_cost (Pmode, speed);\n \n   acost = costs[mem_mode][symbol_present][var_present][offset_p][ratio_p];\n   complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n@@ -3191,12 +3200,12 @@ get_address_cost (bool symbol_present, bool var_present,\n /* Estimates cost of forcing expression EXPR into a variable.  */\n \n static comp_cost\n-force_expr_to_var_cost (tree expr)\n+force_expr_to_var_cost (tree expr, bool speed)\n {\n   static bool costs_initialized = false;\n-  static unsigned integer_cost;\n-  static unsigned symbol_cost;\n-  static unsigned address_cost;\n+  static unsigned integer_cost [2];\n+  static unsigned symbol_cost [2];\n+  static unsigned address_cost [2];\n   tree op0, op1;\n   comp_cost cost0, cost1, cost;\n   enum machine_mode mode;\n@@ -3206,30 +3215,36 @@ force_expr_to_var_cost (tree expr)\n       tree type = build_pointer_type (integer_type_node);\n       tree var, addr;\n       rtx x;\n+      int i;\n \n       var = create_tmp_var_raw (integer_type_node, \"test_var\");\n       TREE_STATIC (var) = 1;\n       x = produce_memory_decl_rtl (var, NULL);\n       SET_DECL_RTL (var, x);\n \n-      integer_cost = computation_cost (build_int_cst (integer_type_node,\n-\t\t\t\t\t\t      2000));\n-\n       addr = build1 (ADDR_EXPR, type, var);\n-      symbol_cost = computation_cost (addr) + 1;\n \n-      address_cost\n-\t= computation_cost (build2 (POINTER_PLUS_EXPR, type,\n-\t\t\t\t    addr,\n-\t\t\t\t    build_int_cst (sizetype, 2000))) + 1;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+\n+      for (i = 0; i < 2; i++)\n \t{\n-\t  fprintf (dump_file, \"force_expr_to_var_cost:\\n\");\n-\t  fprintf (dump_file, \"  integer %d\\n\", (int) integer_cost);\n-\t  fprintf (dump_file, \"  symbol %d\\n\", (int) symbol_cost);\n-\t  fprintf (dump_file, \"  address %d\\n\", (int) address_cost);\n-\t  fprintf (dump_file, \"  other %d\\n\", (int) target_spill_cost);\n-\t  fprintf (dump_file, \"\\n\");\n+\t  integer_cost[i] = computation_cost (build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t     2000), i);\n+\n+\t  symbol_cost[i] = computation_cost (addr, i) + 1;\n+\n+\t  address_cost[i]\n+\t    = computation_cost (build2 (POINTER_PLUS_EXPR, type,\n+\t\t\t\t\taddr,\n+\t\t\t\t\tbuild_int_cst (sizetype, 2000)), i) + 1;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"force_expr_to_var_cost %s costs:\\n\", i ? \"speed\" : \"size\");\n+\t      fprintf (dump_file, \"  integer %d\\n\", (int) integer_cost[i]);\n+\t      fprintf (dump_file, \"  symbol %d\\n\", (int) symbol_cost[i]);\n+\t      fprintf (dump_file, \"  address %d\\n\", (int) address_cost[i]);\n+\t      fprintf (dump_file, \"  other %d\\n\", (int) target_spill_cost[i]);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \t}\n \n       costs_initialized = true;\n@@ -3243,7 +3258,7 @@ force_expr_to_var_cost (tree expr)\n   if (is_gimple_min_invariant (expr))\n     {\n       if (TREE_CODE (expr) == INTEGER_CST)\n-\treturn new_cost (integer_cost, 0);\n+\treturn new_cost (integer_cost [speed], 0);\n \n       if (TREE_CODE (expr) == ADDR_EXPR)\n \t{\n@@ -3252,10 +3267,10 @@ force_expr_to_var_cost (tree expr)\n \t  if (TREE_CODE (obj) == VAR_DECL\n \t      || TREE_CODE (obj) == PARM_DECL\n \t      || TREE_CODE (obj) == RESULT_DECL)\n-\t    return new_cost (symbol_cost, 0);\n+\t    return new_cost (symbol_cost [speed], 0);\n \t}\n \n-      return new_cost (address_cost, 0);\n+      return new_cost (address_cost [speed], 0);\n     }\n \n   switch (TREE_CODE (expr))\n@@ -3272,18 +3287,18 @@ force_expr_to_var_cost (tree expr)\n       if (is_gimple_val (op0))\n \tcost0 = zero_cost;\n       else\n-\tcost0 = force_expr_to_var_cost (op0);\n+\tcost0 = force_expr_to_var_cost (op0, speed);\n \n       if (is_gimple_val (op1))\n \tcost1 = zero_cost;\n       else\n-\tcost1 = force_expr_to_var_cost (op1);\n+\tcost1 = force_expr_to_var_cost (op1, speed);\n \n       break;\n \n     default:\n       /* Just an arbitrary value, FIXME.  */\n-      return new_cost (target_spill_cost, 0);\n+      return new_cost (target_spill_cost[speed], 0);\n     }\n \n   mode = TYPE_MODE (TREE_TYPE (expr));\n@@ -3292,16 +3307,16 @@ force_expr_to_var_cost (tree expr)\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      cost = new_cost (add_cost (mode), 0);\n+      cost = new_cost (add_cost (mode, speed), 0);\n       break;\n \n     case MULT_EXPR:\n       if (cst_and_fits_in_hwi (op0))\n-\tcost = new_cost (multiply_by_cost (int_cst_value (op0), mode), 0);\n-      else if (cst_and_fits_in_hwi (op1))\n-\tcost = new_cost (multiply_by_cost (int_cst_value (op1), mode), 0);\n+\tcost = new_cost (multiply_by_cost (int_cst_value (op0), mode, speed), 0);\n+      else if (cst_and_fits_in_hwi (op1))                                  \n+\tcost = new_cost (multiply_by_cost (int_cst_value (op1), mode, speed), 0);\n       else\n-\treturn new_cost (target_spill_cost, 0);\n+\treturn new_cost (target_spill_cost [speed], 0);\n       break;\n \n     default:\n@@ -3315,8 +3330,8 @@ force_expr_to_var_cost (tree expr)\n      computations often are either loop invariant or at least can\n      be shared between several iv uses, so letting this grow without\n      limits would not give reasonable results.  */\n-  if (cost.cost > target_spill_cost)\n-    cost.cost = target_spill_cost;\n+  if (cost.cost > target_spill_cost [speed])\n+    cost.cost = target_spill_cost [speed];\n \n   return cost;\n }\n@@ -3334,7 +3349,7 @@ force_var_cost (struct ivopts_data *data,\n       walk_tree (&expr, find_depends, depends_on, NULL);\n     }\n \n-  return force_expr_to_var_cost (expr);\n+  return force_expr_to_var_cost (expr, data->speed);\n }\n \n /* Estimates cost of expressing address ADDR  as var + symbol + offset.  The\n@@ -3365,7 +3380,7 @@ split_address_cost (struct ivopts_data *data,\n       *var_present = true;\n       fd_ivopts_data = data;\n       walk_tree (&addr, find_depends, depends_on, NULL);\n-      return new_cost (target_spill_cost, 0);\n+      return new_cost (target_spill_cost[data->speed], 0);\n     }\n \n   *offset += bitpos / BITS_PER_UNIT;\n@@ -3395,6 +3410,7 @@ ptr_difference_cost (struct ivopts_data *data,\n {\n   HOST_WIDE_INT diff = 0;\n   comp_cost cost;\n+  bool speed = optimize_loop_for_speed_p (data->current_loop);\n \n   gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n \n@@ -3415,7 +3431,7 @@ ptr_difference_cost (struct ivopts_data *data,\n   \n   cost = force_var_cost (data, e1, depends_on);\n   cost = add_costs (cost, force_var_cost (data, e2, depends_on));\n-  cost.cost += add_cost (Pmode);\n+  cost.cost += add_cost (Pmode, speed);\n \n   return cost;\n }\n@@ -3459,14 +3475,14 @@ difference_cost (struct ivopts_data *data,\n   if (integer_zerop (e1))\n     {\n       cost = force_var_cost (data, e2, depends_on);\n-      cost.cost += multiply_by_cost (-1, mode);\n+      cost.cost += multiply_by_cost (-1, mode, data->speed);\n \n       return cost;\n     }\n \n   cost = force_var_cost (data, e1, depends_on);\n   cost = add_costs (cost, force_var_cost (data, e2, depends_on));\n-  cost.cost += add_cost (mode);\n+  cost.cost += add_cost (mode, data->speed);\n \n   return cost;\n }\n@@ -3491,6 +3507,7 @@ get_computation_cost_at (struct ivopts_data *data,\n   comp_cost cost;\n   unsigned n_sums;\n   double_int rat;\n+  bool speed = optimize_bb_for_speed_p (gimple_bb (at));\n \n   *depends_on = NULL;\n \n@@ -3571,7 +3588,7 @@ get_computation_cost_at (struct ivopts_data *data,\n   else\n     {\n       cost = force_var_cost (data, cbase, depends_on);\n-      cost.cost += add_cost (TYPE_MODE (ctype));\n+      cost.cost += add_cost (TYPE_MODE (ctype), data->speed);\n       cost = add_costs (cost,\n \t\t\tdifference_cost (data,\n \t\t\t\t\t ubase, build_int_cst (utype, 0),\n@@ -3590,20 +3607,20 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (address_p)\n     return add_costs (cost, get_address_cost (symbol_present, var_present,\n \t\t\t\toffset, ratio,\n-\t\t\t\tTYPE_MODE (TREE_TYPE (*use->op_p))));\n+\t\t\t\tTYPE_MODE (TREE_TYPE (*use->op_p)), speed));\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   aratio = ratio > 0 ? ratio : -ratio;\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n-\tcost.cost += multiply_by_cost (ratio, TYPE_MODE (ctype));\n+\tcost.cost += multiply_by_cost (ratio, TYPE_MODE (ctype), speed);\n \n       return cost;\n     }\n \n   if (aratio != 1)\n-    cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype));\n+    cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype), speed);\n \n   n_sums = 1;\n   if (var_present\n@@ -3616,7 +3633,7 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (offset)\n     cost.complexity++;\n \n-  cost.cost += n_sums * add_cost (TYPE_MODE (ctype));\n+  cost.cost += n_sums * add_cost (TYPE_MODE (ctype), speed);\n   return cost;\n \n fallback:\n@@ -3630,7 +3647,7 @@ get_computation_cost_at (struct ivopts_data *data,\n     if (address_p)\n       comp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (comp)), comp);\n \n-    return new_cost (computation_cost (comp), 0);\n+    return new_cost (computation_cost (comp, speed), 0);\n   }\n }\n \n@@ -4008,7 +4025,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n \n   base = cand->iv->base;\n   cost_base = force_var_cost (data, base, NULL);\n-  cost_step = add_cost (TYPE_MODE (TREE_TYPE (base)));\n+  cost_step = add_cost (TYPE_MODE (TREE_TYPE (base)), data->speed);\n \n   cost = cost_step + cost_base.cost / AVG_LOOP_NITER (current_loop);\n \n@@ -4062,7 +4079,7 @@ ivopts_global_cost_for_size (struct ivopts_data *data, unsigned size)\n {\n   /* We add size to the cost, so that we prefer eliminating ivs\n      if possible.  */\n-  return size + estimate_reg_pressure_cost (size, data->regs_used);\n+  return size + estimate_reg_pressure_cost (size, data->regs_used, data->speed);\n }\n \n /* For each size of the induction variable set determine the penalty.  */\n@@ -4101,8 +4118,8 @@ determine_set_costs (struct ivopts_data *data)\n     {\n       fprintf (dump_file, \"Global costs:\\n\");\n       fprintf (dump_file, \"  target_avail_regs %d\\n\", target_avail_regs);\n-      fprintf (dump_file, \"  target_reg_cost %d\\n\", target_reg_cost);\n-      fprintf (dump_file, \"  target_spill_cost %d\\n\", target_spill_cost);\n+      fprintf (dump_file, \"  target_reg_cost %d\\n\", target_reg_cost[data->speed]);\n+      fprintf (dump_file, \"  target_spill_cost %d\\n\", target_spill_cost[data->speed]);\n     }\n \n   n = 0;\n@@ -5255,7 +5272,7 @@ rewrite_use_address (struct ivopts_data *data,\n   gcc_assert (ok);\n   unshare_aff_combination (&aff);\n \n-  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff);\n+  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff, data->speed);\n   copy_ref_info (ref, *use->op_p);\n   *use->op_p = ref;\n }\n@@ -5469,6 +5486,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n \n   gcc_assert (!data->niters);\n   data->current_loop = loop;\n+  data->speed = optimize_loop_for_speed_p (loop);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}]}