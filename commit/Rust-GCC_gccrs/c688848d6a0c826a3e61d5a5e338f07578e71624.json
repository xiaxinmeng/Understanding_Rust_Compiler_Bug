{"sha": "c688848d6a0c826a3e61d5a5e338f07578e71624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY4ODg0OGQ2YTBjODI2YTNlNjFkNWE1ZTMzOGYwNzU3OGU3MTYyNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-14T11:17:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-14T11:17:27Z"}, "message": "Fix indentation in testsuite utility header\n\n\t* testsuite/util/testsuite_allocator.h (memory_resource)\n\t(default_resource_mgr): Fix indentation.\n\nFrom-SVN: r271161", "tree": {"sha": "2fd75a08b6f5d0c62b55c486408ff3124d799a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fd75a08b6f5d0c62b55c486408ff3124d799a7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c688848d6a0c826a3e61d5a5e338f07578e71624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c688848d6a0c826a3e61d5a5e338f07578e71624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c688848d6a0c826a3e61d5a5e338f07578e71624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c688848d6a0c826a3e61d5a5e338f07578e71624/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066f9ea27960c21b73be820f2bcd62d0c2f3d6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066f9ea27960c21b73be820f2bcd62d0c2f3d6b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066f9ea27960c21b73be820f2bcd62d0c2f3d6b8"}], "stats": {"total": 269, "additions": 136, "deletions": 133}, "files": [{"sha": "3af9bf155a0678d461306727a6d703e9b4559d9b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c688848d6a0c826a3e61d5a5e338f07578e71624/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c688848d6a0c826a3e61d5a5e338f07578e71624/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c688848d6a0c826a3e61d5a5e338f07578e71624", "patch": "@@ -1,5 +1,8 @@\n 2019-05-14  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* testsuite/util/testsuite_allocator.h (memory_resource)\n+\t(default_resource_mgr): Fix indentation.\n+\n \t* testsuite/20_util/allocator_traits/members/allocate_hint_nonpod.cc:\n \tUse operator-> to access raw pointer member.\n \t* testsuite/23_containers/vector/59829.cc: Likewise."}, {"sha": "ac7dc8ee2c459c598810cf3ad4a86ce834ef84ba", "filename": "libstdc++-v3/testsuite/util/testsuite_allocator.h", "status": "modified", "additions": 133, "deletions": 133, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c688848d6a0c826a3e61d5a5e338f07578e71624/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c688848d6a0c826a3e61d5a5e338f07578e71624/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h?ref=c688848d6a0c826a3e61d5a5e338f07578e71624", "patch": "@@ -743,162 +743,162 @@ namespace __gnu_test\n \n #if __cplusplus >= 201703L\n #if __cpp_aligned_new && __cpp_rtti\n-    // A concrete memory_resource, with error checking.\n-    class memory_resource : public std::pmr::memory_resource\n-    {\n-    public:\n-      memory_resource()\n-      : lists(new allocation_lists)\n-      { }\n+  // A concrete memory_resource, with error checking.\n+  class memory_resource : public std::pmr::memory_resource\n+  {\n+  public:\n+    memory_resource()\n+    : lists(new allocation_lists)\n+    { }\n \n-      memory_resource(const memory_resource& r) noexcept\n-      : lists(r.lists)\n-      { lists->refcount++; }\n+    memory_resource(const memory_resource& r) noexcept\n+    : lists(r.lists)\n+    { lists->refcount++; }\n \n-      memory_resource& operator=(const memory_resource&) = delete;\n+    memory_resource& operator=(const memory_resource&) = delete;\n \n-      ~memory_resource()\n-      {\n-\tif (lists->refcount-- == 1)\n-\t  delete lists;  // last one out turns out the lights\n-      }\n+    ~memory_resource()\n+    {\n+      if (lists->refcount-- == 1)\n+\tdelete lists;  // last one out turns out the lights\n+    }\n \n-      struct bad_size { };\n-      struct bad_alignment { };\n-      struct bad_address { };\n+    struct bad_size { };\n+    struct bad_alignment { };\n+    struct bad_address { };\n \n-      // Deallocate everything (moving the tracking info to the freed list)\n-      void\n-      deallocate_everything()\n-      {\n-\twhile (lists->active)\n-\t  {\n-\t    auto a = lists->active;\n-\t    // Intentionally virtual dispatch, to inform derived classes:\n-\t    this->do_deallocate(a->p, a->bytes, a->alignment);\n-\t  }\n-      }\n+    // Deallocate everything (moving the tracking info to the freed list)\n+    void\n+    deallocate_everything()\n+    {\n+      while (lists->active)\n+\t{\n+\t  auto a = lists->active;\n+\t  // Intentionally virtual dispatch, to inform derived classes:\n+\t  this->do_deallocate(a->p, a->bytes, a->alignment);\n+\t}\n+    }\n \n-      // Clear the freed list\n-      void\n-      forget_freed_allocations()\n-      { lists->forget_allocations(lists->freed); }\n+    // Clear the freed list\n+    void\n+    forget_freed_allocations()\n+    { lists->forget_allocations(lists->freed); }\n \n-      // Count how many allocations have been done and not freed.\n-      std::size_t\n-      number_of_active_allocations() const noexcept\n-      {\n-\tstd::size_t n = 0;\n-\tfor (auto a = lists->active; a != nullptr; a = a->next)\n-\t  ++n;\n-\treturn n;\n-      }\n+    // Count how many allocations have been done and not freed.\n+    std::size_t\n+    number_of_active_allocations() const noexcept\n+    {\n+      std::size_t n = 0;\n+      for (auto a = lists->active; a != nullptr; a = a->next)\n+\t++n;\n+      return n;\n+    }\n \n-    protected:\n-      void*\n-      do_allocate(std::size_t bytes, std::size_t alignment) override\n-      {\n-\t// TODO perform a single allocation and put the allocation struct\n-\t// in the buffer using placement new? It means deallocation won't\n-\t// actually return memory to the OS, as it will stay in lists->freed.\n-\t//\n-\t// TODO adjust the returned pointer to be minimally aligned?\n-\t// e.g. if alignment==1 don't return something aligned to 2 bytes.\n-\t// Maybe not worth it, at least monotonic_buffer_resource will\n-\t// never ask upstream for anything with small alignment.\n-\tvoid* p = ::operator new(bytes, std::align_val_t(alignment));\n-\tlists->active = new allocation{p, bytes, alignment, lists->active};\n-\treturn p;\n-      }\n+  protected:\n+    void*\n+    do_allocate(std::size_t bytes, std::size_t alignment) override\n+    {\n+      // TODO perform a single allocation and put the allocation struct\n+      // in the buffer using placement new? It means deallocation won't\n+      // actually return memory to the OS, as it will stay in lists->freed.\n+      //\n+      // TODO adjust the returned pointer to be minimally aligned?\n+      // e.g. if alignment==1 don't return something aligned to 2 bytes.\n+      // Maybe not worth it, at least monotonic_buffer_resource will\n+      // never ask upstream for anything with small alignment.\n+      void* p = ::operator new(bytes, std::align_val_t(alignment));\n+      lists->active = new allocation{p, bytes, alignment, lists->active};\n+      return p;\n+    }\n \n-      void\n-      do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n-      {\n-\tallocation** aptr = &lists->active;\n-\twhile (*aptr)\n-\t  {\n-\t    allocation* a = *aptr;\n-\t    if (p == a->p)\n-\t      {\n-\t\tif (bytes != a->bytes)\n-\t\t  throw bad_size();\n-\t\tif (alignment != a->alignment)\n-\t\t  throw bad_alignment();\n+    void\n+    do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n+    {\n+      allocation** aptr = &lists->active;\n+      while (*aptr)\n+\t{\n+\t  allocation* a = *aptr;\n+\t  if (p == a->p)\n+\t    {\n+\t      if (bytes != a->bytes)\n+\t\tthrow bad_size();\n+\t      if (alignment != a->alignment)\n+\t\tthrow bad_alignment();\n #if __cpp_sized_deallocation\n-\t\t::operator delete(p, bytes, std::align_val_t(alignment));\n+\t      ::operator delete(p, bytes, std::align_val_t(alignment));\n #else\n-\t\t::operator delete(p, std::align_val_t(alignment));\n+\t      ::operator delete(p, std::align_val_t(alignment));\n #endif\n-\t\t*aptr = a->next;\n-\t\ta->next = lists->freed;\n-\t\tlists->freed = a;\n-\t\treturn;\n-\t      }\n-\t    aptr = &a->next;\n-\t  }\n-\tthrow bad_address();\n-      }\n-\n-      bool\n-      do_is_equal(const std::pmr::memory_resource& r) const noexcept override\n-      {\n-\t// Equality is determined by sharing the same allocation_lists object.\n-\tif (auto p = dynamic_cast<const memory_resource*>(&r))\n-\t  return p->lists == lists;\n-\treturn false;\n-      }\n-\n-    private:\n-      struct allocation\n-      {\n-\tvoid* p;\n-\tstd::size_t bytes;\n-\tstd::size_t alignment;\n-\tallocation* next;\n-      };\n-\n-      // Maintain list of allocated blocks and list of freed blocks.\n-      // Copies of this memory_resource share the same ref-counted lists.\n-      struct allocation_lists\n-      {\n-\tunsigned refcount = 1;\n-\tallocation* active = nullptr;\n-\tallocation* freed = nullptr;\n-\n-\tvoid forget_allocations(allocation*& list)\n-\t{\n-\t  while (list)\n-\t    {\n-\t      auto p = list;\n-\t      list = list->next;\n-\t      delete p;\n+\t      *aptr = a->next;\n+\t      a->next = lists->freed;\n+\t      lists->freed = a;\n+\t      return;\n \t    }\n+\t  aptr = &a->next;\n \t}\n+      throw bad_address();\n+    }\n \n-\t~allocation_lists()\n-\t{\n-\t  forget_allocations(active); // Anything in this list is a leak!\n-\t  forget_allocations(freed);\n-\t}\n-      };\n+    bool\n+    do_is_equal(const std::pmr::memory_resource& r) const noexcept override\n+    {\n+      // Equality is determined by sharing the same allocation_lists object.\n+      if (auto p = dynamic_cast<const memory_resource*>(&r))\n+\treturn p->lists == lists;\n+      return false;\n+    }\n \n-      allocation_lists* lists;\n+  private:\n+    struct allocation\n+    {\n+      void* p;\n+      std::size_t bytes;\n+      std::size_t alignment;\n+      allocation* next;\n     };\n-#endif // aligned-new && rtti\n \n-    // Set the default resource, and restore the previous one on destruction.\n-    struct default_resource_mgr\n+    // Maintain list of allocated blocks and list of freed blocks.\n+    // Copies of this memory_resource share the same ref-counted lists.\n+    struct allocation_lists\n     {\n-      explicit default_resource_mgr(std::pmr::memory_resource* r)\n-      : prev(std::pmr::set_default_resource(r))\n-      { }\n+      unsigned refcount = 1;\n+      allocation* active = nullptr;\n+      allocation* freed = nullptr;\n \n-      ~default_resource_mgr()\n-      { std::pmr::set_default_resource(prev); }\n+      void forget_allocations(allocation*& list)\n+      {\n+\twhile (list)\n+\t  {\n+\t    auto p = list;\n+\t    list = list->next;\n+\t    delete p;\n+\t  }\n+      }\n \n-      std::pmr::memory_resource* prev;\n+      ~allocation_lists()\n+      {\n+\tforget_allocations(active); // Anything in this list is a leak!\n+\tforget_allocations(freed);\n+      }\n     };\n \n+    allocation_lists* lists;\n+  };\n+#endif // aligned-new && rtti\n+\n+  // Set the default resource, and restore the previous one on destruction.\n+  struct default_resource_mgr\n+  {\n+    explicit default_resource_mgr(std::pmr::memory_resource* r)\n+    : prev(std::pmr::set_default_resource(r))\n+    { }\n+\n+    ~default_resource_mgr()\n+    { std::pmr::set_default_resource(prev); }\n+\n+    std::pmr::memory_resource* prev;\n+  };\n+\n #endif // C++17\n \n } // namespace __gnu_test"}]}