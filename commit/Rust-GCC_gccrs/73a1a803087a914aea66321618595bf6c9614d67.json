{"sha": "73a1a803087a914aea66321618595bf6c9614d67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhMWE4MDMwODdhOTE0YWVhNjYzMjE2MTg1OTViZjZjOTYxNGQ2Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-06-01T07:43:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-06-01T07:43:09Z"}, "message": "gigi.h (build_simple_component_ref): Declare.\n\n\t* gcc-interface/gigi.h (build_simple_component_ref): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Deal with\n\taddress clause on aliased object with unconstrained nominal subtype.\n\tMark the aligning variable as artificial, do not convert the address\n\texpression immediately but mark it as constant instead.\n\t* gcc-interface/utils.c (convert): If the target type contains a\n\ttemplate, be prepared for an empty array.\n\t(maybe_unconstrained_array): Likewise.\n\t* gcc-interface/utils2.c (known_alignment) <POINTER_PLUS_EXPR>: Deal\n\twith the pattern built for aligning types.\n\t<INTEGER_CST>: Do not cap the value at BIGGEST_ALIGNMENT.\n\t(build_simple_component_ref): Make public.\n\tIf the base object is a constructor that contains a template, fold the\n\tresult field by field.\n\nFrom-SVN: r223912", "tree": {"sha": "48929d331a115d7eb4d733c54e68da63d015f2da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48929d331a115d7eb4d733c54e68da63d015f2da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a1a803087a914aea66321618595bf6c9614d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a1a803087a914aea66321618595bf6c9614d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a1a803087a914aea66321618595bf6c9614d67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a1a803087a914aea66321618595bf6c9614d67/comments", "author": null, "committer": null, "parents": [{"sha": "fcdc67186be6960edfa1905abf8c208c4df3713a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdc67186be6960edfa1905abf8c208c4df3713a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcdc67186be6960edfa1905abf8c208c4df3713a"}], "stats": {"total": 344, "additions": 295, "deletions": 49}, "files": [{"sha": "a2887e88b0e9fbc52eba72b572596f20c0840b37", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -1,3 +1,20 @@\n+2015-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (build_simple_component_ref): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Deal with\n+\taddress clause on aliased object with unconstrained nominal subtype.\n+\tMark the aligning variable as artificial, do not convert the address\n+\texpression immediately but mark it as constant instead.\n+\t* gcc-interface/utils.c (convert): If the target type contains a\n+\ttemplate, be prepared for an empty array.\n+\t(maybe_unconstrained_array): Likewise.\n+\t* gcc-interface/utils2.c (known_alignment) <POINTER_PLUS_EXPR>: Deal\n+\twith the pattern built for aligning types.\n+\t<INTEGER_CST>: Do not cap the value at BIGGEST_ALIGNMENT.\n+\t(build_simple_component_ref): Make public.\n+\tIf the base object is a constructor that contains a template, fold the\n+\tresult field by field.\n+\n 2015-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* s-oscons-tmplt.c: Add explicit tests for Android alongside Linux."}, {"sha": "966bf8e1309e3cabcc73f2e36ad79fe102e78b99", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 62, "deletions": 23, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -882,8 +882,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    check_ok_for_atomic_type (gnu_inner, gnat_entity, true);\n \t  }\n \n-\t/* If this is an aliased object with an unconstrained nominal subtype,\n-\t   make a type that includes the template.  */\n+\t/* If this is an aliased object with an unconstrained array nominal\n+\t   subtype, make a type that includes the template.  We will either\n+\t   allocate or create a variable of that type, see below.  */\n \tif (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n \t    && Is_Array_Type (Underlying_Type (Etype (gnat_entity)))\n \t    && !type_annotate_only)\n@@ -1149,7 +1150,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   effects in this case.  */\n \tif (definition && Present (Address_Clause (gnat_entity)))\n \t  {\n-\t    Node_Id gnat_expr = Expression (Address_Clause (gnat_entity));\n+\t    const Node_Id gnat_clause = Address_Clause (gnat_entity);\n+\t    Node_Id gnat_expr = Expression (gnat_clause);\n \t    tree gnu_address\n \t      = present_gnu_tree (gnat_entity)\n \t\t? get_gnu_tree (gnat_entity) : gnat_to_gnu (gnat_expr);\n@@ -1167,6 +1169,40 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| compile_time_known_address_p (gnat_expr);\n \t    gnu_size = NULL_TREE;\n \n+\t    /* If this is an aliased object with an unconstrained array nominal\n+\t       subtype, then it can overlay only another aliased object with an\n+\t       unconstrained array nominal subtype and compatible template.  */\n+\t    if (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n+\t\t&& Is_Array_Type (Underlying_Type (Etype (gnat_entity)))\n+\t\t&& !type_annotate_only)\n+\t      {\n+\t\ttree rec_type = TREE_TYPE (gnu_type);\n+\t\ttree off = byte_position (DECL_CHAIN (TYPE_FIELDS (rec_type)));\n+\n+\t\t/* This is the pattern built for a regular object.  */\n+\t\tif (TREE_CODE (gnu_address) == POINTER_PLUS_EXPR\n+\t\t    && TREE_OPERAND (gnu_address, 1) == off)\n+\t\t  gnu_address = TREE_OPERAND (gnu_address, 0);\n+\t\t/* This is the pattern built for an overaligned object.  */\n+\t\telse if (TREE_CODE (gnu_address) == POINTER_PLUS_EXPR\n+\t\t\t && TREE_CODE (TREE_OPERAND (gnu_address, 1))\n+\t\t\t    == PLUS_EXPR\n+\t\t\t && TREE_OPERAND (TREE_OPERAND (gnu_address, 1), 1)\n+\t\t\t    == off)\n+\t\t  gnu_address\n+\t\t    = build2 (POINTER_PLUS_EXPR, gnu_type,\n+\t\t\t      TREE_OPERAND (gnu_address, 0),\n+\t\t\t      TREE_OPERAND (TREE_OPERAND (gnu_address, 1), 0));\n+\t\telse\n+\t\t  {\n+\t\t    post_error_ne (\"aliased object& with unconstrained array \"\n+\t\t\t\t   \"nominal subtype\", gnat_clause,\n+\t\t\t\t   gnat_entity);\n+\t\t    post_error (\"\\\\can overlay only aliased object with \"\n+\t\t\t\t\"compatible subtype\", gnat_clause);\n+\t\t  }\n+\t      }\n+\n \t    /* If this is a deferred constant, the initializer is attached to\n \t       the full view.  */\n \t    if (kind == E_Constant && Present (Full_View (gnat_entity)))\n@@ -1183,11 +1219,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    else\n \t      gnu_expr\n \t\t= build2 (COMPOUND_EXPR, gnu_type,\n-\t\t\t  build_binary_op\n-\t\t\t  (MODIFY_EXPR, NULL_TREE,\n-\t\t\t   build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t\t   gnu_address),\n-\t\t\t   gnu_expr),\n+\t\t\t  build_binary_op (INIT_EXPR, NULL_TREE,\n+\t\t\t\t\t   build_unary_op (INDIRECT_REF,\n+\t\t\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t\t\t   gnu_address),\n+\t\t\t\t\t   gnu_expr),\n \t\t\t  gnu_address);\n \t  }\n \n@@ -1302,8 +1338,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If this object would go into the stack and has an alignment larger\n \t   than the largest stack alignment the back-end can honor, resort to\n \t   a variable of \"aligning type\".  */\n-\tif (!global_bindings_p () && !static_p && definition\n-\t    && !imported_p && TYPE_ALIGN (gnu_type) > BIGGEST_ALIGNMENT)\n+\tif (definition\n+\t    && !global_bindings_p ()\n+\t    && !static_p\n+\t    && !imported_p\n+\t    && TYPE_ALIGN (gnu_type) > BIGGEST_ALIGNMENT)\n \t  {\n \t    /* Create the new variable.  No need for extra room before the\n \t       aligned field as this is in automatic storage.  */\n@@ -1315,11 +1354,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n \t\t\t\t NULL_TREE, gnu_new_type, NULL_TREE, false,\n \t\t\t\t false, false, false, NULL, gnat_entity);\n+\t    DECL_ARTIFICIAL (gnu_new_var) = 1;\n \n \t    /* Initialize the aligned field if we have an initializer.  */\n \t    if (gnu_expr)\n \t      add_stmt_with_node\n-\t\t(build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t(build_binary_op (INIT_EXPR, NULL_TREE,\n \t\t\t\t  build_component_ref\n \t\t\t\t  (gnu_new_var, NULL_TREE,\n \t\t\t\t   TYPE_FIELDS (gnu_new_type), false),\n@@ -1330,28 +1370,26 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_type = build_reference_type (gnu_type);\n \t    gnu_expr\n \t      = build_unary_op\n-\t\t(ADDR_EXPR, gnu_type,\n+\t\t(ADDR_EXPR, NULL_TREE,\n \t\t build_component_ref (gnu_new_var, NULL_TREE,\n \t\t\t\t      TYPE_FIELDS (gnu_new_type), false));\n+\t    TREE_CONSTANT (gnu_expr) = 1;\n \n \t    used_by_ref = true;\n \t    const_flag = true;\n \t    gnu_size = NULL_TREE;\n \t  }\n \n-\t/* If this is an aliased object with an unconstrained nominal subtype,\n-\t   we make its type a thin reference, i.e. the reference counterpart\n-\t   of a thin pointer, so that it points to the array part.  This is\n-\t   aimed at making it easier for the debugger to decode the object.\n-\t   Note that we have to do that this late because of the couple of\n-\t   allocation adjustments that might be made just above.  */\n+\t/* If this is an aliased object with an unconstrained array nominal\n+\t   subtype, we make its type a thin reference, i.e. the reference\n+\t   counterpart of a thin pointer, so it points to the array part.\n+\t   This is aimed to make it easier for the debugger to decode the\n+\t   object.  Note that we have to do it this late because of the\n+\t   couple of allocation adjustments that might be made above.  */\n \tif (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n \t    && Is_Array_Type (Underlying_Type (Etype (gnat_entity)))\n \t    && !type_annotate_only)\n \t  {\n-\t    tree gnu_array\n-\t      = gnat_to_gnu_type (Base_Type (Etype (gnat_entity)));\n-\n \t    /* In case the object with the template has already been allocated\n \t       just above, we have nothing to do here.  */\n \t    if (!TYPE_IS_THIN_POINTER_P (gnu_type))\n@@ -1362,8 +1400,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t      const_flag, Is_Public (gnat_entity),\n \t\t\t\t      imported_p || !definition, static_p,\n \t\t\t\t      NULL, gnat_entity);\n-\t\tgnu_expr\n-\t\t  = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_unc_var);\n+\t\tgnu_expr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_unc_var);\n \t\tTREE_CONSTANT (gnu_expr) = 1;\n \n \t\tused_by_ref = true;\n@@ -1372,6 +1409,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_size = NULL_TREE;\n \t      }\n \n+\t    tree gnu_array\n+\t      = gnat_to_gnu_type (Base_Type (Etype (gnat_entity)));\n \t    gnu_type\n \t      = build_reference_type (TYPE_OBJECT_RECORD_TYPE (gnu_array));\n \t  }"}, {"sha": "91d9f9cfb581ae5a35b8f96e6db8e1c6f5c1e71e", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -914,6 +914,11 @@ extern tree gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v);\n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n    for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n+extern tree build_simple_component_ref (tree record_variable, tree component,\n+\t\t\t\t\ttree field, bool no_fold_p);\n+\n+/* Likewise, but generate a Constraint_Error if the reference could not be\n+   found.  */\n extern tree build_component_ref (tree record_variable, tree component,\n                                  tree field, bool no_fold_p);\n "}, {"sha": "31bb3d254ed914937e583988d44867f2fb9a917e", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -4092,8 +4092,9 @@ convert (tree type, tree expr)\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n \t\t\t      build_template (TREE_TYPE (TYPE_FIELDS (type)),\n \t\t\t\t\t      obj_type, NULL_TREE));\n-      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t      convert (obj_type, expr));\n+      if (expr)\n+\tCONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n+\t\t\t\tconvert (obj_type, expr));\n       return gnat_build_constructor (type, v);\n     }\n \n@@ -4699,14 +4700,13 @@ maybe_unconstrained_array (tree exp)\n \n       if (TYPE_CONTAINS_TEMPLATE_P (type))\n \t{\n-\t  exp = build_component_ref (exp, NULL_TREE,\n-\t\t\t\t     DECL_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t\t     false);\n-\t  type = TREE_TYPE (exp);\n+\t  exp = build_simple_component_ref (exp, NULL_TREE,\n+\t\t\t\t\t    DECL_CHAIN (TYPE_FIELDS (type)),\n+\t\t\t\t\t    false);\n \n \t  /* If the array type is padded, convert to the unpadded type.  */\n-\t  if (TYPE_IS_PADDING_P (type))\n-\t    exp = convert (TREE_TYPE (TYPE_FIELDS (type)), exp);\n+\t  if (exp && TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n+\t    exp = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n \t}\n       break;\n "}, {"sha": "12d9ea95d7cbe0f00b417f083dea2ea7159572a2", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -78,9 +78,9 @@ get_base_type (tree type)\n   return type;\n }\n \f\n-/* EXP is a GCC tree representing an address.  See if we can find how\n-   strictly the object at that address is aligned.   Return that alignment\n-   in bits.  If we don't know anything about the alignment, return 0.  */\n+/* EXP is a GCC tree representing an address.  See if we can find how strictly\n+   the object at this address is aligned and, if so, return the alignment of\n+   the object in bits.  Otherwise return 0.  */\n \n unsigned int\n known_alignment (tree exp)\n@@ -99,32 +99,42 @@ known_alignment (tree exp)\n       break;\n \n     case COMPOUND_EXPR:\n-      /* The value of a COMPOUND_EXPR is that of it's second operand.  */\n+      /* The value of a COMPOUND_EXPR is that of its second operand.  */\n       this_alignment = known_alignment (TREE_OPERAND (exp, 1));\n       break;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      /* If two address are added, the alignment of the result is the\n+      /* If two addresses are added, the alignment of the result is the\n \t minimum of the two alignments.  */\n       lhs = known_alignment (TREE_OPERAND (exp, 0));\n       rhs = known_alignment (TREE_OPERAND (exp, 1));\n       this_alignment = MIN (lhs, rhs);\n       break;\n \n     case POINTER_PLUS_EXPR:\n-      lhs = known_alignment (TREE_OPERAND (exp, 0));\n-      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+      /* If this is the pattern built for aligning types, decode it.  */\n+      if (TREE_CODE (TREE_OPERAND (exp, 1)) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)) == NEGATE_EXPR)\n+\t{\n+\t  tree op = TREE_OPERAND (TREE_OPERAND (exp, 1), 1);\n+\t  return\n+\t    known_alignment (fold_build1 (BIT_NOT_EXPR, TREE_TYPE (op), op));\n+\t}\n+\n       /* If we don't know the alignment of the offset, we assume that\n \t of the base.  */\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+\n       if (rhs == 0)\n \tthis_alignment = lhs;\n       else\n \tthis_alignment = MIN (lhs, rhs);\n       break;\n \n     case COND_EXPR:\n-      /* If there is a choice between two values, use the smallest one.  */\n+      /* If there is a choice between two values, use the smaller one.  */\n       lhs = known_alignment (TREE_OPERAND (exp, 1));\n       rhs = known_alignment (TREE_OPERAND (exp, 2));\n       this_alignment = MIN (lhs, rhs);\n@@ -135,7 +145,7 @@ known_alignment (tree exp)\n \tunsigned HOST_WIDE_INT c = TREE_INT_CST_LOW (exp);\n \t/* The first part of this represents the lowest bit in the constant,\n \t   but it is originally in bytes, not bits.  */\n-\tthis_alignment = MIN (BITS_PER_UNIT * (c & -c), BIGGEST_ALIGNMENT);\n+\tthis_alignment = (c & -c) * BITS_PER_UNIT;\n       }\n       break;\n \n@@ -172,7 +182,7 @@ known_alignment (tree exp)\n \t  return known_alignment (t);\n       }\n \n-      /* Fall through... */\n+      /* ... fall through ... */\n \n     default:\n       /* For other pointer expressions, we assume that the pointed-to object\n@@ -1990,7 +2000,7 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n    We also handle the fact that we might have been passed a pointer to the\n    actual record and know how to look for fields in variant parts.  */\n \n-static tree\n+tree\n build_simple_component_ref (tree record_variable, tree component, tree field,\n \t\t\t    bool no_fold_p)\n {\n@@ -2128,18 +2138,26 @@ build_simple_component_ref (tree record_variable, tree component, tree field,\n   if (TREE_CODE (base) == CONSTRUCTOR\n       && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (base)))\n     {\n-      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (base);\n-      unsigned HOST_WIDE_INT idx;\n-      tree index, value;\n-      FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n-\tif (index == field)\n-\t  return value;\n+      unsigned int len = CONSTRUCTOR_NELTS (base);\n+      gcc_assert (len > 0);\n+\n+      if (field == CONSTRUCTOR_ELT (base, 0)->index)\n+\treturn CONSTRUCTOR_ELT (base, 0)->value;\n+\n+      if (len > 1)\n+\t{\n+\t  if (field == CONSTRUCTOR_ELT (base, 1)->index)\n+\t    return CONSTRUCTOR_ELT (base, 1)->value;\n+\t}\n+      else\n+\treturn NULL_TREE;\n+\n       return ref;\n     }\n \n   return fold (ref);\n }\n-\f\n+\n /* Likewise, but generate a Constraint_Error if the reference could not be\n    found.  */\n "}, {"sha": "3cafd133bc5a9cfec699efb5ec98a31f74f57a7d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -1,3 +1,10 @@\n+2015-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/addr9_1.adb: New test.\n+\t* gnat.dg/addr9_2.adb: Likewise.\n+\t* gnat.dg/addr9_3.adb: Likewise.\n+\t* gnat.dg/addr9_4.adb: Likewise.\n+\n 2015-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t  * g++.dg/other/dump-ada-spec-4.C: New test."}, {"sha": "d3fc335b9824ee5fccdfc2272b3410876da9af3b", "filename": "gcc/testsuite/gnat.dg/addr9_1.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_1.adb?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -0,0 +1,40 @@\n+-- { dg-do compile }\r\n+\r\n+with Ada.Streams; use Ada.Streams;\r\n+\r\n+procedure Addr9_1 is\r\n+\r\n+   type Signal_Type is mod 2 ** 16;\r\n+\r\n+   type A_Item is record\r\n+      I : Signal_Type;\r\n+      Q : Signal_Type;\r\n+   end record\r\n+   with Size => 32;\r\n+\r\n+   for A_Item use record\r\n+      I at 0 range 0 .. 15;\r\n+      Q at 2 range 0 .. 15;\r\n+   end record;\r\n+\r\n+   type A_Array_Type is\r\n+     array (Positive range <>)\r\n+     of A_Item\r\n+   with Alignment => 16;\r\n+\r\n+   pragma Pack (A_Array_Type);\r\n+\r\n+   type B_Array_Type is new Ada.Streams.Stream_Element_Array\r\n+   with Alignment => 16;\r\n+\r\n+   Ct_Count : constant := 7_000;\r\n+\r\n+   package Set is\r\n+      A : aliased A_Array_Type := (1 .. Ct_Count => <>);\r\n+      B : aliased B_Array_Type := (1 .. Ct_Count * A_Item'Size / 8 => <>);\r\n+      for B'Address use A'Address;\r\n+   end Set;\r\n+\r\n+begin\r\n+   null;\r\n+end;\r"}, {"sha": "64130e264c9562667ad530c56cf57bb369444cf9", "filename": "gcc/testsuite/gnat.dg/addr9_2.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_2.adb?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -0,0 +1,40 @@\n+-- { dg-do compile }\r\n+\r\n+with Ada.Streams; use Ada.Streams;\r\n+\r\n+procedure Addr9_2 is\r\n+\r\n+   type Signal_Type is mod 2 ** 16;\r\n+\r\n+   type A_Item is record\r\n+      I : Signal_Type;\r\n+      Q : Signal_Type;\r\n+   end record\r\n+   with Size => 32;\r\n+\r\n+   for A_Item use record\r\n+      I at 0 range 0 .. 15;\r\n+      Q at 2 range 0 .. 15;\r\n+   end record;\r\n+\r\n+   type A_Array_Type is\r\n+     array (Positive range <>)\r\n+     of A_Item\r\n+   with Alignment => 16;\r\n+\r\n+   pragma Pack (A_Array_Type);\r\n+\r\n+   type B_Array_Type is new Ada.Streams.Stream_Element_Array\r\n+   with Alignment => 16;\r\n+\r\n+   Ct_Count : constant := 7_000;\r\n+\r\n+   package Set is\r\n+      A : A_Array_Type := (1 .. Ct_Count => <>);\r\n+      B : aliased B_Array_Type := (1 .. Ct_Count * A_Item'Size / 8 => <>);\r\n+      for B'Address use A'Address; -- { dg-warning \"aliased object\" }\r\n+   end Set;\r\n+\r\n+begin\r\n+   null;\r\n+end;\r"}, {"sha": "f7e31621551cc513e2045dd1346dc2c10ae1e87e", "filename": "gcc/testsuite/gnat.dg/addr9_3.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_3.adb?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -0,0 +1,40 @@\n+-- { dg-do compile }\r\n+\r\n+with Ada.Streams; use Ada.Streams;\r\n+\r\n+procedure Addr9_3 is\r\n+\r\n+   type Signal_Type is mod 2 ** 16;\r\n+\r\n+   type A_Item is record\r\n+      I : Signal_Type;\r\n+      Q : Signal_Type;\r\n+   end record\r\n+   with Size => 32;\r\n+\r\n+   for A_Item use record\r\n+      I at 0 range 0 .. 15;\r\n+      Q at 2 range 0 .. 15;\r\n+   end record;\r\n+\r\n+   type A_Array_Type is\r\n+     array (Positive range <>)\r\n+     of A_Item\r\n+   with Alignment => 16;\r\n+\r\n+   pragma Pack (A_Array_Type);\r\n+\r\n+   type B_Array_Type is new Ada.Streams.Stream_Element_Array\r\n+   with Alignment => 16;\r\n+\r\n+   Ct_Count : constant := 7_000;\r\n+\r\n+   package Set is\r\n+      A : aliased A_Array_Type := (1 .. Ct_Count => <>);\r\n+      B : B_Array_Type := (1 .. Ct_Count * A_Item'Size / 8 => <>);\r\n+      for B'Address use A'Address;\r\n+   end Set;\r\n+\r\n+begin\r\n+   null;\r\n+end;\r"}, {"sha": "526d2a01514463532c68fd253afbbcde138e970d", "filename": "gcc/testsuite/gnat.dg/addr9_4.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a1a803087a914aea66321618595bf6c9614d67/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faddr9_4.adb?ref=73a1a803087a914aea66321618595bf6c9614d67", "patch": "@@ -0,0 +1,40 @@\n+-- { dg-do compile }\r\n+\r\n+with Ada.Streams; use Ada.Streams;\r\n+\r\n+procedure Addr9_4 is\r\n+\r\n+   type Signal_Type is mod 2 ** 16;\r\n+\r\n+   type A_Item is record\r\n+      I : Signal_Type;\r\n+      Q : Signal_Type;\r\n+   end record\r\n+   with Size => 32;\r\n+\r\n+   for A_Item use record\r\n+      I at 0 range 0 .. 15;\r\n+      Q at 2 range 0 .. 15;\r\n+   end record;\r\n+\r\n+   type A_Array_Type is\r\n+     array (Positive range <>)\r\n+     of A_Item\r\n+   with Alignment => 16;\r\n+\r\n+   pragma Pack (A_Array_Type);\r\n+\r\n+   type B_Array_Type is new Ada.Streams.Stream_Element_Array\r\n+   with Alignment => 16;\r\n+\r\n+   Ct_Count : constant := 7_000;\r\n+\r\n+   package Set is\r\n+      A : A_Array_Type := (1 .. Ct_Count => <>);\r\n+      B : B_Array_Type := (1 .. Ct_Count * A_Item'Size / 8 => <>);\r\n+      for B'Address use A'Address;\r\n+   end Set;\r\n+\r\n+begin\r\n+   null;\r\n+end;\r"}]}