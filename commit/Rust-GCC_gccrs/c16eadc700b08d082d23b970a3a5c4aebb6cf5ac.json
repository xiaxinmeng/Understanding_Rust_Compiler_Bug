{"sha": "c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE2ZWFkYzcwMGIwOGQwODJkMjNiOTcwYTNhNWM0YWViYjZjZjVhYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-10-11T14:22:54Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-11T14:22:54Z"}, "message": "lb1sf68.asm: Follow spelling conventions.\n\n\t* config/m68k/lb1sf68.asm: Follow spelling conventions.\n\t* config/m68k/m68k.c: Likewise.\n\t* config/m68k/m68k.h: Likewise.\n\t* config/m68k/m68k.md: Likewise.\n\nFrom-SVN: r72336", "tree": {"sha": "a6401873c13d46bbe28cb405a16266dec306bd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6401873c13d46bbe28cb405a16266dec306bd8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/comments", "author": null, "committer": null, "parents": [{"sha": "ea82015ce986194da3d0f20d48accede0174d3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea82015ce986194da3d0f20d48accede0174d3e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea82015ce986194da3d0f20d48accede0174d3e2"}], "stats": {"total": 53, "additions": 30, "deletions": 23}, "files": [{"sha": "c71aaa57434b806ed07ffa1bc0632f303dbc0ac6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "patch": "@@ -1,3 +1,10 @@\n+2003-10-11  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/m68k/lb1sf68.asm: Follow spelling conventions.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* config/m68k/m68k.h: Likewise.\n+\t* config/m68k/m68k.md: Likewise.\n+\n 2003-10-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (expand_builtin_memcpy): Optimize case when the two"}, {"sha": "755f1af84da2be0fce7da303306dfb09a693deab", "filename": "gcc/config/m68k/lb1sf68.asm", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm?ref=c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "patch": "@@ -416,11 +416,11 @@ L4:\tlsrl\tIMM (1), d1\t/* shift divisor */\n \tlsrl\tIMM (1), d0\t/* shift dividend */\n \tcmpl\tIMM (0x10000), d1 /* still divisor >= 2 ^ 16 ?  */\n \tjcc\tL4\n-\tdivu\td1, d0\t\t/* now we have 16 bit divisor */\n+\tdivu\td1, d0\t\t/* now we have 16-bit divisor */\n \tandl\tIMM (0xffff), d0 /* mask out divisor, ignore remainder */\n \n-/* Multiply the 16 bit tentative quotient with the 32 bit divisor.  Because of\n-   the operand ranges, this might give a 33 bit product.  If this product is\n+/* Multiply the 16-bit tentative quotient with the 32-bit divisor.  Because of\n+   the operand ranges, this might give a 33-bit product.  If this product is\n    greater than the dividend, the tentative quotient was too large. */\n \tmovel\td2, d1\n \tmulu\td0, d1\t\t/* low part, 32 bits */\n@@ -440,7 +440,7 @@ L6:\tmovel\tsp@+, d2\n \n #else /* __mcoldfire__ */\n \n-/* Coldfire implementation of non-restoring division algorithm from\n+/* ColdFire implementation of non-restoring division algorithm from\n    Hennessy & Patterson, Appendix A. */\n \tlink\ta6,IMM (-12)\n \tmoveml\td2-d4,sp@"}, {"sha": "e2215d17817477096d11fd643ce8e5a5a9b768c6", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "patch": "@@ -478,7 +478,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n #endif\n     }\n \n-  /* on Coldfire add register save into initial stack frame setup, if possible */\n+  /* on ColdFire add register save into initial stack frame setup, if possible */\n   num_saved_regs = 0;\n   if (TARGET_COLDFIRE && current_frame.reg_no > 2)\n     num_saved_regs = current_frame.reg_no;\n@@ -1667,7 +1667,7 @@ const_method (rtx constant)\n   if (USE_MOVQ (i))\n     return MOVQ;\n \n-  /* The Coldfire doesn't have byte or word operations.  */\n+  /* The ColdFire doesn't have byte or word operations.  */\n   /* FIXME: This may not be useful for the m68060 either */\n   if (!TARGET_COLDFIRE) \n     {\n@@ -1982,7 +1982,7 @@ output_move_qimode (rtx *operands)\n   /* This is probably useless, since it loses for pushing a struct\n      of several bytes a byte at a time.\t */\n   /* 68k family always modifies the stack pointer by at least 2, even for\n-     byte pushes.  The 5200 (coldfire) does not do this.  */\n+     byte pushes.  The 5200 (ColdFire) does not do this.  */\n   if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n       && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n@@ -2032,7 +2032,7 @@ output_move_qimode (rtx *operands)\n     return \"sub%.l %0,%0\";\n   if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n     return \"move%.l %1,%0\";\n-  /* 68k family (including the 5200 coldfire) does not support byte moves to\n+  /* 68k family (including the 5200 ColdFire) does not support byte moves to\n      from address registers.  */\n   if (ADDRESS_REG_P (operands[0]) || ADDRESS_REG_P (operands[1]))\n     return \"move%.w %1,%0\";\n@@ -2452,7 +2452,7 @@ find_addr_reg (rtx addr)\n   abort ();\n }\n \n-/* Output assembler code to perform a 32 bit 3 operand add.  */\n+/* Output assembler code to perform a 32-bit 3-operand add.  */\n \n const char *\n output_addsi3 (rtx *operands)"}, {"sha": "e40492f2519dcdb25f1304af55effe6a978dfa40", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "patch": "@@ -194,8 +194,8 @@ extern int target_flags;\n \n /* Align ints to a word boundary.  This breaks compatibility with the \n    published ABI's for structures containing ints, but produces faster\n-   code on cpus with 32 bit busses (020, 030, 040, 060, CPU32+, coldfire).\n-   It's required for coldfire cpus without a misalignment module.  */\n+   code on cpus with 32-bit busses (020, 030, 040, 060, CPU32+, ColdFire).\n+   It's required for ColdFire cpus without a misalignment module.  */\n #define MASK_ALIGN_INT\t(1<<13)\n #define TARGET_ALIGN_INT (target_flags & MASK_ALIGN_INT)\n \n@@ -229,7 +229,7 @@ extern int target_flags;\n #define MASK_COLDFIRE\t(MASK_5200|MASK_528x|MASK_CFV3|MASK_CFV4)\n #define TARGET_COLDFIRE\t(target_flags & MASK_COLDFIRE)\n \n-/* Which bits can be set by specifying a coldfire */\n+/* Which bits can be set by specifying a ColdFire */\n #define MASK_ALL_CF_BITS\t(MASK_COLDFIRE|MASK_CF_HWDIV)\n \n /* Macro to define tables used to set the flags.\n@@ -423,9 +423,9 @@ extern int target_flags;\n \n /* No data type wants to be aligned rounder than this. \n    Most published ABIs say that ints should be aligned on 16 bit\n-   boundaries, but cpus with 32 bit busses get better performance\n-   aligned on 32 bit boundaries.  Coldfires without a misalignment\n-   module require 32 bit alignment.  */\n+   boundaries, but cpus with 32-bit busses get better performance\n+   aligned on 32-bit boundaries.  ColdFires without a misalignment\n+   module require 32-bit alignment.  */\n #define BIGGEST_ALIGNMENT (TARGET_ALIGN_INT ? 32 : 16)\n \n /* Set this nonzero if move instructions will actually fail to work\n@@ -808,7 +808,7 @@ enum reg_class {\n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n    On the 68000, sp@- in a byte insn really pushes a word.\n-   On the 5200 (coldfire), sp@- in a byte insn pushes just a byte.  */\n+   On the 5200 (ColdFire), sp@- in a byte insn pushes just a byte.  */\n #define PUSH_ROUNDING(BYTES) (TARGET_COLDFIRE ? BYTES : ((BYTES) + 1) & ~1)\n \n /* We want to avoid trying to push bytes.  */\n@@ -1237,7 +1237,7 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \t  && (TARGET_68020 || (unsigned) INTVAL (XEXP (X, 0)) + 0x80 < 0x100))\t\t\\\n \t{ rtx go_temp = XEXP (X, 1); GO_IF_INDEXING (go_temp, ADDR); } } }\n \n-/* coldfire/5200 does not allow HImode index registers.  */\n+/* ColdFire/5200 does not allow HImode index registers.  */\n #define LEGITIMATE_INDEX_REG_P(X)   \\\n   ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n    || (! TARGET_COLDFIRE\t\t\t\t\t\\"}, {"sha": "5883f4ba35adefba7f1692f953c903e3093f2e32", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16eadc700b08d082d23b970a3a5c4aebb6cf5ac/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=c16eadc700b08d082d23b970a3a5c4aebb6cf5ac", "patch": "@@ -548,7 +548,7 @@\n \f\n ;; Recognizers for btst instructions.\n \n-;; Coldfire/5200 only allows \"<Q>\" type addresses when the bit position is\n+;; ColdFire/5200 only allows \"<Q>\" type addresses when the bit position is\n ;; specified as a constant, so we must disable all patterns that may extract\n ;; from a MEM at a constant bit position if we can't use this as a constraint.\n \n@@ -4841,7 +4841,7 @@\n ; alignment of structure members is specified.\n ;\n ; The move is allowed to be odd byte aligned, because that's still faster\n-; than an odd byte aligned bit field instruction.\n+; than an odd byte aligned bit-field instruction.\n ;\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n@@ -4897,7 +4897,7 @@\n ; alignment of structure members is specified.\n ;\n ; The move is allowed to be odd byte aligned, because that's still faster\n-; than an odd byte aligned bit field instruction.\n+; than an odd byte aligned bit-field instruction.\n ;\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n@@ -4953,7 +4953,7 @@\n ; alignment of structure members is specified.\n ;\n ; The move is allowed to be odd byte aligned, because that's still faster\n-; than an odd byte aligned bit field instruction.\n+; than an odd byte aligned bit-field instruction.\n ;\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n@@ -4999,7 +4999,7 @@\n   return \\\"move%.w %1,%0\\;ext%.l %0\\\";\n }\")\n \f\n-;; Bit field instructions, general cases.\n+;; Bit-field instructions, general cases.\n ;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n ;; so that its address is reloaded.\n \n@@ -5103,7 +5103,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n   \"bfins %3,%0{%b2:%b1}\")\n \n-;; Now recognize bit field insns that operate on registers\n+;; Now recognize bit-field insns that operate on registers\n ;; (or at least were intended to do so).\n \n (define_insn \"\""}]}