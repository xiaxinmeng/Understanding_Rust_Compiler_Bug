{"sha": "d9957cf9a9cae15a9559d1d352b9f87486a04f24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk5NTdjZjlhOWNhZTE1YTk1NTlkMWQzNTJiOWY4NzQ4NmEwNGYyNA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-07-02T12:17:47Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-07-02T12:17:47Z"}, "message": "tree-vrp.c (extract_range_from_unary_expr): Abstract ABS_EXPR code...\n\n\t* tree-vrp.c (extract_range_from_unary_expr): Abstract ABS_EXPR\n\tcode...\n\t(extract_range_from_abs_expr): ...here.\n\nFrom-SVN: r262305", "tree": {"sha": "8399e83892a5a10b7c8432455354076f785e4b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8399e83892a5a10b7c8432455354076f785e4b70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9957cf9a9cae15a9559d1d352b9f87486a04f24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9957cf9a9cae15a9559d1d352b9f87486a04f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9957cf9a9cae15a9559d1d352b9f87486a04f24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9957cf9a9cae15a9559d1d352b9f87486a04f24/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "108e1a85811c8bf25a1d684a111d010db89d6ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108e1a85811c8bf25a1d684a111d010db89d6ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108e1a85811c8bf25a1d684a111d010db89d6ca0"}], "stats": {"total": 197, "additions": 86, "deletions": 111}, "files": [{"sha": "b4874ca72db8f7b9af68ef35dd445e74d808b3d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9957cf9a9cae15a9559d1d352b9f87486a04f24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9957cf9a9cae15a9559d1d352b9f87486a04f24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9957cf9a9cae15a9559d1d352b9f87486a04f24", "patch": "@@ -1,3 +1,9 @@\n+2018-07-02  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (extract_range_from_unary_expr): Abstract ABS_EXPR\n+\tcode...\n+\t(extract_range_from_abs_expr): ...here.\n+\n 2018-07-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/i386/i386.c (ix86_finalize_stack_frame_flags): Do not overrule"}, {"sha": "42436b38eba2f314997b2807e6c1e493d51659f6", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 80, "deletions": 111, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9957cf9a9cae15a9559d1d352b9f87486a04f24/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9957cf9a9cae15a9559d1d352b9f87486a04f24/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d9957cf9a9cae15a9559d1d352b9f87486a04f24", "patch": "@@ -2374,6 +2374,85 @@ extract_range_from_binary_expr_1 (value_range *vr,\n     set_value_range (vr, type, min, max, NULL);\n }\n \n+/* Calculates the absolute value of a range and puts the result in VR.\n+   VR0 is the input range.  TYPE is the type of the resulting\n+   range.  */\n+\n+static void\n+extract_range_from_abs_expr (value_range &vr, tree type, value_range &vr0)\n+{\n+  /* Pass through vr0 in the easy cases.  */\n+  if (TYPE_UNSIGNED (type)\n+      || value_range_nonnegative_p (&vr0))\n+    {\n+      copy_value_range (&vr, &vr0);\n+      return;\n+    }\n+\n+  /* For the remaining varying or symbolic ranges we can't do anything\n+     useful.  */\n+  if (vr0.type == VR_VARYING\n+      || symbolic_range_p (&vr0))\n+    {\n+      set_value_range_to_varying (&vr);\n+      return;\n+    }\n+\n+  /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n+     useful range.  */\n+  if (!TYPE_OVERFLOW_UNDEFINED (type)\n+      && ((vr0.type == VR_RANGE\n+\t   && vrp_val_is_min (vr0.min))\n+\t  || (vr0.type == VR_ANTI_RANGE\n+\t      && !vrp_val_is_min (vr0.min))))\n+    {\n+      set_value_range_to_varying (&vr);\n+      return;\n+    }\n+\n+  /* ABS_EXPR may flip the range around, if the original range\n+     included negative values.  */\n+  tree min, max;\n+  if (!vrp_val_is_min (vr0.min))\n+    min = fold_unary_to_constant (ABS_EXPR, type, vr0.min);\n+  else\n+    min = TYPE_MAX_VALUE (type);\n+\n+  if (!vrp_val_is_min (vr0.max))\n+    max = fold_unary_to_constant (ABS_EXPR, type, vr0.max);\n+  else\n+    max = TYPE_MAX_VALUE (type);\n+\n+  int cmp = compare_values (min, max);\n+  gcc_assert (vr0.type != VR_ANTI_RANGE);\n+\n+  /* If the range contains zero then we know that the minimum value in the\n+     range will be zero.  */\n+  if (range_includes_zero_p (vr0.min, vr0.max) == 1)\n+    {\n+      if (cmp == 1)\n+\tmax = min;\n+      min = build_int_cst (type, 0);\n+    }\n+  else\n+    {\n+      /* If the range was reversed, swap MIN and MAX.  */\n+      if (cmp == 1)\n+\tstd::swap (min, max);\n+    }\n+\n+  cmp = compare_values (min, max);\n+  if (cmp == -2 || cmp == 1)\n+    {\n+      /* If the new range has its limits swapped around (MIN > MAX),\n+\t then the operation caused one of them to wrap around, mark\n+\t the new range VARYING.  */\n+      set_value_range_to_varying (&vr);\n+    }\n+  else\n+    set_value_range (&vr, vr0.type, min, max, NULL);\n+}\n+\n /* Extract range information from a unary operation CODE based on\n    the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.\n    The resulting range is stored in *VR.  */\n@@ -2504,117 +2583,7 @@ extract_range_from_unary_expr (value_range *vr,\n       return;\n     }\n   else if (code == ABS_EXPR)\n-    {\n-      tree min, max;\n-      int cmp;\n-\n-      /* Pass through vr0 in the easy cases.  */\n-      if (TYPE_UNSIGNED (type)\n-\t  || value_range_nonnegative_p (&vr0))\n-\t{\n-\t  copy_value_range (vr, &vr0);\n-\t  return;\n-\t}\n-\n-      /* For the remaining varying or symbolic ranges we can't do anything\n-\t useful.  */\n-      if (vr0.type == VR_VARYING\n-\t  || symbolic_range_p (&vr0))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n-      /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n-         useful range.  */\n-      if (!TYPE_OVERFLOW_UNDEFINED (type)\n-\t  && ((vr0.type == VR_RANGE\n-\t       && vrp_val_is_min (vr0.min))\n-\t      || (vr0.type == VR_ANTI_RANGE\n-\t\t  && !vrp_val_is_min (vr0.min))))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n-      /* ABS_EXPR may flip the range around, if the original range\n-\t included negative values.  */\n-      if (!vrp_val_is_min (vr0.min))\n-\tmin = fold_unary_to_constant (code, type, vr0.min);\n-      else\n-\tmin = TYPE_MAX_VALUE (type);\n-\n-      if (!vrp_val_is_min (vr0.max))\n-\tmax = fold_unary_to_constant (code, type, vr0.max);\n-      else\n-\tmax = TYPE_MAX_VALUE (type);\n-\n-      cmp = compare_values (min, max);\n-\n-      /* If a VR_ANTI_RANGEs contains zero, then we have\n-\t ~[-INF, min(MIN, MAX)].  */\n-      if (vr0.type == VR_ANTI_RANGE)\n-\t{\n-\t  if (range_includes_zero_p (vr0.min, vr0.max) == 1)\n-\t    {\n-\t      /* Take the lower of the two values.  */\n-\t      if (cmp != 1)\n-\t\tmax = min;\n-\n-\t      /* Create ~[-INF, min (abs(MIN), abs(MAX))]\n-\t         or ~[-INF + 1, min (abs(MIN), abs(MAX))] when\n-\t\t flag_wrapv is set and the original anti-range doesn't include\n-\t         TYPE_MIN_VALUE, remember -TYPE_MIN_VALUE = TYPE_MIN_VALUE.  */\n-\t      if (TYPE_OVERFLOW_WRAPS (type))\n-\t\t{\n-\t\t  tree type_min_value = TYPE_MIN_VALUE (type);\n-\n-\t\t  min = (vr0.min != type_min_value\n-\t\t\t ? int_const_binop (PLUS_EXPR, type_min_value,\n-\t\t\t\t\t    build_int_cst (TREE_TYPE (type_min_value), 1))\n-\t\t\t : type_min_value);\n-\t\t}\n-\t      else\n-\t\tmin = TYPE_MIN_VALUE (type);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* All else has failed, so create the range [0, INF], even for\n-\t         flag_wrapv since TYPE_MIN_VALUE is in the original\n-\t         anti-range.  */\n-\t      vr0.type = VR_RANGE;\n-\t      min = build_int_cst (type, 0);\n-\t      max = TYPE_MAX_VALUE (type);\n-\t    }\n-\t}\n-\n-      /* If the range contains zero then we know that the minimum value in the\n-         range will be zero.  */\n-      else if (range_includes_zero_p (vr0.min, vr0.max) == 1)\n-\t{\n-\t  if (cmp == 1)\n-\t    max = min;\n-\t  min = build_int_cst (type, 0);\n-\t}\n-      else\n-\t{\n-          /* If the range was reversed, swap MIN and MAX.  */\n-\t  if (cmp == 1)\n-\t    std::swap (min, max);\n-\t}\n-\n-      cmp = compare_values (min, max);\n-      if (cmp == -2 || cmp == 1)\n-\t{\n-\t  /* If the new range has its limits swapped around (MIN > MAX),\n-\t     then the operation caused one of them to wrap around, mark\n-\t     the new range VARYING.  */\n-\t  set_value_range_to_varying (vr);\n-\t}\n-      else\n-\tset_value_range (vr, vr0.type, min, max, NULL);\n-      return;\n-    }\n+    return extract_range_from_abs_expr (*vr, type, vr0);\n \n   /* For unhandled operations fall back to varying.  */\n   set_value_range_to_varying (vr);"}]}