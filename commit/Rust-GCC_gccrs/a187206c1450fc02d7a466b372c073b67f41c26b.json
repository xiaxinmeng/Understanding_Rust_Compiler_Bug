{"sha": "a187206c1450fc02d7a466b372c073b67f41c26b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4NzIwNmMxNDUwZmMwMmQ3YTQ2NmIzNzJjMDczYjY3ZjQxYzI2Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:07:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:07:38Z"}, "message": "[multiple changes]\n\n2017-04-25  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-mmap.ads (Data): Add pragma Inline.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Insert_Valid_Check): Do not use\n\ta renaming to alias a volatile name because this will lead to\n\tmultiple evaluations of the volatile name. Use a constant to\n\tcapture the value instead.\n\n2017-04-25  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c [VxWorks Section]: Disable sigtramp for ppc64-vx7.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb, exp_util.ads (Build_Class_Wide_Expression):\n\tAdd out parameter to indicate to caller that a wrapper must\n\tbe constructed for an inherited primitive whose inherited\n\tpre/postcondition has called to overridden primitives.\n\t* freeze.adb (Check_Inherited_Conditions): Build wrapper body\n\tfor inherited primitive that requires it.\n\t* sem_disp.adb (Check_Dispatching_Operation): Such wrappers are\n\tlegal primitive operations and belong to the list of bodies\n\tgenerated after the freeze point of a type.\n\t* sem_prag.adb (Build_Pragma_Check_Equivalent): Use new signature\n\tof Build_Class_Wide_Expression.\n\t* sem_util.adb, sem_util.ads (Build_Overriding_Spec): New procedure\n\tto construct the specification of the wrapper subprogram created\n\tfor an inherited operation.\n\nFrom-SVN: r247140", "tree": {"sha": "f8c6c93a6bf4164317376630f72b4e12aef4e5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8c6c93a6bf4164317376630f72b4e12aef4e5d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a187206c1450fc02d7a466b372c073b67f41c26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187206c1450fc02d7a466b372c073b67f41c26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a187206c1450fc02d7a466b372c073b67f41c26b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187206c1450fc02d7a466b372c073b67f41c26b/comments", "author": null, "committer": null, "parents": [{"sha": "15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15fc8cb7ee426fe6730b742a7fecf05ba0082d87"}], "stats": {"total": 270, "additions": 239, "deletions": 31}, "files": [{"sha": "5b093d9aad7aaddc5791ca9adf27a29b09e02b4e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -1,3 +1,35 @@\n+2017-04-25  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-mmap.ads (Data): Add pragma Inline.\n+\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Insert_Valid_Check): Do not use\n+\ta renaming to alias a volatile name because this will lead to\n+\tmultiple evaluations of the volatile name. Use a constant to\n+\tcapture the value instead.\n+\n+2017-04-25  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c [VxWorks Section]: Disable sigtramp for ppc64-vx7.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb, exp_util.ads (Build_Class_Wide_Expression):\n+\tAdd out parameter to indicate to caller that a wrapper must\n+\tbe constructed for an inherited primitive whose inherited\n+\tpre/postcondition has called to overridden primitives.\n+\t* freeze.adb (Check_Inherited_Conditions): Build wrapper body\n+\tfor inherited primitive that requires it.\n+\t* sem_disp.adb (Check_Dispatching_Operation): Such wrappers are\n+\tlegal primitive operations and belong to the list of bodies\n+\tgenerated after the freeze point of a type.\n+\t* sem_prag.adb (Build_Pragma_Check_Equivalent): Use new signature\n+\tof Build_Class_Wide_Expression.\n+\t* sem_util.adb, sem_util.ads (Build_Overriding_Spec): New procedure\n+\tto construct the specification of the wrapper subprogram created\n+\tfor an inherited operation.\n+\n 2017-04-25  Bob Duff  <duff@adacore.com>\n \n \t* s-osinte-linux.ads (pthread_mutexattr_setprotocol,"}, {"sha": "40d3f3cefd759a69d004787919bac0827cf73158", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -7210,17 +7210,18 @@ package body Checks is\n          end if;\n \n          --  Build the prefix for the 'Valid call. If the expression denotes\n-         --  a name, use a renaming to alias it, otherwise use a constant to\n-         --  capture the value of the expression.\n+         --  a non-volatile name, use a renaming to alias it, otherwise use a\n+         --  constant to capture the value of the expression.\n \n-         --    Temp : ... renames Expr;      --  reference to a name\n+         --    Temp : ... renames Expr;      --  non-volatile name\n          --    Temp : constant ... := Expr;  --  all other cases\n \n          PV :=\n            Duplicate_Subexpr_No_Checks\n              (Exp           => Exp,\n               Name_Req      => False,\n-              Renaming_Req  => Is_Name_Reference (Exp),\n+              Renaming_Req  =>\n+                Is_Name_Reference (Exp) and then not Is_Volatile (Typ),\n               Related_Id    => Related_Id,\n               Is_Low_Bound  => Is_Low_Bound,\n               Is_High_Bound => Is_High_Bound);"}, {"sha": "f9310bd4adde3d375e23af74b07c7c56a3887c71", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -1041,11 +1041,13 @@ package body Exp_Util is\n    ---------------------------------\n \n    procedure Build_Class_Wide_Expression\n-     (Prag        : Node_Id;\n-      Subp        : Entity_Id;\n-      Par_Subp    : Entity_Id;\n-      Adjust_Sloc : Boolean)\n+     (Prag          : Node_Id;\n+      Subp          : Entity_Id;\n+      Par_Subp      : Entity_Id;\n+      Adjust_Sloc   : Boolean;\n+      Needs_Wrapper : out Boolean)\n    is\n+\n       function Replace_Entity (N : Node_Id) return Traverse_Result;\n       --  Replace reference to formal of inherited operation or to primitive\n       --  operation of root type, with corresponding entity for derived type,\n@@ -1089,6 +1091,13 @@ package body Exp_Util is\n \n             if Present (New_E) then\n                Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n+\n+               --  If the entity is an overridden primitive, we must build\n+               --  a wrapper for the current inherited operation.\n+\n+               if Is_Subprogram (New_E) then\n+                  Needs_Wrapper := True;\n+               end if;\n             end if;\n \n             --  Check that there are no calls left to abstract operations if\n@@ -1156,6 +1165,8 @@ package body Exp_Util is\n    --  Start of processing for Build_Class_Wide_Expression\n \n    begin\n+      Needs_Wrapper := False;\n+\n       --  Add mapping from old formals to new formals\n \n       Par_Formal  := First_Formal (Par_Subp);"}, {"sha": "a6b6b03521a0919fed431c7bbf4fc0506a756933", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -248,10 +248,11 @@ package Exp_Util is\n    --  not install a call to Abort_Defer.\n \n    procedure Build_Class_Wide_Expression\n-     (Prag        : Node_Id;\n-      Subp        : Entity_Id;\n-      Par_Subp    : Entity_Id;\n-      Adjust_Sloc : Boolean);\n+     (Prag          : Node_Id;\n+      Subp          : Entity_Id;\n+      Par_Subp      : Entity_Id;\n+      Adjust_Sloc   : Boolean;\n+      Needs_Wrapper : out Boolean);\n    --  Build the expression for an inherited class-wide condition. Prag is\n    --  the pragma constructed from the corresponding aspect of the parent\n    --  subprogram, and Subp is the overriding operation, and Par_Subp is\n@@ -264,6 +265,11 @@ package Exp_Util is\n    --  is the expression of the original class-wide aspect. In SPARK_Mode, such\n    --  operation which are just inherited but have modified pre/postconditions\n    --  are illegal.\n+   --  If there are calls to overridden operations in the condition, and the\n+   --  pragma applies to an inherited operation, a wrapper must be built for\n+   --  it to capture the new inherited condition. The flag Needs_Wrapper is\n+   --  set in that case so that the wrapper can be built, when the controlling\n+   --  type is frozen.\n \n    function Build_DIC_Call\n      (Loc    : Source_Ptr;"}, {"sha": "645f0a750bef2194b654c114c216306db8071275", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 117, "deletions": 16, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -55,6 +55,7 @@ with Sem_Ch6;   use Sem_Ch6;\n with Sem_Ch7;   use Sem_Ch7;\n with Sem_Ch8;   use Sem_Ch8;\n with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Disp;  use Sem_Disp;\n with Sem_Eval;  use Sem_Eval;\n with Sem_Mech;  use Sem_Mech;\n with Sem_Prag;  use Sem_Prag;\n@@ -1395,17 +1396,22 @@ package body Freeze is\n    --------------------------------\n \n    procedure Check_Inherited_Conditions (R : Entity_Id) is\n-      Prim_Ops : constant Elist_Id := Primitive_Operations (R);\n-      A_Post   : Node_Id;\n-      A_Pre    : Node_Id;\n-      Op_Node  : Elmt_Id;\n-      Par_Prim : Entity_Id;\n-      Prim     : Entity_Id;\n+      Prim_Ops      : constant Elist_Id := Primitive_Operations (R);\n+      A_Post        : Node_Id;\n+      A_Pre         : Node_Id;\n+      Decls         : List_Id;\n+      Op_Node       : Elmt_Id;\n+      Par_Prim      : Entity_Id;\n+      Par_Type      : Entity_Id;\n+      New_Prag      : Node_Id;\n+      Prim          : Entity_Id;\n+      Needs_Wrapper : Boolean;\n \n    begin\n       Op_Node := First_Elmt (Prim_Ops);\n       while Present (Op_Node) loop\n-         Prim := Node (Op_Node);\n+         Prim          := Node (Op_Node);\n+         Needs_Wrapper := False;\n \n          --  Map the overridden primitive to the overriding one. This takes\n          --  care of all overridings and is done only once.\n@@ -1446,9 +1452,12 @@ package body Freeze is\n \n       Op_Node := First_Elmt (Prim_Ops);\n       while Present (Op_Node) loop\n-         Prim := Node (Op_Node);\n+         Decls := Empty_List;\n+         Prim  := Node (Op_Node);\n+\n          if not Comes_From_Source (Prim) and then Present (Alias (Prim)) then\n             Par_Prim := Alias (Prim);\n+            Par_Type := Find_Dispatching_Type (Par_Prim);\n \n             --  Analyze the contract items of the parent operation, before\n             --  they are rewritten when inherited.\n@@ -1458,24 +1467,116 @@ package body Freeze is\n             A_Pre := Get_Pragma (Par_Prim, Pragma_Precondition);\n \n             if Present (A_Pre) and then Class_Present (A_Pre) then\n+               New_Prag := New_Copy_Tree (A_Pre);\n                Build_Class_Wide_Expression\n-                 (Prag        => New_Copy_Tree (A_Pre),\n-                  Subp        => Prim,\n-                  Par_Subp    => Par_Prim,\n-                  Adjust_Sloc => False);\n+                 (Prag          => New_Prag,\n+                  Subp          => Prim,\n+                  Par_Subp      => Par_Prim,\n+                  Adjust_Sloc   => False,\n+                  Needs_Wrapper => Needs_Wrapper);\n+\n+               if Needs_Wrapper then\n+                  Append (New_Prag, Decls);\n+               end if;\n             end if;\n \n             A_Post := Get_Pragma (Par_Prim, Pragma_Postcondition);\n \n             if Present (A_Post) and then Class_Present (A_Post) then\n+               New_Prag := New_Copy_Tree (A_Pre);\n                Build_Class_Wide_Expression\n-                 (Prag        => New_Copy_Tree (A_Post),\n-                  Subp        => Prim,\n-                  Par_Subp    => Par_Prim,\n-                  Adjust_Sloc => False);\n+                 (Prag           => New_Prag,\n+                  Subp           => Prim,\n+                  Par_Subp       => Par_Prim,\n+                  Adjust_Sloc    => False,\n+                  Needs_Wrapper  => Needs_Wrapper);\n+\n+               if Needs_Wrapper then\n+                  Append (New_Prag, Decls);\n+               end if;\n             end if;\n          end if;\n \n+         if Needs_Wrapper and then not Is_Abstract_Subprogram (Par_Prim) then\n+\n+            --  We need to build a new primitive that overrides the inherited\n+            --  one, and whose inherited expression has been updated above.\n+            --  These expressions are the arguments of pragmas that are part\n+            --  of the declarations of the wrapper. The wrapper holds a single\n+            --  statement that is a call to the parent primitive, where the\n+            --  controlling actuals are conversions to the corresponding type\n+            --  in the parent primitive:\n+\n+            --  procedure New_Prim (F1 : T1.; ...) is\n+            --     pragma Check (Precondition,  Expr);\n+            --  begin\n+            --     Par_Prim (Par_Type (F1) ..);\n+            --  end;\n+            --\n+            --  If the primitive is a function the statement is a call.\n+\n+            declare\n+               Loc        : constant Source_Ptr := Sloc (R);\n+               Formal     : Entity_Id;\n+               Actuals    : List_Id;\n+               New_F_Spec : Node_Id;\n+               New_Formal : Entity_Id;\n+               New_Proc   : Node_Id;\n+               New_Spec   : Node_Id;\n+               Call       : Node_Id;\n+\n+            begin\n+               Actuals  := Empty_List;\n+               New_Spec := Build_Overriding_Spec (Par_Prim, R);\n+               Formal     := First_Formal (Par_Prim);\n+               New_F_Spec := First (Parameter_Specifications (New_Spec));\n+\n+               while Present (Formal) loop\n+                  New_Formal := Defining_Identifier (New_F_Spec);\n+\n+                  --  If controlling argument, add conversion.\n+\n+                  if Etype (Formal) = Par_Type then\n+                     Append_To (Actuals,\n+                       Make_Type_Conversion (Loc,\n+                         New_Occurrence_Of (Par_Type, Loc),\n+                         New_Occurrence_Of (New_Formal, Loc)));\n+\n+                  else\n+                     Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+                  Next (New_F_Spec);\n+               end loop;\n+\n+               if Ekind (Par_Prim) = E_Procedure then\n+                  Call := Make_Procedure_Call_Statement (Loc,\n+                    Parameter_Associations => Actuals,\n+                    Name => New_Occurrence_Of (Par_Prim, Loc));\n+               else\n+                  Call := Make_Simple_Return_Statement (Loc,\n+                     Expression =>\n+                       Make_Function_Call (Loc,\n+                         Parameter_Associations => Actuals,\n+                      Name => New_Occurrence_Of (Par_Prim, Loc)));\n+               end if;\n+\n+               New_Proc := Make_Subprogram_Body (Loc,\n+                Specification              => New_Spec,\n+                Declarations               => Decls,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Call),\n+                    End_Label  => Make_Identifier (Loc, Chars (Prim))));\n+\n+               Insert_After (Parent (R), New_Proc);\n+               Analyze (New_Proc);\n+            end;\n+\n+            Needs_Wrapper := False;\n+         end if;\n+\n          Next_Elmt (Op_Node);\n       end loop;\n    end Check_Inherited_Conditions;"}, {"sha": "07155f02301537b15cd2bdcc099e03e5d3425bfc", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -2005,7 +2005,7 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-#if defined (__ARMEL__) || defined (__PPC__) || defined (__i386__) || defined (__x86_64__)\n+#if defined (__ARMEL__) || (defined (__PPC__) && !defined (__PPC64__)) || defined (__i386__) || defined (__x86_64__)\n   /* On certain targets, kernel mode, we process signals through a Call Frame\n      Info trampoline, voiding the need for myriads of fallback_frame_state\n      variants in the ZCX runtime.  We have no simple way to distinguish ZCX"}, {"sha": "7719367c805888a76de8572e9bd92c966fb50705", "filename": "gcc/ada/s-mmap.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fs-mmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fs-mmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmap.ads?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -223,11 +223,13 @@ package System.Mmap is\n    --  (File); such accesses may cause Storage_Error to be raised.\n \n    function Data (Region : Mapped_Region) return Str_Access;\n+   pragma Inline (Data);\n    --  The data mapped in Region as requested. The result is an unconstrained\n    --  string, so you cannot use the usual 'First and 'Last attributes.\n    --  Instead, these are respectively 1 and Size.\n \n    function Data (File : Mapped_File) return Str_Access;\n+   pragma Inline (Data);\n    --  Likewise for the region contained in File\n \n    function Is_Mutable (Region : Mapped_Region) return Boolean;"}, {"sha": "73bc8b6ceae4587c74b096a7cc3a906d874fefa6", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -1090,6 +1090,11 @@ package body Sem_Disp is\n          --  3. Subprograms associated with stream attributes (built by\n          --     New_Stream_Subprogram)\n \n+         --  4. Wrapper built for inherited operations with inherited class-\n+         --     wide conditions, where the conditions include calls to other\n+         --     overridden primitives. The wrappers include checks on these\n+         --     modified conditions. (AI12-113).\n+\n          if Present (Old_Subp)\n            and then Present (Overridden_Operation (Subp))\n            and then Is_Dispatching_Operation (Old_Subp)\n@@ -1098,14 +1103,18 @@ package body Sem_Disp is\n               ((Ekind (Subp) = E_Function\n                  and then Is_Dispatching_Operation (Old_Subp)\n                  and then Is_Null_Extension (Base_Type (Etype (Subp))))\n+\n               or else\n                (Ekind (Subp) = E_Procedure\n                  and then Is_Dispatching_Operation (Old_Subp)\n                  and then Present (Alias (Old_Subp))\n                  and then Is_Null_Interface_Primitive\n                              (Ultimate_Alias (Old_Subp)))\n+\n               or else Get_TSS_Name (Subp) = TSS_Stream_Read\n-              or else Get_TSS_Name (Subp) = TSS_Stream_Write);\n+              or else Get_TSS_Name (Subp) = TSS_Stream_Write\n+\n+              or else Present (Contract (Overridden_Operation (Subp))));\n \n             Check_Controlling_Formals (Tagged_Type, Subp);\n             Override_Dispatching_Operation (Tagged_Type, Old_Subp, Subp);"}, {"sha": "789aa31e65481b117eb113347d0499385b86ce05", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -27017,6 +27017,9 @@ package body Sem_Prag is\n       Inher_Id       : Entity_Id := Empty;\n       Keep_Pragma_Id : Boolean := False) return Node_Id\n    is\n+      Needs_Wrapper : Boolean;\n+      pragma Unreferenced (Needs_Wrapper);\n+\n       function Suppress_Reference (N : Node_Id) return Traverse_Result;\n       --  Detect whether node N references a formal parameter subject to\n       --  pragma Unreferenced. If this is the case, set Comes_From_Source\n@@ -27085,7 +27088,8 @@ package body Sem_Prag is\n          --  Build the inherited class-wide condition\n \n          Build_Class_Wide_Expression\n-           (Check_Prag, Subp_Id, Inher_Id, Adjust_Sloc => True);\n+           (Check_Prag, Subp_Id, Inher_Id, Adjust_Sloc => True,\n+             Needs_Wrapper =>  Needs_Wrapper);\n \n       --  If not an inherited condition simply copy the original pragma\n "}, {"sha": "53410cc7a7aa642041ea97af980e8d37dc75600f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -1581,6 +1581,40 @@ package body Sem_Util is\n       Set_Etype (Expr, Designated_Type (Etype (Disc)));\n    end Build_Explicit_Dereference;\n \n+   ---------------------------\n+   -- Build_Overriding_Spec --\n+   ---------------------------\n+\n+   function Build_Overriding_Spec\n+     (Op  : Entity_Id;\n+      Typ : Entity_Id) return Node_Id\n+   is\n+      Loc     : constant Source_Ptr := Sloc (Typ);\n+      Par_Typ : constant Entity_Id := Find_Dispatching_Type (Op);\n+      Spec    : constant Node_Id := Specification (Unit_Declaration_Node (Op));\n+\n+      Formal_Spec : Node_Id;\n+      Formal_Type : Node_Id;\n+      New_Spec    : Node_Id;\n+   begin\n+      New_Spec := Copy_Subprogram_Spec (Spec);\n+      Formal_Spec := First (Parameter_Specifications (New_Spec));\n+      while Present (Formal_Spec) loop\n+         Formal_Type := Parameter_Type (Formal_Spec);\n+         if Is_Entity_Name (Formal_Type)\n+           and then Entity (Formal_Type) = Par_Typ\n+         then\n+            Rewrite (Formal_Type, New_Occurrence_Of (Typ, Loc));\n+         end if;\n+\n+         --  Nothing needs to be done for access parameters.\n+\n+         Next (Formal_Spec);\n+      end loop;\n+\n+      return New_Spec;\n+   end Build_Overriding_Spec;\n+\n    -----------------------------------\n    -- Cannot_Raise_Constraint_Error --\n    -----------------------------------"}, {"sha": "fb0bdf33a0c1a3f0f9556651c3b4e3f5250fe19e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187206c1450fc02d7a466b372c073b67f41c26b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=a187206c1450fc02d7a466b372c073b67f41c26b", "patch": "@@ -227,6 +227,14 @@ package Sem_Util is\n    --  the compilation unit, and install it in the Elaboration_Entity field\n    --  of Spec_Id, the entity for the compilation unit.\n \n+   function Build_Overriding_Spec\n+     (Op  : Node_Id;\n+      Typ : Entity_Id) return Node_Id;\n+   --  Build a subprogram specification for the wrapper of an inherited\n+   --  operation with a modified pre- or postcondition (See AI12-0113).\n+   --  Op is the parent operation, and Typ is the descendant type that\n+   --  inherits the operation.\n+\n    procedure Build_Explicit_Dereference\n      (Expr : Node_Id;\n       Disc : Entity_Id);"}]}