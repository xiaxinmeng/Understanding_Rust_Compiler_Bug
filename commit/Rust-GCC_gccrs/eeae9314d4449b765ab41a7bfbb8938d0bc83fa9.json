{"sha": "eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVhZTkzMTRkNDQ0OWI3NjVhYjQxYTdiZmJiODkzOGQwYmM4M2ZhOQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2018-11-22T17:25:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2018-11-22T17:25:57Z"}, "message": "re PR rtl-optimization/87718 (FAIL: gcc.target/i386/avx512dq-concatv2si-1.c)\n\n2018-11-22  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/87718\n\t* ira-costs.c: Remove trailing white-spaces.\n\t(record_operand_costs): Add a special treatment for moves\n\tinvolving a hard register.\n\n2018-11-22  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/87718\n\t* gcc.target/i386/pr82361-1.c: Check only the first operand of\n\tmoves.\n\nFrom-SVN: r266385", "tree": {"sha": "adbd6a0a3b8501328a28b31f182d10655279badd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adbd6a0a3b8501328a28b31f182d10655279badd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b8a3183134353cb86383f4395b99452e04acaa74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a3183134353cb86383f4395b99452e04acaa74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8a3183134353cb86383f4395b99452e04acaa74"}], "stats": {"total": 191, "additions": 115, "deletions": 76}, "files": [{"sha": "563f22cd317385373a8b45595a45ad88de4539c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "patch": "@@ -1,3 +1,10 @@\n+2018-11-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/87718\n+\t* ira-costs.c: Remove trailing white-spaces.\n+\t(record_operand_costs): Add a special treatment for moves\n+\tinvolving a hard register.\n+\n 2018-11-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_avx_emit_vzeroupper): Remove."}, {"sha": "6c1d9ddde5627ecbca54f26093c98ffb3cc9d92f", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 101, "deletions": 75, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "patch": "@@ -1257,7 +1257,7 @@ record_address_regs (machine_mode mode, addr_space_t as, rtx x,\n \t    add_cost = (move_in_cost[i][rclass] * scale) / 2;\n \t    if (INT_MAX - add_cost < pp_costs[k])\n \t      pp_costs[k] = INT_MAX;\n-\t    else \n+\t    else\n \t      pp_costs[k] += add_cost;\n \t  }\n       }\n@@ -1283,10 +1283,100 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   machine_mode modes[MAX_RECOG_OPERANDS];\n-  rtx ops[MAX_RECOG_OPERANDS];\n   rtx set;\n   int i;\n \n+  if ((set = single_set (insn)) != NULL_RTX\n+      /* In rare cases the single set insn might have less 2 operands\n+\t as the source can be a fixed special reg.  */\n+      && recog_data.n_operands > 1\n+      && recog_data.operand[0] == SET_DEST (set)\n+      && recog_data.operand[1] == SET_SRC (set))\n+    {\n+      int regno, other_regno;\n+      rtx dest = SET_DEST (set);\n+      rtx src = SET_SRC (set);\n+\n+      if (GET_CODE (dest) == SUBREG\n+\t  && known_eq (GET_MODE_SIZE (GET_MODE (dest)),\n+\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))))\n+\tdest = SUBREG_REG (dest);\n+      if (GET_CODE (src) == SUBREG\n+\t  && known_eq (GET_MODE_SIZE (GET_MODE (src)),\n+\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n+\tsrc = SUBREG_REG (src);\n+      if (REG_P (src) && REG_P (dest)\n+\t  && (((regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n+\t       && (other_regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER)\n+\t      || ((regno = REGNO (dest)) >= FIRST_PSEUDO_REGISTER\n+\t\t  && (other_regno = REGNO (src)) < FIRST_PSEUDO_REGISTER)))\n+\t{\n+\t  machine_mode mode = GET_MODE (SET_SRC (set));\n+\t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n+\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n+\t  reg_class_t rclass, hard_reg_class, pref_class;\n+\t  int cost, k;\n+\t  bool dead_p = find_regno_note (insn, REG_DEAD, REGNO (src));\n+\n+\t  hard_reg_class = REGNO_REG_CLASS (other_regno);\n+\t  i = regno == (int) REGNO (src) ? 1 : 0;\n+\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t    {\n+\t      rclass = cost_classes[k];\n+\t      cost = ((i == 0\n+\t\t       ? ira_register_move_cost[mode][hard_reg_class][rclass]\n+\t\t       : ira_register_move_cost[mode][rclass][hard_reg_class])\n+\t\t      * frequency);\n+\t      op_costs[i]->cost[k] = cost;\n+\t      /* If we have assigned a class to this allocno in our\n+\t\t first pass, add a cost to this alternative\n+\t\t corresponding to what we would add if this allocno\n+\t\t were not in the appropriate class.  */\n+\t      if (pref)\n+\t\t{\n+\t\t  if ((pref_class = pref[COST_INDEX (regno)]) == NO_REGS)\n+\t\t    op_costs[i]->cost[k]\n+\t\t      += ((i == 0 ? ira_memory_move_cost[mode][rclass][0] : 0)\n+\t\t\t  + (i == 1 ? ira_memory_move_cost[mode][rclass][1] : 0)\n+\t\t\t  * frequency);\n+\t\t  else if (ira_reg_class_intersect[pref_class][rclass]\n+\t\t\t   == NO_REGS)\n+\t\t    op_costs[i]->cost[k]\n+\t\t      += (ira_register_move_cost[mode][pref_class][rclass]\n+\t\t\t  * frequency);\n+\t\t}\n+\t      /* If this insn is a single set copying operand 1 to\n+\t\t operand 0 and one operand is an allocno with the\n+\t\t other a hard reg or an allocno that prefers a hard\n+\t\t register that is in its own register class then we\n+\t\t may want to adjust the cost of that register class to\n+\t\t -1.\n+\n+\t\t Avoid the adjustment if the source does not die to\n+\t\t avoid stressing of register allocator by preferencing\n+\t\t two colliding registers into single class.  */\n+\t      if (dead_p\n+\t\t  && TEST_HARD_REG_BIT (reg_class_contents[rclass], other_regno)\n+\t\t  && (reg_class_size[(int) rclass]\n+\t\t      == (ira_reg_class_max_nregs\n+\t\t\t  [(int) rclass][(int) GET_MODE(src)])))\n+\t\t{\n+\t\t  if (reg_class_size[rclass] == 1)\n+\t\t    op_costs[i]->cost[k] = -frequency;\n+\t\t  else if (in_hard_reg_set_p (reg_class_contents[rclass],\n+\t\t\t\t\t      GET_MODE(src), other_regno))\n+\t\t    op_costs[i]->cost[k] = -frequency;\n+\t\t}\n+\t    }\n+\t  op_costs[i]->mem_cost\n+\t    = ira_memory_move_cost[mode][hard_reg_class][i] * frequency;\n+\t  if (pref && (pref_class = pref[COST_INDEX (regno)]) != NO_REGS)\n+\t    op_costs[i]->mem_cost\n+\t      += ira_memory_move_cost[mode][pref_class][i] * frequency;\n+\t  return;\n+\t}\n+    }\n+\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       constraints[i] = recog_data.constraints[i];\n@@ -1302,7 +1392,6 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n     {\n       memcpy (op_costs[i], init_cost, struct_costs_size);\n \n-      ops[i] = recog_data.operand[i];\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n@@ -1318,7 +1407,7 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n \t\t\t     recog_data.operand[i], 0, ADDRESS, SCRATCH,\n \t\t\t     frequency * 2);\n     }\n-  \n+\n   /* Check for commutative in a separate loop so everything will have\n      been initialized.  We must do this even if one operand is a\n      constant--see addsi3 in m68k.md.  */\n@@ -1328,8 +1417,8 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n \tconst char *xconstraints[MAX_RECOG_OPERANDS];\n \tint j;\n \n-\t/* Handle commutative operands by swapping the constraints.\n-\t   We assume the modes are the same.  */\n+\t/* Handle commutative operands by swapping the\n+\t   constraints.  We assume the modes are the same.  */\n \tfor (j = 0; j < recog_data.n_operands; j++)\n \t  xconstraints[j] = constraints[j];\n \n@@ -1342,69 +1431,6 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n   record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n \t\t      recog_data.operand, modes,\n \t\t      constraints, insn, pref);\n-\n-  /* If this insn is a single set copying operand 1 to operand 0 and\n-     one operand is an allocno with the other a hard reg or an allocno\n-     that prefers a hard register that is in its own register class\n-     then we may want to adjust the cost of that register class to -1.\n-\n-     Avoid the adjustment if the source does not die to avoid\n-     stressing of register allocator by preferencing two colliding\n-     registers into single class.\n-\n-     Also avoid the adjustment if a copy between hard registers of the\n-     class is expensive (ten times the cost of a default copy is\n-     considered arbitrarily expensive).  This avoids losing when the\n-     preferred class is very expensive as the source of a copy\n-     instruction.  */\n-  if ((set = single_set (insn)) != NULL_RTX\n-      /* In rare cases the single set insn might have less 2 operands\n-\t as the source can be a fixed special reg.  */\n-      && recog_data.n_operands > 1\n-      && ops[0] == SET_DEST (set) && ops[1] == SET_SRC (set))\n-    {\n-      int regno, other_regno;\n-      rtx dest = SET_DEST (set);\n-      rtx src = SET_SRC (set);\n-\n-      if (GET_CODE (dest) == SUBREG\n-\t  && known_eq (GET_MODE_SIZE (GET_MODE (dest)),\n-\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))))\n-\tdest = SUBREG_REG (dest);\n-      if (GET_CODE (src) == SUBREG\n-\t  && known_eq (GET_MODE_SIZE (GET_MODE (src)),\n-\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n-\tsrc = SUBREG_REG (src);\n-      if (REG_P (src) && REG_P (dest)\n-\t  && find_regno_note (insn, REG_DEAD, REGNO (src))\n-\t  && (((regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n-\t       && (other_regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER)\n-\t      || ((regno = REGNO (dest)) >= FIRST_PSEUDO_REGISTER\n-\t\t  && (other_regno = REGNO (src)) < FIRST_PSEUDO_REGISTER)))\n-\t{\n-\t  machine_mode mode = GET_MODE (src);\n-\t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n-\t  reg_class_t rclass;\n-\t  int k;\n-\n-\t  i = regno == (int) REGNO (src) ? 1 : 0;\n-\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t    {\n-\t      rclass = cost_classes[k];\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], other_regno)\n-\t\t  && (reg_class_size[(int) rclass]\n-\t\t      == ira_reg_class_max_nregs [(int) rclass][(int) mode]))\n-\t\t{\n-\t\t  if (reg_class_size[rclass] == 1)\n-\t\t    op_costs[i]->cost[k] = -frequency;\n-\t\t  else if (in_hard_reg_set_p (reg_class_contents[rclass],\n-\t\t\t\t\t      mode, other_regno))\n-\t\t    op_costs[i]->cost[k] = -frequency;\n-\t\t}\n-\t    }\n-\t}\n-    }\n }\n \n \f\n@@ -1457,7 +1483,7 @@ scan_one_insn (rtx_insn *insn)\n \n   /* If this insn loads a parameter from its stack slot, then it\n      represents a savings, rather than a cost, if the parameter is\n-     stored in memory.  Record this fact. \n+     stored in memory.  Record this fact.\n \n      Similarly if we're loading other constants from memory (constant\n      pool, TOC references, small data areas, etc) and this is the only\n@@ -1468,7 +1494,7 @@ scan_one_insn (rtx_insn *insn)\n      mem_cost might result in it being loaded using the specialized\n      instruction into a register, then stored into stack and loaded\n      again from the stack.  See PR52208.\n-     \n+\n      Don't do this if SET_SRC (set) has side effect.  See PR56124.  */\n   if (set != 0 && REG_P (SET_DEST (set)) && MEM_P (SET_SRC (set))\n       && (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != NULL_RTX\n@@ -1766,7 +1792,7 @@ find_costs_and_classes (FILE *dump_file)\n \t\t   a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t\t{\n \t\t  int *a_costs, *p_costs;\n-\t\t      \n+\n \t\t  a_num = ALLOCNO_NUM (a);\n \t\t  if ((flag_ira_region == IRA_REGION_ALL\n \t\t       || flag_ira_region == IRA_REGION_MIXED)\n@@ -1936,7 +1962,7 @@ find_costs_and_classes (FILE *dump_file)\n \t      int a_num = ALLOCNO_NUM (a);\n \t      int *total_a_costs = COSTS (total_allocno_costs, a_num)->cost;\n \t      int *a_costs = COSTS (costs, a_num)->cost;\n-\t\n+\n \t      if (aclass == NO_REGS)\n \t\tbest = NO_REGS;\n \t      else\n@@ -1998,7 +2024,7 @@ find_costs_and_classes (FILE *dump_file)\n \t\t}\n \t    }\n \t}\n-      \n+\n       if (internal_flag_ira_verbose > 4 && dump_file)\n \t{\n \t  if (allocno_p)\n@@ -2081,7 +2107,7 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n \tint cost;\n \tenum reg_class hard_reg_class;\n \tmachine_mode mode;\n-\t\n+\n \tmode = ALLOCNO_MODE (a);\n \thard_reg_class = REGNO_REG_CLASS (hard_regno);\n \tira_init_register_move_cost_if_necessary (mode);"}, {"sha": "b3675a4ec2df11bb6f90a322bebc4af8f5529afc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "patch": "@@ -1,3 +1,9 @@\n+2018-11-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/87718\n+\t* gcc.target/i386/pr82361-1.c: Check only the first operand of\n+\tmoves.\n+\n 2018-11-22  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n \n \t* gcc.target/arm/pr85434.c: New test."}, {"sha": "e7c35655703e297440e4349448fa65e94dadd433", "filename": "gcc/testsuite/gcc.target/i386/pr82361-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeae9314d4449b765ab41a7bfbb8938d0bc83fa9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c?ref=eeae9314d4449b765ab41a7bfbb8938d0bc83fa9", "patch": "@@ -6,7 +6,7 @@\n /* { dg-final { scan-assembler-not \"movl\\t%eax, %eax\" } } */\n /* FIXME: We are still not able to optimize the modulo in f1/f2, only manage\n    one.  */\n-/* { dg-final { scan-assembler-times \"movl\\t%edx, %edx\" 2 } } */\n+/* { dg-final { scan-assembler-times \"movl\\t%edx\" 2 } } */\n \n void\n f1 (unsigned int a, unsigned int b)"}]}