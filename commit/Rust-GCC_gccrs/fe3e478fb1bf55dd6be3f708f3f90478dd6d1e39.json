{"sha": "fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUzZTQ3OGZiMWJmNTVkZDZiZTNmNzA4ZjNmOTA0NzhkZDZkMWUzOQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-10-18T10:51:08Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-10-18T10:51:08Z"}, "message": "re PR target/53513 ([SH] Add support for fpchg insn and improve fenv support)\n\ngcc/\n\tPR target/53513\n\t* config/sh/sh-modes.def (PSI): Remove.\n\t* config/sh/sh-protos.h (get_fpscr_rtx): Remove.\n\t* config/sh/sh.c (fpscr_rtx, get_fpscr_rtx): Remove.\n\t(sh_reorg): Remove commented out FPSCR code.\n\t(fpscr_set_from_mem): Use SImode instead of PSImode.  Emit lds_fpscr\n\tinsn instead of move insn.\n\t(sh_hard_regno_mode_ok): Return SImode for FPSCR.\n\t(sh_legitimate_address_p, sh_legitimize_reload_address): Remove PSImode\n\thandling.\n\t(sh_emit_mode_set): Emit lds_fpscr and sts_fpscr insns.\n\t(sh1_builtin_p): Uncomment.\n\t(SH_BLTIN_UV 25, SH_BLTIN_VU 26): New macros.\n\t(bdesc): Add __builtin_sh_get_fpscr and __builtin_sh_set_fpscr.\n\t* config/sh/sh/predicates.md (fpscr_operand): Simplify.\n\t(fpscr_movsrc_operand, fpscr_movdst_operand): New predicates.\n\t(general_movsrc_operand, general_movdst_operand): Disallow\n\tfpscr_operand.\n\t* config/sh/sh.md (FPSCR_FR): New constant.\n\t(push_fpscr): Emit sts_fpscr insn.\n\t(pop_fpscr): Emit lds_fpscr_insn.\n\t(movsi_ie): Disallow FPSCR operands.\n\t(fpu_switch, unnamed related split, extend_psi_si,\n\ttruncate_si_psi): Remove insns.\n\t(lds_fpscr, sts_fpscr): New insns.\n\t(toggle_sz, toggle_pr): Use SImode for FPSCR_REG instead of PSImode.\n\nFrom-SVN: r216424", "tree": {"sha": "ceddd0f8598d93825e1843a5627012d331c1cadf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ceddd0f8598d93825e1843a5627012d331c1cadf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/comments", "author": null, "committer": null, "parents": [{"sha": "7e813472a20d496c4dafb20a704932656bfc8366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e813472a20d496c4dafb20a704932656bfc8366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e813472a20d496c4dafb20a704932656bfc8366"}], "stats": {"total": 302, "additions": 147, "deletions": 155}, "files": [{"sha": "74037a227f2bcd9a3435082a24d5ea95c7829daf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "patch": "@@ -1,3 +1,32 @@\n+2014-10-18  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53513\n+\t* config/sh/sh-modes.def (PSI): Remove.\n+\t* config/sh/sh-protos.h (get_fpscr_rtx): Remove.\n+\t* config/sh/sh.c (fpscr_rtx, get_fpscr_rtx): Remove.\n+\t(sh_reorg): Remove commented out FPSCR code.\n+\t(fpscr_set_from_mem): Use SImode instead of PSImode.  Emit lds_fpscr\n+\tinsn instead of move insn.\n+\t(sh_hard_regno_mode_ok): Return SImode for FPSCR.\n+\t(sh_legitimate_address_p, sh_legitimize_reload_address): Remove PSImode\n+\thandling.\n+\t(sh_emit_mode_set): Emit lds_fpscr and sts_fpscr insns.\n+\t(sh1_builtin_p): Uncomment.\n+\t(SH_BLTIN_UV 25, SH_BLTIN_VU 26): New macros.\n+\t(bdesc): Add __builtin_sh_get_fpscr and __builtin_sh_set_fpscr.\n+\t* config/sh/sh/predicates.md (fpscr_operand): Simplify.\n+\t(fpscr_movsrc_operand, fpscr_movdst_operand): New predicates.\n+\t(general_movsrc_operand, general_movdst_operand): Disallow\n+\tfpscr_operand.\n+\t* config/sh/sh.md (FPSCR_FR): New constant.\n+\t(push_fpscr): Emit sts_fpscr insn.\n+\t(pop_fpscr): Emit lds_fpscr_insn.\n+\t(movsi_ie): Disallow FPSCR operands.\n+\t(fpu_switch, unnamed related split, extend_psi_si,\n+\ttruncate_si_psi): Remove insns.\n+\t(lds_fpscr, sts_fpscr): New insns.\n+\t(toggle_sz, toggle_pr): Use SImode for FPSCR_REG instead of PSImode.\n+\n 2014-10-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* ipa-inline-transform.c (master_clone_with_noninline_clones_p): New."}, {"sha": "ff1c2f54a38221440418a7fb0de6ffd404aa2713", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "patch": "@@ -154,7 +154,7 @@\n \n       return (regno != T_REG && regno != PR_REG\n \t      && ! TARGET_REGISTER_P (regno)\n-\t      && regno != FPUL_REG\n+\t      && regno != FPUL_REG && regno != FPSCR_REG\n \t      && regno != MACH_REG && regno != MACL_REG);\n     }\n   /* Allow a no-op sign extension - compare LOAD_EXTEND_OP.\n@@ -347,13 +347,27 @@\n \n ;; Returns true if OP is the FPSCR.\n (define_predicate \"fpscr_operand\"\n-  (match_code \"reg\")\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == FPSCR_REG\")))\n+\n+;; Returns true if OP is a valid source operand for a FPSCR move insn.\n+(define_predicate \"fpscr_movsrc_operand\"\n+  (match_code \"reg,subreg,mem\")\n {\n-  return (REG_P (op)\n-\t  && (REGNO (op) == FPSCR_REG\n-\t      || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t\t  && !(reload_in_progress || reload_completed)))\n-\t  && GET_MODE (op) == PSImode);\n+  if (arith_reg_operand (op, mode))\n+    return true;\n+\n+  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC;\n+})\n+\n+;; Returns true if OP is a valid destination operand for a FPSCR move insn.\n+(define_predicate \"fpscr_movdst_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (arith_reg_dest (op, mode))\n+    return true;\n+\n+  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == PRE_DEC;\n })\n \n ;; Returns true if OP is an operand that is either the fpul hard reg or\n@@ -451,6 +465,9 @@\n   if (t_reg_operand (op, mode))\n     return 0;\n \n+  if (fpscr_operand (op, mode))\n+    return false;\n+\n   /* Disallow PC relative QImode loads, since these is no insn to do that\n      and an imm8 load should be used instead.  */\n   if (IS_PC_RELATIVE_LOAD_ADDR_P (op) && GET_MODE (op) == QImode)\n@@ -546,6 +563,9 @@\n   if (t_reg_operand (op, mode))\n     return 0;\n \n+  if (fpscr_operand (op, mode))\n+    return false;\n+\n   if (MEM_P (op))\n     {\n       rtx inside = XEXP (op, 0);"}, {"sha": "02710aa29e4160057e71845950f0b607cfbdfc89", "filename": "gcc/config/sh/sh-modes.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-modes.def?ref=fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "patch": "@@ -17,8 +17,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* The SH uses a partial integer mode to represent the FPSCR register.  */\n-PARTIAL_INT_MODE (SI, 22, PSI);\n /* PDI mode is used to represent a function address in a target register.  */\n PARTIAL_INT_MODE (DI, 64, PDI);\n "}, {"sha": "77c9ae4e3420aab3fcd1a5f2d3870dce3aaef357", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "patch": "@@ -107,7 +107,6 @@ extern int barrier_align (rtx_insn *);\n extern int sh_loop_align (rtx_insn *);\n extern bool fp_zero_operand (rtx);\n extern bool fp_one_operand (rtx);\n-extern rtx get_fpscr_rtx (void);\n extern bool sh_legitimate_index_p (enum machine_mode, rtx, bool, bool);\n extern bool sh_legitimize_reload_address (rtx *, enum machine_mode, int, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n@@ -185,7 +184,6 @@ extern void sh_cpu_cpp_builtins (cpp_reader* pfile);\n \n extern const char *output_jump_label_table (void);\n extern rtx get_t_reg_rtx (void);\n-extern rtx get_fpscr_rtx (void);\n extern int sh_media_register_for_return (void);\n extern void sh_expand_prologue (void);\n extern void sh_expand_epilogue (bool);"}, {"sha": "3daa375b957ac1e7f52c0359b359a064585bf4d9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "patch": "@@ -6443,14 +6443,6 @@ sh_reorg (void)\n \t  emit_insn_before (gen_use_sfunc_addr (reg), insn);\n \t}\n     }\n-#if 0\n-  /* fpscr is not actually a user variable, but we pretend it is for the\n-     sake of the previous optimization passes, since we want it handled like\n-     one.  However, we don't have any debugging information for it, so turn\n-     it into a non-user variable now.  */\n-  if (TARGET_SH4)\n-    REG_USERVAR_P (get_fpscr_rtx ()) = 0;\n-#endif\n   mdep_reorg_phase = SH_AFTER_MDEP_REORG;\n }\n \n@@ -10009,21 +10001,6 @@ get_t_reg_rtx (void)\n   return t_reg_rtx;\n }\n \n-static GTY(()) rtx fpscr_rtx;\n-rtx\n-get_fpscr_rtx (void)\n-{\n-  if (! fpscr_rtx)\n-    {\n-      fpscr_rtx = gen_rtx_REG (PSImode, FPSCR_REG);\n-      REG_USERVAR_P (fpscr_rtx) = 1;\n-      mark_user_reg (fpscr_rtx);\n-    }\n-  if (! reload_completed || mdep_reorg_phase != SH_AFTER_MDEP_REORG)\n-    mark_user_reg (fpscr_rtx);\n-  return fpscr_rtx;\n-}\n-\n static GTY(()) tree fpscr_values;\n \n static void\n@@ -10055,13 +10032,12 @@ emit_fpu_switch (rtx scratch, int index)\n       emit_move_insn (scratch, XEXP (src, 0));\n       if (index != 0)\n \temit_insn (gen_addsi3 (scratch, scratch, GEN_INT (index * 4)));\n-      src = adjust_automodify_address (src, PSImode, scratch, index * 4);\n+      src = adjust_automodify_address (src, SImode, scratch, index * 4);\n     }\n   else\n-    src = adjust_address (src, PSImode, index * 4);\n+    src = adjust_address (src, SImode, index * 4);\n \n-  dst = get_fpscr_rtx ();\n-  emit_move_insn (dst, src);\n+  emit_insn (gen_lds_fpscr (src));\n }\n \f\n static rtx get_free_reg (HARD_REG_SET);\n@@ -10269,8 +10245,7 @@ sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \t   && ! TARGET_SHMEDIA\n \t   && MAYBE_BASE_REGISTER_RTX_P (XEXP (x, 0), strict))\n     return true;\n-  else if (GET_CODE (x) == PLUS\n-\t   && (mode != PSImode || reload_completed))\n+  else if (GET_CODE (x) == PLUS)\n     {\n       rtx xop0 = XEXP (x, 0);\n       rtx xop1 = XEXP (x, 1);\n@@ -10474,7 +10449,6 @@ sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n \t  return gen_rtx_PLUS (Pmode, sum, adj.mov_disp);\n \t}\n     }\n-\n   return x;\n }\n \n@@ -10516,7 +10490,6 @@ sh_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n \n   if (GET_CODE (*p) == PLUS && CONST_INT_P (XEXP (*p, 1))\n       && MAYBE_BASE_REGISTER_RTX_P (XEXP (*p, 0), true)\n-      && ! (mode == PSImode && type == RELOAD_FOR_INPUT_ADDRESS)\n       && (ALLOW_INDEXED_ADDRESS\n \t  || XEXP (*p, 0) == stack_pointer_rtx\n \t  || XEXP (*p, 0) == hard_frame_pointer_rtx))\n@@ -11607,13 +11580,12 @@ shmedia_builtin_p (void)\n }\n \n /* This function can be used if there are any built-ins that are not for\n-   SHmedia.  It's commented out to avoid the defined-but-unused warning.\n+   SHmedia.  It's commented out to avoid the defined-but-unused warning.  */\n static bool\n sh1_builtin_p (void)\n {\n   return TARGET_SH1;\n }\n-*/\n \n /* describe number and signedness of arguments; arg[0] == result\n    (1: unsigned, 2: signed, 4: don't care, 8: pointer 0: no argument */\n@@ -11674,6 +11646,10 @@ static const char signature_args[][4] =\n   { 0, 8 },\n #define SH_BLTIN_VP 24\n   { 8, 0 },\n+#define SH_BLTIN_UV 25\n+  { 1, 0 },\n+#define SH_BLTIN_VU 26\n+  { 0, 1 },\n };\n /* mcmv: operands considered unsigned.  */\n /* mmulsum_wq, msad_ubq: result considered unsigned long long.  */\n@@ -11849,6 +11825,11 @@ static struct builtin_description bdesc[] =\n     CODE_FOR_byterev,\t\"__builtin_sh_media_BYTEREV\", SH_BLTIN_2, 0 },\n   { shmedia_builtin_p,\n     CODE_FOR_prefetch,\t\"__builtin_sh_media_PREFO\", SH_BLTIN_PSSV, 0 },\n+\n+  { sh1_builtin_p,\n+    CODE_FOR_sts_fpscr, \"__builtin_sh_get_fpscr\", SH_BLTIN_UV, 0 },\n+  { sh1_builtin_p,\n+    CODE_FOR_set_fpscr, \"__builtin_sh_set_fpscr\", SH_BLTIN_VU, 0 },\n };\n \n static void\n@@ -12162,7 +12143,7 @@ sh_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n     return mode == SImode;\n \n   if (regno == FPSCR_REG)\n-    return mode == PSImode;\n+    return mode == SImode;\n \n   /* FIXME.  This works around PR target/37633 for -O0.  */\n   if (!optimize && TARGET_SHMEDIA32 && GET_MODE_SIZE (mode) > 4)\n@@ -13627,33 +13608,24 @@ sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,\n     }\n   else if (mode != FP_MODE_NONE)\n     {\n-      rtx tmp0 = gen_reg_rtx (PSImode);\n-      rtx tmp1 = gen_reg_rtx (SImode);\n-\n-      emit_move_insn (tmp0, get_fpscr_rtx ());\n-      emit_insn (gen_extend_psi_si (tmp1, tmp0));\n-\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_sts_fpscr (tmp));\n       rtx i = NULL;\n \n       const unsigned HOST_WIDE_INT fpbits =\n \t  TARGET_FMOVD ? (FPSCR_PR | FPSCR_SZ) : FPSCR_PR;\n \n       if (prev_mode != FP_MODE_NONE && prev_mode != mode)\n-\ti = gen_xorsi3 (tmp1, tmp1,\n-\t\t\tforce_reg (SImode, GEN_INT (fpbits)));\n+\ti = gen_xorsi3 (tmp, tmp, force_reg (SImode, GEN_INT (fpbits)));\n       else if (mode == FP_MODE_SINGLE)\n-\ti = gen_andsi3 (tmp1, tmp1,\n-\t\t\tforce_reg (SImode, GEN_INT (~fpbits)));\n+\ti = gen_andsi3 (tmp, tmp, force_reg (SImode, GEN_INT (~fpbits)));\n       else if (mode == FP_MODE_DOUBLE)\n-\ti = gen_iorsi3 (tmp1, tmp1,\n-\t\t\tforce_reg (SImode, GEN_INT (fpbits)));\n+\ti = gen_iorsi3 (tmp, tmp, force_reg (SImode, GEN_INT (fpbits)));\n       else\n \tgcc_unreachable ();\n \n       emit_insn (i);\n-\n-      emit_insn (gen_truncate_si_psi (tmp0, tmp1));\n-      emit_move_insn (get_fpscr_rtx (), tmp0);\n+      emit_insn (gen_lds_fpscr (tmp));\n     }\n }\n "}, {"sha": "675017c2c977d4778f03ab29748f533a1b68d0b4", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 70, "deletions": 95, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fe3e478fb1bf55dd6be3f708f3f90478dd6d1e39", "patch": "@@ -116,8 +116,9 @@\n \n   (XD0_REG\t136)\n \n-  (FPSCR_PR\t524288)\n-  (FPSCR_SZ\t1048576)\n+  (FPSCR_PR\t524288)  ;; 1 << 19\n+  (FPSCR_SZ\t1048576) ;; 1 << 20\n+  (FPSCR_FR\t2097152) ;; 1 << 21\n ])\n \n (define_c_enum \"unspec\" [\n@@ -6508,23 +6509,23 @@ label:\n   [(const_int 0)]\n   \"TARGET_SH2E\"\n {\n-  rtx insn = emit_insn (gen_fpu_switch (gen_frame_mem (PSImode,\n-\t\t\t\t\t\t gen_rtx_PRE_DEC (Pmode,\n-\t\t\t\t\t\t\t  stack_pointer_rtx)),\n-\t\t\t\t\tget_fpscr_rtx ()));\n-  add_reg_note (insn, REG_INC, stack_pointer_rtx);\n+  add_reg_note (\n+    emit_insn (\n+      gen_sts_fpscr (\n+\tgen_frame_mem (SImode, gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx)))),\n+    REG_INC, stack_pointer_rtx);\n   DONE;\n })\n \n (define_expand \"pop_fpscr\"\n   [(const_int 0)]\n   \"TARGET_SH2E\"\n {\n-  rtx insn = emit_insn (gen_fpu_switch (get_fpscr_rtx (),\n-\t\t\t\t\tgen_frame_mem (PSImode,\n-\t\t\t\t\t\t gen_rtx_POST_INC (Pmode,\n-\t\t\t\t\t\t\t  stack_pointer_rtx))));\n-  add_reg_note (insn, REG_INC, stack_pointer_rtx);\n+  add_reg_note (\n+    emit_insn (\n+      gen_lds_fpscr (\n+\tgen_frame_mem (SImode, gen_rtx_POST_INC (Pmode, stack_pointer_rtx)))),\n+    REG_INC, stack_pointer_rtx);\n   DONE;\n })\n \n@@ -6713,8 +6714,10 @@ label:\n \t(match_operand:SI 1 \"general_movsrc_operand\"\n \t \"Q,r,I08,I20,I28,mr,x,l,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y\"))]\n   \"(TARGET_SH2E || TARGET_SH2A)\n-   && (register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode))\"\n+   && ((register_operand (operands[0], SImode)\n+\t&& !fpscr_operand (operands[0], SImode))\n+       || (register_operand (operands[1], SImode)\n+\t   && !fpscr_operand (operands[1], SImode)))\"\n   \"@\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n@@ -12207,97 +12210,69 @@ label:\n ;; Floating point instructions.\n ;; -------------------------------------------------------------------------\n \n-;; ??? All patterns should have a type attribute.\n-\n-(define_expand \"movpsi\"\n-  [(set (match_operand:PSI 0 \"register_operand\" \"\")\n-\t(match_operand:PSI 1 \"general_movsrc_operand\" \"\"))]\n-  \"TARGET_FPU_ANY\"\n-{\n-  emit_insn (gen_fpu_switch (operands[0], operands[1]));\n-  DONE;\n-})\n-\n-;; The c / m alternative is a fake to guide reload to load directly into\n-;; fpscr, since reload doesn't know how to use post-increment.\n-;; TARGET_LEGITIMATE_ADDRESS_P guards about bogus addresses before reload,\n-;; SECONDARY_INPUT_RELOAD_CLASS does this during reload, and the insn's\n-;; predicate after reload.\n-;; The mac_gp type for r/!c might look a bit odd, but it actually schedules\n-;; like a mac -> gpr move.\n-(define_insn \"fpu_switch\"\n-  [(set (match_operand:PSI 0 \"general_movdst_operand\" \"=c,c,r,c,c,r,m,r,<\")\n-\t(match_operand:PSI 1 \"general_movsrc_operand\" \" c,>,m,m,r,r,r,!c,c\"))\n-   (use (reg:SI FPSCR_STAT_REG))\n-   (use (reg:SI FPSCR_MODES_REG))\n+;; FIXME: For now we disallow any memory operands for fpscr loads/stores,\n+;; except for post-inc loads and pre-dec stores for push/pop purposes.\n+;; This avoids problems with reload.  As a consequence, user initiated fpscr\n+;; stores to memory will always be ferried through a general register.\n+;; User initiated fpscr loads always have to undergo bit masking to preserve\n+;; the current fpu mode settings for the compiler generated code.  Thus such\n+;; fpscr loads will always have to go through general registers anyways.\n+(define_insn \"lds_fpscr\"\n+  [(set (reg:SI FPSCR_REG)\n+\t(match_operand:SI 0 \"fpscr_movsrc_operand\" \"r,>\"))\n    (set (reg:SI FPSCR_STAT_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_STAT))\n    (set (reg:SI FPSCR_MODES_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]\n-  \"TARGET_FPU_ANY\n-   && (! reload_completed\n-       || true_regnum (operands[0]) != FPSCR_REG\n-       || !MEM_P (operands[1])\n-       || GET_CODE (XEXP (operands[1], 0)) != PLUS)\"\n+  \"TARGET_FPU_ANY\"\n+  \"@\n+\tlds\t%0,fpscr\n+\tlds.l\t%0,fpscr\"\n+  [(set_attr \"type\" \"gp_fpscr,mem_fpscr\")])\n+\n+;; A move fpscr -> reg schedules like a move mac -> reg.  Thus we use mac_gp\n+;; type for it.\n+(define_insn \"sts_fpscr\"\n+  [(set (match_operand:SI 0 \"fpscr_movdst_operand\" \"=r,<\")\n+\t(reg:SI FPSCR_REG))\n+   (use (reg:SI FPSCR_STAT_REG))\n+   (use (reg:SI FPSCR_MODES_REG))]\n+  \"TARGET_FPU_ANY\"\n   \"@\n-\t! precision stays the same\n-\tlds.l\t%1,fpscr\n-\tmov.l\t%1,%0\n-\t#\n-\tlds\t%1,fpscr\n-\tmov\t%1,%0\n-\tmov.l\t%1,%0\n \tsts\tfpscr,%0\n \tsts.l\tfpscr,%0\"\n-  [(set_attr \"length\" \"0,2,2,4,2,2,2,2,2\")\n-   (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,\n-\t\t     mac_gp,fstore\")])\n+  [(set_attr \"type\" \"mac_gp,fstore\")])\n \n-(define_split\n-  [(set (reg:PSI FPSCR_REG)\n-        (match_operand:PSI 0 \"simple_mem_operand\"))\n-   (use (reg:SI FPSCR_STAT_REG))\n-   (use (reg:SI FPSCR_MODES_REG))\n-   (set (reg:SI FPSCR_STAT_REG)\n-\t(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_STAT))\n-   (set (reg:SI FPSCR_MODES_REG)\n-\t(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]\n-  \"TARGET_FPU_ANY && reload_completed\"\n-  [(const_int 0)]\n+(define_expand \"set_fpscr\"\n+  [(parallel [(set (reg:SI FPSCR_REG)\n+\t\t   (match_operand:SI 0 \"general_operand\"))\n+\t      (set (reg:SI FPSCR_STAT_REG)\n+\t\t   (unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))])]\n+  \"TARGET_FPU_ANY\"\n {\n-  rtx addrreg = XEXP (operands[0], 0);\n-  rtx mem = replace_equiv_address (operands[0],\n-\t\t\t\t   gen_rtx_POST_INC (Pmode, addrreg));\n+  /* We have to mask out the FR, SZ and PR bits.  To do that, we need to\n+     get the current FPSCR value first.\n+     (a & ~mask) | (b & mask) = a ^ ((a ^ b) & mask)  */\n \n-  add_reg_note (emit_insn (gen_fpu_switch (get_fpscr_rtx (), mem)),\n-\t\tREG_INC, addrreg);\n+  rtx mask = force_reg (SImode, GEN_INT (FPSCR_FR | FPSCR_SZ | FPSCR_PR));\n \n-  /* Modify the address reg to compensate for the forced post-inc mode.\n-     If the address reg becomes dead afterwards, the add will be eliminated\n-     automatically.  */\n-  emit_insn (gen_addsi3 (addrreg, addrreg, GEN_INT (-4)));\n-})\n+  rtx a = force_reg (SImode, operands[0]);\n \n-;; The 'extend_psi_si' and 'truncate_si_psi' insns are needed since we can't\n-;; do logic on PSImode.  Adding PSImode logic patterns works, but loading\n-;; a PSImode constant causes a double indirection, since the SH constant pool\n-;; is not aware of it.\n-;; FIXME: We could treat the FPSCR reg as SImode, but currently this causes\n-;; additional troubles.\n-(define_insn \"extend_psi_si\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(zero_extend:SI (match_operand:PSI 1 \"arith_reg_operand\" \"0\")))]\n-  \"TARGET_SH1\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")])\n+  rtx b = gen_reg_rtx (SImode);\n+  emit_insn (gen_sts_fpscr (b));\n \n-(define_insn \"truncate_si_psi\"\n-  [(set (match_operand:PSI 0 \"arith_reg_dest\" \"=r\")\n-\t(truncate:PSI (match_operand:SI 1 \"arith_reg_operand\" \"0\")))]\n-  \"TARGET_SH1\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")])\n+  rtx a_xor_b = gen_reg_rtx (SImode);\n+  emit_insn (gen_xorsi3 (a_xor_b, a, b));\n+\n+  rtx a_xor_b_and_mask = gen_reg_rtx (SImode);\n+  emit_insn (gen_andsi3 (a_xor_b_and_mask, a_xor_b, mask));\n+\n+  rtx r = gen_reg_rtx (SImode);\n+  emit_insn (gen_xorsi3 (r, a_xor_b_and_mask, a));\n+  emit_insn (gen_lds_fpscr (r));\n \n+  DONE;\n+})\n \n ;; ??? This uses the fp unit, but has no type indicating that.\n ;; If we did that, this would either give a bogus latency or introduce\n@@ -12306,8 +12281,8 @@ label:\n ;; it is probably best to claim no function unit, which matches the\n ;; current setting.\n (define_insn \"toggle_sz\"\n-  [(set (reg:PSI FPSCR_REG)\n-\t(xor:PSI (reg:PSI FPSCR_REG) (const_int FPSCR_SZ)))\n+  [(set (reg:SI FPSCR_REG)\n+\t(xor:SI (reg:SI FPSCR_REG) (const_int FPSCR_SZ)))\n    (set (reg:SI FPSCR_MODES_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]\n   \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\"\n@@ -12317,8 +12292,8 @@ label:\n ;; Toggle FPU precision PR mode.\n \n (define_insn \"toggle_pr\"\n-  [(set (reg:PSI FPSCR_REG)\n-\t(xor:PSI (reg:PSI FPSCR_REG) (const_int FPSCR_PR)))\n+  [(set (reg:SI FPSCR_REG)\n+\t(xor:SI (reg:SI FPSCR_REG) (const_int FPSCR_PR)))\n    (set (reg:SI FPSCR_MODES_REG)\n \t(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]\n   \"TARGET_SH4A_FP\""}]}