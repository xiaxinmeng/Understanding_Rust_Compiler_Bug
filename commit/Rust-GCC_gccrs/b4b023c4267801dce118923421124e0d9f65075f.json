{"sha": "b4b023c4267801dce118923421124e0d9f65075f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRiMDIzYzQyNjc4MDFkY2UxMTg5MjM0MjExMjRlMGQ5ZjY1MDc1Zg==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-04-16T23:07:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-05T13:09:09Z"}, "message": "[Ada] Add Ada 2022 Image and Put_Image support for tagged types\n\ngcc/ada/\n\n\t* debug.adb: Remove comments about -gnatd_z switch.\n\t* exp_ch3.adb (Make_Predefined_Primitive_Specs): A one-line fix\n\tfor a subtle bug that took some effort to debug. Append a new\n\tPut_Image procedure for a type extension even if it seems to\n\talready have one, just as is done for (for example) the\n\tstreaming-related Read procedure.\n\t* exp_put_image.adb:\n\t(Build_Record_Put_Image_Procedure.Make_Component_Attributes): Do\n\tnot treat _Parent component like just another component, for two\n\treasons.  1. If the _parent component's type has a\n\tuser-specified Put_Image procedure, then we want to generate a\n\tcall to that procedure and then generate extension aggregate\n\tsyntax.  2. Otherwise, we still don't want to see any mention of\n\t\"_parent\" in the generated image text.\n\t(Build_Record_Put_Image_Procedure.Make_Component_Name): Add\n\tassertion that we are not generating a reference to an \"_parent\"\n\tcomponent.\n\t(Build_Record_Put_Image_Procedure): Add special treatment for\n\tnull records.  Add call to Duplicate_Subexpr for image attribute\n\tprefix in order to help with expansion needed in the class-wide\n\tcase (where the prefix is also referenced in the call to\n\tWide_Wide_Expanded_Name) if evaluation of the prefix has side\n\teffects. Add new local helper function, Put_String_Exp.  Add\n\tsupport for case where prefix type is class-wide.\n\t(Enable_Put_Image, Preload_Root_Buffer_Type): Query Ada_Version\n\t> Ada_2022 instead of (indirectly) querying -gnatd_z switch.\n\t* freeze.adb (In_Expanded_Body): A one-line change to add\n\tTSS_Put_Image to the list of subprograms that have\n\texpander-created bodies.\n\t* rtsfind.ads: Add support for accessing\n\tAda.Tags.Wide_Wide_Expanded_Name.\n\t* sem_ch3.ads, sem_ch3.adb: Delete Is_Null_Extension function,\n\tas part of moving it to Sem_Util.\n\t* sem_ch13.adb\n\t(Analyze_Put_Image_TSS_Definition.Has_Good_Profile): Improve\n\tdiagnostic messages in cases where the result is going to be\n\tFalse and the Report parameter is True. Relax overly-restrictive\n\tchecks in order to implement mode conformance.\n\t(Analyze_Stream_TSS_Definition.Has_Good_Profile): Add similar\n\trelaxation of parameter subtype checking for the Stream\n\tparameter of user-defined streaming subprograms.\n\t* sem_disp.adb (Check_Dispatching_Operation): A one-line\n\tchange (and an accompanying comment change) to add TSS_Put_Image\n\tto the list of compiler-generated dispatching primitive\n\toperations.\n\t* sem_util.ads, sem_util.adb: Add Ignore_Privacy Boolean\n\tparameter to Is_Null_Record_Type function (typically the\n\tparameter will be False when the function is being used in the\n\timplementation of static semantics and True for dynamic\n\tsemantics; the parameter might make a difference in the case of,\n\tfor example, a private type that is implemented as a null record\n\ttype).  Add related new routines Is_Null_Extension (formerly\n\tdeclared in Sem_Ch3), Is_Null_Extension_Of, and\n\tIs_Null_Record_Definition.", "tree": {"sha": "d090c11ee08f2d652f4bbbc7ba82a24aff438478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d090c11ee08f2d652f4bbbc7ba82a24aff438478"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4b023c4267801dce118923421124e0d9f65075f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b023c4267801dce118923421124e0d9f65075f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4b023c4267801dce118923421124e0d9f65075f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b023c4267801dce118923421124e0d9f65075f/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9713be32ba408b1d8002d92c589c6c3ed8f8831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9713be32ba408b1d8002d92c589c6c3ed8f8831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9713be32ba408b1d8002d92c589c6c3ed8f8831"}], "stats": {"total": 579, "additions": 425, "deletions": 154}, "files": [{"sha": "978f333e9cc1c741fcbd48a72f03b1a0c5094eb7", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -164,7 +164,7 @@ package body Debug is\n    --  d_w\n    --  d_x  Disable inline expansion of Image attribute for enumeration types\n    --  d_y\n-   --  d_z  Enable Put_Image on tagged types\n+   --  d_z\n \n    --  d_A  Stop generation of ALI file\n    --  d_B  Warn on build-in-place function calls\n@@ -993,9 +993,6 @@ package body Debug is\n    --  d_x  The compiler does not expand in line the Image attribute for user-\n    --       defined enumeration types and the standard boolean type.\n \n-   --  d_z  Enable the default Put_Image on tagged types that are not\n-   --       predefined.\n-\n    --  d_A  Do not generate ALI files by setting Opt.Disable_ALI_File.\n \n    --  d_B  Warn on build-in-place function calls. This allows users to"}, {"sha": "ce6d294e9235754918eceaed2d05996d8399380c", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -10345,9 +10345,7 @@ package body Exp_Ch3 is\n \n       --  Spec of Put_Image\n \n-      if Enable_Put_Image (Tag_Typ)\n-        and then No (TSS (Tag_Typ, TSS_Put_Image))\n-      then\n+      if Enable_Put_Image (Tag_Typ) then\n          Append_To (Res, Predef_Spec_Or_Body (Loc,\n            Tag_Typ => Tag_Typ,\n            Name    => Make_TSS_Name (Tag_Typ, TSS_Put_Image),"}, {"sha": "3a9751b574d967b2d17e2c9c81376e6a89712bd2", "filename": "gcc/ada/exp_put_image.adb", "status": "modified", "additions": 225, "deletions": 61, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fexp_put_image.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fexp_put_image.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_put_image.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -23,13 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;        use Aspects;\n with Atree;          use Atree;\n+with Csets;          use Csets;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Exp_Tss;        use Exp_Tss;\n-with Exp_Util;\n-with Debug;          use Debug;\n+with Exp_Util;       use Exp_Util;\n with Lib;            use Lib;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n@@ -49,9 +50,6 @@ with Uintp;          use Uintp;\n \n package body Exp_Put_Image is\n \n-   Tagged_Put_Image_Enabled : Boolean renames Debug_Flag_Underscore_Z;\n-   --  ???Set True to enable Put_Image for at least some tagged types\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -649,32 +647,90 @@ package body Exp_Put_Image is\n             --  Loop through components, skipping all internal components,\n             --  which are not part of the value (e.g. _Tag), except that we\n             --  don't skip the _Parent, since we do want to process that\n-            --  recursively. If _Parent is an interface type, being abstract\n-            --  with no components there is no need to handle it.\n+            --  recursively.\n \n             while Present (Item) loop\n                if Nkind (Item) in\n                     N_Component_Declaration | N_Discriminant_Specification\n-                 and then\n-                   ((Chars (Defining_Identifier (Item)) = Name_uParent\n-                       and then not Is_Interface\n-                                      (Etype (Defining_Identifier (Item))))\n-                     or else\n-                    not Is_Internal_Name (Chars (Defining_Identifier (Item))))\n                then\n-                  if First_Time then\n-                     First_Time := False;\n-                  else\n-                     Append_To (Result,\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name =>\n-                           New_Occurrence_Of (RTE (RE_Record_Between), Loc),\n-                         Parameter_Associations => New_List\n-                           (Make_Identifier (Loc, Name_S))));\n+                  if Chars (Defining_Identifier (Item)) = Name_uParent then\n+                     declare\n+                        Parent_Type : constant Entity_Id :=\n+                          Underlying_Type (Base_Type (\n+                            (Etype (Defining_Identifier (Item)))));\n+\n+                        Parent_Aspect_Spec : constant Node_Id :=\n+                          Find_Aspect (Parent_Type, Aspect_Put_Image);\n+\n+                        Parent_Type_Decl : constant Node_Id :=\n+                          Declaration_Node (Parent_Type);\n+\n+                        Parent_Rdef : Node_Id :=\n+                          Type_Definition (Parent_Type_Decl);\n+                     begin\n+                        --  If parent type has an noninherited\n+                        --  explicitly-specified Put_Image aspect spec, then\n+                        --  display parent part by calling specified procedure,\n+                        --  and then use extension-aggregate syntax for the\n+                        --  remaining components as per RM 4.10(15/5);\n+                        --  otherwise, \"look through\" the parent component\n+                        --  to its components - we don't want the image text\n+                        --  to include mention of an \"_parent\" component.\n+\n+                        if Present (Parent_Aspect_Spec) and then\n+                          Entity (Parent_Aspect_Spec) = Parent_Type\n+                        then\n+                           Append_Component_Attr\n+                             (Result, Defining_Identifier (Item));\n+\n+                           --  Omit the \" with \" if no subsequent components.\n+\n+                           if not Is_Null_Extension_Of\n+                                    (Descendant => Typ,\n+                                     Ancestor => Parent_Type)\n+                           then\n+                              Append_To (Result,\n+                                 Make_Procedure_Call_Statement (Loc,\n+                                   Name =>\n+                                     New_Occurrence_Of\n+                                       (RTE (RE_Put_UTF_8), Loc),\n+                                   Parameter_Associations => New_List\n+                                     (Make_Identifier (Loc, Name_S),\n+                                      Make_String_Literal (Loc, \" with \"))));\n+                           end if;\n+                        else\n+                           if Nkind (Parent_Rdef) = N_Derived_Type_Definition\n+                           then\n+                              Parent_Rdef :=\n+                                Record_Extension_Part (Parent_Rdef);\n+                           end if;\n+\n+                           if Present (Component_List (Parent_Rdef)) then\n+                              Append_List_To (Result,\n+                                 Make_Component_List_Attributes\n+                                   (Component_List (Parent_Rdef)));\n+                           end if;\n+                        end if;\n+                     end;\n+\n+                  elsif not Is_Internal_Name\n+                              (Chars (Defining_Identifier (Item)))\n+                  then\n+                     if First_Time then\n+                        First_Time := False;\n+                     else\n+                        Append_To (Result,\n+                          Make_Procedure_Call_Statement (Loc,\n+                            Name =>\n+                              New_Occurrence_Of (RTE (RE_Record_Between), Loc),\n+                            Parameter_Associations => New_List\n+                              (Make_Identifier (Loc, Name_S))));\n+                     end if;\n+\n+                     Append_To (Result, Make_Component_Name (Item));\n+                     Append_Component_Attr\n+                       (Result, Defining_Identifier (Item));\n                   end if;\n-\n-                  Append_To (Result, Make_Component_Name (Item));\n-                  Append_Component_Attr (Result, Defining_Identifier (Item));\n                end if;\n \n                Next (Item);\n@@ -690,13 +746,35 @@ package body Exp_Put_Image is\n \n       function Make_Component_Name (C : Entity_Id) return Node_Id is\n          Name : constant Name_Id := Chars (Defining_Identifier (C));\n+         pragma Assert (Name /= Name_uParent);\n+\n+         function To_Upper (S : String) return String;\n+         --  Same as Ada.Characters.Handling.To_Upper, but withing\n+         --  Ada.Characters.Handling seems to cause mailserver problems.\n+\n+         --------------\n+         -- To_Upper --\n+         --------------\n+\n+         function To_Upper (S : String) return String is\n+         begin\n+            return Result : String := S do\n+               for Char of Result loop\n+                  Char := Fold_Upper (Char);\n+               end loop;\n+            end return;\n+         end To_Upper;\n+\n+      --  Start of processing for Make_Component_Name\n+\n       begin\n          return\n            Make_Procedure_Call_Statement (Loc,\n              Name => New_Occurrence_Of (RTE (RE_Put_UTF_8), Loc),\n              Parameter_Associations => New_List\n                (Make_Identifier (Loc, Name_S),\n-                Make_String_Literal (Loc, Get_Name_String (Name) & \" => \")));\n+                Make_String_Literal (Loc,\n+                  To_Upper (Get_Name_String (Name)) & \" => \")));\n       end Make_Component_Name;\n \n       Stms : constant List_Id := New_List;\n@@ -707,38 +785,47 @@ package body Exp_Put_Image is\n    --  Start of processing for Build_Record_Put_Image_Procedure\n \n    begin\n-      Append_To (Stms,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (RTE (RE_Record_Before), Loc),\n-          Parameter_Associations => New_List\n-            (Make_Identifier (Loc, Name_S))));\n+      if Is_Null_Record_Type (Btyp, Ignore_Privacy => True) then\n+         Append_To (Stms,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (RTE (RE_Put_UTF_8), Loc),\n+             Parameter_Associations => New_List\n+               (Make_Identifier (Loc, Name_S),\n+                Make_String_Literal (Loc, \"(NULL RECORD)\"))));\n+      else\n+         Append_To (Stms,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (RTE (RE_Record_Before), Loc),\n+             Parameter_Associations => New_List\n+               (Make_Identifier (Loc, Name_S))));\n \n-      --  Generate Put_Images for the discriminants of the type\n+         --  Generate Put_Images for the discriminants of the type\n \n-      Append_List_To (Stms,\n-        Make_Component_Attributes (Discriminant_Specifications (Type_Decl)));\n+         Append_List_To (Stms,\n+           Make_Component_Attributes\n+             (Discriminant_Specifications (Type_Decl)));\n \n-      Rdef := Type_Definition (Type_Decl);\n+         Rdef := Type_Definition (Type_Decl);\n \n-      --  In the record extension case, the components we want, including the\n-      --  _Parent component representing the parent type, are to be found in\n-      --  the extension. We will process the _Parent component using the type\n-      --  of the parent.\n+         --  In the record extension case, the components we want are to be\n+         --  found in the extension (although we have to process the\n+         --  _Parent component to find inherited components).\n \n-      if Nkind (Rdef) = N_Derived_Type_Definition then\n-         Rdef := Record_Extension_Part (Rdef);\n-      end if;\n+         if Nkind (Rdef) = N_Derived_Type_Definition then\n+            Rdef := Record_Extension_Part (Rdef);\n+         end if;\n \n-      if Present (Component_List (Rdef)) then\n-         Append_List_To (Stms,\n-           Make_Component_List_Attributes (Component_List (Rdef)));\n-      end if;\n+         if Present (Component_List (Rdef)) then\n+            Append_List_To (Stms,\n+              Make_Component_List_Attributes (Component_List (Rdef)));\n+         end if;\n \n-      Append_To (Stms,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (RTE (RE_Record_After), Loc),\n-          Parameter_Associations => New_List\n-            (Make_Identifier (Loc, Name_S))));\n+         Append_To (Stms,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (RTE (RE_Record_After), Loc),\n+             Parameter_Associations => New_List\n+               (Make_Identifier (Loc, Name_S))));\n+      end if;\n \n       Pnam := Make_Put_Image_Name (Loc, Btyp);\n       Build_Put_Image_Proc (Loc, Btyp, Decl, Pnam, Stms);\n@@ -843,9 +930,9 @@ package body Exp_Put_Image is\n       --\n       --  Put_Image on tagged types triggers some bugs.\n \n-      if Is_Remote_Types (Scope (Typ))\n+      if Ada_Version < Ada_2022\n+        or else Is_Remote_Types (Scope (Typ))\n         or else (Is_Tagged_Type (Typ) and then In_Predefined_Unit (Typ))\n-        or else (Is_Tagged_Type (Typ) and then not Tagged_Put_Image_Enabled)\n       then\n          return False;\n       end if;\n@@ -952,7 +1039,7 @@ package body Exp_Put_Image is\n       --  For T'Image (X) Generate an Expression_With_Actions node:\n       --\n       --     do\n-      --        S : Buffer := New_Buffer;\n+      --        S : Buffer;\n       --        U_Type'Put_Image (S, X);\n       --        Result : constant String := Get (S);\n       --        Destroy (S);\n@@ -970,13 +1057,16 @@ package body Exp_Put_Image is\n           Object_Definition =>\n             New_Occurrence_Of (RTE (RE_Buffer_Type), Loc));\n \n+      Image_Prefix : constant Node_Id :=\n+        Duplicate_Subexpr (First (Expressions (N)));\n+\n       Put_Im : constant Node_Id :=\n         Make_Attribute_Reference (Loc,\n           Prefix         => New_Occurrence_Of (U_Type, Loc),\n           Attribute_Name => Name_Put_Image,\n           Expressions    => New_List (\n             New_Occurrence_Of (Sink_Entity, Loc),\n-            New_Copy_Tree (First (Expressions (N)))));\n+            Image_Prefix));\n       Result_Entity : constant Entity_Id :=\n         Make_Defining_Identifier (Loc, Chars => New_Internal_Name ('R'));\n       Result_Decl : constant Node_Id :=\n@@ -989,12 +1079,86 @@ package body Exp_Put_Image is\n               Name => New_Occurrence_Of (RTE (RE_Get), Loc),\n               Parameter_Associations => New_List (\n                 New_Occurrence_Of (Sink_Entity, Loc))));\n-      Image : constant Node_Id :=\n-        Make_Expression_With_Actions (Loc,\n-          Actions => New_List (Sink_Decl, Put_Im, Result_Decl),\n-          Expression => New_Occurrence_Of (Result_Entity, Loc));\n+      Actions : List_Id;\n+\n+      function Put_String_Exp (String_Exp : Node_Id;\n+                               Wide_Wide  : Boolean := False) return Node_Id;\n+      --  Generate a call to evaluate a String (or Wide_Wide_String, depending\n+      --  on the Wide_Wide Boolean parameter) expression and output it into\n+      --  the buffer.\n+\n+      --------------------\n+      -- Put_String_Exp --\n+      --------------------\n+\n+      function Put_String_Exp (String_Exp : Node_Id;\n+                               Wide_Wide  : Boolean := False) return Node_Id is\n+         Put_Id : constant RE_Id :=\n+           (if Wide_Wide then RE_Wide_Wide_Put else RE_Put_UTF_8);\n+\n+         --  We could build a nondispatching call here, but to make\n+         --  that work we'd have to change Rtsfind spec to make available\n+         --  corresponding callees out of Ada.Strings.Text_Buffers.Unbounded\n+         --  (as opposed to from Ada.Strings.Text_Buffers). Seems simpler to\n+         --  introduce a type conversion and leave it to the optimizer to\n+         --  eliminate the dispatching. This does not *introduce* any problems\n+         --  if a no-dispatching-allowed restriction is in effect, since we\n+         --  are already in the middle of generating a call to T'Class'Image.\n+\n+         Sink_Exp : constant Node_Id :=\n+           Make_Type_Conversion (Loc,\n+             Subtype_Mark =>\n+               New_Occurrence_Of\n+                 (Class_Wide_Type (RTE (RE_Root_Buffer_Type)), Loc),\n+             Expression   => New_Occurrence_Of (Sink_Entity, Loc));\n+      begin\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (RTE (Put_Id), Loc),\n+             Parameter_Associations => New_List (Sink_Exp, String_Exp));\n+      end Put_String_Exp;\n+\n+   --  Start of processing for Build_Image_Call\n+\n    begin\n-      return Image;\n+      if Is_Class_Wide_Type (U_Type) then\n+         --  Generate qualified-expression syntax; qualification name comes\n+         --  from calling Ada.Tags.Wide_Wide_Expanded_Name.\n+\n+         declare\n+            --  The copy of Image_Prefix will be evaluated before the\n+            --  original, which is ok if no side effects are involved.\n+\n+            pragma Assert (Side_Effect_Free (Image_Prefix));\n+\n+            Specific_Type_Name : constant Node_Id :=\n+              Put_String_Exp\n+                (Make_Function_Call (Loc,\n+                   Name => New_Occurrence_Of\n+                             (RTE (RE_Wide_Wide_Expanded_Name), Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => Duplicate_Subexpr (Image_Prefix),\n+                       Attribute_Name => Name_Tag))),\n+                 Wide_Wide => True);\n+\n+            Qualification : constant Node_Id :=\n+              Put_String_Exp (Make_String_Literal (Loc, \"'\"));\n+         begin\n+            Actions := New_List\n+                         (Sink_Decl,\n+                          Specific_Type_Name,\n+                          Qualification,\n+                          Put_Im,\n+                          Result_Decl);\n+         end;\n+      else\n+         Actions := New_List (Sink_Decl, Put_Im, Result_Decl);\n+      end if;\n+\n+      return Make_Expression_With_Actions (Loc,\n+        Actions    => Actions,\n+        Expression => New_Occurrence_Of (Result_Entity, Loc));\n    end Build_Image_Call;\n \n    ------------------------------\n@@ -1023,7 +1187,7 @@ package body Exp_Put_Image is\n       --  Don't do it if type Root_Buffer_Type is unavailable in the runtime.\n \n       if not In_Predefined_Unit (Compilation_Unit)\n-        and then Tagged_Put_Image_Enabled\n+        and then Ada_Version >= Ada_2022\n         and then Tagged_Seen\n         and then not No_Run_Time_Mode\n         and then RTE_Available (RE_Root_Buffer_Type)"}, {"sha": "fa16887c0d7b9da4c2cb05460927c98b5058c2fd", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -7591,6 +7591,7 @@ package body Freeze is\n                          or else Is_TSS (Id, TSS_Stream_Output)\n                          or else Is_TSS (Id, TSS_Stream_Read)\n                          or else Is_TSS (Id, TSS_Stream_Write)\n+                         or else Is_TSS (Id, TSS_Put_Image)\n                          or else Nkind (Original_Node (P)) =\n                                              N_Subprogram_Renaming_Declaration)\n             then"}, {"sha": "6bec611c8087d961638bbf278567935e379ac302", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -708,6 +708,7 @@ package Rtsfind is\n      RE_TK_Tagged,                       -- Ada.Tags\n      RE_TK_Task,                         -- Ada.Tags\n      RE_Unregister_Tag,                  -- Ada.Tags\n+     RE_Wide_Wide_Expanded_Name,         -- Ada.Tags\n \n      RE_Set_Specific_Handler,            -- Ada.Task_Termination\n      RE_Specific_Handler,                -- Ada.Task_Termination\n@@ -2389,6 +2390,7 @@ package Rtsfind is\n      RE_TK_Tagged                        => Ada_Tags,\n      RE_TK_Task                          => Ada_Tags,\n      RE_Unregister_Tag                   => Ada_Tags,\n+     RE_Wide_Wide_Expanded_Name          => Ada_Tags,\n \n      RE_Set_Specific_Handler             => Ada_Task_Termination,\n      RE_Specific_Handler                 => Ada_Task_Termination,"}, {"sha": "83d7d3c92bcd78f9f081866d5b8df42a92c49f4b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -5230,44 +5230,64 @@ package body Sem_Ch13 is\n \n             F := First_Formal (Subp);\n \n-            if No (F)\n-              or else Etype (F) /= Class_Wide_Type (RTE (RE_Root_Buffer_Type))\n+            if No (F) then\n+               return False;\n+            end if;\n+\n+            if Base_Type (Etype (F))\n+              /= Class_Wide_Type (RTE (RE_Root_Buffer_Type))\n             then\n+               if Report then\n+                  Error_Msg_N\n+                    (\"wrong type for Put_Image procedure''s first parameter\",\n+                     Parameter_Type (Parent (F)));\n+               end if;\n+\n                return False;\n             end if;\n \n-            Next_Formal (F);\n+            if Parameter_Mode (F) /= E_In_Out_Parameter then\n+               if Report then\n+                  Error_Msg_N\n+                    (\"wrong mode for Put_Image procedure''s first parameter\",\n+                     Parent (F));\n+               end if;\n \n-            if Parameter_Mode (F) /= E_In_Parameter then\n                return False;\n             end if;\n \n+            Next_Formal (F);\n+\n             Typ := Etype (F);\n \n             --  Verify that the prefix of the attribute and the local name for\n             --  the type of the formal match.\n \n-            if Typ /= Ent then\n-               return False;\n-            end if;\n+            if Base_Type (Typ) /= Base_Type (Ent) then\n+               if Report then\n+                  Error_Msg_N\n+                    (\"wrong type for Put_Image procedure''s second parameter\",\n+                     Parameter_Type (Parent (F)));\n+               end if;\n \n-            if Present (Next_Formal (F)) then\n                return False;\n+            end if;\n \n-            elsif not Is_Scalar_Type (Typ)\n-              and then not Is_First_Subtype (Typ)\n-            then\n-               if Report and not Is_First_Subtype (Typ) then\n+            if Parameter_Mode (F) /= E_In_Parameter then\n+               if Report then\n                   Error_Msg_N\n-                    (\"subtype of formal in Put_Image operation must be a \"\n-                     & \"first subtype\", Parameter_Type (Parent (F)));\n+                    (\"wrong mode for Put_Image procedure''s second parameter\",\n+                     Parent (F));\n                end if;\n \n                return False;\n+            end if;\n \n-            else\n-               return True;\n+            if Present (Next_Formal (F)) then\n+               return False;\n             end if;\n+\n+            return True;\n          end Has_Good_Profile;\n \n       --  Start of processing for Analyze_Put_Image_TSS_Definition\n@@ -5386,7 +5406,7 @@ package body Sem_Ch13 is\n \n             if No (F)\n               or else Ekind (Etype (F)) /= E_Anonymous_Access_Type\n-              or else Designated_Type (Etype (F)) /=\n+              or else Base_Type (Designated_Type (Etype (F))) /=\n                         Class_Wide_Type (RTE (RE_Root_Stream_Type))\n             then\n                return False;"}, {"sha": "42504836bdbeec8eb9e39d90747a13493acf3494", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -19013,56 +19013,6 @@ package body Sem_Ch3 is\n       return False;\n    end Is_EVF_Procedure;\n \n-   -----------------------\n-   -- Is_Null_Extension --\n-   -----------------------\n-\n-   function Is_Null_Extension (T : Entity_Id) return Boolean is\n-      Type_Decl : constant Node_Id := Parent (Base_Type (T));\n-      Comp_List : Node_Id;\n-      Comp      : Node_Id;\n-\n-   begin\n-      if Nkind (Type_Decl) /= N_Full_Type_Declaration\n-        or else not Is_Tagged_Type (T)\n-        or else Nkind (Type_Definition (Type_Decl)) /=\n-                                              N_Derived_Type_Definition\n-        or else No (Record_Extension_Part (Type_Definition (Type_Decl)))\n-      then\n-         return False;\n-      end if;\n-\n-      Comp_List :=\n-        Component_List (Record_Extension_Part (Type_Definition (Type_Decl)));\n-\n-      if Present (Discriminant_Specifications (Type_Decl)) then\n-         return False;\n-\n-      elsif Present (Comp_List)\n-        and then Is_Non_Empty_List (Component_Items (Comp_List))\n-      then\n-         Comp := First (Component_Items (Comp_List));\n-\n-         --  Only user-defined components are relevant. The component list\n-         --  may also contain a parent component and internal components\n-         --  corresponding to secondary tags, but these do not determine\n-         --  whether this is a null extension.\n-\n-         while Present (Comp) loop\n-            if Comes_From_Source (Comp) then\n-               return False;\n-            end if;\n-\n-            Next (Comp);\n-         end loop;\n-\n-         return True;\n-\n-      else\n-         return True;\n-      end if;\n-   end Is_Null_Extension;\n-\n    --------------------------\n    -- Is_Private_Primitive --\n    --------------------------"}, {"sha": "eedb98caf129d63f618fb71c60ebe78fc8241752", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -176,11 +176,6 @@ package Sem_Ch3 is\n    --  corresponding to that discriminant in the constraint that specifies its\n    --  value.\n \n-   function Is_Null_Extension (T : Entity_Id) return Boolean;\n-   --  Returns True if the tagged type T has an N_Full_Type_Declaration that\n-   --  is a null extension, meaning that it has an extension part without any\n-   --  components and does not have a known discriminant part.\n-\n    function Is_Visible_Component\n      (C : Entity_Id;\n       N : Node_Id := Empty) return Boolean;"}, {"sha": "06c4b07c0c753b1afe17b32b6487c288c7e9b620", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -45,7 +45,6 @@ with Restrict;       use Restrict;\n with Rident;         use Rident;\n with Sem;            use Sem;\n with Sem_Aux;        use Sem_Aux;\n-with Sem_Ch3;        use Sem_Ch3;\n with Sem_Ch6;        use Sem_Ch6;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Eval;       use Sem_Eval;\n@@ -1209,7 +1208,7 @@ package body Sem_Disp is\n          --     primitives.\n \n          --  3. Subprograms associated with stream attributes (built by\n-         --     New_Stream_Subprogram)\n+         --     New_Stream_Subprogram) or with the Put_Image attribute.\n \n          --  4. Wrappers built for inherited operations with inherited class-\n          --     wide conditions, where the conditions include calls to other\n@@ -1238,6 +1237,7 @@ package body Sem_Disp is\n \n               or else Get_TSS_Name (Subp) = TSS_Stream_Read\n               or else Get_TSS_Name (Subp) = TSS_Stream_Write\n+              or else Get_TSS_Name (Subp) = TSS_Put_Image\n \n               or else\n                (Is_Wrapper (Subp)"}, {"sha": "e5b76f33cc2f056ea606ce402d33bc9936b87ad5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 134, "deletions": 9, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -712,7 +712,7 @@ package body Sem_Util is\n                return Make_Level_Literal\n                         (Type_Access_Level (Etype (E)));\n \n-            --  A non-discriminant selected component where the component\n+            --  A nondiscriminant selected component where the component\n             --  is an anonymous access type means that its associated\n             --  level is that of the containing type - see RM 3.10.2 (16).\n \n@@ -18576,18 +18576,143 @@ package body Sem_Util is\n       return False;\n    end Is_Nontrivial_DIC_Procedure;\n \n+   -----------------------\n+   -- Is_Null_Extension --\n+   -----------------------\n+\n+   function Is_Null_Extension\n+     (T : Entity_Id; Ignore_Privacy : Boolean := False) return Boolean\n+   is\n+      Type_Decl : Node_Id;\n+      Type_Def  : Node_Id;\n+   begin\n+      if Ignore_Privacy then\n+         Type_Decl := Parent (Underlying_Type (Base_Type (T)));\n+      else\n+         Type_Decl := Parent (Base_Type (T));\n+         if Nkind (Type_Decl) /= N_Full_Type_Declaration then\n+            return False;\n+         end if;\n+      end if;\n+      pragma Assert (Nkind (Type_Decl) = N_Full_Type_Declaration);\n+      Type_Def := Type_Definition (Type_Decl);\n+      if Present (Discriminant_Specifications (Type_Decl))\n+        or else Nkind (Type_Def) /= N_Derived_Type_Definition\n+        or else not Is_Tagged_Type (T)\n+        or else No (Record_Extension_Part (Type_Def))\n+      then\n+         return False;\n+      end if;\n+\n+      return Is_Null_Record_Definition (Record_Extension_Part (Type_Def));\n+   end Is_Null_Extension;\n+\n+   --------------------------\n+   -- Is_Null_Extension_Of --\n+   --------------------------\n+\n+   function Is_Null_Extension_Of\n+     (Descendant, Ancestor : Entity_Id) return Boolean\n+   is\n+      Ancestor_Type : constant Entity_Id\n+        := Underlying_Type (Base_Type (Ancestor));\n+      Descendant_Type : Entity_Id := Underlying_Type (Base_Type (Descendant));\n+   begin\n+      pragma Assert (Descendant_Type /= Ancestor_Type);\n+      while Descendant_Type /= Ancestor_Type loop\n+         if not Is_Null_Extension\n+                  (Descendant_Type, Ignore_Privacy => True)\n+         then\n+            return False;\n+         end if;\n+         Descendant_Type := Etype (Subtype_Indication\n+                              (Type_Definition (Parent (Descendant_Type))));\n+         Descendant_Type := Underlying_Type (Base_Type (Descendant_Type));\n+      end loop;\n+      return True;\n+   end Is_Null_Extension_Of;\n+\n+   -------------------------------\n+   -- Is_Null_Record_Definition --\n+   -------------------------------\n+\n+   function Is_Null_Record_Definition (Record_Def : Node_Id) return Boolean is\n+      Item : Node_Id;\n+   begin\n+      --  Testing Null_Present is just an optimization, not required.\n+\n+      if Null_Present (Record_Def) then\n+         return True;\n+      elsif Present (Variant_Part (Component_List (Record_Def))) then\n+         return False;\n+      elsif not Present (Component_List (Record_Def)) then\n+         return True;\n+      end if;\n+\n+      Item := First (Component_Items (Component_List (Record_Def)));\n+\n+      while Present (Item) loop\n+         if Nkind (Item) = N_Component_Declaration\n+           and then Is_Internal_Name (Chars (Defining_Identifier (Item)))\n+         then\n+            null;\n+         elsif Nkind (Item) = N_Pragma then\n+            null;\n+         else\n+            return False;\n+         end if;\n+         Item := Next (Item);\n+      end loop;\n+\n+      return True;\n+   end Is_Null_Record_Definition;\n+\n    -------------------------\n    -- Is_Null_Record_Type --\n    -------------------------\n \n-   function Is_Null_Record_Type (T : Entity_Id) return Boolean is\n-      Decl : constant Node_Id := Parent (T);\n+   function Is_Null_Record_Type\n+     (T : Entity_Id; Ignore_Privacy : Boolean := False) return Boolean\n+   is\n+      Decl     : Node_Id;\n+      Type_Def : Node_Id;\n    begin\n-      return Nkind (Decl) = N_Full_Type_Declaration\n-        and then Nkind (Type_Definition (Decl)) = N_Record_Definition\n-        and then\n-          (No (Component_List (Type_Definition (Decl)))\n-            or else Null_Present (Component_List (Type_Definition (Decl))));\n+      if not Is_Record_Type (T) then\n+         return False;\n+      end if;\n+\n+      if Ignore_Privacy then\n+         Decl := Parent (Underlying_Type (Base_Type (T)));\n+      else\n+         Decl := Parent (Base_Type (T));\n+         if Nkind (Decl) /= N_Full_Type_Declaration then\n+            return False;\n+         end if;\n+      end if;\n+      pragma Assert (Nkind (Decl) = N_Full_Type_Declaration);\n+      Type_Def := Type_Definition (Decl);\n+\n+      if Has_Discriminants (Defining_Identifier (Decl)) then\n+         return False;\n+      end if;\n+\n+      case Nkind (Type_Def) is\n+         when N_Record_Definition =>\n+            return Is_Null_Record_Definition (Type_Def);\n+         when N_Derived_Type_Definition =>\n+            if not Is_Null_Record_Type\n+                     (Etype (Subtype_Indication (Type_Def)),\n+                      Ignore_Privacy => Ignore_Privacy)\n+            then\n+               return False;\n+            elsif not Is_Tagged_Type (T) then\n+               return True;\n+            else\n+               return Is_Null_Extension (T, Ignore_Privacy => Ignore_Privacy);\n+            end if;\n+         when others =>\n+            return False;\n+      end case;\n    end Is_Null_Record_Type;\n \n    ---------------------\n@@ -19183,7 +19308,7 @@ package body Sem_Util is\n          elsif Is_Tagged_Type (Typ) then\n             return True;\n \n-         --  Case of non-discriminated record\n+         --  Case of nondiscriminated record\n \n          else\n             declare"}, {"sha": "0894d034085fc3c524ff00578dc97430da5f9a42", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b023c4267801dce118923421124e0d9f65075f/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b4b023c4267801dce118923421124e0d9f65075f", "patch": "@@ -2126,9 +2126,28 @@ package Sem_Util is\n    --  assertion expression of pragma Default_Initial_Condition and if it does,\n    --  the encapsulated expression is nontrivial.\n \n-   function Is_Null_Record_Type (T : Entity_Id) return Boolean;\n-   --  Determine whether T is declared with a null record definition or a\n-   --  null component list.\n+   function Is_Null_Extension\n+    (T : Entity_Id; Ignore_Privacy : Boolean := False) return Boolean;\n+   --  Given a tagged type, returns True if argument is a type extension\n+   --  that introduces no new components (discriminant or nondiscriminant).\n+   --  Ignore_Privacy should be True for use in implementing dynamic semantics.\n+\n+   function Is_Null_Extension_Of\n+     (Descendant, Ancestor : Entity_Id) return Boolean;\n+   --  Given two tagged types, the first a descendant of the second,\n+   --  returns True if every component of Descendant is inherited\n+   --  (directly or indirectly) from Ancestor. Privacy is ignored.\n+\n+   function Is_Null_Record_Definition (Record_Def : Node_Id) return Boolean;\n+   --  Returns True for an N_Record_Definition node that has no user-defined\n+   --  components (and no variant part).\n+\n+   function Is_Null_Record_Type\n+     (T : Entity_Id; Ignore_Privacy : Boolean := False) return Boolean;\n+   --  Determine whether T is declared with a null record definition, a\n+   --  null component list, or as a type derived from a null record type\n+   --  (with a null extension if tagged). Returns True for interface types,\n+   --  False for discriminated types.\n \n    function Is_Object_Image (Prefix : Node_Id) return Boolean;\n    --  Returns True if an 'Img, 'Image, 'Wide_Image, or 'Wide_Wide_Image"}]}