{"sha": "bfb26eddf539d1531e29f7cdc4f4313eeb133de0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZiMjZlZGRmNTM5ZDE1MzFlMjlmN2NkYzRmNDMxM2VlYjEzM2RlMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-23T22:32:54Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-23T22:32:54Z"}, "message": "* config/ns32k/ns32k.c: Convert to ISO-C.\n\nFrom-SVN: r74989", "tree": {"sha": "499103077af3ca4879d7cc16e24ec660135d184e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/499103077af3ca4879d7cc16e24ec660135d184e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfb26eddf539d1531e29f7cdc4f4313eeb133de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb26eddf539d1531e29f7cdc4f4313eeb133de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfb26eddf539d1531e29f7cdc4f4313eeb133de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb26eddf539d1531e29f7cdc4f4313eeb133de0/comments", "author": null, "committer": null, "parents": [{"sha": "692fb023ef14a4690ee766c0596306353175aeec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692fb023ef14a4690ee766c0596306353175aeec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692fb023ef14a4690ee766c0596306353175aeec"}], "stats": {"total": 104, "additions": 35, "deletions": 69}, "files": [{"sha": "64d1a3db25e16ad98d1d22784b7b8a5caa7c7a1f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb26eddf539d1531e29f7cdc4f4313eeb133de0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb26eddf539d1531e29f7cdc4f4313eeb133de0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfb26eddf539d1531e29f7cdc4f4313eeb133de0", "patch": "@@ -1,3 +1,7 @@\n+2003-12-23  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/ns32k/ns32k.c: Convert to ISO-C.\n+\n 2003-12-23  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config/ia64/ia64.c (ia64_va_arg): Pass pointer for"}, {"sha": "e80724ecf40f1e65d7184d0fc75471f244a06fe4", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 31, "deletions": 69, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb26eddf539d1531e29f7cdc4f4313eeb133de0/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb26eddf539d1531e29f7cdc4f4313eeb133de0/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=bfb26eddf539d1531e29f7cdc4f4313eeb133de0", "patch": "@@ -150,9 +150,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n #endif\n \n static void\n-ns32k_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+ns32k_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n {\n   register int regno, g_regs_used = 0;\n   int used_regs_buf[8], *bufp = used_regs_buf;\n@@ -330,9 +328,7 @@ ns32k_output_function_prologue (file, size)\n #if !defined (MERLIN_TARGET) && !defined (UTEK_ASM)\n \n static void\n-ns32k_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+ns32k_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n {\n   register int regno, g_regs_used = 0, f_regs_used = 0;\n   int used_regs_buf[8], *bufp = used_regs_buf;\n@@ -472,9 +468,7 @@ ns32k_output_function_epilogue (file, size)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n int\n-hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n+hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   int size = GET_MODE_UNIT_SIZE (mode);\n \n@@ -498,10 +492,7 @@ hard_regno_mode_ok (regno, mode)\n }\n \n static bool\n-ns32k_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n+ns32k_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n {\n   switch (code)\n     {\n@@ -529,9 +520,8 @@ ns32k_rtx_costs (x, code, outer_code, total)\n     }\n }\n \n-int register_move_cost (CLASS1, CLASS2)\n-     enum reg_class CLASS1;\n-     enum reg_class CLASS2;\n+int\n+register_move_cost (enum reg_class CLASS1, enum reg_class CLASS2)\n {\n   if (CLASS1 == NO_REGS || CLASS2 == NO_REGS)\n     return 2;\n@@ -550,10 +540,10 @@ int register_move_cost (CLASS1, CLASS2)\n #if 0\n /* We made the insn definitions copy from floating point to general\n   registers via the stack. */\n-int secondary_memory_needed (CLASS1, CLASS2, M)\n-     enum reg_class CLASS1;\n-     enum reg_class CLASS2;\n-     enum machine_mode M;\n+int\n+secondary_memory_needed (enum reg_class CLASS1,\n+\t\t\t enum reg_class CLASS2,\n+\t\t\t enum machine_mode M)\n {\n   int ret = ((SUBSET_P (CLASS1, FP_REGS) && !SUBSET_P (CLASS2, FP_REGS))\n    || (!SUBSET_P (CLASS1, FP_REGS) && SUBSET_P (CLASS2, FP_REGS)));\n@@ -567,8 +557,7 @@ int secondary_memory_needed (CLASS1, CLASS2, M)\n    the default. */\n \n static int\n-ns32k_address_cost (operand)\n-     rtx operand;\n+ns32k_address_cost (rtx operand)\n {\n   int cost = 0;\n \n@@ -623,10 +612,9 @@ ns32k_address_cost (operand)\n    NO_REGS is returned.  */\n \n enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx in;\n+secondary_reload_class (enum reg_class class,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\trtx in)\n {\n   int regno = true_regnum (in);\n \n@@ -646,8 +634,7 @@ secondary_reload_class (class, mode, in)\n    multiplier (for MULT). */\n \n static rtx\n-gen_indexed_expr (base, index, scale)\n-     rtx base, index, scale;\n+gen_indexed_expr (rtx base, rtx index, rtx scale)\n {\n   rtx addr;\n \n@@ -669,10 +656,7 @@ gen_indexed_expr (base, index, scale)\n    that parallel \"operands\". */\n \n void\n-split_di (operands, num, lo_half, hi_half)\n-     rtx operands[];\n-     int num;\n-     rtx lo_half[], hi_half[];\n+split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n {\n   while (num--)\n     {\n@@ -699,8 +683,7 @@ split_di (operands, num, lo_half, hi_half)\n    for moving operands[1] into operands[0] as a fullword.  */\n \n static const char *\n-singlemove_string (operands)\n-     rtx *operands;\n+singlemove_string (rtx *operands)\n {\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) <= 7\n@@ -710,8 +693,7 @@ singlemove_string (operands)\n }\n \n const char *\n-output_move_double (operands)\n-     rtx *operands;\n+output_move_double (rtx *operands)\n {\n   enum anon1 { REGOP, OFFSOP, PUSHOP, CNSTOP, RNDOP } optype0, optype1;\n   rtx latehalf[2];\n@@ -849,10 +831,7 @@ output_move_double (operands)\n    operands[3] is the alignment.  */\n \n static void\n-move_tail (operands, bytes, offset)\n-     rtx operands[];\n-     int bytes;\n-     int offset;\n+move_tail (rtx operands[], int bytes, int offset)\n {\n   if (bytes & 2)\n     {\n@@ -866,8 +845,7 @@ move_tail (operands, bytes, offset)\n }\n \n void\n-expand_block_move (operands)\n-     rtx operands[];\n+expand_block_move (rtx operands[])\n {\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n@@ -994,9 +972,7 @@ expand_block_move (operands)\n /* Returns 1 if OP contains a global symbol reference */\n \n int\n-global_symbolic_reference_mentioned_p (op, f)\n-     rtx op;\n-     int f;\n+global_symbolic_reference_mentioned_p (rtx op, int f)\n {\n   register const char *fmt;\n   register int i;\n@@ -1034,8 +1010,7 @@ global_symbolic_reference_mentioned_p (op, f)\n /* Returns 1 if OP contains a symbol reference */\n \n int\n-symbolic_reference_mentioned_p (op)\n-     rtx op;\n+symbolic_reference_mentioned_p (rtx op)\n {\n   register const char *fmt;\n   register int i;\n@@ -1077,12 +1052,10 @@ const struct attribute_spec ns32k_attribute_table[] =\n /* Handle an attribute requiring a FUNCTION_TYPE, FIELD_DECL or TYPE_DECL;\n    arguments as in struct attribute_spec.handler.  */\n static tree\n-ns32k_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+ns32k_handle_fntype_attribute (tree *node, tree name,\n+\t\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t\t       bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_TYPE\n       && TREE_CODE (*node) != FIELD_DECL\n@@ -1115,10 +1088,7 @@ ns32k_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n    The attribute stdcall is equivalent to RET on a per module basis.  */\n \n int\n-ns32k_return_pops_args (fundecl, funtype, size)\n-     tree fundecl ATTRIBUTE_UNUSED;\n-     tree funtype;\n-     int size;\n+ns32k_return_pops_args (tree fundecl ATTRIBUTE_UNUSED, tree funtype, int size)\n {\n   int rtd = TARGET_RTD;\n \n@@ -1149,10 +1119,7 @@ ns32k_return_pops_args (fundecl, funtype, size)\n \n /* XXX time 12% of cpu time is in fprintf for non optimizing */\n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   if (code == '$')\n     PUT_IMMEDIATE_PREFIX (file);\n@@ -1240,9 +1207,7 @@ print_operand (file, x, code)\n    90-11-25 Tatu Yl|nen <ylo@cs.hut.fi> */\n \n void\n-print_operand_address (file, addr)\n-     register FILE *file;\n-     register rtx addr;\n+print_operand_address (register FILE *file, register rtx addr)\n {\n   static const char scales[] = { 'b', 'w', 'd', 0, 'q', };\n   rtx offset, base, indexexp, tmp;\n@@ -1524,8 +1489,7 @@ print_operand_address (file, addr)\n    better performance in many common cases by using other\n    techniques.  */\n const char *\n-output_shift_insn (operands)\n-     rtx *operands;\n+output_shift_insn (rtx *operands)\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) > 0\n@@ -1574,9 +1538,7 @@ output_shift_insn (operands)\n }\n \n const char *\n-output_move_dconst (n, s)\n-\tint n;\n-\tconst char *s;\n+output_move_dconst (int n, const char *s)\n {\n   static char r[32];\n "}]}