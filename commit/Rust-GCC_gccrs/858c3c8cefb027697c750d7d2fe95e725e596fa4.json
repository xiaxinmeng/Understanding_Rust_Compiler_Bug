{"sha": "858c3c8cefb027697c750d7d2fe95e725e596fa4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU4YzNjOGNlZmIwMjc2OTdjNzUwZDdkMmZlOTVlNzI1ZTU5NmZhNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-01-14T20:38:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-01-14T20:38:34Z"}, "message": "Add support for REG[NO]_MODE_OK_FOR_BASE_P\n\nFrom-SVN: r13492", "tree": {"sha": "46dd334aa6c69ca33b4982811624e1ba06160774", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46dd334aa6c69ca33b4982811624e1ba06160774"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/858c3c8cefb027697c750d7d2fe95e725e596fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858c3c8cefb027697c750d7d2fe95e725e596fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858c3c8cefb027697c750d7d2fe95e725e596fa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858c3c8cefb027697c750d7d2fe95e725e596fa4/comments", "author": null, "committer": null, "parents": [{"sha": "8026ebba9914ccc5526ecd5c848fc14100a1bb69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8026ebba9914ccc5526ecd5c848fc14100a1bb69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8026ebba9914ccc5526ecd5c848fc14100a1bb69"}], "stats": {"total": 116, "additions": 65, "deletions": 51}, "files": [{"sha": "a463a8c10b0fd1c0815dda7dc7a4d8a73687b0c4", "filename": "gcc/reload.c", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/858c3c8cefb027697c750d7d2fe95e725e596fa4/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/858c3c8cefb027697c750d7d2fe95e725e596fa4/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=858c3c8cefb027697c750d7d2fe95e725e596fa4", "patch": "@@ -103,6 +103,14 @@ a register with any other reload.  */\n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n+\n+#ifndef REGNO_MODE_OK_FOR_BASE_P\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n+#endif\n+\n+#ifndef REG_MODE_OK_FOR_BASE_P\n+#define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n+#endif\n \f\n /* The variables set up by `find_reloads' are:\n \n@@ -311,8 +319,8 @@ static int find_reloads_address\tPROTO((enum machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t       int, enum reload_type, int));\n static rtx subst_reg_equivs\tPROTO((rtx));\n static rtx subst_indexed_address PROTO((rtx));\n-static int find_reloads_address_1 PROTO((rtx, int, rtx *, int,\n-\t\t\t\t\t enum reload_type,int));\n+static int find_reloads_address_1 PROTO((enum machine_mode, rtx, int, rtx *,\n+\t\t\t\t\t int, enum reload_type,int));\n static void find_reloads_address_part PROTO((rtx, rtx *, enum reg_class,\n \t\t\t\t\t     enum machine_mode, int,\n \t\t\t\t\t     enum reload_type, int));\n@@ -4233,7 +4241,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t hard register that is valid as a base register and which is not the\n \t subject of a CLOBBER in this insn.  */\n \n-      else if (regno < FIRST_PSEUDO_REGISTER && REGNO_OK_FOR_BASE_P (regno)\n+      else if (regno < FIRST_PSEUDO_REGISTER\n+\t       && REGNO_MODE_OK_FOR_BASE_P (regno, mode)\n \t       && ! regno_clobbered_p (regno, this_insn))\n \treturn 0;\n \n@@ -4324,7 +4333,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n   else if (GET_CODE (ad) == PLUS\n \t   && GET_CODE (XEXP (ad, 0)) == REG\n \t   && REGNO (XEXP (ad, 0)) < FIRST_PSEUDO_REGISTER\n-\t   && REG_OK_FOR_BASE_P (XEXP (ad, 0))\n+\t   && REG_MODE_OK_FOR_BASE_P (XEXP (ad, 0), mode)\n \t   && GET_CODE (XEXP (ad, 1)) == CONST_INT)\n     {\n       /* Unshare the MEM rtx so we can safely alter it.  */\n@@ -4401,7 +4410,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t\t\t   XEXP (XEXP (ad, 0), 1));\n       find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0), BASE_REG_CLASS,\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n-      find_reloads_address_1 (XEXP (ad, 1), 1, &XEXP (ad, 1), opnum, type, 0);\n+      find_reloads_address_1 (mode, XEXP (ad, 1), 1, &XEXP (ad, 1), opnum,\n+\t\t\t      type, 0);\n \n       return 1;\n     }\n@@ -4424,7 +4434,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t\t\t\t\t  INTVAL (XEXP (ad, 1))));\n       find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1), BASE_REG_CLASS,\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n-      find_reloads_address_1 (XEXP (ad, 0), 1, &XEXP (ad, 0), opnum, type, 0);\n+      find_reloads_address_1 (mode, XEXP (ad, 0), 1, &XEXP (ad, 0), opnum,\n+\t\t\t      type, 0);\n \n       return 1;\n     }\n@@ -4470,7 +4481,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n       return 1;\n     }\n \n-  return find_reloads_address_1 (ad, 0, loc, opnum, type, ind_levels);\n+  return find_reloads_address_1 (mode, ad, 0, loc, opnum, type, ind_levels);\n }\n \f\n /* Find all pseudo regs appearing in AD\n@@ -4633,9 +4644,11 @@ subst_indexed_address (addr)\n   return addr;\n }\n \f\n-/* Record the pseudo registers we must reload into hard registers\n-   in a subexpression of a would-be memory address, X.\n-   (This function is not called if the address we find is strictly valid.)\n+/* Record the pseudo registers we must reload into hard registers in a\n+   subexpression of a would-be memory address, X referring to a value\n+   in mode MODE.  (This function is not called if the address we find\n+   is strictly valid.)\n+\n    CONTEXT = 1 means we are considering regs as index regs,\n    = 0 means we are considering them as base regs.\n \n@@ -4653,7 +4666,8 @@ subst_indexed_address (addr)\n    could have addressing modes that this does not handle right.  */\n \n static int\n-find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n+find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n+     enum machine_mode mode;\n      rtx x;\n      int context;\n      rtx *loc;\n@@ -4695,74 +4709,74 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE \n \t    || code0 == ZERO_EXTEND || code1 == MEM)\n \t  {\n-\t    find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n-\t\t\t\t    ind_levels);\n-\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t    ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n+\t\t\t\t    type, ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n+\t\t\t\t    type, ind_levels);\n \t  }\n \n \telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n \t\t || code1 == ZERO_EXTEND || code0 == MEM)\n \t  {\n-\t    find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n-\t\t\t\t    ind_levels);\n-\t    find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n-\t\t\t\t    ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n+\t\t\t\t    type, ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n+\t\t\t\t    type, ind_levels);\n \t  }\n \n \telse if (code0 == CONST_INT || code0 == CONST\n \t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t  find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t  ind_levels);\n+\t  find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n+\t\t\t\t  type, ind_levels);\n \n \telse if (code1 == CONST_INT || code1 == CONST\n \t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t  find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n-\t\t\t\t  ind_levels);\n+\t  find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n+\t\t\t\t  type, ind_levels);\n \n \telse if (code0 == REG && code1 == REG)\n \t  {\n \t    if (REG_OK_FOR_INDEX_P (op0)\n-\t\t&& REG_OK_FOR_BASE_P (op1))\n+\t\t&& REG_MODE_OK_FOR_BASE_P (op1, mode))\n \t      return 0;\n \t    else if (REG_OK_FOR_INDEX_P (op1)\n-\t\t     && REG_OK_FOR_BASE_P (op0))\n+\t\t     && REG_MODE_OK_FOR_BASE_P (op0, mode))\n \t      return 0;\n-\t    else if (REG_OK_FOR_BASE_P (op1))\n-\t      find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type, \n-\t\t\t\t      ind_levels);\n-\t    else if (REG_OK_FOR_BASE_P (op0))\n-\t      find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n-\t\t\t\t      ind_levels);\n+\t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t      find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n+\t\t\t\t      type, ind_levels);\n+\t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t      find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n+\t\t\t\t      type, ind_levels);\n \t    else if (REG_OK_FOR_INDEX_P (op1))\n-\t      find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n-\t\t\t\t      ind_levels);\n+\t      find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n+\t\t\t\t      type, ind_levels);\n \t    else if (REG_OK_FOR_INDEX_P (op0))\n-\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t    ind_levels);\n+\t      find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n+\t\t\t\t      type, ind_levels);\n \t    else\n \t      {\n-\t\tfind_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n-\t\t\t\t\tind_levels);\n-\t\tfind_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t\tind_levels);\n+\t\tfind_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n+\t\t\t\t\ttype, ind_levels);\n+\t\tfind_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n+\t\t\t\t\ttype, ind_levels);\n \t      }\n \t  }\n \n \telse if (code0 == REG)\n \t  {\n-\t    find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n-\t\t\t\t    ind_levels);\n-\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t    ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n+\t\t\t\t    type, ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n+\t\t\t\t    type, ind_levels);\n \t  }\n \n \telse if (code1 == REG)\n \t  {\n-\t    find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n-\t\t\t\t    ind_levels);\n-\t    find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n-\t\t\t\t    ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n+\t\t\t\t    type, ind_levels);\n+\t    find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n+\t\t\t\t    type, ind_levels);\n \t  }\n       }\n \n@@ -4811,7 +4825,7 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \t    regno = reg_renumber[regno];\n \t  if ((regno >= FIRST_PSEUDO_REGISTER\n \t       || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t    : REGNO_OK_FOR_BASE_P (regno))))\n+\t\t    : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t    {\n \t      register rtx link;\n \n@@ -4928,7 +4942,7 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \n \tif ((regno >= FIRST_PSEUDO_REGISTER\n \t     || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t  : REGNO_OK_FOR_BASE_P (regno))))\n+\t\t  : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n@@ -4961,7 +4975,7 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \t      int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n \n \t      if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t     : REGNO_OK_FOR_BASE_P (regno)))\n+\t\t     : REGNO_MODE_OK_FOR_BASE_P (regno, mode)))\n \t\t{\n \t\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n@@ -4994,7 +5008,7 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n-\t  find_reloads_address_1 (XEXP (x, i), context, &XEXP (x, i),\n+\t  find_reloads_address_1 (mode, XEXP (x, i), context, &XEXP (x, i),\n \t\t\t\t  opnum, type, ind_levels);\n       }\n   }"}]}