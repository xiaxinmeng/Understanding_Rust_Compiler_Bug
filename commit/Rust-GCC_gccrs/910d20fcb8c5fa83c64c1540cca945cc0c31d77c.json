{"sha": "910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwZDIwZmNiOGM1ZmE4M2M2NGMxNTQwY2NhOTQ1Y2MwYzMxZDc3Yw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@gnat.com", "date": "2004-09-21T15:31:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-09-21T15:31:03Z"}, "message": "decl.c (gnat_to_gnu_type, [...]): Wrap modular packed array types in both little- and big-endian cases.\n\n2004-09-21  Robert Dewar  <dewar@gnat.com>\n\n\t* decl.c (gnat_to_gnu_type, case E_Modular_Integer_Type): Wrap modular\n\tpacked array types in both little- and big-endian cases. This change\n\tensures that we no longer count on the unused bits being initialized\n\tfor such types (and in particular ensures that equality testing will\n\tonly read the relevant bits).\n\tChange name TYPE_LEFT_JUSTIFIED_MODULAR_P to TYPE_JUSTIFIED_MODULAR_P\n\tThese changes mean that we no longer need to initialize small packed\n\tarrays.\n\t(gnat_to_gnu_entity) <E_Record_Subtype>: Apply the same\n\toptimization to an LJM field as to its parent field.\n\n\t* ada-tree.h:, trans.c, utils.c, utils2.c:\n\tChange name TYPE_LEFT_JUSTIFIED_MODULAR_P to TYPE_JUSTIFIED_MODULAR_P\n\nFrom-SVN: r87806", "tree": {"sha": "0f2f5fda62754d844de054ab5257854ecaf80e0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f2f5fda62754d844de054ab5257854ecaf80e0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/comments", "author": null, "committer": null, "parents": [{"sha": "f1b1846249458e8b583b407f674fec541c4f6869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b1846249458e8b583b407f674fec541c4f6869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b1846249458e8b583b407f674fec541c4f6869"}], "stats": {"total": 124, "additions": 74, "deletions": 50}, "files": [{"sha": "3799d7b0b54507e8d91756a8fdb4ddb34997820d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "patch": "@@ -1,3 +1,19 @@\n+2004-09-21  Robert Dewar  <dewar@gnat.com>\n+\n+\t* decl.c (gnat_to_gnu_type, case E_Modular_Integer_Type): Wrap modular\n+\tpacked array types in both little- and big-endian cases. This change\n+\tensures that we no longer count on the unused bits being initialized\n+\tfor such types (and in particular ensures that equality testing will\n+\tonly read the relevant bits).\n+\tChange name TYPE_LEFT_JUSTIFIED_MODULAR_P to TYPE_JUSTIFIED_MODULAR_P\n+\tThese changes mean that we no longer need to initialize small packed\n+\tarrays.\n+\t(gnat_to_gnu_entity) <E_Record_Subtype>: Apply the same\n+\toptimization to an LJM field as to its parent field.\n+\n+\t* ada-tree.h, trans.c, utils.c, utils2.c:\n+\tChange name TYPE_LEFT_JUSTIFIED_MODULAR_P to TYPE_JUSTIFIED_MODULAR_P\n+\n 2004-09-20  Jan Hubicka  <jh@suse.cz>\n \n \t* utils.c (gnat_finalize): Remove."}, {"sha": "c087f7851ef494d22aff859e2e872763b1d970ab", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "patch": "@@ -86,8 +86,8 @@ struct lang_type GTY(()) {tree t; };\n   TYPE_LANG_FLAG_1 (FUNCTION_TYPE_CHECK (NODE))\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n-   a left-justified modular type (will only be true for RECORD_TYPE).  */\n-#define TYPE_LEFT_JUSTIFIED_MODULAR_P(NODE) \\\n+   a justified modular type (will only be true for RECORD_TYPE).  */\n+#define TYPE_JUSTIFIED_MODULAR_P(NODE) \\\n   TYPE_LANG_FLAG_1 (RECORD_OR_UNION_CHECK (NODE))\n \n /* Nonzero in an arithmetic subtype if this is a subtype not known to the\n@@ -290,4 +290,4 @@ struct lang_type GTY(()) {tree t; };\n #define REGION_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 2)\n #define HANDLER_STMT_ARG(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 0)\n #define HANDLER_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 1)\n-#define HANDLER_STMT_BLOCK(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 2)\n+#define HANDLER_STMT_BLOCK(NODE) TREE_OPERAND_CHECK_CODE(NODE, HANDLER_STMT, 2)"}, {"sha": "b73081bb3eeed0246505bc72658e559c3dc72678", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "patch": "@@ -1341,9 +1341,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       /* If the type we are dealing with is to represent a packed array,\n \t we need to have the bits left justified on big-endian targets\n-\t (see exp_packd.ads).  We build a record with a bitfield of the\n-\t appropriate size to achieve this.  */\n-      if (Is_Packed_Array_Type (gnat_entity) && BYTES_BIG_ENDIAN)\n+\t and right justified on little-endian targets.  We also need to\n+\t ensure that when the value is read (e.g. for comparison of two\n+\t such values), we only get the good bits, since the unused bits\n+\t are uninitialized.  Both goals are accomplished by wrapping the\n+\t modular value in an enclosing struct.  */\n+\tif (Is_Packed_Array_Type (gnat_entity))\n \t{\n \t  tree gnu_field_type = gnu_type;\n \t  tree gnu_field;\n@@ -1362,7 +1365,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n \n \t  finish_record_type (gnu_type, gnu_field, false, false);\n-\t  TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n+\t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n \t}\n \n@@ -2108,7 +2111,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n \t  while (TREE_CODE (gnu_inner_type) == RECORD_TYPE\n-\t\t && (TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_inner_type)\n+\t\t && (TYPE_JUSTIFIED_MODULAR_P (gnu_inner_type)\n \t\t     || TYPE_IS_PADDING_P (gnu_inner_type)))\n \t    gnu_inner_type = TREE_TYPE (TYPE_FIELDS (gnu_inner_type));\n \n@@ -2164,7 +2167,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n \n \t      if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type))\n+\t\t  && TYPE_JUSTIFIED_MODULAR_P (gnu_type))\n \t\tTREE_TYPE (TYPE_FIELDS (gnu_type)) = gnu_inner_type;\n \t    }\n \t}\n@@ -2631,9 +2634,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t    /* If there was a component clause, the field types must be\n \t\t       the same for the type and subtype, so copy the data from\n-\t\t       the old field to avoid recomputation here.  */\n+\t\t       the old field to avoid recomputation here.  Also if the\n+\t\t       field is justified modular and the optimization in\n+\t\t       gnat_to_gnu_field was applied.  */\n \t\t    if (Present (Component_Clause\n-\t\t\t\t (Original_Record_Component (gnat_field))))\n+\t\t\t\t (Original_Record_Component (gnat_field)))\n+\t\t\t|| (TREE_CODE (gnu_field_type) == RECORD_TYPE\n+\t\t\t    && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n+\t\t\t    && TREE_TYPE (TYPE_FIELDS (gnu_field_type))\n+\t\t\t       == TREE_TYPE (gnu_old_field)))\n \t\t      {\n \t\t\tgnu_size = DECL_SIZE (gnu_old_field);\n \t\t\tgnu_field_type = TREE_TYPE (gnu_old_field);\n@@ -4650,8 +4659,8 @@ make_packable_type (tree type)\n      the alignment to try for an integral type.  For QUAL_UNION_TYPE,\n      also copy the size.  */\n   TYPE_NAME (new_type) = TYPE_NAME (type);\n-  TYPE_LEFT_JUSTIFIED_MODULAR_P (new_type)\n-    = TYPE_LEFT_JUSTIFIED_MODULAR_P (type);\n+  TYPE_JUSTIFIED_MODULAR_P (new_type)\n+    = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n \n   if (TREE_CODE (type) == RECORD_TYPE)\n@@ -5021,15 +5030,15 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n \n-  /* If the field's type is left-justified modular, the wrapper can prevent\n+  /* If the field's type is justified modular, the wrapper can prevent\n      packing so we make the field the type of the inner object unless the\n      situation forbids it. We may not do that when the field is addressable_p,\n      typically because in that case this field may later be passed by-ref for\n-     a formal argument expecting the left justification.  The condition below\n+     a formal argument expecting the justification.  The condition below\n      is then matching the addressable_p code for COMPONENT_REF.  */\n   if (!Is_Aliased (gnat_field) && flag_strict_aliasing\n       && TREE_CODE (gnu_field_type) == RECORD_TYPE\n-      && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_field_type))\n+      && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type))\n     gnu_field_type = TREE_TYPE (TYPE_FIELDS (gnu_field_type));\n \n   /* If we are packing this record, have a specified size that's smaller than\n@@ -5175,12 +5184,12 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     gnu_pos = NULL_TREE;\n   else\n     {\n-      /* Unless this field is aliased, we can remove any left-justified\n+      /* Unless this field is aliased, we can remove any justified\n \t modular type since it's only needed in the unchecked conversion\n \t case, which doesn't apply here.  */\n       if (!needs_strict_alignment\n \t  && TREE_CODE (gnu_field_type) == RECORD_TYPE\n-\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_field_type))\n+\t  && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type))\n \tgnu_field_type = TREE_TYPE (TYPE_FIELDS (gnu_field_type));\n \n       gnu_field_type"}, {"sha": "1085b06314f90221ba8d1d8b849aa407c4d3b41a", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "patch": "@@ -1606,7 +1606,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t\t\t\tgnu_target,\n \t\t\t\t\t\t\tfalse)),\n \t\t     NULL_TREE);\n-\t\t\t\t\t\t   \n+\n     }\n \n   /* The only way we can be making a call via an access type is if Name is an\n@@ -1668,7 +1668,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      tree gnu_temp;\n \n \t      /* Remove any unpadding on the actual and make a copy.  But if\n-\t\t the actual is a left-justified modular type, first convert\n+\t\t the actual is a justified modular type, first convert\n \t\t to it.  */\n \t      if (TREE_CODE (gnu_name) == COMPONENT_REF\n \t\t  && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_name, 0)))\n@@ -1677,7 +1677,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t  (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))))\n \t\tgnu_name = gnu_copy = TREE_OPERAND (gnu_name, 0);\n \t      else if (TREE_CODE (gnu_name_type) == RECORD_TYPE\n-\t\t       && (TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_name_type)))\n+\t\t       && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)))\n \t\tgnu_name = convert (gnu_name_type, gnu_name);\n \n \t      gnu_actual = save_expr (gnu_name);\n@@ -1714,7 +1714,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       if (Ekind (gnat_formal) != E_In_Parameter\n \t  && TREE_CODE (gnu_name) == CONSTRUCTOR\n \t  && TREE_CODE (TREE_TYPE (gnu_name)) == RECORD_TYPE\n-\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n+\t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n \tgnu_name = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_name))),\n \t\t\t    gnu_name);\n \n@@ -1829,7 +1829,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       else\n \t{\n \t  tree gnu_actual_size = TYPE_SIZE (TREE_TYPE (gnu_actual));\n-\t  \n+\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n@@ -2083,7 +2083,6 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t\t\t\t build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\t gnu_jmpbuf_decl)));\n \n-\n   if (Present (First_Real_Statement (gnat_node)))\n     process_decls (Statements (gnat_node), Empty,\n \t\t   First_Real_Statement (gnat_node), true, true);\n@@ -2521,11 +2520,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \ttree gnu_type;\n \n \t/* Get the type of the result, looking inside any padding and\n-\t   left-justified modular types.  Then get the value in that type.  */\n+\t   justified modular types.  Then get the value in that type.  */\n \tgnu_type = gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n \tif (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t    && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type))\n+\t    && TYPE_JUSTIFIED_MODULAR_P (gnu_type))\n \t  gnu_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n \n \tgnu_result = UI_To_gnu (Intval (gnat_node), gnu_type);\n@@ -4102,7 +4101,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   && (CONTAINS_PLACEHOLDER_P\n \t\t       (TYPE_SIZE (TREE_TYPE (gnu_result))))))\n \t   && !(TREE_CODE (gnu_result_type) == RECORD_TYPE\n-\t\t&& TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_result_type))))\n+\t\t&& TYPE_JUSTIFIED_MODULAR_P (gnu_result_type))))\n     {\n       /* In this case remove padding only if the inner object is of\n \t self-referential size: in that case it must be an object of\n@@ -4521,7 +4520,7 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t  return GS_ALL_DONE;\n \t}\n       return GS_UNHANDLED;\n-\t \n+\n     case COMPONENT_REF:\n       /* We have a kludge here.  If the FIELD_DECL is from a fat pointer and is\n \t from an early dummy type, replace it with the proper FIELD_DECL.  */\n@@ -5062,7 +5061,7 @@ emit_index_check (tree gnu_array_object,\n \f\n /* GNU_COND contains the condition corresponding to an access, discriminant or\n    range check of value GNU_EXPR.  Build a COND_EXPR that returns GNU_EXPR if\n-   GNU_COND is false and raises a CONSTRAINT_ERROR if GNU_COND is true. \n+   GNU_COND is false and raises a CONSTRAINT_ERROR if GNU_COND is true.\n    REASON is the code that says why the exception was raised.  */\n \n static tree"}, {"sha": "08c08195b88c2a860f5386c94ea9681583505dbf", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "patch": "@@ -2092,7 +2092,7 @@ build_template (tree template_type, tree array_type, tree expr)\n \n   if (TREE_CODE (array_type) == RECORD_TYPE\n       && (TYPE_IS_PADDING_P (array_type)\n-\t  || TYPE_LEFT_JUSTIFIED_MODULAR_P (array_type)))\n+\t  || TYPE_JUSTIFIED_MODULAR_P (array_type)))\n     array_type = TREE_TYPE (TYPE_FIELDS (array_type));\n \n   if (TREE_CODE (array_type) == ARRAY_TYPE\n@@ -2801,10 +2801,10 @@ convert (tree type, tree expr)\n \t\t\t\t\t\t      expr)),\n \t\t\t\t\tTYPE_MIN_VALUE (etype))));\n \n-  /* If the input is a left-justified modular type, we need to extract\n+  /* If the input is a justified modular type, we need to extract\n      the actual object before converting it to any other type with the\n      exception of an unconstrained array.  */\n-  if (ecode == RECORD_TYPE && TYPE_LEFT_JUSTIFIED_MODULAR_P (etype)\n+  if (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype)\n       && code != UNCONSTRAINED_ARRAY_TYPE)\n     return convert (type, build_component_ref (expr, NULL_TREE,\n \t\t\t\t\t       TYPE_FIELDS (etype), false));\n@@ -2979,7 +2979,7 @@ convert (tree type, tree expr)\n       return fold (convert_to_real (type, expr));\n \n     case RECORD_TYPE:\n-      if (TYPE_LEFT_JUSTIFIED_MODULAR_P (type) && !AGGREGATE_TYPE_P (etype))\n+      if (TYPE_JUSTIFIED_MODULAR_P (type) && !AGGREGATE_TYPE_P (etype))\n \treturn\n \t  gnat_build_constructor\n \t    (type, tree_cons (TYPE_FIELDS (type),\n@@ -3002,7 +3002,7 @@ convert (tree type, tree expr)\n \t  if (TREE_TYPE (tem) == etype)\n \t    return build1 (CONVERT_EXPR, type, expr);\n \t  else if (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n-\t\t   && (TYPE_LEFT_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n+\t\t   && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n \t\t       || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n \t\t   && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype)\n \t    return build1 (CONVERT_EXPR, type,\n@@ -3015,12 +3015,12 @@ convert (tree type, tree expr)\n       /* If EXPR is a constrained array, take its address, convert it to a\n \t fat pointer, and then dereference it.  Likewise if EXPR is a\n \t record containing both a template and a constrained array.\n-\t Note that a record representing a left justified modular type\n+\t Note that a record representing a justified modular type\n \t always represents a packed constrained array.  */\n       if (ecode == ARRAY_TYPE\n \t  || (ecode == INTEGER_TYPE && TYPE_HAS_ACTUAL_BOUNDS_P (etype))\n \t  || (ecode == RECORD_TYPE && TYPE_CONTAINS_TEMPLATE_P (etype))\n-\t  || (ecode == RECORD_TYPE && TYPE_LEFT_JUSTIFIED_MODULAR_P (etype)))\n+\t  || (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype)))\n \treturn\n \t  build_unary_op\n \t    (INDIRECT_REF, NULL_TREE,\n@@ -3048,7 +3048,7 @@ convert (tree type, tree expr)\n }\n \f\n /* Remove all conversions that are done in EXP.  This includes converting\n-   from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n+   from a padded type or to a justified modular type.  If TRUE_ADDRESS\n    is true, always return the address of the containing object even if\n    the address is not bit-aligned.  */\n \n@@ -3060,7 +3060,7 @@ remove_conversions (tree exp, bool true_address)\n     case CONSTRUCTOR:\n       if (true_address\n \t  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (TREE_TYPE (exp)))\n+\t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (exp)))\n \treturn remove_conversions (TREE_VALUE (CONSTRUCTOR_ELTS (exp)), true);\n       break;\n \n@@ -3156,13 +3156,13 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t      && TYPE_VAX_FLOATING_POINT_P (type)))\n \t|| (POINTER_TYPE_P (type) && ! TYPE_THIN_POINTER_P (type))\n \t|| (TREE_CODE (type) == RECORD_TYPE\n-\t    && TYPE_LEFT_JUSTIFIED_MODULAR_P (type)))\n+\t    && TYPE_JUSTIFIED_MODULAR_P (type)))\n        && ((INTEGRAL_TYPE_P (etype)\n \t    && !(TREE_CODE (etype) == INTEGER_TYPE\n \t\t && TYPE_VAX_FLOATING_POINT_P (etype)))\n \t   || (POINTER_TYPE_P (etype) && !TYPE_THIN_POINTER_P (etype))\n \t   || (TREE_CODE (etype) == RECORD_TYPE\n-\t       && TYPE_LEFT_JUSTIFIED_MODULAR_P (etype))))\n+\t       && TYPE_JUSTIFIED_MODULAR_P (etype))))\n       || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n     {\n       tree rtype = type;"}, {"sha": "9015dca2ce685fb9ffdafb1e5000ecadce569b3e", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910d20fcb8c5fa83c64c1540cca945cc0c31d77c/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=910d20fcb8c5fa83c64c1540cca945cc0c31d77c", "patch": "@@ -112,7 +112,7 @@ tree\n get_base_type (tree type)\n {\n   if (TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_LEFT_JUSTIFIED_MODULAR_P (type))\n+      && TYPE_JUSTIFIED_MODULAR_P (type))\n     type = TREE_TYPE (TYPE_FIELDS (type));\n \n   while (TREE_TYPE (type)\n@@ -601,7 +601,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n   if (operation_type\n       && TREE_CODE (operation_type) == RECORD_TYPE\n-      && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n+      && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n     operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n \n   if (operation_type\n@@ -631,9 +631,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t      || POINTER_TYPE_P (TREE_TYPE\n \t\t\t\t\t (TREE_OPERAND (left_operand, 0)))))\n \t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n-\t\t       /* Don't remove conversions to left-justified modular\n+\t\t       /* Don't remove conversions to justified modular\n \t\t\t  types. */\n-\t\t       && !TYPE_LEFT_JUSTIFIED_MODULAR_P (left_type))\n+\t\t       && !TYPE_JUSTIFIED_MODULAR_P (left_type))\n \t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n \t\t     && ((TREE_CODE (TREE_TYPE\n \t\t\t\t     (TREE_OPERAND (left_operand, 0)))\n@@ -661,13 +661,13 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t type, which we must not remove.  */\n       while (TREE_CODE (right_operand) == VIEW_CONVERT_EXPR\n \t     && ((TREE_CODE (right_type) == RECORD_TYPE\n-\t\t  && !TYPE_LEFT_JUSTIFIED_MODULAR_P (right_type)\n+\t\t  && !TYPE_JUSTIFIED_MODULAR_P (right_type)\n \t\t  && !TYPE_ALIGN_OK (right_type)\n \t\t  && !TYPE_IS_FAT_POINTER_P (right_type))\n \t\t || TREE_CODE (right_type) == ARRAY_TYPE)\n \t     && (((TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n \t\t   == RECORD_TYPE)\n-\t\t  && !(TYPE_LEFT_JUSTIFIED_MODULAR_P\n+\t\t  && !(TYPE_JUSTIFIED_MODULAR_P\n \t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n \t\t  && !(TYPE_ALIGN_OK\n \t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n@@ -803,10 +803,10 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t\t       TREE_OPERAND (right_operand, 0)),\n \t\t       integer_zero_node);\n \n-      /* If either object is a left-justified modular types, get the\n+      /* If either object is a justified modular types, get the\n \t fields from within.  */\n       if (TREE_CODE (left_type) == RECORD_TYPE\n-\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (left_type))\n+\t  && TYPE_JUSTIFIED_MODULAR_P (left_type))\n \t{\n \t  left_operand = convert (TREE_TYPE (TYPE_FIELDS (left_type)),\n \t\t\t\t  left_operand);\n@@ -815,7 +815,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t}\n \n       if (TREE_CODE (right_type) == RECORD_TYPE\n-\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (right_type))\n+\t  && TYPE_JUSTIFIED_MODULAR_P (right_type))\n \t{\n \t  right_operand = convert (TREE_TYPE (TYPE_FIELDS (right_type)),\n \t\t\t\t  right_operand);\n@@ -1039,7 +1039,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n   if (operation_type\n       && TREE_CODE (operation_type) == RECORD_TYPE\n-      && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n+      && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n     operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n \n   if (operation_type"}]}