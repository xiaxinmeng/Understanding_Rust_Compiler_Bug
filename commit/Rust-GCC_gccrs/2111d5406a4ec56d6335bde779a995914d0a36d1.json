{"sha": "2111d5406a4ec56d6335bde779a995914d0a36d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjExMWQ1NDA2YTRlYzU2ZDYzMzViZGU3NzlhOTk1OTE0ZDBhMzZkMQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-04-09T12:37:21Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-04-09T12:37:21Z"}, "message": "sra: Fix sra_modify_expr handling of partial writes (PR 94482)\n\nwhen sra_modify_expr is invoked on an expression that modifies only\npart of the underlying replacement, such as a BIT_FIELD_REF on a LHS\nof an assignment and the SRA replacement's type is not compatible with\nwhat is being replaced (0th operand of the B_F_R in the above\nexample), it does not work properly, basically throwing away the partd\nof the expr that should have stayed intact.\n\nThis is fixed in two ways.  For BIT_FIELD_REFs, which operate on the\nbinary image of the replacement (and so in a way serve as a\nVIEW_CONVERT_EXPR) we just do not bother with convertsing.  For\nREALPART_EXPRs and IMAGPART_EXPRs, if the replacement is not a\nregister, we insert a VIEW_CONVERT_EXPR under\nthe complex partial access expression, which is always OK, for loads\nfrom registers we take the extra step of converting it to a temporary.\n\nThis revealed a bug in fwprop which is fixed with the hunk from Richi.\n\nThe testcase for handling REALPART_EXPR and IMAGPART_EXPR is a bit\nfragile because SRA prefers complex and vector types over anything\nelse (and in between the two it decides based on TYPE_UID which in my\ntesting today always preferred complex types) and so I only run it at\n-O1 (which is the only level where the the test fails for me).\n\nBootstrapped and tested on x86_64-linux, i686-linux and aarch64-linux.\n\n2020-04-09  Martin Jambor  <mjambor@suse.cz>\n\t    Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/94482\n\t* tree-sra.c (create_access_replacement): Dump new replacement with\n\tTDF_UID.\n\t(sra_modify_expr): Fix handling of cases when the original EXPR writes\n\tto only part of the replacement.\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Properly verify\n\tthe first operand of combinations into REAL/IMAGPART_EXPR and\n\tBIT_FIELD_REF.\n\n\ttestsuite/\n\t* gcc.dg/torture/pr94482.c: New test.\n\t* gcc.dg/tree-ssa/pr94482-2.c: Likewise.", "tree": {"sha": "d3e35dc3a2eb4373abb505764ee5d9a5261a958c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3e35dc3a2eb4373abb505764ee5d9a5261a958c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2111d5406a4ec56d6335bde779a995914d0a36d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2111d5406a4ec56d6335bde779a995914d0a36d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2111d5406a4ec56d6335bde779a995914d0a36d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2111d5406a4ec56d6335bde779a995914d0a36d1/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "830c572428758f134bd001e699a08e622e2452c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830c572428758f134bd001e699a08e622e2452c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830c572428758f134bd001e699a08e622e2452c3"}], "stats": {"total": 141, "additions": 135, "deletions": 6}, "files": [{"sha": "368dfd6094e08b0a58cbf3888a9375bbc2bba755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2111d5406a4ec56d6335bde779a995914d0a36d1", "patch": "@@ -1,3 +1,15 @@\n+2020-04-09  Martin Jambor  <mjambor@suse.cz>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/94482\n+\t* tree-sra.c (create_access_replacement): Dump new replacement with\n+\tTDF_UID.\n+\t(sra_modify_expr): Fix handling of cases when the original EXPR writes\n+\tto only part of the replacement.\n+\t* tree-ssa-forwprop.c (pass_forwprop::execute): Properly verify\n+\tthe first operand of combinations into REAL/IMAGPART_EXPR and\n+\tBIT_FIELD_REF.\n+\n 2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* doc/sourcebuild.texi (check-function-bodies): Treat the third"}, {"sha": "e01fdb0fe2c7f0102b72f9c7462f588e4765f30c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2111d5406a4ec56d6335bde779a995914d0a36d1", "patch": "@@ -1,3 +1,9 @@\n+2020-04-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/94482\n+\t* gcc.dg/torture/pr94482.c: New test.\n+\t* gcc.dg/tree-ssa/pr94482-2.c: Likewise.\n+\n 2020-04-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93790"}, {"sha": "d9ccaf39049918902238c49b4f1ad0c5096c898a", "filename": "gcc/testsuite/gcc.dg/torture/pr94482.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr94482.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr94482.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr94482.c?ref=2111d5406a4ec56d6335bde779a995914d0a36d1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-options \"-msse\" { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-require-effective-target sse_runtime { target { i?86-*-* x86_64-*-* } } } */\n+\n+typedef unsigned V __attribute__ ((__vector_size__ (16)));\n+union U\n+{\n+  V j;\n+  unsigned long long i __attribute__ ((__vector_size__ (16)));\n+};\n+\n+static inline __attribute__((always_inline)) V\n+foo (unsigned long long a)\n+{\n+  union U z = { .j = (V) {} };\n+  for (unsigned long i = 0; i < 1; i++)\n+    z.i[i] = a;\n+  return z.j;\n+}\n+\n+static inline __attribute__((always_inline)) V\n+bar (V a, unsigned long long i, int q)\n+{\n+  union U z = { .j = a };\n+  z.i[q] = i;\n+  return z.j;\n+}\n+\n+int\n+main ()\n+{\n+  union U z = { .j = bar (foo (1729), 2, 1) };\n+  if (z.i[0] != 1729)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "fcac9d5e43987f8bfe2fa2b815e6cfa5415b7162", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr94482-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr94482-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr94482-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr94482-2.c?ref=2111d5406a4ec56d6335bde779a995914d0a36d1", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O1\" } */\n+\n+typedef unsigned long V __attribute__ ((__vector_size__ (8)));\n+typedef _Complex int Ci;\n+typedef _Complex float Cf;\n+\n+union U\n+{\n+  Ci ci;\n+  Cf cf;\n+};\n+\n+volatile Ci vgi;\n+\n+Cf foo (Cf c)\n+{\n+  __real c = 0x1ffp10;\n+  return c;\n+}\n+\n+Ci ioo (Ci c)\n+{\n+  __real c = 50;\n+  return c;\n+}\n+\n+\n+int main (int argc, char *argv[])\n+{\n+  union U u;\n+\n+  __real u.ci = 500;\n+  __imag u.ci = 1000;\n+  vgi = u.ci;\n+\n+  u.ci = ioo (u.ci);\n+  __imag u.ci = 100;\n+\n+  if (__real u.ci != 50 || __imag u.ci != 100)\n+    __builtin_abort();\n+\n+  u.cf = foo (u.cf);\n+  __imag u.cf = 0x1p3;\n+\n+  if (__real u.cf != 0x1ffp10 || __imag u.cf != 0x1p3)\n+    __builtin_abort();\n+\n+  return 0;\n+}"}, {"sha": "84c113c403cc5d42afbc018773f61ea1d9a4ee55", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=2111d5406a4ec56d6335bde779a995914d0a36d1", "patch": "@@ -2257,7 +2257,7 @@ create_access_replacement (struct access *access, tree reg_type = NULL_TREE)\n \t  print_generic_expr (dump_file, access->base);\n \t  fprintf (dump_file, \" offset: %u, size: %u: \",\n \t\t   (unsigned) access->offset, (unsigned) access->size);\n-\t  print_generic_expr (dump_file, repl);\n+\t  print_generic_expr (dump_file, repl, TDF_UID);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n@@ -3698,6 +3698,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n   location_t loc;\n   struct access *access;\n   tree type, bfr, orig_expr;\n+  bool partial_cplx_access = false;\n \n   if (TREE_CODE (*expr) == BIT_FIELD_REF)\n     {\n@@ -3708,7 +3709,10 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n     bfr = NULL_TREE;\n \n   if (TREE_CODE (*expr) == REALPART_EXPR || TREE_CODE (*expr) == IMAGPART_EXPR)\n-    expr = &TREE_OPERAND (*expr, 0);\n+    {\n+      expr = &TREE_OPERAND (*expr, 0);\n+      partial_cplx_access = true;\n+    }\n   access = get_access_for_expr (*expr);\n   if (!access)\n     return false;\n@@ -3736,13 +3740,32 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n          be accessed as a different type too, potentially creating a need for\n          type conversion (see PR42196) and when scalarized unions are involved\n          in assembler statements (see PR42398).  */\n-      if (!useless_type_conversion_p (type, access->type))\n+      if (!bfr && !useless_type_conversion_p (type, access->type))\n \t{\n \t  tree ref;\n \n \t  ref = build_ref_for_model (loc, orig_expr, 0, access, gsi, false);\n \n-\t  if (write)\n+\t  if (partial_cplx_access)\n+\t    {\n+\t    /* VIEW_CONVERT_EXPRs in partial complex access are always fine in\n+\t       the case of a write because in such case the replacement cannot\n+\t       be a gimple register.  In the case of a load, we have to\n+\t       differentiate in between a register an non-register\n+\t       replacement.  */\n+\t      tree t = build1 (VIEW_CONVERT_EXPR, type, repl);\n+\t      gcc_checking_assert (!write || access->grp_partial_lhs);\n+\t      if (!access->grp_partial_lhs)\n+\t\t{\n+\t\t  tree tmp = make_ssa_name (type);\n+\t\t  gassign *stmt = gimple_build_assign (tmp, t);\n+\t\t  /* This is always a read. */\n+\t\t  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\t\t  t = tmp;\n+\t\t}\n+\t      *expr = t;\n+\t    }\n+\t  else if (write)\n \t    {\n \t      gassign *stmt;\n "}, {"sha": "3d8acf7eb0355601cdaaa81bd8760eab585cf82d", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2111d5406a4ec56d6335bde779a995914d0a36d1/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2111d5406a4ec56d6335bde779a995914d0a36d1", "patch": "@@ -2815,7 +2815,8 @@ pass_forwprop::execute (function *fun)\n \t\t    continue;\n \t\t  if (!is_gimple_assign (use_stmt)\n \t\t      || (gimple_assign_rhs_code (use_stmt) != REALPART_EXPR\n-\t\t\t  && gimple_assign_rhs_code (use_stmt) != IMAGPART_EXPR))\n+\t\t\t  && gimple_assign_rhs_code (use_stmt) != IMAGPART_EXPR)\n+\t\t      || TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) != lhs)\n \t\t    {\n \t\t      rewrite = false;\n \t\t      break;\n@@ -2877,7 +2878,8 @@ pass_forwprop::execute (function *fun)\n \t\t  if (is_gimple_debug (use_stmt))\n \t\t    continue;\n \t\t  if (!is_gimple_assign (use_stmt)\n-\t\t      || gimple_assign_rhs_code (use_stmt) != BIT_FIELD_REF)\n+\t\t      || gimple_assign_rhs_code (use_stmt) != BIT_FIELD_REF\n+\t\t      || TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) != lhs)\n \t\t    {\n \t\t      rewrite = false;\n \t\t      break;"}]}