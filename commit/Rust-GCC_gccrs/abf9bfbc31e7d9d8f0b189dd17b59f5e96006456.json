{"sha": "abf9bfbc31e7d9d8f0b189dd17b59f5e96006456", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJmOWJmYmMzMWU3ZDlkOGYwYjE4OWRkMTdiNTlmNWU5NjAwNjQ1Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-10T08:20:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-10T08:20:07Z"}, "message": "tree-vect-slp.c (vect_get_and_check_slp_defs): Remove broken code swapping operands.\n\n2013-04-10  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove\n\tbroken code swapping operands.\n\t(vect_build_slp_tree): Do not compute load permutations here.\n\t(vect_analyze_slp_instance): Compute load permutations here,\n\tafter building the SLP tree.\n\nFrom-SVN: r197665", "tree": {"sha": "45f7594bb9107502c7974afb11b46efc56000891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45f7594bb9107502c7974afb11b46efc56000891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456/comments", "author": null, "committer": null, "parents": [{"sha": "f408477e6d42fa6459e4372dff14da5aa9294a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f408477e6d42fa6459e4372dff14da5aa9294a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f408477e6d42fa6459e4372dff14da5aa9294a5d"}], "stats": {"total": 162, "additions": 52, "deletions": 110}, "files": [{"sha": "5878fe94ffd417ce4b9b6be88a76dc3b902a06bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abf9bfbc31e7d9d8f0b189dd17b59f5e96006456", "patch": "@@ -1,12 +1,20 @@\n+2013-04-10  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove\n+\tbroken code swapping operands.\n+\t(vect_build_slp_tree): Do not compute load permutations here.\n+\t(vect_analyze_slp_instance): Compute load permutations here,\n+\tafter building the SLP tree.\n+\n 2013-04-09  Christian Bruel  <christian.bruel@st.com>\n \n \t* config/sh/sh.md (barrier_align): Use next/prev_active_insn instead\n \tof next/prev_real_insn.\n \n 2013-04-09  Jan Hubicka  <jh@suse.cz>\n \n-\t* ipa.c (cgraph_externally_visible_p, varpool_externally_visible_p): Drop\n-\taliased parameter.\n+\t* ipa.c (cgraph_externally_visible_p, varpool_externally_visible_p):\n+\tDrop aliased parameter.\n \t(function_and_variable_visibility): Do not handle alias pairs.\n \t* cgraph.c (varpool_externally_visible_p): Update prototype.\n \t* varpool.c (varpool_add_new_variable): Update."}, {"sha": "a06eeb73073a9be29470f53f40808a2c8525a6f5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 42, "deletions": 108, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf9bfbc31e7d9d8f0b189dd17b59f5e96006456/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=abf9bfbc31e7d9d8f0b189dd17b59f5e96006456", "patch": "@@ -204,15 +204,12 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n-  tree def, def_op0 = NULL_TREE;\n+  tree def;\n   gimple def_stmt;\n   enum vect_def_type dt = vect_uninitialized_def;\n-  enum vect_def_type dt_op0 = vect_uninitialized_def;\n   struct loop *loop = NULL;\n-  enum tree_code rhs_code;\n-  bool different_types = false;\n   bool pattern = false;\n-  slp_oprnd_info oprnd_info, oprnd0_info, oprnd1_info;\n+  slp_oprnd_info oprnd_info;\n   int op_idx = 1;\n   tree compare_rhs = NULL_TREE;\n \n@@ -334,12 +331,6 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               oprnd_info->first_def_type = NULL_TREE;\n               oprnd_info->first_const_oprnd = oprnd;\n             }\n-\n-\t  if (i == 0)\n-\t    {\n-\t      def_op0 = def;\n-\t      dt_op0 = dt;\n-\t    }\n \t}\n       else\n \t{\n@@ -357,57 +348,13 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t\t   TREE_TYPE (def))))\n \t       || (!def\n \t\t   && !types_compatible_p (TREE_TYPE (oprnd_info->first_const_oprnd),\n-\t\t\t\t\t   TREE_TYPE (oprnd)))\n-\t       || different_types)\n+\t\t\t\t\t   TREE_TYPE (oprnd))))\n \t    {\n-\t      if (number_of_oprnds != 2)\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"Build SLP failed: different types \");\n-\n-\t\t  return false;\n-                }\n-\n-\t      /* Try to swap operands in case of binary operation.  */\n-              if (i == 0)\n-                different_types = true;\n-              else\n-\t\t{\n-\t\t  oprnd0_info = (*oprnds_info)[0];\n-\t\t  if (is_gimple_assign (stmt)\n-\t\t      && (rhs_code = gimple_assign_rhs_code (stmt))\n- \t\t      && TREE_CODE_CLASS (rhs_code) == tcc_binary\n-\t\t      && commutative_tree_code (rhs_code)\n-\t\t      && oprnd0_info->first_dt == dt\n-\t\t      && oprnd_info->first_dt == dt_op0\n-\t\t      && def_op0 && def\n-\t\t      && !(oprnd0_info->first_def_type\n-\t\t\t   && !types_compatible_p (oprnd0_info->first_def_type,\n-\t\t\t                           TREE_TYPE (def)))\n-                      && !(oprnd_info->first_def_type\n-                           && !types_compatible_p (oprnd_info->first_def_type,\n-                                                   TREE_TYPE (def_op0))))\n-                    {\n-                      if (dump_enabled_p ())\n-\t                {\n-\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t   \"Swapping operands of \");\n- \t\t          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t\t\t}\n-\n- \t\t      swap_tree_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n- \t                                  gimple_assign_rhs2_ptr (stmt));\n-\t\t    }\n-                  else\n-                    {\n-         \t      if (dump_enabled_p ())\n-\t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t\t \"Build SLP failed: different types \");\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: different types \");\n \n-\t\t      return false;\n-\t\t    }\n-\t\t}\n+\t      return false;\n \t    }\n \t}\n \n@@ -420,18 +367,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  break;\n \n \tcase vect_internal_def:\n-          if (different_types)\n-            {\n-\t      oprnd0_info = (*oprnds_info)[0];\n-\t      oprnd1_info = (*oprnds_info)[0];\n-              if (i == 0)\n-                oprnd1_info->def_stmts.quick_push (def_stmt);\n-              else\n-                oprnd0_info->def_stmts.quick_push (def_stmt);\n-            }\n-\t  else\n- \t    oprnd_info->def_stmts.quick_push (def_stmt);\n-\n+\t  oprnd_info->def_stmts.quick_push (def_stmt);\n \t  break;\n \n \tdefault:\n@@ -460,9 +396,8 @@ static bool\n vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                      slp_tree *node, unsigned int group_size,\n                      unsigned int *max_nunits,\n-                     vec<int> *load_permutation,\n                      vec<slp_tree> *loads,\n-                     unsigned int vectorization_factor, bool *loads_permuted)\n+                     unsigned int vectorization_factor)\n {\n   unsigned int i;\n   vec<gimple> stmts = SLP_TREE_SCALAR_STMTS (*node);\n@@ -478,8 +413,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   enum machine_mode vec_mode;\n   struct data_reference *first_dr;\n   HOST_WIDE_INT dummy;\n-  bool permutation = false;\n-  unsigned int load_place;\n   gimple first_load = NULL, prev_first_load = NULL, old_first_load = NULL;\n   vec<slp_oprnd_info> oprnds_info;\n   unsigned int nops;\n@@ -839,16 +772,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                     }\n                 }\n \n-              /* Store the place of this load in the interleaving chain.  In\n-                 case that permutation is needed we later decide if a specific\n-                 permutation is supported.  */\n-              load_place = vect_get_place_in_interleaving_chain (stmt,\n-                                                                 first_load);\n-              if (load_place != i)\n-                permutation = true;\n-\n-              load_permutation->safe_push (load_place);\n-\n               /* We stop the tree when we reach a group of loads.  */\n               stop_recursion = true;\n              continue;\n@@ -925,17 +848,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   if (stop_recursion)\n     {\n       loads->safe_push (*node);\n-      if (permutation)\n-\t*loads_permuted = true;\n-      else\n-        {\n-          /* We don't check here complex numbers chains, so we set\n-             LOADS_PERMUTED for further check in\n-             vect_supported_load_permutation_p.  */\n-          if (rhs_code == REALPART_EXPR || rhs_code == IMAGPART_EXPR)\n-            *loads_permuted = true;\n-        }\n-\n       vect_free_oprnd_info (oprnds_info);\n       return true;\n     }\n@@ -951,8 +863,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       child = vect_create_new_slp_node (oprnd_info->def_stmts);\n       if (!child\n           || !vect_build_slp_tree (loop_vinfo, bb_vinfo, &child, group_size,\n-\t\t\t\t   max_nunits, load_permutation, loads,\n-\t\t\t\t   vectorization_factor, loads_permuted))\n+\t\t\t\t   max_nunits, loads,\n+\t\t\t\t   vectorization_factor))\n         {\n \t  if (child)\n \t    oprnd_info->def_stmts = vNULL;\n@@ -1604,10 +1516,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   unsigned int vectorization_factor = 0;\n   int i;\n   unsigned int max_nunits = 0;\n-  vec<int> load_permutation;\n   vec<slp_tree> loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n-  bool loads_permuted = false;\n   vec<gimple> scalar_stmts;\n \n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n@@ -1689,13 +1599,12 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n   node = vect_create_new_slp_node (scalar_stmts);\n \n-  load_permutation.create (group_size * group_size);\n   loads.create (group_size);\n \n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n-\t\t\t   &max_nunits, &load_permutation, &loads,\n-\t\t\t   vectorization_factor, &loads_permuted))\n+\t\t\t   &max_nunits, &loads,\n+\t\t\t   vectorization_factor))\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n@@ -1709,7 +1618,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t     \"Build SLP failed: unrolling required in basic\"\n \t\t\t     \" block SLP\");\n \t  vect_free_slp_tree (node);\n-\t  load_permutation.release ();\n \t  loads.release ();\n           return false;\n         }\n@@ -1722,10 +1630,37 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_BODY_COST_VEC (new_instance) = vNULL;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n       SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n-      SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n+      SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = vNULL;\n+\n+      /* Compute the load permutation.  */\n+      slp_tree load_node;\n+      bool loads_permuted = false;\n+      vec<int> load_permutation;\n+      load_permutation.create (group_size * group_size);\n+      FOR_EACH_VEC_ELT (loads, i, load_node)\n+\t{\n+\t  int j;\n+\t  gimple load;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n+\t    {\n+\t      int load_place;\n+\t      load_place = vect_get_place_in_interleaving_chain\n+\t\t(load, GROUP_FIRST_ELEMENT (vinfo_for_stmt (load)));\n+\t      if (load_place != j\n+\t\t  /* ???  We allow loads from different groups to\n+\t\t     get to here for a special case handled in\n+\t\t     the permutation code.  Make sure we get to that.  */\n+\t\t  || (GROUP_FIRST_ELEMENT\n+\t\t        (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]))\n+\t\t      != GROUP_FIRST_ELEMENT (vinfo_for_stmt (load))))\n+\t\tloads_permuted = true;\n+\t      load_permutation.safe_push (load_place);\n+\t    }\n+\t}\n \n       if (loads_permuted)\n         {\n+\t  SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n           if (!vect_supported_load_permutation_p (new_instance, group_size,\n                                                   load_permutation))\n             {\n@@ -1745,7 +1680,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n              = vect_find_first_load_in_slp_instance (new_instance);\n         }\n       else\n-        SLP_INSTANCE_LOAD_PERMUTATION (new_instance).release ();\n+        load_permutation.release ();\n \n       /* Compute the costs of this SLP instance.  */\n       vect_analyze_slp_cost (loop_vinfo, bb_vinfo,\n@@ -1765,7 +1700,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Failed to SLP.  */\n   /* Free the allocated memory.  */\n   vect_free_slp_tree (node);\n-  load_permutation.release ();\n   loads.release ();\n \n   return false;"}]}