{"sha": "9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI2NmViYjE0NjBkYWFlMmIwNDZkNjJkNTBkN2MzYzgzNWJhMWM0Mw==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-02-03T14:45:44Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-02-03T14:45:44Z"}, "message": "backport: re PR target/12476 (ARM/THUMB thunk calls broken)\n\n\tMerge from csl-arm-branch.\n\n\t2004-01-30  Paul Brook  <paul@codesourcery.com>\n\n\t* aof.h (REGISTER_NAMES): Add vfp reg names\n\t(ADDITIONAL_REGISTER_NAMES): Ditto.\n\t* aout.h (REGISTER_NAMES): Ditto.\n\t(ADDITIONAL_REGISTER_NAMES): Ditto.\n\t* arm-protos.h: Update/Add Prototypes.\n\t* arm.c (init_fp_table): Rename from init_fpa_table. Update users.\n\tOnly allow 0.0 for VFP.\n\t(fp_consts_inited): Rename from fpa_consts_inited.  Update users.\n\t(values_fp): Rename from values_fpa.  Update Users.\n\t(arm_const_double_rtx): Rename from const_double_rtx_ok_for_fpa.\n\tUpdate users.  Only check valid constants for this hardware.\n\t(arm_float_rhs_operand): Rename from fpa_rhs_operand.  Update Users.\n\tOnly allow consts for FPA.\n\t(arm_float_add_operand): Rename from fpa_add_operand.  Update users.\n\tOnly allow consts for FPA.\n\t(use_return_insn): Check for saved VFP regs.\n\t(arm_legitimate_address_p): Handle VFP DFmode addressing.\n\t(arm_legitimize_address): Ditto.\n\t(arm_general_register_operand): New function.\n\t(vfp_mem_operand): New function.\n\t(vfp_compare_operand): New function.\n\t(vfp_secondary_reload_class): New function.\n\t(arm_float_compare_operand): New function.\n\t(vfp_print_multi): New function.\n\t(vfp_output_fstmx): New function.\n\t(vfp_emit_fstm): New function.\n\t(arm_output_epilogue): Output VPF reg restore code.\n\t(arm_expand_prologue): Output VFP reg save code.\n\t(arm_print_operand): Add 'P'.\n\t(arm_hard_regno_mode_ok): Return modes for VFP regs.\n\t(arm_regno_class): Return classes for VFP regs.\n\t(arm_compute_initial_elimination_offset): Include space for VFP regs.\n\t(arm_get_frame_size): Ditto.\n\t* arm.h (FIXED_REGISTERS): Add VFP regs.\n\t(CALL_USED_REGISTERS): Ditto.\n\t(CONDITIONAL_REGISTER_USAGE): Enable VFP regs.\n\t(FIRST_VFP_REGNUM): Define.\n\t(LAST_VFP_REGNUM): Define.\n\t(IS_VFP_REGNUM): Define.\n\t(FIRST_PSEUDO_REGISTER): Include VFP regs.\n\t(HARD_REGNO_NREGS): Handle VFP regs.\n\t(REG_ALLOC_ORDER): Add VFP regs.\n\t(enum reg_class): Add VFP_REGS.\n\t(REG_CLASS_NAMES): Ditto.\n\t(REG_CLASS_CONTENTS): Ditto.\n\t(CANNOT_CHANGE_MODE_CLASS) Handle VFP Regs.\n\t(REG_CLASS_FROM_LETTER): Add 'w'.\n\t(EXTRA_CONSTRAINT_ARM): Add 'U'.\n\t(EXTRA_MEMORY_CONSTRAINT): Define.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): Handle VFP regs.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Ditto.\n\t(REGISTER_MOVE_COST): Ditto.\n\t(PREDICATE_CODES): Add arm_general_register_operand,\n\tarm_float_compare_operand and vfp_compare_operand.\n\t* arm.md (various): Rename as above.\n\t(divsf3): Enable when TARGET_VFP.\n\t(divdf3): Ditto.\n\t(movdfcc): Ditto.\n\t(sqrtsf2): Ditto.\n\t(sqrtdf2): Ditto.\n\t(arm_movdi): Disable when TARGET_VFP.\n\t(arm_movsi_insn): Ditto.\n\t(movsi): Only split with general regs.\n\t(cmpsf): Use arm_float_compare_operand.\n\t(push_fp_multi): Restrict to TARGET_FPA.\n\t(vfp.md): Include.\n\t* vfp.md: New file.\n\t* fpa.md (various): Rename as above.\n\t* doc/md.texi: Document ARM w and U constraints.\n\n\t2004-01-15  Paul Brook  <paul@codesourcery.com>\n\n\t* config.gcc: Add with_fpu.  Allow with-float=softfp.\n\t* config/arm/arm.c (arm_override_options): Rename *-s to *s.\n\tBreak out of loop when we find a float-abi.  Fix typo.\n\t* config/arm/arm.h (OPTION_DEFAULT_SPECS): Add \"fpu\".\n\tSet -mfloat-abi=.\n\t* doc/install.texi: Document --with-fpu.\n\n\t2003-01-14  Paul Brook  <paul@codesourcery.com>\n\n\t* config.gcc (with_arch): Add armv6.\n\t* config/arm/arm.h: Rename TARGET_CPU_*_s to TARGET_CPU_*s.\n\t* config/arm/arm.c (arm_overrride_options): Ditto.\n\n\t2004-01-08  Richard Earnshaw  <rearnsha@arm.com>\n\n\t* arm.c (FL_ARCH3M): Renamed from FL_FAST_MULT.\n\t(FL_ARCH6): Renamed from FL_ARCH6J.\n\t(arm_arch3m): Renamed from arm_fast_multiply.\n\t(arm_arch6): Renamed from arm_arch6j.\n\t* arm.h: Update all uses of above.\n\t* arm-cores.def: Likewise.\n\t* arm.md: Likewise.\n\n\t* arm.h (CPP_CPU_ARCH_SPEC): Emit __ARM_ARCH_6J__ define for armV6j,\n\tnot arm6j.  Add entry for arch armv6.\n\n\t2004-01-07  Richard Earnshaw  <rearnsha@arm.com>\n\n\t* arm.c (arm_emit_extendsi): Delete.\n\t* arm-protos.h (arm_emit_extendsi): Delete.\n\t* arm.md (zero_extendhisi2): Also handle zero-extension of\n\tnon-subregs.\n\t(zero_extendqisi2, extendhisi2, extendqisi2): Likewise.\n\t(thumb_zero_extendhisi2): Only match if not v6.\n\t(arm_zero_extendhisi2, thumb_zero_extendqisi2, arm_zero_extendqisi2)\n\t(thumb_extendhisi2, arm_extendhisi2, arm_extendqisi)\n\t(thumb_extendqisi2): Likewise.\n\t(thumb_zero_extendhisi2_v6, arm_zero_extendhisi2_v6): New patterns.\n\t(thumb_zero_extendqisi2_v6, arm_zero_extendqisi2_v6): New patterns.\n\t(thumb_extendhisi2_insn_v6, arm_extendhisi2_v6): New patterns.\n\t(thumb_extendqisi2_v6, arm_extendqisi_v6): New patterns.\n\t(arm_zero_extendhisi2_reg, arm_zero_extendqisi2_reg): Delete.\n\t(arm_extendhisi2_reg, arm_extendqisi2_reg): Delete.\n\t(arm_zero_extendhisi2addsi): Remove subreg.  Add attributes.\n\t(arm_zero_extendqisi2addsi, arm_extendhisi2addsi): Likewise.\n\t(arm_extendqisi2addsi): Likewise.\n\n\t2003-12-31  Mark Mitchell  <mark@codesourcery.com>\n\n\tRevert this change:\n\t* config/arm/arm.h (THUMB_LEGTITIMIZE_RELOAD_ADDRESS): Reload REG\n\t+ REG addressing modes.\n\n\t* config/arm/arm.h (THUMB_LEGTITIMIZE_RELOAD_ADDRESS): Reload REG\n\t+ REG addressing modes.\n\n\t2003-12-30  Mark Mitchell  <mark@codesourcery.com>\n\n\t* config/arm/arm.h (THUMB_LEGITIMATE_CONSTANT_P): Accept\n\tCONSTANT_P_RTX.\n\n\t2003-30-12  Paul Brook  <paul@codesourcery.com>\n\n\t* longlong.h: protect arm inlines with !defined (__thumb__)\n\n\t2003-30-12  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Always define __arm__.\n\n\t2003-12-30  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* builtins.c (expand_builtin_apply_args_1): Fix typo in previous\n\tchange.\n\n\t2003-12-29  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* builtins.c (expand_builtin_apply_args_1): Add pretend args size\n\tto the virtual incoming args pointer for downward stacks.\n\n\t2003-12-29  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm-cores.def: Add cost function.\n\t* config/arm/arm.c (arm_*_rtx_costs): New functions.\n\t(arm_rtx_costs): Remove\n\t(struct processors): Add rtx_costs field.\n\t(all_cores, all_architectures): Ditto.\n\t(arm_override_options): Set targetm.rtx_costs.\n\t(thumb_rtx_costs): New function.\n\t(arm_rtx_costs_1): Remove cases handled elsewhere.\n\t* config/arm/arm.h (processor_type): Add COSTS parameter.\n\n\t2003-12-29  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* config/arm/arm.md (generic_sched): arm926 has its own scheduler.\n\t(arm926ejs.md): Include it.\n\t* config/arm/arm926ejs.md: New pipeline description.\n\n\t2003-12-24  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm.c (arm_arch6j): New variable.\n\t(arm_override_options): Set it.\n\t(arm_emit_extendsi): New function.\n\t* config/arm/arm-protos.h (arm_emit_extendsi): Add prototype.\n\t* config/arm/arm.h (arm_arch6j): Declare.\n\t* config/arm/arm.md: Add sign/zero extend insns.\n\n\t2003-12-23  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm.c (all_architectures): Add armv6.\n\t* doc/invoke.texi: Document it.\n\n\t2003-12-19  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm.md: Add load1 and load_byte \"type\" attrs.  Modify\n\tinsn patterns to match.\n\t* config/arm/arm-generic.md: Ditto.\n\t* config/arm/cirrus.md: Ditto.\n\t* config/arm/fpa.md: Ditto.\n\t* config/amm/iwmmxt.md: Ditto.\n\t* config/arm/arm1026ejs.md: Ditto.\n\t* config/arm/arm1135jfs.md: Ditto.  Add insn_reservation and bypasses\n\tfor 11_loadb.\n\n\t2003-12-18  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* config/arm/arm-protos.h (arm_no_early_alu_shift_value_dep): Declare.\n\t* config/arm/arm.c (arm_adjust_cost): Check shift cost for\n\tTYPE_ALU_SHIFT and TYPE_ALU_SHIFT_REG.\n\t(arm_no_early_store_addr_dep, arm_no_early_alu_shift_dep,\n\tarm_no_early_mul_dep): Correctly deal with conditional execution,\n\tparallels and single shift operations.\n\t(arm_no_early_alu_shift_value_dep): Define.\n\t* arm.md (attr type): Replace 'normal' with 'alu',\n\t'alu_shift' and 'alu_shift_reg'.\n\t(attr core_cycles): Adjust.\n\t(*addsi3_carryin_shift, andsi_not_shiftsi_si, *arm_shiftsi3,\n\t*shiftsi3_compare0, *notsi_shiftsi, *notsi_shiftsi_compare0,\n\t*not_shiftsi_compare0_scratch, *cmpsi_shiftsi, *cmpsi_shiftsi_swp,\n\t*cmpsi_neg_shiftsi, *arith_shiftsi, *arith_shiftsi_compare0,\n\t*arith_shiftsi_compare0_scratch, *sub_shiftsi,\n\t*sub_shiftsi_compare0, *sub_shiftsi_compare0_scratch,\n\t*if_shift_move, *if_move_shift, *if_shift_shift): Set type\n\tattribute appropriately.\n\t* config/arm/arm1026ejs.md (alu_op): Adjust.\n\t(alu_shift_op, alu_shift_reg_op): New.\n\t* config/arm/arm1136.md: Add better bypasses for early\n\tregisters. Remove load[234] and store[234] bypasses.\n\t(11_alu_op): Adjust.\n\t(11_alu_shift_op, 11_alu_shift_reg_op): New.\n\n\t2003-12-15  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* config/arm/arm-protos.h (arm_no_early_store_addr_dep,\n\tarm_no_early_alu_shift_dep, arm_no_early_mul_dep): Declare.\n\t* config/arm/arm.c (arm_no_early_store_addr_dep,\n\tarm_no_early_alu_shift_dep, arm_no_early_mul_dep): Define.\n\t* config/arm/arm1026ejs.md: Add load-store bypass.\n\t* config/arm/arm1136jfs.md (11_alu_op): Take 2 cycles.\n\tAdd bypasses between instructions.\n\n\t2003-12-10  Paul Brook  <paul@codesourcery.com>\n\n\t* config/arm/arm.c (arm_fpu_model): New variable.\n\t(arm_fload_abi): New variable.\n\t(target_fpe_name): Rename from target_fp_name.\n\t(target_fpu_name): New variable.\n\t(arm_is_cirrus): Remove.\n\t(fpu_desc): New struct.\n\t(all_fpus): Define.\n\t(pf_model_for_fpu): Define.\n\t(all_loat_abis): Define.\n\t(arm_override_options): Set fp arch flags based on -mfpu=\n\tand -float-abi=.\n\t(FIRST_FPA_REGNUM): Rename from FIRST_ARM_FP_REGNUM.\n\t(LAST_FPA_REGNUM): Rename from LAST_ARM_FP_REGNUM.\n\t(*): Use new TARGET_* flags.\n\t* config/arm/arm.h (TARGET_ANY_HARD_FLOAT): Remove.\n\t(TARGET_HARD_FLOAT): No longer implies TARGET_FPA.\n\t(TARGET_SOFT_FLOAT): Ditto.\n\t(TARGET_SOFT_FLOAT_ABI): New.\n\t(TARGET_MAVERICK): Rename from TARGET_CIRRUS.  No longer implies\n\tTARGET_HARD_FLOAT.\n\t(TARGET_VFP): No longer implies TARGET_HARD_FLOAT.\n\t(TARGET_OPTIONS): Add -mfpu=.\n\t(FIRST_FPA_REGNUM): Rename from FIRST_ARM_FP_REGNUM.\n\t(LAST_FPA_REGNUM): Rename from LAST_ARM_FP_REGNUM.\n\t(arm_pf_model): Define.\n\t(arm_float_abi_type): Define.\n\t(fputype): Add FPUTYPE_VFP.  Change SOFT_FPA->NONE\n\t* config/arm/arm.md: Use new TARGET_* flags.\n\t* config/arm/cirrus.md: Ditto.\n\t* config/arm/fpa.md: Ditto.\n\t* config/arm/elf.h (ASM_SPEC): Pass -mfloat-abi= and -mfpu=.\n\t* config/arm/semi.h (ASM_SPEC): Ditto.\n\t* config/arm/netbsd-elf.h (SUBTARGET_ASM_FLOAT_SPEC): Specify vfp.\n\t(FPUTYPE_DEFAULT): Set to VFP.\n\t* doc/invoke.texi: Document -mfpu= and -mfloat-abi=.\n\n\t2003-11-22  Phil Edwards  <phil@codesourcery.com>\n\n\tPR target/12476\n\t* config/arm/arm.c (arm_output_mi_thunk):  In Thumb mode, use\n\t'bx' instead of 'b' to avoid branch range restrictions.  Output\n\tthe thunk immediately before the thunked-to function.\n\t* config/arm/arm.h (ARM_DECLARE_FUNCTION_NAME):  Do not emit\n\t.thumb_func if a thunk is being generated.  Emit .code 16 along\n\twith .thumb_func if a thunk is not being generated.\n\n\t2003-11-15  Nicolas Pitre <nico@cam.org>\n\n\t* config/arm/arm.md (ashldi3, arm_ashldi3_1bit, ashrdi3,\n\tarm_ashrdi3_1bit, lshrdi3, arm_lshrdi3_1bit): New patterns.\n\t* config/arm/iwmmxt.md (ashrdi3_iwmmxt): Renamed from ashrdi3.\n\t(lshrdi3_iwmmxt): Renamed from lshrdi3.\n\t* config/arm/arm.c (IWMMXT_BUILTIN2): Renamed argument accordingly.\n\n\t2003-11-12  Steve Woodford  <scw@wasabisystems.com>\n\t    Ian Lance Taylor  <ian@wasabisystems.com>\n\n\t* config/arm/lib1funcs.asm (ARM_DIV_BODY, ARM_MOD_BODY): Add new\n\tcode for __ARM_ARCH__ >= 5 && ! defined (__OPTIMIZE_SIZE__).\n\n\t2003-11-05  Phil Edwards  <phil@codesourcery.com>\n\n\t* config/arm/arm.md (insn):  Add new V6 instruction names.\n\t(generic_sched):  New attr.\n\t* config/arm/arm-generic.md:  Use generic_sched here.\n\t* config/arm/arm1026ejs.md:  Do not model fetch/issue/decode\n\tstages of pipeline.  Adjust latency counts accordingly.\n\t* config/arm/arm1136jfs.md:  New file.\n\n\t2003-10-28  Mark Mitchell  <mark@codesourcery.com>\n\n\t* config/arm/arm.h (processor_type): New enumeration type.\n\t(CPP_ARCH_DEFAULT_SPEC): Set appropriately for ARM 926EJ-S,\n\tARM1026EJ-S, ARM1136J-S, and ARM1136JF-S processor cores.\n\t(CPP_CPU_ARCH_SPEC): Likewise.\n\t* config/arm/arm.c (arm_tune): New variable.\n\t(all_cores): Use cores.def.\n\t(all_architectures): Add representative processor.\n\t(arm_override_options): Restructure way in which tuning\n\tinformation is deduced.\n\t* arm.md: Update \"insn\" and \"type\" attributes throughout.\n\t(insn): New attribute.\n\t(type): Compute \"mult\" from \"insn\" attribute.  Add load2,\n\tload3, load4 alternatives.\n\t(arm automaton): Move to arm-generic.md.\n\t* config/arm/arm-cores.def: New file.\n\t* config/arm/arm-generic.md: Likewise.\n\t* config/arm/arm1026ejs.md: Likewise.\n\nFrom-SVN: r77171", "tree": {"sha": "5b51ca91b5146c11a7b22ca3e6f6fda03887cc0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b51ca91b5146c11a7b22ca3e6f6fda03887cc0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/comments", "author": null, "committer": null, "parents": [{"sha": "e93f124e0aa1927ca32c61dfcf3172bbbc305eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93f124e0aa1927ca32c61dfcf3172bbbc305eaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93f124e0aa1927ca32c61dfcf3172bbbc305eaf"}], "stats": {"total": 5876, "additions": 4737, "deletions": 1139}, "files": [{"sha": "fedcaadeaa016136bd04748bc1fef18b32ff10ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -1,3 +1,332 @@\n+2004-02-02  Paul Brook  <paul@codesourcery.com>\n+\n+\tMerge from csl-arm-branch.\n+\n+\t2004-01-30  Paul Brook  <paul@codesourcery.com>\n+\n+\t* aof.h (REGISTER_NAMES): Add vfp reg names\n+\t(ADDITIONAL_REGISTER_NAMES): Ditto.\n+\t* aout.h (REGISTER_NAMES): Ditto.\n+\t(ADDITIONAL_REGISTER_NAMES): Ditto.\n+\t* arm-protos.h: Update/Add Prototypes.\n+\t* arm.c (init_fp_table): Rename from init_fpa_table. Update users.\n+\tOnly allow 0.0 for VFP.\n+\t(fp_consts_inited): Rename from fpa_consts_inited.  Update users.\n+\t(values_fp): Rename from values_fpa.  Update Users.\n+\t(arm_const_double_rtx): Rename from const_double_rtx_ok_for_fpa.\n+\tUpdate users.  Only check valid constants for this hardware.\n+\t(arm_float_rhs_operand): Rename from fpa_rhs_operand.  Update Users.\n+\tOnly allow consts for FPA.\n+\t(arm_float_add_operand): Rename from fpa_add_operand.  Update users.\n+\tOnly allow consts for FPA.\n+\t(use_return_insn): Check for saved VFP regs.\n+\t(arm_legitimate_address_p): Handle VFP DFmode addressing.\n+\t(arm_legitimize_address): Ditto.\n+\t(arm_general_register_operand): New function.\n+\t(vfp_mem_operand): New function.\n+\t(vfp_compare_operand): New function.\n+\t(vfp_secondary_reload_class): New function.\n+\t(arm_float_compare_operand): New function.\n+\t(vfp_print_multi): New function.\n+\t(vfp_output_fstmx): New function.\n+\t(vfp_emit_fstm): New function.\n+\t(arm_output_epilogue): Output VPF reg restore code.\n+\t(arm_expand_prologue): Output VFP reg save code.\n+\t(arm_print_operand): Add 'P'.\n+\t(arm_hard_regno_mode_ok): Return modes for VFP regs.\n+\t(arm_regno_class): Return classes for VFP regs.\n+\t(arm_compute_initial_elimination_offset): Include space for VFP regs.\n+\t(arm_get_frame_size): Ditto.\n+\t* arm.h (FIXED_REGISTERS): Add VFP regs.\n+\t(CALL_USED_REGISTERS): Ditto.\n+\t(CONDITIONAL_REGISTER_USAGE): Enable VFP regs.\n+\t(FIRST_VFP_REGNUM): Define.\n+\t(LAST_VFP_REGNUM): Define.\n+\t(IS_VFP_REGNUM): Define.\n+\t(FIRST_PSEUDO_REGISTER): Include VFP regs.\n+\t(HARD_REGNO_NREGS): Handle VFP regs.\n+\t(REG_ALLOC_ORDER): Add VFP regs.\n+\t(enum reg_class): Add VFP_REGS.\n+\t(REG_CLASS_NAMES): Ditto.\n+\t(REG_CLASS_CONTENTS): Ditto.\n+\t(CANNOT_CHANGE_MODE_CLASS) Handle VFP Regs.\n+\t(REG_CLASS_FROM_LETTER): Add 'w'.\n+\t(EXTRA_CONSTRAINT_ARM): Add 'U'.\n+\t(EXTRA_MEMORY_CONSTRAINT): Define.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Handle VFP regs.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Ditto.\n+\t(REGISTER_MOVE_COST): Ditto.\n+\t(PREDICATE_CODES): Add arm_general_register_operand,\n+\tarm_float_compare_operand and vfp_compare_operand.\n+\t* arm.md (various): Rename as above.\n+\t(divsf3): Enable when TARGET_VFP.\n+\t(divdf3): Ditto.\n+\t(movdfcc): Ditto.\n+\t(sqrtsf2): Ditto.\n+\t(sqrtdf2): Ditto.\n+\t(arm_movdi): Disable when TARGET_VFP.\n+\t(arm_movsi_insn): Ditto.\n+\t(movsi): Only split with general regs.\n+\t(cmpsf): Use arm_float_compare_operand.\n+\t(push_fp_multi): Restrict to TARGET_FPA.\n+\t(vfp.md): Include.\n+\t* vfp.md: New file.\n+\t* fpa.md (various): Rename as above.\n+\t* doc/md.texi: Document ARM w and U constraints.\n+\n+\t2004-01-15  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config.gcc: Add with_fpu.  Allow with-float=softfp.\n+\t* config/arm/arm.c (arm_override_options): Rename *-s to *s.\n+\tBreak out of loop when we find a float-abi.  Fix typo.\n+\t* config/arm/arm.h (OPTION_DEFAULT_SPECS): Add \"fpu\".\n+\tSet -mfloat-abi=.\n+\t* doc/install.texi: Document --with-fpu.\n+\n+\t2003-01-14  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config.gcc (with_arch): Add armv6.\n+\t* config/arm/arm.h: Rename TARGET_CPU_*_s to TARGET_CPU_*s.\n+\t* config/arm/arm.c (arm_overrride_options): Ditto.\n+\n+\t2004-01-08  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (FL_ARCH3M): Renamed from FL_FAST_MULT.\n+\t(FL_ARCH6): Renamed from FL_ARCH6J.\n+\t(arm_arch3m): Renamed from arm_fast_multiply.\n+\t(arm_arch6): Renamed from arm_arch6j.\n+\t* arm.h: Update all uses of above.\n+\t* arm-cores.def: Likewise.\n+\t* arm.md: Likewise.\n+\n+\t* arm.h (CPP_CPU_ARCH_SPEC): Emit __ARM_ARCH_6J__ define for armV6j,\n+\tnot arm6j.  Add entry for arch armv6.\n+\n+\t2004-01-07  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_emit_extendsi): Delete.\n+\t* arm-protos.h (arm_emit_extendsi): Delete.\n+\t* arm.md (zero_extendhisi2): Also handle zero-extension of\n+\tnon-subregs.\n+\t(zero_extendqisi2, extendhisi2, extendqisi2): Likewise.\n+\t(thumb_zero_extendhisi2): Only match if not v6.\n+\t(arm_zero_extendhisi2, thumb_zero_extendqisi2, arm_zero_extendqisi2)\n+\t(thumb_extendhisi2, arm_extendhisi2, arm_extendqisi)\n+\t(thumb_extendqisi2): Likewise.\n+\t(thumb_zero_extendhisi2_v6, arm_zero_extendhisi2_v6): New patterns.\n+\t(thumb_zero_extendqisi2_v6, arm_zero_extendqisi2_v6): New patterns.\n+\t(thumb_extendhisi2_insn_v6, arm_extendhisi2_v6): New patterns.\n+\t(thumb_extendqisi2_v6, arm_extendqisi_v6): New patterns.\n+\t(arm_zero_extendhisi2_reg, arm_zero_extendqisi2_reg): Delete.\n+\t(arm_extendhisi2_reg, arm_extendqisi2_reg): Delete.\n+\t(arm_zero_extendhisi2addsi): Remove subreg.  Add attributes.\n+\t(arm_zero_extendqisi2addsi, arm_extendhisi2addsi): Likewise.\n+\t(arm_extendqisi2addsi): Likewise.\n+\n+\t2003-12-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRevert this change:\n+\t* config/arm/arm.h (THUMB_LEGTITIMIZE_RELOAD_ADDRESS): Reload REG\n+\t+ REG addressing modes.\n+\n+\t* config/arm/arm.h (THUMB_LEGTITIMIZE_RELOAD_ADDRESS): Reload REG\n+\t+ REG addressing modes.\n+\n+\t2003-12-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* config/arm/arm.h (THUMB_LEGITIMATE_CONSTANT_P): Accept\n+\tCONSTANT_P_RTX.\n+\n+\t2003-30-12  Paul Brook  <paul@codesourcery.com>\n+\n+\t* longlong.h: protect arm inlines with !defined (__thumb__)\n+\n+\t2003-30-12  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Always define __arm__.\n+\n+\t2003-12-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* builtins.c (expand_builtin_apply_args_1): Fix typo in previous\n+\tchange.\n+\n+\t2003-12-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* builtins.c (expand_builtin_apply_args_1): Add pretend args size\n+\tto the virtual incoming args pointer for downward stacks.\n+\n+\t2003-12-29  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm-cores.def: Add cost function.\n+\t* config/arm/arm.c (arm_*_rtx_costs): New functions.\n+\t(arm_rtx_costs): Remove\n+\t(struct processors): Add rtx_costs field.\n+\t(all_cores, all_architectures): Ditto.\n+\t(arm_override_options): Set targetm.rtx_costs.\n+\t(thumb_rtx_costs): New function.\n+\t(arm_rtx_costs_1): Remove cases handled elsewhere.\n+\t* config/arm/arm.h (processor_type): Add COSTS parameter.\n+\n+\t2003-12-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arm/arm.md (generic_sched): arm926 has its own scheduler.\n+\t(arm926ejs.md): Include it.\n+\t* config/arm/arm926ejs.md: New pipeline description.\n+\n+\t2003-12-24  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_arch6j): New variable.\n+\t(arm_override_options): Set it.\n+\t(arm_emit_extendsi): New function.\n+\t* config/arm/arm-protos.h (arm_emit_extendsi): Add prototype.\n+\t* config/arm/arm.h (arm_arch6j): Declare.\n+\t* config/arm/arm.md: Add sign/zero extend insns.\n+\n+\t2003-12-23  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (all_architectures): Add armv6.\n+\t* doc/invoke.texi: Document it.\n+\n+\t2003-12-19  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.md: Add load1 and load_byte \"type\" attrs.  Modify\n+\tinsn patterns to match.\n+\t* config/arm/arm-generic.md: Ditto.\n+\t* config/arm/cirrus.md: Ditto.\n+\t* config/arm/fpa.md: Ditto.\n+\t* config/amm/iwmmxt.md: Ditto.\n+\t* config/arm/arm1026ejs.md: Ditto.\n+\t* config/arm/arm1135jfs.md: Ditto.  Add insn_reservation and bypasses\n+\tfor 11_loadb.\n+\n+\t2003-12-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arm/arm-protos.h (arm_no_early_alu_shift_value_dep): Declare.\n+\t* config/arm/arm.c (arm_adjust_cost): Check shift cost for\n+\tTYPE_ALU_SHIFT and TYPE_ALU_SHIFT_REG.\n+\t(arm_no_early_store_addr_dep, arm_no_early_alu_shift_dep,\n+\tarm_no_early_mul_dep): Correctly deal with conditional execution,\n+\tparallels and single shift operations.\n+\t(arm_no_early_alu_shift_value_dep): Define.\n+\t* arm.md (attr type): Replace 'normal' with 'alu',\n+\t'alu_shift' and 'alu_shift_reg'.\n+\t(attr core_cycles): Adjust.\n+\t(*addsi3_carryin_shift, andsi_not_shiftsi_si, *arm_shiftsi3,\n+\t*shiftsi3_compare0, *notsi_shiftsi, *notsi_shiftsi_compare0,\n+\t*not_shiftsi_compare0_scratch, *cmpsi_shiftsi, *cmpsi_shiftsi_swp,\n+\t*cmpsi_neg_shiftsi, *arith_shiftsi, *arith_shiftsi_compare0,\n+\t*arith_shiftsi_compare0_scratch, *sub_shiftsi,\n+\t*sub_shiftsi_compare0, *sub_shiftsi_compare0_scratch,\n+\t*if_shift_move, *if_move_shift, *if_shift_shift): Set type\n+\tattribute appropriately.\n+\t* config/arm/arm1026ejs.md (alu_op): Adjust.\n+\t(alu_shift_op, alu_shift_reg_op): New.\n+\t* config/arm/arm1136.md: Add better bypasses for early\n+\tregisters. Remove load[234] and store[234] bypasses.\n+\t(11_alu_op): Adjust.\n+\t(11_alu_shift_op, 11_alu_shift_reg_op): New.\n+\n+\t2003-12-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arm/arm-protos.h (arm_no_early_store_addr_dep,\n+\tarm_no_early_alu_shift_dep, arm_no_early_mul_dep): Declare.\n+\t* config/arm/arm.c (arm_no_early_store_addr_dep,\n+\tarm_no_early_alu_shift_dep, arm_no_early_mul_dep): Define.\n+\t* config/arm/arm1026ejs.md: Add load-store bypass.\n+\t* config/arm/arm1136jfs.md (11_alu_op): Take 2 cycles.\n+\tAdd bypasses between instructions.\n+\n+\t2003-12-10  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_fpu_model): New variable.\n+\t(arm_fload_abi): New variable.\n+\t(target_fpe_name): Rename from target_fp_name.\n+\t(target_fpu_name): New variable.\n+\t(arm_is_cirrus): Remove.\n+\t(fpu_desc): New struct.\n+\t(all_fpus): Define.\n+\t(pf_model_for_fpu): Define.\n+\t(all_loat_abis): Define.\n+\t(arm_override_options): Set fp arch flags based on -mfpu=\n+\tand -float-abi=.\n+\t(FIRST_FPA_REGNUM): Rename from FIRST_ARM_FP_REGNUM.\n+\t(LAST_FPA_REGNUM): Rename from LAST_ARM_FP_REGNUM.\n+\t(*): Use new TARGET_* flags.\n+\t* config/arm/arm.h (TARGET_ANY_HARD_FLOAT): Remove.\n+\t(TARGET_HARD_FLOAT): No longer implies TARGET_FPA.\n+\t(TARGET_SOFT_FLOAT): Ditto.\n+\t(TARGET_SOFT_FLOAT_ABI): New.\n+\t(TARGET_MAVERICK): Rename from TARGET_CIRRUS.  No longer implies\n+\tTARGET_HARD_FLOAT.\n+\t(TARGET_VFP): No longer implies TARGET_HARD_FLOAT.\n+\t(TARGET_OPTIONS): Add -mfpu=.\n+\t(FIRST_FPA_REGNUM): Rename from FIRST_ARM_FP_REGNUM.\n+\t(LAST_FPA_REGNUM): Rename from LAST_ARM_FP_REGNUM.\n+\t(arm_pf_model): Define.\n+\t(arm_float_abi_type): Define.\n+\t(fputype): Add FPUTYPE_VFP.  Change SOFT_FPA->NONE\n+\t* config/arm/arm.md: Use new TARGET_* flags.\n+\t* config/arm/cirrus.md: Ditto.\n+\t* config/arm/fpa.md: Ditto.\n+\t* config/arm/elf.h (ASM_SPEC): Pass -mfloat-abi= and -mfpu=.\n+\t* config/arm/semi.h (ASM_SPEC): Ditto.\n+\t* config/arm/netbsd-elf.h (SUBTARGET_ASM_FLOAT_SPEC): Specify vfp.\n+\t(FPUTYPE_DEFAULT): Set to VFP.\n+\t* doc/invoke.texi: Document -mfpu= and -mfloat-abi=.\n+\n+\t2003-11-22  Phil Edwards  <phil@codesourcery.com>\n+\n+\tPR target/12476\n+\t* config/arm/arm.c (arm_output_mi_thunk):  In Thumb mode, use\n+\t'bx' instead of 'b' to avoid branch range restrictions.  Output\n+\tthe thunk immediately before the thunked-to function.\n+\t* config/arm/arm.h (ARM_DECLARE_FUNCTION_NAME):  Do not emit\n+\t.thumb_func if a thunk is being generated.  Emit .code 16 along\n+\twith .thumb_func if a thunk is not being generated.\n+\n+\t2003-11-15  Nicolas Pitre <nico@cam.org>\n+\n+\t* config/arm/arm.md (ashldi3, arm_ashldi3_1bit, ashrdi3,\n+\tarm_ashrdi3_1bit, lshrdi3, arm_lshrdi3_1bit): New patterns.\n+\t* config/arm/iwmmxt.md (ashrdi3_iwmmxt): Renamed from ashrdi3.\n+\t(lshrdi3_iwmmxt): Renamed from lshrdi3.\n+\t* config/arm/arm.c (IWMMXT_BUILTIN2): Renamed argument accordingly.\n+\n+\t2003-11-12  Steve Woodford  <scw@wasabisystems.com>\n+\t    Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* config/arm/lib1funcs.asm (ARM_DIV_BODY, ARM_MOD_BODY): Add new\n+\tcode for __ARM_ARCH__ >= 5 && ! defined (__OPTIMIZE_SIZE__).\n+\n+\t2003-11-05  Phil Edwards  <phil@codesourcery.com>\n+\n+\t* config/arm/arm.md (insn):  Add new V6 instruction names.\n+\t(generic_sched):  New attr.\n+\t* config/arm/arm-generic.md:  Use generic_sched here.\n+\t* config/arm/arm1026ejs.md:  Do not model fetch/issue/decode\n+\tstages of pipeline.  Adjust latency counts accordingly.\n+\t* config/arm/arm1136jfs.md:  New file.\n+\n+\t2003-10-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* config/arm/arm.h (processor_type): New enumeration type.\n+\t(CPP_ARCH_DEFAULT_SPEC): Set appropriately for ARM 926EJ-S,\n+\tARM1026EJ-S, ARM1136J-S, and ARM1136JF-S processor cores.\n+\t(CPP_CPU_ARCH_SPEC): Likewise.\n+\t* config/arm/arm.c (arm_tune): New variable.\n+\t(all_cores): Use cores.def.\n+\t(all_architectures): Add representative processor.\n+\t(arm_override_options): Restructure way in which tuning\n+\tinformation is deduced.\n+\t* arm.md: Update \"insn\" and \"type\" attributes throughout.\n+\t(insn): New attribute.\n+\t(type): Compute \"mult\" from \"insn\" attribute.  Add load2,\n+\tload3, load4 alternatives.\n+\t(arm automaton): Move to arm-generic.md.\n+\t* config/arm/arm-cores.def: New file.\n+\t* config/arm/arm-generic.md: Likewise.\n+\t* config/arm/arm1026ejs.md: Likewise.\n+\n 2004-02-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* doc/invoke.texi (SPARC options): Remove -mflat and"}, {"sha": "eb9c3ac22a2dd07210fa37d73b9a880d8bcac5f4", "filename": "gcc/config.gcc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -2399,7 +2399,7 @@ fi\n \t\t;;\n \n \tarm*-*-*)\n-\t\tsupported_defaults=\"arch cpu float tune\"\n+\t\tsupported_defaults=\"arch cpu float tune fpu\"\n \t\tfor which in cpu tune; do\n \t\t\teval \"val=\\$with_$which\"\n \t\t\tcase \"$val\" in\n@@ -2426,7 +2426,7 @@ fi\n \n \t\tcase \"$with_arch\" in\n \t\t\"\" \\\n-\t\t| armv[2345] | armv2a | armv3m | armv4t | armv5t \\\n+\t\t| armv[23456] | armv2a | armv3m | armv4t | armv5t \\\n \t\t| armv5te | armv6j | ep9312)\n \t\t\t# OK\n \t\t\t;;\n@@ -2438,7 +2438,7 @@ fi\n \n \t\tcase \"$with_float\" in\n \t\t\"\" \\\n-\t\t| soft | hard)\n+\t\t| soft | hard | softfp)\n \t\t\t# OK\n \t\t\t;;\n \t\t*)\n@@ -2447,6 +2447,17 @@ fi\n \t\t\t;;\n \t\tesac\n \n+\t\tcase \"$with_fpu\" in\n+\t\t\"\" \\\n+\t\t| fpa | fpe2 | fpe3 | maverick | vfp )\n+\t\t\t# OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Unknown fpu used in --with-fpu=$fpu\" 2>&1\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n \t\tif test \"x$with_arch\" != x && test \"x$with_cpu\" != x; then\n \t\t\techo \"Warning: --with-arch overrides --with-cpu\" 1>&2\n \t\tfi\n@@ -2737,7 +2748,7 @@ fi\n \tesac\n \n \tt=\n-\tall_defaults=\"abi cpu arch tune schedule float mode\"\n+\tall_defaults=\"abi cpu arch tune schedule float mode fpu\"\n \tfor option in $all_defaults\n \tdo\n \t\teval \"val=\\$with_$option\""}, {"sha": "8f058e26406faaab4f20129ab68e4782ddb9480c", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -246,7 +246,12 @@ do {\t\t\t\t\t\\\n   \"wr0\",   \"wr1\",   \"wr2\",   \"wr3\",\t\t\\\n   \"wr4\",   \"wr5\",   \"wr6\",   \"wr7\",\t\t\\\n   \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\\\n-  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\"\t\t\\\n+  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t\\\n+  \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",  \\\n+  \"s8\",  \"s9\",  \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\", \\\n+  \"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\", \\\n+  \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\",  \\\n+  \"vfpcc\"\n }\n \n #define ADDITIONAL_REGISTER_NAMES\t\t\\\n@@ -267,6 +272,22 @@ do {\t\t\t\t\t\\\n   {\"r13\", 13}, {\"sp\", 13}, \t\t\t\\\n   {\"r14\", 14}, {\"lr\", 14},\t\t\t\\\n   {\"r15\", 15}, {\"pc\", 15}\t\t\t\\\n+  {\"d0\", 63},\t\t\t\t\t\\\n+  {\"d1\", 65},\t\t\t\t\t\\\n+  {\"d2\", 67},\t\t\t\t\t\\\n+  {\"d3\", 69},\t\t\t\t\t\\\n+  {\"d4\", 71},\t\t\t\t\t\\\n+  {\"d5\", 73},\t\t\t\t\t\\\n+  {\"d6\", 75},\t\t\t\t\t\\\n+  {\"d7\", 77},\t\t\t\t\t\\\n+  {\"d8\", 79},\t\t\t\t\t\\\n+  {\"d9\", 81},\t\t\t\t\t\\\n+  {\"d10\", 83},\t\t\t\t\t\\\n+  {\"d11\", 85},\t\t\t\t\t\\\n+  {\"d12\", 87},\t\t\t\t\t\\\n+  {\"d13\", 89},\t\t\t\t\t\\\n+  {\"d14\", 91},\t\t\t\t\t\\\n+  {\"d15\", 93},\t\t\t\t\t\\\n }\n \n #define REGISTER_PREFIX \"__\""}, {"sha": "e18a1158484b12a8e200bc5fb75c745c198020cd", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -49,7 +49,7 @@\n \n /* The assembler's names for the registers.  */\n #ifndef REGISTER_NAMES\n-#define REGISTER_NAMES  \t\t\t   \\\n+#define REGISTER_NAMES\t\t\t\t   \\\n {\t\t\t\t                   \\\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n   \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n@@ -63,7 +63,12 @@\n   \"wr0\",   \"wr1\",   \"wr2\",   \"wr3\",\t\t   \\\n   \"wr4\",   \"wr5\",   \"wr6\",   \"wr7\",\t\t   \\\n   \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t   \\\n-  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\"\t\t   \\\n+  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t   \\\n+  \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",  \\\n+  \"s8\",  \"s9\",  \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\", \\\n+  \"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\", \\\n+  \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\", \\\n+  \"vfpcc\"\t\t\t\t\t   \\\n }\n #endif\n \n@@ -152,7 +157,23 @@\n   {\"mvdx12\", 39},\t\t\t\t\\\n   {\"mvdx13\", 40},\t\t\t\t\\\n   {\"mvdx14\", 41},\t\t\t\t\\\n-  {\"mvdx15\", 42}\t\t\t\t\\\n+  {\"mvdx15\", 42},\t\t\t\t\\\n+  {\"d0\", 63},\t\t\t\t\t\\\n+  {\"d1\", 65},\t\t\t\t\t\\\n+  {\"d2\", 67},\t\t\t\t\t\\\n+  {\"d3\", 69},\t\t\t\t\t\\\n+  {\"d4\", 71},\t\t\t\t\t\\\n+  {\"d5\", 73},\t\t\t\t\t\\\n+  {\"d6\", 75},\t\t\t\t\t\\\n+  {\"d7\", 77},\t\t\t\t\t\\\n+  {\"d8\", 79},\t\t\t\t\t\\\n+  {\"d9\", 81},\t\t\t\t\t\\\n+  {\"d10\", 83},\t\t\t\t\t\\\n+  {\"d11\", 85},\t\t\t\t\t\\\n+  {\"d12\", 87},\t\t\t\t\t\\\n+  {\"d13\", 89},\t\t\t\t\t\\\n+  {\"d14\", 91},\t\t\t\t\t\\\n+  {\"d15\", 93},\t\t\t\t\t\\\n }\n #endif\n "}, {"sha": "038773c2b536f56436f5bf71ef7d3d4638d1702e", "filename": "gcc/config/arm/arm-cores.def", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cores.def?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -0,0 +1,87 @@\n+/* ARM CPU Cores\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Written by CodeSourcery, LLC\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* Before using #include to read this file, define a macro:\n+\t\n+      ARM_CORE(CORE_NAME, FLAGS)\n+\n+   The CORE_NAME is the name of the core, represented as an identifier\n+   rather than a string constant.  The FLAGS are the bitwise-or of the\n+   traits that apply to that core.\n+\n+   If you update this table, you must update the \"tune\" attribue in\n+   arm.md.  */\n+\n+ARM_CORE(arm2,\t\tFL_CO_PROC | FL_MODE26, slowmul)\n+ARM_CORE(arm250,\tFL_CO_PROC | FL_MODE26, slowmul)\n+ARM_CORE(arm3,\t\tFL_CO_PROC | FL_MODE26, slowmul)\n+ARM_CORE(arm6,\t\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm60,\t\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm600,\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm610,\t             FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm620,\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm7,\t\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+/* arm7m doesn't exist on its own, but only with D, (and I), but\n+   those don't alter the code, so arm7m is sometimes used.  */\n+ARM_CORE(arm7m,\t\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_ARCH3M, fastmul)\n+ARM_CORE(arm7d,\t\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm7dm,\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_ARCH3M, fastmul)\n+ARM_CORE(arm7di,\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm7dmi,\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_ARCH3M, fastmul)\n+ARM_CORE(arm70,\t\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm700,\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm700i,\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm710,\t             FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm720,\t             FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm710c,\t             FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm7100,\t             FL_MODE26 | FL_MODE32, slowmul)\n+ARM_CORE(arm7500,\t             FL_MODE26 | FL_MODE32, slowmul)\n+/* Doesn't have an external co-proc, but does have embedded fpa.  */\n+ARM_CORE(arm7500fe,\tFL_CO_PROC | FL_MODE26 | FL_MODE32, slowmul)\n+/* V4 Architecture Processors */\n+ARM_CORE(arm7tdmi,\tFL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB, fastmul)\n+ARM_CORE(arm710t,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB, fastmul)\n+ARM_CORE(arm720t,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB, fastmul)\n+ARM_CORE(arm740t,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB, fastmul)\n+ARM_CORE(arm8,\t                     FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED, fastmul)\n+ARM_CORE(arm810,\t             FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED, fastmul)\n+ARM_CORE(arm9,\t                                 FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED, fastmul)\n+ARM_CORE(arm920,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED, fastmul)\n+ARM_CORE(arm920t,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED, fastmul)\n+ARM_CORE(arm940t,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED, fastmul)\n+ARM_CORE(arm9tdmi,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED, fastmul)\n+ARM_CORE(arm9e,\t       \t      \t\t         FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED, 9e)\n+\n+ARM_CORE(ep9312,\t   \t\t\t FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED |             FL_CIRRUS, fastmul)\n+ARM_CORE(strongarm,\t             FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED | FL_STRONG, fastmul)\n+ARM_CORE(strongarm110,               FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED | FL_STRONG, fastmul)\n+ARM_CORE(strongarm1100,              FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED | FL_STRONG, fastmul)\n+ARM_CORE(strongarm1110,              FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 |            FL_LDSCHED | FL_STRONG, fastmul)\n+/* V5 Architecture Processors */\n+ARM_CORE(arm10tdmi,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED             | FL_ARCH5, fastmul)\n+ARM_CORE(arm1020t,\t                         FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED             | FL_ARCH5, fastmul)\n+ARM_CORE(arm926ejs,                              FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E, 9e)\n+ARM_CORE(arm1026ejs,                             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E, 9e)\n+ARM_CORE(xscale,                                 FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE, xscale)\n+ARM_CORE(iwmmxt,                                 FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE | FL_IWMMXT, xscale)\n+/* V6 Architecture Processors */\n+ARM_CORE(arm1136js,                              FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E | FL_ARCH6, 9e)\n+ARM_CORE(arm1136jfs,                             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E | FL_ARCH6 | FL_VFPV2, 9e)"}, {"sha": "ec2df47b46582e1b96c002af1b8ca4aa5dffca45", "filename": "gcc/config/arm/arm-generic.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-generic.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -0,0 +1,152 @@\n+;; Generic ARM Pipeline Description\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.  */\n+\n+(define_automaton \"arm\")\n+\n+;; Write buffer\n+;\n+; Strictly, we should model a 4-deep write buffer for ARM7xx based chips\n+;\n+; The write buffer on some of the arm6 processors is hard to model exactly.\n+; There is room in the buffer for up to two addresses and up to eight words\n+; of memory, but the two needn't be split evenly.  When writing the two\n+; addresses are fully pipelined.  However, a read from memory that is not\n+; currently in the cache will block until the writes have completed.\n+; It is normally the case that FCLK and MCLK will be in the ratio 2:1, so\n+; writes will take 2 FCLK cycles per word, if FCLK and MCLK are asynchronous\n+; (they aren't allowed to be at present) then there is a startup cost of 1MCLK\n+; cycle to add as well.\n+(define_cpu_unit \"write_buf\" \"arm\")\n+\n+;; Write blockage unit\n+;\n+; The write_blockage unit models (partially), the fact that reads will stall\n+; until the write buffer empties.\n+; The f_mem_r and r_mem_f could also block, but they are to the stack,\n+; so we don't model them here\n+(define_cpu_unit \"write_blockage\" \"arm\")\n+\n+;; Core\n+;\n+(define_cpu_unit \"core\" \"arm\")\n+\n+(define_insn_reservation \"r_mem_f_wbuf\" 5\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"yes\")\n+\t    (eq_attr \"type\" \"r_mem_f\")))\n+  \"core+write_buf*3\")\n+\n+(define_insn_reservation \"store_wbuf\" 5\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"yes\")\n+       \t    (eq_attr \"type\" \"store1\")))\n+  \"core+write_buf*3+write_blockage*5\")\n+\n+(define_insn_reservation \"store2_wbuf\" 7\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"yes\")\n+\t    (eq_attr \"type\" \"store2\")))\n+  \"core+write_buf*4+write_blockage*7\")\n+\n+(define_insn_reservation \"store3_wbuf\" 9\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"yes\")\n+\t    (eq_attr \"type\" \"store3\")))\n+  \"core+write_buf*5+write_blockage*9\")\n+\n+(define_insn_reservation \"store4_wbuf\" 11\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"yes\")\n+            (eq_attr \"type\" \"store4\")))\n+  \"core+write_buf*6+write_blockage*11\")\n+\n+(define_insn_reservation \"store2\" 3\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"no\")\n+            (eq_attr \"type\" \"store2\")))\n+  \"core*3\")\n+\n+(define_insn_reservation \"store3\" 4\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"no\")\n+            (eq_attr \"type\" \"store3\")))\n+  \"core*4\")\n+\n+(define_insn_reservation \"store4\" 5\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"model_wbuf\" \"no\")\n+\t    (eq_attr \"type\" \"store4\")))\n+  \"core*5\")\n+\n+(define_insn_reservation \"store_ldsched\" 1\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"yes\") \n+\t    (eq_attr \"type\" \"store1\")))\n+  \"core\")\n+\n+(define_insn_reservation \"load_ldsched_xscale\" 3\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"yes\") \n+\t    (and (eq_attr \"type\" \"load_byte,load1\")\n+\t         (eq_attr \"is_xscale\" \"yes\"))))\n+  \"core\")\n+\n+(define_insn_reservation \"load_ldsched\" 2\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"yes\") \n+\t    (and (eq_attr \"type\" \"load_byte,load1\")\n+\t         (eq_attr \"is_xscale\" \"no\"))))\n+  \"core\")\n+\n+(define_insn_reservation \"load_or_store\" 2\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"!yes\") \n+\t    (eq_attr \"type\" \"load_byte,load1,load2,load3,load4,store1\")))\n+  \"core*2\")\n+\n+(define_insn_reservation \"mult\" 16\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"no\") (eq_attr \"type\" \"mult\")))\n+  \"core*16\")\n+\n+(define_insn_reservation \"mult_ldsched_strongarm\" 3\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"yes\") \n+\t    (and (eq_attr \"is_strongarm\" \"yes\")\n+\t         (eq_attr \"type\" \"mult\"))))\n+  \"core*2\")\n+\n+(define_insn_reservation \"mult_ldsched\" 4\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"ldsched\" \"yes\") \n+\t    (and (eq_attr \"is_strongarm\" \"no\")\n+\t         (eq_attr \"type\" \"mult\"))))\n+  \"core*4\")\n+\n+(define_insn_reservation \"multi_cycle\" 32\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (and (eq_attr \"core_cycles\" \"multi\")\n+            (eq_attr \"type\" \"!mult,load_byte,load1,load2,load3,load4,store1,store2,store3,store4\")))\n+  \"core*32\")\n+\n+(define_insn_reservation \"single_cycle\" 1\n+  (and (eq_attr \"generic_sched\" \"yes\")\n+       (eq_attr \"core_cycles\" \"single\"))\n+  \"core\")"}, {"sha": "25f563109abe83b5ae81f305210d9414944816a0", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -1,5 +1,6 @@\n /* Prototypes for exported functions defined in arm.c and pe.c\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n    Contributed by Richard Earnshaw (rearnsha@arm.com)\n    Minor hacks by Nick Clifton (nickc@cygnus.com)\n \n@@ -53,12 +54,14 @@ extern int arm_legitimate_address_p  (enum machine_mode, rtx, int);\n extern int thumb_legitimate_address_p (enum machine_mode, rtx, int);\n extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n extern rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n-extern int const_double_rtx_ok_for_fpa (rtx);\n+extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n+extern enum reg_class vfp_secondary_reload_class (enum machine_mode, rtx);\n \n /* Predicates.  */\n extern int s_register_operand (rtx, enum machine_mode);\n extern int arm_hard_register_operand (rtx, enum machine_mode);\n+extern int arm_general_register_operand (rtx, enum machine_mode);\n extern int f_register_operand (rtx, enum machine_mode);\n extern int reg_or_int_operand (rtx, enum machine_mode);\n extern int arm_reload_memory_operand (rtx, enum machine_mode);\n@@ -70,8 +73,8 @@ extern int arm_not_operand (rtx, enum machine_mode);\n extern int offsettable_memory_operand (rtx, enum machine_mode);\n extern int alignable_memory_operand (rtx, enum machine_mode);\n extern int bad_signed_byte_operand (rtx, enum machine_mode);\n-extern int fpa_rhs_operand (rtx, enum machine_mode);\n-extern int fpa_add_operand (rtx, enum machine_mode);\n+extern int arm_float_rhs_operand (rtx, enum machine_mode);\n+extern int arm_float_add_operand (rtx, enum machine_mode);\n extern int power_of_two_operand (rtx, enum machine_mode);\n extern int nonimmediate_di_operand (rtx, enum machine_mode);\n extern int di_operand (rtx, enum machine_mode);\n@@ -95,6 +98,13 @@ extern int cirrus_general_operand (rtx, enum machine_mode);\n extern int cirrus_register_operand (rtx, enum machine_mode);\n extern int cirrus_shift_const (rtx, enum machine_mode);\n extern int cirrus_memory_offset (rtx);\n+extern int vfp_mem_operand (rtx);\n+extern int vfp_compare_operand (rtx, enum machine_mode);\n+extern int arm_float_compare_operand (rtx, enum machine_mode);\n+extern int arm_no_early_store_addr_dep (rtx, rtx);\n+extern int arm_no_early_alu_shift_dep (rtx, rtx);\n+extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n+extern int arm_no_early_mul_dep (rtx, rtx);\n \n extern int symbol_mentioned_p (rtx);\n extern int label_mentioned_p (rtx);\n@@ -138,6 +148,7 @@ extern int arm_debugger_arg_offset (int, rtx);\n extern int arm_is_longcall_p (rtx, int, int);\n extern int    arm_emit_vector_const (FILE *, rtx);\n extern const char * arm_output_load_gr (rtx *);\n+extern const char *vfp_output_fstmx (rtx *);\n \n #if defined TREE_CODE\n extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);"}, {"sha": "650c74ddb76db0bedd6b672f749caccaa063d9b3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1243, "deletions": 382, "changes": 1625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -75,7 +75,6 @@ static bool arm_assemble_integer (rtx, unsigned int, int);\n #endif\n static const char *fp_const_from_val (REAL_VALUE_TYPE *);\n static arm_cc get_arm_condition_code (rtx);\n-static void init_fpa_table (void);\n static HOST_WIDE_INT int_log2 (HOST_WIDE_INT);\n static rtx is_jump_table (rtx);\n static const char *output_multi_immediate (rtx *, const char *, const char *,\n@@ -124,7 +123,10 @@ static void arm_internal_label (FILE *, const char *, unsigned long);\n static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t tree);\n static int arm_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n-static bool arm_rtx_costs (rtx, int, int, int *);\n+static bool arm_slowmul_rtx_costs (rtx, int, int, int *);\n+static bool arm_fastmul_rtx_costs (rtx, int, int, int *);\n+static bool arm_xscale_rtx_costs (rtx, int, int, int *);\n+static bool arm_9e_rtx_costs (rtx, int, int, int *);\n static int arm_address_cost (rtx);\n static bool arm_memory_load_p (rtx);\n static bool arm_cirrus_insn_p (rtx);\n@@ -223,8 +225,9 @@ static void arm_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+/* This will be overridden in arm_override_options.  */\n #undef  TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS arm_rtx_costs\n+#define TARGET_RTX_COSTS arm_slowmul_rtx_costs\n #undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST arm_address_cost\n \n@@ -266,25 +269,40 @@ int making_const_table;\n    stored from the compare operation.  */\n rtx arm_compare_op0, arm_compare_op1;\n \n-/* What type of floating point are we tuning for?  */\n-enum fputype arm_fpu_tune;\n+/* The processor for which instructions should be scheduled.  */\n+enum processor_type arm_tune = arm_none;\n+\n+/* Which floating point model to use.  */\n+enum arm_fp_model arm_fp_model;\n \n-/* What type of floating point instructions are available?  */\n+/* Which floating point hardware is available.  */\n enum fputype arm_fpu_arch;\n \n+/* Which floating point hardware to schedule for.  */\n+enum fputype arm_fpu_tune;\n+\n+/* Whether to use floating point hardware.  */\n+enum float_abi_type arm_float_abi;\n+\n /* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */\n enum prog_mode_type arm_prgmode;\n \n-/* Set by the -mfp=... option.  */\n-const char * target_fp_name = NULL;\n+/* Set by the -mfpu=... option.  */\n+const char * target_fpu_name = NULL;\n+\n+/* Set by the -mfpe=... option.  */\n+const char * target_fpe_name = NULL;\n+\n+/* Set by the -mfloat-abi=... option.  */\n+const char * target_float_abi_name = NULL;\n \n /* Used to parse -mstructure_size_boundary command line option.  */\n const char * structure_size_string = NULL;\n int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n \n /* Bit values used to identify processor capabilities.  */\n #define FL_CO_PROC    (1 << 0)        /* Has external co-processor bus */\n-#define FL_FAST_MULT  (1 << 1)        /* Fast multiply */\n+#define FL_ARCH3M     (1 << 1)        /* Extended multiply */\n #define FL_MODE26     (1 << 2)        /* 26-bit mode support */\n #define FL_MODE32     (1 << 3)        /* 32-bit mode support */\n #define FL_ARCH4      (1 << 4)        /* Architecture rel 4 */\n@@ -295,26 +313,25 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n #define FL_ARCH5E     (1 << 9)        /* DSP extensions to v5 */\n #define FL_XSCALE     (1 << 10)\t      /* XScale */\n #define FL_CIRRUS     (1 << 11)\t      /* Cirrus/DSP.  */\n-#define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n-#define FL_ARCH6J     (1 << 12)       /* Architecture rel 6.  Adds\n+#define FL_ARCH6      (1 << 12)       /* Architecture rel 6.  Adds\n \t\t\t\t\t media instructions.  */\n #define FL_VFPV2      (1 << 13)       /* Vector Floating Point V2.  */\n \n+#define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n+\n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n static unsigned long insn_flags = 0;\n \n /* The bits in this mask specify which instruction scheduling options should\n-   be used.  Note - there is an overlap with the FL_FAST_MULT.  For some\n-   hardware we want to be able to generate the multiply instructions, but to\n-   tune as if they were not present in the architecture.  */\n+   be used.  */\n static unsigned long tune_flags = 0;\n \n /* The following are used in the arm.md file as equivalents to bits\n    in the above two flag variables.  */\n \n-/* Nonzero if this is an \"M\" variant of the processor.  */\n-int arm_fast_multiply = 0;\n+/* Nonzero if this chip supports the ARM Architecture 3M extensions.  */\n+int arm_arch3m = 0;\n \n /* Nonzero if this chip supports the ARM Architecture 4 extensions.  */\n int arm_arch4 = 0;\n@@ -325,6 +342,9 @@ int arm_arch5 = 0;\n /* Nonzero if this chip supports the ARM Architecture 5E extensions.  */\n int arm_arch5e = 0;\n \n+/* Nonzero if this chip supports the ARM Architecture 6 extensions.  */\n+int arm_arch6 = 0;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n int arm_ld_sched = 0;\n \n@@ -343,9 +363,6 @@ int arm_tune_xscale = 0;\n /* Nonzero if this chip is an ARM6 or an ARM7.  */\n int arm_is_6_or_7 = 0;\n \n-/* Nonzero if this chip is a Cirrus/DSP.  */\n-int arm_is_cirrus = 0;\n-\n /* Nonzero if generating Thumb instructions.  */\n int thumb_code = 0;\n \n@@ -389,91 +406,45 @@ static const char * const arm_condition_codes[] =\n struct processors\n {\n   const char *const name;\n+  enum processor_type core;\n   const unsigned long flags;\n+  bool (* rtx_costs) (rtx, int, int, int *);\n };\n \n /* Not all of these give usefully different compilation alternatives,\n    but there is no simple way of generalizing them.  */\n static const struct processors all_cores[] =\n {\n   /* ARM Cores */\n-  \n-  {\"arm2\",\tFL_CO_PROC | FL_MODE26 },\n-  {\"arm250\",\tFL_CO_PROC | FL_MODE26 },\n-  {\"arm3\",\tFL_CO_PROC | FL_MODE26 },\n-  {\"arm6\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm60\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm600\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm610\",\t             FL_MODE26 | FL_MODE32 },\n-  {\"arm620\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm7\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  /* arm7m doesn't exist on its own, but only with D, (and I), but\n-     those don't alter the code, so arm7m is sometimes used.  */\n-  {\"arm7m\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n-  {\"arm7d\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm7dm\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n-  {\"arm7di\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm7dmi\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n-  {\"arm70\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm700\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm700i\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"arm710\",\t             FL_MODE26 | FL_MODE32 },\n-  {\"arm720\",\t             FL_MODE26 | FL_MODE32 },\n-  {\"arm710c\",\t             FL_MODE26 | FL_MODE32 },\n-  {\"arm7100\",\t             FL_MODE26 | FL_MODE32 },\n-  {\"arm7500\",\t             FL_MODE26 | FL_MODE32 },\n-  /* Doesn't have an external co-proc, but does have embedded fpa.  */\n-  {\"arm7500fe\",\tFL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  /* V4 Architecture Processors */\n-  {\"arm7tdmi\",\tFL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n-  {\"arm710t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n-  {\"arm720t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n-  {\"arm740t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n-  {\"arm8\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n-  {\"arm810\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n-  {\"arm9\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n-  {\"arm920\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n-  {\"arm920t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n-  {\"arm940t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n-  {\"arm9tdmi\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED },\n-  {\"arm9e\",\t       \t      \t\t FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED },\n-  {\"ep9312\",\t   \t\t\t FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED |             FL_CIRRUS },\n-  {\"strongarm\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n-  {\"strongarm110\",           FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n-  {\"strongarm1100\",          FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n-  {\"strongarm1110\",          FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n-  /* V5 Architecture Processors */\n-  {\"arm10tdmi\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED             | FL_ARCH5 },\n-  {\"arm1020t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED             | FL_ARCH5 },\n-  {\"arm926ejs\",                          FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E },\n-  {\"arm1026ejs\",                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E },\n-  {\"xscale\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE },\n-  {\"iwmmxt\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE | FL_IWMMXT },\n-  /* V6 Architecture Processors */\n-  {\"arm1136js\",                          FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E | FL_ARCH6J },\n-  {\"arm1136jfs\",                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB                          | FL_ARCH5 | FL_ARCH5E | FL_ARCH6J | FL_VFPV2 },\n-  {NULL, 0}\n+#define ARM_CORE(NAME, FLAGS, COSTS) \\\n+  {#NAME, arm_none, FLAGS, arm_##COSTS##_rtx_costs},\n+#include \"arm-cores.def\"\n+#undef ARM_CORE\n+  {NULL, arm_none, 0, NULL}\n };\n \n static const struct processors all_architectures[] =\n {\n   /* ARM Architectures */\n+  /* We don't specify rtx_costs here as it will be figured out\n+     from the core.  */\n   \n-  { \"armv2\",     FL_CO_PROC | FL_MODE26 },\n-  { \"armv2a\",    FL_CO_PROC | FL_MODE26 },\n-  { \"armv3\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  { \"armv3m\",    FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n-  { \"armv4\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 },\n+  { \"armv2\",     arm2,       FL_CO_PROC | FL_MODE26 , NULL},\n+  { \"armv2a\",    arm2,       FL_CO_PROC | FL_MODE26 , NULL},\n+  { \"armv3\",     arm6,       FL_CO_PROC | FL_MODE26 | FL_MODE32 , NULL},\n+  { \"armv3m\",    arm7m,      FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_ARCH3M , NULL},\n+  { \"armv4\",     arm7tdmi,   FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_ARCH3M | FL_ARCH4 , NULL},\n   /* Strictly, FL_MODE26 is a permitted option for v4t, but there are no\n      implementations that support it, so we will leave it out for now.  */\n-  { \"armv4t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n-  { \"armv5\",     FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n-  { \"armv5t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n-  { \"armv5te\",   FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E },\n-  { \"armv6j\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E | FL_ARCH6J },\n-  { \"ep9312\",\t\t\t\t  FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_LDSCHED | FL_CIRRUS },\n-  {\"iwmmxt\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE | FL_IWMMXT },\n-  { NULL, 0 }\n+  { \"armv4t\",    arm7tdmi,   FL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB , NULL},\n+  { \"armv5\",     arm10tdmi,  FL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_ARCH5 , NULL},\n+  { \"armv5t\",    arm10tdmi,  FL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_ARCH5 , NULL},\n+  { \"armv5te\",   arm1026ejs, FL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E , NULL},\n+  { \"armv6\",     arm1136js,  FL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E | FL_ARCH6 , NULL},\n+  { \"armv6j\",    arm1136js,  FL_CO_PROC |             FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E | FL_ARCH6 , NULL},\n+  { \"ep9312\",\t ep9312, \t\t\t      FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_LDSCHED | FL_CIRRUS , NULL},\n+  {\"iwmmxt\",     iwmmxt,                              FL_MODE32 | FL_ARCH3M | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE | FL_IWMMXT , NULL},\n+  { NULL, arm_none, 0 , NULL}\n };\n \n /* This is a magic structure.  The 'string' field is magically filled in\n@@ -488,6 +459,57 @@ struct arm_cpu_select arm_select[] =\n   { NULL,\t\"-mtune=\",\tall_cores }\n };\n \n+struct fpu_desc\n+{\n+  const char * name;\n+  enum fputype fpu;\n+};\n+\n+\n+/* Available values for for -mfpu=.  */\n+\n+static const struct fpu_desc all_fpus[] =\n+{\n+  {\"fpa\",\tFPUTYPE_FPA},\n+  {\"fpe2\",\tFPUTYPE_FPA_EMU2},\n+  {\"fpe3\",\tFPUTYPE_FPA_EMU2},\n+  {\"maverick\",\tFPUTYPE_MAVERICK},\n+  {\"vfp\",\tFPUTYPE_VFP}\n+};\n+\n+\n+/* Floating point models used by the different hardware.\n+   See fputype in arm.h.  */\n+\n+static const enum fputype fp_model_for_fpu[] =\n+{\n+  /* No FP hardware.  */\n+  ARM_FP_MODEL_UNKNOWN,\t\t/* FPUTYPE_NONE  */\n+  ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA  */\n+  ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU2  */\n+  ARM_FP_MODEL_FPA,\t\t/* FPUTYPE_FPA_EMU3  */\n+  ARM_FP_MODEL_MAVERICK,\t/* FPUTYPE_MAVERICK  */\n+  ARM_FP_MODEL_VFP\t\t/* FPUTYPE_VFP  */\n+};\n+\n+\n+struct float_abi\n+{\n+  const char * name;\n+  enum float_abi_type abi_type;\n+};\n+\n+\n+/* Available values for -mfloat-abi=.  */\n+\n+static const struct float_abi all_float_abis[] =\n+{\n+  {\"soft\",\tARM_FLOAT_ABI_SOFT},\n+  {\"softfp\",\tARM_FLOAT_ABI_SOFTFP},\n+  {\"hard\",\tARM_FLOAT_ABI_HARD}\n+};\n+\n+\n /* Return the number of bits set in VALUE.  */\n static unsigned\n bit_count (unsigned long value)\n@@ -509,7 +531,7 @@ void\n arm_override_options (void)\n {\n   unsigned i;\n-  \n+\n   /* Set up the flags based on the cpu/architecture selected by the user.  */\n   for (i = ARRAY_SIZE (arm_select); i--;)\n     {\n@@ -522,9 +544,19 @@ arm_override_options (void)\n           for (sel = ptr->processors; sel->name != NULL; sel++)\n             if (streq (ptr->string, sel->name))\n               {\n-\t\tif (i == 2)\n-\t\t  tune_flags = sel->flags;\n-\t\telse\n+\t\t/* Determine the processor core for which we should\n+\t\t   tune code-generation.  */\n+\t\tif (/* -mcpu= is a sensible default.  */\n+\t\t    i == 0\n+\t\t    /* If -march= is used, and -mcpu= has not been used,\n+\t\t       assume that we should tune for a representative\n+\t\t       CPU from that architecture.  */\n+\t\t    || i == 1\n+\t\t    /* -mtune= overrides -mcpu= and -march=.  */\n+\t\t    || i == 2)\n+\t\t  arm_tune = (enum processor_type) (sel - ptr->processors);\n+\n+\t\tif (i != 2)\n \t\t  {\n \t\t    /* If we have been given an architecture and a processor\n \t\t       make sure that they are compatible.  We only generate\n@@ -571,10 +603,10 @@ arm_override_options (void)\n \t{ TARGET_CPU_xscale,    \"xscale\" },\n \t{ TARGET_CPU_ep9312,    \"ep9312\" },\n \t{ TARGET_CPU_iwmmxt,    \"iwmmxt\" },\n-\t{ TARGET_CPU_arm926ej_s, \"arm926ej-s\" },\n-\t{ TARGET_CPU_arm1026ej_s, \"arm1026ej-s\" },\n-\t{ TARGET_CPU_arm1136j_s, \"arm1136j_s\" },\n-\t{ TARGET_CPU_arm1136jf_s, \"arm1136jf_s\" },\n+\t{ TARGET_CPU_arm926ejs, \"arm926ejs\" },\n+\t{ TARGET_CPU_arm1026ejs, \"arm1026ejs\" },\n+\t{ TARGET_CPU_arm1136js, \"arm1136js\" },\n+\t{ TARGET_CPU_arm1136jfs, \"arm1136jfs\" },\n \t{ TARGET_CPU_generic,   \"arm\" },\n \t{ 0, 0 }\n       };\n@@ -598,7 +630,7 @@ arm_override_options (void)\n \tabort ();\n \n       insn_flags = sel->flags;\n-      \n+\n       /* Now check to see if the user has specified some command line\n \t switch that require certain abilities from the cpu.  */\n       sought = 0;\n@@ -668,12 +700,17 @@ arm_override_options (void)\n \n \t  insn_flags = sel->flags;\n \t}\n+      if (arm_tune == arm_none)\n+\tarm_tune = (enum processor_type) (sel - all_cores);\n     }\n   \n-  /* If tuning has not been specified, tune for whichever processor or\n-     architecture has been selected.  */\n-  if (tune_flags == 0)\n-    tune_flags = insn_flags;\n+  /* The processor for which we should tune should now have been\n+     chosen.  */\n+  if (arm_tune == arm_none)\n+    abort ();\n+  \n+  tune_flags = all_cores[(int)arm_tune].flags;\n+  targetm.rtx_costs = all_cores[(int)arm_tune].rtx_costs;\n \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n@@ -762,66 +799,110 @@ arm_override_options (void)\n     warning (\"passing floating point arguments in fp regs not yet supported\");\n   \n   /* Initialize boolean versions of the flags, for use in the arm.md file.  */\n-  arm_fast_multiply = (insn_flags & FL_FAST_MULT) != 0;\n-  arm_arch4         = (insn_flags & FL_ARCH4) != 0;\n-  arm_arch5         = (insn_flags & FL_ARCH5) != 0;\n-  arm_arch5e        = (insn_flags & FL_ARCH5E) != 0;\n-  arm_arch_xscale     = (insn_flags & FL_XSCALE) != 0;\n-\n-  arm_ld_sched      = (tune_flags & FL_LDSCHED) != 0;\n-  arm_is_strong     = (tune_flags & FL_STRONG) != 0;\n-  thumb_code\t    = (TARGET_ARM == 0);\n-  arm_is_6_or_7     = (((tune_flags & (FL_MODE26 | FL_MODE32))\n-\t\t       && !(tune_flags & FL_ARCH4))) != 0;\n-  arm_tune_xscale       = (tune_flags & FL_XSCALE) != 0;\n-  arm_is_cirrus\t    = (tune_flags & FL_CIRRUS) != 0;\n-  arm_arch_iwmmxt   = (insn_flags & FL_IWMMXT) != 0;\n+  arm_arch3m = (insn_flags & FL_ARCH3M) != 0;\n+  arm_arch4 = (insn_flags & FL_ARCH4) != 0;\n+  arm_arch5 = (insn_flags & FL_ARCH5) != 0;\n+  arm_arch5e = (insn_flags & FL_ARCH5E) != 0;\n+  arm_arch6 = (insn_flags & FL_ARCH6) != 0;\n+  arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;\n+\n+  arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;\n+  arm_is_strong = (tune_flags & FL_STRONG) != 0;\n+  thumb_code = (TARGET_ARM == 0);\n+  arm_is_6_or_7 = (((tune_flags & (FL_MODE26 | FL_MODE32))\n+\t\t    && !(tune_flags & FL_ARCH4))) != 0;\n+  arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;\n+  arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;\n \n   if (TARGET_IWMMXT && (! TARGET_ATPCS))\n     target_flags |= ARM_FLAG_ATPCS;    \n \n-  if (arm_is_cirrus)\n+  arm_fp_model = ARM_FP_MODEL_UNKNOWN;\n+  if (target_fpu_name == NULL && target_fpe_name != NULL)\n     {\n-      arm_fpu_tune = FPUTYPE_MAVERICK;\n-\n-      /* Ignore -mhard-float if -mcpu=ep9312.  */\n-      if (TARGET_HARD_FLOAT)\n-\ttarget_flags ^= ARM_FLAG_SOFT_FLOAT;\n+      if (streq (target_fpe_name, \"2\"))\n+\ttarget_fpu_name = \"fpe2\";\n+      else if (streq (target_fpe_name, \"3\"))\n+\ttarget_fpu_name = \"fpe3\";\n+      else\n+\terror (\"invalid floating point emulation option: -mfpe=%s\",\n+\t       target_fpe_name);\n+    }\n+  if (target_fpu_name != NULL)\n+    {\n+      /* The user specified a FPU.  */\n+      for (i = 0; i < ARRAY_SIZE (all_fpus); i++)\n+\t{\n+\t  if (streq (all_fpus[i].name, target_fpu_name))\n+\t    {\n+\t      arm_fpu_arch = all_fpus[i].fpu;\n+\t      arm_fpu_tune = arm_fpu_arch;\n+\t      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];\n+\t      break;\n+\t    }\n+\t}\n+      if (arm_fp_model == ARM_FP_MODEL_UNKNOWN)\n+\terror (\"invalid floating point option: -mfpu=%s\", target_fpu_name);\n     }\n   else\n-    /* Default value for floating point code... if no co-processor\n-       bus, then schedule for emulated floating point.  Otherwise,\n-       assume the user has an FPA.\n-       Note: this does not prevent use of floating point instructions,\n-       -msoft-float does that.  */\n-    arm_fpu_tune = (tune_flags & FL_CO_PROC) ? FPUTYPE_FPA : FPUTYPE_FPA_EMU3;\n-  \n-  if (target_fp_name)\n     {\n-      if (streq (target_fp_name, \"2\"))\n+#ifdef FPUTYPE_DEFAULT\n+      /* Use the default is it is specified for this platform.  */\n+      arm_fpu_arch = FPUTYPE_DEFAULT;\n+      arm_fpu_tune = FPUTYPE_DEFAULT;\n+#else\n+      /* Pick one based on CPU type.  */\n+      if ((insn_flags & FL_VFP) != 0)\n+\tarm_fpu_arch = FPUTYPE_VFP;\n+      else if (insn_flags & FL_CIRRUS)\n+\tarm_fpu_arch = FPUTYPE_MAVERICK;\n+      else\n \tarm_fpu_arch = FPUTYPE_FPA_EMU2;\n-      else if (streq (target_fp_name, \"3\"))\n-\tarm_fpu_arch = FPUTYPE_FPA_EMU3;\n+#endif\n+      if (tune_flags & FL_CO_PROC && arm_fpu_arch == FPUTYPE_FPA_EMU2)\n+\tarm_fpu_tune = FPUTYPE_FPA;\n       else\n-\terror (\"invalid floating point emulation option: -mfpe-%s\",\n-\t       target_fp_name);\n+\tarm_fpu_tune = arm_fpu_arch;\n+      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];\n+      if (arm_fp_model == ARM_FP_MODEL_UNKNOWN)\n+\tabort ();\n+    }\n+\n+  if (target_float_abi_name != NULL)\n+    {\n+      /* The user specified a FP ABI.  */\n+      for (i = 0; i < ARRAY_SIZE (all_float_abis); i++)\n+\t{\n+\t  if (streq (all_float_abis[i].name, target_float_abi_name))\n+\t    {\n+\t      arm_float_abi = all_float_abis[i].abi_type;\n+\t      break;\n+\t    }\n+\t}\n+      if (i == ARRAY_SIZE (all_float_abis))\n+\terror (\"invalid floating point abi: -mfloat-abi=%s\",\n+\t       target_float_abi_name);\n     }\n   else\n-    arm_fpu_arch = FPUTYPE_DEFAULT;\n-  \n-  if (TARGET_FPE)\n     {\n-      if (arm_fpu_tune == FPUTYPE_FPA_EMU3)\n-\tarm_fpu_tune = FPUTYPE_FPA_EMU2;\n-      else if (arm_fpu_tune == FPUTYPE_MAVERICK)\n-\twarning (\"-mfpe switch not supported by ep9312 target cpu - ignored.\");\n-      else if (arm_fpu_tune != FPUTYPE_FPA)\n-\tarm_fpu_tune = FPUTYPE_FPA_EMU2;\n+      /* Use soft-float target flag.  */\n+      if (target_flags & ARM_FLAG_SOFT_FLOAT)\n+\tarm_float_abi = ARM_FLOAT_ABI_SOFT;\n+      else\n+\tarm_float_abi = ARM_FLOAT_ABI_HARD;\n     }\n+\n+  if (arm_float_abi == ARM_FLOAT_ABI_SOFTFP)\n+    sorry (\"-mfloat-abi=softfp\");\n+  /* If soft-float is specified then don't use FPU.  */\n+  if (TARGET_SOFT_FLOAT)\n+    arm_fpu_arch = FPUTYPE_NONE;\n   \n   /* For arm2/3 there is no need to do any scheduling if there is only\n      a floating point emulator, or we are doing software floating-point.  */\n-  if ((TARGET_SOFT_FLOAT || arm_fpu_tune != FPUTYPE_FPA)\n+  if ((TARGET_SOFT_FLOAT\n+       || arm_fpu_tune == FPUTYPE_FPA_EMU2\n+       || arm_fpu_tune == FPUTYPE_FPA_EMU3)\n       && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n   \n@@ -1123,8 +1204,14 @@ use_return_insn (int iscond, rtx sibling)\n \n   /* Can't be done if any of the FPA regs are pushed,\n      since this also requires an insn.  */\n-  if (TARGET_HARD_FLOAT)\n-    for (regno = FIRST_ARM_FP_REGNUM; regno <= LAST_ARM_FP_REGNUM; regno++)\n+  if (TARGET_HARD_FLOAT && TARGET_FPA)\n+    for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n+      if (regs_ever_live[regno] && !call_used_regs[regno])\n+\treturn 0;\n+\n+  /* Likewise VFP regs.  */\n+  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+    for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n       if (regs_ever_live[regno] && !call_used_regs[regno])\n \treturn 0;\n \n@@ -2028,15 +2115,14 @@ arm_return_in_memory (tree type)\n int\n arm_float_words_big_endian (void)\n {\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     return 0;\n \n   /* For FPA, float words are always big-endian.  For VFP, floats words\n      follow the memory system mode.  */\n \n-  if (TARGET_HARD_FLOAT)\n+  if (TARGET_FPA)\n     {\n-      /* FIXME: TARGET_HARD_FLOAT currently implies FPA.  */\n       return 1;\n     }\n \n@@ -2779,6 +2865,24 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t}\n     }\n \n+  else if (TARGET_HARD_FLOAT && TARGET_VFP && mode == DFmode)\n+    {\n+      if (GET_CODE (x) == PLUS\n+\t  && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n+\n+\t  /* ??? valid arm offsets are a subset of VFP offsets.\n+\t     For now only allow this subset.  Proper fix is to add an\n+\t     additional memory constraint for arm address modes.\n+\t     Alternatively allow full vfp addressing and let\n+\t     output_move_double fix it up with a sub-optimal sequence.  */\n+          if (val == 4 || val == -4 || val == -8)\n+\t    return 1;\n+\t}\n+    }\n+\n   else if (GET_CODE (x) == PLUS)\n     {\n       rtx xop0 = XEXP (x, 0);\n@@ -2825,12 +2929,12 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n   HOST_WIDE_INT range;\n   enum rtx_code code = GET_CODE (index);\n \n-  if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+  if (TARGET_HARD_FLOAT && TARGET_FPA && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     return (code == CONST_INT && INTVAL (index) < 1024\n \t    && INTVAL (index) > -1024\n \t    && (INTVAL (index) & 3) == 0);\n \n-  if (TARGET_CIRRUS\n+  if (TARGET_HARD_FLOAT && TARGET_MAVERICK\n       && (GET_MODE_CLASS (mode) == MODE_FLOAT || mode == DImode))\n     return (code == CONST_INT\n \t    && INTVAL (index) < 255\n@@ -3065,7 +3169,10 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n \t  rtx base_reg, val;\n \t  n = INTVAL (xop1);\n \n-\t  if (mode == DImode || (TARGET_SOFT_FLOAT && mode == DFmode))\n+\t  /* VFP addressing modes actually allow greater offsets, but for\n+\t     now we just stick with the lowest common denominator.  */\n+\t  if (mode == DImode\n+\t      || ((TARGET_SOFT_FLOAT || TARGET_VFP) && mode == DFmode))\n \t    {\n \t      low_n = n & 0x0f;\n \t      n &= ~0x0f;\n@@ -3135,129 +3242,133 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n #ifndef COSTS_N_INSNS\n #define COSTS_N_INSNS(N) ((N) * 4 - 2)\n #endif\n-/* Worker routine for arm_rtx_costs.  */\n static inline int\n-arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n+thumb_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n {\n   enum machine_mode mode = GET_MODE (x);\n-  enum rtx_code subcode;\n-  int extra_cost;\n \n-  if (TARGET_THUMB)\n+  switch (code)\n     {\n-      switch (code)\n-\t{\n-\tcase ASHIFT:\n-\tcase ASHIFTRT:\n-\tcase LSHIFTRT:\n-\tcase ROTATERT:\t\n-\tcase PLUS:\n-\tcase MINUS:\n-\tcase COMPARE:\n-\tcase NEG:\n-\tcase NOT:\t\n-\t  return COSTS_N_INSNS (1);\n-\t  \n-\tcase MULT:\t\t\t\t\t\t\t\n-\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\t\t\t\n-\t    {\t\t\t\t\t\t\t\t\n-\t      int cycles = 0;\t\t\t\t\t\t\n-\t      unsigned HOST_WIDE_INT i = INTVAL (XEXP (x, 1));\n-\t      \n-\t      while (i)\t\t\t\t\t\t\n-\t\t{\t\t\t\t\t\t\t\n-\t\t  i >>= 2;\t\t\t\t\t\t\n-\t\t  cycles++;\t\t\t\t\t\t\n-\t\t}\t\t\t\t\t\t\t\n-\t      return COSTS_N_INSNS (2) + cycles;\t\t\t\n-\t    }\n-\t  return COSTS_N_INSNS (1) + 16;\n-\t  \n-\tcase SET:\t\t\t\t\t\t\t\n-\t  return (COSTS_N_INSNS (1)\t\t\t\t\t\n-\t\t  + 4 * ((GET_CODE (SET_SRC (x)) == MEM)\t\t\n-\t\t\t + GET_CODE (SET_DEST (x)) == MEM));\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ROTATERT:\t\n+    case PLUS:\n+    case MINUS:\n+    case COMPARE:\n+    case NEG:\n+    case NOT:\t\n+      return COSTS_N_INSNS (1);\n+      \n+    case MULT:\t\t\t\t\t\t\t\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\t\t\t\n+\t{\t\t\t\t\t\t\t\t\n+\t  int cycles = 0;\t\t\t\t\t\t\n+\t  unsigned HOST_WIDE_INT i = INTVAL (XEXP (x, 1));\n \t  \n-\tcase CONST_INT:\t\t\t\t\t\t\n-\t  if (outer == SET)\t\t\t\t\t\t\n+\t  while (i)\t\t\t\t\t\t\n \t    {\t\t\t\t\t\t\t\n-\t      if ((unsigned HOST_WIDE_INT) INTVAL (x) < 256)\t\t\n-\t\treturn 0;\t\t\t\t\t\t\n-\t      if (thumb_shiftable_const (INTVAL (x)))\t\t\t\n-\t\treturn COSTS_N_INSNS (2);\t\t\t\t\n-\t      return COSTS_N_INSNS (3);\t\t\t\t\n-\t    }\t\t\t\t\t\t\t\t\n-\t  else if ((outer == PLUS || outer == COMPARE)\n-\t\t   && INTVAL (x) < 256 && INTVAL (x) > -256)\t\t\n-\t    return 0;\n-\t  else if (outer == AND\n-\t\t   && INTVAL (x) < 256 && INTVAL (x) >= -256)\n-\t    return COSTS_N_INSNS (1);\n-\t  else if (outer == ASHIFT || outer == ASHIFTRT\t\t\n-\t\t   || outer == LSHIFTRT)\t\t\t\t\n-\t    return 0;\t\t\t\t\t\t\t\n-\t  return COSTS_N_INSNS (2);\n-\t  \n-\tcase CONST:\t\t\t\t\t\t\t\n-\tcase CONST_DOUBLE:\t\t\t\t\t\t\n-\tcase LABEL_REF:\t\t\t\t\t\t\n-\tcase SYMBOL_REF:\t\t\t\t\t\t\n-\t  return COSTS_N_INSNS (3);\n-\t  \n-\tcase UDIV:\n-\tcase UMOD:\n-\tcase DIV:\n-\tcase MOD:\n-\t  return 100;\n+\t      i >>= 2;\t\t\t\t\t\t\n+\t      cycles++;\t\t\t\t\t\t\n+\t    }\t\t\t\t\t\t\t\n+\t  return COSTS_N_INSNS (2) + cycles;\t\t\t\n+\t}\n+      return COSTS_N_INSNS (1) + 16;\n+      \n+    case SET:\t\t\t\t\t\t\t\n+      return (COSTS_N_INSNS (1)\t\t\t\t\t\n+\t      + 4 * ((GET_CODE (SET_SRC (x)) == MEM)\t\t\n+\t\t     + GET_CODE (SET_DEST (x)) == MEM));\n+      \n+    case CONST_INT:\t\t\t\t\t\t\n+      if (outer == SET)\t\t\t\t\t\t\n+\t{\t\t\t\t\t\t\t\n+\t  if ((unsigned HOST_WIDE_INT) INTVAL (x) < 256)\t\t\n+\t    return 0;\t\t\t\t\t\t\n+\t  if (thumb_shiftable_const (INTVAL (x)))\t\t\t\n+\t    return COSTS_N_INSNS (2);\t\t\t\t\n+\t  return COSTS_N_INSNS (3);\t\t\t\t\n+\t}\t\t\t\t\t\t\t\t\n+      else if ((outer == PLUS || outer == COMPARE)\n+\t       && INTVAL (x) < 256 && INTVAL (x) > -256)\t\t\n+\treturn 0;\n+      else if (outer == AND\n+\t       && INTVAL (x) < 256 && INTVAL (x) >= -256)\n+\treturn COSTS_N_INSNS (1);\n+      else if (outer == ASHIFT || outer == ASHIFTRT\t\t\n+\t       || outer == LSHIFTRT)\t\t\t\t\n+\treturn 0;\t\t\t\t\t\t\t\n+      return COSTS_N_INSNS (2);\n+      \n+    case CONST:\t\t\t\t\t\t\t\n+    case CONST_DOUBLE:\t\t\t\t\t\t\n+    case LABEL_REF:\t\t\t\t\t\t\n+    case SYMBOL_REF:\t\t\t\t\t\t\n+      return COSTS_N_INSNS (3);\n+      \n+    case UDIV:\n+    case UMOD:\n+    case DIV:\n+    case MOD:\n+      return 100;\n \n-\tcase TRUNCATE:\n-\t  return 99;\n+    case TRUNCATE:\n+      return 99;\n \n-\tcase AND:\n-\tcase XOR:\n-\tcase IOR: \n-\t  /* XXX guess.  */\n-\t  return 8;\n-\n-\tcase ADDRESSOF:\n-\tcase MEM:\n-\t  /* XXX another guess.  */\n-\t  /* Memory costs quite a lot for the first word, but subsequent words\n-\t     load at the equivalent of a single insn each.  */\n-\t  return (10 + 4 * ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n-\t\t  + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n-\t\t     ? 4 : 0));\n-\n-\tcase IF_THEN_ELSE:\n-\t  /* XXX a guess.  */\n-\t  if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n-\t    return 14;\n-\t  return 2;\n+    case AND:\n+    case XOR:\n+    case IOR: \n+      /* XXX guess. */\n+      return 8;\n \n-\tcase ZERO_EXTEND:\n-\t  /* XXX still guessing.  */\n-\t  switch (GET_MODE (XEXP (x, 0)))\n-\t    {\n-\t    case QImode:\n-\t      return (1 + (mode == DImode ? 4 : 0)\n-\t\t      + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n-\t      \n-\t    case HImode:\n-\t      return (4 + (mode == DImode ? 4 : 0)\n-\t\t      + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n-\t      \n-\t    case SImode:\n-\t      return (1 + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+    case ADDRESSOF:\n+    case MEM:\n+      /* XXX another guess.  */\n+      /* Memory costs quite a lot for the first word, but subsequent words\n+\t load at the equivalent of a single insn each.  */\n+      return (10 + 4 * ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n+\t      + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+\t\t ? 4 : 0));\n+\n+    case IF_THEN_ELSE:\n+      /* XXX a guess. */\n+      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n+\treturn 14;\n+      return 2;\n+\n+    case ZERO_EXTEND:\n+      /* XXX still guessing.  */\n+      switch (GET_MODE (XEXP (x, 0)))\n+\t{\n+\tcase QImode:\n+\t  return (1 + (mode == DImode ? 4 : 0)\n+\t\t  + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n \t  \n-\t    default:\n-\t      return 99;\n-\t    }\n+\tcase HImode:\n+\t  return (4 + (mode == DImode ? 4 : 0)\n+\t\t  + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n \t  \n+\tcase SImode:\n+\t  return (1 + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+      \n \tdefault:\n \t  return 99;\n \t}\n+      \n+    default:\n+      return 99;\n     }\n-  \n+}\n+\n+\n+/* Worker routine for arm_rtx_costs.  */\n+static inline int\n+arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  enum rtx_code subcode;\n+  int extra_cost;\n+\n   switch (code)\n     {\n     case MEM:\n@@ -3309,11 +3420,11 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \treturn (2 + ((REG_OR_SUBREG_REG (XEXP (x, 1))\n \t\t      || (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n-\t\t\t  && const_double_rtx_ok_for_fpa (XEXP (x, 1))))\n+\t\t\t  && arm_const_double_rtx (XEXP (x, 1))))\n \t\t     ? 0 : 8)\n \t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 0))\n \t\t    || (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE\n-\t\t\t&& const_double_rtx_ok_for_fpa (XEXP (x, 0))))\n+\t\t\t&& arm_const_double_rtx (XEXP (x, 0))))\n \t\t   ? 0 : 8));\n \n       if (((GET_CODE (XEXP (x, 0)) == CONST_INT\n@@ -3338,7 +3449,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \treturn (2 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 8)\n \t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 1))\n \t\t    || (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n-\t\t\t&& const_double_rtx_ok_for_fpa (XEXP (x, 1))))\n+\t\t\t&& arm_const_double_rtx (XEXP (x, 1))))\n \t\t   ? 0 : 8));\n \n       /* Fall through */\n@@ -3388,65 +3499,11 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n       return 8;\n \n     case MULT:\n-      /* There is no point basing this on the tuning, since it is always the\n-\t fast variant if it exists at all.  */\n-      if (arm_fast_multiply && mode == DImode\n-\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n-\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n-\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n-\treturn 8;\n-\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  || mode == DImode)\n-\treturn 30;\n-\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n-\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n-\t  int cost, const_ok = const_ok_for_arm (i);\n-\t  int j, booth_unit_size;\n-\n-\t  if (arm_tune_xscale)\n-\t    {\n-\t      unsigned HOST_WIDE_INT masked_const;\n-\n-\t      /* The cost will be related to two insns.\n-\t\t First a load of the constant (MOV or LDR), then a multiply.  */\n-\t      cost = 2;\n-\t      if (! const_ok)\n-\t\tcost += 1;      /* LDR is probably more expensive because\n-\t\t\t\t   of longer result latency.  */\n-\t      masked_const = i & 0xffff8000;\n-\t      if (masked_const != 0 && masked_const != 0xffff8000)\n-\t\t{\n-\t\t  masked_const = i & 0xf8000000;\n-\t\t  if (masked_const == 0 || masked_const == 0xf8000000)\n-\t\t    cost += 1;\n-\t\t  else\n-\t\t    cost += 2;\n-\t\t}\n-\t      return cost;\n-\t    }\n-\t  \n-\t  /* Tune as appropriate.  */ \n-\t  cost = const_ok ? 4 : 8;\n-\t  booth_unit_size = ((tune_flags & FL_FAST_MULT) ? 8 : 2);\n-\t  for (j = 0; i && j < 32; j += booth_unit_size)\n-\t    {\n-\t      i >>= booth_unit_size;\n-\t      cost += 2;\n-\t    }\n-\n-\t  return cost;\n-\t}\n-\n-      return (((tune_flags & FL_FAST_MULT) ? 8 : 30)\n-\t      + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n-\t      + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4));\n+      /* This should have been handled by the CPU specific routines.  */\n+      abort ();\n \n     case TRUNCATE:\n-      if (arm_fast_multiply && mode == SImode\n+      if (arm_arch3m && mode == SImode\n \t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n \t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0))\n@@ -3527,7 +3584,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n       return 6;\n       \n     case CONST_DOUBLE:\t\t\t\t\t\t\n-      if (const_double_rtx_ok_for_fpa (x))\t\t\t\n+      if (arm_const_double_rtx (x))\n \treturn outer == SET ? 2 : -1;\t\t\t\n       else if ((outer == COMPARE || outer == PLUS)\t\n \t       && neg_const_double_rtx_ok_for_fpa (x))\t\t\n@@ -3539,13 +3596,262 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n     }\n }\n \n+/* RTX costs for cores with a slow MUL implimentation.  */\n+\n static bool\n-arm_rtx_costs (rtx x, int code, int outer_code, int *total)\n+arm_slowmul_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n-  *total = arm_rtx_costs_1 (x, code, outer_code);\n-  return true;\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (TARGET_THUMB)\n+    {\n+      *total = thumb_rtx_costs (x, code, outer_code);\n+      return true;\n+    }\n+  \n+  switch (code)\n+    {\n+    case MULT:\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  || mode == DImode)\n+\t{\n+\t  *total = 30;\n+\t  return true;\n+\t}\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n+\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n+\t  int cost, const_ok = const_ok_for_arm (i);\n+\t  int j, booth_unit_size;\n+\n+\t  /* Tune as appropriate.  */ \n+\t  cost = const_ok ? 4 : 8;\n+\t  booth_unit_size = 2;\n+\t  for (j = 0; i && j < 32; j += booth_unit_size)\n+\t    {\n+\t      i >>= booth_unit_size;\n+\t      cost += 2;\n+\t    }\n+\n+\t  *total = cost;\n+\t  return true;\n+\t}\n+\n+      *total = 30 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n+\t          + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4);\n+      return true;\n+  \n+    default:\n+      *total = arm_rtx_costs_1 (x, code, outer_code);\n+      return true;\n+    }\n }\n \n+\n+/* RTX cost for cores with a fast multiply unit (M variants).  */\n+\n+static bool\n+arm_fastmul_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (TARGET_THUMB)\n+    {\n+      *total = thumb_rtx_costs (x, code, outer_code);\n+      return true;\n+    }\n+  \n+  switch (code)\n+    {\n+    case MULT:\n+      /* There is no point basing this on the tuning, since it is always the\n+\t fast variant if it exists at all.  */\n+      if (mode == DImode\n+\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n+\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n+\t{\n+\t  *total = 8;\n+\t  return true;\n+\t}\n+      \n+\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  || mode == DImode)\n+\t{\n+\t  *total = 30;\n+\t  return true;\n+\t}\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n+\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n+\t  int cost, const_ok = const_ok_for_arm (i);\n+\t  int j, booth_unit_size;\n+\n+\t  /* Tune as appropriate.  */ \n+\t  cost = const_ok ? 4 : 8;\n+\t  booth_unit_size = 8;\n+\t  for (j = 0; i && j < 32; j += booth_unit_size)\n+\t    {\n+\t      i >>= booth_unit_size;\n+\t      cost += 2;\n+\t    }\n+\n+\t  *total = cost;\n+\t  return true;\n+\t}\n+\n+      *total = 8 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n+\t         + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4);\n+      return true;\n+  \n+    default:\n+      *total = arm_rtx_costs_1 (x, code, outer_code);\n+      return true;\n+    }\n+}\n+\n+\n+/* RTX cost for XScale CPUs.  */\n+\n+static bool\n+arm_xscale_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (TARGET_THUMB)\n+    {\n+      *total = thumb_rtx_costs (x, code, outer_code);\n+      return true;\n+    }\n+  \n+  switch (code)\n+    {\n+    case MULT:\n+      /* There is no point basing this on the tuning, since it is always the\n+\t fast variant if it exists at all.  */\n+      if (mode == DImode\n+\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n+\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n+\t{\n+\t  *total = 8;\n+\t  return true;\n+\t}\n+      \n+\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  || mode == DImode)\n+\t{\n+\t  *total = 30;\n+\t  return true;\n+\t}\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n+\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n+\t  int cost, const_ok = const_ok_for_arm (i);\n+\t  unsigned HOST_WIDE_INT masked_const;\n+\n+\t  /* The cost will be related to two insns.\n+\t     First a load of the constant (MOV or LDR), then a multiply. */\n+\t  cost = 2;\n+\t  if (! const_ok)\n+\t    cost += 1;      /* LDR is probably more expensive because\n+\t\t\t       of longer result latency. */\n+\t  masked_const = i & 0xffff8000;\n+\t  if (masked_const != 0 && masked_const != 0xffff8000)\n+\t    {\n+\t      masked_const = i & 0xf8000000;\n+\t      if (masked_const == 0 || masked_const == 0xf8000000)\n+\t\tcost += 1;\n+\t      else\n+\t\tcost += 2;\n+\t    }\n+\t  *total = cost;\n+\t  return true;\n+\t}\n+\n+      *total = 8 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n+\t\t + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4);\n+      return true;\n+  \n+    default:\n+      *total = arm_rtx_costs_1 (x, code, outer_code);\n+      return true;\n+    }\n+}\n+\n+\n+/* RTX costs for 9e (and later) cores.  */\n+\n+static bool\n+arm_9e_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  int nonreg_cost;\n+  int cost;\n+  \n+  if (TARGET_THUMB)\n+    {\n+      switch (code)\n+\t{\n+\tcase MULT:\n+\t  *total = COSTS_N_INSNS (3);\n+\t  return true;\n+\t  \n+\tdefault:\n+\t  *total = thumb_rtx_costs (x, code, outer_code);\n+\t  return true;\n+\t}\n+    }\n+  \n+  switch (code)\n+    {\n+    case MULT:\n+      /* There is no point basing this on the tuning, since it is always the\n+\t fast variant if it exists at all.  */\n+      if (mode == DImode\n+\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n+\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n+\t{\n+\t  *total = 3;\n+\t  return true;\n+\t}\n+      \n+\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t{\n+\t  *total = 30;\n+\t  return true;\n+\t}\n+      if (mode == DImode)\n+\t{\n+\t  cost = 7;\n+\t  nonreg_cost = 8;\n+\t}\n+      else\n+\t{\n+\t  cost = 2;\n+\t  nonreg_cost = 4;\n+\t}\n+\n+\n+      *total = cost + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : nonreg_cost)\n+\t\t    + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : nonreg_cost);\n+      return true;\n+  \n+    default:\n+      *total = arm_rtx_costs_1 (x, code, outer_code);\n+      return true;\n+    }\n+}\n /* All address computations that can be done are free, but rtx cost returns\n    the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):\n@@ -3623,7 +3929,8 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n \t operand for INSN.  If we have a shifted input operand and the\n \t instruction we depend on is another ALU instruction, then we may\n \t have to account for an additional stall.  */\n-      if (shift_opnum != 0 && attr_type == TYPE_NORMAL)\n+      if (shift_opnum != 0\n+\t  && (attr_type == TYPE_ALU_SHIFT || attr_type == TYPE_ALU_SHIFT_REG))\n \t{\n \t  rtx shifted_operand;\n \t  int opno;\n@@ -3681,47 +3988,51 @@ arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n   return cost;\n }\n \n-static int fpa_consts_inited = 0;\n+static int fp_consts_inited = 0;\n \n-static const char * const strings_fpa[8] =\n+/* Only zero is valid for VFP.  Other values are also valid for FPA.  */\n+static const char * const strings_fp[8] =\n {\n   \"0\",   \"1\",   \"2\",   \"3\",\n   \"4\",   \"5\",   \"0.5\", \"10\"\n };\n \n-static REAL_VALUE_TYPE values_fpa[8];\n+static REAL_VALUE_TYPE values_fp[8];\n \n static void\n-init_fpa_table (void)\n+init_fp_table (void)\n {\n   int i;\n   REAL_VALUE_TYPE r;\n \n-  for (i = 0; i < 8; i++)\n+  if (TARGET_VFP)\n+    fp_consts_inited = 1;\n+  else\n+    fp_consts_inited = 8;\n+\n+  for (i = 0; i < fp_consts_inited; i++)\n     {\n-      r = REAL_VALUE_ATOF (strings_fpa[i], DFmode);\n-      values_fpa[i] = r;\n+      r = REAL_VALUE_ATOF (strings_fp[i], DFmode);\n+      values_fp[i] = r;\n     }\n-\n-  fpa_consts_inited = 1;\n }\n \n-/* Return TRUE if rtx X is a valid immediate FPA constant.  */\n+/* Return TRUE if rtx X is a valid immediate FP constant.  */\n int\n-const_double_rtx_ok_for_fpa (rtx x)\n+arm_const_double_rtx (rtx x)\n {\n   REAL_VALUE_TYPE r;\n   int i;\n   \n-  if (!fpa_consts_inited)\n-    init_fpa_table ();\n+  if (!fp_consts_inited)\n+    init_fp_table ();\n   \n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n   if (REAL_VALUE_MINUS_ZERO (r))\n     return 0;\n \n-  for (i = 0; i < 8; i++)\n-    if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n+  for (i = 0; i < fp_consts_inited; i++)\n+    if (REAL_VALUES_EQUAL (r, values_fp[i]))\n       return 1;\n \n   return 0;\n@@ -3734,16 +4045,16 @@ neg_const_double_rtx_ok_for_fpa (rtx x)\n   REAL_VALUE_TYPE r;\n   int i;\n   \n-  if (!fpa_consts_inited)\n-    init_fpa_table ();\n+  if (!fp_consts_inited)\n+    init_fp_table ();\n   \n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n   r = REAL_VALUE_NEGATE (r);\n   if (REAL_VALUE_MINUS_ZERO (r))\n     return 0;\n \n   for (i = 0; i < 8; i++)\n-    if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n+    if (REAL_VALUES_EQUAL (r, values_fp[i]))\n       return 1;\n \n   return 0;\n@@ -3786,6 +4097,21 @@ arm_hard_register_operand (rtx op, enum machine_mode mode)\n \t  && REGNO (op) < FIRST_PSEUDO_REGISTER);\n }\n     \n+/* An arm register operand.  */\n+int\n+arm_general_register_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) <= LAST_ARM_REGNUM\n+\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER));\n+}\n+\n /* Only accept reg, subreg(reg), const_int.  */\n int\n reg_or_int_operand (rtx op, enum machine_mode mode)\n@@ -3957,38 +4283,53 @@ f_register_operand (rtx op, enum machine_mode mode)\n \t      || REGNO_REG_CLASS (REGNO (op)) == FPA_REGS));\n }\n \n-/* Return TRUE for valid operands for the rhs of an FPA instruction.  */\n+/* Return TRUE for valid operands for the rhs of an floating point insns.\n+   Allows regs or certain consts on FPA, just regs for everything else.  */\n int\n-fpa_rhs_operand (rtx op, enum machine_mode mode)\n+arm_float_rhs_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n \n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n \n-  if (GET_CODE (op) == CONST_DOUBLE)\n-    return const_double_rtx_ok_for_fpa (op);\n+  if (TARGET_FPA && GET_CODE (op) == CONST_DOUBLE)\n+    return arm_const_double_rtx (op);\n \n   return FALSE;\n }\n \n int\n-fpa_add_operand (rtx op, enum machine_mode mode)\n+arm_float_add_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n \n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n \n-  if (GET_CODE (op) == CONST_DOUBLE)\n-    return (const_double_rtx_ok_for_fpa (op) \n+  if (TARGET_FPA && GET_CODE (op) == CONST_DOUBLE)\n+    return (arm_const_double_rtx (op)\n \t    || neg_const_double_rtx_ok_for_fpa (op));\n \n   return FALSE;\n }\n \n+\n+/* Return TRUE if OP is suitable for the rhs of a floating point comparison.\n+   Depends which fpu we are targeting.  */\n+\n+int\n+arm_float_compare_operand (rtx op, enum machine_mode mode)\n+{\n+  if (TARGET_VFP)\n+    return vfp_compare_operand (op, mode);\n+  else\n+    return arm_float_rhs_operand (op, mode);\n+}\n+\n+\n /* Return nonzero if OP is a valid Cirrus memory address pattern.  */\n int\n cirrus_memory_offset (rtx op)\n@@ -4065,6 +4406,84 @@ cirrus_shift_const (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t  && INTVAL (op) < 64);\n }\n \n+\n+/* Return TRUE if OP is a valid VFP memory address pattern.  */\n+/* Copied from cirrus_memory_offset but with restricted offset range.  */\n+\n+int\n+vfp_mem_operand (rtx op)\n+{\n+  /* Reject eliminable registers.  */\n+\n+  if (! (reload_in_progress || reload_completed)\n+      && (   reg_mentioned_p (frame_pointer_rtx, op)\n+\t  || reg_mentioned_p (arg_pointer_rtx, op)\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, op)\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, op)))\n+    return FALSE;\n+\n+  /* Constants are converted into offets from labels.  */\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx ind;\n+\n+      ind = XEXP (op, 0);\n+\n+      if (reload_completed\n+\t  && (GET_CODE (ind) == LABEL_REF\n+\t      || (GET_CODE (ind) == CONST\n+\t\t  && GET_CODE (XEXP (ind, 0)) == PLUS\n+\t\t  && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n+\t\t  && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+\treturn TRUE;\n+\n+      /* Match: (mem (reg)).  */\n+      if (GET_CODE (ind) == REG)\n+\treturn arm_address_register_rtx_p (ind, 0);\n+\n+      /* Match:\n+\t (mem (plus (reg)\n+\t            (const))).  */\n+      if (GET_CODE (ind) == PLUS\n+\t  && GET_CODE (XEXP (ind, 0)) == REG\n+\t  && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n+\t  && GET_CODE (XEXP (ind, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (ind, 1)) > -1024\n+\t  && INTVAL (XEXP (ind, 1)) <  1024)\n+\treturn TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+\n+/* Return TRUE if OP is a REG or constant zero.  */\n+int\n+vfp_compare_operand (rtx op, enum machine_mode mode)\n+{\n+  if (s_register_operand (op, mode))\n+    return TRUE;\n+\n+  return (GET_CODE (op) == CONST_DOUBLE\n+\t  && arm_const_double_rtx (op));\n+}\n+\n+\n+/* Return GENERAL_REGS if a scratch register required to reload x to/from\n+   VFP registers.  Otherwise return NO_REGS.  */\n+\n+enum reg_class\n+vfp_secondary_reload_class (enum machine_mode mode, rtx x)\n+{\n+  if (vfp_mem_operand (x) || s_register_operand (x, mode))\n+    return NO_REGS;\n+\n+  return GENERAL_REGS;\n+}\n+\n+\n /* Returns TRUE if INSN is an \"LDR REG, ADDR\" instruction.\n    Use by the Cirrus Maverick code which has to workaround\n    a hardware bug triggered by such instructions.  */\n@@ -4300,7 +4719,7 @@ nonimmediate_di_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return TRUE for a valid operand of a DFmode operation when -msoft-float.\n+/* Return TRUE for a valid operand of a DFmode operation when soft-float.\n    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).\n    Note that this disallows MEM(REG+REG), but allows\n    MEM(PRE/POST_INC/DEC(REG)).  */\n@@ -5649,7 +6068,7 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \tcase LE:\n \tcase GT:\n \tcase GE:\n-\t  if (TARGET_CIRRUS)\n+\t  if (TARGET_HARD_FLOAT && TARGET_MAVERICK)\n \t    return CCFPmode;\n \t  return CCFPEmode;\n \n@@ -7195,13 +7614,13 @@ fp_immediate_constant (rtx x)\n   REAL_VALUE_TYPE r;\n   int i;\n   \n-  if (!fpa_consts_inited)\n-    init_fpa_table ();\n+  if (!fp_consts_inited)\n+    init_fp_table ();\n   \n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n   for (i = 0; i < 8; i++)\n-    if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n-      return strings_fpa[i];\n+    if (REAL_VALUES_EQUAL (r, values_fp[i]))\n+      return strings_fp[i];\n \n   abort ();\n }\n@@ -7212,12 +7631,12 @@ fp_const_from_val (REAL_VALUE_TYPE *r)\n {\n   int i;\n \n-  if (!fpa_consts_inited)\n-    init_fpa_table ();\n+  if (!fp_consts_inited)\n+    init_fp_table ();\n \n   for (i = 0; i < 8; i++)\n-    if (REAL_VALUES_EQUAL (*r, values_fpa[i]))\n-      return strings_fpa[i];\n+    if (REAL_VALUES_EQUAL (*r, values_fp[i]))\n+      return strings_fp[i];\n \n   abort ();\n }\n@@ -7262,6 +7681,124 @@ print_multi_reg (FILE *stream, const char *instr, int reg, int mask)\n   fprintf (stream, \"\\n\");\n }\n \n+\n+/* Output the operands of a FLDM/FSTM instruction to STREAM.\n+   REG is the base register,\n+   INSTR is the possibly suffixed load or store instruction.\n+   FMT specifies now to print the register name.\n+   START and COUNT specify the register range.  */\n+\n+static void\n+vfp_print_multi (FILE *stream, const char *instr, int reg,\n+\t\t const char * fmt, int start, int count)\n+{\n+  int i;\n+\n+  fputc ('\\t', stream);\n+  asm_fprintf (stream, instr, reg);\n+  fputs (\", {\", stream);\n+\n+  for (i = start; i < start + count; i++)\n+    {\n+      if (i > start)\n+\tfputs (\", \", stream);\n+      asm_fprintf (stream, fmt, i);\n+    }\n+  fputs (\"}\\n\", stream);\n+}\n+\n+\n+/* Output the assembly for a store multiple.  */\n+\n+const char *\n+vfp_output_fstmx (rtx * operands)\n+{\n+  char pattern[100];\n+  int p;\n+  int base;\n+  int i;\n+\n+  strcpy (pattern, \"fstmfdx\\t%m0!, {%P1\");\n+  p = strlen (pattern);\n+\n+  if (GET_CODE (operands[1]) != REG)\n+    abort ();\n+\n+  base = (REGNO (operands[1]) - FIRST_VFP_REGNUM) / 2;\n+  for (i = 1; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      p += sprintf (&pattern[p], \", d%d\", base + i);\n+    }\n+  strcpy (&pattern[p], \"}\");\n+\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+\n+/* Emit RTL to save block of VFP register pairs to the stack.  */\n+\n+static rtx\n+vfp_emit_fstmx (int base_reg, int count)\n+{\n+  rtx par;\n+  rtx dwarf;\n+  rtx tmp, reg;\n+  int i;\n+\n+  /* ??? The frame layout is implementation defined.  We describe\n+     standard format 1 (equivalent to a FSTMD insn and unused pad word).\n+     We really need some way of representing the whole block so that the\n+     unwinder can figure it out at runtime.  */\n+  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n+\n+  reg = gen_rtx_REG (DFmode, base_reg);\n+  base_reg += 2;\n+\n+  XVECEXP (par, 0, 0)\n+    = gen_rtx_SET (VOIDmode,\n+\t\t   gen_rtx_MEM (BLKmode,\n+\t\t\t\tgen_rtx_PRE_DEC (BLKmode, stack_pointer_rtx)),\n+\t\t   gen_rtx_UNSPEC (BLKmode,\n+\t\t\t\t   gen_rtvec (1, reg),\n+\t\t\t\t   UNSPEC_PUSH_MULT));\n+\n+  tmp = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t     gen_rtx_PLUS (SImode, stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (-(count * 8 + 4))));\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (dwarf, 0, 0) = tmp;\n+\n+  tmp = gen_rtx_SET (VOIDmode,\n+\t\t     gen_rtx_MEM (DFmode, stack_pointer_rtx),\n+\t\t     reg);\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (dwarf, 0, 1) = tmp;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      reg = gen_rtx_REG (DFmode, base_reg);\n+      base_reg += 2;\n+      XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, reg);\n+\n+      tmp = gen_rtx_SET (VOIDmode,\n+\t\t\t gen_rtx_MEM (DFmode,\n+\t\t\t\t      gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t\t\t    GEN_INT (i * 8))),\n+\t\t\t reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (dwarf, 0, i + 1) = tmp;\n+    }\n+\n+  par = emit_insn (par);\n+  REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n+\t\t\t\t       REG_NOTES (par));\n+  return par;\n+}\n+\n+\n /* Output a 'call' insn.  */\n const char *\n output_call (rtx *operands)\n@@ -8546,6 +9083,7 @@ arm_output_epilogue (rtx sibling)\n   rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   unsigned int lrm_count = 0;\n   int really_return = (sibling == NULL);\n+  int start_reg;\n \n   /* If we have already generated the return instruction\n      then it is futile to generate anything else.  */\n@@ -8591,11 +9129,12 @@ arm_output_epilogue (rtx sibling)\n   \n   if (frame_pointer_needed)\n     {\n+      /* This variable is for the Virtual Frame Pointer, not VFP regs.  */\n       int vfp_offset = 4;\n \n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n-\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n+\t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      {\n \t\tfloats_offset += 12;\n@@ -8605,9 +9144,9 @@ arm_output_epilogue (rtx sibling)\n \t}\n       else\n \t{\n-\t  int start_reg = LAST_ARM_FP_REGNUM;\n+\t  start_reg = LAST_FPA_REGNUM;\n \n-\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n+\t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t    {\n \t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n@@ -8638,6 +9177,62 @@ arm_output_epilogue (rtx sibling)\n \t\t\t FP_REGNUM, floats_offset - vfp_offset);\n \t}\n \n+      if (TARGET_HARD_FLOAT && TARGET_VFP)\n+\t{\n+\t  int nregs = 0;\n+\n+\t  /* We save regs in pairs.  */\n+\t  /* A special insn for saving/restoring VFP registers.  This does\n+\t     not have base+offset addressing modes, so we use IP to\n+\t     hold the address.  Each block requires nregs*2+1 words.  */\n+\t  start_reg = FIRST_VFP_REGNUM;\n+\t  /* Cound how many blocks of registers need saving.  */\n+\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t    {\n+\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n+\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t\t{\n+\t\t  if (start_reg != reg)\n+\t\t    floats_offset += 4;\n+\t\t  start_reg = reg + 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  floats_offset += 8;\n+\t\t  nregs++;\n+\t\t}\n+\t    }\n+\t  if (start_reg != reg)\n+\t    floats_offset += 4;\n+\n+\t  if (nregs > 0)\n+\t    {\n+\t      asm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", IP_REGNUM,\n+\t\t\t   FP_REGNUM, floats_offset - vfp_offset);\n+\t    }\n+\t  start_reg = FIRST_VFP_REGNUM;\n+\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t    {\n+\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n+\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t\t{\n+\t\t  if (start_reg != reg)\n+\t\t    {\n+\t\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", IP_REGNUM, \"d%d\",\n+\t\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t\t       (reg - start_reg) / 2);\n+\t\t    }\n+\t\t  start_reg = reg + 2;\n+\t\t}\n+\t    }\n+\t  if (start_reg != reg)\n+\t    {\n+\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", IP_REGNUM, \"d%d\",\n+\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t       (reg - start_reg) / 2);\n+\t    }\n+\t}\n+\n       if (TARGET_IWMMXT)\n \t{\n \t  /* The frame pointer is guaranteed to be non-double-word aligned.\n@@ -8712,16 +9307,16 @@ arm_output_epilogue (rtx sibling)\n \n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n-\t  for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n+\t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      asm_fprintf (f, \"\\tldfe\\t%r, [%r], #12\\n\",\n \t\t\t   reg, SP_REGNUM);\n \t}\n       else\n \t{\n-\t  int start_reg = FIRST_ARM_FP_REGNUM;\n+\t  start_reg = FIRST_FPA_REGNUM;\n \n-\t  for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n+\t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n \t    {\n \t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n@@ -8749,6 +9344,30 @@ arm_output_epilogue (rtx sibling)\n \t\t\t start_reg, reg - start_reg, SP_REGNUM);\n \t}\n \n+      if (TARGET_HARD_FLOAT && TARGET_VFP)\n+\t{\n+\t  start_reg = FIRST_VFP_REGNUM;\n+\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t    {\n+\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n+\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t\t{\n+\t\t  if (start_reg != reg)\n+\t\t    {\n+\t\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", SP_REGNUM, \"d%d\",\n+\t\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t\t       (reg - start_reg) / 2);\n+\t\t    }\n+\t\t  start_reg = reg + 2;\n+\t\t}\n+\t    }\n+\t  if (start_reg != reg)\n+\t    {\n+\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", SP_REGNUM, \"d%d\",\n+\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t       (reg - start_reg) / 2);\n+\t    }\n+\t}\n       if (TARGET_IWMMXT)\n \tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n \t  if (regs_ever_live[reg] && !call_used_regs[reg])\n@@ -9051,6 +9670,7 @@ emit_sfm (int base_reg, int count)\n   return par;\n }\n \n+\n /* Compute the distance from register FROM to register TO.\n    These can be the arg pointer (26), the soft frame pointer (25),\n    the stack pointer (13) or the hard frame pointer (11).\n@@ -9112,6 +9732,7 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n     {\n       unsigned int reg_mask;\n       unsigned int reg;\n+      bool new_block;\n \n       /* Make sure that we compute which registers will be saved\n \t on the stack using the same algorithm that is used by\n@@ -9132,10 +9753,31 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n       /* If the hard floating point registers are going to be\n \t used then they must be saved on the stack as well.\n          Each register occupies 12 bytes of stack space.  */\n-      for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n+      for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n \tif (regs_ever_live[reg] && ! call_used_regs[reg])\n \t  call_saved_registers += 12;\n \n+      /* Likewise VFP regs.  */\n+      if (TARGET_HARD_FLOAT && TARGET_VFP)\n+\t{\n+\t  new_block = TRUE;\n+\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t    {\n+\t      if ((regs_ever_live[reg] && !call_used_regs[reg])\n+\t\t  || (regs_ever_live[reg + 1] && !call_used_regs[reg + 1]))\n+\t\t{\n+\t\t  if (new_block)\n+\t\t    {\n+\t\t      call_saved_registers += 4;\n+\t\t      new_block = FALSE;\n+\t\t    }\n+\t\t  call_saved_registers += 8;\n+\t\t}\n+\t      else\n+\t\tnew_block = TRUE;\n+\t    }\n+\t}\n+\n       if (TARGET_REALLY_IWMMXT)\n \t/* Check for the call-saved iWMMXt registers.  */\n \tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n@@ -9231,6 +9873,7 @@ arm_get_frame_size (void)\n   int entry_size = 0;\n   unsigned long func_type = arm_current_func_type ();\n   int leaf;\n+  bool new_block;\n \n   if (! TARGET_ARM)\n     abort();\n@@ -9274,12 +9917,33 @@ arm_get_frame_size (void)\n   /* Space for saved registers.  */\n   entry_size += bit_count (arm_compute_save_reg_mask ()) * 4;\n \n-  /* Space for saved FPA registers.  */\n   if (! IS_VOLATILE (func_type))\n     {\n-      for (regno = FIRST_ARM_FP_REGNUM; regno <= LAST_ARM_FP_REGNUM; regno++)\n+      /* Space for saved FPA registers.  */\n+      for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n       if (regs_ever_live[regno] && ! call_used_regs[regno])\n \tentry_size += 12;\n+\n+      /* Space for saved VFP registers.  */\n+      if (TARGET_HARD_FLOAT && TARGET_VFP)\n+\t{\n+\t  new_block = TRUE;\n+\t  for (regno = FIRST_VFP_REGNUM; regno < LAST_VFP_REGNUM; regno += 2)\n+\t    {\n+\t      if ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t\t  || (regs_ever_live[regno + 1] && !call_used_regs[regno + 1]))\n+\t\t{\n+\t\t  if (new_block)\n+\t\t    {\n+\t\t      entry_size += 4;\n+\t\t      new_block = FALSE;\n+\t\t    }\n+\t\t  entry_size += 8;\n+\t\t}\n+\t      else\n+\t\tnew_block = TRUE;\n+\t    }\n+\t}\n     }\n \n   if (TARGET_REALLY_IWMMXT)\n@@ -9474,11 +10138,13 @@ arm_expand_prologue (void)\n \n   if (! IS_VOLATILE (func_type))\n     {\n+      int start_reg;\n+\n       /* Save any floating point call-saved registers used by this\n \t function.  */\n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n-\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n+\t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      {\n \t\tinsn = gen_rtx_PRE_DEC (XFmode, stack_pointer_rtx);\n@@ -9490,9 +10156,9 @@ arm_expand_prologue (void)\n \t}\n       else\n \t{\n-\t  int start_reg = LAST_ARM_FP_REGNUM;\n+\t  start_reg = LAST_FPA_REGNUM;\n \n-\t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n+\t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t    {\n \t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n@@ -9520,6 +10186,31 @@ arm_expand_prologue (void)\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t}\n+      if (TARGET_HARD_FLOAT && TARGET_VFP)\n+\t{\n+\t  start_reg = FIRST_VFP_REGNUM;\n+\n+ \t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t    {\n+\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n+\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t\t{\n+\t\t  if (start_reg != reg)\n+\t\t    {\n+\t\t      insn = vfp_emit_fstmx (start_reg,\n+\t\t\t\t\t    (reg - start_reg) / 2);\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t    }\n+\t\t  start_reg = reg + 2;\n+\t\t}\n+\t    }\n+\t  if (start_reg != reg)\n+\t    {\n+\t      insn = vfp_emit_fstmx (start_reg,\n+\t\t\t\t    (reg - start_reg) / 2);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t}\n     }\n \n   if (frame_pointer_needed)\n@@ -9839,6 +10530,27 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t}\n       return;\n \n+      /* Print a VFP double precision register name.  */\n+    case 'P':\n+      {\n+\tint mode = GET_MODE (x);\n+\tint num;\n+\n+\tif (mode != DImode && mode != DFmode)\n+\t  abort ();\n+\n+\tif (GET_CODE (x) != REG\n+\t    || !IS_VFP_REGNUM (REGNO (x)))\n+\t  abort ();\n+\n+\tnum = REGNO(x) - FIRST_VFP_REGNUM;\n+\tif (num & 1)\n+\t  abort ();\n+\n+\tfprintf (stream, \"d%d\", num >> 1);\n+      }\n+      return;\n+\n     default:\n       if (x == 0)\n \tabort ();\n@@ -10434,7 +11146,7 @@ int\n arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n-    return regno == CC_REGNUM;\n+    return regno == CC_REGNUM || regno == VFPCC_REGNUM;\n   \n   if (TARGET_THUMB)\n     /* For the Thumb we only allow values bigger than SImode in\n@@ -10452,6 +11164,17 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n        get sign extended to 64bits-- aldyh.  */\n     return (GET_MODE_CLASS (mode) == MODE_FLOAT) || (mode == DImode);\n \n+  if (IS_VFP_REGNUM (regno))\n+    {\n+      if (mode == SFmode || mode == SImode)\n+\treturn TRUE;\n+\n+      /* DFmode values are only valid in even register pairs.  */\n+      if (mode == DFmode)\n+\treturn ((regno - FIRST_VFP_REGNUM) & 1) == 0;\n+      return FALSE;\n+    }\n+\n   if (IS_IWMMXT_GR_REGNUM (regno))\n     return mode == SImode;\n \n@@ -10470,8 +11193,8 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n   /* The only registers left are the FPA registers\n      which we only allow to hold FP values.  */\n   return GET_MODE_CLASS (mode) == MODE_FLOAT\n-    && regno >= FIRST_ARM_FP_REGNUM\n-    && regno <= LAST_ARM_FP_REGNUM;\n+    && regno >= FIRST_FPA_REGNUM\n+    && regno <= LAST_FPA_REGNUM;\n }\n \n int\n@@ -10493,12 +11216,15 @@ arm_regno_class (int regno)\n       || regno == ARG_POINTER_REGNUM)\n     return GENERAL_REGS;\n   \n-  if (regno == CC_REGNUM)\n+  if (regno == CC_REGNUM || regno == VFPCC_REGNUM)\n     return NO_REGS;\n \n   if (IS_CIRRUS_REGNUM (regno))\n     return CIRRUS_REGS;\n \n+  if (IS_VFP_REGNUM (regno))\n+    return VFP_REGS;\n+\n   if (IS_IWMMXT_REGNUM (regno))\n     return IWMMXT_REGS;\n \n@@ -10694,13 +11420,13 @@ static const struct builtin_description bdesc_2arg[] =\n   IWMMXT_BUILTIN2 (lshrv2si3_di,    WSRLW)\n   IWMMXT_BUILTIN2 (lshrv2si3,       WSRLWI)\n   IWMMXT_BUILTIN2 (lshrdi3_di,      WSRLD)\n-  IWMMXT_BUILTIN2 (lshrdi3,         WSRLDI)\n+  IWMMXT_BUILTIN2 (lshrdi3_iwmmxt,  WSRLDI)\n   IWMMXT_BUILTIN2 (ashrv4hi3_di,    WSRAH)\n   IWMMXT_BUILTIN2 (ashrv4hi3,       WSRAHI)\n   IWMMXT_BUILTIN2 (ashrv2si3_di,    WSRAW)\n   IWMMXT_BUILTIN2 (ashrv2si3,       WSRAWI)\n   IWMMXT_BUILTIN2 (ashrdi3_di,      WSRAD)\n-  IWMMXT_BUILTIN2 (ashrdi3,         WSRADI)\n+  IWMMXT_BUILTIN2 (ashrdi3_iwmmxt,  WSRADI)\n   IWMMXT_BUILTIN2 (rorv4hi3_di,     WRORH)\n   IWMMXT_BUILTIN2 (rorv4hi3,        WRORHI)\n   IWMMXT_BUILTIN2 (rorv2si3_di,     WRORW)\n@@ -13262,13 +13988,23 @@ arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t\t     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n \t\t     tree function)\n {\n+  static int thunk_label = 0;\n+  char label[256];\n   int mi_delta = delta;\n   const char *const mi_op = mi_delta < 0 ? \"sub\" : \"add\";\n   int shift = 0;\n   int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function)\n                     ? 1 : 0);\n   if (mi_delta < 0)\n     mi_delta = - mi_delta;\n+  if (TARGET_THUMB)\n+    {\n+      int labelno = thunk_label++;\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LTHUMBFUNC\", labelno);\n+      fputs (\"\\tldr\\tr12, \", file);\n+      assemble_name (file, label);\n+      fputc ('\\n', file);\n+    }\n   while (mi_delta != 0)\n     {\n       if ((mi_delta & (3 << shift)) == 0)\n@@ -13282,11 +14018,22 @@ arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n           shift += 8;\n         }\n     }\n-  fputs (\"\\tb\\t\", file);\n-  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n-  if (NEED_PLT_RELOC)\n-    fputs (\"(PLT)\", file);\n-  fputc ('\\n', file);\n+  if (TARGET_THUMB)\n+    {\n+      fprintf (file, \"\\tbx\\tr12\\n\");\n+      ASM_OUTPUT_ALIGN (file, 2);\n+      assemble_name (file, label);\n+      fputs (\":\\n\", file);\n+      assemble_integer (XEXP (DECL_RTL (function), 0), 4, BITS_PER_WORD, 1);\n+    }\n+  else\n+    {\n+      fputs (\"\\tb\\t\", file);\n+      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n+      if (NEED_PLT_RELOC)\n+        fputs (\"(PLT)\", file);\n+      fputc ('\\n', file);\n+    }\n }\n \n int\n@@ -13384,3 +14131,117 @@ arm_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n   if (cum->nregs < NUM_ARG_REGS)\n     *pretend_size = (NUM_ARG_REGS - cum->nregs) * UNITS_PER_WORD;\n }\n+\n+/* Return non-zero if the CONSUMER instruction (a store) does not need\n+   PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_no_early_store_addr_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx addr = PATTERN (consumer);\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (addr) == COND_EXEC)\n+    addr = COND_EXEC_CODE (addr);\n+  if (GET_CODE (addr) == PARALLEL)\n+    addr = XVECEXP (addr, 0, 0);\n+  addr = XEXP (addr, 0);\n+  \n+  return !reg_overlap_mentioned_p (value, addr);\n+}\n+\n+/* Return non-zero if the CONSUMER instruction (an ALU op) does not\n+   have an early register shift value or amount dependency on the\n+   result of PRODUCER.  */\n+\n+int\n+arm_no_early_alu_shift_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx op = PATTERN (consumer);\n+  rtx early_op;\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (op) == COND_EXEC)\n+    op = COND_EXEC_CODE (op);\n+  if (GET_CODE (op) == PARALLEL)\n+    op = XVECEXP (op, 0, 0);\n+  op = XEXP (op, 1);\n+  \n+  early_op = XEXP (op, 0);\n+  /* This is either an actual independent shift, or a shift applied to\n+     the first operand of another operation.  We want the whole shift\n+     operation.  */\n+  if (GET_CODE (early_op) == REG)\n+    early_op = op;\n+\n+  return !reg_overlap_mentioned_p (value, early_op);\n+}\n+\n+/* Return non-zero if the CONSUMER instruction (an ALU op) does not\n+   have an early register shift value dependency on the result of\n+   PRODUCER.  */\n+\n+int\n+arm_no_early_alu_shift_value_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx op = PATTERN (consumer);\n+  rtx early_op;\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (op) == COND_EXEC)\n+    op = COND_EXEC_CODE (op);\n+  if (GET_CODE (op) == PARALLEL)\n+    op = XVECEXP (op, 0, 0);\n+  op = XEXP (op, 1);\n+  \n+  early_op = XEXP (op, 0);\n+\n+  /* This is either an actual independent shift, or a shift applied to\n+     the first operand of another operation.  We want the value being\n+     shifted, in either case.  */\n+  if (GET_CODE (early_op) != REG)\n+    early_op = XEXP (early_op, 0);\n+  \n+  return !reg_overlap_mentioned_p (value, early_op);\n+}\n+\n+/* Return non-zero if the CONSUMER (a mul or mac op) does not\n+   have an early register mult dependency on the result of\n+   PRODUCER.  */\n+\n+int\n+arm_no_early_mul_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx op = PATTERN (consumer);\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (op) == COND_EXEC)\n+    op = COND_EXEC_CODE (op);\n+  if (GET_CODE (op) == PARALLEL)\n+    op = XVECEXP (op, 0, 0);\n+  op = XEXP (op, 1);\n+  \n+  return (GET_CODE (op) == PLUS\n+\t  && !reg_overlap_mentioned_p (value, XEXP (op, 0)));\n+}\n+"}, {"sha": "7b6a79cd1b51fa93a91beb23b44f290599a81627", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 260, "deletions": 110, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -30,9 +30,10 @@\n #define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-\tif (TARGET_ARM)\t\t\t\t\t\\\n-\t  builtin_define (\"__arm__\");\t\t\t\\\n-\telse\t\t\t\t\t\t\\\n+\t/* Define __arm__ even when in thumb mode, for\t\\\n+\t   consistency with armcc.  */\t\t\t\\\n+\tbuiltin_define (\"__arm__\");\t\t\t\\\n+\tif (TARGET_THUMB)\t\t\t\t\\\n \t  builtin_define (\"__thumb__\");\t\t\t\\\n \t\t\t\t\t\t\t\\\n \tif (TARGET_BIG_END)\t\t\t\t\\\n@@ -58,9 +59,7 @@\n \tif (TARGET_SOFT_FLOAT)\t\t\t\t\\\n \t  builtin_define (\"__SOFTFP__\");\t\t\\\n \t\t\t\t\t\t\t\\\n-\t/* FIXME: TARGET_HARD_FLOAT currently implies\t\\\n-\t   FPA.  */\t\t\t\t\t\\\n-\tif (TARGET_VFP && !TARGET_HARD_FLOAT)\t\t\\\n+\tif (TARGET_VFP)\t\t\t\t\t\\\n \t  builtin_define (\"__VFP_FP__\");\t\t\\\n \t\t\t\t\t\t\t\\\n \t/* Add a define for interworking.\t\t\\\n@@ -98,13 +97,27 @@\n #define TARGET_CPU_xscale       0x0100\n #define TARGET_CPU_ep9312\t0x0200\n #define TARGET_CPU_iwmmxt\t0x0400\n-#define TARGET_CPU_arm926ej_s   0x0800\n-#define TARGET_CPU_arm1026ej_s  0x1000\n-#define TARGET_CPU_arm1136j_s   0x2000\n-#define TARGET_CPU_arm1136jf_s  0x4000\n+#define TARGET_CPU_arm926ejs\t0x0800\n+#define TARGET_CPU_arm1026ejs\t0x1000\n+#define TARGET_CPU_arm1136js\t0x2000\n+#define TARGET_CPU_arm1136jfs\t0x4000\n /* Configure didn't specify.  */\n #define TARGET_CPU_generic\t0x8000\n \n+/* The various ARM cores.  */\n+enum processor_type\n+{\n+#define ARM_CORE(NAME, FLAGS, COSTS) \\\n+  NAME,\n+#include \"arm-cores.def\"\n+#undef ARM_CORE\n+  /* Used to indicate that no processor has been specified.  */\n+  arm_none\n+};\n+\n+/* The processor for which instructions should be scheduled.  */\n+extern enum processor_type arm_tune;\n+\n typedef enum arm_cond_code\n {\n   ARM_EQ = 0, ARM_NE, ARM_CS, ARM_CC, ARM_MI, ARM_PL, ARM_VS, ARM_VC,\n@@ -121,8 +134,12 @@ extern int arm_ccfsm_state;\n extern GTY(()) rtx arm_target_insn;\n /* Run-time compilation parameters selecting different hardware subsets.  */\n extern int target_flags;\n-/* The floating point instruction architecture, can be 2 or 3 */\n-extern const char * target_fp_name;\n+/* The floating point mode.  */\n+extern const char *target_fpu_name;\n+/* For backwards compatability.  */\n+extern const char *target_fpe_name;\n+/* Whether to use floating point hardware.  */\n+extern const char *target_float_abi_name;\n /* Define the information needed to generate branch insns.  This is\n    stored from the compare operation.  */\n extern GTY(()) rtx arm_compare_op0;\n@@ -181,6 +198,14 @@ extern GTY(()) rtx aof_pic_label;\n #if TARGET_CPU_DEFAULT == TARGET_CPU_iwmmxt\n #define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_5TE__ -D__XSCALE__ -D__IWMMXT__\"\n #else\n+#if (TARGET_CPU_DEFAULT == TARGET_CPU_arm926ejs || \\\n+     TARGET_CPU_DEFAULT == TARGET_CPU_arm1026ejs)\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_5TEJ__\"\n+#else\n+#if (TARGET_CPU_DEFAULT == TARGET_CPU_arm1136js || \\\n+     TARGET_CPU_DEFAULT == TARGET_CPU_arm1136jfs)\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_6J__\"\n+#else\n #error Unrecognized value in TARGET_CPU_DEFAULT.\n #endif\n #endif\n@@ -190,6 +215,8 @@ extern GTY(()) rtx aof_pic_label;\n #endif\n #endif\n #endif\n+#endif\n+#endif\n \n #undef  CPP_SPEC\n #define CPP_SPEC \"%(cpp_cpu_arch) %(subtarget_cpp_spec)\t\t\t\\\n@@ -225,7 +252,11 @@ extern GTY(()) rtx aof_pic_label;\n %{march=arm9:-D__ARM_ARCH_4T__} \\\n %{march=arm920:-D__ARM_ARCH_4__} \\\n %{march=arm920t:-D__ARM_ARCH_4T__} \\\n+%{march=arm926ejs:-D__ARM_ARCH_5TEJ__} \\\n %{march=arm9tdmi:-D__ARM_ARCH_4T__} \\\n+%{march=arm1026ejs:-D__ARM_ARCH_5TEJ__} \\\n+%{march=arm1136js:-D__ARM_ARCH_6J__} \\\n+%{march=arm1136jfs:-D__ARM_ARCH_6J__} \\\n %{march=strongarm:-D__ARM_ARCH_4__} \\\n %{march=strongarm110:-D__ARM_ARCH_4__} \\\n %{march=strongarm1100:-D__ARM_ARCH_4__} \\\n@@ -243,6 +274,8 @@ extern GTY(()) rtx aof_pic_label;\n %{march=armv5t:-D__ARM_ARCH_5T__} \\\n %{march=armv5e:-D__ARM_ARCH_5E__} \\\n %{march=armv5te:-D__ARM_ARCH_5TE__} \\\n+%{march=armv6:-D__ARM_ARCH6__} \\\n+%{march=armv6j:-D__ARM_ARCH6J__} \\\n %{!march=*: \\\n  %{mcpu=arm2:-D__ARM_ARCH_2__} \\\n  %{mcpu=arm250:-D__ARM_ARCH_2__} \\\n@@ -266,7 +299,11 @@ extern GTY(()) rtx aof_pic_label;\n  %{mcpu=arm9:-D__ARM_ARCH_4T__} \\\n  %{mcpu=arm920:-D__ARM_ARCH_4__} \\\n  %{mcpu=arm920t:-D__ARM_ARCH_4T__} \\\n+ %{mcpu=arm926ejs:-D__ARM_ARCH_5TEJ__} \\\n  %{mcpu=arm9tdmi:-D__ARM_ARCH_4T__} \\\n+ %{mcpu=arm1026ejs:-D__ARM_ARCH_5TEJ__} \\\n+ %{mcpu=arm1136js:-D__ARM_ARCH_6J__} \\\n+ %{mcpu=arm1136jfs:-D__ARM_ARCH_6J__} \\\n  %{mcpu=strongarm:-D__ARM_ARCH_4__} \\\n  %{mcpu=strongarm110:-D__ARM_ARCH_4__} \\\n  %{mcpu=strongarm1100:-D__ARM_ARCH_4__} \\\n@@ -414,13 +451,14 @@ extern GTY(()) rtx aof_pic_label;\n #define TARGET_APCS_REENT\t\t(target_flags & ARM_FLAG_APCS_REENT)\n #define TARGET_ATPCS\t\t\t(target_flags & ARM_FLAG_ATPCS)\n #define TARGET_MMU_TRAPS\t\t(target_flags & ARM_FLAG_MMU_TRAPS)\n-#define TARGET_SOFT_FLOAT\t\t(target_flags & ARM_FLAG_SOFT_FLOAT)\n-#define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n-#define TARGET_CIRRUS\t\t\t(arm_is_cirrus)\n-#define TARGET_ANY_HARD_FLOAT\t\t(TARGET_HARD_FLOAT || TARGET_CIRRUS)\n+#define TARGET_SOFT_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_SOFT)\n+#define TARGET_SOFT_FLOAT_ABI\t\t(arm_float_abi != ARM_FLOAT_ABI_HARD)\n+#define TARGET_HARD_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_HARD)\n+#define TARGET_FPA\t\t\t(arm_fp_model == ARM_FP_MODEL_FPA)\n+#define TARGET_MAVERICK\t\t\t(arm_fp_model == ARM_FP_MODEL_MAVERICK)\n+#define TARGET_VFP\t\t\t(arm_fp_model == ARM_FP_MODEL_VFP)\n #define TARGET_IWMMXT\t\t\t(arm_arch_iwmmxt)\n #define TARGET_REALLY_IWMMXT\t\t(TARGET_IWMMXT && TARGET_ARM)\n-#define TARGET_VFP\t\t\t(target_flags & ARM_FLAG_VFP)\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n #define TARGET_INTERWORK\t\t(target_flags & ARM_FLAG_INTERWORK)\n #define TARGET_LITTLE_WORDS\t\t(target_flags & ARM_FLAG_LITTLE_WORDS)\n@@ -523,20 +561,23 @@ extern GTY(()) rtx aof_pic_label;\n   {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\t   \\\n }\n \n-#define TARGET_OPTIONS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  {\"cpu=\",  & arm_select[0].string,\t\t\t\t\\\n-   N_(\"Specify the name of the target CPU\"), 0},\t\t\\\n-  {\"arch=\", & arm_select[1].string,\t\t\t\t\\\n-   N_(\"Specify the name of the target architecture\"), 0}, \t\\\n-  {\"tune=\", & arm_select[2].string, \"\", 0}, \t\t\t\\\n-  {\"fpe=\",  & target_fp_name, \"\" , 0}, \t\t\t\t\\\n-  {\"fp=\",   & target_fp_name,\t\t\t\t\t\\\n-   N_(\"Specify the version of the floating point emulator\"), 0},\\\n-  {\"structure-size-boundary=\", & structure_size_string, \t\\\n-   N_(\"Specify the minimum bit alignment of structures\"), 0}, \t\\\n-  {\"pic-register=\", & arm_pic_register_string,\t\t\t\\\n-   N_(\"Specify the register to be used for PIC addressing\"), 0}\t\\\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {\"cpu=\",  & arm_select[0].string,\t\t\t\t\t\\\n+   N_(\"Specify the name of the target CPU\"), 0},\t\t\t\\\n+  {\"arch=\", & arm_select[1].string,\t\t\t\t\t\\\n+   N_(\"Specify the name of the target architecture\"), 0},\t\t\\\n+  {\"tune=\", & arm_select[2].string, \"\", 0},\t\t\t\t\\\n+  {\"fpe=\",  & target_fpe_name, \"\", 0},\t\t\t\t\t\\\n+  {\"fp=\",  & target_fpe_name, \"\", 0},\t\t\t\t\t\\\n+  {\"fpu=\",  & target_fpu_name,\t\t\t\t\t\t\\\n+   N_(\"Specify the name of the target floating point hardware/format\"), 0}, \\\n+  {\"float-abi=\", & target_float_abi_name,\t\t\t\t\\\n+   N_(\"Specify if floating point hardware should be used\"), 0},\t\t\\\n+  {\"structure-size-boundary=\", & structure_size_string,\t\t\t\\\n+   N_(\"Specify the minimum bit alignment of structures\"), 0},\t\t\\\n+  {\"pic-register=\", & arm_pic_register_string,\t\t\t\t\\\n+   N_(\"Specify the register to be used for PIC addressing\"), 0}\t\t\\\n }\n \n /* Support for a compile-time default CPU, et cetera.  The rules are:\n@@ -545,13 +586,16 @@ extern GTY(()) rtx aof_pic_label;\n     by --with-arch.\n    --with-tune is ignored if -mtune or -mcpu are specified (but not affected\n      by -march).\n-   --with-float is ignored if -mhard-float or -msoft-float are\n-    specified.  */\n+   --with-float is ignored if -mhard-float, -msoft-float or -mfloat-abi are\n+   specified.\n+   --with-fpu is ignored if -mfpu is specified.  */\n #define OPTION_DEFAULT_SPECS \\\n   {\"arch\", \"%{!march=*:%{!mcpu=*:-march=%(VALUE)}}\" }, \\\n   {\"cpu\", \"%{!march=*:%{!mcpu=*:-mcpu=%(VALUE)}}\" }, \\\n   {\"tune\", \"%{!mcpu=*:%{!mtune=*:-mtune=%(VALUE)}}\" }, \\\n-  {\"float\", \"%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}\" }\n+  {\"float\", \\\n+    \"%{!msoft-float:%{!mhard-float:%{!mfloat-abi=*:-mfloat-abi=%(VALUE)}}}\" }, \\\n+  {\"fpu\", \"%{!mfpu=*:-mfpu=%(VALUE)}\"},\n \n struct arm_cpu_select\n {\n@@ -576,20 +620,36 @@ enum prog_mode_type\n \n extern enum prog_mode_type arm_prgmode;\n \n-/* What sort of floating point unit do we have? Hardware or software.\n-   If software, is it issue 2 or issue 3?  */\n+/* Which floating point model to use.  */\n+enum arm_fp_model\n+{\n+  ARM_FP_MODEL_UNKNOWN,\n+  /* FPA model (Hardware or software).  */\n+  ARM_FP_MODEL_FPA,\n+  /* Cirrus Maverick floating point model.  */\n+  ARM_FP_MODEL_MAVERICK,\n+  /* VFP floating point model.  */\n+  ARM_FP_MODEL_VFP\n+};\n+\n+extern enum arm_fp_model arm_fp_model;\n+\n+/* Which floating point hardware is available.  Also update\n+   fp_model_for_fpu in arm.c when adding entries to this list.  */\n enum fputype\n {\n-  /* Software floating point, FPA style double fmt.  */\n-  FPUTYPE_SOFT_FPA,\n+  /* No FP hardware.  */\n+  FPUTYPE_NONE,\n   /* Full FPA support.  */\n   FPUTYPE_FPA,\n   /* Emulated FPA hardware, Issue 2 emulator (no LFM/SFM).  */\n   FPUTYPE_FPA_EMU2,\n   /* Emulated FPA hardware, Issue 3 emulator.  */\n   FPUTYPE_FPA_EMU3,\n   /* Cirrus Maverick floating point co-processor.  */\n-  FPUTYPE_MAVERICK\n+  FPUTYPE_MAVERICK,\n+  /* VFP.  */\n+  FPUTYPE_VFP\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n@@ -601,8 +661,21 @@ extern enum fputype arm_fpu_tune;\n /* What type of floating point instructions are available */\n extern enum fputype arm_fpu_arch;\n \n+enum float_abi_type\n+{\n+  ARM_FLOAT_ABI_SOFT,\n+  ARM_FLOAT_ABI_SOFTFP,\n+  ARM_FLOAT_ABI_HARD\n+};\n+\n+extern enum float_abi_type arm_float_abi;\n+\n /* Default floating point architecture.  Override in sub-target if\n-   necessary.  */\n+   necessary.\n+   FIXME: Is this still neccessary/desirable?  Do we want VFP chips to\n+   default to VFP unless overridden by a subtarget?  If so it would be best\n+   to remove these definitions.  It also assumes there is only one cpu model\n+   with a Maverick fpu.  */\n #ifndef FPUTYPE_DEFAULT\n #define FPUTYPE_DEFAULT FPUTYPE_FPA_EMU2\n #endif\n@@ -612,19 +685,21 @@ extern enum fputype arm_fpu_arch;\n #define FPUTYPE_DEFAULT FPUTYPE_MAVERICK\n #endif\n \n-/* Nonzero if the processor has a fast multiply insn, and one that does\n-   a 64-bit multiply of two 32-bit values.  */\n-extern int arm_fast_multiply;\n+/* Nonzero if this chip supports the ARM Architecture 3M extensions.  */\n+extern int arm_arch3m;\n \n-/* Nonzero if this chip supports the ARM Architecture 4 extensions */\n+/* Nonzero if this chip supports the ARM Architecture 4 extensions.  */\n extern int arm_arch4;\n \n-/* Nonzero if this chip supports the ARM Architecture 5 extensions */\n+/* Nonzero if this chip supports the ARM Architecture 5 extensions.  */\n extern int arm_arch5;\n \n-/* Nonzero if this chip supports the ARM Architecture 5E extensions */\n+/* Nonzero if this chip supports the ARM Architecture 5E extensions.  */\n extern int arm_arch5e;\n \n+/* Nonzero if this chip supports the ARM Architecture 6 extensions.  */\n+extern int arm_arch6;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n extern int arm_ld_sched;\n \n@@ -871,6 +946,11 @@ extern const char * structure_size_string;\n \tmvf1-mvf3\tCirrus floating point scratch\n \tmvf4-mvf15   S\tCirrus floating point variable.  */\n \n+/*\ts0-s15\t\tVFP scratch (aka d0-d7).\n+\ts16-s31\t      S\tVFP variable (aka d8-d15).\n+\tvfpcc\t\tNot a real register.  Represents the VFP condition\n+\t\t\tcode flags.  */\n+\n /* The stack backtrace structure is as follows:\n   fp points to here:  |  save code pointer  |      [fp]\n                       |  return link value  |      [fp, #-4]\n@@ -895,17 +975,22 @@ extern const char * structure_size_string;\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n-#define FIXED_REGISTERS  \\\n-{                        \\\n-  0,0,0,0,0,0,0,0,\t \\\n-  0,0,0,0,0,1,0,1,\t \\\n-  0,0,0,0,0,0,0,0,\t \\\n+#define FIXED_REGISTERS \\\n+{                       \\\n+  0,0,0,0,0,0,0,0,\t\\\n+  0,0,0,0,0,1,0,1,\t\\\n+  0,0,0,0,0,0,0,0,\t\\\n   1,1,1,\t\t\\\n   1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1,\t \\\n-  1,1,1,1,1,1,1,1,\t \\\n-  1,1,1,1,1,1,1,1,\t \\\n-  1,1,1,1\t\t \\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,\t\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1,1,1,1,1,1,1,1,\t\\\n+  1\t\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -926,7 +1011,12 @@ extern const char * structure_size_string;\n   1,1,1,1,1,1,1,1,\t     \\\n   1,1,1,1,1,1,1,1,\t     \\\n   1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1\t\t     \\\n+  1,1,1,1,\t\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1\t\t\t     \\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -937,10 +1027,10 @@ extern const char * structure_size_string;\n {\t\t\t\t\t\t\t\t\\\n   int regno;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-  if (TARGET_SOFT_FLOAT || TARGET_THUMB)\t\t\t\\\n+  if (TARGET_SOFT_FLOAT || TARGET_THUMB || !TARGET_FPA)\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      for (regno = FIRST_ARM_FP_REGNUM;\t\t\t\t\\\n-\t   regno <= LAST_ARM_FP_REGNUM; ++regno)\t\t\\\n+      for (regno = FIRST_FPA_REGNUM;\t\t\t\t\\\n+\t   regno <= LAST_FPA_REGNUM; ++regno)\t\t\t\\\n \tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n@@ -960,16 +1050,28 @@ extern const char * structure_size_string;\n   if (TARGET_THUMB)\t\t\t\t\t\t\\\n     fixed_regs[LR_REGNUM] = call_used_regs[LR_REGNUM] = 1;\t\\\n \t\t\t\t\t\t\t\t\\\n-  if (TARGET_CIRRUS)\t\t\t\t\t\t\\\n+  if (TARGET_ARM && TARGET_HARD_FLOAT)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      for (regno = FIRST_ARM_FP_REGNUM;\t\t\t\t\\\n-\t   regno <= LAST_ARM_FP_REGNUM; ++ regno)\t\t\\\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      for (regno = FIRST_CIRRUS_FP_REGNUM;\t\t\t\\\n-\t   regno <= LAST_CIRRUS_FP_REGNUM; ++ regno)\t\t\\\n+      if (TARGET_MAVERICK)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  fixed_regs[regno] = 0;\t\t\t\t\\\n-\t  call_used_regs[regno] = regno < FIRST_CIRRUS_FP_REGNUM + 4; \\\n+\t  for (regno = FIRST_FPA_REGNUM;\t\t\t\\\n+\t       regno <= LAST_FPA_REGNUM; ++ regno)\t\t\\\n+\t    fixed_regs[regno] = call_used_regs[regno] = 1;\t\\\n+\t  for (regno = FIRST_CIRRUS_FP_REGNUM;\t\t\t\\\n+\t       regno <= LAST_CIRRUS_FP_REGNUM; ++ regno)\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      fixed_regs[regno] = 0;\t\t\t\t\\\n+\t      call_used_regs[regno] = regno < FIRST_CIRRUS_FP_REGNUM + 4; \\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      if (TARGET_VFP)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  for (regno = FIRST_VFP_REGNUM;\t\t\t\\\n+\t       regno <= LAST_VFP_REGNUM; ++ regno)\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      fixed_regs[regno] = 0;\t\t\t\t\\\n+\t      call_used_regs[regno] = regno < FIRST_VFP_REGNUM + 16; \\\n+\t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n@@ -1031,7 +1133,8 @@ extern const char * structure_size_string;\n /* Convert fron bytes to ints.  */\n #define ARM_NUM_INTS(X) (((X) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* The number of (integer) registers required to hold a quantity of type MODE.  */\n+/* The number of (integer) registers required to hold a quantity of type MODE.\n+   Also used for VFP registers.  */\n #define ARM_NUM_REGS(MODE)\t\t\t\t\\\n   ARM_NUM_INTS (GET_MODE_SIZE (MODE))\n \n@@ -1096,8 +1199,8 @@ extern const char * structure_size_string;\n #define STACK_POINTER_REGNUM\tSP_REGNUM\n \n /* ARM floating pointer registers.  */\n-#define FIRST_ARM_FP_REGNUM \t16\n-#define LAST_ARM_FP_REGNUM  \t23\n+#define FIRST_FPA_REGNUM \t16\n+#define LAST_FPA_REGNUM  \t23\n \n #define FIRST_IWMMXT_GR_REGNUM\t43\n #define LAST_IWMMXT_GR_REGNUM\t46\n@@ -1119,10 +1222,16 @@ extern const char * structure_size_string;\n #define IS_CIRRUS_REGNUM(REGNUM) \\\n   (((REGNUM) >= FIRST_CIRRUS_FP_REGNUM) && ((REGNUM) <= LAST_CIRRUS_FP_REGNUM))\n \n+#define FIRST_VFP_REGNUM\t63\n+#define LAST_VFP_REGNUM\t\t94\n+#define IS_VFP_REGNUM(REGNUM) \\\n+  (((REGNUM) >= FIRST_VFP_REGNUM) && ((REGNUM) <= LAST_VFP_REGNUM))\n+\n /* The number of hard registers is 16 ARM + 8 FPA + 1 CC + 1 SFP + 1 AFP.  */\n /* + 16 Cirrus registers take us up to 43.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n-#define FIRST_PSEUDO_REGISTER   63\n+/* VFP adds 32 + 1 more.  */\n+#define FIRST_PSEUDO_REGISTER   96\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n@@ -1143,9 +1252,10 @@ extern const char * structure_size_string;\n    mode.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)  \t\\\n   ((TARGET_ARM \t\t\t\t\\\n-    && REGNO >= FIRST_ARM_FP_REGNUM\t\\\n+    && REGNO >= FIRST_FPA_REGNUM\t\\\n     && REGNO != FRAME_POINTER_REGNUM\t\\\n     && REGNO != ARG_POINTER_REGNUM)\t\\\n+    && !IS_VFP_REGNUM (REGNO)\t\t\\\n    ? 1 : ARM_NUM_REGS (MODE))\n \n /* Return true if REGNO is suitable for holding a quantity of type MODE.  */\n@@ -1171,6 +1281,7 @@ extern const char * structure_size_string;\n    clobber it anyway.  Allocate r0 through r3 in reverse order since r3 is \n    least likely to contain a function parameter; in addition results are\n    returned in r0.  */\n+\n #define REG_ALLOC_ORDER  \t    \\\n {                                   \\\n      3,  2,  1,  0, 12, 14,  4,  5, \\\n@@ -1181,7 +1292,12 @@ extern const char * structure_size_string;\n     43, 44, 45, 46, 47, 48, 49, 50, \\\n     51, 52, 53, 54, 55, 56, 57, 58, \\\n     59, 60, 61, 62,\t\t    \\\n-    24, 25, 26\t\t\t    \\\n+    24, 25, 26,\t\t\t    \\\n+    78, 77, 76, 75, 74, 73, 72, 71, \\\n+    70, 69, 68, 67, 66, 65, 64, 63, \\\n+    79, 80, 81, 82, 83, 84, 85, 86, \\\n+    87, 88, 89, 90, 91, 92, 93, 94, \\\n+    95\t\t\t\t    \\\n }\n \n /* Interrupt functions can only use registers that have already been\n@@ -1200,13 +1316,15 @@ enum reg_class\n   NO_REGS,\n   FPA_REGS,\n   CIRRUS_REGS,\n+  VFP_REGS,\n   IWMMXT_GR_REGS,\n   IWMMXT_REGS,\n   LO_REGS,\n   STACK_REG,\n   BASE_REGS,\n   HI_REGS,\n   CC_REG,\n+  VFPCC_REG,\n   GENERAL_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -1220,34 +1338,38 @@ enum reg_class\n   \"NO_REGS\",\t\t\\\n   \"FPA_REGS\",\t\t\\\n   \"CIRRUS_REGS\",\t\\\n+  \"VFP_REGS\",\t\t\\\n   \"IWMMXT_GR_REGS\",\t\\\n   \"IWMMXT_REGS\",\t\\\n   \"LO_REGS\",\t\t\\\n   \"STACK_REG\",\t\t\\\n   \"BASE_REGS\",\t\t\\\n   \"HI_REGS\",\t\t\\\n   \"CC_REG\",\t\t\\\n+  \"VFPCC_REG\"\t\t\\\n   \"GENERAL_REGS\",\t\\\n   \"ALL_REGS\",\t\t\\\n }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n-#define REG_CLASS_CONTENTS  \t\t\\\n-{\t\t\t\t\t\\\n-  { 0x00000000, 0x0 },        /* NO_REGS  */\t\\\n-  { 0x00FF0000, 0x0 },        /* FPA_REGS */\t\\\n-  { 0xF8000000, 0x000007FF }, /* CIRRUS_REGS */\t\\\n-  { 0x00000000, 0x00007800 }, /* IWMMXT_GR_REGS */\\\n-  { 0x00000000, 0x7FFF8000 }, /* IWMMXT_REGS */\t\\\n-  { 0x000000FF, 0x0 },        /* LO_REGS */\t\\\n-  { 0x00002000, 0x0 },        /* STACK_REG */\t\\\n-  { 0x000020FF, 0x0 },        /* BASE_REGS */\t\\\n-  { 0x0000FF00, 0x0 },        /* HI_REGS */\t\\\n-  { 0x01000000, 0x0 },        /* CC_REG */\t\\\n-  { 0x0200FFFF, 0x0 },        /* GENERAL_REGS */\\\n-  { 0xFAFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS  */\t\\\n+  { 0x00FF0000, 0x00000000, 0x00000000 }, /* FPA_REGS */\t\\\n+  { 0xF8000000, 0x000007FF, 0x00000000 }, /* CIRRUS_REGS */\t\\\n+  { 0x00000000, 0x80000000, 0x7FFFFFFF }, /* VFP_REGS  */\t\\\n+  { 0x00000000, 0x00007800, 0x00000000 }, /* IWMMXT_GR_REGS */\t\\\n+  { 0x00000000, 0x7FFF8000, 0x00000000 }, /* IWMMXT_REGS */\t\\\n+  { 0x000000FF, 0x00000000, 0x00000000 }, /* LO_REGS */\t\t\\\n+  { 0x00002000, 0x00000000, 0x00000000 }, /* STACK_REG */\t\\\n+  { 0x000020FF, 0x00000000, 0x00000000 }, /* BASE_REGS */\t\\\n+  { 0x0000FF00, 0x00000000, 0x00000000 }, /* HI_REGS */\t\t\\\n+  { 0x01000000, 0x00000000, 0x00000000 }, /* CC_REG */\t\t\\\n+  { 0x00000000, 0x00000000, 0x80000000 }, /* VFPCC_REG */\t\\\n+  { 0x0200FFFF, 0x00000000, 0x00000000 }, /* GENERAL_REGS */\t\\\n+  { 0xFAFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */\t\\\n }\n \n /* The same information, inverted:\n@@ -1256,11 +1378,14 @@ enum reg_class\n    or could index an array.  */\n #define REGNO_REG_CLASS(REGNO)  arm_regno_class (REGNO)\n \n-/* FPA registers can't do dubreg as all values are reformatted to internal\n-   precision.  */\n+/* FPA registers can't do subreg as all values are reformatted to internal\n+   precision.  VFP registers may only be accesed in the mode they\n+   were set.  */\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\\\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\\\n-   ? reg_classes_intersect_p (FPA_REGS, (CLASS)) : 0)\n+   ? reg_classes_intersect_p (FPA_REGS, (CLASS))\t\\\n+     || reg_classes_intersect_p (VFP_REGS, (CLASS))\t\\\n+   : 0)\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  (TARGET_THUMB ? LO_REGS : GENERAL_REGS)\n@@ -1287,6 +1412,7 @@ enum reg_class\n #define REG_CLASS_FROM_LETTER(C)  \t\\\n   (  (C) == 'f' ? FPA_REGS\t\t\\\n    : (C) == 'v' ? CIRRUS_REGS\t\t\\\n+   : (C) == 'w' ? VFP_REGS\t\t\\\n    : (C) == 'y' ? IWMMXT_REGS\t\t\\\n    : (C) == 'z' ? IWMMXT_GR_REGS\t\\\n    : (C) == 'l' ? (TARGET_ARM ? GENERAL_REGS : LO_REGS)\t\\\n@@ -1331,10 +1457,10 @@ enum reg_class\n   (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n    CONST_OK_FOR_ARM_LETTER (VALUE, C) : CONST_OK_FOR_THUMB_LETTER (VALUE, C))\n      \n-/* Constant letter 'G' for the FPA immediate constants. \n+/* Constant letter 'G' for the FP immediate constants.\n    'H' means the same constant negated.  */\n #define CONST_DOUBLE_OK_FOR_ARM_LETTER(X, C)\t\t\t\\\n-    ((C) == 'G' ? const_double_rtx_ok_for_fpa (X) :\t\t\\\n+    ((C) == 'G' ? arm_const_double_rtx (X) :\t\t\t\\\n      (C) == 'H' ? neg_const_double_rtx_ok_for_fpa (X) : 0)\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(X, C)\t\t\t\\\n@@ -1345,7 +1471,8 @@ enum reg_class\n    an offset from a register.  \n    `S' means any symbol that has the SYMBOL_REF_FLAG set or a CONSTANT_POOL\n    address.  This means that the symbol is in the text segment and can be\n-   accessed without using a load.  */\n+   accessed without using a load.\n+   'U' is an address valid for VFP load/store insns.  */\n \n #define EXTRA_CONSTRAINT_ARM(OP, C)\t\t\t\t\t    \\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG :    \\\n@@ -1354,6 +1481,7 @@ enum reg_class\n \t\t && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0))) :\t\t    \\\n    (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP)) :\t\t    \\\n    (C) == 'T' ? cirrus_memory_offset (OP) : \t\t    \t\t    \\\n+   (C) == 'U' ? vfp_mem_operand (OP) :\t\t\t\t\t    \\\n    0)\n \n #define EXTRA_CONSTRAINT_THUMB(X, C)\t\t\t\t\t\\\n@@ -1364,6 +1492,8 @@ enum reg_class\n   (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n    EXTRA_CONSTRAINT_ARM (X, C) : EXTRA_CONSTRAINT_THUMB (X, C))\n \n+#define EXTRA_MEMORY_CONSTRAINT(C, STR) ((C) == 'U')\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS, but for the Thumb we prefer\n@@ -1391,15 +1521,23 @@ enum reg_class\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n-  (TARGET_ARM ?\t\t\t\t\t\t\t\\\n-   (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1)\t\\\n+  /* Restrict which direct reloads are allowed for VFP regs.  */ \\\n+  ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n+    && (CLASS) == VFP_REGS)\t\t\t\t\t\\\n+   ? vfp_secondary_reload_class (MODE, X)\t\t\t\\\n+   : TARGET_ARM\t\t\t\t\t\t\t\\\n+   ? (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1) \\\n     ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n    : THUMB_SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X))\n    \n /* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  /* Restrict which direct reloads are allowed for VFP regs.  */ \\\n+  ((TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\t\\\n+    && (CLASS) == VFP_REGS)\t\t\t\t\t\\\n+    ? vfp_secondary_reload_class (MODE, X) :\t\t\t\\\n   /* Cannot load constants into Cirrus registers.  */\t\t\\\n-  ((TARGET_CIRRUS\t\t\t\t\t\t\\\n+   (TARGET_MAVERICK && TARGET_HARD_FLOAT\t\t\t\\\n      && (CLASS) == CIRRUS_REGS\t\t\t\t\t\\\n      && (CONSTANT_P (X) || GET_CODE (X) == SYMBOL_REF))\t\t\\\n     ? GENERAL_REGS :\t\t\t\t\t\t\\\n@@ -1433,21 +1571,22 @@ enum reg_class\n \t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t   \\\n \t  HOST_WIDE_INT low, high;\t\t\t\t\t   \\\n \t\t\t\t\t\t\t\t\t   \\\n-\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t   \\\n+\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && TARGET_FPA\t   \\\n+\t\t                 && MODE == DFmode))\t\t\t   \\\n \t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t   \\\n-\t  else if (TARGET_CIRRUS)\t\t\t\t\t   \\\n+\t  else if (TARGET_MAVERICK && TARGET_HARD_FLOAT)\t\t   \\\n \t    /* Need to be careful, -256 is not a valid offset.  */\t   \\\n \t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t   \\\n \t  else if (MODE == SImode\t\t\t\t\t   \\\n-\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t   \\\n+\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT && TARGET_FPA)  \\\n \t\t   || ((MODE == HImode || MODE == QImode) && ! arm_arch4)) \\\n \t    /* Need to be careful, -4096 is not a valid offset.  */\t   \\\n \t    low = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t   \\\n \t  else if ((MODE == HImode || MODE == QImode) && arm_arch4)\t   \\\n \t    /* Need to be careful, -256 is not a valid offset.  */\t   \\\n \t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t   \\\n \t  else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t   \\\n-\t\t   && TARGET_HARD_FLOAT)\t\t\t\t   \\\n+\t\t   && TARGET_HARD_FLOAT && TARGET_FPA)\t\t\t   \\\n \t    /* Need to be careful, -1024 is not a valid offset.  */\t   \\\n \t    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t   \\\n \t  else\t\t\t\t\t\t\t\t   \\\n@@ -1520,6 +1659,8 @@ enum reg_class\n   (TARGET_ARM ?\t\t\t\t\t\t\\\n    ((FROM) == FPA_REGS && (TO) != FPA_REGS ? 20 :\t\\\n     (FROM) != FPA_REGS && (TO) == FPA_REGS ? 20 :\t\\\n+    (FROM) == VFP_REGS && (TO) != VFP_REGS ? 10 :  \\\n+    (FROM) != VFP_REGS && (TO) == VFP_REGS ? 10 :  \\\n     (FROM) == IWMMXT_REGS && (TO) != IWMMXT_REGS ? 4 :  \\\n     (FROM) != IWMMXT_REGS && (TO) == IWMMXT_REGS ? 4 :  \\\n     (FROM) == IWMMXT_GR_REGS || (TO) == IWMMXT_GR_REGS ? 20 :  \\\n@@ -1575,9 +1716,11 @@ enum reg_class\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE)  \\\n-  (TARGET_ARM && TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n-   ? gen_rtx_REG (MODE, FIRST_ARM_FP_REGNUM) \\\n-   : TARGET_ARM && TARGET_CIRRUS && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+  (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\t\t\t\\\n+   && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+   ? gen_rtx_REG (MODE, FIRST_FPA_REGNUM)\t\t\t\t\\\n+   : TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\t\t\t\\\n+     && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n    ? gen_rtx_REG (MODE, FIRST_CIRRUS_FP_REGNUM) \t\t\t\\\n    : TARGET_REALLY_IWMMXT && VECTOR_MODE_SUPPORTED_P (MODE)\t\t\\\n    ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) \t\t\t\t\\\n@@ -1595,9 +1738,11 @@ enum reg_class\n /* On a Cirrus chip, mvf0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n   ((REGNO) == ARG_REGISTER (1) \\\n-   || (TARGET_ARM && ((REGNO) == FIRST_CIRRUS_FP_REGNUM) && TARGET_CIRRUS) \\\n+   || (TARGET_ARM && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)\t\t\\\n+       && TARGET_HARD_FLOAT && TARGET_MAVERICK)\t\t\t\t\\\n    || (TARGET_ARM && ((REGNO) == FIRST_IWMMXT_REGNUM) && TARGET_IWMMXT) \\\n-   || (TARGET_ARM && ((REGNO) == FIRST_ARM_FP_REGNUM) && TARGET_HARD_FLOAT))\n+   || (TARGET_ARM && ((REGNO) == FIRST_FPA_REGNUM)\t\t\t\\\n+       && TARGET_HARD_FLOAT && TARGET_FPA))\n \n /* How large values are returned */\n /* A C expression which can inhibit the returning of certain function values\n@@ -2081,6 +2226,7 @@ typedef struct\n #define THUMB_LEGITIMATE_CONSTANT_P(X)\t\\\n  (   GET_CODE (X) == CONST_INT\t\t\\\n   || GET_CODE (X) == CONST_DOUBLE\t\\\n+  || GET_CODE (X) == CONSTANT_P_RTX     \\\n   || CONSTANT_ADDRESS_P (X)\t\t\\\n   || flag_pic)\n \n@@ -2433,10 +2579,11 @@ extern int making_const_table;\n     {\t\t\t\t\t\t\t\\\n       if (TARGET_THUMB) \t\t\t\t\\\n         {\t\t\t\t\t\t\\\n-          if (is_called_in_ARM_mode (DECL))\t\t\\\n+          if (is_called_in_ARM_mode (DECL)      \\\n+\t\t\t  || current_function_is_thunk)\t\t\\\n             fprintf (STREAM, \"\\t.code 32\\n\") ;\t\t\\\n           else\t\t\t\t\t\t\\\n-           fprintf (STREAM, \"\\t.thumb_func\\n\") ;\t\\\n+           fprintf (STREAM, \"\\t.code 16\\n\\t.thumb_func\\n\") ;\t\\\n         }\t\t\t\t\t\t\\\n       if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n         arm_poke_function_name (STREAM, (char *) NAME);\t\\\n@@ -2665,12 +2812,13 @@ extern int making_const_table;\n /* Define the codes that are matched by predicates in arm.c */\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"s_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"arm_general_register_operand\", {SUBREG, REG}},\t\t\t\\\n   {\"arm_hard_register_operand\", {REG}},\t\t\t\t\t\\\n   {\"f_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"arm_add_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"arm_addimm_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"fpa_add_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"fpa_rhs_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"arm_float_add_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n+  {\"arm_float_rhs_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n   {\"arm_rhs_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"arm_not_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"reg_or_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n@@ -2702,7 +2850,9 @@ extern int making_const_table;\n   {\"cirrus_register_operand\", {REG}},\t\t\t\t\t\\\n   {\"cirrus_fp_register\", {REG}},\t\t\t\t\t\\\n   {\"cirrus_shift_const\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"dominant_cc_register\", {REG}},\n+  {\"dominant_cc_register\", {REG}},\t\t\t\t\t\\\n+  {\"arm_float_compare_operand\", {REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"vfp_compare_operand\", {REG, CONST_DOUBLE}},\n \n /* Define this if you have special predicates that know special things\n    about modes.  Genrecog will warn about certain forms of"}, {"sha": "cafac0b58e47d65e3ba88a1acf9062ff8ce2532d", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 808, "deletions": 471, "changes": 1279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -145,7 +145,7 @@\n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n ; performance we should try and group them together).\n-(define_attr \"fpu\" \"softfpa,fpa,fpe2,fpe3,maverick\"\n+(define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp\"\n   (const (symbol_ref \"arm_fpu_attr\")))\n \n ; LENGTH of an instruction (in bytes)\n@@ -167,13 +167,26 @@\n   (set_attr \"length\" \"4\")\n   (set_attr \"pool_range\" \"250\")])\n \n+;; The instruction used to implement a particular pattern.  This\n+;; information is used by pipeline descriptions to provide accurate\n+;; scheduling information.\n+\n+(define_attr \"insn\"\n+        \"smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals,smlawy,smuad,smuadx,smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,other\"\n+        (const_string \"other\"))\n+\n ; TYPE attribute is used to detect floating point instructions which, if\n ; running on a co-processor can run in parallel with other, basic instructions\n ; If write-buffer scheduling is enabled then it can also be used in the\n ; scheduling of writes.\n \n ; Classification of each insn\n-; normal\tany data instruction that doesn't hit memory or fp regs\n+; alu\t\tany alu  instruction that doesn't hit memory or fp\n+;\t\tregs or have a shifted source operand\n+; alu_shift\tany data instruction that doesn't hit memory or fp\n+;\t\tregs, but has a source operand shifted by a constant\n+; alu_shift_reg\tany data instruction that doesn't hit memory or fp\n+;\t\tregs, but has a source operand shifted by a register value\n ; mult\t\ta multiply instruction\n ; block\t\tblockage insn, this blocks all functional units\n ; float\t\ta floating point arithmetic operation (subject to expansion)\n@@ -191,19 +204,27 @@\n ; r_mem_f\tthe reverse of f_mem_r\n ; f_2_r\t\tfast transfer float to arm (no memory needed)\n ; r_2_f\t\tfast transfer arm to float\n+; branch\ta branch\n ; call\t\ta subroutine call\n-; load\t\tany load from memory\n-; store1\tstore 1 word to memory from arm registers\n+; load_byte\tload byte(s) from memory to arm registers\n+; load1\t\tload 1 word from memory to arm registers\n+; load2         load 2 words from memory to arm registers\n+; load3         load 3 words from memory to arm registers\n+; load4         load 4 words from memory to arm registers\n+; store\t\tstore 1 word to memory from arm registers\n ; store2\tstore 2 words\n ; store3\tstore 3 words\n-; store4\tstore 4 words\n+; store4\tstore 4 (or more) words\n ;  Additions for Cirrus Maverick co-processor:\n ; mav_farith\tFloating point arithmetic (4 cycle)\n ; mav_dmult\tDouble multiplies (7 cycle)\n ;\n (define_attr \"type\"\n-\t\"normal,mult,block,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith,float_em,f_load,f_store,f_mem_r,r_mem_f,f_2_r,r_2_f,call,load,store1,store2,store3,store4,mav_farith,mav_dmult\" \n-\t(const_string \"normal\"))\n+\t\"alu,alu_shift,alu_shift_reg,mult,block,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith,float_em,f_load,f_store,f_mem_r,r_mem_f,f_2_r,r_2_f,branch,call,load_byte,load1,load2,load3,load4,store1,store2,store3,store4,mav_farith,mav_dmult\" \n+\t(if_then_else \n+\t (eq_attr \"insn\" \"smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals\")\n+\t (const_string \"mult\")\n+\t (const_string \"alu\")))\n \n ; Load scheduling, set from the arm_ld_sched variable\n ; initialized by arm_override_options() \n@@ -251,131 +272,43 @@\n ; to stall the processor.  Used with model_wbuf above.\n (define_attr \"write_conflict\" \"no,yes\"\n   (if_then_else (eq_attr \"type\"\n-\t\t \"block,float_em,f_load,f_store,f_mem_r,r_mem_f,call,load\")\n+\t\t \"block,float_em,f_load,f_store,f_mem_r,r_mem_f,call,load1\")\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n ; Classify the insns into those that take one cycle and those that take more\n ; than one on the main cpu execution unit.\n (define_attr \"core_cycles\" \"single,multi\"\n   (if_then_else (eq_attr \"type\"\n-\t\t \"normal,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith\")\n+\t\t \"alu,alu_shift,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith\")\n \t\t(const_string \"single\")\n \t        (const_string \"multi\")))\n \n ;; FAR_JUMP is \"yes\" if a BL instruction is used to generate a branch to a\n ;; distant label.  Only applicable to Thumb code.\n (define_attr \"far_jump\" \"yes,no\" (const_string \"no\"))\n \n-(define_automaton \"arm\")\n+;;---------------------------------------------------------------------------\n+;; Pipeline descriptions\n \n-;; Write buffer\n-;\n-; Strictly, we should model a 4-deep write buffer for ARM7xx based chips\n-;\n-; The write buffer on some of the arm6 processors is hard to model exactly.\n-; There is room in the buffer for up to two addresses and up to eight words\n-; of memory, but the two needn't be split evenly.  When writing the two\n-; addresses are fully pipelined.  However, a read from memory that is not\n-; currently in the cache will block until the writes have completed.\n-; It is normally the case that FCLK and MCLK will be in the ratio 2:1, so\n-; writes will take 2 FCLK cycles per word, if FCLK and MCLK are asynchronous\n-; (they aren't allowed to be at present) then there is a startup cost of 1MCLK\n-; cycle to add as well.\n-(define_cpu_unit \"write_buf\" \"arm\")\n-\n-;; Write blockage unit\n-;\n-; The write_blockage unit models (partially), the fact that reads will stall\n-; until the write buffer empties.\n-; The f_mem_r and r_mem_f could also block, but they are to the stack,\n-; so we don't model them here\n-(define_cpu_unit \"write_blockage\" \"arm\")\n+;; Processor type.  This attribute must exactly match the table in \n+;; arm-cores.def.\n+(define_attr \"tune\" \n+\t     \"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7m,arm7d,arm7dm,arm7di,arm7dmi,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7tdmi,arm710t,arm720t,arm740t,arm8,arm810,arm9,arm920,arm920t,arm940t,arm9tdmi,arm9e,ep9312,strongarm,strongarm110,strongarm1100,strongarm1110,arm10tdmi,arm1020t,arm926ejs,arm1026ejs,xscale,iwmmxt,arm1136js,arm1136jfs\"\n+\t     (const (symbol_ref \"arm_tune\")))\n \n-;; Core\n-;\n-(define_cpu_unit \"core\" \"arm\")\n-\n-(define_insn_reservation \"r_mem_f_wbuf\" 5\n-  (and (eq_attr \"model_wbuf\" \"yes\")\n-       (eq_attr \"type\" \"r_mem_f\"))\n-  \"core+write_buf*3\")\n-\n-(define_insn_reservation \"store1_wbuf\" 5\n-  (and (eq_attr \"model_wbuf\" \"yes\")\n-       (eq_attr \"type\" \"store1\"))\n-  \"core+write_buf*3+write_blockage*5\")\n-\n-(define_insn_reservation \"store2_wbuf\" 7\n-  (and (eq_attr \"model_wbuf\" \"yes\")\n-       (eq_attr \"type\" \"store2\"))\n-  \"core+write_buf*4+write_blockage*7\")\n-\n-(define_insn_reservation \"store3_wbuf\" 9\n-  (and (eq_attr \"model_wbuf\" \"yes\")\n-       (eq_attr \"type\" \"store3\"))\n-  \"core+write_buf*5+write_blockage*9\")\n-\n-(define_insn_reservation \"store4_wbuf\" 11\n-  (and (eq_attr \"model_wbuf\" \"yes\")\n-       (eq_attr \"type\" \"store4\"))\n-  \"core+write_buf*6+write_blockage*11\")\n-\n-(define_insn_reservation \"store2\" 3\n-  (and (eq_attr \"model_wbuf\" \"no\")\n-       (eq_attr \"type\" \"store2\"))\n-  \"core*3\")\n-\n-(define_insn_reservation \"store3\" 4\n-  (and (eq_attr \"model_wbuf\" \"no\")\n-       (eq_attr \"type\" \"store3\"))\n-  \"core*4\")\n-\n-(define_insn_reservation \"store4\" 5\n-  (and (eq_attr \"model_wbuf\" \"no\")\n-       (eq_attr \"type\" \"store4\"))\n-  \"core*5\")\n-\n-(define_insn_reservation \"store1_ldsched\" 1\n-  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"store1\"))\n-  \"core\")\n-\n-(define_insn_reservation \"load_ldsched_xscale\" 3\n-  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\"))\n-       (eq_attr \"is_xscale\" \"yes\"))\n-  \"core\")\n-\n-(define_insn_reservation \"load_ldsched\" 2\n-  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\"))\n-       (eq_attr \"is_xscale\" \"no\"))\n-  \"core\")\n-\n-(define_insn_reservation \"load_or_store\" 2\n-  (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"load,store1\"))\n-  \"core*2\")\n-\n-(define_insn_reservation \"mult\" 16\n-  (and (eq_attr \"ldsched\" \"no\") (eq_attr \"type\" \"mult\"))\n-  \"core*16\")\n-\n-(define_insn_reservation \"mult_ldsched_strongarm\" 3\n-  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"is_strongarm\" \"yes\"))\n-       (eq_attr \"type\" \"mult\"))\n-  \"core*2\")\n-\n-(define_insn_reservation \"mult_ldsched\" 4\n-  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"is_strongarm\" \"no\"))\n-       (eq_attr \"type\" \"mult\"))\n-  \"core*4\")\n-\n-(define_insn_reservation \"multi_cycle\" 32\n-  (and (eq_attr \"core_cycles\" \"multi\")\n-       (eq_attr \"type\" \"!mult,load,store1,store2,store3,store4\"))\n-  \"core*32\")\n-\n-(define_insn_reservation \"single_cycle\" 1\n-  (eq_attr \"core_cycles\" \"single\")\n-  \"core\")\n+;; True if the generic scheduling description should be used.\n+\n+(define_attr \"generic_sched\" \"yes,no\"\n+        (if_then_else \n+         (eq_attr \"tune\" \"arm926ejs,arm1026ejs,arm1136js,arm1136jfs\") \n+         (const_string \"no\")\n+         (const_string \"yes\")))\n+\t\n+(include \"arm-generic.md\")\n+(include \"arm926ejs.md\")\n+(include \"arm1026ejs.md\")\n+(include \"arm1136jfs.md\")\n \n \f\n ;;---------------------------------------------------------------------------\n@@ -397,7 +330,7 @@\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_HARD_FLOAT && TARGET_MAVERICK)\n     {\n       if (!cirrus_fp_register (operands[0], DImode))\n         operands[0] = force_reg (DImode, operands[0]);\n@@ -433,7 +366,7 @@\n \t(plus:DI (match_operand:DI 1 \"s_register_operand\" \"%0, 0\")\n \t\t (match_operand:DI 2 \"s_register_operand\" \"r,  0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && !TARGET_CIRRUS\"\n+  \"TARGET_ARM && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\"\n   \"#\"\n   \"TARGET_ARM && reload_completed\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n@@ -461,7 +394,7 @@\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t (match_operand:DI 1 \"s_register_operand\" \"r,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && !TARGET_CIRRUS\"\n+  \"TARGET_ARM && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\"\n   \"#\"\n   \"TARGET_ARM && reload_completed\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n@@ -490,7 +423,7 @@\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t (match_operand:DI 1 \"s_register_operand\" \"r,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && !TARGET_CIRRUS\"\n+  \"TARGET_ARM && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\"\n   \"#\"\n   \"TARGET_ARM && reload_completed\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n@@ -801,7 +734,10 @@\n \t\t    (match_operand:SI 1 \"s_register_operand\" \"r\"))))]\n   \"TARGET_ARM\"\n   \"adc%?\\\\t%0, %1, %3%S2\"\n-  [(set_attr \"conds\" \"use\")]\n+  [(set_attr \"conds\" \"use\")\n+   (set (attr \"type\") (if_then_else (match_operand 4 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*addsi3_carryin_alt1\"\n@@ -864,21 +800,21 @@\n (define_expand \"addsf3\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"\")\n \t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"\")\n-\t\t (match_operand:SF 2 \"fpa_add_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+\t\t (match_operand:SF 2 \"arm_float_add_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS\n+  if (TARGET_MAVERICK\n       && !cirrus_fp_register (operands[2], SFmode))\n     operands[2] = force_reg (SFmode, operands[2]);\n \")\n \n (define_expand \"adddf3\"\n   [(set (match_operand:DF          0 \"s_register_operand\" \"\")\n \t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"\")\n-\t\t (match_operand:DF 2 \"fpa_add_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+\t\t (match_operand:DF 2 \"arm_float_add_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS\n+  if (TARGET_MAVERICK\n       && !cirrus_fp_register (operands[2], DFmode))\n     operands[2] = force_reg (DFmode, operands[2]);\n \")\n@@ -891,7 +827,7 @@\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n-  if (TARGET_CIRRUS\n+  if (TARGET_HARD_FLOAT && TARGET_MAVERICK\n       && TARGET_ARM\n       && cirrus_fp_register (operands[0], DImode)\n       && cirrus_fp_register (operands[1], DImode))\n@@ -1087,11 +1023,11 @@\n \n (define_expand \"subsf3\"\n   [(set (match_operand:SF           0 \"s_register_operand\" \"\")\n-\t(minus:SF (match_operand:SF 1 \"fpa_rhs_operand\" \"\")\n-\t\t  (match_operand:SF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+\t(minus:SF (match_operand:SF 1 \"arm_float_rhs_operand\" \"\")\n+\t\t  (match_operand:SF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     {\n       if (!cirrus_fp_register (operands[1], SFmode))\n         operands[1] = force_reg (SFmode, operands[1]);\n@@ -1102,11 +1038,11 @@\n \n (define_expand \"subdf3\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"\")\n-\t(minus:DF (match_operand:DF 1 \"fpa_rhs_operand\"     \"\")\n-\t\t  (match_operand:DF 2 \"fpa_rhs_operand\"    \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+\t(minus:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"\")\n+\t\t  (match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     {\n        if (!cirrus_fp_register (operands[1], DFmode))\n          operands[1] = force_reg (DFmode, operands[1]);\n@@ -1133,7 +1069,7 @@\n \t\t (match_operand:SI 1 \"s_register_operand\" \"%?r,0\")))]\n   \"TARGET_ARM\"\n   \"mul%?\\\\t%0, %2, %1\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"mul\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1154,7 +1090,7 @@\n     return \\\"mul\\\\t%0, %0, %2\\\";\n   \"\n   [(set_attr \"length\" \"4,4,2\")\n-   (set_attr \"type\" \"mult\")]\n+   (set_attr \"insn\" \"mul\")]\n )\n \n (define_insn \"*mulsi3_compare0\"\n@@ -1168,7 +1104,7 @@\n   \"TARGET_ARM && !arm_arch_xscale\"\n   \"mul%?s\\\\t%0, %2, %1\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"mult\")]\n+   (set_attr \"insn\" \"muls\")]\n )\n \n (define_insn \"*mulsi_compare0_scratch\"\n@@ -1181,7 +1117,7 @@\n   \"TARGET_ARM && !arm_arch_xscale\"\n   \"mul%?s\\\\t%0, %2, %1\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"mult\")]\n+   (set_attr \"insn\" \"muls\")]\n )\n \n ;; Unnamed templates to match MLA instruction.\n@@ -1194,7 +1130,7 @@\n \t  (match_operand:SI 3 \"s_register_operand\" \"?r,r,0,0\")))]\n   \"TARGET_ARM\"\n   \"mla%?\\\\t%0, %2, %1, %3\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"mla\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1212,7 +1148,7 @@\n   \"TARGET_ARM && !arm_arch_xscale\"\n   \"mla%?s\\\\t%0, %2, %1, %3\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"mult\")]\n+   (set_attr \"insn\" \"mlas\")]\n )\n \n (define_insn \"*mulsi3addsi_compare0_scratch\"\n@@ -1227,7 +1163,7 @@\n   \"TARGET_ARM && !arm_arch_xscale\"\n   \"mla%?s\\\\t%0, %2, %1, %3\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"mult\")]\n+   (set_attr \"insn\" \"mlas\")]\n )\n \n ;; Unnamed template to match long long multiply-accumulate (smlal)\n@@ -1239,9 +1175,9 @@\n \t  (sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"%r\"))\n \t  (sign_extend:DI (match_operand:SI 3 \"s_register_operand\" \"r\")))\n \t (match_operand:DI 1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_ARM && arm_fast_multiply\"\n+  \"TARGET_ARM && arm_arch3m\"\n   \"smlal%?\\\\t%Q0, %R0, %3, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smlal\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1250,9 +1186,9 @@\n \t(mult:DI\n \t (sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"%r\"))\n \t (sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"r\"))))]\n-  \"TARGET_ARM && arm_fast_multiply\"\n+  \"TARGET_ARM && arm_arch3m\"\n   \"smull%?\\\\t%Q0, %R0, %1, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smull\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1261,9 +1197,9 @@\n \t(mult:DI\n \t (zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"%r\"))\n \t (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"r\"))))]\n-  \"TARGET_ARM && arm_fast_multiply\"\n+  \"TARGET_ARM && arm_arch3m\"\n   \"umull%?\\\\t%Q0, %R0, %1, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"umull\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1276,9 +1212,9 @@\n \t  (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"%r\"))\n \t  (zero_extend:DI (match_operand:SI 3 \"s_register_operand\" \"r\")))\n \t (match_operand:DI 1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_ARM && arm_fast_multiply\"\n+  \"TARGET_ARM && arm_arch3m\"\n   \"umlal%?\\\\t%Q0, %R0, %3, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"umlal\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1291,9 +1227,9 @@\n \t   (sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=&r,&r\"))]\n-  \"TARGET_ARM && arm_fast_multiply\"\n+  \"TARGET_ARM && arm_arch3m\"\n   \"smull%?\\\\t%3, %0, %2, %1\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smull\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1306,9 +1242,9 @@\n \t   (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=&r,&r\"))]\n-  \"TARGET_ARM && arm_fast_multiply\"\n+  \"TARGET_ARM && arm_arch3m\"\n   \"umull%?\\\\t%3, %0, %2, %1\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"umull\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1320,7 +1256,7 @@\n \t\t  (match_operand:HI 2 \"s_register_operand\" \"r\"))))]\n   \"TARGET_ARM && arm_arch5e\"\n   \"smulbb%?\\\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smulxy\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1333,7 +1269,7 @@\n \t\t  (match_operand:HI 2 \"s_register_operand\" \"r\"))))]\n   \"TARGET_ARM && arm_arch5e\"\n   \"smultb%?\\\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smulxy\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1346,7 +1282,7 @@\n \t\t  (const_int 16))))]\n   \"TARGET_ARM && arm_arch5e\"\n   \"smulbt%?\\\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smulxy\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1360,7 +1296,7 @@\n \t\t  (const_int 16))))]\n   \"TARGET_ARM && arm_arch5e\"\n   \"smultt%?\\\\t%0, %1, %2\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smulxy\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1373,7 +1309,7 @@\n \t\t\t   (match_operand:HI 3 \"s_register_operand\" \"r\")))))]\n   \"TARGET_ARM && arm_arch5e\"\n   \"smlabb%?\\\\t%0, %2, %3, %1\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smlaxy\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -1387,27 +1323,27 @@\n \t\t    (match_operand:HI 3 \"s_register_operand\" \"r\")))))]\n   \"TARGET_ARM && arm_arch5e\"\n   \"smlalbb%?\\\\t%Q0, %R0, %2, %3\"\n-  [(set_attr \"type\" \"mult\")\n+  [(set_attr \"insn\" \"smlalxy\")\n    (set_attr \"predicable\" \"yes\")])\n \n (define_expand \"mulsf3\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"\")\n-\t\t (match_operand:SF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+\t\t (match_operand:SF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS\n+  if (TARGET_MAVERICK\n       && !cirrus_fp_register (operands[2], SFmode))\n     operands[2] = force_reg (SFmode, operands[2]);\n \")\n \n (define_expand \"muldf3\"\n   [(set (match_operand:DF          0 \"s_register_operand\" \"\")\n \t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"\")\n-\t\t (match_operand:DF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+\t\t (match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS\n+  if (TARGET_MAVERICK\n       && !cirrus_fp_register (operands[2], DFmode))\n     operands[2] = force_reg (DFmode, operands[2]);\n \")\n@@ -1416,32 +1352,32 @@\n \n (define_expand \"divsf3\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"\")\n-\t(div:SF (match_operand:SF 1 \"fpa_rhs_operand\" \"\")\n-\t\t(match_operand:SF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t(div:SF (match_operand:SF 1 \"arm_float_rhs_operand\" \"\")\n+\t\t(match_operand:SF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"\")\n \n (define_expand \"divdf3\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n-\t(div:DF (match_operand:DF 1 \"fpa_rhs_operand\" \"\")\n-\t\t(match_operand:DF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t(div:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"\")\n+\t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"\")\n \f\n ;; Modulo insns\n \n (define_expand \"modsf3\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"\")\n \t(mod:SF (match_operand:SF 1 \"s_register_operand\" \"\")\n-\t\t(match_operand:SF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t(match_operand:SF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"\")\n \n (define_expand \"moddf3\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n \t(mod:DF (match_operand:DF 1 \"s_register_operand\" \"\")\n-\t\t(match_operand:DF 2 \"fpa_rhs_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"\")\n \f\n ;; Boolean and,ior,xor insns\n@@ -2048,16 +1984,18 @@\n )\n \n (define_insn \"andsi_not_shiftsi_si\"\n-  [(set (match_operand:SI                   0 \"s_register_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operator:SI  4 \"shift_operator\"\n-\t\t\t [(match_operand:SI 2 \"s_register_operand\"  \"r\")\n-\t\t\t  (match_operand:SI 3 \"arm_rhs_operand\"     \"rM\")]))\n-\t\t(match_operand:SI           1 \"s_register_operand\"  \"r\")))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operator:SI 4 \"shift_operator\"\n+\t\t\t [(match_operand:SI 2 \"s_register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 3 \"arm_rhs_operand\" \"rM\")]))\n+\t\t(match_operand:SI 1 \"s_register_operand\" \"r\")))]\n   \"TARGET_ARM\"\n   \"bic%?\\\\t%0, %1, %2%S4\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"2\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 3 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*andsi_notsi_si_compare0\"\n@@ -2537,6 +2475,41 @@\n \f\n ;; Shift and rotation insns\n \n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI            0 \"s_register_operand\" \"\")\n+        (ashift:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n+                   (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n+  \"TARGET_ARM\"\n+  \"\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n+        {\n+          emit_insn (gen_arm_ashldi3_1bit (operands[0], operands[1]));\n+          DONE;\n+        }\n+        /* Ideally we shouldn't fail here if we could know that operands[1] \n+           ends up already living in an iwmmxt register. Otherwise it's\n+           cheaper to have the alternate code being generated than moving\n+           values to iwmmxt regs and back. */\n+        FAIL;\n+    }\n+  else if (!TARGET_REALLY_IWMMXT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK))\n+    FAIL;\n+  \"\n+)\n+\n+(define_insn \"arm_ashldi3_1bit\"\n+  [(set (match_operand:DI            0 \"s_register_operand\" \"=&r,r\")\n+        (ashift:DI (match_operand:DI 1 \"s_register_operand\" \"?r,0\")\n+                   (const_int 1)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\"\n+  \"movs\\\\t%Q0, %Q1, asl #1\\;adc\\\\t%R0, %R1, %R1\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI            0 \"s_register_operand\" \"\")\n \t(ashift:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -2561,6 +2534,41 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI              0 \"s_register_operand\" \"\")\n+        (ashiftrt:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n+                     (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n+  \"TARGET_ARM\"\n+  \"\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n+        {\n+          emit_insn (gen_arm_ashrdi3_1bit (operands[0], operands[1]));\n+          DONE;\n+        }\n+        /* Ideally we shouldn't fail here if we could know that operands[1] \n+           ends up already living in an iwmmxt register. Otherwise it's\n+           cheaper to have the alternate code being generated than moving\n+           values to iwmmxt regs and back. */\n+        FAIL;\n+    }\n+  else if (!TARGET_REALLY_IWMMXT)\n+    FAIL;\n+  \"\n+)\n+\n+(define_insn \"arm_ashrdi3_1bit\"\n+  [(set (match_operand:DI              0 \"s_register_operand\" \"=&r,r\")\n+        (ashiftrt:DI (match_operand:DI 1 \"s_register_operand\" \"?r,0\")\n+                     (const_int 1)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\"\n+  \"movs\\\\t%R0, %R1, asr #1\\;mov\\\\t%Q0, %Q1, rrx\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI              0 \"s_register_operand\" \"\")\n \t(ashiftrt:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -2582,6 +2590,41 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI              0 \"s_register_operand\" \"\")\n+        (lshiftrt:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n+                     (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n+  \"TARGET_ARM\"\n+  \"\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n+        {\n+          emit_insn (gen_arm_lshrdi3_1bit (operands[0], operands[1]));\n+          DONE;\n+        }\n+        /* Ideally we shouldn't fail here if we could know that operands[1] \n+           ends up already living in an iwmmxt register. Otherwise it's\n+           cheaper to have the alternate code being generated than moving\n+           values to iwmmxt regs and back. */\n+        FAIL;\n+    }\n+  else if (!TARGET_REALLY_IWMMXT)\n+    FAIL;\n+  \"\n+)\n+\n+(define_insn \"arm_lshrdi3_1bit\"\n+  [(set (match_operand:DI              0 \"s_register_operand\" \"=&r,r\")\n+        (lshiftrt:DI (match_operand:DI 1 \"s_register_operand\" \"?r,0\")\n+                     (const_int 1)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\"\n+  \"movs\\\\t%R0, %R1, lsr #1\\;mov\\\\t%Q0, %Q1, rrx\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI              0 \"s_register_operand\" \"\")\n \t(lshiftrt:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -2652,19 +2695,6 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n-(define_expand \"ashldi3\"\n-  [(set (match_operand:DI            0 \"s_register_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\"    \"\")\n-\t\t   (match_operand:SI 2 \"general_operand\"    \"\")))]\n-  \"TARGET_ARM && (TARGET_IWMMXT || TARGET_CIRRUS)\"\n-  \"\n-  if (! s_register_operand (operands[1], DImode))\n-    operands[1] = copy_to_mode_reg (DImode, operands[1]);\n-  if (! s_register_operand (operands[2], SImode))\n-    operands[2] = copy_to_mode_reg (SImode, operands[2]);\n-  \"\n-)\n-\n (define_insn \"*arm_shiftsi3\"\n   [(set (match_operand:SI   0 \"s_register_operand\" \"=r\")\n \t(match_operator:SI  3 \"shift_operator\"\n@@ -2674,7 +2704,9 @@\n   \"mov%?\\\\t%0, %1%S3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*shiftsi3_compare0\"\n@@ -2689,7 +2721,9 @@\n   \"mov%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*shiftsi3_compare0_scratch\"\n@@ -2702,8 +2736,7 @@\n   \"TARGET_ARM\"\n   \"mov%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"shift\" \"1\")\n-   ]\n+   (set_attr \"shift\" \"1\")]\n )\n \n (define_insn \"*notsi_shiftsi\"\n@@ -2715,7 +2748,9 @@\n   \"mvn%?\\\\t%0, %1%S3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*notsi_shiftsi_compare0\"\n@@ -2730,7 +2765,9 @@\n   \"mvn%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*not_shiftsi_compare0_scratch\"\n@@ -2744,7 +2781,9 @@\n   \"mvn%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"1\")\n-  ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n ;; We don't really have extzv, but defining this using shifts helps\n@@ -2841,14 +2880,14 @@\n (define_expand \"negsf2\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"\")\n \t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"\"\n )\n \n (define_expand \"negdf2\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"\")\n \n ;; abssi2 doesn't really clobber the condition codes if a different register\n@@ -2895,25 +2934,25 @@\n (define_expand \"abssf2\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"\")\n \t(abs:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_expand \"absdf2\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"\")\n \t(abs:DF (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_expand \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"\")\n \t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"\")\n \n (define_expand \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n \t(sqrt:DF (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"\")\n \n (define_insn_and_split \"one_cmpldi2\"\n@@ -2984,9 +3023,9 @@\n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF           0 \"s_register_operand\" \"\")\n \t(float:SF (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     {\n       emit_insn (gen_cirrus_floatsisf2 (operands[0], operands[1]));\n       DONE;\n@@ -2996,9 +3035,9 @@\n (define_expand \"floatsidf2\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"\")\n \t(float:DF (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     {\n       emit_insn (gen_cirrus_floatsidf2 (operands[0], operands[1]));\n       DONE;\n@@ -3008,9 +3047,9 @@\n (define_expand \"fix_truncsfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\"  \"\"))))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     {\n       if (!cirrus_fp_register (operands[0], SImode))\n         operands[0] = force_reg (SImode, operands[0]);\n@@ -3024,9 +3063,9 @@\n (define_expand \"fix_truncdfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\"  \"\"))))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS)\n+  if (TARGET_MAVERICK)\n     {\n       if (!cirrus_fp_register (operands[1], DFmode))\n         operands[1] = force_reg (DFmode, operands[0]);\n@@ -3041,7 +3080,7 @@\n   [(set (match_operand:SF  0 \"s_register_operand\" \"\")\n \t(float_truncate:SF\n  \t (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\"\n )\n \f\n@@ -3070,7 +3109,7 @@\n    ldr%?b\\\\t%Q0, %1\\;mov%?\\\\t%R0, #0\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"*,load\")\n+   (set_attr \"type\" \"*,load_byte\")\n    (set_attr \"pool_range\" \"*,4092\")\n    (set_attr \"neg_pool_range\" \"*,4084\")]\n )\n@@ -3099,72 +3138,42 @@\n   \"TARGET_EITHER\"\n   \"\n   {\n-    if (TARGET_ARM)\n+    if ((TARGET_THUMB || arm_arch4) && GET_CODE (operands[1]) == MEM)\n       {\n-        if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n-          {\n-           /* Note: We do not have to worry about TARGET_MMU_TRAPS\n-\t      here because the insn below will generate an LDRH instruction\n-\t      rather than an LDR instruction, so we cannot get an unaligned\n-\t      word access.  */\n-            emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t            gen_rtx_ZERO_EXTEND (SImode,\n-\t\t\t\t\t\t\t operands[1])));\n-            DONE;\n-          }\n-        if (TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n-          {\n-            emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n-            DONE;\n-          }\n-        if (!s_register_operand (operands[1], HImode))\n-          operands[1] = copy_to_mode_reg (HImode, operands[1]);\n-        operands[1] = gen_lowpart (SImode, operands[1]);\n-        operands[2] = gen_reg_rtx (SImode);\n+       /* Note: We do not have to worry about TARGET_MMU_TRAPS\n+\t  here because the insn below will generate an LDRH instruction\n+\t  rather than an LDR instruction, so we cannot get an unaligned\n+\t  word access.  */\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\tgen_rtx_ZERO_EXTEND (SImode, operands[1])));\n+\tDONE;\n       }\n-    else /* TARGET_THUMB */\n-      {\n-        if (GET_CODE (operands[1]) == MEM)\n-\t  {\n-\t    rtx tmp;\n \n-\t    tmp = gen_rtx_ZERO_EXTEND (SImode, operands[1]);\n-\t    tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\t    emit_insn (tmp);\n-\t  }\n-\telse\n-\t  {\n-\t    rtx ops[3];\n-\t    \n-\t    if (!s_register_operand (operands[1], HImode))\n-\t      operands[1] = copy_to_mode_reg (HImode, operands[1]);\n-\t    operands[1] = gen_lowpart (SImode, operands[1]);\n-\t    operands[2] = gen_reg_rtx (SImode);\n-\t    \n-\t    ops[0] = operands[2];\n-\t    ops[1] = operands[1];\n-\t    ops[2] = GEN_INT (16);\n-\t    \n-\t    emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t\t\t    gen_rtx_ASHIFT (SImode, ops[1], ops[2])));\n+    if (TARGET_ARM && TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n+      {\n+\temit_insn (gen_movhi_bytes (operands[0], operands[1]));\n+\tDONE;\n+      }\n \n-\t    ops[0] = operands[0];\n-\t    ops[1] = operands[2];\n-\t    ops[2] = GEN_INT (16);\n+    if (!s_register_operand (operands[1], HImode))\n+      operands[1] = copy_to_mode_reg (HImode, operands[1]);\n \n-\t    emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t\t\t    gen_rtx_LSHIFTRT (SImode, ops[1],\n-\t\t\t\t\t\t      ops[2])));\n-\t  }\n-\tDONE; \n+    if (arm_arch6)\n+      {\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\tgen_rtx_ZERO_EXTEND (SImode, operands[1])));\n+\tDONE;\n       }\n+\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[2] = gen_reg_rtx (SImode);\n   }\"\n )\n \n (define_insn \"*thumb_zero_extendhisi2\"\n-  [(set (match_operand:SI                 0 \"register_operand\" \"=l\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\"    \"m\")))]\n-  \"TARGET_THUMB\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_THUMB && !arm_arch6\"\n   \"*\n   rtx mem = XEXP (operands[1], 0);\n \n@@ -3199,21 +3208,91 @@\n   return \\\"ldrh\\\\t%0, %1\\\";\n   \"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"load\")\n+   (set_attr \"type\" \"load_byte\")\n    (set_attr \"pool_range\" \"60\")]\n )\n \n+(define_insn \"*thumb_zero_extendhisi2_v6\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))]\n+  \"TARGET_THUMB && arm_arch6\"\n+  \"*\n+  rtx mem;\n+\n+  if (which_alternative == 0)\n+    return \\\"uxth\\\\t%0, %1\\\";\n+\n+  mem = XEXP (operands[1], 0);\n+\n+  if (GET_CODE (mem) == CONST)\n+    mem = XEXP (mem, 0);\n+    \n+  if (GET_CODE (mem) == LABEL_REF)\n+    return \\\"ldr\\\\t%0, %1\\\";\n+    \n+  if (GET_CODE (mem) == PLUS)\n+    {\n+      rtx a = XEXP (mem, 0);\n+      rtx b = XEXP (mem, 1);\n+\n+      /* This can happen due to bugs in reload.  */\n+      if (GET_CODE (a) == REG && REGNO (a) == SP_REGNUM)\n+        {\n+          rtx ops[2];\n+          ops[0] = operands[0];\n+          ops[1] = a;\n+      \n+          output_asm_insn (\\\"mov\t%0, %1\\\", ops);\n+\n+          XEXP (mem, 0) = operands[0];\n+       }\n+\n+      else if (   GET_CODE (a) == LABEL_REF\n+\t       && GET_CODE (b) == CONST_INT)\n+        return \\\"ldr\\\\t%0, %1\\\";\n+    }\n+    \n+  return \\\"ldrh\\\\t%0, %1\\\";\n+  \"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"pool_range\" \"*,60\")]\n+)\n+\n (define_insn \"*arm_zero_extendhisi2\"\n-  [(set (match_operand:SI                 0 \"s_register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\"      \"m\")))]\n-  \"TARGET_ARM && arm_arch4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n   \"ldr%?h\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"256\")\n    (set_attr \"neg_pool_range\" \"244\")]\n )\n \n+(define_insn \"*arm_zero_extendhisi2_v6\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"@\n+   uxth%?\\\\t%0, %1\n+   ldr%?h\\\\t%0, %1\"\n+  [(set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"pool_range\" \"*,256\")\n+   (set_attr \"neg_pool_range\" \"*,244\")]\n+)\n+\n+(define_insn \"*arm_zero_extendhisi2addsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (zero_extend:SI (match_operand:HI 1 \"s_register_operand\" \"r\"))\n+\t\t (match_operand:SI 2 \"s_register_operand\" \"r\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"uxtah%?\\\\t%0, %2, %1\"\n+  [(set_attr \"type\" \"alu_shift\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(zero_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\")))\n@@ -3249,7 +3328,7 @@\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_EITHER\"\n   \"\n-  if (GET_CODE (operands[1]) != MEM)\n+  if (!arm_arch6 && GET_CODE (operands[1]) != MEM)\n     {\n       if (TARGET_ARM)\n         {\n@@ -3285,26 +3364,61 @@\n )\n \n (define_insn \"*thumb_zero_extendqisi2\"\n-  [(set (match_operand:SI                 0 \"register_operand\" \"=l\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\"    \"m\")))]\n-  \"TARGET_THUMB\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_THUMB && !arm_arch6\"\n   \"ldrb\\\\t%0, %1\"\n   [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"load\")\n+   (set_attr \"type\" \"load_byte\")\n    (set_attr \"pool_range\" \"32\")]\n )\n \n+(define_insn \"*thumb_zero_extendqisi2_v6\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,m\")))]\n+  \"TARGET_THUMB && arm_arch6\"\n+  \"@\n+   uxtb\\\\t%0, %1\n+   ldrb\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"pool_range\" \"*,32\")]\n+)\n+\n (define_insn \"*arm_zero_extendqisi2\"\n-  [(set (match_operand:SI                 0 \"s_register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\"      \"m\")))]\n-  \"TARGET_ARM\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_ARM && !arm_arch6\"\n   \"ldr%?b\\\\t%0, %1\\\\t%@ zero_extendqisi2\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"4096\")\n    (set_attr \"neg_pool_range\" \"4084\")]\n )\n \n+(define_insn \"*arm_zero_extendqisi2_v6\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"@\n+   uxtb%?\\\\t%0, %1\n+   ldr%?b\\\\t%0, %1\\\\t%@ zero_extendqisi2\"\n+  [(set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"pool_range\" \"*,4096\")\n+   (set_attr \"neg_pool_range\" \"*,4084\")]\n+)\n+\n+(define_insn \"*arm_zero_extendqisi2addsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (zero_extend:SI (match_operand:QI 1 \"s_register_operand\" \"r\"))\n+\t\t (match_operand:SI 2 \"s_register_operand\" \"r\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"uxtab%?\\\\t%0, %2, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"alu_shift\")]\n+)\n+\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(zero_extend:SI (subreg:QI (match_operand:SI 1 \"\" \"\") 0)))\n@@ -3334,55 +3448,55 @@\n   \"TARGET_EITHER\"\n   \"\n   {\n-    if (TARGET_ARM && arm_arch4 && GET_CODE (operands[1]) == MEM)\n+    if (GET_CODE (operands[1]) == MEM)\n       {\n-       /* Note: We do not have to worry about TARGET_MMU_TRAPS\n-\t  here because the insn below will generate an LDRH instruction\n-\t  rather than an LDR instruction, so we cannot get an unaligned\n-\t  word access.  */\n-        emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t   gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-        DONE;\n+\tif (TARGET_THUMB)\n+\t  {\n+\t    emit_insn (gen_thumb_extendhisi2 (operands[0], operands[1]));\n+\t    DONE;\n+          }\n+\telse if (arm_arch4)\n+\t  {\n+\t    /* Note: We do not have to worry about TARGET_MMU_TRAPS\n+\t       here because the insn below will generate an LDRH instruction\n+\t       rather than an LDR instruction, so we cannot get an unaligned\n+\t       word access.  */\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t       gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n+\t    DONE;\n+\t  }\n       }\n \n     if (TARGET_ARM && TARGET_MMU_TRAPS && GET_CODE (operands[1]) == MEM)\n       {\n         emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n         DONE;\n       }\n+\n     if (!s_register_operand (operands[1], HImode))\n       operands[1] = copy_to_mode_reg (HImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_reg_rtx (SImode);\n \n-    if (TARGET_THUMB)\n+    if (arm_arch6)\n       {\n-\trtx ops[3];\n-\t\n-\tops[0] = operands[2];\n-\tops[1] = operands[1];\n-\tops[2] = GEN_INT (16);\n-\t\n-        emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t\t\tgen_rtx_ASHIFT (SImode, ops[1], ops[2])));\n-\t    \n-\tops[0] = operands[0];\n-\tops[1] = operands[2];\n-\tops[2] = GEN_INT (16);\n-\t\n-        emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t\t\tgen_rtx_ASHIFTRT (SImode, ops[1], ops[2])));\n-\t\n+\tif (TARGET_THUMB)\n+\t  emit_insn (gen_thumb_extendhisi2 (operands[0], operands[1]));\n+\telse\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t     gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n+\n \tDONE;\n       }\n+\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[2] = gen_reg_rtx (SImode);\n   }\"\n )\n \n-(define_insn \"*thumb_extendhisi2_insn\"\n-  [(set (match_operand:SI                 0 \"register_operand\" \"=l\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\"    \"m\")))\n-   (clobber (match_scratch:SI             2                   \"=&l\"))]\n-  \"TARGET_THUMB\"\n+(define_insn \"thumb_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:SI 2 \"=&l\"))]\n+  \"TARGET_THUMB && !arm_arch6\"\n   \"*\n   {\n     rtx ops[4];\n@@ -3432,10 +3546,83 @@\n     return \\\"\\\";\n   }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"load\")\n+   (set_attr \"type\" \"load_byte\")\n    (set_attr \"pool_range\" \"1020\")]\n )\n \n+;; We used to have an early-clobber on the scratch register here.\n+;; However, there's a bug somewhere in reload which means that this\n+;; can be partially ignored during spill allocation if the memory\n+;; address also needs reloading; this causes an abort later on when\n+;; we try to verify the operands.  Fortunately, we don't really need\n+;; the early-clobber: we can always use operand 0 if operand 2\n+;; overlaps the address.\n+(define_insn \"*thumb_extendhisi2_insn_v6\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))\n+   (clobber (match_scratch:SI 2 \"=X,l\"))]\n+  \"TARGET_THUMB && arm_arch6\"\n+  \"*\n+  {\n+    rtx ops[4];\n+    rtx mem;\n+\n+    if (which_alternative == 0)\n+      return \\\"sxth\\\\t%0, %1\\\";\n+\n+    mem = XEXP (operands[1], 0);\n+\n+    /* This code used to try to use 'V', and fix the address only if it was\n+       offsettable, but this fails for e.g. REG+48 because 48 is outside the\n+       range of QImode offsets, and offsettable_address_p does a QImode\n+       address check.  */\n+       \n+    if (GET_CODE (mem) == CONST)\n+      mem = XEXP (mem, 0);\n+    \n+    if (GET_CODE (mem) == LABEL_REF)\n+      return \\\"ldr\\\\t%0, %1\\\";\n+    \n+    if (GET_CODE (mem) == PLUS)\n+      {\n+        rtx a = XEXP (mem, 0);\n+        rtx b = XEXP (mem, 1);\n+\n+        if (GET_CODE (a) == LABEL_REF\n+\t    && GET_CODE (b) == CONST_INT)\n+          return \\\"ldr\\\\t%0, %1\\\";\n+\n+        if (GET_CODE (b) == REG)\n+          return \\\"ldrsh\\\\t%0, %1\\\";\n+\t  \n+        ops[1] = a;\n+        ops[2] = b;\n+      }\n+    else\n+      {\n+        ops[1] = mem;\n+        ops[2] = const0_rtx;\n+      }\n+      \n+    if (GET_CODE (ops[1]) != REG)\n+      {\n+        debug_rtx (ops[1]);\n+        abort ();\n+      }\n+\n+    ops[0] = operands[0];\n+    if (reg_mentioned_p (operands[2], ops[1]))\n+      ops[3] = ops[0];\n+    else\n+      ops[3] = operands[2];\n+    output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n+    return \\\"\\\";\n+  }\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"pool_range\" \"*,1020\")]\n+)\n+\n (define_expand \"extendhisi2_mem\"\n   [(set (match_dup 2) (zero_extend:SI (match_operand:HI 1 \"\" \"\")))\n    (set (match_dup 3)\n@@ -3473,17 +3660,38 @@\n   }\"\n )\n \n-(define_insn \"*arm_extendhisi_insn\"\n-  [(set (match_operand:SI                 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\"      \"m\")))]\n-  \"TARGET_ARM && arm_arch4\"\n+(define_insn \"*arm_extendhisi2\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n   \"ldr%?sh\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"256\")\n    (set_attr \"neg_pool_range\" \"244\")]\n )\n \n+(define_insn \"*arm_extendhisi2_v6\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"@\n+   sxth%?\\\\t%0, %1\n+   ldr%?sh\\\\t%0, %1\"\n+  [(set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"pool_range\" \"*,256\")\n+   (set_attr \"neg_pool_range\" \"*,244\")]\n+)\n+\n+(define_insn \"*arm_extendhisi2addsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (sign_extend:SI (match_operand:HI 1 \"s_register_operand\" \"r\"))\n+\t\t (match_operand:SI 2 \"s_register_operand\" \"r\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"sxtah%?\\\\t%0, %2, %1\"\n+)\n+\n (define_split\n   [(set (match_operand:SI                 0 \"s_register_operand\" \"\")\n \t(sign_extend:SI (match_operand:HI 1 \"alignable_memory_operand\" \"\")))\n@@ -3550,7 +3758,7 @@\n     return \\\"#\\\";\n   return \\\"ldr%?sb\\\\t%0, %1\\\";\n   \"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"length\" \"8\")\n    (set_attr \"pool_range\" \"256\")\n@@ -3601,60 +3809,78 @@\n   \"TARGET_EITHER\"\n   \"\n   {\n-    if (TARGET_ARM && arm_arch4 && GET_CODE (operands[1]) == MEM)\n+    if ((TARGET_THUMB || arm_arch4) && GET_CODE (operands[1]) == MEM)\n       {\n-        emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t        operands[0],\n+        emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t        gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n         DONE;\n       }\n+\n     if (!s_register_operand (operands[1], QImode))\n       operands[1] = copy_to_mode_reg (QImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_reg_rtx (SImode);\n-    \n-    if (TARGET_THUMB)\n-      {\n-\trtx ops[3];\n-\t\n-\tops[0] = operands[2];\n-\tops[1] = operands[1];\n-\tops[2] = GEN_INT (24);\n-\t\n-        emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t   gen_rtx_ASHIFT (SImode, ops[1], ops[2])));\n \n-\tops[0] = operands[0];\n-\tops[1] = operands[2];\n-\tops[2] = GEN_INT (24);\n-\t\n-        emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t   gen_rtx_ASHIFTRT (SImode, ops[1], ops[2])));\n-\t\n-\tDONE;\n+    if (arm_arch6)\n+      {\n+        emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t        gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n+        DONE;\n       }\n+\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[2] = gen_reg_rtx (SImode);\n   }\"\n )\n \n ; Rather than restricting all byte accesses to memory addresses that ldrsb\n ; can handle, we fix up the ones that ldrsb can't grok with a split.\n-(define_insn \"*arm_extendqisi_insn\"\n-  [(set (match_operand:SI                 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\"      \"m\")))]\n-  \"TARGET_ARM && arm_arch4\"\n+(define_insn \"*arm_extendqisi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n   \"*\n   /* If the address is invalid, this will split the instruction into two.  */\n   if (bad_signed_byte_operand (operands[1], VOIDmode))\n     return \\\"#\\\";\n   return \\\"ldr%?sb\\\\t%0, %1\\\";\n   \"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"length\" \"8\")\n    (set_attr \"pool_range\" \"256\")\n    (set_attr \"neg_pool_range\" \"244\")]\n )\n \n+(define_insn \"*arm_extendqisi_v6\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"*\n+  if (which_alternative == 0)\n+    return \\\"sxtb%?\\\\t%0, %1\\\";\n+\n+  /* If the address is invalid, this will split the instruction into two.  */\n+  if (bad_signed_byte_operand (operands[1], VOIDmode))\n+    return \\\"#\\\";\n+\n+  return \\\"ldr%?sb\\\\t%0, %1\\\";\n+  \"\n+  [(set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\" \"4,8\")\n+   (set_attr \"pool_range\" \"*,256\")\n+   (set_attr \"neg_pool_range\" \"*,244\")]\n+)\n+\n+(define_insn \"*arm_extendqisi2addsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (sign_extend:SI (match_operand:QI 1 \"s_register_operand\" \"r\"))\n+\t\t (match_operand:SI 2 \"s_register_operand\" \"r\")))]\n+  \"TARGET_ARM && arm_arch6\"\n+  \"sxtab%?\\\\t%0, %2, %1\"\n+  [(set_attr \"type\" \"alu_shift\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(sign_extend:SI (match_operand:QI 1 \"bad_signed_byte_operand\" \"\")))]\n@@ -3688,10 +3914,10 @@\n   }\"\n )\n \n-(define_insn \"*thumb_extendqisi2_insn\"\n-  [(set (match_operand:SI                 0 \"register_operand\" \"=l,l\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\"    \"V,m\")))]\n-  \"TARGET_THUMB\"\n+(define_insn \"*thumb_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"V,m\")))]\n+  \"TARGET_THUMB && !arm_arch6\"\n   \"*\n   {\n     rtx ops[3];\n@@ -3763,14 +3989,95 @@\n     return \\\"\\\";\n   }\"\n   [(set_attr \"length\" \"2,6\")\n-   (set_attr \"type\" \"load,load\")\n+   (set_attr \"type\" \"load_byte,load_byte\")\n    (set_attr \"pool_range\" \"32,32\")]\n )\n \n+(define_insn \"*thumb_extendqisi2_v6\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,l\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,V,m\")))]\n+  \"TARGET_THUMB && arm_arch6\"\n+  \"*\n+  {\n+    rtx ops[3];\n+    rtx mem;\n+\n+    if (which_alternative == 0)\n+      return \\\"sxtb\\\\t%0, %1\\\";\n+\n+    mem = XEXP (operands[1], 0);\n+    \n+    if (GET_CODE (mem) == CONST)\n+      mem = XEXP (mem, 0);\n+    \n+    if (GET_CODE (mem) == LABEL_REF)\n+      return \\\"ldr\\\\t%0, %1\\\";\n+\n+    if (GET_CODE (mem) == PLUS\n+        && GET_CODE (XEXP (mem, 0)) == LABEL_REF)\n+      return \\\"ldr\\\\t%0, %1\\\";\n+      \n+    if (which_alternative == 0)\n+      return \\\"ldrsb\\\\t%0, %1\\\";\n+      \n+    ops[0] = operands[0];\n+    \n+    if (GET_CODE (mem) == PLUS)\n+      {\n+        rtx a = XEXP (mem, 0);\n+\trtx b = XEXP (mem, 1);\n+\t\n+        ops[1] = a;\n+        ops[2] = b;\n+\n+        if (GET_CODE (a) == REG)\n+\t  {\n+\t    if (GET_CODE (b) == REG)\n+              output_asm_insn (\\\"ldrsb\\\\t%0, [%1, %2]\\\", ops);\n+            else if (REGNO (a) == REGNO (ops[0]))\n+\t      {\n+                output_asm_insn (\\\"ldrb\\\\t%0, [%1, %2]\\\", ops);\n+\t\toutput_asm_insn (\\\"sxtb\\\\t%0, %0\\\", ops);\n+\t      }\n+\t    else\n+              output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n+\t  }\n+        else if (GET_CODE (b) != REG)\n+\t  abort ();\n+\telse\n+          {\n+            if (REGNO (b) == REGNO (ops[0]))\n+\t      {\n+                output_asm_insn (\\\"ldrb\\\\t%0, [%2, %1]\\\", ops);\n+\t\toutput_asm_insn (\\\"sxtb\\\\t%0, %0\\\", ops);\n+\t      }\n+\t    else\n+              output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n+          }\n+      }\n+    else if (GET_CODE (mem) == REG && REGNO (ops[0]) == REGNO (mem))\n+      {\n+        output_asm_insn (\\\"ldrb\\\\t%0, [%0, #0]\\\", ops);\n+\toutput_asm_insn (\\\"sxtb\\\\t%0, %0\\\", ops);\n+      }\n+    else\n+      {\n+        ops[1] = mem;\n+        ops[2] = const0_rtx;\n+\t\n+        output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n+      }\n+    return \\\"\\\";\n+  }\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"type\" \"alu_shift,load_byte,load_byte\")\n+   (set_attr \"pool_range\" \"*,32,32\")]\n+)\n+\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF                  0 \"s_register_operand\" \"\")\n \t(float_extend:DF (match_operand:SF 1 \"s_register_operand\"  \"\")))]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\"\n )\n \f\n@@ -3854,12 +4161,14 @@\n (define_insn \"*arm_movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, o<>\")\n \t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r\"))]\n-  \"TARGET_ARM && !TARGET_CIRRUS && ! TARGET_IWMMXT\"\n+  \"TARGET_ARM\n+  && !(TARGET_HARD_FLOAT && (TARGET_MAVERICK || TARGET_VFP))\n+  && !TARGET_IWMMXT\"\n   \"*\n   return (output_move_double (operands));\n   \"\n   [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"*,load,store2\")\n+   (set_attr \"type\" \"*,load2,store2\")\n    (set_attr \"pool_range\" \"*,1020,*\")\n    (set_attr \"neg_pool_range\" \"*,1008,*\")]\n )\n@@ -3872,7 +4181,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=l,l,l,l,>,l, m,*r\")\n \t(match_operand:DI 1 \"general_operand\"      \"l, I,J,>,l,mi,l,*r\"))]\n   \"TARGET_THUMB\n-   && !TARGET_CIRRUS\n+   && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   \"*\n@@ -3907,7 +4216,7 @@\n     }\n   }\"\n   [(set_attr \"length\" \"4,4,6,2,2,6,4,4\")\n-   (set_attr \"type\" \"*,*,*,load,store2,load,store2,*\")\n+   (set_attr \"type\" \"*,*,*,load2,store2,load2,store2,*\")\n    (set_attr \"pool_range\" \"*,*,*,*,*,1020,*,*\")]\n )\n \n@@ -3921,7 +4230,8 @@\n       /* Everything except mem = const or mem = mem can be done easily.  */\n       if (GET_CODE (operands[0]) == MEM)\n         operands[1] = force_reg (SImode, operands[1]);\n-      if (GET_CODE (operands[1]) == CONST_INT\n+      if (arm_general_register_operand (operands[0], SImode)\n+\t  && GET_CODE (operands[1]) == CONST_INT\n           && !(const_ok_for_arm (INTVAL (operands[1]))\n                || const_ok_for_arm (~INTVAL (operands[1]))))\n         {\n@@ -3954,21 +4264,22 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r, m\")\n \t(match_operand:SI 1 \"general_operand\"      \"rI,K,mi,r\"))]\n   \"TARGET_ARM && ! TARGET_IWMMXT\n+   && !(TARGET_HARD_FLOAT && TARGET_VFP)\n    && (   register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n    mov%?\\\\t%0, %1\n    mvn%?\\\\t%0, #%B1\n    ldr%?\\\\t%0, %1\n    str%?\\\\t%1, %0\"\n-  [(set_attr \"type\" \"*,*,load,store1\")\n+  [(set_attr \"type\" \"*,*,load1,store1\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"*,*,4096,*\")\n    (set_attr \"neg_pool_range\" \"*,*,4084,*\")]\n )\n \n (define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n \t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n   \"TARGET_ARM\n   && (!(const_ok_for_arm (INTVAL (operands[1]))\n@@ -3998,7 +4309,7 @@\n    str\\\\t%1, %0\n    mov\\\\t%0, %1\"\n   [(set_attr \"length\" \"2,2,4,4,2,2,2,2,2\")\n-   (set_attr \"type\" \"*,*,*,*,load,store1,load,store1,*\")\n+   (set_attr \"type\" \"*,*,*,*,load1,store1,load1,store1,*\")\n    (set_attr \"pool_range\" \"*,*,*,*,*,*,1020,*,*\")]\n )\n \n@@ -4050,7 +4361,7 @@\n \t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] UNSPEC_PIC_SYM))]\n   \"TARGET_ARM && flag_pic\"\n   \"ldr%?\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set (attr \"pool_range\")     (const_int 4096))\n    (set (attr \"neg_pool_range\") (const_int 4084))]\n )\n@@ -4060,7 +4371,7 @@\n \t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] UNSPEC_PIC_SYM))]\n   \"TARGET_THUMB && flag_pic\"\n   \"ldr\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set (attr \"pool_range\") (const_int 1024))]\n )\n \n@@ -4086,7 +4397,7 @@\n   output_asm_insn (\\\"ldr%?\\\\t%0, %a1\\\", operands);\n   return \\\"\\\";\n   \"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set (attr \"pool_range\")\n \t(if_then_else (eq_attr \"is_thumb\" \"yes\")\n \t\t      (const_int 1024)\n@@ -4514,7 +4825,7 @@\n       return \\\"ldrh\t%0, %1\\\";\n     }\"\n   [(set_attr \"length\" \"2,4,2,2,2,2\")\n-   (set_attr \"type\" \"*,load,store1,*,*,*\")]\n+   (set_attr \"type\" \"*,load1,store1,*,*,*\")]\n )\n \n \n@@ -4532,7 +4843,7 @@\n     output_asm_insn (\\\"ldr%?\\\\t%0, %1\\\\t%@ load-rotate\\\", ops);\n     return \\\"\\\";\n   }\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -4601,7 +4912,7 @@\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n    str%?h\\\\t%1, %0\\\\t%@ movhi \n    ldr%?h\\\\t%0, %1\\\\t%@ movhi\"\n-  [(set_attr \"type\" \"*,*,store1,load\")\n+  [(set_attr \"type\" \"*,*,store1,load1\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"*,*,*,256\")\n    (set_attr \"neg_pool_range\" \"*,*,*,244\")]\n@@ -4621,7 +4932,7 @@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n    ldr%?\\\\t%0, %1\\\\t%@ movhi\"\n-  [(set_attr \"type\" \"*,*,load\")\n+  [(set_attr \"type\" \"*,*,load1\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"4096\")\n    (set_attr \"neg_pool_range\" \"4084\")]\n@@ -4641,7 +4952,7 @@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\n    ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\\;mov%?\\\\t%0, %0, asr #16\"\n-  [(set_attr \"type\" \"*,*,load\")\n+  [(set_attr \"type\" \"*,*,load1\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"length\" \"4,4,8\")\n    (set_attr \"pool_range\" \"*,*,4092\")\n@@ -4656,7 +4967,7 @@\n    && BYTES_BIG_ENDIAN\n    && !TARGET_MMU_TRAPS\"\n   \"ldr%?\\\\t%0, %1\\\\t%@ movhi_bigend\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"4096\")\n    (set_attr \"neg_pool_range\" \"4084\")]\n@@ -4796,7 +5107,7 @@\n    mvn%?\\\\t%0, #%B1\n    ldr%?b\\\\t%0, %1\n    str%?b\\\\t%1, %0\"\n-  [(set_attr \"type\" \"*,*,load,store1\")\n+  [(set_attr \"type\" \"*,*,load1,store1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -4814,7 +5125,7 @@\n    mov\\\\t%0, %1\n    mov\\\\t%0, %1\"\n   [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"*,load,store1,*,*,*\")\n+   (set_attr \"type\" \"*,load1,store1,*,*,*\")\n    (set_attr \"pool_range\" \"*,32,*,*,*,*\")]\n )\n \n@@ -4843,7 +5154,7 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"immediate_operand\" \"\"))]\n   \"TARGET_ARM\n-   && !TARGET_HARD_FLOAT\n+   && !(TARGET_HARD_FLOAT && TARGET_FPA)\n    && reload_completed\n    && GET_CODE (operands[1]) == CONST_DOUBLE\"\n   [(set (match_dup 2) (match_dup 3))]\n@@ -4859,7 +5170,6 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:SF 1 \"general_operand\"  \"r,mE,r\"))]\n   \"TARGET_ARM\n-   && !TARGET_CIRRUS\n    && TARGET_SOFT_FLOAT\n    && (GET_CODE (operands[0]) != MEM\n        || register_operand (operands[1], SFmode))\"\n@@ -4869,7 +5179,7 @@\n    str%?\\\\t%1, %0\\\\t%@ float\"\n   [(set_attr \"length\" \"4,4,4\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"*,load,store1\")\n+   (set_attr \"type\" \"*,load1,store1\")\n    (set_attr \"pool_range\" \"*,4096,*\")\n    (set_attr \"neg_pool_range\" \"*,4084,*\")]\n )\n@@ -4890,7 +5200,7 @@\n    mov\\\\t%0, %1\n    mov\\\\t%0, %1\"\n   [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"*,load,store1,load,store1,*,*\")\n+   (set_attr \"type\" \"*,load1,store1,load1,store1,*,*\")\n    (set_attr \"pool_range\" \"*,*,*,1020,*,*,*\")]\n )\n \n@@ -4962,11 +5272,10 @@\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=r,r,m\")\n \t(match_operand:DF 1 \"soft_df_operand\" \"r,mF,r\"))]\n   \"TARGET_ARM && TARGET_SOFT_FLOAT\n-   && !TARGET_CIRRUS\n   \"\n   \"* return output_move_double (operands);\"\n   [(set_attr \"length\" \"8,8,8\")\n-   (set_attr \"type\" \"*,load,store2\")\n+   (set_attr \"type\" \"*,load2,store2\")\n    (set_attr \"pool_range\" \"1020\")\n    (set_attr \"neg_pool_range\" \"1008\")]\n )\n@@ -5007,7 +5316,7 @@\n     }\n   \"\n   [(set_attr \"length\" \"4,2,2,6,4,4\")\n-   (set_attr \"type\" \"*,load,store2,load,store2,*\")\n+   (set_attr \"type\" \"*,load2,store2,load2,store2,*\")\n    (set_attr \"pool_range\" \"*,*,*,1020,*,*\")]\n )\n \n@@ -5080,7 +5389,7 @@\n \t  (mem:SI (plus:SI (match_dup 2) (const_int 12))))])]\n   \"TARGET_ARM && XVECLEN (operands[0], 0) == 5\"\n   \"ldm%?ia\\\\t%1!, {%3, %4, %5, %6}\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load4\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -5097,7 +5406,7 @@\n \t  (mem:SI (plus:SI (match_dup 2) (const_int 8))))])]\n   \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n   \"ldm%?ia\\\\t%1!, {%3, %4, %5}\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load3\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -5112,7 +5421,7 @@\n \t  (mem:SI (plus:SI (match_dup 2) (const_int 4))))])]\n   \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n   \"ldm%?ia\\\\t%1!, {%3, %4}\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load2\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -5130,7 +5439,7 @@\n \t  (mem:SI (plus:SI (match_dup 1) (const_int 12))))])]\n   \"TARGET_ARM && XVECLEN (operands[0], 0) == 4\"\n   \"ldm%?ia\\\\t%1, {%2, %3, %4, %5}\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load4\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -5144,7 +5453,7 @@\n \t  (mem:SI (plus:SI (match_dup 1) (const_int 8))))])]\n   \"TARGET_ARM && XVECLEN (operands[0], 0) == 3\"\n   \"ldm%?ia\\\\t%1, {%2, %3, %4}\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load3\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -5156,7 +5465,7 @@\n \t  (mem:SI (plus:SI (match_dup 1) (const_int 4))))])]\n   \"TARGET_ARM && XVECLEN (operands[0], 0) == 2\"\n   \"ldm%?ia\\\\t%1, {%2, %3}\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load2\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -6406,12 +6715,9 @@\n \n (define_expand \"cmpsf\"\n   [(match_operand:SF 0 \"s_register_operand\" \"\")\n-   (match_operand:SF 1 \"fpa_rhs_operand\" \"\")]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+   (match_operand:SF 1 \"arm_float_compare_operand\" \"\")]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS && !cirrus_fp_register (operands[1], SFmode))\n-    operands[1] = force_reg (SFmode, operands[1]);\n-\n   arm_compare_op0 = operands[0];\n   arm_compare_op1 = operands[1];\n   DONE;\n@@ -6420,12 +6726,9 @@\n \n (define_expand \"cmpdf\"\n   [(match_operand:DF 0 \"s_register_operand\" \"\")\n-   (match_operand:DF 1 \"fpa_rhs_operand\" \"\")]\n-  \"TARGET_ARM && TARGET_ANY_HARD_FLOAT\"\n+   (match_operand:DF 1 \"arm_float_compare_operand\" \"\")]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"\n-  if (TARGET_CIRRUS && !cirrus_fp_register (operands[1], DFmode))\n-    operands[1] = force_reg (DFmode, operands[1]);\n-\n   arm_compare_op0 = operands[0];\n   arm_compare_op1 = operands[1];\n   DONE;\n@@ -6453,7 +6756,9 @@\n   \"cmp%?\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*cmpsi_shiftsi_swp\"\n@@ -6466,7 +6771,9 @@\n   \"cmp%?\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*cmpsi_neg_shiftsi\"\n@@ -6479,15 +6786,17 @@\n   \"cmn%?\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"1\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 2 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n ;; Cirrus SF compare instruction\n (define_insn \"*cirrus_cmpsf\"\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:SF 0 \"cirrus_fp_register\" \"v\")\n \t\t      (match_operand:SF 1 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcmps%?\\\\tr15, %V0, %V1\"\n   [(set_attr \"type\"   \"mav_farith\")\n    (set_attr \"cirrus\" \"compare\")]\n@@ -6498,7 +6807,7 @@\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:DF 0 \"cirrus_fp_register\" \"v\")\n \t\t      (match_operand:DF 1 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcmpd%?\\\\tr15, %V0, %V1\"\n   [(set_attr \"type\"   \"mav_farith\")\n    (set_attr \"cirrus\" \"compare\")]\n@@ -6508,7 +6817,7 @@\n (define_expand \"cmpdi\"\n   [(match_operand:DI 0 \"cirrus_fp_register\" \"\")\n    (match_operand:DI 1 \"cirrus_fp_register\" \"\")]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"{\n      arm_compare_op0 = operands[0];\n      arm_compare_op1 = operands[1];\n@@ -6519,7 +6828,7 @@\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC (match_operand:DI 0 \"cirrus_fp_register\" \"v\")\n \t\t    (match_operand:DI 1 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcmp64%?\\\\tr15, %V0, %V1\"\n   [(set_attr \"type\"   \"mav_farith\")\n    (set_attr \"cirrus\" \"compare\")]\n@@ -6637,7 +6946,7 @@\n \t(if_then_else (unordered (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n@@ -6647,7 +6956,7 @@\n \t(if_then_else (ordered (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n@@ -6657,7 +6966,7 @@\n \t(if_then_else (ungt (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6666,7 +6975,7 @@\n \t(if_then_else (unlt (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6675,7 +6984,7 @@\n \t(if_then_else (unge (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6684,7 +6993,7 @@\n \t(if_then_else (unle (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6695,7 +7004,7 @@\n \t(if_then_else (uneq (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNEQ, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6704,7 +7013,7 @@\n \t(if_then_else (ltgt (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (LTGT, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6718,7 +7027,7 @@\n \t(if_then_else (uneq (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n   if (arm_ccfsm_state != 0)\n     abort ();\n@@ -6735,7 +7044,7 @@\n \t(if_then_else (ltgt (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n   if (arm_ccfsm_state != 0)\n     abort ();\n@@ -6761,7 +7070,8 @@\n     }\n   return \\\"b%d1\\\\t%l0\\\";\n   \"\n-  [(set_attr \"conds\" \"use\")]\n+  [(set_attr \"conds\" \"use\")\n+   (set_attr \"type\" \"branch\")]\n )\n \n ; Special pattern to match reversed UNEQ.\n@@ -6770,7 +7080,7 @@\n \t(if_then_else (uneq (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n   if (arm_ccfsm_state != 0)\n     abort ();\n@@ -6787,7 +7097,7 @@\n \t(if_then_else (ltgt (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n   if (arm_ccfsm_state != 0)\n     abort ();\n@@ -6813,7 +7123,8 @@\n     }\n   return \\\"b%D1\\\\t%l0\\\";\n   \"\n-  [(set_attr \"conds\" \"use\")]\n+  [(set_attr \"conds\" \"use\")\n+   (set_attr \"type\" \"branch\")]\n )\n \n \f\n@@ -6893,47 +7204,47 @@\n (define_expand \"sunordered\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unordered:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sordered\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(ordered:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sungt\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(ungt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sunge\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unge:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sunlt\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unlt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sunle\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unle:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n@@ -6944,14 +7255,14 @@\n ; (define_expand \"suneq\"\n ;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n ; \t(uneq:SI (match_dup 1) (const_int 0)))]\n-;   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+;   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n ;   \"abort ();\"\n ; )\n ;\n ; (define_expand \"sltgt\"\n ;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n ; \t(ltgt:SI (match_dup 1) (const_int 0)))]\n-;   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+;   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n ;   \"abort ();\"\n ; )\n \n@@ -7022,9 +7333,9 @@\n       FAIL;\n \n     /* When compiling for SOFT_FLOAT, ensure both arms are in registers. \n-       Otherwise, ensure it is a valid FP add operand.  */\n-    if ((!TARGET_HARD_FLOAT)\n-        || (!fpa_add_operand (operands[3], SFmode)))\n+       Otherwise, ensure it is a valid FP add operand */\n+    if ((!(TARGET_HARD_FLOAT && TARGET_FPA))\n+        || (!arm_float_add_operand (operands[3], SFmode)))\n       operands[3] = force_reg (SFmode, operands[3]);\n \n     ccreg = arm_gen_compare_reg (code, arm_compare_op0, arm_compare_op1);\n@@ -7036,8 +7347,8 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n \t(if_then_else:DF (match_operand 1 \"arm_comparison_operator\" \"\")\n \t\t\t (match_operand:DF 2 \"s_register_operand\" \"\")\n-\t\t\t (match_operand:DF 3 \"fpa_add_operand\" \"\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t\t (match_operand:DF 3 \"arm_float_add_operand\" \"\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"\n   {\n     enum rtx_code code = GET_CODE (operands[1]);\n@@ -7403,7 +7714,7 @@\n       }\n     return output_return_instruction (const_true_rtx, TRUE, FALSE);\n   }\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"length\" \"12\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -7426,7 +7737,7 @@\n   }\"\n   [(set_attr \"conds\" \"use\")\n    (set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"load\")]\n+   (set_attr \"type\" \"load1\")]\n )\n \n (define_insn \"*cond_return_inverted\"\n@@ -7446,7 +7757,7 @@\n     return output_return_instruction (operands[0], TRUE, TRUE);\n   }\"\n   [(set_attr \"conds\" \"use\")\n-   (set_attr \"type\" \"load\")]\n+   (set_attr \"type\" \"load1\")]\n )\n \n ;; Generate a sequence of instructions to determine if the processor is\n@@ -7590,7 +7901,7 @@\n \t(match_operand:SI 0 \"memory_operand\" \"m\"))]\n   \"TARGET_ARM\"\n   \"ldr%?\\\\t%|pc, %0\\\\t%@ indirect memory jump\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"pool_range\" \"4096\")\n    (set_attr \"neg_pool_range\" \"4084\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -7636,7 +7947,9 @@\n   \"%i1%?\\\\t%0, %2, %4%S3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"4\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 5 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_split\n@@ -7672,7 +7985,9 @@\n   \"%i1%?s\\\\t%0, %2, %4%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"4\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 5 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*arith_shiftsi_compare0_scratch\"\n@@ -7688,7 +8003,9 @@\n   \"%i1%?s\\\\t%0, %2, %4%S3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"shift\" \"4\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 5 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*sub_shiftsi\"\n@@ -7701,7 +8018,9 @@\n   \"sub%?\\\\t%0, %1, %3%S2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"3\")\n-   ]\n+   (set (attr \"type\") (if_then_else (match_operand 4 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*sub_shiftsi_compare0\"\n@@ -7718,8 +8037,10 @@\n   \"TARGET_ARM\"\n   \"sub%?s\\\\t%0, %1, %3%S2\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"shift\" \"3\") \n-   ]\n+   (set_attr \"shift\" \"3\")\n+   (set (attr \"type\") (if_then_else (match_operand 4 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*sub_shiftsi_compare0_scratch\"\n@@ -7734,8 +8055,10 @@\n   \"TARGET_ARM\"\n   \"sub%?s\\\\t%0, %1, %3%S2\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"shift\" \"3\") \n-   ]\n+   (set_attr \"shift\" \"3\")\n+   (set (attr \"type\") (if_then_else (match_operand 4 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n \f\n@@ -8608,7 +8931,10 @@\n    mvn%D5\\\\t%0, #%B1\\;mov%d5\\\\t%0, %2%S4\"\n   [(set_attr \"conds\" \"use\")\n    (set_attr \"shift\" \"2\")\n-   (set_attr \"length\" \"4,8,8\")]\n+   (set_attr \"length\" \"4,8,8\")\n+   (set (attr \"type\") (if_then_else (match_operand 3 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*ifcompare_move_shift\"\n@@ -8644,7 +8970,10 @@\n    mvn%d5\\\\t%0, #%B1\\;mov%D5\\\\t%0, %2%S4\"\n   [(set_attr \"conds\" \"use\")\n    (set_attr \"shift\" \"2\")\n-   (set_attr \"length\" \"4,8,8\")]\n+   (set_attr \"length\" \"4,8,8\")\n+   (set (attr \"type\") (if_then_else (match_operand 3 \"const_int_operand\" \"\")\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*ifcompare_shift_shift\"\n@@ -8681,7 +9010,12 @@\n   \"mov%d5\\\\t%0, %1%S6\\;mov%D5\\\\t%0, %3%S7\"\n   [(set_attr \"conds\" \"use\")\n    (set_attr \"shift\" \"1\")\n-   (set_attr \"length\" \"8\")]\n+   (set_attr \"length\" \"8\")\n+   (set (attr \"type\") (if_then_else\n+\t\t        (and (match_operand 2 \"const_int_operand\" \"\")\n+                             (match_operand 4 \"const_int_operand\" \"\"))\n+\t\t      (const_string \"alu_shift\")\n+\t\t      (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*ifcompare_not_arith\"\n@@ -8882,7 +9216,7 @@\n   }\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"load\")]\n+   (set_attr \"type\" \"load1\")]\n )\n \n ;; the arm can support extended pre-inc instructions\n@@ -8939,7 +9273,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?b\\\\t%3, [%0, %2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -8955,7 +9289,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?b\\\\t%3, [%0, -%2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -8972,7 +9306,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?b\\\\t%3, [%0, %2]!\\\\t%@ z_extendqisi\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -8989,7 +9323,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?b\\\\t%3, [%0, -%2]!\\\\t%@ z_extendqisi\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9037,7 +9371,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?\\\\t%3, [%0, %2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9053,7 +9387,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?\\\\t%3, [%0, -%2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9072,7 +9406,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?\\\\t%3, [%0, %2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9091,7 +9425,7 @@\n    && (GET_CODE (operands[2]) != REG\n        || REGNO (operands[2]) != FRAME_POINTER_REGNUM)\"\n   \"ldr%?\\\\t%3, [%0, -%2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9145,7 +9479,7 @@\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?b\\\\t%5, [%0, %3%S2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9163,7 +9497,7 @@\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?b\\\\t%5, [%0, -%3%S2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9217,7 +9551,7 @@\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?\\\\t%5, [%0, %3%S2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9235,7 +9569,7 @@\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?\\\\t%5, [%0, -%3%S2]!\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")])\n \n (define_insn \"*loadhi_shiftpreinc\"\n@@ -9255,7 +9589,7 @@\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?\\\\t%5, [%0, %3%S2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9276,7 +9610,7 @@\n    && REGNO (operands[1]) != FRAME_POINTER_REGNUM\n    && REGNO (operands[3]) != FRAME_POINTER_REGNUM\"\n   \"ldr%?\\\\t%5, [%0, -%3%S2]!\\\\t%@ loadhi\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -9388,7 +9722,7 @@\n    (set (reg:CC CC_REGNUM)\n \t(compare:CC (match_dup 1) (const_int 0)))]\n   \"TARGET_ARM\n-   && (!TARGET_CIRRUS\n+   && (!(TARGET_HARD_FLOAT && TARGET_MAVERICK)\n        || (!cirrus_fp_register (operands[0], SImode)\n            && !cirrus_fp_register (operands[1], SImode)))\n   \"\n@@ -9832,7 +10166,7 @@\n     [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n \t  (unspec:BLK [(match_operand:XF 1 \"f_register_operand\" \"f\")]\n \t\t      UNSPEC_PUSH_MULT))])]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"*\n   {\n     char pattern[100];\n@@ -10052,3 +10386,6 @@\n (include \"cirrus.md\")\n ;; Load the Intel Wireless Multimedia Extension patterns\n (include \"iwmmxt.md\")\n+;; Load the VFP co-processor patterns\n+(include \"vfp.md\")\n+"}, {"sha": "5dd433269ac9e3c328648a4ba1cd30ac20fc6c9b", "filename": "gcc/config/arm/arm1026ejs.md", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm1026ejs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm1026ejs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm1026ejs.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -0,0 +1,241 @@\n+;; ARM 1026EJ-S Pipeline Description\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;; Written by CodeSourcery, LLC.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; ARM1026EJ-S Technical Reference Manual, Copyright (c) 2003 ARM\n+;; Limited.\n+;;\n+\n+;; This automaton provides a pipeline description for the ARM\n+;; 1026EJ-S core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"arm1026ejs\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There are two pipelines:\n+;; \n+;; - An Arithmetic Logic Unit (ALU) pipeline.\n+;;\n+;;   The ALU pipeline has fetch, issue, decode, execute, memory, and\n+;;   write stages. We only need to model the execute, memory and write\n+;;   stages.\n+;;\n+;; - A Load-Store Unit (LSU) pipeline.\n+;;\n+;;   The LSU pipeline has decode, execute, memory, and write stages.\n+;;   We only model the execute, memory and write stages.\n+\n+(define_cpu_unit \"a_e,a_m,a_w\" \"arm1026ejs\")\n+(define_cpu_unit \"l_e,l_m,l_w\" \"arm1026ejs\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require three cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations with no shifted operand\n+(define_insn_reservation \"alu_op\" 1 \n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"alu\"))\n+ \"a_e,a_m,a_w\")\n+\n+;; ALU operations with a shift-by-constant operand\n+(define_insn_reservation \"alu_shift_op\" 1 \n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"alu_shift\"))\n+ \"a_e,a_m,a_w\")\n+\n+;; ALU operations with a shift-by-register operand\n+;; These really stall in the decoder, in order to read\n+;; the shift value in a second cycle. Pretend we take two cycles in\n+;; the execute stage.\n+(define_insn_reservation \"alu_shift_reg_op\" 2 \n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"alu_shift_reg\"))\n+ \"a_e*2,a_m,a_w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Multiplication instructions loop in the execute stage until the\n+;; instruction has been passed through the multiplier array enough\n+;; times.\n+\n+;; The result of the \"smul\" and \"smulw\" instructions is not available\n+;; until after the memory stage.\n+(define_insn_reservation \"mult1\" 2\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"insn\" \"smulxy,smulwy\"))\n+ \"a_e,a_m,a_w\")\n+\n+;; The \"smlaxy\" and \"smlawx\" instructions require two iterations through\n+;; the execute stage; the result is available immediately following\n+;; the execute stage.\n+(define_insn_reservation \"mult2\" 2\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"insn\" \"smlaxy,smlalxy,smlawx\"))\n+ \"a_e*2,a_m,a_w\")\n+\n+;; The \"smlalxy\", \"mul\", and \"mla\" instructions require two iterations\n+;; through the execute stage; the result is not available until after\n+;; the memory stage.\n+(define_insn_reservation \"mult3\" 3\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"insn\" \"smlalxy,mul,mla\"))\n+ \"a_e*2,a_m,a_w\")\n+\n+;; The \"muls\" and \"mlas\" instructions loop in the execute stage for\n+;; four iterations in order to set the flags.  The value result is\n+;; available after three iterations.\n+(define_insn_reservation \"mult4\" 3\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"insn\" \"muls,mlas\"))\n+ \"a_e*4,a_m,a_w\")\n+\n+;; Long multiply instructions that produce two registers of\n+;; output (such as umull) make their results available in two cycles;\n+;; the least significant word is available before the most significant\n+;; word.  That fact is not modeled; instead, the instructions are\n+;; described.as if the entire result was available at the end of the\n+;; cycle in which both words are available.\n+\n+;; The \"umull\", \"umlal\", \"smull\", and \"smlal\" instructions all take\n+;; three iterations through the execute cycle, and make their results\n+;; available after the memory cycle.\n+(define_insn_reservation \"mult5\" 4\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"insn\" \"umull,umlal,smull,smlal\"))\n+ \"a_e*3,a_m,a_w\")\n+\n+;; The \"umulls\", \"umlals\", \"smulls\", and \"smlals\" instructions loop in\n+;; the execute stage for five iterations in order to set the flags.\n+;; The value result is vailable after four iterations.\n+(define_insn_reservation \"mult6\" 4\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"insn\" \"umulls,umlals,smulls,smlals\"))\n+ \"a_e*5,a_m,a_w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+;; LSU instructions require six cycles to execute.  They use the ALU\n+;; pipeline in all but the 5th cycle, and the LSU pipeline in cycles\n+;; three through six.\n+;; Loads and stores which use a scaled register offset or scaled\n+;; register pre-indexed addressing mode take three cycles EXCEPT for\n+;; those that are base + offset with LSL of 0 or 2, or base - offset\n+;; with LSL of zero.  The remainder take 1 cycle to execute.\n+;; For 4byte loads there is a bypass from the load stage\n+\n+(define_insn_reservation \"load1_op\" 2\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"load_byte,load1\"))\n+ \"a_e+l_e,l_m,a_w+l_w\")\n+\n+(define_insn_reservation \"store1_op\" 0\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"a_e+l_e,l_m,a_w+l_w\")\n+\n+;; A load's result can be stored by an immediately following store\n+(define_bypass 1 \"load1_op\" \"store1_op\" \"arm_no_early_store_addr_dep\")\n+\n+;; On a LDM/STM operation, the LSU pipeline iterates until all of the\n+;; registers have been processed.\n+;;\n+;; The time it takes to load the data depends on whether or not the\n+;; base address is 64-bit aligned; if it is not, an additional cycle\n+;; is required.  This model assumes that the address is always 64-bit\n+;; aligned.  Because the processor can load two registers per cycle,\n+;; that assumption means that we use the same instruction rservations\n+;; for loading 2k and 2k - 1 registers.\n+;;\n+;; The ALU pipeline is stalled until the completion of the last memory\n+;; stage in the LSU pipeline.  That is modeled by keeping the ALU\n+;; execute stage busy until that point.\n+;;\n+;; As with ALU operations, if one of the destination registers is the\n+;; PC, there are additional stalls; that is not modeled.\n+\n+(define_insn_reservation \"load2_op\" 2\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"load2\"))\n+ \"a_e+l_e,l_m,a_w+l_w\")\n+\n+(define_insn_reservation \"store2_op\" 0\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"store2\"))\n+ \"a_e+l_e,l_m,a_w+l_w\")\n+\n+(define_insn_reservation \"load34_op\" 3\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"load3,load4\"))\n+ \"a_e+l_e,a_e+l_e+l_m,a_e+l_m,a_w+l_w\")\n+\n+(define_insn_reservation \"store34_op\" 0\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"store3,store4\"))\n+ \"a_e+l_e,a_e+l_e+l_m,a_e+l_m,a_w+l_w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The ARM\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycles to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"branch_op\" 0\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"nothing\")\n+\n+;; The latency for a call is not predictable.  Therefore, we use 32 as\n+;; roughly equivalent to postive infinity.\n+\n+(define_insn_reservation \"call_op\" 32\n+ (and (eq_attr \"tune\" \"arm1026ejs\")\n+      (eq_attr \"type\" \"call\"))\n+ \"nothing\")"}, {"sha": "acfce1b5681fe8bfcdcd5cbc18d753531617a56b", "filename": "gcc/config/arm/arm1136jfs.md", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm1136jfs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm1136jfs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm1136jfs.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -0,0 +1,377 @@\n+;; ARM 1136J[F]-S Pipeline Description\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;; Written by CodeSourcery, LLC.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; ARM1136JF-S Technical Reference Manual, Copyright (c) 2003 ARM\n+;; Limited.\n+;;\n+\n+;; This automaton provides a pipeline description for the ARM\n+;; 1136J-S and 1136JF-S cores.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"arm1136jfs\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There are three distinct pipelines (page 1-26 and following):\n+;;\n+;; - A 4-stage decode pipeline, shared by all three.  It has fetch (1),\n+;;   fetch (2), decode, and issue stages.  Since this is always involved,\n+;;   we do not model it in the scheduler.\n+;;\n+;; - A 4-stage ALU pipeline.  It has shifter, ALU (main integer operations),\n+;;   and saturation stages.  The fourth stage is writeback; see below.\n+;;\n+;; - A 4-stage multiply-accumulate pipeline.  It has three stages, called\n+;;   MAC1 through MAC3, and a fourth writeback stage.\n+;;\n+;;   The 4th-stage writeback is shared between the ALU and MAC pipelines,\n+;;   which operate in lockstep.  Results from either pipeline will be\n+;;   moved into the writeback stage.  Because the two pipelines operate\n+;;   in lockstep, we schedule them as a single \"execute\" pipeline.\n+;;\n+;; - A 4-stage LSU pipeline.  It has address generation, data cache (1),\n+;;   data cache (2), and writeback stages.  (Note that this pipeline,\n+;;   including the writeback stage, is independant from the ALU & LSU pipes.)  \n+\n+(define_cpu_unit \"e_1,e_2,e_3,e_wb\" \"arm1136jfs\")     ; ALU and MAC\n+; e_1 = Sh/Mac1, e_2 = ALU/Mac2, e_3 = SAT/Mac3\n+(define_cpu_unit \"l_a,l_dc1,l_dc2,l_wb\" \"arm1136jfs\") ; Load/Store\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require eight cycles to execute, and use the ALU\n+;; pipeline in each of the eight stages.  The results are available\n+;; after the alu stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modelled here.\n+\n+;; ALU operations with no shifted operand\n+(define_insn_reservation \"11_alu_op\" 2\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"alu\"))\n+ \"e_1,e_2,e_3,e_wb\")\n+\n+;; ALU operations with a shift-by-constant operand\n+(define_insn_reservation \"11_alu_shift_op\" 2\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"alu_shift\"))\n+ \"e_1,e_2,e_3,e_wb\")\n+\n+;; ALU operations with a shift-by-register operand\n+;; These really stall in the decoder, in order to read\n+;; the shift value in a second cycle. Pretend we take two cycles in\n+;; the shift stage.\n+(define_insn_reservation \"11_alu_shift_reg_op\" 3\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"alu_shift_reg\"))\n+ \"e_1*2,e_2,e_3,e_wb\")\n+\n+;; alu_ops can start sooner, if there is no shifter dependency\n+(define_bypass 1 \"11_alu_op,11_alu_shift_op\"\n+\t       \"11_alu_op\")\n+(define_bypass 1 \"11_alu_op,11_alu_shift_op\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 1 \"11_alu_op,11_alu_shift_op\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+(define_bypass 2 \"11_alu_shift_reg_op\"\n+\t       \"11_alu_op\")\n+(define_bypass 2 \"11_alu_shift_reg_op\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 2 \"11_alu_shift_reg_op\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+\n+(define_bypass 1 \"11_alu_op,11_alu_shift_op\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 2 \"11_alu_shift_reg_op\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Multiplication instructions loop in the first two execute stages until\n+;; the instruction has been passed through the multiplier array enough\n+;; times.\n+\n+;; Multiply and multiply-accumulate results are available after four stages.\n+(define_insn_reservation \"11_mult1\" 4\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"mul,mla\"))\n+ \"e_1*2,e_2,e_3,e_wb\")\n+\n+;; The *S variants set the condition flags, which requires three more cycles.\n+(define_insn_reservation \"11_mult2\" 4\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"muls,mlas\"))\n+ \"e_1*2,e_2,e_3,e_wb\")\n+\n+(define_bypass 3 \"11_mult1,11_mult2\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 3 \"11_mult1,11_mult2\"\n+\t       \"11_alu_op\")\n+(define_bypass 3 \"11_mult1,11_mult2\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 3 \"11_mult1,11_mult2\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+(define_bypass 3 \"11_mult1,11_mult2\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+\n+;; Signed and unsigned multiply long results are available across two cycles;\n+;; the less significant word is available one cycle before the more significant\n+;; word.  Here we conservatively wait until both are available, which is\n+;; after three iterations and the memory cycle.  The same is also true of\n+;; the two multiply-accumulate instructions.\n+(define_insn_reservation \"11_mult3\" 5\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"smull,umull,smlal,umlal\"))\n+ \"e_1*3,e_2,e_3,e_wb*2\")\n+\n+;; The *S variants set the condition flags, which requires three more cycles.\n+(define_insn_reservation \"11_mult4\" 5\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"smulls,umulls,smlals,umlals\"))\n+ \"e_1*3,e_2,e_3,e_wb*2\")\n+\n+(define_bypass 4 \"11_mult3,11_mult4\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 4 \"11_mult3,11_mult4\"\n+\t       \"11_alu_op\")\n+(define_bypass 4 \"11_mult3,11_mult4\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 4 \"11_mult3,11_mult4\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+(define_bypass 4 \"11_mult3,11_mult4\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+\n+;; Various 16x16->32 multiplies and multiply-accumulates, using combinations\n+;; of high and low halves of the argument registers.  They take a single\n+;; pass through the pipeline and make the result available after three\n+;; cycles.\n+(define_insn_reservation \"11_mult5\" 3\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"smulxy,smlaxy,smulwy,smlawy,smuad,smuadx,smlad,smladx,smusd,smusdx,smlsd,smlsdx\"))\n+ \"e_1,e_2,e_3,e_wb\")\n+\n+(define_bypass 2 \"11_mult5\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 2 \"11_mult5\"\n+\t       \"11_alu_op\")\n+(define_bypass 2 \"11_mult5\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 2 \"11_mult5\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+(define_bypass 2 \"11_mult5\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+\n+;; The same idea, then the 32-bit result is added to a 64-bit quantity.\n+(define_insn_reservation \"11_mult6\" 4\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"smlalxy\"))\n+ \"e_1*2,e_2,e_3,e_wb*2\")\n+\n+;; Signed 32x32 multiply, then the most significant 32 bits are extracted\n+;; and are available after the memory stage.\n+(define_insn_reservation \"11_mult7\" 4\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"insn\" \"smmul,smmulr\"))\n+ \"e_1*2,e_2,e_3,e_wb\")\n+\n+(define_bypass 3 \"11_mult6,11_mult7\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 3 \"11_mult6,11_mult7\"\n+\t       \"11_alu_op\")\n+(define_bypass 3 \"11_mult6,11_mult7\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 3 \"11_mult6,11_mult7\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+(define_bypass 3 \"11_mult6,11_mult7\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; These vary greatly depending on their arguments and the results of\n+;; stat prediction.  Cycle count ranges from zero (unconditional branch,\n+;; folded dynamic prediction) to seven (incorrect predictions, etc).  We\n+;; assume an optimal case for now, because the cost of a cache miss\n+;; overwhelms the cost of everything else anyhow.\n+\n+(define_insn_reservation \"11_branches\" 0\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"nothing\")\n+\n+;; Call latencies are not predictable.  A semi-arbitrary very large\n+;; number is used as \"positive infinity\" so that everything should be\n+;; finished by the time of return.\n+(define_insn_reservation \"11_call\" 32\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"call\"))\n+ \"nothing\")\n+\n+;; Branches are predicted. A correctly predicted branch will be no\n+;; cost, but we're conservative here, and use the timings a\n+;; late-register would give us.\n+(define_bypass 1 \"11_alu_op,11_alu_shift_op\"\n+\t       \"11_branches\")\n+(define_bypass 2 \"11_alu_shift_reg_op\"\n+\t       \"11_branches\")\n+(define_bypass 2 \"11_load1,11_load2\"\n+\t       \"11_branches\")\n+(define_bypass 3 \"11_load34\"\n+\t       \"11_branches\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback.\n+;; These models assume that all memory references hit in dcache.  Also,\n+;; if the PC is one of the registers involved, there are additional stalls\n+;; not modelled here.  Addressing modes are also not modelled.\n+\n+(define_insn_reservation \"11_load1\" 3\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"load1\"))\n+ \"l_a+e_1,l_dc1,l_dc2,l_wb\")\n+\n+;; Load byte results are not available until the writeback stage, where\n+;; the correct byte is extracted.\n+\n+(define_insn_reservation \"11_loadb\" 4\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"load_byte\"))\n+ \"l_a+e_1,l_dc1,l_dc2,l_wb\")\n+\n+(define_insn_reservation \"11_store1\" 0\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"l_a+e_1,l_dc1,l_dc2,l_wb\")\n+\n+;; Load/store double words into adjacent registers.  The timing and\n+;; latencies are different depending on whether the address is 64-bit\n+;; aligned.  This model assumes that it is.\n+(define_insn_reservation \"11_load2\" 3\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"load2\"))\n+ \"l_a+e_1,l_dc1,l_dc2,l_wb\")\n+\n+(define_insn_reservation \"11_store2\" 0\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"store2\"))\n+ \"l_a+e_1,l_dc1,l_dc2,l_wb\")\n+\n+;; Load/store multiple registers.  Two registers are stored per cycle.\n+;; Actual timing depends on how many registers are affected, so we\n+;; optimistically schedule a low latency.\n+(define_insn_reservation \"11_load34\" 4\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"load3,load4\"))\n+ \"l_a+e_1,l_dc1*2,l_dc2,l_wb\")\n+\n+(define_insn_reservation \"11_store34\" 0\n+ (and (eq_attr \"tune\" \"arm1136js,arm1136jfs\")\n+      (eq_attr \"type\" \"store3,store4\"))\n+ \"l_a+e_1,l_dc1*2,l_dc2,l_wb\")\n+\n+;; A store can start immediately after an alu op, if that alu op does\n+;; not provide part of the address to access.\n+(define_bypass 1 \"11_alu_op,11_alu_shift_op\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+(define_bypass 2 \"11_alu_shift_reg_op\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+\n+;; An alu op can start sooner after a load, if that alu op does not\n+;; have an early register dependancy on the load\n+(define_bypass 2 \"11_load1\"\n+\t       \"11_alu_op\")\n+(define_bypass 2 \"11_load1\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 2 \"11_load1\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+\n+(define_bypass 3 \"11_loadb\"\n+\t       \"11_alu_op\")\n+(define_bypass 3 \"11_loadb\"\n+\t       \"11_alu_shift_op\"\n+\t       \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 3 \"11_loadb\"\n+\t       \"11_alu_shift_reg_op\"\n+\t       \"arm_no_early_alu_shift_dep\")\n+\n+;; A mul op can start sooner after a load, if that mul op does not\n+;; have an early multiply dependency\n+(define_bypass 2 \"11_load1\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 3 \"11_load34\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+(define_bypass 3 \"11_loadb\"\n+\t       \"11_mult1,11_mult2,11_mult3,11_mult4,11_mult5,11_mult6,11_mult7\"\n+\t       \"arm_no_early_mul_dep\")\n+\n+;; A store can start sooner after a load, if that load does not\n+;; produce part of the address to access\n+(define_bypass 2 \"11_load1\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")\n+(define_bypass 3 \"11_loadb\"\n+\t       \"11_store1\"\n+\t       \"arm_no_early_store_addr_dep\")"}, {"sha": "e8ba17cf551ebb060fcebd6d6033bd53fb236dc4", "filename": "gcc/config/arm/arm926ejs.md", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm926ejs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Farm926ejs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm926ejs.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -0,0 +1,188 @@\n+;; ARM 926EJ-S Pipeline Description\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;; Written by CodeSourcery, LLC.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; ARM926EJ-S Technical Reference Manual, Copyright (c) 2002 ARM\n+;; Limited.\n+;;\n+\n+;; This automaton provides a pipeline description for the ARM\n+;; 926EJ-S core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"arm926ejs\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There is a single pipeline\n+;;\n+;;   The ALU pipeline has fetch, decode, execute, memory, and\n+;;   write stages. We only need to model the execute, memory and write\n+;;   stages.\n+\n+(define_cpu_unit \"e,m,w\" \"arm926ejs\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require three cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations with no shifted operand\n+(define_insn_reservation \"9_alu_op\" 1 \n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"alu,alu_shift\"))\n+ \"e,m,w\")\n+\n+;; ALU operations with a shift-by-register operand\n+;; These really stall in the decoder, in order to read\n+;; the shift value in a second cycle. Pretend we take two cycles in\n+;; the execute stage.\n+(define_insn_reservation \"9_alu_shift_reg_op\" 2 \n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"alu_shift_reg\"))\n+ \"e*2,m,w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Multiplication instructions loop in the execute stage until the\n+;; instruction has been passed through the multiplier array enough\n+;; times. Multiply operations occur in both the execute and memory\n+;; stages of the pipeline\n+\n+(define_insn_reservation \"9_mult1\" 3\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"insn\" \"smlalxy,mul,mla\"))\n+ \"e*2,m,w\")\n+\n+(define_insn_reservation \"9_mult2\" 4\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"insn\" \"muls,mlas\"))\n+ \"e*3,m,w\")\n+\n+(define_insn_reservation \"9_mult3\" 4\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"insn\" \"umull,umlal,smull,smlal\"))\n+ \"e*3,m,w\")\n+\n+(define_insn_reservation \"9_mult4\" 5\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"insn\" \"umulls,umlals,smulls,smlals\"))\n+ \"e*4,m,w\")\n+\n+(define_insn_reservation \"9_mult5\" 2\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"insn\" \"smulxy,smlaxy,smlawx\"))\n+ \"e,m,w\")\n+\n+(define_insn_reservation \"9_mult6\" 3\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"insn\" \"smlalxy\"))\n+ \"e*2,m,w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+;; Loads with a shifted offset take 3 cycles, and are (a) probably the\n+;; most common and (b) the pessimistic assumption will lead to fewer stalls.\n+(define_insn_reservation \"9_load1_op\" 3\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"load1,load_byte\"))\n+ \"e*2,m,w\")\n+\n+(define_insn_reservation \"9_store1_op\" 0\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"e,m,w\")\n+\n+;; multiple word loads and stores\n+(define_insn_reservation \"9_load2_op\" 3\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"load2\"))\n+ \"e,m*2,w\")\n+\n+(define_insn_reservation \"9_load3_op\" 4\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"load3\"))\n+ \"e,m*3,w\")\n+\n+(define_insn_reservation \"9_load4_op\" 5\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"load4\"))\n+ \"e,m*4,w\")\n+\n+(define_insn_reservation \"9_store2_op\" 0\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"store2\"))\n+ \"e,m*2,w\")\n+\n+(define_insn_reservation \"9_store3_op\" 0\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"store3\"))\n+ \"e,m*3,w\")\n+\n+(define_insn_reservation \"9_store4_op\" 0\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"store4\"))\n+ \"e,m*4,w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The ARM\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycles to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"9_branch_op\" 0\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"nothing\")\n+\n+;; The latency for a call is not predictable.  Therefore, we use 32 as\n+;; roughly equivalent to postive infinity.\n+\n+(define_insn_reservation \"9_call_op\" 32\n+ (and (eq_attr \"tune\" \"arm926ejs\")\n+      (eq_attr \"type\" \"call\"))\n+ \"nothing\")"}, {"sha": "9bd01be45cb3021e039c0962431a588acaec7b7b", "filename": "gcc/config/arm/cirrus.md", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fcirrus.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fcirrus.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcirrus.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -34,7 +34,7 @@\n   [(set (match_operand:DI          0 \"cirrus_fp_register\" \"=v\")\n \t(plus:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")\n \t\t (match_operand:DI 2 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfadd64%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -44,7 +44,7 @@\n   [(set (match_operand:SI          0 \"cirrus_fp_register\" \"=v\")\n \t(plus:SI (match_operand:SI 1 \"cirrus_fp_register\" \"v\")\n \t\t (match_operand:SI 2 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfadd32%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -54,7 +54,7 @@\n   [(set (match_operand:SF          0 \"cirrus_fp_register\" \"=v\")\n \t(plus:SF (match_operand:SF 1 \"cirrus_fp_register\" \"v\")\n \t\t (match_operand:SF 2 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfadds%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -64,7 +64,7 @@\n   [(set (match_operand:DF          0 \"cirrus_fp_register\" \"=v\")\n \t(plus:DF (match_operand:DF 1 \"cirrus_fp_register\" \"v\")\n \t\t (match_operand:DF 2 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfaddd%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -74,7 +74,7 @@\n   [(set (match_operand:DI           0 \"cirrus_fp_register\" \"=v\")\n \t(minus:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")\n \t\t  (match_operand:DI 2 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfsub64%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -84,7 +84,7 @@\n   [(set (match_operand:SI           0 \"cirrus_fp_register\" \"=v\")\n \t(minus:SI (match_operand:SI 1 \"cirrus_fp_register\" \"v\")\n \t\t  (match_operand:SI 2 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfsub32%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -94,7 +94,7 @@\n   [(set (match_operand:SF           0 \"cirrus_fp_register\" \"=v\")\n \t(minus:SF (match_operand:SF 1 \"cirrus_fp_register\"  \"v\")\n \t\t  (match_operand:SF 2 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfsubs%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -104,7 +104,7 @@\n   [(set (match_operand:DF           0 \"cirrus_fp_register\" \"=v\")\n \t(minus:DF (match_operand:DF 1 \"cirrus_fp_register\" \"v\")\n \t\t  (match_operand:DF 2 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfsubd%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -114,7 +114,7 @@\n   [(set (match_operand:SI          0 \"cirrus_fp_register\" \"=v\")\n \t(mult:SI (match_operand:SI 2 \"cirrus_fp_register\"  \"v\")\n \t\t (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfmul32%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -124,7 +124,7 @@\n   [(set (match_operand:DI          0 \"cirrus_fp_register\" \"=v\")\n \t(mult:DI (match_operand:DI 2 \"cirrus_fp_register\"  \"v\")\n \t\t (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfmul64%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_dmult\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -136,7 +136,7 @@\n \t  (mult:SI (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")\n \t\t   (match_operand:SI 2 \"cirrus_fp_register\"  \"v\"))\n \t  (match_operand:SI          3 \"cirrus_fp_register\"  \"0\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfmac32%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -149,7 +149,7 @@\n \t  (match_operand:SI          1 \"cirrus_fp_register\"  \"0\")\n \t  (mult:SI (match_operand:SI 2 \"cirrus_fp_register\"  \"v\")\n \t\t   (match_operand:SI 3 \"cirrus_fp_register\"  \"v\"))))]\n-  \"0 && TARGET_ARM && TARGET_CIRRUS\"\n+  \"0 && TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfmsc32%?\\\\t%V0, %V2, %V3\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -159,7 +159,7 @@\n   [(set (match_operand:SF          0 \"cirrus_fp_register\" \"=v\")\n \t(mult:SF (match_operand:SF 1 \"cirrus_fp_register\"  \"v\")\n \t\t (match_operand:SF 2 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfmuls%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_farith\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -169,7 +169,7 @@\n   [(set (match_operand:DF          0 \"cirrus_fp_register\" \"=v\")\n \t(mult:DF (match_operand:DF 1 \"cirrus_fp_register\"  \"v\")\n \t\t (match_operand:DF 2 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfmuld%?\\\\t%V0, %V1, %V2\"\n   [(set_attr \"type\" \"mav_dmult\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -179,7 +179,7 @@\n   [(set (match_operand:SI            0 \"cirrus_fp_register\" \"=v\")\n \t(ashift:SI (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")\n \t\t   (match_operand:SI 2 \"cirrus_shift_const\"  \"\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfsh32%?\\\\t%V0, %V1, #%s2\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -188,7 +188,7 @@\n   [(set (match_operand:SI\t       0 \"cirrus_fp_register\" \"=v\")\n \t(ashiftrt:SI (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")\n \t\t     (match_operand:SI 2 \"cirrus_shift_const\"  \"\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfsh32%?\\\\t%V0, %V1, #-%s2\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -197,7 +197,7 @@\n   [(set (match_operand:SI            0 \"cirrus_fp_register\" \"=v\")\n \t(ashift:SI (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")\n \t\t   (match_operand:SI 2 \"register_operand\"    \"r\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfrshl32%?\\\\t%V1, %V0, %s2\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -206,7 +206,7 @@\n   [(set (match_operand:DI            0 \"cirrus_fp_register\" \"=v\")\n \t(ashift:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")\n \t\t   (match_operand:SI 2 \"register_operand\"    \"r\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfrshl64%?\\\\t%V1, %V0, %s2\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -215,7 +215,7 @@\n   [(set (match_operand:DI            0 \"cirrus_fp_register\" \"=v\")\n \t(ashift:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")\n \t\t   (match_operand:SI 2 \"cirrus_shift_const\"  \"\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfsh64%?\\\\t%V0, %V1, #%s2\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -224,15 +224,15 @@\n   [(set (match_operand:DI            0 \"cirrus_fp_register\" \"=v\")\n \t(ashiftrt:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")\n \t\t     (match_operand:SI 2 \"cirrus_shift_const\"  \"\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfsh64%?\\\\t%V0, %V1, #-%s2\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_absdi2\"\n   [(set (match_operand:DI         0 \"cirrus_fp_register\" \"=v\")\n \t(abs:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfabs64%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -242,31 +242,31 @@\n   [(set (match_operand:DI         0 \"cirrus_fp_register\" \"=v\")\n \t(neg:DI (match_operand:DI 1 \"cirrus_fp_register\"  \"v\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfneg64%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_negsi2\"\n   [(set (match_operand:SI         0 \"cirrus_fp_register\" \"=v\")\n \t(neg:SI (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfneg32%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_negsf2\"\n   [(set (match_operand:SF         0 \"cirrus_fp_register\" \"=v\")\n \t(neg:SF (match_operand:SF 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfnegs%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_negdf2\"\n   [(set (match_operand:DF         0 \"cirrus_fp_register\" \"=v\")\n \t(neg:DF (match_operand:DF 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfnegd%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -276,23 +276,23 @@\n   [(set (match_operand:SI         0 \"cirrus_fp_register\" \"=v\")\n         (abs:SI (match_operand:SI 1 \"cirrus_fp_register\"  \"v\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\"\n   \"cfabs32%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_abssf2\"\n   [(set (match_operand:SF         0 \"cirrus_fp_register\" \"=v\")\n         (abs:SF (match_operand:SF 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfabss%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_absdf2\"\n   [(set (match_operand:DF         0 \"cirrus_fp_register\" \"=v\")\n         (abs:DF (match_operand:DF 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfabsd%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n@@ -302,7 +302,7 @@\n   [(set (match_operand:SF           0 \"cirrus_fp_register\" \"=v\")\n  \t(float:SF (match_operand:SI 1 \"s_register_operand\"  \"r\")))\n    (clobber (match_scratch:DF 2 \"=v\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfmv64lr%?\\\\t%Z2, %1\\;cfcvt32s%?\\\\t%V0, %Y2\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cirrus\" \"move\")]\n@@ -312,7 +312,7 @@\n   [(set (match_operand:DF           0 \"cirrus_fp_register\" \"=v\")\n \t(float:DF (match_operand:SI 1 \"s_register_operand\" \"r\")))\n    (clobber (match_scratch:DF 2 \"=v\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfmv64lr%?\\\\t%Z2, %1\\;cfcvt32d%?\\\\t%V0, %Y2\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cirrus\" \"move\")]\n@@ -321,22 +321,22 @@\n (define_insn \"floatdisf2\"\n   [(set (match_operand:SF           0 \"cirrus_fp_register\" \"=v\")\n \t(float:SF (match_operand:DI 1 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcvt64s%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")])\n \n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"cirrus_fp_register\" \"=v\")\n \t(float:DF (match_operand:DI 1 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcvt64d%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")])\n \n (define_insn \"cirrus_truncsfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"cirrus_fp_register\"  \"v\"))))\n    (clobber (match_scratch:DF     2                      \"=v\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cftruncs32%?\\\\t%Y2, %V1\\;cfmvr64l%?\\\\t%0, %Z2\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cirrus\" \"normal\")]\n@@ -346,7 +346,7 @@\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"cirrus_fp_register\"  \"v\"))))\n    (clobber (match_scratch:DF     2                      \"=v\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cftruncd32%?\\\\t%Y2, %V1\\;cfmvr64l%?\\\\t%0, %Z2\"\n   [(set_attr \"length\" \"8\")]\n )\n@@ -355,23 +355,23 @@\n   [(set (match_operand:SF  0 \"cirrus_fp_register\" \"=v\")\n         (float_truncate:SF\n          (match_operand:DF 1 \"cirrus_fp_register\" \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcvtds%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_extendsfdf2\"\n   [(set (match_operand:DF                  0 \"cirrus_fp_register\" \"=v\")\n         (float_extend:DF (match_operand:SF 1 \"cirrus_fp_register\"  \"v\")))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"cfcvtsd%?\\\\t%V0, %V1\"\n   [(set_attr \"cirrus\" \"normal\")]\n )\n \n (define_insn \"*cirrus_arm_movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,o<>,v,r,v,m,v\")\n \t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r,r,v,m,v,v\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n   \"*\n   {\n   switch (which_alternative)\n@@ -394,7 +394,7 @@\n     }\n   }\"\n   [(set_attr \"length\"         \"  8,   8,     8,   8,     8,     4,     4,     4\")\n-   (set_attr \"type\"           \"  *,load,store2,   *,     *,  load,store2,     *\")\n+   (set_attr \"type\"           \"  *,load2,store2,   *,     *,  load2,store2,     *\")\n    (set_attr \"pool_range\"     \"  *,1020,     *,   *,     *,     *,     *,     *\")\n    (set_attr \"neg_pool_range\" \"  *,1012,     *,   *,     *,     *,     *,     *\")\n    (set_attr \"cirrus\"         \"not, not,   not,move,normal,double,double,normal\")]\n@@ -406,7 +406,7 @@\n (define_insn \"*cirrus_arm_movsi_insn\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m,*v,r,*v,T,*v\")\n         (match_operand:SI 1 \"general_operand\" \"rI,K,mi,r,r,*v,T,*v,*v\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS && 0\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK && 0\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n@@ -419,7 +419,7 @@\n    cfldr32%?\\\\t%V0, %1\n    cfstr32%?\\\\t%V1, %0\n    cfsh32%?\\\\t%V0, %V1, #0\"\n-  [(set_attr \"type\"           \"*,  *,  load,store1,   *,     *,  load,store1,     *\")\n+  [(set_attr \"type\"           \"*,  *,  load1,store1,   *,     *,  load1,store1,     *\")\n    (set_attr \"pool_range\"     \"*,  *,  4096,     *,   *,     *,  1024,     *,     *\")\n    (set_attr \"neg_pool_range\" \"*,  *,  4084,     *,   *,     *,  1012,     *,     *\")\n    (set_attr \"cirrus\"         \"not,not, not,   not,move,normal,normal,normal,normal\")]\n@@ -428,7 +428,7 @@\n (define_insn \"*cirrus_movsf_hard_insn\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=v,v,v,r,m,r,r,m\")\n         (match_operand:SF 1 \"general_operand\"       \"v,m,r,v,v,r,mE,r\"))]\n-  \"TARGET_ARM && TARGET_CIRRUS\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\n    && (GET_CODE (operands[0]) != MEM\n        || register_operand (operands[1], SFmode))\"\n   \"@\n@@ -441,7 +441,7 @@\n    ldr%?\\\\t%0, %1\\\\t%@ float\n    str%?\\\\t%1, %0\\\\t%@ float\"\n   [(set_attr \"length\"         \"     *,     *,   *,     *,     *,  4,   4,     4\")\n-   (set_attr \"type\"           \"     *,  load,   *,     *,store1,  *,load,store1\")\n+   (set_attr \"type\"           \"     *,  load1,   *,     *,store1,  *,load1,store1\")\n    (set_attr \"pool_range\"     \"     *,     *,   *,     *,     *,  *,4096,     *\")\n    (set_attr \"neg_pool_range\" \"     *,     *,   *,     *,     *,  *,4084,     *\")\n    (set_attr \"cirrus\"         \"normal,normal,move,normal,normal,not, not,   not\")]\n@@ -451,7 +451,7 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,Q,r,m,r,v,v,v,r,m\")\n \t(match_operand:DF 1 \"general_operand\"       \"Q,r,r,r,mF,v,m,r,v,v\"))]\n   \"TARGET_ARM\n-   && TARGET_CIRRUS\n+   && TARGET_HARD_FLOAT && TARGET_MAVERICK\n    && (GET_CODE (operands[0]) != MEM\n        || register_operand (operands[1], DFmode))\"\n   \"*\n@@ -469,7 +469,7 @@\n     default: abort ();\n     }\n   }\"\n-  [(set_attr \"type\"           \"load,store2,  *,store2,load,     *,  load,   *,     *,store2\")\n+  [(set_attr \"type\"           \"load1,store2,  *,store2,load1,     *,  load1,   *,     *,store2\")\n    (set_attr \"length\"         \"   4,     4,  8,     8,   8,     4,     4,   8,     8,     4\")\n    (set_attr \"pool_range\"     \"   *,     *,  *,     *, 252,     *,     *,   *,     *,     *\")\n    (set_attr \"neg_pool_range\" \"   *,     *,  *,     *, 244,     *,     *,   *,     *,     *\")"}, {"sha": "e3f393aa9d9319636e0d24751e92ec489d46e0c2", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -46,7 +46,7 @@\n \n #ifndef SUBTARGET_ASM_FLOAT_SPEC\n #define SUBTARGET_ASM_FLOAT_SPEC \"\\\n-%{mapcs-float:-mfloat} %{msoft-float:-mfpu=softfpa}\"\n+%{mapcs-float:-mfloat}\"\n #endif\n \n #ifndef ASM_SPEC\n@@ -58,6 +58,8 @@\n %{mapcs-*:-mapcs-%*} \\\n %(subtarget_asm_float_spec) \\\n %{mthumb-interwork:-mthumb-interwork} \\\n+%{msoft-float:-mfloat-abi=soft} %{mhard-float:-mfloat-abi=hard} \\\n+%{mfloat-abi=*} %{mfpu=*} \\\n %(subtarget_extra_asm_spec)\"\n #endif\n "}, {"sha": "2eb74ee8c8b37a4ea79039ff92fde9acf035323d", "filename": "gcc/config/arm/fpa.md", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Ffpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Ffpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffpa.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -100,8 +100,8 @@\n (define_insn \"*addsf3_fpa\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"=f,f\")\n \t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"%f,f\")\n-\t\t (match_operand:SF 2 \"fpa_add_operand\"    \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t (match_operand:SF 2 \"arm_float_add_operand\"    \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    adf%?s\\\\t%0, %1, %2\n    suf%?s\\\\t%0, %1, #%N2\"\n@@ -112,8 +112,8 @@\n (define_insn \"*adddf3_fpa\"\n   [(set (match_operand:DF          0 \"s_register_operand\" \"=f,f\")\n \t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"%f,f\")\n-\t\t (match_operand:DF 2 \"fpa_add_operand\"    \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t (match_operand:DF 2 \"arm_float_add_operand\"    \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    adf%?d\\\\t%0, %1, %2\n    suf%?d\\\\t%0, %1, #%N2\"\n@@ -125,8 +125,8 @@\n   [(set (match_operand:DF           0 \"s_register_operand\" \"=f,f\")\n \t(plus:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"s_register_operand\"  \"f,f\"))\n-\t\t (match_operand:DF  2 \"fpa_add_operand\"    \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t (match_operand:DF  2 \"arm_float_add_operand\"    \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    adf%?d\\\\t%0, %1, %2\n    suf%?d\\\\t%0, %1, #%N2\"\n@@ -139,7 +139,7 @@\n \t(plus:DF (match_operand:DF  1 \"s_register_operand\"  \"f\")\n \t\t (float_extend:DF\n \t\t  (match_operand:SF 2 \"s_register_operand\"  \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"adf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"farith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -151,17 +151,17 @@\n \t\t  (match_operand:SF 1 \"s_register_operand\" \"f\"))\n \t\t (float_extend:DF\n \t\t  (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"adf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"farith\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n (define_insn \"*subsf3_fpa\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f,f\")\n-\t(minus:SF (match_operand:SF 1 \"fpa_rhs_operand\" \"f,G\")\n-\t\t  (match_operand:SF 2 \"fpa_rhs_operand\" \"fG,f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t(minus:SF (match_operand:SF 1 \"arm_float_rhs_operand\" \"f,G\")\n+\t\t  (match_operand:SF 2 \"arm_float_rhs_operand\" \"fG,f\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    suf%?s\\\\t%0, %1, %2\n    rsf%?s\\\\t%0, %2, %1\"\n@@ -170,9 +170,9 @@\n \n (define_insn \"*subdf3_fpa\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"=f,f\")\n-\t(minus:DF (match_operand:DF 1 \"fpa_rhs_operand\"     \"f,G\")\n-\t\t  (match_operand:DF 2 \"fpa_rhs_operand\"    \"fG,f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t(minus:DF (match_operand:DF 1 \"arm_float_rhs_operand\"     \"f,G\")\n+\t\t  (match_operand:DF 2 \"arm_float_rhs_operand\"    \"fG,f\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    suf%?d\\\\t%0, %1, %2\n    rsf%?d\\\\t%0, %2, %1\"\n@@ -184,19 +184,19 @@\n   [(set (match_operand:DF            0 \"s_register_operand\" \"=f\")\n \t(minus:DF (float_extend:DF\n \t\t   (match_operand:SF 1 \"s_register_operand\"  \"f\"))\n-\t\t  (match_operand:DF  2 \"fpa_rhs_operand\"    \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t  (match_operand:DF  2 \"arm_float_rhs_operand\"    \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"suf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"farith\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n (define_insn \"*subdf_df_esfdf_fpa\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f,f\")\n-\t(minus:DF (match_operand:DF 1 \"fpa_rhs_operand\" \"f,G\")\n+\t(minus:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"f,G\")\n \t\t  (float_extend:DF\n \t\t   (match_operand:SF 2 \"s_register_operand\" \"f,f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    suf%?d\\\\t%0, %1, %2\n    rsf%?d\\\\t%0, %2, %1\"\n@@ -210,7 +210,7 @@\n \t\t   (match_operand:SF 1 \"s_register_operand\" \"f\"))\n \t\t  (float_extend:DF\n \t\t   (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"suf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"farith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -219,8 +219,8 @@\n (define_insn \"*mulsf3_fpa\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t (match_operand:SF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"fml%?s\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"ffmul\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -229,8 +229,8 @@\n (define_insn \"*muldf3_fpa\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"f\")\n-\t\t (match_operand:DF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t (match_operand:DF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"muf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fmul\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -240,8 +240,8 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(mult:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"s_register_operand\" \"f\"))\n-\t\t (match_operand:DF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t (match_operand:DF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"muf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fmul\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -252,7 +252,7 @@\n \t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"f\")\n \t\t (float_extend:DF\n \t\t  (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"muf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fmul\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -263,7 +263,7 @@\n \t(mult:DF\n \t (float_extend:DF (match_operand:SF 1 \"s_register_operand\" \"f\"))\n \t (float_extend:DF (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"muf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fmul\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -273,9 +273,9 @@\n \n (define_insn \"*divsf3_fpa\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f,f\")\n-\t(div:SF (match_operand:SF 1 \"fpa_rhs_operand\" \"f,G\")\n-\t\t(match_operand:SF 2 \"fpa_rhs_operand\" \"fG,f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t(div:SF (match_operand:SF 1 \"arm_float_rhs_operand\" \"f,G\")\n+\t\t(match_operand:SF 2 \"arm_float_rhs_operand\" \"fG,f\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    fdv%?s\\\\t%0, %1, %2\n    frd%?s\\\\t%0, %2, %1\"\n@@ -285,9 +285,9 @@\n \n (define_insn \"*divdf3_fpa\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f,f\")\n-\t(div:DF (match_operand:DF 1 \"fpa_rhs_operand\" \"f,G\")\n-\t\t(match_operand:DF 2 \"fpa_rhs_operand\" \"fG,f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t(div:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"f,G\")\n+\t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"fG,f\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    dvf%?d\\\\t%0, %1, %2\n    rdf%?d\\\\t%0, %2, %1\"\n@@ -299,19 +299,19 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(div:DF (float_extend:DF\n \t\t (match_operand:SF 1 \"s_register_operand\" \"f\"))\n-\t\t(match_operand:DF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"dvf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n (define_insn \"*divdf_df_esfdf_fpa\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"fpa_rhs_operand\" \"fG\")\n+\t(div:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"fG\")\n \t\t(float_extend:DF\n \t\t (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"rdf%?d\\\\t%0, %2, %1\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -323,7 +323,7 @@\n \t\t (match_operand:SF 1 \"s_register_operand\" \"f\"))\n \t\t(float_extend:DF\n \t\t (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"dvf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -332,8 +332,8 @@\n (define_insn \"*modsf3_fpa\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(mod:SF (match_operand:SF 1 \"s_register_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t(match_operand:SF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"rmf%?s\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivs\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -342,8 +342,8 @@\n (define_insn \"*moddf3_fpa\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(mod:DF (match_operand:DF 1 \"s_register_operand\" \"f\")\n-\t\t(match_operand:DF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"rmf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -353,8 +353,8 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(mod:DF (float_extend:DF\n \t\t (match_operand:SF 1 \"s_register_operand\" \"f\"))\n-\t\t(match_operand:DF 2 \"fpa_rhs_operand\" \"fG\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"fG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"rmf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -365,7 +365,7 @@\n \t(mod:DF (match_operand:DF 1 \"s_register_operand\" \"f\")\n \t\t(float_extend:DF\n \t\t (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"rmf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -377,7 +377,7 @@\n \t\t (match_operand:SF 1 \"s_register_operand\" \"f\"))\n \t\t(float_extend:DF\n \t\t (match_operand:SF 2 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"rmf%?d\\\\t%0, %1, %2\"\n   [(set_attr \"type\" \"fdivd\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -386,7 +386,7 @@\n (define_insn \"*negsf2_fpa\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"mnf%?s\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -395,7 +395,7 @@\n (define_insn \"*negdf2_fpa\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"mnf%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -405,7 +405,7 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(neg:DF (float_extend:DF\n \t\t (match_operand:SF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"mnf%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -414,7 +414,7 @@\n (define_insn \"*abssf2_fpa\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"=f\")\n \t (abs:SF (match_operand:SF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"abs%?s\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -423,7 +423,7 @@\n (define_insn \"*absdf2_fpa\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"=f\")\n \t(abs:DF (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"abs%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -433,7 +433,7 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(abs:DF (float_extend:DF\n \t\t (match_operand:SF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"abs%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -442,7 +442,7 @@\n (define_insn \"*sqrtsf2_fpa\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"sqt%?s\\\\t%0, %1\"\n   [(set_attr \"type\" \"float_em\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -451,7 +451,7 @@\n (define_insn \"*sqrtdf2_fpa\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"sqt%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"float_em\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -461,7 +461,7 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n \t(sqrt:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"sqt%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"float_em\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -470,7 +470,7 @@\n (define_insn \"*floatsisf2_fpa\"\n   [(set (match_operand:SF           0 \"s_register_operand\" \"=f\")\n \t(float:SF (match_operand:SI 1 \"s_register_operand\" \"r\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"flt%?s\\\\t%0, %1\"\n   [(set_attr \"type\" \"r_2_f\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -479,7 +479,7 @@\n (define_insn \"*floatsidf2_fpa\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"=f\")\n \t(float:DF (match_operand:SI 1 \"s_register_operand\" \"r\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"flt%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"r_2_f\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -488,7 +488,7 @@\n (define_insn \"*fix_truncsfsi2_fpa\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"fix%?z\\\\t%0, %1\"\n   [(set_attr \"type\" \"f_2_r\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -497,7 +497,7 @@\n (define_insn \"*fix_truncdfsi2_fpa\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"fix%?z\\\\t%0, %1\"\n   [(set_attr \"type\" \"f_2_r\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -507,7 +507,7 @@\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(float_truncate:SF\n \t (match_operand:DF 1 \"s_register_operand\" \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"mvf%?s\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -516,7 +516,7 @@\n (define_insn \"*extendsfdf2_fpa\"\n   [(set (match_operand:DF                  0 \"s_register_operand\" \"=f\")\n \t(float_extend:DF (match_operand:SF 1 \"s_register_operand\"  \"f\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"mvf%?d\\\\t%0, %1\"\n   [(set_attr \"type\" \"ffarith\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -526,7 +526,7 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,f, m,f,r,r,r, m\")\n \t(match_operand:SF 1 \"general_operand\"      \"fG,H,mE,f,r,f,r,mE,r\"))]\n   \"TARGET_ARM\n-   && TARGET_HARD_FLOAT\n+   && TARGET_HARD_FLOAT && TARGET_FPA\n    && (GET_CODE (operands[0]) != MEM\n        || register_operand (operands[1], SFmode))\"\n   \"@\n@@ -542,7 +542,7 @@\n   [(set_attr \"length\" \"4,4,4,4,8,8,4,4,4\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"type\"\n-\t \"ffarith,ffarith,f_load,f_store,r_mem_f,f_mem_r,*,load,store1\")\n+\t \"ffarith,ffarith,f_load,f_store,r_mem_f,f_mem_r,*,load1,store1\")\n    (set_attr \"pool_range\" \"*,*,1024,*,*,*,*,4096,*\")\n    (set_attr \"neg_pool_range\" \"*,*,1012,*,*,*,*,4084,*\")]\n )\n@@ -553,7 +553,7 @@\n \t(match_operand:DF 1 \"general_operand\"\n \t\t\t\t\t\t\"Q, r,r,r,mF,fG,H,mF,f,r, f\"))]\n   \"TARGET_ARM\n-   && TARGET_HARD_FLOAT\n+   && TARGET_HARD_FLOAT && TARGET_FPA\n    && (GET_CODE (operands[0]) != MEM\n        || register_operand (operands[1], DFmode))\"\n   \"*\n@@ -576,7 +576,7 @@\n   [(set_attr \"length\" \"4,4,8,8,8,4,4,4,4,8,8\")\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"type\"\n-    \"load,store2,*,store2,load,ffarith,ffarith,f_load,f_store,r_mem_f,f_mem_r\")\n+    \"load1,store2,*,store2,load1,ffarith,ffarith,f_load,f_store,r_mem_f,f_mem_r\")\n    (set_attr \"pool_range\" \"*,*,*,*,1020,*,*,1024,*,*,*\")\n    (set_attr \"neg_pool_range\" \"*,*,*,*,1008,*,*,1008,*,*,*\")]\n )\n@@ -589,7 +589,7 @@\n (define_insn \"*movxf_fpa\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f,f,m,f,r,r\")\n \t(match_operand:XF 1 \"general_operand\" \"fG,H,m,f,r,f,r\"))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && reload_completed\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA && reload_completed\"\n   \"*\n   switch (which_alternative)\n     {\n@@ -613,8 +613,8 @@\n (define_insn \"*cmpsf_fpa\"\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:SF 0 \"s_register_operand\" \"f,f\")\n-\t\t      (match_operand:SF 1 \"fpa_add_operand\" \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t      (match_operand:SF 1 \"arm_float_add_operand\" \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    cmf%?\\\\t%0, %1\n    cnf%?\\\\t%0, #%N1\"\n@@ -625,8 +625,8 @@\n (define_insn \"*cmpdf_fpa\"\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:DF 0 \"s_register_operand\" \"f,f\")\n-\t\t      (match_operand:DF 1 \"fpa_add_operand\" \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t      (match_operand:DF 1 \"arm_float_add_operand\" \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    cmf%?\\\\t%0, %1\n    cnf%?\\\\t%0, #%N1\"\n@@ -638,8 +638,8 @@\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (float_extend:DF\n \t\t       (match_operand:SF 0 \"s_register_operand\" \"f,f\"))\n-\t\t      (match_operand:DF 1 \"fpa_add_operand\" \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t      (match_operand:DF 1 \"arm_float_add_operand\" \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    cmf%?\\\\t%0, %1\n    cnf%?\\\\t%0, #%N1\"\n@@ -652,7 +652,7 @@\n \t(compare:CCFP (match_operand:DF 0 \"s_register_operand\" \"f\")\n \t\t      (float_extend:DF\n \t\t       (match_operand:SF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"cmf%?\\\\t%0, %1\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"f_2_r\")]\n@@ -661,8 +661,8 @@\n (define_insn \"*cmpsf_trap_fpa\"\n   [(set (reg:CCFPE CC_REGNUM)\n \t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\" \"f,f\")\n-\t\t       (match_operand:SF 1 \"fpa_add_operand\" \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t       (match_operand:SF 1 \"arm_float_add_operand\" \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    cmf%?e\\\\t%0, %1\n    cnf%?e\\\\t%0, #%N1\"\n@@ -673,8 +673,8 @@\n (define_insn \"*cmpdf_trap_fpa\"\n   [(set (reg:CCFPE CC_REGNUM)\n \t(compare:CCFPE (match_operand:DF 0 \"s_register_operand\" \"f,f\")\n-\t\t       (match_operand:DF 1 \"fpa_add_operand\" \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t       (match_operand:DF 1 \"arm_float_add_operand\" \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    cmf%?e\\\\t%0, %1\n    cnf%?e\\\\t%0, #%N1\"\n@@ -686,8 +686,8 @@\n   [(set (reg:CCFPE CC_REGNUM)\n \t(compare:CCFPE (float_extend:DF\n \t\t\t(match_operand:SF 0 \"s_register_operand\" \"f,f\"))\n-\t\t       (match_operand:DF 1 \"fpa_add_operand\" \"fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t\t       (match_operand:DF 1 \"arm_float_add_operand\" \"fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    cmf%?e\\\\t%0, %1\n    cnf%?e\\\\t%0, #%N1\"\n@@ -700,7 +700,7 @@\n \t(compare:CCFPE (match_operand:DF 0 \"s_register_operand\" \"f\")\n \t\t       (float_extend:DF\n \t\t\t(match_operand:SF 1 \"s_register_operand\" \"f\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"cmf%?e\\\\t%0, %1\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"f_2_r\")]\n@@ -711,9 +711,9 @@\n \t(if_then_else:SF\n \t (match_operator 3 \"arm_comparison_operator\" \n \t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t (match_operand:SF 1 \"fpa_add_operand\" \"0,0,fG,H,fG,fG,H,H\")\n-\t (match_operand:SF 2 \"fpa_add_operand\" \"fG,H,0,0,fG,H,fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t (match_operand:SF 1 \"arm_float_add_operand\" \"0,0,fG,H,fG,fG,H,H\")\n+\t (match_operand:SF 2 \"arm_float_add_operand\" \"fG,H,0,0,fG,H,fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    mvf%D3s\\\\t%0, %2\n    mnf%D3s\\\\t%0, #%N2\n@@ -733,9 +733,9 @@\n \t(if_then_else:DF\n \t (match_operator 3 \"arm_comparison_operator\"\n \t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t (match_operand:DF 1 \"fpa_add_operand\" \"0,0,fG,H,fG,fG,H,H\")\n-\t (match_operand:DF 2 \"fpa_add_operand\" \"fG,H,0,0,fG,H,fG,H\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n+\t (match_operand:DF 1 \"arm_float_add_operand\" \"0,0,fG,H,fG,fG,H,H\")\n+\t (match_operand:DF 2 \"arm_float_add_operand\" \"fG,H,0,0,fG,H,fG,H\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n   \"@\n    mvf%D3d\\\\t%0, %2\n    mnf%D3d\\\\t%0, #%N2"}, {"sha": "6c87500093ebb0564bd93220a59598fbb8e96cae", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -86,7 +86,7 @@\n     }\n }\"\n   [(set_attr \"length\"         \"8,8,8,4,4,4,4,4\")\n-   (set_attr \"type\"           \"*,load,store2,*,*,*,*,*\")\n+   (set_attr \"type\"           \"*,load1,store2,*,*,*,*,*\")\n    (set_attr \"pool_range\"     \"*,1020,*,*,*,*,*,*\")\n    (set_attr \"neg_pool_range\" \"*,1012,*,*,*,*,*,*\")]\n )\n@@ -110,7 +110,7 @@\n    case 7: return \\\"wstrw\\\\t%1, %0\\\";\n    default:return \\\"wstrw\\\\t%1, [sp, #-4]!\\;wldrw\\\\t%0, [sp], #4\\\\t@move CG reg\\\";\n   }\"\n-  [(set_attr \"type\"           \"*,*,load,store1,*,*,load,store1,*\")\n+  [(set_attr \"type\"           \"*,*,load1,store1,*,*,load1,store1,*\")\n    (set_attr \"length\"         \"*,*,*,        *,*,*,  16,     *,8\")\n    (set_attr \"pool_range\"     \"*,*,4096,     *,*,*,1024,     *,*\")\n    (set_attr \"neg_pool_range\" \"*,*,4084,     *,*,*,   *,  1012,*\")\n@@ -148,7 +148,7 @@\n    case 4: return \\\"tmcr%?\\\\t%0, %1\\\";\n    default: return \\\"tmrc%?\\\\t%0, %1\\\";\n   }\"\n-  [(set_attr \"type\"           \"*,*,load,store1,*,*\")\n+  [(set_attr \"type\"           \"*,*,load1,store1,*,*\")\n    (set_attr \"pool_range\"     \"*,*,4096,     *,*,*\")\n    (set_attr \"neg_pool_range\" \"*,*,4084,     *,*,*\")]\n )\n@@ -169,7 +169,7 @@\n    }\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"length\"         \"4,     4,   4,4,4,   8\")\n-   (set_attr \"type\"           \"*,store1,load,*,*,load\")\n+   (set_attr \"type\"           \"*,store1,load1,*,*,load1\")\n    (set_attr \"pool_range\"     \"*,     *, 256,*,*, 256\")\n    (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n \n@@ -189,7 +189,7 @@\n    }\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"length\"         \"4,     4,   4,4,4,   8\")\n-   (set_attr \"type\"           \"*,store1,load,*,*,load\")\n+   (set_attr \"type\"           \"*,store1,load1,*,*,load1\")\n    (set_attr \"pool_range\"     \"*,     *, 256,*,*, 256\")\n    (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n \n@@ -209,7 +209,7 @@\n    }\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"length\"         \"4,     4,   4,4,4,  24\")\n-   (set_attr \"type\"           \"*,store1,load,*,*,load\")\n+   (set_attr \"type\"           \"*,store1,load1,*,*,load1\")\n    (set_attr \"pool_range\"     \"*,     *, 256,*,*, 256\")\n    (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n \n@@ -225,7 +225,7 @@\n   \"* return output_move_double (operands);\"\n   [(set_attr \"predicable\"     \"yes\")\n    (set_attr \"length\"         \"8\")\n-   (set_attr \"type\"           \"load\")\n+   (set_attr \"type\"           \"load1\")\n    (set_attr \"pool_range\"     \"256\")\n    (set_attr \"neg_pool_range\" \"244\")])\n \n@@ -1149,7 +1149,7 @@\n   \"wsrawg%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"ashrdi3\"\n+(define_insn \"ashrdi3_iwmmxt\"\n   [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n \t\t   (match_operand:SI   2 \"register_operand\" \"z\")))]\n@@ -1173,7 +1173,7 @@\n   \"wsrlwg%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")])\n \n-(define_insn \"lshrdi3\"\n+(define_insn \"lshrdi3_iwmmxt\"\n   [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n \t\t     (match_operand:SI 2 \"register_operand\" \"z\")))]"}, {"sha": "cdf71151b58e42610cfe9f45a956212131805353", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -243,6 +243,25 @@ pc\t\t.req\tr15\n /* ------------------------------------------------------------------------ */\t\n .macro ARM_DIV_BODY dividend, divisor, result, curbit\n \n+#if __ARM_ARCH__ >= 5 && ! defined (__OPTIMIZE_SIZE__)\n+\n+\tclz\t\\curbit, \\dividend\n+\tclz\t\\result, \\divisor\n+\tsub\t\\curbit, \\result, \\curbit\n+\trsbs\t\\curbit, \\curbit, #31\n+\taddne\t\\curbit, \\curbit, \\curbit, lsl #1\n+\tmov\t\\result, #0\n+\taddne\tpc, pc, \\curbit, lsl #2\n+\tnop\n+\t.set\tshift, 32\n+\t.rept\t32\n+\t.set\tshift, shift - 1\n+\tcmp\t\\dividend, \\divisor, lsl #shift\n+\tadc\t\\result, \\result, \\result\n+\tsubcs\t\\dividend, \\dividend, \\divisor, lsl #shift\n+\t.endr\n+\n+#else /* __ARM_ARCH__ < 5 || defined (__OPTIMIZE_SIZE__) */\n #if __ARM_ARCH__ >= 5\n \n \tclz\t\\curbit, \\divisor\n@@ -253,7 +272,7 @@ pc\t\t.req\tr15\n \tmov\t\\curbit, \\curbit, lsl \\result\n \tmov\t\\result, #0\n \t\n-#else\n+#else /* __ARM_ARCH__ < 5 */\n \n \t@ Initially shift the divisor left 3 bits if possible,\n \t@ set curbit accordingly.  This allows for curbit to be located\n@@ -284,7 +303,7 @@ pc\t\t.req\tr15\n \n \tmov\t\\result, #0\n \n-#endif\n+#endif /* __ARM_ARCH__ < 5 */\n \n \t@ Division loop\n 1:\tcmp\t\\dividend, \\divisor\n@@ -304,6 +323,8 @@ pc\t\t.req\tr15\n \tmovne\t\\divisor,  \\divisor, lsr #4\n \tbne\t1b\n \n+#endif /* __ARM_ARCH__ < 5 || defined (__OPTIMIZE_SIZE__) */\n+\n .endm\n /* ------------------------------------------------------------------------ */\t\n .macro ARM_DIV2_ORDER divisor, order\n@@ -338,14 +359,30 @@ pc\t\t.req\tr15\n /* ------------------------------------------------------------------------ */\n .macro ARM_MOD_BODY dividend, divisor, order, spare\n \n+#if __ARM_ARCH__ >= 5 && ! defined (__OPTIMIZE_SIZE__)\n+\n+\tclz\t\\order, \\divisor\n+\tclz\t\\spare, \\dividend\n+\tsub\t\\order, \\order, \\spare\n+\trsbs\t\\order, \\order, #31\n+\taddne\tpc, pc, \\order, lsl #3\n+\tnop\n+\t.set\tshift, 32\n+\t.rept\t32\n+\t.set\tshift, shift - 1\n+\tcmp\t\\dividend, \\divisor, lsl #shift\n+\tsubcs\t\\dividend, \\dividend, \\divisor, lsl #shift\n+\t.endr\n+\n+#else /* __ARM_ARCH__ < 5 || defined (__OPTIMIZE_SIZE__) */\n #if __ARM_ARCH__ >= 5\n \n \tclz\t\\order, \\divisor\n \tclz\t\\spare, \\dividend\n \tsub\t\\order, \\order, \\spare\n \tmov\t\\divisor, \\divisor, lsl \\order\n \t\n-#else\n+#else /* __ARM_ARCH__ < 5 */\n \n \tmov\t\\order, #0\n \n@@ -367,7 +404,7 @@ pc\t\t.req\tr15\n \taddlo\t\\order, \\order, #1\n \tblo\t1b\n \n-#endif\n+#endif /* __ARM_ARCH__ < 5 */\n \n \t@ Perform all needed substractions to keep only the reminder.\n \t@ Do comparisons in batch of 4 first.\n@@ -404,6 +441,9 @@ pc\t\t.req\tr15\n 4:\tcmp\t\\dividend, \\divisor\n \tsubhs\t\\dividend, \\dividend, \\divisor\n 5:\n+\n+#endif /* __ARM_ARCH__ < 5 || defined (__OPTIMIZE_SIZE__) */\n+\n .endm\n /* ------------------------------------------------------------------------ */\n .macro THUMB_DIV_MOD_BODY modulo"}, {"sha": "bbfcbeb336089817a088264b05a3fb3eaeb42a5d", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -55,7 +55,7 @@\n    %{shared:-lc} \\\n    %{!shared:%{profile:-lc_p}%{!profile:-lc}}\"\n \n-#define LIBGCC_SPEC \"%{msoft-float:-lfloat} -lgcc\"\n+#define LIBGCC_SPEC \"%{msoft-float:-lfloat} %{mfloat-abi=soft*:-lfloat} -lgcc\"\n \n /* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add\n    the GNU/Linux magical crtbegin.o file (see crtstuff.c) which"}, {"sha": "5c6960ef899ff98db7da1fac1fd06367d1b87c11", "filename": "gcc/config/arm/netbsd-elf.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -57,14 +57,11 @@\n #define SUBTARGET_EXTRA_ASM_SPEC\t\\\n   \"-matpcs %{fpic|fpie:-k} %{fPIC|fPIE:-k}\"\n \n-/* Default floating point model is soft-VFP.\n-   FIXME: -mhard-float currently implies FPA.  */\n+/* Default to full VFP if -mhard-float is specified.  */\n #undef SUBTARGET_ASM_FLOAT_SPEC\n #define SUBTARGET_ASM_FLOAT_SPEC\t\\\n-  \"%{mhard-float:-mfpu=fpa} \\\n-   %{msoft-float:-mfpu=softvfp} \\\n-   %{!mhard-float: \\\n-     %{!msoft-float:-mfpu=softvfp}}\"\n+  \"%{mhard-float:{!mfpu=*:-mfpu=vfp}}   \\\n+   %{mfloat-abi=hard:{!mfpu=*:-mfpu=vfp}}\"\n \n #undef SUBTARGET_EXTRA_SPECS\n #define SUBTARGET_EXTRA_SPECS\t\t\t\t\\\n@@ -171,3 +168,7 @@ do\t\t\t\t\t\t\t\t\t\\\n     (void) sysarch (0, &s);\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n+\n+#undef FPUTYPE_DEFAULT\n+#define FPUTYPE_DEFAULT FPUTYPE_VFP\n+"}, {"sha": "0c9dadc208f8ac650894509f39afacc02600ce4f", "filename": "gcc/config/arm/semi.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fsemi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fsemi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsemi.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -64,7 +64,8 @@\n %{mcpu=*:-mcpu=%*} \\\n %{march=*:-march=%*} \\\n %{mapcs-float:-mfloat} \\\n-%{msoft-float:-mfpu=softfpa} \\\n+%{msoft-float:-mfloat-abi=soft} %{mhard-float:mfloat-abi=hard} \\\n+%{mfloat-abi=*} %{mfpu=*} \\\n %{mthumb-interwork:-mthumb-interwork} \\\n %(subtarget_extra_asm_spec)\"\n #endif"}, {"sha": "a4b6bfb334d5a50d08a8d8293e4c0b07ca82d21c", "filename": "gcc/config/arm/vfp.md", "status": "added", "additions": 744, "deletions": 0, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -0,0 +1,744 @@\n+;; ARM VFP coprocessor Machine Description\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;; Written by CodeSourcery, LLC.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.  */\n+\n+;; Additional register numbers\n+(define_constants\n+  [(VFPCC_REGNUM 95)]\n+)\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipeline description\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_automaton \"vfp11\")\n+\n+;; There are 3 pipelines in the VFP11 unit.\n+;;\n+;; - A 8-stage FMAC pipeline (7 execute + writeback) with forward from\n+;;   fourth stage for simple operations.\n+;;\n+;; - A 5-stage DS pipeline (4 execute + writeback) for divide/sqrt insns.\n+;;   These insns also uses first execute stage of FMAC pipeline.\n+;;\n+;; - A 4-stage LS pipeline (execute + 2 memory + writeback) with forward from\n+;;   second memory stage for loads.\n+\n+;; We do not model Write-After-Read hazards.\n+;; We do not do write scheduling with the arm core, so it is only neccessary\n+;; to model the first stage of each pieline\n+;; ??? Need to model LS pipeline properly for load/store multiple?\n+;; We do not model fmstat properly.  This could be done by modeiling pipelines\n+;; properly and defining an absence set between a dummy fmstat unit and all\n+;; other vfp units.\n+\n+(define_cpu_unit \"fmac\" \"vfp11\")\n+\n+(define_cpu_unit \"ds\" \"vfp11\")\n+\n+(define_cpu_unit \"vfp_ls\" \"vfp11\")\n+\n+;; The VFP \"type\" attributes differ from those used in the FPA model.\n+;; ffarith\tFast floating point insns, eg. abs, neg, cpy, cmp.\n+;; farith\tMost arithmetic insns.\n+;; fmul\t\tDouble preision multiply.\n+;; fdivs\tSingle precision sqrt or division.\n+;; fdivd\tDouble precision sqrt or division.\n+;; f_load\tFloating point load from memory.\n+;; f_store\tFloating point store to memory.\n+;; f_2_r\tTransfer vfp to arm reg.\n+;; r_2_f\tTransfer arm to vfp reg.\n+\n+(define_insn_reservation \"vfp_ffarith\" 4\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"ffarith\"))\n+ \"fmac\")\n+\n+(define_insn_reservation \"vfp_farith\" 8\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"farith\"))\n+ \"fmac\")\n+\n+(define_insn_reservation \"vfp_fmul\" 9\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"fmul\"))\n+ \"fmac*2\")\n+\n+(define_insn_reservation \"vfp_fdivs\" 19\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"fdivs\"))\n+ \"ds*15\")\n+\n+(define_insn_reservation \"vfp_fdivd\" 33\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"fdivd\"))\n+ \"fmac+ds*29\")\n+\n+;; Moves to/from arm regs also use the load/store pipeline.\n+(define_insn_reservation \"vfp_fload\" 4\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"f_load,r_2_f\"))\n+ \"vfp_ls\")\n+\n+(define_insn_reservation \"vfp_fstore\" 4\n+ (and (eq_attr \"fpu\" \"vfp\")\n+      (eq_attr \"type\" \"f_load,f_2_r\"))\n+ \"vfp_ls\")\n+\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Insn pattersn\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; SImode moves\n+;; ??? For now do not allow loading constants into vfp regs.  This causes\n+;; problems because small sonstants get converted into adds.\n+(define_insn \"*arm_movsi_vfp\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r ,m,!w,r,!w,!w, U\")\n+      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,mi,r,r,!w,!w,Ui,!w\"))]\n+  \"TARGET_ARM && TARGET_VFP && TARGET_HARD_FLOAT\n+   && (   s_register_operand (operands[0], SImode)\n+       || s_register_operand (operands[1], SImode))\"\n+  \"@\n+  mov%?\\\\t%0, %1\n+  mvn%?\\\\t%0, #%B1\n+  ldr%?\\\\t%0, %1\n+  str%?\\\\t%1, %0\n+  fmsr%?\\\\t%0, %1\\\\t%@ int\n+  fmrs%?\\\\t%0, %1\\\\t%@ int\n+  fcpys%?\\\\t%0, %1\\\\t%@ int\n+  flds%?\\\\t%0, %1\\\\t%@ int\n+  fsts%?\\\\t%1, %0\\\\t%@ int\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"*,*,load1,store1,r_2_f,f_2_r,ffarith,f_load,f_store\")\n+   (set_attr \"pool_range\"     \"*,*,4096,*,*,*,*,1020,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,4084,*,*,*,*,1008,*\")]\n+)\n+\n+\n+;; DImode moves\n+\n+(define_insn \"*arm_movdi_vfp\"\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r,o<>,w,r,w,w ,U\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r ,r,w,w,Ui,w\"))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0: case 1: case 2:\n+      return (output_move_double (operands));\n+    case 3:\n+      return \\\"fmdrr%?\\\\t%P0, %1\\\\t%@ int\\\";\n+    case 4:\n+      return \\\"fmrrd%?\\\\t%0, %1\\\\t%@ int\\\";\n+    case 5:\n+      return \\\"fcpyd%?\\\\t%P0, %P1\\\\t%@ int\\\";\n+    case 6:\n+      return \\\"fldd%?\\\\t%P0, %1\\\\t%@ int\\\";\n+    case 7:\n+      return \\\"fstd%?\\\\t%P1, %0\\\\t%@ int\\\";\n+    default:\n+      abort ();\n+    }\n+  \"\n+  [(set_attr \"type\" \"*,load2,store2,r_2_f,f_2_r,ffarith,f_load,f_store\")\n+   (set_attr \"length\" \"8,8,8,4,4,4,4,4\")\n+   (set_attr \"pool_range\"     \"*,1020,*,*,*,*,1020,*\")\n+   (set_attr \"neg_pool_range\" \"*,1008,*,*,*,*,1008,*\")]\n+)\n+\n+\n+;; SFmode moves\n+\n+(define_insn \"*movsf_vfp\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=w,r,w ,U,r ,m,w,r\")\n+\t(match_operand:SF 1 \"general_operand\"\t   \" r,w,UE,w,mE,r,w,r\"))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n+   && (   s_register_operand (operands[0], SFmode)\n+       || s_register_operand (operands[1], SFmode))\"\n+  \"@\n+  fmsr%?\\\\t%0, %1\n+  fmrs%?\\\\t%0, %1\n+  flds%?\\\\t%0, %1\n+  fsts%?\\\\t%1, %0\n+  ldr%?\\\\t%0, %1\\\\t%@ float\n+  str%?\\\\t%1, %0\\\\t%@ float\n+  fcpys%?\\\\t%0, %1\n+  mov%?\\\\t%0, %1\\\\t%@ float\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,f_load,f_store,load1,store1\")\n+   (set_attr \"pool_range\" \"*,*,1020,*,4096,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,1008,*,4080,*,*,*\")]\n+)\n+\n+\n+;; DFmode moves\n+\n+(define_insn \"*movdf_vfp\"\n+  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,r,r, m,w ,U,w,r\")\n+\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" r,w,mF,r,UF,w,w,r\"))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"*\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+\treturn \\\"fmdrr%?\\\\t%P0, %Q1, %R1\\\";\n+      case 1:\n+\treturn \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\";\n+      case 2: case 3: case 7:\n+\treturn output_move_double (operands);\n+      case 4:\n+\treturn \\\"fldd%?\\\\t%P0, %1\\\";\n+      case 5:\n+\treturn \\\"fstd%?\\\\t%P1, %0\\\";\n+      case 6:\n+\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n+      default:\n+\tabort ();\n+      }\n+    }\n+  \"\n+  [(set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,load2,store2,f_load,f_store\")\n+   (set_attr \"length\" \"4,4,8,8,4,4,4,8\")\n+   (set_attr \"pool_range\" \"*,*,1020,*,1020,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,1008,*,1008,*,*,*\")]\n+)\n+\n+\n+;; Conditional move patterns\n+\n+(define_insn \"*movsfcc_vfp\"\n+  [(set (match_operand:SF   0 \"s_register_operand\" \"=w,w,w,w,w,w,?r,?r,?r\")\n+\t(if_then_else:SF\n+\t  (match_operator   3 \"arm_comparison_operator\"\n+\t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n+\t  (match_operand:SF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n+\t  (match_operand:SF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"@\n+   fcpys%D3\\\\t%0, %2\n+   fcpys%d3\\\\t%0, %1\n+   fcpys%D3\\\\t%0, %2\\;fcpys%d3\\\\t%0, %1\n+   fmsr%D3\\\\t%0, %2\n+   fmsr%d3\\\\t%0, %1\n+   fmsr%D3\\\\t%0, %2\\;fmsr%d3\\\\t%0, %1\n+   fmrs%D3\\\\t%0, %2\n+   fmrs%d3\\\\t%0, %1\n+   fmrs%D3\\\\t%0, %2\\;fmrs%d3\\\\t%0, %1\"\n+   [(set_attr \"conds\" \"use\")\n+    (set_attr \"length\" \"4,4,8,4,4,8,4,4,8\")\n+    (set_attr \"type\" \"ffarith,ffarith,ffarith,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r\")]\n+)\n+\n+(define_insn \"*movdfcc_vfp\"\n+  [(set (match_operand:DF   0 \"s_register_operand\" \"=w,w,w,w,w,w,?r,?r,?r\")\n+\t(if_then_else:DF\n+\t  (match_operator   3 \"arm_comparison_operator\"\n+\t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n+\t  (match_operand:DF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n+\t  (match_operand:DF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"@\n+   fcpyd%D3\\\\t%P0, %P2\n+   fcpyd%d3\\\\t%P0, %P1\n+   fcpyd%D3\\\\t%P0, %P2\\;fcpyd%d3\\\\t%P0, %P1\n+   fmdrr%D3\\\\t%P0, %Q2, %R2\n+   fmdrr%d3\\\\t%P0, %Q1, %R1\n+   fmdrr%D3\\\\t%P0, %Q2, %R2\\;fmdrr%d3\\\\t%P0, %Q1, %R1\n+   fmrrd%D3\\\\t%Q0, %R0, %P2\n+   fmrrd%d3\\\\t%Q0, %R0, %P1\n+   fmrrd%D3\\\\t%Q0, %R0, %P2\\;fmrrd%d3\\\\t%Q0, %R0, %P1\"\n+   [(set_attr \"conds\" \"use\")\n+    (set_attr \"length\" \"4,4,8,4,4,8,4,4,8\")\n+    (set_attr \"type\" \"ffarith,ffarith,ffarith,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r\")]\n+)\n+\n+\n+;; Sign manipulation functions\n+\n+(define_insn \"*abssf2_vfp\"\n+  [(set (match_operand:SF\t  0 \"s_register_operand\" \"=w\")\n+\t(abs:SF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fabss%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn \"*absdf2_vfp\"\n+  [(set (match_operand:DF\t  0 \"s_register_operand\" \"=w\")\n+\t(abs:DF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fabsd%?\\\\t%P0, %P1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn \"*negsf2_vfp\"\n+  [(set (match_operand:SF\t  0 \"s_register_operand\" \"+w\")\n+\t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnegs%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn \"*negdf2_vfp\"\n+  [(set (match_operand:DF\t  0 \"s_register_operand\" \"+w\")\n+\t(neg:DF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnegd%?\\\\t%P0, %P1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+\n+;; Arithmetic insns\n+\n+(define_insn \"*addsf3_vfp\"\n+  [(set (match_operand:SF\t   0 \"s_register_operand\" \"=w\")\n+\t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n+\t\t (match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fadds%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*adddf3_vfp\"\n+  [(set (match_operand:DF\t   0 \"s_register_operand\" \"=w\")\n+\t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n+\t\t (match_operand:DF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"faddd%?\\\\t%P0, %P1, %P2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+\n+(define_insn \"*subsf3_vfp\"\n+  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=w\")\n+\t(minus:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n+\t\t  (match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fsubs%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*subdf3_vfp\"\n+  [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n+\t(minus:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n+\t\t  (match_operand:DF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fsubd%?\\\\t%P0, %P1, %P2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+\n+;; Division insns\n+\n+(define_insn \"*divsf3_vfp\"\n+  [(set (match_operand:SF\t  0 \"s_register_operand\" \"+w\")\n+\t(div:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n+\t\t(match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fdivs%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fdivs\")]\n+)\n+\n+(define_insn \"*divdf3_vfp\"\n+  [(set (match_operand:DF\t  0 \"s_register_operand\" \"+w\")\n+\t(div:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n+\t\t(match_operand:DF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fdivd%?\\\\t%P0, %P1, %P2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fdivd\")]\n+)\n+\n+\n+;; Multiplication insns\n+\n+(define_insn \"*mulsf3_vfp\"\n+  [(set (match_operand:SF\t   0 \"s_register_operand\" \"+w\")\n+\t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"w\")\n+\t\t (match_operand:SF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmuls%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*muldf3_vfp\"\n+  [(set (match_operand:DF\t   0 \"s_register_operand\" \"+w\")\n+\t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n+\t\t (match_operand:DF 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmuld%?\\\\t%P0, %P1, %P2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fmul\")]\n+)\n+\n+\n+(define_insn \"*mulsf3negsf_vfp\"\n+  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"+w\")\n+\t(mult:SF (neg:SF (match_operand:SF 1 \"s_register_operand\" \"w\"))\n+\t\t (match_operand:SF\t   2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnmuls%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*muldf3negdf_vfp\"\n+  [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"+w\")\n+\t(mult:DF (neg:DF (match_operand:DF 1 \"s_register_operand\" \"w\"))\n+\t\t (match_operand:DF\t   2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnmuld%?\\\\t%P0, %P1, %P2\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fmul\")]\n+)\n+\n+\n+;; Multiply-accumulate insns\n+\n+;; 0 = 1 * 2 + 0\n+(define_insn \"*mulsf3addsf_vfp\"\n+  [(set (match_operand:SF\t\t    0 \"s_register_operand\" \"=w\")\n+\t(plus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"w\")\n+\t\t\t  (match_operand:SF 3 \"s_register_operand\" \"w\"))\n+\t\t (match_operand:SF\t    1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmacs%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*muldf3adddf_vfp\"\n+  [(set (match_operand:DF\t\t    0 \"s_register_operand\" \"=w\")\n+\t(plus:DF (mult:DF (match_operand:DF 2 \"s_register_operand\" \"w\")\n+\t\t\t  (match_operand:DF 3 \"s_register_operand\" \"w\"))\n+\t\t (match_operand:DF\t    1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmacd%?\\\\t%P0, %P2, %P3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fmul\")]\n+)\n+\n+;; 0 = 1 * 2 - 0\n+(define_insn \"*mulsf3subsf_vfp\"\n+  [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=w\")\n+\t(minus:SF (mult:SF (match_operand:SF 2 \"s_register_operand\" \"w\")\n+\t\t\t   (match_operand:SF 3 \"s_register_operand\" \"w\"))\n+\t\t  (match_operand:SF\t     1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmscs%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*muldf3subdf_vfp\"\n+  [(set (match_operand:DF\t\t     0 \"s_register_operand\" \"=w\")\n+\t(minus:DF (mult:DF (match_operand:DF 2 \"s_register_operand\" \"w\")\n+\t\t\t   (match_operand:DF 3 \"s_register_operand\" \"w\"))\n+\t\t  (match_operand:DF\t     1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmscd%?\\\\t%P0, %P2, %P3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fmul\")]\n+)\n+\n+;; 0 = -(1 * 2) + 0\n+(define_insn \"*mulsf3negsfaddsf_vfp\"\n+  [(set (match_operand:SF\t\t     0 \"s_register_operand\" \"=w\")\n+\t(minus:SF (match_operand:SF\t     1 \"s_register_operand\" \"0\")\n+\t\t  (mult:SF (match_operand:SF 2 \"s_register_operand\" \"w\")\n+\t\t\t   (match_operand:SF 3 \"s_register_operand\" \"w\"))))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnmacs%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*fmuldf3negdfadddf_vfp\"\n+  [(set (match_operand:DF\t\t     0 \"s_register_operand\" \"=w\")\n+\t(minus:DF (match_operand:DF\t     1 \"s_register_operand\" \"0\")\n+\t\t  (mult:DF (match_operand:DF 2 \"s_register_operand\" \"w\")\n+\t\t\t   (match_operand:DF 3 \"s_register_operand\" \"w\"))))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnmacd%?\\\\t%P0, %P2, %P3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fmul\")]\n+)\n+\n+\n+;; 0 = -(1 * 2) - 0\n+(define_insn \"*mulsf3negsfsubsf_vfp\"\n+  [(set (match_operand:SF\t\t      0 \"s_register_operand\" \"=w\")\n+\t(minus:SF (mult:SF\n+\t\t    (neg:SF (match_operand:SF 2 \"s_register_operand\" \"w\"))\n+\t\t    (match_operand:SF\t      3 \"s_register_operand\" \"w\"))\n+\t\t  (match_operand:SF\t      1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnmscs%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*muldf3negdfsubdf_vfp\"\n+  [(set (match_operand:DF\t\t      0 \"s_register_operand\" \"=w\")\n+\t(minus:DF (mult:DF\n+\t\t    (neg:DF (match_operand:DF 2 \"s_register_operand\" \"w\"))\n+\t\t    (match_operand:DF\t      3 \"s_register_operand\" \"w\"))\n+\t\t  (match_operand:DF\t      1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fnmscd%?\\\\t%P0, %P2, %P3\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fmul\")]\n+)\n+\n+\n+;; Conversion routines\n+\n+(define_insn \"*extendsfdf2_vfp\"\n+  [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"=w\")\n+\t(float_extend:DF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fcvtds%?\\\\t%P0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*truncdfsf2_vfp\"\n+  [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=w\")\n+\t(float_truncate:SF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fcvtsd%?\\\\t%0, %P1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*truncsisf2_vfp\"\n+  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=w\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"s_register_operand\" \"w\"))))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"ftosizs%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*truncsidf2_vfp\"\n+  [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=w\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"w\"))))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"ftosizd%?\\\\t%0, %P1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*floatsisf2_vfp\"\n+  [(set (match_operand:SF\t    0 \"s_register_operand\" \"=w\")\n+\t(float:SF (match_operand:SI 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fsitos%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+(define_insn \"*floatsidf2_vfp\"\n+  [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n+\t(float:DF (match_operand:SI 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fsitod%?\\\\t%P0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"farith\")]\n+)\n+\n+\n+;; Sqrt insns.\n+\n+(define_insn \"*sqrtsf2_vfp\"\n+  [(set (match_operand:SF\t   0 \"s_register_operand\" \"=w\")\n+\t(sqrt:SF (match_operand:SF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fsqrts%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fdivs\")]\n+)\n+\n+(define_insn \"*sqrtdf2_vfp\"\n+  [(set (match_operand:DF\t   0 \"s_register_operand\" \"=w\")\n+\t(sqrt:DF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fsqrtd%?\\\\t%P0, %P1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"fdivd\")]\n+)\n+\n+\n+;; Patterns to split/copy vfp condition flags.\n+\n+(define_insn \"*movcc_vfp\"\n+  [(set (reg CC_REGNUM)\n+\t(reg VFPCC_REGNUM))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"fmstat%?\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn_and_split \"*cmpsf_split_vfp\"\n+  [(set (reg:CCFP CC_REGNUM)\n+\t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"w\")\n+\t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"wG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"#\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  [(set (reg:CCFP VFPCC_REGNUM)\n+\t(compare:CCFP (match_dup 0)\n+\t\t      (match_dup 1)))\n+   (set (reg:CCFP CC_REGNUM)\n+\t(reg:CCFP VFPCC_REGNUM))]\n+  \"\"\n+)\n+\n+(define_insn_and_split \"*cmpsf_trap_split_vfp\"\n+  [(set (reg:CCFPE CC_REGNUM)\n+\t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"w\")\n+\t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"wG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"#\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  [(set (reg:CCFPE VFPCC_REGNUM)\n+\t(compare:CCFPE (match_dup 0)\n+\t\t       (match_dup 1)))\n+   (set (reg:CCFPE CC_REGNUM)\n+\t(reg:CCFPE VFPCC_REGNUM))]\n+  \"\"\n+)\n+\n+(define_insn_and_split \"*cmpdf_split_vfp\"\n+  [(set (reg:CCFP CC_REGNUM)\n+\t(compare:CCFP (match_operand:DF 0 \"s_register_operand\"  \"w\")\n+\t\t      (match_operand:DF 1 \"vfp_compare_operand\" \"wG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"#\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  [(set (reg:CCFP VFPCC_REGNUM)\n+\t(compare:CCFP (match_dup 0)\n+\t\t       (match_dup 1)))\n+   (set (reg:CCFP CC_REGNUM)\n+\t(reg:CCFPE VFPCC_REGNUM))]\n+  \"\"\n+)\n+\n+(define_insn_and_split \"*cmpdf_trap_split_vfp\"\n+  [(set (reg:CCFPE CC_REGNUM)\n+\t(compare:CCFPE (match_operand:DF 0 \"s_register_operand\"  \"w\")\n+\t\t       (match_operand:DF 1 \"vfp_compare_operand\" \"wG\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"#\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  [(set (reg:CCFPE VFPCC_REGNUM)\n+\t(compare:CCFPE (match_dup 0)\n+\t\t       (match_dup 1)))\n+   (set (reg:CCFPE CC_REGNUM)\n+\t(reg:CCFPE VFPCC_REGNUM))]\n+  \"\"\n+)\n+\n+\n+;; Comparison patterns\n+\n+(define_insn \"*cmpsf_vfp\"\n+  [(set (reg:CCFP VFPCC_REGNUM)\n+\t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"w,w\")\n+\t\t      (match_operand:SF 1 \"vfp_compare_operand\" \"w,G\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"@\n+   fcmps%?\\\\t%0, %1\n+   fcmpzs%?\\\\t%0\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn \"*cmpsf_trap_vfp\"\n+  [(set (reg:CCFPE VFPCC_REGNUM)\n+\t(compare:CCFPE (match_operand:SF 0 \"s_register_operand\"  \"w,w\")\n+\t\t       (match_operand:SF 1 \"vfp_compare_operand\" \"w,G\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"@\n+   fcmpes%?\\\\t%0, %1\n+   fcmpezs%?\\\\t%0\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn \"*cmpdf_vfp\"\n+  [(set (reg:CCFP VFPCC_REGNUM)\n+\t(compare:CCFP (match_operand:DF 0 \"s_register_operand\"  \"w,w\")\n+\t\t      (match_operand:DF 1 \"vfp_compare_operand\" \"w,G\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"@\n+   fcmpd%?\\\\t%P0, %P1\n+   fcmpzd%?\\\\t%P0\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+(define_insn \"*cmpdf_trap_vfp\"\n+  [(set (reg:CCFPE VFPCC_REGNUM)\n+\t(compare:CCFPE (match_operand:DF 0 \"s_register_operand\"  \"w,w\")\n+\t\t       (match_operand:DF 1 \"vfp_compare_operand\" \"w,G\")))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"@\n+   fcmped%?\\\\t%P0, %P1\n+   fcmpezd%?\\\\t%P0\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"ffarith\")]\n+)\n+\n+\n+;; Store multiple insn used in function prologue.\n+\n+(define_insn \"*push_multi_vfp\"\n+  [(match_parallel 2 \"multi_register_push\"\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n+\t  (unspec:BLK [(match_operand:DF 1 \"s_register_operand\" \"w\")]\n+\t\t      UNSPEC_PUSH_MULT))])]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"* return vfp_output_fstmx (operands);\"\n+  [(set_attr \"type\" \"f_store\")]\n+)\n+\n+\n+;; Unimplemented insns:\n+;; fldm*\n+;; fstm*\n+;; fmdhr et al (VFPv1)\n+;; Support for xD (single precisio only) variants.\n+;; fmrrs, fmsrr\n+;; fuito*\n+;; ftoui*"}, {"sha": "8379fe773bb872b8344f494b443eb0f06ee7f5c2", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -926,12 +926,13 @@ and SPARC@.\n @itemx --with-arch=@var{cpu}\n @itemx --with-tune=@var{cpu}\n @itemx --with-abi=@var{abi}\n+@itemx --with-fpu=@var{type}\n @itemx --with-float=@var{type}\n These configure options provide default values for the @option{-mschedule=},\n-@option{-march=}, @option{-mtune=}, and @option{-mabi=} options and for\n-@option{-mhard-float} or @option{-msoft-float}.  As with @option{--with-cpu},\n-which switches will be accepted and acceptable values of the arguments depend\n-on the target.\n+@option{-march=}, @option{-mtune=}, @option{-mabi=}, and @option{-mfpu=}\n+options and for @option{-mhard-float} or @option{-msoft-float}.  As with\n+@option{--with-cpu}, which switches will be accepted and acceptable values\n+of the arguments depend on the target.\n \n @item --enable-altivec\n Specify that the target supports AltiVec vector enhancements.  This"}, {"sha": "5e7897c6c11c784c52c7d48a7222d143e19cbd2f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -375,9 +375,9 @@ in the following sections.\n -msched-prolog  -mno-sched-prolog @gol\n -mlittle-endian  -mbig-endian  -mwords-little-endian @gol\n -malignment-traps  -mno-alignment-traps @gol\n--msoft-float  -mhard-float  -mfpe @gol\n+-mfloat-abi=@var{name}  soft-float  -mhard-float  -mfpe @gol\n -mthumb-interwork  -mno-thumb-interwork @gol\n--mcpu=@var{name}  -march=@var{name}  -mfpe=@var{name}  @gol\n+-mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  @gol\n -mstructure-size-boundary=@var{n} @gol\n -mabort-on-noreturn @gol\n -mlong-calls  -mno-long-calls @gol\n@@ -6497,6 +6497,16 @@ this option.  In particular, you need to compile @file{libgcc.a}, the\n library that comes with GCC, with @option{-msoft-float} in order for\n this to work.\n \n+@item -mfloat-abi=@var{name}\n+@opindex mfloat-abi\n+Specifies which ABI to use for floating point values.  Permissible values\n+are: @samp{soft}, @samp{softfp} and @samp{hard}.\n+\n+@samp{soft} and @samp{hard} are equivalent to @option{-msoft-float}\n+and @option{-mhard-float} respectively.  @samp{softfp} allows the generation\n+of floating point instructions, but still uses the soft-float calling\n+conventions.\n+\n @item -mlittle-endian\n @opindex mlittle-endian\n Generate code for a processor running in little-endian mode.  This is\n@@ -6595,16 +6605,23 @@ name to determine what kind of instructions it can emit when generating\n assembly code.  This option can be used in conjunction with or instead\n of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},\n @samp{armv2a}, @samp{armv3}, @samp{armv3m}, @samp{armv4}, @samp{armv4t},\n-@samp{armv5}, @samp{armv5t}, @samp{armv5te}, @samp{armv6j},\n+@samp{armv5}, @samp{armv5t}, @samp{armv5te}, @samp{armv6}, @samp{armv6j},\n @samp{iwmmxt}, @samp{ep9312}.\n \n-@item -mfpe=@var{number}\n+@item -mfpu=@var{name}\n+@itemx -mfpe=@var{number}\n @itemx -mfp=@var{number}\n+@opindex mfpu\n @opindex mfpe\n @opindex mfp\n-This specifies the version of the floating point emulation available on\n-the target.  Permissible values are 2 and 3.  @option{-mfp=} is a synonym\n-for @option{-mfpe=}, for compatibility with older versions of GCC@.\n+This specifies what floating point hardware (or hardware emulation) is\n+available on the target.  Permissible names are: @samp{fpa}, @samp{fpe2},\n+@samp{fpe3}, @samp{maverick}, @samp{vfp}.  @option{-mfp} and @option{-mfpe}\n+are synonyms for @option{-mpfu}=@samp{fpe}@var{number}, for compatibility\n+with older versions of GCC@.\n+\n+If @option{-msoft-float} is specified this specifies the format of\n+floating point values.\n \n @item -mstructure-size-boundary=@var{n}\n @opindex mstructure-size-boundary"}, {"sha": "131280cae1915ab2f105f4990c635bb85b7b77fe", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -1340,6 +1340,9 @@ available on some particular machines.\n @item f\n Floating-point register\n \n+@item w\n+VFP floating-point register\n+\n @item F\n One of the floating-point constants 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0\n or 10.0\n@@ -1376,6 +1379,9 @@ An item in the constant pool\n A symbol in the text segment of the current file\n @end table\n \n+@item U\n+A memory reference suitable for VFP load/store insns (reg+constant offset)\n+\n @item AVR family---@file{avr.h}\n @table @code\n @item l"}, {"sha": "03150201103bb13825b74fc05bd5bb39254776a1", "filename": "gcc/longlong.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b66ebb1460daae2b046d62d50d7c3c835ba1c43/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=9b66ebb1460daae2b046d62d50d7c3c835ba1c43", "patch": "@@ -186,7 +186,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n UDItype __umulsidi3 (USItype, USItype);\n #endif\n \n-#if defined (__arm__) && W_TYPE_SIZE == 32\n+#if defined (__arm__) && !defined (__thumb__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"adds\t%1, %4, %5\\n\\tadc\t%0, %2, %3\"\t\t\\\n \t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\"}]}