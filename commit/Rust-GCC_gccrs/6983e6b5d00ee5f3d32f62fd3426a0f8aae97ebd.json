{"sha": "6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk4M2U2YjVkMDBlZTVmM2QzMmY2MmZkMzQyNmEwZjhhYWU5N2ViZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-04-17T12:13:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-17T12:13:37Z"}, "message": "tree-vect-slp.c (vect_build_slp_tree_1): Split out from ...\n\n2013-04-17  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Split out from ...\n\t(vect_build_slp_tree): ... here.\n\t(vect_build_slp_tree_1): Compute which stmts of the SLP group\n\tmatch.  Remove special-casing of mismatched complex loads.\n\t(vect_build_slp_tree): Based on the result from vect_build_slp_tree_1\n\tre-try the match with swapped commutative operands.\n\t(vect_supported_load_permutation_p): Remove special-casing of\n\tmismatched complex loads.\n\t(vect_analyze_slp_instance): Adjust.\n\nFrom-SVN: r198026", "tree": {"sha": "b0a8d4233b3bf48c21f3d16ff28a3006aa3a5c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0a8d4233b3bf48c21f3d16ff28a3006aa3a5c51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef23e6a2d730a0f57afa958768dba05d0ee36d10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef23e6a2d730a0f57afa958768dba05d0ee36d10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef23e6a2d730a0f57afa958768dba05d0ee36d10"}], "stats": {"total": 379, "additions": 205, "deletions": 174}, "files": [{"sha": "416871c8fe3c911e18a9864ccfc496fe42170152", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd", "patch": "@@ -1,3 +1,15 @@\n+2013-04-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Split out from ...\n+\t(vect_build_slp_tree): ... here.\n+\t(vect_build_slp_tree_1): Compute which stmts of the SLP group\n+\tmatch.  Remove special-casing of mismatched complex loads.\n+\t(vect_build_slp_tree): Based on the result from vect_build_slp_tree_1\n+\tre-try the match with swapped commutative operands.\n+\t(vect_supported_load_permutation_p): Remove special-casing of\n+\tmismatched complex loads.\n+\t(vect_analyze_slp_instance): Adjust.\n+\n 2013-04-17  Richard Biener  <rguenther@suse.de>\n \n \tPR rtl-optimization/56921"}, {"sha": "4dc79f408402b3a0eced71767e019595f588ee9a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 193, "deletions": 174, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6983e6b5d00ee5f3d32f62fd3426a0f8aae97ebd", "patch": "@@ -376,25 +376,25 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n }\n \n \n-/* Recursively build an SLP tree starting from NODE.\n-   Fail (and return FALSE) if def-stmts are not isomorphic, require data\n-   permutation or are of unsupported types of operation.  Otherwise, return\n-   TRUE.  */\n+/* Verify if the scalar stmts STMTS are isomorphic, require data\n+   permutation or are of unsupported types of operation.  Return\n+   true if they are, otherwise return false and indicate in *MATCHES\n+   which stmts are not isomorphic to the first one.  If MATCHES[0]\n+   is false then this indicates the comparison could not be\n+   carried out or the stmts will never be vectorized by SLP.  */\n \n static bool\n-vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-                     slp_tree *node, unsigned int group_size,\n-                     unsigned int *max_nunits,\n-                     vec<slp_tree> *loads,\n-                     unsigned int vectorization_factor)\n+vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+\t\t       vec<gimple> stmts, unsigned int group_size,\n+\t\t       unsigned nops, unsigned int *max_nunits,\n+\t\t       unsigned int vectorization_factor, bool *matches)\n {\n   unsigned int i;\n-  vec<gimple> stmts = SLP_TREE_SCALAR_STMTS (*node);\n   gimple stmt = stmts[0];\n   enum tree_code first_stmt_code = ERROR_MARK, rhs_code = ERROR_MARK;\n   enum tree_code first_cond_code = ERROR_MARK;\n   tree lhs;\n-  bool stop_recursion = false, need_same_oprnds = false;\n+  bool need_same_oprnds = false;\n   tree vectype, scalar_type, first_op1 = NULL_TREE;\n   optab optab;\n   int icode;\n@@ -403,27 +403,13 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   struct data_reference *first_dr;\n   HOST_WIDE_INT dummy;\n   gimple first_load = NULL, prev_first_load = NULL, old_first_load = NULL;\n-  vec<slp_oprnd_info> oprnds_info;\n-  unsigned int nops;\n-  slp_oprnd_info oprnd_info;\n   tree cond;\n \n-  if (is_gimple_call (stmt))\n-    nops = gimple_call_num_args (stmt);\n-  else if (is_gimple_assign (stmt))\n-    {\n-      nops = gimple_num_ops (stmt) - 1;\n-      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n-\tnops++;\n-    }\n-  else\n-    return false;\n-\n-  oprnds_info = vect_create_oprnd_info (nops, group_size);\n-\n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n+      matches[i] = false;\n+\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for \");\n@@ -439,8 +425,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       \"Build SLP failed: unvectorizable statement \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n-\n-\t  vect_free_oprnd_info (oprnds_info);\n+\t  /* Fatal mismatch.  */\n+\t  matches[0] = false;\n           return false;\n         }\n \n@@ -454,8 +440,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       \"GIMPLE_CALL \");\n \t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t    }\n-\n-\t  vect_free_oprnd_info (oprnds_info);\n+\t  /* Fatal mismatch.  */\n+\t  matches[0] = false;\n \t  return false;\n \t}\n \n@@ -471,8 +457,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       \"comparison \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n-\n-\t  vect_free_oprnd_info (oprnds_info);\n+\t  /* Fatal mismatch.  */\n+\t  matches[0] = false;\n           return false;\n         }\n \n@@ -487,8 +473,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t scalar_type);\n             }\n-\n-\t  vect_free_oprnd_info (oprnds_info);\n+\t  /* Fatal mismatch.  */\n+\t  matches[0] = false;\n           return false;\n         }\n \n@@ -515,8 +501,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"Build SLP failed: unsupported call type \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n-\n-\t      vect_free_oprnd_info (oprnds_info);\n+\t      /* Fatal mismatch.  */\n+\t      matches[0] = false;\n \t      return false;\n \t    }\n \t}\n@@ -552,7 +538,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: no optab.\");\n-\t  \t      vect_free_oprnd_info (oprnds_info);\n+\t\t      /* Fatal mismatch.  */\n+\t\t      matches[0] = false;\n \t\t      return false;\n \t\t    }\n \t\t  icode = (int) optab_handler (optab, vec_mode);\n@@ -562,7 +549,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: \"\n \t\t\t\t\t \"op not supported by target.\");\n-\t  \t      vect_free_oprnd_info (oprnds_info);\n+\t\t      /* Fatal mismatch.  */\n+\t\t      matches[0] = false;\n \t\t      return false;\n \t\t    }\n \t\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n@@ -600,9 +588,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"in stmt \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n-\n-\t      vect_free_oprnd_info (oprnds_info);\n-\t      return false;\n+\t      /* Mismatch.  */\n+\t      continue;\n \t    }\n \n \t  if (need_same_oprnds\n@@ -615,9 +602,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"arguments in \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n-\n-\t      vect_free_oprnd_info (oprnds_info);\n-\t      return false;\n+\t      /* Mismatch.  */\n+\t      continue;\n \t    }\n \n \t  if (rhs_code == CALL_EXPR)\n@@ -636,9 +622,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n \t\t    }\n-\n-\t\t  vect_free_oprnd_info (oprnds_info);\n-\t\t  return false;\n+\t\t  /* Mismatch.  */\n+\t\t  continue;\n \t\t}\n \t    }\n \t}\n@@ -649,12 +634,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (REFERENCE_CLASS_P (lhs))\n \t    {\n \t      /* Store.  */\n-\t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo,\n-\t\t\t\t\t\tstmt, (i == 0), &oprnds_info))\n-\t\t{\n-\t  \t  vect_free_oprnd_info (oprnds_info);\n- \t\t  return false;\n-\t\t}\n+\t      ;\n \t    }\n \t  else\n \t    {\n@@ -681,8 +661,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n                     }\n-\n-\t  \t  vect_free_oprnd_info (oprnds_info);\n+\t\t  /* Fatal mismatch.  */\n+\t\t  matches[0] = false;\n                   return false;\n                 }\n \n@@ -705,8 +685,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n                     }\n-\n-\t  \t  vect_free_oprnd_info (oprnds_info);\n+\t\t  /* Fatal mismatch.  */\n+\t\t  matches[0] = false;\n                   return false;\n                 }\n \n@@ -715,11 +695,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               if (prev_first_load)\n                 {\n                   /* Check that there are no loads from different interleaving\n-                     chains in the same node.  The only exception is complex\n-                     numbers.  */\n-                  if (prev_first_load != first_load\n-                      && rhs_code != REALPART_EXPR\n-                      && rhs_code != IMAGPART_EXPR)\n+                     chains in the same node.  */\n+                  if (prev_first_load != first_load)\n                     {\n                       if (dump_enabled_p ())\n                         {\n@@ -730,9 +707,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\t    stmt, 0);\n                         }\n-\n-\t  \t      vect_free_oprnd_info (oprnds_info);\n-                      return false;\n+\t\t      /* Mismatch.  */\n+\t\t      continue;\n                     }\n                 }\n               else\n@@ -755,15 +731,11 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\t    stmt, 0);\n                         }\n-\n-\t  \t      vect_free_oprnd_info (oprnds_info);\n+\t\t      /* Fatal mismatch.  */\n+\t\t      matches[0] = false;\n                       return false;\n                     }\n                 }\n-\n-              /* We stop the tree when we reach a group of loads.  */\n-              stop_recursion = true;\n-             continue;\n            }\n         } /* Grouped access.  */\n       else\n@@ -779,7 +751,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t}\n \n \t      /* FORNOW: Not grouped loads are not supported.  */\n-\t      vect_free_oprnd_info (oprnds_info);\n+\t      /* Fatal mismatch.  */\n+\t      matches[0] = false;\n \t      return false;\n \t    }\n \n@@ -796,8 +769,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" unsupported \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n-\n-\t      vect_free_oprnd_info (oprnds_info);\n+\t      /* Fatal mismatch.  */\n+\t      matches[0] = false;\n \t      return false;\n \t    }\n \n@@ -817,53 +790,161 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n                     }\n-\n-\t\t  vect_free_oprnd_info (oprnds_info);\n-                  return false;\n+\t\t  /* Mismatch.  */\n+\t\t  continue;\n \t\t}\n             }\n-\n-\t  /* Find the def-stmts.  */\n-\t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, stmt,\n-\t\t\t\t\t    (i == 0), &oprnds_info))\n-\t    {\n-\t      vect_free_oprnd_info (oprnds_info);\n-\t      return false;\n-\t    }\n \t}\n+\n+      matches[i] = true;\n+    }\n+\n+  for (i = 0; i < group_size; ++i)\n+    if (!matches[i])\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Recursively build an SLP tree starting from NODE.\n+   Fail (and return a value not equal to zero) if def-stmts are not\n+   isomorphic, require data permutation or are of unsupported types of\n+   operation.  Otherwise, return 0.\n+   The value returned is the depth in the SLP tree where a mismatch\n+   was found.  */\n+\n+static bool\n+vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+                     slp_tree *node, unsigned int group_size,\n+                     unsigned int *max_nunits,\n+                     vec<slp_tree> *loads,\n+                     unsigned int vectorization_factor,\n+\t\t     bool *matches, unsigned *npermutes)\n+{\n+  unsigned nops, i, this_npermutes = 0;\n+  gimple stmt;\n+\n+  if (!matches)\n+    matches = XALLOCAVEC (bool, group_size);\n+  if (!npermutes)\n+    npermutes = &this_npermutes;\n+\n+  matches[0] = false;\n+\n+  stmt = SLP_TREE_SCALAR_STMTS (*node)[0];\n+  if (is_gimple_call (stmt))\n+    nops = gimple_call_num_args (stmt);\n+  else if (is_gimple_assign (stmt))\n+    {\n+      nops = gimple_num_ops (stmt) - 1;\n+      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\tnops++;\n     }\n+  else\n+    return false;\n \n-  /* Grouped loads were reached - stop the recursion.  */\n-  if (stop_recursion)\n+  if (!vect_build_slp_tree_1 (loop_vinfo, bb_vinfo,\n+\t\t\t      SLP_TREE_SCALAR_STMTS (*node), group_size, nops,\n+\t\t\t      max_nunits, vectorization_factor, matches))\n+    return false;\n+\n+  /* If the SLP node is a load, terminate the recursion.  */\n+  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n+      && DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))\n     {\n       loads->safe_push (*node);\n-      vect_free_oprnd_info (oprnds_info);\n       return true;\n     }\n \n+  /* Get at the operands, verifying they are compatible.  */\n+  vec<slp_oprnd_info> oprnds_info = vect_create_oprnd_info (nops, group_size);\n+  slp_oprnd_info oprnd_info;\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (*node), i, stmt)\n+    {\n+      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo,\n+\t\t\t\t\tstmt, (i == 0), &oprnds_info))\n+\t{\n+\t  vect_free_oprnd_info (oprnds_info);\n+\t  return false;\n+\t}\n+    }\n+\n+  stmt = SLP_TREE_SCALAR_STMTS (*node)[0];\n+\n   /* Create SLP_TREE nodes for the definition node/s.  */\n   FOR_EACH_VEC_ELT (oprnds_info, i, oprnd_info)\n     {\n       slp_tree child;\n+      unsigned old_nloads = loads->length ();\n+      unsigned old_max_nunits = *max_nunits;\n \n       if (oprnd_info->first_dt != vect_internal_def)\n         continue;\n \n       child = vect_create_new_slp_node (oprnd_info->def_stmts);\n-      if (!child\n-          || !vect_build_slp_tree (loop_vinfo, bb_vinfo, &child, group_size,\n-\t\t\t\t   max_nunits, loads,\n-\t\t\t\t   vectorization_factor))\n-        {\n-\t  if (child)\n-\t    oprnd_info->def_stmts = vNULL;\n-\t  vect_free_slp_tree (child);\n+      if (!child)\n+\t{\n \t  vect_free_oprnd_info (oprnds_info);\n-   \t  return false;\n+\t  return false;\n+\t}\n+\n+      bool *matches = XALLOCAVEC (bool, group_size);\n+      if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &child,\n+\t\t\t       group_size, max_nunits, loads,\n+\t\t\t       vectorization_factor, matches, npermutes))\n+\t{\n+\t  oprnd_info->def_stmts = vNULL;\n+\t  SLP_TREE_CHILDREN (*node).quick_push (child);\n+\t  continue;\n+\t}\n+\n+      /* If the SLP build for operand zero failed and operand zero\n+\t and one can be commutated try that for the scalar stmts\n+\t that failed the match.  */\n+      if (i == 0\n+\t  /* A first scalar stmt mismatch signals a fatal mismatch.  */\n+\t  && matches[0]\n+\t  /* ???  For COND_EXPRs we can swap the comparison operands\n+\t     as well as the arms under some constraints.  */\n+\t  && nops == 2\n+\t  && oprnds_info[1]->first_dt == vect_internal_def\n+\t  && is_gimple_assign (stmt)\n+\t  && commutative_tree_code (gimple_assign_rhs_code (stmt))\n+\t  /* Do so only if the number of not successful permutes was nor more\n+\t     than a cut-ff as re-trying the recursive match on\n+\t     possibly each level of the tree would expose exponential\n+\t     behavior.  */\n+\t  && *npermutes < 4)\n+\t{\n+\t  /* Roll back.  */\n+\t  *max_nunits = old_max_nunits;\n+\t  loads->truncate (old_nloads);\n+\t  /* Swap mismatched definition stmts.  */\n+\t  for (unsigned j = 0; j < group_size; ++j)\n+\t    if (!matches[j])\n+\t      {\n+\t\tgimple tem = oprnds_info[0]->def_stmts[j];\n+\t\toprnds_info[0]->def_stmts[j] = oprnds_info[1]->def_stmts[j];\n+\t\toprnds_info[1]->def_stmts[j] = tem;\n+\t      }\n+\t  /* And try again ... */\n+\t  if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &child,\n+\t\t\t\t   group_size, max_nunits, loads,\n+\t\t\t\t   vectorization_factor,\n+\t\t\t\t   matches, npermutes))\n+\t    {\n+\t      oprnd_info->def_stmts = vNULL;\n+\t      SLP_TREE_CHILDREN (*node).quick_push (child);\n+\t      continue;\n+\t    }\n+\n+\t  ++*npermutes;\n \t}\n \n-      oprnd_info->def_stmts.create (0);\n-      SLP_TREE_CHILDREN (*node).quick_push (child);\n+      oprnd_info->def_stmts = vNULL;\n+      vect_free_slp_tree (child);\n+      vect_free_oprnd_info (oprnds_info);\n+      return false;\n     }\n \n   vect_free_oprnd_info (oprnds_info);\n@@ -1045,9 +1126,8 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   int i = 0, j, prev = -1, next, k, number_of_groups;\n   bool supported, bad_permutation = false;\n   sbitmap load_index;\n-  slp_tree node, other_complex_node;\n-  gimple stmt, first = NULL, other_node_first, load, next_load, first_load;\n-  unsigned complex_numbers = 0;\n+  slp_tree node;\n+  gimple stmt, load, next_load, first_load;\n   struct data_reference *dr;\n   bb_vec_info bb_vinfo;\n \n@@ -1071,66 +1151,9 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n \n   /* Check that all the load nodes are of the same size.  */\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-    {\n-      if (SLP_TREE_SCALAR_STMTS (node).length () != (unsigned) group_size)\n-        return false;\n-\n-      stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-      if (is_gimple_assign (stmt) \n-          && (gimple_assign_rhs_code (stmt) == REALPART_EXPR\n-              || gimple_assign_rhs_code (stmt) == IMAGPART_EXPR))\n-        complex_numbers++;\n-    }\n-\n-  /* Complex operands can be swapped as following:\n-      real_c = real_b + real_a;\n-      imag_c = imag_a + imag_b;\n-     i.e., we have {real_b, imag_a} and {real_a, imag_b} instead of \n-     {real_a, imag_a} and {real_b, imag_b}.  We check here that if interleaving\n-     chains are mixed, they match the above pattern.  */\n-  if (complex_numbers)\n-    {\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-        {\n-\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, stmt)\n-            {\n-              if (j == 0)\n-                first = stmt;\n-              else\n-                {\n-                  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != first)\n-                    {\n-                      if (complex_numbers != 2)\n-                        return false;\n-\n-                      if (i == 0)\n-                        k = 1;\n-                      else\n-                        k = 0;\n- \n-                      other_complex_node = SLP_INSTANCE_LOADS (slp_instn)[k];\n-                      other_node_first = \n-                                SLP_TREE_SCALAR_STMTS (other_complex_node)[0];\n-\n-                      if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n-                          != other_node_first)\n-                       return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    if (SLP_TREE_SCALAR_STMTS (node).length () != (unsigned) group_size)\n+      return false;\n \n-  /* We checked that this case ok, so there is no need to proceed with \n-     permutation tests.  */\n-  if (complex_numbers == 2\n-      && SLP_INSTANCE_LOADS (slp_instn).length () == 2)\n-    {\n-      SLP_INSTANCE_LOADS (slp_instn).release ();\n-      SLP_INSTANCE_LOAD_PERMUTATION (slp_instn).release ();\n-      return true;\n-    }\n-                   \n   node = SLP_INSTANCE_TREE (slp_instn);\n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   /* LOAD_PERMUTATION is a list of indices of all the loads of the SLP\n@@ -1593,7 +1616,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n \t\t\t   &max_nunits, &loads,\n-\t\t\t   vectorization_factor))\n+\t\t\t   vectorization_factor, NULL, NULL))\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n@@ -1629,19 +1652,15 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       FOR_EACH_VEC_ELT (loads, i, load_node)\n \t{\n \t  int j;\n-\t  gimple load;\n+\t  gimple load, first_stmt;\n+\t  first_stmt = GROUP_FIRST_ELEMENT\n+\t      (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n \t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n \t    {\n-\t      int load_place;\n-\t      load_place = vect_get_place_in_interleaving_chain\n-\t\t(load, GROUP_FIRST_ELEMENT (vinfo_for_stmt (load)));\n-\t      if (load_place != j\n-\t\t  /* ???  We allow loads from different groups to\n-\t\t     get to here for a special case handled in\n-\t\t     the permutation code.  Make sure we get to that.  */\n-\t\t  || (GROUP_FIRST_ELEMENT\n-\t\t        (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]))\n-\t\t      != GROUP_FIRST_ELEMENT (vinfo_for_stmt (load))))\n+\t      int load_place\n+\t\t= vect_get_place_in_interleaving_chain (load, first_stmt);\n+\t      gcc_assert (load_place != -1);\n+\t      if (load_place != j)\n \t\tloads_permuted = true;\n \t      load_permutation.safe_push (load_place);\n \t    }"}]}