{"sha": "7177dab5c931138c85a1762acc54fd53880f4933", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE3N2RhYjVjOTMxMTM4Yzg1YTE3NjJhY2M1NGZkNTM4ODBmNDkzMw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-11-02T10:08:03Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-11-02T10:08:03Z"}, "message": "AbstractList.java: Throw messages with IndexOutOfBoundsExceptions.\n\n2000-11-02  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* java/util/AbstractList.java: Throw messages with\n\tIndexOutOfBoundsExceptions.\n\t (listIterator()): Call listIterator(0).\n\t(size): New field. Initialize to size().\n\t(hasNext): Test position against size, not size().\n\t(remove): Increment knownMod by one instead of resetting it from\n\tmodCount.\n\t(add): Ditto.\n\t(SubList.upMod): Removed.\n\t(SubList.set): Don't call upMod() or update knownMod.\n\t(SubList.add(int,Object)): Increment modCount instead of calling\n\tupMod().\n\t(SubList.remove): Ditto.\n\t(SubList.addAll): Don't call backingList.size(). Increment size from\n\tc.size().\n\t(SubList.iterator): New method. Call listIterator(0).\n\t(SubList.listIterator): New method. Restore code to return an\n\tanonymous listIterator implementation (with some changes).\n\t* java/util/AbstractSequentialList.java: Throw messages with\n\tIndexOutOfBoundsExceptions.\n\t(addAll): Add a specnote.\n\t* java/util/ArrayList.java (removeRange): Get the math right.\n\t(addAll): Increment modCount _before_ creating iterator.\n\t* java/util/LinkedList.java: Rewritten, mostly.\n\nFrom-SVN: r37203", "tree": {"sha": "8357f25c2a8a67f24d63ee938da87068de9dfce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8357f25c2a8a67f24d63ee938da87068de9dfce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7177dab5c931138c85a1762acc54fd53880f4933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7177dab5c931138c85a1762acc54fd53880f4933", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7177dab5c931138c85a1762acc54fd53880f4933", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7177dab5c931138c85a1762acc54fd53880f4933/comments", "author": null, "committer": null, "parents": [{"sha": "17e2e7f92defe956f5b700558d58aefa96869817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e2e7f92defe956f5b700558d58aefa96869817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e2e7f92defe956f5b700558d58aefa96869817"}], "stats": {"total": 1109, "additions": 657, "deletions": 452}, "files": [{"sha": "4ad11eb751c5bdce2aac8aaa9f4ed2e9bdbc1907", "filename": "libjava/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7177dab5c931138c85a1762acc54fd53880f4933", "patch": "@@ -1,3 +1,29 @@\n+2000-11-02  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/util/AbstractList.java: Throw messages with \n+\tIndexOutOfBoundsExceptions.\n+\t (listIterator()): Call listIterator(0).\n+\t(size): New field. Initialize to size().\n+\t(hasNext): Test position against size, not size().\n+\t(remove): Increment knownMod by one instead of resetting it from \n+\tmodCount.\n+\t(add): Ditto.\n+\t(SubList.upMod): Removed.\n+\t(SubList.set): Don't call upMod() or update knownMod.\n+\t(SubList.add(int,Object)): Increment modCount instead of caling upMod().\n+\t(SubList.remove): Ditto.\n+\t(SubList.addAll): Don't call backingList.size(). Increment size from \n+\tc.size().\n+\t(SubList.iterator): New method. Call listIterator(0).\n+\t(SubList.listIterator): New method. Restore code to return an anonymous\n+\tlistIterator implementation (with some changes).\n+\t* java/util/AbstractSequentialList.java: Throw messages with \n+\tIndexOutOfBoundsExceptions.\n+\t(addAll): Add a specnote.\n+\t* java/util/ArrayList.java (removeRange): Get the math right.\n+\t(addAll): Increment modCount _before_ creating iterator.\n+\t* java/util/LinkedList.java: Rewritten, mostly.\n+\n 2000-11-01  Tom Tromey  <tromey@cygnus.com>\n \n \t* scripts/encodings.pl: Added `ASCII' alias."}, {"sha": "03282e5ebe80716f18e943ee52966e4392a3d205", "filename": "libjava/java/util/AbstractList.java", "status": "modified", "additions": 134, "deletions": 31, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FAbstractList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FAbstractList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractList.java?ref=7177dab5c931138c85a1762acc54fd53880f4933", "patch": "@@ -145,15 +145,22 @@ public int lastIndexOf(Object o)\n     return -1;\n   }\n \n+  /**\n+   * Return an Iterator over this List. This implementation calls\n+   * listIterator(0).\n+   *\n+   * @return an Iterator over this List\n+   */\n   public ListIterator listIterator()\n   {\n-    return new AbstractListItr(0);\n+    return listIterator(0);\n   }\n \n   public ListIterator listIterator(int index)\n   {\n     if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException();\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size());\n \n     return new AbstractListItr(index);\n   }\n@@ -193,10 +200,10 @@ public Object set(int index, Object o)\n     throw new UnsupportedOperationException();\n   }\n \n-  public List subList(final int fromIndex, final int toIndex)\n+  public List subList(int fromIndex, int toIndex)\n   {\n     if (fromIndex > toIndex)\n-      throw new IllegalArgumentException();\n+      throw new IllegalArgumentException(fromIndex + \" > \" + toIndex);\n     if (fromIndex < 0 || toIndex > size())\n       throw new IndexOutOfBoundsException();\n \n@@ -208,6 +215,7 @@ class AbstractListItr implements ListIterator\n     private int knownMod = modCount;\n     private int position;\n     private int lastReturned = -1;\n+    private int size = size();\n \n     AbstractListItr(int start_pos)\n     {\n@@ -223,7 +231,7 @@ private void checkMod()\n     public boolean hasNext()\n     {\n       checkMod();\n-      return position < size();\n+      return position < size;\n     }\n \n     public boolean hasPrevious()\n@@ -235,7 +243,7 @@ public boolean hasPrevious()\n     public Object next()\n     {\n       checkMod();\n-      if (position < size())\n+      if (position < size)\n \t{\n \t  lastReturned = position++;\n \t  return get(lastReturned);\n@@ -280,7 +288,7 @@ public void remove()\n \t  throw new IllegalStateException();\n \t}\n       AbstractList.this.remove(lastReturned);\n-      knownMod = modCount;\n+      knownMod++;\n       position = lastReturned;\n       lastReturned = -1;\n     }\n@@ -298,7 +306,7 @@ public void add(Object o)\n       checkMod();\n       AbstractList.this.add(position++, o);\n       lastReturned = -1;\n-      knownMod = modCount;\n+      knownMod++;\n     }\n   }\t\t\t\t// AbstractList.Iterator\n \n@@ -311,7 +319,9 @@ static class SubList extends AbstractList\n     public SubList(AbstractList backing, int fromIndex, int toIndex)\n     {\n       backingList = backing;\n-      upMod();\n+      // FIXME: The `this' prefixes in this class are a workaround for a\n+      // gcj bug. They should be removed later.\n+      this.modCount = backingList.modCount;\n       offset = fromIndex;\n       size = toIndex - fromIndex;\n     }\n@@ -331,17 +341,6 @@ private void checkMod()\n \tthrow new ConcurrentModificationException();\n     }\n \n-    /**\n-     * This method is called after every method that causes a structural\n-     * modification to the backing list. It updates the local modCount field\n-     * to match that of the backing list.\n-     * Note that since this method is private, it will be inlined.\n-     */\n-    private void upMod()\n-    {\n-      this.modCount = backingList.modCount;\n-    }\n-\n     /**\n      * This method checks that a value is between 0 and size (inclusive). If\n      * it is not, an exception is thrown.\n@@ -352,7 +351,8 @@ private void upMod()\n     private void checkBoundsInclusive(int index)\n     {\n       if (index < 0 || index > size)\n-\tthrow new IndexOutOfBoundsException();\n+\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                            size);\n     }\n \n     /**\n@@ -365,7 +365,8 @@ private void checkBoundsInclusive(int index)\n     private void checkBoundsExclusive(int index)\n     {\n       if (index < 0 || index >= size)\n-\tthrow new IndexOutOfBoundsException();\n+\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                            size);\n     }\n \n     public int size()\n@@ -379,7 +380,6 @@ public Object set(int index, Object o)\n       checkMod();\n       checkBoundsExclusive(index);\n       o = backingList.set(index + offset, o);\n-      upMod();\n       return o;\n     }\n \n@@ -395,7 +395,7 @@ public void add(int index, Object o)\n       checkMod();\n       checkBoundsInclusive(index);\n       backingList.add(index + offset, o);\n-      upMod();\n+      this.modCount++;\n       size++;\n     }\n \n@@ -404,7 +404,7 @@ public Object remove(int index)\n       checkMod();\n       checkBoundsExclusive(index);\n       Object o = backingList.remove(index + offset);\n-      upMod();\n+      this.modCount++;\n       size--;\n       return o;\n     }\n@@ -417,19 +417,122 @@ public void removeRange(int fromIndex, int toIndex)\n \n       // this call will catch the toIndex < fromIndex condition\n       backingList.removeRange(offset + fromIndex, offset + toIndex);\n-      upMod();\n+      this.modCount = backingList.modCount;\n       size -= toIndex - fromIndex;\n     }\n-\n+    \n     public boolean addAll(int index, Collection c)\n     {\n       checkMod();\n       checkBoundsInclusive(index);\n-      int s = backingList.size();\n+      int csize = c.size();\n       boolean result = backingList.addAll(offset + index, c);\n-      upMod();\n-      size += backingList.size() - s;\n+      this.modCount = backingList.modCount;\n+      size += csize;\n       return result;\n     }\n-  }\t\t\t\t// AbstractList.SubList\n+    \n+    public Iterator iterator()\n+    {\n+      return listIterator(0);\n+    }\n+\n+    public ListIterator listIterator(final int index)\n+    {      \n+      checkMod();\n+      checkBoundsInclusive(index);\n+      \n+      return new ListIterator() \n+      {\n+        ListIterator i = backingList.listIterator(index + offset);\n+        int position = index;\n+        \n+        public boolean hasNext()\n+\t{\n+          checkMod();\n+          return position < size;\n+        }\n+        \n+        public boolean hasPrevious()\n+\t{\n+          checkMod();\n+          return position > 0;\n+        }\n+        \n+        public Object next()\n+\t{\n+          if (position < size)\n+\t    {\n+              Object o = i.next();\n+              position++;\n+              return o;\n+            }\n+\t  else\n+            throw new NoSuchElementException();\n+\t}\n+        \n+        public Object previous()\n+\t{\n+          if (position > 0)\n+\t    {\n+              Object o = i.previous();\n+              position--;\n+              return o;\n+            }\n+\t  else\n+            throw new NoSuchElementException();\n+        }\n+        \n+        public int nextIndex()\n+\t{\n+          return offset + i.nextIndex();\n+        }\n+        \n+        public int previousIndex()\n+\t{\n+          return offset + i.previousIndex();\n+        }\n+\n+        public void remove()\n+\t{\n+          i.remove();\n+\t  SubList.this.modCount++;\n+          size--;\n+          position = nextIndex();\n+        }\n+        \n+        public void set(Object o)\n+\t{\n+          i.set(o);\n+        }\n+        \n+        public void add(Object o)\n+\t{\n+          i.add(o);\n+\t  SubList.this.modCount++;\n+          size++;\n+          position++;\n+        }\n+\n+        // Here is the reason why the various modCount fields are mostly\n+        // ignored in this wrapper listIterator.\n+        // IF the backing listIterator is failfast, then the following holds:\n+        //   Using any other method on this list will call a corresponding\n+        //   method on the backing list *after* the backing listIterator\n+        //   is created, which will in turn cause a ConcurrentModException\n+        //   when this listIterator comes to use the backing one. So it is\n+        //   implicitly failfast.\n+        // If the backing listIterator is NOT failfast, then the whole of\n+        //   this list isn't failfast, because the modCount field of the\n+        //   backing list is not valid. It would still be *possible* to\n+        //   make the iterator failfast wrt modifications of the sublist\n+        //   only, but somewhat pointless when the list can be changed under\n+        //   us.\n+        // Either way, no explicit handling of modCount is needed.\n+        // However modCount++ must be executed in add and remove, and size\n+        // must also be updated in these two methods, since they do not go\n+        // through the corresponding methods of the subList.\n+      };\n+    }\n+  }  // AbstractList.SubList\n }"}, {"sha": "b9b8e63d1f6996c9efcf29f83cb716eda62f5c63", "filename": "libjava/java/util/AbstractSequentialList.java", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSequentialList.java?ref=7177dab5c931138c85a1762acc54fd53880f4933", "patch": "@@ -64,6 +64,12 @@ public void add(int index, Object o)\n     i.add(o);\n   }\n \n+  /**\n+   * @specnote The spec in the JDK1.3 online docs is wrong. The implementation\n+   *           should not call next() to skip over new elements as they are\n+   *           added, because iterator.add() should add new elements BEFORE\n+   *           the cursor.\n+   */\n   public boolean addAll(int index, Collection c)\n   {\n     boolean modified = false;\n@@ -81,7 +87,8 @@ public Object get(int index)\n   {\n     ListIterator i = listIterator(index);\n     if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException();\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size());\n     return i.next();\n   }\n \n@@ -100,7 +107,8 @@ public Object remove(int index)\n   {\n     ListIterator i = listIterator(index);\n     if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException();\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size());\n     Object removed = i.next();\n     i.remove();\n     return removed;\n@@ -110,7 +118,8 @@ public Object set(int index, Object o)\n   {\n     ListIterator i = listIterator(index);\n     if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException();\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size());\n     Object old = i.next();\n     i.set(o);\n     return old;"}, {"sha": "084084cff3d09407e242fe17a600d9784f82c771", "filename": "libjava/java/util/ArrayList.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrayList.java?ref=7177dab5c931138c85a1762acc54fd53880f4933", "patch": "@@ -43,7 +43,7 @@\n  * to or removing from the end of a list, checking the size, &c.\n  *\n  * @author        Jon A. Zeppieri\n- * @version       $Id: ArrayList.java,v 1.6 2000/10/26 10:19:00 bryce Exp $\n+ * @version       $Id: ArrayList.java,v 1.2 2000/10/29 05:06:10 bryce Exp $\n  * @see           java.util.AbstractList\n  * @see           java.util.List\n  */\n@@ -187,7 +187,7 @@ protected void removeRange(int fromIndex, int toIndex)\n     if (fromIndex != toIndex)\n       {\n \tSystem.arraycopy(data, toIndex, data, fromIndex, size - toIndex);\n-\tsize -= (fromIndex - toIndex);\n+\tsize -= (toIndex - fromIndex);\n       }\n   }\n \n@@ -219,9 +219,9 @@ public void add(int index, Object e)\n    */\n   public boolean addAll(Collection c)\n   {\n+    modCount++;\n     Iterator itr = c.iterator();\n     int csize = c.size();\n-    modCount++;\n     ensureCapacity(size + csize);\n     for (int pos = 0; pos < csize; pos++)\n       {\n@@ -240,13 +240,13 @@ public boolean addAll(Collection c)\n    */\n   public boolean addAll(int index, Collection c)\n   {\n-    Iterator itr = c.iterator();\n-    int csize = c.size();\n-\n-    modCount++;\n     if (index < 0 || index > size)\n       throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n                                           size);\n+    modCount++;\n+    Iterator itr = c.iterator();\n+    int csize = c.size();\n+\n     ensureCapacity(size + csize);\n     int end = index + csize;\n     if (size > 0 && index != size)"}, {"sha": "5854496708e59a821718b575b40890ec71cd6163", "filename": "libjava/java/util/LinkedList.java", "status": "modified", "additions": 478, "deletions": 411, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FLinkedList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7177dab5c931138c85a1762acc54fd53880f4933/libjava%2Fjava%2Futil%2FLinkedList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedList.java?ref=7177dab5c931138c85a1762acc54fd53880f4933", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -30,16 +30,17 @@\n import java.io.ObjectOutputStream;\n import java.io.ObjectInputStream;\n import java.io.IOException;\n+import java.lang.reflect.Array;\n \n // TO DO:\n // ~ Doc comment for the class.\n // ~ Doc comments for the non-list methods.\n-// ~ Some commenting on the Backing API and other general implementation notes.\n+// ~ other general implementation notes.\n \n /**\n  * Linked list implementation of the List interface.\n  */\n-public class LinkedList extends AbstractSequentialList \n+public class LinkedList extends AbstractSequentialList\n   implements Serializable, Cloneable\n {\n   static final long serialVersionUID = 876323262645176354L;\n@@ -49,7 +50,8 @@ public class LinkedList extends AbstractSequentialList\n    * previous field) of the list. The data field is null. If the list is empty,\n    * both the head and the tail point to ends itself.\n    */\n-  transient Entry ends = new Entry();\n+  transient Entry first;\n+  transient Entry last;\n \n   /**\n    * The current length of the list.\n@@ -59,260 +61,86 @@ public class LinkedList extends AbstractSequentialList\n   /**\n    * Class to represent an entry in the list. Holds a single element.\n    */\n-  private static class Entry {\n-\n-    /**\n-     * The list element.\n-     */\n-    Object data = null;\n-\n-    /**\n-     * The next entry in the list. If this is the last entry in the list, the\n-     * ends field of the list is held here.\n-     */\n-    Entry next;\n-\n-    /**\n-     * The previous entry in the list. If this is the first entry in the list,\n-     * the ends field of the list is held here.\n-     */\n-    Entry previous;\n-\n-    /**\n-     * Create an entry with given data and linkage.\n-     */\n-    Entry(Object d, Entry n, Entry p) {\n-      data = d;\n-      next = n;\n-      previous = p;\n-    }\n-\n-    /**\n-     * Create an entry with no data and linking to itself, for use as the ends\n-     * field of the list.\n-     */\n-    Entry() {\n-      next = previous = this;\n-    }\n-\n-    /**\n-     * Remove this entry.\n-     */\n-    Object remove() {\n-      previous.next = next;\n-      next.previous = previous;\n-      return data;\n-    }\n-  }\n-\n-  private static interface Backing {\n-    void checkMod(int known);\n-    void upMod();\n-    void incSize(int by);\n-    void decSize(int by);\n-  }\n-\n-  private final Backing back = new Backing() {\n-    public void checkMod(int known) {\n-      if (known != modCount) {\n-\tthrow new ConcurrentModificationException();\n-      }\n-    }\n-    public void upMod() {\n-      modCount++;\n-    }\n-    public void incSize(int by) {\n-      size += by;\n-    }\n-    public void decSize(int by) {\n-      size -= by;\n-    }\n-  };\n-\n-  /** A ListIterator over the list. This class keeps track of its\n-   * position in the list, the size of the list, and the two list\n-   * entries it is between.  This enables it to be used identically\n-   * for both the list itself and a sublist of the list.\n-   */\n-  private static class Iter implements ListIterator {\n-\n-    /**\n-     * The index of the element that will be returned by next().\n-     */\n-    int pos;\n-\n-    /**\n-     * The size of the backing list.\n-     */\n-    int size;\n-\n-    /**\n-     * The entry containing the element that will be returned by next().\n-     */\n+  private static class Entry\n+  {\n+    Object data;\n     Entry next;\n-\n-    /**\n-     * The entry containing the element that will be returned by previous().\n-     */\n     Entry previous;\n-\n-    /**\n-     * The entry that will be affected by remove() or set().\n-     */\n-    Entry recent;\n-\n-    /**\n-     * The known value of the modCount of the backing list.\n-     */\n-    int knownMod;\n-\n-    private final Backing b;\n-\n-    /**\n-     * Create a new Iter starting at a given Entry within the list, at a given\n-     * position, in a list of given size.\n-     *\n-     * @param index the index to begin iteration.\n-     * @exception IndexOutOfBoundsException if index < 0 || index > size.\n-     */\n-    Iter(Backing backing, Entry n, int index, int s, int modCount) {\n-      b = backing;\n-      pos = index;\n-      size = s;\n-      next = n;\n-      previous = n.previous;\n-      knownMod = modCount;\n-    }\n-\n-    public int nextIndex() {\n-      b.checkMod(knownMod);\n-      return pos;\n-    }\n-\n-    public int previousIndex() {\n-      b.checkMod(knownMod);\n-      return pos - 1;\n-    }\n-\n-    public boolean hasNext() {\n-      b.checkMod(knownMod);\n-      return pos < size;\n-    }\n-\n-    public boolean hasPrevious() {\n-      b.checkMod(knownMod);\n-      return pos > 0;\n-    }\n-\n-    public Object next() {\n-      b.checkMod(knownMod);\n-      if (pos >= size) {\n-\tthrow new NoSuchElementException();\n-      } else {\n-\tpos++;\n-\trecent = previous = next;\n-\tnext = recent.next;\n-\treturn recent.data;\n-      }\n-    }\n-\n-    public Object previous() {\n-      b.checkMod(knownMod);\n-      if (pos <= 0) {\n-\tthrow new NoSuchElementException();\n-      } else {\n-\tpos--;\n-\trecent = next = previous;\n-\tprevious = recent.previous;\n-\treturn recent.data;\n-      }\n-    }\n-\n-    public void remove() {\n-      b.checkMod(knownMod);\n-      if (recent == null) {\n-\tthrow new IllegalStateException();\n-      }\n-\n-      // Adjust the position to before the removed element\n-      if (recent == previous) pos--;\n-\n-      // Could use recent.remove() but this way is quicker, and also correctly\n-      // fixes next and previous.\n-      next = recent.previous.next = recent.next;\n-      previous = recent.next.previous = recent.previous;\n-      size--;\n-      b.decSize(1);\n-      knownMod++;\n-      b.upMod();\n-      recent = null;\n-    }\n-\n-    public void add(Object o) {\n-      b.checkMod(knownMod);\n-      previous.next = next.previous = new Entry(o, next, previous);\n-\n-      // New for 1.2RC1 - the semantics changed so that the iterator is\n-      // positioned *after* the new element.\n-      previous = previous.next;\n-      pos++;\n-\n-      size++;\n-      b.incSize(1);\n-      knownMod++;\n-      b.upMod();\n-      recent = null;\n-    }\n-\n-    public void set(Object o) {\n-      b.checkMod(knownMod);\n-      if (recent == null) {\n-\tthrow new IllegalStateException();\n-      }\n-      recent.data = o;\n+    \n+    Entry(Object data)\n+    {\n+      this.data = data;\n     }\n   }\n-\n+  \n   /**\n    * Obtain the Entry at a given position in a list. This method of course\n    * takes linear time, but it is intelligent enough to take the shorter of the\n    * paths to get to the Entry required. This implies that the first or last\n    * entry in the list is obtained in constant time, which is a very desirable\n    * property.\n-   * For speed and flexibility in which ranges are valid, range checking is not\n-   * done in this method, and if n is outside the range -1 <= n <= size, the\n-   * result will be wrong (but no exception will be thrown).\n-   * Note that you *can* obtain entries at position -1 and size, which are\n-   * equal to prehead and posttail respectively.\n-   * This method is static so that it can also be used in subList.\n+   * For speed and flexibility, range checking is not done in this method:\n+   * Incorrect values will be returned if (n < 0) or (n >= size).\n    *\n    * @param n the number of the entry to get.\n-   * @param size the size of the list to get the entry in.\n-   * @param head the entry before the first element of the list (usually ends).\n-   * @param tail the entry after the last element of the list (usually ends).\n    */\n-  static Entry getEntry(int n, int size, Entry head, Entry tail) {\n-\n-    // n less than size/2, iterate from start\n-    if (n < size >> 1) {\n-      while (n-- >= 0) {\n-\thead = head.next;\n+  private Entry getEntry(int n)\n+  {\n+    Entry e;\n+    if (n < size / 2)\n+      {\n+        e = first;\n+\t// n less than size/2, iterate from start\n+\twhile (n-- > 0)\n+\t  {\n+\t    e = e.next;\n+\t  }\n       }\n-      return head;\n-\n-    // n greater than size/2, iterate from end\n-    } else {\n-      while (++n <= size) {\n-\ttail = tail.previous;\n+    else\n+      {\n+        e = last;      \n+\t// n greater than size/2, iterate from end\n+\twhile (++n < size)\n+\t  {\n+\t    e = e.previous;\n+\t  }\n       }\n-      return tail;\n-    }\n+    return e;\n+  }\n+  \n+  /** Remove an entry from the list. This will adjust size and deal with\n+   *  `first' and  `last' appropriatly. It does not effect modCount, that is \n+   *  the responsibility of the caller. */\n+  private void removeEntry(Entry e)\n+  {\n+    if (size == 1)\n+      first = last = null;\n+    else\n+      {\n+\tif (e == first)\n+\t  {\n+\t    first = e.next;\n+\t    e.next.previous = null;\n+\t  }\n+\telse if (e == last)\n+\t  {\n+\t    last = e.previous;\n+\t    e.previous.next = null;\n+\t  }\n+\telse\n+\t  {\n+\t    e.next.previous = e.previous;\t\n+\t    e.previous.next = e.next;\n+\t  }\n+      }\n+    size--;\n   }\n \n   /**\n    * Create an empty linked list.\n    */\n-  public LinkedList() {\n+  public LinkedList()\n+  {\n     super();\n   }\n \n@@ -322,92 +150,288 @@ public LinkedList() {\n    *\n    * @param c the collection to populate this list from.\n    */\n-  public LinkedList(Collection c) {\n+  public LinkedList(Collection c)\n+  {\n     super();\n     // Note: addAll could be made slightly faster, but not enough so to justify\n     // re-implementing it from scratch. It is just a matter of a relatively\n     // small constant factor.\n     addAll(c);\n   }\n \n-  public Object getFirst() {\n-    if (size == 0) {\n+  public Object getFirst()\n+  {\n+    if (size == 0)\n       throw new NoSuchElementException();\n-    }\n-    return ends.next.data;\n+    return first.data;\n   }\n \n-  public Object getLast() {\n-    if (size == 0) {\n+  public Object getLast()\n+  {\n+    if (size == 0)\n       throw new NoSuchElementException();\n-    }\n-    return ends.previous.data;\n+    return last.data;\n   }\n \n-  public Object removeFirst() {\n-    if (size == 0) {\n+  public Object removeFirst()\n+  {\n+    if (size == 0)\n       throw new NoSuchElementException();\n-    }\n     size--;\n     modCount++;\n-    return ends.next.remove();\n+    Object r = first.data;\n+    \n+    if (first.next != null)\n+      first.next.previous = null;\n+    return r;\n   }\n \n-  public Object removeLast() {\n-    if (size == 0) {\n+  public Object removeLast()\n+  {\n+    if (size == 0)\n       throw new NoSuchElementException();\n-    }\n     size--;\n     modCount++;\n-    return ends.previous.remove();\n+    Object r = last.data;\n+    \n+    if (last.previous != null)\n+      last.previous.next = null;    \n+    return r;\n   }\n \n-  public void addFirst(Object o) {\n-    ends.next.previous = ends.next = new Entry(o, ends.next, ends);\n-    size++;\n+  public void addFirst(Object o)\n+  {\n     modCount++;\n+    Entry e = new Entry(o);\n+    \n+    if (size == 0)\n+      first = last = e;\n+    else\n+      {\n+\te.next = first;\n+        first.previous = e;\n+\tfirst = e;\n+      }    \n+    size++;\n   }\n \n-  public void addLast(Object o) {\n-    ends.previous.next = ends.previous = new Entry(o, ends, ends.previous);\n-    size++;\n+  public void addLast(Object o)\n+  {\n     modCount++;\n+    addLastEntry(new Entry(o));\n+  }\n+  \n+  private void addLastEntry(Entry e)\n+  {\n+    if (size == 0)\n+      first = last = e;\n+    else\n+      {\n+\te.previous = last;\n+        last.next = e;\n+\tlast = e;\n+      }\n+    size++;\n   }\n \n-  /**\n-   * Obtain the number of elements currently in this list.\n-   *\n-   * @returns the number of elements currently in this list.\n-   */\n-  public int size() {\n+  public boolean contains(Object o)\n+  {\n+    Entry e = first;\n+    while (e != null)\n+      {\n+        if (e.data == null ? o == null : o.equals(e.data))\n+\t  return true;\n+        e = e.next;\n+      }\n+    return false;\n+  }\n+\n+  public int size()\n+  {\n     return size;\n   }\n+  \n+  public boolean add(Object o)\n+  {\n+    modCount++;\n+    addLastEntry(new Entry(o));\n+    return true;\n+  }\n+  \n+  public boolean remove(Object o)\n+  {\n+    modCount++;\n+    Entry e = first;\n+    while (e != null)\n+      {\n+        if (e.data == null ? o == null : o.equals(e.data))\n+\t  {\n+\t    removeEntry(e);\n+\t    return true;\n+\t  }\n+        e = e.next;\n+      }\n+    return false;\n+  }\n \n-  /**\n-   * Remove a range of elements from this list.\n-   *\n-   * @param fromIndex the index, inclusive, to remove from.\n-   * @param toIndex the index, exclusive, to remove to.\n-   * @exception IndexOutOfBoundsException if fromIndex > toIndex || fromIndex <\n-   *   0 || toIndex > size().\n-   */\n-  // Note: normally removeRange is provided to allow efficient ways to\n-  // implement clear() on subLists. However, in this case clear on subLists\n-  // works anyway, so this implementation is included just for completeness\n-  // and because subclasses might try to use it.\n-  protected void removeRange(int fromIndex, int toIndex) {\n-    subList(fromIndex, toIndex).clear();\n+  public boolean addAll(Collection c)\n+  {\n+    return addAll(size, c);\n+  }\n+  \n+  public boolean addAll(int index, Collection c)\n+  {\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    modCount++;\n+    int csize = c.size();\n+\n+    if (csize == 0)\n+      return false;\n+\n+    Iterator itr = c.iterator();\n+    \n+    // Get the entries just before and after index. If index is at the start\n+    // of the list, BEFORE is null. If index is at the end of thelist, AFTER is\n+    // null. If the list is empty, both are null.\n+    Entry after = null;\n+    Entry before = null;    \n+    if (index != size)\n+      {\n+\tafter = getEntry(index);\n+\tbefore = after.previous;\n+      }\n+    else\n+      before = last;\n+      \n+    // Create the first new entry. We do not yet set the link from `before'\n+    // to the first entry, in order to deal with the case where (c == this). \n+    // [Actually, we don't have to handle this case to fufill the \n+    // contract for addAll(), but Sun's implementation appears to.]\n+    Entry e = new Entry(itr.next());\n+    e.previous = before;\n+    Entry prev = e;\n+    Entry firstNew = e;\n+    \n+    // Create and link all the remaining entries.\n+    for (int pos = 1; pos < csize; pos++)\n+      {\n+        e = new Entry(itr.next());\n+\te.previous = prev;\t\n+\tprev.next = e;\n+\tprev = e;\n+      }\n+    // Fix up the links between the last new entry and the following entry.\n+    prev.next = after;\n+    if (after != null)\n+      after.previous = e;\n+    else\n+      last = e;\n+    \n+    if (before != null)\n+      before.next = firstNew;\n+    else\n+      first = firstNew;\n+    \n+    size += csize;\n+    return true;\n   }\n \n-  /**\n-   * Clear the list.\n-   */\n-  public void clear() {\n-    ends.next = ends.previous = ends;\n+  public void clear()\n+  {\n     modCount++;\n+    first = null;\n+    last = null;\n     size = 0;\n   }\n \n+  public Object get(int index)\n+  {\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    Entry e = getEntry(index);\n+    return e.data;\n+  }\n+  \n+  public Object set(int index, Object o)\n+  {\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    Entry e = getEntry(index);\n+    Object old = e.data;\n+    e.data = o;\n+    return old;\n+  }\n+\n+  public void add(int index, Object o)\n+  {\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    modCount++;\n+    addEntry(index, new Entry(o));    \n+  }\n+  \n+  private void addEntry(int index, Entry e)\n+  {\n+    if (index < size)\n+      {\n+\tEntry after = getEntry(index);\n+\te.next = after;\n+\te.previous = after.previous;\n+\tif (after.previous == null)\n+\t  first = e;\n+\telse\n+\t  after.previous.next = e;\n+\tafter.previous = e;\n+\tsize++;        \n+      }\n+    else\n+      addLastEntry(e);\n+  }\n+  \n+  public Object remove(int index)\n+  {\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    modCount++;\n+    Entry e = getEntry(index);\n+    removeEntry(e);\n+    return e.data;\n+  }\n+  \n+  public int indexOf(Object o)\n+  {\n+    int index = 0;\n+    Entry e = first;\n+    while (e != null)\n+      {\n+        if (e.data == null ? o == null : o.equals(e.data))\n+\t  return index;\n+\t++index;\n+        e = e.next;\n+      }\n+    return -1;\n+  }\n+  \n+  public int lastIndexOf(Object o)\n+  {\n+    int index = size - 1;\n+    Entry e = last;\n+    while (e != null)\n+      {\n+        if (e.data == null ? o == null : o.equals(e.data))\n+\t  return index;\n+\t--index;\n+        e = e.previous;\n+      }\n+    return -1;  \n+  }\n+\n   /**\n    * Obtain a ListIterator over this list, starting at a given index. The\n    * ListIterator returned by this method supports the add, remove and set\n@@ -417,155 +441,73 @@ public void clear() {\n    *   next(), or size() to be initially positioned at the end of the list.\n    * @exception IndexOutOfBoundsException if index < 0 || index > size().\n    */\n-  public ListIterator listIterator(int index) {\n-\n-    // Check bounds\n-    if (index < 0 || index > size) {\n-      throw new IndexOutOfBoundsException();\n-    }\n-\n-    return new Iter(back, getEntry(index, size, ends, ends), \n-\t\t    index, size, modCount);\n-  }\n-\n-  /**\n-   * Obtain a List view of a subsection of this list, from fromIndex\n-   * (inclusive) to toIndex (exclusive). The returned list is modifiable in\n-   * every respect. Changes to the returned list are reflected in this list. If\n-   * this list is structurally modified is any way other than through the\n-   * returned list, any subsequent operations on the returned list will result\n-   * in a ConcurrentModificationException (that is, the returned list is\n-   * fail-fast).\n-   *\n-   * @param fromIndex the index that the returned list should start from\n-   *    (inclusive).\n-   * @param toIndex the index that the returned list should go to (exclusive).\n-   * @returns a List backed by a subsection of this list.\n-   * @exception IndexOutOfBoundsException if fromIndex < 0 || toIndex > size()\n-   *   || fromIndex > toIndex.\n-   */\n-  public List subList(int fromIndex, int toIndex) {\n-\n-    // Check bounds\n-    if (fromIndex > toIndex || fromIndex < 0 || toIndex > size) {\n-      throw new IndexOutOfBoundsException();\n-    }\n-\n-    return new SubLinkedList(back, modCount,\n-\t\t\t     getEntry(fromIndex - 1, size, ends, ends),\n-\t\t\t     getEntry(toIndex, size, ends, ends),\n-\t\t\t     toIndex - fromIndex);\n-  }\n-\n-  private static class SubLinkedList extends AbstractSequentialList {\n-\n-    Entry head; // entry before the beginning\n-    Entry tail; // entry after the end\n-    int size;\n-    private final Backing b;\n-\n-    private final Backing back = new Backing() {\n-      public void checkMod(int known) {\n-\tif (known != modCount) {\n-\t  throw new ConcurrentModificationException();\n-\t}\n-      }\n-      public void upMod() {\n-\tmodCount++;\n-      }\n-      public void incSize(int by) {\n-\tsize += by;\n-      }\n-      public void decSize(int by) {\n-\tsize -= by;\n-      }\n-    };\n-\n-    SubLinkedList(Backing backing, int knownMod, Entry h, Entry t, int s) {\n-      this.modCount = knownMod;\n-      b = backing;\n-      head = h;\n-      tail = t;\n-      size = s;\n-    }\n-\n-    public int size() {\n-      b.checkMod(this.modCount);\n-      return size;\n-    }\n-\n-    public ListIterator listIterator(int index) {\n-      b.checkMod(this.modCount);\n-\n-      // Check bounds\n-      if (index < 0 || index > size) {\n-\tthrow new IndexOutOfBoundsException();\n-      }\n-\n-      return new Iter(back, getEntry(index, size, head, tail), \n-\t\t      index, size, modCount);\n-    }\n-\n-    public void clear() {\n-      b.checkMod(this.modCount);\n-      head.next = tail;\n-      tail.previous = head;\n-      size = 0;\n-      b.decSize(size);\n-      modCount++;\n-      b.upMod();\n-    }\n-\n-    // No removeRange because this class cannot be publically subclassed.\n-\n-    public List subList(int fromIndex, int toIndex) {\n-      b.checkMod(this.modCount);\n-\n-      // Check bounds\n-      if (fromIndex > toIndex || fromIndex < 0 || toIndex > size) {\n-\tthrow new IndexOutOfBoundsException();\n-      }\n-\n-      return new SubLinkedList(back, this.modCount,\n-\t\t\t       getEntry(fromIndex - 1, size, head, tail),\n-\t\t\t       getEntry(toIndex, size, head, tail),\n-\t\t\t       toIndex - fromIndex);\n-    }\n+  public ListIterator listIterator(int index)\n+  {\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n+                                          size);\n+    return new LinkedListItr(index);\n   }\n \n   /**\n    * Create a shallow copy of this LinkedList.\n    * @return an object of the same class as this object, containing the\n    * same elements in the same order.\n    */\n-  public Object clone() \n+  public Object clone()\n   {\n-    LinkedList copy;\n+    LinkedList copy = null;\n     try\n       {\n \tcopy = (LinkedList) super.clone();\n       }\n     catch (CloneNotSupportedException ex)\n       {\n-\tthrow new InternalError(ex.getMessage());\n       }\n     copy.size = 0;\n-    copy.ends = new Entry();\n     copy.addAll(this);\n     return copy;\n   }\n+  \n+  public Object[] toArray()\n+  {\n+    Object[] array = new Object[size];\n+    Entry e = first;\n+    for (int i = 0; i < size; i++)\n+      {\n+        array[i] = e.data;\n+        e = e.next;\n+      }\n+    return array;\n+  }\n+  \n+  public Object[] toArray(Object[] array)\n+  {\n+    if (array.length < size)\n+      array = (Object[]) Array.newInstance(array.getClass().getComponentType(), \n+        \t\t\t\t   size);\n+    else if (array.length > size)\n+      array[size] = null;\n+    Entry e = first;\n+    for (int i = 0; i < size; i++)\n+      {\n+        array[i] = e.data;\n+        e = e.next;\n+      }\n+    return array;  \n+  }\n \n   /**\n    * Serialize an object to a stream.\n    * @serialdata the size of the list (int), followed by all the elements\n    * (Object) in proper order.\n    */\n-  private void writeObject(ObjectOutputStream s)\n-    throws IOException\n+  private void writeObject(ObjectOutputStream s) throws IOException\n   {\n     s.writeInt(size);\n-    for (Iterator i = iterator(); i.hasNext(); )\n-      s.writeObject(i.next());\n+    Iterator itr = iterator();\n+    for (int i = 0; i < size; i++)\n+      s.writeObject(itr.next());\n   }\n \n   /**\n@@ -577,8 +519,133 @@ private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n     int serialSize = s.readInt();\n-    ends = new Entry();\n-    for (int i=0; i< serialSize; i++)\n-      addLast(s.readObject());\n+    for (int i = 0; i < serialSize; i++)\n+      addLastEntry(new Entry(s.readObject()));\n   }\n+  \n+  /** A ListIterator over the list. This class keeps track of its\n+   * position in the list, the size of the list, and the two list\n+   * entries it is between.  This enables it to be used identically\n+   * for both the list itself and a sublist of the list.\n+   */\n+  class LinkedListItr implements ListIterator\n+  {\n+    int knownMod;\n+    Entry next;         // entry that will be returned by next().\n+    Entry previous;     // entry that will be returned by previous().\n+    Entry lastReturned; // entry that will be affected by remove() or set().\n+    int position;       // index of `next'.\n+\n+    /**\n+     * Create a new Iter starting at a given Entry within the list, at a given\n+     * position, in a list of given size.\n+     */\n+    LinkedListItr(int index)\n+    {      \n+      if (index == size)\n+        {\n+          next = null;\n+\t  previous = last;\n+\t}\n+      else\n+        {\n+          next = getEntry(index);\n+\t  previous = next.previous;\n+\t}\n+      position = index;\n+      knownMod = modCount;\n+    }\n+\n+    private void checkMod()\n+    {\n+      if (knownMod != modCount)\n+\tthrow new ConcurrentModificationException();\n+    }\n+\n+    public int nextIndex()\n+    {\n+      checkMod();\n+      return position;\n+    }\n+\n+    public int previousIndex()\n+    {\n+      checkMod();\n+      return position - 1;\n+    }\n+\n+    public boolean hasNext()\n+    {\n+      checkMod();\n+      return (next != null);\n+    }\n+\n+    public boolean hasPrevious()\n+    {\n+      checkMod();\n+      return (previous != null);\n+    }\n+\n+    public Object next()\n+    {\n+      checkMod();\n+      if (next == null)\n+\tthrow new NoSuchElementException();\n+      position++;\n+      lastReturned = previous = next;\n+      next = lastReturned.next;\n+      return lastReturned.data;\n+    }\n+\n+    public Object previous()\n+    {\n+      checkMod();\n+      if (previous == null)\n+\tthrow new NoSuchElementException();\n+      position--;\n+      lastReturned = next = previous;\n+      previous = lastReturned.previous;\n+      return lastReturned.data;\n+    }\n+\n+    public void remove()\n+    {\n+      checkMod();\n+      if (lastReturned == null)\n+\tthrow new IllegalStateException();\n+\n+      // Adjust the position to before the removed element, if the element\n+      // being removed is behind the cursor.\n+      if (lastReturned == previous)\n+\tposition--;\n+\n+      next = lastReturned.next;\n+      previous = lastReturned.previous;\n+      // Because the list is being manipulated directly, there's no need to \n+      // touch either modCount or knownMod here.\n+      removeEntry(lastReturned);\n+      \n+      lastReturned = null;\n+    }\n+\n+    public void add(Object o)\n+    {\n+      checkMod();\n+      // Because the list is being manipulated directly, there's no need to \n+      // touch either modCount or knownMod here.\n+      Entry e = new Entry(o);\n+      addEntry(position, e);\n+      previous = e;\n+      position++;\n+      lastReturned = null;\n+    }\n+\n+    public void set(Object o)\n+    {\n+      checkMod();\n+      if (lastReturned == null)\n+\tthrow new IllegalStateException();\n+      lastReturned.data = o;\n+    }\n+  }  // class LinkedListItr  \n }"}]}