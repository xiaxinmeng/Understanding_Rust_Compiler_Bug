{"sha": "1be179930b5099059cf337cd1473409419d9219b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJlMTc5OTMwYjUwOTkwNTljZjMzN2NkMTQ3MzQwOTQxOWQ5MjE5Yg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-06-12T04:10:25Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-06-12T04:10:25Z"}, "message": "re PR fortran/40117 ([OOP][F2008] Type-bound procedure: allow list after PROCEDURE)\n\n2010-06-12  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40117\n\t* decl.c (match_procedure_in_type): Allow procedure lists (F08).\n\n\n2010-06-12  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40117\n\t* gfortran.dg/typebound_proc_4.f03: Modified error message.\n\t* gfortran.dg/typebound_proc_14.f03: New.\n\t* gfortran.dg/typebound_proc_15.f03: New.\n\nFrom-SVN: r160646", "tree": {"sha": "15d070f72a48db5a61bc792a10fa79fe19f9cd4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15d070f72a48db5a61bc792a10fa79fe19f9cd4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1be179930b5099059cf337cd1473409419d9219b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be179930b5099059cf337cd1473409419d9219b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be179930b5099059cf337cd1473409419d9219b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be179930b5099059cf337cd1473409419d9219b/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1130db7eee202beda2211645f4ca3dc026a05aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1130db7eee202beda2211645f4ca3dc026a05aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1130db7eee202beda2211645f4ca3dc026a05aad"}], "stats": {"total": 238, "additions": 157, "deletions": 81}, "files": [{"sha": "48dd521d85ff36873ccf53dbe350ae2d74c5cbad", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1be179930b5099059cf337cd1473409419d9219b", "patch": "@@ -1,3 +1,8 @@\n+2010-06-12  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40117\n+\t* decl.c (match_procedure_in_type): Allow procedure lists (F08).\n+\n 2010-06-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* trans-intrinsic.c (gfc_build_intrinsic_lib_fndecls): Fix comment."}, {"sha": "f969383fdc88d249882f9326d04057bfb6036830", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 83, "deletions": 78, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1be179930b5099059cf337cd1473409419d9219b", "patch": "@@ -7542,14 +7542,15 @@ match_procedure_in_type (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   char target_buf[GFC_MAX_SYMBOL_LEN + 1];\n-  char* target = NULL;\n+  char* target = NULL, *ifc = NULL;\n   gfc_typebound_proc* tb;\n   bool seen_colons;\n   bool seen_attrs;\n   match m;\n   gfc_symtree* stree;\n   gfc_namespace* ns;\n   gfc_symbol* block;\n+  int num;\n \n   /* Check current state.  */\n   gcc_assert (gfc_state_stack->state == COMP_DERIVED_CONTAINS);\n@@ -7574,7 +7575,7 @@ match_procedure_in_type (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      target = target_buf;\n+      ifc = target_buf;\n     }\n \n   /* Construct the data structure.  */\n@@ -7588,14 +7589,13 @@ match_procedure_in_type (void)\n     return m;\n   seen_attrs = (m == MATCH_YES);\n \n-  /* Check that attribute DEFERRED is given iff an interface is specified, which\n-     means target != NULL.  */\n-  if (tb->deferred && !target)\n+  /* Check that attribute DEFERRED is given if an interface is specified.  */\n+  if (tb->deferred && !ifc)\n     {\n       gfc_error (\"Interface must be specified for DEFERRED binding at %C\");\n       return MATCH_ERROR;\n     }\n-  if (target && !tb->deferred)\n+  if (ifc && !tb->deferred)\n     {\n       gfc_error (\"PROCEDURE(interface) at %C should be declared DEFERRED\");\n       return MATCH_ERROR;\n@@ -7612,97 +7612,102 @@ match_procedure_in_type (void)\n       return MATCH_ERROR;\n     }\n \n-  /* Match the binding name.  */ \n-  m = gfc_match_name (name);\n-  if (m == MATCH_ERROR)\n-    return m;\n-  if (m == MATCH_NO)\n-    {\n-      gfc_error (\"Expected binding name at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  /* Try to match the '=> target', if it's there.  */\n-  m = gfc_match (\" =>\");\n-  if (m == MATCH_ERROR)\n-    return m;\n-  if (m == MATCH_YES)\n+  /* Match the binding names.  */ \n+  for(num=1;;num++)\n     {\n-      if (tb->deferred)\n+      m = gfc_match_name (name);\n+      if (m == MATCH_ERROR)\n+\treturn m;\n+      if (m == MATCH_NO)\n \t{\n-\t  gfc_error (\"'=> target' is invalid for DEFERRED binding at %C\");\n+\t  gfc_error (\"Expected binding name at %C\");\n \t  return MATCH_ERROR;\n \t}\n \n-      if (!seen_colons)\n-\t{\n-\t  gfc_error (\"'::' needed in PROCEDURE binding with explicit target\"\n-\t\t     \" at %C\");\n-\t  return MATCH_ERROR;\n-\t}\n+      if (num>1 && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: PROCEDURE list\"\n+\t\t\t\t   \" at %C\") == FAILURE)\n+\treturn MATCH_ERROR;\n \n-      m = gfc_match_name (target_buf);\n+      /* Try to match the '=> target', if it's there.  */\n+      target = ifc;\n+      m = gfc_match (\" =>\");\n       if (m == MATCH_ERROR)\n \treturn m;\n-      if (m == MATCH_NO)\n+      if (m == MATCH_YES)\n \t{\n-\t  gfc_error (\"Expected binding target after '=>' at %C\");\n-\t  return MATCH_ERROR;\n+\t  if (tb->deferred)\n+\t    {\n+\t      gfc_error (\"'=> target' is invalid for DEFERRED binding at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\n+\t  if (!seen_colons)\n+\t    {\n+\t      gfc_error (\"'::' needed in PROCEDURE binding with explicit target\"\n+\t\t\t \" at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\n+\t  m = gfc_match_name (target_buf);\n+\t  if (m == MATCH_ERROR)\n+\t    return m;\n+\t  if (m == MATCH_NO)\n+\t    {\n+\t      gfc_error (\"Expected binding target after '=>' at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  target = target_buf;\n \t}\n-      target = target_buf;\n-    }\n \n-  /* Now we should have the end.  */\n-  m = gfc_match_eos ();\n-  if (m == MATCH_ERROR)\n-    return m;\n-  if (m == MATCH_NO)\n-    {\n-      gfc_error (\"Junk after PROCEDURE declaration at %C\");\n-      return MATCH_ERROR;\n-    }\n+      /* If no target was found, it has the same name as the binding.  */\n+      if (!target)\n+\ttarget = name;\n \n-  /* If no target was found, it has the same name as the binding.  */\n-  if (!target)\n-    target = name;\n+      /* Get the namespace to insert the symbols into.  */\n+      ns = block->f2k_derived;\n+      gcc_assert (ns);\n \n-  /* Get the namespace to insert the symbols into.  */\n-  ns = block->f2k_derived;\n-  gcc_assert (ns);\n+      /* If the binding is DEFERRED, check that the containing type is ABSTRACT.  */\n+      if (tb->deferred && !block->attr.abstract)\n+\t{\n+\t  gfc_error (\"Type '%s' containing DEFERRED binding at %C \"\n+\t\t     \"is not ABSTRACT\", block->name);\n+\t  return MATCH_ERROR;\n+\t}\n \n-  /* If the binding is DEFERRED, check that the containing type is ABSTRACT.  */\n-  if (tb->deferred && !block->attr.abstract)\n-    {\n-      gfc_error (\"Type '%s' containing DEFERRED binding at %C is not ABSTRACT\",\n-\t\t block->name);\n-      return MATCH_ERROR;\n-    }\n+      /* See if we already have a binding with this name in the symtree which\n+\t would be an error.  If a GENERIC already targetted this binding, it may\n+\t be already there but then typebound is still NULL.  */\n+      stree = gfc_find_symtree (ns->tb_sym_root, name);\n+      if (stree && stree->n.tb)\n+\t{\n+\t  gfc_error (\"There is already a procedure with binding name '%s' for \"\n+\t\t     \"the derived type '%s' at %C\", name, block->name);\n+\t  return MATCH_ERROR;\n+\t}\n \n-  /* See if we already have a binding with this name in the symtree which would\n-     be an error.  If a GENERIC already targetted this binding, it may be\n-     already there but then typebound is still NULL.  */\n-  stree = gfc_find_symtree (ns->tb_sym_root, name);\n-  if (stree && stree->n.tb)\n-    {\n-      gfc_error (\"There's already a procedure with binding name '%s' for the\"\n-\t\t \" derived type '%s' at %C\", name, block->name);\n-      return MATCH_ERROR;\n-    }\n+      /* Insert it and set attributes.  */\n \n-  /* Insert it and set attributes.  */\n+      if (!stree)\n+\t{\n+\t  stree = gfc_new_symtree (&ns->tb_sym_root, name);\n+\t  gcc_assert (stree);\n+\t}\n+      stree->n.tb = tb;\n \n-  if (!stree)\n-    {\n-      stree = gfc_new_symtree (&ns->tb_sym_root, name);\n-      gcc_assert (stree);\n+      if (gfc_get_sym_tree (target, gfc_current_ns, &tb->u.specific, false))\n+\treturn MATCH_ERROR;\n+      gfc_set_sym_referenced (tb->u.specific->n.sym);\n+  \n+      if (gfc_match_eos () == MATCH_YES)\n+\treturn MATCH_YES;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n     }\n-  stree->n.tb = tb;\n-\n-  if (gfc_get_sym_tree (target, gfc_current_ns, &tb->u.specific, false))\n-    return MATCH_ERROR;\n-  gfc_set_sym_referenced (tb->u.specific->n.sym);\n \n-  return MATCH_YES;\n+syntax:\n+  gfc_error (\"Syntax error in PROCEDURE statement at %C\");\n+  return MATCH_ERROR;\n }\n \n "}, {"sha": "e56ac3af3f05c0c829b51c10238173ec02caed8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1be179930b5099059cf337cd1473409419d9219b", "patch": "@@ -1,3 +1,10 @@\n+2010-06-12  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40117\n+\t* gfortran.dg/typebound_proc_4.f03: Modified error message.\n+\t* gfortran.dg/typebound_proc_14.f03: New.\n+\t* gfortran.dg/typebound_proc_15.f03: New.\n+\n 2010-06-11  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/opts-1.c: New test."}, {"sha": "766a0ef66c1b6e1efcb7ede2e41f169bd4edb3e6", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_14.f03", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_14.f03?ref=1be179930b5099059cf337cd1473409419d9219b", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+!\n+! PR 40117: [OOP][F2008] Type-bound procedure: allow list after PROCEDURE\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+\n+implicit none\n+\n+type :: t\n+contains\n+  procedure :: foo, bar, baz\n+end type\n+\n+contains\n+\n+  subroutine foo (this)\n+    class(t) :: this\n+  end subroutine\n+\n+  real function bar (this)\n+    class(t) :: this\n+  end function\n+\n+  subroutine baz (this, par)\n+    class(t) :: this\n+    integer :: par\n+  end subroutine\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "a8a2ce7e87a656339aa3d0648638ce833cb943c7", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_15.f03", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_15.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_15.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_15.f03?ref=1be179930b5099059cf337cd1473409419d9219b", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! PR 40117: [OOP][F2008] Type-bound procedure: allow list after PROCEDURE\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org> \n+\n+module m\n+\n+implicit none\n+\n+type :: t\n+contains\n+  procedure :: foo\n+  procedure :: bar, baz  { dg-error \"PROCEDURE list\" }\n+end type\n+\n+contains\n+\n+  subroutine foo (this)\n+    class(t) :: this\n+  end subroutine\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "60aa728a40ff599c4636eb01b61384f0fbe99402", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_4.f03", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be179930b5099059cf337cd1473409419d9219b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_4.f03?ref=1be179930b5099059cf337cd1473409419d9219b", "patch": "@@ -17,12 +17,12 @@ MODULE testmod\n     PROCEDURE ? ! { dg-error \"Expected binding name\" }\n     PROCEDURE :: p2 => ! { dg-error \"Expected binding target\" }\n     PROCEDURE :: p3 =>, ! { dg-error \"Expected binding target\" }\n-    PROCEDURE p4, ! { dg-error \"Junk after\" }\n-    PROCEDURE :: p5 => proc2, ! { dg-error \"Junk after\" }\n+    PROCEDURE p4, ! { dg-error \"Expected binding name\" }\n+    PROCEDURE :: p5 => proc2, ! { dg-error \"Expected binding name\" }\n     PROCEDURE :: p0 => proc3 ! { dg-error \"already a procedure\" }\n     PROCEDURE, PASS p6 ! { dg-error \"::\" }\n     PROCEDURE, PASS NON_OVERRIDABLE ! { dg-error \"Expected\" }\n-    PROCEDURE PASS :: ! { dg-error \"Junk after\" }\n+    PROCEDURE PASS :: ! { dg-error \"Syntax error\" }\n     PROCEDURE, PASS (x ! { dg-error \"Expected\" }\n     PROCEDURE, PASS () ! { dg-error \"Expected\" }\n     PROCEDURE, NOPASS, PASS ! { dg-error \"illegal PASS\" }"}]}