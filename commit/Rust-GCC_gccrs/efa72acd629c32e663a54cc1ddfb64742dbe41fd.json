{"sha": "efa72acd629c32e663a54cc1ddfb64742dbe41fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZhNzJhY2Q2MjljMzJlNjYzYTU0Y2MxZGRmYjY0NzQyZGJlNDFmZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@linux.vnet.ibm.com", "date": "2014-05-20T14:18:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-05-20T14:18:44Z"}, "message": "re PR bootstrap/61210 (bootstrap failure with clang)\n\ngcc/cp/\n\tPR bootstrap/61210\n\t* pt.c (tsubst_copy, tsubst_omp_for_iterator, tsubst_expr)\n\t(tsubst_copy_and_build): Perform recursive substitutions in a\n\tdeterministic order.\n\nFrom-SVN: r210645", "tree": {"sha": "ba16a0311b674afe3a50da11b9126f7842f21e23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba16a0311b674afe3a50da11b9126f7842f21e23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efa72acd629c32e663a54cc1ddfb64742dbe41fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa72acd629c32e663a54cc1ddfb64742dbe41fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa72acd629c32e663a54cc1ddfb64742dbe41fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa72acd629c32e663a54cc1ddfb64742dbe41fd/comments", "author": null, "committer": null, "parents": [{"sha": "ec217bd88a7f9ac30e05ff43de51dda5e4b001d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec217bd88a7f9ac30e05ff43de51dda5e4b001d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec217bd88a7f9ac30e05ff43de51dda5e4b001d2"}], "stats": {"total": 263, "additions": 154, "deletions": 109}, "files": [{"sha": "6886b965b27005deb4ea2577d1885d256a2825c5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa72acd629c32e663a54cc1ddfb64742dbe41fd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa72acd629c32e663a54cc1ddfb64742dbe41fd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=efa72acd629c32e663a54cc1ddfb64742dbe41fd", "patch": "@@ -1,3 +1,10 @@\n+2014-05-20  Richard Sandiford  <rsandifo@linux.vnet.ibm.com>\n+\n+\tPR bootstrap/61210\n+\t* pt.c (tsubst_copy, tsubst_omp_for_iterator, tsubst_expr)\n+\t(tsubst_copy_and_build): Perform recursive substitutions in a\n+\tdeterministic order.\n+\n 2014-05-20  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58664"}, {"sha": "fca1ab34d0512dd327cc0540b18acf6617d1d76d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 147, "deletions": 109, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa72acd629c32e663a54cc1ddfb64742dbe41fd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa72acd629c32e663a54cc1ddfb64742dbe41fd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=efa72acd629c32e663a54cc1ddfb64742dbe41fd", "patch": "@@ -12734,9 +12734,11 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case IMPLICIT_CONV_EXPR:\n     case CONVERT_EXPR:\n     case NOP_EXPR:\n-      return build1\n-\t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\treturn build1 (code, type, op0);\n+      }\n \n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n@@ -12804,9 +12806,11 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case PAREN_EXPR:\n-      return build1\n-\t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\treturn build1 (code, type, op0);\n+      }\n \n     case COMPONENT_REF:\n       {\n@@ -12880,24 +12884,26 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      return build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n+      {\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\treturn build_nt (code, op0, op1);\n+      }\n \n     case SCOPE_REF:\n-      return build_qualified_name (/*type=*/NULL_TREE,\n-\t\t\t\t   tsubst_copy (TREE_OPERAND (t, 0),\n-\t\t\t\t\t\targs, complain, in_decl),\n-\t\t\t\t   tsubst_copy (TREE_OPERAND (t, 1),\n-\t\t\t\t\t\targs, complain, in_decl),\n-\t\t\t\t   QUALIFIED_NAME_IS_TEMPLATE (t));\n+      {\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\treturn build_qualified_name (/*type=*/NULL_TREE, op0, op1,\n+\t\t\t\t     QUALIFIED_NAME_IS_TEMPLATE (t));\n+      }\n \n     case ARRAY_REF:\n-      return build_nt\n-\t(ARRAY_REF,\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t NULL_TREE, NULL_TREE);\n+      {\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\treturn build_nt (ARRAY_REF, op0, op1, NULL_TREE, NULL_TREE);\n+      }\n \n     case CALL_EXPR:\n       {\n@@ -12915,29 +12921,29 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case PSEUDO_DTOR_EXPR:\n     case VEC_PERM_EXPR:\n       {\n-\tr = build_nt\n-\t  (code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\ttree op2 = tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl);\n+\tr = build_nt (code, op0, op1, op2);\n \tTREE_NO_WARNING (r) = TREE_NO_WARNING (t);\n \treturn r;\n       }\n \n     case NEW_EXPR:\n       {\n-\tr = build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\ttree op2 = tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl);\n+\tr = build_nt (code, op0, op1, op2);\n \tNEW_EXPR_USE_GLOBAL (r) = NEW_EXPR_USE_GLOBAL (t);\n \treturn r;\n       }\n \n     case DELETE_EXPR:\n       {\n-\tr = build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\tr = build_nt (code, op0, op1);\n \tDELETE_EXPR_USE_GLOBAL (r) = DELETE_EXPR_USE_GLOBAL (t);\n \tDELETE_EXPR_USE_VEC (r) = DELETE_EXPR_USE_VEC (t);\n \treturn r;\n@@ -13017,10 +13023,11 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       gcc_unreachable ();\n \n     case VA_ARG_EXPR:\n-      return build_x_va_arg (EXPR_LOCATION (t),\n-\t\t\t     tsubst_copy (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t\t  in_decl),\n-\t\t\t     tsubst (TREE_TYPE (t), args, complain, in_decl));\n+      {\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\treturn build_x_va_arg (EXPR_LOCATION (t), op0, type);\n+      }\n \n     case CLEANUP_POINT_EXPR:\n       /* We shouldn't have built any of these during initial template\n@@ -13029,13 +13036,15 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       gcc_unreachable ();\n \n     case OFFSET_REF:\n-      r = build2\n-\t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n-      PTRMEM_OK_P (r) = PTRMEM_OK_P (t);\n-      mark_used (TREE_OPERAND (r, 1));\n-      return r;\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\tr = build2 (code, type, op0, op1);\n+\tPTRMEM_OK_P (r) = PTRMEM_OK_P (t);\n+\tmark_used (TREE_OPERAND (r, 1));\n+\treturn r;\n+      }\n \n     case EXPR_PACK_EXPANSION:\n       error (\"invalid use of pack expansion expression\");\n@@ -13270,10 +13279,12 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n       cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));\n       incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n       if (TREE_CODE (incr) == MODIFY_EXPR)\n-\tincr = build_x_modify_expr (EXPR_LOCATION (incr),\n-\t\t\t\t    RECUR (TREE_OPERAND (incr, 0)), NOP_EXPR,\n-\t\t\t\t    RECUR (TREE_OPERAND (incr, 1)),\n-\t\t\t\t    complain);\n+\t{\n+\t  tree lhs = RECUR (TREE_OPERAND (incr, 0));\n+\t  tree rhs = RECUR (TREE_OPERAND (incr, 1));\n+\t  incr = build_x_modify_expr (EXPR_LOCATION (incr), lhs,\n+\t\t\t\t      NOP_EXPR, rhs, complain);\n+\t}\n       else\n \tincr = RECUR (incr);\n       TREE_VEC_ELT (declv, i) = decl;\n@@ -13319,9 +13330,11 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n     }\n   cond = TREE_VEC_ELT (OMP_FOR_COND (t), i);\n   if (COMPARISON_CLASS_P (cond))\n-    cond = build2 (TREE_CODE (cond), boolean_type_node,\n-\t\t   RECUR (TREE_OPERAND (cond, 0)),\n-\t\t   RECUR (TREE_OPERAND (cond, 1)));\n+    {\n+      tree op0 = RECUR (TREE_OPERAND (cond, 0));\n+      tree op1 = RECUR (TREE_OPERAND (cond, 1));\n+      cond = build2 (TREE_CODE (cond), boolean_type_node, op0, op1);\n+    }\n   else\n     cond = RECUR (cond);\n   incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n@@ -13339,11 +13352,12 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n \t  || TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR)\n \t{\n \t  tree rhs = TREE_OPERAND (incr, 1);\n-\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl),\n-\t\t\t RECUR (TREE_OPERAND (incr, 0)),\n+\t  tree lhs = RECUR (TREE_OPERAND (incr, 0));\n+\t  tree rhs0 = RECUR (TREE_OPERAND (rhs, 0));\n+\t  tree rhs1 = RECUR (TREE_OPERAND (rhs, 1));\n+\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl), lhs,\n \t\t\t build2 (TREE_CODE (rhs), TREE_TYPE (decl),\n-\t\t\t\t RECUR (TREE_OPERAND (rhs, 0)),\n-\t\t\t\t RECUR (TREE_OPERAND (rhs, 1))));\n+\t\t\t\t rhs0, rhs1));\n \t}\n       else\n \tincr = RECUR (incr);\n@@ -13363,11 +13377,12 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n \t\t   || (TREE_CODE (TREE_OPERAND (incr, 2)) == MINUS_EXPR)))\n \t{\n \t  tree rhs = TREE_OPERAND (incr, 2);\n-\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl),\n-\t\t\t RECUR (TREE_OPERAND (incr, 0)),\n+\t  tree lhs = RECUR (TREE_OPERAND (incr, 0));\n+\t  tree rhs0 = RECUR (TREE_OPERAND (rhs, 0));\n+\t  tree rhs1 = RECUR (TREE_OPERAND (rhs, 1));\n+\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl), lhs,\n \t\t\t build2 (TREE_CODE (rhs), TREE_TYPE (decl),\n-\t\t\t\t RECUR (TREE_OPERAND (rhs, 0)),\n-\t\t\t\t RECUR (TREE_OPERAND (rhs, 1))));\n+\t\t\t\t rhs0, rhs1));\n \t}\n       else\n \tincr = RECUR (incr);\n@@ -13645,9 +13660,11 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case CASE_LABEL_EXPR:\n-      finish_case_label (EXPR_LOCATION (t),\n-\t\t\t RECUR (CASE_LOW (t)),\n-\t\t\t RECUR (CASE_HIGH (t)));\n+      {\n+\ttree low = RECUR (CASE_LOW (t));\n+\ttree high = RECUR (CASE_HIGH (t));\n+\tfinish_case_label (EXPR_LOCATION (t), low, high);\n+      }\n       break;\n \n     case LABEL_EXPR:\n@@ -13674,14 +13691,18 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case ASM_EXPR:\n-      tmp = finish_asm_stmt\n-\t(ASM_VOLATILE_P (t),\n-\t RECUR (ASM_STRING (t)),\n-\t tsubst_copy_asm_operands (ASM_OUTPUTS (t), args, complain, in_decl),\n-\t tsubst_copy_asm_operands (ASM_INPUTS (t), args, complain, in_decl),\n-\t tsubst_copy_asm_operands (ASM_CLOBBERS (t), args, complain, in_decl),\n-\t tsubst_copy_asm_operands (ASM_LABELS (t), args, complain, in_decl));\n       {\n+\ttree string = RECUR (ASM_STRING (t));\n+\ttree outputs = tsubst_copy_asm_operands (ASM_OUTPUTS (t), args,\n+\t\t\t\t\t\t complain, in_decl);\n+\ttree inputs = tsubst_copy_asm_operands (ASM_INPUTS (t), args,\n+\t\t\t\t\t\tcomplain, in_decl);\n+\ttree clobbers = tsubst_copy_asm_operands (ASM_CLOBBERS (t), args,\n+\t \t\t\t\t\t  complain, in_decl);\n+\ttree labels = tsubst_copy_asm_operands (ASM_LABELS (t), args,\n+\t\t\t\t\t\tcomplain, in_decl);\n+\ttmp = finish_asm_stmt (ASM_VOLATILE_P (t), string, outputs, inputs,\n+\t\t\t       clobbers, labels);\n \ttree asm_expr = tmp;\n \tif (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)\n \t  asm_expr = TREE_OPERAND (asm_expr, 0);\n@@ -13978,8 +13999,11 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case MUST_NOT_THROW_EXPR:\n-      RETURN (build_must_not_throw_expr (RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t\tRECUR (MUST_NOT_THROW_COND (t))));\n+      {\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree cond = RECUR (MUST_NOT_THROW_COND (t));\n+\tRETURN (build_must_not_throw_expr (op0, cond));\n+      }\n \n     case EXPR_PACK_EXPANSION:\n       error (\"invalid use of pack expansion expression\");\n@@ -14246,9 +14270,11 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case NOP_EXPR:\n-      RETURN (build_nop\n-\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0))));\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\tRETURN (build_nop (type, op0));\n+      }\n \n     case IMPLICIT_CONV_EXPR:\n       {\n@@ -14262,10 +14288,11 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case CONVERT_EXPR:\n-      RETURN (build1\n-\t(CONVERT_EXPR,\n-\t tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0))));\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\tRETURN (build1 (CONVERT_EXPR, type, op0));\n+      }\n \n     case CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n@@ -14330,12 +14357,12 @@ tsubst_copy_and_build (tree t,\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n       RETURN (build_x_unary_op (input_location, TREE_CODE (t),\n-\t\t\t       RECUR (TREE_OPERAND (t, 0)),\n+\t\t\t\tRECUR (TREE_OPERAND (t, 0)),\n \t\t\t\tcomplain|decltype_flag));\n \n     case FIX_TRUNC_EXPR:\n       RETURN (cp_build_unary_op (FIX_TRUNC_EXPR, RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t0, complain));\n+\t\t\t\t 0, complain));\n \n     case ADDR_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n@@ -14385,13 +14412,15 @@ tsubst_copy_and_build (tree t,\n       {\n \twarning_sentinel s1(warn_type_limits);\n \twarning_sentinel s2(warn_div_by_zero);\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree op1 = RECUR (TREE_OPERAND (t, 1));\n \ttree r = build_x_binary_op\n \t  (input_location, TREE_CODE (t),\n-\t   RECUR (TREE_OPERAND (t, 0)),\n+\t   op0,\n \t   (TREE_NO_WARNING (TREE_OPERAND (t, 0))\n \t    ? ERROR_MARK\n \t    : TREE_CODE (TREE_OPERAND (t, 0))),\n-\t   RECUR (TREE_OPERAND (t, 1)),\n+\t   op1,\n \t   (TREE_NO_WARNING (TREE_OPERAND (t, 1))\n \t    ? ERROR_MARK\n \t    : TREE_CODE (TREE_OPERAND (t, 1))),\n@@ -14404,8 +14433,11 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case POINTER_PLUS_EXPR:\n-      return fold_build_pointer_plus (RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t      RECUR (TREE_OPERAND (t, 1)));\n+      {\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree op1 = RECUR (TREE_OPERAND (t, 1));\n+\treturn fold_build_pointer_plus (op0, op1);\n+      }\n \n     case SCOPE_REF:\n       RETURN (tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,\n@@ -14515,11 +14547,10 @@ tsubst_copy_and_build (tree t,\n     case MODOP_EXPR:\n       {\n \twarning_sentinel s(warn_div_by_zero);\n+\ttree lhs = RECUR (TREE_OPERAND (t, 0));\n+\ttree rhs = RECUR (TREE_OPERAND (t, 2));\n \ttree r = build_x_modify_expr\n-\t  (EXPR_LOCATION (t),\n-\t   RECUR (TREE_OPERAND (t, 0)),\n-\t   TREE_CODE (TREE_OPERAND (t, 1)),\n-\t   RECUR (TREE_OPERAND (t, 2)),\n+\t  (EXPR_LOCATION (t), lhs, TREE_CODE (TREE_OPERAND (t, 1)), rhs,\n \t   complain|decltype_flag);\n \t/* TREE_NO_WARNING must be set if either the expression was\n \t   parenthesized or it uses an operator such as >>= rather\n@@ -14578,10 +14609,9 @@ tsubst_copy_and_build (tree t,\n \t      }\n \t  }\n \n-\tret = build_new (&placement_vec,\n-\t\t\t tsubst (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t\t\t RECUR (TREE_OPERAND (t, 2)),\n-\t\t\t &init_vec,\n+\ttree op1 = tsubst (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\ttree op2 = RECUR (TREE_OPERAND (t, 2));\n+\tret = build_new (&placement_vec, op1, op2, &init_vec,\n \t\t\t NEW_EXPR_USE_GLOBAL (t),\n \t\t\t complain);\n \n@@ -14594,12 +14624,14 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case DELETE_EXPR:\n-     RETURN (delete_sanity\n-       (RECUR (TREE_OPERAND (t, 0)),\n-\tRECUR (TREE_OPERAND (t, 1)),\n-\tDELETE_EXPR_USE_VEC (t),\n-\tDELETE_EXPR_USE_GLOBAL (t),\n-\tcomplain));\n+      {\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree op1 = RECUR (TREE_OPERAND (t, 1));\n+\tRETURN (delete_sanity (op0, op1,\n+\t\t\t       DELETE_EXPR_USE_VEC (t),\n+\t\t\t       DELETE_EXPR_USE_GLOBAL (t),\n+\t\t\t       complain));\n+      }\n \n     case COMPOUND_EXPR:\n       {\n@@ -14866,11 +14898,13 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case PSEUDO_DTOR_EXPR:\n-      RETURN (finish_pseudo_destructor_expr\n-\t      (RECUR (TREE_OPERAND (t, 0)),\n-\t       RECUR (TREE_OPERAND (t, 1)),\n-\t       tsubst (TREE_OPERAND (t, 2), args, complain, in_decl),\n-\t       input_location));\n+      {\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree op1 = RECUR (TREE_OPERAND (t, 1));\n+\ttree op2 = tsubst (TREE_OPERAND (t, 2), args, complain, in_decl);\n+\tRETURN (finish_pseudo_destructor_expr (op0, op1, op2,\n+\t\t\t\t\t       input_location));\n+      }\n \n     case TREE_LIST:\n       {\n@@ -15194,9 +15228,11 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case VA_ARG_EXPR:\n-      RETURN (build_x_va_arg (EXPR_LOCATION (t),\n-\t\t\t     RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t     tsubst (TREE_TYPE (t), args, complain, in_decl)));\n+      {\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\tRETURN (build_x_va_arg (EXPR_LOCATION (t), op0, type));\n+      }\n \n     case OFFSETOF_EXPR:\n       RETURN (finish_offsetof (RECUR (TREE_OPERAND (t, 0))));\n@@ -15305,11 +15341,13 @@ tsubst_copy_and_build (tree t,\n       RETURN (finish_parenthesized_expr (RECUR (TREE_OPERAND (t, 0))));\n \n     case VEC_PERM_EXPR:\n-      RETURN (build_x_vec_perm_expr (input_location,\n-\t\tRECUR (TREE_OPERAND (t, 0)),\n-\t\tRECUR (TREE_OPERAND (t, 1)),\n-\t\tRECUR (TREE_OPERAND (t, 2)),\n-\t\tcomplain));\n+      {\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\ttree op1 = RECUR (TREE_OPERAND (t, 1));\n+\ttree op2 = RECUR (TREE_OPERAND (t, 2));\n+\tRETURN (build_x_vec_perm_expr (input_location, op0, op1, op2,\n+\t\t\t\t       complain));\n+      }\n \n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */"}]}