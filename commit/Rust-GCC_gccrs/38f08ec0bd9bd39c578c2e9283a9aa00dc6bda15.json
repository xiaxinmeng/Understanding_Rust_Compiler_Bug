{"sha": "38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmMDhlYzBiZDliZDM5YzU3OGMyZTkyODNhOWFhMDBkYzZiZGExNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-02T00:16:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-02T00:16:43Z"}, "message": "runtime: scan register backing store on ia64\n    \n    On ia64, a separate stack is used for saving/restoring register frames,\n    occupying the other end of the stack mapping. This must also be scanned\n    for pointers into the heap.\n    \n    Reviewed-on: https://go-review.googlesource.com/85276\n\nFrom-SVN: r257323", "tree": {"sha": "13c1ddb95c4048060b536abd200b8e24d0b2d066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13c1ddb95c4048060b536abd200b8e24d0b2d066"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/comments", "author": null, "committer": null, "parents": [{"sha": "2e30f1ee86b087497fb5178a23a09ea6e22b1af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e30f1ee86b087497fb5178a23a09ea6e22b1af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e30f1ee86b087497fb5178a23a09ea6e22b1af4"}], "stats": {"total": 45, "additions": 44, "deletions": 1}, "files": [{"sha": "46bdc3c67da6fc3e1e7dacc903659522286d8197", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "patch": "@@ -1,4 +1,4 @@\n-e148068360699f24118950b728f23a5c98e1f85e\n+5e8a91bf239c253d7b5c84bd2c1dd3ecb18980e9\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0299d5a788f38eb32b5bfb2158e5851006f318e1", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "patch": "@@ -409,11 +409,15 @@ type g struct {\n \t// gcnextsegment: unused\n \t// gcnextsp: current SP while executing a syscall\n \t// gcinitialsp: g0: top of stack; others: start of stack memory\n+\t// gcnextsp2: current secondary stack pointer (if present)\n+\t// gcinitialsp2: start of secondary stack (if present)\n \tgcstack       uintptr\n \tgcstacksize   uintptr\n \tgcnextsegment uintptr\n \tgcnextsp      uintptr\n \tgcinitialsp   unsafe.Pointer\n+\tgcnextsp2     uintptr\n+\tgcinitialsp2  unsafe.Pointer\n \n \t// gcregs holds the register values while executing a syscall.\n \t// This is set by getcontext and scanned by the garbage collector."}, {"sha": "12c055d71ad79e728ac2e16a2eebda84bbee52db", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "patch": "@@ -308,6 +308,7 @@ runtime_mcall(FuncVal *fv)\n \t// Ensure that all registers are on the stack for the garbage\n \t// collector.\n \t__builtin_unwind_init();\n+\tflush_registers_to_secondary_stack();\n \n \tgp = g;\n \tmp = gp->m;\n@@ -322,6 +323,7 @@ runtime_mcall(FuncVal *fv)\n \t\t// We have to point to an address on the stack that is\n \t\t// below the saved registers.\n \t\tgp->gcnextsp = (uintptr)(&afterregs);\n+\t\tgp->gcnextsp2 = (uintptr)(secondary_stack_pointer());\n #endif\n \t\tgp->fromgogo = false;\n \t\tgetcontext(ucontext_arg(&gp->context[0]));\n@@ -500,6 +502,8 @@ runtime_mstart(void *arg)\n \t// is the top of the stack, not the bottom.\n \tgp->gcstacksize = 0;\n \tgp->gcnextsp = (uintptr)(&arg);\n+\tgp->gcinitialsp2 = secondary_stack_pointer();\n+\tgp->gcnextsp2 = (uintptr)(gp->gcinitialsp2);\n #endif\n \n \t// Save the currently active context.  This will return\n@@ -576,6 +580,8 @@ setGContext(void)\n \tgp->gcstack = 0;\n \tgp->gcstacksize = 0;\n \tgp->gcnextsp = (uintptr)(&val);\n+\tgp->gcinitialsp2 = secondary_stack_pointer();\n+\tgp->gcnextsp2 = (uintptr)(gp->gcinitialsp2);\n #endif\n \tgetcontext(ucontext_arg(&gp->context[0]));\n \n@@ -654,6 +660,7 @@ doentersyscall(uintptr pc, uintptr sp)\n \t\tvoid *v;\n \n \t\tg->gcnextsp = (uintptr)(&v);\n+\t\tg->gcnextsp2 = (uintptr)(secondary_stack_pointer());\n \t}\n #endif\n \n@@ -694,6 +701,7 @@ doentersyscallblock(uintptr pc, uintptr sp)\n \t\tvoid *v;\n \n \t\tg->gcnextsp = (uintptr)(&v);\n+\t\tg->gcnextsp2 = (uintptr)(secondary_stack_pointer());\n \t}\n #endif\n \n@@ -756,6 +764,7 @@ runtime_malg(bool allocatestack, bool signalstack, byte** ret_stack, uintptr* re\n \t\t*ret_stacksize = (uintptr)stacksize;\n \t\tnewg->gcinitialsp = *ret_stack;\n \t\tnewg->gcstacksize = (uintptr)stacksize;\n+\t\tnewg->gcinitialsp2 = initial_secondary_stack_pointer(*ret_stack);\n #endif\n \t}\n \treturn newg;\n@@ -807,6 +816,7 @@ resetNewG(G *newg, void **sp, uintptr *spsize)\n   if(*spsize == 0)\n     runtime_throw(\"bad spsize in resetNewG\");\n   newg->gcnextsp = (uintptr)(*sp);\n+  newg->gcnextsp2 = (uintptr)(newg->gcinitialsp2);\n #endif\n }\n "}, {"sha": "0fafe82144189d743a5674f3ccdf05967fc9353f", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "patch": "@@ -437,6 +437,23 @@ void\truntime_check(void)\n // the stacks are allocated by the splitstack library.\n extern uintptr runtime_stacks_sys;\n \n+/*\n+ * ia64's register file is spilled to a separate stack, the register backing\n+ * store, on window overflow, and must also be scanned. This occupies the other\n+ * end of the normal stack allocation, growing upwards.\n+ * We also need to ensure all register windows are flushed to the backing\n+ * store, as unlike SPARC, __builtin_unwind_init doesn't do this on ia64.\n+ */\n+#ifdef __ia64__\n+# define secondary_stack_pointer() __builtin_ia64_bsp()\n+# define initial_secondary_stack_pointer(stack_alloc) (stack_alloc)\n+# define flush_registers_to_secondary_stack() __builtin_ia64_flushrs()\n+#else\n+# define secondary_stack_pointer() nil\n+# define initial_secondary_stack_pointer(stack_alloc) nil\n+# define flush_registers_to_secondary_stack()\n+#endif\n+\n struct backtrace_state;\n extern struct backtrace_state *__go_get_backtrace_state(void);\n extern _Bool __go_file_line(uintptr, int, String*, String*, intgo *);"}, {"sha": "a971e8f9266e73396fc0a15647b43b188ef30c21", "filename": "libgo/runtime/stack.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fruntime%2Fstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15/libgo%2Fruntime%2Fstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fstack.c?ref=38f08ec0bd9bd39c578c2e9283a9aa00dc6bda15", "patch": "@@ -34,6 +34,7 @@ void doscanstack(G *gp, void* gcw) {\n \t// Save registers on the stack, so that if we are scanning our\n \t// own stack we will see them.\n \t__builtin_unwind_init();\n+\tflush_registers_to_secondary_stack();\n \n \tdoscanstack1(gp, gcw);\n }\n@@ -82,21 +83,32 @@ static void doscanstack1(G *gp, void *gcw) {\n #else\n \tbyte* bottom;\n \tbyte* top;\n+\tbyte* nextsp2;\n+\tbyte* initialsp2;\n \n \tif(gp == runtime_g()) {\n \t\t// Scanning our own stack.\n \t\tbottom = (byte*)&gp;\n+\t\tnextsp2 = secondary_stack_pointer();\n \t} else {\n \t\t// Scanning another goroutine's stack.\n \t\t// The goroutine is usually asleep (the world is stopped).\n \t\tbottom = (void*)gp->gcnextsp;\n \t\tif(bottom == nil)\n \t\t\treturn;\n+\t\tnextsp2 = (void*)gp->gcnextsp2;\n \t}\n \ttop = (byte*)(void*)(gp->gcinitialsp) + gp->gcstacksize;\n \tif(top > bottom)\n \t\tscanstackblock(bottom, (uintptr)(top - bottom), gcw);\n \telse\n \t\tscanstackblock(top, (uintptr)(bottom - top), gcw);\n+\tif (nextsp2 != nil) {\n+\t\tinitialsp2 = (byte*)(void*)(gp->gcinitialsp2);\n+\t\tif(initialsp2 > nextsp2)\n+\t\t\tscanstackblock(nextsp2, (uintptr)(initialsp2 - nextsp2), gcw);\n+\t\telse\n+\t\t\tscanstackblock(initialsp2, (uintptr)(nextsp2 - initialsp2), gcw);\n+\t}\n #endif\n }"}]}