{"sha": "0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmZDM4YzgxZjJiZWIxNmQ3MWQ5NWE4Y2ZhMWI1MzJkOWQ2MDJlYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-12-04T10:16:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-12-04T10:16:17Z"}, "message": "target-supports.exp (get_compiler_messages): Replace with...\n\ngcc/testsuite/\n\t* lib/target-supports.exp (get_compiler_messages): Replace with...\n\t(check_compile): ...this new procedure.  Handle TYPE == executable.\n\tUse comments in the source to determine the correct extension.\n\tReturn a pair containing the compiler output and the output filename.\n\tDon't delete the file here.\n\t(check_no_compiler_messages_nocache): New procedure.\n\t(check_no_compiler_messages): Use it.\n\t(check_no_messages_and_pattern_nocache): New procedure.\n\t(check_no_messages_and_pattern): Use it.\n\t(check_runtime_nocache, check_runtime): New procedures.\n\t(check_effective_target_tls): Use check_no_compiler_messages.\n\t(check_effective_target_tls_native): Use check_no_messages_and_pattern.\n\t(check_effective_target_tls_runtime): Use check_runtime.\n\t(check_effective_target_fstack_protector): Likewise.\n\t(check_iconv_available): Use check_runtime_nocache.\n\t(check_effective_target_fortran_large_real): Use\n\tcheck_no_compiler_messages.\n\t(check_effective_target_fortran_large_int): Likewise.\n\t(check_effective_target_static_libgfortran): Likewise.\n\t(check_750cl_hw_available): Use check_cached_effective_target\n\tand check_runtime_nocache.\n\t(check_vmx_hw_available): Likewise.\n\t(check_effective_target_broken_cplxf_arg): Likewise.\n\t(check_alpha_max_hw_available): Use check_runtime.\n\t(check_function_available): Use check_no_compiler_messages.\n\t(check_cxa_atexit_available): Use check_cached_effective_target\n\tand check_runtime_nocache.\n\t(check_effective_target_dfp_nocache): Use\n\tcheck_no_compiler_messages_nocache.\n\t(check_effective_target_dfprt_nocache): Use check_runtime_nocache.\n\t(check_effective_target_dfp): Use check_cached_effective_target.\n\t(check_effective_target_dfprt): Likewise.\n\t(check_effective_target_arm_neon_hw): Use check_runtime.\n\t(check_effective_target_ultrasparc_hw): Likewise.\n\t(check_effective_target_c99_runtime): Use\n\tcheck_no_compiler_messages_nocache.\n\nFrom-SVN: r130599", "tree": {"sha": "8af9cfb4241921c60621b1d95a04b294aa0ee4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8af9cfb4241921c60621b1d95a04b294aa0ee4c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea/comments", "author": null, "committer": null, "parents": [{"sha": "34add7804eeec20db8774269a9765c8a4cbc018e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34add7804eeec20db8774269a9765c8a4cbc018e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34add7804eeec20db8774269a9765c8a4cbc018e"}], "stats": {"total": 1154, "additions": 324, "deletions": 830}, "files": [{"sha": "8ec5307f8e5f5d3b06a216dffc6af223f49b13fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea", "patch": "@@ -1,3 +1,42 @@\n+2007-12-04  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* lib/target-supports.exp (get_compiler_messages): Replace with...\n+\t(check_compile): ...this new procedure.  Handle TYPE == executable.\n+\tUse comments in the source to determine the correct extension.\n+\tReturn a pair containing the compiler output and the output filename.\n+\tDon't delete the file here.\n+\t(check_no_compiler_messages_nocache): New procedure.\n+\t(check_no_compiler_messages): Use it.\n+\t(check_no_messages_and_pattern_nocache): New procedure.\n+\t(check_no_messages_and_pattern): Use it.\n+\t(check_runtime_nocache, check_runtime): New procedures.\n+\t(check_effective_target_tls): Use check_no_compiler_messages.\n+\t(check_effective_target_tls_native): Use check_no_messages_and_pattern.\n+\t(check_effective_target_tls_runtime): Use check_runtime.\n+\t(check_effective_target_fstack_protector): Likewise.\n+\t(check_iconv_available): Use check_runtime_nocache.\n+\t(check_effective_target_fortran_large_real): Use\n+\tcheck_no_compiler_messages.\n+\t(check_effective_target_fortran_large_int): Likewise.\n+\t(check_effective_target_static_libgfortran): Likewise.\n+\t(check_750cl_hw_available): Use check_cached_effective_target\n+\tand check_runtime_nocache.\n+\t(check_vmx_hw_available): Likewise.\n+\t(check_effective_target_broken_cplxf_arg): Likewise.\n+\t(check_alpha_max_hw_available): Use check_runtime.\n+\t(check_function_available): Use check_no_compiler_messages.\n+\t(check_cxa_atexit_available): Use check_cached_effective_target\n+\tand check_runtime_nocache.\n+\t(check_effective_target_dfp_nocache): Use\n+\tcheck_no_compiler_messages_nocache.\n+\t(check_effective_target_dfprt_nocache): Use check_runtime_nocache.\n+\t(check_effective_target_dfp): Use check_cached_effective_target.\n+\t(check_effective_target_dfprt): Likewise.\n+\t(check_effective_target_arm_neon_hw): Use check_runtime.\n+\t(check_effective_target_ultrasparc_hw): Likewise.\n+\t(check_effective_target_c99_runtime): Use\n+\tcheck_no_compiler_messages_nocache.\n+\n 2007-12-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/29749"}, {"sha": "f6a4cce415f89dabffaee5f39f00637bc4ecc103", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 285, "deletions": 830, "changes": 1115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0ffd38c81f2beb16d71d95a8cfa1b532d9d602ea", "patch": "@@ -20,60 +20,42 @@\n \n # This file defines procs for determining features supported by the target.\n \n-# Try to compile some code and return the messages printed by the compiler,\n-# and optionally the contents for assembly files.  Either a string or\n-# a list of two strings are returned, depending on WANT_OUTPUT.\n+# Try to compile the code given by CONTENTS into an output file of\n+# type TYPE, where TYPE is as for target_compile.  Return a list\n+# whose first element contains the compiler messages and whose\n+# second element is the name of the output file.\n #\n-# BASENAME is a basename to use for temporary files.\n-# WANT_OUTPUT is a flag which is 0 to request returning just the\n-#   compiler messages, or 1 to return the messages and the contents\n-#   of the assembly file.  TYPE should be \"assembly\" if WANT_OUTPUT\n-#   is set.\n-# TYPE is the type of compilation to perform (see target_compile).\n-# CONTENTS gives the contents of the input file.\n-# The rest is optional:\n-# OPTIONS: additional compiler options to use.\n-proc get_compiler_messages {basename want_output type contents args} {\n+# BASENAME is a prefix to use for source and output files.\n+# If ARGS is not empty, its first element is a string that\n+# should be added to the command line.\n+#\n+# Assume by default that CONTENTS is C code.  C++ code should contain\n+# \"// C++\" and Fortran code should contain \"! Fortran\".\n+proc check_compile {basename type contents args} {\n     global tool\n \n     if { [llength $args] > 0 } {\n \tset options [list \"additional_flags=[lindex $args 0]\"]\n     } else {\n \tset options \"\"\n     }\n-\n-    set src ${basename}[pid].c\n+    switch -glob -- $contents {\n+\t\"*! Fortran*\" { set src ${basename}[pid].f90 }\n+\t\"*// C++*\" { set src ${basename}[pid].cc }\n+\tdefault { set src ${basename}[pid].c }\n+    }\n     switch $type {\n \tassembly { set output ${basename}[pid].s }\n \tobject { set output ${basename}[pid].o }\n+\texecutable { set output ${basename}[pid].exe }\n     }\n     set f [open $src \"w\"]\n     puts $f $contents\n     close $f\n     set lines [${tool}_target_compile $src $output $type \"$options\"]\n     file delete $src\n \n-    if { $want_output } {\n-\tif { $type != \"assembly\" } {\n-\t    error \"WANT_OUTPUT can only be used with assembly output\"\n-\t} elseif { ![string match \"\" $lines] } {\n-\t    # An error occurred.\n-\t    set result [list $lines \"\"]\n-\t} else {\n-\t    set text \"\"\n-\t    set chan [open \"$output\"]\n-\t    while {[gets $chan line] >= 0} {\n-\t\tappend text \"$line\\n\"\n-\t    }\n-\t    close $chan\n-\t    set result [list $lines $text]\n-\t}\n-    } else {\n-\tset result $lines\n-    }\n-\n-    remote_file build delete $output\n-    return $result\n+    return [list $lines $output]\n }\n \n proc current_target_name { } {\n@@ -104,23 +86,96 @@ proc check_cached_effective_target { prop args } {\n     return $value\n }\n \n-# Implement an effective-target check for property PROP by invoking\n-# the compiler and seeing if it prints any messages.  Assume that the\n-# property holds if the compiler doesn't print anything.  The other\n-# arguments are as for get_compiler_messages, starting with TYPE.\n+# Like check_compile, but delete the output file and return true if the\n+# compiler printed no messages.\n+proc check_no_compiler_messages_nocache {args} {\n+    set result [eval check_compile $args]\n+    set lines [lindex $result 0]\n+    set output [lindex $result 1]\n+    remote_file build delete $output\n+    return [string match \"\" $lines]\n+}\n+\n+# Like check_no_compiler_messages_nocache, but cache the result.\n+# PROP is the property we're checking, and doubles as a prefix for\n+# temporary filenames.\n proc check_no_compiler_messages {prop args} {\n     return [check_cached_effective_target $prop {\n-\tstring match \"\" [eval get_compiler_messages $prop 0 $args]\n+\teval [list check_no_compiler_messages_nocache $prop] $args\n     }]\n }\n \n-# Similar to check_no_compiler_messages, but also verify that the regular\n-# expression PATTERN matches the compiler's output.\n+# Like check_compile, but return true if the compiler printed no\n+# messages and if the contents of the output file satisfy PATTERN.\n+# If PATTERN has the form \"!REGEXP\", the contents satisfy it if they\n+# don't match regular expression REGEXP, otherwise they satisfy it\n+# if they do match regular expression PATTERN.  (PATTERN can start\n+# with something like \"[!]\" if the regular expression needs to match\n+# \"!\" as the first character.)\n+#\n+# Delete the output file before returning.  The other arguments are\n+# as for check_compile.\n+proc check_no_messages_and_pattern_nocache {basename pattern args} {\n+    global tool\n+\n+    set result [eval [list check_compile $basename] $args]\n+    set lines [lindex $result 0]\n+    set output [lindex $result 1]\n+\n+    set ok 0\n+    if { [string match \"\" $lines] } {\n+\tset chan [open \"$output\"]\n+\tset invert [regexp {^!(.*)} $pattern dummy pattern]\n+\tset ok [expr { [regexp $pattern [read $chan]] != $invert }]\n+\tclose $chan\n+    }\n+\n+    remote_file build delete $output\n+    return $ok\n+}\n+\n+# Like check_no_messages_and_pattern_nocache, but cache the result.\n+# PROP is the property we're checking, and doubles as a prefix for\n+# temporary filenames.\n proc check_no_messages_and_pattern {prop pattern args} {\n     return [check_cached_effective_target $prop {\n-\tset results [eval get_compiler_messages $prop 1 $args]\n-\texpr { [string match \"\" [lindex $results 0]]\n-\t       && [regexp $pattern [lindex $results 1]] }\n+\teval [list check_no_messages_and_pattern_nocache $prop $pattern] $args\n+    }]\n+}\n+\n+# Try to compile and run an executable from code CONTENTS.  Return true\n+# if the compiler reports no messages and if execution \"passes\" in the\n+# usual DejaGNU sense.  The arguments are as for check_compile, with\n+# TYPE implicitly being \"executable\".\n+proc check_runtime_nocache {basename contents args} {\n+    global tool\n+\n+    set result [eval [list check_compile $basename executable $contents] $args]\n+    set lines [lindex $result 0]\n+    set output [lindex $result 1]\n+\n+    set ok 0\n+    if { [string match \"\" $lines] } {\n+\t# No error messages, everything is OK.\n+\tset result [remote_load target \"./$output\" \"\" \"\"]\n+\tset status [lindex $result 0]\n+\tverbose \"check_runtime_nocache $basename: status is <$status>\" 2\n+\tif { $status == \"pass\" } {\n+\t    set ok 1\n+\t}\n+    }\n+    remote_file build delete $output\n+    return $ok\n+}\n+\n+# Like check_runtime_nocache, but cache the result.  PROP is the\n+# property we're checking, and doubles as a prefix for temporary\n+# filenames.\n+proc check_runtime {prop args} {\n+    global tool\n+\n+    return [check_cached_effective_target $prop {\n+\teval [list check_runtime_nocache $prop] $args\n     }]\n }\n \n@@ -414,127 +469,34 @@ proc check_effective_target_pcc_bitfield_type_matters { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_tls {} {\n-    global et_tls_saved\n-    global tool\n-\n-    if [info exists et_tls_saved] {\n-\tverbose \"check_effective_target_tls: using cached result\" 2\n-    } else {\n-\tset et_tls_saved 0\n-\n-\tset src tls[pid].c\n-\tset asm tls[pid].S\n-\tverbose \"check_effective_target_tls: compiling testfile $src\" 2\n-\tset f [open $src \"w\"]\n-\t# Compile a small test program.  Make sure that we test accesses\n-\t# as well as declarations.  \n-\tputs $f \"__thread int i;\\n\"\n-\tputs $f \"int f (void) { return i; }\\n\"\n-\tputs $f \"void g (int j) { i = j; }\\n\"\n-\tclose $f\n-\n-\t# Test for thread-local data supported by the platform.\n-\tset comp_output \\\n-\t    [${tool}_target_compile $src $asm assembly \"\"]\n-\tfile delete $src\n-\tif { [string match \"\" $comp_output] } {\n-\t    # No error messages, everything is OK.\n-\t    set et_tls_saved 1\n-\t}\n-\tremove-build-file $asm\n-    }\n-    verbose \"check_effective_target_tls: returning $et_tls_saved\" 2\n-    return $et_tls_saved\n+    return [check_no_compiler_messages tls assembly {\n+\t__thread int i;\n+\tint f (void) { return i; }\n+\tvoid g (int j) { i = j; }\n+    }]\n }\n \n # Return 1 if *native* thread local storage (TLS) is supported, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_tls_native {} {\n-    global et_tls_native_saved\n-    global tool\n-\n-    if [info exists et_tls_saved] {\n-\tverbose \"check_effective_target_tls_native: using cached result\" 2\n-    } else {\n-\tset et_tls_native_saved 0\n-\n-\tset src tls[pid].c\n-\tset asm tls[pid].S\n-\tverbose \"check_effective_target_tls_native: compiling testfile $src\" 2\n-\tset f [open $src \"w\"]\n-\t# Compile a small test program.  Make sure that we test accesses\n-\t# as well as declarations.  \n-\tputs $f \"__thread int i;\\n\"\n-\tputs $f \"int f (void) { return i; }\\n\"\n-\tputs $f \"void g (int j) { i = j; }\\n\"\n-\tclose $f\n-\n-\t# Test for thread-local data supported by the platform.\n-\tset comp_output [${tool}_target_compile $src $asm assembly \"\"]\n-\tfile delete $src\n-\tif { [string match \"\" $comp_output] } {\n-\t    # No error messages, everything is OK.\n-\t    set fd [open $asm r]\n-\t    set text [read $fd]\n-\t    close $fd\n-\t    if { [string match \"*emutls*\" $text]} {\n-\t\tset et_tls_native_saved 0\n-\t    } else {\n-\t\tset et_tls_native_saved 1\n-\t    }\n-\t}\n-\tremove-build-file $asm\n-    }\n-    verbose \"check_effective_target_tls_native: returning $et_tls_native_saved\" 2\n-    return $et_tls_native_saved\n+    return [check_no_messages_and_pattern tls_native \"!emultls\" assembly {\n+\t__thread int i;\n+\tint f (void) { return i; }\n+\tvoid g (int j) { i = j; }\n+    }]\n }\n \n # Return 1 if TLS executables can run correctly, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_tls_runtime {} {\n-    global et_tls_runtime_saved\n-    global tool\n-\n-    if [info exists et_tls_runtime_saved] {\n-\tverbose \"check_effective_target_tls_runtime: using cached result\" 2\n-    } else {\n-\tset et_tls_runtime_saved 0\n-\n-\tset src tls_runtime[pid].c\n-\tset exe tls_runtime[pid].x\n-\tverbose \"check_effective_target_tls_runtime: compiling testfile $src\" 2\n-\tset f [open $src \"w\"]\n-\t# Compile a small test program.\n-\tputs $f \"__thread int thr = 0;\\n\"\n-\tputs $f \"int main(void)\\n {\\n return thr;\\n}\"\n-\tclose $f\n-\n-\tset comp_output \\\n-\t    [${tool}_target_compile $src $exe executable \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $comp_output] then {\n-\t    # No error messages, everything is OK.\n-\n-\t    set result [remote_load target \"./$exe\" \"\" \"\"]\n-\t    set status [lindex $result 0]\n-\t    remote_file build delete $exe\n-\n-\t    verbose \"check_effective_target_tls_runtime status is <$status>\" 2\n-\n-\t    if { $status == \"pass\" } {\n-\t\tset et_tls_runtime_saved 1\n-\t    }\n-\n-\t    verbose \"check_effective_target_tls_runtime: returning $et_tls_runtime_saved\" 2\n-\t}\n-    }\n-\n-    return $et_tls_runtime_saved\n+    return [check_runtime tls_runtime {\n+\t__thread int thr = 0;\n+\tint main (void) { return thr; }\n+    }]\n }\n \n # Return 1 if compilation with -fopenmp is error-free for trivial\n@@ -548,35 +510,9 @@ proc check_effective_target_fopenmp {} {\n \n # Return 1 if the target supports -fstack-protector\n proc check_effective_target_fstack_protector {} {\n-    global tool\n-    set result \"\"\n-\n-    set src stack_prot[pid].c\n-    set exe stack_prot[pid].x\n-\n-    verbose \"check_effective_target_fstack_protector compiling testfile $src\" 2\n-\n-    set f [open $src \"w\"]\n-    # Compile a small test program.\n-    puts $f \"int main (void)\\n { return 0; }\\n\"\n-    close $f\n-\n-    set opts \"additional_flags=-fstack-protector\"\n-    set lines [${tool}_target_compile $src $exe executable \"$opts\" ]\n-    file delete $src\n-\n-    if [string match \"\" $lines] then {\n-        # No error messages, everything is OK.\n-        set result [${tool}_load \"./$exe\" \"\" \"\"]\n-        set status [lindex $result 0]\n-        remote_file build delete $exe\n-        verbose \"check_iconv_available status is <$status>\" 2\n-\n-        if { $status == \"pass\" } then {\n-            return 1\n-        }\n-    }\n-    return 0\n+    return [check_runtime fstack_protector {\n+\tint main (void) { return 0; }\n+    } \"-fstack-protector\"]\n }\n \n # Return 1 if compilation with -freorder-blocks-and-partition is error-free\n@@ -699,45 +635,25 @@ proc check_effective_target_unwrapped { } {\n # Return true if iconv is supported on the target. In particular IBM1047.\n \n proc check_iconv_available { test_what } {\n-    global tool\n     global libiconv\n \n-    set result \"\"\n-\n-    set src iconv[pid].c\n-    set exe iconv[pid].x\n-    verbose \"check_iconv_available compiling testfile $src\" 2\n-    set f [open $src \"w\"]\n-    # Compile a small test program.\n-    puts $f \"#include <iconv.h>\\n\"\n-    puts $f \"int main (void)\\n {\\n iconv_t cd; \\n\"\n-    puts $f \"cd = iconv_open (\\\"[lindex $test_what 1]\\\", \\\"UTF-8\\\");\\n\"\n-    puts $f \"if (cd == (iconv_t) -1)\\n return 1;\\n\"\n-    puts $f \"return 0;\\n}\"\n-    close $f\n-\n     # If the tool configuration file has not set libiconv, try \"-liconv\"\n     if { ![info exists libiconv] } {\n \tset libiconv \"-liconv\"\n     }\n-    set lines [${tool}_target_compile $src $exe executable \"libs=$libiconv\" ]\n-    file delete $src\n-\n-    if [string match \"\" $lines] then {\n-\t# No error messages, everything is OK.\n-\n-\tset result [${tool}_load \"./$exe\" \"\" \"\"]\n-\tset status [lindex $result 0]\n-\tremote_file build delete $exe\n-\n-\tverbose \"check_iconv_available status is <$status>\" 2\n-\n-\tif { $status == \"pass\" } then {\n-\t    return 1\n+    set test_what [lindex $test_what 1]\n+    return [check_runtime_nocache $test_what [subst {\n+\t#include <iconv.h>\n+\tint main (void)\n+\t{\n+\t  iconv_t cd;\n+\n+\t  cd = iconv_open (\"$test_what\", \"UTF-8\");\n+\t  if (cd == (iconv_t) -1)\n+\t    return 1;\n+\t  return 0;\n \t}\n-    }\n-\n-    return 0\n+    }] $libiconv]\n }\n \n # Return true if named sections are supported on this target.\n@@ -754,56 +670,13 @@ proc check_named_sections_available { } {\n # When the target name changes, replace the cached result.\n \n proc check_effective_target_fortran_large_real { } {\n-    global et_fortran_large_real_saved\n-    global et_fortran_large_real_target_name\n-    global tool\n-\n-    if { ![info exists et_fortran_large_real_target_name] } {\n-\tset et_fortran_large_real_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_fortran_large_real_target_name } {\n-\tverbose \"check_effective_target_fortran_large_real: `$et_fortran_large_real_target_name' `$current_target'\" 2\n-\tset et_fortran_large_real_target_name $current_target\n-\tif [info exists et_fortran_large_real_saved] {\n-\t    verbose \"check_effective_target_fortran_large_real: removing cached result\" 2\n-\t    unset et_fortran_large_real_saved\n-\t}\n-    }\n-\n-    if [info exists et_fortran_large_real_saved] {\n-\tverbose \"check_effective_target_fortran_large_real returning saved $et_fortran_large_real_saved\" 2\n-    } else {\n-\tset et_fortran_large_real_saved 0\n-\n-\t# Set up, compile, and execute a test program using large real\n-\t# kinds.  Include the current process ID in the file names to\n-\t# prevent conflicts with invocations for multiple testsuites.\n-\tset src real[pid].f90\n-        set exe real[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"integer,parameter :: k = &\"\n-        puts $f \"  selected_real_kind (precision (0.0_8) + 1)\"\n-        puts $f \"real(kind=k) :: x\"\n-        puts $f \"x = cos (x);\"\n-\tputs $f \"end\"\n-\tclose $f\n-\n-\tverbose \"check_effective_target_fortran_large_real compiling testfile $src\" 2\n-\tset lines [${tool}_target_compile $src $exe executable \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] then {\n-\t    # No error message, compilation succeeded.\n-\t    remote_file build delete $exe\n-  \t    set et_fortran_large_real_saved 1\n-\t}\n-    }\n-\n-    return $et_fortran_large_real_saved\n+    return [check_no_compiler_messages fortran_large_real executable {\n+\t! Fortran\n+\tinteger,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+\treal(kind=k) :: x\n+\tx = cos (x)\n+\tend\n+    }]\n }\n \n # Return 1 if the target supports Fortran integer kinds larger than\n@@ -812,233 +685,80 @@ proc check_effective_target_fortran_large_real { } {\n # When the target name changes, replace the cached result.\n \n proc check_effective_target_fortran_large_int { } {\n-    global et_fortran_large_int_saved\n-    global et_fortran_large_int_target_name\n-    global tool\n-\n-    if { ![info exists et_fortran_large_int_target_name] } {\n-\tset et_fortran_large_int_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_fortran_large_int_target_name } {\n-\tverbose \"check_effective_target_fortran_large_int: `$et_fortran_large_int_target_name' `$current_target'\" 2\n-\tset et_fortran_large_int_target_name $current_target\n-\tif [info exists et_fortran_large_int_saved] {\n-\t    verbose \"check_effective_target_fortran_large_int: removing cached result\" 2\n-\t    unset et_fortran_large_int_saved\n-\t}\n-    }\n-\n-    if [info exists et_fortran_large_int_saved] {\n-\tverbose \"check_effective_target_fortran_large_int returning saved $et_fortran_large_int_saved\" 2\n-    } else {\n-\tset et_fortran_large_int_saved 0\n-\n-\t# Set up, compile, and execute a test program using large integer\n-\t# kinds.  Include the current process ID in the file names to\n-\t# prevent conflicts with invocations for multiple testsuites.\n-\tset src int[pid].f90\n-        set exe int[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"integer,parameter :: k = &\"\n-        puts $f \"  selected_int_kind (range (0_8) + 1)\"\n-        puts $f \"integer(kind=k) :: i\"\n-\tputs $f \"end\"\n-\tclose $f\n-\n-\tverbose \"check_effective_target_fortran_large_int compiling testfile $src\" 2\n-\tset lines [${tool}_target_compile $src $exe executable \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] then {\n-\t    # No error message, compilation succeeded.\n-\t    remote_file build delete $exe\n-\t    set et_fortran_large_int_saved 1\n-\t}\n-    }\n-\n-    return $et_fortran_large_int_saved\n+    return [check_no_compiler_messages fortran_large_int executable {\n+\t! Fortran\n+\tinteger,parameter :: k = selected_int_kind (range (0_8) + 1)\n+\tinteger(kind=k) :: i\n+\tend\n+    }]\n }\n \n # Return 1 if we can statically link libgfortran, 0 otherwise.\n #\n # When the target name changes, replace the cached result.\n \n proc check_effective_target_static_libgfortran { } {\n-    global et_static_libgfortran\n-    global et_static_libgfortran_target_name\n-    global tool\n-\n-    if { ![info exists et_static_libgfortran_target_name] } {\n-       set et_static_libgfortran_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_static_libgfortran_target_name } {\n-       verbose \"check_effective_target_static_libgfortran: `$et_static_libgfortran_target_name' `$current_target'\" 2\n-       set et_static_libgfortran_target_name $current_target\n-       if [info exists et_static_libgfortran_saved] {\n-           verbose \"check_effective_target_static_libgfortran: removing cached result\" 2\n-           unset et_static_libgfortran_saved\n-       }\n-    }\n-\n-    if [info exists et_static_libgfortran_saved] {\n-       verbose \"check_effective_target_static_libgfortran returning saved $et_static_libgfortran_saved\" 2\n-    } else {\n-       set et_static_libgfortran_saved 0\n-\n-       # Set up, compile, and execute a test program using static linking.\n-       # Include the current process ID in the file names to prevent\n-       # conflicts with invocations for multiple testsuites.\n-       set opts \"additional_flags=-static\"\n-       set src static[pid].f\n-       set exe static[pid].x\n-\n-       set f [open $src \"w\"]\n-       puts $f \"      print *, 'test'\"\n-       puts $f \"      end\"\n-       close $f\n-\n-       verbose \"check_effective_target_static_libgfortran compiling testfile $src\" 2\n-       set lines [${tool}_target_compile $src $exe executable \"$opts\"]\n-       file delete $src\n-\n-       if [string match \"\" $lines] then {\n-           # No error message, compilation succeeded.\n-\t   remote_file build delete $exe\n-           set et_static_libgfortran_saved 1\n-       }\n-    }\n-\n-    return $et_static_libgfortran_saved\n+    return [check_no_compiler_messages static_libgfortran executable {\n+\t! Fortran\n+\tprint *, 'test'\n+\tend\n+    } \"-static\"]\n }\n \n # Return 1 if the target supports executing 750CL paired-single instructions, 0\n # otherwise.  Cache the result.\n \n proc check_750cl_hw_available { } {\n-    global 750cl_hw_available_saved\n-    global tool\n-\n-    if [info exists 750cl_hw_available_saved] {\n-        verbose \"check_hw_available  returning saved $750cl_hw_available_saved\" 2\n-    } else {\n-        set 750cl_hw_available_saved 0\n-\n-        # If this is not the right target then we can quit.\n-        if { ![istarget powerpc-*paired*] } {\n-            verbose \"check_hw_available  returning 0\" 2\n-            return $750cl_hw_available_saved\n-        }\n-\n-        # Set up, compile, and execute a test program containing paired-single\n-        # instructions.  Include the current process ID in the file\n-        # names to prevent conflicts with invocations for multiple\n-        # testsuites.\n-        set src 750cl[pid].c\n-        set exe 750cl[pid].x\n-\n-        set f [open $src \"w\"]\n-        puts $f \"int main() {\"\n-        puts $f \"#ifdef __MACH__\"\n-        puts $f \"  asm volatile (\\\"ps_mul v0,v0,v0\\\");\"\n-        puts $f \"#else\"\n-        puts $f \"  asm volatile (\\\"ps_mul 0,0,0\\\");\"\n-        puts $f \"#endif\"\n-        puts $f \"  return 0; }\"\n-        close $f\n-\n-        verbose \"check_750cl_hw_available  compiling testfile $src\" 2\n-        set lines [${tool}_target_compile $src $exe executable \"-mpaired\"]\n-        file delete $src\n-\n-        if [string match \"\" $lines] then {\n-            # No error message, compilation succeeded.\n-            set result [${tool}_load \"./$exe\" \"\" \"\"]\n-            set status [lindex $result 0]\n-            remote_file build delete $exe\n-            verbose \"check_750cl_hw_available testfile status is <$status>\" 2\n-\n-            if { $status == \"pass\" } then {\n-                set 750cl_hw_available_saved 1\n-            }\n-        } else {\n-            verbose \"check_750cl_hw_availalble testfile compilation failed\" 2\n-        }\n-    }\n-    return $750cl_hw_available_saved\n+    return [check_cached_effective_target 750cl_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { ![istarget powerpc-*paired*] } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache 750cl_hw_available {\n+\t\t int main()\n+\t\t {\n+\t\t #ifdef __MACH__\n+\t\t   asm volatile (\"ps_mul v0,v0,v0\");\n+\t\t #else\n+\t\t   asm volatile (\"ps_mul 0,0,0\");\n+\t\t #endif\n+\t\t   return 0;\n+\t\t }\n+\t    } \"-mpaired\"\n+\t}\n+    }]\n }\n \n-\n # Return 1 if the target supports executing AltiVec instructions, 0\n # otherwise.  Cache the result.\n \n proc check_vmx_hw_available { } {\n-    global vmx_hw_available_saved\n-    global tool\n-\n-    if [info exists vmx_hw_available_saved] {\n-\tverbose \"check_hw_available  returning saved $vmx_hw_available_saved\" 2\n-    } else {\n-\tset vmx_hw_available_saved 0\n-\n+    return [check_cached_effective_target vmx_hw_available {\n \t# Some simulators are known to not support VMX instructions.\n \tif { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] } {\n-\t    verbose \"check_hw_available  returning 0\" 2\n-\t    return $vmx_hw_available_saved\n-\t}\n-\n-\t# Set up, compile, and execute a test program containing VMX\n-\t# instructions.  Include the current process ID in the file\n-\t# names to prevent conflicts with invocations for multiple\n-\t# testsuites.\n-\tset src vmx[pid].c\n-\tset exe vmx[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"int main() {\"\n-\tputs $f \"#ifdef __MACH__\"\n-\tputs $f \"  asm volatile (\\\"vor v0,v0,v0\\\");\"\n-\tputs $f \"#else\"\n-\tputs $f \"  asm volatile (\\\"vor 0,0,0\\\");\"\n-\tputs $f \"#endif\"\n-\tputs $f \"  return 0; }\"\n-\tclose $f\n-\n-\t# Most targets don't require special flags for this test case, but\n-\t# Darwin does.\n-\tif { [istarget *-*-darwin*] \n-\t     || [istarget *-*-aix*] } {\n-\t  set opts \"additional_flags=-maltivec\"\n+\t    expr 0\n \t} else {\n-\t  set opts \"\"\n-\t}\n-\n-\tverbose \"check_vmx_hw_available  compiling testfile $src\" 2\n-\tset lines [${tool}_target_compile $src $exe executable \"$opts\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] then {\n-\t    # No error message, compilation succeeded.\n-\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n-\t    set status [lindex $result 0]\n-\t    remote_file build delete $exe\n-\t    verbose \"check_vmx_hw_available testfile status is <$status>\" 2\n-\n-\t    if { $status == \"pass\" } then {\n-\t\tset vmx_hw_available_saved 1\n+\t    # Most targets don't require special flags for this test case, but\n+\t    # Darwin does.\n+\t    if { [istarget *-*-darwin*]\n+\t\t || [istarget *-*-aix*] } {\n+\t\tset options \"-maltivec\"\n+\t    } else {\n+\t\tset options \"\"\n \t    }\n-\t} else {\n-\t    verbose \"check_vmx_hw_availalble testfile compilation failed\" 2\n+\t    check_runtime_nocache vmx_hw_available {\n+\t\tint main()\n+\t\t{\n+\t\t#ifdef __MACH__\n+\t\t  asm volatile (\"vor v0,v0,v0\");\n+\t\t#else\n+\t\t  asm volatile (\"vor 0,0,0\");\n+\t        #endif\n+\t\t  return 0;\n+\t\t}\n+\t    } $options\n \t}\n-    }\n-\n-    return $vmx_hw_available_saved\n+    }]\n }\n \n # GCC 3.4.0 for powerpc64-*-linux* included an ABI fix for passing\n@@ -1049,159 +769,52 @@ proc check_vmx_hw_available { } {\n # When the target name changes, replace the cached result.\n \n proc check_effective_target_broken_cplxf_arg { } {\n-    global et_broken_cplxf_arg_saved\n-    global et_broken_cplxf_arg_target_name\n-    global tool\n-\n-    # Skip the work for targets known not to be affected.\n-    if { ![istarget powerpc64-*-linux*] } {\n-\treturn 0\n-    } elseif { [is-effective-target ilp32] } {\n-\treturn 0\n-    }\n-\n-    if { ![info exists et_broken_cplxf_arg_target_name] } {\n-\tset et_broken_cplxf_arg_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_broken_cplxf_arg_target_name } {\n-\tverbose \"check_effective_target_broken_cplxf_arg: `$et_broken_cplxf_arg_target_name'\" 2\n-\tset et_broken_cplxf_arg_target_name $current_target\n-\tif [info exists et_broken_cplxf_arg_saved] {\n-\t    verbose \"check_effective_target_broken_cplxf_arg: removing cached result\" 2\n-\t    unset et_broken_cplxf_arg_saved\n-\t}\n-    }\n-\n-    if [info exists et_broken_cplxf_arg_saved] {\n-\tverbose \"check_effective_target_broken_cplxf_arg: using cached result\" 2\n-    } else {\n-\tset et_broken_cplxf_arg_saved 0\n-\t# This is only known to affect one target.\n-\tif { ![istarget powerpc64-*-linux*] || ![is-effective-target lp64] } {\n-\t    set et_broken_cplxf_arg_saved 0\n-\t    verbose \"check_effective_target_broken_cplxf_arg: caching 0\" 2\n-\t    return $et_broken_cplxf_arg_saved\n-\t}\n-\n-\t# Set up, compile, and execute a C test program that calls cabsf.\n-\tset src cabsf[pid].c\n-\tset exe cabsf[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <complex.h>\"\n-\tputs $f \"extern void abort (void);\"\n-\tputs $f \"float fabsf (float);\"\n-\tputs $f \"float cabsf (_Complex float);\"\n-\tputs $f \"int main ()\"\n-\tputs $f \"{\"\n-\tputs $f \"  _Complex float cf;\"\n-\tputs $f \"  float f;\"\n-\tputs $f \"  cf = 3 + 4.0fi;\"\n-\tputs $f \"  f = cabsf (cf);\"\n-\tputs $f \"  if (fabsf (f - 5.0) > 0.0001) abort ();\"\n-\tputs $f \"  return 0;\"\n-\tputs $f \"}\"\n-\tclose $f\n-\n-\tset lines [${tool}_target_compile $src $exe executable \"-lm\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, compilation succeeded.\n-\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n-\t    set status [lindex $result 0]\n-\t    remote_file build delete $exe\n-\n-\t    verbose \"check_effective_target_broken_cplxf_arg: status is <$status>\" 2\n-\n-\t    if { $status != \"pass\" } {\n-\t\tset et_broken_cplxf_arg_saved 1\n-\t    }\n+    return [check_cached_effective_target broken_cplxf_arg {\n+\t# Skip the work for targets known not to be affected.\n+\tif { ![istarget powerpc64-*-linux*] } {\n+\t    expr 0\n+\t} elseif { ![is-effective-target lp64] } {\n+\t    expr 0\n \t} else {\n-\t    verbose \"check_effective_target_broken_cplxf_arg: compilation failed\" 2\n+\t    check_runtime_nocache broken_cplxf_arg {\n+\t\t#include <complex.h>\n+\t\textern void abort (void);\n+\t\tfloat fabsf (float);\n+\t\tfloat cabsf (_Complex float);\n+\t\tint main ()\n+\t\t{\n+\t\t  _Complex float cf;\n+\t\t  float f;\n+\t\t  cf = 3 + 4.0fi;\n+\t\t  f = cabsf (cf);\n+\t\t  if (fabsf (f - 5.0) > 0.0001)\n+\t\t    abort ();\n+\t\t  return 0;\n+\t\t}\n+\t    } \"-lm\"\n \t}\n-    }\n-    return $et_broken_cplxf_arg_saved\n+    }]\n }\n \n proc check_alpha_max_hw_available { } {\n-    global alpha_max_hw_available_saved\n-    global tool\n-\n-    if [info exists alpha_max_hw_available_saved] {\n-\tverbose \"check_alpha_max_hw_available returning saved $alpha_max_hw_available_saved\" 2\n-    } else {\n-\tset alpha_max_hw_available_saved 0\n-\n-\t# Set up, compile, and execute a test program probing bit 8 of the\n-\t# architecture mask, which indicates presence of MAX instructions.\n-\tset src max[pid].c\n-\tset exe max[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"int main() { return __builtin_alpha_amask(1<<8) != 0; }\"\n-\tclose $f\n-\n-\tverbose \"check_alpha_max_hw_available compiling testfile $src\" 2\n-\tset lines [${tool}_target_compile $src $exe executable \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] then {\n-\t    # No error message, compilation succeeded.\n-\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n-\t    set status [lindex $result 0]\n-\t    remote_file build delete $exe\n-\t    verbose \"check_alpha_max_hw_available testfile status is <$status>\" 2\n-\n-\t    if { $status == \"pass\" } then {\n-\t\tset alpha_max_hw_available_saved 1\n-\t    }\n-\t} else {\n-\t    verbose \"check_alpha_max_hw_availalble testfile compilation failed\" 2\n-\t}\n-    }\n-\n-    return $alpha_max_hw_available_saved\n+    return [check_runtime alpha_max_hw_available {\n+\tint main() { return __builtin_alpha_amask(1<<8) != 0; }\n+    }]\n }\n \n # Returns true iff the FUNCTION is available on the target system.\n # (This is essentially a Tcl implementation of Autoconf's\n # AC_CHECK_FUNC.)\n \n proc check_function_available { function } {\n-    set var \"${function}_available_saved\"\n-    global $var\n-    global tool\n-\n-    if {![info exists $var]} {\n-\t# Assume it exists.\n-\tset $var 1\n-\t# Check to make sure.\n-\tset src \"function[pid].c\"\n-\tset exe \"function[pid].exe\"\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#ifdef __cplusplus\\nextern \\\"C\\\"\\n#endif\\n\"\n-\tputs $f \"char $function ();\\n\"\n-\tputs $f \"int main () { $function (); }\"\n-\tclose $f\n-\n-\tset lines [${tool}_target_compile $src $exe executable \"\"]\n-\tfile delete $src\n-\tfile delete $exe\n-\n-\tif {![string match \"\" $lines]} then {\n-\t    set $var 0\n-\t    verbose -log \"$function is not available\"\n-\t} else {\n-\t    verbose -log \"$function is available\"\n-\t}\n-    }\n-\n-    eval return \\$$var\n+    return [check_no_compiler_messages ${function}_available \\\n+\t\texecutable [subst {\n+\t#ifdef __cplusplus\n+\textern \"C\"\n+\t#endif\n+\tchar $function ();\n+\tint main () { $function (); }\n+    }]]\n }\n \n # Returns true iff \"fork\" is available on the target system.\n@@ -1224,90 +837,44 @@ proc check_mkfifo_available {} {\n # Returns true iff \"__cxa_atexit\" is used on the target system.\n \n proc check_cxa_atexit_available { } {\n-    global et_cxa_atexit\n-    global et_cxa_atexit_target_name\n-    global tool\t\n-\n-    if { ![info exists et_cxa_atexit_target_name] } {\n-\tset et_cxa_atexit_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_cxa_atexit_target_name } {\n-\tverbose \"check_cxa_atexit_available: `$et_cxa_atexit_target_name'\" 2\n-\tset et_cxa_atexit_target_name $current_target\n-\tif [info exists et_cxa_atexit] {\n-\t    verbose \"check_cxa_atexit_available: removing cached result\" 2\n-\t    unset et_cxa_atexit\n-\t}\n-    }\n-\n-    if [info exists et_cxa_atexit] {\n-\tverbose \"check_cxa_atexit_available: using cached result\" 2\n-    } elseif { [istarget \"hppa*-*-hpux10*\"] } {\n-\t# HP-UX 10 doesn't have __cxa_atexit but subsequent test passes.\n-\tset et_cxa_atexit 0\n-    } else {\n-\tset et_cxa_atexit 0\n-\n-\t# Set up, compile, and execute a C++ test program that depends\n-\t# on correct ordering of static object destructors. This is\n-\t# indicative of the presence and use of __cxa_atexit.\n-\tset src cxaatexit[pid].cc\n-\tset exe cxaatexit[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <stdlib.h>\"\n-\tputs $f \"static unsigned int count;\"\n-\tputs $f \"struct X\"\n-\tputs $f \"{\"\n-\tputs $f \"  X() { count = 1; }\"\n-\tputs $f \"  ~X()\"\n-\tputs $f \"  {\"\n-\tputs $f \"    if (count != 3)\"\n-\tputs $f \"      exit(1);\"\n-\tputs $f \"    count = 4;\"\n-        puts $f \"  }\"\n-        puts $f \"};\"\n-\tputs $f \"void f()\"\n-\tputs $f \"{\"\n-\tputs $f \"  static X x;\"\n-        puts $f \"}\"\n-\tputs $f \"struct Y\"\n-\tputs $f \"{\"\n-\tputs $f \"  Y() { f(); count = 2; }\"\n-\tputs $f \"  ~Y()\"\n-\tputs $f \"  {\"\n-\tputs $f \"    if (count != 2)\"\n-\tputs $f \"      exit(1);\"\n-\tputs $f \"    count = 3;\"\n-        puts $f \"  }\"\n-        puts $f \"};\"\n-\tputs $f \"Y y;\"\n-\tputs $f \"int main()\"\n-\tputs $f \"{ return 0; }\"\n-\tclose $f\n-\n-\tset lines [${tool}_target_compile $src $exe executable \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, compilation succeeded.\n-\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n-\t    set status [lindex $result 0]\n-\t    remote_file build delete $exe\n-\n-\t    verbose \"check_cxa_atexit_available: status is <$status>\" 2\n-\n-\t    if { $status == \"pass\" } {\n-\t\tset et_cxa_atexit 1\n-\t    }\n+    return [check_cached_effective_target cxa_atexit_available {\n+\tif { [istarget \"hppa*-*-hpux10*\"] } {\n+\t    # HP-UX 10 doesn't have __cxa_atexit but subsequent test passes.\n+\t    expr 0\n \t} else {\n-\t    verbose \"check_cxa_atexit_available: compilation failed\" 2\n+\t    check_runtime_nocache cxa_atexit_available {\n+\t\t// C++\n+\t\t#include <stdlib.h>\n+\t\tstatic unsigned int count;\n+\t\tstruct X\n+\t\t{\n+\t\t  X() { count = 1; }\n+\t\t  ~X()\n+\t\t  {\n+\t\t    if (count != 3)\n+\t\t      exit(1);\n+\t\t    count = 4;\n+\t\t  }\n+\t\t};\n+\t\tvoid f()\n+\t\t{\n+\t\t  static X x;\n+\t\t}\n+\t\tstruct Y\n+\t\t{\n+\t\t  Y() { f(); count = 2; }\n+\t\t  ~Y()\n+\t\t  {\n+\t\t    if (count != 2)\n+\t\t      exit(1);\n+\t\t    count = 3;\n+\t\t  }\n+\t\t};\n+\t\tY y;\n+\t\tint main() { return 0; }\n+\t    }\n \t}\n-    }\n-    return $et_cxa_atexit\n+    }]\n }\n \n \n@@ -1392,45 +959,18 @@ proc check_effective_target_fixed_point { } {\n \n proc check_effective_target_dfp_nocache { } {\n     verbose \"check_effective_target_dfp_nocache: compiling source\" 2\n-    set ret [string match \"\" [get_compiler_messages dfp 0 object {\n+    set ret [check_no_compiler_messages_nocache dfp object {\n         _Decimal32 x; _Decimal64 y; _Decimal128 z;\n-    }]]\n+    }]\n     verbose \"check_effective_target_dfp_nocache: returning $ret\" 2\n     return $ret\n }\n \n proc check_effective_target_dfprt_nocache { } {\n-    global tool\n-\n-    set ret 0\n-\n-    verbose \"check_effective_target_dfprt_nocache: compiling source\" 2\n-    # Set up, compile, and execute a test program containing decimal\n-    # float operations.\n-    set src dfprt[pid].c\n-    set exe dfprt[pid].x\n-\n-    set f [open $src \"w\"]\n-    puts $f \"_Decimal32 x = 1.2df; _Decimal64 y = 2.3dd; _Decimal128 z;\"\n-    puts $f \"int main () { z = x + y; return 0; }\"\n-    close $f\n-\n-    verbose \"check_effective_target_dfprt_nocache: compiling testfile $src\" 2\n-    set lines [${tool}_target_compile $src $exe executable \"\"]\n-    file delete $src\n-\n-    if [string match \"\" $lines] then {\n-\t# No error message, compilation succeeded.\n-\tset result [${tool}_load \"./$exe\" \"\" \"\"]\n-\tset status [lindex $result 0]\n-\tremote_file build delete $exe\n-\tverbose \"check_effective_target_dfprt_nocache: testfile status is <$status>\" 2\n-\tif { $status == \"pass\" } then {\n-\t    set ret 1\n-\t}\n-    }\n-    return $ret\n-    verbose \"check_effective_target_dfprt_nocache: returning $ret\" 2\n+    return [check_runtime_nocache dfprt {\n+\t_Decimal32 x = 1.2df; _Decimal64 y = 2.3dd; _Decimal128 z;\n+\tint main () { z = x + y; return 0; }\n+    }]\n }\n \n # Return 1 if the target supports compiling Decimal Floating Point,\n@@ -1439,15 +979,9 @@ proc check_effective_target_dfprt_nocache { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_dfp { } {\n-    global et_dfp_saved\n-\n-    if [info exists et_dfp_saved] {\n-\tverbose \"check_effective_target_dfp: using cached result\" 2\n-    } else {\n-\tset et_dfp_saved [check_effective_target_dfp_nocache]\n-    }\n-    verbose \"check_effective_target_dfp: returning $et_dfp_saved\" 2\n-    return $et_dfp_saved\n+    return [check_cached_effective_target dfp {\n+\tcheck_effective_target_dfp_nocache\n+    }]\n }\n \n # Return 1 if the target supports linking and executing Decimal Floating\n@@ -1456,16 +990,9 @@ proc check_effective_target_dfp { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_dfprt { } {\n-    global et_dfprt_saved\n-    global tool\n-\n-    if [info exists et_dfprt_saved] {\n-\tverbose \"check_effective_target_dfprt: using cached result\" 2\n-    } else {\n-\tset et_dfprt_saved [check_effective_target_dfprt_nocache]\n-    }\n-    verbose \"check_effective_target_dfprt: returning $et_dfprt_saved\" 2\n-    return $et_dfprt_saved\n+    return [check_cached_effective_target dfprt {\n+\tcheck_effective_target_dfprt_nocache\n+    }]\n }\n \n # Return 1 if the target needs a command line argument to enable a SIMD\n@@ -1619,54 +1146,17 @@ proc check_effective_target_arm_neon_ok { } {\n # otherwise.  Cache the result.\n \n proc check_effective_target_arm_neon_hw { } {\n-    global arm_neon_hw_available_saved\n-    global tool\n-\n-    if [info exists arm_neon_hw_available_saved] {\n-        verbose \"check_arm_neon_hw_available  returning saved $arm_neon_hw_avail\n-able_saved\" 2\n-    } else {\n-        set arm_neon_hw_available_saved 0\n-\n-        # Set up, compile, and execute a test program containing NEON\n-        # instructions.  Include the current process ID in the file\n-        # names to prevent conflicts with invocations for multiple\n-        # testsuites.\n-        set src neon[pid].c\n-        set exe neon[pid].x\n-\n-        set f [open $src \"w\"]\n-        puts $f \"int main() {\"\n-        puts $f \"  long long a = 0, b = 1;\"\n-        puts $f \"  asm (\\\"vorr %P0, %P1, %P2\\\"\"\n-        puts $f \"       : \\\"=w\\\" (a)\"\n-        puts $f \"       : \\\"0\\\" (a), \\\"w\\\" (b));\"\n-        puts $f \"  return (a != 1);\"\n-        puts $f \"}\"\n-        close $f\n-\n-        set opts \"additional_flags=-mfpu=neon additional_flags=-mfloat-abi=softfp\"\n-\n-        verbose \"check_arm_neon_hw_available  compiling testfile $src\" 2\n-        set lines [${tool}_target_compile $src $exe executable \"$opts\"]\n-        file delete $src\n-\n-        if [string match \"\" $lines] then {\n-            # No error message, compilation succeeded.\n-            set result [${tool}_load \"./$exe\" \"\" \"\"]\n-            set status [lindex $result 0]\n-            remote_file build delete $exe\n-            verbose \"check_arm_neon_hw_available testfile status is <$status>\" 2\n-\n-            if { $status == \"pass\" } then {\n-                set arm_neon_hw_available_saved 1\n-            }\n-        } else {\n-            verbose \"check_arm_neon_hw_available testfile compilation failed\" 2\n-        }\n-    }\n-\n-    return $arm_neon_hw_available_saved\n+    return [check_runtime arm_neon_hw_available {\n+\tint\n+\tmain (void)\n+\t{\n+\t  long long a = 0, b = 1;\n+\t  asm (\"vorr %P0, %P1, %P2\"\n+\t       : \"=w\" (a)\n+\t       : \"0\" (a), \"w\" (b));\n+\t  return (a != 1);\n+\t}\n+    } \"-mfpu=neon -mfloat-abi=softfp\"]\n }\n \n # Return 1 if this is a PowerPC target with floating-point registers.\n@@ -1743,44 +1233,9 @@ proc check_effective_target_powerpc_altivec { } {\n # test environment appears to run executables on such a simulator.\n \n proc check_effective_target_ultrasparc_hw { } {\n-    global et_ultrasparc_hw_saved\n-    global tool\n-\n-    if [info exists et_ultrasparc_hw_saved] {\n-\tverbose \"check_ultrasparc_hw_available returning saved $et_ultrasparc_hw_saved\" 2\n-    } else {\n-\tset et_ultrasparc_hw_saved 0\n-\n-\t# Set up, compile, and execute a simple test program.  The\n-\t# program will be compiled with -mcpu=ultrasparc to instruct the\n-\t# assembler to produce EM_SPARC32PLUS executables.\n-\tset src svect[pid].c\n-\tset exe svect[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"int main() { return 0; }\"\n-\tclose $f\n-\n-\tverbose \"check_ultrasparc_hw_available compiling testfile $src\" 2\n-\tset lines [${tool}_target_compile $src $exe executable \"additional_flags=-mcpu=ultrasparc\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] then {\n-\t    # No error message, compilation succeeded.\n-\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n-\t    set status [lindex $result 0]\n-\t    remote_file build delete $exe\n-\t    verbose \"check_ultrasparc_hw_available testfile status is <$status>\" 2\n-\n-\t    if { $status == \"pass\" } then {\n-\t\tset et_ultrasparc_hw_saved 1\n-\t    }\n-\t} else {\n-\t    verbose \"check_ultrasparc_hw_available testfile compilation failed\" 2\n-\t}\n-    }\n-\n-    return $et_ultrasparc_hw_saved\n+    return [check_runtime ultrasparc_hw {\n+\tint main() { return 0; }\n+    } \"-mcpu=ultrasparc\"]\n }\n \n # Return 1 if the target supports hardware vector shift operation.\n@@ -2747,7 +2202,7 @@ proc check_effective_target_c99_runtime { } {\n \t    #error FOO\n \t    #endif\n \t}\n-\tstring match \"\" [get_compiler_messages c99_runtime 0 assembly \\\n-\t\t\t     $contents [add_options_for_c99_runtime \"\"]]\n+\tcheck_no_compiler_messages_nocache c99_runtime assembly \\\n+\t    $contents [add_options_for_c99_runtime \"\"]\n     }]\n }"}]}