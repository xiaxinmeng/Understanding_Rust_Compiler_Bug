{"sha": "2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5ZjZjZWYxY2RjMTQ5YTA1NzU0ODM5Y2EyN2FmMDAxYzhkM2QxZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2005-09-12T04:49:11Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2005-09-12T04:49:11Z"}, "message": "[multiple changes]\n\n\n2005-09-11  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/19265\n\tPR libstdc++/22309\n\t* include/ext/mt_allocator.h\n\t(__gnu_cxx::__create_handler): Remove.\n\t(__pool<true>::_M_destroy_thread_key): Compatibility only.\n\t(__pool<true>::_M_initialize(__destroy): Same.\n\t(__pool<true>::_M_initialize): New.\n\t(__pool<true>::_M_initialize_once): Nothing fancy.\n\t(__pool<true>::_M_once): Remove.\n\t(__common_pool): New.\n\t(__common_pool_base): New.\n\t(__per_type_pool): New.\n\t(__per_type_pool_base): New.\n\t* src/mt_allocator.cc: Same.\n\t* config/linker-map.gnu (__pool<true>::_M_initialize()): Add.\n\n2005-09-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/19265\n\tPR libstdc++/22309\n\t* src/mt_allocator.cc (__gnu_internal::freelist_mutex): Make static.\n\t(__gnu_internal::__freelist): New type.\n\t(__gnu_internal::freelist): New variable.\n\t(__gnu_internal::_M_destroy_thread_key): New function.\n\t(__gnu_cxx::__pool<true>::_M_destroy): Don't delete\n\t_M_thread_freelist_initial.\n\t(__gnu_cxx::__pool<true>::_M_initialize): Make argument nameless.\n\tDon't use _M_thread_freelist and _M_thread_freelist_initial\n\t__pool<true> fields, instead use __gnu_internal::freelist fields, call\n\tgthread_key_create just once.  Use\n\t__gnu_internal::_M_destroy_thread_key as key destructor.\n\t(__gnu_cxx::__pool<true>::_M_get_thread_id): Store size_t id\n\trather than _Thread_record* in the thread specific value.  Don't\n\tuse _M_thread_freelist __pool<true> field, instead use\n\t__gnu_internal::freelist fields.\n\t(__gnu_cxx::__pool<true>::_M_destroy_thread_key): Do nothing.\n\n2005-09-11  Benjamin Kosnik  <bkoz@redhat.com>\n            Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/19265\n\tPR libstdc++/22309\n\t* testsuite/testsuite_shared.cc: New.\n\t* testsuite/lib/dg-options.exp (dg-require-sharedlib): New.\n\t* testsuite/lib/libstdc++.exp (libstdc++_init): Look for shared\n\tlibrary, and set v3-sharedlib based on this.\n\t(check_v3_target_sharedlib): New.\n\t(proc v3-build_support): Build shared objects.\n\t* testsuite/ext/mt_allocator/22309_thread.cc: New, use above.\n\nFrom-SVN: r104161", "tree": {"sha": "8b5f928c92d3aae14b4285ea94519fe9d16b10f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b5f928c92d3aae14b4285ea94519fe9d16b10f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/comments", "author": null, "committer": null, "parents": [{"sha": "56b4ea3de8efa797ff0edf9504704803d2ae4981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b4ea3de8efa797ff0edf9504704803d2ae4981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b4ea3de8efa797ff0edf9504704803d2ae4981"}], "stats": {"total": 836, "additions": 633, "deletions": 203}, "files": [{"sha": "cb6c84cc9b88b06427f2e3133b97efeb39373a43", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -1,3 +1,55 @@\n+2005-09-11  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/19265\n+\tPR libstdc++/22309\n+\t* include/ext/mt_allocator.h\n+\t(__gnu_cxx::__create_handler): Remove.\n+\t(__pool<true>::_M_destroy_thread_key): Compatibility only.\n+\t(__pool<true>::_M_initialize(__destroy): Same.\n+\t(__pool<true>::_M_initialize): New.\n+\t(__pool<true>::_M_initialize_once): Nothing fancy.\n+\t(__pool<true>::_M_once): Remove.\n+\t(__common_pool): New.\n+\t(__common_pool_base): New.\t\n+\t(__per_type_pool): New.\n+\t(__per_type_pool_base): New.\n+\t* src/mt_allocator.cc: Same.\n+\t* config/linker-map.gnu (__pool<true>::_M_initialize()): Add.\n+\t\n+2005-09-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libstdc++/19265\n+\tPR libstdc++/22309\n+\t* src/mt_allocator.cc (__gnu_internal::freelist_mutex): Make static.\n+\t(__gnu_internal::__freelist): New type.\n+\t(__gnu_internal::freelist): New variable.\n+\t(__gnu_internal::_M_destroy_thread_key): New function.\n+\t(__gnu_cxx::__pool<true>::_M_destroy): Don't delete\n+\t_M_thread_freelist_initial.\n+\t(__gnu_cxx::__pool<true>::_M_initialize): Make argument nameless.\n+\tDon't use _M_thread_freelist and _M_thread_freelist_initial\n+\t__pool<true> fields, instead use __gnu_internal::freelist fields, call\n+\tgthread_key_create just once.  Use\n+\t__gnu_internal::_M_destroy_thread_key as key destructor.\t\n+\t(__gnu_cxx::__pool<true>::_M_get_thread_id): Store size_t id\n+\trather than _Thread_record* in the thread specific value.  Don't\n+\tuse _M_thread_freelist __pool<true> field, instead use\n+\t__gnu_internal::freelist fields.\n+\t(__gnu_cxx::__pool<true>::_M_destroy_thread_key): Do nothing.\n+\n+2005-09-11  Benjamin Kosnik  <bkoz@redhat.com>\n+            Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libstdc++/19265\n+\tPR libstdc++/22309\t\n+\t* testsuite/testsuite_shared.cc: New.\n+\t* testsuite/lib/dg-options.exp (dg-require-sharedlib): New.\n+\t* testsuite/lib/libstdc++.exp (libstdc++_init): Look for shared\n+\tlibrary, and set v3-sharedlib based on this.\n+\t(check_v3_target_sharedlib): New.\n+\t(proc v3-build_support): Build shared objects.\n+\t* testsuite/ext/mt_allocator/22309_thread.cc: New, use above.\n+\n 2005-09-11  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/23781"}, {"sha": "eb8fab60c4c8a168feb7bcb814d2134cfd72f9fd", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -515,8 +515,8 @@ GLIBCXX_3.4.3 {\n } GLIBCXX_3.4.2;\n \n GLIBCXX_3.4.4 {\n- \n-   _ZN9__gnu_cxx6__poolILb0EE13_M_initializeEv;\n+\n+    _ZN9__gnu_cxx6__poolILb0EE13_M_initializeEv;\n     _ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE;\n     _ZN9__gnu_cxx6__poolILb1EE21_M_destroy_thread_keyEPv;\n     _ZN9__gnu_cxx6__poolILb1EE16_M_get_thread_idEv;\n@@ -571,6 +571,8 @@ GLIBCXX_3.4.6 {\n \n     _ZNKSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strEv;\n \n+   _ZN9__gnu_cxx6__poolILb1EE13_M_initializeEv;\n+\n } GLIBCXX_3.4.5;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "311e219aaee5101aebbb1b66a792a595040d0346", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 103, "deletions": 135, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -43,7 +43,6 @@\n namespace __gnu_cxx\n {\n   typedef void (*__destroy_handler)(void*);\n-  typedef void (*__create_handler)(void);\n \n   /// @brief  Base class for pool object.\n   struct __pool_base\n@@ -185,12 +184,6 @@ namespace __gnu_cxx\n   template<bool _Thread>\n     class __pool;\n \n-  template<>\n-    class __pool<true>;\n-\n-  template<>\n-    class __pool<false>;\n-\n   /// Specialization for single thread.\n   template<>\n     class __pool<false> : public __pool_base\n@@ -313,24 +306,15 @@ namespace __gnu_cxx\n \t__gthread_mutex_t*              _M_mutex;\n       };\n       \n+      // XXX GLIBCXX_ABI Deprecated\n       void\n-      _M_initialize(__destroy_handler __d);\n+      _M_initialize(__destroy_handler);\n \n       void\n-      _M_initialize_once(__create_handler __c)\n+      _M_initialize_once()\n       {\n-\t// Although the test in __gthread_once() would suffice, we\n-\t// wrap test of the once condition in our own unlocked\n-\t// check. This saves one function call to pthread_once()\n-\t// (which itself only tests for the once value unlocked anyway\n-\t// and immediately returns if set)\n \tif (__builtin_expect(_M_init == false, false))\n-\t  {\n-\t    if (__gthread_active_p())\n-\t      __gthread_once(&_M_once, __c);\n-\t    if (!_M_init)\n-\t      __c();\n-\t  }\n+\t  _M_initialize();\n       }\n \n       void\n@@ -358,28 +342,21 @@ namespace __gnu_cxx\n \t  }\n       }\n \n+      // XXX GLIBCXX_ABI Deprecated\n       void \n-      _M_destroy_thread_key(void* __freelist_pos);\n+      _M_destroy_thread_key(void*);\n \n       size_t \n       _M_get_thread_id();\n \n       explicit __pool() \n       : _M_bin(NULL), _M_bin_size(1), _M_thread_freelist(NULL) \n-      {\n-\t// On some platforms, __gthread_once_t is an aggregate.\n-\t__gthread_once_t __tmp = __GTHREAD_ONCE_INIT;\n-\t_M_once = __tmp;\n-      }\n+      { }\n \n       explicit __pool(const __pool_base::_Tune& __tune) \n       : __pool_base(__tune), _M_bin(NULL), _M_bin_size(1), \n       _M_thread_freelist(NULL) \n-      {\n-\t// On some platforms, __gthread_once_t is an aggregate.\n-\t__gthread_once_t __tmp = __GTHREAD_ONCE_INIT;\n-\t_M_once = __tmp;\n-      }\n+      { }\n \n     private:\n       // An \"array\" of bin_records each of which represents a specific\n@@ -390,39 +367,39 @@ namespace __gnu_cxx\n       // Actual value calculated in _M_initialize().\n       size_t \t       \t     \t_M_bin_size;\n \n-      __gthread_once_t \t\t_M_once;\n-      \n       _Thread_record* \t\t_M_thread_freelist;\n       void*\t\t\t_M_thread_freelist_initial;\n+\n+      void\n+      _M_initialize();\n     };\n #endif\n \n-\n-  /// @brief  Policy for shared __pool objects.\n   template<template <bool> class _PoolTp, bool _Thread>\n-    struct __common_pool_policy;\n-\n-  /// Partial specialization for single thread.\n-  template<template <bool> class _PoolTp>\n-    struct __common_pool_policy<_PoolTp, false>\n+    struct __common_pool\n     {\n-      typedef _PoolTp<false> pool_type;\n+      typedef _PoolTp<_Thread> \t\tpool_type;\n       \n-      template<typename _Tp1, template <bool> class _PoolTp1 = _PoolTp, \n-\t       bool _Thread1 = false>\n-        struct _M_rebind\n-        { typedef __common_pool_policy<_PoolTp1, _Thread1> other; };\n-\n       static pool_type&\n       _S_get_pool()\n       { \n \tstatic pool_type _S_pool;\n \treturn _S_pool;\n       }\n+    };\n+\n+  template<template <bool> class _PoolTp, bool _Thread>\n+    struct __common_pool_base;\n+\n+  template<template <bool> class _PoolTp>\n+    struct __common_pool_base<_PoolTp, false> \n+    : public __common_pool<_PoolTp, false>\n+    {\n+      using  __common_pool<_PoolTp, false>::_S_get_pool;\n \n       static void\n-      _S_initialize_once() \n-      { \n+      _S_initialize_once()\n+      {\n \tstatic bool __init;\n \tif (__builtin_expect(__init == false, false))\n \t  {\n@@ -433,87 +410,88 @@ namespace __gnu_cxx\n     };\n \n #ifdef __GTHREADS\n-  /// Partial specialization for thread enabled, via gthreads.h.\n   template<template <bool> class _PoolTp>\n-    struct __common_pool_policy<_PoolTp, true>\n+    struct __common_pool_base<_PoolTp, true>\n+    : public __common_pool<_PoolTp, true>\n     {\n-      typedef _PoolTp<true> pool_type;\n+      using  __common_pool<_PoolTp, true>::_S_get_pool;\n       \n-      template<typename _Tp1, template <bool> class _PoolTp1 = _PoolTp, \n-\t       bool _Thread1 = true>\n-        struct _M_rebind\n-        { typedef __common_pool_policy<_PoolTp1, _Thread1> other; };\n-\n-      static pool_type&\n-      _S_get_pool()\n-      { \n-\tstatic pool_type _S_pool;\n-\treturn _S_pool;\n-      }\n+      static void\n+      _S_initialize() \n+      { _S_get_pool()._M_initialize_once(); }\n \n       static void\n-      _S_initialize_once() \n+      _S_initialize_once()\n       { \n \tstatic bool __init;\n \tif (__builtin_expect(__init == false, false))\n \t  {\n-\t    _S_get_pool()._M_initialize_once(_S_initialize); \n+\t    if (__gthread_active_p())\n+\t      {\n+\t\t// On some platforms, __gthread_once_t is an aggregate.\n+\t\tstatic __gthread_once_t __once = __GTHREAD_ONCE_INIT;\n+\t\t__gthread_once(&__once, _S_initialize);\n+\t      }\n+\t    else\n+\t      _S_get_pool()._M_initialize_once(); \n \t    __init = true;\n \t  }\n       }\n-\n-    private:\n-      static void\n-      _S_destroy_thread_key(void* __freelist_pos)\n-      { _S_get_pool()._M_destroy_thread_key(__freelist_pos); }\n-      \n-      static void\n-      _S_initialize() \n-      { _S_get_pool()._M_initialize(_S_destroy_thread_key); }\n-   };\n+    };\n #endif\n \n- \n-  /// @brief  Policy for individual __pool objects.\n-  template<typename _Tp, template <bool> class _PoolTp, bool _Thread>\n-    struct __per_type_pool_policy;\n-\n-  /// Partial specialization for single thread.\n-  template<typename _Tp, template <bool> class _PoolTp>\n-    struct __per_type_pool_policy<_Tp, _PoolTp, false>\n+  /// @brief  Policy for shared __pool objects.\n+  template<template <bool> class _PoolTp, bool _Thread>\n+    struct __common_pool_policy : public __common_pool_base<_PoolTp, _Thread>\n     {\n-      typedef _Tp value_type;\n-      typedef _PoolTp<false> pool_type;\n-\n       template<typename _Tp1, template <bool> class _PoolTp1 = _PoolTp, \n-\t       bool _Thread1 = false>\n+\t       bool _Thread1 = _Thread>\n         struct _M_rebind\n-        { typedef __per_type_pool_policy<_Tp1, _PoolTp1, _Thread1> other; };\n+        { typedef __common_pool_policy<_PoolTp1, _Thread1> other; };\n \n+      using  __common_pool_base<_PoolTp, _Thread>::_S_get_pool;\n+      using  __common_pool_base<_PoolTp, _Thread>::_S_initialize_once;\n+  };\n+ \n+\n+  template<typename _Tp, template <bool> class _PoolTp, bool _Thread>\n+    struct __per_type_pool\n+    {\n+      typedef _Tp \t\t\tvalue_type;\n+      typedef _PoolTp<_Thread> \t\tpool_type;\n+      \n       static pool_type&\n       _S_get_pool()\n       { \n \t// Sane defaults for the _PoolTp.\n \ttypedef typename pool_type::_Block_record _Block_record;\n-\tconst static size_t __align = (__alignof__(_Tp) >= sizeof(_Block_record)\n-\t\t\t\t       ? __alignof__(_Tp)\n-\t\t\t\t       : sizeof(_Block_record));\n+\tconst static size_t __a = (__alignof__(_Tp) >= sizeof(_Block_record)\n+\t\t\t\t   ? __alignof__(_Tp) : sizeof(_Block_record));\n \n \ttypedef typename __pool_base::_Tune _Tune;\n-\tstatic _Tune _S_tune(__align, sizeof(_Tp) * 64,\n-\t\t\t     sizeof(_Tp) * 2 >= __align ? sizeof(_Tp) * 2\n-\t\t\t                                : __align,\n+\tstatic _Tune _S_tune(__a, sizeof(_Tp) * 64,\n+\t\t\t     sizeof(_Tp) * 2 >= __a ? sizeof(_Tp) * 2 : __a,\n \t\t\t     sizeof(_Tp) * size_t(_Tune::_S_chunk_size),\n \t\t\t     _Tune::_S_max_threads,\n \t\t\t     _Tune::_S_freelist_headroom,\n \t\t\t     getenv(\"GLIBCXX_FORCE_NEW\") ? true : false);\n \tstatic pool_type _S_pool(_S_tune);\n \treturn _S_pool;\n       }\n+    };\n+\n+  template<typename _Tp, template <bool> class _PoolTp, bool _Thread>\n+    struct __per_type_pool_base;\n+\n+  template<typename _Tp, template <bool> class _PoolTp>\n+    struct __per_type_pool_base<_Tp, _PoolTp, false> \n+    : public __per_type_pool<_Tp, _PoolTp, false> \n+    {\n+      using  __per_type_pool<_Tp, _PoolTp, false>::_S_get_pool;\n \n       static void\n       _S_initialize_once()\n-      { \n+      {\n \tstatic bool __init;\n \tif (__builtin_expect(__init == false, false))\n \t  {\n@@ -523,62 +501,52 @@ namespace __gnu_cxx\n       }\n     };\n \n-#ifdef __GTHREADS\n-  /// Partial specialization for thread enabled, via gthreads.h.\n-  template<typename _Tp, template <bool> class _PoolTp>\n-    struct __per_type_pool_policy<_Tp, _PoolTp, true>\n+ #ifdef __GTHREADS\n+ template<typename _Tp, template <bool> class _PoolTp>\n+    struct __per_type_pool_base<_Tp, _PoolTp, true> \n+    : public __per_type_pool<_Tp, _PoolTp, true> \n     {\n-      typedef _Tp value_type;\n-      typedef _PoolTp<true> pool_type;\n+      using  __per_type_pool<_Tp, _PoolTp, true>::_S_get_pool;\n \n-     template<typename _Tp1, template <bool> class _PoolTp1 = _PoolTp, \n-\t       bool _Thread1 = true>\n-        struct _M_rebind\n-        { typedef __per_type_pool_policy<_Tp1, _PoolTp1, _Thread1> other; };\n-\n-      static pool_type&\n-      _S_get_pool()\n-      { \n-\t// Sane defaults for the _PoolTp.\n-\ttypedef typename pool_type::_Block_record _Block_record;\n-\tconst static size_t __align = (__alignof__(_Tp) >= sizeof(_Block_record)\n-\t\t\t\t       ? __alignof__(_Tp)\n-\t\t\t\t       : sizeof(_Block_record));\n-\n-\ttypedef typename __pool_base::_Tune _Tune;\n-\tstatic _Tune _S_tune(__align, sizeof(_Tp) * 64,\n-\t\t\t     sizeof(_Tp) * 2 >= __align ? sizeof(_Tp) * 2\n-                                                        : __align,\n-\t\t\t     sizeof(_Tp) * size_t(_Tune::_S_chunk_size),\n-\t\t\t     _Tune::_S_max_threads,\n-\t\t\t     _Tune::_S_freelist_headroom,\n-\t\t\t     getenv(\"GLIBCXX_FORCE_NEW\") ? true : false);\n-\tstatic pool_type _S_pool(_S_tune);\n-\treturn _S_pool;\n-      }\n+      static void\n+      _S_initialize() \n+      { _S_get_pool()._M_initialize_once(); }\n \n       static void\n       _S_initialize_once()\n       { \n \tstatic bool __init;\n \tif (__builtin_expect(__init == false, false))\n \t  {\n-\t    _S_get_pool()._M_initialize_once(_S_initialize); \n+\t    if (__gthread_active_p())\n+\t      {\n+\t\t// On some platforms, __gthread_once_t is an aggregate.\n+\t\tstatic __gthread_once_t __once = __GTHREAD_ONCE_INIT;\n+\t\t__gthread_once(&__once, _S_initialize);\n+\t      }\n+\t    else\n+\t      _S_get_pool()._M_initialize_once(); \n \t    __init = true;\n \t  }\n       }\n-\n-    private:\n-      static void\n-      _S_destroy_thread_key(void* __freelist_pos)\n-      { _S_get_pool()._M_destroy_thread_key(__freelist_pos); }\n-      \n-      static void\n-      _S_initialize() \n-      { _S_get_pool()._M_initialize(_S_destroy_thread_key); }\n     };\n #endif\n \n+  /// @brief  Policy for individual __pool objects.\n+  template<typename _Tp, template <bool> class _PoolTp, bool _Thread>\n+    struct __per_type_pool_policy \n+    : public __per_type_pool_base<_Tp, _PoolTp, _Thread>\n+    {\n+      template<typename _Tp1, template <bool> class _PoolTp1 = _PoolTp, \n+\t       bool _Thread1 = _Thread>\n+        struct _M_rebind\n+        { typedef __per_type_pool_policy<_Tp1, _PoolTp1, _Thread1> other; };\n+\n+      using  __per_type_pool_base<_Tp, _PoolTp, _Thread>::_S_get_pool;\n+      using  __per_type_pool_base<_Tp, _PoolTp, _Thread>::_S_initialize_once;\n+  };\n+\n+\n   /// @brief  Base class for _Tp dependent member functions.\n   template<typename _Tp>\n     class __mt_alloc_base "}, {"sha": "1f4ec3ff1e009c9a79d9b60463865b9ccb355fe6", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "modified", "additions": 278, "deletions": 49, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -1,8 +1,8 @@\n // Allocator details.\n \n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n //\n-// This file is part of the GNU ISO C++ Librarbooly.  This library is free\n+// This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n // terms of the GNU General Public License as published by the\n // Free Software Foundation; either version 2, or (at your option)\n@@ -37,10 +37,42 @@\n \n namespace __gnu_internal\n {\n+#ifdef __GTHREADS\n+  struct __freelist\n+  {\n+    typedef __gnu_cxx::__pool<true>::_Thread_record _Thread_record;\n+    _Thread_record* \t_M_thread_freelist;\n+    _Thread_record* \t_M_thread_freelist_array;\n+    size_t \t\t_M_max_threads;\n+    __gthread_key_t \t_M_key;\n+\n+    ~__freelist()\n+    {\n+      if (_M_thread_freelist_array)\n+\t{\n+\t  __gthread_key_delete(_M_key);\n+\t  ::operator delete(static_cast<void*>(_M_thread_freelist_array));\n+\t}\n+    }\n+  };\n+\n+  // Ensure freelist is constructed first.\n+  static __freelist freelist;\n   static __glibcxx_mutex_define_initialized(freelist_mutex);\n \n-#ifdef __GTHREADS\n-  __gthread_key_t freelist_key;\n+  static void \n+  _M_destroy_thread_key(void* __id)\n+  {\n+    // Return this thread id record to front of thread_freelist.\n+    __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+    size_t _M_id = reinterpret_cast<size_t>(__id);\n+\n+    using namespace __gnu_internal;\n+    typedef __gnu_cxx::__pool<true>::_Thread_record _Thread_record;\n+    _Thread_record* __tr = &freelist._M_thread_freelist_array[_M_id - 1];\n+    __tr->_M_next = freelist._M_thread_freelist;\n+    freelist._M_thread_freelist = __tr;\n+  }\n #endif\n }\n \n@@ -171,6 +203,7 @@ namespace __gnu_cxx\n       }\n     _M_init = true;\n   }\n+\n   \n #ifdef __GTHREADS\n   void\n@@ -194,7 +227,6 @@ namespace __gnu_cxx\n \t\t::operator delete(__bin._M_used);\n \t\t::operator delete(__bin._M_mutex);\n \t      }\n-\t    ::operator delete(_M_thread_freelist_initial);\n \t  }\n \telse\n \t  {\n@@ -386,8 +418,8 @@ namespace __gnu_cxx\n     return reinterpret_cast<char*>(__block) + __options._M_align;\n   }\n \n- void\n-  __pool<true>::_M_initialize(__destroy_handler __d)\n+  void\n+  __pool<true>::_M_initialize()\n   {\n     // _M_force_new must not change after the first allocate(),\n     // which in turn calls this method, so if it's false, it's false\n@@ -397,7 +429,7 @@ namespace __gnu_cxx\n \t_M_init = true;\n \treturn;\n       }\n-      \n+\n     // Create the bins.\n     // Calculate the number of bins required based on _M_max_bytes.\n     // _M_bin_size is statically-initialized to one.\n@@ -433,29 +465,70 @@ namespace __gnu_cxx\n     // directly and have no need for this.\n     if (__gthread_active_p())\n       {\n-\tconst size_t __k = sizeof(_Thread_record) * _M_options._M_max_threads;\n-\t__v = ::operator new(__k);\n-\t_M_thread_freelist = static_cast<_Thread_record*>(__v);\n-\t_M_thread_freelist_initial = __v;\n-\t  \n-\t// NOTE! The first assignable thread id is 1 since the\n-\t// global pool uses id 0\n-\tsize_t __i;\n-\tfor (__i = 1; __i < _M_options._M_max_threads; ++__i)\n-\t  {\n-\t    _Thread_record& __tr = _M_thread_freelist[__i - 1];\n-\t    __tr._M_next = &_M_thread_freelist[__i];\n-\t    __tr._M_id = __i;\n-\t  }\n-\t  \n-\t// Set last record.\n-\t_M_thread_freelist[__i - 1]._M_next = NULL;\n-\t_M_thread_freelist[__i - 1]._M_id = __i;\n-\t  \n-\t// Initialize per thread key to hold pointer to\n-\t// _M_thread_freelist.\n-\t__gthread_key_create(&__gnu_internal::freelist_key, __d);\n-\t  \n+\t{\n+\t  __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+\n+\t  if (!__gnu_internal::freelist._M_thread_freelist_array\n+\t      || __gnu_internal::freelist._M_max_threads\n+\t\t < _M_options._M_max_threads)\n+\t    {\n+\t      const size_t __k = sizeof(_Thread_record)\n+\t\t\t\t * _M_options._M_max_threads;\n+\t      __v = ::operator new(__k);\n+\t      _Thread_record* _M_thread_freelist\n+\t\t= static_cast<_Thread_record*>(__v);\n+\n+\t      // NOTE! The first assignable thread id is 1 since the\n+\t      // global pool uses id 0\n+\t      size_t __i;\n+\t      for (__i = 1; __i < _M_options._M_max_threads; ++__i)\n+\t\t{\n+\t\t  _Thread_record& __tr = _M_thread_freelist[__i - 1];\n+\t\t  __tr._M_next = &_M_thread_freelist[__i];\n+\t\t  __tr._M_id = __i;\n+\t\t}\n+\n+\t      // Set last record.\n+\t      _M_thread_freelist[__i - 1]._M_next = NULL;\n+\t      _M_thread_freelist[__i - 1]._M_id = __i;\n+\n+\t      if (!__gnu_internal::freelist._M_thread_freelist_array)\n+\t\t{\n+\t\t  // Initialize per thread key to hold pointer to\n+\t\t  // _M_thread_freelist.\n+\t\t  __gthread_key_create(&__gnu_internal::freelist._M_key,\n+\t\t\t\t       __gnu_internal::_M_destroy_thread_key);\n+\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = _M_thread_freelist;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _Thread_record* _M_old_freelist\n+\t\t    = __gnu_internal::freelist._M_thread_freelist;\n+\t\t  _Thread_record* _M_old_array\n+\t\t    = __gnu_internal::freelist._M_thread_freelist_array;\n+\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = &_M_thread_freelist[_M_old_freelist - _M_old_array];\n+\t\t  while (_M_old_freelist)\n+\t\t    {\n+\t\t      size_t next_id;\n+\t\t      if (_M_old_freelist->_M_next)\n+\t\t\tnext_id = _M_old_freelist->_M_next - _M_old_array;\n+\t\t      else\n+\t\t\tnext_id = __gnu_internal::freelist._M_max_threads;\n+\t\t      _M_thread_freelist[_M_old_freelist->_M_id - 1]._M_next\n+\t\t\t= &_M_thread_freelist[next_id];\n+\t\t      _M_old_freelist = _M_old_freelist->_M_next;\n+\t\t    }\n+\t\t  ::operator delete(static_cast<void*>(_M_old_array));\n+\t\t}\n+\t      __gnu_internal::freelist._M_thread_freelist_array\n+\t\t= _M_thread_freelist;\n+\t      __gnu_internal::freelist._M_max_threads\n+\t\t= _M_options._M_max_threads;\n+\t    }\n+\t}\n+\n \tconst size_t __max_threads = _M_options._M_max_threads + 1;\n \tfor (size_t __n = 0; __n < _M_bin_size; ++__n)\n \t  {\n@@ -514,38 +587,194 @@ namespace __gnu_cxx\n     // returns it's id.\n     if (__gthread_active_p())\n       {\n-\tvoid* v = __gthread_getspecific(__gnu_internal::freelist_key);\n-\t_Thread_record* __freelist_pos = static_cast<_Thread_record*>(v); \n-\tif (__freelist_pos == NULL)\n+\tvoid* v = __gthread_getspecific(__gnu_internal::freelist._M_key);\n+\tsize_t _M_id = (size_t)v;\n+\tif (_M_id == 0)\n \t  {\n-\t    // Since _M_options._M_max_threads must be larger than\n-\t    // the theoretical max number of threads of the OS the\n-\t    // list can never be empty.\n \t    {\n \t      __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n-\t      __freelist_pos = _M_thread_freelist;\n-\t      _M_thread_freelist = _M_thread_freelist->_M_next;\n+\t      if (__gnu_internal::freelist._M_thread_freelist)\n+\t\t{\n+\t\t  _M_id = __gnu_internal::freelist._M_thread_freelist->_M_id;\n+\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = __gnu_internal::freelist._M_thread_freelist->_M_next;\n+\t\t}\n \t    }\n-\t      \n-\t    __gthread_setspecific(__gnu_internal::freelist_key, \n-\t\t\t\t  static_cast<void*>(__freelist_pos));\n+\n+\t    __gthread_setspecific(__gnu_internal::freelist._M_key,\n+\t\t\t\t  (void*)_M_id);\n \t  }\n-\treturn __freelist_pos->_M_id;\n+\treturn _M_id >= _M_options._M_max_threads ? 0 : _M_id;\n       }\n \n     // Otherwise (no thread support or inactive) all requests are\n     // served from the global pool 0.\n     return 0;\n   }\n \n+  // XXX GLIBCXX_ABI Deprecated\n+  void \n+  __pool<true>::_M_destroy_thread_key(void*) { }\n+\n+  // XXX GLIBCXX_ABI Deprecated\n   void\n-  __pool<true>::_M_destroy_thread_key(void* __freelist_pos)\n+  __pool<true>::_M_initialize(__destroy_handler)\n   {\n-    // Return this thread id record to front of thread_freelist.\n-    __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n-    _Thread_record* __tr = static_cast<_Thread_record*>(__freelist_pos);\n-    __tr->_M_next = _M_thread_freelist; \n-    _M_thread_freelist = __tr;\n+    // _M_force_new must not change after the first allocate(),\n+    // which in turn calls this method, so if it's false, it's false\n+    // forever and we don't need to return here ever again.\n+    if (_M_options._M_force_new) \n+      {\n+\t_M_init = true;\n+\treturn;\n+      }\n+\n+    // Create the bins.\n+    // Calculate the number of bins required based on _M_max_bytes.\n+    // _M_bin_size is statically-initialized to one.\n+    size_t __bin_size = _M_options._M_min_bin;\n+    while (_M_options._M_max_bytes > __bin_size)\n+      {\n+\t__bin_size <<= 1;\n+\t++_M_bin_size;\n+      }\n+      \n+    // Setup the bin map for quick lookup of the relevant bin.\n+    const size_t __j = (_M_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n+    _M_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n+    _Binmap_type* __bp = _M_binmap;\n+    _Binmap_type __bin_max = _M_options._M_min_bin;\n+    _Binmap_type __bint = 0;\n+    for (_Binmap_type __ct = 0; __ct <= _M_options._M_max_bytes; ++__ct)\n+      {\n+\tif (__ct > __bin_max)\n+\t  {\n+\t    __bin_max <<= 1;\n+\t    ++__bint;\n+\t  }\n+\t*__bp++ = __bint;\n+      }\n+      \n+    // Initialize _M_bin and its members.\n+    void* __v = ::operator new(sizeof(_Bin_record) * _M_bin_size);\n+    _M_bin = static_cast<_Bin_record*>(__v);\n+      \n+    // If __gthread_active_p() create and initialize the list of\n+    // free thread ids. Single threaded applications use thread id 0\n+    // directly and have no need for this.\n+    if (__gthread_active_p())\n+      {\n+\t{\n+\t  __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+\n+\t  if (!__gnu_internal::freelist._M_thread_freelist_array\n+\t      || __gnu_internal::freelist._M_max_threads\n+\t\t < _M_options._M_max_threads)\n+\t    {\n+\t      const size_t __k = sizeof(_Thread_record)\n+\t\t\t\t * _M_options._M_max_threads;\n+\t      __v = ::operator new(__k);\n+\t      _Thread_record* _M_thread_freelist\n+\t\t= static_cast<_Thread_record*>(__v);\n+\n+\t      // NOTE! The first assignable thread id is 1 since the\n+\t      // global pool uses id 0\n+\t      size_t __i;\n+\t      for (__i = 1; __i < _M_options._M_max_threads; ++__i)\n+\t\t{\n+\t\t  _Thread_record& __tr = _M_thread_freelist[__i - 1];\n+\t\t  __tr._M_next = &_M_thread_freelist[__i];\n+\t\t  __tr._M_id = __i;\n+\t\t}\n+\n+\t      // Set last record.\n+\t      _M_thread_freelist[__i - 1]._M_next = NULL;\n+\t      _M_thread_freelist[__i - 1]._M_id = __i;\n+\n+\t      if (!__gnu_internal::freelist._M_thread_freelist_array)\n+\t\t{\n+\t\t  // Initialize per thread key to hold pointer to\n+\t\t  // _M_thread_freelist.\n+\t\t  __gthread_key_create(&__gnu_internal::freelist._M_key,\n+\t\t\t\t       __gnu_internal::_M_destroy_thread_key);\n+\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = _M_thread_freelist;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _Thread_record* _M_old_freelist\n+\t\t    = __gnu_internal::freelist._M_thread_freelist;\n+\t\t  _Thread_record* _M_old_array\n+\t\t    = __gnu_internal::freelist._M_thread_freelist_array;\n+\t\t  __gnu_internal::freelist._M_thread_freelist\n+\t\t    = &_M_thread_freelist[_M_old_freelist - _M_old_array];\n+\t\t  while (_M_old_freelist)\n+\t\t    {\n+\t\t      size_t next_id;\n+\t\t      if (_M_old_freelist->_M_next)\n+\t\t\tnext_id = _M_old_freelist->_M_next - _M_old_array;\n+\t\t      else\n+\t\t\tnext_id = __gnu_internal::freelist._M_max_threads;\n+\t\t      _M_thread_freelist[_M_old_freelist->_M_id - 1]._M_next\n+\t\t\t= &_M_thread_freelist[next_id];\n+\t\t      _M_old_freelist = _M_old_freelist->_M_next;\n+\t\t    }\n+\t\t  ::operator delete(static_cast<void*>(_M_old_array));\n+\t\t}\n+\t      __gnu_internal::freelist._M_thread_freelist_array\n+\t\t= _M_thread_freelist;\n+\t      __gnu_internal::freelist._M_max_threads\n+\t\t= _M_options._M_max_threads;\n+\t    }\n+\t}\n+\n+\tconst size_t __max_threads = _M_options._M_max_threads + 1;\n+\tfor (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t  {\n+\t    _Bin_record& __bin = _M_bin[__n];\n+\t    __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n+\t    __bin._M_first = static_cast<_Block_record**>(__v);\n+\n+\t    __bin._M_address = NULL;\n+\n+\t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    __bin._M_free = static_cast<size_t*>(__v);\n+\t      \n+\t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    __bin._M_used = static_cast<size_t*>(__v);\n+\t      \n+\t    __v = ::operator new(sizeof(__gthread_mutex_t));\n+\t    __bin._M_mutex = static_cast<__gthread_mutex_t*>(__v);\n+\t      \n+#ifdef __GTHREAD_MUTEX_INIT\n+\t    {\n+\t      // Do not copy a POSIX/gthr mutex once in use.\n+\t      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+\t      *__bin._M_mutex = __tmp;\n+\t    }\n+#else\n+\t    { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n+#endif\n+\t    for (size_t __threadn = 0; __threadn < __max_threads; ++__threadn)\n+\t      {\n+\t\t__bin._M_first[__threadn] = NULL;\n+\t\t__bin._M_free[__threadn] = 0;\n+\t\t__bin._M_used[__threadn] = 0;\n+\t      }\n+\t  }\n+      }\n+    else\n+      {\n+\tfor (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t  {\n+\t    _Bin_record& __bin = _M_bin[__n];\n+\t    __v = ::operator new(sizeof(_Block_record*));\n+\t    __bin._M_first = static_cast<_Block_record**>(__v);\n+\t    __bin._M_first[0] = NULL;\n+\t    __bin._M_address = NULL;\n+\t  }\n+      }\n+    _M_init = true;\n   }\n #endif\n "}, {"sha": "ce4024eb8768eb2854f0128582c069844a8b8560", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/22309_thread.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2F22309_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2F22309_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2F22309_thread.cc?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -0,0 +1,101 @@\n+// { dg-require-sharedlib \"\" }\n+// { dg-do run { target *-*-linux* } }\n+// { dg-options \"-g -O2 -pthread -ldl\" { target *-*-linux* } }\n+\n+// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <dlfcn.h>\n+#include <pthread.h>\n+#include <cstdlib>\n+#include <stdexcept>\n+\n+void\n+check_dlopen(void*& h)\n+{\n+  dlerror();\n+  void* tmp = dlopen(\"./testsuite_shared.so\", RTLD_LAZY);\n+  if (!tmp) \n+    {\n+      try \n+\t{\n+\t  // Throws std::logic_error on NULL string.\n+\t  std::string error(dlerror());\n+\t  throw std::runtime_error(error);\n+\t}\n+      catch (const std::logic_error&)\n+\t{ }\n+    }\n+  h = tmp;\n+}\n+\n+void\n+check_dlsym(void*& h)\n+{\n+  dlerror();\n+\n+  typedef void (*function_type) (void);\n+  function_type fn;\n+  fn = reinterpret_cast<function_type>(dlsym(h, \"foo\"));\n+\n+  try \n+    {\n+      std::string error(dlerror());\n+      throw std::runtime_error(error);\n+    }\n+  catch (const std::logic_error&)\n+    { }\n+\n+  fn();\n+}\n+\n+void\n+check_dlclose(void*& h)\n+{\n+  dlerror();\n+  if (dlclose(h) != 0)\n+    {\n+      try \n+\t{\n+\t  std::string error(dlerror());\n+\t  throw std::runtime_error(error);\n+\t}\n+      catch (const std::logic_error&)\n+\t{ }\n+    }\n+}\n+\n+void*\n+tf(void* arg)\n+{\n+  void* h;\n+  check_dlopen(h);\n+  check_dlsym(h);\n+  check_dlclose(h);\n+  return 0;\n+}\n+\n+// libstdc++/22309\n+int\n+main (void)\n+{\n+  pthread_t th;\n+  pthread_create(&th, NULL, tf, NULL);\n+  pthread_join(th, NULL);\n+  return 0;\n+}"}, {"sha": "2ab8e425d342b213306a7282ef707344ea3ca380", "filename": "libstdc++-v3/testsuite/lib/dg-options.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -44,3 +44,12 @@ proc dg-require-cxa-atexit { args } {\n     }\n     return\n }\n+\n+proc dg-require-sharedlib { args } {\n+    if { ![ check_v3_target_sharedlib ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+\treturn\n+    }\n+    return\n+}"}, {"sha": "333d50ccede3f930b13eba5d50cbcfe3c2e8767a", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -14,7 +14,8 @@\n # \n # You should have received a copy of the GNU General Public License\n # along with this program; if not, write to the Free Software\n-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n \n \n # Define callbacks and load other libraries.  This file is loaded relatively\n@@ -79,6 +80,7 @@ proc v3-copy-files {srcfiles} {\n # Called once, during runtest.exp setup.\n proc libstdc++_init { testfile } {\n     global env\n+    global v3-sharedlib \n     global srcdir blddir objdir tool_root_dir\n     global cxx cxxflags\n     global includes\n@@ -127,6 +129,15 @@ proc libstdc++_init { testfile } {\n     }\n     v3track gccdir 3\n \n+    # Look for shared library. (ie libstdc++.so.)\n+    set v3-sharedlib 0\n+    set sharedlibdir [lookfor_file $blddir src/.libs/libstdc++.so]\n+    if {$sharedlibdir != \"\"} {\n+        set v3-sharedlib 1\n+\tverbose -log \"shared library support detected\"\n+    }\n+    v3track v3-sharedlib 3\n+\n     # Compute what needs to be added to the existing LD_LIBRARY_PATH.\n     if {$gccdir != \"\"} {\n \tset ld_library_path \"\"\n@@ -324,6 +335,7 @@ proc v3-build_support {} {\n     global v3-threads\n     global v3-test_objs\n     global v3-symver\n+    global v3-sharedlib\n \n     # Figure out whether or not the library supports certain features.\n     set v3-wchar_t 0\n@@ -353,7 +365,7 @@ proc v3-build_support {} {\n \n     # Build the support objects.\n     set source_files \\\n-\t[list testsuite_abi.cc testsuite_allocator.cc testsuite_character.cc testsuite_hooks.cc]\n+\t[list testsuite_abi.cc testsuite_allocator.cc testsuite_character.cc testsuite_hooks.cc ]\n     foreach f $source_files {\n \tset object_file [file rootname $f].o\n \t# Compile with \"-w\" so that warnings issued by the compiler\n@@ -365,6 +377,27 @@ proc v3-build_support {} {\n \t}\n \tappend v3-test_objs \"$object_file \"\n     }\n+\n+    # Build the shared support objects.\n+    if { ${v3-sharedlib} == 1 } {\n+\tset source_files \\\n+\t    [list testsuite_shared.cc]\n+\tforeach f $source_files {\n+\t    set object_file [file rootname $f].so\n+\t    # Compile with \"-w\" so that warnings issued by the compiler\n+\t    # do not prevent compilation.\n+\t    if { [v3_target_compile $srcdir/$f $object_file \"executable\" \\\n+\t     [list \"incdir=$srcdir\" \"additional_flags=-w -shared -fPIC -DPIC\"]]\n+\t\t != \"\" } {\n+\t\terror \"could not compile $f\"\n+\t    }\n+\t}\n+    }\n+}\n+\n+proc check_v3_target_sharedlib { } {\n+    global v3-sharedlib\n+    return ${v3-sharedlib}\n }\n \n proc check_v3_target_namedlocale { } {\n@@ -491,27 +524,27 @@ proc check_v3_target_cxa_atexit { } {\n \tputs $f \"static unsigned int count;\"\n \tputs $f \"struct X\"\n \tputs $f \"{\"\n-\tputs $f \"X() { count = 1; }\"\n-\tputs $f \"~X()\"\n-\tputs $f \"{\"\n-\tputs $f \"  if (count != 3)\"\n-\tputs $f \"    exit(1);\"\n-\tputs $f \"  count = 4;\"\n-        puts $f \"}\"\n+\tputs $f \"  X() { count = 1; }\"\n+\tputs $f \"  ~X()\"\n+\tputs $f \"  {\"\n+\tputs $f \"    if (count != 3)\"\n+\tputs $f \"      exit(1);\"\n+\tputs $f \"    count = 4;\"\n+        puts $f \"  }\"\n         puts $f \"};\"\n \tputs $f \"void f()\"\n \tputs $f \"{\"\n-\tputs $f \"static X x;\"\n+\tputs $f \"  static X x;\"\n         puts $f \"}\"\n \tputs $f \"struct Y\"\n \tputs $f \"{\"\n-\tputs $f \"Y() { f(); count = 2; }\"\n-\tputs $f \"~Y()\"\n-\tputs $f \"{\"\n-\tputs $f \"if (count != 2)\"\n-\tputs $f \"  exit(1);\"\n-\tputs $f \"count = 3;\"\n-        puts $f \"}\"\n+\tputs $f \"  Y() { f(); count = 2; }\"\n+\tputs $f \"  ~Y()\"\n+\tputs $f \"  {\"\n+\tputs $f \"    if (count != 2)\"\n+\tputs $f \"      exit(1);\"\n+\tputs $f \"    count = 3;\"\n+        puts $f \"  }\"\n         puts $f \"};\"\n \tputs $f \"Y y;\"\n \tputs $f \"int main()\""}, {"sha": "a829fb47aa74bd131a6ebffc53b4e3b8a6a0154d", "filename": "libstdc++-v3/testsuite/testsuite_shared.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_shared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9f6cef1cdc149a05754839ca27af001c8d3d1e/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_shared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_shared.cc?ref=2f9f6cef1cdc149a05754839ca27af001c8d3d1e", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <string>\n+#include <ext/mt_allocator.h>\n+\n+// libstdc++/22309\n+extern \"C\" void\n+foo()\n+{\n+  typedef char value_t;\n+\n+  typedef __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> policy_t;\n+  typedef __gnu_cxx::__mt_alloc<value_t, policy_t> allocator_t;\n+\n+  typedef std::char_traits<value_t> traits_t; \n+  typedef std::basic_string<value_t, traits_t, allocator_t> string_t;\n+\n+  string_t s;\n+  s += \"west beach, indiana dunes\";\n+}"}]}