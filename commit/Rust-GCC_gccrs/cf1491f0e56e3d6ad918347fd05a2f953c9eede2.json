{"sha": "cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxNDkxZjBlNTZlM2Q2YWQ5MTgzNDdmZDA1YTJmOTUzYzllZWRlMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-10-25T20:44:09Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-10-25T20:44:09Z"}, "message": "re PR middle-end/29335 (transcendental functions with constant arguments should be resolved at compile-time)\n\n\tPR middle-end/29335\n\t* builtins.c (fold_builtin_cbrt, fold_builtin_logarithm):\n\tCalculate compile-time constants using MPFR.\n\t(fold_builtin_1): Likewise handle BUILT_IN_ERF, BUILT_IN_ERFC,\n\tBUILT_IN_EXPM1 and BUILT_IN_LOG1P.\n\t\ntestsuite:\n\t* gcc.dg/torture/builtin-math-2.c (TESTIT): Use new helper macro.\n\tAdd checks for log, log2, log10 and log1p.\n\n\t* gcc.dg/torture/builtin-math-3.c: Add checks for -0.0 everywhere\n\twe already test 0.0.  Add checks for expm1, log, log2, log10,\n\tlog1p, cbrt, erf and erfc.\n\nFrom-SVN: r118042", "tree": {"sha": "bcb317eaa0092ea0dc3d9db35118efcd9c04bc92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcb317eaa0092ea0dc3d9db35118efcd9c04bc92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/comments", "author": null, "committer": null, "parents": [{"sha": "4f0abdc91b8f1174b3dbd3660761e09b93e6d997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0abdc91b8f1174b3dbd3660761e09b93e6d997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0abdc91b8f1174b3dbd3660761e09b93e6d997"}], "stats": {"total": 260, "additions": 184, "deletions": 76}, "files": [{"sha": "c28bd899a010ecd7d17a789f9fb9eee8b04d3c5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "patch": "@@ -1,3 +1,11 @@\n+2006-10-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/29335\n+\t* builtins.c (fold_builtin_cbrt, fold_builtin_logarithm):\n+\tCalculate compile-time constants using MPFR.\n+\t(fold_builtin_1): Likewise handle BUILT_IN_ERF, BUILT_IN_ERFC,\n+\tBUILT_IN_EXPM1 and BUILT_IN_LOG1P.\n+\n 2006-10-25  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/lib2funcs.S: Use C-style comments."}, {"sha": "694185d73ad7856b869ecba903b5dcb560935ff8", "filename": "gcc/builtins.c", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "patch": "@@ -7110,13 +7110,14 @@ fold_builtin_cbrt (tree arglist, tree type)\n {\n   tree arg = TREE_VALUE (arglist);\n   const enum built_in_function fcode = builtin_mathfn_code (arg);\n+  tree res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n \n-  /* Optimize cbrt of constant value.  */\n-  if (real_zerop (arg) || real_onep (arg) || real_minus_onep (arg))\n-    return arg;\n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpfr_arg1 (arg, type, mpfr_cbrt, NULL, NULL, 0)))\n+    return res;\n \n   if (flag_unsafe_math_optimizations)\n     {\n@@ -7203,7 +7204,8 @@ fold_builtin_cbrt (tree arglist, tree type)\n static tree\n fold_builtin_cos (tree arglist, tree type, tree fndecl)\n {\n-  tree arg = TREE_VALUE (arglist), res;\n+  tree arg = TREE_VALUE (arglist);\n+  tree res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n@@ -7229,7 +7231,8 @@ static tree\n fold_builtin_tan (tree arglist, tree type)\n {\n   enum built_in_function fcode;\n-  tree arg = TREE_VALUE (arglist), res;\n+  tree arg = TREE_VALUE (arglist);\n+  tree res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n@@ -7552,45 +7555,46 @@ real_dconstp (tree expr, const REAL_VALUE_TYPE *value)\n }\n \n /* A subroutine of fold_builtin to fold the various logarithmic\n-   functions.  EXP is the CALL_EXPR of a call to a builtin logN\n-   function.  VALUE is the base of the logN function.  */\n+   functions.  Return NULL_TREE if no simplification can me made.\n+   FUNC is the corresponding MPFR logarithm function.  */\n \n static tree\n fold_builtin_logarithm (tree fndecl, tree arglist,\n-\t\t\tconst REAL_VALUE_TYPE *value)\n+\t\t\tint (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t))\n {\n   if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     {\n       tree type = TREE_TYPE (TREE_TYPE (fndecl));\n       tree arg = TREE_VALUE (arglist);\n+      tree res;\n       const enum built_in_function fcode = builtin_mathfn_code (arg);\n \n-      /* Optimize logN(1.0) = 0.0.  */\n-      if (real_onep (arg))\n-\treturn build_real (type, dconst0);\n-\n-      /* Optimize logN(N) = 1.0.  If N can't be truncated to MODE\n-\t exactly, then only do this if flag_unsafe_math_optimizations.  */\n-      if (exact_real_truncate (TYPE_MODE (type), value)\n-\t  || flag_unsafe_math_optimizations)\n-\t{\n-\t  const REAL_VALUE_TYPE value_truncate =\n-\t    real_value_truncate (TYPE_MODE (type), *value);\n-\t  if (real_dconstp (arg, &value_truncate))\n+      /* Optimize log(e) = 1.0.  We're never passed an exact 'e',\n+\t instead we'll look for 'e' truncated to MODE.  So only do\n+\t this if flag_unsafe_math_optimizations is set.  */\n+      if (flag_unsafe_math_optimizations && func == mpfr_log)\n+        {\n+\t  const REAL_VALUE_TYPE e_truncated =\n+\t    real_value_truncate (TYPE_MODE (type), dconste);\n+\t  if (real_dconstp (arg, &e_truncated))\n \t    return build_real (type, dconst1);\n \t}\n \n+      /* Calculate the result when the argument is a constant.  */\n+      if ((res = do_mpfr_arg1 (arg, type, func, &dconst0, NULL, false)))\n+\treturn res;\n+\n       /* Special case, optimize logN(expN(x)) = x.  */\n       if (flag_unsafe_math_optimizations\n-\t  && ((value == &dconste\n+\t  && ((func == mpfr_log\n \t       && (fcode == BUILT_IN_EXP\n \t\t   || fcode == BUILT_IN_EXPF\n \t\t   || fcode == BUILT_IN_EXPL))\n-\t      || (value == &dconst2\n+\t      || (func == mpfr_log2\n \t\t  && (fcode == BUILT_IN_EXP2\n \t\t      || fcode == BUILT_IN_EXP2F\n \t\t      || fcode == BUILT_IN_EXP2L))\n-\t      || (value == &dconst10 && (BUILTIN_EXP10_P (fcode)))))\n+\t      || (func == mpfr_log10 && (BUILTIN_EXP10_P (fcode)))))\n \treturn fold_convert (type, TREE_VALUE (TREE_OPERAND (arg, 1)));\n \n       /* Optimize logN(func()) for various exponential functions.  We\n@@ -7869,7 +7873,8 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n   if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     {\n       tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-      tree arg = TREE_VALUE (arglist), res;\n+      tree arg = TREE_VALUE (arglist);\n+      tree res;\n       \n       /* Calculate the result when the argument is a constant.  */\n       if ((res = do_mpfr_arg1 (arg, type, func, NULL, NULL, 0)))\n@@ -9040,6 +9045,18 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n \t\t\t     NULL, NULL, 0);\n     break;\n \n+    CASE_FLT_FN (BUILT_IN_ERF):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_erf,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_ERFC):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_erfc,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n     CASE_FLT_FN (BUILT_IN_EXP):\n       return fold_builtin_exponent (fndecl, arglist, mpfr_exp);\n \n@@ -9050,14 +9067,26 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     CASE_FLT_FN (BUILT_IN_POW10):\n       return fold_builtin_exponent (fndecl, arglist, mpfr_exp10);\n \n+    CASE_FLT_FN (BUILT_IN_EXPM1):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_expm1,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+ \n     CASE_FLT_FN (BUILT_IN_LOG):\n-      return fold_builtin_logarithm (fndecl, arglist, &dconste);\n+      return fold_builtin_logarithm (fndecl, arglist, mpfr_log);\n \n     CASE_FLT_FN (BUILT_IN_LOG2):\n-      return fold_builtin_logarithm (fndecl, arglist, &dconst2);\n+      return fold_builtin_logarithm (fndecl, arglist, mpfr_log2);\n \n     CASE_FLT_FN (BUILT_IN_LOG10):\n-      return fold_builtin_logarithm (fndecl, arglist, &dconst10);\n+      return fold_builtin_logarithm (fndecl, arglist, mpfr_log10);\n+\n+    CASE_FLT_FN (BUILT_IN_LOG1P):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_log1p,\n+\t\t\t     &dconstm1, NULL, false);\n+    break;\n \n     CASE_FLT_FN (BUILT_IN_POW):\n       return fold_builtin_pow (fndecl, arglist, type);"}, {"sha": "b90afcc3de2fd2fc56e4e36f81b2f00774e70735", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "patch": "@@ -1,3 +1,12 @@\n+2006-10-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-2.c (TESTIT): Use new helper macro.\n+\tAdd checks for log, log2, log10 and log1p.\n+\n+\t* gcc.dg/torture/builtin-math-3.c: Add checks for -0.0 everywhere\n+\twe already test 0.0.  Add checks for expm1, log, log2, log10,\n+\tlog1p, cbrt, erf and erfc.\n+\n 2006-10-25  Steve Ellcey  <sje@cup.hp.com>\n \n \t* gcc.dg/pthread-init-2.c: Define _POSIX_C_SOURCE on ia64 HP-UX."}, {"sha": "8545600a1957e0c9d3b9ac7dd10b718d6e2f58f6", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-2.c", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c?ref=cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "patch": "@@ -12,6 +12,12 @@ extern void foof (float);\n extern void foo (double);\n extern void fool (long double);\n \n+#define TESTIT(FUNC, ARG) do { \\\n+  foof (__builtin_##FUNC##f (ARG##F)); \\\n+  foo (__builtin_##FUNC (ARG)); \\\n+  fool (__builtin_##FUNC##l (ARG##L)); \\\n+} while (0)\n+\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n@@ -28,68 +34,55 @@ void bar()\n   fool (__builtin_exp2l (-__builtin_infl()));\n \n   /* Result overflows MPFR, which in version 2.2.x has 30 exponent bits.  */\n-  foof (__builtin_exp2f (0x1p50F));\n-  foo (__builtin_exp2 (0x1p50));\n-  fool (__builtin_exp2l (0x1p50L));\n+  TESTIT (exp2, 0x1p50);\n   /* Result underflows MPFR, which in version 2.2.x has 30 exponent bits.  */\n-  foof (__builtin_exp2f (-0x1p50F));\n-  foo (__builtin_exp2 (-0x1p50));\n-  fool (__builtin_exp2l (-0x1p50L));\n+  TESTIT (exp2, -0x1p50);\n \n   /* Result overflows GCC's REAL_VALUE_TYPE, which has 26 exponent bits.  */\n-  foof (__builtin_exp2f (0x1p28F));\n-  foo (__builtin_exp2 (0x1p28));\n-  fool (__builtin_exp2l (0x1p28L));\n+  TESTIT (exp2, 0x1p28);\n   /* Result underflows GCC's REAL_VALUE_TYPE, which has 26 exponent bits.  */\n-  foof (__builtin_exp2f (-0x1p28F));\n-  foo (__builtin_exp2 (-0x1p28));\n-  fool (__builtin_exp2l (-0x1p28L));\n-\n+  TESTIT (exp2, -0x1p28);\n+  \n   /* Result overflows (even an extended) C double's mode.  */\n-  foof (__builtin_exp2f (0x1p24F));\n-  foo (__builtin_exp2 (0x1p24));\n-  fool (__builtin_exp2l (0x1p24L));\n+  TESTIT (exp2, 0x1p24);\n   /* Result underflows (even an extended) C double's mode.  */\n-  foof (__builtin_exp2f (-0x1p24F));\n-  foo (__builtin_exp2 (-0x1p24));\n-  fool (__builtin_exp2l (-0x1p24L));\n+  TESTIT (exp2, -0x1p24);\n \n   /* Ensure that normal arguments/results are folded.  */\n-  foof (__builtin_exp2f (1.5F));\n-  foo (__builtin_exp2 (1.5));\n-  fool (__builtin_exp2l (1.5L));\n-  foof (__builtin_exp2f (-1.5F));\n-  foo (__builtin_exp2 (-1.5));\n-  fool (__builtin_exp2l (-1.5L));\n-\n+  TESTIT (exp2, 1.5);\n+  TESTIT (exp2, -1.5);\n+  \n   /* The asin arg must be [-1 ... 1] inclusive.  */\n-  foof (__builtin_asinf (-1.5F));\n-  foof (__builtin_asinf (1.5F));\n-  foo (__builtin_asin (-1.5));\n-  foo (__builtin_asin (1.5));\n-  fool (__builtin_asinl (-1.5L));\n-  fool (__builtin_asinl (1.5L));\n+  TESTIT (asin, -1.5);\n+  TESTIT (asin, 1.5);\n \n   /* The acos arg must be [-1 ... 1] inclusive.  */\n-  foof (__builtin_acosf (-1.5F));\n-  foof (__builtin_acosf (1.5F));\n-  foo (__builtin_acos (-1.5));\n-  foo (__builtin_acos (1.5));\n-  fool (__builtin_acosl (-1.5L));\n-  fool (__builtin_acosl (1.5L));\n-\n+  TESTIT (acos, -1.5);\n+  TESTIT (acos, 1.5);\n+  \n   /* The acosh arg must be [1 ... Inf] inclusive.  */\n-  foof (__builtin_acoshf (0.5F));\n-  foo (__builtin_acosh (0.5));\n-  fool (__builtin_acoshl (0.5L));\n+  TESTIT (acosh, 0.5);\n+\n+  /* The atanh arg must be [-1 ... 1] EXclusive.  */\n+  TESTIT (atanh, -1.0);\n+  TESTIT (atanh, 1.0);\n \n-  /* The atanh arg must be [-1 ... 1] exclusive.  */\n-  foof (__builtin_atanhf (-1.0F));\n-  foof (__builtin_atanhf (1.0F));\n-  foo (__builtin_atanh (-1.0));\n-  foo (__builtin_atanh (1.0));\n-  fool (__builtin_atanhl (-1.0L));\n-  fool (__builtin_atanhl (1.0L));\n+  /* The log* arg must be [0 ... Inf] EXclusive.  */\n+  TESTIT (log, -1.0);\n+  TESTIT (log, 0.0);\n+  TESTIT (log, -0.0);\n+  \n+  TESTIT (log2, -1.0);\n+  TESTIT (log2, 0.0);\n+  TESTIT (log2, -0.0);\n+  \n+  TESTIT (log10, -1.0);\n+  TESTIT (log10, 0.0);\n+  TESTIT (log10, -0.0);\n+  \n+  /* The log1p arg must be [-1 ... Inf] EXclusive.  */\n+  TESTIT (log1p, -2.0);\n+  TESTIT (log1p, -1.0);\n }\n \n /* { dg-final { scan-tree-dump-times \"exp2 \" 9 \"original\" } } */\n@@ -107,4 +100,16 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"atanh \" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"atanhf\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"atanhl\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log \" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"logf\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"logl\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log2 \" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log2f\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log2l\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log10 \" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log10f\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log10l\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log1p \" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log1pf\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"log1pl\" 2 \"original\" } } */\n /* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "e3c9e98b657286e1010fc0e63513e694d57b9b67", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-3.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1491f0e56e3d6ad918347fd05a2f953c9eede2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c?ref=cf1491f0e56e3d6ad918347fd05a2f953c9eede2", "patch": "@@ -7,6 +7,9 @@\n \n /* { dg-do link } */\n \n+/* Define \"e\" with as many bits as found in builtins.c:dconste.  */\n+#define M_E  2.7182818284590452353602874713526624977572470936999595749669676277241\n+\n /* All references to link_error should go away at compile-time.  */\n extern void link_error(int);\n \n@@ -34,66 +37,120 @@ int main (void)\n {\n   TESTIT2 (asin, -1.0, -3.15/2.0, -3.14/2.0); /* asin(-1) == -pi/2 */\n   TESTIT (asin, 0.0, 0.0); /* asin(0) == 0 */\n+  TESTIT (asin, -0.0, -0.0); /* asin(-0) == -0 */\n   TESTIT2 (asin, 1.0, 3.14/2.0, 3.15/2.0); /* asin(1) == pi/2 */\n \n   TESTIT2 (acos, -1.0, 3.14, 3.15); /* acos(-1) == pi */\n   TESTIT2 (acos, 0.0, 3.14/2.0, 3.15/2.0); /* acos(0) == pi/2 */\n+  TESTIT2 (acos, -0.0, 3.14/2.0, 3.15/2.0); /* acos(-0) == pi/2 */\n   TESTIT (acos, 1.0, 0.0); /* acos(1) == 0 */\n \n   TESTIT2 (atan, -1.0, -3.15/4.0, -3.14/4.0); /* atan(-1) == -pi/4 */\n   TESTIT (atan, 0.0, 0.0); /* atan(0) == 0 */\n+  TESTIT (atan, -0.0, -0.0); /* atan(-0) == -0 */\n   TESTIT2 (atan, 1.0, 3.14/4.0, 3.15/4.0); /* atan(1) == pi/4 */\n \n   TESTIT2 (asinh, -1.0, -0.89, -0.88); /* asinh(-1) == -0.881... */\n   TESTIT (asinh, 0.0, 0.0); /* asinh(0) == 0 */\n+  TESTIT (asinh, -0.0, -0.0); /* asinh(-0) == -0 */\n   TESTIT2 (asinh, 1.0, 0.88, 0.89); /* asinh(1) == 0.881... */\n \n   TESTIT (acosh, 1.0, 0.0); /* acosh(1) == 0. */\n   TESTIT2 (acosh, 2.0, 1.31, 1.32); /* acosh(2) == 1.316... */\n \n   TESTIT2 (atanh, -0.5, -0.55, -0.54); /* atanh(-0.5) == -0.549... */\n   TESTIT (atanh, 0.0, 0.0); /* atanh(0) == 0 */\n+  TESTIT (atanh, -0.0, -0.0); /* atanh(-0) == -0 */\n   TESTIT2 (atanh, 0.5, 0.54, 0.55); /* atanh(0.5) == 0.549... */\n \n   TESTIT2 (sin, -1.0, -0.85, -0.84); /* sin(-1) == -0.841... */\n   TESTIT (sin, 0.0, 0.0); /* sin(0) == 0 */\n+  TESTIT (sin, -0.0, -0.0); /* sin(-0) == -0 */\n   TESTIT2 (sin, 1.0, 0.84, 0.85); /* sin(1) == 0.841... */\n \n   TESTIT2 (cos, -1.0, 0.54, 0.55); /* cos(-1) == 0.5403... */\n   TESTIT (cos, 0.0, 1.0); /* cos(0) == 1 */\n+  TESTIT (cos, -0.0, 1.0); /* cos(-0) == 1 */\n   TESTIT2 (cos, 1.0, 0.54, 0.55); /* cos(1) == 0.5403... */\n \n   TESTIT2 (tan, -1.0, -1.56, 1.55); /* tan(-1) == -1.557... */\n   TESTIT (tan, 0.0, 0.0); /* tan(0) == 0 */\n+  TESTIT (tan, -0.0, -0.0); /* tan(-0) == -0 */\n   TESTIT2 (tan, 1.0, 1.55, 1.56); /* tan(1) == 1.557... */\n \n   TESTIT2 (sinh, -1.0, -1.18, -1.17); /* sinh(-1) == -1.175... */\n   TESTIT (sinh, 0.0, 0.0); /* sinh(0) == 0 */\n+  TESTIT (sinh, -0.0, -0.0); /* sinh(-0) == -0 */\n   TESTIT2 (sinh, 1.0, 1.17, 1.18); /* sinh(1) == 1.175... */\n \n   TESTIT2 (cosh, -1.0, 1.54, 1.55); /* cosh(-1) == 1.543... */\n   TESTIT (cosh, 0.0, 1.0); /* cosh(0) == 1 */\n+  TESTIT (cosh, -0.0, 1.0); /* cosh(-0) == 1 */\n   TESTIT2 (cosh, 1.0, 1.54, 1.55); /* cosh(1) == 1.543... */\n \n   TESTIT2 (tanh, -1.0, -0.77, -0.76); /* tanh(-1) == -0.761... */\n+  TESTIT (tanh, -0.0, -0.0); /* tanh(-0) == -0 */\n   TESTIT (tanh, 0.0, 0.0); /* tanh(0) == 0 */\n   TESTIT2 (tanh, 1.0, 0.76, 0.77); /* tanh(1) == 0.761... */\n \n   TESTIT2 (exp, -1.0, 0.36, 0.37); /* exp(-1) == 1/e */\n+  TESTIT (exp, -0.0, 1.0); /* exp(-0) == 1 */\n   TESTIT (exp, 0.0, 1.0); /* exp(0) == 1 */\n   TESTIT2 (exp, 1.0, 2.71, 2.72); /* exp(1) == e */\n \n   TESTIT (exp2, -1.0, 0.5); /* exp2(-1) == 1/2 */\n+  TESTIT (exp2, -0.0, 1.0); /* exp2(-0) == 1 */\n   TESTIT (exp2, 0.0, 1.0); /* exp2(0) == 1 */\n   TESTIT (exp2, 1.0, 2.0); /* exp2(1) == 2 */\n \n   TESTIT (exp10, -1.0, 0.1); /* exp10(-1) == 1/10 */\n+  TESTIT (exp10, -0.0, 1.0); /* exp10(-0) == 1 */\n   TESTIT (exp10, 0.0, 1.0); /* exp10(0) == 1 */\n   TESTIT (exp10, 1.0, 10.0); /* exp10(1) == 10 */\n \n   TESTIT (pow10, -1.0, 0.1); /* pow10(-1) == 1/10 */\n+  TESTIT (pow10, -0.0, 1.0); /* pow10(-0) == 1 */\n   TESTIT (pow10, 0.0, 1.0); /* pow10(0) == 1 */\n   TESTIT (pow10, 1.0, 10.0); /* pow10(1) == 10 */\n \n+  TESTIT2 (expm1, -1.0, -0.64, -0.63); /* expm1(-1) == 1/e - 1 */\n+  TESTIT (expm1, -0.0, -0.0); /* expm1(-0) == 0 */\n+  TESTIT (expm1, 0.0, 0.0); /* expm1(0) == 0 */\n+  TESTIT2 (expm1, 1.0, 1.71, 1.72); /* expm1(1) == e - 1 */\n+\n+  TESTIT (log, 1.0, 0.0); /* log(1) == 0 */\n+  TESTIT2 (log, M_E, 0.99, 1.01); /* log(e) == 1.000... */\n+  TESTIT2 (log, M_E*M_E, 1.99, 2.01); /* log(e*e) == 2.000... */\n+\n+  TESTIT (log2, 1.0, 0.0); /* log2(1) == 0 */\n+  TESTIT (log2, 2.0, 1.0); /* log2(2) == 1 */\n+  TESTIT (log2, 4.0, 2.0); /* log2(4) == 2 */\n+\n+  TESTIT (log10, 1.0, 0.0); /* log10(1) == 0 */\n+  TESTIT (log10, 10.0, 1.0); /* log10(10) == 1 */\n+  TESTIT (log10, 100.0, 2.0); /* log10(100) == 2 */\n+\n+  TESTIT (log1p, 0.0, 0.0); /* log1p(0) == 0 */\n+  TESTIT (log1p, -0.0, -0.0); /* log1p(-0) == -0 */\n+  TESTIT2 (log1p, M_E-1, 0.99, 1.01); /* log1p(e-1) == 1.000... */\n+  TESTIT2 (log1p, M_E*M_E-1, 1.99, 2.01); /* log1p(e*e-1) == 2.000... */\n+\n+  TESTIT (cbrt, -0.0, -0.0); /* cbrt(-0) == -0 */\n+  TESTIT (cbrt, 0.0, 0.0); /* cbrt(0) == 0 */\n+  TESTIT (cbrt, 1.0, 1.0); /* cbrt(1) == 1 */\n+  TESTIT (cbrt, -1.0, -1.0); /* cbrt(-1) == -1 */\n+  TESTIT (cbrt, 8.0, 2.0); /* cbrt(8) == 2 */\n+  TESTIT (cbrt, -8.0, -2.0); /* cbrt(-8) == -2 */\n+\n+  TESTIT (erf, -0.0, -0.0); /* erf(-0) == -0 */\n+  TESTIT (erf, 0.0, 0.0); /* erf(0) == 0 */\n+  TESTIT2 (erf, 1.0, 0.84, 0.85); /* erf(1) == 0.842... */\n+  TESTIT2 (erf, -1.0, -0.85, -0.84); /* erf(-1) == -0.842... */\n+\n+  TESTIT (erfc, -0.0, 1.0); /* erfc(-0) == 1 */\n+  TESTIT (erfc, 0.0, 1.0); /* erfc(0) == 1 */\n+  TESTIT2 (erfc, 1.0, 0.15, 0.16); /* erfc(1) == 0.157... */\n+  TESTIT2 (erfc, -1.0, 1.84, 1.85); /* erfc(-1) == 1.842... */\n+\n   return 0;\n }"}]}