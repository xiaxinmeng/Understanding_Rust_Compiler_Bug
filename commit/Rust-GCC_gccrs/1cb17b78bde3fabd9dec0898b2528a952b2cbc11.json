{"sha": "1cb17b78bde3fabd9dec0898b2528a952b2cbc11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiMTdiNzhiZGUzZmFiZDlkZWMwODk4YjI1MjhhOTUyYjJjYmMxMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-01T09:04:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-01T09:04:06Z"}, "message": "sem_ch4.adb (Analyze_One_Call): Handle complex overloading of a procedure call whose prefix is a parameterless...\n\n2008-08-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_One_Call): Handle complex overloading of a\n\tprocedure call whose prefix\n\tis a parameterless function call that returns an access_to_procedure.\n\nFrom-SVN: r138491", "tree": {"sha": "ded38177fe761487895f0f33295bf1900cef6564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ded38177fe761487895f0f33295bf1900cef6564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cb17b78bde3fabd9dec0898b2528a952b2cbc11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb17b78bde3fabd9dec0898b2528a952b2cbc11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb17b78bde3fabd9dec0898b2528a952b2cbc11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb17b78bde3fabd9dec0898b2528a952b2cbc11/comments", "author": null, "committer": null, "parents": [{"sha": "d54c4e31c27f21d3555ed2f093f82736f82772b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54c4e31c27f21d3555ed2f093f82736f82772b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54c4e31c27f21d3555ed2f093f82736f82772b7"}], "stats": {"total": 93, "additions": 88, "deletions": 5}, "files": [{"sha": "90015c480b809bb65326c14198e7bba5761f82c9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb17b78bde3fabd9dec0898b2528a952b2cbc11/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb17b78bde3fabd9dec0898b2528a952b2cbc11/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1cb17b78bde3fabd9dec0898b2528a952b2cbc11", "patch": "@@ -1,3 +1,66 @@\n+2008-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb (Process_PPCs): Don't copy spec PPC to body if not\n+\tgenerating code\n+\n+2008-08-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* checks.adb (Apply_Float_Conversion_Check): If the expression to be\n+\tconverted is a real literal and the target type has static bounds,\n+\tperform the conversion exactly to prevent floating-point anomalies on\n+\tsome targets.\n+\n+2008-08-01  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-attr.adb: New attribute Compiler'Name_Syntax (<lang>)\n+\t\n+\t* prj-nmsc.adb (Process_Compiler): Recognize attribute Name_Syntax\n+\t\n+\t* prj.adb (Object_Exist_For): Use Object_Generated, not\n+\tObjects_Generated that is removed and was never modified anyway.\n+\n+\t* prj.ads:\n+\t(Path_Syntax_Kind): New enumeration type\n+\t(Language_Config): New component Path_Syntax, defaulted to Host.\n+\tComponents PIC_Option and Objects_Generated removed, as they are not\n+\tused.\n+\n+\t* snames.adb: New standard name Path_Syntax\n+\t\n+\t* snames.ads: New standard name Path_Syntax\n+\n+2008-08-01  Vincent Celier  <celier@adacore.com>\n+\n+\t* mlib-utl.adb:\n+\t(Adalib_Path): New variable to store the path of the adalib directory\n+\twhen procedure Specify_Adalib_Dir is called.\n+\t(Lib_Directory): If Adalib_Path is not null, return its value\n+\t(Specify_Adalib_Dir): New procedure\n+\t\n+\t* mlib-utl.ads (Specify_Adalib_Dir): New procedure\n+\n+2008-08-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb:\n+\t(Check_Precondition_Postcondition): If not generating code, analyze the\n+\texpression in a postcondition that appears in a subprogram body, so that\n+\tit is properly decorated for ASIS use.\n+\n+2008-08-01  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Remove ugly special-case code that resets\n+\tOrig_Prev to Prev in the case where the actual is N_Function_Call or\n+\tN_Identifier. This was interfering with other cases that are rewritten\n+\tas N_Identifier, such as allocators, resulting in passing of the wrong\n+\taccessibility level, and based on testing this code is apparently no\n+\tlonger needed at all.\n+\n+2008-08-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_One_Call): Handle complex overloading of a\n+\tprocedure call whose prefix\n+\tis a parameterless function call that returns an access_to_procedure.\n+\n 2008-08-01  Jose Ruiz  <ruiz@adacore.com>\n \n \t* adaint.c (__gnat_tmp_name): Refine the generation of temporary names"}, {"sha": "128ba5a2ee2ff2a48023f554d0911119d54b5d2c", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb17b78bde3fabd9dec0898b2528a952b2cbc11/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb17b78bde3fabd9dec0898b2528a952b2cbc11/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=1cb17b78bde3fabd9dec0898b2528a952b2cbc11", "patch": "@@ -688,6 +688,9 @@ package body Sem_Ch4 is\n       X       : Interp_Index;\n       It      : Interp;\n       Nam_Ent : Entity_Id;\n+      Deref   : Boolean := False;\n+      --  Flag indicates whether an interpretation of the prefix is a\n+      --  parameterless call that returns an access_to_subprogram.\n       Success : Boolean := False;\n \n       function Name_Denotes_Function return Boolean;\n@@ -874,6 +877,7 @@ package body Sem_Ch4 is\n \n          while Present (It.Nam) loop\n             Nam_Ent := It.Nam;\n+            Deref   := False;\n \n             --  Name may be call that returns an access to subprogram, or more\n             --  generally an overloaded expression one of whose interpretations\n@@ -888,11 +892,17 @@ package body Sem_Ch4 is\n                Nam_Ent := Designated_Type (Nam_Ent);\n \n             elsif Is_Access_Type (Etype (Nam_Ent))\n-              and then not Is_Entity_Name (Nam)\n+              and then\n+                (not Is_Entity_Name (Nam)\n+                   or else Nkind (N) = N_Procedure_Call_Statement)\n               and then Ekind (Designated_Type (Etype (Nam_Ent)))\n                                                           = E_Subprogram_Type\n             then\n                Nam_Ent := Designated_Type (Etype (Nam_Ent));\n+\n+               if Is_Entity_Name (Nam) then\n+                  Deref := True;\n+               end if;\n             end if;\n \n             Analyze_One_Call (N, Nam_Ent, False, Success);\n@@ -904,7 +914,16 @@ package body Sem_Ch4 is\n             --  guation is done directly in Resolve.\n \n             if Success then\n-               Set_Etype (Nam, It.Typ);\n+               if Deref\n+                 and then Nkind (Parent (N)) /= N_Explicit_Dereference\n+               then\n+                  Set_Entity (Nam, It.Nam);\n+                  Insert_Explicit_Dereference (Nam);\n+                  Set_Etype (Nam, Nam_Ent);\n+\n+               else\n+                  Set_Etype (Nam, It.Typ);\n+               end if;\n \n             elsif Nkind_In (Name (N), N_Selected_Component,\n                                       N_Function_Call)\n@@ -1480,14 +1499,15 @@ package body Sem_Ch4 is\n         and then Is_Overloaded (N)\n       then\n          --  The prefix may include access to subprograms and other access\n-         --  types. If the context selects the interpretation that is a call,\n-         --  we cannot rewrite the node yet, but we include the result of\n-         --  the call interpretation.\n+         --  types. If the context selects the interpretation that is a\n+         --  function  call (not a procedure call) we cannot rewrite the\n+         --  node yet, but we include the result of the call interpretation.\n \n          Get_First_Interp (N, I, It);\n          while Present (It.Nam) loop\n             if Ekind (Base_Type (It.Typ)) = E_Subprogram_Type\n                and then Etype (Base_Type (It.Typ)) /= Standard_Void_Type\n+               and then Nkind (Parent (N)) /= N_Procedure_Call_Statement\n             then\n                Add_One_Interp (N, Etype (It.Typ), Etype (It.Typ));\n             end if;"}]}