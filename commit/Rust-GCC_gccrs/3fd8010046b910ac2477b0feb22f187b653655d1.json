{"sha": "3fd8010046b910ac2477b0feb22f187b653655d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkODAxMDA0NmI5MTBhYzI0NzdiMGZlYjIyZjE4N2I2NTM2NTVkMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-01-10T19:39:26Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-01-10T19:39:26Z"}, "message": "PR libgcj/12016, PR libgcj/18405, PR libgcj/17738:\n\n\t* java/lang/Package.java (getPackages): Use VMClassLoader when\n\tappropriate.\n\t(getPackage): Likewise.\n\t* prims.cc (_Jv_CreateJavaVM): Call\n\t_Jv_RegisterBootstrapPackages.\n\t* include/jvm.h (_Jv_RegisterBootstrapPackages): Declare.\n\t* java/lang/VMClassLoader.java (getPackage): Rewrote.\n\t(getPackages): Likewise.\n\t(definedPackages): New field.\n\t(definePackageForNative): New method.\n\t* java/lang/Class.h (_Jv_FindClassInCache): Updated.\n\t* java/lang/natVMClassLoader.cc (loadClass): Updated.\n\t* defineclass.cc (handleClassBegin): Use\n\tClassLoader.findLoadedClass.\n\t* java/lang/natClassLoader.cc (_Jv_RegisterInitiatingLoader):\n\tRewrote.\n\t(struct _Jv_LoaderInfo): Removed.\n\t(initiated_classes): Likewise.\n\t(_Jv_UnregisterClass): Don't use initiated_classes.\n\t(_Jv_FindClassInCache): Likewise.  Removed 'loader' argument.\n\t(_Jv_FindClass): Register classes found during boostrap.\n\t(BOOTSTRAP_CLASS_LIST_SIZE): New define.\n\t(bootstrap_class_list): New global.\n\t(bootstrap_index): Likewise.\n\t(_Jv_RegisterBootstrapPackages): New function.\n\t* gnu/gcj/runtime/natVMClassLoader.cc (findClass): Call\n\tdefinePackageForNative.\n\t(findClass): Updated.\n\t* gnu/gcj/runtime/VMClassLoader.java (definePackageForNative):\n\tNew method.\n\nFrom-SVN: r93155", "tree": {"sha": "966d2f436ef2b2ebadf80447ac97eca99afd09f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/966d2f436ef2b2ebadf80447ac97eca99afd09f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd8010046b910ac2477b0feb22f187b653655d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd8010046b910ac2477b0feb22f187b653655d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd8010046b910ac2477b0feb22f187b653655d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd8010046b910ac2477b0feb22f187b653655d1/comments", "author": null, "committer": null, "parents": [{"sha": "2f2bc52472b9fee4d0dd20044e9d41ece39ba4cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2bc52472b9fee4d0dd20044e9d41ece39ba4cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2bc52472b9fee4d0dd20044e9d41ece39ba4cb"}], "stats": {"total": 265, "additions": 159, "deletions": 106}, "files": [{"sha": "a1b28a63546ed316142bb8d76ef2a57126aacb26", "filename": "libjava/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,3 +1,37 @@\n+2005-01-10  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/12016, PR libgcj/18405, PR libgcj/17738:\n+\t* java/lang/Package.java (getPackages): Use VMClassLoader when\n+\tappropriate.\n+\t(getPackage): Likewise.\n+\t* prims.cc (_Jv_CreateJavaVM): Call\n+\t_Jv_RegisterBootstrapPackages.\n+\t* include/jvm.h (_Jv_RegisterBootstrapPackages): Declare.\n+\t* java/lang/VMClassLoader.java (getPackage): Rewrote.\n+\t(getPackages): Likewise.\n+\t(definedPackages): New field.\n+\t(definePackageForNative): New method.\n+\t* java/lang/Class.h (_Jv_FindClassInCache): Updated.\n+\t* java/lang/natVMClassLoader.cc (loadClass): Updated.\n+\t* defineclass.cc (handleClassBegin): Use\n+\tClassLoader.findLoadedClass.\n+\t* java/lang/natClassLoader.cc (_Jv_RegisterInitiatingLoader):\n+\tRewrote.\n+\t(struct _Jv_LoaderInfo): Removed.\n+\t(initiated_classes): Likewise.\n+\t(_Jv_UnregisterClass): Don't use initiated_classes.\n+\t(_Jv_FindClassInCache): Likewise.  Removed 'loader' argument.\n+\t(_Jv_FindClass): Register classes found during boostrap.\n+\t(BOOTSTRAP_CLASS_LIST_SIZE): New define.\n+\t(bootstrap_class_list): New global.\n+\t(bootstrap_index): Likewise.\n+\t(_Jv_RegisterBootstrapPackages): New function.\n+\t* gnu/gcj/runtime/natVMClassLoader.cc (findClass): Call\n+\tdefinePackageForNative.\n+\t(findClass): Updated.\n+\t* gnu/gcj/runtime/VMClassLoader.java (definePackageForNative):\n+\tNew method.\n+\n 2005-01-10  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/18868:"}, {"sha": "a40bff1758e89fe4c9ed44a7b4603e6c70e2ac4e", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n // defineclass.cc - defining a class from .class format.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -868,7 +868,7 @@ _Jv_ClassReader::handleClassBegin (int access_flags, int this_class, int super_c\n   // was ClassLoader.defineClass called with an expected class name?\n   if (def->name == 0)\n     {\n-      jclass orig = _Jv_FindClassInCache (loadedName, def->loader);\n+      jclass orig = def->loader->findLoadedClass(loadedName->toString());\n \n       if (orig == 0)\n \t{"}, {"sha": "2d46ebcb770dfaf17f4f93d50fdc7785e565e3ab", "filename": "libjava/gnu/gcj/runtime/VMClassLoader.java", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1999, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -118,6 +118,27 @@ static void initialize ()\n     instance.init();\n   }\n \n+  // Define a package for something loaded natively.\n+  void definePackageForNative(String className)\n+  {\n+    int lastDot = className.lastIndexOf('.');\n+    if (lastDot != -1)\n+      {\n+\tString packageName = className.substring(0, lastDot);\n+\tif (getPackage(packageName) == null)\n+\t  {\n+\t    // FIXME: this assumes we're defining the core, which\n+\t    // isn't necessarily so.  We could detect this and set up\n+\t    // appropriately.  We could also look at a manifest file\n+\t    // compiled into the .so.\n+\t    definePackage(packageName, \"Java Platform API Specification\",\n+\t\t\t  \"GNU\", \"1.4\", \"gcj\", \"GNU\",\n+\t\t\t  null, // FIXME: gcj version.\n+\t\t\t  null);\n+\t  }\n+      }\n+  }\n+\n   // This keeps track of shared libraries we've already tried to load.\n   private HashSet tried_libraries = new HashSet();\n "}, {"sha": "7f2ee34eb32d219898a26f765895e28a2dc2bc38", "filename": "libjava/gnu/gcj/runtime/natVMClassLoader.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatVMClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatVMClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatVMClassLoader.cc?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n // Native code for VMClassLoader\n \n-/* Copyright (C) 2002, 2003  Free Software Foundation\n+/* Copyright (C) 2002, 2003, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -24,7 +24,7 @@ jclass\n gnu::gcj::runtime::VMClassLoader::findClass (jstring name)\n {\n   _Jv_Utf8Const *name_u = _Jv_makeUtf8Const (name);\n-  jclass klass = _Jv_FindClassInCache (name_u, 0);\n+  jclass klass = _Jv_FindClassInCache (name_u);\n \n   if (! klass && lib_control != LIB_NEVER)\n     {\n@@ -65,12 +65,14 @@ gnu::gcj::runtime::VMClassLoader::findClass (jstring name)\n \t    so_base_name = so_base_name->substring (0, nd);\n \n \t  if (loaded)\n-\t    klass = _Jv_FindClassInCache (name_u, 0);\n+\t    klass = _Jv_FindClassInCache (name_u);\n \t}\n     }\n \n-  // Now try loading using the interpreter.\n-  if (! klass)\n+  // Either define the package, or try loading using the interpreter.\n+  if (klass)\n+    definePackageForNative(name);\n+  else\n     klass = java::net::URLClassLoader::findClass (name);\n \n   return klass;"}, {"sha": "d45ef25b6997e962edddb45586f55b4795f6ed29", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -561,4 +561,6 @@ extern void (*_Jv_JVMPI_Notify_THREAD_END) (JVMPI_Event *event);\n /* FIXME: this should really be defined in some more generic place */\n #define ROUND(V, A) (((((unsigned) (V))-1) | ((A)-1))+1)\n \n+extern void _Jv_RegisterBootstrapPackages ();\n+\n #endif /* __JAVA_JVM_H__ */"}, {"sha": "cea1c13a8e2edbe42ff562517be74fb9bdb6a2cb", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n // Class.h - Header file for java.lang.Class.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -215,8 +215,7 @@ void _Jv_RegisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n void _Jv_UnregisterClass (jclass);\n jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t      java::lang::ClassLoader *loader);\n-jclass _Jv_FindClassInCache (_Jv_Utf8Const *name,\n-\t\t\t     java::lang::ClassLoader *loader);\n+jclass _Jv_FindClassInCache (_Jv_Utf8Const *name);\n jclass _Jv_PopClass (void);\n void _Jv_PushClass (jclass k);\n void _Jv_NewArrayClass (jclass element,\n@@ -440,8 +439,7 @@ class java::lang::Class : public java::lang::Object\n   friend void ::_Jv_UnregisterClass (jclass);\n   friend jclass (::_Jv_FindClass) (_Jv_Utf8Const *name,\n \t\t\t\t   java::lang::ClassLoader *loader);\n-  friend jclass (::_Jv_FindClassInCache) (_Jv_Utf8Const *name,\n-\t\t\t\t\t  java::lang::ClassLoader *loader);\n+  friend jclass (::_Jv_FindClassInCache) (_Jv_Utf8Const *name);\n   friend jclass (::_Jv_PopClass) (void);\n   friend void ::_Jv_PushClass (jclass k);\n   friend void ::_Jv_NewArrayClass (jclass element,"}, {"sha": "29b42b63cf12a92d09aef78f627dfe6858d25711", "filename": "libjava/java/lang/Package.java", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FPackage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FPackage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FPackage.java?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,5 +1,5 @@\n /* Package.java -- information about a package\n-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2005 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -274,7 +274,7 @@ public static Package getPackage(String name)\n   {\n     // Get the caller's classloader\n     ClassLoader cl = VMSecurityManager.currentClassLoader();\n-    return cl != null ? cl.getPackage(name) : null;\n+    return cl != null ? cl.getPackage(name) : VMClassLoader.getPackage(name);\n   }\n \n   /**\n@@ -288,10 +288,7 @@ public static Package[] getPackages()\n     // Get the caller's classloader\n     Class c = VMSecurityManager.getClassContext()[1];\n     ClassLoader cl = c.getClassLoader();\n-    // Sun's implementation returns the packages loaded by the bootstrap\n-    // classloader if cl is null, but right now our bootstrap classloader\n-    // does not create any Packages.\n-    return cl != null ? cl.getPackages() : new Package[0];\n+    return cl != null ? cl.getPackages() : VMClassLoader.getPackages();\n   }\n \n   /**"}, {"sha": "1afda4570ea363d32a5ab5c2fb47abb0cc385cd2", "filename": "libjava/java/lang/VMClassLoader.java", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n /* VMClassLoader.java -- Reference implementation of native interface\n    required by ClassLoader\n-   Copyright (C) 1998, 2001, 2002, 2003, 2004 Free Software Foundation\n+   Copyright (C) 1998, 2001, 2002, 2003, 2004, 2005 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -76,6 +76,8 @@\n     unknownProtectionDomain = new ProtectionDomain(null, permissions);  \n   }\n \n+  static final HashMap definedPackages = new HashMap();\n+\n   /**\n    * Helper to define a class using a string of bytes. This assumes that\n    * the security checks have already been performed, if necessary.\n@@ -173,9 +175,9 @@ static Enumeration getResources(String name) throws IOException\n    * @param name the name to find\n    * @return the named package, if it exists\n    */\n-  static Package getPackage(String name)\n+  static synchronized Package getPackage(String name)\n   {\n-    return null;\n+    return (Package) definedPackages.get(name);\n   }\n \n   /**\n@@ -185,9 +187,33 @@ static Package getPackage(String name)\n    *\n    * @return all named packages, if any exist\n    */\n-  static Package[] getPackages()\n+  static synchronized Package[] getPackages()\n+  {\n+    Package[] packages = new Package[definedPackages.size()];\n+    return (Package[]) definedPackages.values().toArray(packages);\n+  }\n+\n+  // Define a package for something loaded natively.\n+  static synchronized void definePackageForNative(String className)\n   {\n-    return new Package[0];\n+    int lastDot = className.lastIndexOf('.');\n+    if (lastDot != -1)\n+      {\n+\tString packageName = className.substring(0, lastDot);\n+\tif (getPackage(packageName) == null)\n+\t  {\n+\t    // FIXME: this assumes we're defining the core, which\n+\t    // isn't necessarily so.  We could detect this and set up\n+\t    // appropriately.  We could also look at a manifest file\n+\t    // compiled into the .so.\n+\t    Package p = new Package(packageName,\n+\t\t\t\t    \"Java Platform API Specification\",\n+\t\t\t\t    \"GNU\", \"1.4\", \"gcj\", \"GNU\",\n+\t\t\t\t    null, // FIXME: gcj version.\n+\t\t\t\t    null);\n+\t    definedPackages.put(packageName, p);\n+\t  }\n+      }\n   }\n \n   /**"}, {"sha": "b05c1dd0a5bb9fe40b8d33d79e814d8d22e61185", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 47, "deletions": 79, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n // natClassLoader.cc - Implementation of java.lang.ClassLoader native methods.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -42,76 +42,45 @@ details.  */\n #include <java/lang/StringBuffer.h>\n #include <java/io/Serializable.h>\n #include <java/lang/Cloneable.h>\n-\n-//\n-//  A single class can have many \"initiating\" class loaders,\n-//  and a single \"defining\" class loader.  The Defining\n-//  class loader is what is returned from Class.getClassLoader()\n-//  and is used when loading dependent classes during resolution.\n-//  The set of initiating class loaders are used to ensure\n-//  safety of linking, and is maintained in the hash table\n-//  \"initiated_classes\".  A defining classloader is by definition also\n-//  initiating, so we only store classes in this table if they have more\n-//  than one class loader associated.\n-//\n-\n+#include <java/util/HashMap.h>\n \n // Size of local hash table.\n #define HASH_LEN 1013\n \n // Hash function for Utf8Consts.\n #define HASH_UTF(Utf) ((Utf)->hash16() % HASH_LEN)\n \n-struct _Jv_LoaderInfo\n-{\n-  _Jv_LoaderInfo          *next;\n-  java::lang::Class       *klass;\n-  java::lang::ClassLoader *loader;\n-};\n-\n-static _Jv_LoaderInfo *initiated_classes[HASH_LEN];\n static jclass loaded_classes[HASH_LEN];\n \n // This is the root of a linked list of classes\n static jclass stack_head;\n \n+// While bootstrapping we keep a list of classes we found, so that we\n+// can register their packages.  There aren't many of these so we\n+// just keep a small buffer here and abort if we overflow.\n+#define BOOTSTRAP_CLASS_LIST_SIZE 20\n+static jclass bootstrap_class_list[BOOTSTRAP_CLASS_LIST_SIZE];\n+static int bootstrap_index;\n+\n \n \f\n \n+// This tries to find a class in our built-in cache.  This cache is\n+// used only for classes which are linked in to the executable or\n+// loaded via dlopen().\n jclass\n-_Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n+_Jv_FindClassInCache (_Jv_Utf8Const *name)\n {\n   JvSynchronize sync (&java::lang::Class::class$);\n   jint hash = HASH_UTF (name);\n \n-  if (loader && loader == java::lang::ClassLoader::getSystemClassLoader())\n-    loader = NULL;\n-\n-  // first, if LOADER is a defining loader, then it is also initiating\n   jclass klass;\n   for (klass = loaded_classes[hash]; klass; klass = klass->next)\n     {\n-      if (loader == klass->loader && _Jv_equalUtf8Consts (name, klass->name))\n+      if (_Jv_equalUtf8Consts (name, klass->name))\n \tbreak;\n     }\n \n-  // otherwise, it may be that the class in question was defined\n-  // by some other loader, but that the loading was initiated by \n-  // the loader in question.\n-  if (!klass)\n-    {\n-      _Jv_LoaderInfo *info;\n-      for (info = initiated_classes[hash]; info; info = info->next)\n-\t{\n-\t  if (loader == info->loader\n-\t      && _Jv_equalUtf8Consts (name, info->klass->name))\n-\t    {\n-\t      klass = info->klass;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n   return klass;\n }\n \n@@ -130,38 +99,15 @@ _Jv_UnregisterClass (jclass the_class)\n \t  break;\n \t}\n     }\n-\n-  _Jv_LoaderInfo **info = &(initiated_classes[hash]);\n-  for ( ; ; info = &((*info)->next))\n-    {\n-      while (*info && (*info)->klass == the_class)\n-\t{\n-\t  _Jv_LoaderInfo *old = *info;\n-\t  *info = (*info)->next;\n-\t  _Jv_Free (old);\n-\t}\n-\n-      if (*info == NULL)\n-\tbreak;\n-    }\n }\n \n+// Register an initiating class loader for a given class.\n void\n _Jv_RegisterInitiatingLoader (jclass klass, java::lang::ClassLoader *loader)\n {\n-  if (loader && loader == java::lang::ClassLoader::getSystemClassLoader())\n-    loader = NULL;\n-\n-  // This information can't be visible to the GC.\n-  _Jv_LoaderInfo *info\n-    = (_Jv_LoaderInfo *) _Jv_Malloc (sizeof(_Jv_LoaderInfo));\n-  jint hash = HASH_UTF(klass->name);\n-\n-  JvSynchronize sync (&java::lang::Class::class$);\n-  info->loader = loader;\n-  info->klass  = klass;\n-  info->next   = initiated_classes[hash];\n-  initiated_classes[hash] = info;\n+  if (! loader)\n+    loader = java::lang::ClassLoader::getSystemClassLoader();\n+  loader->loadedClasses->put(klass->name->toString(), klass);\n }\n \n // This function is called many times during startup, before main() is\n@@ -254,15 +200,21 @@ _Jv_RegisterClass (jclass klass)\n jclass\n _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n {\n-  jclass klass = _Jv_FindClassInCache (name, loader);\n+  // See if the class was already loaded by this loader.  This handles\n+  // initiating loader checks, as we register classes with their\n+  // initiating loaders.\n+  java::lang::ClassLoader *sys\n+    = java::lang::ClassLoader::getSystemClassLoader ();\n+  java::lang::ClassLoader *real = loader;\n+  if (! real)\n+    real = sys;\n+  jstring sname = name->toString();\n+  // We might still be bootstrapping the VM, in which case there\n+  // won't be a system class loader yet.\n+  jclass klass = real ? real->findLoadedClass (sname) : NULL;\n \n   if (! klass)\n     {\n-      jstring sname = name->toString();\n-\n-      java::lang::ClassLoader *sys\n-\t= java::lang::ClassLoader::getSystemClassLoader ();\n-\n       if (loader)\n \t{\n \t  // Load using a user-defined loader, jvmspec 5.3.2\n@@ -277,7 +229,7 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t  if (klass && klass->getClassLoaderInternal () != delegate)\n \t    _Jv_RegisterInitiatingLoader (klass, loader);\n \t}\n-      else \n+      else if (sys)\n \t{\n \t  // Load using the bootstrap loader jvmspec 5.3.1.\n \t  klass = sys->loadClass (sname, false); \n@@ -286,6 +238,15 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t  if (klass)\n \t    _Jv_RegisterInitiatingLoader (klass, 0);\n \t}\n+      else\n+\t{\n+\t  // Not even a bootstrap loader, try the built-in cache.\n+\t  klass = _Jv_FindClassInCache (name);\n+\n+\t  if (bootstrap_index == BOOTSTRAP_CLASS_LIST_SIZE)\n+\t    abort ();\n+\t  bootstrap_class_list[bootstrap_index++] = klass;\n+\t}\n     }\n   else\n     {\n@@ -297,6 +258,13 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n   return klass;\n }\n \n+void\n+_Jv_RegisterBootstrapPackages ()\n+{\n+  for (int i = 0; i < bootstrap_index; ++i)\n+    java::lang::VMClassLoader::definePackageForNative(bootstrap_class_list[i]->getName());\n+}\n+\n jclass\n _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n \t      java::lang::ClassLoader *loader)"}, {"sha": "e34be99296dee8771a867d2c2560446e7c3bd435", "filename": "libjava/java/lang/natVMClassLoader.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n // natVMClassLoader.cc - VMClassLoader native methods\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -130,7 +130,7 @@ jclass\n java::lang::VMClassLoader::loadClass(jstring name, jboolean resolve)\n {\n   _Jv_Utf8Const *utf = _Jv_makeUtf8Const (name);\n-  jclass klass = _Jv_FindClassInCache (utf, NULL);\n+  jclass klass = _Jv_FindClassInCache (utf);\n   if (klass)\n     {\n       // We never want to return a class without its supers linked.\n@@ -140,6 +140,9 @@ java::lang::VMClassLoader::loadClass(jstring name, jboolean resolve)\n \t_Jv_InitClass (klass);\n       else\n \t_Jv_Linker::wait_for_state (klass, JV_STATE_LOADING);\n+\n+      definePackageForNative(name);\n     }\n+\n   return klass;\n }"}, {"sha": "ac48d0dd9e3b32564eff4001dfc5e3b9bdd392eb", "filename": "libjava/prims.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd8010046b910ac2477b0feb22f187b653655d1/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=3fd8010046b910ac2477b0feb22f187b653655d1", "patch": "@@ -1,6 +1,6 @@\n // prims.cc - Code for core of runtime environment.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -968,6 +968,8 @@ _Jv_CreateJavaVM (void* /*vm_args*/)\n   // system loader, by having it read the class path.\n   gnu::gcj::runtime::VMClassLoader::initialize();\n \n+  _Jv_RegisterBootstrapPackages();\n+\n   no_memory = new java::lang::OutOfMemoryError;\n \n   java::lang::VMThrowable::trace_enabled = 1;"}]}