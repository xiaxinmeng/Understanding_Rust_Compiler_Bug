{"sha": "9d7d33ac5800da1e76d0fb6a838111ca1378f522", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ3ZDMzYWM1ODAwZGExZTc2ZDBmYjZhODM4MTExY2ExMzc4ZjUyMg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-12-09T15:06:22Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2018-12-09T15:06:22Z"}, "message": "Merge dmd upstream e2fe2687b\n\nBackports VRP fixes from the D front-end implementation to the C++ port,\nand fixes errors reported by ubsan build where the conversion from D\ndidn't include adjusting integer suffixes from 'UL' to 'ULL'.\n\nFixes https://gcc.gnu.org/PR88366\n\nReviewed-on: https://github.com/dlang/dmd/pull/9046\n\nFrom-SVN: r266925", "tree": {"sha": "e271a577a601d6f4c9a9b7079e7470e736ff6ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e271a577a601d6f4c9a9b7079e7470e736ff6ee8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d7d33ac5800da1e76d0fb6a838111ca1378f522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d7d33ac5800da1e76d0fb6a838111ca1378f522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d7d33ac5800da1e76d0fb6a838111ca1378f522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d7d33ac5800da1e76d0fb6a838111ca1378f522/comments", "author": null, "committer": null, "parents": [{"sha": "5d62bfc3e7e954218fafe377324226621e47229d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d62bfc3e7e954218fafe377324226621e47229d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d62bfc3e7e954218fafe377324226621e47229d"}], "stats": {"total": 1033, "additions": 728, "deletions": 305}, "files": [{"sha": "a1a1fa0efd11a3eacf20dd6707acfaa2872f8f83", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -1,4 +1,4 @@\n-5220ad51eebe06754e6881d9bd5aab89dba2b065\n+e2fe2687b817a201528abaa3aa882333e04db01b\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "c3df013d802393cc804e76fbbc32659cbdae8e8f", "filename": "gcc/d/dmd/constfold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fconstfold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fconstfold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.c?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -446,13 +446,13 @@ UnionExp Div(Loc loc, Type *type, Expression *e1, Expression *e2)\n         if (n2 == -1 && !type->isunsigned())\n         {\n             // Check for int.min / -1\n-            if ((dinteger_t)n1 == 0xFFFFFFFF80000000UL && type->toBasetype()->ty != Tint64)\n+            if ((dinteger_t)n1 == 0xFFFFFFFF80000000ULL && type->toBasetype()->ty != Tint64)\n             {\n                 e2->error(\"integer overflow: int.min / -1\");\n                 new(&ue) ErrorExp();\n                 return ue;\n             }\n-            else if ((dinteger_t)n1 == 0x8000000000000000L) // long.min / -1\n+            else if ((dinteger_t)n1 == 0x8000000000000000LL) // long.min / -1\n             {\n                 e2->error(\"integer overflow: long.min / -1\");\n                 new(&ue) ErrorExp();"}, {"sha": "9606c99448243e473f7af2549a80d3a613a89f63", "filename": "gcc/d/dmd/dcast.c", "status": "modified", "additions": 29, "deletions": 197, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -986,6 +986,19 @@ MATCH implicitConvTo(Expression *e, Type *t)\n             visit((Expression *)e);\n         }\n \n+        void visit(AndExp *e)\n+        {\n+            visit((Expression *)e);\n+            if (result != MATCHnomatch)\n+                return;\n+\n+            MATCH m1 = e->e1->implicitConvTo(t);\n+            MATCH m2 = e->e2->implicitConvTo(t);\n+\n+            // Pick the worst match\n+            result = (m1 < m2) ? m1 : m2;\n+        }\n+\n         void visit(OrExp *e)\n         {\n             visit((Expression *)e);\n@@ -3381,74 +3394,6 @@ IntRange getIntRange(Expression *e)\n {\n     class IntRangeVisitor : public Visitor\n     {\n-    private:\n-        static uinteger_t getMask(uinteger_t v)\n-        {\n-            // Ref: http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n-            v |= v >> 1;\n-            v |= v >> 2;\n-            v |= v >> 4;\n-            v |= v >> 8;\n-            v |= v >> 16;\n-            v |= v >> 32;\n-            return v;\n-        }\n-\n-        // The algorithms for &, |, ^ are not yet the best! Sometimes they will produce\n-        //  not the tightest bound. See\n-        //      https://github.com/D-Programming-Language/dmd/pull/116\n-        //  for detail.\n-        static IntRange unsignedBitwiseAnd(const IntRange& a, const IntRange& b)\n-        {\n-            // the DiffMasks stores the mask of bits which are variable in the range.\n-            uinteger_t aDiffMask = getMask(a.imin.value ^ a.imax.value);\n-            uinteger_t bDiffMask = getMask(b.imin.value ^ b.imax.value);\n-            // Since '&' computes the digitwise-minimum, the we could set all varying\n-            //  digits to 0 to get a lower bound, and set all varying digits to 1 to get\n-            //  an upper bound.\n-            IntRange result;\n-            result.imin.value = (a.imin.value & ~aDiffMask) & (b.imin.value & ~bDiffMask);\n-            result.imax.value = (a.imax.value | aDiffMask) & (b.imax.value | bDiffMask);\n-            // Sometimes the upper bound is overestimated. The upper bound will never\n-            //  exceed the input.\n-            if (result.imax.value > a.imax.value)\n-                result.imax.value = a.imax.value;\n-            if (result.imax.value > b.imax.value)\n-                result.imax.value = b.imax.value;\n-            result.imin.negative = result.imax.negative = a.imin.negative && b.imin.negative;\n-            return result;\n-        }\n-        static IntRange unsignedBitwiseOr(const IntRange& a, const IntRange& b)\n-        {\n-            // the DiffMasks stores the mask of bits which are variable in the range.\n-            uinteger_t aDiffMask = getMask(a.imin.value ^ a.imax.value);\n-            uinteger_t bDiffMask = getMask(b.imin.value ^ b.imax.value);\n-            // The imax algorithm by Adam D. Ruppe.\n-            // http://www.digitalmars.com/pnews/read.php?server=news.digitalmars.com&group=digitalmars.D&artnum=108796\n-            IntRange result;\n-            result.imin.value = (a.imin.value & ~aDiffMask) | (b.imin.value & ~bDiffMask);\n-            result.imax.value = a.imax.value | b.imax.value | getMask(a.imax.value & b.imax.value);\n-            // Sometimes the lower bound is underestimated. The lower bound will never\n-            //  less than the input.\n-            if (result.imin.value < a.imin.value)\n-                result.imin.value = a.imin.value;\n-            if (result.imin.value < b.imin.value)\n-                result.imin.value = b.imin.value;\n-            result.imin.negative = result.imax.negative = a.imin.negative || b.imin.negative;\n-            return result;\n-        }\n-        static IntRange unsignedBitwiseXor(const IntRange& a, const IntRange& b)\n-        {\n-            // the DiffMasks stores the mask of bits which are variable in the range.\n-            uinteger_t aDiffMask = getMask(a.imin.value ^ a.imax.value);\n-            uinteger_t bDiffMask = getMask(b.imin.value ^ b.imax.value);\n-            IntRange result;\n-            result.imin.value = (a.imin.value ^ b.imin.value) & ~(aDiffMask | bDiffMask);\n-            result.imax.value = (a.imax.value ^ b.imax.value) | (aDiffMask | bDiffMask);\n-            result.imin.negative = result.imax.negative = a.imin.negative != b.imin.negative;\n-            return result;\n-        }\n-\n     public:\n         IntRange range;\n \n@@ -3471,169 +3416,71 @@ IntRange getIntRange(Expression *e)\n         {\n             IntRange ir1 = getIntRange(e->e1);\n             IntRange ir2 = getIntRange(e->e2);\n-            range = IntRange(ir1.imin + ir2.imin, ir1.imax + ir2.imax).cast(e->type);\n+            range = (ir1 + ir2).cast(e->type);\n         }\n \n         void visit(MinExp *e)\n         {\n             IntRange ir1 = getIntRange(e->e1);\n             IntRange ir2 = getIntRange(e->e2);\n-            range = IntRange(ir1.imin - ir2.imax, ir1.imax - ir2.imin).cast(e->type);\n+            range = (ir1 - ir2).cast(e->type);\n         }\n \n         void visit(DivExp *e)\n         {\n             IntRange ir1 = getIntRange(e->e1);\n             IntRange ir2 = getIntRange(e->e2);\n \n-            // Should we ignore the possibility of div-by-0???\n-            if (ir2.containsZero())\n-            {\n-                visit((Expression *)e);\n-                return;\n-            }\n-\n-            // [a,b] / [c,d] = [min (a/c, a/d, b/c, b/d), max (a/c, a/d, b/c, b/d)]\n-            SignExtendedNumber bdy[4];\n-            bdy[0] = ir1.imin / ir2.imin;\n-            bdy[1] = ir1.imin / ir2.imax;\n-            bdy[2] = ir1.imax / ir2.imin;\n-            bdy[3] = ir1.imax / ir2.imax;\n-            range = IntRange::fromNumbers4(bdy).cast(e->type);\n+            range = (ir1 / ir2).cast(e->type);\n         }\n \n         void visit(MulExp *e)\n         {\n             IntRange ir1 = getIntRange(e->e1);\n             IntRange ir2 = getIntRange(e->e2);\n \n-            // [a,b] * [c,d] = [min (ac, ad, bc, bd), max (ac, ad, bc, bd)]\n-            SignExtendedNumber bdy[4];\n-            bdy[0] = ir1.imin * ir2.imin;\n-            bdy[1] = ir1.imin * ir2.imax;\n-            bdy[2] = ir1.imax * ir2.imin;\n-            bdy[3] = ir1.imax * ir2.imax;\n-            range = IntRange::fromNumbers4(bdy).cast(e->type);\n+            range = (ir1 * ir2).cast(e->type);\n         }\n \n         void visit(ModExp *e)\n         {\n-            IntRange irNum = getIntRange(e->e1);\n-            IntRange irDen = getIntRange(e->e2).absNeg();\n-\n-            /*\n-            due to the rules of D (C)'s % operator, we need to consider the cases\n-            separately in different range of signs.\n-\n-                case 1. [500, 1700] % [7, 23] (numerator is always positive)\n-                    = [0, 22]\n-                case 2. [-500, 1700] % [7, 23] (numerator can be negative)\n-                    = [-22, 22]\n-                case 3. [-1700, -500] % [7, 23] (numerator is always negative)\n-                    = [-22, 0]\n-\n-            the number 22 is the maximum absolute value in the denomator's range. We\n-            don't care about divide by zero.\n-            */\n+            IntRange ir1 = getIntRange(e->e1);\n+            IntRange ir2 = getIntRange(e->e2);\n \n             // Modding on 0 is invalid anyway.\n-            if (!irDen.imin.negative)\n+            if (!ir2.absNeg().imin.negative)\n             {\n                 visit((Expression *)e);\n                 return;\n             }\n-\n-            ++ irDen.imin;\n-            irDen.imax = -irDen.imin;\n-\n-            if (!irNum.imin.negative)\n-                irNum.imin.value = 0;\n-            else if (irNum.imin < irDen.imin)\n-                irNum.imin = irDen.imin;\n-\n-            if (irNum.imax.negative)\n-            {\n-                irNum.imax.negative = false;\n-                irNum.imax.value = 0;\n-            }\n-            else if (irNum.imax > irDen.imax)\n-                irNum.imax = irDen.imax;\n-\n-            range = irNum.cast(e->type);\n+            range = (ir1 % ir2).cast(e->type);\n         }\n \n         void visit(AndExp *e)\n         {\n-            IntRange ir1 = getIntRange(e->e1);\n-            IntRange ir2 = getIntRange(e->e2);\n-\n-            IntRange ir1neg, ir1pos, ir2neg, ir2pos;\n-            bool has1neg, has1pos, has2neg, has2pos;\n-\n-            ir1.splitBySign(ir1neg, has1neg, ir1pos, has1pos);\n-            ir2.splitBySign(ir2neg, has2neg, ir2pos, has2pos);\n-\n             IntRange result;\n             bool hasResult = false;\n-            if (has1pos && has2pos)\n-                result.unionOrAssign(unsignedBitwiseAnd(ir1pos, ir2pos), hasResult);\n-            if (has1pos && has2neg)\n-                result.unionOrAssign(unsignedBitwiseAnd(ir1pos, ir2neg), hasResult);\n-            if (has1neg && has2pos)\n-                result.unionOrAssign(unsignedBitwiseAnd(ir1neg, ir2pos), hasResult);\n-            if (has1neg && has2neg)\n-                result.unionOrAssign(unsignedBitwiseAnd(ir1neg, ir2neg), hasResult);\n+            result.unionOrAssign(getIntRange(e->e1) & getIntRange(e->e2), hasResult);\n+\n             assert(hasResult);\n             range = result.cast(e->type);\n         }\n \n         void visit(OrExp *e)\n         {\n-            IntRange ir1 = getIntRange(e->e1);\n-            IntRange ir2 = getIntRange(e->e2);\n-\n-            IntRange ir1neg, ir1pos, ir2neg, ir2pos;\n-            bool has1neg, has1pos, has2neg, has2pos;\n-\n-            ir1.splitBySign(ir1neg, has1neg, ir1pos, has1pos);\n-            ir2.splitBySign(ir2neg, has2neg, ir2pos, has2pos);\n-\n             IntRange result;\n             bool hasResult = false;\n-            if (has1pos && has2pos)\n-                result.unionOrAssign(unsignedBitwiseOr(ir1pos, ir2pos), hasResult);\n-            if (has1pos && has2neg)\n-                result.unionOrAssign(unsignedBitwiseOr(ir1pos, ir2neg), hasResult);\n-            if (has1neg && has2pos)\n-                result.unionOrAssign(unsignedBitwiseOr(ir1neg, ir2pos), hasResult);\n-            if (has1neg && has2neg)\n-                result.unionOrAssign(unsignedBitwiseOr(ir1neg, ir2neg), hasResult);\n+            result.unionOrAssign(getIntRange(e->e1) | getIntRange(e->e2), hasResult);\n \n             assert(hasResult);\n             range = result.cast(e->type);\n         }\n \n         void visit(XorExp *e)\n         {\n-            IntRange ir1 = getIntRange(e->e1);\n-            IntRange ir2 = getIntRange(e->e2);\n-\n-            IntRange ir1neg, ir1pos, ir2neg, ir2pos;\n-            bool has1neg, has1pos, has2neg, has2pos;\n-\n-            ir1.splitBySign(ir1neg, has1neg, ir1pos, has1pos);\n-            ir2.splitBySign(ir2neg, has2neg, ir2pos, has2pos);\n-\n             IntRange result;\n             bool hasResult = false;\n-            if (has1pos && has2pos)\n-                result.unionOrAssign(unsignedBitwiseXor(ir1pos, ir2pos), hasResult);\n-            if (has1pos && has2neg)\n-                result.unionOrAssign(unsignedBitwiseXor(ir1pos, ir2neg), hasResult);\n-            if (has1neg && has2pos)\n-                result.unionOrAssign(unsignedBitwiseXor(ir1neg, ir2pos), hasResult);\n-            if (has1neg && has2neg)\n-                result.unionOrAssign(unsignedBitwiseXor(ir1neg, ir2neg), hasResult);\n+            result.unionOrAssign(getIntRange(e->e1) ^ getIntRange(e->e2), hasResult);\n \n             assert(hasResult);\n             range = result.cast(e->type);\n@@ -3644,38 +3491,23 @@ IntRange getIntRange(Expression *e)\n             IntRange ir1 = getIntRange(e->e1);\n             IntRange ir2 = getIntRange(e->e2);\n \n-            if (ir2.imin.negative)\n-                ir2 = IntRange(SignExtendedNumber(0), SignExtendedNumber(64));\n-\n-            SignExtendedNumber lower = ir1.imin << (ir1.imin.negative ? ir2.imax : ir2.imin);\n-            SignExtendedNumber upper = ir1.imax << (ir1.imax.negative ? ir2.imin : ir2.imax);\n-\n-            range = IntRange(lower, upper).cast(e->type);\n+            range = (ir1 << ir2).cast(e->type);\n         }\n \n         void visit(ShrExp *e)\n         {\n             IntRange ir1 = getIntRange(e->e1);\n             IntRange ir2 = getIntRange(e->e2);\n \n-            if (ir2.imin.negative)\n-                ir2 = IntRange(SignExtendedNumber(0), SignExtendedNumber(64));\n-\n-            SignExtendedNumber lower = ir1.imin >> (ir1.imin.negative ? ir2.imin : ir2.imax);\n-            SignExtendedNumber upper = ir1.imax >> (ir1.imax.negative ? ir2.imax : ir2.imin);\n-\n-            range = IntRange(lower, upper).cast(e->type);\n+            range = (ir1 >> ir2).cast(e->type);\n         }\n \n         void visit(UshrExp *e)\n         {\n             IntRange ir1 = getIntRange(e->e1).castUnsigned(e->e1->type);\n             IntRange ir2 = getIntRange(e->e2);\n \n-            if (ir2.imin.negative)\n-                ir2 = IntRange(SignExtendedNumber(0), SignExtendedNumber(64));\n-\n-            range = IntRange(ir1.imin >> ir2.imax, ir1.imax >> ir2.imin).cast(e->type);\n+            range = (ir1 >> ir2).cast(e->type);\n         }\n \n         void visit(AssignExp *e)\n@@ -3719,7 +3551,7 @@ IntRange getIntRange(Expression *e)\n         void visit(NegExp *e)\n         {\n             IntRange ir = getIntRange(e->e1);\n-            range = IntRange(-ir.imax, -ir.imin).cast(e->type);\n+            range = (-ir).cast(e->type);\n         }\n     };\n "}, {"sha": "d0678a06c7434f3880715e54e858fa394b5b214f", "filename": "gcc/d/dmd/dsymbol.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -1191,12 +1191,12 @@ void ScopeDsymbol::importScope(Dsymbol *s, Prot protection)\n \n static void bitArraySet(BitArray *array, size_t idx)\n {\n-    array->ptr[idx / (sizeof(size_t) * CHAR_BIT)] |= 1 << (idx & (sizeof(size_t) * CHAR_BIT - 1));\n+    array->ptr[idx / (sizeof(size_t) * CHAR_BIT)] |= 1ULL << (idx & (sizeof(size_t) * CHAR_BIT - 1));\n }\n \n static bool bitArrayGet(BitArray *array, size_t idx)\n {\n-    return (array->ptr[idx / (sizeof(size_t) * CHAR_BIT)] & (1 << (idx & (sizeof(size_t) * CHAR_BIT - 1)))) != 0;\n+    return (array->ptr[idx / (sizeof(size_t) * CHAR_BIT)] & (1ULL << (idx & (sizeof(size_t) * CHAR_BIT - 1)))) != 0;\n }\n \n static void bitArrayLength(BitArray *array, size_t len)"}, {"sha": "dd794d98a8ceb5ae47c0bb1af4f94a4e71850777", "filename": "gcc/d/dmd/intrange.c", "status": "modified", "additions": 425, "deletions": 45, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fintrange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fintrange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.c?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -54,6 +54,26 @@ SignExtendedNumber SignExtendedNumber::max()\n     return SignExtendedNumber(UINT64_MAX, false);\n }\n \n+SignExtendedNumber& SignExtendedNumber::operator++()\n+{\n+    if (value != UINT64_MAX)\n+        ++value;\n+    else if (negative)\n+    {\n+        value = 0;\n+        negative = false;\n+    }\n+    return *this;\n+}\n+\n+SignExtendedNumber SignExtendedNumber::operator~() const\n+{\n+    if (~value == 0)\n+        return SignExtendedNumber(~value);\n+    else\n+        return SignExtendedNumber(~value, !negative);\n+}\n+\n SignExtendedNumber SignExtendedNumber::operator-() const\n {\n     if (value == 0)\n@@ -62,28 +82,42 @@ SignExtendedNumber SignExtendedNumber::operator-() const\n         return SignExtendedNumber(-value, !negative);\n }\n \n-SignExtendedNumber SignExtendedNumber::operator+(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator&(const SignExtendedNumber& rhs) const\n {\n-    uinteger_t sum = value + a.value;\n-    bool carry = sum < value && sum < a.value;\n-    if (negative != a.negative)\n+    return SignExtendedNumber(value & rhs.value);\n+}\n+\n+SignExtendedNumber SignExtendedNumber::operator|(const SignExtendedNumber& rhs) const\n+{\n+    return SignExtendedNumber(value | rhs.value);\n+}\n+\n+SignExtendedNumber SignExtendedNumber::operator^(const SignExtendedNumber& rhs) const\n+{\n+    return SignExtendedNumber(value ^ rhs.value);\n+}\n+\n+SignExtendedNumber SignExtendedNumber::operator+(const SignExtendedNumber& rhs) const\n+{\n+    uinteger_t sum = value + rhs.value;\n+    bool carry = sum < value && sum < rhs.value;\n+    if (negative != rhs.negative)\n         return SignExtendedNumber(sum, !carry);\n     else if (negative)\n         return SignExtendedNumber(carry ? sum : 0, true);\n     else\n         return SignExtendedNumber(carry ? UINT64_MAX : sum, false);\n }\n \n-SignExtendedNumber SignExtendedNumber::operator-(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator-(const SignExtendedNumber& rhs) const\n {\n-    if (a.isMinimum())\n+    if (rhs.isMinimum())\n         return negative ? SignExtendedNumber(value, false) : max();\n     else\n-        return *this + (-a);\n+        return *this + (-rhs);\n }\n \n-\n-SignExtendedNumber SignExtendedNumber::operator*(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator*(const SignExtendedNumber& rhs) const\n {\n     // perform *saturated* multiplication, otherwise we may get bogus ranges\n     //  like 0x10 * 0x10 == 0x100 == 0.\n@@ -98,43 +132,43 @@ SignExtendedNumber SignExtendedNumber::operator*(const SignExtendedNumber& a) co\n     {\n         if (!negative)\n             return *this;\n-        else if (a.negative)\n+        else if (rhs.negative)\n             return max();\n         else\n-            return a.value == 0 ? a : *this;\n+            return rhs.value == 0 ? rhs : *this;\n     }\n-    else if (a.value == 0)\n-        return a * *this;   // don't duplicate the symmetric case.\n+    else if (rhs.value == 0)\n+        return rhs * *this;   // don't duplicate the symmetric case.\n \n     SignExtendedNumber rv;\n     // these are != 0 now surely.\n     uinteger_t tAbs = copySign(value, negative);\n-    uinteger_t aAbs = copySign(a.value, a.negative);\n-    rv.negative = negative != a.negative;\n+    uinteger_t aAbs = copySign(rhs.value, rhs.negative);\n+    rv.negative = negative != rhs.negative;\n     if (UINT64_MAX / tAbs < aAbs)\n         rv.value = rv.negative-1;\n     else\n         rv.value = copySign(tAbs * aAbs, rv.negative);\n     return rv;\n }\n \n-SignExtendedNumber SignExtendedNumber::operator/(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator/(const SignExtendedNumber& rhs) const\n {\n     /* special handling for zeros:\n         INT65_MIN / INT65_MIN = 1\n         anything / INT65_MIN = 0\n         + / 0 = INT65_MAX  (eh?)\n         - / 0 = INT65_MIN  (eh?)\n     */\n-    if (a.value == 0)\n+    if (rhs.value == 0)\n     {\n-        if (a.negative)\n+        if (rhs.negative)\n             return SignExtendedNumber(value == 0 && negative);\n         else\n             return extreme(negative);\n     }\n \n-    uinteger_t aAbs = copySign(a.value, a.negative);\n+    uinteger_t aAbs = copySign(rhs.value, rhs.negative);\n     uinteger_t rvVal;\n \n     if (!isMinimum())\n@@ -147,7 +181,7 @@ SignExtendedNumber SignExtendedNumber::operator/(const SignExtendedNumber& a) co\n     else\n     {\n         if (aAbs == 1)\n-            return extreme(!a.negative);\n+            return extreme(!rhs.negative);\n         rvVal = 1ULL << 63;\n         aAbs >>= 1;\n         if (aAbs & 0xAAAAAAAAAAAAAAAAULL) rvVal >>= 1;\n@@ -157,18 +191,18 @@ SignExtendedNumber SignExtendedNumber::operator/(const SignExtendedNumber& a) co\n         if (aAbs & 0xFFFF0000FFFF0000ULL) rvVal >>= 16;\n         if (aAbs & 0xFFFFFFFF00000000ULL) rvVal >>= 32;\n     }\n-    bool rvNeg = negative != a.negative;\n+    bool rvNeg = negative != rhs.negative;\n     rvVal = copySign(rvVal, rvNeg);\n \n     return SignExtendedNumber(rvVal, rvVal != 0 && rvNeg);\n }\n \n-SignExtendedNumber SignExtendedNumber::operator%(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator%(const SignExtendedNumber& rhs) const\n {\n-    if (a.value == 0)\n-        return !a.negative ? a : isMinimum() ? SignExtendedNumber(0) : *this;\n+    if (rhs.value == 0)\n+        return !rhs.negative ? rhs : isMinimum() ? SignExtendedNumber(0) : *this;\n \n-    uinteger_t aAbs = copySign(a.value, a.negative);\n+    uinteger_t aAbs = copySign(rhs.value, rhs.negative);\n     uinteger_t rvVal;\n \n     // a % b == sgn(a) * abs(a) % abs(b).\n@@ -186,25 +220,13 @@ SignExtendedNumber SignExtendedNumber::operator%(const SignExtendedNumber& a) co\n     return SignExtendedNumber(rvVal, rvVal != 0 && negative);\n }\n \n-SignExtendedNumber& SignExtendedNumber::operator++()\n-{\n-    if (value != UINT64_MAX)\n-        ++ value;\n-    else if (negative)\n-    {\n-        value = 0;\n-        negative = false;\n-    }\n-    return *this;\n-}\n-\n-SignExtendedNumber SignExtendedNumber::operator<<(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator<<(const SignExtendedNumber& rhs) const\n {\n     // assume left-shift the shift-amount is always unsigned. Thus negative\n     //  shifts will give huge result.\n     if (value == 0)\n         return *this;\n-    else if (a.negative)\n+    else if (rhs.negative)\n         return extreme(negative);\n \n     uinteger_t v = copySign(value, negative);\n@@ -223,21 +245,21 @@ SignExtendedNumber SignExtendedNumber::operator<<(const SignExtendedNumber& a) c\n                                            r |= (v >> 1);\n \n     uinteger_t allowableShift = 63 - r;\n-    if (a.value > allowableShift)\n+    if (rhs.value > allowableShift)\n         return extreme(negative);\n     else\n-        return SignExtendedNumber(value << a.value, negative);\n+        return SignExtendedNumber(value << rhs.value, negative);\n }\n \n-SignExtendedNumber SignExtendedNumber::operator>>(const SignExtendedNumber& a) const\n+SignExtendedNumber SignExtendedNumber::operator>>(const SignExtendedNumber& rhs) const\n {\n-    if (a.negative || a.value > 64)\n+    if (rhs.negative || rhs.value > 63)\n         return negative ? SignExtendedNumber(-1, true) : SignExtendedNumber(0);\n     else if (isMinimum())\n-        return a.value == 0 ? *this : SignExtendedNumber(-1ULL << (64-a.value), true);\n+        return rhs.value == 0 ? *this : SignExtendedNumber(-1ULL << (64 - rhs.value), true);\n \n     uinteger_t x = value ^ -negative;\n-    x >>= a.value;\n+    x >>= rhs.value;\n     return SignExtendedNumber(x ^ -negative, negative);\n }\n \n@@ -448,6 +470,364 @@ void IntRange::splitBySign(IntRange& negRange, bool& hasNegRange,\n     }\n }\n \n+IntRange IntRange::operator~() const\n+{\n+    return IntRange(~imax, ~imin);\n+}\n+\n+IntRange IntRange::operator-() const\n+{\n+    return IntRange(-imax, -imin);\n+}\n+\n+IntRange IntRange::operator&(const IntRange& rhs) const\n+{\n+    // unsigned or identical sign bits\n+    if ((imin.negative ^ imax.negative) != 1 && (rhs.imin.negative ^ rhs.imax.negative) != 1)\n+    {\n+        return IntRange(minAnd(*this, rhs), maxAnd(*this, rhs));\n+    }\n+\n+    IntRange l = IntRange(*this);\n+    IntRange r = IntRange(rhs);\n+\n+    // both intervals span [-1,0]\n+    if ((l.imin.negative ^ l.imax.negative) == 1 && (r.imin.negative ^ r.imax.negative) == 1)\n+    {\n+        // cannot be larger than either l.max or r.max, set the other one to -1\n+        SignExtendedNumber max = l.imax.value > r.imax.value ? l.imax : r.imax;\n+\n+        // only negative numbers for minimum\n+        l.imax.value = -1;\n+        l.imax.negative = true;\n+        r.imax.value = -1;\n+        r.imax.negative = true;\n+\n+        return IntRange(minAnd(l, r), max);\n+    }\n+    else\n+    {\n+        // only one interval spans [-1,0]\n+        if ((l.imin.negative ^ l.imax.negative) == 1)\n+        {\n+            swap(l, r); // r spans [-1,0]\n+        }\n+\n+        SignExtendedNumber minAndNeg = minAnd(l, IntRange(r.imin, SignExtendedNumber(-1)));\n+        SignExtendedNumber minAndPos = minAnd(l, IntRange(SignExtendedNumber(0), r.imax));\n+        SignExtendedNumber maxAndNeg = maxAnd(l, IntRange(r.imin, SignExtendedNumber(-1)));\n+        SignExtendedNumber maxAndPos = maxAnd(l, IntRange(SignExtendedNumber(0), r.imax));\n+\n+        SignExtendedNumber min = minAndNeg < minAndPos ? minAndNeg : minAndPos;\n+        SignExtendedNumber max = maxAndNeg > maxAndPos ? maxAndNeg : maxAndPos;\n+\n+        return IntRange(min, max);\n+    }\n+}\n+\n+IntRange IntRange::operator|(const IntRange& rhs) const\n+{\n+    // unsigned or identical sign bits:\n+    if ((imin.negative ^ imax.negative) == 0 && (rhs.imin.negative ^ rhs.imax.negative) == 0)\n+    {\n+        return IntRange(minOr(*this, rhs), maxOr(*this, rhs));\n+    }\n+\n+    IntRange l = IntRange(*this);\n+    IntRange r = IntRange(rhs);\n+\n+    // both intervals span [-1,0]\n+    if ((l.imin.negative ^ l.imax.negative) == 1 && (r.imin.negative ^ r.imax.negative) == 1)\n+    {\n+        // cannot be smaller than either l.min or r.min, set the other one to 0\n+        SignExtendedNumber min = l.imin.value < r.imin.value ? l.imin : r.imin;\n+\n+        // only negative numbers for minimum\n+        l.imin.value = 0;\n+        l.imin.negative = false;\n+        r.imin.value = 0;\n+        r.imin.negative = false;\n+\n+        return IntRange(min, maxOr(l, r));\n+    }\n+    else\n+    {\n+        // only one interval spans [-1,0]\n+        if ((imin.negative ^ imax.negative) == 1)\n+        {\n+            swap(l, r); // r spans [-1,0]\n+        }\n+\n+        SignExtendedNumber minOrNeg = minOr(l, IntRange(r.imin, SignExtendedNumber(-1)));\n+        SignExtendedNumber minOrPos = minOr(l, IntRange(SignExtendedNumber(0), r.imax));\n+        SignExtendedNumber maxOrNeg = maxOr(l, IntRange(r.imin, SignExtendedNumber(-1)));\n+        SignExtendedNumber maxOrPos = maxOr(l, IntRange(SignExtendedNumber(0), r.imax));\n+\n+        SignExtendedNumber min = minOrNeg < minOrPos ? minOrNeg : minOrPos;\n+        SignExtendedNumber max = maxOrNeg > maxOrPos ? maxOrNeg : maxOrPos;\n+\n+        return IntRange(min, max);\n+    }\n+}\n+\n+IntRange IntRange::operator^(const IntRange& rhs) const\n+{\n+    return (*this & (~rhs)) | (~(*this) & rhs);\n+}\n+\n+IntRange IntRange::operator+(const IntRange& rhs) const\n+{\n+    return IntRange(imin + rhs.imin, imax + rhs.imax);\n+}\n+\n+IntRange IntRange::operator-(const IntRange& rhs) const\n+{\n+    return IntRange(imin - rhs.imax, imax - rhs.imin);\n+}\n+\n+IntRange IntRange::operator*(const IntRange& rhs) const\n+{\n+    // [a,b] * [c,d] = [min (ac, ad, bc, bd), max (ac, ad, bc, bd)]\n+    SignExtendedNumber bdy[4];\n+    bdy[0] = imin * rhs.imin;\n+    bdy[1] = imin * rhs.imax;\n+    bdy[2] = imax * rhs.imin;\n+    bdy[3] = imax * rhs.imax;\n+    return IntRange::fromNumbers4(bdy);\n+}\n+\n+IntRange IntRange::operator/(const IntRange& rhs) const\n+{\n+    // Handle divide by 0\n+    if (rhs.imax.value == 0 && rhs.imin.value == 0)\n+        return widest();\n+\n+    IntRange r = IntRange(rhs);\n+\n+    // Don't treat the whole range as divide by 0 if only one end of a range is 0.\n+    // Issue 15289\n+    if (r.imax.value == 0)\n+    {\n+        r.imax.value--;\n+    }\n+    else if(r.imin.value == 0)\n+    {\n+        r.imin.value++;\n+    }\n+\n+    if (!imin.negative && !imax.negative && !r.imin.negative && !r.imax.negative)\n+    {\n+        return IntRange(imin / r.imax, imax / r.imin);\n+    }\n+    else\n+    {\n+        // [a,b] / [c,d] = [min (a/c, a/d, b/c, b/d), max (a/c, a/d, b/c, b/d)]\n+        SignExtendedNumber bdy[4];\n+        bdy[0] = imin / r.imin;\n+        bdy[1] = imin / r.imax;\n+        bdy[2] = imax / r.imin;\n+        bdy[3] = imax / r.imax;\n+\n+        return IntRange::fromNumbers4(bdy);\n+    }\n+}\n+\n+IntRange IntRange::operator%(const IntRange& rhs) const\n+{\n+    IntRange irNum = *this;\n+    IntRange irDen = rhs.absNeg();\n+\n+    /*\n+     due to the rules of D (C)'s % operator, we need to consider the cases\n+     separately in different range of signs.\n+\n+         case 1. [500, 1700] % [7, 23] (numerator is always positive)\n+             = [0, 22]\n+         case 2. [-500, 1700] % [7, 23] (numerator can be negative)\n+             = [-22, 22]\n+         case 3. [-1700, -500] % [7, 23] (numerator is always negative)\n+             = [-22, 0]\n+\n+     the number 22 is the maximum absolute value in the denomator's range. We\n+     don't care about divide by zero.\n+     */\n+\n+    irDen.imin = irDen.imin + SignExtendedNumber(1);\n+    irDen.imax = -irDen.imin;\n+\n+    if (!irNum.imin.negative)\n+    {\n+        irNum.imin.value = 0;\n+    }\n+    else if (irNum.imin < irDen.imin)\n+    {\n+        irNum.imin = irDen.imin;\n+    }\n+\n+    if (irNum.imax.negative)\n+    {\n+        irNum.imax.negative = false;\n+        irNum.imax.value = 0;\n+    }\n+    else if (irNum.imax > irDen.imax)\n+    {\n+        irNum.imax = irDen.imax;\n+    }\n+\n+    return irNum;\n+}\n+\n+IntRange IntRange::operator<<(const IntRange& rhs) const\n+{\n+    IntRange r = IntRange(rhs);\n+    if (r.imin.negative)\n+    {\n+        r = IntRange(SignExtendedNumber(0), SignExtendedNumber(64));\n+    }\n+\n+    SignExtendedNumber lower = imin << (imin.negative ? r.imax : r.imin);\n+    SignExtendedNumber upper = imax << (imax.negative ? r.imin : r.imax);\n+\n+    return IntRange(lower, upper);\n+}\n+\n+IntRange IntRange::operator>>(const IntRange& rhs) const\n+{\n+    IntRange r = IntRange(rhs);\n+    if (r.imin.negative)\n+    {\n+        r = IntRange(SignExtendedNumber(0), SignExtendedNumber(64));\n+    }\n+\n+    SignExtendedNumber lower = imin >> (imin.negative ? r.imin : r.imax);\n+    SignExtendedNumber upper = imax >> (imax.negative ? r.imax : r.imin);\n+\n+    return IntRange(lower, upper);\n+}\n+\n+SignExtendedNumber IntRange::maxOr(const IntRange& lhs, const IntRange& rhs)\n+{\n+    uinteger_t x = 0;\n+    bool sign = false;\n+    uinteger_t xorvalue = lhs.imax.value ^ rhs.imax.value;\n+    uinteger_t andvalue = lhs.imax.value & rhs.imax.value;\n+    IntRange lhsc = IntRange(lhs);\n+    IntRange rhsc = IntRange(rhs);\n+\n+    // Sign bit not part of the .value so we need an extra iteration\n+    if (lhsc.imax.negative ^ rhsc.imax.negative)\n+    {\n+        sign = true;\n+        if (lhsc.imax.negative)\n+        {\n+            if (!lhsc.imin.negative)\n+            {\n+                lhsc.imin.value = 0;\n+            }\n+            if (!rhsc.imin.negative)\n+            {\n+                rhsc.imin.value = 0;\n+            }\n+        }\n+    }\n+    else if (lhsc.imin.negative & rhsc.imin.negative)\n+    {\n+        sign = true;\n+    }\n+    else if (lhsc.imax.negative & rhsc.imax.negative)\n+    {\n+        return SignExtendedNumber(-1, false);\n+    }\n+\n+    for (uinteger_t d = 1ULL << (8 * sizeof(uinteger_t) - 1); d; d >>= 1)\n+    {\n+        if (xorvalue & d)\n+        {\n+            x |= d;\n+            if (lhsc.imax.value & d)\n+            {\n+                if (~lhsc.imin.value & d)\n+                {\n+                    lhsc.imin.value = 0;\n+                }\n+            }\n+            else\n+            {\n+                if (~rhsc.imin.value & d)\n+                {\n+                    rhsc.imin.value = 0;\n+                }\n+            }\n+        }\n+        else if (lhsc.imin.value & rhsc.imin.value & d)\n+        {\n+            x |= d;\n+        }\n+        else if (andvalue & d)\n+        {\n+            x |= (d << 1) - 1;\n+            break;\n+        }\n+    }\n+\n+    return SignExtendedNumber(x, sign);\n+}\n+\n+SignExtendedNumber IntRange::minOr(const IntRange& lhs, const IntRange& rhs)\n+{\n+    return ~maxAnd(~lhs, ~rhs);\n+}\n+\n+SignExtendedNumber IntRange::maxAnd(const IntRange& lhs, const IntRange& rhs)\n+{\n+    uinteger_t x = 0;\n+    bool sign = false;\n+    IntRange lhsc = IntRange(lhs);\n+    IntRange rhsc = IntRange(rhs);\n+\n+    if (lhsc.imax.negative & rhsc.imax.negative)\n+    {\n+        sign = true;\n+    }\n+\n+    for (uinteger_t d = 1ULL << (8 * sizeof(uinteger_t) - 1); d; d >>= 1)\n+    {\n+        if (lhsc.imax.value & rhsc.imax.value & d)\n+        {\n+            x |= d;\n+            if (~lhsc.imin.value & d)\n+            {\n+                lhsc.imin.value = 0;\n+            }\n+            if (~rhsc.imin.value & d)\n+            {\n+                rhsc.imin.value = 0;\n+            }\n+        }\n+        else if (~lhsc.imin.value & d && lhsc.imax.value & d)\n+        {\n+            lhsc.imax.value |= d - 1;\n+        }\n+        else if (~rhsc.imin.value & d && rhsc.imax.value & d)\n+        {\n+            rhsc.imax.value |= d - 1;\n+        }\n+    }\n+\n+    return SignExtendedNumber(x, sign);\n+}\n+\n+SignExtendedNumber IntRange::minAnd(const IntRange& lhs, const IntRange& rhs)\n+{\n+    return ~maxOr(~lhs, ~rhs);\n+}\n+\n+void IntRange::swap(IntRange& a, IntRange& b)\n+{\n+    IntRange aux = a;\n+    a = b;\n+    b = aux;\n+}\n \n const IntRange& IntRange::dump(const char* funcName, Expression *e) const\n {"}, {"sha": "aee773a14a0c625e56b8c534168ba446513a89ef", "filename": "gcc/d/dmd/intrange.h", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fintrange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fintrange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.h?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -60,23 +60,30 @@ struct SignExtendedNumber\n     bool operator<=(const SignExtendedNumber& a) const { return !(a < *this); }\n     bool operator>=(const SignExtendedNumber& a) const { return !(*this < a); }\n \n+    /// Increase the sign-extended number by 1 (saturated).\n+    SignExtendedNumber& operator++();\n+    /// Compute the saturated complement of a sign-extended number.\n+    SignExtendedNumber operator~() const;\n     /// Compute the saturated negation of a sign-extended number.\n     SignExtendedNumber operator-() const;\n \n+    /// Compute the saturated binary and of two sign-extended number.\n+    SignExtendedNumber operator&(const SignExtendedNumber&) const;\n+    /// Compute the saturated binary or of two sign-extended number.\n+    SignExtendedNumber operator|(const SignExtendedNumber&) const;\n+    /// Compute the saturated binary xor of two sign-extended number.\n+    SignExtendedNumber operator^(const SignExtendedNumber&) const;\n     /// Compute the saturated sum of two sign-extended number.\n     SignExtendedNumber operator+(const SignExtendedNumber&) const;\n     /// Compute the saturated difference of two sign-extended number.\n-    SignExtendedNumber operator-(const SignExtendedNumber& a) const;\n+    SignExtendedNumber operator-(const SignExtendedNumber&) const;\n     /// Compute the saturated product of two sign-extended number.\n     SignExtendedNumber operator*(const SignExtendedNumber&) const;\n     /// Compute the saturated quotient of two sign-extended number.\n     SignExtendedNumber operator/(const SignExtendedNumber&) const;\n     /// Compute the saturated modulus of two sign-extended number.\n     SignExtendedNumber operator%(const SignExtendedNumber&) const;\n \n-    /// Increase the sign-extended number by 1 (saturated).\n-    SignExtendedNumber& operator++();\n-\n     /// Compute the saturated shifts of two sign-extended number.\n     SignExtendedNumber operator<<(const SignExtendedNumber&) const;\n     SignExtendedNumber operator>>(const SignExtendedNumber&) const;\n@@ -146,4 +153,25 @@ struct IntRange\n     /// Split the range into two nonnegative- and negative-only subintervals.\n     void splitBySign(IntRange& negRange, bool& hasNegRange,\n                      IntRange& nonNegRange, bool& hasNonNegRange) const;\n+\n+    /// Credits to Timon Gehr maxOr, minOr, maxAnd, minAnd\n+    /// https://github.com/tgehr/d-compiler/blob/master/vrange.d\n+    static SignExtendedNumber maxOr(const IntRange&, const IntRange&);\n+    static SignExtendedNumber minOr(const IntRange&, const IntRange&);\n+    static SignExtendedNumber maxAnd(const IntRange&, const IntRange&);\n+    static SignExtendedNumber minAnd(const IntRange&, const IntRange&);\n+    static void swap(IntRange&, IntRange&);\n+\n+    IntRange operator~() const;\n+    IntRange operator-() const;\n+    IntRange operator&(const IntRange&) const;\n+    IntRange operator|(const IntRange&) const;\n+    IntRange operator^(const IntRange&) const;\n+    IntRange operator+(const IntRange&) const;\n+    IntRange operator-(const IntRange&) const;\n+    IntRange operator*(const IntRange&) const;\n+    IntRange operator/(const IntRange&) const;\n+    IntRange operator%(const IntRange&) const;\n+    IntRange operator<<(const IntRange&) const;\n+    IntRange operator>>(const IntRange&) const;\n };"}, {"sha": "b35b7af3201bae6a7dd066a783a5aca18da0e7aa", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -3832,6 +3832,7 @@ MATCH TypeVector::implicitConvTo(Type *to)\n     //printf(\"TypeVector::implicitConvTo(%s) from %s\\n\", to->toChars(), toChars());\n     if (this == to)\n         return MATCHexact;\n+#ifdef IN_GCC\n     if (to->ty == Tvector)\n     {\n         TypeVector *tv = (TypeVector *)to;\n@@ -3848,6 +3849,10 @@ MATCH TypeVector::implicitConvTo(Type *to)\n         // Otherwise implicitly convertible only if basetypes are.\n         return basetype->implicitConvTo(tv->basetype);\n     }\n+#else\n+    if (ty == to->ty)\n+        return MATCHconvert;\n+#endif\n     return MATCHnomatch;\n }\n "}, {"sha": "954b5019b832aa9f2f01b1296e36d6a7e8a3ac2d", "filename": "gcc/testsuite/gdc.test/compilable/testVRP.d", "status": "modified", "additions": 232, "deletions": 54, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestVRP.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7d33ac5800da1e76d0fb6a838111ca1378f522/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestVRP.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestVRP.d?ref=9d7d33ac5800da1e76d0fb6a838111ca1378f522", "patch": "@@ -1,121 +1,163 @@\n // PERMUTE_ARGS: -O -inline\n \n // Test value-range propagation.\n-// See Bug 3147, Bug 6000, Bug 5225.\n+// https://issues.dlang.org/show_bug.cgi?id=3147\n+// https://issues.dlang.org/show_bug.cgi?id=6000\n+// https://issues.dlang.org/show_bug.cgi?id=5225\n \n-void add() {\n+void add()\n+{\n     byte x, y;\n     short a = x + y;\n }\n \n-void leftShift() {\n+void leftShift()\n+{\n     byte x, y;\n     short z = x << 1;\n }\n \n-void leftShiftFail() {\n-    ubyte x, y;\n-    ushort z;\n-    static assert(!__traits(compiles, z = x << y));\n-    // 1 << 31 surely overflows the range of 'ushort'.\n+void leftShiftFail()\n+{\n+    {\n+        ubyte x, y;\n+        ushort z;\n+        static assert(!__traits(compiles, z = x << y));\n+        // 1 << 31 surely overflows the range of 'ushort'.\n+    }\n+    {\n+        ulong a, b;\n+        int res;\n+        static assert(!__traits(compiles, res = a << (b % 65U)));\n+    }\n }\n \n-void rightShiftFail() {\n-    short x;\n-    byte y, z;\n-    static assert(!__traits(compiles, z = x >> y));\n-    // [this passes in 2.053.]\n+void rightShiftFail()\n+{\n+    {\n+        short x;\n+        byte y, z;\n+        static assert(!__traits(compiles, z = x >> y));\n+        // [this passes in 2.053.]\n+    }\n+    {\n+        ulong a, b;\n+        int res;\n+        static assert(!__traits(compiles, res = a >> (b % 65U)));\n+    }\n }\n \n-void rightShift() {\n+void rightShift()\n+{\n     ushort x;\n     ubyte y = x >> 16;\n }\n \n-void unsignedRightShiftFail() {\n+void unsignedRightShiftFail()\n+{\n     int x;\n     ubyte y;\n     static assert(!__traits(compiles, y = x >>> 2));\n     // [this passes in 2.053.]\n }\n \n-void subtract() {\n+void subtract()\n+{\n     ubyte x, y;\n     short z = x - y;\n }\n \n-void multiply() {\n+void multiply()\n+{\n     byte x, y;\n     short z = x * y;\n }\n \n-void subMulFail() {\n+void subMulFail()\n+{\n     ubyte x, y;\n     ubyte z;\n     static assert(!__traits(compiles, z = x - y));\n     static assert(!__traits(compiles, z = x * y));\n     // [these pass in 2.053.]\n }\n \n-void multiplyNeg1() {\n+void multiplyNeg1()\n+{\n     byte b;\n     b = -1 + (b * -1);\n     static assert(!__traits(compiles, b = -1 + b * ulong.max));\n }\n \n-void divide() {\n+void divide()\n+{\n     short w;\n     byte y = w / 300;\n }\n \n-void divideFail() {\n+void divideFail()\n+{\n     short w;\n     byte y;\n     static assert(!__traits(compiles, y = w / -1));\n }\n \n-void plus1Fail() {\n+void plus1Fail()\n+{\n     byte u, v;\n     static assert(!__traits(compiles, v = u + 1));\n     // [these pass in 2.053.]\n }\n \n-void modulus() {\n+void modulus()\n+{\n     int x;\n     byte u = x % 128;\n }\n \n-void modulus_bug6000a() {\n+void modulus_bug6000a()\n+{\n     ulong t;\n     uint u = t % 16;\n }\n \n-void modulus_bug6000b() {\n+void modulus_bug6000b()\n+{\n     long n = 10520;\n     ubyte b;\n     static assert(!__traits(compiles, b = n % 10));\n }\n \n-void modulus2() {\n+void modulus2()\n+{\n     short s;\n     byte b = byte.max;\n     byte c = s % b;\n }\n \n-void modulus3() {\n+void modulus3()\n+{\n     int i;\n     short s = short.max;\n     short t = i % s;\n }\n \n-void modulus4() {\n+void modulus4()\n+{\n     uint i;\n     ushort s;\n     short t;\n     static assert(!__traits(compiles, t = i % s));\n }\n \n-void modulusFail() {\n+void modulus5()\n+{\n+    short a;\n+    byte foo = (a - short.max - 1) % 127;\n+}\n+\n+void modulusFail()\n+{\n     int i;\n     short s;\n     byte b;\n@@ -124,7 +166,8 @@ void modulusFail() {\n     // [these pass in 2.053.]\n }\n \n-void bitwise() {\n+void bitwise()\n+{\n     ubyte a, b, c;\n     uint d;\n     c = a & b;\n@@ -134,56 +177,159 @@ void bitwise() {\n     // [these pass in 2.053.]\n }\n \n-void bitAnd() {\n+void bitAnd()\n+{\n     byte c;\n     int d;\n     c = (0x3ff_ffffU << (0&c)) & (0x4000_0000U << (0&c));\n     // the result of the above is always 0 :).\n }\n \n-void bitOrFail() {\n-    ubyte c;\n-    static assert(!__traits(compiles, c = c | 0x100));\n-    // [this passes in 2.053.]\n+void bitAndTest()\n+{\n+    {\n+        ushort a, b;\n+        byte res = ((a % 7) - 6) & ((b % 7) - 6);\n+    }\n+    {\n+        // rhs[-128..127] outside range of lhs[0..255]\n+        //   -> calls byte.implicitConvTo(ubyte) => MATCH.convert\n+        byte a, b;\n+        ubyte res;\n+\n+        res = cast(byte)(a + 5) & b;\n+        res = cast(byte)(a - 5) & b;\n+        res = cast(byte)(a / 5) & b;\n+        res = cast(byte)(a * 5) & b;\n+        res = cast(byte)(a % 5) & b;\n+    }\n+}\n+\n+void bitOrFail()\n+{\n+    {\n+        ubyte c;\n+        static assert(!__traits(compiles, c = c | 0x100));\n+        // [this passes in 2.053.]\n+    }\n+    {\n+        byte a, b;\n+        ubyte res;\n+\n+        static assert(!__traits(compiles, res = (a + 5) | b)); // [-128..255]\n+        static assert(!__traits(compiles, res = (a - 5) | b)); // [-133..127]\n+        static assert(!__traits(compiles, res = (a / 5) | b)); // [-128..127]\n+        static assert(!__traits(compiles, res = (a * 5) | b)); // [-640..639]\n+        static assert(!__traits(compiles, res = (a % 5) | b)); // [-128..127]\n+    }\n }\n \n-void bitAndOr() {\n+void bitAndOr()\n+{\n     ubyte c;\n     c = (c | 0x1000) & ~0x1000;\n }\n \n-void bitAndFail() {\n-    int d;\n-    short s;\n-    byte c;\n-    static assert(!__traits(compiles, c = d & s));\n-    static assert(!__traits(compiles, c = d & 256));\n-    // [these pass in 2.053.]\n+void bitOrTest()\n+{\n+    {\n+        // Tests condition for different signs between min & max\n+        // ((imin.negative ^ imax.negative) == 1 && (rhs.imin.negative ^ rhs.imax.negative) == 1\n+        ushort a, b;\n+        byte res = ((a % 127) - 126) | ((b % 6) - 5);\n+    }\n+    {\n+        // rhs[-128..127] outside range of lhs[0..255]\n+        //   -> calls byte.implicitConvTo(ubyte) => MATCH.convert\n+        byte a, b, c;\n+        ubyte res;\n+\n+        res = cast(byte)(a + 5) | b;\n+        res = cast(byte)(a - 5) | b;\n+        res = cast(byte)(a / 5) | b;\n+        res = cast(byte)(a * 5) | b;\n+        res = cast(byte)(a % 5) | b;\n+    }\n }\n \n-void bitXor() {\n-    ushort s;\n-    ubyte c;\n-    c = (0xffff << (s&0)) ^ 0xff00;\n+void bitAndFail()\n+{\n+    {\n+        int d;\n+        short s;\n+        byte c;\n+        static assert(!__traits(compiles, c = d & s));\n+        static assert(!__traits(compiles, c = d & 256));\n+        // [these pass in 2.053.]\n+    }\n+    {\n+        byte a, b;\n+        ubyte res;\n+\n+        static assert(!__traits(compiles, res = (a + 5) & b)); // [-128..132]\n+        static assert(!__traits(compiles, res = (a - 5) & b)); // [-256..127]\n+        static assert(!__traits(compiles, res = (a / 5) & b)); // [-128..127]\n+        static assert(!__traits(compiles, res = (a * 5) & b)); // [-640..635]\n+        static assert(!__traits(compiles, res = (a % 5) & b)); // [-128..127]\n+    }\n+}\n+\n+void bitXor()\n+{\n+    {\n+        ushort s;\n+        ubyte c;\n+        c = (0xffff << (s & 0)) ^ 0xff00;\n+    }\n+    {\n+        // rhs[-128..127] outside range of lhs[0..255]\n+        //   -> calls byte.implicitConvTo(ubyte) => MATCH.convert\n+        byte a, b, c;\n+        ubyte res;\n+\n+        res = cast(byte)(a + 5) ^ b;\n+        res = cast(byte)(a - 5) ^ b;\n+        res = cast(byte)(a / 5) ^ b;\n+        res = cast(byte)(a * 5) ^ b;\n+        res = cast(byte)(a % 5) ^ b;\n+    }\n }\n \n-void bitComplement() {\n+void bitXorFail()\n+{\n+    {\n+        byte a, b;\n+        ubyte res;\n+\n+        static assert(!__traits(compiles, res = (a + 5) ^ b)); // [-256..255]\n+        static assert(!__traits(compiles, res = (a - 5) ^ b)); // [-256..255]\n+        static assert(!__traits(compiles, res = (a / 5) ^ b)); // [-128..127]\n+        static assert(!__traits(compiles, res = (a * 5) ^ b)); // [-640..1023]\n+        static assert(!__traits(compiles, res = (a % 5) ^ b)); // [-128..127]\n+    }\n+}\n+\n+void bitComplement()\n+{\n     int i;\n     ubyte b = ~(i | ~0xff);\n }\n \n-void bitComplementFail() {\n+void bitComplementFail()\n+{\n     ubyte b;\n     static assert(!__traits(compiles, b = ~(b | 1)));\n     // [this passes in 2.053.]\n }\n \n-void negation() {\n+void negation()\n+{\n     int x;\n     byte b = -(x & 0x7);\n }\n \n-void negationFail() {\n+void negationFail()\n+{\n     int x;\n     byte b;\n     static assert(!__traits(compiles, b = -(x & 255)));\n@@ -200,7 +346,8 @@ short bug1977_comment5(byte i) {\n   return o;\n }\n \n-void testDchar() {\n+void testDchar()\n+{\n     dchar d;\n     uint i;\n     /+\n@@ -210,13 +357,15 @@ void testDchar() {\n     d = i % 0x110000;\n }\n \n-void bug1977_comment11() {\n+void bug1977_comment11()\n+{\n     uint a;\n     byte b = a & 1;\n     // [this passes in 2.053.]\n }\n \n-void bug1977_comment20() {\n+void bug1977_comment20()\n+{\n     long a;\n     int b = a % 1000;\n }\n@@ -329,3 +478,32 @@ void test13001(bool unknown)\n         static assert(!__traits(compiles, b = i + 254));\n     }\n }\n+\n+void test10310()\n+{\n+    int y;\n+    ubyte x = ((y & 252) ^ 2) + 1;\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=15289\n+void test15289a()\n+{\n+    int [] arr = [1, 2, 3, 4];\n+    uint foo = 50 / arr.length;\n+}\n+\n+void test15289b()\n+{\n+    int [] arr = [1, 2, 3, 4];\n+    uint foo = 50 % arr.length;\n+}\n+\n+void testShiftRightOnNegative()\n+{\n+    int neg = -1;\n+    uint[] arr = [1, 2, 3];\n+    ubyte b;\n+    // Shift with negative value returns value in range [0, ulong.max]\n+    static assert(!__traits(compiles, b = arr.length >> neg));\n+    static assert(!__traits(compiles, b = arr.length << neg));\n+}"}]}