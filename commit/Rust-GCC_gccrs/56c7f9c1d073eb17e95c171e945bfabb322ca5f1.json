{"sha": "56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjN2Y5YzFkMDczZWIxN2U5NWMxNzFlOTQ1YmZhYmIzMjJjYTVmMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-11-27T03:38:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-11-27T03:38:57Z"}, "message": "re PR c++/29886 (Cast misinterpreted as variable declaration)\n\n\tPR c++/29886\n\t* parser.c (cp_parser): Add in_function_body.\n\t(cp_parser_new): Initialize it.\n\t(cp_parser_primary_expression): Use parser->in_function_body\n\tinstead of at_function_scope_p.\n\t(cp_parser_asm_definition): Likewise.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_class_specifier): Clear parser->in_function_body.\n\t(cp_parser_constructor_declarator_p): Use parser->in_function_body\n\tinstead of at_function_scope_p.\n\t(cp_parser_function_body_after_declarator): Set\n\tparser->in_function_body.\n\tPR c++/29886\n\t* g++.dg/expr/cast8.C: New test.\n\nFrom-SVN: r119242", "tree": {"sha": "8286b3f99f0ffc3955165946f34a9bbf324c1b16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8286b3f99f0ffc3955165946f34a9bbf324c1b16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/comments", "author": null, "committer": null, "parents": [{"sha": "f019376cf52c44761f3ad38ef7ea9f0465f30306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f019376cf52c44761f3ad38ef7ea9f0465f30306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f019376cf52c44761f3ad38ef7ea9f0465f30306"}], "stats": {"total": 59, "additions": 53, "deletions": 6}, "files": [{"sha": "095c2fe55270147fd7db311ae2a05a8f87a61b0b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "patch": "@@ -1,3 +1,18 @@\n+2006-11-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/29886\n+\t* parser.c (cp_parser): Add in_function_body.\n+\t(cp_parser_new): Initialize it.\n+\t(cp_parser_primary_expression): Use parser->in_function_body\n+\tinstead of at_function_scope_p.\n+\t(cp_parser_asm_definition): Likewise.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_class_specifier): Clear parser->in_function_body.\n+\t(cp_parser_constructor_declarator_p): Use parser->in_function_body\n+\tinstead of at_function_scope_p.\n+\t(cp_parser_function_body_after_declarator): Set\n+\tparser->in_function_body.\n+\n 2006-11-21      Douglas Gregor <doug.gregor@gmail.com>\n \n         * cp-tree.def (STATIC_ASSERT): New.  "}, {"sha": "b6b1c9729210db0c72eda4c665cb3bc34894d576", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "patch": "@@ -1390,6 +1390,10 @@ typedef struct cp_parser GTY(())\n      character set.  */\n   bool translate_strings_p;\n \n+  /* TRUE if we are presently parsing the body of a function, but not\n+     a local class.  */\n+  bool in_function_body;\n+\n   /* If non-NULL, then we are parsing a construct where new type\n      definitions are not permitted.  The string stored here will be\n      issued as an error message if a type is defined.  */\n@@ -2634,6 +2638,9 @@ cp_parser_new (void)\n   /* String literals should be translated to the execution character set.  */\n   parser->translate_strings_p = true;\n \n+  /* We are not parsing a function body.  */\n+  parser->in_function_body = false;\n+\n   /* The unparsed function queue is empty.  */\n   parser->unparsed_functions_queues = build_tree_list (NULL_TREE, NULL_TREE);\n \n@@ -2990,7 +2997,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t int i = ({ int j = 3; j + 1; });\n \n \t       at class or namespace scope.  */\n-\t    if (!at_function_scope_p ())\n+\t    if (!parser->in_function_body)\n \t      error (\"statement-expressions are allowed only inside functions\");\n \t    /* Start the statement-expression.  */\n \t    expr = begin_stmt_expr ();\n@@ -10952,7 +10959,7 @@ cp_parser_asm_definition (cp_parser* parser)\n      too.  Doing that means that we have to treat the `::' operator as\n      two `:' tokens.  */\n   if (cp_parser_allow_gnu_extensions_p (parser)\n-      && at_function_scope_p ()\n+      && parser->in_function_body\n       && (cp_lexer_next_token_is (parser->lexer, CPP_COLON)\n \t  || cp_lexer_next_token_is (parser->lexer, CPP_SCOPE)))\n     {\n@@ -11018,7 +11025,7 @@ cp_parser_asm_definition (cp_parser* parser)\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n \n   /* Create the ASM_EXPR.  */\n-  if (at_function_scope_p ())\n+  if (parser->in_function_body)\n     {\n       asm_stmt = finish_asm_stmt (volatile_p, string, outputs,\n \t\t\t\t  inputs, clobbers);\n@@ -11698,7 +11705,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      /* Normally, the array bound must be an integral constant\n \t\t expression.  However, as an extension, we allow VLAs\n \t\t in function scopes.  */\n-\t      else if (!at_function_scope_p ())\n+\t      else if (!parser->in_function_body)\n \t\t{\n \t\t  error (\"array bound is not an integer constant\");\n \t\t  bounds = error_mark_node;\n@@ -13080,6 +13087,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   int has_trailing_semicolon;\n   bool nested_name_specifier_p;\n   unsigned saved_num_template_parameter_lists;\n+  bool saved_in_function_body;\n   tree old_scope = NULL_TREE;\n   tree scope = NULL_TREE;\n \n@@ -13114,6 +13122,9 @@ cp_parser_class_specifier (cp_parser* parser)\n   saved_num_template_parameter_lists\n     = parser->num_template_parameter_lists;\n   parser->num_template_parameter_lists = 0;\n+  /* We are not in a function body.  */\n+  saved_in_function_body = parser->in_function_body;\n+  parser->in_function_body = false;\n \n   /* Start the class.  */\n   if (nested_name_specifier_p)\n@@ -13222,7 +13233,8 @@ cp_parser_class_specifier (cp_parser* parser)\n   /* Put back any saved access checks.  */\n   pop_deferring_access_checks ();\n \n-  /* Restore the count of active template-parameter-lists.  */\n+  /* Restore saved state.  */\n+  parser->in_function_body = saved_in_function_body;\n   parser->num_template_parameter_lists\n     = saved_num_template_parameter_lists;\n \n@@ -15388,7 +15400,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n   /* The common case is that this is not a constructor declarator, so\n      try to avoid doing lots of work if at all possible.  It's not\n      valid declare a constructor at function scope.  */\n-  if (at_function_scope_p ())\n+  if (parser->in_function_body)\n     return false;\n   /* And only certain tokens can begin a constructor declarator.  */\n   next_token = cp_lexer_peek_token (parser->lexer);\n@@ -15578,8 +15590,11 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n   tree fn;\n   bool ctor_initializer_p = false;\n   bool saved_in_unbraced_linkage_specification_p;\n+  bool saved_in_function_body;\n   unsigned saved_num_template_parameter_lists;\n \n+  saved_in_function_body = parser->in_function_body;\n+  parser->in_function_body = true;\n   /* If the next token is `return', then the code may be trying to\n      make use of the \"named return value\" extension that G++ used to\n      support.  */\n@@ -15633,6 +15648,7 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n     = saved_in_unbraced_linkage_specification_p;\n   parser->num_template_parameter_lists\n     = saved_num_template_parameter_lists;\n+  parser->in_function_body = saved_in_function_body;\n \n   return fn;\n }"}, {"sha": "f5cd43d3965e6e6ae1bcbc253cbab857d35db18f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "patch": "@@ -1,3 +1,8 @@\n+2006-11-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/29886\n+\t* g++.dg/expr/cast8.C: New test.\n+\n 2006-11-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-minmax-1.c: Test NaN in fmin/fmax."}, {"sha": "9f1ce36f487ccbe587b2fcce9edc8e0e0a151285", "filename": "gcc/testsuite/g++.dg/expr/cast8.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56c7f9c1d073eb17e95c171e945bfabb322ca5f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast8.C?ref=56c7f9c1d073eb17e95c171e945bfabb322ca5f1", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/29886\n+\n+struct A {\n+  static int x[1];\n+};\n+\n+void foo(int i)\n+{\n+  if (int(A::x[i])) {}\n+}\n+"}]}