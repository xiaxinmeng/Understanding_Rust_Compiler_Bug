{"sha": "529749b9480f8690c8474cd782664a2d38459ad2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI5NzQ5Yjk0ODBmODY5MGM4NDc0Y2Q3ODI2NjRhMmQzODQ1OWFkMg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-22T13:26:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-22T13:26:28Z"}, "message": "[Ada] In-place initialization for Initialize_Scalars\n\nThis patch optimizes the initialization and allocation of scalar array objects\nwhen pragma Initialize_Scalars is in effect. The patch also extends the syntax\nand semantics of pragma Initialize_Scalars to allow for the specification of\ninvalid values pertaining to families of scalar types. The new syntax is as\nfollows:\n\n   pragma Initialize_Scalars\n     [ ( TYPE_VALUE_PAIR {, TYPE_VALUE_PAIR} ) ];\n\n   TYPE_VALUE_PAIR ::=\n     SCALAR_TYPE => static_EXPRESSION\n\n   SCALAR_TYPE :=\n     Short_Float\n   | Float\n   | Long_Float\n   | Long_Long_Flat\n   | Signed_8\n   | Signed_16\n   | Signed_32\n   | Signed_64\n   | Unsigned_8\n   | Unsigned_16\n   | Unsigned_32\n   | Unsigned_64\n\nDepending on the value specified by pragma Initialize_Scalars, the backend may\noptimize the creation of the scalar array object into a fast memset.\n\n------------\n-- Source --\n------------\n\n--  gnat.adc\n\npragma Initialize_Scalars\n  (Short_Float     => 0.0,\n   Float           => 0.0,\n   Long_Float      => 0.0,\n   Long_Long_Float => 0.0,\n   Signed_8        => 0,\n   Signed_16       => 0,\n   Signed_32       => 0,\n   Signed_64       => 0,\n   Unsigned_8      => 0,\n   Unsigned_16     => 0,\n   Unsigned_32     => 0,\n   Unsigned_64     => 0);\n\n--  types.ads\n\nwith System;\n\npackage Types is\n   Max : constant := 10_000;\n   subtype Big is Integer range 1 .. Max;\n\n   type Byte is range 0 .. 255;\n   for Byte'Size use System.Storage_Unit;\n\n   type Byte_Arr_1 is array (1 .. Max) of Byte;\n   type Byte_Arr_2 is array (Big) of Byte;\n   type Byte_Arr_3 is array (Integer range <>) of Byte;\n   type Byte_Arr_4 is array (Integer range <>,\n                             Integer range <>) of Byte;\n   type Constr_Arr_1 is array (1 .. Max) of Integer;\n   type Constr_Arr_2 is array (Big) of Integer;\n   type Constr_Arr_3 is array (1 .. Max, 1 .. Max) of Integer;\n   type Constr_Arr_4 is array (Big, Big) of Integer;\n\n   type Unconstr_Arr_1 is array (Integer range <>) of Integer;\n   type Unconstr_Arr_2 is array (Integer range <>,\n                                 Integer range <>) of Integer;\n\n   subtype Subt_Arr_1 is Unconstr_Arr_1 (1 .. Max);\n   subtype Subt_Arr_2 is Unconstr_Arr_1 (Big);\n   subtype Subt_Arr_3 is Unconstr_Arr_2 (1 .. Max, 1 .. Max);\n   subtype Subt_Arr_4 is Unconstr_Arr_2 (Big, Big);\n\n   subtype Subt_Str_1 is String (1 .. Max);\n   subtype Subt_Str_2 is String (Big);\n\n   type Byte_Arr_1_Ptr     is access Byte_Arr_1;\n   type Byte_Arr_2_Ptr     is access Byte_Arr_2;\n   type Byte_Arr_3_Ptr     is access Byte_Arr_3;\n   type Byte_Arr_4_Ptr     is access Byte_Arr_4;\n   type Constr_Arr_1_Ptr   is access Constr_Arr_1;\n   type Constr_Arr_2_Ptr   is access Constr_Arr_2;\n   type Constr_Arr_3_Ptr   is access Constr_Arr_3;\n   type Constr_Arr_4_Ptr   is access Constr_Arr_4;\n   type Unconstr_Arr_1_Ptr is access Unconstr_Arr_1;\n   type Unconstr_Arr_2_Ptr is access Unconstr_Arr_2;\n   type Subt_Arr_1_Ptr     is access Subt_Arr_1;\n   type Subt_Arr_2_Ptr     is access Subt_Arr_2;\n   type Subt_Arr_3_Ptr     is access Subt_Arr_3;\n   type Subt_Arr_4_Ptr     is access Subt_Arr_4;\n   type Str_Ptr            is access String;\n   type Subt_Str_1_Ptr     is access Subt_Str_1;\n   type Subt_Str_2_Ptr     is access Subt_Str_2;\nend Types;\n\n--  main.adb\n\nwith Types; use Types;\n\nprocedure Main is\n   Byte_Arr_1_Obj     : Byte_Arr_1;\n   Byte_Arr_2_Obj     : Byte_Arr_2;\n   Byte_Arr_3_Obj     : Byte_Arr_3 (1 .. Max);\n   Byte_Arr_4_Obj     : Byte_Arr_3 (Big);\n   Byte_Arr_5_Obj     : Byte_Arr_4 (1 .. Max, 1 .. Max);\n   Byte_Arr_6_Obj     : Byte_Arr_4 (Big, Big);\n   Constr_Arr_1_Obj   : Constr_Arr_1;\n   Constr_Arr_2_Obj   : Constr_Arr_2;\n   Constr_Arr_3_Obj   : Constr_Arr_3;\n   Constr_Arr_4_Obj   : Constr_Arr_4;\n   Unconstr_Arr_1_Obj : Unconstr_Arr_1 (1 .. Max);\n   Unconstr_Arr_2_Obj : Unconstr_Arr_1 (Big);\n   Unconstr_Arr_3_Obj : Unconstr_Arr_2 (1 .. Max, 1 .. Max);\n   Unconstr_Arr_4_Obj : Unconstr_Arr_2 (Big, Big);\n   Subt_Arr_1_Obj     : Subt_Arr_1;\n   Subt_Arr_2_Obj     : Subt_Arr_2;\n   Subt_Arr_3_Obj     : Subt_Arr_3;\n   Subt_Arr_4_Obj     : Subt_Arr_4;\n   Str_1_Obj          : String (1 .. Max);\n   Str_2_Obj          : String (Big);\n   Subt_Str_1_Obj     : Subt_Str_1;\n   Subt_Str_2_Obj     : Subt_Str_2;\n\n   Byte_Arr_1_Ptr_Obj     : Byte_Arr_1_Ptr     := new Byte_Arr_1;\n   Byte_Arr_2_Ptr_Obj     : Byte_Arr_2_Ptr     := new Byte_Arr_2;\n   Byte_Arr_3_Ptr_Obj     : Byte_Arr_3_Ptr     := new Byte_Arr_3 (1 .. Max);\n   Byte_Arr_4_Ptr_Obj     : Byte_Arr_3_Ptr     := new Byte_Arr_3 (Big);\n   Byte_Arr_5_Ptr_Obj     : Byte_Arr_4_Ptr     :=\n                              new Byte_Arr_4 (1 .. Max, 1 .. Max);\n   Byte_Arr_6_Ptr_Obj     : Byte_Arr_4_Ptr     := new Byte_Arr_4 (Big, Big);\n   Constr_Arr_1_Ptr_Obj   : Constr_Arr_1_Ptr   := new Constr_Arr_1;\n   Constr_Arr_2_Ptr_Obj   : Constr_Arr_2_Ptr   := new Constr_Arr_2;\n   Constr_Arr_3_Ptr_Obj   : Constr_Arr_3_Ptr   := new Constr_Arr_3;\n   Constr_Arr_4_Ptr_Obj   : Constr_Arr_4_Ptr   := new Constr_Arr_4;\n   Unconstr_Arr_1_Ptr_Obj : Unconstr_Arr_1_Ptr :=\n                              new Unconstr_Arr_1 (1 .. Max);\n   Unconstr_Arr_2_Ptr_Obj : Unconstr_Arr_1_Ptr := new Unconstr_Arr_1 (Big);\n   Unconstr_Arr_3_Ptr_Obj : Unconstr_Arr_2_Ptr :=\n                              new Unconstr_Arr_2 (1 .. Max, 1 .. Max);\n   Unconstr_Arr_4_Ptr_Obj : Unconstr_Arr_2_Ptr :=\n                              new Unconstr_Arr_2 (Big, Big);\n   Subt_Arr_1_Ptr_Obj     : Subt_Arr_1_Ptr     := new Subt_Arr_1;\n   Subt_Arr_2_Ptr_Obj     : Subt_Arr_2_Ptr     := new Subt_Arr_2;\n   Subt_Arr_3_Ptr_Obj     : Subt_Arr_3_Ptr     := new Subt_Arr_3;\n   Subt_Arr_4_Ptr_Obj     : Subt_Arr_4_Ptr     := new Subt_Arr_4;\n   Str_Ptr_1_Obj          : Str_Ptr            := new String (1 .. Max);\n   Str_Ptr_2_Obj          : Str_Ptr            := new String (Big);\n   Subt_Str_1_Ptr_Obj     : Subt_Str_1_Ptr     := new Subt_Str_1;\n   Subt_Str_2_Ptr_Obj     : Subt_Str_2_Ptr     := new Subt_Str_2;\nbegin null; end Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gcc -c -S -gnatDG -gnatws main.adb\n$ grep -c \"others => types__TbyteB!(0));\" main.adb.dg\n$ grep -c \"others => integer!(0));\" main.adb.dg\n$ grep -c \"others => character!(0));\" main.adb.dg\n$ grep -c \"others => types__TbyteB!(0));\" main.adb.dg\n$ grep -c \"memset\" main.s\n8\n12\n8\n8\n44\n\n2018-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Strip away any\n\tconversions before extracting the value of the expression.\n\t* exp_ch3.adb (Default_Initialize_Object): Optimize the default\n\tinitialization of an array of scalars.\n\t(Get_Simple_Init_Val): Add processing for array types. Remove the\n\tprocessing of strings because this case is already handled by the array\n\tcase.\n\t(Needs_Simple_Initialization): Moved to Sem_Util.\n\t(Simple_Init_Array_Type): New routine.\n\t(Simple_Init_Initialize_Scalars_Type): Reimplemented to use the new\n\tfacilities from Sem_Util.\n\t(Simple_Initialization_OK): New routine.\n\t* exp_ch3.ads (Needs_Simple_Initialization): Moved to Sem_Util.\n\t* exp_ch4.adb (Expand_N_Allocator): Optimize the default allocation of\n\tan array of scalars.\n\t* sem_prag.adb (Analyze_Float_Value): New routine.\n\t(Analyze_Integer_Value): New routine.\n\t(Analyze_Pragma): Reimplement the analysis of pragma Initialize_Scalars\n\tto handled the extended form of the pragma.\n\t(Analyze_Type_Value_Pair): New routine.\n\t* sem_util.adb: Add invalid value-related data structures.\n\t(Examine_Array_Bounds): New routine.\n\t(Has_Static_Array_Bounds): Reimplemented.\n\t(Has_Static_Non_Empty_Array_Bounds): New routine.\n\t(Invalid_Scalar_Value): New routine.\n\t(Needs_Simple_Initialization): Moved from Exp_Ch3.\n\t(Set_Invalid_Scalar_Value): New routines.\n\t* sem_util.ads (Has_Static_Non_Empty_Array_Bounds): New routine.\n\t(Invalid_Scalar_Value): New routine.\n\t(Needs_Simple_Initialization): Moved from Exp_Ch3.\n\t(Set_Invalid_Scalar_Value): New routines.\n\t* snames.ads-tmpl: Add names for the salar type families used by pragma\n\tInitialize_Scalars.\n\nFrom-SVN: r260529", "tree": {"sha": "67720e906fb46d265b635cf802d1bd6e25a23d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67720e906fb46d265b635cf802d1bd6e25a23d14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/529749b9480f8690c8474cd782664a2d38459ad2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529749b9480f8690c8474cd782664a2d38459ad2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/529749b9480f8690c8474cd782664a2d38459ad2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529749b9480f8690c8474cd782664a2d38459ad2/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b00baef5ad6140128cf7510aa5928bdf032717cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00baef5ad6140128cf7510aa5928bdf032717cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00baef5ad6140128cf7510aa5928bdf032717cb"}], "stats": {"total": 1034, "additions": 830, "deletions": 204}, "files": [{"sha": "748e4a4bb77aeb50f43d5db7b3c47d5d840a535e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -1,3 +1,39 @@\n+2018-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Strip away any\n+\tconversions before extracting the value of the expression.\n+\t* exp_ch3.adb (Default_Initialize_Object): Optimize the default\n+\tinitialization of an array of scalars.\n+\t(Get_Simple_Init_Val): Add processing for array types. Remove the\n+\tprocessing of strings because this case is already handled by the array\n+\tcase.\n+\t(Needs_Simple_Initialization): Moved to Sem_Util.\n+\t(Simple_Init_Array_Type): New routine.\n+\t(Simple_Init_Initialize_Scalars_Type): Reimplemented to use the new\n+\tfacilities from Sem_Util.\n+\t(Simple_Initialization_OK): New routine.\n+\t* exp_ch3.ads (Needs_Simple_Initialization): Moved to Sem_Util.\n+\t* exp_ch4.adb (Expand_N_Allocator): Optimize the default allocation of\n+\tan array of scalars.\n+\t* sem_prag.adb (Analyze_Float_Value): New routine.\n+\t(Analyze_Integer_Value): New routine.\n+\t(Analyze_Pragma): Reimplement the analysis of pragma Initialize_Scalars\n+\tto handled the extended form of the pragma.\n+\t(Analyze_Type_Value_Pair): New routine.\n+\t* sem_util.adb: Add invalid value-related data structures.\n+\t(Examine_Array_Bounds): New routine.\n+\t(Has_Static_Array_Bounds): Reimplemented.\n+\t(Has_Static_Non_Empty_Array_Bounds): New routine.\n+\t(Invalid_Scalar_Value): New routine.\n+\t(Needs_Simple_Initialization): Moved from Exp_Ch3.\n+\t(Set_Invalid_Scalar_Value): New routines.\n+\t* sem_util.ads (Has_Static_Non_Empty_Array_Bounds): New routine.\n+\t(Invalid_Scalar_Value): New routine.\n+\t(Needs_Simple_Initialization): Moved from Exp_Ch3.\n+\t(Set_Invalid_Scalar_Value): New routines.\n+\t* snames.ads-tmpl: Add names for the salar type families used by pragma\n+\tInitialize_Scalars.\n+\n 2018-05-22  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_disp.adb (Make_DT): Initialize the External_Tag with an empty"}, {"sha": "975d32ff3597372d77ce90bf0d54be31849cfb58", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -4918,20 +4918,21 @@ package body Exp_Aggr is\n       --  specifically optimized for the target.\n \n       function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean is\n+         Csiz      : Uint;\n          Ctyp      : Entity_Id;\n+         Expr      : Node_Id;\n+         High      : Node_Id;\n          Index     : Entity_Id;\n-         Expr      : Node_Id := N;\n          Low       : Node_Id;\n-         High      : Node_Id;\n-         Csiz      : Uint;\n+         Nunits    : Int;\n          Remainder : Uint;\n          Value     : Uint;\n-         Nunits    : Nat;\n \n       begin\n          --  Recurse as far as possible to find the innermost component type\n \n          Ctyp := Etype (N);\n+         Expr := N;\n          while Is_Array_Type (Ctyp) loop\n             if Nkind (Expr) /= N_Aggregate\n               or else not Is_Others_Aggregate (Expr)\n@@ -5022,6 +5023,15 @@ package body Exp_Aggr is\n \n          Analyze_And_Resolve (Expr, Ctyp);\n \n+         --  Strip away any conversions from the expression as they simply\n+         --  qualify the real expression.\n+\n+         while Nkind_In (Expr, N_Unchecked_Type_Conversion,\n+                               N_Type_Conversion)\n+         loop\n+            Expr := Expression (Expr);\n+         end loop;\n+\n          Nunits := UI_To_Int (Csiz) / System_Storage_Unit;\n \n          if Nunits = 1 then"}, {"sha": "fe755e3b1238d69096d701f25e96b9758de8c63c", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 143, "deletions": 128, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -5936,6 +5936,11 @@ package body Exp_Ch3 is\n          --  Return a new reference to Def_Id with attributes Assignment_OK and\n          --  Must_Not_Freeze already set.\n \n+         function Simple_Initialization_OK\n+           (Init_Typ : Entity_Id) return Boolean;\n+         --  Determine whether object declaration N with entity Def_Id needs\n+         --  simple initialization, assuming that it is of type Init_Typ.\n+\n          --------------------------\n          -- New_Object_Reference --\n          --------------------------\n@@ -5957,6 +5962,28 @@ package body Exp_Ch3 is\n             return Obj_Ref;\n          end New_Object_Reference;\n \n+         ------------------------------\n+         -- Simple_Initialization_OK --\n+         ------------------------------\n+\n+         function Simple_Initialization_OK\n+           (Init_Typ : Entity_Id) return Boolean\n+         is\n+         begin\n+            --  Do not consider the object declaration if it comes with an\n+            --  initialization expression, or is internal in which case it\n+            --  will be assigned later.\n+\n+            return\n+              not Is_Internal (Def_Id)\n+                and then not Has_Init_Expression (N)\n+                and then Needs_Simple_Initialization\n+                           (Typ         => Init_Typ,\n+                            Consider_IS =>\n+                              Initialize_Scalars\n+                                and then No (Following_Address_Clause (N)));\n+         end Simple_Initialization_OK;\n+\n          --  Local variables\n \n          Exceptions_OK : constant Boolean :=\n@@ -6041,6 +6068,41 @@ package body Exp_Ch3 is\n                elsif Build_Equivalent_Aggregate then\n                   null;\n \n+               --  Optimize the default initialization of an array object when\n+               --  the following conditions are met:\n+               --\n+               --    * Pragma Initialize_Scalars or Normalize_Scalars is in\n+               --      effect.\n+               --\n+               --    * The bounds of the array type are static and lack empty\n+               --      ranges.\n+               --\n+               --    * The array type does not contain atomic components or is\n+               --      treated as packed.\n+               --\n+               --    * The component is of a scalar type which requires simple\n+               --      initialization.\n+               --\n+               --  Construct an in-place initialization aggregate which may be\n+               --  convert into a fast memset by the backend.\n+\n+               elsif Init_Or_Norm_Scalars\n+                 and then Is_Array_Type (Typ)\n+                 and then not Has_Atomic_Components (Typ)\n+                 and then not Is_Packed (Typ)\n+                 and then Has_Static_Non_Empty_Array_Bounds (Typ)\n+                 and then Is_Scalar_Type (Component_Type (Typ))\n+                 and then Simple_Initialization_OK (Component_Type (Typ))\n+               then\n+                  Set_No_Initialization (N, False);\n+                  Set_Expression (N,\n+                    Get_Simple_Init_Val\n+                      (Typ  => Typ,\n+                       N    => Obj_Def,\n+                       Size => Esize (Def_Id)));\n+\n+                  Analyze_And_Resolve (Expression (N), Typ);\n+\n                --  Otherwise invoke the type init proc, generate:\n                --    Type_Init_Proc (Obj);\n \n@@ -6056,15 +6118,8 @@ package body Exp_Ch3 is\n             end if;\n \n          --  Provide a default value if the object needs simple initialization\n-         --  and does not already have an initial value. A generated temporary\n-         --  does not require initialization because it will be assigned later.\n \n-         elsif Needs_Simple_Initialization\n-                 (Typ, Initialize_Scalars\n-                         and then No (Following_Address_Clause (N)))\n-           and then not Is_Internal (Def_Id)\n-           and then not Has_Init_Expression (N)\n-         then\n+         elsif Simple_Initialization_OK (Typ) then\n             Set_No_Initialization (N, False);\n             Set_Expression (N,\n               Get_Simple_Init_Val\n@@ -7954,6 +8009,9 @@ package body Exp_Ch3 is\n       --    * Hi_Bound - Set to No_Unit when there is no information available,\n       --      or to the known high bound.\n \n+      function Simple_Init_Array_Type return Node_Id;\n+      --  Build an expression to initialize array type Typ\n+\n       function Simple_Init_Defaulted_Type return Node_Id;\n       --  Build an expression to initialize type Typ which is subject to\n       --  aspect Default_Value.\n@@ -7974,9 +8032,6 @@ package body Exp_Ch3 is\n       function Simple_Init_Scalar_Type return Node_Id;\n       --  Build an expression to initialize scalar type Typ\n \n-      function Simple_Init_String_Type return Node_Id;\n-      --  Build an expression to initialize string type Typ\n-\n       ----------------------------\n       -- Extract_Subtype_Bounds --\n       ----------------------------\n@@ -8034,6 +8089,57 @@ package body Exp_Ch3 is\n          end loop;\n       end Extract_Subtype_Bounds;\n \n+      ----------------------------\n+      -- Simple_Init_Array_Type --\n+      ----------------------------\n+\n+      function Simple_Init_Array_Type return Node_Id is\n+         Comp_Typ : constant Entity_Id := Component_Type (Typ);\n+\n+         function Simple_Init_Dimension (Index : Node_Id) return Node_Id;\n+         --  Initialize a single array dimension with index constraint Index\n+\n+         --------------------\n+         -- Simple_Init_Dimension --\n+         --------------------\n+\n+         function Simple_Init_Dimension (Index : Node_Id) return Node_Id is\n+         begin\n+            --  Process the current dimension\n+\n+            if Present (Index) then\n+\n+               --  Build a suitable \"others\" aggregate for the next dimension,\n+               --  or initialize the component itself. Generate:\n+               --\n+               --    (others => ...)\n+\n+               return\n+                 Make_Aggregate (Loc,\n+                   Component_Associations => New_List (\n+                     Make_Component_Association (Loc,\n+                       Choices    => New_List (Make_Others_Choice (Loc)),\n+                       Expression =>\n+                         Simple_Init_Dimension (Next_Index (Index)))));\n+\n+            --  Otherwise all dimensions have been processed. Initialize the\n+            --  component itself.\n+\n+            else\n+               return\n+                 Get_Simple_Init_Val\n+                   (Typ  => Comp_Typ,\n+                    N    => N,\n+                    Size => Esize (Comp_Typ));\n+            end if;\n+         end Simple_Init_Dimension;\n+\n+      --  Start of processing for Simple_Init_Array_Type\n+\n+      begin\n+         return Simple_Init_Dimension (First_Index (Typ));\n+      end Simple_Init_Array_Type;\n+\n       --------------------------------\n       -- Simple_Init_Defaulted_Type --\n       --------------------------------\n@@ -8080,67 +8186,63 @@ package body Exp_Ch3 is\n          Float_Typ : Entity_Id;\n          Hi_Bound  : Uint;\n          Lo_Bound  : Uint;\n-         Val_RE    : RE_Id;\n+         Scal_Typ  : Scalar_Id;\n \n       begin\n          Extract_Subtype_Bounds (Lo_Bound, Hi_Bound);\n \n-         --  For float types, use float values from System.Scalar_Values\n+         --  Float types\n \n          if Is_Floating_Point_Type (Typ) then\n             Float_Typ := Root_Type (Typ);\n \n             if Float_Typ = Standard_Short_Float then\n-               Val_RE := RE_IS_Isf;\n+               Scal_Typ := Name_Short_Float;\n             elsif Float_Typ = Standard_Float then\n-               Val_RE := RE_IS_Ifl;\n+               Scal_Typ := Name_Float;\n             elsif Float_Typ = Standard_Long_Float then\n-               Val_RE := RE_IS_Ilf;\n+               Scal_Typ := Name_Long_Float;\n             else pragma Assert (Float_Typ = Standard_Long_Long_Float);\n-               Val_RE := RE_IS_Ill;\n+               Scal_Typ := Name_Long_Long_Float;\n             end if;\n \n-         --  If zero is invalid, use zero values from System.Scalar_Values\n+         --  If zero is invalid, it is a convenient value to use that is for\n+         --  sure an appropriate invalid value in all situations.\n \n          elsif Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n-            if Size_To_Use <= 8 then\n-               Val_RE := RE_IS_Iz1;\n-            elsif Size_To_Use <= 16 then\n-               Val_RE := RE_IS_Iz2;\n-            elsif Size_To_Use <= 32 then\n-               Val_RE := RE_IS_Iz4;\n-            else\n-               Val_RE := RE_IS_Iz8;\n-            end if;\n+            return Make_Integer_Literal (Loc, 0);\n \n-         --  For unsigned, use unsigned values from System.Scalar_Values\n+         --  Unsigned types\n \n          elsif Is_Unsigned_Type (Typ) then\n             if Size_To_Use <= 8 then\n-               Val_RE := RE_IS_Iu1;\n+               Scal_Typ := Name_Unsigned_8;\n             elsif Size_To_Use <= 16 then\n-               Val_RE := RE_IS_Iu2;\n+               Scal_Typ := Name_Unsigned_16;\n             elsif Size_To_Use <= 32 then\n-               Val_RE := RE_IS_Iu4;\n+               Scal_Typ := Name_Unsigned_32;\n             else\n-               Val_RE := RE_IS_Iu8;\n+               Scal_Typ := Name_Unsigned_64;\n             end if;\n \n-         --  For signed, use signed values from System.Scalar_Values\n+         --  Signed types\n \n          else\n             if Size_To_Use <= 8 then\n-               Val_RE := RE_IS_Is1;\n+               Scal_Typ := Name_Signed_8;\n             elsif Size_To_Use <= 16 then\n-               Val_RE := RE_IS_Is2;\n+               Scal_Typ := Name_Signed_16;\n             elsif Size_To_Use <= 32 then\n-               Val_RE := RE_IS_Is4;\n+               Scal_Typ := Name_Signed_32;\n             else\n-               Val_RE := RE_IS_Is8;\n+               Scal_Typ := Name_Signed_64;\n             end if;\n          end if;\n \n-         return New_Occurrence_Of (RTE (Val_RE), Loc);\n+         --  Use the values specified by pragma Initialize_Scalars or the ones\n+         --  provided by the binder. Higher precedence is given to the pragma.\n+\n+         return Invalid_Scalar_Value (Loc, Scal_Typ);\n       end Simple_Init_Initialize_Scalars_Type;\n \n       ----------------------------------------\n@@ -8308,29 +8410,6 @@ package body Exp_Ch3 is\n          return Expr;\n       end Simple_Init_Scalar_Type;\n \n-      -----------------------------\n-      -- Simple_Init_String_Type --\n-      -----------------------------\n-\n-      function Simple_Init_String_Type return Node_Id is\n-         Comp_Typ : constant Entity_Id := Component_Type (Typ);\n-\n-      begin\n-         --  Generate:\n-         --    (others => Get_Simple_Init_Value)\n-\n-         return\n-           Make_Aggregate (Loc,\n-             Component_Associations => New_List (\n-               Make_Component_Association (Loc,\n-                 Choices    => New_List (Make_Others_Choice (Loc)),\n-                 Expression =>\n-                   Get_Simple_Init_Val\n-                     (Typ  => Comp_Typ,\n-                      N    => N,\n-                      Size => Esize (Comp_Typ)))));\n-      end Simple_Init_String_Type;\n-\n    --  Start of processing for Get_Simple_Init_Val\n \n    begin\n@@ -8344,11 +8423,11 @@ package body Exp_Ch3 is\n             return Simple_Init_Scalar_Type;\n          end if;\n \n-      --  [[Wide_]Wide_]String with Initialize or Normalize_Scalars\n+      --  Array type with Initialize or Normalize_Scalars\n \n-      elsif Is_Standard_String_Type (Typ) then\n+      elsif Is_Array_Type (Typ) then\n          pragma Assert (Init_Or_Norm_Scalars);\n-         return Simple_Init_String_Type;\n+         return Simple_Init_Array_Type;\n \n       --  Access type is initialized to null\n \n@@ -10002,70 +10081,6 @@ package body Exp_Ch3 is\n       end if;\n    end Make_Tag_Assignment;\n \n-   ---------------------------------\n-   -- Needs_Simple_Initialization --\n-   ---------------------------------\n-\n-   function Needs_Simple_Initialization\n-     (Typ         : Entity_Id;\n-      Consider_IS : Boolean := True) return Boolean\n-   is\n-      Consider_IS_NS : constant Boolean :=\n-        Normalize_Scalars or (Initialize_Scalars and Consider_IS);\n-\n-   begin\n-      --  Never need initialization if it is suppressed\n-\n-      if Initialization_Suppressed (Typ) then\n-         return False;\n-      end if;\n-\n-      --  Check for private type, in which case test applies to the underlying\n-      --  type of the private type.\n-\n-      if Is_Private_Type (Typ) then\n-         declare\n-            RT : constant Entity_Id := Underlying_Type (Typ);\n-         begin\n-            if Present (RT) then\n-               return Needs_Simple_Initialization (RT);\n-            else\n-               return False;\n-            end if;\n-         end;\n-\n-      --  Scalar type with Default_Value aspect requires initialization\n-\n-      elsif Is_Scalar_Type (Typ) and then Has_Default_Aspect (Typ) then\n-         return True;\n-\n-      --  Cases needing simple initialization are access types, and, if pragma\n-      --  Normalize_Scalars or Initialize_Scalars is in effect, then all scalar\n-      --  types.\n-\n-      elsif Is_Access_Type (Typ)\n-        or else (Consider_IS_NS and then (Is_Scalar_Type (Typ)))\n-      then\n-         return True;\n-\n-      --  If Initialize/Normalize_Scalars is in effect, string objects also\n-      --  need initialization, unless they are created in the course of\n-      --  expanding an aggregate (since in the latter case they will be\n-      --  filled with appropriate initializing values before they are used).\n-\n-      elsif Consider_IS_NS\n-        and then Is_Standard_String_Type (Typ)\n-        and then\n-          (not Is_Itype (Typ)\n-            or else Nkind (Associated_Node_For_Itype (Typ)) /= N_Aggregate)\n-      then\n-         return True;\n-\n-      else\n-         return False;\n-      end if;\n-   end Needs_Simple_Initialization;\n-\n    ----------------------\n    -- Predef_Deep_Spec --\n    ----------------------"}, {"sha": "d41029dd657f09a38c75b72ffda673a68e69b4af", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -134,17 +134,4 @@ package Exp_Ch3 is\n    --  clause the assignment is handled as part of the freezing of the object,\n    --  see Check_Address_Clause.\n \n-   function Needs_Simple_Initialization\n-     (Typ         : Entity_Id;\n-      Consider_IS : Boolean := True) return Boolean;\n-   --  Certain types need initialization even though there is no specific\n-   --  initialization routine:\n-   --    Access types (which need initializing to null)\n-   --    All scalar types if Normalize_Scalars mode set\n-   --    Descendants of standard string types if Normalize_Scalars mode set\n-   --    Scalar types having a Default_Value attribute\n-   --  Regarding Initialize_Scalars mode, this is ignored if Consider_IS is\n-   --  set to False, but if Consider_IS is set to True, then the cases above\n-   --  mentioning Normalize_Scalars also apply for Initialize_Scalars mode.\n-\n end Exp_Ch3;"}, {"sha": "87a00826a77263f9c81b6d974814fb2a4007a323", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -4595,7 +4595,7 @@ package body Exp_Ch4 is\n       --  first argument to Init must be converted to the task record type.\n \n       declare\n-         T         : constant Entity_Id := Entity (Expression (N));\n+         T         : constant Entity_Id := Etype (Expression (N));\n          Args      : List_Id;\n          Decls     : List_Id;\n          Decl      : Node_Id;\n@@ -4618,6 +4618,67 @@ package body Exp_Ch4 is\n                   Is_Allocate => True);\n             end if;\n \n+         --  Optimize the default allocation of an array object when the\n+         --  following conditions are met:\n+         --\n+         --    * Pragma Initialize_Scalars or Normalize_Scalars is in effect\n+         --\n+         --    * The bounds of the array type are static and lack empty ranges\n+         --\n+         --    * The array type does not contain atomic components or is\n+         --      treated as packed.\n+         --\n+         --    * The component is of a scalar type which requires simple\n+         --      initialization.\n+         --\n+         --  Construct an in-place initialization aggregate which may be\n+         --  convert into a fast memset by the backend.\n+\n+         elsif Init_Or_Norm_Scalars\n+           and then Is_Array_Type (T)\n+           and then not Has_Atomic_Components (T)\n+           and then not Is_Packed (T)\n+           and then Has_Static_Non_Empty_Array_Bounds (T)\n+           and then Is_Scalar_Type (Component_Type (T))\n+           and then Needs_Simple_Initialization\n+                      (Typ         => Component_Type (T),\n+                       Consider_IS => True)\n+         then\n+            Set_Analyzed (N);\n+            Temp := Make_Temporary (Loc, 'P');\n+\n+            --  Generate:\n+            --    Temp : Ptr_Typ := new ...;\n+\n+            Insert_Action\n+              (Assoc_Node => N,\n+               Ins_Action =>\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition   => New_Occurrence_Of (PtrT, Loc),\n+                   Expression          => Relocate_Node (N)),\n+               Suppress   => All_Checks);\n+\n+            --  Generate:\n+            --    Temp.all := (others => ...);\n+\n+            Insert_Action\n+              (Assoc_Node => N,\n+               Ins_Action =>\n+                 Make_Assignment_Statement (Loc,\n+                   Name       =>\n+                     Make_Explicit_Dereference (Loc,\n+                       Prefix => New_Occurrence_Of (Temp, Loc)),\n+                   Expression =>\n+                     Get_Simple_Init_Val\n+                       (Typ  => T,\n+                        N    => N,\n+                        Size => Esize (Component_Type (T)))),\n+               Suppress   => All_Checks);\n+\n+            Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+            Analyze_And_Resolve (N, PtrT);\n+\n          --  Case of no initialization procedure present\n \n          elsif not Has_Non_Null_Base_Init_Proc (T) then"}, {"sha": "4e256d0db55588d9ba7363637f9f9af1e83f1762", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 173, "deletions": 7, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -17124,24 +17124,190 @@ package body Sem_Prag is\n          -- Initialize_Scalars --\n          ------------------------\n \n-         --  pragma Initialize_Scalars;\n+         --  pragma Initialize_Scalars\n+         --    [ ( TYPE_VALUE_PAIR {, TYPE_VALUE_PAIR} ) ];\n+\n+         --  TYPE_VALUE_PAIR ::=\n+         --    SCALAR_TYPE => static_EXPRESSION\n+\n+         --  SCALAR_TYPE :=\n+         --    Short_Float\n+         --  | Float\n+         --  | Long_Float\n+         --  | Long_Long_Flat\n+         --  | Signed_8\n+         --  | Signed_16\n+         --  | Signed_32\n+         --  | Signed_64\n+         --  | Unsigned_8\n+         --  | Unsigned_16\n+         --  | Unsigned_32\n+         --  | Unsigned_64\n+\n+         when Pragma_Initialize_Scalars => Do_Initialize_Scalars : declare\n+            Seen : array (Scalar_Id) of Node_Id := (others => Empty);\n+            --  This collection holds the individual pairs which specify the\n+            --  invalid values of their respective scalar types.\n+\n+            procedure Analyze_Float_Value\n+              (Scal_Typ : Float_Scalar_Id;\n+               Val_Expr : Node_Id);\n+            --  Analyze a type value pair associated with float type Scal_Typ\n+            --  and expression Val_Expr.\n+\n+            procedure Analyze_Integer_Value\n+              (Scal_Typ : Integer_Scalar_Id;\n+               Val_Expr : Node_Id);\n+            --  Analyze a type value pair associated with integer type Scal_Typ\n+            --  and expression Val_Expr.\n+\n+            procedure Analyze_Type_Value_Pair (Pair : Node_Id);\n+            --  Analyze type value pair Pair\n \n-         when Pragma_Initialize_Scalars =>\n+            -------------------------\n+            -- Analyze_Float_Value --\n+            -------------------------\n+\n+            procedure Analyze_Float_Value\n+              (Scal_Typ : Float_Scalar_Id;\n+               Val_Expr : Node_Id)\n+            is\n+            begin\n+               Analyze_And_Resolve (Val_Expr, Any_Real);\n+\n+               if Is_OK_Static_Expression (Val_Expr) then\n+                  Set_Invalid_Scalar_Value (Scal_Typ, Expr_Value_R (Val_Expr));\n+\n+               else\n+                  Error_Msg_Name_1 := Scal_Typ;\n+                  Error_Msg_N (\"value for type % must be static\", Val_Expr);\n+               end if;\n+            end Analyze_Float_Value;\n+\n+            ---------------------------\n+            -- Analyze_Integer_Value --\n+            ---------------------------\n+\n+            procedure Analyze_Integer_Value\n+              (Scal_Typ : Integer_Scalar_Id;\n+               Val_Expr : Node_Id)\n+            is\n+            begin\n+               Analyze_And_Resolve (Val_Expr, Any_Integer);\n+\n+               if Is_OK_Static_Expression (Val_Expr) then\n+                  Set_Invalid_Scalar_Value (Scal_Typ, Expr_Value (Val_Expr));\n+\n+               else\n+                  Error_Msg_Name_1 := Scal_Typ;\n+                  Error_Msg_N (\"value for type % must be static\", Val_Expr);\n+               end if;\n+            end Analyze_Integer_Value;\n+\n+            -----------------------------\n+            -- Analyze_Type_Value_Pair --\n+            -----------------------------\n+\n+            procedure Analyze_Type_Value_Pair (Pair : Node_Id) is\n+               Scal_Typ  : constant Name_Id := Chars (Pair);\n+               Val_Expr  : constant Node_Id := Expression (Pair);\n+               Prev_Pair : Node_Id;\n+\n+            begin\n+               if Scal_Typ in Scalar_Id then\n+                  Prev_Pair := Seen (Scal_Typ);\n+\n+                  --  Prevent multiple attempts to set a value for a scalar\n+                  --  type.\n+\n+                  if Present (Prev_Pair) then\n+                     Error_Msg_Name_1 := Scal_Typ;\n+                     Error_Msg_N\n+                       (\"cannot specify multiple invalid values for type %\",\n+                        Pair);\n+\n+                     Error_Msg_Sloc := Sloc (Prev_Pair);\n+                     Error_Msg_N (\"previous value set #\", Pair);\n+\n+                     --  Ignore the effects of the pair, but do not halt the\n+                     --  analysis of the pragma altogether.\n+\n+                     return;\n+\n+                  --  Otherwise capture the first pair for this scalar type\n+\n+                  else\n+                     Seen (Scal_Typ) := Pair;\n+                  end if;\n+\n+                  if Scal_Typ in Float_Scalar_Id then\n+                     Analyze_Float_Value (Scal_Typ, Val_Expr);\n+\n+                  else pragma Assert (Scal_Typ in Integer_Scalar_Id);\n+                     Analyze_Integer_Value (Scal_Typ, Val_Expr);\n+                  end if;\n+\n+               --  Otherwise the scalar family is illegal\n+\n+               else\n+                  Error_Msg_Name_1 := Pname;\n+                  Error_Msg_N\n+                    (\"argument of pragma % must denote valid scalar family\",\n+                     Pair);\n+               end if;\n+            end Analyze_Type_Value_Pair;\n+\n+            --  Local variables\n+\n+            Pairs : constant List_Id := Pragma_Argument_Associations (N);\n+            Pair  : Node_Id;\n+\n+         --  Start of processing for Do_Initialize_Scalars\n+\n+         begin\n             GNAT_Pragma;\n-            Check_Arg_Count (0);\n             Check_Valid_Configuration_Pragma;\n             Check_Restriction (No_Initialize_Scalars, N);\n \n+            --  Ignore the effects of the pragma when No_Initialize_Scalars is\n+            --  in effect.\n+\n+            if Restriction_Active (No_Initialize_Scalars) then\n+               null;\n+\n             --  Initialize_Scalars creates false positives in CodePeer, and\n             --  incorrect negative results in GNATprove mode, so ignore this\n             --  pragma in these modes.\n \n-            if not Restriction_Active (No_Initialize_Scalars)\n-              and then not (CodePeer_Mode or GNATprove_Mode)\n-            then\n+            elsif CodePeer_Mode or GNATprove_Mode then\n+               null;\n+\n+            --  Otherwise analyze the pragma\n+\n+            else\n+               if Present (Pairs) then\n+\n+                  --  Install Standard in order to provide access to primitive\n+                  --  types in case the expressions contain attributes such as\n+                  --  Integer'Last.\n+\n+                  Push_Scope (Standard_Standard);\n+\n+                  Pair := First (Pairs);\n+                  while Present (Pair) loop\n+                     Analyze_Type_Value_Pair (Pair);\n+                     Next (Pair);\n+                  end loop;\n+\n+                  --  Remove Standard\n+\n+                  Pop_Scope;\n+               end if;\n+\n                Init_Or_Norm_Scalars := True;\n-               Initialize_Scalars := True;\n+               Initialize_Scalars   := True;\n             end if;\n+         end Do_Initialize_Scalars;\n \n          -----------------\n          -- Initializes --"}, {"sha": "93ffae3a2c1e61bc128cdd2b3eb30491b1d6189b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 343, "deletions": 51, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -72,6 +72,25 @@ with GNAT.HTable; use GNAT.HTable;\n \n package body Sem_Util is\n \n+   ---------------------------\n+   -- Local Data Structures --\n+   ---------------------------\n+\n+   Invalid_Binder_Values : array (Scalar_Id) of Entity_Id := (others => Empty);\n+   --  A collection to hold the entities of the variables declared in package\n+   --  System.Scalar_Values which describe the invalid values of scalar types.\n+\n+   Invalid_Binder_Values_Set : Boolean := False;\n+   --  This flag prevents multiple attempts to initialize Invalid_Binder_Values\n+\n+   Invalid_Floats : array (Float_Scalar_Id) of Ureal := (others => No_Ureal);\n+   --  A collection to hold the invalid values of float types as specified by\n+   --  pragma Initialize_Scalars.\n+\n+   Invalid_Integers : array (Integer_Scalar_Id) of Uint := (others => No_Uint);\n+   --  A collection to hold the invalid values of integer types as specified\n+   --  by pragma Initialize_Scalars.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -84,6 +103,14 @@ package body Sem_Util is\n    --  and Build_Discriminal_Subtype_Of_Component. C is a list of constraints,\n    --  Loc is the source location, T is the original subtype.\n \n+   procedure Examine_Array_Bounds\n+     (Typ        : Entity_Id;\n+      All_Static : out Boolean;\n+      Has_Empty  : out Boolean);\n+   --  Inspect the index constraints of array type Typ. Flag All_Static is set\n+   --  when all ranges are static. Flag Has_Empty is set only when All_Static\n+   --  is set and indicates that at least one range is empty.\n+\n    function Has_Enabled_Property\n      (Item_Id  : Entity_Id;\n       Property : Name_Id) return Boolean;\n@@ -7365,6 +7392,91 @@ package body Sem_Util is\n       return Id;\n    end Entity_Of;\n \n+   --------------------------\n+   -- Examine_Array_Bounds --\n+   --------------------------\n+\n+   procedure Examine_Array_Bounds\n+     (Typ        : Entity_Id;\n+      All_Static : out Boolean;\n+      Has_Empty  : out Boolean)\n+   is\n+      function Is_OK_Static_Bound (Bound : Node_Id) return Boolean;\n+      --  Determine whether bound Bound is a suitable static bound\n+\n+      ------------------------\n+      -- Is_OK_Static_Bound --\n+      ------------------------\n+\n+      function Is_OK_Static_Bound (Bound : Node_Id) return Boolean is\n+      begin\n+         return\n+           not Error_Posted (Bound)\n+             and then Is_OK_Static_Expression (Bound);\n+      end Is_OK_Static_Bound;\n+\n+      --  Local variables\n+\n+      Hi_Bound : Node_Id;\n+      Index    : Node_Id;\n+      Lo_Bound : Node_Id;\n+\n+   --  Start of processing for Examine_Array_Bounds\n+\n+   begin\n+      --  An unconstrained array type does not have static bounds, and it is\n+      --  not known whether they are empty or not.\n+\n+      if not Is_Constrained (Typ) then\n+         All_Static := False;\n+         Has_Empty  := False;\n+\n+      --  A string literal has static bounds, and is not empty as long as it\n+      --  contains at least one character.\n+\n+      elsif Ekind (Typ) = E_String_Literal_Subtype then\n+         All_Static := True;\n+         Has_Empty  := String_Literal_Length (Typ) > 0;\n+      end if;\n+\n+      --  Assume that all bounds are static and not empty\n+\n+      All_Static := True;\n+      Has_Empty  := False;\n+\n+      --  Examine each index\n+\n+      Index := First_Index (Typ);\n+      while Present (Index) loop\n+         if Is_Discrete_Type (Etype (Index)) then\n+            Get_Index_Bounds (Index, Lo_Bound, Hi_Bound);\n+\n+            if Is_OK_Static_Bound (Lo_Bound)\n+                 and then\n+               Is_OK_Static_Bound (Hi_Bound)\n+            then\n+               --  The static bounds produce an empty range\n+\n+               if Is_Null_Range (Lo_Bound, Hi_Bound) then\n+                  Has_Empty := True;\n+               end if;\n+\n+            --  Otherwise at least one of the bounds is not static\n+\n+            else\n+               All_Static := False;\n+            end if;\n+\n+         --  Otherwise the index is non-discrete, therefore not static\n+\n+         else\n+            All_Static := False;\n+         end if;\n+\n+         Next_Index (Index);\n+      end loop;\n+   end Examine_Array_Bounds;\n+\n    --------------------------\n    -- Explain_Limited_Type --\n    --------------------------\n@@ -11372,64 +11484,28 @@ package body Sem_Util is\n    -----------------------------\n \n    function Has_Static_Array_Bounds (Typ : Node_Id) return Boolean is\n-      Ndims : constant Nat := Number_Dimensions (Typ);\n-\n-      Index : Node_Id;\n-      Low   : Node_Id;\n-      High  : Node_Id;\n+      All_Static : Boolean;\n+      Dummy      : Boolean;\n \n    begin\n-      --  Unconstrained types do not have static bounds\n-\n-      if not Is_Constrained (Typ) then\n-         return False;\n-      end if;\n-\n-      --  First treat string literals specially, as the lower bound and length\n-      --  of string literals are not stored like those of arrays.\n-\n-      --  A string literal always has static bounds\n-\n-      if Ekind (Typ) = E_String_Literal_Subtype then\n-         return True;\n-      end if;\n-\n-      --  Treat all dimensions in turn\n-\n-      Index := First_Index (Typ);\n-      for Indx in 1 .. Ndims loop\n-\n-         --  In case of an illegal index which is not a discrete type, return\n-         --  that the type is not static.\n-\n-         if not Is_Discrete_Type (Etype (Index))\n-           or else Etype (Index) = Any_Type\n-         then\n-            return False;\n-         end if;\n+      Examine_Array_Bounds (Typ, All_Static, Dummy);\n \n-         Get_Index_Bounds (Index, Low, High);\n+      return All_Static;\n+   end Has_Static_Array_Bounds;\n \n-         if Error_Posted (Low) or else Error_Posted (High) then\n-            return False;\n-         end if;\n+   ---------------------------------------\n+   -- Has_Static_Non_Empty_Array_Bounds --\n+   ---------------------------------------\n \n-         if Is_OK_Static_Expression (Low)\n-              and then\n-            Is_OK_Static_Expression (High)\n-         then\n-            null;\n-         else\n-            return False;\n-         end if;\n+   function Has_Static_Non_Empty_Array_Bounds (Typ : Node_Id) return Boolean is\n+      All_Static : Boolean;\n+      Has_Empty  : Boolean;\n \n-         Next (Index);\n-      end loop;\n-\n-      --  If we fall through the loop, all indexes matched\n+   begin\n+      Examine_Array_Bounds (Typ, All_Static, Has_Empty);\n \n-      return True;\n-   end Has_Static_Array_Bounds;\n+      return All_Static and not Has_Empty;\n+   end Has_Static_Non_Empty_Array_Bounds;\n \n    ----------------\n    -- Has_Stream --\n@@ -12729,6 +12805,124 @@ package body Sem_Util is\n       SPARK_Mode_Pragma := Prag;\n    end Install_SPARK_Mode;\n \n+   --------------------------\n+   -- Invalid_Scalar_Value --\n+   --------------------------\n+\n+   function Invalid_Scalar_Value\n+     (Loc      : Source_Ptr;\n+      Scal_Typ : Scalar_Id) return Node_Id\n+   is\n+      function Invalid_Binder_Value return Node_Id;\n+      --  Return a reference to the corresponding invalid value for type\n+      --  Scal_Typ as defined in unit System.Scalar_Values.\n+\n+      function Invalid_Float_Value return Node_Id;\n+      --  Return the invalid value of float type Scal_Typ\n+\n+      function Invalid_Integer_Value return Node_Id;\n+      --  Return the invalid value of integer type Scal_Typ\n+\n+      procedure Set_Invalid_Binder_Values;\n+      --  Set the contents of collection Invalid_Binder_Values\n+\n+      --------------------------\n+      -- Invalid_Binder_Value --\n+      --------------------------\n+\n+      function Invalid_Binder_Value return Node_Id is\n+         Val_Id : Entity_Id;\n+\n+      begin\n+         --  Initialize the collection of invalid binder values the first time\n+         --  around.\n+\n+         Set_Invalid_Binder_Values;\n+\n+         --  Obtain the corresponding variable from System.Scalar_Values which\n+         --  holds the invalid value for this type.\n+\n+         Val_Id := Invalid_Binder_Values (Scal_Typ);\n+         pragma Assert (Present (Val_Id));\n+\n+         return New_Occurrence_Of (Val_Id, Loc);\n+      end Invalid_Binder_Value;\n+\n+      -------------------------\n+      -- Invalid_Float_Value --\n+      -------------------------\n+\n+      function Invalid_Float_Value return Node_Id is\n+         Value : constant Ureal := Invalid_Floats (Scal_Typ);\n+\n+      begin\n+         --  Pragma Invalid_Scalars did not specify an invalid value for this\n+         --  type. Fall back to the value provided by the binder.\n+\n+         if Value = No_Ureal then\n+            return Invalid_Binder_Value;\n+         else\n+            return Make_Real_Literal (Loc, Realval => Value);\n+         end if;\n+      end Invalid_Float_Value;\n+\n+      ---------------------------\n+      -- Invalid_Integer_Value --\n+      ---------------------------\n+\n+      function Invalid_Integer_Value return Node_Id is\n+         Value : constant Uint := Invalid_Integers (Scal_Typ);\n+\n+      begin\n+         --  Pragma Invalid_Scalars did not specify an invalid value for this\n+         --  type. Fall back to the value provided by the binder.\n+\n+         if Value = No_Uint then\n+            return Invalid_Binder_Value;\n+         else\n+            return Make_Integer_Literal (Loc, Intval => Value);\n+         end if;\n+      end Invalid_Integer_Value;\n+\n+      -------------------------------\n+      -- Set_Invalid_Binder_Values --\n+      -------------------------------\n+\n+      procedure Set_Invalid_Binder_Values is\n+      begin\n+         if not Invalid_Binder_Values_Set then\n+            Invalid_Binder_Values_Set := True;\n+\n+            --  Initialize the contents of the collection once since RTE calls\n+            --  are not cheap.\n+\n+            Invalid_Binder_Values :=\n+              (Name_Short_Float     => RTE (RE_IS_Isf),\n+               Name_Float           => RTE (RE_IS_Ifl),\n+               Name_Long_Float      => RTE (RE_IS_Ilf),\n+               Name_Long_Long_Float => RTE (RE_IS_Ill),\n+               Name_Signed_8        => RTE (RE_IS_Is1),\n+               Name_Signed_16       => RTE (RE_IS_Is2),\n+               Name_Signed_32       => RTE (RE_IS_Is4),\n+               Name_Signed_64       => RTE (RE_IS_Is8),\n+               Name_Unsigned_8      => RTE (RE_IS_Iu1),\n+               Name_Unsigned_16     => RTE (RE_IS_Iu2),\n+               Name_Unsigned_32     => RTE (RE_IS_Iu4),\n+               Name_Unsigned_64     => RTE (RE_IS_Iu8));\n+         end if;\n+      end Set_Invalid_Binder_Values;\n+\n+   --  Start of processing for Invalid_Scalar_Value\n+\n+   begin\n+      if Scal_Typ in Float_Scalar_Id then\n+         return Invalid_Float_Value;\n+\n+      else pragma Assert (Scal_Typ in Integer_Scalar_Id);\n+         return Invalid_Integer_Value;\n+      end if;\n+   end Invalid_Scalar_Value;\n+\n    -----------------------------\n    -- Is_Actual_Out_Parameter --\n    -----------------------------\n@@ -18771,6 +18965,70 @@ package body Sem_Util is\n       end if;\n    end Needs_One_Actual;\n \n+   ---------------------------------\n+   -- Needs_Simple_Initialization --\n+   ---------------------------------\n+\n+   function Needs_Simple_Initialization\n+     (Typ         : Entity_Id;\n+      Consider_IS : Boolean := True) return Boolean\n+   is\n+      Consider_IS_NS : constant Boolean :=\n+        Normalize_Scalars or (Initialize_Scalars and Consider_IS);\n+\n+   begin\n+      --  Never need initialization if it is suppressed\n+\n+      if Initialization_Suppressed (Typ) then\n+         return False;\n+      end if;\n+\n+      --  Check for private type, in which case test applies to the underlying\n+      --  type of the private type.\n+\n+      if Is_Private_Type (Typ) then\n+         declare\n+            RT : constant Entity_Id := Underlying_Type (Typ);\n+         begin\n+            if Present (RT) then\n+               return Needs_Simple_Initialization (RT);\n+            else\n+               return False;\n+            end if;\n+         end;\n+\n+      --  Scalar type with Default_Value aspect requires initialization\n+\n+      elsif Is_Scalar_Type (Typ) and then Has_Default_Aspect (Typ) then\n+         return True;\n+\n+      --  Cases needing simple initialization are access types, and, if pragma\n+      --  Normalize_Scalars or Initialize_Scalars is in effect, then all scalar\n+      --  types.\n+\n+      elsif Is_Access_Type (Typ)\n+        or else (Consider_IS_NS and then (Is_Scalar_Type (Typ)))\n+      then\n+         return True;\n+\n+      --  If Initialize/Normalize_Scalars is in effect, string objects also\n+      --  need initialization, unless they are created in the course of\n+      --  expanding an aggregate (since in the latter case they will be\n+      --  filled with appropriate initializing values before they are used).\n+\n+      elsif Consider_IS_NS\n+        and then Is_Standard_String_Type (Typ)\n+        and then\n+          (not Is_Itype (Typ)\n+            or else Nkind (Associated_Node_For_Itype (Typ)) /= N_Aggregate)\n+      then\n+         return True;\n+\n+      else\n+         return False;\n+      end if;\n+   end Needs_Simple_Initialization;\n+\n    ------------------------\n    -- New_Copy_List_Tree --\n    ------------------------\n@@ -23782,6 +24040,40 @@ package body Sem_Util is\n       Set_Entity (N, Val);\n    end Set_Entity_With_Checks;\n \n+   ------------------------------\n+   -- Set_Invalid_Scalar_Value --\n+   ------------------------------\n+\n+   procedure Set_Invalid_Scalar_Value\n+     (Scal_Typ : Float_Scalar_Id;\n+      Value    : Ureal)\n+   is\n+      Slot : Ureal renames Invalid_Floats (Scal_Typ);\n+\n+   begin\n+      --  Detect an attempt to set a different value for the same scalar type\n+\n+      pragma Assert (Slot = No_Ureal);\n+      Slot := Value;\n+   end Set_Invalid_Scalar_Value;\n+\n+   ------------------------------\n+   -- Set_Invalid_Scalar_Value --\n+   ------------------------------\n+\n+   procedure Set_Invalid_Scalar_Value\n+     (Scal_Typ : Integer_Scalar_Id;\n+      Value    : Uint)\n+   is\n+      Slot : Uint renames Invalid_Integers (Scal_Typ);\n+\n+   begin\n+      --  Detect an attempt to set a different value for the same scalar type\n+\n+      pragma Assert (Slot = No_Uint);\n+      Slot := Value;\n+   end Set_Invalid_Scalar_Value;\n+\n    ------------------------\n    -- Set_Name_Entity_Id --\n    ------------------------"}, {"sha": "4fa49dbcf2fa8cb51101ffc63dd30d3127f9385a", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -1325,6 +1325,9 @@ package Sem_Util is\n    function Has_Static_Array_Bounds (Typ : Node_Id) return Boolean;\n    --  Return whether an array type has static bounds\n \n+   function Has_Static_Non_Empty_Array_Bounds (Typ : Node_Id) return Boolean;\n+   --  Determine whether array type Typ has static non-empty bounds\n+\n    function Has_Stream (T : Entity_Id) return Boolean;\n    --  Tests if type T is derived from Ada.Streams.Root_Stream_Type, or in the\n    --  case of a composite type, has a component for which this predicate is\n@@ -1471,6 +1474,13 @@ package Sem_Util is\n    procedure Install_SPARK_Mode (Mode : SPARK_Mode_Type; Prag : Node_Id);\n    --  Establish the SPARK_Mode and SPARK_Mode_Pragma currently in effect\n \n+   function Invalid_Scalar_Value\n+     (Loc      : Source_Ptr;\n+      Scal_Typ : Scalar_Id) return Node_Id;\n+   --  Obtain the invalid value for scalar type Scal_Typ as either specified by\n+   --  pragma Initialize_Scalars or by the binder. Return an expression created\n+   --  at source location Loc, which denotes the invalid value.\n+\n    function Is_Actual_Out_Parameter (N : Node_Id) return Boolean;\n    --  Determines if N is an actual parameter of out mode in a subprogram call\n \n@@ -2183,6 +2193,19 @@ package Sem_Util is\n    --  syntactic ambiguity that results from an indexing of a function call\n    --  that returns an array, so that Obj.F (X, Y) may mean F (Ob) (X, Y).\n \n+   function Needs_Simple_Initialization\n+     (Typ         : Entity_Id;\n+      Consider_IS : Boolean := True) return Boolean;\n+   --  Certain types need initialization even though there is no specific\n+   --  initialization routine:\n+   --    Access types (which need initializing to null)\n+   --    All scalar types if Normalize_Scalars mode set\n+   --    Descendants of standard string types if Normalize_Scalars mode set\n+   --    Scalar types having a Default_Value attribute\n+   --  Regarding Initialize_Scalars mode, this is ignored if Consider_IS is\n+   --  set to False, but if Consider_IS is set to True, then the cases above\n+   --  mentioning Normalize_Scalars also apply for Initialize_Scalars mode.\n+\n    function New_Copy_List_Tree (List : List_Id) return List_Id;\n    --  Copy recursively an analyzed list of nodes. Uses New_Copy_Tree defined\n    --  below. As for New_Copy_Tree, it is illegal to attempt to copy extended\n@@ -2633,6 +2656,18 @@ package Sem_Util is\n    --    If restriction No_Implementation_Identifiers is set, then it checks\n    --    that the entity is not implementation defined.\n \n+   procedure Set_Invalid_Scalar_Value\n+     (Scal_Typ : Float_Scalar_Id;\n+      Value    : Ureal);\n+   --  Associate invalid value Value with scalar type Scal_Typ as specified by\n+   --  pragma Initialize_Scalars.\n+\n+   procedure Set_Invalid_Scalar_Value\n+     (Scal_Typ : Integer_Scalar_Id;\n+      Value    : Uint);\n+   --  Associate invalid value Value with scalar type Scal_Typ as specified by\n+   --  pragma Initialize_Scalars.\n+\n    procedure Set_Name_Entity_Id (Id : Name_Id; Val : Entity_Id);\n    pragma Inline (Set_Name_Entity_Id);\n    --  Sets the Entity_Id value associated with the given name, which is the"}, {"sha": "25d6fca6a8d83f878287102a024f9639d983972d", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529749b9480f8690c8474cd782664a2d38459ad2/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=529749b9480f8690c8474cd782664a2d38459ad2", "patch": "@@ -1137,6 +1137,30 @@ package Snames is\n    Name_Sequential                         : constant Name_Id := N + $;\n    Last_Partition_Elaboration_Policy_Name  : constant Name_Id := N + $;\n \n+   --  Names of recognized scalar families for pragma Initialize_Scalars\n+\n+   Name_Short_Float                    : constant Name_Id := N + $; -- GNAT\n+   Name_Float                          : constant Name_Id := N + $; -- GNAT\n+   Name_Long_Float                     : constant Name_Id := N + $; -- GNAT\n+   Name_Long_Long_Float                : constant Name_Id := N + $; -- GNAT\n+   Name_Signed_8                       : constant Name_Id := N + $; -- GNAT\n+   Name_Signed_16                      : constant Name_Id := N + $; -- GNAT\n+   Name_Signed_32                      : constant Name_Id := N + $; -- GNAT\n+   Name_Signed_64                      : constant Name_Id := N + $; -- GNAT\n+   Name_Unsigned_8                     : constant Name_Id := N + $; -- GNAT\n+   Name_Unsigned_16                    : constant Name_Id := N + $; -- GNAT\n+   Name_Unsigned_32                    : constant Name_Id := N + $; -- GNAT\n+   Name_Unsigned_64                    : constant Name_Id := N + $; -- GNAT\n+\n+   subtype Scalar_Id is Name_Id range\n+     Name_Short_Float .. Name_Unsigned_64;\n+\n+   subtype Float_Scalar_Id is Name_Id range\n+     Name_Short_Float .. Name_Long_Long_Float;\n+\n+   subtype Integer_Scalar_Id is Name_Id range\n+     Name_Signed_8 .. Name_Unsigned_64;\n+\n    --  Names of recognized checks for pragma Suppress\n \n    --  Note: the name Atomic_Synchronization can only be specified internally"}]}