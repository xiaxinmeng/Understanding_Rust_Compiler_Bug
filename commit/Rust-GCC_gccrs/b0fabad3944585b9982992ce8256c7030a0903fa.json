{"sha": "b0fabad3944585b9982992ce8256c7030a0903fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmYWJhZDM5NDQ1ODViOTk4Mjk5MmNlODI1NmM3MDMwYTA5MDNmYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-12T21:37:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-12T21:37:43Z"}, "message": "pa.c (emit_move_sequence): Rewrite code to handle arithmetic involving plabels.\n\n        * pa.c (emit_move_sequence): Rewrite code to handle arithmetic\n        involving plabels.\n\nFrom-SVN: r14231", "tree": {"sha": "0da3a021b802102127541bc69253300a9eeca5c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0da3a021b802102127541bc69253300a9eeca5c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0fabad3944585b9982992ce8256c7030a0903fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fabad3944585b9982992ce8256c7030a0903fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0fabad3944585b9982992ce8256c7030a0903fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fabad3944585b9982992ce8256c7030a0903fa/comments", "author": null, "committer": null, "parents": [{"sha": "b96257b6df86d010bb9b2487c09364699b0bbcea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b96257b6df86d010bb9b2487c09364699b0bbcea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b96257b6df86d010bb9b2487c09364699b0bbcea"}], "stats": {"total": 63, "additions": 38, "deletions": 25}, "files": [{"sha": "2f9ea94c7657578a5a15ce717060ea3a39de34b3", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fabad3944585b9982992ce8256c7030a0903fa/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fabad3944585b9982992ce8256c7030a0903fa/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b0fabad3944585b9982992ce8256c7030a0903fa", "patch": "@@ -1242,27 +1242,51 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t}\n       if (symbolic_operand (operand1, mode))\n \t{\n-\t  rtx const_part = NULL;\n-\n \t  /* Argh.  The assembler and linker can't handle arithmetic\n-\t     involving plabels.  We'll have to split up operand1 here\n-\t     if it's a function label involved in an arithmetic\n-\t     expression.  Luckily, this only happens with addition\n-\t     of constants to plabels, which simplifies the test.\n+\t     involving plabels.\n \n-\t     We add the constant back in just before returning to\n-\t     our caller.  */\n+\t     So we force the plabel into memory, load operand0 from\n+\t     the memory location, then add in the constant part.  */\n \t  if (GET_CODE (operand1) == CONST\n \t      && GET_CODE (XEXP (operand1, 0)) == PLUS\n \t      && function_label_operand (XEXP (XEXP (operand1, 0), 0), Pmode))\n \t    {\n+\t      rtx scratch_reg, temp, const_part;\n+\n+\t      /* Figure out what (if any) scratch register to use.  */\n+\t      if (reload_in_progress || reload_completed)\n+\t\tscratch_reg = scratch_reg ? scratch_reg : operand0;\n+\t      else if (flag_pic)\n+\t\tscratch_reg = gen_reg_rtx (Pmode);\n+\n \t      /* Save away the constant part of the expression.  */\n \t      const_part = XEXP (XEXP (operand1, 0), 1);\n \t      if (GET_CODE (const_part) != CONST_INT)\n \t\tabort ();\n \n-\t      /* Set operand1 to just the SYMBOL_REF.  */\n-\t      operand1 = XEXP (XEXP (operand1, 0), 0);\n+\t      /* Force the function label into memory.  */\n+\t      temp = force_const_mem (mode, XEXP (XEXP (operand1, 0), 0));\n+\n+\t      /* Get the address of the memory location.  PIC-ify it if\n+\t\t necessary.  */\n+\t      temp = XEXP (temp, 0);\n+\t      if (flag_pic)\n+\t\ttemp = legitimize_pic_address (temp, mode, scratch_reg);\n+\n+\t      /* Put the address of the memory location into our destination\n+\t\t register.  */\n+\t      operands[1] = temp;\n+\t      emit_move_sequence (operands, mode, scratch_reg);\n+\n+\t      /* Now load from the memory location into our destination\n+\t\t register.  */\n+\t      operands[1] = gen_rtx (MEM, Pmode, operands[0]);\n+\t      emit_move_sequence (operands, mode, scratch_reg);\n+\n+\t      /* And add back in the constant part.  */\n+\t      expand_inc (operand0, const_part);\n+\n+\t      return 1;\n \t    }\n \n \t  if (flag_pic)\n@@ -1274,17 +1298,10 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      else\n \t\ttemp = gen_reg_rtx (Pmode);\n \n-\t      /* If operand1 is a function label, then we've got to\n-\t\t force it to memory, then load op0 from memory.  */\n-\t      if (function_label_operand (operand1, mode))\n-\t\t{\n-\t\t  operands[1] = force_const_mem (mode, operand1);\n-\t\t  emit_move_sequence (operands, mode, temp);\n-\t\t}\n-\t      /* Likewise for (const (plus (symbol) (const_int))) when\n-\t\t generating pic code during or after reload and const_int\n-\t\t will not fit in 14 bits.  */\n-\t      else if (GET_CODE (operand1) == CONST\n+\t      /* (const (plus (symbol) (const_int))) must be forced to\n+\t\t memory during/after reload if the const_int will not fit\n+\t\t in 14 bits.  */\n+\t      if (GET_CODE (operand1) == CONST\n \t\t       && GET_CODE (XEXP (operand1, 0)) == PLUS\n \t\t       && GET_CODE (XEXP (XEXP (operand1, 0), 1)) == CONST_INT\n \t\t       && !INT_14_BITS (XEXP (XEXP (operand1, 0), 1))\n@@ -1336,10 +1353,6 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      emit_insn (set);\n \n \t    }\n-\n-\t  /* Add back in the constant part if needed.  */\n-\t  if (const_part != NULL)\n-\t    expand_inc (operand0, const_part);\n \t  return 1;\n \t}\n       else if (GET_CODE (operand1) != CONST_INT"}]}