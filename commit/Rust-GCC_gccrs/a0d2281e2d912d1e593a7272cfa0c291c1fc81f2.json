{"sha": "a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkMjI4MWUyZDkxMmQxZTU5M2E3MjcyY2ZhMGMyOTFjMWZjODFmMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-02-24T20:00:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-02-24T20:00:09Z"}, "message": "re PR middle-end/19953 (Special-case real + complex arithmetic operation (-ffast-math))\n\n        PR middle-end/19953\n        * builtins.c (fold_builtin_complex_mul, fold_builtin_complex_div): New.\n        (fold_builtin_1): Call them.\n        * fold-const.c (fold_complex_mult_parts): Split out from ...\n        (fold_complex_mult): ... here.  Fix typo in both imaginary case.\n        (fold_complex_div_parts, fold_complex_div): New.\n        (fold): Use them.\n        * tree.h (fold_complex_mult_parts, fold_complex_div_parts): Declare.\n\nFrom-SVN: r95511", "tree": {"sha": "79896db4727874e5decda78a3b61216e7fcbce2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79896db4727874e5decda78a3b61216e7fcbce2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/comments", "author": null, "committer": null, "parents": [{"sha": "ae95537a89e5f8d5c57ede74ca84a4a4cf3d96e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae95537a89e5f8d5c57ede74ca84a4a4cf3d96e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae95537a89e5f8d5c57ede74ca84a4a4cf3d96e3"}], "stats": {"total": 267, "additions": 248, "deletions": 19}, "files": [{"sha": "3e2bcb494740de00a7ac5d10ac36674e7a91653a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "patch": "@@ -1,3 +1,14 @@\n+2005-02-24  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/19953\n+\t* builtins.c (fold_builtin_complex_mul, fold_builtin_complex_div): New.\n+\t(fold_builtin_1): Call them.\n+\t* fold-const.c (fold_complex_mult_parts): Split out from ...\n+\t(fold_complex_mult): ... here.  Fix typo in both imaginary case.\n+\t(fold_complex_div_parts, fold_complex_div): New.\n+\t(fold): Use them.\n+\t* tree.h (fold_complex_mult_parts, fold_complex_div_parts): Declare.\n+\n 2005-02-24  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* tree-ssa-ccp.c (visit_assignment): Verify that result of"}, {"sha": "078edc39b5177fba7e0b6fb686d20ab16143c525", "filename": "gcc/builtins.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "patch": "@@ -7843,6 +7843,44 @@ fold_builtin_unordered_cmp (tree exp,\n \t\t       fold (build2 (code, type, arg0, arg1))));\n }\n \n+/* Fold a call to one of the external complex multiply libcalls.  */\n+\n+static tree\n+fold_builtin_complex_mul (tree type, tree arglist)\n+{\n+  tree ar, ai, br, bi;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, REAL_TYPE,\n+\t\t\t REAL_TYPE, VOID_TYPE))\n+    return NULL;\n+\n+  ar = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+  ai = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+  br = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+  bi = TREE_VALUE (arglist);\n+\n+  return fold_complex_mult_parts (type, ar, ai, br, bi);\n+}\n+\n+/* Fold a call to one of the external complex division libcalls.  */\n+\n+static tree\n+fold_builtin_complex_div (tree type, tree arglist)\n+{\n+  tree ar, ai, br, bi;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, REAL_TYPE,\n+\t\t\t REAL_TYPE, VOID_TYPE))\n+    return NULL;\n+\n+  ar = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+  ai = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+  br = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+  bi = TREE_VALUE (arglist);\n+\n+  return fold_complex_div_parts (type, ar, ai, br, bi, RDIV_EXPR);\n+}\n+\n /* Used by constant folding to simplify calls to builtin functions.  EXP is\n    the CALL_EXPR of a call to a builtin function.  IGNORE is true if the\n    result of the function call is ignored.  This function returns NULL_TREE\n@@ -7854,11 +7892,13 @@ fold_builtin_1 (tree exp, bool ignore)\n   tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+  enum built_in_function fcode;\n \n   if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n     return targetm.fold_builtin (exp, ignore);\n \n-  switch (DECL_FUNCTION_CODE (fndecl))\n+  fcode = DECL_FUNCTION_CODE (fndecl);\n+  switch (fcode)\n     {\n     case BUILT_IN_FPUTS:\n       return fold_builtin_fputs (arglist, ignore, false, NULL_TREE);\n@@ -8188,6 +8228,12 @@ fold_builtin_1 (tree exp, bool ignore)\n       break;\n \n     default:\n+      if (fcode >= BUILT_IN_COMPLEX_MUL_MIN\n+\t  && fcode <= BUILT_IN_COMPLEX_MUL_MAX)\n+\treturn fold_builtin_complex_mul (type, arglist);\n+      if (fcode >= BUILT_IN_COMPLEX_DIV_MIN\n+\t  && fcode <= BUILT_IN_COMPLEX_DIV_MAX)\n+\treturn fold_builtin_complex_div (type, arglist);\n       break;\n     }\n "}, {"sha": "5c3139ccb50a8a99c78fb48a47f18f7f31077d75", "filename": "gcc/fold-const.c", "status": "modified", "additions": 163, "deletions": 18, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "patch": "@@ -6336,26 +6336,12 @@ fold_complex_add (tree type, tree ac, tree bc, enum tree_code code)\n /* Perform some simplifications of complex multiplication when one or more\n    of the components are constants or zeros.  Return non-null if successful.  */\n \n-static tree\n-fold_complex_mult (tree type, tree ac, tree bc)\n+tree\n+fold_complex_mult_parts (tree type, tree ar, tree ai, tree br, tree bi)\n {\n-  tree ar, ai, br, bi, rr, ri, inner_type, zero;\n+  tree rr, ri, inner_type, zero;\n   bool ar0, ai0, br0, bi0, bi1;\n \n-  if (TREE_CODE (ac) == COMPLEX_EXPR)\n-    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n-  else if (TREE_CODE (ac) == COMPLEX_CST)\n-    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n-  else\n-    return NULL;\n-\n-  if (TREE_CODE (bc) == COMPLEX_EXPR)\n-    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n-  else if (TREE_CODE (bc) == COMPLEX_CST)\n-    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n-  else\n-    return NULL;\n-\n   inner_type = TREE_TYPE (type);\n   zero = NULL;\n \n@@ -6432,7 +6418,7 @@ fold_complex_mult (tree type, tree ac, tree bc)\n     }\n   else if (ar0 && br0)\n     {\n-      rr = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+      rr = fold (build2 (MULT_EXPR, inner_type, ai, bi));\n       rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n       ri = zero;\n     }\n@@ -6464,6 +6450,152 @@ fold_complex_mult (tree type, tree ac, tree bc)\n   return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n }\n \n+static tree\n+fold_complex_mult (tree type, tree ac, tree bc)\n+{\n+  tree ar, ai, br, bi;\n+\n+  if (TREE_CODE (ac) == COMPLEX_EXPR)\n+    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n+  else if (TREE_CODE (ac) == COMPLEX_CST)\n+    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n+  else\n+    return NULL;\n+\n+  if (TREE_CODE (bc) == COMPLEX_EXPR)\n+    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n+  else if (TREE_CODE (bc) == COMPLEX_CST)\n+    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n+  else\n+    return NULL;\n+\n+  return fold_complex_mult_parts (type, ar, ai, br, bi);\n+}\n+\n+/* Perform some simplifications of complex division when one or more of\n+   the components are constants or zeros.  Return non-null if successful.  */\n+\n+tree\n+fold_complex_div_parts (tree type, tree ar, tree ai, tree br, tree bi,\n+\t\t\tenum tree_code code)\n+{\n+  tree rr, ri, inner_type, zero;\n+  bool ar0, ai0, br0, bi0, bi1;\n+\n+  inner_type = TREE_TYPE (type);\n+  zero = NULL;\n+\n+  if (SCALAR_FLOAT_TYPE_P (inner_type))\n+    {\n+      ar0 = ai0 = br0 = bi0 = bi1 = false;\n+\n+      /* We're only interested in +0.0 here, thus we don't use real_zerop.  */\n+\n+      if (TREE_CODE (ar) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ar), dconst0))\n+\tar0 = true, zero = ar;\n+\n+      if (TREE_CODE (ai) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ai), dconst0))\n+\tai0 = true, zero = ai;\n+\n+      if (TREE_CODE (br) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (br), dconst0))\n+\tbr0 = true, zero = br;\n+\n+      if (TREE_CODE (bi) == REAL_CST)\n+\t{\n+\t  if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst0))\n+\t    bi0 = true, zero = bi;\n+\t  else if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst1))\n+\t    bi1 = true;\n+\t}\n+    }\n+  else\n+    {\n+      ar0 = integer_zerop (ar);\n+      if (ar0)\n+\tzero = ar;\n+      ai0 = integer_zerop (ai);\n+      if (ai0)\n+\tzero = ai;\n+      br0 = integer_zerop (br);\n+      if (br0)\n+\tzero = br;\n+      bi0 = integer_zerop (bi);\n+      if (bi0)\n+\t{\n+\t  zero = bi;\n+\t  bi1 = false;\n+\t}\n+      else\n+\tbi1 = integer_onep (bi);\n+    }\n+\n+  /* We won't optimize anything below unless something is zero.  */\n+  if (zero == NULL)\n+    return NULL;\n+\n+  if (ai0 && bi0)\n+    {\n+      rr = fold (build2 (code, inner_type, ar, br));\n+      ri = zero;\n+    }\n+  else if (ai0 && br0)\n+    {\n+      rr = zero;\n+      ri = fold (build2 (code, inner_type, ar, bi));\n+      ri = fold (build1 (NEGATE_EXPR, inner_type, ri));\n+    }\n+  else if (ar0 && bi0)\n+    {\n+      rr = zero;\n+      ri = fold (build2 (code, inner_type, ai, br));\n+    }\n+  else if (ar0 && br0)\n+    {\n+      rr = fold (build2 (code, inner_type, ai, bi));\n+      ri = zero;\n+    }\n+  else if (bi0)\n+    {\n+      rr = fold (build2 (code, inner_type, ar, br));\n+      ri = fold (build2 (code, inner_type, ai, br));\n+    }\n+  else if (br0)\n+    {\n+      rr = fold (build2 (code, inner_type, ai, bi));\n+      ri = fold (build2 (code, inner_type, ar, bi));\n+      ri = fold (build1 (NEGATE_EXPR, inner_type, ri));\n+    }\n+  else\n+    return NULL;\n+\n+  return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n+}\n+\n+static tree\n+fold_complex_div (tree type, tree ac, tree bc, enum tree_code code)\n+{\n+  tree ar, ai, br, bi;\n+\n+  if (TREE_CODE (ac) == COMPLEX_EXPR)\n+    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n+  else if (TREE_CODE (ac) == COMPLEX_CST)\n+    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n+  else\n+    return NULL;\n+\n+  if (TREE_CODE (bc) == COMPLEX_EXPR)\n+    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n+  else if (TREE_CODE (bc) == COMPLEX_CST)\n+    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n+  else\n+    return NULL;\n+\n+  return fold_complex_div_parts (type, ar, ai, br, bi, code);\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -8042,6 +8174,13 @@ fold (tree expr)\n \t\t\t\t TREE_OPERAND (arg1, 0)));\n \t}\n \n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold_complex_div (type, arg0, arg1, code);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       if (flag_unsafe_math_optimizations)\n \t{\n \t  enum built_in_function fcode = builtin_mathfn_code (arg1);\n@@ -8166,6 +8305,12 @@ fold (tree expr)\n \t\t\t\t\t code, NULL_TREE)))\n \treturn fold_convert (type, tem);\n \n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold_complex_div (type, arg0, arg1, code);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n       goto binary;\n \n     case CEIL_MOD_EXPR:"}, {"sha": "7dff01ce425e842aa5078f4bfac74f54430928e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/complex-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-1.c?ref=a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "patch": "@@ -0,0 +1,12 @@\n+/* Verify that we don't libcall for complex * real.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -O -fdump-tree-optimized\" } */\n+\n+typedef _Complex float C;\n+\n+C foo(C x, float y)\n+{\n+  return x * y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__mul\" 0 \"optimized\" } } */"}, {"sha": "ce72eb2172f709e54c6d212de09da544a450d5ea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/complex-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-2.c?ref=a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "patch": "@@ -0,0 +1,12 @@\n+/* Verify that we don't libcall for complex / real.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -O -fdump-tree-optimized\" } */\n+\n+typedef _Complex float C;\n+\n+C foo(C x, float y)\n+{\n+  return x / y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__div\" 0 \"optimized\" } } */"}, {"sha": "81992f904bd006ea0a3f48a7f431a8673b70f199", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d2281e2d912d1e593a7272cfa0c291c1fc81f2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a0d2281e2d912d1e593a7272cfa0c291c1fc81f2", "patch": "@@ -3549,6 +3549,9 @@ extern tree build_fold_indirect_ref (tree);\n extern tree fold_indirect_ref (tree);\n extern tree constant_boolean_node (int, tree);\n extern tree build_low_bits_mask (tree, unsigned);\n+extern tree fold_complex_mult_parts (tree, tree, tree, tree, tree);\n+extern tree fold_complex_div_parts (tree, tree, tree, tree, tree,\n+\t\t\t\t    enum tree_code);\n \n extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);"}]}