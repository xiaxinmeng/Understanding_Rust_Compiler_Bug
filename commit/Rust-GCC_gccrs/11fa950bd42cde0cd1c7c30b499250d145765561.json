{"sha": "11fa950bd42cde0cd1c7c30b499250d145765561", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmYTk1MGJkNDJjZGUwY2QxYzdjMzBiNDk5MjUwZDE0NTc2NTU2MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-31T08:59:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-31T08:59:01Z"}, "message": "[multiple changes]\n\n2011-08-31  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch4.adb (Try_Object_Operation): When a dispatching primitive is\n\tfound check if there is a class-wide subprogram covering the primitive.\n\t\n2011-08-31  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb: Further cases where full expansion test is needed,\n\trather than expansion test.\n\n2011-08-31  Pascal Obry  <obry@adacore.com>\n\n\t* prj-attr.adb: Fix Source_File_Switches attribute kind (must be a list)\n\n2011-08-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb: Handle iterators over derived container types.\n\n2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.ads, einfo.adb: Add new flag Has_Anonymous_Master.\n\t(Has_Anonymous_Master): New routine.\n\t(Set_Has_Anonymous_Master): New routine.\n\t(Write_Entity_Flags): Add an entry for Has_Anonymous_Master.\n\t* exp_ch4.adb: Add with and use clause for Sem_Ch8.\n\t(Current_Anonymous_Master): New routine.\n\t(Current_Unit_First_Declaration): Removed.\n\t(Current_Unit_Scope): Removed.\n\t(Expand_N_Allocator): Anonymous access-to-controlled types now chain\n\ttheir objects on a per-unit heterogeneous finalization master.\n\n2011-08-31  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cbhama.adb, a-cbhase.adb (Insert): Check for zero-length buckets\n\tarray.\n\n2011-08-31  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-taprop-linux.adb (Create_Task): Avoid changing the affinity mask\n\twhen not needed.\n\n2011-08-31  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_disp.adb (Propagate_Tag): Return without propagating in the case\n\twhere the actual is an unexpanded call to 'Input.\n\nFrom-SVN: r178361", "tree": {"sha": "ad656d24959df5b9496983f927a2a5e6ba1f20a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad656d24959df5b9496983f927a2a5e6ba1f20a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11fa950bd42cde0cd1c7c30b499250d145765561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11fa950bd42cde0cd1c7c30b499250d145765561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11fa950bd42cde0cd1c7c30b499250d145765561", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11fa950bd42cde0cd1c7c30b499250d145765561/comments", "author": null, "committer": null, "parents": [{"sha": "d2b4b3da0d21bea1af905d255971a4869b5617cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b4b3da0d21bea1af905d255971a4869b5617cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2b4b3da0d21bea1af905d255971a4869b5617cc"}], "stats": {"total": 464, "additions": 339, "deletions": 125}, "files": [{"sha": "a2c2cd332dd80ba943b346b8f885bbf8e6d136ba", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -1,3 +1,49 @@\n+2011-08-31  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Object_Operation): When a dispatching primitive is\n+\tfound check if there is a class-wide subprogram covering the primitive.\n+\t\n+2011-08-31  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb: Further cases where full expansion test is needed,\n+\trather than expansion test.\n+\n+2011-08-31  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj-attr.adb: Fix Source_File_Switches attribute kind (must be a list)\n+\n+2011-08-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb: Handle iterators over derived container types.\n+\n+2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.ads, einfo.adb: Add new flag Has_Anonymous_Master.\n+\t(Has_Anonymous_Master): New routine.\n+\t(Set_Has_Anonymous_Master): New routine.\n+\t(Write_Entity_Flags): Add an entry for Has_Anonymous_Master.\n+\t* exp_ch4.adb: Add with and use clause for Sem_Ch8.\n+\t(Current_Anonymous_Master): New routine.\n+\t(Current_Unit_First_Declaration): Removed.\n+\t(Current_Unit_Scope): Removed.\n+\t(Expand_N_Allocator): Anonymous access-to-controlled types now chain\n+\ttheir objects on a per-unit heterogeneous finalization master.\n+\n+2011-08-31  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cbhama.adb, a-cbhase.adb (Insert): Check for zero-length buckets\n+\tarray.\n+\n+2011-08-31  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* s-taprop-linux.adb (Create_Task): Avoid changing the affinity mask\n+\twhen not needed.\n+\n+2011-08-31  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_disp.adb (Propagate_Tag): Return without propagating in the case\n+\twhere the actual is an unexpanded call to 'Input.\n+\n 2011-08-31  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch4.adb: Code clean up."}, {"sha": "d7c75d44aafb5351ed981dd2237abd5147186fd7", "filename": "gcc/ada/a-cbhama.adb", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -513,6 +513,11 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       procedure Assign_Key (Node : in out Node_Type) is\n       begin\n          Node.Key := Key;\n+\n+         --  Note that we do not also assign the element component of the node\n+         --  here, because this version of Insert does not accept an element\n+         --  parameter.\n+\n          --  Node.Element := New_Item;\n       end Assign_Key;\n \n@@ -530,20 +535,17 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    --  Start of processing for Insert\n \n    begin\n-      --  ???\n-      --  if HT_Ops.Capacity (HT) = 0 then\n-      --     HT_Ops.Reserve_Capacity (HT, 1);\n-      --  end if;\n+      --  The buckets array length is specified by the user as a discriminant\n+      --  of the container type, so it is possible for the buckets array to\n+      --  have a length of zero. We must check for this case specifically, in\n+      --  order to prevent divide-by-zero errors later, when we compute the\n+      --  buckets array index value for a key, given its hash value.\n+\n+      if Container.Buckets'Length = 0 then\n+         raise Capacity_Error with \"No capacity for insertion\";\n+      end if;\n \n       Local_Insert (Container, Key, Position.Node, Inserted);\n-\n-      --  ???\n-      --  if Inserted\n-      --    and then HT.Length > HT_Ops.Capacity (HT)\n-      --  then\n-      --     HT_Ops.Reserve_Capacity (HT, HT.Length);\n-      --  end if;\n-\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -590,20 +592,17 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    --  Start of processing for Insert\n \n    begin\n-      --  ??\n-      --  if HT_Ops.Capacity (HT) = 0 then\n-      --     HT_Ops.Reserve_Capacity (HT, 1);\n-      --  end if;\n+      --  The buckets array length is specified by the user as a discriminant\n+      --  of the container type, so it is possible for the buckets array to\n+      --  have a length of zero. We must check for this case specifically, in\n+      --  order to prevent divide-by-zero errors later, when we compute the\n+      --  buckets array index value for a key, given its hash value.\n+\n+      if Container.Buckets'Length = 0 then\n+         raise Capacity_Error with \"No capacity for insertion\";\n+      end if;\n \n       Local_Insert (Container, Key, Position.Node, Inserted);\n-\n-      --  ???\n-      --  if Inserted\n-      --    and then HT.Length > HT_Ops.Capacity (HT)\n-      --  then\n-      --     HT_Ops.Reserve_Capacity (HT, HT.Length);\n-      --  end if;\n-\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n "}, {"sha": "d2d5b6c53b5687d061efc74a3cc6832e99526b44", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -710,19 +710,17 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    --  Start of processing for Insert\n \n    begin\n-      --  ???\n-      --  if HT_Ops.Capacity (HT) = 0 then\n-      --     HT_Ops.Reserve_Capacity (HT, 1);\n-      --  end if;\n+      --  The buckets array length is specified by the user as a discriminant\n+      --  of the container type, so it is possible for the buckets array to\n+      --  have a length of zero. We must check for this case specifically, in\n+      --  order to prevent divide-by-zero errors later, when we compute the\n+      --  buckets array index value for an element, given its hash value.\n+\n+      if Container.Buckets'Length = 0 then\n+         raise Capacity_Error with \"No capacity for insertion\";\n+      end if;\n \n       Local_Insert (Container, New_Item, Node, Inserted);\n-\n-      --  ???\n-      --  if Inserted\n-      --    and then HT.Length > HT_Ops.Capacity (HT)\n-      --  then\n-      --     HT_Ops.Reserve_Capacity (HT, HT.Length);\n-      --  end if;\n    end Insert;\n \n    ------------------"}, {"sha": "dbe5c261073bd36e594a3154bb6adfa83dca353e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -521,8 +521,8 @@ package body Einfo is\n \n    --    Has_Implicit_Dereference        Flag251\n    --    Is_Processed_Transient          Flag252\n+   --    Has_Anonymous_Master            Flag253\n \n-   --    (unused)                        Flag253\n    --    (unused)                        Flag254\n \n    -----------------------\n@@ -1183,6 +1183,13 @@ package body Einfo is\n       return Flag201 (Id);\n    end Has_Anon_Block_Suffix;\n \n+   function Has_Anonymous_Master (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Function, E_Package, E_Package_Body, E_Procedure));\n+      return Flag253 (Id);\n+   end Has_Anonymous_Master;\n+\n    function Has_Atomic_Components (Id : E) return B is\n    begin\n       return Flag86 (Implementation_Base_Type (Id));\n@@ -3662,6 +3669,13 @@ package body Einfo is\n       Set_Flag201 (Id, V);\n    end Set_Has_Anon_Block_Suffix;\n \n+   procedure Set_Has_Anonymous_Master (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Function, E_Package, E_Package_Body, E_Procedure));\n+      Set_Flag253 (Id, V);\n+   end Set_Has_Anonymous_Master;\n+\n    procedure Set_Has_Atomic_Components (Id : E; V : B := True) is\n    begin\n       pragma Assert (not Is_Type (Id) or else Is_Base_Type (Id));\n@@ -7418,6 +7432,7 @@ package body Einfo is\n       W (\"Has_Alignment_Clause\",            Flag46  (Id));\n       W (\"Has_All_Calls_Remote\",            Flag79  (Id));\n       W (\"Has_Anon_Block_Suffix\",           Flag201 (Id));\n+      W (\"Has_Anonymous_Master\",            Flag253 (Id));\n       W (\"Has_Atomic_Components\",           Flag86  (Id));\n       W (\"Has_Biased_Representation\",       Flag139 (Id));\n       W (\"Has_Completion\",                  Flag26  (Id));"}, {"sha": "ca9f7fde540990e7687cbe7b7bc8096e6408455f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -1341,6 +1341,13 @@ package Einfo is\n --       more anonymous blocks and the Chars field contains a name with an\n --       anonymous block suffix (see Exp_Dbug for further details).\n \n+--    Has_Anonymous_Master (Flag253)\n+--       Present in units (top-level functions and procedures, library-level\n+--       packages). Set to True if the associated unit contains a heterogeneous\n+--       finalization master. The master's name is of the form <unit>AM and it\n+--       services anonymous access-to-controlled types with an undetermined\n+--       lifetime.\n+\n --    Has_Atomic_Components (Flag86) [implementation base type only]\n --       Present in all types and objects. Set only for an array type or\n --       an array object if a valid pragma Atomic_Components applies to the\n@@ -5239,6 +5246,7 @@ package Einfo is\n    --    Delay_Cleanups                      (Flag114)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Discard_Names                       (Flag88)\n+   --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n    --    Has_Controlling_Result              (Flag98)\n    --    Has_Invariants                      (Flag232)\n@@ -5429,6 +5437,7 @@ package Einfo is\n    --    Elaborate_Body_Desirable            (Flag210)  (non-generic case only)\n    --    From_With_Type                      (Flag159)\n    --    Has_All_Calls_Remote                (Flag79)\n+   --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n    --    Has_Forward_Instantiation           (Flag175)\n    --    Has_Master_Entity                   (Flag21)\n@@ -5439,10 +5448,10 @@ package Einfo is\n    --    Is_Instantiated                     (Flag126)\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Visible_Child_Unit               (Flag116)\n-   --    Is_Wrapper_Package                  (synth)    (non-generic case only)\n    --    Renamed_In_Spec                     (Flag231)  (non-generic case only)\n-   --    Scope_Depth                         (synth)\n    --    Static_Elaboration_Desired          (Flag77)   (non-generic case only)\n+   --    Is_Wrapper_Package                  (synth)    (non-generic case only)\n+   --    Scope_Depth                         (synth)\n \n    --  E_Package_Body\n    --    Handler_Records                     (List10)   (non-generic case only)\n@@ -5452,9 +5461,10 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Finalizer                           (Node24)   (non-generic case only)\n-   --    Scope_Depth                         (synth)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n+   --    Has_Anonymous_Master                (Flag253)\n    --    Has_Subprogram_Descriptor           (Flag93)\n+   --    Scope_Depth                         (synth)\n \n    --  E_Private_Type\n    --  E_Private_Subtype\n@@ -5505,6 +5515,7 @@ package Einfo is\n    --    Delay_Cleanups                      (Flag114)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Discard_Names                       (Flag88)\n+   --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n    --    Has_Invariants                      (Flag232)\n    --    Has_Master_Entity                   (Flag21)\n@@ -6073,6 +6084,7 @@ package Einfo is\n    function Has_Alignment_Clause                (Id : E) return B;\n    function Has_All_Calls_Remote                (Id : E) return B;\n    function Has_Anon_Block_Suffix               (Id : E) return B;\n+   function Has_Anonymous_Master                (Id : E) return B;\n    function Has_Atomic_Components               (Id : E) return B;\n    function Has_Biased_Representation           (Id : E) return B;\n    function Has_Completion                      (Id : E) return B;\n@@ -6660,6 +6672,7 @@ package Einfo is\n    procedure Set_Has_Alignment_Clause            (Id : E; V : B := True);\n    procedure Set_Has_All_Calls_Remote            (Id : E; V : B := True);\n    procedure Set_Has_Anon_Block_Suffix           (Id : E; V : B := True);\n+   procedure Set_Has_Anonymous_Master            (Id : E; V : B := True);\n    procedure Set_Has_Atomic_Components           (Id : E; V : B := True);\n    procedure Set_Has_Biased_Representation       (Id : E; V : B := True);\n    procedure Set_Has_Completion                  (Id : E; V : B := True);\n@@ -7360,6 +7373,7 @@ package Einfo is\n    pragma Inline (Has_Alignment_Clause);\n    pragma Inline (Has_All_Calls_Remote);\n    pragma Inline (Has_Anon_Block_Suffix);\n+   pragma Inline (Has_Anonymous_Master);\n    pragma Inline (Has_Atomic_Components);\n    pragma Inline (Has_Biased_Representation);\n    pragma Inline (Has_Completion);\n@@ -7803,6 +7817,7 @@ package Einfo is\n    pragma Inline (Set_Has_Alignment_Clause);\n    pragma Inline (Set_Has_All_Calls_Remote);\n    pragma Inline (Set_Has_Anon_Block_Suffix);\n+   pragma Inline (Set_Has_Anonymous_Master);\n    pragma Inline (Set_Has_Atomic_Components);\n    pragma Inline (Set_Has_Biased_Representation);\n    pragma Inline (Set_Has_Completion);"}, {"sha": "1a1159b2a19826f752ebc71aee9fee1926f72e23", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 145, "deletions": 62, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -58,6 +58,7 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -92,13 +93,11 @@ package body Exp_Ch4 is\n    --  If a boolean array assignment can be done in place, build call to\n    --  corresponding library procedure.\n \n-   function Current_Unit_First_Declaration return Node_Id;\n-   --  Return the current unit's first declaration. If the declaration list is\n-   --  empty, the routine generates a null statement and returns it.\n-\n-   function Current_Unit_Scope return Entity_Id;\n-   --  Return the scope of the current unit. If the current unit is a body,\n-   --  return the scope of the spec.\n+   function Current_Anonymous_Master return Entity_Id;\n+   --  Return the entity of the heterogeneous finalization master belonging to\n+   --  the current unit (either function, package or procedure). This master\n+   --  services all anonymous access-to-controlled types. If the current unit\n+   --  does not have such master, create one.\n \n    procedure Displace_Allocator_Pointer (N : Node_Id);\n    --  Ada 2005 (AI-251): Subsidiary procedure to Expand_N_Allocator and\n@@ -376,79 +375,166 @@ package body Exp_Ch4 is\n          return;\n    end Build_Boolean_Array_Proc_Call;\n \n-   ------------------------------------\n-   -- Current_Unit_First_Declaration --\n-   ------------------------------------\n+   ------------------------------\n+   -- Current_Anonymous_Master --\n+   ------------------------------\n \n-   function Current_Unit_First_Declaration return Node_Id is\n-      Sem_U : Node_Id := Unit (Cunit (Current_Sem_Unit));\n-      Decl  : Node_Id;\n-      Decls : List_Id;\n+   function Current_Anonymous_Master return Entity_Id is\n+      Decls      : List_Id;\n+      Fin_Mas_Id : Entity_Id;\n+      Loc        : Source_Ptr;\n+      Subp_Body  : Node_Id;\n+      Unit_Decl  : Node_Id;\n+      Unit_Id    : Entity_Id;\n \n    begin\n-      if Nkind (Sem_U) = N_Package_Declaration then\n-         Sem_U := Specification (Sem_U);\n-         Decls := Visible_Declarations (Sem_U);\n+      Unit_Id := Cunit_Entity (Current_Sem_Unit);\n+\n+      --  Find the entity of the current unit\n+\n+      if Ekind (Unit_Id) = E_Subprogram_Body then\n+\n+         --  When processing subprogram bodies, the proper scope is always that\n+         --  of the spec.\n+\n+         Subp_Body := Unit_Id;\n+         while Present (Subp_Body)\n+           and then Nkind (Subp_Body) /= N_Subprogram_Body\n+         loop\n+            Subp_Body := Parent (Subp_Body);\n+         end loop;\n+\n+         Unit_Id := Corresponding_Spec (Subp_Body);\n+      end if;\n+\n+      Loc := Sloc (Unit_Id);\n+      Unit_Decl := Unit (Cunit (Current_Sem_Unit));\n+\n+      --  Find the declarations list of the current unit\n+\n+      if Nkind (Unit_Decl) = N_Package_Declaration then\n+         Unit_Decl := Specification (Unit_Decl);\n+         Decls := Visible_Declarations (Unit_Decl);\n \n          if No (Decls) then\n-            Decl := Make_Null_Statement (Sloc (Sem_U));\n-            Decls := New_List (Decl);\n-            Set_Visible_Declarations (Sem_U, Decls);\n+            Decls := New_List (Make_Null_Statement (Loc));\n+            Set_Visible_Declarations (Unit_Decl, Decls);\n \n          elsif Is_Empty_List (Decls) then\n-            Decl := Make_Null_Statement (Sloc (Sem_U));\n-            Append_To (Decls, Decl);\n-\n-         else\n-            Decl := First (Decls);\n+            Append_To (Decls, Make_Null_Statement (Loc));\n          end if;\n \n       else\n-         Decls := Declarations (Sem_U);\n+         Decls := Declarations (Unit_Decl);\n \n          if No (Decls) then\n-            Decl := Make_Null_Statement (Sloc (Sem_U));\n-            Decls := New_List (Decl);\n-            Set_Declarations (Sem_U, Decls);\n+            Decls := New_List (Make_Null_Statement (Loc));\n+            Set_Declarations (Unit_Decl, Decls);\n \n          elsif Is_Empty_List (Decls) then\n-            Decl := Make_Null_Statement (Sloc (Sem_U));\n-            Append_To (Decls, Decl);\n-\n-         else\n-            Decl := First (Decls);\n+            Append_To (Decls, Make_Null_Statement (Loc));\n          end if;\n       end if;\n \n-      return Decl;\n-   end Current_Unit_First_Declaration;\n+      --  The current unit has an existing anonymous master, traverse its\n+      --  declarations and locate the entity.\n \n-   ------------------------\n-   -- Current_Unit_Scope --\n-   ------------------------\n+      if Has_Anonymous_Master (Unit_Id) then\n+         Fin_Mas_Id := First_Entity (Unit_Id);\n+         while Present (Fin_Mas_Id) loop\n \n-   function Current_Unit_Scope return Entity_Id is\n-      Scop_Id  : Entity_Id := Cunit_Entity (Current_Sem_Unit);\n-      Subp_Bod : Node_Id;\n+            --  Look for the first variable whose type is Finalization_Master\n \n-   begin\n-      if Ekind (Scop_Id) = E_Subprogram_Body then\n-\n-         --  When processing subprogram bodies, the proper scope is always\n-         --  that of the spec.\n+            if Ekind (Fin_Mas_Id) = E_Variable\n+              and then Etype (Fin_Mas_Id) = RTE (RE_Finalization_Master)\n+            then\n+               return Fin_Mas_Id;\n+            end if;\n \n-         Subp_Bod := Scop_Id;\n-         while Present (Subp_Bod)\n-           and then Nkind (Subp_Bod) /= N_Subprogram_Body\n-         loop\n-            Subp_Bod := Parent (Subp_Bod);\n+            Next_Entity (Fin_Mas_Id);\n          end loop;\n \n-         Scop_Id := Corresponding_Spec (Subp_Bod);\n-      end if;\n+         raise Program_Error;\n+\n+      --  Create a new anonymous master\n \n-      return Scop_Id;\n-   end Current_Unit_Scope;\n+      else\n+         declare\n+            First_Decl : constant Node_Id := First (Decls);\n+            Action     : Node_Id;\n+\n+         begin\n+            --  Since the master and its associated initialization is inserted\n+            --  at top level, use the scope of the unit when analyzing.\n+\n+            Push_Scope (Unit_Id);\n+\n+            --  Create the finalization master\n+\n+            Fin_Mas_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Chars (Unit_Id), \"AM\"));\n+\n+            --  Generate:\n+            --    <Fin_Mas_Id> : Finalization_Master;\n+\n+            Action :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Fin_Mas_Id,\n+                Object_Definition =>\n+                  New_Reference_To (RTE (RE_Finalization_Master), Loc));\n+\n+            Insert_Before_And_Analyze (First_Decl, Action);\n+\n+            --  Mark the unit to prevent the generation of multiple masters\n+\n+            Set_Has_Anonymous_Master (Unit_Id);\n+\n+            --  Do not set the base pool and mode of operation on .NET/JVM\n+            --  since those targets do not support pools and all VM masters\n+            --  are heterogeneous by default.\n+\n+            if VM_Target = No_VM then\n+\n+               --  Generate:\n+               --    Set_Base_Pool\n+               --      (<Fin_Mas_Id>, Global_Pool_Object'Unrestricted_Access);\n+\n+               Action :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (RTE (RE_Set_Base_Pool), Loc),\n+\n+                   Parameter_Associations => New_List (\n+                     New_Reference_To (Fin_Mas_Id, Loc),\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         New_Reference_To (RTE (RE_Global_Pool_Object), Loc),\n+                       Attribute_Name => Name_Unrestricted_Access)));\n+\n+               Insert_Before_And_Analyze (First_Decl, Action);\n+\n+               --  Generate:\n+               --    Set_Is_Heterogeneous (<Fin_Mas_Id>);\n+\n+               Action :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (RTE (RE_Set_Is_Heterogeneous), Loc),\n+                   Parameter_Associations => New_List (\n+                     New_Reference_To (Fin_Mas_Id, Loc)));\n+\n+               Insert_Before_And_Analyze (First_Decl, Action);\n+            end if;\n+\n+            --  Restore the original state of the scope stack\n+\n+            Pop_Scope;\n+\n+            return Fin_Mas_Id;\n+         end;\n+      end if;\n+   end Current_Anonymous_Master;\n \n    --------------------------------\n    -- Displace_Allocator_Pointer --\n@@ -3373,18 +3459,15 @@ package body Exp_Ch4 is\n          if No (Associated_Storage_Pool (PtrT))\n            and then VM_Target = No_VM\n          then\n-            Set_Associated_Storage_Pool (PtrT,\n-              Get_Global_Pool_For_Access_Type (PtrT));\n+            Set_Associated_Storage_Pool\n+              (PtrT, Get_Global_Pool_For_Access_Type (PtrT));\n          end if;\n \n          --  The finalization master must be inserted and analyzed as part of\n          --  the current semantic unit.\n \n          if No (Finalization_Master (PtrT)) then\n-            Build_Finalization_Master\n-              (Typ        => PtrT,\n-               Ins_Node   => Current_Unit_First_Declaration,\n-               Encl_Scope => Current_Unit_Scope);\n+            Set_Finalization_Master (PtrT, Current_Anonymous_Master);\n          end if;\n       end if;\n "}, {"sha": "9362d7df610d49608e806b35065a7d6721c812bf", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -2985,7 +2985,7 @@ package body Exp_Ch5 is\n \n          --  If \"reverse\" is present, then the initialization of the cursor\n          --  uses Last and the step becomes Prev. Pack is the name of the\n-         --  package which instantiates the container.\n+         --  scope where the container package is instantiated.\n \n          declare\n             Element_Type : constant Entity_Id := Etype (Id);\n@@ -3007,13 +3007,23 @@ package body Exp_Ch5 is\n             --  use-visible, so we introduce the name of the enclosing package\n             --  in the declarations below. The Iterator type is declared in a\n             --  an instance within the container package itself.\n+            --  If the container type is a derived type, the cursor type is\n+            --  found in the package of the parent type.\n \n             Iter_Type := Etype (Name (I_Spec));\n \n             if Is_Iterator (Iter_Type) then\n-               Pack := Scope (Scope (Etype (Container)));\n+               if Is_Derived_Type (Container_Typ) then\n+                  Pack := Scope (Scope (Root_Type (Container_Typ)));\n+               else\n+                  Pack := Scope (Scope (Container_Typ));\n+               end if;\n             else\n-               Pack := Scope (Etype (Container));\n+               if Is_Derived_Type (Container_Typ) then\n+                  Pack := Scope (Root_Type (Container_Typ));\n+               else\n+                  Pack := Scope (Container_Typ);\n+               end if;\n             end if;\n \n             --  The \"of\" case uses an internally generated cursor whose type\n@@ -3128,7 +3138,7 @@ package body Exp_Ch5 is\n                end;\n \n             --  X in Iterate (S) : type of iterator is type of explicitly\n-            --  given Iterate function.\n+            --  given Iterate function, and the loop variable is the cursor.\n \n             else\n                Cursor := Id;"}, {"sha": "4dad66d02139b9230a173f92a11dfb54e25a0f7a", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -190,7 +190,7 @@ package body Prj.Attr is\n    \"Latrailing_required_switches#\" &\n    \"Lapic_option#\" &\n    \"Sapath_syntax#\" &\n-   \"Sasource_file_switches#\" &\n+   \"Lasource_file_switches#\" &\n    \"Saobject_file_suffix#\" &\n    \"Laobject_file_switches#\" &\n    \"Lamulti_unit_switches#\" &"}, {"sha": "2b4f54021c44f38b2e2124eafcff58c78e8cc26c", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -880,7 +880,16 @@ package body System.Task_Primitives.Operations is\n \n       --  Handle dispatching domains\n \n-      elsif T.Common.Domain /= null then\n+      --  To avoid changing CPU affinities when not needed, we set the\n+      --  affinity only when assigning to a domain other than the default\n+      --  one, or when the default one has been modified.\n+\n+      elsif T.Common.Domain /= null and then\n+        (T.Common.Domain /= ST.System_Domain\n+          or else T.Common.Domain.all /=\n+                    (Multiprocessors.CPU'First ..\n+                     Multiprocessors.Number_Of_CPUs => True))\n+      then\n          declare\n             CPU_Set : aliased cpu_set_t := (bits => (others => False));\n "}, {"sha": "2745389599aaa0b4faa9be1c703e40919ca328a9", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -6638,7 +6638,7 @@ package body Sem_Ch4 is\n          Call    : Node_Id;\n          Subp    : Entity_Id) return Entity_Id;\n       --  If the subprogram is a valid interpretation, record it, and add\n-      --  to the list of interpretations of Subprog.\n+      --  to the list of interpretations of Subprog. Otherwise return Empty.\n \n       procedure Complete_Object_Operation\n         (Call_Node       : Node_Id;\n@@ -7104,6 +7104,14 @@ package body Sem_Ch4 is\n                     and then N = Name (Parent (N))\n                   then\n                      goto Next_Hom;\n+\n+                  --  If the context is a function call, ignore procedures\n+                  --  in the name of the call.\n+\n+                  elsif Ekind (Hom) = E_Procedure\n+                    and then Nkind (Parent (N)) /= N_Procedure_Call_Statement\n+                  then\n+                     goto Next_Hom;\n                   end if;\n \n                   Set_Etype (Call_Node, Any_Type);\n@@ -7271,16 +7279,39 @@ package body Sem_Ch4 is\n             return;\n          end if;\n \n-         if Try_Primitive_Operation\n-              (Call_Node       => New_Call_Node,\n-               Node_To_Replace => Node_To_Replace)\n-           or else\n-             Try_Class_Wide_Operation\n-               (Call_Node       => New_Call_Node,\n-                Node_To_Replace => Node_To_Replace)\n-         then\n-            null;\n-         end if;\n+         declare\n+            Dup_Call_Node : constant Node_Id := New_Copy (New_Call_Node);\n+            CW_Result     : Boolean;\n+            Prim_Result   : Boolean;\n+            pragma Unreferenced (CW_Result);\n+\n+         begin\n+            Prim_Result :=\n+              Try_Primitive_Operation\n+                (Call_Node       => New_Call_Node,\n+                 Node_To_Replace => Node_To_Replace);\n+\n+            --  Check if there is a class-wide subprogram covering the\n+            --  primitive. This check must be done even if a candidate\n+            --  was found in order to report ambiguous calls.\n+\n+            if not (Prim_Result) then\n+               CW_Result :=\n+                 Try_Class_Wide_Operation\n+                   (Call_Node       => New_Call_Node,\n+                    Node_To_Replace => Node_To_Replace);\n+\n+            --  If we found a primitive we search for class-wide subprograms\n+            --  using a duplicate of the call node (done to avoid missing its\n+            --  decoration if there is no ambiguity).\n+\n+            else\n+               CW_Result :=\n+                 Try_Class_Wide_Operation\n+                   (Call_Node       => Dup_Call_Node,\n+                    Node_To_Replace => Node_To_Replace);\n+            end if;\n+         end;\n       end Try_One_Prefix_Interpretation;\n \n       -----------------------------"}, {"sha": "7e64d98cd673c1858b1c82fb5985be0f1f4f50e6", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -2262,6 +2262,14 @@ package body Sem_Disp is\n       then\n          return;\n \n+      --  When expansion is suppressed, an unexpanded call to 'Input can occur,\n+      --  and in that case we can simply return.\n+\n+      elsif Nkind (Actual) = N_Attribute_Reference then\n+         pragma Assert (Attribute_Name (Actual) = Name_Input);\n+\n+         return;\n+\n       --  Only other possibilities are parenthesized or qualified expression,\n       --  or an expander-generated unchecked conversion of a function call to\n       --  a stream Input attribute."}, {"sha": "3fe07196a4525310c2c38be88a41b3ee79553855", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fa950bd42cde0cd1c7c30b499250d145765561/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=11fa950bd42cde0cd1c7c30b499250d145765561", "patch": "@@ -1725,7 +1725,7 @@ package body Sem_Res is\n    --  Start of processing for Replace_Actual_Discriminants\n \n    begin\n-      if not Expander_Active then\n+      if not Full_Expander_Active then\n          return;\n       end if;\n \n@@ -1970,7 +1970,7 @@ package body Sem_Res is\n                if (Attr = Attribute_Access           or else\n                    Attr = Attribute_Unchecked_Access or else\n                    Attr = Attribute_Unrestricted_Access)\n-                 and then Expander_Active\n+                 and then Full_Expander_Active\n                  and then Get_PCS_Name /= Name_No_DSA\n                then\n                   Check_Subtype_Conformant\n@@ -6833,7 +6833,7 @@ package body Sem_Res is\n \n          --  Why the Expander_Active test here ???\n \n-         if Expander_Active\n+         if Full_Expander_Active\n            and then\n              (Ekind_In (T, E_Anonymous_Access_Type,\n                            E_Anonymous_Access_Subprogram_Type)\n@@ -7148,7 +7148,7 @@ package body Sem_Res is\n       --  We must preserve the original entity in a generic setting, so that\n       --  the legality of the operation can be verified in an instance.\n \n-      if not Expander_Active then\n+      if not Full_Expander_Active then\n          return;\n       end if;\n \n@@ -8197,7 +8197,7 @@ package body Sem_Res is\n       --  transformation while analyzing generic units, as type information\n       --  would be lost when reanalyzing the constant node in the instance.\n \n-      if Is_Discrete_Type (Typ) and then Expander_Active then\n+      if Is_Discrete_Type (Typ) and then Full_Expander_Active then\n          if Is_OK_Static_Expression (L) then\n             Fold_Uint  (L, Expr_Value (L), Is_Static_Expression (L));\n          end if;\n@@ -9345,7 +9345,7 @@ package body Sem_Res is\n       --  expression coincides with the target type.\n \n       if Ada_Version >= Ada_2005\n-        and then Expander_Active\n+        and then Full_Expander_Active\n         and then Operand_Typ /= Target_Typ\n       then\n          declare\n@@ -9844,7 +9844,7 @@ package body Sem_Res is\n       --  premature (e.g. if the slice is within a transient scope). This needs\n       --  to be done only if expansion is enabled.\n \n-      elsif Expander_Active then\n+      elsif Full_Expander_Active then\n          Ensure_Defined (Typ => Slice_Subtype, N => N);\n       end if;\n    end Set_Slice_Subtype;"}]}