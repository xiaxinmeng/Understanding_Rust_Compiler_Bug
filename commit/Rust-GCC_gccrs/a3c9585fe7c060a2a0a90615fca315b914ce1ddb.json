{"sha": "a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNjOTU4NWZlN2MwNjBhMmEwYTkwNjE1ZmNhMzE1YjkxNGNlMWRkYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-31T00:25:51Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-31T00:25:51Z"}, "message": "aix.h: Fix comment formatting.\n\n\t* config/rs6000/aix.h: Fix comment formatting.\n\t* config/rs6000/rs6000-modes.def: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.h: Likewise.\n\t* config/rs6000/rs6000.md: Likewise.\n\nFrom-SVN: r75252", "tree": {"sha": "56279f5300e43f32544f21f76eec9708fc0952d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56279f5300e43f32544f21f76eec9708fc0952d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/comments", "author": null, "committer": null, "parents": [{"sha": "c0a112d17e43bc13d4e48f4e3afd087aa1d0ada7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0a112d17e43bc13d4e48f4e3afd087aa1d0ada7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0a112d17e43bc13d4e48f4e3afd087aa1d0ada7"}], "stats": {"total": 48, "additions": 28, "deletions": 20}, "files": [{"sha": "bdfef52bd01ede506ee41ebd07857189f81c64be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "patch": "@@ -1,3 +1,11 @@\n+2003-12-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/rs6000/aix.h: Fix comment formatting.\n+\t* config/rs6000/rs6000-modes.def: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.h: Likewise.\n+\t* config/rs6000/rs6000.md: Likewise.\n+\n 2003-12-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/i386/i386-protos.h: Remove prototype for"}, {"sha": "3318621a2537bbb2834229122d4f15e6b81d098b", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "patch": "@@ -128,7 +128,7 @@\n #define LIB_SPEC \"%{pg:-L/lib/profiled -L/usr/lib/profiled}\\\n %{p:-L/lib/profiled -L/usr/lib/profiled} %{!shared:%{g*:-lg}} -lc\"\n \n-/* This now supports a natural alignment mode. */\n+/* This now supports a natural alignment mode.  */\n /* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n   (TARGET_ALIGN_NATURAL ? (COMPUTED) : \\"}, {"sha": "6f17f1a7acc21aea5f6c4ce51e0e2370bc3b13a0", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "patch": "@@ -20,7 +20,7 @@\n    MA 02111-1307, USA.  */\n \n /* 128-bit floating point.  ABI_V4 uses IEEE quad, AIX/Darwin\n-   adjust this in rs6000_override_options. */\n+   adjust this in rs6000_override_options.  */\n FLOAT_MODE (TF, 16, ieee_quad_format);\n \n /* PSImode is used for the XER register.  The XER register"}, {"sha": "f8037c0a195fb860af4f2ccadf5864da3c763038", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "patch": "@@ -239,8 +239,8 @@ static int rs6000_sr_alias_set;\n int rs6000_default_long_calls;\n const char *rs6000_longcall_switch;\n \n-/* Control alignment for fields within structures. */\n-/* String from -malign-XXXXX. */\n+/* Control alignment for fields within structures.  */\n+/* String from -malign-XXXXX.  */\n const char *rs6000_alignment_string;\n int rs6000_alignment_flags;\n \n@@ -2129,7 +2129,7 @@ and64_operand (rtx op, enum machine_mode mode)\n int\n and64_2_operand (rtx op, enum machine_mode mode)\n {\n-  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis. */\n+  if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n     return gpc_reg_operand (op, mode) || mask64_2_operand (op, mode);\n \n   return logical_operand (op, mode) || mask64_2_operand (op, mode);\n@@ -4040,7 +4040,7 @@ rs6000_mixed_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       else if (align_words + RS6000_ARG_SIZE (mode, type)\n \t       > GP_ARG_NUM_REG)\n \t/* If this is partially on the stack, then we only\n-\t   include the portion actually in registers here. */\n+\t   include the portion actually in registers here.  */\n \treturn gen_rtx_PARALLEL (DFmode,\n \t\t gen_rtvec (2,   \n \t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n@@ -4696,7 +4696,7 @@ rs6000_va_arg (tree valist, tree type)\n       sav_scale = 4;\n     }\n \n-  /* Pull the value out of the saved registers ...  */\n+  /* Pull the value out of the saved registers....  */\n \n   lab_false = gen_label_rtx ();\n   lab_over = gen_label_rtx ();\n@@ -9734,7 +9734,7 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n     s += sprintf (s, \"{b%s|b%s%s} \", ccode, ccode, pred);\n \n   /* We need to escape any '%' characters in the reg_names string.\n-     Assume they'd only be the first character...  */\n+     Assume they'd only be the first character....  */\n   if (reg_names[cc_regno + CR0_REGNO][0] == '%')\n     *s++ = '%';\n   s += sprintf (s, \"%s\", reg_names[cc_regno + CR0_REGNO]);\n@@ -9767,7 +9767,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   enum machine_mode result_mode = GET_MODE (dest);\n   rtx temp;\n \n-  /* These modes should always match. */\n+  /* These modes should always match.  */\n   if (GET_MODE (op1) != compare_mode\n       /* In the isel case however, we can use a compare immediate, so\n \t op1 may be a small constant.  */\n@@ -9779,7 +9779,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n     return 0;\n \n   /* First, work out if the hardware can do this at all, or\n-     if it's too slow...  */\n+     if it's too slow....  */\n   if (! rs6000_compare_fp_p)\n     {\n       if (TARGET_ISEL)\n@@ -10892,7 +10892,7 @@ rs6000_ra_ever_killed (void)\n   /* regs_ever_live has LR marked as used if any sibcalls are present,\n      but this should not force saving and restoring in the\n      pro/epilogue.  Likewise, reg_set_between_p thinks a sibcall\n-     clobbers LR, so that is inappropriate. */\n+     clobbers LR, so that is inappropriate.  */\n \n   /* Also, the prologue can generate a store into LR that\n      doesn't really count, like this:\n@@ -11966,7 +11966,7 @@ rs6000_output_function_prologue (FILE *file,\n       rs6000_emit_prologue ();\n       emit_note (NOTE_INSN_DELETED);\n \n-      /* Expand INSN_ADDRESSES so final() doesn't crash. */\n+      /* Expand INSN_ADDRESSES so final() doesn't crash.  */\n       {\n \trtx insn;\n \tunsigned addr = 0;\n@@ -12398,7 +12398,7 @@ rs6000_output_function_epilogue (FILE *file,\n \t  rs6000_emit_epilogue (FALSE);\n \t  emit_note (NOTE_INSN_DELETED);\n \n-\t  /* Expand INSN_ADDRESSES so final() doesn't crash. */\n+\t  /* Expand INSN_ADDRESSES so final() doesn't crash.  */\n \t  {\n \t    rtx insn;\n \t    unsigned addr = 0;\n@@ -13481,7 +13481,7 @@ output_function_profiler (FILE *file, int labelno)\n     case ABI_DARWIN:\n       if (!TARGET_PROFILE_KERNEL)\n \t{\n-\t  /* Don't do anything, done in output_profile_hook (). */\n+\t  /* Don't do anything, done in output_profile_hook ().  */\n \t}\n       else\n \t{\n@@ -13691,7 +13691,7 @@ is_cracked_insn (rtx insn)\n }\n \n /* The function returns true if INSN can be issued only from\n-   the branch slot. */\n+   the branch slot.  */\n \n static bool\n is_branch_slot_insn (rtx insn)\n@@ -14965,7 +14965,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n       if (GET_CODE (XEXP (orig, 0)) == PLUS)\n \t{\n \t  /* Use a different reg for the intermediate value, as\n-\t     it will be marked UNCHANGING. */\n+\t     it will be marked UNCHANGING.  */\n \t  rtx reg_temp = no_new_pseudos ? reg : gen_reg_rtx (Pmode);\n \n \t  base =\n@@ -15544,7 +15544,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n       return true;\n \n     case MEM:\n-      /* MEM should be slightly more expensive than (plus (reg) (const)) */\n+      /* MEM should be slightly more expensive than (plus (reg) (const)).  */\n       *total = 5;\n       return true;\n \n@@ -15571,7 +15571,7 @@ rs6000_register_move_cost (enum machine_mode mode,\n \treturn (rs6000_memory_move_cost (mode, from, 0)\n \t\t+ rs6000_memory_move_cost (mode, GENERAL_REGS, 0));\n \n-/* It's more expensive to move CR_REGS than CR0_REGS because of the shift...*/\n+/* It's more expensive to move CR_REGS than CR0_REGS because of the shift....  */\n       else if (from == CR_REGS)\n \treturn 4;\n "}, {"sha": "3b14ce63ec3a1dbc53af0a1772e61e88b7626360", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "patch": "@@ -2231,7 +2231,7 @@ do {\t\t\t\t\t\t\t\t\\\n    between pointers and any other objects of this machine mode.  */\n #define Pmode (TARGET_32BIT ? SImode : DImode)\n \n-/* Supply definition of STACK_SIZE_MODE for allocate_dynamic_stack_space. */\n+/* Supply definition of STACK_SIZE_MODE for allocate_dynamic_stack_space.  */\n #define STACK_SIZE_MODE (TARGET_32BIT ? SImode : DImode)\n \n /* Mode of a function address in a call instruction (for indexing purposes)."}, {"sha": "602eabaf8522f0eee168591f1da98abc5d8a8c17", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3c9585fe7c060a2a0a90615fca315b914ce1ddb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a3c9585fe7c060a2a0a90615fca315b914ce1ddb", "patch": "@@ -7635,7 +7635,7 @@\n \t  operands2[1] = operands[1];\n \t  operands2[2] = operands[2];\n \t  if (TARGET_POWERPC64 && TARGET_32BIT)\n-\t    /* Note, old assemblers didn't support relocation here. */\n+\t    /* Note, old assemblers didn't support relocation here.  */\n \t    return \\\"ld %0,lo16(%2)(%1)\\\";\n \t  else\n \t  {"}]}