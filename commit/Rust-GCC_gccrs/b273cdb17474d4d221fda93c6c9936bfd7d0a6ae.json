{"sha": "b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI3M2NkYjE3NDc0ZDRkMjIxZmRhOTNjNmM5OTM2YmZkN2QwYTZhZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-06-15T03:51:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-06-15T03:51:59Z"}, "message": "re PR c++/49107 ([C++0x][4.7 Regression] incomplete type regression with std::pair)\n\n\tPR c++/49107\n\t* cp-tree.h (DEFERRED_NOEXCEPT_SPEC_P): Handle overload.\n\t* method.c (defaulted_late_check): Only maybe_instantiate_noexcept\n\tif the declaration had an exception-specifier.\n\t(process_subob_fn): Don't maybe_instantiate_noexcept.\n\t* pt.c (maybe_instantiate_noexcept): Handle overload.\n\t* typeck2.c (nothrow_spec_p_uninst): New.\n\t(merge_exception_specifiers): Add 'fn' parm.  Build up overload.\n\t* typeck.c (merge_types): Adjust.\n\nFrom-SVN: r175073", "tree": {"sha": "894f5414477006e9ef4e80113e95f3c6f4ed6beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894f5414477006e9ef4e80113e95f3c6f4ed6beb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1608bfca56f5ab4a7160c57d5179e59a7c4a197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1608bfca56f5ab4a7160c57d5179e59a7c4a197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1608bfca56f5ab4a7160c57d5179e59a7c4a197"}], "stats": {"total": 263, "additions": 204, "deletions": 59}, "files": [{"sha": "88bb8fb35a093bbcadd75694824b95fb8121ff0c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -1,5 +1,15 @@\n 2011-06-14  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/49107\n+\t* cp-tree.h (DEFERRED_NOEXCEPT_SPEC_P): Handle overload.\n+\t* method.c (defaulted_late_check): Only maybe_instantiate_noexcept\n+\tif the declaration had an exception-specifier.\n+\t(process_subob_fn): Don't maybe_instantiate_noexcept.\n+\t* pt.c (maybe_instantiate_noexcept): Handle overload.\n+\t* typeck2.c (nothrow_spec_p_uninst): New.\n+\t(merge_exception_specifiers): Add 'fn' parm.  Build up overload.\n+\t* typeck.c (merge_types): Adjust.\n+\n \t* pt.c (deduction_tsubst_fntype): Don't save input_location.\n \t(maybe_instantiate_noexcept): Likewise.\n "}, {"sha": "ff8b2dc121ebe253c5b800b16f41f4a3ba673bb1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -514,7 +514,8 @@ struct GTY (()) tree_default_arg {\n   (((struct tree_deferred_noexcept *)DEFERRED_NOEXCEPT_CHECK (NODE))->args)\n #define DEFERRED_NOEXCEPT_SPEC_P(NODE)\t\t\t\t\\\n   ((NODE) && (TREE_PURPOSE (NODE))\t\t\t\t\\\n-   && TREE_CODE (TREE_PURPOSE (NODE)) == DEFERRED_NOEXCEPT)\n+  && (TREE_CODE (TREE_PURPOSE (NODE)) == DEFERRED_NOEXCEPT\t\\\n+      || is_overloaded_fn (TREE_PURPOSE (NODE))))\n \n struct GTY (()) tree_deferred_noexcept {\n   struct tree_base base;\n@@ -1792,7 +1793,10 @@ struct GTY((variable_size)) lang_type {\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n    will be NULL_TREE to indicate a throw specification of `()', or\n    no exceptions allowed.  For a noexcept specification, TREE_VALUE\n-   is NULL_TREE and TREE_PURPOSE is the constant-expression. */\n+   is NULL_TREE and TREE_PURPOSE is the constant-expression.  For\n+   a deferred noexcept-specification, TREE_PURPOSE is a DEFERRED_NOEXCEPT\n+   (for templates) or an OVERLOAD list of functions (for implicitly\n+   declared functions).  */\n #define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_LANG_SLOT_1 (NODE)\n \n /* For FUNCTION_TYPE or METHOD_TYPE, return 1 iff it is declared `throw()'\n@@ -5698,7 +5702,7 @@ extern tree build_x_arrow\t\t\t(tree);\n extern tree build_m_component_ref\t\t(tree, tree);\n extern tree build_functional_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree add_exception_specifier\t\t(tree, tree, int);\n-extern tree merge_exception_specifiers\t\t(tree, tree);\n+extern tree merge_exception_specifiers\t\t(tree, tree, tree);\n \n /* in mangle.c */\n extern void init_mangle\t\t\t\t(void);"}, {"sha": "48b9c74e78e5cf52cfb6428567806e7c14e30058", "filename": "gcc/cp/method.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -924,10 +924,8 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n \n   if (spec_p)\n     {\n-      tree raises;\n-      maybe_instantiate_noexcept (fn);\n-      raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n-      *spec_p = merge_exception_specifiers (*spec_p, raises);\n+      tree raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+      *spec_p = merge_exception_specifiers (*spec_p, raises, fn);\n     }\n \n   if (!trivial_fn_p (fn))\n@@ -1561,15 +1559,16 @@ defaulted_late_check (tree fn)\n      it had been implicitly declared.  */\n   if (DECL_DEFAULTED_IN_CLASS_P (fn))\n     {\n-      tree eh_spec;\n-      maybe_instantiate_noexcept (fn);\n-      eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (implicit_fn));\n-      if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn))\n-\t  && !comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)),\n-\t\t\t\t eh_spec, ce_normal))\n-\terror (\"function %q+D defaulted on its first declaration \"\n-\t       \"with an exception-specification that differs from \"\n-\t       \"the implicit declaration %q#D\", fn, implicit_fn);\n+      tree eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (implicit_fn));\n+      if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)))\n+\t{\n+\t  maybe_instantiate_noexcept (fn);\n+\t  if (!comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)),\n+\t\t\t\t  eh_spec, ce_normal))\n+\t    error (\"function %q+D defaulted on its first declaration \"\n+\t\t   \"with an exception-specification that differs from \"\n+\t\t   \"the implicit declaration %q#D\", fn, implicit_fn);\n+\t}\n       TREE_TYPE (fn) = build_exception_variant (TREE_TYPE (fn), eh_spec);\n       if (DECL_DECLARED_CONSTEXPR_P (implicit_fn))\n \t/* Hmm...should we do this for out-of-class too? Should it be OK to"}, {"sha": "ff145a263fd397ce4c6e4f2628393cb025fcc11f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -17354,27 +17354,49 @@ always_instantiate_p (tree decl)\n void\n maybe_instantiate_noexcept (tree fn)\n {\n-  tree fntype = TREE_TYPE (fn);\n-  tree spec = TYPE_RAISES_EXCEPTIONS (fntype);\n-  tree noex = NULL_TREE;\n-  tree clone;\n+  tree fntype, spec, noex, clone;\n+\n+  if (DECL_CLONED_FUNCTION_P (fn))\n+    fn = DECL_CLONED_FUNCTION (fn);\n+  fntype = TREE_TYPE (fn);\n+  spec = TYPE_RAISES_EXCEPTIONS (fntype);\n \n   if (!DEFERRED_NOEXCEPT_SPEC_P (spec))\n     return;\n+\n   noex = TREE_PURPOSE (spec);\n \n-  push_tinst_level (fn);\n-  push_access_scope (fn);\n-  input_location = DECL_SOURCE_LOCATION (fn);\n-  noex = tsubst_copy_and_build (DEFERRED_NOEXCEPT_PATTERN (noex),\n-\t\t\t\tDEFERRED_NOEXCEPT_ARGS (noex),\n-\t\t\t\ttf_warning_or_error, fn, /*function_p=*/false,\n-\t\t\t\t/*integral_constant_expression_p=*/true);\n-  pop_access_scope (fn);\n-  pop_tinst_level ();\n-  spec = build_noexcept_spec (noex, tf_warning_or_error);\n-  if (spec == error_mark_node)\n-    spec = noexcept_false_spec;\n+  if (TREE_CODE (noex) == DEFERRED_NOEXCEPT)\n+    {\n+      push_tinst_level (fn);\n+      push_access_scope (fn);\n+      input_location = DECL_SOURCE_LOCATION (fn);\n+      noex = tsubst_copy_and_build (DEFERRED_NOEXCEPT_PATTERN (noex),\n+\t\t\t\t    DEFERRED_NOEXCEPT_ARGS (noex),\n+\t\t\t\t    tf_warning_or_error, fn, /*function_p=*/false,\n+\t\t\t\t    /*integral_constant_expression_p=*/true);\n+      pop_access_scope (fn);\n+      pop_tinst_level ();\n+      spec = build_noexcept_spec (noex, tf_warning_or_error);\n+      if (spec == error_mark_node)\n+\tspec = noexcept_false_spec;\n+    }\n+  else\n+    {\n+      /* This is an implicitly declared function, so NOEX is a list of\n+\t other functions to evaluate and merge.  */\n+      tree elt;\n+      spec = noexcept_true_spec;\n+      for (elt = noex; elt; elt = OVL_NEXT (elt))\n+\t{\n+\t  tree fn = OVL_CURRENT (elt);\n+\t  tree subspec;\n+\t  maybe_instantiate_noexcept (fn);\n+\t  subspec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n+\t  spec = merge_exception_specifiers (spec, subspec, NULL_TREE);\n+\t}\n+    }\n+\n   TREE_TYPE (fn) = build_exception_variant (fntype, spec);\n \n   FOR_EACH_CLONE (clone, fn)"}, {"sha": "39e974bb8027befe26b276a70e36d849774a1cb4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -830,7 +830,8 @@ merge_types (tree t1, tree t2)\n \tgcc_assert (type_memfn_quals (t1) == type_memfn_quals (t2));\n \trval = apply_memfn_quals (rval, type_memfn_quals (t1));\n \traises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n-\t\t\t\t\t     TYPE_RAISES_EXCEPTIONS (t2));\n+\t\t\t\t\t     TYPE_RAISES_EXCEPTIONS (t2),\n+\t\t\t\t\t     NULL_TREE);\n \tt1 = build_exception_variant (rval, raises);\n \tbreak;\n       }\n@@ -841,7 +842,8 @@ merge_types (tree t1, tree t2)\n \t   is just the main variant of this.  */\n \ttree basetype = class_of_this_parm (t2);\n \ttree raises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n-\t\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (t2));\n+\t\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (t2),\n+\t\t\t\t\t\t  NULL_TREE);\n \ttree t3;\n \n \t/* If this was a member function type, get back to the"}, {"sha": "6d6267e8d728fa370fe505afc2a5cb41e5f99f0e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -1771,50 +1771,76 @@ add_exception_specifier (tree list, tree spec, int complain)\n   return list;\n }\n \n+/* Like nothrow_spec_p, but don't abort on deferred noexcept.  */\n+\n+static bool\n+nothrow_spec_p_uninst (const_tree spec)\n+{\n+  if (DEFERRED_NOEXCEPT_SPEC_P (spec))\n+    return false;\n+  return nothrow_spec_p (spec);\n+}\n+\n /* Combine the two exceptions specifier lists LIST and ADD, and return\n-   their union.  */\n+   their union.  If FN is non-null, it's the source of ADD.  */\n \n tree\n-merge_exception_specifiers (tree list, tree add)\n+merge_exception_specifiers (tree list, tree add, tree fn)\n {\n+  tree noex, orig_list;\n+\n   /* No exception-specifier or noexcept(false) are less strict than\n      anything else.  Prefer the newer variant (LIST).  */\n   if (!list || list == noexcept_false_spec)\n     return list;\n   else if (!add || add == noexcept_false_spec)\n     return add;\n \n-  /* We need to instantiate deferred noexcept before we get here.  */\n-  gcc_assert (!DEFERRED_NOEXCEPT_SPEC_P (list)\n-\t      && !DEFERRED_NOEXCEPT_SPEC_P (add));\n-\n-  /* For merging noexcept(true) and throw(), take the more recent one (LIST).\n-     Any other noexcept-spec should only be merged with an equivalent one.\n-     So the !TREE_VALUE code below is correct for all cases.  */\n-  if (!TREE_VALUE (add))\n+  /* noexcept(true) and throw() are stricter than anything else.\n+     As above, prefer the more recent one (LIST).  */\n+  if (nothrow_spec_p_uninst (add))\n     return list;\n-  else if (!TREE_VALUE (list))\n+\n+  noex = TREE_PURPOSE (list);\n+  if (DEFERRED_NOEXCEPT_SPEC_P (add))\n+    {\n+      /* If ADD is a deferred noexcept, we must have been called from\n+\t process_subob_fn.  For implicitly declared functions, we build up\n+\t a list of functions to consider at instantiation time.  */\n+      if (noex == boolean_true_node)\n+\tnoex = NULL_TREE;\n+      gcc_assert (fn && (!noex || is_overloaded_fn (noex)));\n+      noex = build_overload (fn, noex);\n+    }\n+  else if (nothrow_spec_p_uninst (list))\n     return add;\n   else\n+    gcc_checking_assert (!TREE_PURPOSE (add)\n+\t\t\t || cp_tree_equal (noex, TREE_PURPOSE (add)));\n+\n+  /* Combine the dynamic-exception-specifiers, if any.  */\n+  orig_list = list;\n+  for (; add && TREE_VALUE (add); add = TREE_CHAIN (add))\n     {\n-      tree orig_list = list;\n+      tree spec = TREE_VALUE (add);\n+      tree probe;\n \n-      for (; add; add = TREE_CHAIN (add))\n+      for (probe = orig_list; probe && TREE_VALUE (probe);\n+\t   probe = TREE_CHAIN (probe))\n+\tif (same_type_p (TREE_VALUE (probe), spec))\n+\t  break;\n+      if (!probe)\n \t{\n-\t  tree spec = TREE_VALUE (add);\n-\t  tree probe;\n-\n-\t  for (probe = orig_list; probe; probe = TREE_CHAIN (probe))\n-\t    if (same_type_p (TREE_VALUE (probe), spec))\n-\t      break;\n-\t  if (!probe)\n-\t    {\n-\t      spec = build_tree_list (NULL_TREE, spec);\n-\t      TREE_CHAIN (spec) = list;\n-\t      list = spec;\n-\t    }\n+\t  spec = build_tree_list (NULL_TREE, spec);\n+\t  TREE_CHAIN (spec) = list;\n+\t  list = spec;\n \t}\n     }\n+\n+  /* Keep the noexcept-specifier at the beginning of the list.  */\n+  if (noex != TREE_PURPOSE (list))\n+    list = tree_cons (noex, TREE_VALUE (list), TREE_CHAIN (list));\n+\n   return list;\n }\n "}, {"sha": "265f95daf716e23e6c9cfdb409806440ec7f1068", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -1,3 +1,7 @@\n+2011-06-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/noexcept13.C: New.\n+\n 2011-06-14  Easwaran Raman  <eraman@google.com>\n \n \tPR rtl-optimization/44194"}, {"sha": "7d51c82b5492b54e5d07271647411d7c5f0da7a7", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept13.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b273cdb17474d4d221fda93c6c9936bfd7d0a6ae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept13.C?ref=b273cdb17474d4d221fda93c6c9936bfd7d0a6ae", "patch": "@@ -0,0 +1,78 @@\n+// PR c++/49107\n+// { dg-options -std=c++0x }\n+\n+namespace std\n+{\n+  template<typename _Tp> _Tp&& declval() noexcept;\n+\n+  struct true_type { static const bool value = true; };\n+  struct false_type { static const bool value = false; };\n+\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible_impl\n+    {\n+      template<typename _Tp2, typename _Arg2, typename\n+\t       = decltype(::new _Tp2(declval<_Arg2>()))>\n+      static true_type __test(int);\n+\n+      template<typename, typename>\n+      static false_type __test(...);\n+\n+      typedef decltype(__test<_Tp, _Arg>(0)) type;\n+    };\n+\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible_new_safe\n+    : public __is_direct_constructible_impl<_Tp, _Arg>::type\n+    { };\n+\n+  template<class _T1, class _T2>\n+    struct pair\n+    {\n+      pair() = default;\n+      constexpr pair(const pair&) = default;\n+\n+      pair(pair&& __p)\n+      noexcept(__is_direct_constructible_new_safe<_T2,_T2&&>::value);\n+    };\n+}\n+\n+template <class R_>\n+struct Vector3\n+{\n+  typedef typename R_::Ray_3 Ray_3;\n+  Vector3() {}\n+  explicit Vector3(const Ray_3& r);\n+};\n+\n+template < class R_ > class LineC3\n+{\n+  typedef typename R_::Vector_3 Vector_3;\n+  std::pair<int, Vector_3> x;\n+};\n+\n+template < class R_ > class RayH3\n+{\n+  typedef typename R_::Vector_3 Vector_3;\n+  std::pair<int, Vector_3> x;\n+};\n+\n+template <typename Kernel >\n+struct Homogeneous_base\n+{\n+  typedef LineC3<Kernel> Line_3;\n+  typedef RayH3<Kernel> Ray_3;\n+};\n+\n+template < typename RT_>\n+struct Simple_homogeneous\n+: public Homogeneous_base< Simple_homogeneous<RT_> >\n+{\n+  typedef Vector3<Simple_homogeneous<RT_> > Vector_3;\n+};\n+\n+int main()\n+{\n+  typedef Simple_homogeneous<double> R;\n+  R::Line_3 l3;\n+}"}]}