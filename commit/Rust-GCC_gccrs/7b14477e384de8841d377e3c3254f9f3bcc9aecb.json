{"sha": "7b14477e384de8841d377e3c3254f9f3bcc9aecb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxNDQ3N2UzODRkZTg4NDFkMzc3ZTNjMzI1NGY5ZjNiY2M5YWVjYg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-06-11T18:28:17Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-06-11T18:28:17Z"}, "message": "Fix PR44483: incrementally gimplify BB predicates to avoid redundant computations.\n\n2010-06-11  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR middle-end/44483\n\t* tree-if-conv.c (bb_predicate_s): New struct.\n\t(bb_predicate_p): New.\n\t(bb_has_predicate): New.\n\t(bb_predicate): New.\n\t(set_bb_predicate): New.\n\t(bb_predicate_gimplified_stmts): New.\n\t(set_bb_predicate_gimplified_stmts): New.\n\t(add_bb_predicate_gimplified_stmts): New.\n\t(init_bb_predicate): New.\n\t(free_bb_predicate): New.\n\t(is_predicated): Use bb_predicate.\n\t(add_to_predicate_list): Use bb_predicate and set_bb_predicate.\n\t(predicate_bbs): Same.  Gimplify the condition of the basic blocks\n\tbefore processing their successors.\n\t(clean_predicate_lists): Removed.\n\t(find_phi_replacement_condition): Use bb_predicate.\n\t(process_phi_nodes): Renamed ifconvert_phi_nodes.  Avoid useless\n\tcomputations.\n\t(insert_gimplified_predicates): New.\n\t(combine_blocks): Call insert_gimplified_predicates.\n\t(tree_if_conversion): Call free_bb_predicate instead of\n\tclean_predicate_lists.\n\n\t* gcc.dg/tree-ssa/pr44483.c: New.\n\nFrom-SVN: r160625", "tree": {"sha": "c2958d27e9baeef55b3c52f7e9e7f229f90562ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2958d27e9baeef55b3c52f7e9e7f229f90562ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b14477e384de8841d377e3c3254f9f3bcc9aecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b14477e384de8841d377e3c3254f9f3bcc9aecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b14477e384de8841d377e3c3254f9f3bcc9aecb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b14477e384de8841d377e3c3254f9f3bcc9aecb/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1021b0e570cd0a324d15d117eaaa5dd60e4848f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1021b0e570cd0a324d15d117eaaa5dd60e4848f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1021b0e570cd0a324d15d117eaaa5dd60e4848f0"}], "stats": {"total": 286, "additions": 238, "deletions": 48}, "files": [{"sha": "5d32047ee212d9d7da1e46e7a0185638cf845345", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b14477e384de8841d377e3c3254f9f3bcc9aecb", "patch": "@@ -1,3 +1,29 @@\n+2010-06-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/44483\n+\t* tree-if-conv.c (bb_predicate_s): New struct.\n+\t(bb_predicate_p): New.\n+\t(bb_has_predicate): New.\n+\t(bb_predicate): New.\n+\t(set_bb_predicate): New.\n+\t(bb_predicate_gimplified_stmts): New.\n+\t(set_bb_predicate_gimplified_stmts): New.\n+\t(add_bb_predicate_gimplified_stmts): New.\n+\t(init_bb_predicate): New.\n+\t(free_bb_predicate): New.\n+\t(is_predicated): Use bb_predicate.\n+\t(add_to_predicate_list): Use bb_predicate and set_bb_predicate.\n+\t(predicate_bbs): Same.  Gimplify the condition of the basic blocks\n+\tbefore processing their successors.\n+\t(clean_predicate_lists): Removed.\n+\t(find_phi_replacement_condition): Use bb_predicate.\n+\t(process_phi_nodes): Renamed ifconvert_phi_nodes.  Avoid useless\n+\tcomputations.\n+\t(insert_gimplified_predicates): New.\n+\t(combine_blocks): Call insert_gimplified_predicates.\n+\t(tree_if_conversion): Call free_bb_predicate instead of\n+\tclean_predicate_lists.\n+\n 2010-10-11  Paul Brook  <paul@codesourcery.com>\n  \n \t* doc/invoke.texi: Document ARM -mcpu=cortex-m4."}, {"sha": "d4a788ea84e0a8d791820270277f032df3d8acb3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b14477e384de8841d377e3c3254f9f3bcc9aecb", "patch": "@@ -1,3 +1,8 @@\n+2010-06-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/44483\n+\t* gcc.dg/tree-ssa/pr44483.c: New.\n+\n 2010-06-11  Paul Brook  <paul@codesourcery.com>\n  \n \t* g++.dg/other/arm-neon-1.C: New test."}, {"sha": "cdae91a9098a40813f683bce88efd24c0f62f9a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr44483.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr44483.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr44483.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr44483.c?ref=7b14477e384de8841d377e3c3254f9f3bcc9aecb", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-c -O3\" { target *-*-* } } */\n+\n+int ffesum (void) {\n+  int ch[4], ii, jj, kk;\n+  char asc[32];\n+\n+  for (ii = 0; ii < 4; ii++)\n+    {\n+      for (jj = 0; jj < 4; jj++)\n+        ch[jj] = ii;\n+      for (kk = 0; kk < 13; kk++)\n+        for (jj = 0; jj < 4; jj += 2)\n+          if ((unsigned char) ch[jj] || (unsigned char) ch[jj + 1])\n+            ch[jj]++;\n+      for (jj = 0; jj < 4; jj++)\n+        asc[4 * jj + ii] = ch[jj];\n+    }\n+  return asc[0];\n+}"}, {"sha": "16864734a24d1cd697f21eec86891fd734676df6", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 187, "deletions": 48, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b14477e384de8841d377e3c3254f9f3bcc9aecb/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=7b14477e384de8841d377e3c3254f9f3bcc9aecb", "patch": "@@ -102,6 +102,106 @@ along with GCC; see the file COPYING3.  If not see\n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n+/* Structure used to predicate basic blocks.  This is attached to the\n+   ->aux field of the BBs in the loop to be if-converted.  */\n+typedef struct bb_predicate_s {\n+\n+  /* The condition under which this basic block is executed.  */\n+  tree predicate;\n+\n+  /* PREDICATE is gimplified, and the sequence of statements is\n+     recorded here, in order to avoid the duplication of computations\n+     that occur in previous conditions.  See PR44483.  */\n+  gimple_seq predicate_gimplified_stmts;\n+} *bb_predicate_p;\n+\n+/* Returns true when the basic block BB has a predicate.  */\n+\n+static inline bool\n+bb_has_predicate (basic_block bb)\n+{\n+  return bb->aux != NULL;\n+}\n+\n+/* Returns the gimplified predicate for basic block BB.  */\n+\n+static inline tree\n+bb_predicate (basic_block bb)\n+{\n+  return ((bb_predicate_p) bb->aux)->predicate;\n+}\n+\n+/* Sets the gimplified predicate COND for basic block BB.  */\n+\n+static inline void\n+set_bb_predicate (basic_block bb, tree cond)\n+{\n+  ((bb_predicate_p) bb->aux)->predicate = cond;\n+}\n+\n+/* Returns the sequence of statements of the gimplification of the\n+   predicate for basic block BB.  */\n+\n+static inline gimple_seq\n+bb_predicate_gimplified_stmts (basic_block bb)\n+{\n+  return ((bb_predicate_p) bb->aux)->predicate_gimplified_stmts;\n+}\n+\n+/* Sets the sequence of statements STMTS of the gimplification of the\n+   predicate for basic block BB.  */\n+\n+static inline void\n+set_bb_predicate_gimplified_stmts (basic_block bb, gimple_seq stmts)\n+{\n+  ((bb_predicate_p) bb->aux)->predicate_gimplified_stmts = stmts;\n+}\n+\n+/* Adds the sequence of statements STMTS to the sequence of statements\n+   of the predicate for basic block BB.  */\n+\n+static inline void\n+add_bb_predicate_gimplified_stmts (basic_block bb, gimple_seq stmts)\n+{\n+  gimple_seq_add_seq\n+    (&(((bb_predicate_p) bb->aux)->predicate_gimplified_stmts), stmts);\n+}\n+\n+/* Initializes to TRUE the predicate of basic block BB.  */\n+\n+static inline void\n+init_bb_predicate (basic_block bb)\n+{\n+  bb->aux = XNEW (struct bb_predicate_s);\n+  set_bb_predicate_gimplified_stmts (bb, NULL);\n+  set_bb_predicate (bb, NULL_TREE);\n+}\n+\n+/* Free the predicate of basic block BB.  */\n+\n+static inline void\n+free_bb_predicate (basic_block bb)\n+{\n+  gimple_seq stmts;\n+\n+  if (!bb_has_predicate (bb))\n+    return;\n+\n+  /* Release the SSA_NAMEs created for the gimplification of the\n+     predicate.  */\n+  stmts = bb_predicate_gimplified_stmts (bb);\n+  if (stmts)\n+    {\n+      gimple_stmt_iterator i;\n+\n+      for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))\n+\tfree_stmt_operands (gsi_stmt (i));\n+    }\n+\n+  free (bb->aux);\n+  bb->aux = NULL;\n+}\n+\n /* Create a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n    to the new variable.  */\n \n@@ -145,20 +245,20 @@ is_true_predicate (tree cond)\n static inline bool\n is_predicated (basic_block bb)\n {\n-  return !is_true_predicate ((tree) bb->aux);\n+  return !is_true_predicate (bb_predicate (bb));\n }\n \n /* Add condition NEW_COND to the predicate list of basic block BB.  */\n \n static inline void\n add_to_predicate_list (basic_block bb, tree new_cond)\n {\n-  tree cond = (tree) bb->aux;\n+  tree cond = bb_predicate (bb);\n \n-  bb->aux = is_true_predicate (cond) ? new_cond :\n-    fold_build2_loc (EXPR_LOCATION (cond),\n-\t\t     TRUTH_OR_EXPR, boolean_type_node,\n-\t\t     cond, new_cond);\n+  set_bb_predicate (bb, is_true_predicate (cond) ? new_cond :\n+\t\t    fold_build2_loc (EXPR_LOCATION (cond),\n+\t\t\t\t     TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t     cond, new_cond));\n }\n \n /* Add the condition COND to the previous condition PREV_COND, and add\n@@ -471,7 +571,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n /* Returns true when the analysis of the predicates for all the basic\n    blocks in LOOP succeeded.\n \n-   predicate_bbs first clears the ->aux fields of the basic blocks.\n+   predicate_bbs first allocates the predicates of the basic blocks.\n    These fields are then initialized with the tree expressions\n    representing the predicates under which a basic block is executed\n    in the LOOP.  As the loop->header is executed at each iteration, it\n@@ -492,14 +592,33 @@ predicate_bbs (loop_p loop)\n   unsigned int i;\n \n   for (i = 0; i < loop->num_nodes; i++)\n-    ifc_bbs[i]->aux = NULL;\n+    init_bb_predicate (ifc_bbs[i]);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      basic_block bb = ifc_bbs [i];\n-      tree cond = (tree) bb->aux;\n+      basic_block bb = ifc_bbs[i];\n+      tree cond;\n       gimple_stmt_iterator itr;\n \n+      /* The loop latch is always executed and has no extra conditions\n+\t to be processed: skip it.  */\n+      if (bb == loop->latch)\n+\t{\n+\t  set_bb_predicate (loop->latch, boolean_true_node);\n+\t  set_bb_predicate_gimplified_stmts (loop->latch, NULL);\n+\t  continue;\n+\t}\n+\n+      cond = bb_predicate (bb);\n+      if (cond\n+\t  && bb != loop->header)\n+\t{\n+\t  gimple_seq stmts;\n+\n+\t  cond = force_gimple_operand (cond, &stmts, true, NULL_TREE);\n+\t  add_bb_predicate_gimplified_stmts (bb, stmts);\n+\t}\n+\n       for (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n \t{\n \t  gimple stmt = gsi_stmt (itr);\n@@ -522,11 +641,10 @@ predicate_bbs (loop_p loop)\n \t\t\t\t\t  gimple_cond_lhs (stmt),\n \t\t\t\t\t  gimple_cond_rhs (stmt));\n \n+\t\t/* Add new condition into destination's predicate list.  */\n \t\textract_true_false_edges_from_block (gimple_bb (stmt),\n \t\t\t\t\t\t     &true_edge, &false_edge);\n \n-\t\t/* Add new condition into destination's predicate list.  */\n-\n \t\t/* If C is true, then TRUE_EDGE is taken.  */\n \t\tadd_to_dst_predicate_list (loop, true_edge, cond, c);\n \n@@ -561,7 +679,9 @@ predicate_bbs (loop_p loop)\n     }\n \n   /* The loop header is always executed.  */\n-  loop->header->aux = boolean_true_node;\n+  set_bb_predicate (loop->header, boolean_true_node);\n+  gcc_assert (bb_predicate_gimplified_stmts (loop->header) == NULL\n+\t      && bb_predicate_gimplified_stmts (loop->latch) == NULL);\n \n   return true;\n }\n@@ -679,27 +799,12 @@ if_convertible_loop_p (struct loop *loop)\n   return true;\n }\n \n-/* During if-conversion, the bb->aux field is used to hold a predicate\n-   list.  This function cleans for all the basic blocks in the given\n-   LOOP their predicate list.  */\n-\n-static void\n-clean_predicate_lists (struct loop *loop)\n-{\n-  unsigned int i;\n-  basic_block *bbs = get_loop_body (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    bbs[i]->aux = NULL;\n-\n-  free (bbs);\n-}\n-\n-/* Basic block BB has two predecessors.  Using predecessor's bb->aux\n-   field, set appropriate condition COND for the PHI node replacement.\n-   Return true block whose phi arguments are selected when cond is\n-   true.  LOOP is the loop containing the if-converted region, GSI is\n-   the place to insert the code for the if-conversion.  */\n+/* Basic block BB has two predecessors.  Using predecessor's bb\n+   predicate, set an appropriate condition COND for the PHI node\n+   replacement.  Return the true block whose phi arguments are\n+   selected when cond is true.  LOOP is the loop containing the\n+   if-converted region, GSI is the place to insert the code for the\n+   if-conversion.  */\n \n static basic_block\n find_phi_replacement_condition (struct loop *loop,\n@@ -738,7 +843,7 @@ find_phi_replacement_condition (struct loop *loop,\n         See PR23115.  */\n \n   /* Select condition that is not TRUTH_NOT_EXPR.  */\n-  tmp_cond = (tree) (first_edge->src)->aux;\n+  tmp_cond = bb_predicate (first_edge->src);\n   gcc_assert (tmp_cond);\n \n   if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n@@ -756,7 +861,7 @@ find_phi_replacement_condition (struct loop *loop,\n       || dominated_by_p (CDI_DOMINATORS,\n \t\t\t second_edge->src, first_edge->src))\n     {\n-      *cond = (tree) (second_edge->src)->aux;\n+      *cond = bb_predicate (second_edge->src);\n \n       if (TREE_CODE (*cond) == TRUTH_NOT_EXPR)\n \t*cond = invert_truthvalue (*cond);\n@@ -765,7 +870,7 @@ find_phi_replacement_condition (struct loop *loop,\n \tfirst_edge = second_edge;\n     }\n   else\n-    *cond = (tree) (first_edge->src)->aux;\n+    *cond = bb_predicate (first_edge->src);\n \n   /* Gimplify the condition: the vectorizer prefers to have gimple\n      values as conditions.  Various targets use different means to\n@@ -851,11 +956,11 @@ replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n     }\n }\n \n-/* Process phi nodes for the given LOOP.  Replace phi nodes with\n-   conditional modify expressions.  */\n+/* Replaces in LOOP all the phi nodes other than those in the\n+   LOOP->header block with conditional modify expressions.  */\n \n static void\n-process_phi_nodes (struct loop *loop)\n+ifconvert_phi_nodes (struct loop *loop)\n {\n   basic_block bb;\n   unsigned int orig_loop_num_nodes = loop->num_nodes;\n@@ -873,12 +978,13 @@ process_phi_nodes (struct loop *loop)\n \tcontinue;\n \n       phi_gsi = gsi_start_phis (bb);\n-      gsi = gsi_after_labels (bb);\n+      if (gsi_end_p (phi_gsi))\n+\tcontinue;\n \n       /* BB has two predecessors.  Using predecessor's aux field, set\n \t appropriate condition for the PHI node replacement.  */\n-      if (!gsi_end_p (phi_gsi))\n-\ttrue_bb = find_phi_replacement_condition (loop, bb, &cond, &gsi);\n+      gsi = gsi_after_labels (bb);\n+      true_bb = find_phi_replacement_condition (loop, bb, &cond, &gsi);\n \n       while (!gsi_end_p (phi_gsi))\n \t{\n@@ -887,10 +993,40 @@ process_phi_nodes (struct loop *loop)\n \t  release_phi_node (phi);\n \t  gsi_next (&phi_gsi);\n \t}\n+\n       set_phi_nodes (bb, NULL);\n     }\n }\n \n+/* Insert in each basic block of LOOP the statements produced by the\n+   gimplification of the predicates.  */\n+\n+static void\n+insert_gimplified_predicates (loop_p loop)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = ifc_bbs[i];\n+      gimple_seq stmts = bb_predicate_gimplified_stmts (bb);\n+\n+      if (stmts)\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\n+\t  if (gsi_end_p (gsi)\n+\t      || gimple_code (gsi_stmt (gsi)) == GIMPLE_COND)\n+\t    gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+\t  else\n+\t    gsi_insert_seq_after (&gsi, stmts, GSI_SAME_STMT);\n+\n+\t  /* Once the sequence is code generated, set it to NULL.  */\n+\t  set_bb_predicate_gimplified_stmts (bb, NULL);\n+\t}\n+    }\n+}\n+\n /* Remove all GIMPLE_CONDs and GIMPLE_LABELs of all the basic blocks\n    other than the exit and latch of the LOOP.  Also resets the\n    GIMPLE_DEBUG information.  */\n@@ -903,7 +1039,7 @@ remove_conditions_and_labels (loop_p loop)\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      basic_block bb = ifc_bbs [i];\n+      basic_block bb = ifc_bbs[i];\n \n       if (bb_with_exit_edge_p (loop, bb)\n         || bb == loop->latch)\n@@ -946,9 +1082,8 @@ combine_blocks (struct loop *loop)\n   edge_iterator ei;\n \n   remove_conditions_and_labels (loop);\n-\n-  /* Process phi nodes to prepare blocks for merge.  */\n-  process_phi_nodes (loop);\n+  insert_gimplified_predicates (loop);\n+  ifconvert_phi_nodes (loop);\n \n   /* Merge basic blocks: first remove all the edges in the loop,\n      except for those from the exit block.  */\n@@ -1052,9 +1187,13 @@ tree_if_conversion (struct loop *loop)\n   combine_blocks (loop);\n \n  cleanup:\n-  clean_predicate_lists (loop);\n   if (ifc_bbs)\n     {\n+      unsigned int i;\n+\n+      for (i = 0; i < loop->num_nodes; i++)\n+\tfree_bb_predicate (ifc_bbs[i]);\n+\n       free (ifc_bbs);\n       ifc_bbs = NULL;\n     }"}]}