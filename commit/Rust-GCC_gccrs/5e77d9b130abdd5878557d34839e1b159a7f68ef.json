{"sha": "5e77d9b130abdd5878557d34839e1b159a7f68ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3N2Q5YjEzMGFiZGQ1ODc4NTU3ZDM0ODM5ZTFiMTU5YTdmNjhlZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-01-24T21:57:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-24T21:57:16Z"}, "message": "re PR target/83994 (%ebx is clobbered by stack-clash probing for regparm-3 function in PIC mode)\n\n\tPR target/83994\n\t* i386.c (get_probe_interval): Move to earlier point.\n\t(ix86_compute_frame_layout): If -fstack-clash-protection and\n\tthe frame is larger than the probe interval, then use pushes\n\tto save registers rather than reg->mem moves.\n\t(ix86_expand_prologue): Remove conditional for int_registers_saved\n\tassertion.\n\n\tPR target/83994\n\t* gcc.target/i386/pr83994.c: New test.\n\nFrom-SVN: r257031", "tree": {"sha": "380dc091644ccc25405ff6216ba410ee0ebf7620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/380dc091644ccc25405ff6216ba410ee0ebf7620"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e77d9b130abdd5878557d34839e1b159a7f68ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e77d9b130abdd5878557d34839e1b159a7f68ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e77d9b130abdd5878557d34839e1b159a7f68ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e77d9b130abdd5878557d34839e1b159a7f68ef/comments", "author": null, "committer": null, "parents": [{"sha": "ffd464df03c608e008caeba1cab1c9eb276fd41e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd464df03c608e008caeba1cab1c9eb276fd41e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd464df03c608e008caeba1cab1c9eb276fd41e"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "9427ef89b53d29a7e11466c072495efcf41a693c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e77d9b130abdd5878557d34839e1b159a7f68ef", "patch": "@@ -1,3 +1,13 @@\n+2017-01-08  Jeff Law  <law@redhat.com>\n+\n+\tPR target/83994\n+\t* i386.c (get_probe_interval): Move to earlier point.\n+\t(ix86_compute_frame_layout): If -fstack-clash-protection and\n+\tthe frame is larger than the probe interval, then use pushes\n+\tto save registers rather than reg->mem moves.\n+\t(ix86_expand_prologue): Remove conditional for int_registers_saved\n+\tassertion.\n+\n 2018-01-24  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/84014"}, {"sha": "cd681687895444295d615a547eba70de83fcf3e1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5e77d9b130abdd5878557d34839e1b159a7f68ef", "patch": "@@ -11497,6 +11497,18 @@ static void warn_once_call_ms2sysv_xlogues (const char *feature)\n     }\n }\n \n+/* Return the probing interval for -fstack-clash-protection.  */\n+\n+static HOST_WIDE_INT\n+get_probe_interval (void)\n+{\n+  if (flag_stack_clash_protection)\n+    return (HOST_WIDE_INT_1U\n+\t    << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n+  else\n+    return (HOST_WIDE_INT_1U << STACK_CHECK_PROBE_INTERVAL_EXP);\n+}\n+\n /* When using -fsplit-stack, the allocation routines set a field in\n    the TCB to the bottom of the stack plus this much space, measured\n    in bytes.  */\n@@ -11773,7 +11785,14 @@ ix86_compute_frame_layout (void)\n   to_allocate = offset - frame->sse_reg_save_offset;\n \n   if ((!to_allocate && frame->nregs <= 1)\n-      || (TARGET_64BIT && to_allocate >= HOST_WIDE_INT_C (0x80000000)))\n+      || (TARGET_64BIT && to_allocate >= HOST_WIDE_INT_C (0x80000000))\n+      /* If stack clash probing needs a loop, then it needs a\n+\t scratch register.  But the returned register is only guaranteed\n+\t to be safe to use after register saves are complete.  So if\n+\t stack clash protections are enabled and the allocated frame is\n+\t larger than the probe interval, then use pushes to save\n+\t callee saved registers.  */\n+      || (flag_stack_clash_protection && to_allocate > get_probe_interval ()))\n     frame->save_regs_using_mov = false;\n \n   if (ix86_using_red_zone ()\n@@ -12567,18 +12586,6 @@ release_scratch_register_on_entry (struct scratch_reg *sr)\n     }\n }\n \n-/* Return the probing interval for -fstack-clash-protection.  */\n-\n-static HOST_WIDE_INT\n-get_probe_interval (void)\n-{\n-  if (flag_stack_clash_protection)\n-    return (HOST_WIDE_INT_1U\n-\t    << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n-  else\n-    return (HOST_WIDE_INT_1U << STACK_CHECK_PROBE_INTERVAL_EXP);\n-}\n-\n /* Emit code to adjust the stack pointer by SIZE bytes while probing it.\n \n    This differs from the next routine in that it tries hard to prevent\n@@ -13726,12 +13733,11 @@ ix86_expand_prologue (void)\n       && (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n \t  || flag_stack_clash_protection))\n     {\n-      /* This assert wants to verify that integer registers were saved\n-\t prior to probing.  This is necessary when probing may be implemented\n-\t as a function call (Windows).  It is not necessary for stack clash\n-\t protection probing.  */\n-      if (!flag_stack_clash_protection)\n-\tgcc_assert (int_registers_saved);\n+      /* We expect the GP registers to be saved when probes are used\n+\t as the probing sequences might need a scratch register and\n+\t the routine to allocate one assumes the integer registers\n+\t have already been saved.  */\n+      gcc_assert (int_registers_saved);\n \n       if (flag_stack_clash_protection)\n \t{"}, {"sha": "2c637fe5d891c9ea4c91b8cad60c72c59c1ef0c2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e77d9b130abdd5878557d34839e1b159a7f68ef", "patch": "@@ -1,3 +1,8 @@\n+2018-01-19  Jeff Law  <law@redhat.com>\n+\n+\tPR target/83994\n+\t* gcc.target/i386/pr83994.c: New test.\n+\n 2018-01-24  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/84014"}, {"sha": "dc0b7cb44c448da06a76bffba78043f6e7a02efb", "filename": "gcc/testsuite/gcc.target/i386/pr83994.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83994.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e77d9b130abdd5878557d34839e1b159a7f68ef/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83994.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83994.c?ref=5e77d9b130abdd5878557d34839e1b159a7f68ef", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=i686 -fpic -fstack-clash-protection\" } */\n+/* { dg-require-effective-target ia32 } */\n+\n+void f1 (char *);\n+\n+__attribute__ ((regparm (3)))\n+int\n+f2 (int arg1, int arg2, int arg3)\n+{\n+  char buf[16384];\n+  f1 (buf);\n+  f1 (buf);\n+  return 0;\n+}\n+"}]}