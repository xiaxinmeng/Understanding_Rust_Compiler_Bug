{"sha": "00803cd56f7d96060766249a23f3e89f778ad8f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4MDNjZDU2ZjdkOTYwNjA3NjYyNDlhMjNmM2U4OWY3NzhhZDhmMw==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-11T16:56:54Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-11T16:56:54Z"}, "message": "tree-vectorizer.c (update_phi_nodes_for_guard): Call reverse_phis.\n\n2004-11-11  Dorit Naishlos  <dorit@il.ibm.com>\n\n        * tree-vectorizer.c (update_phi_nodes_for_guard): Call reverse_phis.\n        (vect_update_ivs_after_vectorizer): Update function documentation.\n        Avoid quadratic behavior and direct write to PHI_ARG_DEF.\n\nFrom-SVN: r90480", "tree": {"sha": "3eab02180eef9d936dfec3c0ff63a7fe40704715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eab02180eef9d936dfec3c0ff63a7fe40704715"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00803cd56f7d96060766249a23f3e89f778ad8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00803cd56f7d96060766249a23f3e89f778ad8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00803cd56f7d96060766249a23f3e89f778ad8f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00803cd56f7d96060766249a23f3e89f778ad8f3/comments", "author": null, "committer": null, "parents": [{"sha": "286d28c32f89e6b8aebd42fc231a5e95f963cff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/286d28c32f89e6b8aebd42fc231a5e95f963cff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/286d28c32f89e6b8aebd42fc231a5e95f963cff2"}], "stats": {"total": 126, "additions": 75, "deletions": 51}, "files": [{"sha": "accb4dedeb8bd1745c7074bb82ce07c29f7eca38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00803cd56f7d96060766249a23f3e89f778ad8f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00803cd56f7d96060766249a23f3e89f778ad8f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00803cd56f7d96060766249a23f3e89f778ad8f3", "patch": "@@ -1,3 +1,9 @@\n+2004-11-11  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (update_phi_nodes_for_guard): Call reverse_phis.\n+\t(vect_update_ivs_after_vectorizer): Update function documentation.\n+\tAvoid quadratic behavior and direct write to PHI_ARG_DEF.\n+\n 2004-11-11  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/arm/arm.c: Fix a comment typo."}, {"sha": "3fdc54ea625b65d28d9a16f5070de03ff441305b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 69, "deletions": 51, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00803cd56f7d96060766249a23f3e89f778ad8f3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00803cd56f7d96060766249a23f3e89f778ad8f3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=00803cd56f7d96060766249a23f3e89f778ad8f3", "patch": "@@ -556,15 +556,15 @@ static void\n update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n {\n   tree phi, phi1;\n+  basic_block bb = loop->exit_edges[0]->dest;\n \n   for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n       {\n \ttree new_phi;\n \ttree phi_arg;\n \n \t/* Generate new phi node.  */\n-\tnew_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (phi)),\n-\t\t\t           loop->exit_edges[0]->dest);\n+\tnew_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (phi)), bb);\n \n \t/* Add argument coming from guard true edge.  */\n \tphi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->entry_edges[0]);\n@@ -575,22 +575,23 @@ update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n \tadd_phi_arg (&new_phi, phi_arg, loop->exit_edges[0]);\n       \n \t/* Update all phi nodes at the loop exit successor.  */\n-\tfor (phi1 = phi_nodes (EDGE_SUCC (loop->exit_edges[0]->dest, 0)->dest); \n+\tfor (phi1 = phi_nodes (EDGE_SUCC (bb, 0)->dest); \n \t     phi1; \n \t     phi1 = TREE_CHAIN (phi1))\n \t  {\n-\t    tree old_arg = PHI_ARG_DEF_FROM_EDGE (phi1, \n-\t\t\t\t  EDGE_SUCC (loop->exit_edges[0]->dest, 0));\n+\t    tree old_arg = PHI_ARG_DEF_FROM_EDGE (phi1, EDGE_SUCC (bb, 0));\n \t    if (old_arg == phi_arg)\n \t      {\t\n-\t\tedge e = EDGE_SUCC (loop->exit_edges[0]->dest, 0);\n+\t\tedge e = EDGE_SUCC (bb, 0);\n \n \t\tSET_PHI_ARG_DEF (phi1, \n \t\t\t\t phi_arg_from_edge (phi1, e),\n \t\t\t\t PHI_RESULT (new_phi)); \n \t      }\n \t  }\n       }       \n+\n+  set_phi_nodes (bb, phi_reverse (phi_nodes (bb)));\n }\n \n \n@@ -2884,44 +2885,76 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n }\n \n \n-/*   Advance IVs of the loop (to be vectorized later) to correct position.\n+/*   Function vect_update_ivs_after_vectorizer.\n+\n+     \"Advance\" the induction variables of LOOP to the value they should take\n+     after the execution of LOOP.  This is currently necessary because the\n+     vectorizer does not handle induction variables that are used after the\n+     loop.  Such a situation occurs when the last iterations of LOOP are\n+     peeled, because:\n+     1. We introduced new uses after LOOP for IVs that were not originally used\n+        after LOOP: the IVs of LOOP are now used by an epilog loop.\n+     2. LOOP is going to be vectorized; this means that it will iterate N/VF\n+        times, whereas the loop IVs should be bumped N times.\n+\n+     Input:\n+     - LOOP - a loop that is going to be vectorized. The last few iterations\n+              of LOOP were peeled.\n+     - NITERS - the number of iterations that LOOP executes (before it is\n+                vectorized). i.e, the number of times the ivs should be bumped.\n+\n+     We have:\n+\n+        bb_before_loop:\n+          if (guard-cond) GOTO bb_before_epilog_loop\n+          else            GOTO loop\n \n-     When loop is vectorized, its IVs are not always advanced\n-     correctly since vectorization changes the loop count. It's ok\n-     in case epilog loop was not produced after original one before \n-     vectorization process (the vectorizer checks that there is no uses \n-     of IVs after the loop). However, in case the epilog loop was peeled, \n-     IVs from original loop are used in epilog loop and should be \n-     advanced correctly.\n+        loop:\n+          do {\n+          } while ...\n \n-     Here we use access functions of IVs and number of\n-     iteration loop executes in order to bring IVs to correct position.\n+        bb_before_epilog_loop:\n \n-     Function also update phis of basic block at the exit\n-     from the loop.  */\n+     bb_before_epilog_loop has edges coming in form the loop exit and\n+     from bb_before_loop.  New definitions for ivs will be placed on the edge\n+     from loop->exit to bb_before_epilog_loop.  This also requires that we update\n+     the phis in bb_before_epilog_loop. (In the code this bb is denoted \n+     \"update_bb\").\n+\n+     Assumption 1: Like the rest of the vectorizer, this function assumes\n+     a single loop exit that has a single predecessor.\n+\n+     Assumption 2: The phi nodes in the LOOP header and in update_bb are\n+     organized in the same order.\n+\n+     Assumption 3: The access function of the ivs is simple enough (see\n+     vect_can_advance_ivs_p).  This assumption will be relaxed in the future.\n+ */\n \n static void\n vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n {\n   edge exit = loop->exit_edges[0];\n-  tree phi;\n-  edge latch = loop_latch_edge (loop);\n+  tree phi, phi1;\n+  basic_block update_bb = exit->dest;\n+  edge update_e;\n \n   /* Generate basic block at the exit from the loop.  */\n   basic_block new_bb = split_edge (exit);\n+\n   add_bb_to_loop (new_bb, EDGE_SUCC (new_bb, 0)->dest->loop_father);\n-  \n   loop->exit_edges[0] = EDGE_PRED (new_bb, 0);\n+  update_e = EDGE_SUCC (new_bb, 0);\n   \n-  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+  for (phi = phi_nodes (loop->header), phi1 = phi_nodes (update_bb); \n+       phi && phi1; \n+       phi = PHI_CHAIN (phi), phi1 = PHI_CHAIN (phi1))\n     {\n       tree access_fn = NULL;\n       tree evolution_part;\n       tree init_expr;\n       tree step_expr;\n       tree var, stmt, ni, ni_name;\n-      int i, j, num_elem1, num_elem2;\n-      tree phi1;\n       block_stmt_iterator last_bsi;\n \n       /* Skip virtual phi's. The data dependences that are associated with\n@@ -2935,15 +2968,17 @@ vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n \t}\n \n       access_fn = analyze_scalar_evolution (loop, PHI_RESULT (phi)); \n-\n-      evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n+      gcc_assert (access_fn);\n+      evolution_part =\n+\t unshare_expr (evolution_part_in_loop_num (access_fn, loop->num));\n       \n       /* FORNOW: We do not transform initial conditions of IVs \n \t which evolution functions are a polynomial of degree >= 2 or\n \t exponential.  */\n+      gcc_assert (!tree_is_chrec (evolution_part));\n \n       step_expr = evolution_part;\n-      init_expr = initial_condition (access_fn);\n+      init_expr = unshare_expr (initial_condition (access_fn));\n \n       ni = build2 (PLUS_EXPR, TREE_TYPE (init_expr),\n \t\t  build2 (MULT_EXPR, TREE_TYPE (niters),\n@@ -2956,31 +2991,14 @@ vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n       \n       /* Insert stmt into new_bb.  */\n       last_bsi = bsi_last (new_bb);\n-      bsi_insert_after (&last_bsi, stmt, BSI_NEW_STMT);   \n+      if (stmt)\n+        bsi_insert_after (&last_bsi, stmt, BSI_NEW_STMT);   \n \n       /* Fix phi expressions in duplicated loop.  */\n-      num_elem1 = PHI_NUM_ARGS (phi);\n-      for (i = 0; i < num_elem1; i++)\n-\tif (PHI_ARG_EDGE (phi, i) == latch)\n-\t  {\n-\t    tree def = PHI_ARG_DEF (phi, i);\n-\n-\t    for (phi1 = phi_nodes (EDGE_SUCC (new_bb, 0)->dest); phi1; \n-\t\t phi1 = TREE_CHAIN (phi1))\n-\t      {\n-\t\tnum_elem2 = PHI_NUM_ARGS (phi1);\n-\t\tfor (j = 0; j < num_elem2; j++)\n-\t\t  if (PHI_ARG_DEF (phi1, j) == def)\n-\t\t    {\n-\t\t      SET_PHI_ARG_DEF (phi1, j, ni_name);\n-\t\t      PHI_ARG_EDGE (phi1, j) = EDGE_SUCC (new_bb, 0);\t\t      \n-\t\t      break;\n- \t\t    }\t\t    \n-\t      }\n-\t    break;\n-\t  }\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (phi1, update_e) ==\n+                  PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0)));\n+      SET_PHI_ARG_DEF (phi1, phi_arg_from_edge (phi1, update_e), ni_name);\n     }\n-        \n }\n \n \n@@ -4426,8 +4444,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n        in code size).\n \n      The scheme we use FORNOW: peel to force the alignment of the first\n-     misaligned store in the loop.\n-     Rationale: misaligned store are not yet supported.\n+     misaliged store in the loop.\n+     Rationale: misaligned stores are not yet supported.\n \n      TODO: Use a better cost model.  */\n "}]}