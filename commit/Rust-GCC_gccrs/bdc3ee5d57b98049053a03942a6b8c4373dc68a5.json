{"sha": "bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjM2VlNWQ1N2I5ODA0OTA1M2EwMzk0MmE2YjhjNDM3M2RjNjhhNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-14T03:25:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-14T03:25:58Z"}, "message": "Move lowering of vector shifts from v/s to v/v from gimple to rtl.\n\nThis allows other rtl expanders to rely on shifts of vector by scalar.\n\nFrom-SVN: r179956", "tree": {"sha": "59dd3e79664e96b03e31703448c40d89aff4dd85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59dd3e79664e96b03e31703448c40d89aff4dd85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/comments", "author": null, "committer": null, "parents": [{"sha": "0772d476effe546701564ee9281fddfd189586f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0772d476effe546701564ee9281fddfd189586f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0772d476effe546701564ee9281fddfd189586f1"}], "stats": {"total": 172, "additions": 102, "deletions": 70}, "files": [{"sha": "fa2cfa89e6b4e9ba180fa565953df757084709df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -9,6 +9,12 @@\n \t* config/i386/sse.md (VEC_PERM_CONST): New mode iterator.\n \t(vec_perm_const<VEC_PERM_CONST>): New expander.\n \n+\t* optabs.c (expand_vector_broadcast): New.\n+\t(expand_binop): Expand scalar shifts of vectors to vector shifts\n+\tof vectors, if the former isn't supported.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Don't do that\n+\there; always simplify to scalar shift of vector if possible.\n+\n 2011-10-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/sse.md (vec_set<mode>): Change V_128 iterator mode"}, {"sha": "e112467196d8b596128664f76c240a98b29df155", "filename": "gcc/optabs.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -735,6 +735,41 @@ expand_vec_shift_expr (sepops ops, rtx target)\n   return eops[0].value;\n }\n \n+/* Create a new vector value in VMODE with all elements set to OP.  The\n+   mode of OP must be the element mode of VMODE.  If OP is a constant,\n+   then the return value will be a constant.  */\n+\n+static rtx\n+expand_vector_broadcast (enum machine_mode vmode, rtx op)\n+{\n+  enum insn_code icode;\n+  rtvec vec;\n+  rtx ret;\n+  int i, n;\n+\n+  gcc_checking_assert (VECTOR_MODE_P (vmode));\n+\n+  n = GET_MODE_NUNITS (vmode);\n+  vec = rtvec_alloc (n);\n+  for (i = 0; i < n; ++i)\n+    RTVEC_ELT (vec, i) = op;\n+\n+  if (CONSTANT_P (op))\n+    return gen_rtx_CONST_VECTOR (vmode, vec);\n+\n+  /* ??? If the target doesn't have a vec_init, then we have no easy way\n+     of performing this operation.  Most of this sort of generic support\n+     is hidden away in the vector lowering support in gimple.  */\n+  icode = optab_handler (vec_init_optab, vmode);\n+  if (icode == CODE_FOR_nothing)\n+    return NULL;\n+\n+  ret = gen_reg_rtx (vmode);\n+  emit_insn (GEN_FCN (icode) (ret, gen_rtx_PARALLEL (vmode, vec)));\n+\n+  return ret;\n+}\n+\n /* This subroutine of expand_doubleword_shift handles the cases in which\n    the effective shift value is >= BITS_PER_WORD.  The arguments and return\n    value are the same as for the parent routine, except that SUPERWORD_OP1\n@@ -1533,6 +1568,36 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n     }\n \n+  /* If this is a vector shift by a scalar, see if we can do a vector\n+     shift by a vector.  If so, broadcast the scalar into a vector.  */\n+  if (mclass == MODE_VECTOR_INT)\n+    {\n+      optab otheroptab = NULL;\n+\n+      if (binoptab == ashl_optab)\n+\totheroptab = vashl_optab;\n+      else if (binoptab == ashr_optab)\n+\totheroptab = vashr_optab;\n+      else if (binoptab == lshr_optab)\n+\totheroptab = vlshr_optab;\n+      else if (binoptab == rotl_optab)\n+\totheroptab = vrotl_optab;\n+      else if (binoptab == rotr_optab)\n+\totheroptab = vrotr_optab;\n+\n+      if (otheroptab && optab_handler (otheroptab, mode) != CODE_FOR_nothing)\n+\t{\n+\t  rtx vop1 = expand_vector_broadcast (mode, op1);\n+\t  if (vop1)\n+\t    {\n+\t      temp = expand_binop_directly (mode, otheroptab, op0, vop1,\n+\t\t\t\t\t    target, unsignedp, methods, last);\n+\t      if (temp)\n+\t\treturn temp;\n+\t    }\n+\t}\n+    }\n+\n   /* Look for a wider mode of the same class for which we think we\n      can open-code the operation.  Check for a widening multiply at the\n      wider mode as well.  */"}, {"sha": "48a61c9706a280c63d8764c9f9e5dbe3e2c9da78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -1,3 +1,11 @@\n+2011-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_shift_scalar):\n+\tDelete.\n+\t* gcc.dg/vect/vec-scal-opt.c: Don't test vect_shift_scalar.\n+\t* gcc.dg/vect/vec-scal-opt1.c: Likewise.\n+\t* gcc.dg/vect/vec-scal-opt2.c: Likewise.\n+\n 2011-10-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50614"}, {"sha": "f53e66d4cee37491b75165066e6501a32155dbca", "filename": "gcc/testsuite/gcc.dg/vect/vec-scal-opt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt.c?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -19,5 +19,5 @@ int main (int argc, char *argv[]) {\n    return vidx(short, r1, 0);\n }\n \n-/* { dg-final { scan-tree-dump-times \">> k.\\[0-9_\\]*\" 1 \"veclower2\" { target vect_shift_scalar } } } */\n+/* { dg-final { scan-tree-dump-times \">> k.\\[0-9_\\]*\" 1 \"veclower2\" } } */\n /* { dg-final { cleanup-tree-dump \"veclower2\" } } */"}, {"sha": "4025f6717ae0f6e2ee10c3e2df2bcb3a6cfde704", "filename": "gcc/testsuite/gcc.dg/vect/vec-scal-opt1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt1.c?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -17,5 +17,5 @@ int main (int argc, char *argv[]) {\n    return vidx(short, r1, 0);\n }\n \n-/* { dg-final { scan-tree-dump-times \">> 2\" 1 \"veclower2\" { target vect_shift_scalar } } } */\n+/* { dg-final { scan-tree-dump-times \">> 2\" 1 \"veclower2\" } } */\n /* { dg-final { cleanup-tree-dump \"veclower2\" } } */"}, {"sha": "677836da90d284b81c69a5de93a3471fbd86541a", "filename": "gcc/testsuite/gcc.dg/vect/vec-scal-opt2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvec-scal-opt2.c?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -16,5 +16,5 @@ int main (int argc, char *argv[]) {\n    return vidx(short, r1, 0);\n }\n \n-/* { dg-final { scan-tree-dump-times \">> 2\" 1 \"veclower2\" { target vect_shift_scalar } } } */\n+/* { dg-final { scan-tree-dump-times \">> 2\" 1 \"veclower2\" } } */\n /* { dg-final { cleanup-tree-dump \"veclower2\" } } */"}, {"sha": "99e83f608e3b8fed7ff56d1cd910a78e73645c80", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -2421,27 +2421,6 @@ proc check_effective_target_vect_shift { } {\n     return $et_vect_shift_saved\n }\n \n-# Return 1 if the target supports hardware vector shift operation with\n-# scalar shift argument.\n-\n-proc check_effective_target_vect_shift_scalar { } {\n-    global et_vect_shift_scalar_saved\n-\n-    if [info exists et_vect_shift_scalar_saved] {\n-        verbose \"check_effective_target_vect_shift_scalar: using cached result\" 2\n-    } else {\n-        set et_vect_shift_scalar_saved 0\n-        if { [istarget x86_64-*-*]\n-             || [istarget i?86-*-*] } {\n-           set et_vect_shift_scalar_saved 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_shift_scalar: returning $et_vect_shift_scalar_saved\" 2\n-    return $et_vect_shift_scalar_saved\n-}\n-\n-\n # Return 1 if the target supports hardware vector shift operation for char.\n \n proc check_effective_target_vect_shift_char { } {"}, {"sha": "7fba9bb42b6ffdbcb978feb2fc18b3246ab6d9c8", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc3ee5d57b98049053a03942a6b8c4373dc68a5/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=bdc3ee5d57b98049053a03942a6b8c4373dc68a5", "patch": "@@ -775,60 +775,39 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n       || code == LROTATE_EXPR\n       || code == RROTATE_EXPR)\n     {\n-      bool vector_scalar_shift;\n-      op = optab_for_tree_code (code, type, optab_scalar);\n-\n-      /* Vector/Scalar shift is supported.  */\n-      vector_scalar_shift = (op && (optab_handler (op, TYPE_MODE (type))\n-\t\t\t\t    != CODE_FOR_nothing));\n-\n-      /* If the 2nd argument is vector, we need a vector/vector shift.\n-         Except all the elements in the second vector are the same.  */\n+      /* Check whether we have vector <op> {x,x,x,x} where x\n+         could be a scalar variable or a constant.  Transform\n+         vector <op> {x,x,x,x} ==> vector <op> scalar.  */\n       if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (rhs2))))\n         {\n           tree first;\n           gimple def_stmt;\n \n-          /* Check whether we have vector <op> {x,x,x,x} where x\n-             could be a scalar variable or a constant. Transform\n-             vector <op> {x,x,x,x} ==> vector <op> scalar.  */\n-          if (vector_scalar_shift\n-              && ((TREE_CODE (rhs2) == VECTOR_CST\n-\t\t   && (first = uniform_vector_p (rhs2)) != NULL_TREE)\n-\t\t  || (TREE_CODE (rhs2) == SSA_NAME\n-\t\t      && (def_stmt = SSA_NAME_DEF_STMT (rhs2))\n-\t\t      && gimple_assign_single_p (def_stmt)\n-\t\t      && (first = uniform_vector_p\n-\t\t\t    (gimple_assign_rhs1 (def_stmt))) != NULL_TREE)))\n+          if ((TREE_CODE (rhs2) == VECTOR_CST\n+\t       && (first = uniform_vector_p (rhs2)) != NULL_TREE)\n+\t      || (TREE_CODE (rhs2) == SSA_NAME\n+\t\t  && (def_stmt = SSA_NAME_DEF_STMT (rhs2))\n+\t\t  && gimple_assign_single_p (def_stmt)\n+\t\t  && (first = uniform_vector_p\n+\t\t      (gimple_assign_rhs1 (def_stmt))) != NULL_TREE))\n             {\n               gimple_assign_set_rhs2 (stmt, first);\n               update_stmt (stmt);\n               rhs2 = first;\n             }\n-          else\n-            op = optab_for_tree_code (code, type, optab_vector);\n         }\n \n-      /* Try for a vector/scalar shift, and if we don't have one, see if we\n-         have a vector/vector shift */\n-      else if (!vector_scalar_shift)\n+      if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (rhs2))))\n+        op = optab_for_tree_code (code, type, optab_vector);\n+      else\n \t{\n-\t  op = optab_for_tree_code (code, type, optab_vector);\n+          op = optab_for_tree_code (code, type, optab_scalar);\n \n-\t  if (op && (optab_handler (op, TYPE_MODE (type))\n-\t\t     != CODE_FOR_nothing))\n-\t    {\n-\t      /* Transform vector <op> scalar => vector <op> {x,x,x,x}.  */\n-\t      int n_parts = TYPE_VECTOR_SUBPARTS (type);\n-\t      int part_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (type)), 1);\n-\t      tree part_type = lang_hooks.types.type_for_size (part_size, 1);\n-\t      tree vect_type = build_vector_type (part_type, n_parts);\n-\n-\t      rhs2 = fold_convert (part_type, rhs2);\n-\t      rhs2 = build_vector_from_val (vect_type, rhs2);\n-\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t      update_stmt (stmt);\n-\t    }\n+\t  /* The rtl expander will expand vector/scalar as vector/vector\n+\t     if necessary.  Don't bother converting the stmt here.  */\n+\t  if (op == NULL\n+\t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\t    op = optab_for_tree_code (code, type, optab_vector);\n \t}\n     }\n   else\n@@ -874,12 +853,7 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   if (compute_type == type)\n     {\n       compute_mode = TYPE_MODE (compute_type);\n-      if ((GET_MODE_CLASS (compute_mode) == MODE_VECTOR_INT\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FRACT\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_UFRACT\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_ACCUM\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_UACCUM)\n+      if (VECTOR_MODE_P (compute_mode)\n           && op != NULL\n \t  && optab_handler (op, compute_mode) != CODE_FOR_nothing)\n \treturn;"}]}