{"sha": "df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY1Y2MyMmM3ZTQ1ZDVjZjFkNjhmMjRlZTZkYjk5YzA1MmZlN2RlMQ==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2017-09-25T14:35:02Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2017-09-25T14:35:02Z"}, "message": "rs6000.c (rs6000_gimple_fold_builtin): Add handling for early folding of vector stores (ALTIVEC_BUILTIN_ST_*).\n\n[gcc]\n\n2017-09-25  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Add handling\n\tfor early folding of vector stores (ALTIVEC_BUILTIN_ST_*).\n\t(rs6000_builtin_valid_without_lhs): New helper function.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tRemove obsoleted code for handling ALTIVEC_BUILTIN_VEC_ST.\n\nFrom-SVN: r253152", "tree": {"sha": "e35846d6be9b6960e89d806774c2ad92bbabd5ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e35846d6be9b6960e89d806774c2ad92bbabd5ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2678bf2fb5f35ed07b8df3b03c9d54c2b656a96b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2678bf2fb5f35ed07b8df3b03c9d54c2b656a96b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2678bf2fb5f35ed07b8df3b03c9d54c2b656a96b"}], "stats": {"total": 153, "additions": 78, "deletions": 75}, "files": [{"sha": "ae61ed3f566ece9b6a0c17d313a6a122317a9fb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "patch": "@@ -1,3 +1,11 @@\n+2017-09-25  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Add handling\n+\tfor early folding of vector stores (ALTIVEC_BUILTIN_ST_*).\n+\t(rs6000_builtin_valid_without_lhs): New helper function.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tRemove obsoleted code for handling ALTIVEC_BUILTIN_VEC_ST.\n+\n 2017-09-25  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* target.h (vec_perm_indices): Use unsigned short rather than"}, {"sha": "4a363a12a8e198c360408b24bf79f947235c85e2", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "patch": "@@ -6472,78 +6472,6 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       return stmt;\n     }\n \n-  /* Expand vec_st into an expression that masks the address and\n-     performs the store.  We need to expand this early to allow\n-     the best aliasing, as by the time we get into RTL we no longer\n-     are able to honor __restrict__, for example.  We may want to\n-     consider this for all memory access built-ins.\n-\n-     When -maltivec=be is specified, or the wrong number of arguments\n-     is provided, simply punt to existing built-in processing.  */\n-\n-  if (fcode == ALTIVEC_BUILTIN_VEC_ST\n-      && (BYTES_BIG_ENDIAN || !VECTOR_ELT_ORDER_BIG)\n-      && nargs == 3)\n-    {\n-      tree arg0 = (*arglist)[0];\n-      tree arg1 = (*arglist)[1];\n-      tree arg2 = (*arglist)[2];\n-\n-      /* Construct the masked address.  Let existing error handling take\n-\t over if we don't have a constant offset.  */\n-      arg1 = fold (arg1);\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST)\n-\t{\n-\t  if (!ptrofftype_p (TREE_TYPE (arg1)))\n-\t    arg1 = build1 (NOP_EXPR, sizetype, arg1);\n-\n-\t  tree arg2_type = TREE_TYPE (arg2);\n-\t  if (TREE_CODE (arg2_type) == ARRAY_TYPE && c_dialect_cxx ())\n-\t    {\n-\t      /* Force array-to-pointer decay for C++.  */\n-\t      arg2 = default_conversion (arg2);\n-\t      arg2_type = TREE_TYPE (arg2);\n-\t    }\n-\n-\t  /* Find the built-in to make sure a compatible one exists; if not\n-\t     we fall back to default handling to get the error message.  */\n-\t  for (desc = altivec_overloaded_builtins;\n-\t       desc->code && desc->code != fcode; desc++)\n-\t    continue;\n-\n-\t  for (; desc->code == fcode; desc++)\n-\t    if (rs6000_builtin_type_compatible (TREE_TYPE (arg0), desc->op1)\n-\t\t&& rs6000_builtin_type_compatible (TREE_TYPE (arg1), desc->op2)\n-\t\t&& rs6000_builtin_type_compatible (TREE_TYPE (arg2),\n-\t\t\t\t\t\t   desc->op3))\n-\t      {\n-\t\ttree addr = fold_build2_loc (loc, POINTER_PLUS_EXPR, arg2_type,\n-\t\t\t\t\t     arg2, arg1);\n-\t\ttree aligned\n-\t\t  = fold_build2_loc (loc, BIT_AND_EXPR, arg2_type,\n-\t\t\t\t     addr, build_int_cst (arg2_type, -16));\n-\n-\t\ttree arg0_type = TREE_TYPE (arg0);\n-\t\tif (TYPE_MODE (arg0_type) == V2DImode)\n-\t\t  /* Type-based aliasing analysis thinks vector long\n-\t\t     and vector long long are different and will put them\n-\t\t     in distinct alias classes.  Force our address type\n-\t\t     to be a may-alias type to avoid this.  */\n-\t\t  arg0_type\n-\t\t    = build_pointer_type_for_mode (arg0_type, Pmode,\n-\t\t\t\t\t\t   true/*can_alias_all*/);\n-\t\telse\n-\t\t  arg0_type = build_pointer_type (arg0_type);\n-\t\taligned = build1 (NOP_EXPR, arg0_type, aligned);\n-\t\ttree stg = build_indirect_ref (loc, aligned, RO_NULL);\n-\t\ttree retval = build2 (MODIFY_EXPR, TREE_TYPE (stg), stg,\n-\t\t\t\t      convert (TREE_TYPE (stg), arg0));\n-\t\treturn retval;\n-\t      }\n-\t}\n-    }\n-\n   for (n = 0;\n        !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;\n        fnargs = TREE_CHAIN (fnargs), n++)"}, {"sha": "3212634f7838f25cde76dc736c274a8a40951402", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=df5cc22c7e45d5cf1d68f24ee6db99c052fe7de1", "patch": "@@ -16157,6 +16157,25 @@ rs6000_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n #endif\n }\n \n+/*  Helper function to sort out which built-ins may be valid without having\n+    a LHS.  */\n+static bool\n+rs6000_builtin_valid_without_lhs (enum rs6000_builtins fn_code)\n+{\n+  switch (fn_code)\n+    {\n+    case ALTIVEC_BUILTIN_STVX_V16QI:\n+    case ALTIVEC_BUILTIN_STVX_V8HI:\n+    case ALTIVEC_BUILTIN_STVX_V4SI:\n+    case ALTIVEC_BUILTIN_STVX_V4SF:\n+    case ALTIVEC_BUILTIN_STVX_V2DI:\n+    case ALTIVEC_BUILTIN_STVX_V2DF:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n    a constant, use rs6000_fold_builtin.)  */\n \n@@ -16184,8 +16203,9 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n   if (!rs6000_fold_gimple)\n     return false;\n \n-  /* Generic solution to prevent gimple folding of code without a LHS.  */\n-  if (!gimple_call_lhs (stmt))\n+  /* Prevent gimple folding for code that does not have a LHS, unless it is\n+   allowed per the rs6000_builtin_valid_without_lhs helper function.  */\n+  if (!gimple_call_lhs (stmt) && !rs6000_builtin_valid_without_lhs (fn_code))\n     return false;\n \n   switch (fn_code)\n@@ -16587,7 +16607,54 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t gsi_replace (gsi, g, true);\n \t return true;\n       }\n-\n+    /* Vector stores.  */\n+    case ALTIVEC_BUILTIN_STVX_V16QI:\n+    case ALTIVEC_BUILTIN_STVX_V8HI:\n+    case ALTIVEC_BUILTIN_STVX_V4SI:\n+    case ALTIVEC_BUILTIN_STVX_V4SF:\n+    case ALTIVEC_BUILTIN_STVX_V2DI:\n+    case ALTIVEC_BUILTIN_STVX_V2DF:\n+      {\n+\t /* Do not fold for -maltivec=be on LE targets.  */\n+\t if (VECTOR_ELT_ORDER_BIG && !BYTES_BIG_ENDIAN)\n+\t    return false;\n+\t arg0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n+\t arg1 = gimple_call_arg (stmt, 1); /* Offset.  */\n+\t tree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n+\t location_t loc = gimple_location (stmt);\n+\t tree arg0_type = TREE_TYPE (arg0);\n+\t /* Use ptr_type_node (no TBAA) for the arg2_type.\n+\t  FIXME: (Richard)  \"A proper fix would be to transition this type as\n+\t  seen from the frontend to GIMPLE, for example in a similar way we\n+\t  do for MEM_REFs by piggy-backing that on an extra argument, a\n+\t  constant zero pointer of the alias pointer type to use (which would\n+\t  also serve as a type indicator of the store itself).  I'd use a\n+\t  target specific internal function for this (not sure if we can have\n+\t  those target specific, but I guess if it's folded away then that's\n+\t  fine) and get away with the overload set.\"\n+\t  */\n+\t tree arg2_type = ptr_type_node;\n+\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t    the tree using the value from arg0.  The resulting type will match\n+\t    the type of arg2.  */\n+\t gimple_seq stmts = NULL;\n+\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n+\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg2_type, arg2, temp_offset);\n+\t /* Mask off any lower bits from the address.  */\n+\t tree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n+\t\t\t\t\t  arg2_type, temp_addr,\n+\t\t\t\t\t  build_int_cst (arg2_type, -16));\n+\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* The desired gimple result should be similar to:\n+\t MEM[(__vector floatD.1407 *)_1] = vf1D.2697;  */\n+\t gimple *g;\n+\t g = gimple_build_assign (build2 (MEM_REF, arg0_type, aligned_addr,\n+\t\t\t\t\t   build_int_cst (arg2_type, 0)), arg0);\n+\t gimple_set_location (g, loc);\n+\t gsi_replace (gsi, g, true);\n+\t return true;\n+      }\n     default:\n \tif (TARGET_DEBUG_BUILTIN)\n \t   fprintf (stderr, \"gimple builtin intrinsic not matched:%d %s %s\\n\","}]}