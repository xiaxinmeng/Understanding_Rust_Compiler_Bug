{"sha": "581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxZWRmOTI2MGJkZGQzZjBjZTEzZTJmMmI2NzU4ZjZmNjM4YjIyYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-04-08T18:12:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-04-08T18:12:53Z"}, "message": "gigi.h (standard_datatypes): Add ADT_fdesc_type and ADT_null_fdesc.\n\n\t* gigi.h (standard_datatypes): Add ADT_fdesc_type and ADT_null_fdesc.\n\t(fdesc_type_node): Define.\n\t(null_fdesc_node): Likewise.\n\t* decl.c (gnat_to_gnu_entity) <E_Access_Subprogram_Type>: If the target\n\tuses descriptors for vtables and the type comes from a dispatch table,\n\treturn the descriptor type.\n\t* trans.c (Attribute_to_gnu) <Attr_Unrestricted_Access>: If the target\n\tuses descriptors for vtables and the type comes from a dispatch table,\n\tbuild a descriptor in the static case and copy the existing one in the\n\tnon-static case.\n\t(gnat_to_gnu) <N_Null>: If the target uses descriptors for vtables and\n\tthe type is a pointer-to-subprogram coming from a dispatch table,\n\treturn the null descriptor.\n\t<N_Unchecked_Type_Conversion>: If the target uses descriptors for\n\tvtables, the source type is the descriptor type and the target type\n\tis a pointer type, first build the pointer.\n\t* utils.c (init_gigi_decls): If the target uses descriptors for vtables\n\tbuild the descriptor type and the null descriptor.\n\nFrom-SVN: r134101", "tree": {"sha": "e042a3438f9aaea3565ebd713196dfa9f19c8e53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e042a3438f9aaea3565ebd713196dfa9f19c8e53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/comments", "author": null, "committer": null, "parents": [{"sha": "57b9e36755f9459bcb6b6699b12b150037a5adb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57b9e36755f9459bcb6b6699b12b150037a5adb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57b9e36755f9459bcb6b6699b12b150037a5adb4"}], "stats": {"total": 129, "additions": 126, "deletions": 3}, "files": [{"sha": "716f1bd37dfe02544f786a0d168cf728ca81e39f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "patch": "@@ -1,3 +1,24 @@\n+2008-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gigi.h (standard_datatypes): Add ADT_fdesc_type and ADT_null_fdesc.\n+\t(fdesc_type_node): Define.\n+\t(null_fdesc_node): Likewise.\n+\t* decl.c (gnat_to_gnu_entity) <E_Access_Subprogram_Type>: If the target\n+\tuses descriptors for vtables and the type comes from a dispatch table,\n+\treturn the descriptor type.\n+\t* trans.c (Attribute_to_gnu) <Attr_Unrestricted_Access>: If the target\n+\tuses descriptors for vtables and the type comes from a dispatch table,\n+\tbuild a descriptor in the static case and copy the existing one in the\n+\tnon-static case.\n+\t(gnat_to_gnu) <N_Null>: If the target uses descriptors for vtables and\n+\tthe type is a pointer-to-subprogram coming from a dispatch table,\n+\treturn the null descriptor.\n+\t<N_Unchecked_Type_Conversion>: If the target uses descriptors for\n+\tvtables, the source type is the descriptor type and the target type\n+\tis a pointer type, first build the pointer.\n+\t* utils.c (init_gigi_decls): If the target uses descriptors for vtables\n+\tbuild the descriptor type and the null descriptor.\n+\n 2008-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* decl.c (prepend_attributes): Fix typo."}, {"sha": "aca69ff84a38f356d5f013f44a661f6197c59356", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "patch": "@@ -3089,6 +3089,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Access_Subprogram_Type:\n+      /* Use the special descriptor type for dispatch tables if needed,\n+\t that is to say for the Prim_Ptr of a-tags.ads and its clones.\n+\t Note that we are only required to do so for static tables in\n+\t order to be compatible with the C++ ABI, but Ada 2005 allows\n+\t to extend library level tagged types at the local level so\n+\t we do it in the non-static case as well.  */\n+      if (TARGET_VTABLE_USES_DESCRIPTORS\n+\t  && Is_Dispatch_Table_Entity (gnat_entity))\n+\t{\n+\t    gnu_type = fdesc_type_node;\n+\t    gnu_size = TYPE_SIZE (gnu_type);\n+\t    break;\n+\t}\n+\n+      /* ... fall through ... */\n+\n     case E_Anonymous_Access_Subprogram_Type:\n       /* If we are not defining this entity, and we have incomplete\n \t entities being processed above us, make a dummy type and"}, {"sha": "59a17ab66af6b887b266e23cf005bb543bbac81f", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "patch": "@@ -373,8 +373,12 @@ enum standard_datatypes\n   /* Type declaration node  <==> typedef void *T() */\n   ADT_ptr_void_ftype,\n \n-  /* A function declaration node for a run-time function for allocating memory.\n-     Ada allocators cause calls to this function to be generated.   */\n+  /* Type declaration node  <==> typedef virtual void *T() */\n+  ADT_fdesc_type,\n+\n+  /* Null pointer for above type */\n+  ADT_null_fdesc,\n+\n   ADT_malloc_decl,\n \n   /* Likewise for freeing memory.  */\n@@ -406,6 +410,8 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n #define ptr_void_type_node gnat_std_decls[(int) ADT_ptr_void_type]\n #define void_ftype gnat_std_decls[(int) ADT_void_ftype]\n #define ptr_void_ftype gnat_std_decls[(int) ADT_ptr_void_ftype]\n+#define fdesc_type_node gnat_std_decls[(int) ADT_fdesc_type]\n+#define null_fdesc_node gnat_std_decls[(int) ADT_null_fdesc]\n #define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n #define free_decl gnat_std_decls[(int) ADT_free_decl]\n #define jmpbuf_type gnat_std_decls[(int) ADT_jmpbuf_type]"}, {"sha": "4dc5202f17cd60c2e499cf7ae64b727355d4d171", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "patch": "@@ -852,6 +852,53 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       if (attribute == Attr_Address)\n \tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n \n+      /* If we are building a static dispatch table, we have to honor\n+\t TARGET_VTABLE_USES_DESCRIPTORS if we want to be compatible\n+\t with the C++ ABI.  We do it in the non-static case as well,\n+\t see gnat_to_gnu_entity, case E_Access_Subprogram_Type.  */\n+      else if (TARGET_VTABLE_USES_DESCRIPTORS\n+\t       && Is_Dispatch_Table_Entity (Etype (gnat_node)))\n+\t{\n+\t  tree gnu_field, gnu_list = NULL_TREE, t;\n+\t  /* Descriptors can only be built here for top-level functions.  */\n+\t  bool build_descriptor = (global_bindings_p () != 0);\n+\t  int i;\n+\n+\t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\n+\t  /* If we're not going to build the descriptor, we have to retrieve\n+\t     the one which will be built by the linker (or by the compiler\n+\t     later if a static chain is requested).  */\n+\t  if (!build_descriptor)\n+\t    {\n+\t      gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_prefix);\n+\t      gnu_result = fold_convert (build_pointer_type (gnu_result_type),\n+\t\t\t\t\t gnu_result);\n+\t      gnu_result = build1 (INDIRECT_REF, gnu_result_type, gnu_result);\n+\t    }\n+\n+\t  for (gnu_field = TYPE_FIELDS (gnu_result_type), i = 0;\n+\t       i < TARGET_VTABLE_USES_DESCRIPTORS;\n+\t       gnu_field = TREE_CHAIN (gnu_field), i++)\n+\t    {\n+\t      if (build_descriptor)\n+\t\t{\n+\t\t  t = build2 (FDESC_EXPR, TREE_TYPE (gnu_field), gnu_prefix,\n+\t\t\t      build_int_cst (NULL_TREE, i));\n+\t\t  TREE_CONSTANT (t) = 1;\n+\t\t  TREE_INVARIANT (t) = 1;\n+\t\t}\n+\t      else\n+\t\tt = build3 (COMPONENT_REF, ptr_void_ftype, gnu_result,\n+\t\t\t    gnu_field, NULL_TREE);\n+\n+\t      gnu_list = tree_cons (gnu_field, t, gnu_list);\n+\t    }\n+\n+\t  gnu_result = gnat_build_constructor (gnu_result_type, gnu_list);\n+\t  break;\n+\t}\n+\n       /* ... fall through ... */\n \n     case Attr_Access:\n@@ -3649,7 +3696,12 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Null:\n-      gnu_result = null_pointer_node;\n+      if (TARGET_VTABLE_USES_DESCRIPTORS\n+\t  && Ekind (Etype (gnat_node)) == E_Access_Subprogram_Type\n+\t  && Is_Dispatch_Table_Entity (Etype (gnat_node)))\n+\tgnu_result = null_fdesc_node;\n+      else\n+\tgnu_result = null_pointer_node;\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       break;\n \n@@ -3687,6 +3739,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       size_int (align / BITS_PER_UNIT), oalign / BITS_PER_UNIT);\n \t}\n \n+      /* If we are converting a descriptor to a function pointer, first\n+\t build the pointer.  */\n+      if (TARGET_VTABLE_USES_DESCRIPTORS\n+\t  && TREE_TYPE (gnu_result) == fdesc_type_node\n+\t  && POINTER_TYPE_P (gnu_result_type))\n+\tgnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_result);\n+\n       gnu_result = unchecked_convert (gnu_result_type, gnu_result,\n \t\t\t\t      No_Truncation (gnat_node));\n       break;"}, {"sha": "76f4aabbb2629f578a742a70739d7a2bb3b5dd6c", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581edf9260bddd3f0ce13e2f2b6758f6f638b22c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "patch": "@@ -548,6 +548,27 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n   void_ftype = build_function_type (void_type_node, NULL_TREE);\n   ptr_void_ftype = build_pointer_type (void_ftype);\n \n+  /* Build the special descriptor type and its null node if needed.  */\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    {\n+      tree field_list = NULL_TREE, null_list = NULL_TREE;\n+      int j;\n+\n+      fdesc_type_node = make_node (RECORD_TYPE);\n+\n+      for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; j++)\n+\t{\n+\t  tree field = create_field_decl (NULL_TREE, ptr_void_ftype,\n+\t\t\t\t\t  fdesc_type_node, 0, 0, 0, 1);\n+\t  TREE_CHAIN (field) = field_list;\n+\t  field_list = field;\n+\t  null_list = tree_cons (field, null_pointer_node, null_list);\n+\t}\n+\n+      finish_record_type (fdesc_type_node, nreverse (field_list), 0, false);\n+      null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_list);\n+    }\n+\n   /* Now declare runtime functions. */\n   endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n "}]}