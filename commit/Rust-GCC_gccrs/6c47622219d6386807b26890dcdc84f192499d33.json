{"sha": "6c47622219d6386807b26890dcdc84f192499d33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM0NzYyMjIxOWQ2Mzg2ODA3YjI2ODkwZGNkYzg0ZjE5MjQ5OWQzMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:20:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:20:52Z"}, "message": "Remove global call sets: IRA\n\nFor -fipa-ra, IRA already keeps track of which specific registers\nare call-clobbered in a region, rather than using global information.\nThe patch generalises this so that it tracks which ABIs are used\nby calls in the region.\n\nWe can then use the new ABI descriptors to handle partially-clobbered\nregisters in the same way as fully-clobbered registers, without having\nspecial code for targetm.hard_regno_call_part_clobbered.  This in turn\nmakes -fipa-ra work for partially-clobbered registers too.\n\nA side-effect of allowing multiple ABIs is that we no longer have\nan obvious set of conflicting registers for the self-described\n\"fragile hack\" in ira-constraints.c.  This code kicks in for\nuser-defined registers that aren't live across a call at -O0,\nand it tries to avoid allocating a call-clobbered register to them.\nHere I've used the set of call-clobbered registers in the current\nfunction's ABI, applying on top of any registers that are clobbered by\ncalled functions.  This is enough to keep gcc.dg/debug/dwarf2/pr5948.c\nhappy.\n\nThe handling of GENERIC_STACK_CHECK in do_reload seemed to have\na reversed condition:\n\n      for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n\tif (df_regs_ever_live_p (i)\n\t    && !fixed_regs[i]\n\t    && call_used_or_fixed_reg_p (i))\n\t  size += UNITS_PER_WORD;\n\nThe final part of the condition counts registers that don't need to be\nsaved in the prologue, but I think the opposite was intended.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* function-abi.h (call_clobbers_in_region): Declare.\n\t(call_clobbered_in_region_p): New function.\n\t* function-abi.cc (call_clobbers_in_region): Likewise.\n\t* ira-int.h: Include function-abi.h.\n\t(ira_allocno::crossed_calls_abis): New field.\n\t(ALLOCNO_CROSSED_CALLS_ABIS): New macro.\n\t(ira_need_caller_save_regs): New function.\n\t(ira_need_caller_save_p): Likewise.\n\t* ira.c (setup_reg_renumber): Use ira_need_caller_save_p instead\n\tof call_used_or_fixed_regs.\n\t(do_reload): Use crtl->abi to test whether the current function\n\tneeds to save a register in the prologue.  Count registers that\n\tneed to be saved rather than registers that don't.\n\t* ira-build.c (create_cap_allocno): Copy ALLOCNO_CROSSED_CALLS_ABIS.\n\tRemove unnecessary | from ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS.\n\t(propagate_allocno_info): Merge ALLOCNO_CROSSED_CALLS_ABIS too.\n\t(propagate_some_info_from_allocno): Likewise.\n\t(copy_info_to_removed_store_destinations): Likewise.\n\t(ira_flattening): Say that ALLOCNO_CROSSED_CALLS_ABIS and\n\tALLOCNO_CROSSED_CALLS_CLOBBERED_REGS are handled conservatively.\n\t(ira_build): Use ira_need_caller_save_regs instead of\n\tcall_used_or_fixed_regs.\n\t* ira-color.c (calculate_saved_nregs): Use crtl->abi to test\n\twhether the current function would need to save a register\n\tbefore using it.\n\t(calculate_spill_cost): Likewise.\n\t(allocno_reload_assign): Use ira_need_caller_save_regs and\n\tira_need_caller_save_p instead of call_used_or_fixed_regs.\n\t* ira-conflicts.c (ira_build_conflicts): Use\n\tira_need_caller_save_regs rather than call_used_or_fixed_regs\n\tas the set of call-clobbered registers.  Remove the\n\tcall_used_or_fixed_regs mask from the calculation of\n\ttemp_hard_reg_set and mask its use instead.  Remove special\n\thandling of partially-clobbered registers.\n\t* ira-costs.c (ira_tune_allocno_costs): Use ira_need_caller_save_p.\n\t* ira-lives.c (process_bb_node_lives): Use mode_clobbers to\n\tcalculate the set of conflicting registers for calls that\n\tcan throw.  Record the ABIs of calls in ALLOCNO_CROSSED_CALLS_ABIS.\n\tUse full_and_partial_reg_clobbers rather than full_reg_clobbers\n\tfor the calculation of ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS.\n\tUse eh_edge_abi to calculate the set of registers that could\n\tbe clobbered by an EH edge.  Include partially-clobbered as\n\twell as fully-clobbered registers.\n\nFrom-SVN: r276325", "tree": {"sha": "9ea524a6474c5ed4540c9d867042bd4df6f45c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ea524a6474c5ed4540c9d867042bd4df6f45c85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c47622219d6386807b26890dcdc84f192499d33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c47622219d6386807b26890dcdc84f192499d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c47622219d6386807b26890dcdc84f192499d33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c47622219d6386807b26890dcdc84f192499d33/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7450506b5d48642a71459cfc24efcea6ca58e97e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7450506b5d48642a71459cfc24efcea6ca58e97e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7450506b5d48642a71459cfc24efcea6ca58e97e"}], "stats": {"total": 258, "additions": 178, "deletions": 80}, "files": [{"sha": "c0454ce7d9bf7eacd2dc157a6411d39708d5f22b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -1,3 +1,49 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* function-abi.h (call_clobbers_in_region): Declare.\n+\t(call_clobbered_in_region_p): New function.\n+\t* function-abi.cc (call_clobbers_in_region): Likewise.\n+\t* ira-int.h: Include function-abi.h.\n+\t(ira_allocno::crossed_calls_abis): New field.\n+\t(ALLOCNO_CROSSED_CALLS_ABIS): New macro.\n+\t(ira_need_caller_save_regs): New function.\n+\t(ira_need_caller_save_p): Likewise.\n+\t* ira.c (setup_reg_renumber): Use ira_need_caller_save_p instead\n+\tof call_used_or_fixed_regs.\n+\t(do_reload): Use crtl->abi to test whether the current function\n+\tneeds to save a register in the prologue.  Count registers that\n+\tneed to be saved rather than registers that don't.\n+\t* ira-build.c (create_cap_allocno): Copy ALLOCNO_CROSSED_CALLS_ABIS.\n+\tRemove unnecessary | from ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS.\n+\t(propagate_allocno_info): Merge ALLOCNO_CROSSED_CALLS_ABIS too.\n+\t(propagate_some_info_from_allocno): Likewise.\n+\t(copy_info_to_removed_store_destinations): Likewise.\n+\t(ira_flattening): Say that ALLOCNO_CROSSED_CALLS_ABIS and\n+\tALLOCNO_CROSSED_CALLS_CLOBBERED_REGS are handled conservatively.\n+\t(ira_build): Use ira_need_caller_save_regs instead of\n+\tcall_used_or_fixed_regs.\n+\t* ira-color.c (calculate_saved_nregs): Use crtl->abi to test\n+\twhether the current function would need to save a register\n+\tbefore using it.\n+\t(calculate_spill_cost): Likewise.\n+\t(allocno_reload_assign): Use ira_need_caller_save_regs and\n+\tira_need_caller_save_p instead of call_used_or_fixed_regs.\n+\t* ira-conflicts.c (ira_build_conflicts): Use\n+\tira_need_caller_save_regs rather than call_used_or_fixed_regs\n+\tas the set of call-clobbered registers.  Remove the\n+\tcall_used_or_fixed_regs mask from the calculation of\n+\ttemp_hard_reg_set and mask its use instead.  Remove special\n+\thandling of partially-clobbered registers.\n+\t* ira-costs.c (ira_tune_allocno_costs): Use ira_need_caller_save_p.\n+\t* ira-lives.c (process_bb_node_lives): Use mode_clobbers to\n+\tcalculate the set of conflicting registers for calls that\n+\tcan throw.  Record the ABIs of calls in ALLOCNO_CROSSED_CALLS_ABIS.\n+\tUse full_and_partial_reg_clobbers rather than full_reg_clobbers\n+\tfor the calculation of ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS.\n+\tUse eh_edge_abi to calculate the set of registers that could\n+\tbe clobbered by an EH edge.  Include partially-clobbered as\n+\twell as fully-clobbered registers.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* haifa-sched.c: Include function-abi.h."}, {"sha": "4bace9e138bb235390de8e0f12849ec47b6c1ad7", "filename": "gcc/function-abi.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Ffunction-abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Ffunction-abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.cc?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -126,6 +126,31 @@ predefined_function_abi::add_full_reg_clobber (unsigned int regno)\n     SET_HARD_REG_BIT (m_mode_clobbers[i], regno);\n }\n \n+/* Return the set of registers that cannot be used to hold a value of\n+   mode MODE across the calls in a region described by ABIS and MASK, where:\n+\n+   * Bit ID of ABIS is set if the region contains a call with\n+     function_abi identifier ID.\n+\n+   * MASK contains all the registers that are fully or partially\n+     clobbered by calls in the region.\n+\n+   This is not quite as accurate as testing each individual call,\n+   but it's a close and conservatively-correct approximation.\n+   It's much better for some targets than just using MASK.  */\n+\n+HARD_REG_SET\n+call_clobbers_in_region (unsigned int abis, const_hard_reg_set mask,\n+\t\t\t machine_mode mode)\n+{\n+  HARD_REG_SET result;\n+  CLEAR_HARD_REG_SET (result);\n+  for (unsigned int id = 0; abis; abis >>= 1, ++id)\n+    if (abis & 1)\n+      result |= function_abis[id].mode_clobbers (mode);\n+  return result & mask;\n+}\n+\n /* Return the predefined ABI used by functions with type TYPE.  */\n \n const predefined_function_abi &"}, {"sha": "8dd139ecb1bf5eb8b89cddd6fd1de80d694a8bb9", "filename": "gcc/function-abi.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Ffunction-abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Ffunction-abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.h?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -265,6 +265,32 @@ extern target_function_abi_info *this_target_function_abi_info;\n   (this_target_function_abi_info->x_function_abis[0])\n #define eh_edge_abi default_function_abi\n \n+extern HARD_REG_SET call_clobbers_in_region (unsigned int, const_hard_reg_set,\n+\t\t\t\t\t     machine_mode mode);\n+\n+/* Return true if (reg:MODE REGNO) might be clobbered by one of the\n+   calls in a region described by ABIS and MASK, where:\n+\n+   * Bit ID of ABIS is set if the region contains a call with\n+     function_abi identifier ID.\n+\n+   * MASK contains all the registers that are fully or partially\n+     clobbered by calls in the region.\n+\n+   This is not quite as accurate as testing each individual call,\n+   but it's a close and conservatively-correct approximation.\n+   It's much better for some targets than:\n+\n+     overlaps_hard_reg_set_p (MASK, MODE, REGNO).  */\n+\n+inline bool\n+call_clobbered_in_region_p (unsigned int abis, const_hard_reg_set mask,\n+\t\t\t    machine_mode mode, unsigned int regno)\n+{\n+  HARD_REG_SET clobbers = call_clobbers_in_region (abis, mask, mode);\n+  return overlaps_hard_reg_set_p (clobbers, mode, regno);\n+}\n+\n extern const predefined_function_abi &fntype_abi (const_tree);\n extern function_abi fndecl_abi (const_tree);\n extern function_abi insn_callee_abi (const rtx_insn *);"}, {"sha": "ad1eaa45a2852cacb115d15e6ee1776ae16fd56a", "filename": "gcc/ira-build.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -903,8 +903,9 @@ create_cap_allocno (ira_allocno_t a)\n \n   ALLOCNO_CALLS_CROSSED_NUM (cap) = ALLOCNO_CALLS_CROSSED_NUM (a);\n   ALLOCNO_CHEAP_CALLS_CROSSED_NUM (cap) = ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n+  ALLOCNO_CROSSED_CALLS_ABIS (cap) = ALLOCNO_CROSSED_CALLS_ABIS (a);\n   ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (cap)\n-    |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n+    = ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     {\n       fprintf (ira_dump_file, \"    Creating cap \");\n@@ -2032,6 +2033,8 @@ propagate_allocno_info (void)\n \t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n \t  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n \t    += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n+\t  ALLOCNO_CROSSED_CALLS_ABIS (parent_a)\n+\t    |= ALLOCNO_CROSSED_CALLS_ABIS (a);\n \t  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a)\n \t    |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n \t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n@@ -2415,6 +2418,7 @@ propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n   ALLOCNO_CALLS_CROSSED_NUM (a) += ALLOCNO_CALLS_CROSSED_NUM (from_a);\n   ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a)\n     += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (from_a);\n+  ALLOCNO_CROSSED_CALLS_ABIS (a) |= ALLOCNO_CROSSED_CALLS_ABIS (from_a);\n   ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a)\n     |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (from_a);\n \n@@ -3056,6 +3060,8 @@ copy_info_to_removed_store_destinations (int regno)\n \t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n       ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n \t+= ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n+      ALLOCNO_CROSSED_CALLS_ABIS (parent_a)\n+\t|= ALLOCNO_CROSSED_CALLS_ABIS (a);\n       ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a)\n \t|= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n       ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n@@ -3155,6 +3161,9 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t\t-= ALLOCNO_CALLS_CROSSED_NUM (a);\n \t      ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n \t\t-= ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n+\t      /* Assume that ALLOCNO_CROSSED_CALLS_ABIS and\n+\t\t ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS stay the same.\n+\t\t We'd need to rebuild the IR to do better.  */\n \t      ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t\t-= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t      ira_assert (ALLOCNO_CALLS_CROSSED_NUM (parent_a) >= 0\n@@ -3462,7 +3471,7 @@ ira_build (void)\n \t allocno crossing calls.  */\n       FOR_EACH_ALLOCNO (a, ai)\n \tif (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t  ior_hard_reg_conflicts (a, call_used_or_fixed_regs);\n+\t  ior_hard_reg_conflicts (a, ira_need_caller_save_regs (a));\n     }\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_copies (ira_dump_file);"}, {"sha": "9197db972f37f6e8183741dfa1f03dc2e50e9b2f", "filename": "gcc/ira-color.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -1650,7 +1650,7 @@ calculate_saved_nregs (int hard_regno, machine_mode mode)\n   ira_assert (hard_regno >= 0);\n   for (i = hard_regno_nregs (hard_regno, mode) - 1; i >= 0; i--)\n     if (!allocated_hardreg_p[hard_regno + i]\n-\t&& !TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno + i)\n+\t&& !crtl->abi->clobbers_full_reg_p (hard_regno + i)\n \t&& !LOCAL_REGNO (hard_regno + i))\n       nregs++;\n   return nregs;\n@@ -4379,7 +4379,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n       saved[i] = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n       OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= forbidden_regs;\n       if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_or_fixed_regs;\n+\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= ira_need_caller_save_regs (a);\n     }\n   ALLOCNO_ASSIGNED_P (a) = false;\n   aclass = ALLOCNO_CLASS (a);\n@@ -4398,9 +4398,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n \t       ? ALLOCNO_CLASS_COST (a)\n \t       : ALLOCNO_HARD_REG_COSTS (a)[ira_class_hard_reg_index\n \t\t\t\t\t    [aclass][hard_regno]]));\n-      if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n-\t  && ira_hard_reg_set_intersection_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t      call_used_or_fixed_regs))\n+      if (ira_need_caller_save_p (a, regno))\n \t{\n \t  ira_assert (flag_caller_saves);\n \t  caller_save_needed = 1;\n@@ -4687,16 +4685,16 @@ ira_mark_new_stack_slot (rtx x, int regno, poly_uint64 total_size)\n    given IN and OUT for INSN.  Return also number points (through\n    EXCESS_PRESSURE_LIVE_LENGTH) where the pseudo-register lives and\n    the register pressure is high, number of references of the\n-   pseudo-registers (through NREFS), number of callee-clobbered\n-   hard-registers occupied by the pseudo-registers (through\n-   CALL_USED_COUNT), and the first hard regno occupied by the\n+   pseudo-registers (through NREFS), the number of psuedo registers\n+   whose allocated register wouldn't need saving in the prologue\n+   (through CALL_USED_COUNT), and the first hard regno occupied by the\n    pseudo-registers (through FIRST_HARD_REGNO).  */\n static int\n calculate_spill_cost (int *regnos, rtx in, rtx out, rtx_insn *insn,\n \t\t      int *excess_pressure_live_length,\n \t\t      int *nrefs, int *call_used_count, int *first_hard_regno)\n {\n-  int i, cost, regno, hard_regno, j, count, saved_cost, nregs;\n+  int i, cost, regno, hard_regno, count, saved_cost;\n   bool in_p, out_p;\n   int length;\n   ira_allocno_t a;\n@@ -4713,11 +4711,8 @@ calculate_spill_cost (int *regnos, rtx in, rtx out, rtx_insn *insn,\n       a = ira_regno_allocno_map[regno];\n       length += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a) / ALLOCNO_NUM_OBJECTS (a);\n       cost += ALLOCNO_MEMORY_COST (a) - ALLOCNO_CLASS_COST (a);\n-      nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (a));\n-      for (j = 0; j < nregs; j++)\n-\tif (! TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno + j))\n-\t  break;\n-      if (j == nregs)\n+      if (in_hard_reg_set_p (crtl->abi->full_reg_clobbers (),\n+\t\t\t     ALLOCNO_MODE (a), hard_regno))\n \tcount++;\n       in_p = in && REG_P (in) && (int) REGNO (in) == hard_regno;\n       out_p = out && REG_P (out) && (int) REGNO (out) == hard_regno;"}, {"sha": "a0aefaa0549a9843e7bee36afa0b843375911c40", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 18, "deletions": 38, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -770,39 +770,36 @@ ira_build_conflicts (void)\n   if (! targetm.class_likely_spilled_p (base))\n     CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   else\n-    temp_hard_reg_set = (reg_class_contents[base]\n-\t\t\t & ~ira_no_alloc_regs\n-\t\t\t & call_used_or_fixed_regs);\n+    temp_hard_reg_set = reg_class_contents[base] & ~ira_no_alloc_regs;\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       int i, n = ALLOCNO_NUM_OBJECTS (a);\n \n       for (i = 0; i < n; i++)\n \t{\n \t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-\t  machine_mode obj_mode = obj->allocno->mode;\n \t  rtx allocno_reg = regno_reg_rtx [ALLOCNO_REGNO (a)];\n \n-\t  if ((! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t      /* For debugging purposes don't put user defined variables in\n-\t\t callee-clobbered registers.  However, do allow parameters\n-\t\t in callee-clobbered registers to improve debugging.  This\n-\t\t is a bit of a fragile hack.  */\n-\t      || (optimize == 0\n-\t\t  && REG_USERVAR_P (allocno_reg)\n-\t\t  && ! reg_is_parm_p (allocno_reg)))\n+\t  /* For debugging purposes don't put user defined variables in\n+\t     callee-clobbered registers.  However, do allow parameters\n+\t     in callee-clobbered registers to improve debugging.  This\n+\t     is a bit of a fragile hack.  */\n+\t  if (optimize == 0\n+\t      && REG_USERVAR_P (allocno_reg)\n+\t      && ! reg_is_parm_p (allocno_reg))\n \t    {\n-\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_or_fixed_regs;\n-\t      OBJECT_CONFLICT_HARD_REGS (obj) |= call_used_or_fixed_regs;\n+\t      HARD_REG_SET new_conflict_regs = crtl->abi->full_reg_clobbers ();\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= new_conflict_regs;\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= new_conflict_regs;\n \t    }\n-\t  else if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+\n+\t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t    {\n-\t      HARD_REG_SET no_caller_save_reg_set\n-\t\t= (call_used_or_fixed_regs & ~savable_regs);\n-\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= no_caller_save_reg_set;\n-\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= temp_hard_reg_set;\n-\t      OBJECT_CONFLICT_HARD_REGS (obj) |= no_caller_save_reg_set;\n-\t      OBJECT_CONFLICT_HARD_REGS (obj) |= temp_hard_reg_set;\n+\t      HARD_REG_SET new_conflict_regs = ira_need_caller_save_regs (a);\n+\t      if (flag_caller_saves)\n+\t\tnew_conflict_regs &= (~savable_regs | temp_hard_reg_set);\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= new_conflict_regs;\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= new_conflict_regs;\n \t    }\n \n \t  /* Now we deal with paradoxical subreg cases where certain registers\n@@ -829,23 +826,6 @@ ira_build_conflicts (void)\n \t\t     }\n \t\t}\n \t    }\n-\n-\t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t    {\n-\t      int regno;\n-\n-\t      /* Allocnos bigger than the saved part of call saved\n-\t\t regs must conflict with them.  */\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif (!TEST_HARD_REG_BIT (call_used_or_fixed_regs, regno)\n-\t\t    && targetm.hard_regno_call_part_clobbered (0, regno,\n-\t\t\t\t\t\t\t       obj_mode))\n-\t\t  {\n-\t\t    SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n-\t\t    SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\t      regno);\n-\t\t  }\n-\t    }\n \t}\n     }\n   if (optimize && ira_conflicts_p"}, {"sha": "65511a3aa6391fbce50eab5adc30216a55ce28f0", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -2340,7 +2340,6 @@ ira_tune_allocno_costs (void)\n   ira_allocno_object_iterator oi;\n   ira_object_t obj;\n   bool skip_p;\n-  HARD_REG_SET *crossed_calls_clobber_regs;\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n@@ -2375,14 +2374,7 @@ ira_tune_allocno_costs (void)\n \t\tcontinue;\n \t      rclass = REGNO_REG_CLASS (regno);\n \t      cost = 0;\n-\t      crossed_calls_clobber_regs\n-\t\t= &(ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));\n-\t      if (ira_hard_reg_set_intersection_p (regno, mode,\n-\t\t\t\t\t\t   *crossed_calls_clobber_regs)\n-\t\t  && (ira_hard_reg_set_intersection_p (regno, mode,\n-\t\t\t\t\t\t       call_used_or_fixed_regs)\n-\t\t      || targetm.hard_regno_call_part_clobbered (0, regno,\n-\t\t\t\t\t\t\t\t mode)))\n+\t      if (ira_need_caller_save_p (a, regno))\n \t\tcost += (ALLOCNO_CALL_FREQ (a)\n \t\t\t * (ira_memory_move_cost[mode][rclass][0]\n \t\t\t    + ira_memory_move_cost[mode][rclass][1]));"}, {"sha": "6da37f86076f0180f0051fa19c1b2902f79e8928", "filename": "gcc/ira-int.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_IRA_INT_H\n \n #include \"recog.h\"\n+#include \"function-abi.h\"\n \n /* To provide consistency in naming, all IRA external variables,\n    functions, common typedefs start with prefix ira_.  */\n@@ -287,6 +288,9 @@ struct ira_allocno\n   /* Register class which should be used for allocation for given\n      allocno.  NO_REGS means that we should use memory.  */\n   ENUM_BITFIELD (reg_class) aclass : 16;\n+  /* A bitmask of the ABIs used by calls that occur while the allocno\n+     is live.  */\n+  unsigned int crossed_calls_abis : NUM_ABI_IDS;\n   /* During the reload, value TRUE means that we should not reassign a\n      hard register to the allocno got memory earlier.  It is set up\n      when we removed memory-memory move insn before each iteration of\n@@ -423,6 +427,7 @@ struct ira_allocno\n #define ALLOCNO_CALL_FREQ(A) ((A)->call_freq)\n #define ALLOCNO_CALLS_CROSSED_NUM(A) ((A)->calls_crossed_num)\n #define ALLOCNO_CHEAP_CALLS_CROSSED_NUM(A) ((A)->cheap_calls_crossed_num)\n+#define ALLOCNO_CROSSED_CALLS_ABIS(A) ((A)->crossed_calls_abis)\n #define ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS(A) \\\n   ((A)->crossed_calls_clobbered_regs)\n #define ALLOCNO_MEM_OPTIMIZED_DEST(A) ((A)->mem_optimized_dest)\n@@ -1510,4 +1515,28 @@ ira_allocate_and_set_or_copy_costs (int **vec, enum reg_class aclass,\n extern rtx ira_create_new_reg (rtx);\n extern int first_moveable_pseudo, last_moveable_pseudo;\n \n+/* Return the set of registers that would need a caller save if allocno A\n+   overlapped them.  */\n+\n+inline HARD_REG_SET\n+ira_need_caller_save_regs (ira_allocno_t a)\n+{\n+  return call_clobbers_in_region (ALLOCNO_CROSSED_CALLS_ABIS (a),\n+\t\t\t\t  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a),\n+\t\t\t\t  ALLOCNO_MODE (a));\n+}\n+\n+/* Return true if we would need to save allocno A around a call if we\n+   assigned hard register REGNO.  */\n+\n+inline bool\n+ira_need_caller_save_p (ira_allocno_t a, unsigned int regno)\n+{\n+  if (ALLOCNO_CALLS_CROSSED_NUM (a) == 0)\n+    return false;\n+  return call_clobbered_in_region_p (ALLOCNO_CROSSED_CALLS_ABIS (a),\n+\t\t\t\t     ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a),\n+\t\t\t\t     ALLOCNO_MODE (a), regno);\n+}\n+\n #endif /* GCC_IRA_INT_H */"}, {"sha": "cce73a1c3d4fe8dd16ecd9fd78186254ecb830d9", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -1255,11 +1255,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  ira_object_t obj = ira_object_id_map[i];\n \t\t  a = OBJECT_ALLOCNO (obj);\n \t\t  int num = ALLOCNO_NUM (a);\n-\t\t  HARD_REG_SET this_call_used_reg_set\n-\t\t    = insn_callee_abi (insn).full_reg_clobbers ();\n-\t\t  /* ??? This preserves traditional behavior; it might not be\n-\t\t     needed.  */\n-\t\t  this_call_used_reg_set |= fixed_reg_set;\n+\t\t  function_abi callee_abi = insn_callee_abi (insn);\n \n \t\t  /* Don't allocate allocnos that cross setjmps or any\n \t\t     call, if this function receives a nonlocal\n@@ -1275,9 +1271,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  if (can_throw_internal (insn))\n \t\t    {\n \t\t      OBJECT_CONFLICT_HARD_REGS (obj)\n-\t\t\t|= this_call_used_reg_set;\n+\t\t\t|= callee_abi.mode_clobbers (ALLOCNO_MODE (a));\n \t\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj)\n-\t\t\t|= this_call_used_reg_set;\n+\t\t\t|= callee_abi.mode_clobbers (ALLOCNO_MODE (a));\n \t\t    }\n \n \t\t  if (sparseset_bit_p (allocnos_processed, num))\n@@ -1294,8 +1290,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  /* Mark it as saved at the next call.  */\n \t\t  allocno_saved_at_call[num] = last_call_num + 1;\n \t\t  ALLOCNO_CALLS_CROSSED_NUM (a)++;\n+\t\t  ALLOCNO_CROSSED_CALLS_ABIS (a) |= 1 << callee_abi.id ();\n \t\t  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a)\n-\t\t    |= this_call_used_reg_set;\n+\t\t    |= callee_abi.full_and_partial_reg_clobbers ();\n \t\t  if (cheap_reg != NULL_RTX\n \t\t      && ALLOCNO_REGNO (a) == (int) REGNO (cheap_reg))\n \t\t    ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a)++;\n@@ -1359,10 +1356,11 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  }\n \n       /* Allocnos can't go in stack regs at the start of a basic block\n-\t that is reached by an abnormal edge. Likewise for call\n-\t clobbered regs, because caller-save, fixup_abnormal_edges and\n-\t possibly the table driven EH machinery are not quite ready to\n-\t handle such allocnos live across such edges.  */\n+\t that is reached by an abnormal edge. Likewise for registers\n+\t that are at least partly call clobbered, because caller-save,\n+\t fixup_abnormal_edges and possibly the table driven EH machinery\n+\t are not quite ready to handle such allocnos live across such\n+\t edges.  */\n       if (bb_has_abnormal_pred (bb))\n \t{\n #ifdef STACK_REGS\n@@ -1382,7 +1380,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  if (!cfun->has_nonlocal_label\n \t      && has_abnormal_call_or_eh_pred_edge_p (bb))\n \t    for (px = 0; px < FIRST_PSEUDO_REGISTER; px++)\n-\t      if (call_used_or_fixed_reg_p (px)\n+\t      if (eh_edge_abi.clobbers_at_least_part_of_reg_p (px)\n #ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n \t\t  /* We should create a conflict of PIC pseudo with\n \t\t     PIC hard reg as PIC hard reg can have a wrong"}, {"sha": "925ea266bb1637394b23a122ad6d9a6d6a645571", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c47622219d6386807b26890dcdc84f192499d33/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=6c47622219d6386807b26890dcdc84f192499d33", "patch": "@@ -2368,9 +2368,7 @@ setup_reg_renumber (void)\n \t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj)\n \t\t|= ~reg_class_contents[pclass];\n \t    }\n-\t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n-\t      && ira_hard_reg_set_intersection_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t\t  call_used_or_fixed_regs))\n+\t  if (ira_need_caller_save_p (a, hard_regno))\n \t    {\n \t      ira_assert (!optimize || flag_caller_saves\n \t\t\t  || (ALLOCNO_CALLS_CROSSED_NUM (a)\n@@ -5591,7 +5589,7 @@ do_reload (void)\n       for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (df_regs_ever_live_p (i)\n \t    && !fixed_regs[i]\n-\t    && call_used_or_fixed_reg_p (i))\n+\t    && !crtl->abi->clobbers_full_reg_p (i))\n \t  size += UNITS_PER_WORD;\n \n       if (constant_lower_bound (size) > STACK_CHECK_MAX_FRAME_SIZE)"}]}