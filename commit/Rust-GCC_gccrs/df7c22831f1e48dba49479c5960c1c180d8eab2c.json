{"sha": "df7c22831f1e48dba49479c5960c1c180d8eab2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3YzIyODMxZjFlNDhkYmE0OTQ3OWM1OTYwYzFjMTgwZDhlYWIyYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T15:12:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T15:12:58Z"}, "message": "Support vectorisation with mixed vector sizes\n\nAfter previous patches, it's now possible to make the vectoriser\nsupport multiple vector sizes in the same vector region, using\nrelated_vector_mode to pick the right vector mode for a given\nelement mode.  No port yet takes advantage of this, but I have\na follow-on patch for AArch64.\n\nThis patch also seemed like a good opportunity to add some more dump\nmessages: one to make it clear which vector size/mode was being used\nwhen analysis passed or failed, and another to say when we've decided\nto skip a redundant vector size/mode.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* machmode.h (opt_machine_mode::operator==): New function.\n\t(opt_machine_mode::operator!=): Likewise.\n\t* tree-vectorizer.h (vec_info::vector_mode): Update comment.\n\t(get_related_vectype_for_scalar_type): Delete.\n\t(get_vectype_for_scalar_type_and_size): Declare.\n\t* tree-vect-slp.c (vect_slp_bb_region): Print dump messages to say\n\twhether analysis passed or failed, and with what vector modes.\n\tUse related_vector_mode to check whether trying a particular\n\tvector mode would be redundant with the autodetected mode,\n\tand print a dump message if we decide to skip it.\n\t* tree-vect-loop.c (vect_analyze_loop): Likewise.\n\t(vect_create_epilog_for_reduction): Use\n\tget_related_vectype_for_scalar_type instead of\n\tget_vectype_for_scalar_type_and_size.\n\t* tree-vect-stmts.c (get_vectype_for_scalar_type_and_size): Replace\n\twith...\n\t(get_related_vectype_for_scalar_type): ...this new function.\n\tTake a starting/\"prevailing\" vector mode rather than a vector size.\n\tTake an optional nunits argument, with the same meaning as for\n\trelated_vector_mode.  Use related_vector_mode when not\n\tauto-detecting a mode, falling back to mode_for_vector if no\n\ttarget mode exists.\n\t(get_vectype_for_scalar_type): Update accordingly.\n\t(get_same_sized_vectype): Likewise.\n\t* tree-vectorizer.c (get_vec_alignment_for_array_type): Likewise.\n\nFrom-SVN: r278240", "tree": {"sha": "4778c923cb13cbea0d49eb5ba6c6365451d9995a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4778c923cb13cbea0d49eb5ba6c6365451d9995a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df7c22831f1e48dba49479c5960c1c180d8eab2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7c22831f1e48dba49479c5960c1c180d8eab2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7c22831f1e48dba49479c5960c1c180d8eab2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7c22831f1e48dba49479c5960c1c180d8eab2c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f52eb891b738337d5cf82c7c440a5eea8c7b0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f52eb891b738337d5cf82c7c440a5eea8c7b0c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f52eb891b738337d5cf82c7c440a5eea8c7b0c9"}], "stats": {"total": 185, "additions": 147, "deletions": 38}, "files": [{"sha": "680aa85121af39dd1742e40500c1255cef324e0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -1,3 +1,31 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* machmode.h (opt_machine_mode::operator==): New function.\n+\t(opt_machine_mode::operator!=): Likewise.\n+\t* tree-vectorizer.h (vec_info::vector_mode): Update comment.\n+\t(get_related_vectype_for_scalar_type): Delete.\n+\t(get_vectype_for_scalar_type_and_size): Declare.\n+\t* tree-vect-slp.c (vect_slp_bb_region): Print dump messages to say\n+\twhether analysis passed or failed, and with what vector modes.\n+\tUse related_vector_mode to check whether trying a particular\n+\tvector mode would be redundant with the autodetected mode,\n+\tand print a dump message if we decide to skip it.\n+\t* tree-vect-loop.c (vect_analyze_loop): Likewise.\n+\t(vect_create_epilog_for_reduction): Use\n+\tget_related_vectype_for_scalar_type instead of\n+\tget_vectype_for_scalar_type_and_size.\n+\t* tree-vect-stmts.c (get_vectype_for_scalar_type_and_size): Replace\n+\twith...\n+\t(get_related_vectype_for_scalar_type): ...this new function.\n+\tTake a starting/\"prevailing\" vector mode rather than a vector size.\n+\tTake an optional nunits argument, with the same meaning as for\n+\trelated_vector_mode.  Use related_vector_mode when not\n+\tauto-detecting a mode, falling back to mode_for_vector if no\n+\ttarget mode exists.\n+\t(get_vectype_for_scalar_type): Update accordingly.\n+\t(get_same_sized_vectype): Likewise.\n+\t* tree-vectorizer.c (get_vec_alignment_for_array_type): Likewise.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (vectorizable_call): Require the types"}, {"sha": "a507ed66c3f693d8988c4f556f64fcd22ee8f529", "filename": "gcc/machmode.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -258,6 +258,9 @@ class opt_mode\n   bool exists () const;\n   template<typename U> bool exists (U *) const;\n \n+  bool operator== (const T &m) const { return m_mode == m; }\n+  bool operator!= (const T &m) const { return m_mode != m; }\n+\n private:\n   machine_mode m_mode;\n };"}, {"sha": "e60c159d11ac4bd45346a6be84f138df261be9c9", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -2435,6 +2435,17 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n       res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n       if (mode_i == 0)\n \tautodetected_vector_mode = loop_vinfo->vector_mode;\n+      if (dump_enabled_p ())\n+\t{\n+\t  if (res)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Analysis succeeded with vector mode %s\\n\",\n+\t\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n+\t  else\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Analysis failed with vector mode %s\\n\",\n+\t\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n+\t}\n \n       loop->aux = NULL;\n       if (res)\n@@ -2501,9 +2512,22 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t}\n \n       if (mode_i < vector_modes.length ()\n-\t  && known_eq (GET_MODE_SIZE (vector_modes[mode_i]),\n-\t\t       GET_MODE_SIZE (autodetected_vector_mode)))\n-\tmode_i += 1;\n+\t  && VECTOR_MODE_P (autodetected_vector_mode)\n+\t  && (related_vector_mode (vector_modes[mode_i],\n+\t\t\t\t   GET_MODE_INNER (autodetected_vector_mode))\n+\t      == autodetected_vector_mode)\n+\t  && (related_vector_mode (autodetected_vector_mode,\n+\t\t\t\t   GET_MODE_INNER (vector_modes[mode_i]))\n+\t      == vector_modes[mode_i]))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Skipping vector mode %s, which would\"\n+\t\t\t     \" repeat the analysis for %s\\n\",\n+\t\t\t     GET_MODE_NAME (vector_modes[mode_i]),\n+\t\t\t     GET_MODE_NAME (autodetected_vector_mode));\n+\t  mode_i += 1;\n+\t}\n \n       if (mode_i == vector_modes.length ()\n \t  || autodetected_vector_mode == VOIDmode)\n@@ -4898,13 +4922,14 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t halves against each other.  */\n       enum machine_mode mode1 = mode;\n       tree stype = TREE_TYPE (vectype);\n-      unsigned sz = tree_to_uhwi (TYPE_SIZE_UNIT (vectype));\n-      unsigned sz1 = sz;\n+      unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n+      unsigned nunits1 = nunits;\n       if (!slp_reduc\n \t  && (mode1 = targetm.vectorize.split_reduction (mode)) != mode)\n-\tsz1 = GET_MODE_SIZE (mode1).to_constant ();\n+\tnunits1 = GET_MODE_NUNITS (mode1).to_constant ();\n \n-      tree vectype1 = get_vectype_for_scalar_type_and_size (stype, sz1);\n+      tree vectype1 = get_related_vectype_for_scalar_type (TYPE_MODE (vectype),\n+\t\t\t\t\t\t\t   stype, nunits1);\n       reduce_with_shift = have_whole_vector_shift (mode1);\n       if (!VECTOR_MODE_P (mode1))\n \treduce_with_shift = false;\n@@ -4918,11 +4943,13 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       /* First reduce the vector to the desired vector size we should\n \t do shift reduction on by combining upper and lower halves.  */\n       new_temp = new_phi_result;\n-      while (sz > sz1)\n+      while (nunits > nunits1)\n \t{\n \t  gcc_assert (!slp_reduc);\n-\t  sz /= 2;\n-\t  vectype1 = get_vectype_for_scalar_type_and_size (stype, sz);\n+\t  nunits /= 2;\n+\t  vectype1 = get_related_vectype_for_scalar_type (TYPE_MODE (vectype),\n+\t\t\t\t\t\t\t  stype, nunits);\n+\t  unsigned int bitsize = tree_to_uhwi (TYPE_SIZE (vectype1));\n \n \t  /* The target has to make sure we support lowpart/highpart\n \t     extraction, either via direct vector extract or through\n@@ -4947,15 +4974,14 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t\t  = gimple_build_assign (dst2, BIT_FIELD_REF,\n \t\t\t\t\t build3 (BIT_FIELD_REF, vectype1,\n \t\t\t\t\t\t new_temp, TYPE_SIZE (vectype1),\n-\t\t\t\t\t\t bitsize_int (sz * BITS_PER_UNIT)));\n+\t\t\t\t\t\t bitsize_int (bitsize)));\n \t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \t    }\n \t  else\n \t    {\n \t      /* Extract via punning to appropriately sized integer mode\n \t\t vector.  */\n-\t      tree eltype = build_nonstandard_integer_type (sz * BITS_PER_UNIT,\n-\t\t\t\t\t\t\t    1);\n+\t      tree eltype = build_nonstandard_integer_type (bitsize, 1);\n \t      tree etype = build_vector_type (eltype, 2);\n \t      gcc_assert (convert_optab_handler (vec_extract_optab,\n \t\t\t\t\t\t TYPE_MODE (etype),\n@@ -4984,7 +5010,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t\t  = gimple_build_assign (tem, BIT_FIELD_REF,\n \t\t\t\t\t build3 (BIT_FIELD_REF, eltype,\n \t\t\t\t\t\t new_temp, TYPE_SIZE (eltype),\n-\t\t\t\t\t\t bitsize_int (sz * BITS_PER_UNIT)));\n+\t\t\t\t\t\t bitsize_int (bitsize)));\n \t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \t      dst2 =  make_ssa_name (vectype1);\n \t      epilog_stmt = gimple_build_assign (dst2, VIEW_CONVERT_EXPR,"}, {"sha": "1e00db5a326c99c6bea1e653c05b6b07fe93996a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -3203,7 +3203,12 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \t  && dbg_cnt (vect_slp))\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB part\\n\");\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"***** Analysis succeeded with vector mode\"\n+\t\t\t       \" %s\\n\", GET_MODE_NAME (bb_vinfo->vector_mode));\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB part\\n\");\n+\t    }\n \n \t  bb_vinfo->shared->check_datarefs ();\n \t  vect_schedule_slp (bb_vinfo);\n@@ -3223,16 +3228,36 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \n \t  vectorized = true;\n \t}\n+      else\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Analysis failed with vector mode %s\\n\",\n+\t\t\t     GET_MODE_NAME (bb_vinfo->vector_mode));\n+\t}\n \n       if (mode_i == 0)\n \tautodetected_vector_mode = bb_vinfo->vector_mode;\n \n       delete bb_vinfo;\n \n       if (mode_i < vector_modes.length ()\n-\t  && known_eq (GET_MODE_SIZE (vector_modes[mode_i]),\n-\t\t       GET_MODE_SIZE (autodetected_vector_mode)))\n-\tmode_i += 1;\n+\t  && VECTOR_MODE_P (autodetected_vector_mode)\n+\t  && (related_vector_mode (vector_modes[mode_i],\n+\t\t\t\t   GET_MODE_INNER (autodetected_vector_mode))\n+\t      == autodetected_vector_mode)\n+\t  && (related_vector_mode (autodetected_vector_mode,\n+\t\t\t\t   GET_MODE_INNER (vector_modes[mode_i]))\n+\t      == vector_modes[mode_i]))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Skipping vector mode %s, which would\"\n+\t\t\t     \" repeat the analysis for %s\\n\",\n+\t\t\t     GET_MODE_NAME (vector_modes[mode_i]),\n+\t\t\t     GET_MODE_NAME (autodetected_vector_mode));\n+\t  mode_i += 1;\n+\t}\n \n       if (vectorized\n \t  || mode_i == vector_modes.length ()"}, {"sha": "36f832bb5224910fa75ecca658c60b60a5df397f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -11138,18 +11138,28 @@ vect_remove_stores (stmt_vec_info first_stmt_info)\n     }\n }\n \n-/* Function get_vectype_for_scalar_type_and_size.\n+/* If NUNITS is nonzero, return a vector type that contains NUNITS\n+   elements of type SCALAR_TYPE, or null if the target doesn't support\n+   such a type.\n \n-   Returns the vector type corresponding to SCALAR_TYPE  and SIZE as supported\n-   by the target.  */\n+   If NUNITS is zero, return a vector type that contains elements of\n+   type SCALAR_TYPE, choosing whichever vector size the target prefers.\n+\n+   If PREVAILING_MODE is VOIDmode, we have not yet chosen a vector mode\n+   for this vectorization region and want to \"autodetect\" the best choice.\n+   Otherwise, PREVAILING_MODE is a previously-chosen vector TYPE_MODE\n+   and we want the new type to be interoperable with it.   PREVAILING_MODE\n+   in this case can be a scalar integer mode or a vector mode; when it\n+   is a vector mode, the function acts like a tree-level version of\n+   related_vector_mode.  */\n \n tree\n-get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n+get_related_vectype_for_scalar_type (machine_mode prevailing_mode,\n+\t\t\t\t     tree scalar_type, poly_uint64 nunits)\n {\n   tree orig_scalar_type = scalar_type;\n   scalar_mode inner_mode;\n   machine_mode simd_mode;\n-  poly_uint64 nunits;\n   tree vectype;\n \n   if (!is_int_mode (TYPE_MODE (scalar_type), &inner_mode)\n@@ -11189,10 +11199,11 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n   if (scalar_type == NULL_TREE)\n     return NULL_TREE;\n \n-  /* If no size was supplied use the mode the target prefers.   Otherwise\n-     lookup a vector mode of the specified size.  */\n-  if (known_eq (size, 0U))\n+  /* If no prevailing mode was supplied, use the mode the target prefers.\n+     Otherwise lookup a vector mode based on the prevailing mode.  */\n+  if (prevailing_mode == VOIDmode)\n     {\n+      gcc_assert (known_eq (nunits, 0U));\n       simd_mode = targetm.vectorize.preferred_simd_mode (inner_mode);\n       if (SCALAR_INT_MODE_P (simd_mode))\n \t{\n@@ -11208,9 +11219,19 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n \t    return NULL_TREE;\n \t}\n     }\n-  else if (!multiple_p (size, nbytes, &nunits)\n-\t   || !mode_for_vector (inner_mode, nunits).exists (&simd_mode))\n-    return NULL_TREE;\n+  else if (SCALAR_INT_MODE_P (prevailing_mode)\n+\t   || !related_vector_mode (prevailing_mode,\n+\t\t\t\t    inner_mode, nunits).exists (&simd_mode))\n+    {\n+      /* Fall back to using mode_for_vector, mostly in the hope of being\n+\t able to use an integer mode.  */\n+      if (known_eq (nunits, 0U)\n+\t  && !multiple_p (GET_MODE_SIZE (prevailing_mode), nbytes, &nunits))\n+\treturn NULL_TREE;\n+\n+      if (!mode_for_vector (inner_mode, nunits).exists (&simd_mode))\n+\treturn NULL_TREE;\n+    }\n \n   vectype = build_vector_type_for_mode (scalar_type, simd_mode);\n \n@@ -11238,9 +11259,8 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n tree\n get_vectype_for_scalar_type (vec_info *vinfo, tree scalar_type)\n {\n-  tree vectype;\n-  poly_uint64 vector_size = GET_MODE_SIZE (vinfo->vector_mode);\n-  vectype = get_vectype_for_scalar_type_and_size (scalar_type, vector_size);\n+  tree vectype = get_related_vectype_for_scalar_type (vinfo->vector_mode,\n+\t\t\t\t\t\t      scalar_type);\n   if (vectype && vinfo->vector_mode == VOIDmode)\n     vinfo->vector_mode = TYPE_MODE (vectype);\n   return vectype;\n@@ -11273,8 +11293,13 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n   if (VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type))\n     return truth_type_for (vector_type);\n \n-  return get_vectype_for_scalar_type_and_size\n-\t   (scalar_type, GET_MODE_SIZE (TYPE_MODE (vector_type)));\n+  poly_uint64 nunits;\n+  if (!multiple_p (GET_MODE_SIZE (TYPE_MODE (vector_type)),\n+\t\t   GET_MODE_SIZE (TYPE_MODE (scalar_type)), &nunits))\n+    return NULL_TREE;\n+\n+  return get_related_vectype_for_scalar_type (TYPE_MODE (vector_type),\n+\t\t\t\t\t      scalar_type, nunits);\n }\n \n /* Function vect_is_simple_use."}, {"sha": "7be81a0b27ff874d939608170fcd342708d25816", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -1359,7 +1359,7 @@ get_vec_alignment_for_array_type (tree type)\n   poly_uint64 array_size, vector_size;\n \n   tree scalar_type = strip_array_types (type);\n-  tree vectype = get_vectype_for_scalar_type_and_size (scalar_type, 0);\n+  tree vectype = get_related_vectype_for_scalar_type (VOIDmode, scalar_type);\n   if (!vectype\n       || !poly_int_tree_p (TYPE_SIZE (type), &array_size)\n       || !poly_int_tree_p (TYPE_SIZE (vectype), &vector_size)"}, {"sha": "fadc4d89d1644d081bcb0bfedcbb84b61b4f8248", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7c22831f1e48dba49479c5960c1c180d8eab2c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=df7c22831f1e48dba49479c5960c1c180d8eab2c", "patch": "@@ -335,8 +335,9 @@ class vec_info {\n   /* Cost data used by the target cost model.  */\n   void *target_cost_data;\n \n-  /* If we've chosen a vector size for this vectorization region,\n-     this is one mode that has such a size, otherwise it is VOIDmode.  */\n+  /* The argument we should pass to related_vector_mode when looking up\n+     the vector mode for a scalar mode, or VOIDmode if we haven't yet\n+     made any decisions about which vector modes to use.  */\n   machine_mode vector_mode;\n \n private:\n@@ -1624,8 +1625,9 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n extern void vect_update_inits_of_drs (loop_vec_info, tree, tree_code);\n \n /* In tree-vect-stmts.c.  */\n+extern tree get_related_vectype_for_scalar_type (machine_mode, tree,\n+\t\t\t\t\t\t poly_uint64 = 0);\n extern tree get_vectype_for_scalar_type (vec_info *, tree);\n-extern tree get_vectype_for_scalar_type_and_size (tree, poly_uint64);\n extern tree get_mask_type_for_scalar_type (vec_info *, tree);\n extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_get_loop_mask_type (loop_vec_info);"}]}