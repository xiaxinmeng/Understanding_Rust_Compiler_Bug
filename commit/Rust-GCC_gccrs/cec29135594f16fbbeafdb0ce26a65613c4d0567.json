{"sha": "cec29135594f16fbbeafdb0ce26a65613c4d0567", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VjMjkxMzU1OTRmMTZmYmJlYWZkYjBjZTI2YTY1NjEzYzRkMDU2Nw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2009-04-17T09:36:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:36:05Z"}, "message": "sem_ch3.adb (Access_Subprogram_Definition): Additional checks on illegal uses of incomplete types in formal parts and...\n\n2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Access_Subprogram_Definition): Additional checks on\n\tillegal uses of incomplete types in formal parts and return types.\n\n\t* sem_ch6.adb (Process_Formals): Taft-amendment types are legal in\n\taccess to subprograms.\n\n\t* sem_ch7.adb (Uninstall_Declarations): diagnose attempts to use\n\tTaft-amendment types as the return type of an access_to_function type.\n\n\t* freeze.adb (Freeze_Entity): Remove tests on formals of an incomplete\n\ttype for access_to_subprograms. The check is performed on package exit.\n\nFrom-SVN: r146229", "tree": {"sha": "b1f17f1be16920dc495a705179f177a3e4872b86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1f17f1be16920dc495a705179f177a3e4872b86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cec29135594f16fbbeafdb0ce26a65613c4d0567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec29135594f16fbbeafdb0ce26a65613c4d0567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cec29135594f16fbbeafdb0ce26a65613c4d0567", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec29135594f16fbbeafdb0ce26a65613c4d0567/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "618fb570b9d2a668d6d217ad486379ad0e1370b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618fb570b9d2a668d6d217ad486379ad0e1370b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618fb570b9d2a668d6d217ad486379ad0e1370b6"}], "stats": {"total": 408, "additions": 202, "deletions": 206}, "files": [{"sha": "31e32af0455e74163f51462a4e831f0b3829247a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=cec29135594f16fbbeafdb0ce26a65613c4d0567", "patch": "@@ -3497,50 +3497,11 @@ package body Freeze is\n \n             Freeze_Subprogram (E);\n \n-            --  Ada 2005 (AI-326): Check wrong use of tag incomplete type\n-\n-            --    type T;  --   tagged or untagged, may be from limited view\n-            --    type Acc is access function (X : T) return T; -- ERROR\n-\n-            if Ekind (Etype (E)) = E_Incomplete_Type\n-              and then No (Full_View (Etype (E)))\n-              and then not Is_Value_Type (Etype (E))\n-            then\n-               Error_Msg_NE\n-                 (\"invalid use of incomplete type&\", E, Etype (E));\n-            end if;\n-\n          --  For access to a protected subprogram, freeze the equivalent type\n          --  (however this is not set if we are not generating code or if this\n          --  is an anonymous type used just for resolution).\n \n          elsif Is_Access_Protected_Subprogram_Type (E) then\n-\n-            --  AI-326: Check wrong use of tagged incomplete types\n-\n-            --    type T is tagged;\n-            --    type As3D is access protected\n-            --      function (X : Float) return T; -- ERROR\n-\n-            declare\n-               Etyp : Entity_Id;\n-\n-            begin\n-               Etyp := Etype (Directly_Designated_Type (E));\n-\n-               if Is_Class_Wide_Type (Etyp) then\n-                  Etyp := Etype (Etyp);\n-               end if;\n-\n-               if Ekind (Etyp) = E_Incomplete_Type\n-                 and then No (Full_View (Etyp))\n-                 and then not Is_Value_Type (Etype (E))\n-               then\n-                  Error_Msg_NE\n-                    (\"invalid use of incomplete type&\", E, Etyp);\n-               end if;\n-            end;\n-\n             if Present (Equivalent_Type (E)) then\n                Freeze_And_Append (Equivalent_Type (E), Loc, Result);\n             end if;"}, {"sha": "8b9071a6bde16a2bc5997ebeed24fd9b60094d6c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=cec29135594f16fbbeafdb0ce26a65613c4d0567", "patch": "@@ -1135,7 +1135,27 @@ package body Sem_Ch3 is\n                       (T           => Typ,\n                        Related_Nod => T_Def,\n                        Scope_Id    => Current_Scope));\n+\n                else\n+                  if From_With_Type (Typ) then\n+                     Error_Msg_NE\n+                      (\"illegal use of incomplete type&\",\n+                         Result_Definition (T_Def), Typ);\n+\n+                  elsif Ekind (Current_Scope) = E_Package\n+                    and then In_Private_Part (Current_Scope)\n+                  then\n+                     if Ekind (Typ) = E_Incomplete_Type then\n+                        Append_Elmt (Desig_Type, Private_Dependents (Typ));\n+\n+                     elsif Is_Class_Wide_Type (Typ)\n+                       and then Ekind (Etype (Typ)) = E_Incomplete_Type\n+                     then\n+                        Append_Elmt\n+                          (Desig_Type, Private_Dependents (Etype (Typ)));\n+                     end if;\n+                  end if;\n+\n                   Set_Etype (Desig_Type, Typ);\n                end if;\n             end;"}, {"sha": "080b3e06013f6fc62b78ce54c5b37fe176f32a09", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=cec29135594f16fbbeafdb0ce26a65613c4d0567", "patch": "@@ -7716,17 +7716,23 @@ package body Sem_Ch6 is\n                --  primitive operations, as long as their completion is\n                --  in the same declarative part. If in the private part\n                --  this means that the type cannot be a Taft-amendment type.\n-               --  Check is done on package exit.\n+               --  Check is done on package exit. For access to subprograms,\n+               --  the use is legal for Taft-amendment types.\n \n                if Is_Tagged_Type (Formal_Type) then\n                   if Ekind (Scope (Current_Scope)) = E_Package\n                     and then In_Private_Part (Scope (Current_Scope))\n                     and then not From_With_Type (Formal_Type)\n                     and then not Is_Class_Wide_Type (Formal_Type)\n                   then\n-                     Append_Elmt\n-                       (Current_Scope,\n-                          Private_Dependents (Base_Type (Formal_Type)));\n+                     if not Nkind_In\n+                       (Parent (T), N_Access_Function_Definition,\n+                                    N_Access_Procedure_Definition)\n+                     then\n+                        Append_Elmt\n+                          (Current_Scope,\n+                             Private_Dependents (Base_Type (Formal_Type)));\n+                     end if;\n                   end if;\n \n                --  Special handling of Value_Type for CIL case"}, {"sha": "ba005a3c3b3b1c4aa210805c328079dd8c3e0aeb", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 172, "deletions": 163, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec29135594f16fbbeafdb0ce26a65613c4d0567/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=cec29135594f16fbbeafdb0ce26a65613c4d0567", "patch": "@@ -25,8 +25,8 @@\n \n --  This package contains the routines to process package specifications and\n --  bodies. The most important semantic aspects of package processing are the\n---  handling of private and full declarations, and the construction of\n---  dispatch tables for tagged types.\n+--  handling of private and full declarations, and the construction of dispatch\n+--  tables for tagged types.\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n@@ -102,9 +102,9 @@ package body Sem_Ch7 is\n    --  before other body declarations.\n \n    procedure Install_Package_Entity (Id : Entity_Id);\n-   --  Supporting procedure for Install_{Visible,Private}_Declarations.\n-   --  Places one entity on its visibility chain, and recurses on the visible\n-   --  part if the entity is an inner package.\n+   --  Supporting procedure for Install_{Visible,Private}_Declarations. Places\n+   --  one entity on its visibility chain, and recurses on the visible part if\n+   --  the entity is an inner package.\n \n    function Is_Private_Base_Type (E : Entity_Id) return Boolean;\n    --  True for a private type that is not a subtype\n@@ -144,10 +144,10 @@ package body Sem_Ch7 is\n       Pack_Decl        : Node_Id;\n \n       procedure Install_Composite_Operations (P : Entity_Id);\n-      --  Composite types declared in the current scope may depend on\n-      --  types that were private at the point of declaration, and whose\n-      --  full view is now in  scope. Indicate that the corresponding\n-      --  operations on the composite type are available.\n+      --  Composite types declared in the current scope may depend on types\n+      --  that were private at the point of declaration, and whose full view\n+      --  is now in scope. Indicate that the corresponding operations on the\n+      --  composite type are available.\n \n       ----------------------------------\n       -- Install_Composite_Operations --\n@@ -175,12 +175,12 @@ package body Sem_Ch7 is\n    --  Start of processing for Analyze_Package_Body\n \n    begin\n-      --  Find corresponding package specification, and establish the\n-      --  current scope. The visible defining entity for the package is the\n-      --  defining occurrence in the spec. On exit from the package body, all\n-      --  body declarations are attached to the defining entity for the body,\n-      --  but the later is never used for name resolution. In this fashion\n-      --  there is only one visible entity that denotes the package.\n+      --  Find corresponding package specification, and establish the current\n+      --  scope. The visible defining entity for the package is the defining\n+      --  occurrence in the spec. On exit from the package body, all body\n+      --  declarations are attached to the defining entity for the body, but\n+      --  the later is never used for name resolution. In this fashion there\n+      --  is only one visible entity that denotes the package.\n \n       if Debug_Flag_C then\n          Write_Str (\"====  Compiling package body \");\n@@ -190,15 +190,15 @@ package body Sem_Ch7 is\n          Write_Eol;\n       end if;\n \n-      --  Set Body_Id. Note that this Will be reset to point to the\n-      --  generic copy later on in the generic case.\n+      --  Set Body_Id. Note that this Will be reset to point to the generic\n+      --  copy later on in the generic case.\n \n       Body_Id := Defining_Entity (N);\n \n       if Present (Corresponding_Spec (N)) then\n \n-         --  Body is body of package instantiation. Corresponding spec\n-         --  has already been set.\n+         --  Body is body of package instantiation. Corresponding spec has\n+         --  already been set.\n \n          Spec_Id := Corresponding_Spec (N);\n          Pack_Decl := Unit_Declaration_Node (Spec_Id);\n@@ -257,8 +257,8 @@ package body Sem_Ch7 is\n \n       if Ekind (Spec_Id) = E_Generic_Package then\n \n-         --  Disable expansion and perform semantic analysis on copy.\n-         --  The unannotated body will be used in all instantiations.\n+         --  Disable expansion and perform semantic analysis on copy. The\n+         --  unannotated body will be used in all instantiations.\n \n          Body_Id := Defining_Entity (N);\n          Set_Ekind (Body_Id, E_Package_Body);\n@@ -270,23 +270,23 @@ package body Sem_Ch7 is\n          New_N := Copy_Generic_Node (N, Empty, Instantiating => False);\n          Rewrite (N, New_N);\n \n-         --  Update Body_Id to point to the copied node for the remainder\n-         --  of the processing.\n+         --  Update Body_Id to point to the copied node for the remainder of\n+         --  the processing.\n \n          Body_Id := Defining_Entity (N);\n          Start_Generic;\n       end if;\n \n       --  The Body_Id is that of the copied node in the generic case, the\n-      --  current node otherwise. Note that N was rewritten above, so we\n-      --  must be sure to get the latest Body_Id value.\n+      --  current node otherwise. Note that N was rewritten above, so we must\n+      --  be sure to get the latest Body_Id value.\n \n       Set_Ekind (Body_Id, E_Package_Body);\n       Set_Body_Entity (Spec_Id, Body_Id);\n       Set_Spec_Entity (Body_Id, Spec_Id);\n \n-      --  Defining name for the package body is not a visible entity: Only\n-      --  the defining name for the declaration is visible.\n+      --  Defining name for the package body is not a visible entity: Only the\n+      --  defining name for the declaration is visible.\n \n       Set_Etype (Body_Id, Standard_Void_Type);\n       Set_Scope (Body_Id, Scope (Spec_Id));\n@@ -340,7 +340,7 @@ package body Sem_Ch7 is\n          Inspect_Deferred_Constant_Completion (Declarations (N));\n       end if;\n \n-      --  Analyze_Declarations has caused freezing of all types; now generate\n+      --  Analyze_Declarations has caused freezing of all types. Now generate\n       --  bodies for RACW primitives and stream attributes, if any.\n \n       if Ekind (Spec_Id) = E_Package and then Has_RACW (Spec_Id) then\n@@ -416,9 +416,8 @@ package body Sem_Ch7 is\n             Set_Is_Potentially_Use_Visible (E, False);\n             Set_Is_Hidden (E);\n \n-            --  Child units may appear on the entity list (for example if\n-            --  they appear in the context of a subunit) but they are not\n-            --  body entities.\n+            --  Child units may appear on the entity list (e.g. if they appear\n+            --  in the context of a subunit) but they are not body entities.\n \n             if not Is_Child_Unit (E) then\n                Set_Is_Package_Body_Entity (E);\n@@ -444,9 +443,9 @@ package body Sem_Ch7 is\n       --  following loop runs backwards from the end of the entities of the\n       --  package body making these entities invisible until we reach a\n       --  referencer, i.e. a declaration that could reference a previous\n-      --  declaration, a generic body or an inlined body, or a stub (which\n-      --  may contain either of these). This is of course an approximation,\n-      --  but it is conservative and definitely correct.\n+      --  declaration, a generic body or an inlined body, or a stub (which may\n+      --  contain either of these). This is of course an approximation, but it\n+      --  is conservative and definitely correct.\n \n       --  We only do this at the outer (library) level non-generic packages.\n       --  The reason is simply to cut down on the number of external symbols\n@@ -464,16 +463,15 @@ package body Sem_Ch7 is\n                Outer : Boolean)\n                return  Boolean;\n             --  Traverse the given list of declarations in reverse order.\n-            --  Return True as soon as a referencer is reached. Return\n-            --  False if none is found. The Outer parameter is True for\n-            --  the outer level call, and False for inner level calls for\n-            --  nested packages. If Outer is True, then any entities up\n-            --  to the point of hitting a referencer get their Is_Public\n-            --  flag cleared, so that the entities will be treated as\n-            --  static entities in the C sense, and need not have fully\n-            --  qualified names. For inner levels, we need all names to\n-            --  be fully qualified to deal with the same name appearing\n-            --  in parallel packages (right now this is tied to their\n+            --  Return True as soon as a referencer is reached. Return False if\n+            --  none is found. The Outer parameter is True for the outer level\n+            --  call, and False for inner level calls for nested packages. If\n+            --  Outer is True, then any entities up to the point of hitting a\n+            --  referencer get their Is_Public flag cleared, so that the\n+            --  entities will be treated as static entities in the C sense, and\n+            --  need not have fully qualified names. For inner levels, we need\n+            --  all names to be fully qualified to deal with the same name\n+            --  appearing in parallel packages (right now this is tied to their\n             --  being external).\n \n             --------------------\n@@ -512,10 +510,10 @@ package body Sem_Ch7 is\n \n                         --  Note that we test Has_Pragma_Inline here rather\n                         --  than Is_Inlined. We are compiling this for a\n-                        --  client, and it is the client who will decide\n-                        --  if actual inlining should occur, so we need to\n-                        --  assume that the procedure could be inlined for\n-                        --  the purpose of accessing global entities.\n+                        --  client, and it is the client who will decide if\n+                        --  actual inlining should occur, so we need to assume\n+                        --  that the procedure could be inlined for the purpose\n+                        --  of accessing global entities.\n \n                         if Has_Pragma_Inline (E) then\n                            return True;\n@@ -542,20 +540,19 @@ package body Sem_Ch7 is\n                   then\n                      E := Corresponding_Spec (D);\n \n-                     --  Generic package body is a referencer. It would\n-                     --  seem that we only have to consider generics that\n-                     --  can be exported, i.e. where the corresponding spec\n-                     --  is the spec of the current package, but because of\n-                     --  nested instantiations, a fully private generic\n-                     --  body may export other private body entities.\n+                     --  Generic package body is a referencer. It would seem\n+                     --  that we only have to consider generics that can be\n+                     --  exported, i.e. where the corresponding spec is the\n+                     --  spec of the current package, but because of nested\n+                     --  instantiations, a fully private generic body may\n+                     --  export other private body entities.\n \n                      if Is_Generic_Unit (E) then\n                         return True;\n \n-                     --  For non-generic package body, recurse into body\n-                     --  unless this is an instance, we ignore instances\n-                     --  since they cannot have references that affect\n-                     --  outer entities.\n+                     --  For non-generic package body, recurse into body unless\n+                     --  this is an instance, we ignore instances since they\n+                     --  cannot have references that affect outer entities.\n \n                      elsif not Is_Generic_Instance (E) then\n                         if Has_Referencer\n@@ -583,10 +580,10 @@ package body Sem_Ch7 is\n                         end if;\n                      end if;\n \n-                  --  Objects and exceptions need not be public if we have\n-                  --  not encountered a referencer so far. We only reset\n-                  --  the flag for outer level entities that are not\n-                  --  imported/exported, and which have no interface name.\n+                  --  Objects and exceptions need not be public if we have not\n+                  --  encountered a referencer so far. We only reset the flag\n+                  --  for outer level entities that are not imported/exported,\n+                  --  and which have no interface name.\n \n                   elsif Nkind_In (K, N_Object_Declaration,\n                                      N_Exception_Declaration,\n@@ -623,10 +620,10 @@ package body Sem_Ch7 is\n       end if;\n \n       --  If expander is not active, then here is where we turn off the\n-      --  In_Package_Body flag, otherwise it is turned off at the end of\n-      --  the corresponding expansion routine. If this is an instance body,\n-      --  we need to qualify names of local entities, because the body may\n-      --  have been compiled as a preliminary to another instantiation.\n+      --  In_Package_Body flag, otherwise it is turned off at the end of the\n+      --  corresponding expansion routine. If this is an instance body, we need\n+      --  to qualify names of local entities, because the body may have been\n+      --  compiled as a preliminary to another instantiation.\n \n       if not Expander_Active then\n          Set_In_Package_Body (Spec_Id, False);\n@@ -692,9 +689,9 @@ package body Sem_Ch7 is\n \n       Body_Required := Unit_Requires_Body (Id);\n \n-      --  When this spec does not require an explicit body, we know that\n-      --  there are no entities requiring completion in the language sense;\n-      --  we call Check_Completion here only to ensure that any nested package\n+      --  When this spec does not require an explicit body, we know that there\n+      --  are no entities requiring completion in the language sense; we call\n+      --  Check_Completion here only to ensure that any nested package\n       --  declaration that requires an implicit body gets one. (In the case\n       --  where a body is required, Check_Completion is called at the end of\n       --  the body's declarative part.)\n@@ -734,8 +731,8 @@ package body Sem_Ch7 is\n    -- Analyze_Package_Specification --\n    -----------------------------------\n \n-   --  Note that this code is shared for the analysis of generic package\n-   --  specs (see Sem_Ch12.Analyze_Generic_Package_Declaration for details).\n+   --  Note that this code is shared for the analysis of generic package specs\n+   --  (see Sem_Ch12.Analyze_Generic_Package_Declaration for details).\n \n    procedure Analyze_Package_Specification (N : Node_Id) is\n       Id           : constant Entity_Id  := Defining_Entity (N);\n@@ -760,10 +757,10 @@ package body Sem_Ch7 is\n       --  visibility analysis for preconditions and postconditions in specs.\n \n       procedure Clear_Constants (Id : Entity_Id; FE : Entity_Id);\n-      --  Clears constant indications (Never_Set_In_Source, Constant_Value,\n-      --  and Is_True_Constant) on all variables that are entities of Id,\n-      --  and on the chain whose first element is FE. A recursive call is\n-      --  made for all packages and generic packages.\n+      --  Clears constant indications (Never_Set_In_Source, Constant_Value, and\n+      --  Is_True_Constant) on all variables that are entities of Id, and on\n+      --  the chain whose first element is FE. A recursive call is made for all\n+      --  packages and generic packages.\n \n       procedure Generate_Parent_References;\n       --  For a child unit, generate references to parent units, for\n@@ -822,18 +819,17 @@ package body Sem_Ch7 is\n          E : Entity_Id;\n \n       begin\n-         --  Ignore package renamings, not interesting and they can\n-         --  cause self referential loops in the code below.\n+         --  Ignore package renamings, not interesting and they can cause self\n+         --  referential loops in the code below.\n \n          if Nkind (Parent (Id)) = N_Package_Renaming_Declaration then\n             return;\n          end if;\n \n-         --  Note: in the loop below, the check for Next_Entity pointing\n-         --  back to the package entity may seem odd, but it is needed,\n-         --  because a package can contain a renaming declaration to itself,\n-         --  and such renamings are generated automatically within package\n-         --  instances.\n+         --  Note: in the loop below, the check for Next_Entity pointing back\n+         --  to the package entity may seem odd, but it is needed, because a\n+         --  package can contain a renaming declaration to itself, and such\n+         --  renamings are generated automatically within package instances.\n \n          E := FE;\n          while Present (E) and then E /= Id loop\n@@ -873,8 +869,8 @@ package body Sem_Ch7 is\n          elsif not Nkind_In (Unit (Cunit (Main_Unit)), N_Subprogram_Body,\n                                                        N_Subunit)\n          then\n-            --  If current unit is an ancestor of main unit, generate\n-            --  a reference to its own parent.\n+            --  If current unit is an ancestor of main unit, generate a\n+            --  reference to its own parent.\n \n             declare\n                U         : Node_Id;\n@@ -1065,11 +1061,11 @@ package body Sem_Ch7 is\n          Validate_RCI_Declarations (Id);\n       end if;\n \n-      --  Save global references in the visible declarations, before\n-      --  installing private declarations of parent unit if there is one,\n-      --  because the privacy status of types defined in the parent will\n-      --  change. This is only relevant for generic child units, but is\n-      --  done in all cases for uniformity.\n+      --  Save global references in the visible declarations, before installing\n+      --  private declarations of parent unit if there is one, because the\n+      --  privacy status of types defined in the parent will change. This is\n+      --  only relevant for generic child units, but is done in all cases for\n+      --  uniformity.\n \n       if Ekind (Id) = E_Generic_Package\n         and then Nkind (Orig_Decl) = N_Generic_Package_Declaration\n@@ -1360,8 +1356,8 @@ package body Sem_Ch7 is\n    procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id) is\n \n       function Is_Primitive_Of (T : Entity_Id; S : Entity_Id) return Boolean;\n-      --  Check whether an inherited subprogram is an operation of an\n-      --  untagged derived type.\n+      --  Check whether an inherited subprogram is an operation of an untagged\n+      --  derived type.\n \n       ---------------------\n       -- Is_Primitive_Of --\n@@ -1371,9 +1367,9 @@ package body Sem_Ch7 is\n          Formal : Entity_Id;\n \n       begin\n-         --  If the full view is a scalar type, the type is the anonymous\n-         --  base type, but the operation mentions the first subtype, so\n-         --  check the signature against the base type.\n+         --  If the full view is a scalar type, the type is the anonymous base\n+         --  type, but the operation mentions the first subtype, so check the\n+         --  signature against the base type.\n \n          if Base_Type (Etype (S)) = Base_Type (T) then\n             return True;\n@@ -1409,10 +1405,10 @@ package body Sem_Ch7 is\n       E := First_Entity (Id);\n       while Present (E) loop\n \n-         --  If the entity is a nonprivate type extension whose parent\n-         --  type is declared in an open scope, then the type may have\n-         --  inherited operations that now need to be made visible.\n-         --  Ditto if the entity is a formal derived type in a child unit.\n+         --  If the entity is a nonprivate type extension whose parent type\n+         --  is declared in an open scope, then the type may have inherited\n+         --  operations that now need to be made visible. Ditto if the entity\n+         --  is a formal derived type in a child unit.\n \n          if ((Is_Derived_Type (E) and then not Is_Private_Type (E))\n                or else\n@@ -1498,16 +1494,15 @@ package body Sem_Ch7 is\n                        (Is_Dispatching_Operation (New_Op)\n                          and then Node (Last_Elmt (Op_List)) = New_Op);\n \n-                     --  Substitute the new operation for the old one\n-                     --  in the type's primitive operations list. Since\n-                     --  the new operation was also just added to the end\n-                     --  of list, the last element must be removed.\n+                     --  Substitute the new operation for the old one in the\n+                     --  type's primitive operations list. Since the new\n+                     --  operation was also just added to the end of list,\n+                     --  the last element must be removed.\n \n-                     --  (Question: is there a simpler way of declaring\n-                     --  the operation, say by just replacing the name\n-                     --  of the earlier operation, reentering it in the\n-                     --  in the symbol table (how?), and marking it as\n-                     --  private???)\n+                     --  (Question: is there a simpler way of declaring the\n+                     --  operation, say by just replacing the name of the\n+                     --  earlier operation, reentering it in the in the symbol\n+                     --  table (how?), and marking it as private???)\n \n                      Replace_Elmt (Op_Elmt, New_Op);\n                      Remove_Last_Elmt (Op_List);\n@@ -1524,8 +1519,8 @@ package body Sem_Ch7 is\n                end if;\n \n             else\n-               --   Non-tagged type, scan forward to locate\n-               --   inherited hidden operations.\n+               --   Non-tagged type, scan forward to locate inherited hidden\n+               --   operations.\n \n                Prim_Op := Next_Entity (E);\n                while Present (Prim_Op) loop\n@@ -1581,8 +1576,8 @@ package body Sem_Ch7 is\n       Next2 := Next_Entity (Full_Id);\n       H2    := Homonym (Full_Id);\n \n-      --  Reset full declaration pointer to reflect the switched entities\n-      --  and readjust the next entity chains.\n+      --  Reset full declaration pointer to reflect the switched entities and\n+      --  readjust the next entity chains.\n \n       Exchange_Entities (Id, Full_Id);\n \n@@ -1625,13 +1620,13 @@ package body Sem_Ch7 is\n       Full      : Entity_Id;\n \n    begin\n-      --  First exchange declarations for private types, so that the\n-      --  full declaration is visible. For each private type, we check\n-      --  its Private_Dependents list and also exchange any subtypes of\n-      --  or derived types from it. Finally, if this is a Taft amendment\n-      --  type, the incomplete declaration is irrelevant, and we want to\n-      --  link the eventual full declaration with the original private\n-      --  one so we also skip the exchange.\n+      --  First exchange declarations for private types, so that the full\n+      --  declaration is visible. For each private type, we check its\n+      --  Private_Dependents list and also exchange any subtypes of or derived\n+      --  types from it. Finally, if this is a Taft amendment type, the\n+      --  incomplete declaration is irrelevant, and we want to link the\n+      --  eventual full declaration with the original private one so we also\n+      --  skip the exchange.\n \n       Id := First_Entity (P);\n       while Present (Id) and then Id /= First_Private_Entity (P) loop\n@@ -1659,12 +1654,12 @@ package body Sem_Ch7 is\n                --  can only happen in a package nested within a child package,\n                --  when the parent type is defined in the parent unit. At this\n                --  point the current type is not private either, and we have to\n-               --  install the underlying full view, which is now visible.\n-               --  Save the current full view as well, so that all views can\n-               --  be restored on exit. It may seem that after compiling the\n-               --  child body there are not environments to restore, but the\n-               --  back-end expects those links to be valid, and freeze nodes\n-               --  depend on them.\n+               --  install the underlying full view, which is now visible. Save\n+               --  the current full view as well, so that all views can be\n+               --  restored on exit. It may seem that after compiling the child\n+               --  body there are not environments to restore, but the back-end\n+               --  expects those links to be valid, and freeze nodes depend on\n+               --  them.\n \n                if No (Full_View (Full))\n                  and then Present (Underlying_Full_View (Full))\n@@ -1686,8 +1681,8 @@ package body Sem_Ch7 is\n                Priv := Node (Priv_Elmt);\n \n                --  Before the exchange, verify that the presence of the\n-               --  Full_View field. It will be empty if the entity\n-               --  has already been installed due to a previous call.\n+               --  Full_View field. It will be empty if the entity has already\n+               --  been installed due to a previous call.\n \n                if Present (Full_View (Priv))\n                  and then Is_Visible_Dependent (Priv)\n@@ -1772,8 +1767,7 @@ package body Sem_Ch7 is\n       S : constant Entity_Id := Scope (Dep);\n \n    begin\n-      --  Renamings created for actual types have the visibility of the\n-      --  actual.\n+      --  Renamings created for actual types have the visibility of the actual\n \n       if Ekind (S) = E_Package\n         and then Is_Generic_Instance (S)\n@@ -1785,9 +1779,9 @@ package body Sem_Ch7 is\n       elsif not (Is_Derived_Type (Dep))\n         and then Is_Derived_Type (Full_View (Dep))\n       then\n-         --  When instantiating a package body, the scope stack is empty,\n-         --  so check instead whether the dependent type is defined in\n-         --  the same scope as the instance itself.\n+         --  When instantiating a package body, the scope stack is empty, so\n+         --  check instead whether the dependent type is defined in the same\n+         --  scope as the instance itself.\n \n          return In_Open_Scopes (S)\n            or else (Is_Generic_Instance (Current_Scope)\n@@ -1856,8 +1850,8 @@ package body Sem_Ch7 is\n         No (Discriminant_Specifications (N))\n           and then not Unknown_Discriminants_Present (N));\n \n-      --  Set tagged flag before processing discriminants, to catch\n-      --  illegal usage.\n+      --  Set tagged flag before processing discriminants, to catch illegal\n+      --  usage.\n \n       Set_Is_Tagged_Type (Id, Tagged_Present (Def));\n \n@@ -1900,8 +1894,8 @@ package body Sem_Ch7 is\n       Priv_Sub  : Entity_Id;\n \n       procedure Preserve_Full_Attributes (Priv, Full : Entity_Id);\n-      --  Copy to the private declaration the attributes of the full view\n-      --  that need to be available for the partial view also.\n+      --  Copy to the private declaration the attributes of the full view that\n+      --  need to be available for the partial view also.\n \n       function Type_In_Use (T : Entity_Id) return Boolean;\n       --  Check whether type or base type appear in an active use_type clause\n@@ -1951,8 +1945,8 @@ package body Sem_Ch7 is\n          then\n             if Priv_Is_Base_Type then\n \n-               --  Ada 2005 (AI-345): The full view of a type implementing\n-               --  an interface can be a task type.\n+               --  Ada 2005 (AI-345): The full view of a type implementing an\n+               --  interface can be a task type.\n \n                --    type T is new I with private;\n                --  private\n@@ -1984,8 +1978,8 @@ package body Sem_Ch7 is\n \n             if Is_Tagged_Type (Priv) then\n \n-               --  If the type is tagged, the tag itself must be available\n-               --  on the partial view, for expansion purposes.\n+               --  If the type is tagged, the tag itself must be available on\n+               --  the partial view, for expansion purposes.\n \n                Set_First_Entity (Priv, First_Entity (Full));\n \n@@ -2156,8 +2150,8 @@ package body Sem_Ch7 is\n       end if;\n \n       --  Make private entities invisible and exchange full and private\n-      --  declarations for private types. Id is now the first private\n-      --  entity in the package.\n+      --  declarations for private types. Id is now the first private entity\n+      --  in the package.\n \n       while Present (Id) loop\n          if Debug_Flag_E then\n@@ -2178,10 +2172,10 @@ package body Sem_Ch7 is\n          then\n             Full := Full_View (Id);\n \n-            --  If the partial view is not declared in the visible part\n-            --  of the package (as is the case when it is a type derived\n-            --  from some other private type in the private part of the\n-            --  current package), no exchange takes place.\n+            --  If the partial view is not declared in the visible part of the\n+            --  package (as is the case when it is a type derived from some\n+            --  other private type in the private part of the current package),\n+            --  no exchange takes place.\n \n             if No (Parent (Id))\n               or else List_Containing (Parent (Id))\n@@ -2192,10 +2186,10 @@ package body Sem_Ch7 is\n \n             --  The entry in the private part points to the full declaration,\n             --  which is currently visible. Exchange them so only the private\n-            --  type declaration remains accessible, and link private and\n-            --  full declaration in the opposite direction. Before the actual\n-            --  exchange, we copy back attributes of the full view that\n-            --  must be available to the partial view too.\n+            --  type declaration remains accessible, and link private and full\n+            --  declaration in the opposite direction. Before the actual\n+            --  exchange, we copy back attributes of the full view that must\n+            --  be available to the partial view too.\n \n             Preserve_Full_Attributes (Id, Full);\n \n@@ -2213,10 +2207,10 @@ package body Sem_Ch7 is\n             --  Swap out the subtypes and derived types of Id that were\n             --  compiled in this scope, or installed previously by\n             --  Install_Private_Declarations.\n-            --  Before we do the swap, we verify the presence of the\n-            --  Full_View field which may be empty due to a swap by\n-            --  a previous call to End_Package_Scope (e.g. from the\n-            --  freezing mechanism).\n+\n+            --  Before we do the swap, we verify the presence of the Full_View\n+            --  field which may be empty due to a swap by a previous call to\n+            --  End_Package_Scope (e.g. from the freezing mechanism).\n \n             while Present (Priv_Elmt) loop\n                Priv_Sub := Node (Priv_Elmt);\n@@ -2244,10 +2238,11 @@ package body Sem_Ch7 is\n \n             Exchange_Declarations (Id);\n \n-            --  If we have installed an underlying full view for a type\n-            --  derived from a private type in a child unit, restore the\n-            --  proper views of private and full view. See corresponding\n-            --  code in Install_Private_Declarations.\n+            --  If we have installed an underlying full view for a type derived\n+            --  from a private type in a child unit, restore the proper views\n+            --  of private and full view. See corresponding code in\n+            --  Install_Private_Declarations.\n+\n             --  After the exchange, Full denotes the private type in the\n             --  visible part of the package.\n \n@@ -2264,9 +2259,8 @@ package body Sem_Ch7 is\n            and then Comes_From_Source (Id)\n            and then No (Full_View (Id))\n          then\n-\n-            --  Mark Taft amendment types. Verify that there are no\n-            --  primitive operations declared for the type (3.10.1 (9)).\n+            --  Mark Taft amendment types. Verify that there are no primitive\n+            --  operations declared for the type (3.10.1 (9)).\n \n             Set_Has_Completion_In_Body (Id);\n \n@@ -2278,10 +2272,25 @@ package body Sem_Ch7 is\n                Elmt := First_Elmt (Private_Dependents (Id));\n                while Present (Elmt) loop\n                   Subp := Node (Elmt);\n+\n                   if Is_Overloadable (Subp) then\n                      Error_Msg_NE\n                        (\"type& must be completed in the private part\",\n                          Parent (Subp), Id);\n+\n+                  --  The return type of an access_to_function cannot be a\n+                  --  Taft-amendment type.\n+\n+                  elsif Ekind (Subp) = E_Subprogram_Type then\n+                     if Etype (Subp) = Id\n+                       or else\n+                         (Is_Class_Wide_Type (Etype (Subp))\n+                            and then Etype (Etype (Subp)) = Id)\n+                     then\n+                        Error_Msg_NE\n+                          (\"type& must be completed in the private part\",\n+                             Associated_Node_For_Itype (Subp), Id);\n+                     end if;\n                   end if;\n \n                   Next_Elmt (Elmt);\n@@ -2309,9 +2318,9 @@ package body Sem_Ch7 is\n       E : Entity_Id;\n \n    begin\n-      --  Imported entity never requires body. Right now, only\n-      --  subprograms can be imported, but perhaps in the future\n-      --  we will allow import of packages.\n+      --  Imported entity never requires body. Right now, only subprograms can\n+      --  be imported, but perhaps in the future we will allow import of\n+      --  packages.\n \n       if Is_Imported (P) then\n          return False;"}]}