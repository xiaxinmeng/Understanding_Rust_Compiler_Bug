{"sha": "a1ee6d507b0c26466be519d177f5a08b22f63647", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlZTZkNTA3YjBjMjY0NjZiZTUxOWQxNzdmNWEwOGIyMmY2MzY0Nw==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2020-08-07T16:49:04Z"}, "committer": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2020-08-07T16:49:04Z"}, "message": "Disable some VEC_COND_EXPR transformations after vector lowering\n\nARM understands VEC_COND_EXPR<v == w, -1, 0> but not a plain v == w which is\nfed to something other than VEC_COND_EXPR (say BIT_IOR_EXPR). This patch avoids\nintroducing the second kind of statement after the vector lowering pass, which\nis the last chance to turn v == w back into something the target handles.\n\nThis is just a workaround to avoid ICEs, a v == w produced before vector\nlowering will yield pretty bad code. Either the arm target needs to learn to\nhandle vector comparisons (aarch64 already does), or the middle-end needs to\nfall back to vcond when plain comparisons are not supported (or ...).\n\n2020-08-07  Marc Glisse  <marc.glisse@inria.fr>\n\n\t* generic-match-head.c (optimize_vectors_before_lowering_p): New\n\tfunction.\n\t* gimple-match-head.c (optimize_vectors_before_lowering_p):\n\tLikewise.\n\t* match.pd ((v ? w : 0) ? a : b, c1 ? c2 ? a : b : b): Use it.", "tree": {"sha": "5da578f99b7f1a468969a38129f9f4a345353e05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5da578f99b7f1a468969a38129f9f4a345353e05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ee6d507b0c26466be519d177f5a08b22f63647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee6d507b0c26466be519d177f5a08b22f63647", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ee6d507b0c26466be519d177f5a08b22f63647", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee6d507b0c26466be519d177f5a08b22f63647/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c3ae88d1e13b71665d1b27821159dcbea410267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3ae88d1e13b71665d1b27821159dcbea410267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3ae88d1e13b71665d1b27821159dcbea410267"}], "stats": {"total": 40, "additions": 31, "deletions": 9}, "files": [{"sha": "fdb528d968635282f3e0be9bad3a997965a3870b", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee6d507b0c26466be519d177f5a08b22f63647/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee6d507b0c26466be519d177f5a08b22f63647/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=a1ee6d507b0c26466be519d177f5a08b22f63647", "patch": "@@ -80,6 +80,16 @@ canonicalize_math_after_vectorization_p ()\n   return false;\n }\n \n+/* Return true if we can still perform transformations that may introduce\n+   vector operations that are not supported by the target. Vector lowering\n+   normally handles those, but after that pass, it becomes unsafe.  */\n+\n+static inline bool\n+optimize_vectors_before_lowering_p ()\n+{\n+  return true;\n+}\n+\n /* Return true if successive divisions can be optimized.\n    Defer to GIMPLE opts.  */\n "}, {"sha": "4a65be703b92b6426c6aefa732f63fc20e9ebf32", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee6d507b0c26466be519d177f5a08b22f63647/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee6d507b0c26466be519d177f5a08b22f63647/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=a1ee6d507b0c26466be519d177f5a08b22f63647", "patch": "@@ -1158,6 +1158,16 @@ canonicalize_math_after_vectorization_p ()\n   return !cfun || (cfun->curr_properties & PROP_gimple_lvec) != 0;\n }\n \n+/* Return true if we can still perform transformations that may introduce\n+   vector operations that are not supported by the target. Vector lowering\n+   normally handles those, but after that pass, it becomes unsafe.  */\n+\n+static inline bool\n+optimize_vectors_before_lowering_p ()\n+{\n+  return !cfun || (cfun->curr_properties & PROP_gimple_lvec) == 0;\n+}\n+\n /* Return true if pow(cst, x) should be optimized into exp(log(cst) * x).\n    As a workaround for SPEC CPU2017 628.pop2_s, don't do it if arg0\n    is an exact integer, arg1 = phi_res +/- cst1 and phi_res = PHI <cst2, ...>"}, {"sha": "7e5c5a6eae618a8bfebadf11ba5a79a2bfe41e85", "filename": "gcc/match.pd", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee6d507b0c26466be519d177f5a08b22f63647/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee6d507b0c26466be519d177f5a08b22f63647/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=a1ee6d507b0c26466be519d177f5a08b22f63647", "patch": "@@ -3461,40 +3461,42 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (vec_cond @0 (op! @3 @1) (op! @3 @2))))\n #endif\n \n-/* (v ? w : 0) ? a : b is just (v & w) ? a : b  */\n+/* (v ? w : 0) ? a : b is just (v & w) ? a : b\n+   Currently disabled after pass lvec because ARM understands\n+   VEC_COND_EXPR<v==w,-1,0> but not a plain v==w fed to BIT_IOR_EXPR.  */\n (simplify\n  (vec_cond (vec_cond:s @0 @3 integer_zerop) @1 @2)\n- (if (types_match (@0, @3))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @3))\n   (vec_cond (bit_and @0 @3) @1 @2)))\n (simplify\n  (vec_cond (vec_cond:s @0 integer_all_onesp @3) @1 @2)\n- (if (types_match (@0, @3))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @3))\n   (vec_cond (bit_ior @0 @3) @1 @2)))\n (simplify\n  (vec_cond (vec_cond:s @0 integer_zerop @3) @1 @2)\n- (if (types_match (@0, @3))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @3))\n   (vec_cond (bit_ior @0 (bit_not @3)) @2 @1)))\n (simplify\n  (vec_cond (vec_cond:s @0 @3 integer_all_onesp) @1 @2)\n- (if (types_match (@0, @3))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @3))\n   (vec_cond (bit_and @0 (bit_not @3)) @2 @1)))\n \n /* c1 ? c2 ? a : b : b  -->  (c1 & c2) ? a : b  */\n (simplify\n  (vec_cond @0 (vec_cond:s @1 @2 @3) @3)\n- (if (types_match (@0, @1))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @1))\n   (vec_cond (bit_and @0 @1) @2 @3)))\n (simplify\n  (vec_cond @0 @2 (vec_cond:s @1 @2 @3))\n- (if (types_match (@0, @1))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @1))\n   (vec_cond (bit_ior @0 @1) @2 @3)))\n (simplify\n  (vec_cond @0 (vec_cond:s @1 @2 @3) @2)\n- (if (types_match (@0, @1))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @1))\n   (vec_cond (bit_ior (bit_not @0) @1) @2 @3)))\n (simplify\n  (vec_cond @0 @3 (vec_cond:s @1 @2 @3))\n- (if (types_match (@0, @1))\n+ (if (optimize_vectors_before_lowering_p () && types_match (@0, @1))\n   (vec_cond (bit_and (bit_not @0) @1) @2 @3)))\n \n /* Simplification moved from fold_cond_expr_with_comparison.  It may also"}]}