{"sha": "6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYxYWJiMDZhNjI4ZjFiMGFiZDFhODViNzhjYjY4NjY2YmNiM2IyMw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2010-11-02T12:44:19Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2010-11-02T12:44:19Z"}, "message": "Restore canonical type comparison for dependent type(def)s\n\nThis patch restores canonical type comparison for dependent types and\nthen dependent typedefs. After this patch, two template type\nparameters T are equal if they have the same index, level, *and*\nnumber of sibling parameters. The novelty is to take in account the\nnumber of sibling parameters.\n\nTo do this we first build the template parameters w/o taking in\naccount their number of siblings. When we know the number of template\nparameters we fix up each template parameter with the number of\nslibling parameters and we build the appropriate canonical types\naccordingly. The patch fixes the fallouts deemed necessary.\n\nThis fixes PR c++/45606 but actually fixes all the previous bugs\nrelated to dependent typedef comparison we had since we started to\nproperly representing dependent typedefs.\n\ngcc/cp/ChangeLog:\n\tPR c++/45606\n\t* cp-tree.h (TEMPLATE_TYPE_PARM_SIBLING_PARMS): Remove.\n\t(struct template_parm_index_s)<num_siblings>: New field.\n\t(TEMPLATE_PARM_NUM_SIBLINGS): New accessor.\n\t(process_template_parm): Extend the API to accept the number of\n\ttemplate parms in argument.\n\t(cp_set_underlying_type): Remove this.\n\t* class.c (build_self_reference): Require canonical type equality\n\tback on the self reference of class.\n\t* decl2.c (grokfield): Require canonical type equality back on\n\ttypedef class fields.\n\t* name-lookup.c (pushdecl_maybe_friend): Require canonical type\n\tequality back on typedefs.\n\t* parser.c (cp_parser_template_parameter_list): Do not require\n\tcanonical type equality on dependent types created during\n\ttemplate parameters parsing.\n\t* pt.c (fixup_template_type_parm_type, fixup_template_parm_index)\n\t(fixup_template_parm, fixup_template_parms): New private\n\tfunctions.\n\t(current_template_args): Declare this.\n\t(process_template_parm): Pass the total number of template parms\n\tto canonical_type_parameter.\n\t(build_template_parm_index): Add a new argument to carry the total\n\tnumber of template parms.\n\t(reduce_template_parm_level, process_template_parm, make_auto): Adjust.\n\t(current_template_args): Fix this for template template\n\tparameters.\n\t(tsubst_template_parm): Split out of ...\n\t(tsubst_template_parms): ... this.\n\t(reduce_template_parm_level): Don't loose\n\tTEMPLATE_PARM_NUM_SIBLINGS when cloning a TEMPLATE_PARM_INDEX.\n\t(template_parm_to_arg): Extracted this function from\n\tcurrent_template_args. Make it represent invalid template parms\n\twith an error_mark_node instead of a LIST_TREE containing an\n\terror_mark_node.\n\t(current_template_args): Use template_parm_to_arg.\n\t(dependent_template_arg_p): Consider an invalid template argument\n\tas dependent.\n\t(end_template_parm_list): Do not update template sibling parms\n\there anymore. Use fixup_template_parms instead.\n\t(process_template_parm): Pass the number of template parms to\n\tcanonical_type_parameter.\n\t(make_auto): Require structural equality on auto\n\tTEMPLATE_TYPE_PARM for now.\n\t(unify)<BOUND_TEMPLATE_TEMPLATE_PARM>: Coerce template parameters\n\tusing all the arguments deduced so far.\n\t(tsubst)<TEMPLATE_TYPE_PARM>: Pass the number of sibling parms to\n\tcanonical_type_parameter.\n\t* tree.c (cp_set_underlying_type): Remove.\n\t* typeck.c (get_template_parms_of_dependent_type)\n\t(incompatible_dependent_types_p): Remove.\n\t(structural_comptypes): Do not call incompatible_dependent_types_p\n\tanymore.\n\t(comp_template_parms_position): Re-organized. Take the length of\n\ttemplate parms list in account.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/45606\n\t* g++.dg/template/typedef36.C: New test.\n\t* gcc/testsuite/g++.dg/template/canon-type-9.C: Likewise.\n\t* g++.dg/template/canon-type-10.C: Likewise.\n\t* g++.dg/template/canon-type-11.C: Likewise.\n\t* g++.dg/template/canon-type-12.C: Likewise.\n\t* g++.dg/template/canon-type-13.C: Likewise.\n\nFrom-SVN: r166179", "tree": {"sha": "ebd70402d2077b3f75d086daf709eb562d85e72a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebd70402d2077b3f75d086daf709eb562d85e72a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/comments", "author": null, "committer": null, "parents": [{"sha": "9d8477b66b410f3b38cb09317794cb7e8dee9489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d8477b66b410f3b38cb09317794cb7e8dee9489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d8477b66b410f3b38cb09317794cb7e8dee9489"}], "stats": {"total": 924, "additions": 701, "deletions": 223}, "files": [{"sha": "1ab6854ea8a818ca30d17ce068ec9cbc2cf92cb0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -1,3 +1,62 @@\n+2010-11-02  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/45606\n+\t* cp-tree.h (TEMPLATE_TYPE_PARM_SIBLING_PARMS): Remove.\n+\t(struct template_parm_index_s)<num_siblings>: New field.\n+\t(TEMPLATE_PARM_NUM_SIBLINGS): New accessor.\n+\t(process_template_parm): Extend the API to accept the number of\n+\ttemplate parms in argument.\n+\t(cp_set_underlying_type): Remove this.\n+\t* class.c (build_self_reference): Require canonical type equality\n+\tback on the self reference of class.\n+\t* decl2.c (grokfield): Require canonical type equality back on\n+\ttypedef class fields.\n+\t* name-lookup.c (pushdecl_maybe_friend): Require canonical type\n+\tequality back on typedefs.\n+\t* parser.c (cp_parser_template_parameter_list): Do not require\n+\tcanonical type equality on dependent types created during template\n+\tparameters parsing.\n+\t* pt.c (fixup_template_type_parm_type, fixup_template_parm_index)\n+\t(fixup_template_parm, fixup_template_parms): New private\n+\tfunctions.\n+\t(current_template_args): Declare this.\n+\t(process_template_parm): Pass the total number of template parms\n+\tto canonical_type_parameter.\n+\t(build_template_parm_index): Add a new argument to carry the total\n+\tnumber of template parms.\n+\t(reduce_template_parm_level, process_template_parm, make_auto):\n+\tAdjust.\n+\t(current_template_args): Fix this for template template\n+\tparameters.\n+\t(tsubst_template_parm): Split out of ...\n+\t(tsubst_template_parms): ... this.\n+\t(reduce_template_parm_level): Don't loose\n+\tTEMPLATE_PARM_NUM_SIBLINGS when cloning a TEMPLATE_PARM_INDEX.\n+\t(template_parm_to_arg): Extracted this function from\n+\tcurrent_template_args. Make it represent invalid template parms\n+\twith an error_mark_node instead of a LIST_TREE containing an\n+\terror_mark_node.\n+\t(current_template_args): Use template_parm_to_arg.\n+\t(dependent_template_arg_p): Consider an invalid template argument\n+\tas dependent.\n+\t(end_template_parm_list): Do not update template sibling parms\n+\there anymore. Use fixup_template_parms instead.\n+\t(process_template_parm): Pass the number of template parms to\n+\tcanonical_type_parameter.\n+\t(make_auto): Require structural equality on auto\n+\tTEMPLATE_TYPE_PARM for now.\n+\t(unify)<BOUND_TEMPLATE_TEMPLATE_PARM>: Coerce template parameters\n+\tusing all the arguments deduced so far.\n+\t(tsubst)<TEMPLATE_TYPE_PARM>: Pass the number of sibling parms to\n+\tcanonical_type_parameter.\n+\t* tree.c (cp_set_underlying_type): Remove.\n+\t* typeck.c (get_template_parms_of_dependent_type)\n+\t(incompatible_dependent_types_p): Remove.\n+\t(structural_comptypes): Do not call incompatible_dependent_types_p\n+\tanymore.\n+\t(comp_template_parms_position): Re-organized. Take the length of\n+\ttemplate parms list in account.\n+\n 2010-11-01  Jason Merrill  <jason@redhat.com>\n \n \t* semantics.c (call_stack, call_stack_tick, cx_error_context): New."}, {"sha": "7aa697450d1e3fbbd3940cf4b1f1ae2dfbba5724", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -6768,7 +6768,7 @@ build_self_reference (void)\n   DECL_CONTEXT (value) = current_class_type;\n   DECL_ARTIFICIAL (value) = 1;\n   SET_DECL_SELF_REFERENCE_P (value);\n-  cp_set_underlying_type (value);\n+  set_underlying_type (value);\n \n   if (processing_template_decl)\n     value = push_template_decl (value);"}, {"sha": "b46959b7f984c33b3f3c3cd972745bb38c156bb2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -236,6 +236,7 @@ struct GTY(()) template_parm_index_s {\n   int index;\n   int level;\n   int orig_level;\n+  int num_siblings;\n   tree decl;\n };\n typedef struct template_parm_index_s template_parm_index;\n@@ -4310,6 +4311,9 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n \t((template_parm_index*)TEMPLATE_PARM_INDEX_CHECK (NODE))\n #define TEMPLATE_PARM_IDX(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->index)\n #define TEMPLATE_PARM_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->level)\n+/* The Number of sibling parms this template parm has.  */\n+#define TEMPLATE_PARM_NUM_SIBLINGS(NODE) \\\n+  (TEMPLATE_PARM_INDEX_CAST (NODE)->num_siblings)\n #define TEMPLATE_PARM_DESCENDANTS(NODE) (TREE_CHAIN (NODE))\n #define TEMPLATE_PARM_ORIG_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->orig_level)\n #define TEMPLATE_PARM_DECL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->decl)\n@@ -4331,10 +4335,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n   (TEMPLATE_PARM_DECL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n #define TEMPLATE_TYPE_PARAMETER_PACK(NODE) \\\n   (TEMPLATE_PARM_PARAMETER_PACK (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n-/* The list of template parms that a given template parameter of type\n-   TEMPLATE_TYPE_PARM belongs to.*/\n-#define TEMPLATE_TYPE_PARM_SIBLING_PARMS(NODE) \\\n-  (TREE_CHECK ((NODE), TEMPLATE_TYPE_PARM))->type.maxval\n \n /* These constants can used as bit flags in the process of tree formatting.\n \n@@ -5022,7 +5022,7 @@ extern void append_type_to_template_for_access_check (tree, tree, tree,\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, location_t, tree, \n-\t\t\t\t\t\t bool, bool);\n+\t\t\t\t\t\t bool, bool, unsigned);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n extern tree maybe_update_decl_type\t\t(tree, tree);\n@@ -5366,7 +5366,6 @@ extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern tree strip_typedefs\t\t\t(tree);\n-extern void cp_set_underlying_type\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(const_tree);"}, {"sha": "a805c6b52d771c9d452a1d03aae2e5b3ed41d9d6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -864,7 +864,7 @@ grokfield (const cp_declarator *declarator,\n       if (declspecs->specs[(int)ds_typedef]\n           && TREE_TYPE (value) != error_mark_node\n           && TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (value))) != value)\n-\tcp_set_underlying_type (value);\n+\tset_underlying_type (value);\n \n       return value;\n     }"}, {"sha": "0a93da880839906b5a9da368d4988d90f1c2048a", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -872,7 +872,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t     inlining.  */\n \t\t  && (!TYPE_NAME (type)\n \t\t      || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x))))\n-\t    cp_set_underlying_type (x);\n+\t    set_underlying_type (x);\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)"}, {"sha": "864ec9b280651c6e245622cfbfa93852422b9c2d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -11045,6 +11045,13 @@ cp_parser_template_parameter_list (cp_parser* parser)\n   tree parameter_list = NULL_TREE;\n \n   begin_template_parm_list ();\n+\n+  /* The loop below parses the template parms.  We first need to know\n+     the total number of template parms to be able to compute proper\n+     canonical types of each dependent type. So after the loop, when\n+     we know the total number of template parms,\n+     end_template_parm_list computes the proper canonical types and\n+     fixes up the dependent types accordingly.  */\n   while (true)\n     {\n       tree parameter;\n@@ -11063,11 +11070,11 @@ cp_parser_template_parameter_list (cp_parser* parser)\n \t\t\t\t\t\tparm_loc,\n \t\t\t\t\t\tparameter,\n \t\t\t\t\t\tis_non_type,\n-                                                is_parameter_pack);\n+\t\t\t\t\t\tis_parameter_pack,\n+\t\t\t\t\t\t0);\n       else\n        {\n          tree err_parm = build_tree_list (parameter, parameter);\n-         TREE_VALUE (err_parm) = error_mark_node;\n          parameter_list = chainon (parameter_list, err_parm);\n        }\n "}, {"sha": "e4975c6a1120d8ce6af9608ceb98fa87b22bed78", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 447, "deletions": 85, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -137,7 +137,7 @@ static tree convert_template_argument (tree, tree, tree,\n static int for_each_template_parm (tree, tree_fn_t, void*,\n \t\t\t\t   struct pointer_set_t*, bool);\n static tree expand_template_argument_pack (tree);\n-static tree build_template_parm_index (int, int, int, tree, tree);\n+static tree build_template_parm_index (int, int, int, int, tree, tree);\n static bool inline_needs_template_parms (tree);\n static void push_inline_template_parms_recursive (tree, int);\n static tree retrieve_local_specialization (tree);\n@@ -189,6 +189,12 @@ static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n \t\t\t\t\t\t\tlocation_t);\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n+static tree template_parm_to_arg (tree t);\n+static tree current_template_args (void);\n+static tree fixup_template_type_parm_type (tree, int);\n+static tree fixup_template_parm_index (tree, tree, int);\n+static void fixup_template_parms (void);\n+static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -3353,19 +3359,22 @@ check_template_shadow (tree decl)\n }\n \n /* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n-   ORIG_LEVEL, DECL, and TYPE.  */\n+   ORIG_LEVEL, DECL, and TYPE.  NUM_SIBLINGS is the total number of\n+   template parameters.  */\n \n static tree\n build_template_parm_index (int index,\n \t\t\t   int level,\n \t\t\t   int orig_level,\n+\t\t\t   int num_siblings,\n \t\t\t   tree decl,\n \t\t\t   tree type)\n {\n   tree t = make_node (TEMPLATE_PARM_INDEX);\n   TEMPLATE_PARM_IDX (t) = index;\n   TEMPLATE_PARM_LEVEL (t) = level;\n   TEMPLATE_PARM_ORIG_LEVEL (t) = orig_level;\n+  TEMPLATE_PARM_NUM_SIBLINGS (t) = num_siblings;\n   TEMPLATE_PARM_DECL (t) = decl;\n   TREE_TYPE (t) = type;\n   TREE_CONSTANT (t) = TREE_CONSTANT (decl);\n@@ -3377,6 +3386,7 @@ build_template_parm_index (int index,\n /* Find the canonical type parameter for the given template type\n    parameter.  Returns the canonical type parameter, which may be TYPE\n    if no such parameter existed.  */\n+\n static tree\n canonical_type_parameter (tree type)\n {\n@@ -3430,6 +3440,7 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n       t = build_template_parm_index (TEMPLATE_PARM_IDX (index),\n \t\t\t\t     TEMPLATE_PARM_LEVEL (index) - levels,\n \t\t\t\t     TEMPLATE_PARM_ORIG_LEVEL (index),\n+\t\t\t\t     TEMPLATE_PARM_NUM_SIBLINGS (index),\n \t\t\t\t     decl, type);\n       TEMPLATE_PARM_DESCENDANTS (index) = t;\n       TEMPLATE_PARM_PARAMETER_PACK (t) \n@@ -3445,15 +3456,20 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n   return TEMPLATE_PARM_DESCENDANTS (index);\n }\n \n-/* Process information from new template parameter PARM and append it to the\n-   LIST being built.  This new parameter is a non-type parameter iff\n-   IS_NON_TYPE is true. This new parameter is a parameter\n-   pack iff IS_PARAMETER_PACK is true.  The location of PARM is in \n-   PARM_LOC.  */\n+/* Process information from new template parameter PARM and append it\n+   to the LIST being built.  This new parameter is a non-type\n+   parameter iff IS_NON_TYPE is true. This new parameter is a\n+   parameter pack iff IS_PARAMETER_PACK is true.  The location of PARM\n+   is in PARM_LOC. NUM_TEMPLATE_PARMS is the size of the template\n+   parameter list PARM belongs to. This is used used to create a\n+   proper canonical type for the type of PARM that is to be created,\n+   iff PARM is a type.  If the size is not known, this parameter shall\n+   be set to 0.  */\n \n tree\n-process_template_parm (tree list, location_t parm_loc, tree parm, bool is_non_type, \n-                       bool is_parameter_pack)\n+process_template_parm (tree list, location_t parm_loc, tree parm,\n+\t\t       bool is_non_type, bool is_parameter_pack,\n+\t\t       unsigned num_template_parms)\n {\n   tree decl = 0;\n   tree defval;\n@@ -3528,6 +3544,7 @@ process_template_parm (tree list, location_t parm_loc, tree parm, bool is_non_ty\n       DECL_INITIAL (parm) = DECL_INITIAL (decl)\n \t= build_template_parm_index (idx, processing_template_decl,\n \t\t\t\t     processing_template_decl,\n+\t\t\t\t     num_template_parms,\n \t\t\t\t     decl, TREE_TYPE (parm));\n \n       TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)) \n@@ -3561,6 +3578,7 @@ process_template_parm (tree list, location_t parm_loc, tree parm, bool is_non_ty\n       TEMPLATE_TYPE_PARM_INDEX (t)\n \t= build_template_parm_index (idx, processing_template_decl,\n \t\t\t\t     processing_template_decl,\n+\t\t\t\t     num_template_parms,\n \t\t\t\t     decl, TREE_TYPE (parm));\n       TEMPLATE_TYPE_PARAMETER_PACK (t) = is_parameter_pack;\n       TYPE_CANONICAL (t) = canonical_type_parameter (t);\n@@ -3593,16 +3611,313 @@ end_template_parm_list (tree parms)\n       next = TREE_CHAIN (parm);\n       TREE_VEC_ELT (saved_parmlist, nparms) = parm;\n       TREE_CHAIN (parm) = NULL_TREE;\n-      if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n-\tTEMPLATE_TYPE_PARM_SIBLING_PARMS (TREE_TYPE (TREE_VALUE (parm))) =\n-\t      current_template_parms;\n     }\n \n+  fixup_template_parms ();\n+\n   --processing_template_parmlist;\n \n   return saved_parmlist;\n }\n \n+/* Create a new type almost identical to TYPE but which has the\n+   following differences:\n+\n+     1/ T has a new TEMPLATE_PARM_INDEX that carries the new number of\n+     template sibling parameters of T.\n+\n+     2/ T has a new canonical type that matches the new number\n+     of sibling parms.\n+\n+     3/ From now on, T is going to be what lookups referring to the\n+     name of TYPE will return. No lookup should return TYPE anymore.\n+\n+   NUM_PARMS is the new number of sibling parms TYPE belongs to.\n+\n+   This is a subroutine of fixup_template_parms.  */\n+\n+static tree\n+fixup_template_type_parm_type (tree type, int num_parms)\n+{\n+  tree orig_idx = TEMPLATE_TYPE_PARM_INDEX (type), idx;\n+  tree t;\n+  /* This is the decl which name is inserted into the symbol table for\n+     the template parm type. So whenever we lookup the type name, this\n+     is the DECL we get.  */\n+  tree decl;\n+\n+  /* Do not fix up the type twice.  */\n+  if (orig_idx && TEMPLATE_PARM_NUM_SIBLINGS (orig_idx) != 0)\n+    return type;\n+\n+  t = copy_type (type);\n+  decl = TYPE_NAME (t);\n+\n+  TYPE_MAIN_VARIANT (t) = t;\n+  TYPE_NEXT_VARIANT (t)= NULL_TREE;\n+  TYPE_POINTER_TO (t) = 0;\n+  TYPE_REFERENCE_TO (t) = 0;\n+\n+  idx = build_template_parm_index (TEMPLATE_PARM_IDX (orig_idx),\n+\t\t\t\t   TEMPLATE_PARM_LEVEL (orig_idx),\n+\t\t\t\t   TEMPLATE_PARM_ORIG_LEVEL (orig_idx),\n+\t\t\t\t   num_parms,\n+\t\t\t\t   decl, t);\n+  TEMPLATE_PARM_DESCENDANTS (idx) = TEMPLATE_PARM_DESCENDANTS (orig_idx);\n+  TEMPLATE_PARM_PARAMETER_PACK (idx) = TEMPLATE_PARM_PARAMETER_PACK (orig_idx);\n+  TEMPLATE_TYPE_PARM_INDEX (t) = idx;\n+\n+  TYPE_STUB_DECL (t) = decl;\n+  TEMPLATE_TYPE_DECL (t) = decl;\n+  if (TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n+    TREE_TYPE (DECL_TEMPLATE_RESULT  (decl)) = t;\n+\n+  /* Update the type associated to the type name stored in the symbol\n+     table. Now, whenever the type name is looked up, the resulting\n+     type is properly fixed up.  */\n+  TREE_TYPE (decl) = t;\n+\n+  TYPE_CANONICAL (t) = canonical_type_parameter (t);\n+\n+  return t;\n+}\n+\n+/* Create and return a new TEMPLATE_PARM_INDEX that is almost\n+   identical to I, but that is fixed up as to:\n+\n+   1/ carry the number of sibling parms (NUM_PARMS) of the template\n+   parm represented by I.\n+\n+   2/ replace all references to template parm types declared before I\n+   (in the same template parm list as I) by references to template\n+   parm types contained in ARGS. ARGS should contain the list of\n+   template parms that have been fixed up so far, in a form suitable\n+   to be passed to tsubst.\n+\n+   This is a subroutine of fixup_template_parms.  */\n+\n+static tree\n+fixup_template_parm_index (tree i, tree args, int num_parms)\n+{\n+  tree index, decl, type;\n+\n+  if (i == NULL_TREE\n+      || TREE_CODE (i) != TEMPLATE_PARM_INDEX\n+      /* Do not fix up the index twice.  */\n+      || (TEMPLATE_PARM_NUM_SIBLINGS (i) != 0))\n+    return i;\n+\n+  decl = TEMPLATE_PARM_DECL (i);\n+  type = TREE_TYPE (decl);\n+\n+  index = build_template_parm_index (TEMPLATE_PARM_IDX (i),\n+\t\t\t\t     TEMPLATE_PARM_LEVEL (i),\n+\t\t\t\t     TEMPLATE_PARM_ORIG_LEVEL (i),\n+\t\t\t\t     num_parms,\n+\t\t\t\t     decl, type);\n+\n+  TEMPLATE_PARM_DESCENDANTS (index) = TEMPLATE_PARM_DESCENDANTS (i);\n+  TEMPLATE_PARM_PARAMETER_PACK (index) = TEMPLATE_PARM_PARAMETER_PACK (i);\n+\n+  type = tsubst (type, args, tf_none, NULL_TREE);\n+  \n+  TREE_TYPE (decl) = type;\n+  TREE_TYPE (index) = type;\n+\n+  return index;\n+}\n+\n+/* \n+   This is a subroutine of fixup_template_parms.\n+\n+   It computes the canonical type of the type of the template\n+   parameter PARM_DESC and update all references to that type so that\n+   they use the newly computed canonical type. No access check is\n+   performed during the fixup. PARM_DESC is a TREE_LIST which\n+   TREE_VALUE is the template parameter and its TREE_PURPOSE is the\n+   default argument of the template parm if any. IDX is the index of\n+   the template parameter, starting at 0. NUM_PARMS is the number of\n+   template parameters in the set PARM_DESC belongs to. ARGLIST is a\n+   TREE_VEC containing the full set of template parameters in a form\n+   suitable to be passed to substs functions as their ARGS\n+   argument. This is what current_template_args returns for a given\n+   template. The innermost vector of args in ARGLIST is the set of\n+   template parms that have been fixed up so far. This function adds\n+   the fixed up parameter into that vector.  */\n+\n+static void\n+fixup_template_parm (tree parm_desc,\n+\t\t     int idx,\n+\t\t     int num_parms,\n+\t\t     tree arglist)\n+{\n+  tree parm = TREE_VALUE (parm_desc);\n+  tree fixedup_args = INNERMOST_TEMPLATE_ARGS (arglist);\n+\n+  push_deferring_access_checks (dk_no_check);\n+\n+  if (TREE_CODE (parm) == TYPE_DECL)\n+    {\n+      /* PARM is a template type parameter. Fix up its type, add\n+\t the fixed-up template parm to the vector of fixed-up\n+\t template parms so far, and substitute the fixed-up\n+\t template parms into the default argument of this\n+\t parameter.  */\n+      tree t =\n+\tfixup_template_type_parm_type (TREE_TYPE (parm), num_parms);\n+      TREE_TYPE (parm) = t;\n+\n+      TREE_VEC_ELT (fixedup_args, idx) = template_parm_to_arg (parm_desc);\n+    }\n+  else if (TREE_CODE (parm) == TEMPLATE_DECL)\n+    {\n+      /* PARM is a template template parameter. This is going to\n+\t be interesting.  */\n+      tree tparms, targs, innermost_args;\n+      int j;\n+\n+      /* First, fix up the type of the parm.  */\n+\n+      tree t =\n+\tfixup_template_type_parm_type (TREE_TYPE (parm), num_parms);\n+      TREE_TYPE (parm) = t;\n+\n+      TREE_VEC_ELT (fixedup_args, idx) =\n+\ttemplate_parm_to_arg (parm_desc);\n+\n+      /* Now we need to substitute the template parm types that\n+\t have been fixed up so far into the non-type template\n+\t parms of this template template parm. E.g, consider this:\n+\n+\t template<class T, template<T u> class TT> class S;\n+\n+\t In this case we want to substitute T into the\n+\t template parameters of TT.\n+\n+\t So let's walk the template parms of PARM here, and\n+\t tsubst ARGLIST into into each of the template\n+\t parms.   */\n+\n+      /* For this substitution we need to build the full set of\n+\t template parameters and use that as arguments for the\n+\t tsubsting function.  */\n+      tparms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (parm));\n+\n+      /* This will contain the innermost parms of PARM into which\n+\t we have substituted so far.  */\n+      innermost_args = make_tree_vec (TREE_VEC_LENGTH (tparms));\n+      targs = add_to_template_args (arglist, innermost_args);\n+      for (j = 0; j < TREE_VEC_LENGTH (tparms); ++j)\n+\t{\n+\t  tree parameter;\n+\n+\t  parameter = TREE_VEC_ELT (tparms, j);\n+\n+\t  /* INNERMOST_ARGS needs to have at least the same number\n+\t     of elements as the index PARAMETER, ortherwise\n+\t     tsubsting into PARAMETER will result in partially\n+\t     instantiating it, reducing its tempate parm\n+\t     level. Let's tactically fill INNERMOST_ARGS for that\n+\t     purpose.  */\n+\t  TREE_VEC_ELT (innermost_args, j) =\n+\t    template_parm_to_arg (parameter);\n+\n+\t  fixup_template_parm (parameter, j,\n+\t\t\t       TREE_VEC_LENGTH (tparms),\n+\t\t\t       targs);\n+\t}\n+    }\n+  else if (TREE_CODE (parm) == PARM_DECL)\n+    {\n+      /* PARM is a non-type template parameter. We need to:\n+\n+       * Fix up its TEMPLATE_PARM_INDEX to make it carry the\n+       proper number of sibling parameters.\n+\n+       * Make lookups of the template parameter return a reference\n+       to the fixed-up index. No lookup should return references\n+       to the former index anymore.\n+\n+       * Substitute the template parms that got fixed up so far\n+\n+       * into the type of PARM.  */\n+\n+      tree index = DECL_INITIAL (parm);\n+\n+      /* PUSHED_DECL is the decl added to the symbol table with\n+\t the name of the parameter. E,g:\n+\t     \n+\t template<class T, T u> //#0\n+\t auto my_function(T t) -> decltype(u); //#1\n+\n+\t Here, when looking up u at //#1, we get the decl of u\n+\t resulting from the declaration in #0. This is what\n+\t PUSHED_DECL is. We need to replace the reference to the\n+\t old TEMPLATE_PARM_INDEX carried by PUSHED_DECL by the\n+\t fixed-up TEMPLATE_PARM_INDEX.  */\n+      tree pushed_decl = TEMPLATE_PARM_DECL (index);\n+\n+      /* Let's fix up the TEMPLATE_PARM_INDEX then. Note that we must\n+\t fixup the type of PUSHED_DECL as well and luckily\n+\t fixup_template_parm_index does it for us too.  */\n+      tree fixed_up_index =\n+\tfixup_template_parm_index (index, arglist, num_parms);\n+\n+      DECL_INITIAL (pushed_decl) = DECL_INITIAL (parm) = fixed_up_index;\n+\n+      /* Add this fixed up PARM to the template parms we've fixed\n+\t up so far and use that to substitute the fixed-up\n+\t template parms into the type of PARM.  */\n+      TREE_VEC_ELT (fixedup_args, idx) =\n+\ttemplate_parm_to_arg (parm_desc);\n+      TREE_TYPE (parm) = tsubst (TREE_TYPE (parm), arglist,\n+\t\t\t\t tf_none, NULL_TREE);\n+    }\n+\n+  TREE_PURPOSE (parm_desc) =\n+    tsubst_template_arg (TREE_PURPOSE (parm_desc),\n+\t\t\t arglist, tf_none, parm);\n+\n+  pop_deferring_access_checks ();\n+}\n+\n+/* Walk current the template parms and properly compute the canonical\n+   types of the dependent types created during\n+   cp_parser_template_parameter_list.  */\n+\n+static void\n+fixup_template_parms (void)\n+{\n+  tree arglist;\n+  tree parameter_vec;\n+  tree fixedup_args;\n+  int i, num_parms;\n+\n+  parameter_vec = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+  if (parameter_vec == NULL_TREE)\n+    return;\n+\n+  num_parms = TREE_VEC_LENGTH (parameter_vec);\n+\n+  /* This vector contains the current innermost template parms that\n+     have been fixed up so far.  The form of FIXEDUP_ARGS is suitable\n+     to be passed to tsubst* functions as their ARGS argument.  */\n+  fixedup_args = make_tree_vec (num_parms);\n+\n+  /* This vector contains the full set of template parms in a form\n+     suitable to be passed to substs functions as their ARGS\n+     argument.  */\n+  arglist = current_template_args ();\n+  arglist = add_outermost_template_args (arglist, fixedup_args);\n+\n+  fixedup_args = INNERMOST_TEMPLATE_ARGS (arglist);\n+\n+  /* Let's do the proper fixup now.  */\n+  for (i = 0; i < num_parms; ++i)\n+    fixup_template_parm (TREE_VEC_ELT (parameter_vec, i),\n+\t\t\t i, num_parms, arglist);\n+}\n+\n /* end_template_decl is called after a template declaration is seen.  */\n \n void\n@@ -3620,6 +3935,68 @@ end_template_decl (void)\n   current_template_parms = TREE_CHAIN (current_template_parms);\n }\n \n+/* Takes a TREE_LIST representing a template parameter and convert it\n+   into an argument suitable to be passed to the type substitution\n+   functions.  Note that If the TREE_LIST contains an error_mark\n+   node, the returned argument is error_mark_node.  */\n+\n+static tree\n+template_parm_to_arg (tree t)\n+{\n+\n+  if (t == NULL_TREE\n+      || TREE_CODE (t) != TREE_LIST)\n+    return t;\n+\n+  if (error_operand_p (TREE_VALUE (t)))\n+    return error_mark_node;\n+\n+  t = TREE_VALUE (t);\n+\n+  if (TREE_CODE (t) == TYPE_DECL\n+      || TREE_CODE (t) == TEMPLATE_DECL)\n+    {\n+      t = TREE_TYPE (t);\n+\n+      if (TEMPLATE_TYPE_PARAMETER_PACK (t))\n+\t{\n+\t  /* Turn this argument into a TYPE_ARGUMENT_PACK\n+\t     with a single element, which expands T.  */\n+\t  tree vec = make_tree_vec (1);\n+#ifdef ENABLE_CHECKING\n+\t  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n+\t    (vec, TREE_VEC_LENGTH (vec));\n+#endif\n+\t  TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n+\n+\t  t = cxx_make_type (TYPE_ARGUMENT_PACK);\n+\t  SET_ARGUMENT_PACK_ARGS (t, vec);\n+\t}\n+    }\n+  else\n+    {\n+      t = DECL_INITIAL (t);\n+\n+      if (TEMPLATE_PARM_PARAMETER_PACK (t))\n+\t{\n+\t  /* Turn this argument into a NONTYPE_ARGUMENT_PACK\n+\t     with a single element, which expands T.  */\n+\t  tree vec = make_tree_vec (1);\n+\t  tree type = TREE_TYPE (TEMPLATE_PARM_DECL (t));\n+#ifdef ENABLE_CHECKING\n+\t  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n+\t    (vec, TREE_VEC_LENGTH (vec));\n+#endif\n+\t  TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n+\n+\t  t  = make_node (NONTYPE_ARGUMENT_PACK);\n+\t  SET_ARGUMENT_PACK_ARGS (t, vec);\n+\t  TREE_TYPE (t) = type;\n+\t}\n+    }\n+  return t;\n+}\n+\n /* Within the declaration of a template, return all levels of template\n    parameters that apply.  The template parameters are represented as\n    a TREE_VEC, in the form documented in cp-tree.h for template\n@@ -3646,63 +4023,7 @@ current_template_args (void)\n \n       TREE_TYPE (a) = NULL_TREE;\n       for (i = TREE_VEC_LENGTH (a) - 1; i >= 0; --i)\n-\t{\n-\t  tree t = TREE_VEC_ELT (a, i);\n-\n-\t  /* T will be a list if we are called from within a\n-\t     begin/end_template_parm_list pair, but a vector directly\n-\t     if within a begin/end_member_template_processing pair.  */\n-\t  if (TREE_CODE (t) == TREE_LIST)\n-\t    {\n-\t      t = TREE_VALUE (t);\n-\n-\t      if (!error_operand_p (t))\n-\t\t{\n-\t\t  if (TREE_CODE (t) == TYPE_DECL\n-\t\t      || TREE_CODE (t) == TEMPLATE_DECL)\n-                    {\n-                      t = TREE_TYPE (t);\n-                      \n-                      if (TEMPLATE_TYPE_PARAMETER_PACK (t))\n-                        {\n-                          /* Turn this argument into a TYPE_ARGUMENT_PACK\n-                             with a single element, which expands T.  */\n-                          tree vec = make_tree_vec (1);\n-#ifdef ENABLE_CHECKING\n-\t\t\t  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n-\t\t\t\t(vec, TREE_VEC_LENGTH (vec));\n-#endif\n-                          TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n-                          \n-                          t = cxx_make_type (TYPE_ARGUMENT_PACK);\n-                          SET_ARGUMENT_PACK_ARGS (t, vec);\n-                        }\n-                    }\n-                  else\n-                    {\n-                      t = DECL_INITIAL (t);\n-                      \n-                      if (TEMPLATE_PARM_PARAMETER_PACK (t))\n-                        {\n-                          /* Turn this argument into a NONTYPE_ARGUMENT_PACK\n-                             with a single element, which expands T.  */\n-                          tree vec = make_tree_vec (1);\n-                          tree type = TREE_TYPE (TEMPLATE_PARM_DECL (t));\n-#ifdef ENABLE_CHECKING\n-\t\t\t  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT\n-\t\t\t\t(vec, TREE_VEC_LENGTH (vec));\n-#endif\n-                          TREE_VEC_ELT (vec, 0) = make_pack_expansion (t);\n-                          \n-                          t  = make_node (NONTYPE_ARGUMENT_PACK);\n-                          SET_ARGUMENT_PACK_ARGS (t, vec);\n-                          TREE_TYPE (t) = type;\n-                        }\n-                    }\n-\t\t  TREE_VEC_ELT (a, i) = t;\n-                }\n-\t    }\n-\t}\n+\tTREE_VEC_ELT (a, i) = template_parm_to_arg (TREE_VEC_ELT (a, i));\n \n #ifdef ENABLE_CHECKING\n       SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (a, TREE_VEC_LENGTH (a));\n@@ -3714,6 +4035,21 @@ current_template_args (void)\n \targs = a;\n     }\n \n+    if (length > 1 && TREE_VEC_ELT (args, 0) == NULL_TREE)\n+      /* This can happen for template parms of a template template\n+\t parameter, e.g:\n+\n+\t template<template<class T, class U> class TT> struct S;\n+\n+\t Consider the level of the parms of TT; T and U both have\n+\t level 2; TT has no template parm of level 1. So in this case\n+\t the first element of full_template_args is NULL_TREE. If we\n+\t leave it like this TMPL_ARG_DEPTH on args returns 1 instead\n+\t of 2. This will make tsubst wrongly consider that T and U\n+\t have level 1. Instead, let's create a dummy vector as the\n+\t first element of full_template_args so that TMPL_ARG_DEPTH\n+\t returns the correct depth for args.  */\n+      TREE_VEC_ELT (args, 0) = make_tree_vec (1);\n   return args;\n }\n \n@@ -8721,8 +9057,6 @@ tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n       for (i = 0; i < TREE_VEC_LENGTH (new_vec); ++i)\n \t{\n           tree tuple;\n-          tree default_value;\n-          tree parm_decl;\n \n           if (parms == error_mark_node)\n             continue;\n@@ -8732,18 +9066,8 @@ tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n           if (tuple == error_mark_node)\n             continue;\n \n-          default_value = TREE_PURPOSE (tuple);\n-          parm_decl = TREE_VALUE (tuple);\n-\n-\t  parm_decl = tsubst (parm_decl, args, complain, NULL_TREE);\n-\t  if (TREE_CODE (parm_decl) == PARM_DECL\n-\t      && invalid_nontype_parm_type_p (TREE_TYPE (parm_decl), complain))\n-\t    parm_decl = error_mark_node;\n-\t  default_value = tsubst_template_arg (default_value, args,\n-\t\t\t\t\t       complain, NULL_TREE);\n-\n-\t  tuple = build_tree_list (default_value, parm_decl);\n-\t  TREE_VEC_ELT (new_vec, i) = tuple;\n+\t  TREE_VEC_ELT (new_vec, i) =\n+\t    tsubst_template_parm (tuple, args, complain);\n \t}\n \n       *new_parms =\n@@ -8757,6 +9081,36 @@ tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n   return r;\n }\n \n+/* Return the result of substituting ARGS into one template parameter\n+   given by T. T Must be a TREE_LIST which TREE_VALUE is the template\n+   parameter and which TREE_PURPOSE is the default argument of the\n+   template parameter.  */\n+\n+static tree\n+tsubst_template_parm (tree t, tree args, tsubst_flags_t complain)\n+{\n+  tree default_value, parm_decl;\n+\n+  if (args == NULL_TREE\n+      || t == NULL_TREE\n+      || t == error_mark_node)\n+    return t;\n+\n+  gcc_assert (TREE_CODE (t) == TREE_LIST);\n+\n+  default_value = TREE_PURPOSE (t);\n+  parm_decl = TREE_VALUE (t);\n+\n+  parm_decl = tsubst (parm_decl, args, complain, NULL_TREE);\n+  if (TREE_CODE (parm_decl) == PARM_DECL\n+      && invalid_nontype_parm_type_p (TREE_TYPE (parm_decl), complain))\n+    parm_decl = error_mark_node;\n+  default_value = tsubst_template_arg (default_value, args,\n+\t\t\t\t       complain, NULL_TREE);\n+\n+  return build_tree_list (default_value, parm_decl);\n+}\n+\n /* Substitute the ARGS into the indicated aggregate (or enumeration)\n    type T.  If T is not an aggregate or enumeration type, it is\n    handled as if by tsubst.  IN_DECL is as for tsubst.  If\n@@ -14668,6 +15022,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  {\n \t    tree parmvec = TYPE_TI_ARGS (parm);\n \t    tree argvec = INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (arg));\n+\t    tree full_argvec = add_to_template_args (targs, argvec);\n \t    tree parm_parms \n               = DECL_INNERMOST_TEMPLATE_PARMS\n \t          (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (parm));\n@@ -14702,7 +15057,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t      the global operator+ will be used; if they are not, the\n \t      Lvalue_proxy will be converted to float.  */\n \t    if (coerce_template_parms (parm_parms,\n-                                       argvec,\n+                                       full_argvec,\n \t\t\t\t       TYPE_TI_TEMPLATE (parm),\n \t\t\t\t       tf_none,\n \t\t\t\t       /*require_all_args=*/true,\n@@ -18007,6 +18362,13 @@ dependent_template_arg_p (tree arg)\n   if (!processing_template_decl)\n     return false;\n \n+  /* Assume a template argument that was wrongly written by the user\n+     is dependent. This is consistent with what\n+     any_dependent_template_arguments_p [that calls this function]\n+     does.  */\n+  if (arg == error_mark_node)\n+    return true;\n+\n   if (TREE_CODE (arg) == TEMPLATE_DECL\n       || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n     return dependent_template_p (arg);\n@@ -18434,7 +18796,7 @@ make_auto (void)\n   TYPE_STUB_DECL (au) = TYPE_NAME (au);\n   TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n     (0, processing_template_decl + 1, processing_template_decl + 1,\n-     TYPE_NAME (au), NULL_TREE);\n+     0, TYPE_NAME (au), NULL_TREE);\n   TYPE_CANONICAL (au) = canonical_type_parameter (au);\n   DECL_ARTIFICIAL (TYPE_NAME (au)) = 1;\n   SET_DECL_TEMPLATE_PARM_P (TYPE_NAME (au));"}, {"sha": "d1d306e3a2a137b7c0d6a2332e2f18c4c1f4e921", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -1096,22 +1096,6 @@ strip_typedefs (tree t)\n   return cp_build_qualified_type (result, cp_type_quals (t));\n }\n \n-/* Setup a TYPE_DECL node as a typedef representation.\n-   See comments of set_underlying_type in c-common.c.  */\n-\n-void\n-cp_set_underlying_type (tree t)\n-{\n-  set_underlying_type (t);\n-  /* If T is a template type parm, make it require structural equality.\n-     This is useful when comparing two template type parms,\n-     because it forces the comparison of the template parameters of their\n-     decls.  */\n-  if (TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n-    SET_TYPE_STRUCTURAL_EQUALITY (TREE_TYPE (t));\n-}\n-\n-\f\n /* Makes a copy of BINFO and TYPE, which is to be inherited into a\n    graph dominated by T.  If BINFO is NULL, TYPE is a dependent base,\n    and we do a shallow copy.  If BINFO is non-NULL, we do a deep copy."}, {"sha": "5f8d32162f04b979345444fb8ab46ab5b0d79970", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 111, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -1143,120 +1143,30 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)\n static bool\n comp_template_parms_position (tree t1, tree t2)\n {\n+  tree index1, index2;\n   gcc_assert (t1 && t2\n \t      && TREE_CODE (t1) == TREE_CODE (t2)\n \t      && (TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM\n \t\t  || TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM\n \t\t  || TREE_CODE (t1) == TEMPLATE_TYPE_PARM));\n \n-      if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n-\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2)\n-          || (TEMPLATE_TYPE_PARAMETER_PACK (t1) \n-              != TEMPLATE_TYPE_PARAMETER_PACK (t2)))\n-\treturn false;\n-\n-      return true;\n-}\n-\n-/* Subroutine of incompatible_dependent_types_p.\n-   Return the template parameter of the dependent type T.\n-   If T is a typedef, return the template parameters of\n-   the _decl_ of the typedef. T must be a dependent type.  */\n-\n-static tree\n-get_template_parms_of_dependent_type (tree t)\n-{\n-  tree tinfo = NULL_TREE, tparms = NULL_TREE;\n-\n-  /* First, try the obvious case of getting the\n-     template info from T itself.  */\n-  if ((tinfo = get_template_info (t)))\n-    ;\n-  else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-    return TEMPLATE_TYPE_PARM_SIBLING_PARMS (t);\n-  else if (typedef_variant_p (t)\n-\t   && !NAMESPACE_SCOPE_P (TYPE_NAME (t)))\n-    tinfo = get_template_info (DECL_CONTEXT (TYPE_NAME (t)));\n-  /* If T is a TYPENAME_TYPE which context is a template type\n-     parameter, get the template parameters from that context.  */\n-  else if (TYPE_CONTEXT (t)\n-\t   && TREE_CODE (TYPE_CONTEXT (t)) == TEMPLATE_TYPE_PARM)\n-   return TEMPLATE_TYPE_PARM_SIBLING_PARMS (TYPE_CONTEXT (t));\n-  else if (TYPE_CONTEXT (t)\n-\t   && !NAMESPACE_SCOPE_P (t))\n-    tinfo = get_template_info (TYPE_CONTEXT (t));\n-\n-  if (tinfo)\n-    tparms = DECL_TEMPLATE_PARMS (TI_TEMPLATE (tinfo));\n-\n-  return tparms;\n-}\n-\n-/* Subroutine of structural_comptypes.\n-   Compare the dependent types T1 and T2.\n-   Return TRUE if we are sure they can't be equal, FALSE otherwise.\n-   The whole point of this function is to support cases where either T1 or\n-   T2 is a typedef. In those cases, we need to compare the template parameters\n-   of the _decl_ of the typedef. If those don't match then we know T1\n-   and T2 cannot be equal.  */\n-\n-static bool\n-incompatible_dependent_types_p (tree t1, tree t2)\n-{\n-  tree tparms1 = NULL_TREE, tparms2 = NULL_TREE;\n-  bool t1_typedef_variant_p, t2_typedef_variant_p;\n-\n-  if (!uses_template_parms (t1) || !uses_template_parms (t2))\n-    return false;\n-\n-  if (TREE_CODE (t1) == TEMPLATE_TYPE_PARM)\n-    {\n-      /* If T1 and T2 don't have the same relative position in their\n-\t template parameters set, they can't be equal.  */\n-      if (!comp_template_parms_position (t1, t2))\n-\treturn true;\n-    }\n-\n-  t1_typedef_variant_p = typedef_variant_p (t1);\n-  t2_typedef_variant_p = typedef_variant_p (t2);\n+  index1 = TEMPLATE_TYPE_PARM_INDEX (TYPE_MAIN_VARIANT (t1));\n+  index2 = TEMPLATE_TYPE_PARM_INDEX (TYPE_MAIN_VARIANT (t2));\n \n-  /* Either T1 or T2 must be a typedef.  */\n-  if (!t1_typedef_variant_p && !t2_typedef_variant_p)\n+  /* If T1 and T2 belong to template parm lists of different size,\n+     let's assume they are different.  */\n+  if (TEMPLATE_PARM_NUM_SIBLINGS (index1)\n+      != TEMPLATE_PARM_NUM_SIBLINGS (index2))\n     return false;\n \n-  if (!t1_typedef_variant_p || !t2_typedef_variant_p)\n-    /* Either T1 or T2 is not a typedef so we cannot compare the\n-       template parms of the typedefs of T1 and T2.\n-       At this point, if the main variant type of T1 and T2 are equal\n-       it means the two types can't be incompatible, from the perspective\n-       of this function.  */\n-    if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n-      return false;\n-\n-  /* So if we reach this point, it means either T1 or T2 is a typedef variant.\n-     Let's compare their template parameters.  */\n-\n-  tparms1 = get_template_parms_of_dependent_type (t1);\n-  tparms2 = get_template_parms_of_dependent_type (t2);\n-\n-  /* If T2 is a template type parm and if we could not get the template\n-     parms it belongs to, that means we have not finished parsing the\n-     full set of template parameters of the template declaration it\n-     belongs to yet. If we could get the template parms T1 belongs to,\n-     that mostly means T1 and T2 belongs to templates that are\n-     different and incompatible.  */\n-  if (TREE_CODE (t1) == TEMPLATE_TYPE_PARM\n-      && (tparms1 == NULL_TREE || tparms2 == NULL_TREE)\n-      && tparms1 != tparms2)\n-    return true;\n-\n-  if (tparms1 == NULL_TREE\n-      || tparms2 == NULL_TREE\n-      || tparms1 == tparms2)\n+  /* Then compare their relative position.  */\n+  if (TEMPLATE_PARM_IDX (index1) != TEMPLATE_PARM_IDX (index2)\n+      || TEMPLATE_PARM_LEVEL (index1) != TEMPLATE_PARM_LEVEL (index2)\n+      || (TEMPLATE_PARM_PARAMETER_PACK (index1)\n+\t  != TEMPLATE_PARM_PARAMETER_PACK (index2)))\n     return false;\n \n-  /* And now compare the mighty template parms!  */\n-  return !comp_template_parms (tparms1, tparms2);\n+  return true;\n }\n \n /* Subroutine in comptypes.  */\n@@ -1301,12 +1211,6 @@ structural_comptypes (tree t1, tree t2, int strict)\n   if (TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n     return false;\n \n-  /* If T1 and T2 are dependent typedefs then check upfront that\n-     the template parameters of their typedef DECLs match before\n-     going down checking their subtypes.  */\n-  if (incompatible_dependent_types_p (t1, t2))\n-    return false;\n-\n   /* Allow for two different type nodes which have essentially the same\n      definition.  Note that we already checked for equality of the type\n      qualifiers (just above).  */\n@@ -1407,8 +1311,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      /* If incompatible_dependent_types_p called earlier didn't decide\n-         T1 and T2 were different, they might be equal.  */\n+      /* If T1 and T2 don't have the same relative position in their\n+\t template parameters set, they can't be equal.  */\n+      if (!comp_template_parms_position (t1, t2))\n+\treturn false;\n       break;\n \n     case TYPENAME_TYPE:"}, {"sha": "b784b1cad8d3f8a698dabd8be705785a7a6e51cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -1,3 +1,13 @@\n+2010-11-02  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/45606\n+\t* g++.dg/template/typedef36.C: New test.\n+\t* gcc/testsuite/g++.dg/template/canon-type-9.C: Likewise.\n+\t* g++.dg/template/canon-type-10.C: Likewise.\n+\t* g++.dg/template/canon-type-11.C: Likewise.\n+\t* g++.dg/template/canon-type-12.C: Likewise.\n+\t* g++.dg/template/canon-type-13.C: Likewise.\n+\n 2010-11-02  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* g++.dg/debug/dwarf2/pubnames-1.C: Amend to check for only one instance"}, {"sha": "0c38946ec0a20ed680aa39edc22e3e6698ff2432", "filename": "gcc/testsuite/g++.dg/template/canon-type-10.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-10.C?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -0,0 +1,23 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// { dg-do \"compile\" }\n+\n+template<class T>\n+struct C\n+{\n+};\n+\n+template<class T,\n+\t template<class TT_T0, template<class TT_T1> class TT_TT> class TT,\n+\t class U = TT<int, C> >\n+struct S\n+{\n+  void foo(TT<T, C>);\n+};\n+\n+template<class T,\n+\t template<class TT_T0, template<class TT_T1> class TT_TT> class TT,\n+\t class U>\n+void\n+S<T, TT, U>::foo(TT<T, C>)\n+{\n+}"}, {"sha": "698fe31882744a513ea599b308d95a858eb50a73", "filename": "gcc/testsuite/g++.dg/template/canon-type-11.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-11.C?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -0,0 +1,39 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// { dg-do \"compile\" }\n+\n+template<class T>\n+struct C\n+{\n+  void bar();\n+};\n+\n+template<class T>\n+void\n+C<T>::bar()\n+{\n+}\n+\n+\n+template<class U,\n+\t template<class TT0_T0> class TT0 = C,\n+\t template<class TT1_T0> class TT1 = TT0>\n+struct S\n+{\n+  C<U> s;\n+\n+  void foo(TT1<U>);\n+\n+  void bar()\n+  {\n+    foo(s);\n+  }\n+};\n+\n+template<class T,\n+\t template<class TT0_T0> class TT0,\n+\t template<class TT1_T0> class TT1>\n+void\n+S<T, TT0, TT1>::foo(TT1<T>)\n+{\n+  C<T> c;\n+}"}, {"sha": "694cc5e13790cb5aeb3edad018342993bddade94", "filename": "gcc/testsuite/g++.dg/template/canon-type-12.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-12.C?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template<class T, T t = (T)0>\n+struct S\n+{\n+  void\n+  foo(decltype(t) = t);\n+};\n+\n+template<class T, T t>\n+void\n+S<T, t>::foo(T)\n+{\n+}\n+\n+void\n+bar()\n+{\n+  S<int> s;\n+  s.foo();\n+}"}, {"sha": "ca39cea912458fe56ab7b5cc43e6f6c24da5e5f1", "filename": "gcc/testsuite/g++.dg/template/canon-type-13.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-13.C?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -0,0 +1,27 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// { dg-do \"compile\" }\n+\n+template<class T>\n+struct S0\n+{\n+};\n+\n+template<class T>\n+struct S1\n+{\n+};\n+\n+template<class T, template<class T>  class A, template<class T>  class B = A>\n+struct C\n+{\n+  B<T> m;\n+};\n+\n+void\n+foo()\n+{\n+  C<int, S0> s;\n+  S0<int> s0;\n+\n+  s.m = s0;\n+}"}, {"sha": "de6170e985262435098811e78af7b7d65279f299", "filename": "gcc/testsuite/g++.dg/template/canon-type-9.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcanon-type-9.C?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -0,0 +1,18 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do \"compile\" }\n+\n+struct F { F(int) {}};\n+\n+template<class T, T* u>\n+struct S\n+{\n+  decltype(u) foo(T);\n+};\n+\n+template<class T, T *u>\n+T* S<T, u>::foo(T)\n+{\n+  T t;\n+  return t;\n+}"}, {"sha": "318deef92df8531df70fa9de01b1184d5645982a", "filename": "gcc/testsuite/g++.dg/template/typedef36.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef36.C?ref=6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "patch": "@@ -0,0 +1,23 @@\n+// Origin: PR c++/45606\n+// { dg-do compile }\n+\n+template<class T, class U = int>\n+struct S0\n+{\n+  typedef int const_iterator;\n+};\n+\n+template<class T>\n+struct Test\n+{\n+  typedef S0<T> SAlias;\n+  typedef typename SAlias::const_iterator const_iterator;\n+  const_iterator begin ();\n+};\n+\n+template<class T>\n+typename S0<T>::const_iterator\n+Test<T>::begin()\n+{\n+  return 0;\n+}"}]}