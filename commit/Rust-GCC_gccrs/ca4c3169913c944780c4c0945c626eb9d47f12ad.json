{"sha": "ca4c3169913c944780c4c0945c626eb9d47f12ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0YzMxNjk5MTNjOTQ0NzgwYzRjMDk0NWM2MjZlYjlkNDdmMTJhZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-02-10T00:32:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-02-10T00:32:47Z"}, "message": "re PR tree-optimization/18687 (>200% compile time regression compared to gcc-3.4)\n\n\tPR tree-optimization/18687\n\t* tree-flow.h (find_loop_niter): Declare.\n\t* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):\n\tTry using scev even for loops with more than one exit.\n\t* tree-ssa-loop-ivopts.c (struct loop_data): Removed niter field.\n\t(struct ivopts_data): Added niters field.\n\t(struct nfe_cache_elt): New.\n\t(nfe_hash, nfe_eq, niter_for_exit, niter_for_single_dom_exit): New\n\tfunctions.\n\t(tree_ssa_iv_optimize_init): Initialize niters cache.\n\t(determine_number_of_iterations): Removed.\n\t(find_induction_variables): Do not call determine_number_of_iterations.\n\tAccess niters for single exit through niter_for_single_dom_exit.\n\t(add_iv_outer_candidates): Access niters for single exit through\n\tniter_for_single_dom_exit.\n\t(may_eliminate_iv): Take data argument.  Use niter_for_exit.  Do not use\n\tnumber_of_iterations_cond.\n\t(iv_period): New function.\n\t(determine_use_iv_cost_condition): Pass data to may_eliminate_iv.\n\t(may_replace_final_value): Take data argument.  Use\n\tniter_for_single_dom_exit.\n\t(determine_use_iv_cost_outer): Pass data to may_replace_final_value.\n\t(rewrite_use_compare): Pass data to may_eliminate_iv.\n\t(rewrite_use_outer): Pass data to may_replace_final_value.\n\t(free_loop_data): Clean up the niters cache.\n\t(tree_ssa_iv_optimize_finalize): Free the niters cache.\n\t(tree_ssa_iv_optimize_loop): Do not call loop_commit_inserts.\n\t* tree-ssa-loop-niter.c (find_loop_niter): New function.\n\t(find_loop_niter_by_eval): Use tree_int_cst_lt.\n\t(num_ending_zeros): Moved to tree.c.\n\t* tree.h (num_ending_zeros): Declare.\n\t* tree.c (num_ending_zeros): Moved from tree.c.\n\nFrom-SVN: r94787", "tree": {"sha": "97fb019298ce16faec345a7102ee459f0b806cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97fb019298ce16faec345a7102ee459f0b806cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca4c3169913c944780c4c0945c626eb9d47f12ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4c3169913c944780c4c0945c626eb9d47f12ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4c3169913c944780c4c0945c626eb9d47f12ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4c3169913c944780c4c0945c626eb9d47f12ad/comments", "author": null, "committer": null, "parents": [{"sha": "1bc83fd3bcc5591ce3d535520a3d451151f8a521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc83fd3bcc5591ce3d535520a3d451151f8a521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bc83fd3bcc5591ce3d535520a3d451151f8a521"}], "stats": {"total": 454, "additions": 324, "deletions": 130}, "files": [{"sha": "bf1d9fa01a0a13d6674344056e6c814950c91d59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -1,3 +1,38 @@\n+2005-02-09  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/18687\n+\t* tree-flow.h (find_loop_niter): Declare.\n+\t* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):\n+\tTry using scev even for loops with more than one exit.\n+\t* tree-ssa-loop-ivopts.c (struct loop_data): Removed niter field.\n+\t(struct ivopts_data): Added niters field.\n+\t(struct nfe_cache_elt): New.\n+\t(nfe_hash, nfe_eq, niter_for_exit, niter_for_single_dom_exit): New\n+\tfunctions.\n+\t(tree_ssa_iv_optimize_init): Initialize niters cache.\n+\t(determine_number_of_iterations): Removed.\n+\t(find_induction_variables): Do not call determine_number_of_iterations.\n+\tAccess niters for single exit through niter_for_single_dom_exit.\n+\t(add_iv_outer_candidates): Access niters for single exit through\n+\tniter_for_single_dom_exit.\n+\t(may_eliminate_iv): Take data argument.  Use niter_for_exit.  Do not use\n+\tnumber_of_iterations_cond.\n+\t(iv_period): New function.\n+\t(determine_use_iv_cost_condition): Pass data to may_eliminate_iv.\n+\t(may_replace_final_value): Take data argument.  Use\n+\tniter_for_single_dom_exit.\n+\t(determine_use_iv_cost_outer): Pass data to may_replace_final_value.\n+\t(rewrite_use_compare): Pass data to may_eliminate_iv.\n+\t(rewrite_use_outer): Pass data to may_replace_final_value.\n+\t(free_loop_data): Clean up the niters cache.\n+\t(tree_ssa_iv_optimize_finalize): Free the niters cache.\n+\t(tree_ssa_iv_optimize_loop): Do not call loop_commit_inserts.\n+\t* tree-ssa-loop-niter.c (find_loop_niter): New function.\n+\t(find_loop_niter_by_eval): Use tree_int_cst_lt.\n+\t(num_ending_zeros): Moved to tree.c.\n+\t* tree.h (num_ending_zeros): Declare.\n+\t* tree.c (num_ending_zeros): Moved from tree.c.\n+\n 2005-02-09  Richard Henderson  <rth@redhat.com>\n \n \t* builtins.c (DEF_BUILTIN): Add COND argument."}, {"sha": "80ad68680a8d90f702f20288df2a446f174ef597", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -667,6 +667,7 @@ void number_of_iterations_cond (tree, tree, tree, enum tree_code, tree, tree,\n \t\t\t\tstruct tree_niter_desc *);\n bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\tstruct tree_niter_desc *niter);\n+tree find_loop_niter (struct loop *, edge *);\n tree loop_niter_by_eval (struct loop *, edge);\n tree find_loop_niter_by_eval (struct loop *, edge *);\n void estimate_numbers_of_iterations (struct loops *);"}, {"sha": "a2930166908b53b71023a2dc2cab4c62f83f66b7", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -220,12 +220,23 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n       niter = fold (build2 (MINUS_EXPR, TREE_TYPE (niter), niter,\n \t\t\t    build_int_cst (TREE_TYPE (niter), 1)));\n     }\n-  else if (try_eval)\n-    niter = find_loop_niter_by_eval (loop, &exit);\n-\n-  if (chrec_contains_undetermined (niter)\n-      || TREE_CODE (niter) != INTEGER_CST)\n-    return false;\n+  else\n+    {\n+      /* If the loop has more than one exit, try checking all of them\n+\t for # of iterations determinable through scev.  */\n+      if (!loop->single_exit)\n+\tniter = find_loop_niter (loop, &exit);\n+\n+      /* Finally if everything else fails, try brute force evaluation.  */\n+      if (try_eval\n+\t  && (chrec_contains_undetermined (niter)\n+\t      || TREE_CODE (niter) != INTEGER_CST))\n+\tniter = find_loop_niter_by_eval (loop, &exit);\n+\n+      if (chrec_contains_undetermined (niter)\n+\t  || TREE_CODE (niter) != INTEGER_CST)\n+\treturn false;\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "84965b9719e7bdf997da98be103e5d7126f8b8e9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 161, "deletions": 82, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -123,9 +123,6 @@ struct version_info\n /* Information attached to loop.  */\n struct loop_data\n {\n-  struct tree_niter_desc niter;\n-\t\t\t/* Number of iterations.  */\n-\n   unsigned regs_used;\t/* Number of registers used.  */\n };\n \n@@ -199,6 +196,9 @@ struct ivopts_data\n   /* The currently optimized loop.  */\n   struct loop *current_loop;\n \n+  /* Numbers of iterations for all exits of the current loop.  */\n+  htab_t niters;\n+\n   /* The size of version_info array allocated.  */\n   unsigned version_info_size;\n \n@@ -639,6 +639,86 @@ stmt_after_increment (struct loop *loop, struct iv_cand *cand, tree stmt)\n     }\n }\n \n+/* Element of the table in that we cache the numbers of iterations obtained\n+   from exits of the loop.  */\n+\n+struct nfe_cache_elt\n+{\n+  /* The edge for that the number of iterations is cached.  */\n+  edge exit;\n+\n+  /* True if the # of iterations was succesfully determined.  */\n+  bool valid_p;\n+\n+  /* Description of # of iterations.  */\n+  struct tree_niter_desc niter;\n+};\n+\n+/* Hash function for nfe_cache_elt E.  */\n+\n+static hashval_t\n+nfe_hash (const void *e)\n+{\n+  const struct nfe_cache_elt *elt = e;\n+\n+  return htab_hash_pointer (elt->exit);\n+}\n+\n+/* Equality function for nfe_cache_elt E1 and edge E2.  */\n+\n+static int\n+nfe_eq (const void *e1, const void *e2)\n+{\n+  const struct nfe_cache_elt *elt1 = e1;\n+\n+  return elt1->exit == e2;\n+}\n+\n+/*  Returns structure describing number of iterations determined from\n+    EXIT of DATA->current_loop, or NULL if something goes wrong.  */\n+\n+static struct tree_niter_desc *\n+niter_for_exit (struct ivopts_data *data, edge exit)\n+{\n+  struct nfe_cache_elt *nfe_desc;\n+  PTR *slot;\n+\n+  slot = htab_find_slot_with_hash (data->niters, exit,\n+\t\t\t\t   htab_hash_pointer (exit),\n+\t\t\t\t   INSERT);\n+\n+  if (!*slot)\n+    {\n+      nfe_desc = xmalloc (sizeof (struct nfe_cache_elt));\n+      nfe_desc->exit = exit;\n+      nfe_desc->valid_p = number_of_iterations_exit (data->current_loop,\n+\t\t\t\t\t\t     exit, &nfe_desc->niter);\n+      *slot = nfe_desc;\n+    }\n+  else\n+    nfe_desc = *slot;\n+\n+  if (!nfe_desc->valid_p)\n+    return NULL;\n+\n+  return &nfe_desc->niter;\n+}\n+\n+/* Returns structure describing number of iterations determined from\n+   single dominating exit of DATA->current_loop, or NULL if something\n+   goes wrong.  */\n+\n+static struct tree_niter_desc *\n+niter_for_single_dom_exit (struct ivopts_data *data)\n+{\n+  edge exit = single_dom_exit (data->current_loop);\n+\n+  if (!exit)\n+    return NULL;\n+\n+  return niter_for_exit (data, exit);\n+}\n+\n /* Initializes data structures used by the iv optimization pass, stored\n    in DATA.  LOOPS is the loop tree.  */\n \n@@ -653,6 +733,7 @@ tree_ssa_iv_optimize_init (struct loops *loops, struct ivopts_data *data)\n   data->relevant = BITMAP_XMALLOC ();\n   data->important_candidates = BITMAP_XMALLOC ();\n   data->max_inv_id = 0;\n+  data->niters = htab_create (10, nfe_hash, nfe_eq, free);\n \n   for (i = 1; i < loops->num; i++)\n     if (loops->parray[i])\n@@ -1009,54 +1090,35 @@ find_givs (struct ivopts_data *data)\n   free (body);\n }\n \n-/* Determine the number of iterations of the current loop.  */\n-\n-static void\n-determine_number_of_iterations (struct ivopts_data *data)\n-{\n-  struct loop *loop = data->current_loop;\n-  edge exit = single_dom_exit (loop);\n-\n-  if (!exit)\n-    return;\n-\n-  number_of_iterations_exit (loop, exit, &loop_data (loop)->niter);\n-}\n-\n /* For each ssa name defined in LOOP determines whether it is an induction\n    variable and if so, its initial value and step.  */\n \n static bool\n find_induction_variables (struct ivopts_data *data)\n {\n   unsigned i;\n-  struct loop *loop = data->current_loop;\n   bitmap_iterator bi;\n \n   if (!find_bivs (data))\n     return false;\n \n   find_givs (data);\n   mark_bivs (data);\n-  determine_number_of_iterations (data);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      if (loop_data (loop)->niter.niter)\n+      struct tree_niter_desc *niter;\n+\n+      niter = niter_for_single_dom_exit (data);\n+\n+      if (niter)\n \t{\n \t  fprintf (dump_file, \"  number of iterations \");\n-\t  print_generic_expr (dump_file, loop_data (loop)->niter.niter,\n-\t\t\t      TDF_SLIM);\n+\t  print_generic_expr (dump_file, niter->niter, TDF_SLIM);\n \t  fprintf (dump_file, \"\\n\");\n \n     \t  fprintf (dump_file, \"  may be zero if \");\n-    \t  print_generic_expr (dump_file, loop_data (loop)->niter.may_be_zero,\n-    \t\t\t      TDF_SLIM);\n-    \t  fprintf (dump_file, \"\\n\");\n-\n-    \t  fprintf (dump_file, \"  bogus unless \");\n-    \t  print_generic_expr (dump_file, loop_data (loop)->niter.assumptions,\n-    \t\t\t      TDF_SLIM);\n+    \t  print_generic_expr (dump_file, niter->may_be_zero, TDF_SLIM);\n     \t  fprintf (dump_file, \"\\n\");\n     \t  fprintf (dump_file, \"\\n\");\n     \t};\n@@ -1958,16 +2020,11 @@ static void\n add_iv_outer_candidates (struct ivopts_data *data, struct iv_use *use)\n {\n   struct tree_niter_desc *niter;\n-  struct loop *loop = data->current_loop;\n \n   /* We must know where we exit the loop and how many times does it roll.  */\n-  if (!single_dom_exit (loop))\n-    return;\n-\n-  niter = &loop_data (loop)->niter;\n-  if (!niter->niter\n-      || !operand_equal_p (niter->assumptions, boolean_true_node, 0)\n-      || !operand_equal_p (niter->may_be_zero, boolean_false_node, 0))\n+  niter = niter_for_single_dom_exit (data);\n+  if (!niter\n+      || !zero_p (niter->may_be_zero))\n     return;\n \n   add_candidate_1 (data, NULL, NULL, false, IP_NORMAL, use, NULL_TREE);\n@@ -3233,19 +3290,44 @@ cand_value_at (struct loop *loop, struct iv_cand *cand, tree at, tree niter)\n   return val;\n }\n \n+/* Returns period of induction variable iv.  */\n+\n+static tree\n+iv_period (struct iv *iv)\n+{\n+  tree step = iv->step, period, type;\n+  tree pow2div;\n+\n+  gcc_assert (step && TREE_CODE (step) == INTEGER_CST);\n+\n+  /* Period of the iv is gcd (step, type range).  Since type range is power\n+     of two, it suffices to determine the maximum power of two that divides\n+     step.  */\n+  pow2div = num_ending_zeros (step);\n+  type = unsigned_type_for (TREE_TYPE (step));\n+\n+  period = build_low_bits_mask (type,\n+\t\t\t\t(TYPE_PRECISION (type)\n+\t\t\t\t - tree_low_cst (pow2div, 1)));\n+\n+  return period;\n+}\n+\n /* Check whether it is possible to express the condition in USE by comparison\n    of candidate CAND.  If so, store the comparison code to COMPARE and the\n    value compared with to BOUND.  */\n \n static bool\n-may_eliminate_iv (struct loop *loop,\n+may_eliminate_iv (struct ivopts_data *data,\n \t\t  struct iv_use *use, struct iv_cand *cand,\n \t\t  enum tree_code *compare, tree *bound)\n {\n   basic_block ex_bb;\n   edge exit;\n-  struct tree_niter_desc niter, new_niter;\n-  tree wider_type, type, base;\n+  struct tree_niter_desc *niter;\n+  tree nit, nit_type;\n+  tree wider_type, period, per_type;\n+  struct loop *loop = data->current_loop;\n   \n   /* For now works only for exits that dominate the loop latch.  TODO -- extend\n      for other conditions inside loop body.  */\n@@ -3262,43 +3344,39 @@ may_eliminate_iv (struct loop *loop,\n   if (flow_bb_inside_loop_p (loop, exit->dest))\n     return false;\n \n-  niter.niter = NULL_TREE;\n-  number_of_iterations_exit (loop, exit, &niter);\n-  if (!niter.niter\n-      || !integer_nonzerop (niter.assumptions)\n-      || !integer_zerop (niter.may_be_zero))\n+  niter = niter_for_exit (data, exit);\n+  if (!niter\n+      || !zero_p (niter->may_be_zero))\n     return false;\n \n-  if (exit->flags & EDGE_TRUE_VALUE)\n-    *compare = EQ_EXPR;\n-  else\n-    *compare = NE_EXPR;\n-\n-  *bound = cand_value_at (loop, cand, use->stmt, niter.niter);\n+  nit = niter->niter;\n+  nit_type = TREE_TYPE (nit);\n \n-  /* Let us check there is not some problem with overflows, by checking that\n-     the number of iterations is unchanged.  */\n-  base = cand->iv->base;\n-  type = TREE_TYPE (base);\n-  if (stmt_after_increment (loop, cand, use->stmt))\n-    base = fold (build2 (PLUS_EXPR, type, base, cand->iv->step));\n-\n-  new_niter.niter = NULL_TREE;\n-  number_of_iterations_cond (TREE_TYPE (cand->iv->base), base,\n-\t\t\t     cand->iv->step, NE_EXPR, *bound, NULL_TREE,\n-\t\t\t     &new_niter);\n-  if (!new_niter.niter\n-      || !integer_nonzerop (new_niter.assumptions)\n-      || !integer_zerop (new_niter.may_be_zero))\n+  /* Determine whether we may use the variable to test whether niter iterations\n+     elapsed.  This is the case iff the period of the induction variable is\n+     greater than the number of iterations.  */\n+  period = iv_period (cand->iv);\n+  if (!period)\n     return false;\n+  per_type = TREE_TYPE (period);\n+\n+  wider_type = TREE_TYPE (period);\n+  if (TYPE_PRECISION (nit_type) < TYPE_PRECISION (per_type))\n+    wider_type = per_type;\n+  else\n+    wider_type = nit_type;\n \n-  wider_type = TREE_TYPE (new_niter.niter);\n-  if (TYPE_PRECISION (wider_type) < TYPE_PRECISION (TREE_TYPE (niter.niter)))\n-    wider_type = TREE_TYPE (niter.niter);\n-  if (!operand_equal_p (fold_convert (wider_type, niter.niter),\n-\t\t\tfold_convert (wider_type, new_niter.niter), 0))\n+  if (!integer_nonzerop (fold (build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t       fold_convert (wider_type, period),\n+\t\t\t\t       fold_convert (wider_type, nit)))))\n     return false;\n \n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    *compare = EQ_EXPR;\n+  else\n+    *compare = NE_EXPR;\n+\n+  *bound = cand_value_at (loop, cand, use->stmt, nit);\n   return true;\n }\n \n@@ -3318,7 +3396,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       return false;\n     }\n \n-  if (may_eliminate_iv (data->current_loop, use, cand, &compare, &bound))\n+  if (may_eliminate_iv (data, use, cand, &compare, &bound))\n     {\n       bitmap depends_on = NULL;\n       unsigned cost = force_var_cost (data, bound, &depends_on);\n@@ -3345,8 +3423,10 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n    a direct computation.  If so, the formula is stored to *VALUE.  */\n \n static bool\n-may_replace_final_value (struct loop *loop, struct iv_use *use, tree *value)\n+may_replace_final_value (struct ivopts_data *data, struct iv_use *use,\n+\t\t\t tree *value)\n {\n+  struct loop *loop = data->current_loop;\n   edge exit;\n   struct tree_niter_desc *niter;\n \n@@ -3357,10 +3437,9 @@ may_replace_final_value (struct loop *loop, struct iv_use *use, tree *value)\n   gcc_assert (dominated_by_p (CDI_DOMINATORS, exit->src,\n \t\t\t      bb_for_stmt (use->stmt)));\n \n-  niter = &loop_data (loop)->niter;\n-  if (!niter->niter\n-      || !operand_equal_p (niter->assumptions, boolean_true_node, 0)\n-      || !operand_equal_p (niter->may_be_zero, boolean_false_node, 0))\n+  niter = niter_for_single_dom_exit (data);\n+  if (!niter\n+      || !zero_p (niter->may_be_zero))\n     return false;\n \n   *value = iv_value (use->iv, niter->niter);\n@@ -3393,7 +3472,7 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n \n   if (!cand->iv)\n     {\n-      if (!may_replace_final_value (loop, use, &value))\n+      if (!may_replace_final_value (data, use, &value))\n \t{\n \t  set_use_iv_cost (data, use, cand, INFTY, NULL);\n \t  return false;\n@@ -4749,8 +4828,7 @@ rewrite_use_compare (struct ivopts_data *data,\n   block_stmt_iterator bsi = bsi_for_stmt (use->stmt);\n   enum tree_code compare;\n   \n-  if (may_eliminate_iv (data->current_loop,\n-\t\t\tuse, cand, &compare, &bound))\n+  if (may_eliminate_iv (data, use, cand, &compare, &bound))\n     {\n       op = force_gimple_operand (unshare_expr (bound), &stmts,\n \t\t\t\t true, NULL_TREE);\n@@ -4924,7 +5002,7 @@ rewrite_use_outer (struct ivopts_data *data,\n     {\n       if (!cand->iv)\n \t{\n-\t  bool ok = may_replace_final_value (data->current_loop, use, &value);\n+\t  bool ok = may_replace_final_value (data, use, &value);\n \t  gcc_assert (ok);\n \t}\n       else\n@@ -5045,6 +5123,8 @@ free_loop_data (struct ivopts_data *data)\n   unsigned i, j;\n   bitmap_iterator bi;\n \n+  htab_empty (data->niters);\n+\n   EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n     {\n       struct version_info *info;\n@@ -5122,6 +5202,7 @@ tree_ssa_iv_optimize_finalize (struct loops *loops, struct ivopts_data *data)\n   free (data->version_info);\n   BITMAP_XFREE (data->relevant);\n   BITMAP_XFREE (data->important_candidates);\n+  htab_delete (data->niters);\n \n   VARRAY_FREE (decl_rtl_to_reset);\n   VARRAY_FREE (data->iv_uses);\n@@ -5189,8 +5270,6 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   /* Remove the ivs that are unused after rewriting.  */\n   remove_unused_ivs (data);\n \n-  loop_commit_inserts ();\n-\n   /* We have changed the structure of induction variables; it might happen\n      that definitions in the scev database refer to some of them that were\n      eliminated.  */"}, {"sha": "dbbc52d2573e48031d5e18d5f26e40dfeaab8833", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -80,44 +80,6 @@ nonzero_p (tree arg)\n   return (TREE_INT_CST_LOW (arg) != 0 || TREE_INT_CST_HIGH (arg) != 0);\n }\n \n-/* Returns number of zeros at the end of binary representation of X.\n-   \n-   ??? Use ffs if available?  */\n-\n-static tree\n-num_ending_zeros (tree x)\n-{\n-  unsigned HOST_WIDE_INT fr, nfr;\n-  unsigned num, abits;\n-  tree type = TREE_TYPE (x);\n-\n-  if (TREE_INT_CST_LOW (x) == 0)\n-    {\n-      num = HOST_BITS_PER_WIDE_INT;\n-      fr = TREE_INT_CST_HIGH (x);\n-    }\n-  else\n-    {\n-      num = 0;\n-      fr = TREE_INT_CST_LOW (x);\n-    }\n-\n-  for (abits = HOST_BITS_PER_WIDE_INT / 2; abits; abits /= 2)\n-    {\n-      nfr = fr >> abits;\n-      if (nfr << abits == fr)\n-\t{\n-\t  num += abits;\n-\t  fr = nfr;\n-\t}\n-    }\n-\n-  if (num > TYPE_PRECISION (type))\n-    num = TYPE_PRECISION (type);\n-\n-  return build_int_cst_type (type, num);\n-}\n-\n /* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */\n \n static tree\n@@ -823,6 +785,75 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   return integer_onep (niter->assumptions);\n }\n \n+/* Try to determine the number of iterations of LOOP.  If we succeed,\n+   expression giving number of iterations is returned and *EXIT is\n+   set to the edge from that the information is obtained.  Otherwise\n+   chrec_dont_know is returned.  */\n+\n+tree\n+find_loop_niter (struct loop *loop, edge *exit)\n+{\n+  unsigned n_exits, i;\n+  edge *exits = get_loop_exit_edges (loop, &n_exits);\n+  edge ex;\n+  tree niter = NULL_TREE, aniter;\n+  struct tree_niter_desc desc;\n+\n+  *exit = NULL;\n+  for (i = 0; i < n_exits; i++)\n+    {\n+      ex = exits[i];\n+      if (!just_once_each_iteration_p (loop, ex->src))\n+\tcontinue;\n+\n+      if (!number_of_iterations_exit (loop, ex, &desc))\n+\tcontinue;\n+\n+      if (nonzero_p (desc.may_be_zero))\n+\t{\n+\t  /* We exit in the first iteration through this exit.\n+\t     We won't find anything better.  */\n+\t  niter = build_int_cst_type (unsigned_type_node, 0);\n+\t  *exit = ex;\n+\t  break;\n+\t}\n+\n+      if (!zero_p (desc.may_be_zero))\n+\tcontinue;\n+\n+      aniter = desc.niter;\n+\n+      if (!niter)\n+\t{\n+\t  /* Nothing recorded yet.  */\n+\t  niter = aniter;\n+\t  *exit = ex;\n+\t  continue;\n+\t}\n+\n+      /* Prefer constants, the lower the better.  */\n+      if (TREE_CODE (aniter) != INTEGER_CST)\n+\tcontinue;\n+\n+      if (TREE_CODE (niter) != INTEGER_CST)\n+\t{\n+\t  niter = aniter;\n+\t  *exit = ex;\n+\t  continue;\n+\t}\n+\n+      if (tree_int_cst_lt (aniter, niter))\n+\t{\n+\t  niter = aniter;\n+\t  *exit = ex;\n+\t  continue;\n+\t}\n+    }\n+  free (exits);\n+\n+  return niter ? niter : chrec_dont_know;\n+}\n+\n /*\n \n    Analysis of a number of iterations of a loop by a brute-force evaluation.\n@@ -1055,13 +1086,11 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n \tcontinue;\n \n       aniter = loop_niter_by_eval (loop, ex);\n-      if (chrec_contains_undetermined (aniter)\n-\t  || TREE_CODE (aniter) != INTEGER_CST)\n+      if (chrec_contains_undetermined (aniter))\n \tcontinue;\n \n       if (niter\n-\t  && !nonzero_p (fold (build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t     aniter, niter))))\n+\t  && !tree_int_cst_lt (aniter, niter))\n \tcontinue;\n \n       niter = aniter;"}, {"sha": "186594375c791babc9953fedbe0e6a95bf11a664", "filename": "gcc/tree.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -6311,4 +6311,42 @@ operand_equal_for_phi_arg_p (tree arg0, tree arg1)\n   return operand_equal_p (arg0, arg1, 0);\n }\n \n+/* Returns number of zeros at the end of binary representation of X.\n+   \n+   ??? Use ffs if available?  */\n+\n+tree\n+num_ending_zeros (tree x)\n+{\n+  unsigned HOST_WIDE_INT fr, nfr;\n+  unsigned num, abits;\n+  tree type = TREE_TYPE (x);\n+\n+  if (TREE_INT_CST_LOW (x) == 0)\n+    {\n+      num = HOST_BITS_PER_WIDE_INT;\n+      fr = TREE_INT_CST_HIGH (x);\n+    }\n+  else\n+    {\n+      num = 0;\n+      fr = TREE_INT_CST_LOW (x);\n+    }\n+\n+  for (abits = HOST_BITS_PER_WIDE_INT / 2; abits; abits /= 2)\n+    {\n+      nfr = fr >> abits;\n+      if (nfr << abits == fr)\n+\t{\n+\t  num += abits;\n+\t  fr = nfr;\n+\t}\n+    }\n+\n+  if (num > TYPE_PRECISION (type))\n+    num = TYPE_PRECISION (type);\n+\n+  return build_int_cst_type (type, num);\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "4b14d3fdfe3b9b369fd3875b58bbfdd27ad8e8c2", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4c3169913c944780c4c0945c626eb9d47f12ad/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ca4c3169913c944780c4c0945c626eb9d47f12ad", "patch": "@@ -3275,6 +3275,7 @@ extern int integer_nonzerop (tree);\n \n extern bool zero_p (tree);\n extern bool cst_and_fits_in_hwi (tree);\n+extern tree num_ending_zeros (tree);\n \n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  Returns the outermost data.  */"}]}