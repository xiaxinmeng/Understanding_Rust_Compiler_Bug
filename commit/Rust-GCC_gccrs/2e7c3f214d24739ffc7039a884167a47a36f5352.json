{"sha": "2e7c3f214d24739ffc7039a884167a47a36f5352", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU3YzNmMjE0ZDI0NzM5ZmZjNzAzOWE4ODQxNjdhNDdhMzZmNTM1Mg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2013-09-17T21:00:59Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2013-09-17T21:00:59Z"}, "message": "constraints.md: For each W* constraint...\n\n* config/rl78/constraints.md: For each W* constraint, rename to C*\nand create a W* constraint that checks for an optional ES: prefix\npattern also.\n* config/rl78/rl78.md (UNS_ES_ADDR): New.\n(es_addr): New.  Used to wrap far addresses.\n* config/rl78/rl78-protos.h (rl78_es_addr): New.\n(rl78_es_base): New.\n* config/rl78/rl78.c (rl78_as_legitimate_address): Accept \"unspec\"\nwrapped far addresses.\n(rl78_print_operand_1): Unwrap far addresses before processing.\n(rl78_lo16): Wrap far addresses in unspecs.\n(rl78_es_addr): New.\n(rl78_es_base): New.\n(insn_ok_now): Check for not-yet-wrapped far addresses.\n(transcode_memory_rtx): Properly re-wrap far addresses.\n\nFrom-SVN: r202666", "tree": {"sha": "af3806e18b02ddc8be01b2dade06dd0e006ea385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af3806e18b02ddc8be01b2dade06dd0e006ea385"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e7c3f214d24739ffc7039a884167a47a36f5352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7c3f214d24739ffc7039a884167a47a36f5352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7c3f214d24739ffc7039a884167a47a36f5352", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7c3f214d24739ffc7039a884167a47a36f5352/comments", "author": null, "committer": null, "parents": [{"sha": "5c26a69a2a9a4c4c6280e7d21d6e48f64b11cf75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c26a69a2a9a4c4c6280e7d21d6e48f64b11cf75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c26a69a2a9a4c4c6280e7d21d6e48f64b11cf75"}], "stats": {"total": 168, "additions": 151, "deletions": 17}, "files": [{"sha": "2b0d211faf60b14a9760ce05833ac15a815bc814", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e7c3f214d24739ffc7039a884167a47a36f5352", "patch": "@@ -1,3 +1,21 @@\n+2013-09-17  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/rl78/constraints.md: For each W* constraint, rename to C*\n+\tand create a W* constraint that checks for an optional ES: prefix\n+\tpattern also.\n+\t* config/rl78/rl78.md (UNS_ES_ADDR): New.\n+\t(es_addr): New.  Used to wrap far addresses.\n+\t* config/rl78/rl78-protos.h (rl78_es_addr): New.\n+\t(rl78_es_base): New.\n+\t* config/rl78/rl78.c (rl78_as_legitimate_address): Accept \"unspec\"\n+\twrapped far addresses.\n+\t(rl78_print_operand_1): Unwrap far addresses before processing.\n+\t(rl78_lo16): Wrap far addresses in unspecs.\n+\t(rl78_es_addr): New.\n+\t(rl78_es_base): New.\n+\t(insn_ok_now): Check for not-yet-wrapped far addresses.\n+\t(transcode_memory_rtx): Properly re-wrap far addresses.\n+\n 2013-09-17  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* config/sparc/t-rtems: Add leon3 multilibs."}, {"sha": "2c5ffd8419d4cc804da85a4f13e07b5a6e1f3023", "filename": "gcc/config/rl78/constraints.md", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fconstraints.md?ref=2e7c3f214d24739ffc7039a884167a47a36f5352", "patch": "@@ -203,17 +203,24 @@\n ; All the memory addressing schemes the RL78 supports\n ; of the form W {register} {bytes of offset}\n ;          or W {register} {register}\n+; Additionally, the Cxx forms are the same as the Wxx forms, but without\n+; the ES: override.\n \n ; absolute address\n-(define_memory_constraint \"Wab\"\n+(define_memory_constraint \"Cab\"\n   \"[addr]\"\n   (and (match_code \"mem\")\n        (ior (match_test \"CONSTANT_P (XEXP (op, 0))\")\n \t    (match_test \"GET_CODE (XEXP (op, 0)) == PLUS && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\"))\n \t    )\n   )\n+(define_memory_constraint \"Wab\"\n+  \"es:[addr]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cab (rl78_es_base (op))\n+               || satisfies_constraint_Cab (op)\")\n+  )\n \n-(define_memory_constraint \"Wbc\"\n+(define_memory_constraint \"Cbc\"\n   \"word16[BC]\"\n   (and (match_code \"mem\")\n        (ior\n@@ -225,29 +232,49 @@\n \t\t       (match_test \"uword_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n        )\n   )\n+(define_memory_constraint \"Wbc\"\n+  \"es:word16[BC]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cbc (rl78_es_base (op))\n+               || satisfies_constraint_Cbc (op)\")\n+  )\n \n-(define_memory_constraint \"Wde\"\n+(define_memory_constraint \"Cde\"\n   \"[DE]\"\n   (and (match_code \"mem\")\n        (and (match_code \"reg\" \"0\")\n \t    (match_test \"REGNO (XEXP (op, 0)) == DE_REG\")))\n   )\n+(define_memory_constraint \"Wde\"\n+  \"es:[DE]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cde (rl78_es_base (op))\n+               || satisfies_constraint_Cde (op)\")\n+  )\n \n-(define_memory_constraint \"Wca\"\n+(define_memory_constraint \"Cca\"\n   \"[AX..HL] for calls\"\n   (and (match_code \"mem\")\n        (and (match_code \"reg\" \"0\")\n \t    (match_test \"REGNO (XEXP (op, 0)) <= HL_REG\")))\n   )\n+(define_memory_constraint \"Wca\"\n+  \"es:[AX..HL] for calls\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cca (rl78_es_base (op))\n+               || satisfies_constraint_Cca (op)\")\n+  )\n \n-(define_memory_constraint \"Wcv\"\n+(define_memory_constraint \"Ccv\"\n   \"[AX..HL,r8-r23] for calls\"\n   (and (match_code \"mem\")\n        (and (match_code \"reg\" \"0\")\n \t    (match_test \"REGNO (XEXP (op, 0)) < 24\")))\n   )\n+(define_memory_constraint \"Wcv\"\n+  \"es:[AX..HL,r8-r23] for calls\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Ccv (rl78_es_base (op))\n+               || satisfies_constraint_Ccv (op)\")\n+  )\n \n-(define_memory_constraint \"Wd2\"\n+(define_memory_constraint \"Cd2\"\n   \"word16[DE]\"\n   (and (match_code \"mem\")\n        (ior\n@@ -259,30 +286,50 @@\n \t\t       (match_test \"uword_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n        )\n   )\n+(define_memory_constraint \"Wd2\"\n+  \"es:word16[DE]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cd2 (rl78_es_base (op))\n+               || satisfies_constraint_Cd2 (op)\")\n+  )\n \n-(define_memory_constraint \"Whl\"\n+(define_memory_constraint \"Chl\"\n   \"[HL]\"\n   (and (match_code \"mem\")\n        (and (match_code \"reg\" \"0\")\n \t    (match_test \"REGNO (XEXP (op, 0)) == HL_REG\")))\n   )\n+(define_memory_constraint \"Whl\"\n+  \"es:[HL]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Chl (rl78_es_base (op))\n+               || satisfies_constraint_Chl (op)\")\n+  )\n \n-(define_memory_constraint \"Wh1\"\n+(define_memory_constraint \"Ch1\"\n   \"byte8[HL]\"\n   (and (match_code \"mem\")\n        (and (match_code \"plus\" \"0\")\n \t    (and (and (match_code \"reg\" \"00\")\n \t\t      (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == HL_REG\"))\n \t\t      (match_test \"ubyte_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n   )\n+(define_memory_constraint \"Wh1\"\n+  \"es:byte8[HL]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Ch1 (rl78_es_base (op))\n+               || satisfies_constraint_Ch1 (op)\")\n+  )\n \n-(define_memory_constraint \"Whb\"\n+(define_memory_constraint \"Chb\"\n   \"[HL+B]\"\n   (and (match_code \"mem\")\n        (match_test \"rl78_hl_b_c_addr_p (XEXP (op, 0))\"))\n   )\n+(define_memory_constraint \"Whb\"\n+  \"es:[HL+B]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Chb (rl78_es_base (op))\n+               || satisfies_constraint_Chb (op)\")\n+  )\n \n-(define_memory_constraint \"Ws1\"\n+(define_memory_constraint \"Cs1\"\n   \"word8[SP]\"\n   (and (match_code \"mem\")\n        (ior\n@@ -294,6 +341,11 @@\n \t\t       (match_test \"ubyte_operand (XEXP (XEXP (op, 0), 1), VOIDmode)\"))))\n        )\n   )\n+(define_memory_constraint \"Ws1\"\n+  \"es:word8[SP]\"\n+  (match_test \"rl78_es_addr (op) && satisfies_constraint_Cs1 (rl78_es_base (op))\n+               || satisfies_constraint_Cs1 (op)\")\n+  )\n \n (define_memory_constraint \"Wfr\"\n   \"ES/CS far pointer\""}, {"sha": "1f30e637b729e5cf76e3286d9428b6f582df712a", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=2e7c3f214d24739ffc7039a884167a47a36f5352", "patch": "@@ -42,3 +42,6 @@ void\t\trl78_register_pragmas (void);\n bool\t\trl78_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, int, int);\n void\t\trl78_setup_peep_movhi (rtx *);\n bool\t\trl78_virt_insns_ok (void);\n+\n+bool\t\trl78_es_addr (rtx);\n+rtx\t\trl78_es_base (rtx);"}, {"sha": "e7bd3deac7d59d8205021526c82e3530e4b0e514", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=2e7c3f214d24739ffc7039a884167a47a36f5352", "patch": "@@ -858,6 +858,10 @@ rl78_as_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n {\n   rtx base, index, addend;\n \n+  if (GET_CODE (x) == UNSPEC\n+      && XINT (x, 1) == UNS_ES_ADDR)\n+    x = XVECEXP (x, 0, 1);\n+\n   if (as == ADDR_SPACE_GENERIC\n       && GET_MODE (x) == SImode)\n     return false;\n@@ -1290,7 +1294,10 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n       else\n \t{\n \t  if (rl78_far_p (op))\n-\t    fprintf (file, \"es:\");\n+\t    {\n+\t      fprintf (file, \"es:\");\n+\t      op = gen_rtx_MEM (GET_MODE (op), XVECEXP (XEXP (op, 0), 0, 1));\n+\t    }\n \t  if (letter == 'H')\n \t    {\n \t      op = adjust_address (op, HImode, 2);\n@@ -1847,6 +1854,8 @@ re-run regmove, but that has not yet been attempted.\n  */\n #define DEBUG_ALLOC 0\n \n+#define OP(x) (*recog_data.operand_loc[x])\n+\n /* This array is used to hold knowledge about the contents of the\n    real registers (A ... H), the memory-based registers (r8 ... r31)\n    and the first NUM_STACK_LOCS words on the stack.  We use this to\n@@ -2072,13 +2081,39 @@ already_contains (rtx loc, rtx value)\n   return true;\n }\n \n+bool\n+rl78_es_addr (rtx addr)\n+{\n+  if (GET_CODE (addr) == MEM)\n+    addr = XEXP (addr, 0);\n+  if (GET_CODE (addr) != UNSPEC)\n+    return false;\n+  if (XINT (addr, 1) != UNS_ES_ADDR)\n+    return false;\n+  return true;\n+}\n+\n+rtx\n+rl78_es_base (rtx addr)\n+{\n+  if (GET_CODE (addr) == MEM)\n+    addr = XEXP (addr, 0);\n+  addr = XVECEXP (addr, 0, 1);\n+  if (GET_CODE (addr) == CONST\n+      && GET_CODE (XEXP (addr, 0)) == ZERO_EXTRACT)\n+    addr = XEXP (XEXP (addr, 0), 0);\n+  /* Mode doesn't matter here.  */\n+  return gen_rtx_MEM (HImode, addr);\n+}\n+\n /* Rescans an insn to see if it's recognized again.  This is done\n    carefully to ensure that all the constraint information is accurate\n    for the newly matched insn.  */\n static bool\n insn_ok_now (rtx insn)\n {\n   rtx pattern = PATTERN (insn);\n+  int i;\n \n   INSN_CODE (insn) = -1;\n \n@@ -2095,6 +2130,14 @@ insn_ok_now (rtx insn)\n \t  if (SET_P (pattern))\n \t    record_content (SET_DEST (pattern), SET_SRC (pattern));\n \n+\t  /* We need to detect far addresses that haven't been\n+\t     converted to es/lo16 format.  */\n+\t  for (i=0; i<recog_data.n_operands; i++)\n+\t    if (GET_CODE (OP(i)) == MEM\n+\t\t&& GET_MODE (XEXP (OP(i), 0)) == SImode\n+\t\t&& GET_CODE (XEXP (OP(i), 0)) != UNSPEC)\n+\t      return false;\n+\n \t  return true;\n \t}\n     }\n@@ -2155,8 +2198,6 @@ insn_ok_now (rtx insn)\n #define DE gen_rtx_REG (HImode, 4)\n #define HL gen_rtx_REG (HImode, 6)\n \n-#define OP(x) (*recog_data.operand_loc[x])\n-\n /* Returns TRUE if R is a virtual register.  */\n static bool\n is_virtual_register (rtx r)\n@@ -2195,14 +2236,20 @@ EM2 (int line ATTRIBUTE_UNUSED, rtx r)\n static rtx\n rl78_lo16 (rtx addr)\n {\n+  rtx r;\n+\n   if (GET_CODE (addr) == SYMBOL_REF\n       || GET_CODE (addr) == CONST)\n     {\n-      rtx r = gen_rtx_ZERO_EXTRACT (HImode, addr, GEN_INT (16), GEN_INT (0));\n+      r = gen_rtx_ZERO_EXTRACT (HImode, addr, GEN_INT (16), GEN_INT (0));\n       r = gen_rtx_CONST (HImode, r);\n-      return r;\n     }\n-  return rl78_subreg (HImode, addr, SImode, 0);\n+  else\n+    r = rl78_subreg (HImode, addr, SImode, 0);\n+\n+  r = gen_es_addr (r);\n+\n+  return r;\n }\n \n /* Return a suitable RTX for the high half's lower byte of a __far address.  */\n@@ -2306,6 +2353,7 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n {\n   rtx base, index, addendr;\n   int addend = 0;\n+  int need_es = 0;\n \n   if (! MEM_P (m))\n     return m;\n@@ -2322,6 +2370,7 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n       record_content (A, NULL_RTX);\n \n       m = change_address (m, GET_MODE (m), rl78_lo16 (XEXP (m, 0)));\n+      need_es = 1;\n     }\n \n   characterize_address (XEXP (m, 0), & base, & index, & addendr);\n@@ -2381,7 +2430,10 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n   fprintf (stderr, \"\\033[33m\");\n   debug_rtx (m);\n #endif\n-  m = change_address (m, GET_MODE (m), base);\n+  if (need_es)\n+    m = change_address (m, GET_MODE (m), gen_es_addr (base));\n+  else\n+    m = change_address (m, GET_MODE (m), base);\n #if DEBUG_ALLOC\n   debug_rtx (m);\n   fprintf (stderr, \"\\033[0m\");"}, {"sha": "e1cbbb03eae74aaa8f59c81ab343f4fad9114b30", "filename": "gcc/config/rl78/rl78.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Frl78.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7c3f214d24739ffc7039a884167a47a36f5352/gcc%2Fconfig%2Frl78%2Frl78.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.md?ref=2e7c3f214d24739ffc7039a884167a47a36f5352", "patch": "@@ -45,6 +45,7 @@\n    (UNS_RETB\t3)\n \n    (UNS_SET_RB\t10)\n+   (UNS_ES_ADDR\t11)\n \n    (UNS_TRAMPOLINE_INIT\t\t20)\n    (UNS_TRAMPOLINE_UNINIT\t21)\n@@ -432,3 +433,11 @@\n \t; end of mulsi macro\"\n   [(set_attr \"valloc\" \"macax\")]\n   )\n+\n+(define_expand \"es_addr\"\n+  [(unspec:SI [(reg:QI ES_REG)\n+\t       (match_operand:HI 0 \"\" \"\")\n+\t       ] UNS_ES_ADDR)]\n+  \"\"\n+  \"\"\n+)"}]}