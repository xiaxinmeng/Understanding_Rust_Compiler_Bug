{"sha": "c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIwM2U4YTczYjJmMTJhMWRhNTJhMTZhMGM0YTUwZTYyYjQyNDQ1Yg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-06-24T13:21:35Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-06-24T13:21:35Z"}, "message": "Remove a layer of indirection from hash_table\n\ngcc/\n\n\t* hash-table.h: Remove a layer of indirection from hash_table so that\n\tit contains the hash table's data instead of a pointer to the data.\n\t* alloc-pool.c, asan.c, attribs.c, bitmap.c, cfg.c,\n\tconfig/arm/arm.c, config/i386/winnt.c, config/ia64/ia64.c,\n\tconfig/mips/mips.c, config/sol2.c, coverage.c, cselib.c,\n\tdata-streamer-out.c, dse.c, dwarf2cfi.c, dwarf2out.c, except.c,\n\tfold-const.c, gcse.c, ggc-common.c,\n\tgimple-ssa-strength-reduction.c, gimplify.c,\n\tgraphite-clast-to-gimple.c, graphite-dependences.c,\n\tgraphite-htab.h, graphite.c, haifa-sched.c, ipa-devirt.c,\n\tipa-profile.c, ira-color.c, ira-costs.c, loop-invariant.c,\n\tloop-iv.c, loop-unroll.c, lto-streamer-in.c, lto-streamer-out.c,\n\tlto-streamer.c, lto-streamer.h, passes.c, plugin.c,\n\tpostreload-gcse.c, sese.c, statistics.c, store-motion.c,\n\ttrans-mem.c, tree-browser.c, tree-cfg.c, tree-complex.c,\n\ttree-eh.c, tree-into-ssa.c, tree-parloops.c, tree-sra.c,\n\ttree-ssa-ccp.c, tree-ssa-coalesce.c, tree-ssa-dom.c,\n\ttree-ssa-live.c, tree-ssa-loop-im.c,\n\ttree-ssa-loop-ivopts.c, tree-ssa-phiopt.c, tree-ssa-pre.c,\n\ttree-ssa-reassoc.c, tree-ssa-sccvn.c, tree-ssa-strlen.c,\n\ttree-ssa-structalias.c, tree-ssa-tail-merge.c,\n\ttree-ssa-threadupdate.c, tree-ssa-uncprop.c,\ntree-vect-data-refs.c, tree-vect-loop.c, tree-vectorizer.c,\ntree-vectorizer.h, valtrack.c, valtrack.h, var-tracking.c,\nvtable-verify.c, vtable-verify.h: Adjust.\n\ngcc/c/\n\n\t* c-decl.c: Adjust.\n\ngcc/cp/\n\n\t* class.c, semantics.c, tree.c, vtable-class-hierarchy.c:\n\tAdjust.\n\ngcc/java/\n\n\t* jcf-io.c: Adjust.\n\ngcc/lto/\n\n\t* lto.c: Adjust.\n\ngcc/objc/\n\n\t* objc-act.c: Adjust.\n\nFrom-SVN: r211936", "tree": {"sha": "b8d7f5b21a14b16949ddbc5dcaeb5f2b2654d63a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d7f5b21a14b16949ddbc5dcaeb5f2b2654d63a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/comments", "author": null, "committer": null, "parents": [{"sha": "fbc2a724d481bb5c205baeaaa955533451226d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc2a724d481bb5c205baeaaa955533451226d01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc2a724d481bb5c205baeaaa955533451226d01"}], "stats": {"total": 2867, "additions": 1361, "deletions": 1506}, "files": [{"sha": "ca591a663050283fd1077b7f24ba38c1d257da5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1,3 +1,31 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-table.h: Remove a layer of indirection from hash_table so that\n+\tit contains the hash table's data instead of a pointer to the data.\n+\t* alloc-pool.c, asan.c, attribs.c, bitmap.c, cfg.c,\n+\tconfig/arm/arm.c, config/i386/winnt.c, config/ia64/ia64.c,\n+\tconfig/mips/mips.c, config/sol2.c, coverage.c, cselib.c,\n+\tdata-streamer-out.c, dse.c, dwarf2cfi.c, dwarf2out.c, except.c,\n+\tfold-const.c, gcse.c, ggc-common.c,\n+\tgimple-ssa-strength-reduction.c, gimplify.c,\n+\tgraphite-clast-to-gimple.c, graphite-dependences.c,\n+\tgraphite-htab.h, graphite.c, haifa-sched.c, ipa-devirt.c,\n+\tipa-profile.c, ira-color.c, ira-costs.c, loop-invariant.c,\n+\tloop-iv.c, loop-unroll.c, lto-streamer-in.c, lto-streamer-out.c,\n+\tlto-streamer.c, lto-streamer.h, passes.c, plugin.c,\n+\tpostreload-gcse.c, sese.c, statistics.c, store-motion.c,\n+\ttrans-mem.c, tree-browser.c, tree-cfg.c, tree-complex.c,\n+\ttree-eh.c, tree-into-ssa.c, tree-parloops.c, tree-sra.c,\n+\ttree-ssa-ccp.c, tree-ssa-coalesce.c, tree-ssa-dom.c,\n+\ttree-ssa-live.c, tree-ssa-loop-im.c,\n+\ttree-ssa-loop-ivopts.c, tree-ssa-phiopt.c, tree-ssa-pre.c,\n+\ttree-ssa-reassoc.c, tree-ssa-sccvn.c, tree-ssa-strlen.c,\n+\ttree-ssa-structalias.c, tree-ssa-tail-merge.c,\n+\ttree-ssa-threadupdate.c, tree-ssa-uncprop.c,\n+tree-vect-data-refs.c, tree-vect-loop.c, tree-vectorizer.c,\n+tree-vectorizer.h, valtrack.c, valtrack.h, var-tracking.c,\n+vtable-verify.c, vtable-verify.h: Adjust.\n+\n 2014-06-24  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/61572"}, {"sha": "49209ee68459c512760620f178b5aa8edfb62d5e", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -105,19 +105,20 @@ alloc_pool_hasher::equal (const value_type *d,\n }\n \n /* Hashtable mapping alloc_pool names to descriptors.  */\n-static hash_table <alloc_pool_hasher>  alloc_pool_hash;\n+static hash_table<alloc_pool_hasher> *alloc_pool_hash;\n \n /* For given name, return descriptor, create new if needed.  */\n static struct alloc_pool_descriptor *\n allocate_pool_descriptor (const char *name)\n {\n   struct alloc_pool_descriptor **slot;\n \n-  if (!alloc_pool_hash.is_created ())\n-    alloc_pool_hash.create (10);\n+  if (!alloc_pool_hash)\n+    alloc_pool_hash = new hash_table<alloc_pool_hasher> (10);\n \n-  slot = alloc_pool_hash.find_slot_with_hash (name,\n-\t\t\t\t\t      htab_hash_pointer (name), INSERT);\n+  slot = alloc_pool_hash->find_slot_with_hash (name,\n+\t\t\t\t\t       htab_hash_pointer (name),\n+\t\t\t\t\t       INSERT);\n   if (*slot)\n     return *slot;\n   *slot = XCNEW (struct alloc_pool_descriptor);\n@@ -404,15 +405,15 @@ dump_alloc_pool_statistics (void)\n   if (! GATHER_STATISTICS)\n     return;\n \n-  if (!alloc_pool_hash.is_created ())\n+  if (!alloc_pool_hash)\n     return;\n \n   fprintf (stderr, \"\\nAlloc-pool Kind         Elt size  Pools  Allocated (elts)            Peak (elts)            Leak (elts)\\n\");\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n   info.total_created = 0;\n   info.total_allocated = 0;\n-  alloc_pool_hash.traverse <struct output_info *,\n-\t\t\t    print_alloc_pool_statistics> (&info);\n+  alloc_pool_hash->traverse <struct output_info *,\n+\t\t\t     print_alloc_pool_statistics> (&info);\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n   fprintf (stderr, \"%-22s           %7lu %10lu\\n\",\n \t   \"Total\", info.total_created, info.total_allocated);"}, {"sha": "9eeafa897cf6fec156f0ccc454b7a5aea87a8398", "filename": "gcc/asan.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -363,18 +363,18 @@ asan_mem_ref_hasher::equal (const asan_mem_ref *m1,\n \t  && operand_equal_p (m1->start, m2->start, 0));\n }\n \n-static hash_table <asan_mem_ref_hasher> asan_mem_ref_ht;\n+static hash_table<asan_mem_ref_hasher> *asan_mem_ref_ht;\n \n /* Returns a reference to the hash table containing memory references.\n    This function ensures that the hash table is created.  Note that\n    this hash table is updated by the function\n    update_mem_ref_hash_table.  */\n \n-static hash_table <asan_mem_ref_hasher> &\n+static hash_table<asan_mem_ref_hasher> *\n get_mem_ref_hash_table ()\n {\n-  if (!asan_mem_ref_ht.is_created ())\n-    asan_mem_ref_ht.create (10);\n+  if (!asan_mem_ref_ht)\n+    asan_mem_ref_ht = new hash_table<asan_mem_ref_hasher> (10);\n \n   return asan_mem_ref_ht;\n }\n@@ -384,17 +384,17 @@ get_mem_ref_hash_table ()\n static void\n empty_mem_ref_hash_table ()\n {\n-  if (asan_mem_ref_ht.is_created ())\n-    asan_mem_ref_ht.empty ();\n+  if (asan_mem_ref_ht)\n+    asan_mem_ref_ht->empty ();\n }\n \n /* Free the memory references hash table.  */\n \n static void\n free_mem_ref_resources ()\n {\n-  if (asan_mem_ref_ht.is_created ())\n-    asan_mem_ref_ht.dispose ();\n+  delete asan_mem_ref_ht;\n+  asan_mem_ref_ht = NULL;\n \n   if (asan_mem_ref_alloc_pool)\n     {\n@@ -411,7 +411,7 @@ has_mem_ref_been_instrumented (tree ref, HOST_WIDE_INT access_size)\n   asan_mem_ref r;\n   asan_mem_ref_init (&r, ref, access_size);\n \n-  return (get_mem_ref_hash_table ().find (&r) != NULL);\n+  return (get_mem_ref_hash_table ()->find (&r) != NULL);\n }\n \n /* Return true iff the memory reference REF has been instrumented.  */\n@@ -858,12 +858,12 @@ has_stmt_been_instrumented_p (gimple stmt)\n static void\n update_mem_ref_hash_table (tree ref, HOST_WIDE_INT access_size)\n {\n-  hash_table <asan_mem_ref_hasher> ht = get_mem_ref_hash_table ();\n+  hash_table<asan_mem_ref_hasher> *ht = get_mem_ref_hash_table ();\n \n   asan_mem_ref r;\n   asan_mem_ref_init (&r, ref, access_size);\n \n-  asan_mem_ref **slot = ht.find_slot (&r, INSERT);\n+  asan_mem_ref **slot = ht->find_slot (&r, INSERT);\n   if (*slot == NULL)\n     *slot = asan_mem_ref_new (ref, access_size);\n }"}, {"sha": "427a0f63f3d459c3d75841581ca366dadc9e198a", "filename": "gcc/attribs.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -85,7 +85,7 @@ struct scoped_attributes\n {\n   const char *ns;\n   vec<attribute_spec> attributes;\n-  hash_table <attribute_hasher> attribute_hash;\n+  hash_table<attribute_hasher> *attribute_hash;\n };\n \n /* The table of scope attributes.  */\n@@ -144,7 +144,7 @@ register_scoped_attributes (const struct attribute_spec * attributes,\n       sa.ns = ns;\n       sa.attributes.create (64);\n       result = attributes_table.safe_push (sa);\n-      result->attribute_hash.create (200);\n+      result->attribute_hash = new hash_table<attribute_hasher> (200);\n     }\n \n   /* Really add the attributes to their namespace now.  */\n@@ -281,7 +281,7 @@ register_scoped_attribute (const struct attribute_spec *attr,\n \n   gcc_assert (attr != NULL && name_space != NULL);\n \n-  gcc_assert (name_space->attribute_hash.is_created ());\n+  gcc_assert (name_space->attribute_hash);\n \n   str.str = attr->name;\n   str.length = strlen (str.str);\n@@ -291,8 +291,8 @@ register_scoped_attribute (const struct attribute_spec *attr,\n   gcc_assert (str.length > 0 && str.str[0] != '_');\n \n   slot = name_space->attribute_hash\n-\t .find_slot_with_hash (&str, substring_hash (str.str, str.length),\n-\t\t\t       INSERT);\n+\t ->find_slot_with_hash (&str, substring_hash (str.str, str.length),\n+\t\t\t\tINSERT);\n   gcc_assert (!*slot || attr->name[0] == '*');\n   *slot = CONST_CAST (struct attribute_spec *, attr);\n }\n@@ -316,8 +316,9 @@ lookup_scoped_attribute_spec (const_tree ns, const_tree name)\n   attr.str = IDENTIFIER_POINTER (name);\n   attr.length = IDENTIFIER_LENGTH (name);\n   extract_attribute_substring (&attr);\n-  return attrs->attribute_hash.find_with_hash (&attr,\n-\t\t\t substring_hash (attr.str, attr.length));\n+  return attrs->attribute_hash->find_with_hash (&attr,\n+\t\t\t\t\t\tsubstring_hash (attr.str,\n+\t\t\t\t\t\t\t       \tattr.length));\n }\n \n /* Return the spec for the attribute named NAME.  If NAME is a TREE_LIST,"}, {"sha": "5f342d4666beaa4fae15ea951791eb5479af0038", "filename": "gcc/bitmap.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -80,7 +80,7 @@ bitmap_desc_hasher::equal (const value_type *d, const compare_type *l)\n }\n \n /* Hashtable mapping bitmap names to descriptors.  */\n-static hash_table <bitmap_desc_hasher> bitmap_desc_hash;\n+static hash_table<bitmap_desc_hasher> *bitmap_desc_hash;\n \n /* For given file and line, return descriptor, create new if needed.  */\n static bitmap_descriptor\n@@ -93,12 +93,13 @@ get_bitmap_descriptor (const char *file, int line, const char *function)\n   loc.function = function;\n   loc.line = line;\n \n-  if (!bitmap_desc_hash.is_created ())\n-    bitmap_desc_hash.create (10);\n+  if (!bitmap_desc_hash)\n+    bitmap_desc_hash = new hash_table<bitmap_desc_hasher> (10);\n \n-  slot = bitmap_desc_hash.find_slot_with_hash (&loc,\n-\t\t\t\t\t       htab_hash_pointer (file) + line,\n-\t\t\t\t\t       INSERT);\n+  slot\n+    = bitmap_desc_hash->find_slot_with_hash (&loc,\n+\t\t\t\t\t     htab_hash_pointer (file) + line,\n+\t\t\t\t\t     INSERT);\n   if (*slot)\n     return *slot;\n \n@@ -2185,7 +2186,7 @@ dump_bitmap_statistics (void)\n   if (! GATHER_STATISTICS)\n     return;\n \n-  if (!bitmap_desc_hash.is_created ())\n+  if (!bitmap_desc_hash)\n     return;\n \n   fprintf (stderr,\n@@ -2196,7 +2197,7 @@ dump_bitmap_statistics (void)\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n   info.count = 0;\n   info.size = 0;\n-  bitmap_desc_hash.traverse <output_info *, print_statistics> (&info);\n+  bitmap_desc_hash->traverse <output_info *, print_statistics> (&info);\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n   fprintf (stderr,\n \t   \"%-41s %9\"PRId64\" %15\"PRId64\"\\n\","}, {"sha": "4ab71603c5deae3d829820507a3e9655fb8c9b4f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1,3 +1,7 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* c-decl.c: Adjust.\n+\n 2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-parser.c (c_parser_omp_for_loop): For"}, {"sha": "def10a2e2de6e0a773420bb9d9f00418d3fa79ed", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -7076,15 +7076,15 @@ is_duplicate_field (tree x, tree y)\n \n static void\n detect_field_duplicates_hash (tree fieldlist,\n-\t\t\t      hash_table <pointer_hash <tree_node> > htab)\n+\t\t\t      hash_table<pointer_hash <tree_node> > *htab)\n {\n   tree x, y;\n   tree_node **slot;\n \n   for (x = fieldlist; x ; x = DECL_CHAIN (x))\n     if ((y = DECL_NAME (x)) != 0)\n       {\n-\tslot = htab.find_slot (y, INSERT);\n+\tslot = htab->find_slot (y, INSERT);\n \tif (*slot)\n \t  {\n \t    error (\"duplicate member %q+D\", x);\n@@ -7104,7 +7104,7 @@ detect_field_duplicates_hash (tree fieldlist,\n \t    && TREE_CODE (TYPE_NAME (TREE_TYPE (x))) == TYPE_DECL)\n \t  {\n \t    tree xn = DECL_NAME (TYPE_NAME (TREE_TYPE (x)));\n-\t    slot = htab.find_slot (xn, INSERT);\n+\t    slot = htab->find_slot (xn, INSERT);\n \t    if (*slot)\n \t      error (\"duplicate member %q+D\", TYPE_NAME (TREE_TYPE (x)));\n \t    *slot = xn;\n@@ -7176,11 +7176,8 @@ detect_field_duplicates (tree fieldlist)\n     }\n   else\n     {\n-      hash_table <pointer_hash <tree_node> > htab;\n-      htab.create (37);\n-\n-      detect_field_duplicates_hash (fieldlist, htab);\n-      htab.dispose ();\n+      hash_table<pointer_hash <tree_node> > htab (37);\n+      detect_field_duplicates_hash (fieldlist, &htab);\n     }\n }\n "}, {"sha": "6070d9ed2205cc0dcc858a559e07535b395ef144", "filename": "gcc/cfg.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1038,11 +1038,11 @@ bb_copy_hasher::equal (const value_type *data, const compare_type *data2)\n \n /* Data structures used to maintain mapping between basic blocks and\n    copies.  */\n-static hash_table <bb_copy_hasher> bb_original;\n-static hash_table <bb_copy_hasher> bb_copy;\n+static hash_table<bb_copy_hasher> *bb_original;\n+static hash_table<bb_copy_hasher> *bb_copy;\n \n /* And between loops and copies.  */\n-static hash_table <bb_copy_hasher> loop_copy;\n+static hash_table<bb_copy_hasher> *loop_copy;\n static alloc_pool original_copy_bb_pool;\n \n \n@@ -1055,9 +1055,9 @@ initialize_original_copy_tables (void)\n   original_copy_bb_pool\n     = create_alloc_pool (\"original_copy\",\n \t\t\t sizeof (struct htab_bb_copy_original_entry), 10);\n-  bb_original.create (10);\n-  bb_copy.create (10);\n-  loop_copy.create (10);\n+  bb_original = new hash_table<bb_copy_hasher> (10);\n+  bb_copy = new hash_table<bb_copy_hasher> (10);\n+  loop_copy = new hash_table<bb_copy_hasher> (10);\n }\n \n /* Free the data structures to maintain mapping between blocks and\n@@ -1066,17 +1066,20 @@ void\n free_original_copy_tables (void)\n {\n   gcc_assert (original_copy_bb_pool);\n-  bb_copy.dispose ();\n-  bb_original.dispose ();\n-  loop_copy.dispose ();\n+  delete bb_copy;\n+  bb_copy = NULL;\n+  delete bb_original;\n+  bb_copy = NULL;\n+  delete loop_copy;\n+  loop_copy = NULL;\n   free_alloc_pool (original_copy_bb_pool);\n   original_copy_bb_pool = NULL;\n }\n \n /* Removes the value associated with OBJ from table TAB.  */\n \n static void\n-copy_original_table_clear (hash_table <bb_copy_hasher> tab, unsigned obj)\n+copy_original_table_clear (hash_table<bb_copy_hasher> *tab, unsigned obj)\n {\n   htab_bb_copy_original_entry **slot;\n   struct htab_bb_copy_original_entry key, *elt;\n@@ -1085,20 +1088,20 @@ copy_original_table_clear (hash_table <bb_copy_hasher> tab, unsigned obj)\n     return;\n \n   key.index1 = obj;\n-  slot = tab.find_slot (&key, NO_INSERT);\n+  slot = tab->find_slot (&key, NO_INSERT);\n   if (!slot)\n     return;\n \n   elt = *slot;\n-  tab.clear_slot (slot);\n+  tab->clear_slot (slot);\n   pool_free (original_copy_bb_pool, elt);\n }\n \n /* Sets the value associated with OBJ in table TAB to VAL.\n    Do nothing when data structures are not initialized.  */\n \n static void\n-copy_original_table_set (hash_table <bb_copy_hasher> tab,\n+copy_original_table_set (hash_table<bb_copy_hasher> *tab,\n \t\t\t unsigned obj, unsigned val)\n {\n   struct htab_bb_copy_original_entry **slot;\n@@ -1108,7 +1111,7 @@ copy_original_table_set (hash_table <bb_copy_hasher> tab,\n     return;\n \n   key.index1 = obj;\n-  slot = tab.find_slot (&key, INSERT);\n+  slot = tab->find_slot (&key, INSERT);\n   if (!*slot)\n     {\n       *slot = (struct htab_bb_copy_original_entry *)\n@@ -1136,7 +1139,7 @@ get_bb_original (basic_block bb)\n   gcc_assert (original_copy_bb_pool);\n \n   key.index1 = bb->index;\n-  entry = bb_original.find (&key);\n+  entry = bb_original->find (&key);\n   if (entry)\n     return BASIC_BLOCK_FOR_FN (cfun, entry->index2);\n   else\n@@ -1161,7 +1164,7 @@ get_bb_copy (basic_block bb)\n   gcc_assert (original_copy_bb_pool);\n \n   key.index1 = bb->index;\n-  entry = bb_copy.find (&key);\n+  entry = bb_copy->find (&key);\n   if (entry)\n     return BASIC_BLOCK_FOR_FN (cfun, entry->index2);\n   else\n@@ -1191,7 +1194,7 @@ get_loop_copy (struct loop *loop)\n   gcc_assert (original_copy_bb_pool);\n \n   key.index1 = loop->num;\n-  entry = loop_copy.find (&key);\n+  entry = loop_copy->find (&key);\n   if (entry)\n     return get_loop (cfun, entry->index2);\n   else"}, {"sha": "464dec1dd836fd7fb17c3781146239d52ac1b23f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -4661,25 +4661,25 @@ libcall_hasher::hash (const value_type *p1)\n   return hash_rtx (p1, VOIDmode, NULL, NULL, FALSE);\n }\n \n-typedef hash_table <libcall_hasher> libcall_table_type;\n+typedef hash_table<libcall_hasher> libcall_table_type;\n \n static void\n-add_libcall (libcall_table_type htab, rtx libcall)\n+add_libcall (libcall_table_type *htab, rtx libcall)\n {\n-  *htab.find_slot (libcall, INSERT) = libcall;\n+  *htab->find_slot (libcall, INSERT) = libcall;\n }\n \n static bool\n arm_libcall_uses_aapcs_base (const_rtx libcall)\n {\n   static bool init_done = false;\n-  static libcall_table_type libcall_htab;\n+  static libcall_table_type *libcall_htab = NULL;\n \n   if (!init_done)\n     {\n       init_done = true;\n \n-      libcall_htab.create (31);\n+      libcall_htab = new libcall_table_type (31);\n       add_libcall (libcall_htab,\n \t\t   convert_optab_libfunc (sfloat_optab, SFmode, SImode));\n       add_libcall (libcall_htab,\n@@ -4738,7 +4738,7 @@ arm_libcall_uses_aapcs_base (const_rtx libcall)\n \t\t\t\t\t\t\tDFmode));\n     }\n \n-  return libcall && libcall_htab.find (libcall) != NULL;\n+  return libcall && libcall_htab->find (libcall) != NULL;\n }\n \n static rtx"}, {"sha": "dd52133198472d18964832fddafdab875f2a4c22", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -469,7 +469,7 @@ i386_pe_reloc_rw_mask (void)\n unsigned int\n i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n {\n-  static hash_table <pointer_hash <unsigned int> > htab;\n+  static hash_table<pointer_hash<unsigned int> > *htab = NULL;\n   unsigned int flags;\n   unsigned int **slot;\n \n@@ -480,8 +480,8 @@ i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n   /* The names we put in the hashtable will always be the unique\n      versions given to us by the stringtable, so we can just use\n      their addresses as the keys.  */\n-  if (!htab.is_created ())\n-    htab.create (31);\n+  if (!htab)\n+    htab = new hash_table<pointer_hash<unsigned int> > (31);\n \n   if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n     flags = SECTION_CODE;\n@@ -500,7 +500,7 @@ i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n     flags |= SECTION_LINKONCE;\n \n   /* See if we already have an entry for this section.  */\n-  slot = htab.find_slot ((const unsigned int *)name, INSERT);\n+  slot = htab->find_slot ((const unsigned int *)name, INSERT);\n   if (!*slot)\n     {\n       *slot = (unsigned int *) xmalloc (sizeof (unsigned int));\n@@ -771,7 +771,7 @@ static const char *\n i386_find_on_wrapper_list (const char *target)\n {\n   static char first_time = 1;\n-  static hash_table <wrapped_symbol_hasher> wrappers;\n+  static hash_table<wrapped_symbol_hasher> *wrappers;\n \n   if (first_time)\n     {\n@@ -784,7 +784,7 @@ i386_find_on_wrapper_list (const char *target)\n       char *bufptr;\n       /* Breaks up the char array into separated strings\n          strings and enter them into the hash table.  */\n-      wrappers.create (8);\n+      wrappers = new hash_table_c<wrapped_symbol_hasher> (8);\n       for (bufptr = wrapper_list_buffer; *bufptr; ++bufptr)\n \t{\n \t  char *found = NULL;\n@@ -797,12 +797,12 @@ i386_find_on_wrapper_list (const char *target)\n \t  if (*bufptr)\n \t    *bufptr = 0;\n \t  if (found)\n-\t    *wrappers.find_slot (found, INSERT) = found;\n+\t    *wrappers->find_slot (found, INSERT) = found;\n \t}\n       first_time = 0;\n     }\n \n-  return wrappers.find (target);\n+  return wrappers->find (target);\n }\n \n #endif /* CXX_WRAP_SPEC_LIST */"}, {"sha": "c2e807c314d3e390bfab933f5beabd075de1f851", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -8586,7 +8586,7 @@ bundle_state_hasher::equal (const value_type *state1,\n /* Hash table of the bundle states.  The key is dfa_state and insn_num\n    of the bundle states.  */\n \n-static hash_table <bundle_state_hasher> bundle_state_table;\n+static hash_table<bundle_state_hasher> *bundle_state_table;\n \n /* The function inserts the BUNDLE_STATE into the hash table.  The\n    function returns nonzero if the bundle has been inserted into the\n@@ -8597,7 +8597,7 @@ insert_bundle_state (struct bundle_state *bundle_state)\n {\n   struct bundle_state **entry_ptr;\n \n-  entry_ptr = bundle_state_table.find_slot (bundle_state, INSERT);\n+  entry_ptr = bundle_state_table->find_slot (bundle_state, INSERT);\n   if (*entry_ptr == NULL)\n     {\n       bundle_state->next = index_to_bundle_states [bundle_state->insn_num];\n@@ -8634,15 +8634,16 @@ insert_bundle_state (struct bundle_state *bundle_state)\n static void\n initiate_bundle_state_table (void)\n {\n-  bundle_state_table.create (50);\n+  bundle_state_table = new hash_table<bundle_state_hasher> (50);\n }\n \n /* Finish work with the hash table.  */\n \n static void\n finish_bundle_state_table (void)\n {\n-  bundle_state_table.dispose ();\n+  delete bundle_state_table;\n+  bundle_state_table = NULL;\n }\n \n \f"}, {"sha": "b1504ee621e471402a486b56f3f2c621ffb0e774", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -16018,14 +16018,14 @@ mips_lo_sum_offset_hasher::equal (const value_type *entry,\n   return rtx_equal_p (entry->base, value);\n }\n \n-typedef hash_table <mips_lo_sum_offset_hasher> mips_offset_table;\n+typedef hash_table<mips_lo_sum_offset_hasher> mips_offset_table;\n \n /* Look up symbolic constant X in HTAB, which is a hash table of\n    mips_lo_sum_offsets.  If OPTION is NO_INSERT, return true if X can be\n    paired with a recorded LO_SUM, otherwise record X in the table.  */\n \n static bool\n-mips_lo_sum_offset_lookup (mips_offset_table htab, rtx x,\n+mips_lo_sum_offset_lookup (mips_offset_table *htab, rtx x,\n \t\t\t   enum insert_option option)\n {\n   rtx base, offset;\n@@ -16038,7 +16038,7 @@ mips_lo_sum_offset_lookup (mips_offset_table htab, rtx x,\n     base = UNSPEC_ADDRESS (base);\n \n   /* Look up the base in the hash table.  */\n-  slot = htab.find_slot_with_hash (base, mips_hash_base (base), option);\n+  slot = htab->find_slot_with_hash (base, mips_hash_base (base), option);\n   if (slot == NULL)\n     return false;\n \n@@ -16068,7 +16068,7 @@ static int\n mips_record_lo_sum (rtx *loc, void *data)\n {\n   if (GET_CODE (*loc) == LO_SUM)\n-    mips_lo_sum_offset_lookup (*(mips_offset_table*) data,\n+    mips_lo_sum_offset_lookup ((mips_offset_table*) data,\n \t\t\t       XEXP (*loc, 1), INSERT);\n   return 0;\n }\n@@ -16078,7 +16078,7 @@ mips_record_lo_sum (rtx *loc, void *data)\n    LO_SUMs in the current function.  */\n \n static bool\n-mips_orphaned_high_part_p (mips_offset_table htab, rtx insn)\n+mips_orphaned_high_part_p (mips_offset_table *htab, rtx insn)\n {\n   enum mips_symbol_type type;\n   rtx x, set;\n@@ -16186,7 +16186,6 @@ mips_reorg_process_insns (void)\n {\n   rtx insn, last_insn, subinsn, next_insn, lo_reg, delayed_reg;\n   int hilo_delay;\n-  mips_offset_table htab;\n \n   /* Force all instructions to be split into their final form.  */\n   split_all_insns_noflow ();\n@@ -16227,7 +16226,7 @@ mips_reorg_process_insns (void)\n   if (TARGET_FIX_VR4130 && !ISA_HAS_MACCHI)\n     cfun->machine->all_noreorder_p = false;\n \n-  htab.create (37);\n+  mips_offset_table htab (37);\n \n   /* Make a first pass over the instructions, recording all the LO_SUMs.  */\n   for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n@@ -16272,7 +16271,7 @@ mips_reorg_process_insns (void)\n \t      FOR_EACH_SUBINSN (subinsn, insn)\n \t\tif (INSN_P (subinsn))\n \t\t  {\n-\t\t    if (mips_orphaned_high_part_p (htab, subinsn))\n+\t\t    if (mips_orphaned_high_part_p (&htab, subinsn))\n \t\t      {\n \t\t\tPATTERN (subinsn) = gen_nop ();\n \t\t\tINSN_CODE (subinsn) = CODE_FOR_nop;\n@@ -16286,7 +16285,7 @@ mips_reorg_process_insns (void)\n \t    {\n \t      /* INSN is a single instruction.  Delete it if it's an\n \t\t orphaned high-part relocation.  */\n-\t      if (mips_orphaned_high_part_p (htab, insn))\n+\t      if (mips_orphaned_high_part_p (&htab, insn))\n \t\tdelete_insn (insn);\n \t      /* Also delete cache barriers if the last instruction\n \t\t was an annulled branch.  INSN will not be speculatively\n@@ -16305,8 +16304,6 @@ mips_reorg_process_insns (void)\n \t    }\n \t}\n     }\n-\n-  htab.dispose ();\n }\n \n /* Return true if the function has a long branch instruction.  */"}, {"sha": "c7764b1993dd3242391375f37e2b260c67d940a1", "filename": "gcc/config/sol2.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fsol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fconfig%2Fsol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -195,7 +195,7 @@ comdat_entry_hasher::equal (const value_type *entry1,\n \n /* Hash table of group signature symbols.  */\n \n-static hash_table <comdat_entry_hasher> solaris_comdat_htab;\n+static hash_table<comdat_entry_hasher> *solaris_comdat_htab;\n \n /* Output assembly to switch to COMDAT group section NAME with attributes\n    FLAGS and group signature symbol DECL, using Sun as syntax.  */\n@@ -236,11 +236,11 @@ solaris_elf_asm_comdat_section (const char *name, unsigned int flags, tree decl)\n      identify the missing ones without changing the affected frontents,\n      remember the signature symbols and emit those not marked\n      TREE_SYMBOL_REFERENCED in solaris_file_end.  */\n-  if (!solaris_comdat_htab.is_created ())\n-    solaris_comdat_htab.create (37);\n+  if (!solaris_comdat_htab)\n+    solaris_comdat_htab = new hash_table<comdat_entry_hasher> (37);\n \n   entry.sig = signature;\n-  slot = solaris_comdat_htab.find_slot (&entry, INSERT);\n+  slot = solaris_comdat_htab->find_slot (&entry, INSERT);\n \n   if (*slot == NULL)\n     {\n@@ -284,10 +284,11 @@ solaris_define_comdat_signature (comdat_entry **slot,\n void\n solaris_file_end (void)\n {\n-  if (!solaris_comdat_htab.is_created ())\n+  if (!solaris_comdat_htab)\n     return;\n \n-  solaris_comdat_htab.traverse <void *, solaris_define_comdat_signature> (NULL);\n+  solaris_comdat_htab->traverse <void *, solaris_define_comdat_signature>\n+    (NULL);\n }\n \n void"}, {"sha": "0eeaaa519ecf704a983cb8717a5d40806405eb6b", "filename": "gcc/coverage.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -174,7 +174,7 @@ counts_entry::remove (value_type *entry)\n }\n \n /* Hash table of count data.  */\n-static hash_table <counts_entry> counts_hash;\n+static hash_table<counts_entry> *counts_hash;\n \n /* Read in the counts file, if available.  */\n \n@@ -215,7 +215,7 @@ read_counts_file (void)\n   tag = gcov_read_unsigned ();\n   bbg_file_stamp = crc32_unsigned (bbg_file_stamp, tag);\n \n-  counts_hash.create (10);\n+  counts_hash = new hash_table<counts_entry> (10);\n   while ((tag = gcov_read_unsigned ()))\n     {\n       gcov_unsigned_t length;\n@@ -270,7 +270,7 @@ read_counts_file (void)\n \t  elt.ident = fn_ident;\n \t  elt.ctr = GCOV_COUNTER_FOR_TAG (tag);\n \n-\t  slot = counts_hash.find_slot (&elt, INSERT);\n+\t  slot = counts_hash->find_slot (&elt, INSERT);\n \t  entry = *slot;\n \t  if (!entry)\n \t    {\n@@ -291,14 +291,16 @@ read_counts_file (void)\n \t      error (\"checksum is (%x,%x) instead of (%x,%x)\",\n \t\t     entry->lineno_checksum, entry->cfg_checksum,\n \t\t     lineno_checksum, cfg_checksum);\n-\t      counts_hash.dispose ();\n+\t      delete counts_hash;\n+\t      counts_hash = NULL;\n \t      break;\n \t    }\n \t  else if (entry->summary.num != n_counts)\n \t    {\n \t      error (\"Profile data for function %u is corrupted\", fn_ident);\n \t      error (\"number of counters is %d instead of %d\", entry->summary.num, n_counts);\n-\t      counts_hash.dispose ();\n+\t      delete counts_hash;\n+\t      counts_hash = NULL;\n \t      break;\n \t    }\n \t  else if (elt.ctr >= GCOV_COUNTERS_SUMMABLE)\n@@ -324,7 +326,8 @@ read_counts_file (void)\n \t{\n \t  error (is_error < 0 ? \"%qs has overflowed\" : \"%qs is corrupted\",\n \t\t da_file_name);\n-\t  counts_hash.dispose ();\n+\t  delete counts_hash;\n+\t  counts_hash = NULL;\n \t  break;\n \t}\n     }\n@@ -342,7 +345,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n   counts_entry_t *entry, elt;\n \n   /* No hash table, no counts.  */\n-  if (!counts_hash.is_created ())\n+  if (!counts_hash)\n     {\n       static int warned = 0;\n \n@@ -358,7 +361,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \n   elt.ident = current_function_funcdef_no + 1;\n   elt.ctr = counter;\n-  entry = counts_hash.find (&elt);\n+  entry = counts_hash->find (&elt);\n   if (!entry || !entry->summary.num)\n     /* The function was not emitted, or is weak and not chosen in the\n        final executable.  Silently fail, because there's nothing we"}, {"sha": "f2f4e3cb5f097e931819c9fc6a3514f0ed9cd840", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1,3 +1,8 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* class.c, semantics.c, tree.c, vtable-class-hierarchy.c:\n+\tAdjust.\n+\n 2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* parser.c (cp_parser_omp_for_loop): For"}, {"sha": "1a7529e806c7e07bd795f0c32bc0defe07662991", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -6709,7 +6709,7 @@ finish_struct (tree t, tree attributes)\n }\n \f\n /* Hash table to avoid endless recursion when handling references.  */\n-static hash_table <pointer_hash <tree_node> > fixed_type_or_null_ref_ht;\n+static hash_table<pointer_hash<tree_node> > *fixed_type_or_null_ref_ht;\n \n /* Return the dynamic type of INSTANCE, if known.\n    Used to determine whether the virtual function table is needed\n@@ -6826,8 +6826,9 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n       else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n \t{\n \t  /* We only need one hash table because it is always left empty.  */\n-\t  if (!fixed_type_or_null_ref_ht.is_created ())\n-\t    fixed_type_or_null_ref_ht.create (37); \n+\t  if (!fixed_type_or_null_ref_ht)\n+\t    fixed_type_or_null_ref_ht\n+\t      = new hash_table<pointer_hash<tree_node> > (37); \n \n \t  /* Reference variables should be references to objects.  */\n \t  if (nonnull)\n@@ -6839,15 +6840,15 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n \t  if (VAR_P (instance)\n \t      && DECL_INITIAL (instance)\n \t      && !type_dependent_expression_p_push (DECL_INITIAL (instance))\n-\t      && !fixed_type_or_null_ref_ht.find (instance))\n+\t      && !fixed_type_or_null_ref_ht->find (instance))\n \t    {\n \t      tree type;\n \t      tree_node **slot;\n \n-\t      slot = fixed_type_or_null_ref_ht.find_slot (instance, INSERT);\n+\t      slot = fixed_type_or_null_ref_ht->find_slot (instance, INSERT);\n \t      *slot = instance;\n \t      type = RECUR (DECL_INITIAL (instance));\n-\t      fixed_type_or_null_ref_ht.remove_elt (instance);\n+\t      fixed_type_or_null_ref_ht->remove_elt (instance);\n \n \t      return type;\n \t    }"}, {"sha": "aad6e2f4cb2bf3cc44e8631ea71ddbdda7e44b9a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -4049,9 +4049,11 @@ expand_or_defer_fn (tree fn)\n \n struct nrv_data\n {\n+  nrv_data () : visited (37) {}\n+\n   tree var;\n   tree result;\n-  hash_table <pointer_hash <tree_node> > visited;\n+  hash_table<pointer_hash <tree_node> > visited;\n };\n \n /* Helper function for walk_tree, used by finalize_nrv below.  */\n@@ -4131,9 +4133,7 @@ finalize_nrv (tree *tp, tree var, tree result)\n \n   data.var = var;\n   data.result = result;\n-  data.visited.create (37);\n   cp_walk_tree (tp, finalize_nrv_r, &data, 0);\n-  data.visited.dispose ();\n }\n \f\n /* Create CP_OMP_CLAUSE_INFO for clause C.  Returns true if it is invalid.  */"}, {"sha": "7ff593564cab2b74e87d7a0441b658278f2140c7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -2092,8 +2092,8 @@ static tree\n verify_stmt_tree_r (tree* tp, int * /*walk_subtrees*/, void* data)\n {\n   tree t = *tp;\n-  hash_table <pointer_hash <tree_node> > *statements\n-      = static_cast <hash_table <pointer_hash <tree_node> > *> (data);\n+  hash_table<pointer_hash <tree_node> > *statements\n+      = static_cast <hash_table<pointer_hash <tree_node> > *> (data);\n   tree_node **slot;\n \n   if (!STATEMENT_CODE_P (TREE_CODE (t)))\n@@ -2116,10 +2116,8 @@ verify_stmt_tree_r (tree* tp, int * /*walk_subtrees*/, void* data)\n void\n verify_stmt_tree (tree t)\n {\n-  hash_table <pointer_hash <tree_node> > statements;\n-  statements.create (37);\n+  hash_table<pointer_hash <tree_node> > statements (37);\n   cp_walk_tree (&t, verify_stmt_tree_r, &statements, NULL);\n-  statements.dispose ();\n }\n \n /* Check if the type T depends on a type with no linkage and if so, return"}, {"sha": "f69e6bb3c9535cabaf3a6da04b70c2c16edf09c6", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1028,7 +1028,7 @@ register_all_pairs (tree body)\n \n           if (vtbl_ptr_array->length() > 0\n               || (current->is_used\n-                  || (current->registered.size() > 0)))\n+                  || (current->registered->size() > 0)))\n             {\n               insert_call_to_register_pair (vtbl_ptr_array,\n                                             arg1, arg2, size_hint_arg, str1,\n@@ -1114,7 +1114,7 @@ write_out_vtv_count_data (void)\n     {\n       struct vtbl_map_node *current = vtbl_map_nodes_vec[i];\n       if (!current->is_used\n-          && current->registered.size() == 0)\n+          && current->registered->size() == 0)\n         unused_vtbl_map_vars++;\n     }\n "}, {"sha": "d069f1095dd7fa70d5ac683e3823e16b1ca2aff1", "filename": "gcc/cselib.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -145,10 +145,10 @@ cselib_hasher::equal (const value_type *v, const compare_type *x_arg)\n }\n \n /* A table that enables us to look up elts by their value.  */\n-static hash_table <cselib_hasher> cselib_hash_table;\n+static hash_table<cselib_hasher> *cselib_hash_table;\n \n /* A table to hold preserved values.  */\n-static hash_table <cselib_hasher> cselib_preserved_hash_table;\n+static hash_table<cselib_hasher> *cselib_preserved_hash_table;\n \n /* This is a global so we don't have to pass this through every function.\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n@@ -499,13 +499,13 @@ preserve_constants_and_equivs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n \tGET_MODE (v->val_rtx), v->val_rtx, VOIDmode\n       };\n       cselib_val **slot\n-\t= cselib_preserved_hash_table.find_slot_with_hash (&lookup,\n+\t= cselib_preserved_hash_table->find_slot_with_hash (&lookup,\n \t\t\t\t\t\t\t   v->hash, INSERT);\n       gcc_assert (!*slot);\n       *slot = v;\n     }\n \n-  cselib_hash_table.clear_slot (x);\n+  cselib_hash_table->clear_slot (x);\n \n   return 1;\n }\n@@ -546,10 +546,11 @@ cselib_reset_table (unsigned int num)\n     }\n \n   if (cselib_preserve_constants)\n-    cselib_hash_table.traverse <void *, preserve_constants_and_equivs> (NULL);\n+    cselib_hash_table->traverse <void *, preserve_constants_and_equivs>\n+      (NULL);\n   else\n     {\n-      cselib_hash_table.empty ();\n+      cselib_hash_table->empty ();\n       gcc_checking_assert (!cselib_any_perm_equivs);\n     }\n \n@@ -581,10 +582,10 @@ cselib_find_slot (enum machine_mode mode, rtx x, hashval_t hash,\n   cselib_val **slot = NULL;\n   cselib_hasher::compare_type lookup = { mode, x, memmode };\n   if (cselib_preserve_constants)\n-    slot = cselib_preserved_hash_table.find_slot_with_hash (&lookup, hash,\n-\t\t\t\t\t\t\t    NO_INSERT);\n+    slot = cselib_preserved_hash_table->find_slot_with_hash (&lookup, hash,\n+\t\t\t\t\t\t\t     NO_INSERT);\n   if (!slot)\n-    slot = cselib_hash_table.find_slot_with_hash (&lookup, hash, insert);\n+    slot = cselib_hash_table->find_slot_with_hash (&lookup, hash, insert);\n   return slot;\n }\n \n@@ -662,7 +663,7 @@ discard_useless_values (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n \tcselib_discard_hook (v);\n \n       CSELIB_VAL_PTR (v->val_rtx) = NULL;\n-      cselib_hash_table.clear_slot (x);\n+      cselib_hash_table->clear_slot (x);\n       unchain_one_value (v);\n       n_useless_values--;\n     }\n@@ -683,7 +684,7 @@ remove_useless_values (void)\n   do\n     {\n       values_became_useless = 0;\n-      cselib_hash_table.traverse <void *, discard_useless_locs> (NULL);\n+      cselib_hash_table->traverse <void *, discard_useless_locs> (NULL);\n     }\n   while (values_became_useless);\n \n@@ -702,7 +703,7 @@ remove_useless_values (void)\n   n_debug_values -= n_useless_debug_values;\n   n_useless_debug_values = 0;\n \n-  cselib_hash_table.traverse <void *, discard_useless_values> (NULL);\n+  cselib_hash_table->traverse <void *, discard_useless_values> (NULL);\n \n   gcc_assert (!n_useless_values);\n }\n@@ -2703,7 +2704,7 @@ cselib_process_insn (rtx insn)\n          quadratic behavior for very large hashtables with very few\n \t useless elements.  */\n       && ((unsigned int)n_useless_values\n-\t  > (cselib_hash_table.elements () - n_debug_values) / 4))\n+\t  > (cselib_hash_table->elements () - n_debug_values) / 4))\n     remove_useless_values ();\n }\n \n@@ -2744,9 +2745,9 @@ cselib_init (int record_what)\n     }\n   used_regs = XNEWVEC (unsigned int, cselib_nregs);\n   n_used_regs = 0;\n-  cselib_hash_table.create (31);\n+  cselib_hash_table = new hash_table<cselib_hasher> (31);\n   if (cselib_preserve_constants)\n-    cselib_preserved_hash_table.create (31);\n+    cselib_preserved_hash_table = new hash_table<cselib_hasher> (31);\n   next_uid = 1;\n }\n \n@@ -2766,9 +2767,11 @@ cselib_finish (void)\n   free_alloc_pool (cselib_val_pool);\n   free_alloc_pool (value_pool);\n   cselib_clear_table ();\n-  cselib_hash_table.dispose ();\n+  delete cselib_hash_table;\n+  cselib_hash_table = NULL;\n   if (preserved)\n-    cselib_preserved_hash_table.dispose ();\n+    delete cselib_preserved_hash_table;\n+  cselib_preserved_hash_table = NULL;\n   free (used_regs);\n   used_regs = 0;\n   n_useless_values = 0;\n@@ -2857,9 +2860,9 @@ void\n dump_cselib_table (FILE *out)\n {\n   fprintf (out, \"cselib hash table:\\n\");\n-  cselib_hash_table.traverse <FILE *, dump_cselib_val> (out);\n+  cselib_hash_table->traverse <FILE *, dump_cselib_val> (out);\n   fprintf (out, \"cselib preserved hash table:\\n\");\n-  cselib_preserved_hash_table.traverse <FILE *, dump_cselib_val> (out);\n+  cselib_preserved_hash_table->traverse <FILE *, dump_cselib_val> (out);\n   if (first_containing_mem != &dummy_val)\n     {\n       fputs (\"first mem \", out);"}, {"sha": "8eefd2f855e7f356702271ebd652da741a6a9f85", "filename": "gcc/data-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdata-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdata-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-out.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -49,7 +49,7 @@ streamer_string_index (struct output_block *ob, const char *s, unsigned int len,\n   s_slot.len = len;\n   s_slot.slot_num = 0;\n \n-  slot = ob->string_hash_table.find_slot (&s_slot, INSERT);\n+  slot = ob->string_hash_table->find_slot (&s_slot, INSERT);\n   if (*slot == NULL)\n     {\n       struct lto_output_stream *string_stream = ob->string_stream;"}, {"sha": "d5b2a14b6184b5c63eb0a66ad56a18d9579d18cb", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -658,7 +658,7 @@ invariant_group_base_hasher::hash (const value_type *gi)\n }\n \n /* Tables of group_info structures, hashed by base value.  */\n-static hash_table <invariant_group_base_hasher> rtx_group_table;\n+static hash_table<invariant_group_base_hasher> *rtx_group_table;\n \n \n /* Get the GROUP for BASE.  Add a new group if it is not there.  */\n@@ -675,7 +675,7 @@ get_group_info (rtx base)\n       /* Find the store_base_info structure for BASE, creating a new one\n \t if necessary.  */\n       tmp_gi.rtx_base = base;\n-      slot = rtx_group_table.find_slot (&tmp_gi, INSERT);\n+      slot = rtx_group_table->find_slot (&tmp_gi, INSERT);\n       gi = (group_info_t) *slot;\n     }\n   else\n@@ -765,7 +765,7 @@ dse_step0 (void)\n     = create_alloc_pool (\"deferred_change_pool\",\n \t\t\t sizeof (struct deferred_change), 10);\n \n-  rtx_group_table.create (11);\n+  rtx_group_table = new hash_table<invariant_group_base_hasher> (11);\n \n   bb_table = XNEWVEC (bb_info_t, last_basic_block_for_fn (cfun));\n   rtx_group_next_id = 0;\n@@ -2829,7 +2829,7 @@ dse_step1 (void)\n \n   BITMAP_FREE (regs_live);\n   cselib_finish ();\n-  rtx_group_table.empty ();\n+  rtx_group_table->empty ();\n }\n \n \f\n@@ -3654,7 +3654,8 @@ dse_step7 (void)\n \n   end_alias_analysis ();\n   free (bb_table);\n-  rtx_group_table.dispose ();\n+  delete rtx_group_table;\n+  rtx_group_table = NULL;\n   rtx_group_vec.release ();\n   BITMAP_FREE (all_blocks);\n   BITMAP_FREE (scratch);"}, {"sha": "386b0f7185cee3d4995a3ee4af9bc992b9e3a16f", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -182,7 +182,7 @@ trace_info_hasher::equal (const value_type *a, const compare_type *b)\n /* The variables making up the pseudo-cfg, as described above.  */\n static vec<dw_trace_info> trace_info;\n static vec<dw_trace_info_ref> trace_work_list;\n-static hash_table <trace_info_hasher> trace_index;\n+static hash_table<trace_info_hasher> *trace_index;\n \n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n@@ -307,7 +307,7 @@ get_trace_info (rtx insn)\n {\n   dw_trace_info dummy;\n   dummy.head = insn;\n-  return trace_index.find_with_hash (&dummy, INSN_UID (insn));\n+  return trace_index->find_with_hash (&dummy, INSN_UID (insn));\n }\n \n static bool\n@@ -2774,7 +2774,8 @@ create_pseudo_cfg (void)\n \n   /* Create the trace index after we've finished building trace_info,\n      avoiding stale pointer problems due to reallocation.  */\n-  trace_index.create (trace_info.length ());\n+  trace_index\n+    = new hash_table<trace_info_hasher> (trace_info.length ());\n   dw_trace_info *tp;\n   FOR_EACH_VEC_ELT (trace_info, i, tp)\n     {\n@@ -2785,7 +2786,7 @@ create_pseudo_cfg (void)\n \t\t rtx_name[(int) GET_CODE (tp->head)], INSN_UID (tp->head),\n \t\t tp->switch_sections ? \" (section switch)\" : \"\");\n \n-      slot = trace_index.find_slot_with_hash (tp, INSN_UID (tp->head), INSERT);\n+      slot = trace_index->find_slot_with_hash (tp, INSN_UID (tp->head), INSERT);\n       gcc_assert (*slot == NULL);\n       *slot = tp;\n     }\n@@ -2936,7 +2937,8 @@ execute_dwarf2_frame (void)\n   }\n   trace_info.release ();\n \n-  trace_index.dispose ();\n+  delete trace_index;\n+  trace_index = NULL;\n \n   return 0;\n }"}, {"sha": "f69253684e5164e65afabd7bc11ead44bc87b437", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 58, "deletions": 66, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -6745,21 +6745,21 @@ cu_hash_table_entry_hasher::remove (value_type *entry)\n     }\n }\n \n-typedef hash_table <cu_hash_table_entry_hasher> cu_hash_type;\n+typedef hash_table<cu_hash_table_entry_hasher> cu_hash_type;\n \n /* Check whether we have already seen this CU and set up SYM_NUM\n    accordingly.  */\n static int\n-check_duplicate_cu (dw_die_ref cu, cu_hash_type htable, unsigned int *sym_num)\n+check_duplicate_cu (dw_die_ref cu, cu_hash_type *htable, unsigned int *sym_num)\n {\n   struct cu_hash_table_entry dummy;\n   struct cu_hash_table_entry **slot, *entry, *last = &dummy;\n \n   dummy.max_comdat_num = 0;\n \n-  slot = htable.find_slot_with_hash (cu,\n-\t\t\t\t     htab_hash_string (cu->die_id.die_symbol),\n-\t\t\t\t     INSERT);\n+  slot = htable->find_slot_with_hash (cu,\n+\t\t\t\t      htab_hash_string (cu->die_id.die_symbol),\n+\t\t\t\t      INSERT);\n   entry = *slot;\n \n   for (; entry; last = entry, entry = entry->next)\n@@ -6785,14 +6785,14 @@ check_duplicate_cu (dw_die_ref cu, cu_hash_type htable, unsigned int *sym_num)\n \n /* Record SYM_NUM to record of CU in HTABLE.  */\n static void\n-record_comdat_symbol_number (dw_die_ref cu, cu_hash_type htable,\n+record_comdat_symbol_number (dw_die_ref cu, cu_hash_type *htable,\n \t\t\t     unsigned int sym_num)\n {\n   struct cu_hash_table_entry **slot, *entry;\n \n-  slot = htable.find_slot_with_hash (cu,\n-\t\t\t\t     htab_hash_string (cu->die_id.die_symbol),\n-\t\t\t\t     NO_INSERT);\n+  slot = htable->find_slot_with_hash (cu,\n+\t\t\t\t      htab_hash_string (cu->die_id.die_symbol),\n+\t\t\t\t      NO_INSERT);\n   entry = *slot;\n \n   entry->max_comdat_num = sym_num;\n@@ -6808,7 +6808,6 @@ break_out_includes (dw_die_ref die)\n   dw_die_ref c;\n   dw_die_ref unit = NULL;\n   limbo_die_node *node, **pnode;\n-  cu_hash_type cu_hash_table;\n \n   c = die->die_child;\n   if (c) do {\n@@ -6841,27 +6840,26 @@ break_out_includes (dw_die_ref die)\n #endif\n \n   assign_symbol_names (die);\n-  cu_hash_table.create (10);\n+  cu_hash_type cu_hash_table (10);\n   for (node = limbo_die_list, pnode = &limbo_die_list;\n        node;\n        node = node->next)\n     {\n       int is_dupl;\n \n       compute_section_prefix (node->die);\n-      is_dupl = check_duplicate_cu (node->die, cu_hash_table,\n+      is_dupl = check_duplicate_cu (node->die, &cu_hash_table,\n \t\t\t&comdat_symbol_number);\n       assign_symbol_names (node->die);\n       if (is_dupl)\n \t*pnode = node->next;\n       else\n \t{\n \t  pnode = &node->next;\n-\t  record_comdat_symbol_number (node->die, cu_hash_table,\n+\t  record_comdat_symbol_number (node->die, &cu_hash_table,\n \t\tcomdat_symbol_number);\n \t}\n     }\n-  cu_hash_table.dispose ();\n }\n \n /* Return non-zero if this DIE is a declaration.  */\n@@ -7070,27 +7068,28 @@ decl_table_entry_hasher::equal (const value_type *entry1,\n   return entry1->orig == entry2;\n }\n \n-typedef hash_table <decl_table_entry_hasher> decl_hash_type;\n+typedef hash_table<decl_table_entry_hasher> decl_hash_type;\n \n /* Copy DIE and its ancestors, up to, but not including, the compile unit\n    or type unit entry, to a new tree.  Adds the new tree to UNIT and returns\n    a pointer to the copy of DIE.  If DECL_TABLE is provided, it is used\n    to check if the ancestor has already been copied into UNIT.  */\n \n static dw_die_ref\n-copy_ancestor_tree (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n+copy_ancestor_tree (dw_die_ref unit, dw_die_ref die,\n+\t\t    decl_hash_type *decl_table)\n {\n   dw_die_ref parent = die->die_parent;\n   dw_die_ref new_parent = unit;\n   dw_die_ref copy;\n   decl_table_entry **slot = NULL;\n   struct decl_table_entry *entry = NULL;\n \n-  if (decl_table.is_created ())\n+  if (decl_table)\n     {\n       /* Check if the entry has already been copied to UNIT.  */\n-      slot = decl_table.find_slot_with_hash (die, htab_hash_pointer (die),\n-\t\t\t\t\t     INSERT);\n+      slot = decl_table->find_slot_with_hash (die, htab_hash_pointer (die),\n+\t\t\t\t\t      INSERT);\n       if (*slot != HTAB_EMPTY_ENTRY)\n         {\n           entry = *slot;\n@@ -7116,7 +7115,7 @@ copy_ancestor_tree (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n   copy = clone_as_declaration (die);\n   add_child_die (new_parent, copy);\n \n-  if (decl_table.is_created ())\n+  if (decl_table)\n     {\n       /* Record the pointer to the copy.  */\n       entry->copy = copy;\n@@ -7171,7 +7170,7 @@ copy_declaration_context (dw_die_ref unit, dw_die_ref die)\n   if (decl->die_parent != NULL\n       && !is_unit_die (decl->die_parent))\n     {\n-      new_decl = copy_ancestor_tree (unit, decl, decl_hash_type ());\n+      new_decl = copy_ancestor_tree (unit, decl, NULL);\n       if (new_decl != NULL)\n         {\n           remove_AT (new_decl, DW_AT_signature);\n@@ -7396,7 +7395,7 @@ break_out_comdat_types (dw_die_ref die)\n    Enter all the cloned children into the hash table decl_table.  */\n \n static dw_die_ref\n-clone_tree_partial (dw_die_ref die, decl_hash_type decl_table)\n+clone_tree_partial (dw_die_ref die, decl_hash_type *decl_table)\n {\n   dw_die_ref c;\n   dw_die_ref clone;\n@@ -7408,8 +7407,8 @@ clone_tree_partial (dw_die_ref die, decl_hash_type decl_table)\n   else\n     clone = clone_die (die);\n \n-  slot = decl_table.find_slot_with_hash (die,\n-\t\t\t\t\t htab_hash_pointer (die), INSERT);\n+  slot = decl_table->find_slot_with_hash (die,\n+\t\t\t\t\t  htab_hash_pointer (die), INSERT);\n \n   /* Assert that DIE isn't in the hash table yet.  If it would be there\n      before, the ancestors would be necessarily there as well, therefore\n@@ -7433,7 +7432,7 @@ clone_tree_partial (dw_die_ref die, decl_hash_type decl_table)\n    type_unit).  */\n \n static void\n-copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n+copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type *decl_table)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n@@ -7450,8 +7449,9 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n           if (targ->die_mark != 0 || targ->comdat_type_p)\n             continue;\n \n-          slot = decl_table.find_slot_with_hash (targ, htab_hash_pointer (targ),\n-\t\t\t\t\t\t INSERT);\n+          slot = decl_table->find_slot_with_hash (targ,\n+\t\t\t\t\t\t  htab_hash_pointer (targ),\n+\t\t\t\t\t\t  INSERT);\n \n           if (*slot != HTAB_EMPTY_ENTRY)\n             {\n@@ -7530,12 +7530,9 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n static void\n copy_decls_for_unworthy_types (dw_die_ref unit)\n {\n-  decl_hash_type decl_table;\n-\n   mark_dies (unit);\n-  decl_table.create (10);\n-  copy_decls_walk (unit, unit, decl_table);\n-  decl_table.dispose ();\n+  decl_hash_type decl_table (10);\n+  copy_decls_walk (unit, unit, &decl_table);\n   unmark_dies (unit);\n }\n \n@@ -7627,18 +7624,18 @@ external_ref_hasher::equal (const value_type *r1, const compare_type *r2)\n   return r1->type == r2->type;\n }\n \n-typedef hash_table <external_ref_hasher> external_ref_hash_type;\n+typedef hash_table<external_ref_hasher> external_ref_hash_type;\n \n /* Return a pointer to the external_ref for references to DIE.  */\n \n static struct external_ref *\n-lookup_external_ref (external_ref_hash_type map, dw_die_ref die)\n+lookup_external_ref (external_ref_hash_type *map, dw_die_ref die)\n {\n   struct external_ref ref, *ref_p;\n   external_ref **slot;\n \n   ref.type = die;\n-  slot = map.find_slot (&ref, INSERT);\n+  slot = map->find_slot (&ref, INSERT);\n   if (*slot != HTAB_EMPTY_ENTRY)\n     return *slot;\n \n@@ -7654,7 +7651,7 @@ lookup_external_ref (external_ref_hash_type map, dw_die_ref die)\n    references, remember how many we've seen.  */\n \n static void\n-optimize_external_refs_1 (dw_die_ref die, external_ref_hash_type map)\n+optimize_external_refs_1 (dw_die_ref die, external_ref_hash_type *map)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n@@ -7725,13 +7722,12 @@ dwarf2_build_local_stub (external_ref **slot, dw_die_ref data)\n    them which will be applied in build_abbrev_table.  This is useful because\n    references to local DIEs are smaller.  */\n \n-static external_ref_hash_type\n+static external_ref_hash_type *\n optimize_external_refs (dw_die_ref die)\n {\n-  external_ref_hash_type map;\n-  map.create (10);\n+  external_ref_hash_type *map = new external_ref_hash_type (10);\n   optimize_external_refs_1 (die, map);\n-  map.traverse <dw_die_ref, dwarf2_build_local_stub> (die);\n+  map->traverse <dw_die_ref, dwarf2_build_local_stub> (die);\n   return map;\n }\n \n@@ -7741,7 +7737,7 @@ optimize_external_refs (dw_die_ref die)\n    die are visited recursively.  */\n \n static void\n-build_abbrev_table (dw_die_ref die, external_ref_hash_type extern_map)\n+build_abbrev_table (dw_die_ref die, external_ref_hash_type *extern_map)\n {\n   unsigned long abbrev_id;\n   unsigned int n_alloc;\n@@ -8950,7 +8946,6 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n {\n   const char *secname, *oldsym;\n   char *tmp;\n-  external_ref_hash_type extern_map;\n \n   /* Unless we are outputting main CU, we may throw away empty ones.  */\n   if (!output_if_empty && die->die_child == NULL)\n@@ -8963,11 +8958,11 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n      this CU so we know which get local refs.  */\n   mark_dies (die);\n \n-  extern_map = optimize_external_refs (die);\n+  external_ref_hash_type *extern_map = optimize_external_refs (die);\n \n   build_abbrev_table (die, extern_map);\n \n-  extern_map.dispose ();\n+  delete extern_map;\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n@@ -9142,16 +9137,16 @@ output_comdat_type_unit (comdat_type_node *node)\n #if defined (OBJECT_FORMAT_ELF)\n   tree comdat_key;\n #endif\n-  external_ref_hash_type extern_map;\n \n   /* First mark all the DIEs in this CU so we know which get local refs.  */\n   mark_dies (node->root_die);\n \n-  extern_map = optimize_external_refs (node->root_die);\n+  external_ref_hash_type *extern_map = optimize_external_refs (node->root_die);\n \n   build_abbrev_table (node->root_die, extern_map);\n \n-  extern_map.dispose ();\n+  delete extern_map;\n+  extern_map = NULL;\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE;\n@@ -21892,7 +21887,7 @@ macinfo_entry_hasher::equal (const value_type *entry1,\n   return !strcmp (entry1->info, entry2->info);\n }\n \n-typedef hash_table <macinfo_entry_hasher> macinfo_hash_type;\n+typedef hash_table<macinfo_entry_hasher> macinfo_hash_type;\n \n /* Output a single .debug_macinfo entry.  */\n \n@@ -21982,7 +21977,7 @@ output_macinfo_op (macinfo_entry *ref)\n \n static unsigned\n optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n-\t\t\tmacinfo_hash_type *macinfo_htab)\n+\t\t\tmacinfo_hash_type **macinfo_htab)\n {\n   macinfo_entry *first, *second, *cur, *inc;\n   char linebuf[sizeof (HOST_WIDE_INT) * 3 + 1];\n@@ -22069,10 +22064,10 @@ optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n   inc->code = DW_MACRO_GNU_transparent_include;\n   inc->lineno = 0;\n   inc->info = ggc_strdup (grp_name);\n-  if (!macinfo_htab->is_created ())\n-    macinfo_htab->create (10);\n+  if (!*macinfo_htab)\n+    *macinfo_htab = new macinfo_hash_type (10);\n   /* Avoid emitting duplicates.  */\n-  slot = macinfo_htab->find_slot (inc, INSERT);\n+  slot = (*macinfo_htab)->find_slot (inc, INSERT);\n   if (*slot != NULL)\n     {\n       inc->code = 0;\n@@ -22092,7 +22087,7 @@ optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n   else\n     {\n       *slot = inc;\n-      inc->lineno = macinfo_htab->elements ();\n+      inc->lineno = (*macinfo_htab)->elements ();\n       output_macinfo_op (inc);\n     }\n   return count;\n@@ -22143,7 +22138,7 @@ output_macinfo (void)\n   unsigned long length = vec_safe_length (macinfo_table);\n   macinfo_entry *ref;\n   vec<macinfo_entry, va_gc> *files = NULL;\n-  macinfo_hash_type macinfo_htab;\n+  macinfo_hash_type *macinfo_htab = NULL;\n \n   if (! length)\n     return;\n@@ -22216,10 +22211,11 @@ output_macinfo (void)\n       ref->code = 0;\n     }\n \n-  if (!macinfo_htab.is_created ())\n+  if (!macinfo_htab)\n     return;\n \n-  macinfo_htab.dispose ();\n+  delete macinfo_htab;\n+  macinfo_htab = NULL;\n \n   /* If any DW_MACRO_GNU_transparent_include were used, on those\n      DW_MACRO_GNU_transparent_include entries terminate the\n@@ -24081,14 +24077,14 @@ loc_list_hasher::equal (const value_type *a, const compare_type *b)\n   return a == NULL && b == NULL;\n }\n \n-typedef hash_table <loc_list_hasher> loc_list_hash_type;\n+typedef hash_table<loc_list_hasher> loc_list_hash_type;\n \n \n /* Recursively optimize location lists referenced from DIE\n    children and share them whenever possible.  */\n \n static void\n-optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type htab)\n+optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type *htab)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n@@ -24102,7 +24098,7 @@ optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type htab)\n \t/* TODO: perform some optimizations here, before hashing\n \t   it and storing into the hash table.  */\n \thash_loc_list (list);\n-\tslot = htab.find_slot_with_hash (list, list->hash, INSERT);\n+\tslot = htab->find_slot_with_hash (list, list->hash, INSERT);\n \tif (*slot == NULL)\n \t  *slot = list;\n \telse\n@@ -24151,10 +24147,8 @@ index_location_lists (dw_die_ref die)\n static void\n optimize_location_lists (dw_die_ref die)\n {\n-  loc_list_hash_type htab;\n-  htab.create (500);\n-  optimize_location_lists_1 (die, htab);\n-  htab.dispose ();\n+  loc_list_hash_type htab (500);\n+  optimize_location_lists_1 (die, &htab);\n }\n \f\n /* Output stuff that dwarf requires at the end of every file,\n@@ -24165,7 +24159,6 @@ dwarf2out_finish (const char *filename)\n {\n   limbo_die_node *node, *next_node;\n   comdat_type_node *ctnode;\n-  hash_table <comdat_type_hasher> comdat_type_table;\n   unsigned int i;\n   dw_die_ref main_comp_unit_die;\n \n@@ -24434,7 +24427,7 @@ dwarf2out_finish (const char *filename)\n   for (node = limbo_die_list; node; node = node->next)\n     output_comp_unit (node->die, 0);\n \n-  comdat_type_table.create (100);\n+  hash_table<comdat_type_hasher> comdat_type_table (100);\n   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n     {\n       comdat_type_node **slot = comdat_type_table.find_slot (ctnode, INSERT);\n@@ -24455,7 +24448,6 @@ dwarf2out_finish (const char *filename)\n       output_comdat_type_unit (ctnode);\n       *slot = ctnode;\n     }\n-  comdat_type_table.dispose ();\n \n   /* The AT_pubnames attribute needs to go in all skeleton dies, including\n      both the main_cu and all skeleton TUs.  Making this call unconditional"}, {"sha": "dc5c1d20132b08ddb9b240a19f68e3518d19eb84", "filename": "gcc/except.c", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -209,7 +209,7 @@ action_record_hasher::equal (const value_type *entry, const compare_type *data)\n   return entry->filter == data->filter && entry->next == data->next;\n }\n \n-typedef hash_table <action_record_hasher> action_hash_type;\n+typedef hash_table<action_record_hasher> action_hash_type;\n \f\n static bool get_eh_region_and_lp_from_rtx (const_rtx, eh_region *,\n \t\t\t\t\t   eh_landing_pad *);\n@@ -219,7 +219,7 @@ static hashval_t t2r_hash (const void *);\n \n static void dw2_build_landing_pads (void);\n \n-static int collect_one_action_chain (action_hash_type, eh_region);\n+static int collect_one_action_chain (action_hash_type *, eh_region);\n static int add_call_site (rtx, int, int);\n \n static void push_uleb128 (vec<uchar, va_gc> **, unsigned int);\n@@ -760,7 +760,7 @@ ttypes_filter_hasher::hash (const value_type *entry)\n   return TREE_HASH (entry->t);\n }\n \n-typedef hash_table <ttypes_filter_hasher> ttypes_hash_type;\n+typedef hash_table<ttypes_filter_hasher> ttypes_hash_type;\n \n \n /* Helper for ehspec hashing.  */\n@@ -797,18 +797,18 @@ ehspec_hasher::hash (const value_type *entry)\n   return h;\n }\n \n-typedef hash_table <ehspec_hasher> ehspec_hash_type;\n+typedef hash_table<ehspec_hasher> ehspec_hash_type;\n \n \n /* Add TYPE (which may be NULL) to cfun->eh->ttype_data, using TYPES_HASH\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n-add_ttypes_entry (ttypes_hash_type ttypes_hash, tree type)\n+add_ttypes_entry (ttypes_hash_type *ttypes_hash, tree type)\n {\n   struct ttypes_filter **slot, *n;\n \n-  slot = ttypes_hash.find_slot_with_hash (type, (hashval_t) TREE_HASH (type),\n+  slot = ttypes_hash->find_slot_with_hash (type, (hashval_t) TREE_HASH (type),\n \t\t\t\t\t  INSERT);\n \n   if ((n = *slot) == NULL)\n@@ -830,14 +830,14 @@ add_ttypes_entry (ttypes_hash_type ttypes_hash, tree type)\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n-add_ehspec_entry (ehspec_hash_type ehspec_hash, ttypes_hash_type ttypes_hash,\n+add_ehspec_entry (ehspec_hash_type *ehspec_hash, ttypes_hash_type *ttypes_hash,\n \t\t  tree list)\n {\n   struct ttypes_filter **slot, *n;\n   struct ttypes_filter dummy;\n \n   dummy.t = list;\n-  slot = ehspec_hash.find_slot (&dummy, INSERT);\n+  slot = ehspec_hash->find_slot (&dummy, INSERT);\n \n   if ((n = *slot) == NULL)\n     {\n@@ -886,8 +886,6 @@ void\n assign_filter_values (void)\n {\n   int i;\n-  ttypes_hash_type ttypes;\n-  ehspec_hash_type ehspec;\n   eh_region r;\n   eh_catch c;\n \n@@ -897,8 +895,8 @@ assign_filter_values (void)\n   else\n     vec_alloc (cfun->eh->ehspec_data.other, 64);\n \n-  ttypes.create (31);\n-  ehspec.create (31);\n+  ehspec_hash_type ehspec (31);\n+  ttypes_hash_type ttypes (31);\n \n   for (i = 1; vec_safe_iterate (cfun->eh->region_array, i, &r); ++i)\n     {\n@@ -922,7 +920,8 @@ assign_filter_values (void)\n \n \t\t  for ( ; tp_node; tp_node = TREE_CHAIN (tp_node))\n \t\t    {\n-\t\t      int flt = add_ttypes_entry (ttypes, TREE_VALUE (tp_node));\n+\t\t      int flt\n+\t\t       \t= add_ttypes_entry (&ttypes, TREE_VALUE (tp_node));\n \t\t      tree flt_node = build_int_cst (integer_type_node, flt);\n \n \t\t      c->filter_list\n@@ -933,7 +932,7 @@ assign_filter_values (void)\n \t\t{\n \t\t  /* Get a filter value for the NULL list also since it\n \t\t     will need an action record anyway.  */\n-\t\t  int flt = add_ttypes_entry (ttypes, NULL);\n+\t\t  int flt = add_ttypes_entry (&ttypes, NULL);\n \t\t  tree flt_node = build_int_cst (integer_type_node, flt);\n \n \t\t  c->filter_list\n@@ -944,16 +943,13 @@ assign_filter_values (void)\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n \t  r->u.allowed.filter\n-\t    = add_ehspec_entry (ehspec, ttypes, r->u.allowed.type_list);\n+\t    = add_ehspec_entry (&ehspec, &ttypes, r->u.allowed.type_list);\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n     }\n-\n-  ttypes.dispose ();\n-  ehspec.dispose ();\n }\n \n /* Emit SEQ into basic block just before INSN (that is assumed to be\n@@ -1074,12 +1070,11 @@ static vec<int> sjlj_lp_call_site_index;\n static int\n sjlj_assign_call_site_values (void)\n {\n-  action_hash_type ar_hash;\n+  action_hash_type ar_hash (31);\n   int i, disp_index;\n   eh_landing_pad lp;\n \n   vec_alloc (crtl->eh.action_record_data, 64);\n-  ar_hash.create (31);\n \n   disp_index = 0;\n   call_site_base = 1;\n@@ -1089,7 +1084,7 @@ sjlj_assign_call_site_values (void)\n \tint action, call_site;\n \n \t/* First: build the action table.  */\n-\taction = collect_one_action_chain (ar_hash, lp->region);\n+\taction = collect_one_action_chain (&ar_hash, lp->region);\n \n \t/* Next: assign call-site values.  If dwarf2 terms, this would be\n \t   the region number assigned by convert_to_eh_region_ranges, but\n@@ -1108,8 +1103,6 @@ sjlj_assign_call_site_values (void)\n \tdisp_index++;\n       }\n \n-  ar_hash.dispose ();\n-\n   return disp_index;\n }\n \n@@ -2321,13 +2314,13 @@ expand_builtin_extend_pointer (tree addr_tree)\n }\n \f\n static int\n-add_action_record (action_hash_type ar_hash, int filter, int next)\n+add_action_record (action_hash_type *ar_hash, int filter, int next)\n {\n   struct action_record **slot, *new_ar, tmp;\n \n   tmp.filter = filter;\n   tmp.next = next;\n-  slot = ar_hash.find_slot (&tmp, INSERT);\n+  slot = ar_hash->find_slot (&tmp, INSERT);\n \n   if ((new_ar = *slot) == NULL)\n     {\n@@ -2352,7 +2345,7 @@ add_action_record (action_hash_type ar_hash, int filter, int next)\n }\n \n static int\n-collect_one_action_chain (action_hash_type ar_hash, eh_region region)\n+collect_one_action_chain (action_hash_type *ar_hash, eh_region region)\n {\n   int next;\n \n@@ -2481,7 +2474,7 @@ static unsigned int\n convert_to_eh_region_ranges (void)\n {\n   rtx insn, iter, note;\n-  action_hash_type ar_hash;\n+  action_hash_type ar_hash (31);\n   int last_action = -3;\n   rtx last_action_insn = NULL_RTX;\n   rtx last_landing_pad = NULL_RTX;\n@@ -2495,8 +2488,6 @@ convert_to_eh_region_ranges (void)\n \n   vec_alloc (crtl->eh.action_record_data, 64);\n \n-  ar_hash.create (31);\n-\n   for (iter = get_insns (); iter ; iter = NEXT_INSN (iter))\n     if (INSN_P (iter))\n       {\n@@ -2515,7 +2506,7 @@ convert_to_eh_region_ranges (void)\n \tif (nothrow)\n \t  continue;\n \tif (region)\n-\t  this_action = collect_one_action_chain (ar_hash, region);\n+\t  this_action = collect_one_action_chain (&ar_hash, region);\n \telse\n \t  this_action = -1;\n \n@@ -2632,7 +2623,6 @@ convert_to_eh_region_ranges (void)\n \n   call_site_base = saved_call_site_base;\n \n-  ar_hash.dispose ();\n   return 0;\n }\n "}, {"sha": "f6b72b7a3a64d597e87e194450001d9b904d63a3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -14686,7 +14686,7 @@ fold (tree expr)\n #undef fold\n \n static void fold_checksum_tree (const_tree, struct md5_ctx *,\n-\t\t\t\thash_table <pointer_hash <tree_node> >);\n+\t\t\t\thash_table<pointer_hash<tree_node> > *);\n static void fold_check_failed (const_tree, const_tree);\n void print_fold_checksum (const_tree);\n \n@@ -14700,20 +14700,18 @@ fold (tree expr)\n   tree ret;\n   struct md5_ctx ctx;\n   unsigned char checksum_before[16], checksum_after[16];\n-  hash_table <pointer_hash <tree_node> > ht;\n+  hash_table<pointer_hash<tree_node> > ht (32);\n \n-  ht.create (32);\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (expr, &ctx, ht);\n+  fold_checksum_tree (expr, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before);\n   ht.empty ();\n \n   ret = fold_1 (expr);\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (expr, &ctx, ht);\n+  fold_checksum_tree (expr, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after);\n-  ht.dispose ();\n \n   if (memcmp (checksum_before, checksum_after, 16))\n     fold_check_failed (expr, ret);\n@@ -14726,13 +14724,11 @@ print_fold_checksum (const_tree expr)\n {\n   struct md5_ctx ctx;\n   unsigned char checksum[16], cnt;\n-  hash_table <pointer_hash <tree_node> > ht;\n+  hash_table<pointer_hash<tree_node> > ht (32);\n \n-  ht.create (32);\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (expr, &ctx, ht);\n+  fold_checksum_tree (expr, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum);\n-  ht.dispose ();\n   for (cnt = 0; cnt < 16; ++cnt)\n     fprintf (stderr, \"%02x\", checksum[cnt]);\n   putc ('\\n', stderr);\n@@ -14746,7 +14742,7 @@ fold_check_failed (const_tree expr ATTRIBUTE_UNUSED, const_tree ret ATTRIBUTE_UN\n \n static void\n fold_checksum_tree (const_tree expr, struct md5_ctx *ctx,\n-\t\t    hash_table <pointer_hash <tree_node> > ht)\n+\t\t    hash_table<pointer_hash <tree_node> > *ht)\n {\n   tree_node **slot;\n   enum tree_code code;\n@@ -14756,7 +14752,7 @@ fold_checksum_tree (const_tree expr, struct md5_ctx *ctx,\n  recursive_label:\n   if (expr == NULL)\n     return;\n-  slot = ht.find_slot (expr, INSERT);\n+  slot = ht->find_slot (expr, INSERT);\n   if (*slot != NULL)\n     return;\n   *slot = CONST_CAST_TREE (expr);\n@@ -14903,11 +14899,10 @@ debug_fold_checksum (const_tree t)\n   int i;\n   unsigned char checksum[16];\n   struct md5_ctx ctx;\n-  hash_table <pointer_hash <tree_node> > ht;\n-  ht.create (32);\n+  hash_table<pointer_hash<tree_node> > ht (32);\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (t, &ctx, ht);\n+  fold_checksum_tree (t, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum);\n   ht.empty ();\n \n@@ -14932,11 +14927,10 @@ fold_build1_stat_loc (location_t loc,\n #ifdef ENABLE_FOLD_CHECKING\n   unsigned char checksum_before[16], checksum_after[16];\n   struct md5_ctx ctx;\n-  hash_table <pointer_hash <tree_node> > ht;\n+  hash_table<pointer_hash<tree_node> > ht (32);\n \n-  ht.create (32);\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op0, &ctx, ht);\n+  fold_checksum_tree (op0, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before);\n   ht.empty ();\n #endif\n@@ -14947,9 +14941,8 @@ fold_build1_stat_loc (location_t loc,\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op0, &ctx, ht);\n+  fold_checksum_tree (op0, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after);\n-  ht.dispose ();\n \n   if (memcmp (checksum_before, checksum_after, 16))\n     fold_check_failed (op0, tem);\n@@ -14975,16 +14968,15 @@ fold_build2_stat_loc (location_t loc,\n \t\tchecksum_after_op0[16],\n \t\tchecksum_after_op1[16];\n   struct md5_ctx ctx;\n-  hash_table <pointer_hash <tree_node> > ht;\n+  hash_table<pointer_hash<tree_node> > ht (32);\n \n-  ht.create (32);\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op0, &ctx, ht);\n+  fold_checksum_tree (op0, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_op0);\n   ht.empty ();\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op1, &ctx, ht);\n+  fold_checksum_tree (op1, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_op1);\n   ht.empty ();\n #endif\n@@ -14995,17 +14987,16 @@ fold_build2_stat_loc (location_t loc,\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op0, &ctx, ht);\n+  fold_checksum_tree (op0, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_op0);\n   ht.empty ();\n \n   if (memcmp (checksum_before_op0, checksum_after_op0, 16))\n     fold_check_failed (op0, tem);\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op1, &ctx, ht);\n+  fold_checksum_tree (op1, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_op1);\n-  ht.dispose ();\n \n   if (memcmp (checksum_before_op1, checksum_after_op1, 16))\n     fold_check_failed (op1, tem);\n@@ -15031,21 +15022,20 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n \t\tchecksum_after_op1[16],\n \t\tchecksum_after_op2[16];\n   struct md5_ctx ctx;\n-  hash_table <pointer_hash <tree_node> > ht;\n+  hash_table<pointer_hash<tree_node> > ht (32);\n \n-  ht.create (32);\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op0, &ctx, ht);\n+  fold_checksum_tree (op0, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_op0);\n   ht.empty ();\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op1, &ctx, ht);\n+  fold_checksum_tree (op1, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_op1);\n   ht.empty ();\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op2, &ctx, ht);\n+  fold_checksum_tree (op2, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_op2);\n   ht.empty ();\n #endif\n@@ -15057,25 +15047,24 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op0, &ctx, ht);\n+  fold_checksum_tree (op0, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_op0);\n   ht.empty ();\n \n   if (memcmp (checksum_before_op0, checksum_after_op0, 16))\n     fold_check_failed (op0, tem);\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op1, &ctx, ht);\n+  fold_checksum_tree (op1, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_op1);\n   ht.empty ();\n \n   if (memcmp (checksum_before_op1, checksum_after_op1, 16))\n     fold_check_failed (op1, tem);\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (op2, &ctx, ht);\n+  fold_checksum_tree (op2, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_op2);\n-  ht.dispose ();\n \n   if (memcmp (checksum_before_op2, checksum_after_op2, 16))\n     fold_check_failed (op2, tem);\n@@ -15099,18 +15088,17 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n \t\tchecksum_after_fn[16],\n \t\tchecksum_after_arglist[16];\n   struct md5_ctx ctx;\n-  hash_table <pointer_hash <tree_node> > ht;\n+  hash_table<pointer_hash<tree_node> > ht (32);\n   int i;\n \n-  ht.create (32);\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (fn, &ctx, ht);\n+  fold_checksum_tree (fn, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_fn);\n   ht.empty ();\n \n   md5_init_ctx (&ctx);\n   for (i = 0; i < nargs; i++)\n-    fold_checksum_tree (argarray[i], &ctx, ht);\n+    fold_checksum_tree (argarray[i], &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_before_arglist);\n   ht.empty ();\n #endif\n@@ -15119,7 +15107,7 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (fn, &ctx, ht);\n+  fold_checksum_tree (fn, &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_fn);\n   ht.empty ();\n \n@@ -15128,9 +15116,8 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n \n   md5_init_ctx (&ctx);\n   for (i = 0; i < nargs; i++)\n-    fold_checksum_tree (argarray[i], &ctx, ht);\n+    fold_checksum_tree (argarray[i], &ctx, &ht);\n   md5_finish_ctx (&ctx, checksum_after_arglist);\n-  ht.dispose ();\n \n   if (memcmp (checksum_before_arglist, checksum_after_arglist, 16))\n     fold_check_failed (NULL_TREE, tem);"}, {"sha": "a15b8bd6e700c31ad0eee2eb15f57f041365dcfe", "filename": "gcc/gcse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -386,7 +386,7 @@ pre_ldst_expr_hasher::equal (const value_type *ptr1,\n }\n \n /* Hashtable for the load/store memory refs.  */\n-static hash_table <pre_ldst_expr_hasher> pre_ldst_table;\n+static hash_table<pre_ldst_expr_hasher> *pre_ldst_table;\n \n /* Bitmap containing one bit for each register in the program.\n    Used when performing GCSE to track which registers have been set since\n@@ -3762,7 +3762,7 @@ ldst_entry (rtx x)\n \t\t   NULL,  /*have_reg_qty=*/false);\n \n   e.pattern = x;\n-  slot = pre_ldst_table.find_slot_with_hash (&e, hash, INSERT);\n+  slot = pre_ldst_table->find_slot_with_hash (&e, hash, INSERT);\n   if (*slot)\n     return *slot;\n \n@@ -3800,8 +3800,8 @@ free_ldst_entry (struct ls_expr * ptr)\n static void\n free_ld_motion_mems (void)\n {\n-  if (pre_ldst_table.is_created ())\n-    pre_ldst_table.dispose ();\n+  delete pre_ldst_table;\n+  pre_ldst_table = NULL;\n \n   while (pre_ldst_mems)\n     {\n@@ -3857,10 +3857,10 @@ find_rtx_in_ldst (rtx x)\n {\n   struct ls_expr e;\n   ls_expr **slot;\n-  if (!pre_ldst_table.is_created ())\n+  if (!pre_ldst_table)\n     return NULL;\n   e.pattern = x;\n-  slot = pre_ldst_table.find_slot (&e, NO_INSERT);\n+  slot = pre_ldst_table->find_slot (&e, NO_INSERT);\n   if (!slot || (*slot)->invalid)\n     return NULL;\n   return *slot;\n@@ -3951,7 +3951,7 @@ compute_ld_motion_mems (void)\n   rtx insn;\n \n   pre_ldst_mems = NULL;\n-  pre_ldst_table.create (13);\n+  pre_ldst_table = new hash_table<pre_ldst_expr_hasher> (13);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -4053,7 +4053,7 @@ trim_ld_motion_mems (void)\n       else\n \t{\n \t  *last = ptr->next;\n-\t  pre_ldst_table.remove_elt_with_hash (ptr, ptr->hash_index);\n+\t  pre_ldst_table->remove_elt_with_hash (ptr, ptr->hash_index);\n \t  free_ldst_entry (ptr);\n \t  ptr = * last;\n \t}"}, {"sha": "b88776bb40e63d1abae2e9c4b4799ded98fbc449", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -320,7 +320,7 @@ saving_hasher::equal (const value_type *p1, const compare_type *p2)\n   return p1->obj == p2;\n }\n \n-static hash_table <saving_hasher> saving_htab;\n+static hash_table<saving_hasher> *saving_htab;\n \n /* Register an object in the hash table.  */\n \n@@ -334,7 +334,7 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n     return 0;\n \n   slot = (struct ptr_data **)\n-    saving_htab.find_slot_with_hash (obj, POINTER_HASH (obj), INSERT);\n+    saving_htab->find_slot_with_hash (obj, POINTER_HASH (obj), INSERT);\n   if (*slot != NULL)\n     {\n       gcc_assert ((*slot)->note_ptr_fn == note_ptr_fn\n@@ -365,7 +365,7 @@ gt_pch_note_reorder (void *obj, void *note_ptr_cookie,\n     return;\n \n   data = (struct ptr_data *)\n-    saving_htab.find_with_hash (obj, POINTER_HASH (obj));\n+    saving_htab->find_with_hash (obj, POINTER_HASH (obj));\n   gcc_assert (data && data->note_ptr_cookie == note_ptr_cookie);\n \n   data->reorder_fn = reorder_fn;\n@@ -431,7 +431,7 @@ relocate_ptrs (void *ptr_p, void *state_p)\n     return;\n \n   result = (struct ptr_data *)\n-    saving_htab.find_with_hash (*ptr, POINTER_HASH (*ptr));\n+    saving_htab->find_with_hash (*ptr, POINTER_HASH (*ptr));\n   gcc_assert (result);\n   *ptr = result->new_addr;\n }\n@@ -460,7 +460,7 @@ write_pch_globals (const struct ggc_root_tab * const *tab,\n \t  else\n \t    {\n \t      new_ptr = (struct ptr_data *)\n-\t\tsaving_htab.find_with_hash (ptr, POINTER_HASH (ptr));\n+\t\tsaving_htab->find_with_hash (ptr, POINTER_HASH (ptr));\n \t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n \t\tfatal_error (\"can%'t write PCH file: %m\");\n@@ -494,7 +494,7 @@ gt_pch_save (FILE *f)\n   gt_pch_save_stringpool ();\n \n   timevar_push (TV_PCH_PTR_REALLOC);\n-  saving_htab.create (50000);\n+  saving_htab = new hash_table<saving_hasher> (50000);\n \n   for (rt = gt_ggc_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n@@ -510,7 +510,7 @@ gt_pch_save (FILE *f)\n   state.f = f;\n   state.d = init_ggc_pch ();\n   state.count = 0;\n-  saving_htab.traverse <traversal_state *, ggc_call_count> (&state);\n+  saving_htab->traverse <traversal_state *, ggc_call_count> (&state);\n \n   mmi.size = ggc_pch_total_size (state.d);\n \n@@ -526,7 +526,7 @@ gt_pch_save (FILE *f)\n   state.ptrs = XNEWVEC (struct ptr_data *, state.count);\n   state.ptrs_i = 0;\n \n-  saving_htab.traverse <traversal_state *, ggc_call_alloc> (&state);\n+  saving_htab->traverse <traversal_state *, ggc_call_alloc> (&state);\n   timevar_pop (TV_PCH_PTR_REALLOC);\n \n   timevar_push (TV_PCH_PTR_SORT);\n@@ -655,7 +655,8 @@ gt_pch_save (FILE *f)\n \n   XDELETE (state.ptrs);\n   XDELETE (this_object);\n-  saving_htab.dispose ();\n+  delete saving_htab;\n+  saving_htab = NULL;\n }\n \n /* Read the state of the compiler back in from F.  */\n@@ -939,7 +940,7 @@ loc_desc_hasher::equal (const value_type *d, const compare_type *d2)\n }\n \n /* Hashtable used for statistics.  */\n-static hash_table <loc_desc_hasher> loc_hash;\n+static hash_table<loc_desc_hasher> *loc_hash;\n \n struct ptr_hash_entry\n {\n@@ -971,7 +972,7 @@ ptr_hash_hasher::equal (const value_type *p, const compare_type *p2)\n }\n \n /* Hashtable converting address of allocated field to loc descriptor.  */\n-static hash_table <ptr_hash_hasher> ptr_hash;\n+static hash_table<ptr_hash_hasher> *ptr_hash;\n \n /* Return descriptor for given call site, create new one if needed.  */\n static struct loc_descriptor *\n@@ -983,10 +984,10 @@ make_loc_descriptor (const char *name, int line, const char *function)\n   loc.file = name;\n   loc.line = line;\n   loc.function = function;\n-  if (!loc_hash.is_created ())\n-    loc_hash.create (10);\n+  if (!loc_hash)\n+    loc_hash = new hash_table<loc_desc_hasher> (10);\n \n-  slot = loc_hash.find_slot (&loc, INSERT);\n+  slot = loc_hash->find_slot (&loc, INSERT);\n   if (*slot)\n     return *slot;\n   *slot = XCNEW (struct loc_descriptor);\n@@ -1008,9 +1009,9 @@ ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n   p->ptr = ptr;\n   p->loc = loc;\n   p->size = allocated + overhead;\n-  if (!ptr_hash.is_created ())\n-    ptr_hash.create (10);\n-  slot = ptr_hash.find_slot_with_hash (ptr, htab_hash_pointer (ptr), INSERT);\n+  if (!ptr_hash)\n+    ptr_hash = new hash_table<ptr_hash_hasher> (10);\n+  slot = ptr_hash->find_slot_with_hash (ptr, htab_hash_pointer (ptr), INSERT);\n   gcc_assert (!*slot);\n   *slot = p;\n \n@@ -1028,7 +1029,7 @@ ggc_prune_ptr (ptr_hash_entry **slot, void *b ATTRIBUTE_UNUSED)\n   if (!ggc_marked_p (p->ptr))\n     {\n       p->loc->collected += p->size;\n-      ptr_hash.clear_slot (slot);\n+      ptr_hash->clear_slot (slot);\n       free (p);\n     }\n   return 1;\n@@ -1039,15 +1040,15 @@ ggc_prune_ptr (ptr_hash_entry **slot, void *b ATTRIBUTE_UNUSED)\n void\n ggc_prune_overhead_list (void)\n {\n-  ptr_hash.traverse <void *, ggc_prune_ptr> (NULL);\n+  ptr_hash->traverse <void *, ggc_prune_ptr> (NULL);\n }\n \n /* Notice that the pointer has been freed.  */\n void\n ggc_free_overhead (void *ptr)\n {\n-  ptr_hash_entry **slot;\n-  slot = ptr_hash.find_slot_with_hash (ptr, htab_hash_pointer (ptr), NO_INSERT);\n+  ptr_hash_entry **slot\n+    = ptr_hash->find_slot_with_hash (ptr, htab_hash_pointer (ptr), NO_INSERT);\n   struct ptr_hash_entry *p;\n   /* The pointer might be not found if a PCH read happened between allocation\n      and ggc_free () call.  FIXME: account memory properly in the presence of\n@@ -1056,7 +1057,7 @@ ggc_free_overhead (void *ptr)\n       return;\n   p = (struct ptr_hash_entry *) *slot;\n   p->loc->freed += p->size;\n-  ptr_hash.clear_slot (slot);\n+  ptr_hash->clear_slot (slot);\n   free (p);\n }\n \n@@ -1120,12 +1121,12 @@ dump_ggc_loc_statistics (bool final)\n   ggc_collect ();\n \n   loc_array = XCNEWVEC (struct loc_descriptor *,\n-\t\t\tloc_hash.elements_with_deleted ());\n+\t\t\tloc_hash->elements_with_deleted ());\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n   fprintf (stderr, \"\\n%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n \t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  loc_hash.traverse <int *, ggc_add_statistics> (&nentries);\n+  loc_hash->traverse <int *, ggc_add_statistics> (&nentries);\n   qsort (loc_array, nentries, sizeof (*loc_array),\n \t final ? final_cmp_statistic : cmp_statistic);\n   for (i = 0; i < nentries; i++)"}, {"sha": "c5944fa9c012405287588eb84b5218f0b5e4cd66", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -430,7 +430,7 @@ cand_chain_hasher::equal (const value_type *chain1, const compare_type *chain2)\n }\n \n /* Hash table embodying a mapping from base exprs to chains of candidates.  */\n-static hash_table <cand_chain_hasher> base_cand_map;\n+static hash_table<cand_chain_hasher> *base_cand_map;\n \f\n /* Pointer map used by tree_to_aff_combination_expand.  */\n static struct pointer_map_t *name_expansions;\n@@ -507,7 +507,7 @@ find_basis_for_base_expr (slsr_cand_t c, tree base_expr)\n   int max_iters = PARAM_VALUE (PARAM_MAX_SLSR_CANDIDATE_SCAN);\n \n   mapping_key.base_expr = base_expr;\n-  chain = base_cand_map.find (&mapping_key);\n+  chain = base_cand_map->find (&mapping_key);\n \n   for (; chain && iters < max_iters; chain = chain->next, ++iters)\n     {\n@@ -604,7 +604,7 @@ record_potential_basis (slsr_cand_t c, tree base)\n   node->base_expr = base;\n   node->cand = c;\n   node->next = NULL;\n-  slot = base_cand_map.find_slot (node, INSERT);\n+  slot = base_cand_map->find_slot (node, INSERT);\n \n   if (*slot)\n     {\n@@ -1848,7 +1848,8 @@ static void\n dump_cand_chains (void)\n {\n   fprintf (dump_file, \"\\nStrength reduction candidate chains:\\n\\n\");\n-  base_cand_map.traverse_noresize <void *, ssa_base_cand_dump_callback> (NULL);\n+  base_cand_map->traverse_noresize <void *, ssa_base_cand_dump_callback>\n+    (NULL);\n   fputs (\"\\n\", dump_file);\n }\n \n@@ -3634,7 +3635,7 @@ pass_strength_reduction::execute (function *fun)\n   gcc_obstack_init (&chain_obstack);\n \n   /* Allocate the mapping from base expressions to candidate chains.  */\n-  base_cand_map.create (500);\n+  base_cand_map = new hash_table<cand_chain_hasher> (500);\n \n   /* Allocate the mapping from bases to alternative bases.  */\n   alt_base_map = pointer_map_create ();\n@@ -3661,7 +3662,8 @@ pass_strength_reduction::execute (function *fun)\n   analyze_candidates_and_replace ();\n \n   loop_optimizer_finalize ();\n-  base_cand_map.dispose ();\n+  delete base_cand_map;\n+  base_cand_map = NULL;\n   obstack_free (&chain_obstack, NULL);\n   pointer_map_destroy (stmt_cand_map);\n   cand_vec.release ();"}, {"sha": "6bea3c67efeecdfac649dfb7d6cbdb5dcd9f36d0", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -121,7 +121,7 @@ struct gimplify_ctx\n \n   vec<tree> case_labels;\n   /* The formal temporary table.  Should this be persistent?  */\n-  hash_table <gimplify_hasher> temp_htab;\n+  hash_table<gimplify_hasher> *temp_htab;\n \n   int conditions;\n   bool save_stack;\n@@ -256,8 +256,8 @@ pop_gimplify_context (gimple body)\n   else\n     record_vars (c->temps);\n \n-  if (c->temp_htab.is_created ())\n-    c->temp_htab.dispose ();\n+  delete c->temp_htab;\n+  c->temp_htab = NULL;\n   ctx_free (c);\n }\n \n@@ -484,9 +484,9 @@ lookup_tmp_var (tree val, bool is_formal)\n       elt_t **slot;\n \n       elt.val = val;\n-      if (!gimplify_ctxp->temp_htab.is_created ())\n-        gimplify_ctxp->temp_htab.create (1000);\n-      slot = gimplify_ctxp->temp_htab.find_slot (&elt, INSERT);\n+      if (!gimplify_ctxp->temp_htab)\n+        gimplify_ctxp->temp_htab = new hash_table<gimplify_hasher> (1000);\n+      slot = gimplify_ctxp->temp_htab->find_slot (&elt, INSERT);\n       if (*slot == NULL)\n \t{\n \t  elt_p = XNEW (elt_t);"}, {"sha": "ad30909220eb82dfe91e6e28b8f00559717512ed", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -183,7 +183,7 @@ clast_index_hasher::remove (value_type *c)\n   free (c);\n }\n \n-typedef hash_table <clast_index_hasher> clast_index_htab_type;\n+typedef hash_table<clast_index_hasher> clast_index_htab_type;\n \n /* Returns a pointer to a new element of type clast_name_index_p built\n    from NAME, INDEX, LEVEL, BOUND_ONE, and BOUND_TWO.  */\n@@ -213,7 +213,7 @@ new_clast_name_index (const char *name, int index, int level,\n    vector of parameters.  */\n \n static inline int\n-clast_name_to_level (clast_name_p name, clast_index_htab_type index_table)\n+clast_name_to_level (clast_name_p name, clast_index_htab_type *index_table)\n {\n   struct clast_name_index tmp;\n   clast_name_index **slot;\n@@ -222,7 +222,7 @@ clast_name_to_level (clast_name_p name, clast_index_htab_type index_table)\n   tmp.name = ((const struct clast_name *) name)->name;\n   tmp.free_name = NULL;\n \n-  slot = index_table.find_slot (&tmp, NO_INSERT);\n+  slot = index_table->find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return ((struct clast_name_index *) *slot)->level;\n@@ -235,15 +235,15 @@ clast_name_to_level (clast_name_p name, clast_index_htab_type index_table)\n    SCATTERING_DIMENSIONS vector.  */\n \n static inline int\n-clast_name_to_index (struct clast_name *name, clast_index_htab_type index_table)\n+clast_name_to_index (struct clast_name *name, clast_index_htab_type *index_table)\n {\n   struct clast_name_index tmp;\n   clast_name_index **slot;\n \n   tmp.name = ((const struct clast_name *) name)->name;\n   tmp.free_name = NULL;\n \n-  slot = index_table.find_slot (&tmp, NO_INSERT);\n+  slot = index_table->find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return (*slot)->index;\n@@ -256,16 +256,17 @@ clast_name_to_index (struct clast_name *name, clast_index_htab_type index_table)\n    found in the INDEX_TABLE, false otherwise.  */\n \n static inline bool\n-clast_name_to_lb_ub (struct clast_name *name, clast_index_htab_type index_table,\n-\t\t     mpz_t bound_one, mpz_t bound_two)\n+clast_name_to_lb_ub (struct clast_name *name,\n+\t\t     clast_index_htab_type *index_table, mpz_t bound_one,\n+\t\t     mpz_t bound_two)\n {\n   struct clast_name_index tmp;\n   clast_name_index **slot;\n \n   tmp.name = name->name;\n   tmp.free_name = NULL;\n \n-  slot = index_table.find_slot (&tmp, NO_INSERT);\n+  slot = index_table->find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     {\n@@ -280,15 +281,15 @@ clast_name_to_lb_ub (struct clast_name *name, clast_index_htab_type index_table,\n /* Records in INDEX_TABLE the INDEX and LEVEL for NAME.  */\n \n static inline void\n-save_clast_name_index (clast_index_htab_type index_table, const char *name,\n+save_clast_name_index (clast_index_htab_type *index_table, const char *name,\n \t\t       int index, int level, mpz_t bound_one, mpz_t bound_two)\n {\n   struct clast_name_index tmp;\n   clast_name_index **slot;\n \n   tmp.name = name;\n   tmp.free_name = NULL;\n-  slot = index_table.find_slot (&tmp, INSERT);\n+  slot = index_table->find_slot (&tmp, INSERT);\n \n   if (slot)\n     {\n@@ -307,7 +308,7 @@ save_clast_name_index (clast_index_htab_type index_table, const char *name,\n \n typedef struct ivs_params {\n   vec<tree> params, *newivs;\n-  clast_index_htab_type newivs_index, params_index;\n+  clast_index_htab_type *newivs_index, *params_index;\n   sese region;\n } *ivs_params_p;\n \n@@ -319,15 +320,15 @@ clast_name_to_gcc (struct clast_name *name, ivs_params_p ip)\n {\n   int index;\n \n-  if (ip->params.exists () && ip->params_index.is_created ())\n+  if (ip->params.exists () && ip->params_index)\n     {\n       index = clast_name_to_index (name, ip->params_index);\n \n       if (index >= 0)\n \treturn ip->params[index];\n     }\n \n-  gcc_assert (ip->newivs && ip->newivs_index.is_created ());\n+  gcc_assert (ip->newivs && ip->newivs_index);\n   index = clast_name_to_index (name, ip->newivs_index);\n   gcc_assert (index >= 0);\n \n@@ -718,12 +719,12 @@ type_for_clast_name (struct clast_name *name, ivs_params_p ip, mpz_t bound_one,\n {\n   bool found = false;\n \n-  if (ip->params.exists () && ip->params_index.is_created ())\n+  if (ip->params.exists () && ip->params_index)\n     found = clast_name_to_lb_ub (name, ip->params_index, bound_one, bound_two);\n \n   if (!found)\n     {\n-      gcc_assert (ip->newivs && ip->newivs_index.is_created ());\n+      gcc_assert (ip->newivs && ip->newivs_index);\n       found = clast_name_to_lb_ub (name, ip->newivs_index, bound_one,\n \t\t\t\t   bound_two);\n       gcc_assert (found);\n@@ -1029,13 +1030,13 @@ new_bb_pbb_def (basic_block bb, poly_bb_p pbb)\n \n static void\n mark_bb_with_pbb (poly_bb_p pbb, basic_block bb,\n-\t\t  bb_pbb_htab_type bb_pbb_mapping)\n+\t\t  bb_pbb_htab_type *bb_pbb_mapping)\n {\n   bb_pbb_def tmp;\n   bb_pbb_def **x;\n \n   tmp.bb = bb;\n-  x = bb_pbb_mapping.find_slot (&tmp, INSERT);\n+  x = bb_pbb_mapping->find_slot (&tmp, INSERT);\n \n   if (x && !*x)\n     *x = new_bb_pbb_def (bb, pbb);\n@@ -1044,13 +1045,13 @@ mark_bb_with_pbb (poly_bb_p pbb, basic_block bb,\n /* Find BB's related poly_bb_p in hash table BB_PBB_MAPPING.  */\n \n poly_bb_p\n-find_pbb_via_hash (bb_pbb_htab_type bb_pbb_mapping, basic_block bb)\n+find_pbb_via_hash (bb_pbb_htab_type *bb_pbb_mapping, basic_block bb)\n {\n   bb_pbb_def tmp;\n   bb_pbb_def **slot;\n \n   tmp.bb = bb;\n-  slot = bb_pbb_mapping.find_slot (&tmp, NO_INSERT);\n+  slot = bb_pbb_mapping->find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return ((bb_pbb_def *) *slot)->pbb;\n@@ -1064,7 +1065,7 @@ find_pbb_via_hash (bb_pbb_htab_type bb_pbb_mapping, basic_block bb)\n    related poly_bb_p.  */\n \n scop_p\n-get_loop_body_pbbs (loop_p loop, bb_pbb_htab_type bb_pbb_mapping,\n+get_loop_body_pbbs (loop_p loop, bb_pbb_htab_type *bb_pbb_mapping,\n \t\t    vec<poly_bb_p> *pbbs)\n {\n   unsigned i;\n@@ -1094,7 +1095,7 @@ get_loop_body_pbbs (loop_p loop, bb_pbb_htab_type bb_pbb_mapping,\n \n static edge\n translate_clast_user (struct clast_user_stmt *stmt, edge next_e,\n-\t\t      bb_pbb_htab_type bb_pbb_mapping, ivs_params_p ip)\n+\t\t      bb_pbb_htab_type *bb_pbb_mapping, ivs_params_p ip)\n {\n   int i, nb_loops;\n   basic_block new_bb;\n@@ -1163,7 +1164,7 @@ graphite_create_new_loop_guard (edge entry_edge, struct clast_for *stmt,\n }\n \n static edge\n-translate_clast (loop_p, struct clast_stmt *, edge, bb_pbb_htab_type,\n+translate_clast (loop_p, struct clast_stmt *, edge, bb_pbb_htab_type *,\n \t\t int, ivs_params_p);\n \n /* Create the loop for a clast for statement.\n@@ -1173,7 +1174,7 @@ translate_clast (loop_p, struct clast_stmt *, edge, bb_pbb_htab_type,\n \n static edge\n translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n-\t\t\t  edge next_e, bb_pbb_htab_type bb_pbb_mapping,\n+\t\t\t  edge next_e, bb_pbb_htab_type *bb_pbb_mapping,\n \t\t\t  int level, tree type, tree lb, tree ub,\n \t\t\t  ivs_params_p ip)\n {\n@@ -1211,7 +1212,7 @@ translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n \n static edge\n translate_clast_for (loop_p context_loop, struct clast_for *stmt, edge next_e,\n-\t\t     bb_pbb_htab_type bb_pbb_mapping, int level,\n+\t\t     bb_pbb_htab_type *bb_pbb_mapping, int level,\n \t\t     ivs_params_p ip)\n {\n   tree type, lb, ub;\n@@ -1270,7 +1271,7 @@ translate_clast_assignment (struct clast_assignment *stmt, edge next_e,\n \n static edge\n translate_clast_guard (loop_p context_loop, struct clast_guard *stmt,\n-\t\t       edge next_e, bb_pbb_htab_type bb_pbb_mapping, int level,\n+\t\t       edge next_e, bb_pbb_htab_type *bb_pbb_mapping, int level,\n \t\t       ivs_params_p ip)\n {\n   edge last_e = graphite_create_new_guard (next_e, stmt, ip);\n@@ -1289,7 +1290,7 @@ translate_clast_guard (loop_p context_loop, struct clast_guard *stmt,\n \n static edge\n translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n-\t\t bb_pbb_htab_type bb_pbb_mapping, int level, ivs_params_p ip)\n+\t\t bb_pbb_htab_type *bb_pbb_mapping, int level, ivs_params_p ip)\n {\n   if (!stmt)\n     return next_e;\n@@ -1331,7 +1332,7 @@ translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n static CloogUnionDomain *\n add_names_to_union_domain (scop_p scop, CloogUnionDomain *union_domain,\n \t\t\t   int nb_scattering_dims,\n-\t\t\t   clast_index_htab_type params_index)\n+\t\t\t   clast_index_htab_type *params_index)\n {\n   sese region = SCOP_REGION (scop);\n   int i;\n@@ -1582,7 +1583,7 @@ int get_max_scattering_dimensions (scop_p scop)\n }\n \n static CloogInput *\n-generate_cloog_input (scop_p scop, clast_index_htab_type params_index)\n+generate_cloog_input (scop_p scop, clast_index_htab_type *params_index)\n {\n   CloogUnionDomain *union_domain;\n   CloogInput *cloog_input;\n@@ -1605,7 +1606,7 @@ generate_cloog_input (scop_p scop, clast_index_htab_type params_index)\n    without a program.  */\n \n static struct clast_stmt *\n-scop_to_clast (scop_p scop, clast_index_htab_type params_index)\n+scop_to_clast (scop_p scop, clast_index_htab_type *params_index)\n {\n   CloogInput *cloog_input;\n   struct clast_stmt *clast;\n@@ -1634,11 +1635,9 @@ void\n print_generated_program (FILE *file, scop_p scop)\n {\n   CloogOptions *options = set_cloog_options ();\n-  clast_index_htab_type params_index;\n+  clast_index_htab_type *params_index = new clast_index_htab_type (10);\n   struct clast_stmt *clast;\n \n-  params_index.create (10);\n-\n   clast = scop_to_clast (scop, params_index);\n \n   fprintf (file, \"       (clast: \\n\");\n@@ -1663,20 +1662,20 @@ debug_generated_program (scop_p scop)\n */\n \n bool\n-gloog (scop_p scop, bb_pbb_htab_type bb_pbb_mapping)\n+gloog (scop_p scop, bb_pbb_htab_type *bb_pbb_mapping)\n {\n   auto_vec<tree, 10> newivs;\n   loop_p context_loop;\n   sese region = SCOP_REGION (scop);\n   ifsese if_region = NULL;\n-  clast_index_htab_type newivs_index, params_index;\n+  clast_index_htab_type *newivs_index, *params_index;\n   struct clast_stmt *clast;\n   struct ivs_params ip;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n   gloog_error = false;\n \n-  params_index.create (10);\n+  params_index = new clast_index_htab_type (10);\n \n   clast = scop_to_clast (scop, params_index);\n \n@@ -1699,7 +1698,7 @@ gloog (scop_p scop, bb_pbb_htab_type bb_pbb_mapping)\n   graphite_verify ();\n \n   context_loop = SESE_ENTRY (region)->src->loop_father;\n-  newivs_index.create (10);\n+  newivs_index= new clast_index_htab_type (10);\n \n   ip.newivs = &newivs;\n   ip.newivs_index = newivs_index;\n@@ -1721,8 +1720,10 @@ gloog (scop_p scop, bb_pbb_htab_type bb_pbb_mapping)\n   free (if_region->region);\n   free (if_region);\n \n-  newivs_index.dispose ();\n-  params_index.dispose ();\n+  delete newivs_index;\n+  newivs_index = NULL;\n+  delete params_index;\n+  params_index = NULL;\n   cloog_clast_free (clast);\n   timevar_pop (TV_GRAPHITE_CODE_GEN);\n "}, {"sha": "8c90c8e434f72fbf46bc5b14d5736b3379d0e2ce", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -587,7 +587,7 @@ loop_level_carries_dependences (scop_p scop, vec<poly_bb_p> body,\n    poly_bb_p.  */\n \n bool\n-loop_is_parallel_p (loop_p loop, bb_pbb_htab_type bb_pbb_mapping, int depth)\n+loop_is_parallel_p (loop_p loop, bb_pbb_htab_type *bb_pbb_mapping, int depth)\n {\n   bool dependences;\n   scop_p scop;"}, {"sha": "ee2507f87ed843c6f90c73ea42fdd4cafecd5b5c", "filename": "gcc/graphite-htab.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite-htab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite-htab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-htab.h?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -50,11 +50,11 @@ bb_pbb_hasher::equal (const value_type *bp1, const compare_type *bp2)\n   return (bp1->bb->index == bp2->bb->index);\n }\n \n-typedef hash_table <bb_pbb_hasher> bb_pbb_htab_type;\n+typedef hash_table<bb_pbb_hasher> bb_pbb_htab_type;\n \n-extern bool gloog (scop_p, bb_pbb_htab_type);\n-poly_bb_p find_pbb_via_hash (bb_pbb_htab_type, basic_block);\n-bool loop_is_parallel_p (loop_p, bb_pbb_htab_type, int);\n-scop_p get_loop_body_pbbs (loop_p, bb_pbb_htab_type, vec<poly_bb_p> *);\n+extern bool gloog (scop_p, bb_pbb_htab_type *);\n+poly_bb_p find_pbb_via_hash (bb_pbb_htab_type *, basic_block);\n+bool loop_is_parallel_p (loop_p, bb_pbb_htab_type *, int);\n+scop_p get_loop_body_pbbs (loop_p, bb_pbb_htab_type *, vec<poly_bb_p> *);\n \n #endif"}, {"sha": "5d1e8706bfde40827f406fa3fd637f9805233d87", "filename": "gcc/graphite.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -269,7 +269,6 @@ graphite_transform_loops (void)\n   scop_p scop;\n   bool need_cfg_cleanup_p = false;\n   vec<scop_p> scops = vNULL;\n-  bb_pbb_htab_type bb_pbb_mapping;\n   isl_ctx *ctx;\n \n   /* If a function is parallel it was most probably already run through graphite\n@@ -291,8 +290,7 @@ graphite_transform_loops (void)\n       print_global_statistics (dump_file);\n     }\n \n-  bb_pbb_mapping.create (10);\n-\n+  bb_pbb_htab_type bb_pbb_mapping (10);\n   FOR_EACH_VEC_ELT (scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       {\n@@ -301,11 +299,10 @@ graphite_transform_loops (void)\n \n \tif (POLY_SCOP_P (scop)\n \t    && apply_poly_transforms (scop)\n-\t    && gloog (scop, bb_pbb_mapping))\n+\t    && gloog (scop, &bb_pbb_mapping))\n \t  need_cfg_cleanup_p = true;\n       }\n \n-  bb_pbb_mapping.dispose ();\n   free_scops (scops);\n   graphite_finalize (need_cfg_cleanup_p);\n   the_isl_ctx = NULL;"}, {"sha": "f93fe4ca0997add721cf94c74bca6c0800e30f84", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -651,8 +651,8 @@ delay_i2_hasher::equal (const value_type *x, const compare_type *y)\n \n /* Two hash tables to record delay_pairs, one indexed by I1 and the other\n    indexed by I2.  */\n-static hash_table <delay_i1_hasher> delay_htab;\n-static hash_table <delay_i2_hasher> delay_htab_i2;\n+static hash_table<delay_i1_hasher> *delay_htab;\n+static hash_table<delay_i2_hasher> *delay_htab_i2;\n \n /* Called through htab_traverse.  Walk the hashtable using I2 as\n    index, and delete all elements involving an UID higher than\n@@ -664,7 +664,7 @@ haifa_htab_i2_traverse (delay_pair **slot, int *data)\n   struct delay_pair *p = *slot;\n   if (INSN_UID (p->i2) >= maxuid || INSN_UID (p->i1) >= maxuid)\n     {\n-      delay_htab_i2.clear_slot (slot);\n+      delay_htab_i2->clear_slot (slot);\n     }\n   return 1;\n }\n@@ -680,7 +680,7 @@ haifa_htab_i1_traverse (delay_pair **pslot, int *data)\n \n   if (INSN_UID ((*pslot)->i1) >= maxuid)\n     {\n-      delay_htab.clear_slot (pslot);\n+      delay_htab->clear_slot (pslot);\n       return 1;\n     }\n   pprev = &first;\n@@ -694,7 +694,7 @@ haifa_htab_i1_traverse (delay_pair **pslot, int *data)\n     }\n   *pprev = NULL;\n   if (first == NULL)\n-    delay_htab.clear_slot (pslot);\n+    delay_htab->clear_slot (pslot);\n   else\n     *pslot = first;\n   return 1;\n@@ -705,8 +705,8 @@ haifa_htab_i1_traverse (delay_pair **pslot, int *data)\n void\n discard_delay_pairs_above (int max_uid)\n {\n-  delay_htab.traverse <int *, haifa_htab_i1_traverse> (&max_uid);\n-  delay_htab_i2.traverse <int *, haifa_htab_i2_traverse> (&max_uid);\n+  delay_htab->traverse <int *, haifa_htab_i1_traverse> (&max_uid);\n+  delay_htab_i2->traverse <int *, haifa_htab_i2_traverse> (&max_uid);\n }\n \n /* This function can be called by a port just before it starts the final\n@@ -736,15 +736,15 @@ record_delay_slot_pair (rtx i1, rtx i2, int cycles, int stages)\n   p->cycles = cycles;\n   p->stages = stages;\n \n-  if (!delay_htab.is_created ())\n+  if (!delay_htab)\n     {\n-      delay_htab.create (10);\n-      delay_htab_i2.create (10);\n+      delay_htab = new hash_table<delay_i1_hasher> (10);\n+      delay_htab_i2 = new hash_table<delay_i2_hasher> (10);\n     }\n-  slot = delay_htab.find_slot_with_hash (i1, htab_hash_pointer (i1), INSERT);\n+  slot = delay_htab->find_slot_with_hash (i1, htab_hash_pointer (i1), INSERT);\n   p->next_same_i1 = *slot;\n   *slot = p;\n-  slot = delay_htab_i2.find_slot_with_hash (i2, htab_hash_pointer (i2), INSERT);\n+  slot = delay_htab_i2->find_slot (p, INSERT);\n   *slot = p;\n }\n \n@@ -755,10 +755,10 @@ real_insn_for_shadow (rtx insn)\n {\n   struct delay_pair *pair;\n \n-  if (!delay_htab.is_created ())\n+  if (!delay_htab)\n     return NULL_RTX;\n \n-  pair = delay_htab_i2.find_with_hash (insn, htab_hash_pointer (insn));\n+  pair = delay_htab_i2->find_with_hash (insn, htab_hash_pointer (insn));\n   if (!pair || pair->stages > 0)\n     return NULL_RTX;\n   return pair->i1;\n@@ -786,10 +786,10 @@ add_delay_dependencies (rtx insn)\n   sd_iterator_def sd_it;\n   dep_t dep;\n \n-  if (!delay_htab.is_created ())\n+  if (!delay_htab)\n     return;\n \n-  pair = delay_htab_i2.find_with_hash (insn, htab_hash_pointer (insn));\n+  pair = delay_htab_i2->find_with_hash (insn, htab_hash_pointer (insn));\n   if (!pair)\n     return;\n   add_dependence (insn, pair->i1, REG_DEP_ANTI);\n@@ -800,7 +800,7 @@ add_delay_dependencies (rtx insn)\n     {\n       rtx pro = DEP_PRO (dep);\n       struct delay_pair *other_pair\n-\t= delay_htab_i2.find_with_hash (pro, htab_hash_pointer (pro));\n+\t= delay_htab_i2->find_with_hash (pro, htab_hash_pointer (pro));\n       if (!other_pair || other_pair->stages)\n \tcontinue;\n       if (pair_delay (other_pair) >= pair_delay (pair))\n@@ -1421,11 +1421,11 @@ dep_cost_1 (dep_t link, dw_t dw)\n   if (DEP_COST (link) != UNKNOWN_DEP_COST)\n     return DEP_COST (link);\n \n-  if (delay_htab.is_created ())\n+  if (delay_htab)\n     {\n       struct delay_pair *delay_entry;\n       delay_entry\n-\t= delay_htab_i2.find_with_hash (used, htab_hash_pointer (used));\n+\t= delay_htab_i2->find_with_hash (used, htab_hash_pointer (used));\n       if (delay_entry)\n \t{\n \t  if (delay_entry->i1 == insn)\n@@ -5779,12 +5779,12 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n \t    {\n \t      int delay_cost = 0;\n \n-\t      if (delay_htab.is_created ())\n+\t      if (delay_htab)\n \t\t{\n \t\t  struct delay_pair *delay_entry;\n \t\t  delay_entry\n-\t\t    = delay_htab.find_with_hash (insn,\n-\t\t\t\t\t\t htab_hash_pointer (insn));\n+\t\t    = delay_htab->find_with_hash (insn,\n+\t\t\t\t\t\t  htab_hash_pointer (insn));\n \t\t  while (delay_entry && delay_cost == 0)\n \t\t    {\n \t\t      delay_cost = estimate_shadow_tick (delay_entry);\n@@ -6278,13 +6278,13 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t      goto restart_choose_ready;\n \t    }\n \n-\t  if (delay_htab.is_created ())\n+\t  if (delay_htab)\n \t    {\n \t      /* If this insn is the first part of a delay-slot pair, record a\n \t\t backtrack point.  */\n \t      struct delay_pair *delay_entry;\n \t      delay_entry\n-\t\t= delay_htab.find_with_hash (insn, htab_hash_pointer (insn));\n+\t\t= delay_htab->find_with_hash (insn, htab_hash_pointer (insn));\n \t      if (delay_entry)\n \t\t{\n \t\t  save_backtrack_point (delay_entry, ls);\n@@ -6873,10 +6873,10 @@ sched_finish (void)\n void\n free_delay_pairs (void)\n {\n-  if (delay_htab.is_created ())\n+  if (delay_htab)\n     {\n-      delay_htab.empty ();\n-      delay_htab_i2.empty ();\n+      delay_htab->empty ();\n+      delay_htab_i2->empty ();\n     }\n }\n "}, {"sha": "41cc19e52fb3918656bd4f14a506ec392eb4a7e4", "filename": "gcc/hash-table.h", "status": "modified", "additions": 232, "deletions": 440, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -60,12 +60,6 @@ along with GCC; see the file COPYING3.  If not see\n       is allocated.  This type is called the allocator type.  It is\n       parameterized on the value type.  It provides four functions.\n \n-         - A static member function named 'control_alloc'.  This function\n-         allocates the control data blocks for the table.\n-\n-         - A static member function named 'control_free'.  This function\n-         frees the control data blocks for the table.\n-\n          - A static member function named 'data_alloc'.  This function\n          allocates the data elements in the table.\n \n@@ -211,23 +205,11 @@ along with GCC; see the file COPYING3.  If not see\n template <typename Type>\n struct xcallocator\n {\n-  static Type *control_alloc (size_t count);\n   static Type *data_alloc (size_t count);\n-  static void control_free (Type *memory);\n   static void data_free (Type *memory);\n };\n \n \n-/* Allocate memory for COUNT control blocks.  */\n-\n-template <typename Type>\n-inline Type *\n-xcallocator <Type>::control_alloc (size_t count)\n-{\n-  return static_cast <Type *> (xcalloc (count, sizeof (Type)));\n-}\n-\n-\n /* Allocate memory for COUNT data blocks.  */\n \n template <typename Type>\n@@ -238,16 +220,6 @@ xcallocator <Type>::data_alloc (size_t count)\n }\n \n \n-/* Free memory for control blocks.  */\n-\n-template <typename Type>\n-inline void\n-xcallocator <Type>::control_free (Type *memory)\n-{\n-  return ::free (memory);\n-}\n-\n-\n /* Free memory for data blocks.  */\n \n template <typename Type>\n@@ -348,37 +320,6 @@ extern hashval_t hash_table_mod1 (hashval_t hash, unsigned int index);\n extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);\n \n \n-/* Internal implementation type.  */\n-\n-template <typename T>\n-struct hash_table_control\n-{\n-  /* Table itself.  */\n-  T **entries;\n-\n-  /* Current size (in entries) of the hash table.  */\n-  size_t size;\n-\n-  /* Current number of elements including also deleted elements.  */\n-  size_t n_elements;\n-\n-  /* Current number of deleted elements in the table.  */\n-  size_t n_deleted;\n-\n-  /* The following member is used for debugging. Its value is number\n-     of all calls of `htab_find_slot' for the hash table. */\n-  unsigned int searches;\n-\n-  /* The following member is used for debugging.  Its value is number\n-     of collisions fixed for time of work with the hash table. */\n-  unsigned int collisions;\n-\n-  /* Current size (in entries) of the hash table, as an index into the\n-     table of primes.  */\n-  unsigned int size_prime_index;\n-};\n-\n-\n /* User-facing hash table type.\n \n    The table stores elements of type Descriptor::value_type.\n@@ -400,278 +341,231 @@ struct hash_table_control\n      The default is xcallocator.\n \n */\n-\n template <typename Descriptor,\n-\t  template <typename Type> class Allocator = xcallocator>\n+\t template<typename Type> class Allocator= xcallocator>\n class hash_table\n {\n-public:\n   typedef typename Descriptor::value_type value_type;\n   typedef typename Descriptor::compare_type compare_type;\n \n-  class iterator\n-  {\n-  public:\n-    inline iterator ();\n-    inline iterator (value_type **, value_type **);\n-    inline value_type &operator * ();\n-    void slide ();\n-    inline iterator &operator ++ ();\n-    inline bool operator != (const iterator &) const;\n-  private:\n-    value_type **m_slot;\n-    value_type **m_limit;\n-  };\n-\n-private:\n-  hash_table_control <value_type> *htab;\n-\n-  value_type **find_empty_slot_for_expand (hashval_t hash);\n-  void expand ();\n-\n public:\n-  hash_table ();\n-  void create (size_t initial_slots);\n-  bool is_created ();\n-  void dispose ();\n-  value_type *find (const value_type *value);\n-  value_type *find_with_hash (const compare_type *comparable, hashval_t hash);\n-  value_type **find_slot (const value_type *value, enum insert_option insert);\n-  value_type **find_slot_with_hash (const compare_type *comparable,\n-\t\t\t\t    hashval_t hash, enum insert_option insert);\n-  void empty ();\n-  void clear_slot (value_type **slot);\n-  void remove_elt (const value_type *value);\n-  void remove_elt_with_hash (const compare_type *comparable, hashval_t hash);\n-  size_t size ();\n-  size_t elements ();\n-  size_t elements_with_deleted ();\n-  double collisions ();\n-\n-  template <typename Argument,\n-\t    int (*Callback) (value_type **slot, Argument argument)>\n-  void traverse_noresize (Argument argument);\n-\n-  template <typename Argument,\n-\t    int (*Callback) (value_type **slot, Argument argument)>\n-  void traverse (Argument argument);\n+  hash_table (size_t);\n+  ~hash_table ();\n \n-  iterator begin ();\n-  iterator end ();\n-};\n+  /* Current size (in entries) of the hash table.  */\n+  size_t size () const { return m_size; }\n \n+  /* Return the current number of elements in this hash table. */\n+  size_t elements () const { return m_n_elements - m_n_deleted; }\n \n-/* Construct the hash table.  The only useful operation next is create.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline\n-hash_table <Descriptor, Allocator>::hash_table ()\n-: htab (NULL)\n-{\n-}\n+  /* Return the current number of elements in this hash table. */\n+  size_t elements_with_deleted () const { return m_n_elements; }\n \n+  /* This function clears all entries in the given hash table.  */\n+  void empty ();\n \n-/* See if the table has been created, as opposed to constructed.  */\n+  /* This function clears a specified SLOT in a hash table.  It is\n+     useful when you've already done the lookup and don't want to do it\n+     again. */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline bool\n-hash_table <Descriptor, Allocator>::is_created ()\n-{\n-  return htab != NULL;\n-}\n+  void clear_slot (value_type **);\n \n+  /* This function searches for a hash table entry equal to the given\n+     COMPARABLE element starting with the given HASH value.  It cannot\n+     be used to insert or delete an element. */\n+  value_type *find_with_hash (const compare_type *, hashval_t);\n \n-/* Like find_with_hash, but compute the hash value from the element.  */\n+/* Like find_slot_with_hash, but compute the hash value from the element.  */\n+  value_type *find (const value_type *value)\n+    {\n+      return find_with_hash (value, Descriptor::hash (value));\n+    }\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline typename Descriptor::value_type *\n-hash_table <Descriptor, Allocator>::find (const value_type *value)\n-{\n-  return find_with_hash (value, Descriptor::hash (value));\n-}\n+  value_type **find_slot (const value_type *value, insert_option insert)\n+    {\n+      return find_slot_with_hash (value, Descriptor::hash (value), insert);\n+    }\n \n+  /* This function searches for a hash table slot containing an entry\n+     equal to the given COMPARABLE element and starting with the given\n+     HASH.  To delete an entry, call this with insert=NO_INSERT, then\n+     call clear_slot on the slot returned (possibly after doing some\n+     checks).  To insert an entry, call this with insert=INSERT, then\n+     write the value you want into the returned slot.  When inserting an\n+     entry, NULL may be returned if memory allocation fails. */\n+  value_type **find_slot_with_hash (const compare_type *comparable,\n+\t\t\t\t    hashval_t hash, enum insert_option insert);\n \n-/* Like find_slot_with_hash, but compute the hash value from the element.  */\n+  /* This function deletes an element with the given COMPARABLE value\n+     from hash table starting with the given HASH.  If there is no\n+     matching element in the hash table, this function does nothing. */\n+  void remove_elt_with_hash (const compare_type *, hashval_t);\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline typename Descriptor::value_type **\n-hash_table <Descriptor, Allocator>\n-::find_slot (const value_type *value, enum insert_option insert)\n-{\n-  return find_slot_with_hash (value, Descriptor::hash (value), insert);\n-}\n+/* Like remove_elt_with_hash, but compute the hash value from the element.  */\n+  void remove_elt (const value_type *value)\n+    {\n+      remove_elt_with_hash (value, Descriptor::hash (value));\n+    }\n \n+  /* This function scans over the entire hash table calling CALLBACK for\n+     each live entry.  If CALLBACK returns false, the iteration stops.\n+     ARGUMENT is passed as CALLBACK's second argument. */\n+  template <typename Argument,\n+\t    int (*Callback) (value_type **slot, Argument argument)>\n+  void traverse_noresize (Argument argument);\n \n-/* Like remove_elt_with_hash, but compute the hash value from the element.  */\n+  /* Like traverse_noresize, but does resize the table when it is too empty\n+     to improve effectivity of subsequent calls.  */\n+  template <typename Argument,\n+\t    int (*Callback) (value_type **slot, Argument argument)>\n+  void traverse (Argument argument);\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline void\n-hash_table <Descriptor, Allocator>::remove_elt (const value_type *value)\n-{\n-  remove_elt_with_hash (value, Descriptor::hash (value));\n-}\n+  class iterator\n+  {\n+  public:\n+    iterator () : m_slot (NULL), m_limit (NULL) {}\n \n+    iterator (value_type **slot, value_type **limit) :\n+      m_slot (slot), m_limit (limit) {}\n \n-/* Return the current size of this hash table.  */\n+    inline value_type &operator * () { return **m_slot; }\n+    void slide ();\n+    inline iterator &operator ++ ();\n+    bool operator != (const iterator &other) const\n+      {\n+\treturn m_slot != other.m_slot || m_limit != other.m_limit;\n+      }\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline size_t\n-hash_table <Descriptor, Allocator>::size ()\n-{\n-  return htab->size;\n-}\n+  private:\n+    value_type **m_slot;\n+    value_type **m_limit;\n+  };\n \n+  iterator begin () const\n+    {\n+      iterator iter (m_entries, m_entries + m_size);\n+      iter.slide ();\n+      return iter;\n+    }\n \n-/* Return the current number of elements in this hash table. */\n+  iterator end () const { return iterator (); }\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline size_t\n-hash_table <Descriptor, Allocator>::elements ()\n-{\n-  return htab->n_elements - htab->n_deleted;\n-}\n+  double collisions () const\n+    {\n+      return m_searches ? static_cast <double> (m_collisions) / m_searches : 0;\n+    }\n \n+private:\n \n-/* Return the current number of elements in this hash table. */\n+  value_type **find_empty_slot_for_expand (hashval_t);\n+  void expand ();\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline size_t\n-hash_table <Descriptor, Allocator>::elements_with_deleted ()\n-{\n-  return htab->n_elements;\n-}\n+  /* Table itself.  */\n+  typename Descriptor::value_type **m_entries;\n \n+  size_t m_size;\n \n-  /* Return the fraction of fixed collisions during all work with given\n-     hash table. */\n+  /* Current number of elements including also deleted elements.  */\n+  size_t m_n_elements;\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline double\n-hash_table <Descriptor, Allocator>::collisions ()\n-{\n-  if (htab->searches == 0)\n-    return 0.0;\n+  /* Current number of deleted elements in the table.  */\n+  size_t m_n_deleted;\n \n-  return static_cast <double> (htab->collisions) / htab->searches;\n-}\n+  /* The following member is used for debugging. Its value is number\n+     of all calls of `htab_find_slot' for the hash table. */\n+  unsigned int m_searches;\n \n+  /* The following member is used for debugging.  Its value is number\n+     of collisions fixed for time of work with the hash table. */\n+  unsigned int m_collisions;\n \n-/* Create a hash table with at least the given number of INITIAL_SLOTS.  */\n+  /* Current size (in entries) of the hash table, as an index into the\n+     table of primes.  */\n+  unsigned int m_size_prime_index;\n+};\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-void\n-hash_table <Descriptor, Allocator>::create (size_t size)\n+template<typename Descriptor, template<typename Type> class Allocator>\n+hash_table<Descriptor, Allocator>::hash_table (size_t size) :\n+  m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0)\n {\n   unsigned int size_prime_index;\n \n   size_prime_index = hash_table_higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n-  htab = Allocator <hash_table_control <value_type> > ::control_alloc (1);\n-  gcc_assert (htab != NULL);\n-  htab->entries = Allocator <value_type*> ::data_alloc (size);\n-  gcc_assert (htab->entries != NULL);\n-  htab->size = size;\n-  htab->size_prime_index = size_prime_index;\n+  m_entries = Allocator <value_type*> ::data_alloc (size);\n+  gcc_assert (m_entries != NULL);\n+  m_size = size;\n+  m_size_prime_index = size_prime_index;\n }\n \n-\n-/* Dispose of a hash table.  Free all memory and return this hash table to\n-   the non-created state.  Naturally the hash table must already exist.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-void\n-hash_table <Descriptor, Allocator>::dispose ()\n+template<typename Descriptor, template<typename Type> class Allocator>\n+hash_table<Descriptor, Allocator>::~hash_table ()\n {\n-  size_t size = htab->size;\n-  value_type **entries = htab->entries;\n+  for (size_t i = m_size - 1; i < m_size; i--)\n+    if (m_entries[i] != HTAB_EMPTY_ENTRY && m_entries[i] != HTAB_DELETED_ENTRY)\n+      Descriptor::remove (m_entries[i]);\n \n-  for (int i = size - 1; i >= 0; i--)\n-    if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Descriptor::remove (entries[i]);\n-\n-  Allocator <value_type *> ::data_free (entries);\n-  Allocator <hash_table_control <value_type> > ::control_free (htab);\n-  htab = NULL;\n+  Allocator <value_type *> ::data_free (m_entries);\n }\n \n-\n /* Similar to find_slot, but without several unwanted side effects:\n     - Does not call equal when it finds an existing entry.\n     - Does not change the count of elements/searches/collisions in the\n       hash table.\n    This function also assumes there are no deleted entries in the table.\n    HASH is the hash value for the element to be inserted.  */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n typename Descriptor::value_type **\n-hash_table <Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n+hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n {\n-  hashval_t index = hash_table_mod1 (hash, htab->size_prime_index);\n-  size_t size = htab->size;\n-  value_type **slot = htab->entries + index;\n+  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n+  size_t size = m_size;\n+  value_type **slot = m_entries + index;\n   hashval_t hash2;\n \n   if (*slot == HTAB_EMPTY_ENTRY)\n     return slot;\n   else if (*slot == HTAB_DELETED_ENTRY)\n     abort ();\n \n-  hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n+  hash2 = hash_table_mod2 (hash, m_size_prime_index);\n   for (;;)\n     {\n       index += hash2;\n       if (index >= size)\n         index -= size;\n \n-      slot = htab->entries + index;\n+      slot = m_entries + index;\n       if (*slot == HTAB_EMPTY_ENTRY)\n         return slot;\n       else if (*slot == HTAB_DELETED_ENTRY)\n         abort ();\n     }\n }\n \n-\n /* The following function changes size of memory allocated for the\n    entries and repeatedly inserts the table elements.  The occupancy\n    of the table after the call will be about 50%.  Naturally the hash\n    table must already exist.  Remember also that the place of the\n    table entries is changed.  If memory allocation fails, this function\n    will abort.  */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n+\t  template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table <Descriptor, Allocator>::expand ()\n+hash_table<Descriptor, Allocator>::expand ()\n {\n-  value_type **oentries;\n-  value_type **olimit;\n-  value_type **p;\n-  value_type **nentries;\n-  size_t nsize, osize, elts;\n-  unsigned int oindex, nindex;\n-\n-  oentries = htab->entries;\n-  oindex = htab->size_prime_index;\n-  osize = htab->size;\n-  olimit = oentries + osize;\n-  elts = elements ();\n+  value_type **oentries = m_entries;\n+  unsigned int oindex = m_size_prime_index;\n+  size_t osize = size ();\n+  value_type **olimit = oentries + osize;\n+  size_t elts = elements ();\n \n   /* Resize only when table after removal of unused elements is either\n      too full or too empty.  */\n+  unsigned int nindex;\n+  size_t nsize;\n   if (elts * 2 > osize || (elts * 8 < osize && osize > 32))\n     {\n       nindex = hash_table_higher_prime_index (elts * 2);\n@@ -683,15 +577,15 @@ hash_table <Descriptor, Allocator>::expand ()\n       nsize = osize;\n     }\n \n-  nentries = Allocator <value_type *> ::data_alloc (nsize);\n+  value_type **nentries = Allocator <value_type *> ::data_alloc (nsize);\n   gcc_assert (nentries != NULL);\n-  htab->entries = nentries;\n-  htab->size = nsize;\n-  htab->size_prime_index = nindex;\n-  htab->n_elements -= htab->n_deleted;\n-  htab->n_deleted = 0;\n+  m_entries = nentries;\n+  m_size = nsize;\n+  m_size_prime_index = nindex;\n+  m_n_elements -= m_n_deleted;\n+  m_n_deleted = 0;\n \n-  p = oentries;\n+  value_type **p = oentries;\n   do\n     {\n       value_type *x = *p;\n@@ -710,47 +604,87 @@ hash_table <Descriptor, Allocator>::expand ()\n   Allocator <value_type *> ::data_free (oentries);\n }\n \n+template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator>::empty ()\n+{\n+  size_t size = m_size;\n+  value_type **entries = m_entries;\n+  int i;\n+\n+  for (i = size - 1; i >= 0; i--)\n+    if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n+      Descriptor::remove (entries[i]);\n+\n+  /* Instead of clearing megabyte, downsize the table.  */\n+  if (size > 1024*1024 / sizeof (PTR))\n+    {\n+      int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n+      int nsize = prime_tab[nindex].prime;\n+\n+      Allocator <value_type *> ::data_free (m_entries);\n+      m_entries = Allocator <value_type *> ::data_alloc (nsize);\n+      m_size = nsize;\n+      m_size_prime_index = nindex;\n+    }\n+  else\n+    memset (entries, 0, size * sizeof (value_type *));\n+  m_n_deleted = 0;\n+  m_n_elements = 0;\n+}\n+\n+/* This function clears a specified SLOT in a hash table.  It is\n+   useful when you've already done the lookup and don't want to do it\n+   again. */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator>::clear_slot (value_type **slot)\n+{\n+  if (slot < m_entries || slot >= m_entries + size ()\n+      || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n+    abort ();\n+\n+  Descriptor::remove (*slot);\n+\n+  *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n+  m_n_deleted++;\n+}\n \n /* This function searches for a hash table entry equal to the given\n    COMPARABLE element starting with the given HASH value.  It cannot\n    be used to insert or delete an element. */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n typename Descriptor::value_type *\n-hash_table <Descriptor, Allocator>\n+hash_table<Descriptor, Allocator>\n ::find_with_hash (const compare_type *comparable, hashval_t hash)\n {\n-  hashval_t index, hash2;\n-  size_t size;\n-  value_type *entry;\n+  m_searches++;\n+  size_t size = m_size;\n+  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n \n-  htab->searches++;\n-  size = htab->size;\n-  index = hash_table_mod1 (hash, htab->size_prime_index);\n-\n-  entry = htab->entries[index];\n+  value_type *entry = m_entries[index];\n   if (entry == HTAB_EMPTY_ENTRY\n       || (entry != HTAB_DELETED_ENTRY && Descriptor::equal (entry, comparable)))\n     return entry;\n \n-  hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n+  hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n   for (;;)\n     {\n-      htab->collisions++;\n+      m_collisions++;\n       index += hash2;\n       if (index >= size)\n         index -= size;\n \n-      entry = htab->entries[index];\n+      entry = m_entries[index];\n       if (entry == HTAB_EMPTY_ENTRY\n           || (entry != HTAB_DELETED_ENTRY\n \t      && Descriptor::equal (entry, comparable)))\n         return entry;\n     }\n }\n \n-\n /* This function searches for a hash table slot containing an entry\n    equal to the given COMPARABLE element and starting with the given\n    HASH.  To delete an entry, call this with insert=NO_INSERT, then\n@@ -759,56 +693,46 @@ ::find_with_hash (const compare_type *comparable, hashval_t hash)\n    write the value you want into the returned slot.  When inserting an\n    entry, NULL may be returned if memory allocation fails. */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n typename Descriptor::value_type **\n-hash_table <Descriptor, Allocator>\n+hash_table<Descriptor, Allocator>\n ::find_slot_with_hash (const compare_type *comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n-  value_type **first_deleted_slot;\n-  hashval_t index, hash2;\n-  size_t size;\n-  value_type *entry;\n-\n-  size = htab->size;\n-  if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n-    {\n-      expand ();\n-      size = htab->size;\n-    }\n-\n-  index = hash_table_mod1 (hash, htab->size_prime_index);\n+  if (insert == INSERT && m_size * 3 <= m_n_elements * 4)\n+    expand ();\n \n-  htab->searches++;\n-  first_deleted_slot = NULL;\n+  m_searches++;\n \n-  entry = htab->entries[index];\n+  value_type **first_deleted_slot = NULL;\n+  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n+  hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n+  value_type *entry = m_entries[index];\n+  size_t size = m_size;\n   if (entry == HTAB_EMPTY_ENTRY)\n     goto empty_entry;\n   else if (entry == HTAB_DELETED_ENTRY)\n-    first_deleted_slot = &htab->entries[index];\n+    first_deleted_slot = &m_entries[index];\n   else if (Descriptor::equal (entry, comparable))\n-    return &htab->entries[index];\n+    return &m_entries[index];\n \n-  hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n   for (;;)\n     {\n-      htab->collisions++;\n+      m_collisions++;\n       index += hash2;\n       if (index >= size)\n \tindex -= size;\n \n-      entry = htab->entries[index];\n+      entry = m_entries[index];\n       if (entry == HTAB_EMPTY_ENTRY)\n \tgoto empty_entry;\n       else if (entry == HTAB_DELETED_ENTRY)\n \t{\n \t  if (!first_deleted_slot)\n-\t    first_deleted_slot = &htab->entries[index];\n+\t    first_deleted_slot = &m_entries[index];\n \t}\n       else if (Descriptor::equal (entry, comparable))\n-\treturn &htab->entries[index];\n+\treturn &m_entries[index];\n     }\n \n  empty_entry:\n@@ -817,108 +741,47 @@ ::find_slot_with_hash (const compare_type *comparable, hashval_t hash,\n \n   if (first_deleted_slot)\n     {\n-      htab->n_deleted--;\n+      m_n_deleted--;\n       *first_deleted_slot = static_cast <value_type *> (HTAB_EMPTY_ENTRY);\n       return first_deleted_slot;\n     }\n \n-  htab->n_elements++;\n-  return &htab->entries[index];\n-}\n-\n-\n-/* This function clears all entries in the given hash table.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-void\n-hash_table <Descriptor, Allocator>::empty ()\n-{\n-  size_t size = htab->size;\n-  value_type **entries = htab->entries;\n-  int i;\n-\n-  for (i = size - 1; i >= 0; i--)\n-    if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Descriptor::remove (entries[i]);\n-\n-  /* Instead of clearing megabyte, downsize the table.  */\n-  if (size > 1024*1024 / sizeof (PTR))\n-    {\n-      int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n-      int nsize = prime_tab[nindex].prime;\n-\n-      Allocator <value_type *> ::data_free (htab->entries);\n-      htab->entries = Allocator <value_type *> ::data_alloc (nsize);\n-      htab->size = nsize;\n-      htab->size_prime_index = nindex;\n-    }\n-  else\n-    memset (entries, 0, size * sizeof (value_type *));\n-  htab->n_deleted = 0;\n-  htab->n_elements = 0;\n-}\n-\n-\n-/* This function clears a specified SLOT in a hash table.  It is\n-   useful when you've already done the lookup and don't want to do it\n-   again. */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-void\n-hash_table <Descriptor, Allocator>::clear_slot (value_type **slot)\n-{\n-  if (slot < htab->entries || slot >= htab->entries + htab->size\n-      || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n-    abort ();\n-\n-  Descriptor::remove (*slot);\n-\n-  *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n-  htab->n_deleted++;\n+  m_n_elements++;\n+  return &m_entries[index];\n }\n \n-\n /* This function deletes an element with the given COMPARABLE value\n    from hash table starting with the given HASH.  If there is no\n    matching element in the hash table, this function does nothing. */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table <Descriptor, Allocator>\n+hash_table<Descriptor, Allocator>\n ::remove_elt_with_hash (const compare_type *comparable, hashval_t hash)\n {\n-  value_type **slot;\n-\n-  slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n+  value_type **slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n   if (*slot == HTAB_EMPTY_ENTRY)\n     return;\n \n   Descriptor::remove (*slot);\n \n   *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n-  htab->n_deleted++;\n+  m_n_deleted++;\n }\n \n-\n /* This function scans over the entire hash table calling CALLBACK for\n    each live entry.  If CALLBACK returns false, the iteration stops.\n    ARGUMENT is passed as CALLBACK's second argument. */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-template <typename Argument,\n+template<typename Descriptor,\n+\t  template<typename Type> class Allocator>\n+template<typename Argument,\n \t  int (*Callback) (typename Descriptor::value_type **slot, Argument argument)>\n void\n-hash_table <Descriptor, Allocator>::traverse_noresize (Argument argument)\n+hash_table<Descriptor, Allocator>::traverse_noresize (Argument argument)\n {\n-  value_type **slot;\n-  value_type **limit;\n-\n-  slot = htab->entries;\n-  limit = slot + htab->size;\n+  value_type **slot = m_entries;\n+  value_type **limit = slot + size ();\n \n   do\n     {\n@@ -931,7 +794,6 @@ hash_table <Descriptor, Allocator>::traverse_noresize (Argument argument)\n   while (++slot < limit);\n }\n \n-\n /* Like traverse_noresize, but does resize the table when it is too empty\n    to improve effectivity of subsequent calls.  */\n \n@@ -941,55 +803,20 @@ template <typename Argument,\n \t  int (*Callback) (typename Descriptor::value_type **slot,\n \t\t\t   Argument argument)>\n void\n-hash_table <Descriptor, Allocator>::traverse (Argument argument)\n+hash_table<Descriptor, Allocator>::traverse (Argument argument)\n {\n-  size_t size = htab->size;\n+  size_t size = m_size;\n   if (elements () * 8 < size && size > 32)\n     expand ();\n \n   traverse_noresize <Argument, Callback> (argument);\n }\n \n-\n-/* Iterator definitions.  */\n-\n-/* The default constructor produces the end value.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline\n-hash_table <Descriptor, Allocator>::iterator::iterator ()\n-: m_slot (NULL), m_limit (NULL)\n-{\n-}\n-\n-/* The parameterized constructor produces the begin value.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline\n-hash_table <Descriptor, Allocator>::iterator::iterator\n-   (value_type **slot, value_type **limit)\n-: m_slot (slot), m_limit (limit)\n-{\n-}\n-\n-/* Obtain the element.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline typename hash_table <Descriptor, Allocator>::value_type &\n-hash_table <Descriptor, Allocator>::iterator::operator * ()\n-{\n-  return **m_slot;\n-}\n-\n /* Slide down the iterator slots until an active entry is found.  */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table <Descriptor, Allocator>::iterator::slide ()\n+hash_table<Descriptor, Allocator>::iterator::slide ()\n {\n   for ( ; m_slot < m_limit; ++m_slot )\n     {\n@@ -1003,50 +830,15 @@ hash_table <Descriptor, Allocator>::iterator::slide ()\n \n /* Bump the iterator.  */\n \n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline typename hash_table <Descriptor, Allocator>::iterator &\n-hash_table <Descriptor, Allocator>::iterator::operator ++ ()\n+template<typename Descriptor, template<typename Type> class Allocator>\n+inline typename hash_table<Descriptor, Allocator>::iterator &\n+hash_table<Descriptor, Allocator>::iterator::operator ++ ()\n {\n   ++m_slot;\n   slide ();\n   return *this;\n }\n \n-/* Compare iterators.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline bool\n-hash_table <Descriptor, Allocator>::iterator::\n-  operator != (const iterator &other) const\n-{\n-  return m_slot != other.m_slot || m_limit != other.m_limit;\n-}\n-\n-/* Hash table iterator producers.  */\n-\n-/* The beginning of a hash table iteration.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline typename hash_table <Descriptor, Allocator>::iterator\n-hash_table <Descriptor, Allocator>::begin ()\n-{\n-  iterator hti (htab->entries, htab->entries + htab->size);\n-  hti.slide ();\n-  return hti;\n-}\n-\n-/* The end of a hash table iteration.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-inline typename hash_table <Descriptor, Allocator>::iterator\n-hash_table <Descriptor, Allocator>::end ()\n-{\n-  return iterator ();\n-}\n \n /* Iterate through the elements of hash_table HTAB,\n    using hash_table <....>::iterator ITER,"}, {"sha": "604b809dbcd62c36bd9d54ce75d083edb7620271", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -324,8 +324,8 @@ odr_hasher::remove (value_type *v)\n \n /* ODR type hash used to lookup ODR type based on tree type node.  */\n \n-typedef hash_table <odr_hasher> odr_hash_type;\n-static odr_hash_type odr_hash;\n+typedef hash_table<odr_hasher> odr_hash_type;\n+static odr_hash_type *odr_hash;\n \n /* ODR types are also stored into ODR_TYPE vector to allow consistent\n    walking.  Bases appear before derived types.  Vector is garbage collected\n@@ -473,7 +473,8 @@ get_odr_type (tree type, bool insert)\n   type = TYPE_MAIN_VARIANT (type);\n   gcc_checking_assert (TYPE_MAIN_VARIANT (type) == type);\n   hash = hash_type_name (type);\n-  slot = odr_hash.find_slot_with_hash (type, hash, insert ? INSERT : NO_INSERT);\n+  slot\n+     = odr_hash->find_slot_with_hash (type, hash, insert ? INSERT : NO_INSERT);\n   if (!slot)\n     return NULL;\n \n@@ -611,11 +612,11 @@ build_type_inheritance_graph (void)\n   FILE *inheritance_dump_file;\n   int flags;\n \n-  if (odr_hash.is_created ())\n+  if (odr_hash)\n     return;\n   timevar_push (TV_IPA_INHERITANCE);\n   inheritance_dump_file = dump_begin (TDI_inheritance, &flags);\n-  odr_hash.create (23);\n+  odr_hash = new odr_hash_type (23);\n \n   /* We reconstruct the graph starting of types of all methods seen in the\n      the unit.  */\n@@ -1011,9 +1012,9 @@ polymorphic_call_target_hasher::remove (value_type *v)\n \n /* Polymorphic call target query cache.  */\n \n-typedef hash_table <polymorphic_call_target_hasher>\n+typedef hash_table<polymorphic_call_target_hasher>\n    polymorphic_call_target_hash_type;\n-static polymorphic_call_target_hash_type polymorphic_call_target_hash;\n+static polymorphic_call_target_hash_type *polymorphic_call_target_hash;\n \n /* Destroy polymorphic call target query cache.  */\n \n@@ -1022,7 +1023,8 @@ free_polymorphic_call_targets_hash ()\n {\n   if (cached_polymorphic_call_targets)\n     {\n-      polymorphic_call_target_hash.dispose ();\n+      delete polymorphic_call_target_hash;\n+      polymorphic_call_target_hash = NULL;\n       pointer_set_destroy (cached_polymorphic_call_targets);\n       cached_polymorphic_call_targets = NULL;\n     }\n@@ -1599,7 +1601,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   bool skipped = false;\n \n   /* If ODR is not initialized, return empty incomplete list.  */\n-  if (!odr_hash.is_created ())\n+  if (!odr_hash)\n     {\n       if (completep)\n \t*completep = false;\n@@ -1656,7 +1658,8 @@ possible_polymorphic_call_targets (tree otr_type,\n   if (!cached_polymorphic_call_targets)\n     {\n       cached_polymorphic_call_targets = pointer_set_create ();\n-      polymorphic_call_target_hash.create (23);\n+      polymorphic_call_target_hash\n+       \t= new polymorphic_call_target_hash_type (23);\n       if (!node_removal_hook_holder)\n \t{\n \t  node_removal_hook_holder =\n@@ -1670,7 +1673,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   key.type = type;\n   key.otr_token = otr_token;\n   key.context = context;\n-  slot = polymorphic_call_target_hash.find_slot (&key, INSERT);\n+  slot = polymorphic_call_target_hash->find_slot (&key, INSERT);\n   if (cache_token)\n    *cache_token = (void *)*slot;\n   if (*slot)\n@@ -1865,7 +1868,7 @@ possible_polymorphic_call_target_p (tree otr_type,\n           || fcode == BUILT_IN_TRAP))\n     return true;\n \n-  if (!odr_hash.is_created ())\n+  if (!odr_hash)\n     return true;\n   targets = possible_polymorphic_call_targets (otr_type, otr_token, ctx, &final);\n   for (i = 0; i < targets.length (); i++)\n@@ -1888,7 +1891,7 @@ update_type_inheritance_graph (void)\n {\n   struct cgraph_node *n;\n \n-  if (!odr_hash.is_created ())\n+  if (!odr_hash)\n     return;\n   free_polymorphic_call_targets_hash ();\n   timevar_push (TV_IPA_INHERITANCE);"}, {"sha": "625d49cbbb9f50943a9a611a4c97f79a048ae8b9", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -112,12 +112,12 @@ histogram_hash::equal (const histogram_entry *val, const histogram_entry *val2)\n    HASHTABLE is the on-side hash kept to avoid duplicates.  */\n \n static void\n-account_time_size (hash_table <histogram_hash> hashtable,\n+account_time_size (hash_table<histogram_hash> *hashtable,\n \t\t   vec<histogram_entry *> &histogram,\n \t\t   gcov_type count, int time, int size)\n {\n   histogram_entry key = {count, 0, 0};\n-  histogram_entry **val = hashtable.find_slot (&key, INSERT);\n+  histogram_entry **val = hashtable->find_slot (&key, INSERT);\n \n   if (!*val)\n     {\n@@ -179,10 +179,9 @@ ipa_profile_generate_summary (void)\n {\n   struct cgraph_node *node;\n   gimple_stmt_iterator gsi;\n-  hash_table <histogram_hash> hashtable;\n   basic_block bb;\n \n-  hashtable.create (10);\n+  hash_table<histogram_hash> hashtable (10);\n   histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n \t\t\t\t      10);\n   \n@@ -230,9 +229,8 @@ ipa_profile_generate_summary (void)\n \t    time += estimate_num_insns (stmt, &eni_time_weights);\n \t    size += estimate_num_insns (stmt, &eni_size_weights);\n \t  }\n-\taccount_time_size (hashtable, histogram, bb->count, time, size);\n+\taccount_time_size (&hashtable, histogram, bb->count, time, size);\n       }\n-  hashtable.dispose ();\n   histogram.qsort (cmp_counts);\n }\n \n@@ -263,10 +261,9 @@ ipa_profile_read_summary (void)\n   struct lto_file_decl_data ** file_data_vec\n     = lto_get_file_decl_data ();\n   struct lto_file_decl_data * file_data;\n-  hash_table <histogram_hash> hashtable;\n   int j = 0;\n \n-  hashtable.create (10);\n+  hash_table<histogram_hash> hashtable (10);\n   histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n \t\t\t\t      10);\n \n@@ -287,15 +284,14 @@ ipa_profile_read_summary (void)\n \t      gcov_type count = streamer_read_gcov_count (ib);\n \t      int time = streamer_read_uhwi (ib);\n \t      int size = streamer_read_uhwi (ib);\n-\t      account_time_size (hashtable, histogram,\n+\t      account_time_size (&hashtable, histogram,\n \t\t\t\t count, time, size);\n \t    }\n \t  lto_destroy_simple_input_block (file_data,\n \t\t\t\t\t  LTO_section_ipa_profile,\n \t\t\t\t\t  ib, data, len);\n \t}\n     }\n-  hashtable.dispose ();\n   histogram.qsort (cmp_counts);\n }\n "}, {"sha": "36c3c879f5757de701b743ce651e068176389af2", "filename": "gcc/ira-color.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -222,21 +222,21 @@ allocno_hard_regs_hasher::equal (const value_type *hv1, const compare_type *hv2)\n }\n \n /* Hash table of unique allocno hard registers.  */\n-static hash_table <allocno_hard_regs_hasher> allocno_hard_regs_htab;\n+static hash_table<allocno_hard_regs_hasher> *allocno_hard_regs_htab;\n \n /* Return allocno hard registers in the hash table equal to HV.  */\n static allocno_hard_regs_t\n find_hard_regs (allocno_hard_regs_t hv)\n {\n-  return allocno_hard_regs_htab.find (hv);\n+  return allocno_hard_regs_htab->find (hv);\n }\n \n /* Insert allocno hard registers HV in the hash table (if it is not\n    there yet) and return the value which in the table.  */\n static allocno_hard_regs_t\n insert_hard_regs (allocno_hard_regs_t hv)\n {\n-  allocno_hard_regs **slot = allocno_hard_regs_htab.find_slot (hv, INSERT);\n+  allocno_hard_regs **slot = allocno_hard_regs_htab->find_slot (hv, INSERT);\n \n   if (*slot == NULL)\n     *slot = hv;\n@@ -248,7 +248,8 @@ static void\n init_allocno_hard_regs (void)\n {\n   allocno_hard_regs_vec.create (200);\n-  allocno_hard_regs_htab.create (200);\n+  allocno_hard_regs_htab\n+    = new hash_table<allocno_hard_regs_hasher> (200);\n }\n \n /* Add (or update info about) allocno hard registers with SET and\n@@ -286,7 +287,8 @@ finish_allocno_hard_regs (void)\n        allocno_hard_regs_vec.iterate (i, &hv);\n        i++)\n     ira_free (hv);\n-  allocno_hard_regs_htab.dispose ();\n+  delete allocno_hard_regs_htab;\n+  allocno_hard_regs_htab = NULL;\n   allocno_hard_regs_vec.release ();\n }\n "}, {"sha": "a83e1dff00c76124ddae7f62af7944ce09590318", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -167,7 +167,7 @@ cost_classes_hasher::remove (value_type *v)\n }\n \n /* Hash table of unique cost classes.  */\n-static hash_table <cost_classes_hasher> cost_classes_htab;\n+static hash_table<cost_classes_hasher> *cost_classes_htab;\n \n /* Map allocno class -> cost classes for pseudo of given allocno\n    class.  */\n@@ -188,7 +188,7 @@ initiate_regno_cost_classes (void)\n \t  sizeof (cost_classes_t) * N_REG_CLASSES);\n   memset (cost_classes_mode_cache, 0,\n \t  sizeof (cost_classes_t) * MAX_MACHINE_MODE);\n-  cost_classes_htab.create (200);\n+  cost_classes_htab = new hash_table<cost_classes_hasher> (200);\n }\n \n /* Create new cost classes from cost classes FROM and set up members\n@@ -262,7 +262,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \t    }\n \t  classes.classes[classes.num++] = cl;\n \t}\n-      slot = cost_classes_htab.find_slot (&classes, INSERT);\n+      slot = cost_classes_htab->find_slot (&classes, INSERT);\n       if (*slot == NULL)\n \t{\n \t  classes_ptr = setup_cost_classes (&classes);\n@@ -301,7 +301,7 @@ setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n \t    continue;\n \t  classes.classes[classes.num++] = cl;\n \t}\n-      slot = cost_classes_htab.find_slot (&classes, INSERT);\n+      slot = cost_classes_htab->find_slot (&classes, INSERT);\n       if (*slot == NULL)\n \t{\n \t  classes_ptr = setup_cost_classes (&classes);\n@@ -319,7 +319,8 @@ static void\n finish_regno_cost_classes (void)\n {\n   ira_free (regno_cost_classes);\n-  cost_classes_htab.dispose ();\n+  delete cost_classes_htab;\n+  cost_classes_htab = NULL;\n }\n \n \f"}, {"sha": "ce90e28f791b7fdeeffe2005d747c05c6890b34d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1,3 +1,7 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* jcf-io.c: Adjust.\n+\n 2014-06-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* java/class.c (build_utf8_ref): Update handling for section names"}, {"sha": "358fc1e47c1dea2226f99e742b2e7449c4b188ac", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -299,7 +299,7 @@ charstar_hash::equal (const value_type *existing, const compare_type *candidate)\n    during class lookup.  (There is no need to cache the values\n    associated with names that were found; they are saved in\n    IDENTIFIER_CLASS_VALUE.)  */\n-static hash_table <charstar_hash> memoized_class_lookups;\n+static hash_table<charstar_hash> *memoized_class_lookups;\n \n /* Returns a freshly malloc'd string with the fully qualified pathname\n    of the .class file for the class CLASSNAME.  CLASSNAME must be\n@@ -321,13 +321,13 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n   hashval_t hash;\n \n   /* Create the hash table, if it does not already exist.  */\n-  if (!memoized_class_lookups.is_created ())\n-    memoized_class_lookups.create (37);\n+  if (!memoized_class_lookups)\n+    memoized_class_lookups = new hash_table<charstar_hash> (37);\n \n   /* Loop for this class in the hashtable.  If it is present, we've\n      already looked for this class and failed to find it.  */\n   hash = charstar_hash::hash (classname);\n-  if (memoized_class_lookups.find_with_hash (classname, hash))\n+  if (memoized_class_lookups->find_with_hash (classname, hash))\n     return NULL;\n \n   /* Allocate and zero out the buffer, since we don't explicitly put a\n@@ -402,7 +402,7 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n \n   /* Remember that this class could not be found so that we do not\n      have to look again.  */\n-  *memoized_class_lookups.find_slot_with_hash (classname, hash, INSERT)\n+  *memoized_class_lookups->find_slot_with_hash (classname, hash, INSERT)\n     = classname;\n \n   return NULL;"}, {"sha": "3852c6b91b4c2d23ca1f41b4c3526ee20a1c297f", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -453,14 +453,14 @@ invariant_expr_hasher::equal (const value_type *entry1,\n \t\t\t\t entry2->inv->insn, entry2->expr);\n }\n \n-typedef hash_table <invariant_expr_hasher> invariant_htab_type;\n+typedef hash_table<invariant_expr_hasher> invariant_htab_type;\n \n /* Checks whether invariant with value EXPR in machine mode MODE is\n    recorded in EQ.  If this is the case, return the invariant.  Otherwise\n    insert INV to the table for this expression and return INV.  */\n \n static struct invariant *\n-find_or_insert_inv (invariant_htab_type eq, rtx expr, enum machine_mode mode,\n+find_or_insert_inv (invariant_htab_type *eq, rtx expr, enum machine_mode mode,\n \t\t    struct invariant *inv)\n {\n   hashval_t hash = hash_invariant_expr_1 (inv->insn, expr);\n@@ -471,7 +471,7 @@ find_or_insert_inv (invariant_htab_type eq, rtx expr, enum machine_mode mode,\n   pentry.expr = expr;\n   pentry.inv = inv;\n   pentry.mode = mode;\n-  slot = eq.find_slot_with_hash (&pentry, hash, INSERT);\n+  slot = eq->find_slot_with_hash (&pentry, hash, INSERT);\n   entry = *slot;\n \n   if (entry)\n@@ -491,7 +491,7 @@ find_or_insert_inv (invariant_htab_type eq, rtx expr, enum machine_mode mode,\n    hash table of the invariants.  */\n \n static void\n-find_identical_invariants (invariant_htab_type eq, struct invariant *inv)\n+find_identical_invariants (invariant_htab_type *eq, struct invariant *inv)\n {\n   unsigned depno;\n   bitmap_iterator bi;\n@@ -528,13 +528,10 @@ merge_identical_invariants (void)\n {\n   unsigned i;\n   struct invariant *inv;\n-  invariant_htab_type eq;\n-  eq.create (invariants.length ());\n+  invariant_htab_type eq (invariants.length ());\n \n   FOR_EACH_VEC_ELT (invariants, i, inv)\n-    find_identical_invariants (eq, inv);\n-\n-  eq.dispose ();\n+    find_identical_invariants (&eq, inv);\n }\n \n /* Determines the basic blocks inside LOOP that are always executed and"}, {"sha": "1c204e9c1dafde3197f63bf259c5176f630115c5", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -134,7 +134,7 @@ biv_entry_hasher::equal (const value_type *b, const compare_type *r)\n \n /* Bivs of the current loop.  */\n \n-static hash_table <biv_entry_hasher> bivs;\n+static hash_table<biv_entry_hasher> *bivs;\n \n static bool iv_analyze_op (rtx, rtx, struct rtx_iv *);\n \n@@ -269,7 +269,7 @@ clear_iv_info (void)\n \t}\n     }\n \n-  bivs.empty ();\n+  bivs->empty ();\n }\n \n \n@@ -284,7 +284,7 @@ iv_analysis_loop_init (struct loop *loop)\n   if (clean_slate)\n     {\n       df_set_flags (DF_EQ_NOTES + DF_DEFER_INSN_RESCAN);\n-      bivs.create (10);\n+      bivs = new hash_table<biv_entry_hasher> (10);\n       clean_slate = false;\n     }\n   else\n@@ -844,7 +844,7 @@ record_iv (df_ref def, struct rtx_iv *iv)\n static bool\n analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n {\n-  struct biv_entry *biv = bivs.find_with_hash (def, REGNO (def));\n+  struct biv_entry *biv = bivs->find_with_hash (def, REGNO (def));\n \n   if (!biv)\n     return false;\n@@ -857,7 +857,7 @@ static void\n record_biv (rtx def, struct rtx_iv *iv)\n {\n   struct biv_entry *biv = XNEW (struct biv_entry);\n-  biv_entry **slot = bivs.find_slot_with_hash (def, REGNO (def), INSERT);\n+  biv_entry **slot = bivs->find_slot_with_hash (def, REGNO (def), INSERT);\n \n   biv->regno = REGNO (def);\n   biv->iv = *iv;\n@@ -1299,7 +1299,8 @@ iv_analysis_done (void)\n       clear_iv_info ();\n       clean_slate = true;\n       df_finish_pass (true);\n-      bivs.dispose ();\n+      delete bivs;\n+      bivs = NULL;\n       free (iv_ref_table);\n       iv_ref_table = NULL;\n       iv_ref_table_size = 0;"}, {"sha": "ad4d3c2da50047b18ad5182b10b685d43b5c864d", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -161,11 +161,11 @@ var_expand_hasher::equal (const value_type *i1, const compare_type *i2)\n \n struct opt_info\n {\n-  hash_table <iv_split_hasher> insns_to_split; /* A hashtable of insns to\n+  hash_table<iv_split_hasher> *insns_to_split; /* A hashtable of insns to\n \t\t\t\t\t\t  split.  */\n   struct iv_to_split *iv_to_split_head; /* The first iv to split.  */\n   struct iv_to_split **iv_to_split_tail; /* Pointer to the tail of the list.  */\n-  hash_table <var_expand_hasher> insns_with_var_to_expand; /* A hashtable of\n+  hash_table<var_expand_hasher> *insns_with_var_to_expand; /* A hashtable of\n \t\t\t\t\tinsns with accumulators to expand.  */\n   struct var_to_expand *var_to_expand_head; /* The first var to expand.  */\n   struct var_to_expand **var_to_expand_tail; /* Pointer to the tail of the list.  */\n@@ -1974,7 +1974,8 @@ analyze_insns_in_loop (struct loop *loop)\n \n   if (flag_split_ivs_in_unroller)\n     {\n-      opt_info->insns_to_split.create (5 * loop->num_nodes);\n+      opt_info->insns_to_split\n+       \t= new hash_table<iv_split_hasher> (5 * loop->num_nodes);\n       opt_info->iv_to_split_head = NULL;\n       opt_info->iv_to_split_tail = &opt_info->iv_to_split_head;\n     }\n@@ -1995,7 +1996,8 @@ analyze_insns_in_loop (struct loop *loop)\n   if (flag_variable_expansion_in_unroller\n       && can_apply)\n     {\n-      opt_info->insns_with_var_to_expand.create (5 * loop->num_nodes);\n+      opt_info->insns_with_var_to_expand\n+       \t= new hash_table<var_expand_hasher> (5 * loop->num_nodes);\n       opt_info->var_to_expand_head = NULL;\n       opt_info->var_to_expand_tail = &opt_info->var_to_expand_head;\n     }\n@@ -2011,25 +2013,25 @@ analyze_insns_in_loop (struct loop *loop)\n         if (!INSN_P (insn))\n           continue;\n \n-        if (opt_info->insns_to_split.is_created ())\n+        if (opt_info->insns_to_split)\n           ivts = analyze_iv_to_split_insn (insn);\n \n         if (ivts)\n           {\n-            slot1 = opt_info->insns_to_split.find_slot (ivts, INSERT);\n+            slot1 = opt_info->insns_to_split->find_slot (ivts, INSERT);\n \t    gcc_assert (*slot1 == NULL);\n             *slot1 = ivts;\n \t    *opt_info->iv_to_split_tail = ivts;\n \t    opt_info->iv_to_split_tail = &ivts->next;\n             continue;\n           }\n \n-        if (opt_info->insns_with_var_to_expand.is_created ())\n+        if (opt_info->insns_with_var_to_expand)\n           ves = analyze_insn_to_expand_var (loop, insn);\n \n         if (ves)\n           {\n-            slot2 = opt_info->insns_with_var_to_expand.find_slot (ves, INSERT);\n+            slot2 = opt_info->insns_with_var_to_expand->find_slot (ves, INSERT);\n \t    gcc_assert (*slot2 == NULL);\n             *slot2 = ves;\n \t    *opt_info->var_to_expand_tail = ves;\n@@ -2407,7 +2409,7 @@ apply_opt_in_copies (struct opt_info *opt_info,\n   gcc_assert (!unrolling || rewrite_original_loop);\n \n   /* Allocate the basic variables (i0).  */\n-  if (opt_info->insns_to_split.is_created ())\n+  if (opt_info->insns_to_split)\n     for (ivts = opt_info->iv_to_split_head; ivts; ivts = ivts->next)\n       allocate_basic_variable (ivts);\n \n@@ -2441,11 +2443,11 @@ apply_opt_in_copies (struct opt_info *opt_info,\n           ve_templ.insn = orig_insn;\n \n           /* Apply splitting iv optimization.  */\n-          if (opt_info->insns_to_split.is_created ())\n+          if (opt_info->insns_to_split)\n             {\n \t      maybe_strip_eq_note_for_split_iv (opt_info, insn);\n \n-              ivts = opt_info->insns_to_split.find (&ivts_templ);\n+              ivts = opt_info->insns_to_split->find (&ivts_templ);\n \n               if (ivts)\n                 {\n@@ -2458,10 +2460,10 @@ apply_opt_in_copies (struct opt_info *opt_info,\n                 }\n             }\n           /* Apply variable expansion optimization.  */\n-          if (unrolling && opt_info->insns_with_var_to_expand.is_created ())\n+          if (unrolling && opt_info->insns_with_var_to_expand)\n             {\n               ves = (struct var_to_expand *)\n-\t\topt_info->insns_with_var_to_expand.find (&ve_templ);\n+\t\topt_info->insns_with_var_to_expand->find (&ve_templ);\n               if (ves)\n                 {\n \t\t  gcc_assert (GET_CODE (PATTERN (insn))\n@@ -2478,7 +2480,7 @@ apply_opt_in_copies (struct opt_info *opt_info,\n \n   /* Initialize the variable expansions in the loop preheader\n      and take care of combining them at the loop exit.  */\n-  if (opt_info->insns_with_var_to_expand.is_created ())\n+  if (opt_info->insns_with_var_to_expand)\n     {\n       for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n \tinsert_var_expansion_initialization (ves, opt_info->loop_preheader);\n@@ -2509,12 +2511,12 @@ apply_opt_in_copies (struct opt_info *opt_info,\n  \t    continue;\n \n           ivts_templ.insn = orig_insn;\n-          if (opt_info->insns_to_split.is_created ())\n+          if (opt_info->insns_to_split)\n             {\n \t      maybe_strip_eq_note_for_split_iv (opt_info, orig_insn);\n \n               ivts = (struct iv_to_split *)\n-\t\topt_info->insns_to_split.find (&ivts_templ);\n+\t\topt_info->insns_to_split->find (&ivts_templ);\n               if (ivts)\n                 {\n                   if (!delta)\n@@ -2533,15 +2535,16 @@ apply_opt_in_copies (struct opt_info *opt_info,\n static void\n free_opt_info (struct opt_info *opt_info)\n {\n-  if (opt_info->insns_to_split.is_created ())\n-    opt_info->insns_to_split.dispose ();\n-  if (opt_info->insns_with_var_to_expand.is_created ())\n+  delete opt_info->insns_to_split;\n+  opt_info->insns_to_split = NULL;\n+  if (opt_info->insns_with_var_to_expand)\n     {\n       struct var_to_expand *ves;\n \n       for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n \tves->var_expansions.release ();\n-      opt_info->insns_with_var_to_expand.dispose ();\n+      delete opt_info->insns_with_var_to_expand;\n+      opt_info->insns_with_var_to_expand = NULL;\n     }\n   free (opt_info);\n }"}, {"sha": "671532715a54a70317a08fc59c8a0e9d4bedeacf", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -72,7 +72,7 @@ freeing_string_slot_hasher::remove (value_type *v)\n }\n \n /* The table to hold the file names.  */\n-static hash_table <freeing_string_slot_hasher> file_name_hash_table;\n+static hash_table<freeing_string_slot_hasher> *file_name_hash_table;\n \n \n /* Check that tag ACTUAL has one of the given values.  NUM_TAGS is the\n@@ -123,7 +123,7 @@ canon_file_name (const char *string)\n   s_slot.s = string;\n   s_slot.len = len;\n \n-  slot = file_name_hash_table.find_slot (&s_slot, INSERT);\n+  slot = file_name_hash_table->find_slot (&s_slot, INSERT);\n   if (*slot == NULL)\n     {\n       char *saved_string;\n@@ -1363,7 +1363,8 @@ void\n lto_reader_init (void)\n {\n   lto_streamer_init ();\n-  file_name_hash_table.create (37);\n+  file_name_hash_table\n+    = new hash_table<freeing_string_slot_hasher> (37);\n }\n \n "}, {"sha": "3af53735d523d282bd60b287534f3175d0f61572", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -87,7 +87,7 @@ create_output_block (enum lto_section_type section_type)\n \n   clear_line_info (ob);\n \n-  ob->string_hash_table.create (37);\n+  ob->string_hash_table = new hash_table<string_slot_hasher> (37);\n   gcc_obstack_init (&ob->obstack);\n \n   return ob;\n@@ -101,7 +101,8 @@ destroy_output_block (struct output_block *ob)\n {\n   enum lto_section_type section_type = ob->section_type;\n \n-  ob->string_hash_table.dispose ();\n+  delete ob->string_hash_table;\n+  ob->string_hash_table = NULL;\n \n   free (ob->main_stream);\n   free (ob->string_stream);"}, {"sha": "34807231bc8e36ab078c59d2a1e41790ad758d95", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -290,7 +290,7 @@ tree_entry_hasher::equal (const value_type *e1, const compare_type *e2)\n   return (e1->key == e2->key);\n }\n \n-static hash_table <tree_hash_entry> tree_htab;\n+static hash_table<tree_hash_entry> *tree_htab;\n #endif\n \n /* Initialization common to the LTO reader and writer.  */\n@@ -305,7 +305,7 @@ lto_streamer_init (void)\n   streamer_check_handled_ts_structures ();\n \n #ifdef LTO_STREAMER_DEBUG\n-  tree_htab.create (31);\n+  tree_htab = new hash_table<tree_hash_entry> (31);\n #endif\n }\n \n@@ -340,7 +340,7 @@ lto_orig_address_map (tree t, intptr_t orig_t)\n \n   ent.key = t;\n   ent.value = orig_t;\n-  slot = tree_htab.find_slot (&ent, INSERT);\n+  slot = tree_htab->find_slot (&ent, INSERT);\n   gcc_assert (!*slot);\n   *slot = XNEW (struct tree_hash_entry);\n   **slot = ent;\n@@ -357,7 +357,7 @@ lto_orig_address_get (tree t)\n   struct tree_hash_entry **slot;\n \n   ent.key = t;\n-  slot = tree_htab.find_slot (&ent, NO_INSERT);\n+  slot = tree_htab->find_slot (&ent, NO_INSERT);\n   return (slot ? (*slot)->value : 0);\n }\n \n@@ -371,10 +371,10 @@ lto_orig_address_remove (tree t)\n   struct tree_hash_entry **slot;\n \n   ent.key = t;\n-  slot = tree_htab.find_slot (&ent, NO_INSERT);\n+  slot = tree_htab->find_slot (&ent, NO_INSERT);\n   gcc_assert (slot);\n   free (*slot);\n-  tree_htab.clear_slot (slot);\n+  tree_htab->clear_slot (slot);\n }\n #endif\n "}, {"sha": "889e91dbc25f9aa8d26f1475a6f73110c99b75c7", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -682,7 +682,7 @@ struct output_block\n \n   /* The hash table that contains the set of strings we have seen so\n      far and the indexes assigned to them.  */\n-  hash_table <string_slot_hasher> string_hash_table;\n+  hash_table<string_slot_hasher> *string_hash_table;\n \n   /* The current cgraph_node that we are currently serializing.  Null\n      if we are serializing something else.  */"}, {"sha": "29d7a5bff71f3983b08ebbd2a3a34af4c4a8aca5", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1,3 +1,7 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* lto.c: Adjust.\n+\n 2014-06-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c (lto_varpool_replace_node): Report TLS model conflicts."}, {"sha": "1fe7ce4eefbfa741ff92a07b458f24a16f0178e6", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1137,7 +1137,7 @@ tree_scc_hasher::equal (const value_type *scc1, const compare_type *scc2)\n   return true;\n }\n \n-static hash_table <tree_scc_hasher> tree_scc_hash;\n+static hash_table<tree_scc_hasher> *tree_scc_hash;\n static struct obstack tree_scc_hash_obstack;\n \n static unsigned long num_merged_types;\n@@ -1734,7 +1734,7 @@ unify_scc (struct streamer_tree_cache_d *cache, unsigned from,\n \n   /* Look for the list of candidate SCCs to compare against.  */\n   tree_scc **slot;\n-  slot = tree_scc_hash.find_slot_with_hash (scc, scc_hash, INSERT);\n+  slot = tree_scc_hash->find_slot_with_hash (scc, scc_hash, INSERT);\n   if (*slot)\n     {\n       /* Try unifying against each candidate.  */\n@@ -2921,7 +2921,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n \t\t\t\t\t    gimple_canonical_type_eq, 0);\n   gcc_obstack_init (&tree_scc_hash_obstack);\n-  tree_scc_hash.create (4096);\n+  tree_scc_hash = new hash_table<tree_scc_hasher> (4096);\n \n   /* Register the common node types with the canonical type machinery so\n      we properly share alias-sets across languages and TUs.  Do not\n@@ -2987,7 +2987,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n     print_lto_report_1 ();\n \n   /* Free gimple type merging datastructures.  */\n-  tree_scc_hash.dispose ();\n+  delete tree_scc_hash;\n+  tree_scc_hash = NULL;\n   obstack_free (&tree_scc_hash_obstack, NULL);\n   htab_delete (gimple_canonical_types);\n   gimple_canonical_types = NULL;\n@@ -3159,17 +3160,17 @@ print_lto_report_1 (void)\n   fprintf (stderr, \"[%s] read %lu SCCs of average size %f\\n\",\n \t   pfx, num_sccs_read, total_scc_size / (double)num_sccs_read);\n   fprintf (stderr, \"[%s] %lu tree bodies read in total\\n\", pfx, total_scc_size);\n-  if (flag_wpa && tree_scc_hash.is_created ())\n+  if (flag_wpa && tree_scc_hash)\n     {\n       fprintf (stderr, \"[%s] tree SCC table: size %ld, %ld elements, \"\n \t       \"collision ratio: %f\\n\", pfx,\n-\t       (long) tree_scc_hash.size (),\n-\t       (long) tree_scc_hash.elements (),\n-\t       tree_scc_hash.collisions ());\n+\t       (long) tree_scc_hash->size (),\n+\t       (long) tree_scc_hash->elements (),\n+\t       tree_scc_hash->collisions ());\n       hash_table<tree_scc_hasher>::iterator hiter;\n       tree_scc *scc, *max_scc = NULL;\n       unsigned max_length = 0;\n-      FOR_EACH_HASH_TABLE_ELEMENT (tree_scc_hash, scc, x, hiter)\n+      FOR_EACH_HASH_TABLE_ELEMENT (*tree_scc_hash, scc, x, hiter)\n \t{\n \t  unsigned length = 0;\n \t  tree_scc *s = scc;"}, {"sha": "dfd8f387e06181d22fb0ca862b5d8c8c45432712", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1,3 +1,7 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* objc-act.c: Adjust.\n+\n 2014-05-17  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* objc-act.c (objc_build_string_object): Adjust."}, {"sha": "c379a51ba9a0065c8e5a776b6d9174b17fd1f7b1", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -3940,8 +3940,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t  {\n \t    /* First, build the hashtable by putting all the instance\n \t       variables of superclasses in it.  */\n-\t    hash_table <decl_name_hash> htab;\n-\t    htab.create (37);\n+\t    hash_table<decl_name_hash> htab (37);\n \t    tree interface;\n \t    for (interface = lookup_interface (CLASS_SUPER_NAME\n \t\t\t\t\t       (objc_interface_context));\n@@ -4018,7 +4017,6 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t\t      }\n \t\t  }\n \t      }\n-\t    htab.dispose ();\n \t    return true;\n \t  }\n       }"}, {"sha": "91b644e33db883555ac4ce1c915cf7c8fd5087d3", "filename": "gcc/passes.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -719,7 +719,7 @@ pass_registry_hasher::equal (const value_type *s1, const compare_type *s2)\n   return !strcmp (s1->unique_name, s2->unique_name);\n }\n \n-static hash_table <pass_registry_hasher> name_to_pass_map;\n+static hash_table<pass_registry_hasher> *name_to_pass_map;\n \n /* Register PASS with NAME.  */\n \n@@ -729,11 +729,11 @@ register_pass_name (opt_pass *pass, const char *name)\n   struct pass_registry **slot;\n   struct pass_registry pr;\n \n-  if (!name_to_pass_map.is_created ())\n-    name_to_pass_map.create (256);\n+  if (!name_to_pass_map)\n+    name_to_pass_map = new hash_table<pass_registry_hasher> (256);\n \n   pr.unique_name = name;\n-  slot = name_to_pass_map.find_slot (&pr, INSERT);\n+  slot = name_to_pass_map->find_slot (&pr, INSERT);\n   if (!*slot)\n     {\n       struct pass_registry *new_pr;\n@@ -777,7 +777,7 @@ create_pass_tab (void)\n     return;\n \n   pass_tab.safe_grow_cleared (g->get_passes ()->passes_by_id_size + 1);\n-  name_to_pass_map.traverse <void *, passes_pass_traverse> (NULL);\n+  name_to_pass_map->traverse <void *, passes_pass_traverse> (NULL);\n }\n \n static bool override_gate_status (opt_pass *, tree, bool);\n@@ -867,7 +867,7 @@ get_pass_by_name (const char *name)\n   struct pass_registry **slot, pr;\n \n   pr.unique_name = name;\n-  slot = name_to_pass_map.find_slot (&pr, NO_INSERT);\n+  slot = name_to_pass_map->find_slot (&pr, NO_INSERT);\n \n   if (!slot || !*slot)\n     return NULL;"}, {"sha": "8debc09cada18a08f961f633851a8c394f163807", "filename": "gcc/plugin.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -80,7 +80,7 @@ event_hasher::equal (const value_type *s1, const compare_type *s2)\n \n /* A hash table to map event names to the position of the names in the\n    plugin_event_name table.  */\n-static hash_table <event_hasher> event_tab;\n+static hash_table<event_hasher> *event_tab;\n \n /* Keep track of the limit of allocated events and space ready for\n    allocating events.  */\n@@ -345,19 +345,19 @@ get_named_event_id (const char *name, enum insert_option insert)\n {\n   const char ***slot;\n \n-  if (!event_tab.is_created ())\n+  if (!event_tab)\n     {\n       int i;\n \n-      event_tab.create (150);\n+      event_tab = new hash_table<event_hasher> (150);\n       for (i = 0; i < event_last; i++)\n \t{\n-\t  slot = event_tab.find_slot (&plugin_event_name[i], INSERT);\n+\t  slot = event_tab->find_slot (&plugin_event_name[i], INSERT);\n \t  gcc_assert (*slot == HTAB_EMPTY_ENTRY);\n \t  *slot = &plugin_event_name[i];\n \t}\n     }\n-  slot = event_tab.find_slot (&name, insert);\n+  slot = event_tab->find_slot (&name, insert);\n   if (slot == NULL)\n     return -1;\n   if (*slot != HTAB_EMPTY_ENTRY)\n@@ -383,7 +383,8 @@ get_named_event_id (const char *name, enum insert_option insert)\n \t\t\t\t\t plugin_callbacks, event_horizon);\n \t}\n       /* All the pointers in the hash table will need to be updated.  */\n-      event_tab.dispose ();\n+      delete event_tab;\n+      event_tab = NULL;\n     }\n   else\n     *slot = &plugin_event_name[event_last];"}, {"sha": "f2391a1e032c9f1dfee264c115eda05694dc1f36", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -148,7 +148,7 @@ expr_hasher::equal (const value_type *exp1, const compare_type *exp2)\n }\n \n /* The table itself.  */\n-static hash_table <expr_hasher> expr_table;\n+static hash_table<expr_hasher> *expr_table;\n \f\n \n static struct obstack expr_obstack;\n@@ -279,7 +279,7 @@ alloc_mem (void)\n      make the hash table too small, but unnecessarily making it too large\n      also doesn't help.  The i/4 is a gcse.c relic, and seems like a\n      reasonable choice.  */\n-  expr_table.create (MAX (i / 4, 13));\n+  expr_table = new hash_table<expr_hasher> (MAX (i / 4, 13));\n \n   /* We allocate everything on obstacks because we often can roll back\n      the whole obstack to some point.  Freeing obstacks is very fast.  */\n@@ -306,7 +306,8 @@ free_mem (void)\n {\n   free (uid_cuid);\n \n-  expr_table.dispose ();\n+  delete expr_table;\n+  expr_table = NULL;\n \n   obstack_free (&expr_obstack, NULL);\n   obstack_free (&occr_obstack, NULL);\n@@ -348,7 +349,7 @@ insert_expr_in_table (rtx x, rtx insn)\n   cur_expr->hash = hash;\n   cur_expr->avail_occr = NULL;\n \n-  slot = expr_table.find_slot_with_hash (cur_expr, hash, INSERT);\n+  slot = expr_table->find_slot_with_hash (cur_expr, hash, INSERT);\n \n   if (! (*slot))\n     /* The expression isn't found, so insert it.  */\n@@ -416,7 +417,7 @@ lookup_expr_in_table (rtx pat)\n   tmp_expr->hash = hash;\n   tmp_expr->avail_occr = NULL;\n \n-  slot = expr_table.find_slot_with_hash (tmp_expr, hash, INSERT);\n+  slot = expr_table->find_slot_with_hash (tmp_expr, hash, INSERT);\n   obstack_free (&expr_obstack, tmp_expr);\n \n   if (!slot)\n@@ -457,13 +458,13 @@ dump_hash_table (FILE *file)\n {\n   fprintf (file, \"\\n\\nexpression hash table\\n\");\n   fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-           (long) expr_table.size (),\n-           (long) expr_table.elements (),\n-           expr_table.collisions ());\n-  if (expr_table.elements () > 0)\n+           (long) expr_table->size (),\n+           (long) expr_table->elements (),\n+           expr_table->collisions ());\n+  if (expr_table->elements () > 0)\n     {\n       fprintf (file, \"\\n\\ntable entries:\\n\");\n-      expr_table.traverse <FILE *, dump_expr_hash_table_entry> (file);\n+      expr_table->traverse <FILE *, dump_expr_hash_table_entry> (file);\n     }\n   fprintf (file, \"\\n\");\n }\n@@ -1253,7 +1254,7 @@ delete_redundant_insns_1 (expr **slot, void *data ATTRIBUTE_UNUSED)\n static void\n delete_redundant_insns (void)\n {\n-  expr_table.traverse <void *, delete_redundant_insns_1> (NULL);\n+  expr_table->traverse <void *, delete_redundant_insns_1> (NULL);\n   if (dump_file)\n     fprintf (dump_file, \"\\n\");\n }\n@@ -1279,7 +1280,7 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n   if (dump_file)\n     dump_hash_table (dump_file);\n \n-  if (expr_table.elements () > 0)\n+  if (expr_table->elements () > 0)\n     {\n       eliminate_partially_redundant_loads ();\n       delete_redundant_insns ();"}, {"sha": "8191cb92ec4b0b17e37f9379550f82fa534b3a02", "filename": "gcc/sese.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -102,15 +102,15 @@ rename_map_hasher::equal (const value_type *elt1, const compare_type *elt2)\n   return (elt1->old_name == elt2->old_name);\n }\n \n-typedef hash_table <rename_map_hasher> rename_map_type;\n+typedef hash_table<rename_map_hasher> rename_map_type;\n \f\n \n /* Print to stderr all the elements of RENAME_MAP.  */\n \n DEBUG_FUNCTION void\n-debug_rename_map (rename_map_type rename_map)\n+debug_rename_map (rename_map_type *rename_map)\n {\n-  rename_map.traverse <void *, debug_rename_map_1> (NULL);\n+  rename_map->traverse <void *, debug_rename_map_1> (NULL);\n }\n \n /* Computes a hash function for database element ELT.  */\n@@ -416,14 +416,14 @@ get_false_edge_from_guard_bb (basic_block bb)\n /* Returns the expression associated to OLD_NAME in RENAME_MAP.  */\n \n static tree\n-get_rename (rename_map_type rename_map, tree old_name)\n+get_rename (rename_map_type *rename_map, tree old_name)\n {\n   struct rename_map_elt_s tmp;\n   rename_map_elt_s **slot;\n \n   gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n   tmp.old_name = old_name;\n-  slot = rename_map.find_slot (&tmp, NO_INSERT);\n+  slot = rename_map->find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return (*slot)->expr;\n@@ -434,7 +434,7 @@ get_rename (rename_map_type rename_map, tree old_name)\n /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).  */\n \n static void\n-set_rename (rename_map_type rename_map, tree old_name, tree expr)\n+set_rename (rename_map_type *rename_map, tree old_name, tree expr)\n {\n   struct rename_map_elt_s tmp;\n   rename_map_elt_s **slot;\n@@ -443,7 +443,7 @@ set_rename (rename_map_type rename_map, tree old_name, tree expr)\n     return;\n \n   tmp.old_name = old_name;\n-  slot = rename_map.find_slot (&tmp, INSERT);\n+  slot = rename_map->find_slot (&tmp, INSERT);\n \n   if (!slot)\n     return;\n@@ -461,7 +461,7 @@ set_rename (rename_map_type rename_map, tree old_name, tree expr)\n    is set when the code generation cannot continue.  */\n \n static bool\n-rename_uses (gimple copy, rename_map_type rename_map,\n+rename_uses (gimple copy, rename_map_type *rename_map,\n \t     gimple_stmt_iterator *gsi_tgt,\n \t     sese region, loop_p loop, vec<tree> iv_map,\n \t     bool *gloog_error)\n@@ -568,7 +568,7 @@ rename_uses (gimple copy, rename_map_type rename_map,\n \n static void\n graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n-\t\t\t\trename_map_type rename_map,\n+\t\t\t\trename_map_type *rename_map,\n \t\t\t\tvec<tree> iv_map, sese region,\n \t\t\t\tbool *gloog_error)\n {\n@@ -636,14 +636,12 @@ copy_bb_and_scalar_dependences (basic_block bb, sese region,\n \t\t\t\tbool *gloog_error)\n {\n   basic_block new_bb = split_edge (next_e);\n-  rename_map_type rename_map;\n-  rename_map.create (10);\n+  rename_map_type rename_map (10);\n \n   next_e = single_succ_edge (new_bb);\n-  graphite_copy_stmts_from_block (bb, new_bb, rename_map, iv_map, region,\n+  graphite_copy_stmts_from_block (bb, new_bb, &rename_map, iv_map, region,\n \t\t\t\t  gloog_error);\n   remove_phi_nodes (new_bb);\n-  rename_map.dispose ();\n \n   return next_e;\n }"}, {"sha": "eb3210ba757b5317cf1146a327d1be5a561d5326", "filename": "gcc/statistics.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -80,16 +80,16 @@ stats_counter_hasher::remove (value_type *v)\n   free (v);\n }\n \n-typedef hash_table <stats_counter_hasher> stats_counter_table_type;\n+typedef hash_table<stats_counter_hasher> stats_counter_table_type;\n \n /* Array of statistic hashes, indexed by pass id.  */\n-static stats_counter_table_type *statistics_hashes;\n+static stats_counter_table_type **statistics_hashes;\n static unsigned nr_statistics_hashes;\n \n /* Return the current hashtable to be used for recording or printing\n    statistics.  */\n \n-static stats_counter_table_type\n+static stats_counter_table_type *\n curr_statistics_hash (void)\n {\n   unsigned idx;\n@@ -98,20 +98,20 @@ curr_statistics_hash (void)\n   idx = current_pass->static_pass_number;\n \n   if (idx < nr_statistics_hashes\n-      && statistics_hashes[idx].is_created ())\n+      && statistics_hashes[idx])\n     return statistics_hashes[idx];\n \n   if (idx >= nr_statistics_hashes)\n     {\n-      statistics_hashes = XRESIZEVEC (stats_counter_table_type,\n+      statistics_hashes = XRESIZEVEC (stats_counter_table_type *,\n \t\t\t\t      statistics_hashes, idx+1);\n       memset (statistics_hashes + nr_statistics_hashes, 0,\n \t      (idx + 1 - nr_statistics_hashes)\n-\t      * sizeof (stats_counter_table_type));\n+\t      * sizeof (stats_counter_table_type *));\n       nr_statistics_hashes = idx + 1;\n     }\n \n-  statistics_hashes[idx].create (15);\n+  statistics_hashes[idx] = new stats_counter_table_type (15);\n \n   return statistics_hashes[idx];\n }\n@@ -195,16 +195,16 @@ statistics_fini_pass (void)\n       fprintf (dump_file, \"Pass statistics:\\n\");\n       fprintf (dump_file, \"----------------\\n\");\n       curr_statistics_hash ()\n-\t.traverse_noresize <void *, statistics_fini_pass_1> (NULL);\n+\t->traverse_noresize <void *, statistics_fini_pass_1> (NULL);\n       fprintf (dump_file, \"\\n\");\n     }\n   if (statistics_dump_file\n       && !(statistics_dump_flags & TDF_STATS\n \t   || statistics_dump_flags & TDF_DETAILS))\n     curr_statistics_hash ()\n-      .traverse_noresize <void *, statistics_fini_pass_2> (NULL);\n+      ->traverse_noresize <void *, statistics_fini_pass_2> (NULL);\n   curr_statistics_hash ()\n-    .traverse_noresize <void *, statistics_fini_pass_3> (NULL);\n+    ->traverse_noresize <void *, statistics_fini_pass_3> (NULL);\n }\n \n /* Helper for printing summary information.  */\n@@ -245,10 +245,10 @@ statistics_fini (void)\n     {\n       unsigned i;\n       for (i = 0; i < nr_statistics_hashes; ++i)\n-\tif (statistics_hashes[i].is_created ()\n+\tif (statistics_hashes[i]\n \t    && passes->get_pass_for_id (i) != NULL)\n \t  statistics_hashes[i]\n-\t    .traverse_noresize <opt_pass *, statistics_fini_1>\n+\t    ->traverse_noresize <opt_pass *, statistics_fini_1>\n \t    (passes->get_pass_for_id (i));\n     }\n \n@@ -280,14 +280,14 @@ statistics_init (void)\n    and HISTOGRAM_P.  */\n \n static statistics_counter_t *\n-lookup_or_add_counter (stats_counter_table_type hash, const char *id, int val,\n+lookup_or_add_counter (stats_counter_table_type *hash, const char *id, int val,\n \t\t       bool histogram_p)\n {\n   statistics_counter_t **counter;\n   statistics_counter_t c;\n   c.id = id;\n   c.val = val;\n-  counter = hash.find_slot (&c, INSERT);\n+  counter = hash->find_slot (&c, INSERT);\n   if (!*counter)\n     {\n       *counter = XNEW (struct statistics_counter_s);"}, {"sha": "3023c0c44bb2c0f80b3821ec666f0e34c4ebdcb9", "filename": "gcc/store-motion.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -129,7 +129,7 @@ st_expr_hasher::equal (const value_type *ptr1, const compare_type *ptr2)\n }\n \n /* Hashtable for the load/store memory refs.  */\n-static hash_table <st_expr_hasher> store_motion_mems_table;\n+static hash_table<st_expr_hasher> *store_motion_mems_table;\n \n /* This will search the st_expr list for a matching expression. If it\n    doesn't find one, we create one and initialize it.  */\n@@ -147,7 +147,7 @@ st_expr_entry (rtx x)\n \t\t   NULL,  /*have_reg_qty=*/false);\n \n   e.pattern = x;\n-  slot = store_motion_mems_table.find_slot_with_hash (&e, hash, INSERT);\n+  slot = store_motion_mems_table->find_slot_with_hash (&e, hash, INSERT);\n   if (*slot)\n     return *slot;\n \n@@ -183,8 +183,8 @@ free_st_expr_entry (struct st_expr * ptr)\n static void\n free_store_motion_mems (void)\n {\n-  if (store_motion_mems_table.is_created ())\n-    store_motion_mems_table.dispose ();\n+  delete store_motion_mems_table;\n+  store_motion_mems_table = NULL;\n \n   while (store_motion_mems)\n     {\n@@ -651,7 +651,7 @@ compute_store_table (void)\n   unsigned int max_gcse_regno = max_reg_num ();\n \n   store_motion_mems = NULL;\n-  store_motion_mems_table.create (13);\n+  store_motion_mems_table = new hash_table<st_expr_hasher> (13);\n   last_set_in = XCNEWVEC (int, max_gcse_regno);\n   already_set = XNEWVEC (int, max_gcse_regno);\n \n@@ -713,7 +713,7 @@ compute_store_table (void)\n       if (! ptr->avail_stores)\n \t{\n \t  *prev_next_ptr_ptr = ptr->next;\n-\t  store_motion_mems_table.remove_elt_with_hash (ptr, ptr->hash_index);\n+\t  store_motion_mems_table->remove_elt_with_hash (ptr, ptr->hash_index);\n \t  free_st_expr_entry (ptr);\n \t}\n       else\n@@ -1152,7 +1152,8 @@ one_store_motion_pass (void)\n   num_stores = compute_store_table ();\n   if (num_stores == 0)\n     {\n-      store_motion_mems_table.dispose ();\n+      delete store_motion_mems_table;\n+      store_motion_mems_table = NULL;\n       end_alias_analysis ();\n       return 0;\n     }"}, {"sha": "c4baa437e9816bb9e538b1929e4b78c9a8371cc5", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -982,7 +982,7 @@ log_entry_hasher::remove (value_type *lp)\n \n \n /* The actual log.  */\n-static hash_table <log_entry_hasher> tm_log;\n+static hash_table<log_entry_hasher> *tm_log;\n \n /* Addresses to log with a save/restore sequence.  These should be in\n    dominator order.  */\n@@ -1027,23 +1027,25 @@ tm_mem_map_hasher::equal (const value_type *v, const compare_type *c)\n \n /* Map for an SSA_NAME originally pointing to a non aliased new piece\n    of memory (malloc, alloc, etc).  */\n-static hash_table <tm_mem_map_hasher> tm_new_mem_hash;\n+static hash_table<tm_mem_map_hasher> *tm_new_mem_hash;\n \n /* Initialize logging data structures.  */\n static void\n tm_log_init (void)\n {\n-  tm_log.create (10);\n-  tm_new_mem_hash.create (5);\n+  tm_log = new hash_table<log_entry_hasher> (10);\n+  tm_new_mem_hash = new hash_table<tm_mem_map_hasher> (5);\n   tm_log_save_addresses.create (5);\n }\n \n /* Free logging data structures.  */\n static void\n tm_log_delete (void)\n {\n-  tm_log.dispose ();\n-  tm_new_mem_hash.dispose ();\n+  delete tm_log;\n+  tm_log = NULL;\n+  delete tm_new_mem_hash;\n+  tm_new_mem_hash = NULL;\n   tm_log_save_addresses.release ();\n }\n \n@@ -1088,7 +1090,7 @@ tm_log_add (basic_block entry_block, tree addr, gimple stmt)\n   struct tm_log_entry l, *lp;\n \n   l.addr = addr;\n-  slot = tm_log.find_slot (&l, INSERT);\n+  slot = tm_log->find_slot (&l, INSERT);\n   if (!*slot)\n     {\n       tree type = TREE_TYPE (addr);\n@@ -1231,10 +1233,10 @@ tm_log_emit_stmt (tree addr, gimple stmt)\n static void\n tm_log_emit (void)\n {\n-  hash_table <log_entry_hasher>::iterator hi;\n+  hash_table<log_entry_hasher>::iterator hi;\n   struct tm_log_entry *lp;\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (tm_log, lp, tm_log_entry_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*tm_log, lp, tm_log_entry_t, hi)\n     {\n       size_t i;\n       gimple stmt;\n@@ -1276,7 +1278,7 @@ tm_log_emit_saves (basic_block entry_block, basic_block bb)\n   for (i = 0; i < tm_log_save_addresses.length (); ++i)\n     {\n       l.addr = tm_log_save_addresses[i];\n-      lp = *(tm_log.find_slot (&l, NO_INSERT));\n+      lp = *(tm_log->find_slot (&l, NO_INSERT));\n       gcc_assert (lp->save_var != NULL);\n \n       /* We only care about variables in the current transaction.  */\n@@ -1312,7 +1314,7 @@ tm_log_emit_restores (basic_block entry_block, basic_block bb)\n   for (i = tm_log_save_addresses.length () - 1; i >= 0; i--)\n     {\n       l.addr = tm_log_save_addresses[i];\n-      lp = *(tm_log.find_slot (&l, NO_INSERT));\n+      lp = *(tm_log->find_slot (&l, NO_INSERT));\n       gcc_assert (lp->save_var != NULL);\n \n       /* We only care about variables in the current transaction.  */\n@@ -1363,7 +1365,7 @@ thread_private_new_memory (basic_block entry_block, tree x)\n \n   /* Look in cache first.  */\n   elt.val = x;\n-  slot = tm_new_mem_hash.find_slot (&elt, INSERT);\n+  slot = tm_new_mem_hash->find_slot (&elt, INSERT);\n   elt_p = *slot;\n   if (elt_p)\n     return elt_p->local_new_memory;\n@@ -3340,7 +3342,7 @@ static bitmap_obstack tm_memopt_obstack;\n /* Unique counter for TM loads and stores. Loads and stores of the\n    same address get the same ID.  */\n static unsigned int tm_memopt_value_id;\n-static hash_table <tm_memop_hasher> tm_memopt_value_numbers;\n+static hash_table<tm_memop_hasher> *tm_memopt_value_numbers;\n \n #define STORE_AVAIL_IN(BB) \\\n   ((struct tm_memopt_bitmaps *) ((BB)->aux))->store_avail_in\n@@ -3374,7 +3376,7 @@ tm_memopt_value_number (gimple stmt, enum insert_option op)\n \n   gcc_assert (is_tm_load (stmt) || is_tm_store (stmt));\n   tmpmem.addr = gimple_call_arg (stmt, 0);\n-  slot = tm_memopt_value_numbers.find_slot (&tmpmem, op);\n+  slot = tm_memopt_value_numbers->find_slot (&tmpmem, op);\n   if (*slot)\n     mem = *slot;\n   else if (op == INSERT)\n@@ -3434,11 +3436,11 @@ dump_tm_memopt_set (const char *set_name, bitmap bits)\n   fprintf (dump_file, \"TM memopt: %s: [\", set_name);\n   EXECUTE_IF_SET_IN_BITMAP (bits, 0, i, bi)\n     {\n-      hash_table <tm_memop_hasher>::iterator hi;\n+      hash_table<tm_memop_hasher>::iterator hi;\n       struct tm_memop *mem = NULL;\n \n       /* Yeah, yeah, yeah.  Whatever.  This is just for debugging.  */\n-      FOR_EACH_HASH_TABLE_ELEMENT (tm_memopt_value_numbers, mem, tm_memop_t, hi)\n+      FOR_EACH_HASH_TABLE_ELEMENT (*tm_memopt_value_numbers, mem, tm_memop_t, hi)\n \tif (mem->value_id == i)\n \t  break;\n       gcc_assert (mem->value_id == i);\n@@ -3874,7 +3876,7 @@ execute_tm_memopt (void)\n   vec<basic_block> bbs;\n \n   tm_memopt_value_id = 0;\n-  tm_memopt_value_numbers.create (10);\n+  tm_memopt_value_numbers = new hash_table<tm_memop_hasher> (10);\n \n   for (region = all_tm_regions; region; region = region->next)\n     {\n@@ -3908,10 +3910,11 @@ execute_tm_memopt (void)\n       tm_memopt_free_sets (bbs);\n       bbs.release ();\n       bitmap_obstack_release (&tm_memopt_obstack);\n-      tm_memopt_value_numbers.empty ();\n+      tm_memopt_value_numbers->empty ();\n     }\n \n-  tm_memopt_value_numbers.dispose ();\n+  delete tm_memopt_value_numbers;\n+  tm_memopt_value_numbers = NULL;\n   return 0;\n }\n "}, {"sha": "8c03550d58c002153ff1352944157efe904c3091", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -134,7 +134,7 @@ tree_upper_hasher::equal (const value_type *parent, const compare_type *node)\n }\n \n /* Static variables.  */\n-static hash_table <tree_upper_hasher> TB_up_ht;\n+static hash_table<tree_upper_hasher> *TB_up_ht;\n static vec<tree, va_gc> *TB_history_stack;\n static int TB_verbose = 1;\n \n@@ -167,7 +167,7 @@ browse_tree (tree begin)\n \n   /* Store in a hashtable information about previous and upper statements.  */\n   {\n-    TB_up_ht.create (1023);\n+    TB_up_ht = new hash_table<tree_upper_hasher> (1023);\n     TB_update_up (head);\n   }\n \n@@ -645,7 +645,8 @@ browse_tree (tree begin)\n     }\n \n  ret:;\n-  TB_up_ht.dispose ();\n+  delete TB_up_ht;\n+  TB_up_ht = NULL;\n   return;\n }\n \n@@ -691,7 +692,7 @@ TB_up_expr (tree node)\n   if (node == NULL_TREE)\n     return NULL_TREE;\n \n-  res = TB_up_ht.find (node);\n+  res = TB_up_ht->find (node);\n   return res;\n }\n \n@@ -769,7 +770,7 @@ store_child_info (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       for (i = 0; i < n; i++)\n \t{\n \t  tree op = TREE_OPERAND (node, i);\n-\t  slot = TB_up_ht.find_slot (op, INSERT);\n+\t  slot = TB_up_ht->find_slot (op, INSERT);\n \t  *slot = node;\n \t}\n     }"}, {"sha": "0a1c4fb93d10f08c340aca4bd92e5a7bc4522682", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -143,7 +143,7 @@ locus_discrim_hasher::equal (const value_type *a, const compare_type *b)\n   return LOCATION_LINE (a->locus) == LOCATION_LINE (b->locus);\n }\n \n-static hash_table <locus_discrim_hasher> discriminator_per_locus;\n+static hash_table<locus_discrim_hasher> *discriminator_per_locus;\n \n /* Basic blocks and flowgraphs.  */\n static void make_blocks (gimple_seq);\n@@ -244,11 +244,12 @@ build_gimple_cfg (gimple_seq seq)\n   group_case_labels ();\n \n   /* Create the edges of the flowgraph.  */\n-  discriminator_per_locus.create (13);\n+  discriminator_per_locus = new hash_table<locus_discrim_hasher> (13);\n   make_edges ();\n   assign_discriminators ();\n   cleanup_dead_labels ();\n-  discriminator_per_locus.dispose ();\n+  delete discriminator_per_locus;\n+  discriminator_per_locus = NULL;\n }\n \n \n@@ -938,7 +939,7 @@ next_discriminator_for_locus (location_t locus)\n \n   item.locus = locus;\n   item.discriminator = 0;\n-  slot = discriminator_per_locus.find_slot_with_hash (\n+  slot = discriminator_per_locus->find_slot_with_hash (\n       &item, LOCATION_LINE (locus), INSERT);\n   gcc_assert (slot);\n   if (*slot == HTAB_EMPTY_ENTRY)"}, {"sha": "7b0115d0f5210c97b7e4080d0e87241dd2f12559", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -73,7 +73,7 @@ static vec<complex_lattice_t> complex_lattice_values;\n \n /* For each complex variable, a pair of variables for the components exists in\n    the hashtable.  */\n-static int_tree_htab_type complex_variable_components;\n+static int_tree_htab_type *complex_variable_components;\n \n /* For each complex SSA_NAME, a pair of ssa names for the components.  */\n static vec<tree> complex_ssa_name_components;\n@@ -85,7 +85,7 @@ cvc_lookup (unsigned int uid)\n {\n   struct int_tree_map *h, in;\n   in.uid = uid;\n-  h = complex_variable_components.find_with_hash (&in, uid);\n+  h = complex_variable_components->find_with_hash (&in, uid);\n   return h ? h->to : NULL;\n }\n \n@@ -100,7 +100,7 @@ cvc_insert (unsigned int uid, tree to)\n   h = XNEW (struct int_tree_map);\n   h->uid = uid;\n   h->to = to;\n-  loc = complex_variable_components.find_slot_with_hash (h, uid, INSERT);\n+  loc = complex_variable_components->find_slot_with_hash (h, uid, INSERT);\n   *loc = h;\n }\n \n@@ -1629,7 +1629,7 @@ tree_lower_complex (void)\n   init_parameter_lattice_values ();\n   ssa_propagate (complex_visit_stmt, complex_visit_phi);\n \n-  complex_variable_components.create (10);\n+  complex_variable_components = new int_tree_htab_type (10);\n \n   complex_ssa_name_components.create (2 * num_ssa_names);\n   complex_ssa_name_components.safe_grow_cleared (2 * num_ssa_names);\n@@ -1650,7 +1650,8 @@ tree_lower_complex (void)\n \n   gsi_commit_edge_inserts ();\n \n-  complex_variable_components.dispose ();\n+  delete complex_variable_components;\n+  complex_variable_components = NULL;\n   complex_ssa_name_components.release ();\n   complex_lattice_values.release ();\n   return 0;"}, {"sha": "ec3d425d7573f60130cbab35a8883c09fe88e66e", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -225,7 +225,7 @@ finally_tree_hasher::equal (const value_type *v, const compare_type *c)\n }\n \n /* Note that this table is *not* marked GTY.  It is short-lived.  */\n-static hash_table <finally_tree_hasher> finally_tree;\n+static hash_table<finally_tree_hasher> *finally_tree;\n \n static void\n record_in_finally_tree (treemple child, gimple parent)\n@@ -237,7 +237,7 @@ record_in_finally_tree (treemple child, gimple parent)\n   n->child = child;\n   n->parent = parent;\n \n-  slot = finally_tree.find_slot (n, INSERT);\n+  slot = finally_tree->find_slot (n, INSERT);\n   gcc_assert (!*slot);\n   *slot = n;\n }\n@@ -316,7 +316,7 @@ outside_finally_tree (treemple start, gimple target)\n   do\n     {\n       n.child = start;\n-      p = finally_tree.find (&n);\n+      p = finally_tree->find (&n);\n       if (!p)\n \treturn true;\n       start.g = p->parent;\n@@ -2161,7 +2161,7 @@ pass_lower_eh::execute (function *fun)\n   if (bodyp == NULL)\n     return 0;\n \n-  finally_tree.create (31);\n+  finally_tree = new hash_table<finally_tree_hasher> (31);\n   eh_region_may_contain_throw_map = BITMAP_ALLOC (NULL);\n   memset (&null_state, 0, sizeof (null_state));\n \n@@ -2179,7 +2179,8 @@ pass_lower_eh::execute (function *fun)\n      didn't change its value, and we don't have to re-set the function.  */\n   gcc_assert (bodyp == gimple_body (current_function_decl));\n \n-  finally_tree.dispose ();\n+  delete finally_tree;\n+  finally_tree = NULL;\n   BITMAP_FREE (eh_region_may_contain_throw_map);\n   eh_seq = NULL;\n "}, {"sha": "1cdcc2faa7c3993cb3bfcf1e2fde15aaa3e9c60a", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -224,7 +224,7 @@ var_info_hasher::equal (const value_type *p1, const compare_type *p2)\n \n /* Each entry in VAR_INFOS contains an element of type STRUCT \n    VAR_INFO_D.  */\n-static hash_table <var_info_hasher> var_infos;\n+static hash_table<var_info_hasher> *var_infos;\n \n \n /* Information stored for SSA names.  */\n@@ -383,7 +383,7 @@ get_var_info (tree decl)\n   struct var_info_d vi;\n   var_info_d **slot;\n   vi.var = decl;\n-  slot = var_infos.find_slot_with_hash (&vi, DECL_UID (decl), INSERT);\n+  slot = var_infos->find_slot_with_hash (&vi, DECL_UID (decl), INSERT);\n   if (*slot == NULL)\n     {\n       var_info_p v = XCNEW (struct var_info_d);\n@@ -1084,14 +1084,14 @@ insert_phi_nodes_compare_var_infos (const void *a, const void *b)\n static void\n insert_phi_nodes (bitmap_head *dfs)\n {\n-  hash_table <var_info_hasher>::iterator hi;\n+  hash_table<var_info_hasher>::iterator hi;\n   unsigned i;\n   var_info_p info;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n-  auto_vec<var_info_p> vars (var_infos.elements ());\n-  FOR_EACH_HASH_TABLE_ELEMENT (var_infos, info, var_info_p, hi)\n+  auto_vec<var_info_p> vars (var_infos->elements ());\n+  FOR_EACH_HASH_TABLE_ELEMENT (*var_infos, info, var_info_p, hi)\n     if (info->info.need_phi_state != NEED_PHI_STATE_NO)\n       vars.quick_push (info);\n \n@@ -1654,7 +1654,7 @@ debug_tree_ssa (void)\n /* Dump statistics for the hash table HTAB.  */\n \n static void\n-htab_statistics (FILE *file, hash_table <var_info_hasher> htab)\n+htab_statistics (FILE *file, const hash_table<var_info_hasher> &htab)\n {\n   fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n \t   (long) htab.size (),\n@@ -1668,11 +1668,11 @@ htab_statistics (FILE *file, hash_table <var_info_hasher> htab)\n void\n dump_tree_ssa_stats (FILE *file)\n {\n-  if (var_infos.is_created ())\n+  if (var_infos)\n     {\n       fprintf (file, \"\\nHash table statistics:\\n\");\n       fprintf (file, \"    var_infos:   \");\n-      htab_statistics (file, var_infos);\n+      htab_statistics (file, *var_infos);\n       fprintf (file, \"\\n\");\n     }\n }\n@@ -1713,8 +1713,8 @@ void\n dump_var_infos (FILE *file)\n {\n   fprintf (file, \"\\n\\nDefinition and live-in blocks:\\n\\n\");\n-  if (var_infos.is_created ())\n-    var_infos.traverse <FILE *, debug_var_infos_r> (file);\n+  if (var_infos)\n+    var_infos->traverse <FILE *, debug_var_infos_r> (file);\n }\n \n \n@@ -2206,7 +2206,7 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what)\n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n       dump_dfa_stats (dump_file);\n-      if (var_infos.is_created ())\n+      if (var_infos)\n \tdump_tree_ssa_stats (dump_file);\n     }\n \n@@ -2261,8 +2261,9 @@ init_ssa_renamer (void)\n   cfun->gimple_df->in_ssa_p = false;\n \n   /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  gcc_assert (!var_infos.is_created ());\n-  var_infos.create (vec_safe_length (cfun->local_decls));\n+  gcc_assert (!var_infos);\n+  var_infos = new hash_table<var_info_hasher>\n+    (vec_safe_length (cfun->local_decls));\n \n   bitmap_obstack_initialize (&update_ssa_obstack);\n }\n@@ -2273,8 +2274,8 @@ init_ssa_renamer (void)\n static void\n fini_ssa_renamer (void)\n {\n-  if (var_infos.is_created ())\n-    var_infos.dispose ();\n+  delete var_infos;\n+    var_infos = NULL;\n \n   bitmap_obstack_release (&update_ssa_obstack);\n \n@@ -3208,7 +3209,7 @@ update_ssa (unsigned update_flags)\n     {\n       /* If we rename bare symbols initialize the mapping to\n          auxiliar info we need to keep track of.  */\n-      var_infos.create (47);\n+      var_infos = new hash_table<var_info_hasher> (47);\n \n       /* If we have to rename some symbols from scratch, we need to\n \t start the process at the root of the CFG.  FIXME, it should"}, {"sha": "3ef4aa632e07d7539776204ecae41f9982f45bb1", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -227,20 +227,20 @@ reduction_hasher::hash (const value_type *a)\n   return a->reduc_version;\n }\n \n-typedef hash_table <reduction_hasher> reduction_info_table_type;\n+typedef hash_table<reduction_hasher> reduction_info_table_type;\n \n \n static struct reduction_info *\n-reduction_phi (reduction_info_table_type reduction_list, gimple phi)\n+reduction_phi (reduction_info_table_type *reduction_list, gimple phi)\n {\n   struct reduction_info tmpred, *red;\n \n-  if (reduction_list.elements () == 0 || phi == NULL)\n+  if (reduction_list->elements () == 0 || phi == NULL)\n     return NULL;\n \n   tmpred.reduc_phi = phi;\n   tmpred.reduc_version = gimple_uid (phi);\n-  red = reduction_list.find (&tmpred);\n+  red = reduction_list->find (&tmpred);\n \n   return red;\n }\n@@ -279,7 +279,7 @@ name_to_copy_hasher::hash (const value_type *a)\n   return (hashval_t) a->version;\n }\n \n-typedef hash_table <name_to_copy_hasher> name_to_copy_table_type;\n+typedef hash_table<name_to_copy_hasher> name_to_copy_table_type;\n \n /* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE\n    matrix.  Rather than use floats, we simply keep a single DENOMINATOR that\n@@ -486,7 +486,7 @@ loop_has_blocks_with_irreducible_flag (struct loop *loop)\n \n static tree\n take_address_of (tree obj, tree type, edge entry,\n-\t\t int_tree_htab_type decl_address, gimple_stmt_iterator *gsi)\n+\t\t int_tree_htab_type *decl_address, gimple_stmt_iterator *gsi)\n {\n   int uid;\n   int_tree_map **dslot;\n@@ -512,7 +512,7 @@ take_address_of (tree obj, tree type, edge entry,\n      on it.  */\n   uid = DECL_UID (TREE_OPERAND (TREE_OPERAND (*var_p, 0), 0));\n   ielt.uid = uid;\n-  dslot = decl_address.find_slot_with_hash (&ielt, uid, INSERT);\n+  dslot = decl_address->find_slot_with_hash (&ielt, uid, INSERT);\n   if (!*dslot)\n     {\n       if (gsi == NULL)\n@@ -609,7 +609,7 @@ struct elv_data\n {\n   struct walk_stmt_info info;\n   edge entry;\n-  int_tree_htab_type decl_address;\n+  int_tree_htab_type *decl_address;\n   gimple_stmt_iterator *gsi;\n   bool changed;\n   bool reset;\n@@ -699,7 +699,7 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n \n static void\n eliminate_local_variables_stmt (edge entry, gimple_stmt_iterator *gsi,\n-\t\t\t\tint_tree_htab_type decl_address)\n+\t\t\t\tint_tree_htab_type *decl_address)\n {\n   struct elv_data dta;\n   gimple stmt = gsi_stmt (*gsi);\n@@ -756,8 +756,7 @@ eliminate_local_variables (edge entry, edge exit)\n   unsigned i;\n   gimple_stmt_iterator gsi;\n   bool has_debug_stmt = false;\n-  int_tree_htab_type decl_address;\n-  decl_address.create (10);\n+  int_tree_htab_type decl_address (10);\n   basic_block entry_bb = entry->src;\n   basic_block exit_bb = exit->dest;\n \n@@ -772,16 +771,14 @@ eliminate_local_variables (edge entry, edge exit)\n \t      has_debug_stmt = true;\n \t  }\n \telse\n-\t  eliminate_local_variables_stmt (entry, &gsi, decl_address);\n+\t  eliminate_local_variables_stmt (entry, &gsi, &decl_address);\n \n   if (has_debug_stmt)\n     FOR_EACH_VEC_ELT (body, i, bb)\n       if (bb != entry_bb && bb != exit_bb)\n \tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t  if (gimple_debug_bind_p (gsi_stmt (gsi)))\n-\t    eliminate_local_variables_stmt (entry, &gsi, decl_address);\n-\n-  decl_address.dispose ();\n+\t    eliminate_local_variables_stmt (entry, &gsi, &decl_address);\n }\n \n /* Returns true if expression EXPR is not defined between ENTRY and\n@@ -819,8 +816,9 @@ expr_invariant_in_region_p (edge entry, edge exit, tree expr)\n    duplicated, storing the copies in DECL_COPIES.  */\n \n static tree\n-separate_decls_in_region_name (tree name, name_to_copy_table_type name_copies,\n-\t\t\t       int_tree_htab_type decl_copies, bool copy_name_p)\n+separate_decls_in_region_name (tree name, name_to_copy_table_type *name_copies,\n+\t\t\t       int_tree_htab_type *decl_copies,\n+\t\t\t       bool copy_name_p)\n {\n   tree copy, var, var_copy;\n   unsigned idx, uid, nuid;\n@@ -834,8 +832,8 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type name_copies,\n \n   idx = SSA_NAME_VERSION (name);\n   elt.version = idx;\n-  slot = name_copies.find_slot_with_hash (&elt, idx,\n-\t\t\t\t\t  copy_name_p ? INSERT : NO_INSERT);\n+  slot = name_copies->find_slot_with_hash (&elt, idx,\n+\t\t\t\t\t   copy_name_p ? INSERT : NO_INSERT);\n   if (slot && *slot)\n     return (*slot)->new_name;\n \n@@ -860,7 +858,7 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type name_copies,\n \n   uid = DECL_UID (var);\n   ielt.uid = uid;\n-  dslot = decl_copies.find_slot_with_hash (&ielt, uid, INSERT);\n+  dslot = decl_copies->find_slot_with_hash (&ielt, uid, INSERT);\n   if (!*dslot)\n     {\n       var_copy = create_tmp_var (TREE_TYPE (var), get_name (var));\n@@ -874,7 +872,7 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type name_copies,\n          it again.  */\n       nuid = DECL_UID (var_copy);\n       ielt.uid = nuid;\n-      dslot = decl_copies.find_slot_with_hash (&ielt, nuid, INSERT);\n+      dslot = decl_copies->find_slot_with_hash (&ielt, nuid, INSERT);\n       gcc_assert (!*dslot);\n       nielt = XNEW (struct int_tree_map);\n       nielt->uid = nuid;\n@@ -897,8 +895,8 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type name_copies,\n \n static void\n separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n-\t\t\t       name_to_copy_table_type name_copies,\n-\t\t\t       int_tree_htab_type decl_copies)\n+\t\t\t       name_to_copy_table_type *name_copies,\n+\t\t\t       int_tree_htab_type *decl_copies)\n {\n   use_operand_p use;\n   def_operand_p def;\n@@ -937,8 +935,8 @@ separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n \n static bool\n separate_decls_in_region_debug (gimple stmt,\n-\t\t\t\tname_to_copy_table_type name_copies,\n-\t\t\t\tint_tree_htab_type decl_copies)\n+\t\t\t\tname_to_copy_table_type *name_copies,\n+\t\t\t\tint_tree_htab_type *decl_copies)\n {\n   use_operand_p use;\n   ssa_op_iter oi;\n@@ -958,7 +956,7 @@ separate_decls_in_region_debug (gimple stmt,\n     return true;\n   gcc_assert (DECL_P (var) && SSA_VAR_P (var));\n   ielt.uid = DECL_UID (var);\n-  dslot = decl_copies.find_slot_with_hash (&ielt, ielt.uid, NO_INSERT);\n+  dslot = decl_copies->find_slot_with_hash (&ielt, ielt.uid, NO_INSERT);\n   if (!dslot)\n     return true;\n   if (gimple_debug_bind_p (stmt))\n@@ -973,7 +971,7 @@ separate_decls_in_region_debug (gimple stmt,\n       continue;\n \n     elt.version = SSA_NAME_VERSION (name);\n-    slot = name_copies.find_slot_with_hash (&elt, elt.version, NO_INSERT);\n+    slot = name_copies->find_slot_with_hash (&elt, elt.version, NO_INSERT);\n     if (!slot)\n       {\n \tgimple_debug_bind_reset_value (stmt);\n@@ -1133,14 +1131,14 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n    shared data is stored in and loaded from.  */\n static void\n create_call_for_reduction (struct loop *loop,\n-\t\t\t   reduction_info_table_type reduction_list,\n+\t\t\t   reduction_info_table_type *reduction_list,\n \t\t\t   struct clsn_data *ld_st_data)\n {\n-  reduction_list.traverse <struct loop *, create_phi_for_local_result> (loop);\n+  reduction_list->traverse <struct loop *, create_phi_for_local_result> (loop);\n   /* Find the fallthru edge from GIMPLE_OMP_CONTINUE.  */\n   ld_st_data->load_bb = FALLTHRU_EDGE (loop->latch)->dest;\n   reduction_list\n-    .traverse <struct clsn_data *, create_call_for_reduction_1> (ld_st_data);\n+    ->traverse <struct clsn_data *, create_call_for_reduction_1> (ld_st_data);\n }\n \n /* Callback for htab_traverse.  Loads the final reduction value at the\n@@ -1182,7 +1180,7 @@ create_loads_for_reductions (reduction_info **slot, struct clsn_data *clsn_data)\n    REDUCTION_LIST describes the list of reductions that the\n    loads should be generated for.  */\n static void\n-create_final_loads_for_reduction (reduction_info_table_type reduction_list,\n+create_final_loads_for_reduction (reduction_info_table_type *reduction_list,\n \t\t\t\t  struct clsn_data *ld_st_data)\n {\n   gimple_stmt_iterator gsi;\n@@ -1196,7 +1194,7 @@ create_final_loads_for_reduction (reduction_info_table_type reduction_list,\n   gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n \n   reduction_list\n-    .traverse <struct clsn_data *, create_loads_for_reductions> (ld_st_data);\n+    ->traverse <struct clsn_data *, create_loads_for_reductions> (ld_st_data);\n \n }\n \n@@ -1288,17 +1286,15 @@ create_loads_and_stores_for_name (name_to_copy_elt **slot,\n \n static void\n separate_decls_in_region (edge entry, edge exit,\n-\t\t\t  reduction_info_table_type reduction_list,\n+\t\t\t  reduction_info_table_type *reduction_list,\n \t\t\t  tree *arg_struct, tree *new_arg_struct,\n \t\t\t  struct clsn_data *ld_st_data)\n \n {\n   basic_block bb1 = split_edge (entry);\n   basic_block bb0 = single_pred (bb1);\n-  name_to_copy_table_type name_copies;\n-  name_copies.create (10);\n-  int_tree_htab_type decl_copies;\n-  decl_copies.create (10);\n+  name_to_copy_table_type name_copies (10);\n+  int_tree_htab_type decl_copies (10);\n   unsigned i;\n   tree type, type_name, nvar;\n   gimple_stmt_iterator gsi;\n@@ -1318,7 +1314,7 @@ separate_decls_in_region (edge entry, edge exit,\n \t{\n \t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    separate_decls_in_region_stmt (entry, exit, gsi_stmt (gsi),\n-\t\t\t\t\t   name_copies, decl_copies);\n+\t\t\t\t\t   &name_copies, &decl_copies);\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n@@ -1328,7 +1324,7 @@ separate_decls_in_region (edge entry, edge exit,\n \t\thas_debug_stmt = true;\n \t      else\n \t\tseparate_decls_in_region_stmt (entry, exit, stmt,\n-\t\t\t\t\t       name_copies, decl_copies);\n+\t\t\t\t\t       &name_copies, &decl_copies);\n \t    }\n \t}\n     }\n@@ -1349,8 +1345,8 @@ separate_decls_in_region (edge entry, edge exit,\n \n \t      if (is_gimple_debug (stmt))\n \t\t{\n-\t\t  if (separate_decls_in_region_debug (stmt, name_copies,\n-\t\t\t\t\t\t      decl_copies))\n+\t\t  if (separate_decls_in_region_debug (stmt, &name_copies,\n+\t\t\t\t\t\t      &decl_copies))\n \t\t    {\n \t\t      gsi_remove (&gsi, true);\n \t\t      continue;\n@@ -1361,7 +1357,7 @@ separate_decls_in_region (edge entry, edge exit,\n \t    }\n \t}\n \n-  if (name_copies.elements () == 0 && reduction_list.elements () == 0)\n+  if (name_copies.elements () == 0 && reduction_list->elements () == 0)\n     {\n       /* It may happen that there is nothing to copy (if there are only\n          loop carried and external variables in the loop).  */\n@@ -1378,10 +1374,10 @@ separate_decls_in_region (edge entry, edge exit,\n       TYPE_NAME (type) = type_name;\n \n       name_copies.traverse <tree, add_field_for_name> (type);\n-      if (reduction_list.is_created () && reduction_list.elements () > 0)\n+      if (reduction_list && reduction_list->elements () > 0)\n \t{\n \t  /* Create the fields for reductions.  */\n-\t  reduction_list.traverse <tree, add_field_for_reduction> (type);\n+\t  reduction_list->traverse <tree, add_field_for_reduction> (type);\n \t}\n       layout_type (type);\n \n@@ -1401,20 +1397,17 @@ separate_decls_in_region (edge entry, edge exit,\n \n       /* Load the calculation from memory (after the join of the threads).  */\n \n-      if (reduction_list.is_created () && reduction_list.elements () > 0)\n+      if (reduction_list && reduction_list->elements () > 0)\n \t{\n \t  reduction_list\n-\t    .traverse <struct clsn_data *, create_stores_for_reduction>\n-\t\t      (ld_st_data);\n+\t    ->traverse <struct clsn_data *, create_stores_for_reduction>\n+\t    (ld_st_data);\n \t  clsn_data.load = make_ssa_name (nvar, NULL);\n \t  clsn_data.load_bb = exit->dest;\n \t  clsn_data.store = ld_st_data->store;\n \t  create_final_loads_for_reduction (reduction_list, &clsn_data);\n \t}\n     }\n-\n-  decl_copies.dispose ();\n-  name_copies.dispose ();\n }\n \n /* Bitmap containing uids of functions created by parallelization.  We cannot\n@@ -1504,7 +1497,7 @@ create_loop_fn (location_t loc)\n \n static void\n transform_to_exit_first_loop (struct loop *loop,\n-\t\t\t      reduction_info_table_type reduction_list,\n+\t\t\t      reduction_info_table_type *reduction_list,\n \t\t\t      tree nit)\n {\n   basic_block *bbs, *nbbs, ex_bb, orig_header;\n@@ -1574,7 +1567,7 @@ transform_to_exit_first_loop (struct loop *loop,\n          PHI_RESULT of this phi is the resulting value of the reduction\n          variable when exiting the loop.  */\n \n-      if (reduction_list.elements () > 0)\n+      if (reduction_list->elements () > 0)\n \t{\n \t  struct reduction_info *red;\n \n@@ -1749,7 +1742,8 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n    REDUCTION_LIST describes the reductions existent in the LOOP.  */\n \n static void\n-gen_parallel_loop (struct loop *loop, reduction_info_table_type reduction_list,\n+gen_parallel_loop (struct loop *loop,\n+\t\t   reduction_info_table_type *reduction_list,\n \t\t   unsigned n_threads, struct tree_niter_desc *niter)\n {\n   tree many_iterations_cond, type, nit;\n@@ -1874,8 +1868,8 @@ gen_parallel_loop (struct loop *loop, reduction_info_table_type reduction_list,\n   transform_to_exit_first_loop (loop, reduction_list, nit);\n \n   /* Generate initializations for reductions.  */\n-  if (reduction_list.elements () > 0)\n-    reduction_list.traverse <struct loop *, initialize_reductions> (loop);\n+  if (reduction_list->elements () > 0)\n+    reduction_list->traverse <struct loop *, initialize_reductions> (loop);\n \n   /* Eliminate the references to local variables from the loop.  */\n   gcc_assert (single_exit (loop));\n@@ -1895,7 +1889,7 @@ gen_parallel_loop (struct loop *loop, reduction_info_table_type reduction_list,\n     loc = gimple_location (cond_stmt);\n   parallel_head = create_parallel_loop (loop, create_loop_fn (loc), arg_struct,\n \t\t\t\t\tnew_arg_struct, n_threads, loc);\n-  if (reduction_list.elements () > 0)\n+  if (reduction_list->elements () > 0)\n     create_call_for_reduction (loop, reduction_list, &clsn_data);\n \n   scev_reset ();\n@@ -1942,7 +1936,7 @@ loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n    and PHI, insert it to the REDUCTION_LIST.  */\n \n static void\n-build_new_reduction (reduction_info_table_type reduction_list,\n+build_new_reduction (reduction_info_table_type *reduction_list,\n \t\t     gimple reduc_stmt, gimple phi)\n {\n   reduction_info **slot;\n@@ -1964,7 +1958,7 @@ build_new_reduction (reduction_info_table_type reduction_list,\n   new_reduction->reduc_phi = phi;\n   new_reduction->reduc_version = SSA_NAME_VERSION (gimple_phi_result (phi));\n   new_reduction->reduction_code = gimple_assign_rhs_code (reduc_stmt);\n-  slot = reduction_list.find_slot (new_reduction, INSERT);\n+  slot = reduction_list->find_slot (new_reduction, INSERT);\n   *slot = new_reduction;\n }\n \n@@ -1981,7 +1975,7 @@ set_reduc_phi_uids (reduction_info **slot, void *data ATTRIBUTE_UNUSED)\n /* Detect all reductions in the LOOP, insert them into REDUCTION_LIST.  */\n \n static void\n-gather_scalar_reductions (loop_p loop, reduction_info_table_type reduction_list)\n+gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list)\n {\n   gimple_stmt_iterator gsi;\n   loop_vec_info simple_loop_info;\n@@ -2013,7 +2007,7 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type reduction_list)\n   /* As gimple_uid is used by the vectorizer in between vect_analyze_loop_form\n      and destroy_loop_vec_info, we can set gimple_uid of reduc_phi stmts\n      only now.  */\n-  reduction_list.traverse <void *, set_reduc_phi_uids> (NULL);\n+  reduction_list->traverse <void *, set_reduc_phi_uids> (NULL);\n }\n \n /* Try to initialize NITER for code generation part.  */\n@@ -2043,7 +2037,7 @@ try_get_loop_niter (loop_p loop, struct tree_niter_desc *niter)\n \n static bool\n try_create_reduction_list (loop_p loop,\n-\t\t\t   reduction_info_table_type reduction_list)\n+\t\t\t   reduction_info_table_type *reduction_list)\n {\n   edge exit = single_dom_exit (loop);\n   gimple_stmt_iterator gsi;\n@@ -2074,7 +2068,7 @@ try_create_reduction_list (loop_p loop,\n \t      fprintf (dump_file,\n \t\t       \"  checking if it a part of reduction pattern:  \\n\");\n \t    }\n-\t  if (reduction_list.elements () == 0)\n+\t  if (reduction_list->elements () == 0)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file,\n@@ -2147,7 +2141,6 @@ parallelize_loops (void)\n   bool changed = false;\n   struct loop *loop;\n   struct tree_niter_desc niter_desc;\n-  reduction_info_table_type reduction_list;\n   struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n   source_location loop_loc;\n@@ -2159,7 +2152,7 @@ parallelize_loops (void)\n     return false;\n \n   gcc_obstack_init (&parloop_obstack);\n-  reduction_list.create (10);\n+  reduction_info_table_type reduction_list (10);\n   init_stmt_vec_info_vec ();\n \n   FOR_EACH_LOOP (loop, 0)\n@@ -2215,7 +2208,7 @@ parallelize_loops (void)\n       if (!try_get_loop_niter (loop, &niter_desc))\n \tcontinue;\n \n-      if (!try_create_reduction_list (loop, reduction_list))\n+      if (!try_create_reduction_list (loop, &reduction_list))\n \tcontinue;\n \n       if (!flag_loop_parallelize_all\n@@ -2234,12 +2227,11 @@ parallelize_loops (void)\n \t  fprintf (dump_file, \"\\nloop at %s:%d: \",\n \t\t   LOCATION_FILE (loop_loc), LOCATION_LINE (loop_loc));\n       }\n-      gen_parallel_loop (loop, reduction_list,\n+      gen_parallel_loop (loop, &reduction_list,\n \t\t\t n_threads, &niter_desc);\n     }\n \n   free_stmt_vec_info_vec ();\n-  reduction_list.dispose ();\n   obstack_free (&parloop_obstack, NULL);\n \n   /* Parallelization will cause new function calls to be inserted through"}, {"sha": "3dac50f798b784f659711421e75a048e4cd77b8f", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -320,7 +320,7 @@ uid_decl_hasher::equal (const value_type *a, const compare_type *b)\n \n /* Set of candidates.  */\n static bitmap candidate_bitmap;\n-static hash_table <uid_decl_hasher> candidates;\n+static hash_table<uid_decl_hasher> *candidates;\n \n /* For a candidate UID return the candidates decl.  */\n \n@@ -329,7 +329,7 @@ candidate (unsigned uid)\n {\n  tree_node t;\n  t.decl_minimal.uid = uid;\n- return candidates.find_with_hash (&t, static_cast <hashval_t> (uid));\n+ return candidates->find_with_hash (&t, static_cast <hashval_t> (uid));\n }\n \n /* Bitmap of candidates which we should try to entirely scalarize away and\n@@ -660,7 +660,8 @@ static void\n sra_initialize (void)\n {\n   candidate_bitmap = BITMAP_ALLOC (NULL);\n-  candidates.create (vec_safe_length (cfun->local_decls) / 2);\n+  candidates = new hash_table<uid_decl_hasher>\n+    (vec_safe_length (cfun->local_decls) / 2);\n   should_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   cannot_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   gcc_obstack_init (&name_obstack);\n@@ -690,7 +691,8 @@ static void\n sra_deinitialize (void)\n {\n   BITMAP_FREE (candidate_bitmap);\n-  candidates.dispose ();\n+  delete candidates;\n+  candidates = NULL;\n   BITMAP_FREE (should_scalarize_away_bitmap);\n   BITMAP_FREE (cannot_scalarize_away_bitmap);\n   free_alloc_pool (access_pool);\n@@ -707,9 +709,7 @@ static void\n disqualify_candidate (tree decl, const char *reason)\n {\n   if (bitmap_clear_bit (candidate_bitmap, DECL_UID (decl)))\n-    candidates.clear_slot (candidates.find_slot_with_hash (decl,\n-\t\t\t\t\t\t\t   DECL_UID (decl),\n-\t\t\t\t\t\t\t   NO_INSERT));\n+    candidates->remove_elt_with_hash (decl, DECL_UID (decl));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1833,7 +1833,7 @@ maybe_add_sra_candidate (tree var)\n     }\n \n   bitmap_set_bit (candidate_bitmap, DECL_UID (var));\n-  slot = candidates.find_slot_with_hash (var, DECL_UID (var), INSERT);\n+  slot = candidates->find_slot_with_hash (var, DECL_UID (var), INSERT);\n   *slot = var;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3792,7 +3792,7 @@ find_param_candidates (void)\n \tcontinue;\n \n       bitmap_set_bit (candidate_bitmap, DECL_UID (parm));\n-      slot = candidates.find_slot_with_hash (parm, DECL_UID (parm), INSERT);\n+      slot = candidates->find_slot_with_hash (parm, DECL_UID (parm), INSERT);\n       *slot = parm;\n \n       ret = true;"}, {"sha": "875ba1a5276945c82894e499cf53eb24aa52780a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1896,14 +1896,14 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n-typedef hash_table <pointer_hash <gimple_statement_base> > gimple_htab;\n+typedef hash_table<pointer_hash<gimple_statement_base> > gimple_htab;\n \n /* Given a BUILT_IN_STACK_SAVE value SAVED_VAL, insert a clobber of VAR before\n    each matching BUILT_IN_STACK_RESTORE.  Mark visited phis in VISITED.  */\n \n static void\n insert_clobber_before_stack_restore (tree saved_val, tree var,\n-\t\t\t\t     gimple_htab *visited)\n+\t\t\t\t     gimple_htab **visited)\n {\n   gimple stmt, clobber_stmt;\n   tree clobber;\n@@ -1924,10 +1924,10 @@ insert_clobber_before_stack_restore (tree saved_val, tree var,\n       }\n     else if (gimple_code (stmt) == GIMPLE_PHI)\n       {\n-\tif (!visited->is_created ())\n-\t  visited->create (10);\n+\tif (!*visited)\n+\t  *visited = new gimple_htab (10);\n \n-\tslot = visited->find_slot (stmt, INSERT);\n+\tslot = (*visited)->find_slot (stmt, INSERT);\n \tif (*slot != NULL)\n \t  continue;\n \n@@ -1973,7 +1973,7 @@ insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n {\n   gimple stmt;\n   tree saved_val;\n-  gimple_htab visited;\n+  gimple_htab *visited = NULL;\n \n   for (; !gsi_end_p (i); gsi_prev_dom_bb_nondebug (&i))\n     {\n@@ -1990,8 +1990,7 @@ insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n       break;\n     }\n \n-  if (visited.is_created ())\n-    visited.dispose ();\n+  delete visited;\n }\n \n /* Detects a __builtin_alloca_with_align with constant size argument.  Declares"}, {"sha": "24ed4b4fed6fbc218b385ab92d9ffd088b8c45bd", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -92,7 +92,7 @@ coalesce_pair_hasher::equal (const value_type *p1, const compare_type *p2)\n \t  && p1->second_element == p2->second_element);\n }\n \n-typedef hash_table <coalesce_pair_hasher> coalesce_table_type;\n+typedef hash_table<coalesce_pair_hasher> coalesce_table_type;\n typedef coalesce_table_type::iterator coalesce_iterator_type;\n \n \n@@ -107,7 +107,7 @@ typedef struct cost_one_pair_d\n \n typedef struct coalesce_list_d\n {\n-  coalesce_table_type list;\t/* Hash table.  */\n+  coalesce_table_type *list;\t/* Hash table.  */\n   coalesce_pair_p *sorted;\t/* List when sorted.  */\n   int num_sorted;\t\t/* Number in the sorted list.  */\n   cost_one_pair_p cost_one_list;/* Single use coalesces with cost 1.  */\n@@ -244,7 +244,7 @@ create_coalesce_list (void)\n     size = 40;\n \n   list = (coalesce_list_p) xmalloc (sizeof (struct coalesce_list_d));\n-  list->list.create (size);\n+  list->list = new coalesce_table_type (size);\n   list->sorted = NULL;\n   list->num_sorted = 0;\n   list->cost_one_list = NULL;\n@@ -258,7 +258,8 @@ static inline void\n delete_coalesce_list (coalesce_list_p cl)\n {\n   gcc_assert (cl->cost_one_list == NULL);\n-  cl->list.dispose ();\n+  delete cl->list;\n+  cl->list = NULL;\n   free (cl->sorted);\n   gcc_assert (cl->num_sorted == 0);\n   free (cl);\n@@ -289,7 +290,7 @@ find_coalesce_pair (coalesce_list_p cl, int p1, int p2, bool create)\n     }\n \n   hash = coalesce_pair_hasher::hash (&p);\n-  slot = cl->list.find_slot_with_hash (&p, hash, create ? INSERT : NO_INSERT);\n+  slot = cl->list->find_slot_with_hash (&p, hash, create ? INSERT : NO_INSERT);\n   if (!slot)\n     return NULL;\n \n@@ -372,14 +373,14 @@ compare_pairs (const void *p1, const void *p2)\n static inline int\n num_coalesce_pairs (coalesce_list_p cl)\n {\n-  return cl->list.elements ();\n+  return cl->list->elements ();\n }\n \n \n /* Iterate over CL using ITER, returning values in PAIR.  */\n \n #define FOR_EACH_PARTITION_PAIR(PAIR, ITER, CL)\t\t\\\n-  FOR_EACH_HASH_TABLE_ELEMENT ((CL)->list, (PAIR), coalesce_pair_p, (ITER))\n+  FOR_EACH_HASH_TABLE_ELEMENT (*(CL)->list, (PAIR), coalesce_pair_p, (ITER))\n \n \n /* Prepare CL for removal of preferred pairs.  When finished they are sorted\n@@ -1267,9 +1268,8 @@ coalesce_ssa_name (void)\n      from the same SSA_NAME_VAR so debug info remains undisturbed.  */\n   if (!optimize)\n     {\n-      hash_table <ssa_name_var_hash> ssa_name_hash;\n+      hash_table<ssa_name_var_hash> ssa_name_hash (10);\n \n-      ssa_name_hash.create (10);\n       for (i = 1; i < num_ssa_names; i++)\n \t{\n \t  tree a = ssa_name (i);\n@@ -1303,7 +1303,6 @@ coalesce_ssa_name (void)\n \t\t}\n \t    }\n \t}\n-      ssa_name_hash.dispose ();\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);"}, {"sha": "6c581ba7ba52cb94be8b955f1b21d7bd63c18237", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -223,7 +223,7 @@ expr_elt_hasher::remove (value_type *element)\n    global redundancy elimination).  Similarly as we pass through conditionals\n    we record the conditional itself as having either a true or false value\n    in this table.  */\n-static hash_table <expr_elt_hasher> avail_exprs;\n+static hash_table<expr_elt_hasher> *avail_exprs;\n \n /* Stack of dest,src pairs that need to be restored during finalization.\n \n@@ -254,7 +254,8 @@ static struct opt_stats_d opt_stats;\n static void optimize_stmt (basic_block, gimple_stmt_iterator);\n static tree lookup_avail_expr (gimple, bool);\n static hashval_t avail_expr_hash (const void *);\n-static void htab_statistics (FILE *, hash_table <expr_elt_hasher>);\n+static void htab_statistics (FILE *,\n+\t\t\t     const hash_table<expr_elt_hasher> &);\n static void record_cond (cond_equivalence *);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n@@ -876,7 +877,7 @@ pass_dominator::execute (function *fun)\n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n   /* Create our hash tables.  */\n-  avail_exprs.create (1024);\n+  avail_exprs = new hash_table<expr_elt_hasher> (1024);\n   avail_exprs_stack.create (20);\n   const_and_copies_stack.create (20);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n@@ -976,7 +977,8 @@ pass_dominator::execute (function *fun)\n   loop_optimizer_finalize ();\n \n   /* Delete our main hashtable.  */\n-  avail_exprs.dispose ();\n+  delete avail_exprs;\n+  avail_exprs = NULL;\n \n   /* Free asserted bitmaps and stacks.  */\n   BITMAP_FREE (need_eh_cleanup);\n@@ -1070,9 +1072,9 @@ remove_local_expressions_from_table (void)\n           print_expr_hash_elt (dump_file, victim);\n         }\n \n-      slot = avail_exprs.find_slot_with_hash (victim, victim->hash, NO_INSERT);\n+      slot = avail_exprs->find_slot (victim, NO_INSERT);\n       gcc_assert (slot && *slot == victim);\n-      avail_exprs.clear_slot (slot);\n+      avail_exprs->clear_slot (slot);\n     }\n }\n \n@@ -1351,7 +1353,7 @@ dump_dominator_optimization_stats (FILE *file)\n   fprintf (file, \"\\nHash table statistics:\\n\");\n \n   fprintf (file, \"    avail_exprs: \");\n-  htab_statistics (file, avail_exprs);\n+  htab_statistics (file, *avail_exprs);\n }\n \n \n@@ -1367,7 +1369,7 @@ debug_dominator_optimization_stats (void)\n /* Dump statistics for the hash table HTAB.  */\n \n static void\n-htab_statistics (FILE *file, hash_table <expr_elt_hasher> htab)\n+htab_statistics (FILE *file, const hash_table<expr_elt_hasher> &htab)\n {\n   fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n \t   (long) htab.size (),\n@@ -1388,7 +1390,7 @@ record_cond (cond_equivalence *p)\n \n   initialize_hash_element_from_expr (&p->cond, p->value, element);\n \n-  slot = avail_exprs.find_slot_with_hash (element, element->hash, INSERT);\n+  slot = avail_exprs->find_slot_with_hash (element, element->hash, INSERT);\n   if (*slot == NULL)\n     {\n       *slot = element;\n@@ -2551,8 +2553,7 @@ lookup_avail_expr (gimple stmt, bool insert)\n     return NULL_TREE;\n \n   /* Finally try to find the expression in the main expression hash table.  */\n-  slot = avail_exprs.find_slot_with_hash (&element, element.hash,\n-\t\t\t\t\t  (insert ? INSERT : NO_INSERT));\n+  slot = avail_exprs->find_slot (&element, (insert ? INSERT : NO_INSERT));\n   if (slot == NULL)\n     {\n       free_expr_hash_elt_contents (&element);"}, {"sha": "23eaf262c64d1eb6923f7e1ff73ef2ada60fc999", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -97,11 +97,10 @@ var_map_base_init (var_map map)\n {\n   int x, num_part;\n   tree var;\n-  hash_table <tree_int_map_hasher> tree_to_index;\n   struct tree_int_map *m, *mapstorage;\n \n   num_part = num_var_partitions (map);\n-  tree_to_index.create (num_part);\n+  hash_table<tree_int_map_hasher> tree_to_index (num_part);\n   /* We can have at most num_part entries in the hash tables, so it's\n      enough to allocate so many map elements once, saving some malloc\n      calls.  */\n@@ -149,7 +148,6 @@ var_map_base_init (var_map map)\n   map->num_basevars = m - mapstorage;\n \n   free (mapstorage);\n-  tree_to_index. dispose ();\n }\n \n "}, {"sha": "189da1415b61adfe64577f06ce6f813d415a4b35", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -184,7 +184,7 @@ mem_ref_hasher::equal (const value_type *mem1, const compare_type *obj2)\n static struct\n {\n   /* The hash table of memory references accessed in loops.  */\n-  hash_table <mem_ref_hasher> refs;\n+  hash_table<mem_ref_hasher> *refs;\n \n   /* The list of memory references.  */\n   vec<mem_ref_p> refs_list;\n@@ -609,7 +609,7 @@ mem_ref_in_stmt (gimple stmt)\n   gcc_assert (!store);\n \n   hash = iterative_hash_expr (*mem, 0);\n-  ref = memory_accesses.refs.find_with_hash (*mem, hash);\n+  ref = memory_accesses.refs->find_with_hash (*mem, hash);\n \n   gcc_assert (ref != NULL);\n   return ref;\n@@ -1485,7 +1485,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n   else\n     {\n       hash = iterative_hash_expr (*mem, 0);\n-      slot = memory_accesses.refs.find_slot_with_hash (*mem, hash, INSERT);\n+      slot = memory_accesses.refs->find_slot_with_hash (*mem, hash, INSERT);\n       if (*slot)\n \t{\n \t  ref = (mem_ref_p) *slot;\n@@ -2436,7 +2436,7 @@ tree_ssa_lim_initialize (void)\n \n   alloc_aux_for_edges (0);\n \n-  memory_accesses.refs.create (100);\n+  memory_accesses.refs = new hash_table<mem_ref_hasher> (100);\n   memory_accesses.refs_list.create (100);\n   /* Allocate a special, unanalyzable mem-ref with ID zero.  */\n   memory_accesses.refs_list.quick_push\n@@ -2486,7 +2486,8 @@ tree_ssa_lim_finalize (void)\n   bitmap_obstack_release (&lim_bitmap_obstack);\n   pointer_map_destroy (lim_aux_data_map);\n \n-  memory_accesses.refs.dispose ();\n+  delete memory_accesses.refs;\n+  memory_accesses.refs = NULL;\n \n   FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n     memref_free (ref);"}, {"sha": "58f41c0f32b1e0cbe0895e0be8a0278ebcc4b676", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -306,7 +306,7 @@ struct ivopts_data\n \n   /* The hashtable of loop invariant expressions created\n      by ivopt.  */\n-  hash_table <iv_inv_expr_hasher> inv_expr_tab;\n+  hash_table<iv_inv_expr_hasher> *inv_expr_tab;\n \n   /* Loop invariant expression id.  */\n   int inv_expr_id;\n@@ -875,7 +875,7 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->niters = NULL;\n   data->iv_uses.create (20);\n   data->iv_candidates.create (20);\n-  data->inv_expr_tab.create (10);\n+  data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);\n   data->inv_expr_id = 0;\n   decl_rtl_to_reset.create (20);\n }\n@@ -3955,7 +3955,7 @@ get_expr_id (struct ivopts_data *data, tree expr)\n \n   ent.expr = expr;\n   ent.hash = iterative_hash_expr (expr, 0);\n-  slot = data->inv_expr_tab.find_slot (&ent, INSERT);\n+  slot = data->inv_expr_tab->find_slot (&ent, INSERT);\n   if (*slot)\n     return (*slot)->id;\n \n@@ -6785,7 +6785,7 @@ free_loop_data (struct ivopts_data *data)\n \n   decl_rtl_to_reset.truncate (0);\n \n-  data->inv_expr_tab.empty ();\n+  data->inv_expr_tab->empty ();\n   data->inv_expr_id = 0;\n }\n \n@@ -6803,7 +6803,8 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   decl_rtl_to_reset.release ();\n   data->iv_uses.release ();\n   data->iv_candidates.release ();\n-  data->inv_expr_tab.dispose ();\n+  delete data->inv_expr_tab;\n+  data->inv_expr_tab = NULL;\n }\n \n /* Returns true if the loop body BODY includes any function calls.  */"}, {"sha": "5c11000e97dd68a3916b3f862485102bb7912f74", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1466,17 +1466,79 @@ ssa_names_hasher::equal (const value_type *n1, const compare_type *n2)\n          && n1->size == n2->size;\n }\n \n-/* The hash table for remembering what we've seen.  */\n-static hash_table <ssa_names_hasher> seen_ssa_names;\n+class nontrapping_dom_walker : public dom_walker\n+{\n+public:\n+  nontrapping_dom_walker (cdi_direction direction, pointer_set_t *ps)\n+    : dom_walker (direction), m_nontrapping (ps), m_seen_ssa_names (128) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+private:\n+\n+  /* We see the expression EXP in basic block BB.  If it's an interesting\n+     expression (an MEM_REF through an SSA_NAME) possibly insert the\n+     expression into the set NONTRAP or the hash table of seen expressions.\n+     STORE is true if this expression is on the LHS, otherwise it's on\n+     the RHS.  */\n+  void add_or_mark_expr (basic_block, tree, bool);\n+\n+  pointer_set_t *m_nontrapping;\n+\n+  /* The hash table for remembering what we've seen.  */\n+  hash_table<ssa_names_hasher> m_seen_ssa_names;\n+};\n+\n+/* Called by walk_dominator_tree, when entering the block BB.  */\n+void\n+nontrapping_dom_walker::before_dom_children (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple_stmt_iterator gsi;\n+\n+  /* If we haven't seen all our predecessors, clear the hash-table.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if ((((size_t)e->src->aux) & 2) == 0)\n+      {\n+\tnt_call_phase++;\n+\tbreak;\n+      }\n+\n+  /* Mark this BB as being on the path to dominator root and as visited.  */\n+  bb->aux = (void*)(1 | 2);\n+\n+  /* And walk the statements in order.  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      if (is_gimple_call (stmt) && !nonfreeing_call_p (stmt))\n+\tnt_call_phase++;\n+      else if (gimple_assign_single_p (stmt) && !gimple_has_volatile_ops (stmt))\n+\t{\n+\t  add_or_mark_expr (bb, gimple_assign_lhs (stmt), true);\n+\t  add_or_mark_expr (bb, gimple_assign_rhs1 (stmt), false);\n+\t}\n+    }\n+}\n+\n+/* Called by walk_dominator_tree, when basic block BB is exited.  */\n+void\n+nontrapping_dom_walker::after_dom_children (basic_block bb)\n+{\n+  /* This BB isn't on the path to dominator root anymore.  */\n+  bb->aux = (void*)2;\n+}\n \n /* We see the expression EXP in basic block BB.  If it's an interesting\n    expression (an MEM_REF through an SSA_NAME) possibly insert the\n    expression into the set NONTRAP or the hash table of seen expressions.\n    STORE is true if this expression is on the LHS, otherwise it's on\n    the RHS.  */\n-static void\n-add_or_mark_expr (basic_block bb, tree exp,\n-\t\t  struct pointer_set_t *nontrap, bool store)\n+void\n+nontrapping_dom_walker::add_or_mark_expr (basic_block bb, tree exp, bool store)\n {\n   HOST_WIDE_INT size;\n \n@@ -1500,7 +1562,7 @@ add_or_mark_expr (basic_block bb, tree exp,\n       map.offset = tree_to_shwi (TREE_OPERAND (exp, 1));\n       map.size = size;\n \n-      slot = seen_ssa_names.find_slot (&map, INSERT);\n+      slot = m_seen_ssa_names.find_slot (&map, INSERT);\n       n2bb = *slot;\n       if (n2bb && n2bb->phase >= nt_call_phase)\n         found_bb = n2bb->bb;\n@@ -1510,7 +1572,7 @@ add_or_mark_expr (basic_block bb, tree exp,\n \t then we can't trap.  */\n       if (found_bb && (((size_t)found_bb->aux) & 1) == 1)\n \t{\n-\t  pointer_set_insert (nontrap, exp);\n+\t  pointer_set_insert (m_nontrapping, exp);\n \t}\n       else\n         {\n@@ -1535,61 +1597,6 @@ add_or_mark_expr (basic_block bb, tree exp,\n     }\n }\n \n-class nontrapping_dom_walker : public dom_walker\n-{\n-public:\n-  nontrapping_dom_walker (cdi_direction direction, pointer_set_t *ps)\n-    : dom_walker (direction), m_nontrapping (ps) {}\n-\n-  virtual void before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-private:\n-  pointer_set_t *m_nontrapping;\n-};\n-\n-/* Called by walk_dominator_tree, when entering the block BB.  */\n-void\n-nontrapping_dom_walker::before_dom_children (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  gimple_stmt_iterator gsi;\n-\n-  /* If we haven't seen all our predecessors, clear the hash-table.  */\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if ((((size_t)e->src->aux) & 2) == 0)\n-      {\n-\tnt_call_phase++;\n-\tbreak;\n-      }\n-\n-  /* Mark this BB as being on the path to dominator root and as visited.  */\n-  bb->aux = (void*)(1 | 2);\n-\n-  /* And walk the statements in order.  */\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-\n-      if (is_gimple_call (stmt) && !nonfreeing_call_p (stmt))\n-\tnt_call_phase++;\n-      else if (gimple_assign_single_p (stmt) && !gimple_has_volatile_ops (stmt))\n-\t{\n-\t  add_or_mark_expr (bb, gimple_assign_lhs (stmt), m_nontrapping, true);\n-\t  add_or_mark_expr (bb, gimple_assign_rhs1 (stmt), m_nontrapping, false);\n-\t}\n-    }\n-}\n-\n-/* Called by walk_dominator_tree, when basic block BB is exited.  */\n-void\n-nontrapping_dom_walker::after_dom_children (basic_block bb)\n-{\n-  /* This BB isn't on the path to dominator root anymore.  */\n-  bb->aux = (void*)2;\n-}\n-\n /* This is the entry point of gathering non trapping memory accesses.\n    It will do a dominator walk over the whole function, and it will\n    make use of the bb->aux pointers.  It returns a set of trees\n@@ -1599,16 +1606,13 @@ get_non_trapping (void)\n {\n   nt_call_phase = 0;\n   pointer_set_t *nontrap = pointer_set_create ();\n-  seen_ssa_names.create (128);\n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   nontrapping_dom_walker (CDI_DOMINATORS, nontrap)\n     .walk (cfun->cfg->x_entry_block_ptr);\n \n-  seen_ssa_names.dispose ();\n-\n   clear_aux_for_blocks ();\n   return nontrap;\n }"}, {"sha": "74238decfef3e9599313cc48127ab3bf0f653d4b", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -253,7 +253,7 @@ static unsigned int next_expression_id;\n \n /* Mapping from expression to id number we can use in bitmap sets.  */\n static vec<pre_expr> expressions;\n-static hash_table <pre_expr_d> expression_to_id;\n+static hash_table<pre_expr_d> *expression_to_id;\n static vec<unsigned> name_to_id;\n \n /* Allocate an expression id for EXPR.  */\n@@ -280,7 +280,7 @@ alloc_expression_id (pre_expr expr)\n     }\n   else\n     {\n-      slot = expression_to_id.find_slot (expr, INSERT);\n+      slot = expression_to_id->find_slot (expr, INSERT);\n       gcc_assert (!*slot);\n       *slot = expr;\n     }\n@@ -309,7 +309,7 @@ lookup_expression_id (const pre_expr expr)\n     }\n   else\n     {\n-      slot = expression_to_id.find_slot (expr, NO_INSERT);\n+      slot = expression_to_id->find_slot (expr, NO_INSERT);\n       if (!slot)\n \treturn 0;\n       return ((pre_expr)*slot)->id;\n@@ -542,7 +542,7 @@ expr_pred_trans_d::equal (const value_type *ve1,\n \n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n-static hash_table <expr_pred_trans_d> phi_translate_table;\n+static hash_table<expr_pred_trans_d> *phi_translate_table;\n \n /* Add the tuple mapping from {expression E, basic block PRED} to\n    the phi translation table and return whether it pre-existed.  */\n@@ -557,7 +557,7 @@ phi_trans_add (expr_pred_trans_t *entry, pre_expr e, basic_block pred)\n   tem.e = e;\n   tem.pred = pred;\n   tem.hashcode = hash;\n-  slot = phi_translate_table.find_slot_with_hash (&tem, hash, INSERT);\n+  slot = phi_translate_table->find_slot_with_hash (&tem, hash, INSERT);\n   if (*slot)\n     {\n       *entry = *slot;\n@@ -1783,7 +1783,7 @@ phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n       else\n \t/* Remove failed translations again, they cause insert\n \t   iteration to not pick up new opportunities reliably.  */\n-\tphi_translate_table.remove_elt_with_hash (slot, slot->hashcode);\n+\tphi_translate_table->remove_elt_with_hash (slot, slot->hashcode);\n     }\n \n   return phitrans;\n@@ -4711,8 +4711,8 @@ init_pre (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  phi_translate_table.create (5110);\n-  expression_to_id.create (num_ssa_names * 3);\n+  phi_translate_table = new hash_table<expr_pred_trans_d> (5110);\n+  expression_to_id = new hash_table<pre_expr_d> (num_ssa_names * 3);\n   bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n \t\t\t\t       sizeof (struct bitmap_set), 30);\n   pre_expr_pool = create_alloc_pool (\"pre_expr nodes\",\n@@ -4738,8 +4738,10 @@ fini_pre ()\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (bitmap_set_pool);\n   free_alloc_pool (pre_expr_pool);\n-  phi_translate_table.dispose ();\n-  expression_to_id.dispose ();\n+  delete phi_translate_table;\n+  phi_translate_table = NULL;\n+  delete expression_to_id;\n+  expression_to_id = NULL;\n   name_to_id.release ();\n \n   free_aux_for_blocks ();"}, {"sha": "4d0d6c21b06c2a68b7a09bac2581cd0a40f39212", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1405,7 +1405,6 @@ undistribute_ops_list (enum tree_code opcode,\n   unsigned nr_candidates, nr_candidates2;\n   sbitmap_iterator sbi0;\n   vec<operand_entry_t> *subops;\n-  hash_table <oecount_hasher> ctable;\n   bool changed = false;\n   int next_oecount_id = 0;\n \n@@ -1453,7 +1452,9 @@ undistribute_ops_list (enum tree_code opcode,\n \n   /* Build linearized sub-operand lists and the counting table.  */\n   cvec.create (0);\n-  ctable.create (15);\n+\n+  hash_table<oecount_hasher> ctable (15);\n+\n   /* ??? Macro arguments cannot have multi-argument template types in\n      them.  This typedef is needed to workaround that limitation.  */\n   typedef vec<operand_entry_t> vec_operand_entry_t_heap;\n@@ -1492,7 +1493,6 @@ undistribute_ops_list (enum tree_code opcode,\n \t    }\n \t}\n     }\n-  ctable.dispose ();\n \n   /* Sort the counting table.  */\n   cvec.qsort (oecount_cmp);"}, {"sha": "139ac3bbc72728b8c0aa75d9e9cdd080ba598f19", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -139,7 +139,7 @@ vn_nary_op_hasher::equal (const value_type *vno1, const compare_type *vno2)\n   return vn_nary_op_eq (vno1, vno2);\n }\n \n-typedef hash_table <vn_nary_op_hasher> vn_nary_op_table_type;\n+typedef hash_table<vn_nary_op_hasher> vn_nary_op_table_type;\n typedef vn_nary_op_table_type::iterator vn_nary_op_iterator_type;\n \n \n@@ -181,7 +181,7 @@ vn_phi_hasher::remove (value_type *phi)\n   phi->phiargs.release ();\n }\n \n-typedef hash_table <vn_phi_hasher> vn_phi_table_type;\n+typedef hash_table<vn_phi_hasher> vn_phi_table_type;\n typedef vn_phi_table_type::iterator vn_phi_iterator_type;\n \n \n@@ -245,17 +245,17 @@ vn_reference_hasher::remove (value_type *v)\n   free_reference (v);\n }\n \n-typedef hash_table <vn_reference_hasher> vn_reference_table_type;\n+typedef hash_table<vn_reference_hasher> vn_reference_table_type;\n typedef vn_reference_table_type::iterator vn_reference_iterator_type;\n \n \n /* The set of hashtables and alloc_pool's for their items.  */\n \n typedef struct vn_tables_s\n {\n-  vn_nary_op_table_type nary;\n-  vn_phi_table_type phis;\n-  vn_reference_table_type references;\n+  vn_nary_op_table_type *nary;\n+  vn_phi_table_type *phis;\n+  vn_reference_table_type *references;\n   struct obstack nary_obstack;\n   alloc_pool phis_pool;\n   alloc_pool references_pool;\n@@ -291,7 +291,7 @@ vn_constant_hasher::equal (const value_type *vc1, const compare_type *vc2)\n   return vn_constant_eq_with_type (vc1->constant, vc2->constant);\n }\n \n-static hash_table <vn_constant_hasher> constant_to_value_id;\n+static hash_table<vn_constant_hasher> *constant_to_value_id;\n static bitmap constant_value_ids;\n \n \n@@ -552,7 +552,7 @@ get_constant_value_id (tree constant)\n \n   vc.hashcode = vn_hash_constant_with_type (constant);\n   vc.constant = constant;\n-  slot = constant_to_value_id.find_slot_with_hash (&vc, vc.hashcode, NO_INSERT);\n+  slot = constant_to_value_id->find_slot (&vc, NO_INSERT);\n   if (slot)\n     return (*slot)->value_id;\n   return 0;\n@@ -570,7 +570,7 @@ get_or_alloc_constant_value_id (tree constant)\n \n   vc.hashcode = vn_hash_constant_with_type (constant);\n   vc.constant = constant;\n-  slot = constant_to_value_id.find_slot_with_hash (&vc, vc.hashcode, INSERT);\n+  slot = constant_to_value_id->find_slot (&vc, INSERT);\n   if (*slot)\n     return (*slot)->value_id;\n \n@@ -1474,9 +1474,9 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n   hashval_t hash;\n \n   hash = vr->hashcode;\n-  slot = current_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n+  slot = current_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = valid_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n+    slot = valid_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n   if (slot)\n     {\n       if (vnresult)\n@@ -1519,9 +1519,9 @@ vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse,\n     vr->hashcode = vr->hashcode + SSA_NAME_VERSION (vr->vuse);\n \n   hash = vr->hashcode;\n-  slot = current_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n+  slot = current_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = valid_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n+    slot = valid_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n   if (slot)\n     return *slot;\n \n@@ -2173,8 +2173,8 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n   vr1->result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;\n   vr1->result_vdef = vdef;\n \n-  slot = current_info->references.find_slot_with_hash (vr1, vr1->hashcode,\n-\t\t\t\t\t\t       INSERT);\n+  slot = current_info->references->find_slot_with_hash (vr1, vr1->hashcode,\n+\t\t\t\t\t\t\tINSERT);\n \n   /* Because we lookup stores using vuses, and value number failures\n      using the vdefs (see visit_reference_op_store for how and why),\n@@ -2216,8 +2216,8 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n     result = SSA_VAL (result);\n   vr1->result = result;\n \n-  slot = current_info->references.find_slot_with_hash (vr1, vr1->hashcode,\n-\t\t\t\t\t\t       INSERT);\n+  slot = current_info->references->find_slot_with_hash (vr1, vr1->hashcode,\n+\t\t\t\t\t\t\tINSERT);\n \n   /* At this point we should have all the things inserted that we have\n      seen before, and we should never try inserting something that\n@@ -2386,9 +2386,11 @@ vn_nary_op_lookup_1 (vn_nary_op_t vno, vn_nary_op_t *vnresult)\n     *vnresult = NULL;\n \n   vno->hashcode = vn_nary_op_compute_hash (vno);\n-  slot = current_info->nary.find_slot_with_hash (vno, vno->hashcode, NO_INSERT);\n+  slot = current_info->nary->find_slot_with_hash (vno, vno->hashcode,\n+\t\t\t\t\t\t  NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = valid_info->nary.find_slot_with_hash (vno, vno->hashcode, NO_INSERT);\n+    slot = valid_info->nary->find_slot_with_hash (vno, vno->hashcode,\n+\t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n   if (vnresult)\n@@ -2471,15 +2473,15 @@ alloc_vn_nary_op (unsigned int length, tree result, unsigned int value_id)\n    VNO->HASHCODE first.  */\n \n static vn_nary_op_t\n-vn_nary_op_insert_into (vn_nary_op_t vno, vn_nary_op_table_type table,\n+vn_nary_op_insert_into (vn_nary_op_t vno, vn_nary_op_table_type *table,\n \t\t\tbool compute_hash)\n {\n   vn_nary_op_s **slot;\n \n   if (compute_hash)\n     vno->hashcode = vn_nary_op_compute_hash (vno);\n \n-  slot = table.find_slot_with_hash (vno, vno->hashcode, INSERT);\n+  slot = table->find_slot_with_hash (vno, vno->hashcode, INSERT);\n   gcc_assert (!*slot);\n \n   *slot = vno;\n@@ -2614,9 +2616,11 @@ vn_phi_lookup (gimple phi)\n   vp1.phiargs = shared_lookup_phiargs;\n   vp1.block = gimple_bb (phi);\n   vp1.hashcode = vn_phi_compute_hash (&vp1);\n-  slot = current_info->phis.find_slot_with_hash (&vp1, vp1.hashcode, NO_INSERT);\n+  slot = current_info->phis->find_slot_with_hash (&vp1, vp1.hashcode,\n+\t\t\t\t\t\t  NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = valid_info->phis.find_slot_with_hash (&vp1, vp1.hashcode, NO_INSERT);\n+    slot = valid_info->phis->find_slot_with_hash (&vp1, vp1.hashcode,\n+\t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n   return (*slot)->result;\n@@ -2647,7 +2651,7 @@ vn_phi_insert (gimple phi, tree result)\n   vp1->result = result;\n   vp1->hashcode = vn_phi_compute_hash (vp1);\n \n-  slot = current_info->phis.find_slot_with_hash (vp1, vp1->hashcode, INSERT);\n+  slot = current_info->phis->find_slot_with_hash (vp1, vp1->hashcode, INSERT);\n \n   /* Because we iterate over phi operations more than once, it's\n      possible the slot might already exist here, hence no assert.*/\n@@ -2886,8 +2890,8 @@ visit_reference_op_call (tree lhs, gimple stmt)\n       vr2->hashcode = vr1.hashcode;\n       vr2->result = lhs;\n       vr2->result_vdef = vdef;\n-      slot = current_info->references.find_slot_with_hash (vr2, vr2->hashcode,\n-\t\t\t\t\t\t\t   INSERT);\n+      slot = current_info->references->find_slot_with_hash (vr2, vr2->hashcode,\n+\t\t\t\t\t\t\t    INSERT);\n       if (*slot)\n \tfree_reference (*slot);\n       *slot = vr2;\n@@ -3748,7 +3752,7 @@ copy_phi (vn_phi_t ophi, vn_tables_t info)\n   vn_phi_s **slot;\n   memcpy (phi, ophi, sizeof (*phi));\n   ophi->phiargs.create (0);\n-  slot = info->phis.find_slot_with_hash (phi, phi->hashcode, INSERT);\n+  slot = info->phis->find_slot_with_hash (phi, phi->hashcode, INSERT);\n   gcc_assert (!*slot);\n   *slot = phi;\n }\n@@ -3763,7 +3767,7 @@ copy_reference (vn_reference_t oref, vn_tables_t info)\n   ref = (vn_reference_t) pool_alloc (info->references_pool);\n   memcpy (ref, oref, sizeof (*ref));\n   oref->operands.create (0);\n-  slot = info->references.find_slot_with_hash (ref, ref->hashcode, INSERT);\n+  slot = info->references->find_slot_with_hash (ref, ref->hashcode, INSERT);\n   if (*slot)\n     free_reference (*slot);\n   *slot = ref;\n@@ -3820,9 +3824,9 @@ process_scc (vec<tree> scc)\n       /* As we are value-numbering optimistically we have to\n \t clear the expression tables and the simplified expressions\n \t in each iteration until we converge.  */\n-      optimistic_info->nary.empty ();\n-      optimistic_info->phis.empty ();\n-      optimistic_info->references.empty ();\n+      optimistic_info->nary->empty ();\n+      optimistic_info->phis->empty ();\n+      optimistic_info->references->empty ();\n       obstack_free (&optimistic_info->nary_obstack, NULL);\n       gcc_obstack_init (&optimistic_info->nary_obstack);\n       empty_alloc_pool (optimistic_info->phis_pool);\n@@ -3839,11 +3843,11 @@ process_scc (vec<tree> scc)\n \n   /* Finally, copy the contents of the no longer used optimistic\n      table to the valid table.  */\n-  FOR_EACH_HASH_TABLE_ELEMENT (optimistic_info->nary, nary, vn_nary_op_t, hin)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->nary, nary, vn_nary_op_t, hin)\n     copy_nary (nary, valid_info);\n-  FOR_EACH_HASH_TABLE_ELEMENT (optimistic_info->phis, phi, vn_phi_t, hip)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->phis, phi, vn_phi_t, hip)\n     copy_phi (phi, valid_info);\n-  FOR_EACH_HASH_TABLE_ELEMENT (optimistic_info->references,\n+  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->references,\n \t\t\t       ref, vn_reference_t, hir)\n     copy_reference (ref, valid_info);\n \n@@ -3998,9 +4002,9 @@ DFS (tree name)\n static void\n allocate_vn_table (vn_tables_t table)\n {\n-  table->phis.create (23);\n-  table->nary.create (23);\n-  table->references.create (23);\n+  table->phis = new vn_phi_table_type (23);\n+  table->nary = new vn_nary_op_table_type (23);\n+  table->references = new vn_reference_table_type (23);\n \n   gcc_obstack_init (&table->nary_obstack);\n   table->phis_pool = create_alloc_pool (\"VN phis\",\n@@ -4016,9 +4020,12 @@ allocate_vn_table (vn_tables_t table)\n static void\n free_vn_table (vn_tables_t table)\n {\n-  table->phis.dispose ();\n-  table->nary.dispose ();\n-  table->references.dispose ();\n+  delete table->phis;\n+  table->phis = NULL;\n+  delete table->nary;\n+  table->nary = NULL;\n+  delete table->references;\n+  table->references = NULL;\n   obstack_free (&table->nary_obstack, NULL);\n   free_alloc_pool (table->phis_pool);\n   free_alloc_pool (table->references_pool);\n@@ -4033,7 +4040,7 @@ init_scc_vn (void)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   sccstack.create (0);\n-  constant_to_value_id.create (23);\n+  constant_to_value_id = new hash_table<vn_constant_hasher> (23);\n \n   constant_value_ids = BITMAP_ALLOC (NULL);\n \n@@ -4090,7 +4097,8 @@ free_scc_vn (void)\n {\n   size_t i;\n \n-  constant_to_value_id.dispose ();\n+  delete constant_to_value_id;\n+  constant_to_value_id = NULL;\n   BITMAP_FREE (constant_value_ids);\n   shared_lookup_phiargs.release ();\n   shared_lookup_references.release ();\n@@ -4141,13 +4149,14 @@ set_hashtable_value_ids (void)\n   /* Now set the value ids of the things we had put in the hash\n      table.  */\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (valid_info->nary, vno, vn_nary_op_t, hin)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*valid_info->nary, vno, vn_nary_op_t, hin)\n     set_value_id_for_result (vno->result, &vno->value_id);\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (valid_info->phis, vp, vn_phi_t, hip)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*valid_info->phis, vp, vn_phi_t, hip)\n     set_value_id_for_result (vp->result, &vp->value_id);\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (valid_info->references, vr, vn_reference_t, hir)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*valid_info->references, vr, vn_reference_t,\n+\t\t\t       hir)\n     set_value_id_for_result (vr->result, &vr->value_id);\n }\n "}, {"sha": "b452d9d6d4cad212fa7c9a202f73e4d80504ee52", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -158,7 +158,7 @@ stridxlist_hasher::equal (const value_type *v, const compare_type *c)\n \n /* Hash table for mapping decls to a chained list of offset -> idx\n    mappings.  */\n-static hash_table <stridxlist_hasher> decl_to_stridxlist_htab;\n+static hash_table<stridxlist_hasher> *decl_to_stridxlist_htab;\n \n /* Obstack for struct stridxlist and struct decl_stridxlist_map.  */\n static struct obstack stridx_obstack;\n@@ -183,15 +183,15 @@ get_addr_stridx (tree exp)\n   struct stridxlist *list;\n   tree base;\n \n-  if (!decl_to_stridxlist_htab.is_created ())\n+  if (!decl_to_stridxlist_htab)\n     return 0;\n \n   base = get_addr_base_and_unit_offset (exp, &off);\n   if (base == NULL || !DECL_P (base))\n     return 0;\n \n   ent.base.from = base;\n-  e = decl_to_stridxlist_htab.find_with_hash (&ent, DECL_UID (base));\n+  e = decl_to_stridxlist_htab->find_with_hash (&ent, DECL_UID (base));\n   if (e == NULL)\n     return 0;\n \n@@ -279,14 +279,14 @@ addr_stridxptr (tree exp)\n   if (base == NULL_TREE || !DECL_P (base))\n     return NULL;\n \n-  if (!decl_to_stridxlist_htab.is_created ())\n+  if (!decl_to_stridxlist_htab)\n     {\n-      decl_to_stridxlist_htab.create (64);\n+      decl_to_stridxlist_htab = new hash_table<stridxlist_hasher> (64);\n       gcc_obstack_init (&stridx_obstack);\n     }\n   ent.base.from = base;\n-  slot = decl_to_stridxlist_htab.find_slot_with_hash (&ent, DECL_UID (base),\n-\t\t\t\t\t\t      INSERT);\n+  slot = decl_to_stridxlist_htab->find_slot_with_hash (&ent, DECL_UID (base),\n+\t\t\t\t\t\t       INSERT);\n   if (*slot)\n     {\n       int i;\n@@ -2106,10 +2106,11 @@ pass_strlen::execute (function *fun)\n \n   ssa_ver_to_stridx.release ();\n   free_alloc_pool (strinfo_pool);\n-  if (decl_to_stridxlist_htab.is_created ())\n+  if (decl_to_stridxlist_htab)\n     {\n       obstack_free (&stridx_obstack, NULL);\n-      decl_to_stridxlist_htab.dispose ();\n+      delete decl_to_stridxlist_htab;\n+      decl_to_stridxlist_htab = NULL;\n     }\n   laststmt.stmt = NULL;\n   laststmt.len = NULL_TREE;"}, {"sha": "0472239f5b02c64ff01fd9303650b61b6f0a6a50", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1927,25 +1927,26 @@ equiv_class_hasher::equal (const value_type *eql1, const compare_type *eql2)\n \n /* A hashtable for mapping a bitmap of labels->pointer equivalence\n    classes.  */\n-static hash_table <equiv_class_hasher> pointer_equiv_class_table;\n+static hash_table<equiv_class_hasher> *pointer_equiv_class_table;\n \n /* A hashtable for mapping a bitmap of labels->location equivalence\n    classes.  */\n-static hash_table <equiv_class_hasher> location_equiv_class_table;\n+static hash_table<equiv_class_hasher> *location_equiv_class_table;\n \n /* Lookup a equivalence class in TABLE by the bitmap of LABELS with\n    hash HAS it contains.  Sets *REF_LABELS to the bitmap LABELS\n    is equivalent to.  */\n \n static equiv_class_label *\n-equiv_class_lookup_or_add (hash_table <equiv_class_hasher> table, bitmap labels)\n+equiv_class_lookup_or_add (hash_table<equiv_class_hasher> *table,\n+\t\t\t   bitmap labels)\n {\n   equiv_class_label **slot;\n   equiv_class_label ecl;\n \n   ecl.labels = labels;\n   ecl.hashcode = bitmap_hash (labels);\n-  slot = table.find_slot_with_hash (&ecl, ecl.hashcode, INSERT);\n+  slot = table->find_slot (&ecl, INSERT);\n   if (!*slot)\n     {\n       *slot = XNEW (struct equiv_class_label);\n@@ -2281,8 +2282,9 @@ perform_var_substitution (constraint_graph_t graph)\n   struct scc_info *si = init_scc_info (size);\n \n   bitmap_obstack_initialize (&iteration_obstack);\n-  pointer_equiv_class_table.create (511);\n-  location_equiv_class_table.create (511);\n+  pointer_equiv_class_table = new hash_table<equiv_class_hasher> (511);\n+  location_equiv_class_table\n+    = new hash_table<equiv_class_hasher> (511);\n   pointer_equiv_class = 1;\n   location_equiv_class = 1;\n \n@@ -2415,8 +2417,10 @@ free_var_substitution_info (struct scc_info *si)\n   free (graph->points_to);\n   free (graph->eq_rep);\n   sbitmap_free (graph->direct_nodes);\n-  pointer_equiv_class_table.dispose ();\n-  location_equiv_class_table.dispose ();\n+  delete pointer_equiv_class_table;\n+  pointer_equiv_class_table = NULL;\n+  delete location_equiv_class_table;\n+  location_equiv_class_table = NULL;\n   bitmap_obstack_release (&iteration_obstack);\n }\n \n@@ -5974,7 +5978,7 @@ shared_bitmap_hasher::equal (const value_type *sbi1, const compare_type *sbi2)\n \n /* Shared_bitmap hashtable.  */\n \n-static hash_table <shared_bitmap_hasher> shared_bitmap_table;\n+static hash_table<shared_bitmap_hasher> *shared_bitmap_table;\n \n /* Lookup a bitmap in the shared bitmap hashtable, and return an already\n    existing instance if there is one, NULL otherwise.  */\n@@ -5988,8 +5992,7 @@ shared_bitmap_lookup (bitmap pt_vars)\n   sbi.pt_vars = pt_vars;\n   sbi.hashcode = bitmap_hash (pt_vars);\n \n-  slot = shared_bitmap_table.find_slot_with_hash (&sbi, sbi.hashcode,\n-\t\t\t\t\t\t  NO_INSERT);\n+  slot = shared_bitmap_table->find_slot (&sbi, NO_INSERT);\n   if (!slot)\n     return NULL;\n   else\n@@ -6008,7 +6011,7 @@ shared_bitmap_add (bitmap pt_vars)\n   sbi->pt_vars = pt_vars;\n   sbi->hashcode = bitmap_hash (pt_vars);\n \n-  slot = shared_bitmap_table.find_slot_with_hash (sbi, sbi->hashcode, INSERT);\n+  slot = shared_bitmap_table->find_slot (sbi, INSERT);\n   gcc_assert (!*slot);\n   *slot = sbi;\n }\n@@ -6682,7 +6685,7 @@ init_alias_vars (void)\n   call_stmt_vars = pointer_map_create ();\n \n   memset (&stats, 0, sizeof (stats));\n-  shared_bitmap_table.create (511);\n+  shared_bitmap_table = new hash_table<shared_bitmap_hasher> (511);\n   init_base_vars ();\n \n   gcc_obstack_init (&fake_var_decl_obstack);\n@@ -6930,7 +6933,8 @@ delete_points_to_sets (void)\n {\n   unsigned int i;\n \n-  shared_bitmap_table.dispose ();\n+  delete shared_bitmap_table;\n+  shared_bitmap_table = NULL;\n   if (dump_file && (dump_flags & TDF_STATS))\n     fprintf (dump_file, \"Points to sets created:%d\\n\",\n \t     stats.points_to_sets_created);"}, {"sha": "7245223ae8cb7009ab46a5351af1325db36bd2b6", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -643,7 +643,7 @@ same_succ_reset (same_succ same)\n   same->succ_flags.truncate (0);\n }\n \n-static hash_table <same_succ_def> same_succ_htab;\n+static hash_table<same_succ_def> *same_succ_htab;\n \n /* Array that is used to store the edge flags for a successor.  */\n \n@@ -664,7 +664,7 @@ extern void debug_same_succ (void);\n DEBUG_FUNCTION void\n debug_same_succ ( void)\n {\n-  same_succ_htab.traverse <FILE *, ssa_same_succ_print_traverse> (stderr);\n+  same_succ_htab->traverse <FILE *, ssa_same_succ_print_traverse> (stderr);\n }\n \n \n@@ -731,7 +731,7 @@ find_same_succ_bb (basic_block bb, same_succ *same_p)\n \n   same->hashval = same_succ_hash (same);\n \n-  slot = same_succ_htab.find_slot_with_hash (same, same->hashval, INSERT);\n+  slot = same_succ_htab->find_slot_with_hash (same, same->hashval, INSERT);\n   if (*slot == NULL)\n     {\n       *slot = same;\n@@ -774,7 +774,7 @@ static void\n init_worklist (void)\n {\n   alloc_aux_for_blocks (sizeof (struct aux_bb_info));\n-  same_succ_htab.create (n_basic_blocks_for_fn (cfun));\n+  same_succ_htab = new hash_table<same_succ_def> (n_basic_blocks_for_fn (cfun));\n   same_succ_edge_flags = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n   deleted_bbs = BITMAP_ALLOC (NULL);\n   deleted_bb_preds = BITMAP_ALLOC (NULL);\n@@ -794,7 +794,8 @@ static void\n delete_worklist (void)\n {\n   free_aux_for_blocks ();\n-  same_succ_htab.dispose ();\n+  delete same_succ_htab;\n+  same_succ_htab = NULL;\n   XDELETEVEC (same_succ_edge_flags);\n   same_succ_edge_flags = NULL;\n   BITMAP_FREE (deleted_bbs);\n@@ -824,7 +825,7 @@ same_succ_flush_bb (basic_block bb)\n   same_succ same = BB_SAME_SUCC (bb);\n   BB_SAME_SUCC (bb) = NULL;\n   if (bitmap_single_bit_set_p (same->bbs))\n-    same_succ_htab.remove_elt_with_hash (same, same->hashval);\n+    same_succ_htab->remove_elt_with_hash (same, same->hashval);\n   else\n     bitmap_clear_bit (same->bbs, bb->index);\n }\n@@ -1714,7 +1715,7 @@ tail_merge_optimize (unsigned int todo)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"htab collision / search: %f\\n\",\n-\t     same_succ_htab.collisions ());\n+\t     same_succ_htab->collisions ());\n \n   if (nr_bbs_removed_total > 0)\n     {"}, {"sha": "02cf42c0da0c51d75e1c27222eb3d16259ff1791", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -311,7 +311,7 @@ create_block_for_threading (basic_block bb,\n \n /* Main data structure to hold information for duplicates of BB.  */\n \n-static hash_table <redirection_data> redirection_data;\n+static hash_table<redirection_data> *redirection_data;\n \n /* Given an outgoing edge E lookup and return its entry in our hash table.\n \n@@ -334,7 +334,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n   elt->dup_blocks[1] = NULL;\n   elt->incoming_edges = NULL;\n \n-  slot = redirection_data.find_slot (elt, insert);\n+  slot = redirection_data->find_slot (elt, insert);\n \n   /* This will only happen if INSERT is false and the entry is not\n      in the hash table.  */\n@@ -850,7 +850,8 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n      use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n      incoming and outgoing edges such linear searches can get expensive.  */\n-  redirection_data.create (EDGE_COUNT (bb->succs));\n+  redirection_data\n+    = new hash_table<struct redirection_data> (EDGE_COUNT (bb->succs));\n \n   /* If we thread the latch of the loop to its exit, the loop ceases to\n      exist.  Make sure we do not restrict ourselves in order to preserve\n@@ -961,26 +962,27 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n   local_info.template_block = NULL;\n   local_info.bb = bb;\n   local_info.jumps_threaded = false;\n-  redirection_data.traverse <ssa_local_info_t *, ssa_create_duplicates>\n+  redirection_data->traverse <ssa_local_info_t *, ssa_create_duplicates>\n \t\t\t    (&local_info);\n \n   /* The template does not have an outgoing edge.  Create that outgoing\n      edge and update PHI nodes as the edge's target as necessary.\n \n      We do this after creating all the duplicates to avoid creating\n      unnecessary edges.  */\n-  redirection_data.traverse <ssa_local_info_t *, ssa_fixup_template_block>\n+  redirection_data->traverse <ssa_local_info_t *, ssa_fixup_template_block>\n \t\t\t    (&local_info);\n \n   /* The hash table traversals above created the duplicate blocks (and the\n      statements within the duplicate blocks).  This loop creates PHI nodes for\n      the duplicated blocks and redirects the incoming edges into BB to reach\n      the duplicates of BB.  */\n-  redirection_data.traverse <ssa_local_info_t *, ssa_redirect_edges>\n+  redirection_data->traverse <ssa_local_info_t *, ssa_redirect_edges>\n \t\t\t    (&local_info);\n \n   /* Done with this block.  Clear REDIRECTION_DATA.  */\n-  redirection_data.dispose ();\n+  delete redirection_data;\n+  redirection_data = NULL;\n \n   if (noloop_only\n       && bb == bb->loop_father->header)"}, {"sha": "81d30851f53d4fcf76a91ed6fa8c4b895c7d40bd", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -321,7 +321,7 @@ val_ssa_equiv_hasher::remove (value_type *elt)\n /* Global hash table implementing a mapping from invariant values\n    to a list of SSA_NAMEs which have the same value.  We might be\n    able to reuse tree-vn for this code.  */\n-static hash_table <val_ssa_equiv_hasher> val_ssa_equiv;\n+static hash_table<val_ssa_equiv_hasher> *val_ssa_equiv;\n \n static void uncprop_into_successor_phis (basic_block);\n \n@@ -336,7 +336,7 @@ remove_equivalence (tree value)\n   an_equiv_elt.value = value;\n   an_equiv_elt.equivalences.create (0);\n \n-  slot = val_ssa_equiv.find_slot (&an_equiv_elt, NO_INSERT);\n+  slot = val_ssa_equiv->find_slot (&an_equiv_elt, NO_INSERT);\n \n   an_equiv_elt_p = *slot;\n   an_equiv_elt_p->equivalences.pop ();\n@@ -354,7 +354,7 @@ record_equiv (tree value, tree equivalence)\n   an_equiv_elt_p->value = value;\n   an_equiv_elt_p->equivalences.create (0);\n \n-  slot = val_ssa_equiv.find_slot (an_equiv_elt_p, INSERT);\n+  slot = val_ssa_equiv->find_slot (an_equiv_elt_p, INSERT);\n \n   if (*slot == NULL)\n     *slot = an_equiv_elt_p;\n@@ -446,7 +446,7 @@ uncprop_into_successor_phis (basic_block bb)\n \t  /* Lookup this argument's value in the hash table.  */\n \t  an_equiv_elt.value = arg;\n \t  an_equiv_elt.equivalences.create (0);\n-\t  slot = val_ssa_equiv.find_slot (&an_equiv_elt, NO_INSERT);\n+\t  slot = val_ssa_equiv->find_slot (&an_equiv_elt, NO_INSERT);\n \n \t  if (slot)\n \t    {\n@@ -578,7 +578,7 @@ pass_uncprop::execute (function *fun)\n   associate_equivalences_with_edges ();\n \n   /* Create our global data structures.  */\n-  val_ssa_equiv.create (1024);\n+  val_ssa_equiv = new hash_table<val_ssa_equiv_hasher> (1024);\n \n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */\n@@ -590,7 +590,8 @@ pass_uncprop::execute (function *fun)\n \n   /* we just need to empty elements out of the hash table, and cleanup the\n     AUX field on the edges.  */\n-  val_ssa_equiv.dispose ();\n+  delete val_ssa_equiv;\n+  val_ssa_equiv = NULL;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       edge e;"}, {"sha": "93a14cf4db2e57bf15655c4647d48fba654eaeed", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1068,7 +1068,7 @@ vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n   bool supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n \n   elem.npeel = npeel;\n-  slot = LOOP_VINFO_PEELING_HTAB (loop_vinfo).find (&elem);\n+  slot = LOOP_VINFO_PEELING_HTAB (loop_vinfo)->find (&elem);\n   if (slot)\n     slot->count++;\n   else\n@@ -1077,7 +1077,8 @@ vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n       slot->npeel = npeel;\n       slot->dr = dr;\n       slot->count = 1;\n-      new_slot = LOOP_VINFO_PEELING_HTAB (loop_vinfo).find_slot (slot, INSERT);\n+      new_slot\n+       \t= LOOP_VINFO_PEELING_HTAB (loop_vinfo)->find_slot (slot, INSERT);\n       *new_slot = slot;\n     }\n \n@@ -1197,15 +1198,15 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n        res.inside_cost = INT_MAX;\n        res.outside_cost = INT_MAX;\n        LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n-           .traverse <_vect_peel_extended_info *,\n-                      vect_peeling_hash_get_lowest_cost> (&res);\n+           ->traverse <_vect_peel_extended_info *,\n+                       vect_peeling_hash_get_lowest_cost> (&res);\n      }\n    else\n      {\n        res.peel_info.count = 0;\n        LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n-           .traverse <_vect_peel_extended_info *,\n-                      vect_peeling_hash_get_most_frequent> (&res);\n+           ->traverse <_vect_peel_extended_info *,\n+                       vect_peeling_hash_get_most_frequent> (&res);\n      }\n \n    *npeel = res.peel_info.npeel;\n@@ -1397,8 +1398,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n               /* Save info about DR in the hash table.  */\n-              if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo).is_created ())\n-                LOOP_VINFO_PEELING_HTAB (loop_vinfo).create (1);\n+              if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n+                LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n+\t\t  = new hash_table<peel_info_hasher> (1);\n \n               vectype = STMT_VINFO_VECTYPE (stmt_info);\n               nelements = TYPE_VECTOR_SUBPARTS (vectype);"}, {"sha": "7cb9787a917fc48c7091422289680138fef660be", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -1031,8 +1031,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   LOOP_VINFO_REDUCTIONS (loop_vinfo).release ();\n   LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo).release ();\n \n-  if (LOOP_VINFO_PEELING_HTAB (loop_vinfo).is_created ())\n-    LOOP_VINFO_PEELING_HTAB (loop_vinfo).dispose ();\n+  delete LOOP_VINFO_PEELING_HTAB (loop_vinfo);\n+  LOOP_VINFO_PEELING_HTAB (loop_vinfo) = NULL;\n \n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n "}, {"sha": "4d30cfa6a771a8c7f385aa935927f55bc55d36cd", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -157,7 +157,7 @@ simd_array_to_simduid::equal (const value_type *p1, const value_type *p2)\n    into their corresponding constants.  */\n \n static void\n-adjust_simduid_builtins (hash_table <simduid_to_vf> &htab)\n+adjust_simduid_builtins (hash_table<simduid_to_vf> **htab)\n {\n   basic_block bb;\n \n@@ -189,8 +189,8 @@ adjust_simduid_builtins (hash_table <simduid_to_vf> &htab)\n \t  gcc_assert (TREE_CODE (arg) == SSA_NAME);\n \t  simduid_to_vf *p = NULL, data;\n \t  data.simduid = DECL_UID (SSA_NAME_VAR (arg));\n-\t  if (htab.is_created ())\n-\t    p = htab.find (&data);\n+\t  if (*htab)\n+\t    p = (*htab)->find (&data);\n \t  if (p)\n \t    vf = p->vf;\n \t  switch (ifn)\n@@ -216,7 +216,7 @@ adjust_simduid_builtins (hash_table <simduid_to_vf> &htab)\n \n struct note_simd_array_uses_struct\n {\n-  hash_table <simd_array_to_simduid> *htab;\n+  hash_table<simd_array_to_simduid> **htab;\n   unsigned int simduid;\n };\n \n@@ -236,11 +236,11 @@ note_simd_array_uses_cb (tree *tp, int *walk_subtrees, void *data)\n \t   && DECL_CONTEXT (*tp) == current_function_decl)\n     {\n       simd_array_to_simduid data;\n-      if (!ns->htab->is_created ())\n-\tns->htab->create (15);\n+      if (!*ns->htab)\n+\t*ns->htab = new hash_table<simd_array_to_simduid> (15);\n       data.decl = *tp;\n       data.simduid = ns->simduid;\n-      simd_array_to_simduid **slot = ns->htab->find_slot (&data, INSERT);\n+      simd_array_to_simduid **slot = (*ns->htab)->find_slot (&data, INSERT);\n       if (*slot == NULL)\n \t{\n \t  simd_array_to_simduid *p = XNEW (simd_array_to_simduid);\n@@ -258,7 +258,7 @@ note_simd_array_uses_cb (tree *tp, int *walk_subtrees, void *data)\n    simduid.  */\n \n static void\n-note_simd_array_uses (hash_table <simd_array_to_simduid> *htab)\n+note_simd_array_uses (hash_table<simd_array_to_simduid> **htab)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n@@ -389,8 +389,8 @@ vectorize_loops (void)\n   unsigned int num_vectorized_loops = 0;\n   unsigned int vect_loops_num;\n   struct loop *loop;\n-  hash_table <simduid_to_vf> simduid_to_vf_htab;\n-  hash_table <simd_array_to_simduid> simd_array_to_simduid_htab;\n+  hash_table<simduid_to_vf> *simduid_to_vf_htab = NULL;\n+  hash_table<simd_array_to_simduid> *simd_array_to_simduid_htab = NULL;\n   bool any_ifcvt_loops = false;\n   unsigned ret = 0;\n \n@@ -400,7 +400,7 @@ vectorize_loops (void)\n   if (vect_loops_num <= 1)\n     {\n       if (cfun->has_simduid_loops)\n-\tadjust_simduid_builtins (simduid_to_vf_htab);\n+\tadjust_simduid_builtins (&simduid_to_vf_htab);\n       return 0;\n     }\n \n@@ -484,11 +484,11 @@ vectorize_loops (void)\n \tif (loop->simduid)\n \t  {\n \t    simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);\n-\t    if (!simduid_to_vf_htab.is_created ())\n-\t      simduid_to_vf_htab.create (15);\n+\t    if (!simduid_to_vf_htab)\n+\t      simduid_to_vf_htab = new hash_table<simduid_to_vf> (15);\n \t    simduid_to_vf_data->simduid = DECL_UID (loop->simduid);\n \t    simduid_to_vf_data->vf = loop_vinfo->vectorization_factor;\n-\t    *simduid_to_vf_htab.find_slot (simduid_to_vf_data, INSERT)\n+\t    *simduid_to_vf_htab->find_slot (simduid_to_vf_data, INSERT)\n \t      = simduid_to_vf_data;\n \t  }\n \n@@ -541,24 +541,24 @@ vectorize_loops (void)\n \n   /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE} builtins.  */\n   if (cfun->has_simduid_loops)\n-    adjust_simduid_builtins (simduid_to_vf_htab);\n+    adjust_simduid_builtins (&simduid_to_vf_htab);\n \n   /* Shrink any \"omp array simd\" temporary arrays to the\n      actual vectorization factors.  */\n-  if (simd_array_to_simduid_htab.is_created ())\n+  if (simd_array_to_simduid_htab)\n     {\n-      for (hash_table <simd_array_to_simduid>::iterator iter\n-\t   = simd_array_to_simduid_htab.begin ();\n-\t   iter != simd_array_to_simduid_htab.end (); ++iter)\n+      for (hash_table<simd_array_to_simduid>::iterator iter\n+\t   = simd_array_to_simduid_htab->begin ();\n+\t   iter != simd_array_to_simduid_htab->end (); ++iter)\n \tif ((*iter).simduid != -1U)\n \t  {\n \t    tree decl = (*iter).decl;\n \t    int vf = 1;\n-\t    if (simduid_to_vf_htab.is_created ())\n+\t    if (simduid_to_vf_htab)\n \t      {\n \t\tsimduid_to_vf *p = NULL, data;\n \t\tdata.simduid = (*iter).simduid;\n-\t\tp = simduid_to_vf_htab.find (&data);\n+\t\tp = simduid_to_vf_htab->find (&data);\n \t\tif (p)\n \t\t  vf = p->vf;\n \t      }\n@@ -568,10 +568,10 @@ vectorize_loops (void)\n \t    relayout_decl (decl);\n \t  }\n \n-      simd_array_to_simduid_htab.dispose ();\n+      delete simd_array_to_simduid_htab;\n     }\n-  if (simduid_to_vf_htab.is_created ())\n-    simduid_to_vf_htab.dispose ();\n+    delete simduid_to_vf_htab;\n+    simduid_to_vf_htab = NULL;\n \n   if (num_vectorized_loops > 0)\n     {"}, {"sha": "9829ac8bcb78df480137524dc87342fbd4c976a9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -332,7 +332,7 @@ typedef struct _loop_vec_info {\n   vec<gimple> reduction_chains;\n \n   /* Hash table used to choose the best peeling option.  */\n-  hash_table <peel_info_hasher> peeling_htab;\n+  hash_table<peel_info_hasher> *peeling_htab;\n \n   /* Cost data used by the target cost model.  */\n   void *target_cost_data;"}, {"sha": "b5c4913f54dc8d04f9ee75949bb31dffd3eb576b", "filename": "gcc/valtrack.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -214,6 +214,7 @@ void\n dead_debug_global_init (struct dead_debug_global *debug, bitmap used)\n {\n   debug->used = used;\n+  debug->htab = NULL;\n   if (used)\n     bitmap_clear (used);\n }\n@@ -250,7 +251,7 @@ dead_debug_global_find (struct dead_debug_global *global, rtx reg)\n   dead_debug_global_entry temp_entry;\n   temp_entry.reg = reg;\n \n-  dead_debug_global_entry *entry = global->htab.find (&temp_entry);\n+  dead_debug_global_entry *entry = global->htab->find (&temp_entry);\n   gcc_checking_assert (entry && entry->reg == temp_entry.reg);\n \n   return entry;\n@@ -265,10 +266,11 @@ dead_debug_global_insert (struct dead_debug_global *global, rtx reg, rtx dtemp)\n   temp_entry.reg = reg;\n   temp_entry.dtemp = dtemp;\n \n-  if (!global->htab.is_created ())\n-    global->htab.create (31);\n+  if (!global->htab)\n+    global->htab = new hash_table<dead_debug_hash_descr> (31);\n \n-  dead_debug_global_entry **slot = global->htab.find_slot (&temp_entry, INSERT);\n+  dead_debug_global_entry **slot = global->htab->find_slot (&temp_entry,\n+\t\t\t\t\t\t\t    INSERT);\n   gcc_checking_assert (!*slot);\n   *slot = XNEW (dead_debug_global_entry);\n   **slot = temp_entry;\n@@ -493,8 +495,8 @@ dead_debug_global_finish (struct dead_debug_global *global, bitmap used)\n   if (global->used != used)\n     BITMAP_FREE (global->used);\n \n-  if (global->htab.is_created ())\n-    global->htab.dispose ();\n+  delete global->htab;\n+  global->htab = NULL;\n }\n \n /* Add USE to DEBUG, or substitute it right away if it's a pseudo in"}, {"sha": "528eaad67bb1755e538d7a254279b1b8ab010cfa", "filename": "gcc/valtrack.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvaltrack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvaltrack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.h?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -84,7 +84,7 @@ dead_debug_hash_descr::remove (value_type *p)\n struct dead_debug_global\n {\n   /* This hash table that maps pseudos to debug temps.  */\n-  hash_table <dead_debug_hash_descr> htab;\n+  hash_table<dead_debug_hash_descr> *htab;\n   /* For each entry in htab, the bit corresponding to its REGNO will\n      be set.  */\n   bitmap used;"}, {"sha": "ece149250ff02da4dada7063e34d6c05cb90d95c", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 111, "deletions": 105, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -501,7 +501,7 @@ variable_hasher::remove (value_type *var)\n   variable_htab_free (var);\n }\n \n-typedef hash_table <variable_hasher> variable_table_type;\n+typedef hash_table<variable_hasher> variable_table_type;\n typedef variable_table_type::iterator variable_iterator_type;\n \n /* Structure for passing some other parameters to function\n@@ -515,7 +515,7 @@ typedef struct emit_note_data_def\n   enum emit_note_where where;\n \n   /* The variables and values active at this point.  */\n-  variable_table_type vars;\n+  variable_table_type *vars;\n } emit_note_data;\n \n /* Structure holding a refcounted hash table.  If refcount > 1,\n@@ -526,7 +526,7 @@ typedef struct shared_hash_def\n   int refcount;\n \n   /* Actual hash table.  */\n-  variable_table_type htab;\n+  variable_table_type *htab;\n } *shared_hash;\n \n /* Structure holding the IN or OUT set for a basic block.  */\n@@ -589,15 +589,15 @@ static alloc_pool shared_hash_pool;\n static alloc_pool loc_exp_dep_pool;\n \n /* Changed variables, notes will be emitted for them.  */\n-static variable_table_type changed_variables;\n+static variable_table_type *changed_variables;\n \n /* Shall notes be emitted?  */\n static bool emit_notes;\n \n /* Values whose dynamic location lists have gone empty, but whose\n    cselib location lists are still usable.  Use this to hold the\n    current location, the backlinks, etc, during emit_notes.  */\n-static variable_table_type dropped_values;\n+static variable_table_type *dropped_values;\n \n /* Empty shared hashtable.  */\n static shared_hash empty_shared_hash;\n@@ -635,7 +635,7 @@ static void attrs_list_union (attrs *, attrs);\n \n static variable_def **unshare_variable (dataflow_set *set, variable_def **slot,\n \t\t\t\t\tvariable var, enum var_init_status);\n-static void vars_copy (variable_table_type, variable_table_type);\n+static void vars_copy (variable_table_type *, variable_table_type *);\n static tree var_debug_decl (tree);\n static void var_reg_set (dataflow_set *, rtx, enum var_init_status, rtx);\n static void var_reg_delete_and_set (dataflow_set *, rtx, bool,\n@@ -652,7 +652,7 @@ static void dataflow_set_clear (dataflow_set *);\n static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n static int variable_union_info_cmp_pos (const void *, const void *);\n static void dataflow_set_union (dataflow_set *, dataflow_set *);\n-static location_chain find_loc_in_1pdv (rtx, variable, variable_table_type);\n+static location_chain find_loc_in_1pdv (rtx, variable, variable_table_type *);\n static bool canon_value_cmp (rtx, rtx);\n static int loc_cmp (rtx, rtx);\n static bool variable_part_different_p (variable_part *, variable_part *);\n@@ -672,7 +672,7 @@ static bool vt_find_locations (void);\n \n static void dump_attrs_list (attrs);\n static void dump_var (variable);\n-static void dump_vars (variable_table_type);\n+static void dump_vars (variable_table_type *);\n static void dump_dataflow_set (dataflow_set *);\n static void dump_dataflow_sets (void);\n \n@@ -1582,7 +1582,7 @@ shared_hash_shared (shared_hash vars)\n \n /* Return the hash table for VARS.  */\n \n-static inline variable_table_type\n+static inline variable_table_type *\n shared_hash_htab (shared_hash vars)\n {\n   return vars->htab;\n@@ -1606,7 +1606,7 @@ shared_hash_unshare (shared_hash vars)\n   shared_hash new_vars = (shared_hash) pool_alloc (shared_hash_pool);\n   gcc_assert (vars->refcount > 1);\n   new_vars->refcount = 1;\n-  new_vars->htab.create (vars->htab.elements () + 3);\n+  new_vars->htab = new variable_table_type (vars->htab->elements () + 3);\n   vars_copy (new_vars->htab, vars->htab);\n   vars->refcount--;\n   return new_vars;\n@@ -1630,7 +1630,7 @@ shared_hash_destroy (shared_hash vars)\n   gcc_checking_assert (vars->refcount > 0);\n   if (--vars->refcount == 0)\n     {\n-      vars->htab.dispose ();\n+      delete vars->htab;\n       pool_free (shared_hash_pool, vars);\n     }\n }\n@@ -1644,7 +1644,7 @@ shared_hash_find_slot_unshare_1 (shared_hash *pvars, decl_or_value dv,\n {\n   if (shared_hash_shared (*pvars))\n     *pvars = shared_hash_unshare (*pvars);\n-  return shared_hash_htab (*pvars).find_slot_with_hash (dv, dvhash, ins);\n+  return shared_hash_htab (*pvars)->find_slot_with_hash (dv, dvhash, ins);\n }\n \n static inline variable_def **\n@@ -1661,9 +1661,9 @@ shared_hash_find_slot_unshare (shared_hash *pvars, decl_or_value dv,\n static inline variable_def **\n shared_hash_find_slot_1 (shared_hash vars, decl_or_value dv, hashval_t dvhash)\n {\n-  return shared_hash_htab (vars).find_slot_with_hash (dv, dvhash,\n-\t\t\t\t\t\t      shared_hash_shared (vars)\n-\t\t\t\t\t\t      ? NO_INSERT : INSERT);\n+  return shared_hash_htab (vars)->find_slot_with_hash (dv, dvhash,\n+\t\t\t\t\t\t       shared_hash_shared (vars)\n+\t\t\t\t\t\t       ? NO_INSERT : INSERT);\n }\n \n static inline variable_def **\n@@ -1678,7 +1678,7 @@ static inline variable_def **\n shared_hash_find_slot_noinsert_1 (shared_hash vars, decl_or_value dv,\n \t\t\t\t  hashval_t dvhash)\n {\n-  return shared_hash_htab (vars).find_slot_with_hash (dv, dvhash, NO_INSERT);\n+  return shared_hash_htab (vars)->find_slot_with_hash (dv, dvhash, NO_INSERT);\n }\n \n static inline variable_def **\n@@ -1693,7 +1693,7 @@ shared_hash_find_slot_noinsert (shared_hash vars, decl_or_value dv)\n static inline variable\n shared_hash_find_1 (shared_hash vars, decl_or_value dv, hashval_t dvhash)\n {\n-  return shared_hash_htab (vars).find_with_hash (dv, dvhash);\n+  return shared_hash_htab (vars)->find_with_hash (dv, dvhash);\n }\n \n static inline variable\n@@ -1790,8 +1790,9 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n   if (var->in_changed_variables)\n     {\n       variable_def **cslot\n-\t= changed_variables.find_slot_with_hash (var->dv,\n-\t\t\t\t    dv_htab_hash (var->dv), NO_INSERT);\n+\t= changed_variables->find_slot_with_hash (var->dv,\n+\t\t\t\t\t\t  dv_htab_hash (var->dv),\n+\t\t\t\t\t\t  NO_INSERT);\n       gcc_assert (*cslot == (void *) var);\n       var->in_changed_variables = false;\n       variable_htab_free (var);\n@@ -1804,16 +1805,17 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n /* Copy all variables from hash table SRC to hash table DST.  */\n \n static void\n-vars_copy (variable_table_type dst, variable_table_type src)\n+vars_copy (variable_table_type *dst, variable_table_type *src)\n {\n   variable_iterator_type hi;\n   variable var;\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (src, var, variable, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (*src, var, variable, hi)\n     {\n       variable_def **dstp;\n       var->refcount++;\n-      dstp = dst.find_slot_with_hash (var->dv, dv_htab_hash (var->dv), INSERT);\n+      dstp = dst->find_slot_with_hash (var->dv, dv_htab_hash (var->dv),\n+\t\t\t\t       INSERT);\n       *dstp = var;\n     }\n }\n@@ -2324,7 +2326,7 @@ clobber_overlapping_mems (dataflow_set *set, rtx loc)\n \n   set->traversed_vars = set->vars;\n   shared_hash_htab (set->vars)\n-    .traverse <overlapping_mems*, drop_overlapping_mem_locs> (&coms);\n+    ->traverse <overlapping_mems*, drop_overlapping_mem_locs> (&coms);\n   set->traversed_vars = NULL;\n }\n \n@@ -3125,7 +3127,7 @@ dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n       variable_iterator_type hi;\n       variable var;\n \n-      FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (src->vars),\n+      FOR_EACH_HASH_TABLE_ELEMENT (*shared_hash_htab (src->vars),\n \t\t\t\t   var, variable, hi)\n \tvariable_union (var, dst);\n     }\n@@ -3189,7 +3191,7 @@ dv_changed_p (decl_or_value dv)\n    be in star-canonical form.  */\n \n static location_chain\n-find_loc_in_1pdv (rtx loc, variable var, variable_table_type vars)\n+find_loc_in_1pdv (rtx loc, variable var, variable_table_type *vars)\n {\n   location_chain node;\n   enum rtx_code loc_code;\n@@ -3246,7 +3248,7 @@ find_loc_in_1pdv (rtx loc, variable var, variable_table_type vars)\n       gcc_checking_assert (!node->next);\n \n       dv = dv_from_value (node->loc);\n-      rvar = vars.find_with_hash (dv, dv_htab_hash (dv));\n+      rvar = vars->find_with_hash (dv, dv_htab_hash (dv));\n       return find_loc_in_1pdv (loc, rvar, vars);\n     }\n \n@@ -4226,14 +4228,14 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   variable_iterator_type hi;\n   variable var;\n \n-  src1_elems = shared_hash_htab (src1->vars).elements ();\n-  src2_elems = shared_hash_htab (src2->vars).elements ();\n+  src1_elems = shared_hash_htab (src1->vars)->elements ();\n+  src2_elems = shared_hash_htab (src2->vars)->elements ();\n   dataflow_set_init (dst);\n   dst->stack_adjust = cur.stack_adjust;\n   shared_hash_destroy (dst->vars);\n   dst->vars = (shared_hash) pool_alloc (shared_hash_pool);\n   dst->vars->refcount = 1;\n-  dst->vars->htab.create (MAX (src1_elems, src2_elems));\n+  dst->vars->htab = new variable_table_type (MAX (src1_elems, src2_elems));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     attrs_list_mpdv_union (&dst->regs[i], src1->regs[i], src2->regs[i]);\n@@ -4243,10 +4245,10 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   dsm.cur = src1;\n   dsm.src_onepart_cnt = 0;\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (dsm.src->vars),\n+  FOR_EACH_HASH_TABLE_ELEMENT (*shared_hash_htab (dsm.src->vars),\n \t\t\t       var, variable, hi)\n     variable_merge_over_src (var, &dsm);\n-  FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (dsm.cur->vars),\n+  FOR_EACH_HASH_TABLE_ELEMENT (*shared_hash_htab (dsm.cur->vars),\n \t\t\t       var, variable, hi)\n     variable_merge_over_cur (var, &dsm);\n \n@@ -4593,22 +4595,22 @@ dataflow_post_merge_adjust (dataflow_set *set, dataflow_set **permp)\n   dfpm.permp = permp;\n \n   shared_hash_htab (set->vars)\n-    .traverse <dfset_post_merge*, variable_post_merge_new_vals> (&dfpm);\n+    ->traverse <dfset_post_merge*, variable_post_merge_new_vals> (&dfpm);\n   if (*permp)\n     shared_hash_htab ((*permp)->vars)\n-      .traverse <dfset_post_merge*, variable_post_merge_perm_vals> (&dfpm);\n+      ->traverse <dfset_post_merge*, variable_post_merge_perm_vals> (&dfpm);\n   shared_hash_htab (set->vars)\n-    .traverse <dataflow_set *, canonicalize_values_star> (set);\n+    ->traverse <dataflow_set *, canonicalize_values_star> (set);\n   shared_hash_htab (set->vars)\n-    .traverse <dataflow_set *, canonicalize_vars_star> (set);\n+    ->traverse <dataflow_set *, canonicalize_vars_star> (set);\n }\n \n /* Return a node whose loc is a MEM that refers to EXPR in the\n    location list of a one-part variable or value VAR, or in that of\n    any values recursively mentioned in the location lists.  */\n \n static location_chain\n-find_mem_expr_in_1pdv (tree expr, rtx val, variable_table_type vars)\n+find_mem_expr_in_1pdv (tree expr, rtx val, variable_table_type *vars)\n {\n   location_chain node;\n   decl_or_value dv;\n@@ -4622,7 +4624,7 @@ find_mem_expr_in_1pdv (tree expr, rtx val, variable_table_type vars)\n \t      && !VALUE_RECURSED_INTO (val));\n \n   dv = dv_from_value (val);\n-  var = vars.find_with_hash (dv, dv_htab_hash (dv));\n+  var = vars->find_with_hash (dv, dv_htab_hash (dv));\n \n   if (!var)\n     return NULL;\n@@ -4873,10 +4875,10 @@ dataflow_set_clear_at_call (dataflow_set *set)\n     {\n       set->traversed_vars = set->vars;\n       shared_hash_htab (set->vars)\n-\t.traverse <dataflow_set *, dataflow_set_preserve_mem_locs> (set);\n+\t->traverse <dataflow_set *, dataflow_set_preserve_mem_locs> (set);\n       set->traversed_vars = set->vars;\n       shared_hash_htab (set->vars)\n-\t.traverse <dataflow_set *, dataflow_set_remove_mem_locs> (set);\n+\t->traverse <dataflow_set *, dataflow_set_remove_mem_locs> (set);\n       set->traversed_vars = NULL;\n     }\n }\n@@ -4981,15 +4983,15 @@ dataflow_set_different (dataflow_set *old_set, dataflow_set *new_set)\n   if (old_set->vars == new_set->vars)\n     return false;\n \n-  if (shared_hash_htab (old_set->vars).elements ()\n-      != shared_hash_htab (new_set->vars).elements ())\n+  if (shared_hash_htab (old_set->vars)->elements ()\n+      != shared_hash_htab (new_set->vars)->elements ())\n     return true;\n \n-  FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (old_set->vars),\n+  FOR_EACH_HASH_TABLE_ELEMENT (*shared_hash_htab (old_set->vars),\n \t\t\t       var1, variable, hi)\n     {\n-      variable_table_type htab = shared_hash_htab (new_set->vars);\n-      variable var2 = htab.find_with_hash (var1->dv, dv_htab_hash (var1->dv));\n+      variable_table_type *htab = shared_hash_htab (new_set->vars);\n+      variable var2 = htab->find_with_hash (var1->dv, dv_htab_hash (var1->dv));\n       if (!var2)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -6945,12 +6947,12 @@ compute_bb_dataflow (basic_block bb)\n \n       dataflow_set_equiv_regs (out);\n       shared_hash_htab (out->vars)\n-\t.traverse <dataflow_set *, canonicalize_values_mark> (out);\n+\t->traverse <dataflow_set *, canonicalize_values_mark> (out);\n       shared_hash_htab (out->vars)\n-\t.traverse <dataflow_set *, canonicalize_values_star> (out);\n+\t->traverse <dataflow_set *, canonicalize_values_star> (out);\n #if ENABLE_CHECKING\n       shared_hash_htab (out->vars)\n-\t.traverse <dataflow_set *, canonicalize_loc_order_check> (out);\n+\t->traverse <dataflow_set *, canonicalize_loc_order_check> (out);\n #endif\n     }\n   changed = dataflow_set_different (&old_out, out);\n@@ -7022,10 +7024,11 @@ vt_find_locations (void)\n \t      if (VTI (bb)->in.vars)\n \t\t{\n \t\t  htabsz\n-\t\t    -= shared_hash_htab (VTI (bb)->in.vars).size ()\n-\t\t\t+ shared_hash_htab (VTI (bb)->out.vars).size ();\n-\t\t  oldinsz = shared_hash_htab (VTI (bb)->in.vars).elements ();\n-\t\t  oldoutsz = shared_hash_htab (VTI (bb)->out.vars).elements ();\n+\t\t    -= shared_hash_htab (VTI (bb)->in.vars)->size ()\n+\t\t\t+ shared_hash_htab (VTI (bb)->out.vars)->size ();\n+\t\t  oldinsz = shared_hash_htab (VTI (bb)->in.vars)->elements ();\n+\t\t  oldoutsz\n+\t\t    = shared_hash_htab (VTI (bb)->out.vars)->elements ();\n \t\t}\n \t      else\n \t\toldinsz = oldoutsz = 0;\n@@ -7064,8 +7067,8 @@ vt_find_locations (void)\n \t\t      /* Merge and merge_adjust should keep entries in\n \t\t\t canonical order.  */\n \t\t      shared_hash_htab (in->vars)\n-\t\t\t.traverse <dataflow_set *,\n-\t\t\t\t   canonicalize_loc_order_check> (in);\n+\t\t\t->traverse <dataflow_set *,\n+\t\t\t\t    canonicalize_loc_order_check> (in);\n #endif\n \t\t      if (dst_can_be_shared)\n \t\t\t{\n@@ -7085,8 +7088,8 @@ vt_find_locations (void)\n \t\t}\n \n \t      changed = compute_bb_dataflow (bb);\n-\t      htabsz += shared_hash_htab (VTI (bb)->in.vars).size ()\n-\t\t\t + shared_hash_htab (VTI (bb)->out.vars).size ();\n+\t      htabsz += shared_hash_htab (VTI (bb)->in.vars)->size ()\n+\t\t\t + shared_hash_htab (VTI (bb)->out.vars)->size ();\n \n \t      if (htabmax && htabsz > htabmax)\n \t\t{\n@@ -7133,9 +7136,9 @@ vt_find_locations (void)\n \t\tfprintf (dump_file,\n \t\t\t \"BB %i: in %i (was %i), out %i (was %i), rem %i + %i, tsz %i\\n\",\n \t\t\t bb->index,\n-\t\t\t (int)shared_hash_htab (VTI (bb)->in.vars).size (),\n+\t\t\t (int)shared_hash_htab (VTI (bb)->in.vars)->size (),\n \t\t\t oldinsz,\n-\t\t\t (int)shared_hash_htab (VTI (bb)->out.vars).size (),\n+\t\t\t (int)shared_hash_htab (VTI (bb)->out.vars)->size (),\n \t\t\t oldoutsz,\n \t\t\t (int)worklist->nodes, (int)pending->nodes, htabsz);\n \n@@ -7242,12 +7245,12 @@ dump_var (variable var)\n /* Print the information about variables from hash table VARS to dump file.  */\n \n static void\n-dump_vars (variable_table_type vars)\n+dump_vars (variable_table_type *vars)\n {\n-  if (vars.elements () > 0)\n+  if (vars->elements () > 0)\n     {\n       fprintf (dump_file, \"Variables:\\n\");\n-      vars.traverse <void *, dump_var_tracking_slot> (NULL);\n+      vars->traverse <void *, dump_var_tracking_slot> (NULL);\n     }\n }\n \n@@ -7299,7 +7302,7 @@ variable_from_dropped (decl_or_value dv, enum insert_option insert)\n   variable empty_var;\n   onepart_enum_t onepart;\n \n-  slot = dropped_values.find_slot_with_hash (dv, dv_htab_hash (dv), insert);\n+  slot = dropped_values->find_slot_with_hash (dv, dv_htab_hash (dv), insert);\n \n   if (!slot)\n     return NULL;\n@@ -7370,7 +7373,7 @@ variable_was_changed (variable var, dataflow_set *set)\n       /* Remember this decl or VALUE has been added to changed_variables.  */\n       set_dv_changed (var->dv, true);\n \n-      slot = changed_variables.find_slot_with_hash (var->dv, hash, INSERT);\n+      slot = changed_variables->find_slot_with_hash (var->dv, hash, INSERT);\n \n       if (*slot)\n \t{\n@@ -7397,9 +7400,9 @@ variable_was_changed (variable var, dataflow_set *set)\n \n \t  if (onepart == ONEPART_VALUE || onepart == ONEPART_DEXPR)\n \t    {\n-\t      dslot = dropped_values.find_slot_with_hash (var->dv,\n-\t\t\t\t\t\tdv_htab_hash (var->dv),\n-\t\t\t\t\t\tINSERT);\n+\t      dslot = dropped_values->find_slot_with_hash (var->dv,\n+\t\t\t\t\t\t\t   dv_htab_hash (var->dv),\n+\t\t\t\t\t\t\t   INSERT);\n \t      empty_var = *dslot;\n \n \t      if (empty_var)\n@@ -7464,7 +7467,7 @@ variable_was_changed (variable var, dataflow_set *set)\n \t      if (shared_hash_shared (set->vars))\n \t\tslot = shared_hash_find_slot_unshare (&set->vars, var->dv,\n \t\t\t\t\t\t      NO_INSERT);\n-\t      shared_hash_htab (set->vars).clear_slot (slot);\n+\t      shared_hash_htab (set->vars)->clear_slot (slot);\n \t    }\n \t}\n     }\n@@ -7976,7 +7979,7 @@ delete_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n struct expand_loc_callback_data\n {\n   /* The variables and values active at this point.  */\n-  variable_table_type vars;\n+  variable_table_type *vars;\n \n   /* Stack of values and debug_exprs under expansion, and their\n      children.  */\n@@ -8065,7 +8068,7 @@ loc_exp_dep_clear (variable var)\n    back-links in VARS.  */\n \n static void\n-loc_exp_insert_dep (variable var, rtx x, variable_table_type vars)\n+loc_exp_insert_dep (variable var, rtx x, variable_table_type *vars)\n {\n   decl_or_value dv;\n   variable xvar;\n@@ -8075,7 +8078,7 @@ loc_exp_insert_dep (variable var, rtx x, variable_table_type vars)\n \n   /* ??? Build a vector of variables parallel to EXPANDING, to avoid\n      an additional look up?  */\n-  xvar = vars.find_with_hash (dv, dv_htab_hash (dv));\n+  xvar = vars->find_with_hash (dv, dv_htab_hash (dv));\n \n   if (!xvar)\n     {\n@@ -8116,7 +8119,7 @@ loc_exp_insert_dep (variable var, rtx x, variable_table_type vars)\n \n static bool\n loc_exp_dep_set (variable var, rtx result, rtx *value, int count,\n-\t\t variable_table_type vars)\n+\t\t variable_table_type *vars)\n {\n   bool pending_recursion = false;\n \n@@ -8145,7 +8148,7 @@ loc_exp_dep_set (variable var, rtx result, rtx *value, int count,\n    attempt to compute a current location.  */\n \n static void\n-notify_dependents_of_resolved_value (variable ivar, variable_table_type vars)\n+notify_dependents_of_resolved_value (variable ivar, variable_table_type *vars)\n {\n   loc_exp_dep *led, *next;\n \n@@ -8183,7 +8186,7 @@ notify_dependents_of_resolved_value (variable ivar, variable_table_type vars)\n \t    continue;\n       }\n \n-      var = vars.find_with_hash (dv, dv_htab_hash (dv));\n+      var = vars->find_with_hash (dv, dv_htab_hash (dv));\n \n       if (!var)\n \tvar = variable_from_dropped (dv, NO_INSERT);\n@@ -8427,7 +8430,7 @@ vt_expand_loc_callback (rtx x, bitmap regs,\n       return NULL;\n     }\n \n-  var = elcd->vars.find_with_hash (dv, dv_htab_hash (dv));\n+  var = elcd->vars->find_with_hash (dv, dv_htab_hash (dv));\n \n   if (!var)\n     {\n@@ -8534,7 +8537,7 @@ resolve_expansions_pending_recursion (vec<rtx, va_heap> *pending)\n    equivalences in VARS, updating their CUR_LOCs in the process.  */\n \n static rtx\n-vt_expand_loc (rtx loc, variable_table_type vars)\n+vt_expand_loc (rtx loc, variable_table_type *vars)\n {\n   struct expand_loc_callback_data data;\n   rtx result;\n@@ -8556,7 +8559,7 @@ vt_expand_loc (rtx loc, variable_table_type vars)\n    in VARS, updating their CUR_LOCs in the process.  */\n \n static rtx\n-vt_expand_1pvar (variable var, variable_table_type vars)\n+vt_expand_1pvar (variable var, variable_table_type *vars)\n {\n   struct expand_loc_callback_data data;\n   rtx loc;\n@@ -8587,7 +8590,7 @@ emit_note_insn_var_location (variable_def **varp, emit_note_data *data)\n   variable var = *varp;\n   rtx insn = data->insn;\n   enum emit_note_where where = data->where;\n-  variable_table_type vars = data->vars;\n+  variable_table_type *vars = data->vars;\n   rtx note, note_vl;\n   int i, j, n_var_parts;\n   bool complete;\n@@ -8802,7 +8805,7 @@ emit_note_insn_var_location (variable_def **varp, emit_note_data *data)\n   set_dv_changed (var->dv, false);\n   gcc_assert (var->in_changed_variables);\n   var->in_changed_variables = false;\n-  changed_variables.clear_slot (varp);\n+  changed_variables->clear_slot (varp);\n \n   /* Continue traversing the hash table.  */\n   return 1;\n@@ -8834,11 +8837,11 @@ remove_value_from_changed_variables (rtx val)\n   variable_def **slot;\n   variable var;\n \n-  slot = changed_variables.find_slot_with_hash (dv, dv_htab_hash (dv),\n+  slot = changed_variables->find_slot_with_hash (dv, dv_htab_hash (dv),\n \t\t\t\t\t\tNO_INSERT);\n   var = *slot;\n   var->in_changed_variables = false;\n-  changed_variables.clear_slot (slot);\n+  changed_variables->clear_slot (slot);\n }\n \n /* If VAL (a value or debug_expr) has backlinks to variables actively\n@@ -8847,21 +8850,21 @@ remove_value_from_changed_variables (rtx val)\n    have dependencies of their own to notify.  */\n \n static void\n-notify_dependents_of_changed_value (rtx val, variable_table_type htab,\n+notify_dependents_of_changed_value (rtx val, variable_table_type *htab,\n \t\t\t\t    vec<rtx, va_heap> *changed_values_stack)\n {\n   variable_def **slot;\n   variable var;\n   loc_exp_dep *led;\n   decl_or_value dv = dv_from_rtx (val);\n \n-  slot = changed_variables.find_slot_with_hash (dv, dv_htab_hash (dv),\n+  slot = changed_variables->find_slot_with_hash (dv, dv_htab_hash (dv),\n \t\t\t\t\t\tNO_INSERT);\n   if (!slot)\n-    slot = htab.find_slot_with_hash (dv, dv_htab_hash (dv), NO_INSERT);\n+    slot = htab->find_slot_with_hash (dv, dv_htab_hash (dv), NO_INSERT);\n   if (!slot)\n-    slot = dropped_values.find_slot_with_hash (dv, dv_htab_hash (dv),\n-\t\t\t\t\t       NO_INSERT);\n+    slot = dropped_values->find_slot_with_hash (dv, dv_htab_hash (dv),\n+\t\t\t\t\t\tNO_INSERT);\n   var = *slot;\n \n   while ((led = VAR_LOC_DEP_LST (var)))\n@@ -8892,14 +8895,14 @@ notify_dependents_of_changed_value (rtx val, variable_table_type htab,\n \t  break;\n \n \tcase ONEPART_VDECL:\n-\t  ivar = htab.find_with_hash (ldv, dv_htab_hash (ldv));\n+\t  ivar = htab->find_with_hash (ldv, dv_htab_hash (ldv));\n \t  gcc_checking_assert (!VAR_LOC_DEP_LST (ivar));\n \t  variable_was_changed (ivar, NULL);\n \t  break;\n \n \tcase NOT_ONEPART:\n \t  pool_free (loc_exp_dep_pool, led);\n-\t  ivar = htab.find_with_hash (ldv, dv_htab_hash (ldv));\n+\t  ivar = htab->find_with_hash (ldv, dv_htab_hash (ldv));\n \t  if (ivar)\n \t    {\n \t      int i = ivar->n_var_parts;\n@@ -8929,15 +8932,15 @@ notify_dependents_of_changed_value (rtx val, variable_table_type htab,\n    CHANGED_VARIABLES.  */\n \n static void\n-process_changed_values (variable_table_type htab)\n+process_changed_values (variable_table_type *htab)\n {\n   int i, n;\n   rtx val;\n   auto_vec<rtx, 20> changed_values_stack;\n \n   /* Move values from changed_variables to changed_values_stack.  */\n   changed_variables\n-    .traverse <vec<rtx, va_heap>*, var_track_values_to_stack>\n+    ->traverse <vec<rtx, va_heap>*, var_track_values_to_stack>\n       (&changed_values_stack);\n \n   /* Back-propagate change notifications in values while popping\n@@ -8969,9 +8972,9 @@ emit_notes_for_changes (rtx insn, enum emit_note_where where,\n \t\t\tshared_hash vars)\n {\n   emit_note_data data;\n-  variable_table_type htab = shared_hash_htab (vars);\n+  variable_table_type *htab = shared_hash_htab (vars);\n \n-  if (!changed_variables.elements ())\n+  if (!changed_variables->elements ())\n     return;\n \n   if (MAY_HAVE_DEBUG_INSNS)\n@@ -8982,19 +8985,19 @@ emit_notes_for_changes (rtx insn, enum emit_note_where where,\n   data.vars = htab;\n \n   changed_variables\n-    .traverse <emit_note_data*, emit_note_insn_var_location> (&data);\n+    ->traverse <emit_note_data*, emit_note_insn_var_location> (&data);\n }\n \n /* Add variable *SLOT to the chain CHANGED_VARIABLES if it differs from the\n    same variable in hash table DATA or is not there at all.  */\n \n int\n-emit_notes_for_differences_1 (variable_def **slot, variable_table_type new_vars)\n+emit_notes_for_differences_1 (variable_def **slot, variable_table_type *new_vars)\n {\n   variable old_var, new_var;\n \n   old_var = *slot;\n-  new_var = new_vars.find_with_hash (old_var->dv, dv_htab_hash (old_var->dv));\n+  new_var = new_vars->find_with_hash (old_var->dv, dv_htab_hash (old_var->dv));\n \n   if (!new_var)\n     {\n@@ -9061,12 +9064,12 @@ emit_notes_for_differences_1 (variable_def **slot, variable_table_type new_vars)\n    table DATA.  */\n \n int\n-emit_notes_for_differences_2 (variable_def **slot, variable_table_type old_vars)\n+emit_notes_for_differences_2 (variable_def **slot, variable_table_type *old_vars)\n {\n   variable old_var, new_var;\n \n   new_var = *slot;\n-  old_var = old_vars.find_with_hash (new_var->dv, dv_htab_hash (new_var->dv));\n+  old_var = old_vars->find_with_hash (new_var->dv, dv_htab_hash (new_var->dv));\n   if (!old_var)\n     {\n       int i;\n@@ -9087,10 +9090,10 @@ emit_notes_for_differences (rtx insn, dataflow_set *old_set,\n \t\t\t    dataflow_set *new_set)\n {\n   shared_hash_htab (old_set->vars)\n-    .traverse <variable_table_type, emit_notes_for_differences_1>\n+    ->traverse <variable_table_type *, emit_notes_for_differences_1>\n       (shared_hash_htab (new_set->vars));\n   shared_hash_htab (new_set->vars)\n-    .traverse <variable_table_type, emit_notes_for_differences_2>\n+    ->traverse <variable_table_type *, emit_notes_for_differences_2>\n       (shared_hash_htab (old_set->vars));\n   emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN, new_set->vars);\n }\n@@ -9446,7 +9449,7 @@ vt_emit_notes (void)\n   basic_block bb;\n   dataflow_set cur;\n \n-  gcc_assert (!changed_variables.elements ());\n+  gcc_assert (!changed_variables->elements ());\n \n   /* Free memory occupied by the out hash tables, as they aren't used\n      anymore.  */\n@@ -9459,7 +9462,7 @@ vt_emit_notes (void)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n-      dropped_values.create (cselib_get_next_uid () * 2);\n+      dropped_values = new variable_table_type (cselib_get_next_uid () * 2);\n       loc_exp_dep_pool = create_alloc_pool (\"loc_exp_dep pool\",\n \t\t\t\t\t    sizeof (loc_exp_dep), 64);\n     }\n@@ -9488,13 +9491,14 @@ vt_emit_notes (void)\n     }\n #ifdef ENABLE_CHECKING\n   shared_hash_htab (cur.vars)\n-    .traverse <variable_table_type, emit_notes_for_differences_1>\n+    ->traverse <variable_table_type *, emit_notes_for_differences_1>\n       (shared_hash_htab (empty_shared_hash));\n #endif\n   dataflow_set_destroy (&cur);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    dropped_values.dispose ();\n+    delete dropped_values;\n+  dropped_values = NULL;\n \n   emit_notes = false;\n }\n@@ -9891,8 +9895,8 @@ vt_initialize (void)\n \t\t\t\t\tsizeof (struct shared_hash_def), 256);\n   empty_shared_hash = (shared_hash) pool_alloc (shared_hash_pool);\n   empty_shared_hash->refcount = 1;\n-  empty_shared_hash->htab.create (1);\n-  changed_variables.create (10);\n+  empty_shared_hash->htab = new variable_table_type (1);\n+  changed_variables = new variable_table_type (10);\n \n   /* Init the IN and OUT sets.  */\n   FOR_ALL_BB_FN (bb, cfun)\n@@ -10246,8 +10250,10 @@ vt_finalize (void)\n \t}\n     }\n   free_aux_for_blocks ();\n-  empty_shared_hash->htab.dispose ();\n-  changed_variables.dispose ();\n+  delete empty_shared_hash->htab;\n+  empty_shared_hash->htab = NULL;\n+  delete changed_variables;\n+  changed_variables = NULL;\n   free_alloc_pool (attrs_pool);\n   free_alloc_pool (var_pool);\n   free_alloc_pool (loc_chain_pool);"}, {"sha": "96586c4820ad2d6986d021b8f80ae3a7786f34a5", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -182,11 +182,10 @@ vtbl_map_node_registration_find (struct vtbl_map_node *node,\n   struct vtable_registration key;\n   struct vtable_registration **slot;\n \n-  gcc_assert (node && node->registered.is_created ());\n+  gcc_assert (node && node->registered);\n \n   key.vtable_decl = vtable_decl;\n-  slot = (struct vtable_registration **) node->registered.find_slot (&key,\n-                                                                     NO_INSERT);\n+  slot = node->registered->find_slot (&key, NO_INSERT);\n \n   if (slot && (*slot))\n     {\n@@ -212,12 +211,11 @@ vtbl_map_node_registration_insert (struct vtbl_map_node *node,\n   struct vtable_registration **slot;\n   bool inserted_something = false;\n \n-  if (!node || !node->registered.is_created ())\n+  if (!node || !node->registered)\n     return false;\n \n   key.vtable_decl = vtable_decl;\n-  slot = (struct vtable_registration **) node->registered.find_slot (&key,\n-                                                                     INSERT);\n+  slot = node->registered->find_slot (&key, INSERT);\n \n   if (! *slot)\n     {\n@@ -307,11 +305,11 @@ vtbl_map_hasher::equal (const value_type *p1, const compare_type *p2)\n    to find the nodes for various tasks (see comments in vtable-verify.h\n    for more details.  */\n \n-typedef hash_table <vtbl_map_hasher> vtbl_map_table_type;\n+typedef hash_table<vtbl_map_hasher> vtbl_map_table_type;\n typedef vtbl_map_table_type::iterator vtbl_map_iterator_type;\n \n /* Vtable map variable nodes stored in a hash table.  */\n-static vtbl_map_table_type vtbl_map_hash;\n+static vtbl_map_table_type *vtbl_map_hash;\n \n /* Vtable map variable nodes stored in a vector.  */\n vec<struct vtbl_map_node *> vtbl_map_nodes_vec;\n@@ -328,7 +326,7 @@ vtbl_map_get_node (tree class_type)\n   tree class_name;\n   unsigned int type_quals;\n \n-  if (!vtbl_map_hash.is_created ())\n+  if (!vtbl_map_hash)\n     return NULL;\n \n   gcc_assert (TREE_CODE (class_type) == RECORD_TYPE);\n@@ -346,8 +344,7 @@ vtbl_map_get_node (tree class_type)\n   class_name = DECL_ASSEMBLER_NAME (class_type_decl);\n \n   key.class_name = class_name;\n-  slot = (struct vtbl_map_node **) vtbl_map_hash.find_slot (&key,\n-                                                            NO_INSERT);\n+  slot = (struct vtbl_map_node **) vtbl_map_hash->find_slot (&key, NO_INSERT);\n   if (!slot)\n     return NULL;\n   return *slot;\n@@ -365,8 +362,8 @@ find_or_create_vtbl_map_node (tree base_class_type)\n   tree class_type_decl;\n   unsigned int type_quals;\n \n-  if (!vtbl_map_hash.is_created ())\n-    vtbl_map_hash.create (10);\n+  if (!vtbl_map_hash)\n+    vtbl_map_hash = new vtbl_map_table_type (10);\n \n   /* Find the TYPE_DECL for the class.  */\n   class_type_decl = TYPE_NAME (base_class_type);\n@@ -377,8 +374,7 @@ find_or_create_vtbl_map_node (tree base_class_type)\n \n   gcc_assert (HAS_DECL_ASSEMBLER_NAME_P (class_type_decl));\n   key.class_name = DECL_ASSEMBLER_NAME (class_type_decl);\n-  slot = (struct vtbl_map_node **) vtbl_map_hash.find_slot (&key,\n-                                                            INSERT);\n+  slot = (struct vtbl_map_node **) vtbl_map_hash->find_slot (&key, INSERT);\n \n   if (*slot)\n     return *slot;\n@@ -396,7 +392,7 @@ find_or_create_vtbl_map_node (tree base_class_type)\n   (node->class_info->parents).create (4);\n   (node->class_info->children).create (4);\n \n-  node->registered.create (16);\n+  node->registered = new register_table_type (16);\n \n   node->is_used = false;\n "}, {"sha": "8ba043598419578ce2df11645ce50e50c194975d", "filename": "gcc/vtable-verify.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvtable-verify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c203e8a73b2f12a1da52a16a0c4a50e62b42445b/gcc%2Fvtable-verify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.h?ref=c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "patch": "@@ -64,7 +64,7 @@ struct registration_hasher : typed_noop_remove <struct vtable_registration>\n   static inline bool equal (const value_type *, const compare_type *);\n };\n \n-typedef hash_table <registration_hasher> register_table_type;\n+typedef hash_table<registration_hasher> register_table_type;\n typedef register_table_type::iterator registration_iterator_type;\n \n /*  This struct is used to represent the class hierarchy information\n@@ -116,7 +116,7 @@ struct vtbl_map_node {\n                                          variable.                          */\n   struct vtbl_map_node *next, *prev;  /* Pointers for the linked list\n                                          structure.                         */\n-  register_table_type registered;     /* Hashtable of vtable pointers for which\n+  register_table_type *registered;     /* Hashtable of vtable pointers for which\n                                          we have generated a _VLTRegisterPair\n                                          call with this vtable map variable. */\n   bool is_used;          /* Boolean indicating if we used this vtable map"}]}