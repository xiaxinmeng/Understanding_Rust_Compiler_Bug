{"sha": "f5bacd9c5be5e129688d9c91eeed05e7b968117e", "node_id": "C_kwDOANBUbNoAKGY1YmFjZDljNWJlNWUxMjk2ODhkOWM5MWVlZWQwNWU3Yjk2ODExN2U", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-25T22:04:06Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-25T23:39:50Z"}, "message": "Move vrp_simplify_cond_using_ranges into the simplifier.\n\nThis static VRP routine does a simplification with casted conditions.  Add it\nto the general simplfier, and continue to invoke if from the VRP folder.\n\n\t* tree-vrp.c (vrp_simplify_cond_using_ranges): Add return type and\n\tmove to vr-values.c.\n\t(simplify_casted_conds): Move to vrp_folder class.\n\t(execute_vrp): Call via vrp_folder now.\n\t* vr-values.c (simplify_cond_using_ranges_1): Call simplify_casted_cond.\n\t(simplify_using_ranges::simplify_casted_cond): Relocate from tree-vrp.c.\n\t* vr-values.h (simplify_casted_cond): Add prototype.", "tree": {"sha": "b4ff3281056503053939cfbc7ad8ef91ba7315ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ff3281056503053939cfbc7ad8ef91ba7315ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5bacd9c5be5e129688d9c91eeed05e7b968117e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5bacd9c5be5e129688d9c91eeed05e7b968117e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5bacd9c5be5e129688d9c91eeed05e7b968117e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5bacd9c5be5e129688d9c91eeed05e7b968117e/comments", "author": null, "committer": null, "parents": [{"sha": "cb153222404e2e149aa65a4b3139b09477551203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb153222404e2e149aa65a4b3139b09477551203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb153222404e2e149aa65a4b3139b09477551203"}], "stats": {"total": 161, "additions": 85, "deletions": 76}, "files": [{"sha": "38ea50303e0d1baab0a47f86b259b1137e298e48", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 15, "deletions": 76, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5bacd9c5be5e129688d9c91eeed05e7b968117e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5bacd9c5be5e129688d9c91eeed05e7b968117e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f5bacd9c5be5e129688d9c91eeed05e7b968117e", "patch": "@@ -4031,6 +4031,7 @@ class vrp_folder : public substitute_and_fold_engine\n     : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n       m_vr_values (v), simplifier (v)\n     {  }\n+  void simplify_casted_conds (function *fun);\n \n private:\n   tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n@@ -4117,78 +4118,6 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n   return simplifier.simplify (si);\n }\n \n-/* STMT is a conditional at the end of a basic block.\n-\n-   If the conditional is of the form SSA_NAME op constant and the SSA_NAME\n-   was set via a type conversion, try to replace the SSA_NAME with the RHS\n-   of the type conversion.  Doing so makes the conversion dead which helps\n-   subsequent passes.  */\n-\n-static void\n-vrp_simplify_cond_using_ranges (range_query *query, gcond *stmt)\n-{\n-  tree op0 = gimple_cond_lhs (stmt);\n-  tree op1 = gimple_cond_rhs (stmt);\n-\n-  /* If we have a comparison of an SSA_NAME (OP0) against a constant,\n-     see if OP0 was set by a type conversion where the source of\n-     the conversion is another SSA_NAME with a range that fits\n-     into the range of OP0's type.\n-\n-     If so, the conversion is redundant as the earlier SSA_NAME can be\n-     used for the comparison directly if we just massage the constant in the\n-     comparison.  */\n-  if (TREE_CODE (op0) == SSA_NAME\n-      && TREE_CODE (op1) == INTEGER_CST)\n-    {\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (op0);\n-      tree innerop;\n-\n-      if (!is_gimple_assign (def_stmt))\n-\treturn;\n-\n-      switch (gimple_assign_rhs_code (def_stmt))\n-\t{\n-\tCASE_CONVERT:\n-\t  innerop = gimple_assign_rhs1 (def_stmt);\n-\t  break;\n-\tcase VIEW_CONVERT_EXPR:\n-\t  innerop = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0);\n-\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (innerop)))\n-\t    return;\n-\t  break;\n-\tdefault:\n-\t  return;\n-\t}\n-\n-      if (TREE_CODE (innerop) == SSA_NAME\n-\t  && !POINTER_TYPE_P (TREE_TYPE (innerop))\n-\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n-\t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n-\t{\n-\t  const value_range *vr = query->get_value_range (innerop);\n-\n-\t  if (range_int_cst_p (vr)\n-\t      && range_fits_type_p (vr,\n-\t\t\t\t    TYPE_PRECISION (TREE_TYPE (op0)),\n-\t\t\t\t    TYPE_SIGN (TREE_TYPE (op0)))\n-\t      && int_fits_type_p (op1, TREE_TYPE (innerop)))\n-\t    {\n-\t      tree newconst = fold_convert (TREE_TYPE (innerop), op1);\n-\t      gimple_cond_set_lhs (stmt, innerop);\n-\t      gimple_cond_set_rhs (stmt, newconst);\n-\t      update_stmt (stmt);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"Folded into: \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* A comparison of an SSA_NAME against a constant where the SSA_NAME\n    was set by a type conversion can often be rewritten to use the RHS\n    of the type conversion.  Do this optimization for all conditionals\n@@ -4198,15 +4127,25 @@ vrp_simplify_cond_using_ranges (range_query *query, gcond *stmt)\n    So that transformation is not performed until after jump threading\n    is complete.  */\n \n-static void\n-simplify_casted_conds (function *fun, range_query *query)\n+void\n+vrp_folder::simplify_casted_conds (function *fun)\n {\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple *last = last_stmt (bb);\n       if (last && gimple_code (last) == GIMPLE_COND)\n-\tvrp_simplify_cond_using_ranges (query, as_a <gcond *> (last));\n+\t{\n+\t  if (simplifier.simplify_casted_cond (as_a <gcond *> (last)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Folded into: \");\n+\t\t  print_gimple_stmt (dump_file, last, 0, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n \n@@ -4301,7 +4240,7 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n       array_checker.check ();\n     }\n \n-  simplify_casted_conds (fun, &vrp_vr_values);\n+  folder.simplify_casted_conds (fun);\n \n   free_numbers_of_iterations_estimates (fun);\n "}, {"sha": "00246c9d3af31b9559d135d6da0bffab8e0c33b7", "filename": "gcc/vr-values.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5bacd9c5be5e129688d9c91eeed05e7b968117e/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5bacd9c5be5e129688d9c91eeed05e7b968117e/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=f5bacd9c5be5e129688d9c91eeed05e7b968117e", "patch": "@@ -3630,6 +3630,75 @@ simplify_using_ranges::simplify_cond_using_ranges_1 (gcond *stmt)\n \t    }\n \t}\n     }\n+  // Try to simplify casted conditions.\n+  return simplify_casted_cond (stmt);\n+}\n+\n+/* STMT is a conditional at the end of a basic block.\n+\n+   If the conditional is of the form SSA_NAME op constant and the SSA_NAME\n+   was set via a type conversion, try to replace the SSA_NAME with the RHS\n+   of the type conversion.  Doing so makes the conversion dead which helps\n+   subsequent passes.  */\n+\n+bool\n+simplify_using_ranges::simplify_casted_cond (gcond *stmt)\n+{\n+  tree op0 = gimple_cond_lhs (stmt);\n+  tree op1 = gimple_cond_rhs (stmt);\n+\n+  /* If we have a comparison of an SSA_NAME (OP0) against a constant,\n+     see if OP0 was set by a type conversion where the source of\n+     the conversion is another SSA_NAME with a range that fits\n+     into the range of OP0's type.\n+\n+     If so, the conversion is redundant as the earlier SSA_NAME can be\n+     used for the comparison directly if we just massage the constant in the\n+     comparison.  */\n+  if (TREE_CODE (op0) == SSA_NAME\n+      && TREE_CODE (op1) == INTEGER_CST)\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (op0);\n+      tree innerop;\n+\n+      if (!is_gimple_assign (def_stmt))\n+\treturn false;\n+\n+      switch (gimple_assign_rhs_code (def_stmt))\n+\t{\n+\tCASE_CONVERT:\n+\t  innerop = gimple_assign_rhs1 (def_stmt);\n+\t  break;\n+\tcase VIEW_CONVERT_EXPR:\n+\t  innerop = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0);\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (innerop)))\n+\t    return false;\n+\t  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+\n+      if (TREE_CODE (innerop) == SSA_NAME\n+\t  && !POINTER_TYPE_P (TREE_TYPE (innerop))\n+\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n+\t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n+\t{\n+\t  const value_range *vr = query->get_value_range (innerop);\n+\n+\t  if (range_int_cst_p (vr)\n+\t      && range_fits_type_p (vr,\n+\t\t\t\t    TYPE_PRECISION (TREE_TYPE (op0)),\n+\t\t\t\t    TYPE_SIGN (TREE_TYPE (op0)))\n+\t      && int_fits_type_p (op1, TREE_TYPE (innerop)))\n+\t    {\n+\t      tree newconst = fold_convert (TREE_TYPE (innerop), op1);\n+\t      gimple_cond_set_lhs (stmt, innerop);\n+\t      gimple_cond_set_rhs (stmt, newconst);\n+\t      update_stmt (stmt);\n+\t      return true;\n+\t    }\n+\t}\n+    }\n   return false;\n }\n "}, {"sha": "21dc4eaebce759643c0fac8804b6e9cf7ca3d55f", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5bacd9c5be5e129688d9c91eeed05e7b968117e/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5bacd9c5be5e129688d9c91eeed05e7b968117e/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=f5bacd9c5be5e129688d9c91eeed05e7b968117e", "patch": "@@ -44,6 +44,7 @@ class simplify_using_ranges\n   tree vrp_evaluate_conditional_warnv_with_ops (gimple *stmt, enum tree_code,\n \t\t\t\t\t\ttree, tree, bool,\n \t\t\t\t\t\tbool *, bool *);\n+  bool simplify_casted_cond (gcond *);\n \n private:\n   bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);"}]}