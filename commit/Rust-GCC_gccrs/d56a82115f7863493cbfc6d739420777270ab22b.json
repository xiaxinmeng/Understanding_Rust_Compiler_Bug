{"sha": "d56a82115f7863493cbfc6d739420777270ab22b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2YTgyMTE1Zjc4NjM0OTNjYmZjNmQ3Mzk0MjA3NzcyNzBhYjIyYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-11-05T15:38:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-11-05T15:38:01Z"}, "message": "Makefile.in (bb-reoder.o): Add depdendency on cfglayout.h; remove unneded depdendencies;\n\n\t* Makefile.in (bb-reoder.o): Add depdendency on cfglayout.h;\n\tremove unneded depdendencies;\n\t(cfglayout.o): New.\n\t* cfglayout.c, cfglayout.h: New files; break out from ...\n\t* bb-reorder.c: ... here; Remove unneeded includes;\n\nFrom-SVN: r46786", "tree": {"sha": "eeb94824f44e30df6454e8ba4f18f0eff58451bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeb94824f44e30df6454e8ba4f18f0eff58451bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d56a82115f7863493cbfc6d739420777270ab22b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56a82115f7863493cbfc6d739420777270ab22b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56a82115f7863493cbfc6d739420777270ab22b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56a82115f7863493cbfc6d739420777270ab22b/comments", "author": null, "committer": null, "parents": [{"sha": "3b0c635f60049f111e7ee358aea56c734a19d2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0c635f60049f111e7ee358aea56c734a19d2cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0c635f60049f111e7ee358aea56c734a19d2cc"}], "stats": {"total": 2204, "additions": 1132, "deletions": 1072}, "files": [{"sha": "411749162a3b0eaf7b0c8175ab7c8b3314bca31c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d56a82115f7863493cbfc6d739420777270ab22b", "patch": "@@ -1,3 +1,11 @@\n+Mon Nov  5 16:15:25 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (bb-reoder.o): Add depdendency on cfglayout.h;\n+\tremove unneded depdendencies;\n+\t(cfglayout.o): New.\n+\t* cfglayout.c, cfglayout.h: New files; break out from ...\n+\t* bb-reorder.c: ... here; Remove unneeded includes; \n+\n 2001-11-04  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.md (load_toc_aix_{si,di}): Mark r2 as used."}, {"sha": "8cb7fe4d98c5ae26408f593a5c43e9473c786b58", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d56a82115f7863493cbfc6d739420777270ab22b", "patch": "@@ -742,7 +742,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t\\\n  sibcall.o simplify-rtx.o splay-tree.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\\\n  stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-inline.o \t\\\n- unroll.o varasm.o varray.o version.o xcoffout.o\t\t\t\\\n+ unroll.o varasm.o varray.o version.o xcoffout.o cfglayout.o\t\t\\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = main.o libbackend.a\n@@ -1578,8 +1578,10 @@ predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H)\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n-   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H)\n+   $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h\n+cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n+   insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h function.h \\\n+   cfglayout.h\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) $(TIMEVAR_H) flags.h intl.h\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h $(RECOG_H) function.h \\"}, {"sha": "72cf90c7134cc914ef2bfb152e13dfb1c37a4031", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 3, "deletions": 1069, "changes": 1072, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=d56a82115f7863493cbfc6d739420777270ab22b", "patch": "@@ -84,234 +84,20 @@\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n-#include \"tm_p.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n-#include \"insn-config.h\"\n-#include \"regs.h\"\n #include \"flags.h\"\n #include \"output.h\"\n-#include \"function.h\"\n-#include \"toplev.h\"\n-#include \"recog.h\"\n-#include \"expr.h\"\n-#include \"obstack.h\"\n-\n+#include \"cfglayout.h\"\n \n #ifndef HAVE_epilogue\n #define HAVE_epilogue 0\n #endif\n \n-\n-/* The contents of the current function definition are allocated\n-   in this obstack, and all are freed at the end of the function.\n-   For top-level functions, this is temporary_obstack.\n-   Separate obstacks are made for nested functions.  */\n-\n-extern struct obstack flow_obstack;\n-\n-\n-/* Structure to hold information about lexical scopes.  */\n-typedef struct scope_def\n-{\n-  int level;\n-\n-  /* The NOTE_INSN_BLOCK_BEG that started this scope.  */\n-  rtx note_beg;\n-\n-  /* The NOTE_INSN_BLOCK_END that ended this scope.  */\n-  rtx note_end;\n-\n-  /* The bb containing note_beg (if any).  */\n-  basic_block bb_beg;\n-\n-  /* The bb containing note_end (if any).  */\n-  basic_block bb_end;\n-\n-  /* List of basic blocks contained within this scope.  */\n-  basic_block *bbs;\n-\n-  /* Number of blocks contained within this scope.  */\n-  int num_bbs;\n-\n-  /* The outer scope or NULL if outermost scope.  */\n-  struct scope_def *outer;\n-\n-  /* The first inner scope or NULL if innermost scope.  */\n-  struct scope_def *inner;\n-\n-  /* The last inner scope or NULL if innermost scope.  */\n-  struct scope_def *inner_last;\n-\n-  /* Link to the next (sibling) scope.  */\n-  struct scope_def *next;\n-} *scope;\n-\n-\n-/* Structure to hold information about the scope forest.  */\n-typedef struct\n-{\n-  /* Number of trees in forest.  */\n-  int num_trees;\n-\n-  /* List of tree roots.  */\n-  scope *trees;\n-} scope_forest_info;\n-\n-/* Structure to hold information about the blocks during reordering.  */\n-typedef struct reorder_block_def\n-{\n-  rtx eff_head;\n-  rtx eff_end;\n-  scope scope;\n-  basic_block next;\n-  int visited;\n-} *reorder_block_def;\n-\n-#define RBI(BB)\t((reorder_block_def) (BB)->aux)\n-\n-/* Holds the interesting trailing notes for the function.  */\n-static rtx function_tail_eff_head;\n-\n-\n /* Local function prototypes.  */\n-static rtx skip_insns_after_block\tPARAMS ((basic_block));\n-static void record_effective_endpoints\tPARAMS ((void));\n static void make_reorder_chain\t\tPARAMS ((void));\n static basic_block make_reorder_chain_1\tPARAMS ((basic_block, basic_block));\n-static rtx label_for_bb\t\t\tPARAMS ((basic_block));\n-static void fixup_reorder_chain\t\tPARAMS ((void));\n-static void relate_bbs_with_scopes\tPARAMS ((scope));\n-static scope make_new_scope\t\tPARAMS ((int, rtx));\n-static void build_scope_forest\t\tPARAMS ((scope_forest_info *));\n-static void remove_scope_notes\t\tPARAMS ((void));\n-static void insert_intra_1\t\tPARAMS ((scope, rtx *, basic_block));\n-static void insert_intra_bb_scope_notes PARAMS ((basic_block));\n-static void insert_inter_bb_scope_notes PARAMS ((basic_block, basic_block));\n-static void rebuild_scope_notes\t\tPARAMS ((scope_forest_info *));\n-static void free_scope_forest_1\t\tPARAMS ((scope));\n-static void free_scope_forest\t\tPARAMS ((scope_forest_info *));\n-void dump_scope_forest\t\t\tPARAMS ((scope_forest_info *));\n-static void dump_scope_forest_1\t\tPARAMS ((scope, int));\n-static rtx get_next_bb_note\t\tPARAMS ((rtx));\n-static rtx get_prev_bb_note\t\tPARAMS ((rtx));\n-\n-void verify_insn_chain\t\t\tPARAMS ((void));\n \f\n-/* Skip over inter-block insns occurring after BB which are typically\n-   associated with BB (e.g., barriers). If there are any such insns,\n-   we return the last one. Otherwise, we return the end of BB.  */\n-\n-static rtx\n-skip_insns_after_block (bb)\n-     basic_block bb;\n-{\n-  rtx insn, last_insn, next_head, prev;\n-\n-  next_head = NULL_RTX;\n-  if (bb->index + 1 != n_basic_blocks)\n-    next_head = BASIC_BLOCK (bb->index + 1)->head;\n-\n-  for (last_insn = insn = bb->end; (insn = NEXT_INSN (insn)); )\n-    {\n-      if (insn == next_head)\n-\tbreak;\n-\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase BARRIER:\n-\t  last_insn = insn;\n-\t  continue;\n-\n-\tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (insn))\n-\t    {\n-\t    case NOTE_INSN_LOOP_END:\n-\t    case NOTE_INSN_BLOCK_END:\n-\t      last_insn = insn;\n-\t      continue;\n-\t    case NOTE_INSN_DELETED:\n-\t    case NOTE_INSN_DELETED_LABEL:\n-\t      continue;\n-\n-\t    default:\n-\t      continue;\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase CODE_LABEL:\n-\t  if (NEXT_INSN (insn)\n-\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t          || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n-\t    {\n-\t      insn = NEXT_INSN (insn);\n-\t      last_insn = insn;\n-\t      continue;\n-\t    }\n-          break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      break;\n-    }\n-  /* It is possible to hit contradicting sequence.  For instance:\n-    \n-     jump_insn\n-     NOTE_INSN_LOOP_BEG\n-     barrier\n-\n-     Where barrier belongs to jump_insn, but the note does not.\n-     This can be created by removing the basic block originally\n-     following NOTE_INSN_LOOP_BEG.\n-\n-     In such case reorder the notes.  */\n-  for (insn = last_insn; insn != bb->end; insn = prev)\n-    {\n-    prev = PREV_INSN (insn);\n-    if (GET_CODE (insn) == NOTE)\n-      switch (NOTE_LINE_NUMBER (insn))\n-        {\n-          case NOTE_INSN_LOOP_END:\n-          case NOTE_INSN_BLOCK_END:\n-          case NOTE_INSN_DELETED:\n-          case NOTE_INSN_DELETED_LABEL:\n-    \tcontinue;\n-          default:\n-    \treorder_insns (insn, insn, last_insn);\n-        }\n-    }\n-\n-  return last_insn;\n-}\n-\n-\n-/* Locate the effective beginning and end of the insn chain for each\n-   block, as defined by skip_insns_after_block above.  */\n-\n-static void\n-record_effective_endpoints ()\n-{\n-  rtx next_insn = get_insns ();\n-  int i;\n-  \n-  for (i = 0; i < n_basic_blocks; ++i)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      rtx end;\n-\n-      RBI (bb)->eff_head = next_insn;\n-      end = skip_insns_after_block (bb);\n-      RBI (bb)->eff_end = end;\n-      next_insn = NEXT_INSN (end);\n-    }\n-  function_tail_eff_head = next_insn;\n-}\n-\n-\n /* Compute an ordering for a subgraph beginning with block BB.  Record the\n    ordering in RBI()->index and chained through RBI()->next.  */\n \n@@ -489,872 +275,20 @@ make_reorder_chain_1 (bb, prev)\n   return prev;\n }\n \n-\n-/* Locate or create a label for a given basic block.  */\n-\n-static rtx\n-label_for_bb (bb)\n-     basic_block bb;\n-{\n-  rtx label = bb->head;\n-\n-  if (GET_CODE (label) != CODE_LABEL)\n-    {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\",\n-\t\t bb->index);\n-\n-      label = block_label (bb);\n-      if (bb->head == PREV_INSN (RBI (bb)->eff_head))\n-\tRBI (bb)->eff_head = label;\n-    }\n-\n-  return label;\n-}\n-\n-\n-/* Given a reorder chain, rearrange the code to match.  */\n-\n-static void\n-fixup_reorder_chain ()\n-{\n-  basic_block bb, last_bb;\n-  int index;\n-  rtx insn;\n-  int old_n_basic_blocks = n_basic_blocks;\n-\n-  /* First do the bulk reordering -- rechain the blocks without regard to\n-     the needed changes to jumps and labels.  */\n-\n-  last_bb = BASIC_BLOCK (0);\n-  bb = RBI (last_bb)->next;\n-  index = 1;\n-  while (bb)\n-    {\n-      rtx last_e = RBI (last_bb)->eff_end;\n-      rtx curr_h = RBI (bb)->eff_head;\n-\n-      NEXT_INSN (last_e) = curr_h;\n-      PREV_INSN (curr_h) = last_e;\n-\n-      last_bb = bb;\n-      bb = RBI (bb)->next;\n-      index++;\n-    }\n-\n-  if (index != n_basic_blocks)\n-    abort ();\n-\n-  insn = RBI (last_bb)->eff_end;\n-\n-  NEXT_INSN (insn) = function_tail_eff_head;\n-  if (function_tail_eff_head)\n-    PREV_INSN (function_tail_eff_head) = insn;\n-\n-  while (NEXT_INSN (insn))\n-    insn = NEXT_INSN (insn);\n-  set_last_insn (insn);\n-#ifdef ENABLE_CHECKING\n-  verify_insn_chain ();\n-#endif\n-\n-  /* Now add jumps and labels as needed to match the blocks new\n-     outgoing edges.  */\n-\n-  for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n-    {\n-      edge e_fall, e_taken, e;\n-      rtx bb_end_insn;\n-      basic_block nb;\n-\n-      if (bb->succ == NULL)\n-\tcontinue;\n-\n-      /* Find the old fallthru edge, and another non-EH edge for\n-\t a taken jump.  */\n-      e_taken = e_fall = NULL;\n-      for (e = bb->succ; e ; e = e->succ_next)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  e_fall = e;\n-\telse if (! (e->flags & EDGE_EH))\n-\t  e_taken = e;\n-\n-      bb_end_insn = bb->end;\n-      if (GET_CODE (bb_end_insn) == JUMP_INSN)\n-\t{\n-\t  if (any_condjump_p (bb_end_insn))\n-\t    {\n-\t      /* If the old fallthru is still next, nothing to do.  */\n-\t      if (RBI (bb)->next == e_fall->dest\n-\t          || (!RBI (bb)->next\n-\t\t      && e_fall->dest == EXIT_BLOCK_PTR))\n-\t\tcontinue;\n-\n-\t      /* There is one special case: if *neither* block is next,\n-\t\t such as happens at the very end of a function, then we'll\n-\t\t need to add a new unconditional jump.  Choose the taken\n-\t\t edge based on known or assumed probability.  */\n-\t      if (RBI (bb)->next != e_taken->dest)\n-\t\t{\n-\t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n-\t\t  if (note\n-\t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n-\t\t      && invert_jump (bb_end_insn,\n-\t\t\t\t      label_for_bb (e_fall->dest), 0))\n-\t\t    {\n-\t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n-\t\t      e_taken->flags |= EDGE_FALLTHRU;\n-\t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n-\t\t    }\n-\t\t}\n-\n-\t      /* Otherwise we can try to invert the jump.  This will \n-\t\t basically never fail, however, keep up the pretense.  */\n-\t      else if (invert_jump (bb_end_insn,\n-\t\t\t\t    label_for_bb (e_fall->dest), 0))\n-\t\t{\n-\t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n-\t\t  e_taken->flags |= EDGE_FALLTHRU;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  else if (returnjump_p (bb_end_insn))\n-\t    continue;\n-\t  else\n-\t    {\n-\t      /* Otherwise we have some switch or computed jump.  In the\n-\t\t 99% case, there should not have been a fallthru edge.  */\n-\t      if (! e_fall)\n-\t\tcontinue;\n-#ifdef CASE_DROPS_THROUGH\n-\t      /* Except for VAX.  Since we didn't have predication for the\n-\t\t tablejump, the fallthru block should not have moved.  */\n-\t      if (RBI (bb)->next == e_fall->dest)\n-\t\tcontinue;\n-\t      bb_end_insn = skip_insns_after_block (bb);\n-#else\n-\t      abort ();\n-#endif\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* No fallthru implies a noreturn function with EH edges, or\n-\t     something similarly bizarre.  In any case, we don't need to\n-\t     do anything.  */\n-\t  if (! e_fall)\n-\t    continue;\n-\n-\t  /* If the fallthru block is still next, nothing to do.  */\n-\t  if (RBI (bb)->next == e_fall->dest)\n-\t    continue;\n-\n-\t  /* An fallthru to exit block.  */\n-\t  if (!RBI (bb)->next && e_fall->dest == EXIT_BLOCK_PTR)\n-\t    continue;\n-\t}\n-\n-      /* We got here if we need to add a new jump insn.  */\n-\n-      nb = force_nonfallthru (e_fall);\n-\n-      if (nb)\n-\t{\n-\t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n-\t  RBI (nb)->eff_head = nb->head;\n-\t  RBI (nb)->eff_end = NEXT_INSN (nb->end);\n-\t  RBI (nb)->scope = RBI (bb)->scope;\n-\t  RBI (nb)->visited = 1;\n-\t  RBI (nb)->next = RBI (bb)->next;\n-\t  RBI (bb)->next = nb;\n-\t  /* Don't process this new block.  */\n-\t  bb = nb;\n-\t}\n-    }\n-\n-  /* Put basic_block_info in the new order.  */\n-  bb = BASIC_BLOCK (0);\n-  index = 0;\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n-  while (bb)\n-    {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \" %i %sbb %i freq %i\\n\", index,\n-\t\t bb->index >= old_n_basic_blocks ? \"compensation \" : \"\",\n-\t\t bb->index,\n-\t   \t bb->frequency);\n-      bb->index = index;\n-      BASIC_BLOCK (index) = bb;\n-\n-      bb = RBI (bb)->next;\n-      index++;\n-    }\n-}\n-\n-\n-/* Perform sanity checks on the insn chain.\n-   1. Check that next/prev pointers are consistent in both the forward and\n-      reverse direction.\n-   2. Count insns in chain, going both directions, and check if equal.\n-   3. Check that get_last_insn () returns the actual end of chain.  */\n-\n-void\n-verify_insn_chain ()\n-{\n-  rtx x,\n-      prevx,\n-      nextx;\n-  int insn_cnt1,\n-      insn_cnt2;\n-\n-  prevx = NULL;\n-  insn_cnt1 = 1;\n-  for (x = get_insns (); x; x = NEXT_INSN (x))\n-    {\n-      if (PREV_INSN (x) != prevx)\n-\t{\n-\t  fprintf (stderr, \"Forward traversal: insn chain corrupt.\\n\");\n-\t  fprintf (stderr, \"previous insn:\\n\");\n-\t  debug_rtx (prevx);\n-\t  fprintf (stderr, \"current insn:\\n\");\n-\t  debug_rtx (x);\n-\t  abort ();\n-\t}\n-      ++insn_cnt1;\n-      prevx = x;\n-    }\n-\n-  if (prevx != get_last_insn ())\n-    {\n-      fprintf (stderr, \"last_insn corrupt.\\n\");\n-      abort ();\n-    }\n-\n-  nextx = NULL;\n-  insn_cnt2 = 1;\n-  for (x = get_last_insn (); x; x = PREV_INSN (x))\n-    {\n-      if (NEXT_INSN (x) != nextx)\n-\t{\n-\t  fprintf (stderr, \"Reverse traversal: insn chain corrupt.\\n\");\n-\t  fprintf (stderr, \"current insn:\\n\");\n-\t  debug_rtx (x);\n-\t  fprintf (stderr, \"next insn:\\n\");\n-\t  debug_rtx (nextx);\n-\t  abort ();\n-\t}\n-      ++insn_cnt2;\n-      nextx = x;\n-    }\n-\n-  if (insn_cnt1 != insn_cnt2)\n-    {\n-      fprintf (stderr, \"insn_cnt1 (%d) not equal to insn_cnt2 (%d).\\n\",\n-\t       insn_cnt1, insn_cnt2);\n-      abort ();\n-    }\n-}\n-\n-static rtx\n-get_next_bb_note (x)\n-     rtx x;\n-{\n-  while (x)\n-    {\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\treturn x;\n-      x = NEXT_INSN (x);\n-    }\n-  return NULL;\n-}\n-\n-\n-static rtx\n-get_prev_bb_note (x)\n-     rtx x;\n-{\n-  while (x)\n-    {\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\treturn x;\n-      x = PREV_INSN (x);\n-    }\n-  return NULL;\n-}\n-\n-\n-/* Determine and record the relationships between basic blocks and\n-   scopes in scope tree S.  */\n-\n-static void\n-relate_bbs_with_scopes (s)\n-     scope s;\n-{\n-  scope p;\n-  int i, bbi1, bbi2, bbs_spanned;\n-  rtx bbnote;\n-\n-  for (p = s->inner; p; p = p->next)\n-    relate_bbs_with_scopes (p);\n-\n-  bbi1 = bbi2 = -1;\n-  bbs_spanned = 0;\n-\n-  /* If the begin and end notes are both inside the same basic block,\n-     or if they are both outside of basic blocks, then we know immediately\n-     how they are related. Otherwise, we need to poke around to make the\n-     determination.  */\n-  if (s->bb_beg != s->bb_end)\n-    {\n-      if (s->bb_beg && s->bb_end)\n-        {\n-\t  /* Both notes are in different bbs. This implies that all the\n-\t     basic blocks spanned by the pair of notes are contained in\n-             this scope.  */\n-\t  bbi1 = s->bb_beg->index;\n-\t  bbi2 = s->bb_end->index;\n-\t  bbs_spanned = 1;\n-\t}\n-      else if (! s->bb_beg)\n-        {\n-\t  /* First note is outside of a bb. If the scope spans more than\n-\t     one basic block, then they all are contained within this\n-             scope. Otherwise, this scope is contained within the basic\n-\t     block.  */\n-\t  bbnote = get_next_bb_note (s->note_beg);\n-\t  if (! bbnote)\n-\t    abort ();\n-\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_end)\n-\t    {\n-\t      bbs_spanned = 0;\n-\t      s->bb_beg = NOTE_BASIC_BLOCK (bbnote);\n-\t    }\n-\t  else\n-\t    {\n-\t      bbi1 = NOTE_BASIC_BLOCK (bbnote)->index;\n-\t      bbi2 = s->bb_end->index;\n-\t      s->bb_end = NULL;\n-\t      bbs_spanned = 1;\n-\t    }\n-\t}\n-      else /* ! s->bb_end */\n-        {\n-\t  /* Second note is outside of a bb. If the scope spans more than\n-\t     one basic block, then they all are contained within this\n-             scope. Otherwise, this scope is contained within the basic\n-\t     block.  */\n-\t  bbnote = get_prev_bb_note (s->note_end);\n-\t  if (! bbnote)\n-\t    abort ();\n-\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_beg)\n-\t    {\n-\t      bbs_spanned = 0;\n-\t      s->bb_end = NOTE_BASIC_BLOCK (bbnote);\n-\t    }\n-\t  else\n-\t    {\n-\t      bbi1 = s->bb_beg->index;\n-\t      bbi2 = NOTE_BASIC_BLOCK (bbnote)->index;\n-\t      s->bb_beg = NULL;\n-\t      bbs_spanned = 1;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      if (s->bb_beg)\n-        /* Both notes are in the same bb, which implies the block\n-\t   contains this scope.  */\n-\tbbs_spanned = 0;\n-      else\n-\t{\n-          rtx x1, x2;\n-\t  /* Both notes are outside of any bbs. This implies that all the\n-\t     basic blocks spanned by the pair of notes are contained in\n-             this scope. \n-\t     There is a degenerate case to consider. If the notes do not\n-\t     span any basic blocks, then it is an empty scope that can\n-\t     safely be deleted or ignored. Mark these with level = -1.  */\n-\n-\t  x1 = get_next_bb_note (s->note_beg);\n-\t  x2 = get_prev_bb_note (s->note_end);\n-\t  if (! (x1 && x2))\n-\t    {\n-\t      s->level = -1; \n-\t      bbs_spanned = 0; \n-\t    }\n-\t  else\n-\t    {\n-\t      bbi1 = NOTE_BASIC_BLOCK (x1)->index;\n-\t      bbi2 = NOTE_BASIC_BLOCK (x2)->index;\n-\t      bbs_spanned = 1;\n-\t    }\n-\t}\n-    }\n-\n-  /* If the scope spans one or more basic blocks, we record them. We\n-     only record the bbs that are immediately contained within this\n-     scope. Note that if a scope is contained within a bb, we can tell\n-     by checking that bb_beg = bb_end and that they are non-null.  */\n-  if (bbs_spanned)\n-    {\n-      int j = 0;\n-\n-      s->num_bbs = 0;\n-      for (i = bbi1; i <= bbi2; i++)\n-\tif (! RBI (BASIC_BLOCK (i))->scope)\n-\t  s->num_bbs++;\n-\n-      s->bbs = xmalloc (s->num_bbs * sizeof (basic_block));\n-      for (i = bbi1; i <= bbi2; i++)\n-\t{\n-\t  basic_block curr_bb = BASIC_BLOCK (i);\n-\t  if (! RBI (curr_bb)->scope)\n-\t    {\n-\t      s->bbs[j++] = curr_bb;\n-\t      RBI (curr_bb)->scope = s;\n-\t    }\n-\t}\n-    }\n-  else\n-    s->num_bbs = 0;\n-}\n-\n-\n-/* Allocate and initialize a new scope structure with scope level LEVEL,\n-   and record the NOTE beginning the scope.  */\n-\n-static scope \n-make_new_scope (level, note)\n-     int level;\n-     rtx note;\n-{\n-  scope new_scope = xcalloc (1, sizeof (struct scope_def));\n-  new_scope->level = level;\n-  new_scope->note_beg = note;\n-  return new_scope;\n-}\n-\n-\n-/* Build a forest representing the scope structure of the function.\n-   Return a pointer to a structure describing the forest.  */\n-\n-static void\n-build_scope_forest (forest)\n-    scope_forest_info *forest;\n-{\n-  rtx x;\n-  int level, bbi, i;\n-  basic_block curr_bb;\n-  scope root, curr_scope = 0;\n-\n-  forest->num_trees = 0;\n-  forest->trees = NULL;\n-  level = -1;\n-  root = NULL;\n-  curr_bb = NULL;\n-  bbi = 0;\n-  for (x = get_insns (); x; x = NEXT_INSN (x))\n-    {\n-      if (bbi < n_basic_blocks && x == BASIC_BLOCK (bbi)->head)\n-\tcurr_bb = BASIC_BLOCK (bbi);\n-\n-      if (GET_CODE (x) == NOTE)\n-\t{\n-\t  if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG)\n-\t    {\n-\t      if (root)\n-\t\t{\n-\t\t  scope new_scope;\n-\t\t  if (! curr_scope)\n-\t\t    abort();\n-\t\t  level++;\n-\t\t  new_scope = make_new_scope (level, x);\n-\t\t  new_scope->outer = curr_scope;\n-\t\t  new_scope->next = NULL;\n-\t\t  if (! curr_scope->inner)\n-\t\t    {\n-\t\t      curr_scope->inner = new_scope;\n-\t\t      curr_scope->inner_last = new_scope;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      curr_scope->inner_last->next = new_scope;\n-\t\t      curr_scope->inner_last = new_scope;\n-\t\t    }\n-\t\t  curr_scope = curr_scope->inner_last;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int ntrees = forest->num_trees;\n-\t\t  level++;\n-\t          curr_scope = make_new_scope (level, x);\n-\t\t  root = curr_scope;\n-\t\t  forest->trees = xrealloc (forest->trees,\n-\t\t\t\t\t    sizeof (scope) * (ntrees + 1));\n-\t\t  forest->trees[forest->num_trees++] = root;\n-\t\t}\n-\t      curr_scope->bb_beg = curr_bb;\n-\t    }\n-\t  else if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END)\n-\t    {\n-\t      curr_scope->bb_end = curr_bb;\n-\t      curr_scope->note_end = x;\n-\t      level--;\n-\t      curr_scope = curr_scope->outer;\n-\t      if (level == -1)\n-\t\troot = NULL;\n-\t    }\n-\t} /* if note */\n-\n-      if (curr_bb && curr_bb->end == x)\n-\t{\n-\t  curr_bb = NULL;\n-\t  bbi++;\n-\t}\n-\n-    } /* for */\n-\n-  for (i = 0; i < forest->num_trees; i++)\n-    relate_bbs_with_scopes (forest->trees[i]);\n-}\n-\n-\n-/* Remove all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes from\n-   the insn chain.  */\n-\n-static void\n-remove_scope_notes ()\n-{\n-  rtx x, next;\n-  basic_block currbb = NULL;\n-\n-  for (x = get_insns (); x; x = next)\n-    {\n-      next = NEXT_INSN (x);\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\tcurrbb = NOTE_BASIC_BLOCK (x);\n-\n-      if (GET_CODE (x) == NOTE\n-\t  && (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG\n-\t      || NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END))\n-\t{\n-\t  /* Check if the scope note happens to be the end of a bb.  */\n-\t  if (currbb && x == currbb->end)\n-\t    currbb->end = PREV_INSN (x);\n-\t  if (currbb && x == currbb->head)\n-\t    abort ();\n-\n-\t  if (PREV_INSN (x))\n-\t    {\n-\t      NEXT_INSN (PREV_INSN (x)) = next;\n-\t      PREV_INSN (next) = PREV_INSN (x);\n-\n-              NEXT_INSN (x) = NULL;\n-              PREV_INSN (x) = NULL;\n-\t    }\n-\t  else\n-\t    abort ();\n-\t}\n-    }\n-}\n-\n-\n-/* Insert scope note pairs for a contained scope tree S after insn IP.  */\n-\n-static void\n-insert_intra_1 (s, ip, bb)\n-     scope s;\n-     rtx *ip;\n-     basic_block bb;\n-{\n-  scope p;\n-\n-  if (NOTE_BLOCK (s->note_beg))\n-    {  \n-      *ip = emit_note_after (NOTE_INSN_BLOCK_BEG, *ip);\n-      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_beg);\n-    } \n-\n-  for (p = s->inner; p; p = p->next)\n-    insert_intra_1 (p, ip, bb);\n-\n-  if (NOTE_BLOCK (s->note_beg))\n-    {  \n-      *ip = emit_note_after (NOTE_INSN_BLOCK_END, *ip);\n-      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_end);\n-    }\n-}\n-\n-\n-/* Insert NOTE_INSN_BLOCK_END notes and NOTE_INSN_BLOCK_BEG notes for\n-   scopes that are contained within BB.  */\n-\n-static void\n-insert_intra_bb_scope_notes (bb)\n-     basic_block bb;\n-{\n-  scope s = RBI (bb)->scope;\n-  scope p;\n-  rtx ip;\n-\n-  if (! s)\n-    return;\n-\n-  ip = bb->head;\n-  if (GET_CODE (ip) == CODE_LABEL)\n-    ip = NEXT_INSN (ip);\n-\n-  for (p = s->inner; p; p = p->next)\n-    {\n-      if (p->bb_beg != NULL && p->bb_beg == p->bb_end && p->bb_beg == bb)\n-\tinsert_intra_1 (p, &ip, bb);\n-    }\n-}\n-\n-\n-/* Given two consecutive basic blocks BB1 and BB2 with different scopes,\n-   insert NOTE_INSN_BLOCK_END notes after BB1 and NOTE_INSN_BLOCK_BEG\n-   notes before BB2 such that the notes are correctly balanced. If BB1 or\n-   BB2 is NULL, we are inserting scope notes for the first and last basic\n-   blocks, respectively.  */\n-\n-static void\n-insert_inter_bb_scope_notes (bb1, bb2)\n-     basic_block bb1;\n-     basic_block bb2;\n-{\n-  rtx ip;\n-  scope com;\n-\n-  /* It is possible that a basic block is not contained in any scope.\n-     In that case, we either open or close a scope but not both.  */\n-  if (bb1 && bb2)\n-    {\n-      scope s1 = RBI (bb1)->scope;\n-      scope s2 = RBI (bb2)->scope;\n-      if (! s1 && ! s2)\n-\treturn;\n-      if (! s1)\n-\tbb1 = NULL;\n-      else if (! s2)\n-\tbb2 = NULL;\n-    }\n-\n-  /* Find common ancestor scope.  */\n-  if (bb1 && bb2)\n-    {\n-      scope s1 = RBI (bb1)->scope;\n-      scope s2 = RBI (bb2)->scope;\n-      while (s1 != s2)\n-\t{\n-          if (! (s1 && s2))\n-\t    abort ();\n-\t  if (s1->level > s2->level)\n-\t    s1 = s1->outer;\n-\t  else if (s2->level > s1->level)\n-\t    s2 = s2->outer;\n-\t  else\n-\t    {\n-\t      s1 = s1->outer;\n-\t      s2 = s2->outer;\n-\t    }\n-\t}\n-      com = s1;\n-    }\n-  else\n-    com = NULL;\n-\n-  /* Close scopes.  */\n-  if (bb1)\n-    {\n-      rtx end = bb1->end;\n-\n-      scope s = RBI (bb1)->scope;\n-      ip = RBI (bb1)->eff_end;\n-      while (s != com)\n-\t{\n-\t  if (NOTE_BLOCK (s->note_beg))\n-\t    {  \n-\t      ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n-\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n-\t    }\n-\t  s = s->outer;\n-\t}\n-      /* Emitting note may move the end of basic block to unwanted place.  */\n-      bb1->end = end;\n-    }\n-\n-  /* Open scopes.  */\n-  if (bb2)\n-    {\n-      scope s = RBI (bb2)->scope;\n-      ip = bb2->head;\n-      while (s != com)\n-\t{\n-\t  if (NOTE_BLOCK (s->note_beg))\n-\t    {  \n-\t      ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n-\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n-\t    }\n-\t  s = s->outer;\n-\t}\n-    }\n-}\n-\n-\n-/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n-   on the scope forest and the newly reordered basic blocks.  */\n-\n-static void\n-rebuild_scope_notes (forest)\n-    scope_forest_info *forest;\n-{\n-  int i;\n-\n-  if (forest->num_trees == 0)\n-    return;\n-\n-  /* Start by opening the scopes before the first basic block.  */\n-  insert_inter_bb_scope_notes (NULL, BASIC_BLOCK (0));\n-\n-  /* Then, open and close scopes as needed between blocks.  */\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n-    {\n-      basic_block bb1 = BASIC_BLOCK (i);\n-      basic_block bb2 = BASIC_BLOCK (i + 1);\n-      if (RBI (bb1)->scope != RBI (bb2)->scope)\n-\tinsert_inter_bb_scope_notes (bb1, bb2);\n-      insert_intra_bb_scope_notes (bb1);\n-    }\n-\n-  /* Finally, close the scopes after the last basic block.  */\n-  insert_inter_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1), NULL);\n-  insert_intra_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1));\n-}\n-\n-\n-/* Free the storage associated with the scope tree at S.  */\n-\n-static void\n-free_scope_forest_1 (s)\n-    scope s;\n-{\n-  scope p, next;\n-\n-  for (p = s->inner; p; p = next)\n-    {\n-      next = p->next;\n-      free_scope_forest_1 (p);\n-    }\n-\n-  if (s->bbs)\n-    free (s->bbs);\n-  free (s);\n-}\n-\n-\n-/* Free the storage associated with the scope forest.  */\n-\n-static void\n-free_scope_forest (forest)\n-    scope_forest_info *forest;\n-{\n-  int i;\n-  for (i = 0; i < forest->num_trees; i++)\n-    free_scope_forest_1 (forest->trees[i]);\n-}\n-\n-\n-/* Visualize the scope forest.  */\n-\n-void\n-dump_scope_forest (forest)\n-    scope_forest_info *forest;\n-{\n-  if (forest->num_trees == 0)\n-    fprintf (stderr, \"\\n< Empty scope forest >\\n\");\n-  else\n-    {\n-      int i;\n-      fprintf (stderr, \"\\n< Scope forest >\\n\");\n-      for (i = 0; i < forest->num_trees; i++)\n-\tdump_scope_forest_1 (forest->trees[i], 0);\n-    }\n-}\n-\n-\n-/* Recursive portion of dump_scope_forest.  */\n-\n-static void\n-dump_scope_forest_1 (s, indent)\n-     scope s;\n-     int indent;\n-{\n-  scope p;\n-  int i;\n-\n-  if (s->bb_beg != NULL && s->bb_beg == s->bb_end\n-      && RBI (s->bb_beg)->scope\n-      && RBI (s->bb_beg)->scope->level + 1 == s->level)\n-    {\n-      fprintf (stderr, \"%*s\", indent, \"\");\n-      fprintf (stderr, \"BB%d:\\n\", s->bb_beg->index);\n-    }\n-\n-  fprintf (stderr, \"%*s\", indent, \"\");\n-  fprintf (stderr, \"{ level %d (block %p)\\n\", s->level,\n-\t   (PTR) NOTE_BLOCK (s->note_beg));\n-\n-  fprintf (stderr, \"%*s%s\", indent, \"\", \"bbs:\");\n-  for (i = 0; i < s->num_bbs; i++)\n-    fprintf (stderr, \" %d\", s->bbs[i]->index);\n-  fprintf (stderr, \"\\n\");\n-  \n-  for (p = s->inner; p; p = p->next)\n-    dump_scope_forest_1 (p, indent + 2);\n-\n-  fprintf (stderr, \"%*s\", indent, \"\");\n-  fprintf (stderr, \"}\\n\");\n-}\n-\n-\n /* Reorder basic blocks.  The main entry point to this file.  */\n \n void\n reorder_basic_blocks ()\n {\n-  scope_forest_info forest;\n-\n   if (n_basic_blocks <= 1)\n     return;\n \n-  alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n+  cfg_layout_initialize ();\n \n-  build_scope_forest (&forest);\n-  remove_scope_notes ();\n-\n-  record_effective_endpoints ();\n   make_reorder_chain ();\n \n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);\n \n-  fixup_reorder_chain ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_insn_chain ();\n-#endif\n-\n-  rebuild_scope_notes (&forest);\n-  free_scope_forest (&forest);\n-  reorder_blocks ();\n-\n-  free_aux_for_blocks ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  cfg_layout_finalize ();\n }"}, {"sha": "896eda6464ba48af2959568e536c0630e392b022", "filename": "gcc/cfglayout.c", "status": "added", "additions": 1079, "deletions": 0, "changes": 1079, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=d56a82115f7863493cbfc6d739420777270ab22b", "patch": "@@ -0,0 +1,1079 @@\n+/* Basic block reordering routines for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"obstack.h\"\n+#include \"cfglayout.h\"\n+\n+/* The contents of the current function definition are allocated\n+   in this obstack, and all are freed at the end of the function.\n+   For top-level functions, this is temporary_obstack.\n+   Separate obstacks are made for nested functions.  */\n+\n+extern struct obstack flow_obstack;\n+\n+/* Structure to hold information about lexical scopes.  */\n+struct scope_def\n+{\n+  int level;\n+\n+  /* The NOTE_INSN_BLOCK_BEG that started this scope.  */\n+  rtx note_beg;\n+\n+  /* The NOTE_INSN_BLOCK_END that ended this scope.  */\n+  rtx note_end;\n+\n+  /* The bb containing note_beg (if any).  */\n+  basic_block bb_beg;\n+\n+  /* The bb containing note_end (if any).  */\n+  basic_block bb_end;\n+\n+  /* List of basic blocks contained within this scope.  */\n+  basic_block *bbs;\n+\n+  /* Number of blocks contained within this scope.  */\n+  int num_bbs;\n+\n+  /* The outer scope or NULL if outermost scope.  */\n+  struct scope_def *outer;\n+\n+  /* The first inner scope or NULL if innermost scope.  */\n+  struct scope_def *inner;\n+\n+  /* The last inner scope or NULL if innermost scope.  */\n+  struct scope_def *inner_last;\n+\n+  /* Link to the next (sibling) scope.  */\n+  struct scope_def *next;\n+};\n+\n+/* Structure to hold information about the scope forest.  */\n+typedef struct\n+{\n+  /* Number of trees in forest.  */\n+  int num_trees;\n+\n+  /* List of tree roots.  */\n+  scope *trees;\n+} scope_forest_info;\n+\n+/* Holds the interesting trailing notes for the function.  */\n+static rtx function_tail_eff_head;\n+\n+/* The scope forst of current function.  */\n+static scope_forest_info forest;\n+\n+static rtx skip_insns_after_block\tPARAMS ((basic_block));\n+static void record_effective_endpoints\tPARAMS ((void));\n+static rtx label_for_bb\t\t\tPARAMS ((basic_block));\n+static void fixup_reorder_chain\t\tPARAMS ((void));\n+\n+static void relate_bbs_with_scopes\tPARAMS ((scope));\n+static scope make_new_scope\t\tPARAMS ((int, rtx));\n+static void build_scope_forest\t\tPARAMS ((scope_forest_info *));\n+static void remove_scope_notes\t\tPARAMS ((void));\n+static void insert_intra_1\t\tPARAMS ((scope, rtx *, basic_block));\n+static void insert_intra_bb_scope_notes PARAMS ((basic_block));\n+static void insert_inter_bb_scope_notes PARAMS ((basic_block, basic_block));\n+static void rebuild_scope_notes\t\tPARAMS ((scope_forest_info *));\n+static void free_scope_forest_1\t\tPARAMS ((scope));\n+static void free_scope_forest\t\tPARAMS ((scope_forest_info *));\n+void dump_scope_forest\t\t\tPARAMS ((scope_forest_info *));\n+static void dump_scope_forest_1\t\tPARAMS ((scope, int));\n+\n+static rtx get_next_bb_note\t\tPARAMS ((rtx));\n+static rtx get_prev_bb_note\t\tPARAMS ((rtx));\n+\n+void verify_insn_chain\t\t\tPARAMS ((void));\n+\f\n+/* Skip over inter-block insns occurring after BB which are typically\n+   associated with BB (e.g., barriers). If there are any such insns,\n+   we return the last one. Otherwise, we return the end of BB.  */\n+\n+static rtx\n+skip_insns_after_block (bb)\n+     basic_block bb;\n+{\n+  rtx insn, last_insn, next_head, prev;\n+\n+  next_head = NULL_RTX;\n+  if (bb->index + 1 != n_basic_blocks)\n+    next_head = BASIC_BLOCK (bb->index + 1)->head;\n+\n+  for (last_insn = insn = bb->end; (insn = NEXT_INSN (insn)); )\n+    {\n+      if (insn == next_head)\n+\tbreak;\n+\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase BARRIER:\n+\t  last_insn = insn;\n+\t  continue;\n+\n+\tcase NOTE:\n+\t  switch (NOTE_LINE_NUMBER (insn))\n+\t    {\n+\t    case NOTE_INSN_LOOP_END:\n+\t    case NOTE_INSN_BLOCK_END:\n+\t      last_insn = insn;\n+\t      continue;\n+\t    case NOTE_INSN_DELETED:\n+\t    case NOTE_INSN_DELETED_LABEL:\n+\t      continue;\n+\n+\t    default:\n+\t      continue;\n+\t      break;\n+\t    }\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\t  if (NEXT_INSN (insn)\n+\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n+\t          || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      last_insn = insn;\n+\t      continue;\n+\t    }\n+          break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      break;\n+    }\n+  /* It is possible to hit contradicting sequence.  For instance:\n+    \n+     jump_insn\n+     NOTE_INSN_LOOP_BEG\n+     barrier\n+\n+     Where barrier belongs to jump_insn, but the note does not.\n+     This can be created by removing the basic block originally\n+     following NOTE_INSN_LOOP_BEG.\n+\n+     In such case reorder the notes.  */\n+  for (insn = last_insn; insn != bb->end; insn = prev)\n+    {\n+    prev = PREV_INSN (insn);\n+    if (GET_CODE (insn) == NOTE)\n+      switch (NOTE_LINE_NUMBER (insn))\n+        {\n+          case NOTE_INSN_LOOP_END:\n+          case NOTE_INSN_BLOCK_END:\n+          case NOTE_INSN_DELETED:\n+          case NOTE_INSN_DELETED_LABEL:\n+    \tcontinue;\n+          default:\n+    \treorder_insns (insn, insn, last_insn);\n+        }\n+    }\n+\n+  return last_insn;\n+}\n+\n+/* Locate or create a label for a given basic block.  */\n+\n+static rtx\n+label_for_bb (bb)\n+     basic_block bb;\n+{\n+  rtx label = bb->head;\n+\n+  if (GET_CODE (label) != CODE_LABEL)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\",\n+\t\t bb->index);\n+\n+      label = block_label (bb);\n+      if (bb->head == PREV_INSN (RBI (bb)->eff_head))\n+\tRBI (bb)->eff_head = label;\n+    }\n+\n+  return label;\n+}\n+\n+/* Locate the effective beginning and end of the insn chain for each\n+   block, as defined by skip_insns_after_block above.  */\n+\n+static void\n+record_effective_endpoints ()\n+{\n+  rtx next_insn = get_insns ();\n+  int i;\n+  \n+  for (i = 0; i < n_basic_blocks; ++i)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx end;\n+\n+      RBI (bb)->eff_head = next_insn;\n+      end = skip_insns_after_block (bb);\n+      RBI (bb)->eff_end = end;\n+      next_insn = NEXT_INSN (end);\n+    }\n+  function_tail_eff_head = next_insn;\n+}\n+\f\n+static rtx\n+get_next_bb_note (x)\n+     rtx x;\n+{\n+  while (x)\n+    {\n+      if (NOTE_INSN_BASIC_BLOCK_P (x))\n+\treturn x;\n+      x = NEXT_INSN (x);\n+    }\n+  return NULL;\n+}\n+\n+static rtx\n+get_prev_bb_note (x)\n+     rtx x;\n+{\n+  while (x)\n+    {\n+      if (NOTE_INSN_BASIC_BLOCK_P (x))\n+\treturn x;\n+      x = PREV_INSN (x);\n+    }\n+  return NULL;\n+}\n+\n+/* Determine and record the relationships between basic blocks and\n+   scopes in scope tree S.  */\n+\n+static void\n+relate_bbs_with_scopes (s)\n+     scope s;\n+{\n+  scope p;\n+  int i, bbi1, bbi2, bbs_spanned;\n+  rtx bbnote;\n+\n+  for (p = s->inner; p; p = p->next)\n+    relate_bbs_with_scopes (p);\n+\n+  bbi1 = bbi2 = -1;\n+  bbs_spanned = 0;\n+\n+  /* If the begin and end notes are both inside the same basic block,\n+     or if they are both outside of basic blocks, then we know immediately\n+     how they are related. Otherwise, we need to poke around to make the\n+     determination.  */\n+  if (s->bb_beg != s->bb_end)\n+    {\n+      if (s->bb_beg && s->bb_end)\n+        {\n+\t  /* Both notes are in different bbs. This implies that all the\n+\t     basic blocks spanned by the pair of notes are contained in\n+             this scope.  */\n+\t  bbi1 = s->bb_beg->index;\n+\t  bbi2 = s->bb_end->index;\n+\t  bbs_spanned = 1;\n+\t}\n+      else if (! s->bb_beg)\n+        {\n+\t  /* First note is outside of a bb. If the scope spans more than\n+\t     one basic block, then they all are contained within this\n+             scope. Otherwise, this scope is contained within the basic\n+\t     block.  */\n+\t  bbnote = get_next_bb_note (s->note_beg);\n+\t  if (! bbnote)\n+\t    abort ();\n+\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_end)\n+\t    {\n+\t      bbs_spanned = 0;\n+\t      s->bb_beg = NOTE_BASIC_BLOCK (bbnote);\n+\t    }\n+\t  else\n+\t    {\n+\t      bbi1 = NOTE_BASIC_BLOCK (bbnote)->index;\n+\t      bbi2 = s->bb_end->index;\n+\t      s->bb_end = NULL;\n+\t      bbs_spanned = 1;\n+\t    }\n+\t}\n+      else /* ! s->bb_end */\n+        {\n+\t  /* Second note is outside of a bb. If the scope spans more than\n+\t     one basic block, then they all are contained within this\n+             scope. Otherwise, this scope is contained within the basic\n+\t     block.  */\n+\t  bbnote = get_prev_bb_note (s->note_end);\n+\t  if (! bbnote)\n+\t    abort ();\n+\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_beg)\n+\t    {\n+\t      bbs_spanned = 0;\n+\t      s->bb_end = NOTE_BASIC_BLOCK (bbnote);\n+\t    }\n+\t  else\n+\t    {\n+\t      bbi1 = s->bb_beg->index;\n+\t      bbi2 = NOTE_BASIC_BLOCK (bbnote)->index;\n+\t      s->bb_beg = NULL;\n+\t      bbs_spanned = 1;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      if (s->bb_beg)\n+        /* Both notes are in the same bb, which implies the block\n+\t   contains this scope.  */\n+\tbbs_spanned = 0;\n+      else\n+\t{\n+          rtx x1, x2;\n+\t  /* Both notes are outside of any bbs. This implies that all the\n+\t     basic blocks spanned by the pair of notes are contained in\n+             this scope. \n+\t     There is a degenerate case to consider. If the notes do not\n+\t     span any basic blocks, then it is an empty scope that can\n+\t     safely be deleted or ignored. Mark these with level = -1.  */\n+\n+\t  x1 = get_next_bb_note (s->note_beg);\n+\t  x2 = get_prev_bb_note (s->note_end);\n+\t  if (! (x1 && x2))\n+\t    {\n+\t      s->level = -1; \n+\t      bbs_spanned = 0; \n+\t    }\n+\t  else\n+\t    {\n+\t      bbi1 = NOTE_BASIC_BLOCK (x1)->index;\n+\t      bbi2 = NOTE_BASIC_BLOCK (x2)->index;\n+\t      bbs_spanned = 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* If the scope spans one or more basic blocks, we record them. We\n+     only record the bbs that are immediately contained within this\n+     scope. Note that if a scope is contained within a bb, we can tell\n+     by checking that bb_beg = bb_end and that they are non-null.  */\n+  if (bbs_spanned)\n+    {\n+      int j = 0;\n+\n+      s->num_bbs = 0;\n+      for (i = bbi1; i <= bbi2; i++)\n+\tif (! RBI (BASIC_BLOCK (i))->scope)\n+\t  s->num_bbs++;\n+\n+      s->bbs = xmalloc (s->num_bbs * sizeof (basic_block));\n+      for (i = bbi1; i <= bbi2; i++)\n+\t{\n+\t  basic_block curr_bb = BASIC_BLOCK (i);\n+\t  if (! RBI (curr_bb)->scope)\n+\t    {\n+\t      s->bbs[j++] = curr_bb;\n+\t      RBI (curr_bb)->scope = s;\n+\t    }\n+\t}\n+    }\n+  else\n+    s->num_bbs = 0;\n+}\n+\n+/* Allocate and initialize a new scope structure with scope level LEVEL,\n+   and record the NOTE beginning the scope.  */\n+\n+static scope \n+make_new_scope (level, note)\n+     int level;\n+     rtx note;\n+{\n+  scope new_scope = xcalloc (1, sizeof (struct scope_def));\n+  new_scope->level = level;\n+  new_scope->note_beg = note;\n+  return new_scope;\n+}\n+\n+\n+/* Build a forest representing the scope structure of the function.\n+   Return a pointer to a structure describing the forest.  */\n+\n+static void\n+build_scope_forest (forest)\n+    scope_forest_info *forest;\n+{\n+  rtx x;\n+  int level, bbi, i;\n+  basic_block curr_bb;\n+  scope root, curr_scope = 0;\n+\n+  forest->num_trees = 0;\n+  forest->trees = NULL;\n+  level = -1;\n+  root = NULL;\n+  curr_bb = NULL;\n+  bbi = 0;\n+  for (x = get_insns (); x; x = NEXT_INSN (x))\n+    {\n+      if (bbi < n_basic_blocks && x == BASIC_BLOCK (bbi)->head)\n+\tcurr_bb = BASIC_BLOCK (bbi);\n+\n+      if (GET_CODE (x) == NOTE)\n+\t{\n+\t  if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG)\n+\t    {\n+\t      if (root)\n+\t\t{\n+\t\t  scope new_scope;\n+\t\t  if (! curr_scope)\n+\t\t    abort();\n+\t\t  level++;\n+\t\t  new_scope = make_new_scope (level, x);\n+\t\t  new_scope->outer = curr_scope;\n+\t\t  new_scope->next = NULL;\n+\t\t  if (! curr_scope->inner)\n+\t\t    {\n+\t\t      curr_scope->inner = new_scope;\n+\t\t      curr_scope->inner_last = new_scope;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      curr_scope->inner_last->next = new_scope;\n+\t\t      curr_scope->inner_last = new_scope;\n+\t\t    }\n+\t\t  curr_scope = curr_scope->inner_last;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int ntrees = forest->num_trees;\n+\t\t  level++;\n+\t          curr_scope = make_new_scope (level, x);\n+\t\t  root = curr_scope;\n+\t\t  forest->trees = xrealloc (forest->trees,\n+\t\t\t\t\t    sizeof (scope) * (ntrees + 1));\n+\t\t  forest->trees[forest->num_trees++] = root;\n+\t\t}\n+\t      curr_scope->bb_beg = curr_bb;\n+\t    }\n+\t  else if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END)\n+\t    {\n+\t      curr_scope->bb_end = curr_bb;\n+\t      curr_scope->note_end = x;\n+\t      level--;\n+\t      curr_scope = curr_scope->outer;\n+\t      if (level == -1)\n+\t\troot = NULL;\n+\t    }\n+\t} /* if note */\n+\n+      if (curr_bb && curr_bb->end == x)\n+\t{\n+\t  curr_bb = NULL;\n+\t  bbi++;\n+\t}\n+\n+    } /* for */\n+\n+  for (i = 0; i < forest->num_trees; i++)\n+    relate_bbs_with_scopes (forest->trees[i]);\n+}\n+\f\n+/* Remove all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes from\n+   the insn chain.  */\n+\n+static void\n+remove_scope_notes ()\n+{\n+  rtx x, next;\n+  basic_block currbb = NULL;\n+\n+  for (x = get_insns (); x; x = next)\n+    {\n+      next = NEXT_INSN (x);\n+      if (NOTE_INSN_BASIC_BLOCK_P (x))\n+\tcurrbb = NOTE_BASIC_BLOCK (x);\n+\n+      if (GET_CODE (x) == NOTE\n+\t  && (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG\n+\t      || NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END))\n+\t{\n+\t  /* Check if the scope note happens to be the end of a bb.  */\n+\t  if (currbb && x == currbb->end)\n+\t    currbb->end = PREV_INSN (x);\n+\t  if (currbb && x == currbb->head)\n+\t    abort ();\n+\n+\t  if (PREV_INSN (x))\n+\t    {\n+\t      NEXT_INSN (PREV_INSN (x)) = next;\n+\t      PREV_INSN (next) = PREV_INSN (x);\n+\n+              NEXT_INSN (x) = NULL;\n+              PREV_INSN (x) = NULL;\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+}\n+\f\n+/* Insert scope note pairs for a contained scope tree S after insn IP.  */\n+\n+static void\n+insert_intra_1 (s, ip, bb)\n+     scope s;\n+     rtx *ip;\n+     basic_block bb;\n+{\n+  scope p;\n+\n+  if (NOTE_BLOCK (s->note_beg))\n+    {  \n+      *ip = emit_note_after (NOTE_INSN_BLOCK_BEG, *ip);\n+      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_beg);\n+    } \n+\n+  for (p = s->inner; p; p = p->next)\n+    insert_intra_1 (p, ip, bb);\n+\n+  if (NOTE_BLOCK (s->note_beg))\n+    {  \n+      *ip = emit_note_after (NOTE_INSN_BLOCK_END, *ip);\n+      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_end);\n+    }\n+}\n+\n+\n+/* Insert NOTE_INSN_BLOCK_END notes and NOTE_INSN_BLOCK_BEG notes for\n+   scopes that are contained within BB.  */\n+\n+static void\n+insert_intra_bb_scope_notes (bb)\n+     basic_block bb;\n+{\n+  scope s = RBI (bb)->scope;\n+  scope p;\n+  rtx ip;\n+\n+  if (! s)\n+    return;\n+\n+  ip = bb->head;\n+  if (GET_CODE (ip) == CODE_LABEL)\n+    ip = NEXT_INSN (ip);\n+\n+  for (p = s->inner; p; p = p->next)\n+    {\n+      if (p->bb_beg != NULL && p->bb_beg == p->bb_end && p->bb_beg == bb)\n+\tinsert_intra_1 (p, &ip, bb);\n+    }\n+}\n+\n+\n+/* Given two consecutive basic blocks BB1 and BB2 with different scopes,\n+   insert NOTE_INSN_BLOCK_END notes after BB1 and NOTE_INSN_BLOCK_BEG\n+   notes before BB2 such that the notes are correctly balanced. If BB1 or\n+   BB2 is NULL, we are inserting scope notes for the first and last basic\n+   blocks, respectively.  */\n+\n+static void\n+insert_inter_bb_scope_notes (bb1, bb2)\n+     basic_block bb1;\n+     basic_block bb2;\n+{\n+  rtx ip;\n+  scope com;\n+\n+  /* It is possible that a basic block is not contained in any scope.\n+     In that case, we either open or close a scope but not both.  */\n+  if (bb1 && bb2)\n+    {\n+      scope s1 = RBI (bb1)->scope;\n+      scope s2 = RBI (bb2)->scope;\n+      if (! s1 && ! s2)\n+\treturn;\n+      if (! s1)\n+\tbb1 = NULL;\n+      else if (! s2)\n+\tbb2 = NULL;\n+    }\n+\n+  /* Find common ancestor scope.  */\n+  if (bb1 && bb2)\n+    {\n+      scope s1 = RBI (bb1)->scope;\n+      scope s2 = RBI (bb2)->scope;\n+      while (s1 != s2)\n+\t{\n+          if (! (s1 && s2))\n+\t    abort ();\n+\t  if (s1->level > s2->level)\n+\t    s1 = s1->outer;\n+\t  else if (s2->level > s1->level)\n+\t    s2 = s2->outer;\n+\t  else\n+\t    {\n+\t      s1 = s1->outer;\n+\t      s2 = s2->outer;\n+\t    }\n+\t}\n+      com = s1;\n+    }\n+  else\n+    com = NULL;\n+\n+  /* Close scopes.  */\n+  if (bb1)\n+    {\n+      rtx end = bb1->end;\n+\n+      scope s = RBI (bb1)->scope;\n+      ip = RBI (bb1)->eff_end;\n+      while (s != com)\n+\t{\n+\t  if (NOTE_BLOCK (s->note_beg))\n+\t    {  \n+\t      ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n+\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n+\t    }\n+\t  s = s->outer;\n+\t}\n+      /* Emitting note may move the end of basic block to unwanted place.  */\n+      bb1->end = end;\n+    }\n+\n+  /* Open scopes.  */\n+  if (bb2)\n+    {\n+      scope s = RBI (bb2)->scope;\n+      ip = bb2->head;\n+      while (s != com)\n+\t{\n+\t  if (NOTE_BLOCK (s->note_beg))\n+\t    {  \n+\t      ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n+\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n+\t    }\n+\t  s = s->outer;\n+\t}\n+    }\n+}\n+\n+\n+/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n+   on the scope forest and the newly reordered basic blocks.  */\n+\n+static void\n+rebuild_scope_notes (forest)\n+    scope_forest_info *forest;\n+{\n+  int i;\n+\n+  if (forest->num_trees == 0)\n+    return;\n+\n+  /* Start by opening the scopes before the first basic block.  */\n+  insert_inter_bb_scope_notes (NULL, BASIC_BLOCK (0));\n+\n+  /* Then, open and close scopes as needed between blocks.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      basic_block bb1 = BASIC_BLOCK (i);\n+      basic_block bb2 = BASIC_BLOCK (i + 1);\n+      if (RBI (bb1)->scope != RBI (bb2)->scope)\n+\tinsert_inter_bb_scope_notes (bb1, bb2);\n+      insert_intra_bb_scope_notes (bb1);\n+    }\n+\n+  /* Finally, close the scopes after the last basic block.  */\n+  insert_inter_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1), NULL);\n+  insert_intra_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1));\n+}\n+\f\n+/* Free the storage associated with the scope tree at S.  */\n+\n+static void\n+free_scope_forest_1 (s)\n+    scope s;\n+{\n+  scope p, next;\n+\n+  for (p = s->inner; p; p = next)\n+    {\n+      next = p->next;\n+      free_scope_forest_1 (p);\n+    }\n+\n+  if (s->bbs)\n+    free (s->bbs);\n+  free (s);\n+}\n+\n+/* Free the storage associated with the scope forest.  */\n+\n+static void\n+free_scope_forest (forest)\n+    scope_forest_info *forest;\n+{\n+  int i;\n+  for (i = 0; i < forest->num_trees; i++)\n+    free_scope_forest_1 (forest->trees[i]);\n+}\n+\f\n+/* Visualize the scope forest.  */\n+\n+void\n+dump_scope_forest (forest)\n+    scope_forest_info *forest;\n+{\n+  if (forest->num_trees == 0)\n+    fprintf (stderr, \"\\n< Empty scope forest >\\n\");\n+  else\n+    {\n+      int i;\n+      fprintf (stderr, \"\\n< Scope forest >\\n\");\n+      for (i = 0; i < forest->num_trees; i++)\n+\tdump_scope_forest_1 (forest->trees[i], 0);\n+    }\n+}\n+\n+/* Recursive portion of dump_scope_forest.  */\n+\n+static void\n+dump_scope_forest_1 (s, indent)\n+     scope s;\n+     int indent;\n+{\n+  scope p;\n+  int i;\n+\n+  if (s->bb_beg != NULL && s->bb_beg == s->bb_end\n+      && RBI (s->bb_beg)->scope\n+      && RBI (s->bb_beg)->scope->level + 1 == s->level)\n+    {\n+      fprintf (stderr, \"%*s\", indent, \"\");\n+      fprintf (stderr, \"BB%d:\\n\", s->bb_beg->index);\n+    }\n+\n+  fprintf (stderr, \"%*s\", indent, \"\");\n+  fprintf (stderr, \"{ level %d (block %p)\\n\", s->level,\n+\t   (PTR) NOTE_BLOCK (s->note_beg));\n+\n+  fprintf (stderr, \"%*s%s\", indent, \"\", \"bbs:\");\n+  for (i = 0; i < s->num_bbs; i++)\n+    fprintf (stderr, \" %d\", s->bbs[i]->index);\n+  fprintf (stderr, \"\\n\");\n+  \n+  for (p = s->inner; p; p = p->next)\n+    dump_scope_forest_1 (p, indent + 2);\n+\n+  fprintf (stderr, \"%*s\", indent, \"\");\n+  fprintf (stderr, \"}\\n\");\n+}\n+\f\n+/* Given a reorder chain, rearrange the code to match.  */\n+\n+static void\n+fixup_reorder_chain ()\n+{\n+  basic_block bb, last_bb;\n+  int index;\n+  rtx insn;\n+  int old_n_basic_blocks = n_basic_blocks;\n+\n+  /* First do the bulk reordering -- rechain the blocks without regard to\n+     the needed changes to jumps and labels.  */\n+\n+  last_bb = BASIC_BLOCK (0);\n+  bb = RBI (last_bb)->next;\n+  index = 1;\n+  while (bb)\n+    {\n+      rtx last_e = RBI (last_bb)->eff_end;\n+      rtx curr_h = RBI (bb)->eff_head;\n+\n+      NEXT_INSN (last_e) = curr_h;\n+      PREV_INSN (curr_h) = last_e;\n+\n+      last_bb = bb;\n+      bb = RBI (bb)->next;\n+      index++;\n+    }\n+\n+  if (index != n_basic_blocks)\n+    abort ();\n+\n+  insn = RBI (last_bb)->eff_end;\n+\n+  NEXT_INSN (insn) = function_tail_eff_head;\n+  if (function_tail_eff_head)\n+    PREV_INSN (function_tail_eff_head) = insn;\n+\n+  while (NEXT_INSN (insn))\n+    insn = NEXT_INSN (insn);\n+  set_last_insn (insn);\n+#ifdef ENABLE_CHECKING\n+  verify_insn_chain ();\n+#endif\n+\n+  /* Now add jumps and labels as needed to match the blocks new\n+     outgoing edges.  */\n+\n+  for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n+    {\n+      edge e_fall, e_taken, e;\n+      rtx bb_end_insn;\n+      basic_block nb;\n+\n+      if (bb->succ == NULL)\n+\tcontinue;\n+\n+      /* Find the old fallthru edge, and another non-EH edge for\n+\t a taken jump.  */\n+      e_taken = e_fall = NULL;\n+      for (e = bb->succ; e ; e = e->succ_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  e_fall = e;\n+\telse if (! (e->flags & EDGE_EH))\n+\t  e_taken = e;\n+\n+      bb_end_insn = bb->end;\n+      if (GET_CODE (bb_end_insn) == JUMP_INSN)\n+\t{\n+\t  if (any_condjump_p (bb_end_insn))\n+\t    {\n+\t      /* If the old fallthru is still next, nothing to do.  */\n+\t      if (RBI (bb)->next == e_fall->dest\n+\t          || (!RBI (bb)->next\n+\t\t      && e_fall->dest == EXIT_BLOCK_PTR))\n+\t\tcontinue;\n+\n+\t      /* There is one special case: if *neither* block is next,\n+\t\t such as happens at the very end of a function, then we'll\n+\t\t need to add a new unconditional jump.  Choose the taken\n+\t\t edge based on known or assumed probability.  */\n+\t      if (RBI (bb)->next != e_taken->dest)\n+\t\t{\n+\t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n+\t\t  if (note\n+\t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n+\t\t      && invert_jump (bb_end_insn,\n+\t\t\t\t      label_for_bb (e_fall->dest), 0))\n+\t\t    {\n+\t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n+\t\t      e_taken->flags |= EDGE_FALLTHRU;\n+\t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Otherwise we can try to invert the jump.  This will \n+\t\t basically never fail, however, keep up the pretense.  */\n+\t      else if (invert_jump (bb_end_insn,\n+\t\t\t\t    label_for_bb (e_fall->dest), 0))\n+\t\t{\n+\t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n+\t\t  e_taken->flags |= EDGE_FALLTHRU;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else if (returnjump_p (bb_end_insn))\n+\t    continue;\n+\t  else\n+\t    {\n+\t      /* Otherwise we have some switch or computed jump.  In the\n+\t\t 99% case, there should not have been a fallthru edge.  */\n+\t      if (! e_fall)\n+\t\tcontinue;\n+#ifdef CASE_DROPS_THROUGH\n+\t      /* Except for VAX.  Since we didn't have predication for the\n+\t\t tablejump, the fallthru block should not have moved.  */\n+\t      if (RBI (bb)->next == e_fall->dest)\n+\t\tcontinue;\n+\t      bb_end_insn = skip_insns_after_block (bb);\n+#else\n+\t      abort ();\n+#endif\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* No fallthru implies a noreturn function with EH edges, or\n+\t     something similarly bizarre.  In any case, we don't need to\n+\t     do anything.  */\n+\t  if (! e_fall)\n+\t    continue;\n+\n+\t  /* If the fallthru block is still next, nothing to do.  */\n+\t  if (RBI (bb)->next == e_fall->dest)\n+\t    continue;\n+\n+\t  /* An fallthru to exit block.  */\n+\t  if (!RBI (bb)->next && e_fall->dest == EXIT_BLOCK_PTR)\n+\t    continue;\n+\t}\n+\n+      /* We got here if we need to add a new jump insn.  */\n+\n+      nb = force_nonfallthru (e_fall);\n+\n+      if (nb)\n+\t{\n+\t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n+\t  RBI (nb)->eff_head = nb->head;\n+\t  RBI (nb)->eff_end = NEXT_INSN (nb->end);\n+\t  RBI (nb)->scope = RBI (bb)->scope;\n+\t  RBI (nb)->visited = 1;\n+\t  RBI (nb)->next = RBI (bb)->next;\n+\t  RBI (bb)->next = nb;\n+\t  /* Don't process this new block.  */\n+\t  bb = nb;\n+\t}\n+    }\n+\n+  /* Put basic_block_info in the new order.  */\n+  bb = BASIC_BLOCK (0);\n+  index = 0;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n+  while (bb)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \" %i %sbb %i freq %i\\n\", index,\n+\t\t bb->index >= old_n_basic_blocks ? \"compensation \" : \"\",\n+\t\t bb->index,\n+\t   \t bb->frequency);\n+      bb->index = index;\n+      BASIC_BLOCK (index) = bb;\n+\n+      bb = RBI (bb)->next;\n+      index++;\n+    }\n+}\n+\f\n+/* Perform sanity checks on the insn chain.\n+   1. Check that next/prev pointers are consistent in both the forward and\n+      reverse direction.\n+   2. Count insns in chain, going both directions, and check if equal.\n+   3. Check that get_last_insn () returns the actual end of chain.  */\n+\n+void\n+verify_insn_chain ()\n+{\n+  rtx x,\n+      prevx,\n+      nextx;\n+  int insn_cnt1,\n+      insn_cnt2;\n+\n+  prevx = NULL;\n+  insn_cnt1 = 1;\n+  for (x = get_insns (); x; x = NEXT_INSN (x))\n+    {\n+      if (PREV_INSN (x) != prevx)\n+\t{\n+\t  fprintf (stderr, \"Forward traversal: insn chain corrupt.\\n\");\n+\t  fprintf (stderr, \"previous insn:\\n\");\n+\t  debug_rtx (prevx);\n+\t  fprintf (stderr, \"current insn:\\n\");\n+\t  debug_rtx (x);\n+\t  abort ();\n+\t}\n+      ++insn_cnt1;\n+      prevx = x;\n+    }\n+\n+  if (prevx != get_last_insn ())\n+    {\n+      fprintf (stderr, \"last_insn corrupt.\\n\");\n+      abort ();\n+    }\n+\n+  nextx = NULL;\n+  insn_cnt2 = 1;\n+  for (x = get_last_insn (); x; x = PREV_INSN (x))\n+    {\n+      if (NEXT_INSN (x) != nextx)\n+\t{\n+\t  fprintf (stderr, \"Reverse traversal: insn chain corrupt.\\n\");\n+\t  fprintf (stderr, \"current insn:\\n\");\n+\t  debug_rtx (x);\n+\t  fprintf (stderr, \"next insn:\\n\");\n+\t  debug_rtx (nextx);\n+\t  abort ();\n+\t}\n+      ++insn_cnt2;\n+      nextx = x;\n+    }\n+\n+  if (insn_cnt1 != insn_cnt2)\n+    {\n+      fprintf (stderr, \"insn_cnt1 (%d) not equal to insn_cnt2 (%d).\\n\",\n+\t       insn_cnt1, insn_cnt2);\n+      abort ();\n+    }\n+}\n+\f\n+/* Main entry point to this module - initialize the datastructures for\n+   CFG layout changes.  */\n+\n+void\n+cfg_layout_initialize ()\n+{\n+  alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n+\n+  build_scope_forest (&forest);\n+  remove_scope_notes ();\n+\n+  record_effective_endpoints ();\n+}\n+\n+/* Finalize the changes - reorder insn list according to the sequence,\n+   enter compensation code, rebuild scope forest.  */\n+\n+void\n+cfg_layout_finalize ()\n+{\n+  fixup_reorder_chain ();\n+#ifdef ENABLE_CHECKING\n+  verify_insn_chain ();\n+#endif\n+\n+  rebuild_scope_notes (&forest);\n+  free_scope_forest (&forest);\n+  reorder_blocks ();\n+\n+  free_aux_for_blocks ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+}"}, {"sha": "3c59e42ffd6c242186ef1dc2a335e291bd443efd", "filename": "gcc/cfglayout.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a82115f7863493cbfc6d739420777270ab22b/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=d56a82115f7863493cbfc6d739420777270ab22b", "patch": "@@ -0,0 +1,37 @@\n+/* Basic block reordering routines for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+struct scope_def;\n+typedef struct scope_def *scope;\n+\n+/* Structure to hold information about the blocks during reordering.  */\n+typedef struct reorder_block_def\n+{\n+  rtx eff_head;\n+  rtx eff_end;\n+  scope scope;\n+  basic_block next;\n+  int visited;\n+} *reorder_block_def;\n+\n+#define RBI(BB)\t((reorder_block_def) (BB)->aux)\n+\n+extern void cfg_layout_initialize\tPARAMS ((void));\n+extern void cfg_layout_finalize\t\tPARAMS ((void));"}]}