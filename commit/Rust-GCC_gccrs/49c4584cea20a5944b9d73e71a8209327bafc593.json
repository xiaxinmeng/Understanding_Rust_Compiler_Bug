{"sha": "49c4584cea20a5944b9d73e71a8209327bafc593", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDljNDU4NGNlYTIwYTU5NDRiOWQ3M2U3MWE4MjA5MzI3YmFmYzU5Mw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-01-25T04:18:30Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-01-25T04:18:30Z"}, "message": "(movcc_gen_code): New variable.\n\n(init_optabs): Initialize it.\n(emit_conditional_move): New function.\n(can_conditionally_move_p): New function.\n\nFrom-SVN: r8802", "tree": {"sha": "f8b7c123193b7417b6a7d93dcd77a18e703c35fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8b7c123193b7417b6a7d93dcd77a18e703c35fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49c4584cea20a5944b9d73e71a8209327bafc593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49c4584cea20a5944b9d73e71a8209327bafc593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49c4584cea20a5944b9d73e71a8209327bafc593", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49c4584cea20a5944b9d73e71a8209327bafc593/comments", "author": null, "committer": null, "parents": [{"sha": "7209f1f9e430458aeb12bad7a980687a38b4a38d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7209f1f9e430458aeb12bad7a980687a38b4a38d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7209f1f9e430458aeb12bad7a980687a38b4a38d"}], "stats": {"total": 156, "additions": 156, "deletions": 0}, "files": [{"sha": "97983a864b1309aa1f8486022830a308a73f63d4", "filename": "gcc/optabs.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c4584cea20a5944b9d73e71a8209327bafc593/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c4584cea20a5944b9d73e71a8209327bafc593/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=49c4584cea20a5944b9d73e71a8209327bafc593", "patch": "@@ -211,6 +211,15 @@ rtxfun bcc_gen_fctn[NUM_RTX_CODE];\n \n enum insn_code setcc_gen_code[NUM_RTX_CODE];\n \n+#ifdef HAVE_conditional_move\n+/* Indexed by the machine mode, gives the insn code to make a conditional\n+   move insn.  This is not indexed by the rtx-code like bcc_gen_fctn and\n+   setcc_gen_code to cut down on the number of named patterns.  Consider a day\n+   when a lot more rtx codes are conditional (eg: for the ARM).  */\n+\n+enum insn_code movcc_gen_code[NUM_MACHINE_MODES];\n+#endif\n+\n static int add_equal_note\tPROTO((rtx, rtx, enum rtx_code, rtx, rtx));\n static rtx widen_operand\tPROTO((rtx, enum machine_mode,\n \t\t\t\t       enum machine_mode, int, int));\n@@ -3050,6 +3059,148 @@ emit_indirect_jump (loc)\n   emit_barrier ();\n }\n \f\n+#ifdef HAVE_conditional_move\n+\n+/* Emit a conditional move instruction if the machine supports one for that\n+   condition and machine mode.\n+\n+   OP0 and OP1 are the operands that should be compared using CODE.  CMODE is\n+   the mode to use should they be constants.  If it is VOIDmode, they cannot\n+   both be constants.\n+\n+   OP2 should be stored in TARGET if the comparison is true, otherwise OP3\n+   should be stored there.  MODE is the mode to use should they be constants.\n+   If it is VOIDmode, they cannot both be constants.\n+\n+   The result is either TARGET (perhaps modified) or NULL_RTX if the operation\n+   is not supported.  */\n+\n+rtx\n+emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n+\t\t       unsignedp)\n+     rtx target;\n+     enum rtx_code code;\n+     rtx op0, op1;\n+     enum machine_mode cmode;\n+     rtx op2, op3;\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  rtx tem, subtarget, comparison, insn;\n+  enum insn_code icode;\n+\n+  /* If one operand is constant, make it the second one.  Only do this\n+     if the other operand is not constant as well.  */\n+\n+  if ((CONSTANT_P (op0) && ! CONSTANT_P (op1))\n+      || (GET_CODE (op0) == CONST_INT && GET_CODE (op1) != CONST_INT))\n+    {\n+      tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+      code = swap_condition (code);\n+    }\n+\n+  if (cmode == VOIDmode)\n+    cmode = GET_MODE (op0);\n+\n+  if ((CONSTANT_P (op2) && ! CONSTANT_P (op3))\n+      || (GET_CODE (op2) == CONST_INT && GET_CODE (op3) != CONST_INT))\n+    {\n+      tem = op2;\n+      op2 = op3;\n+      op3 = tem;\n+      /* ??? This may not be appropriate (consider IEEE).  Perhaps we should\n+\t call can_reverse_comparison_p here and bail out if necessary.\n+\t It's not clear whether we need to do this canonicalization though.  */\n+      code = reverse_condition (code);\n+    }\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op2);\n+\n+  icode = movcc_gen_code[mode];\n+\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  if (flag_force_mem)\n+    {\n+      op2 = force_not_mem (op2);\n+      op3 = force_not_mem (op3);\n+    }\n+\n+  if (target)\n+    target = protect_from_queue (target, 1);\n+  else\n+    target = gen_reg_rtx (mode);\n+\n+  subtarget = target;\n+\n+  emit_queue ();\n+\n+  op2 = protect_from_queue (op2, 0);\n+  op3 = protect_from_queue (op3, 0);\n+\n+  /* If the insn doesn't accept these operands, put them in pseudos.  */\n+\n+  if (! (*insn_operand_predicate[icode][0])\n+      (subtarget, insn_operand_mode[icode][0]))\n+    subtarget = gen_reg_rtx (insn_operand_mode[icode][0]);\n+\n+  if (! (*insn_operand_predicate[icode][2])\n+      (op2, insn_operand_mode[icode][2]))\n+    op2 = copy_to_mode_reg (insn_operand_mode[icode][2], op2);\n+\n+  if (! (*insn_operand_predicate[icode][3])\n+      (op3, insn_operand_mode[icode][3]))\n+    op3 = copy_to_mode_reg (insn_operand_mode[icode][3], op3);\n+\n+  /* Everything should now be in the suitable form, so emit the compare insn\n+     and then the conditional move.  */\n+\n+  comparison \n+    = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX, 0);\n+\n+  /* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */\n+  if (GET_CODE (comparison) != code)\n+    /* This shouldn't happen.  */\n+    abort ();\n+  \n+  insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n+\n+  /* If that failed, then give up.  */\n+  if (insn == 0)\n+    return 0;\n+\n+  emit_insn (insn);\n+\n+  if (subtarget != target)\n+    convert_move (target, subtarget, 0);\n+\n+  return target;\n+}\n+\n+/* Return non-zero if a conditional move of mode MODE is supported.\n+\n+   This function is for combine so it can tell whether an insn that looks\n+   like a conditional move is actually supported by the hardware.  If we\n+   guess wrong we lose a bit on optimization, but that's it.  */\n+/* ??? sparc64 supports conditionally moving integers values based on fp\n+   comparisons, and vice versa.  How do we handle them?  */\n+\n+int\n+can_conditionally_move_p (mode)\n+     enum machine_mode mode;\n+{\n+  if (movcc_gen_code[mode] != CODE_FOR_nothing)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+#endif /* HAVE_conditional_move */\n+\f\n /* These three functions generate an insn body and return it\n    rather than emitting the insn.\n \n@@ -3875,6 +4026,11 @@ init_optabs ()\n   for (i = 0; i < NUM_RTX_CODE; i++)\n     setcc_gen_code[i] = CODE_FOR_nothing;\n \n+#ifdef HAVE_conditional_move\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    movcc_gen_code[i] = CODE_FOR_nothing;\n+#endif\n+\n   add_optab = init_optab (PLUS);\n   sub_optab = init_optab (MINUS);\n   smul_optab = init_optab (MULT);"}]}