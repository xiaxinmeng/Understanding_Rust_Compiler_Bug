{"sha": "8026246fa2c7841f839987fef0117b18bfd374fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAyNjI0NmZhMmM3ODQxZjgzOTk4N2ZlZjAxMTdiMThiZmQzNzRmZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-03T06:56:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-03T06:56:21Z"}, "message": "cp-tree.h (CLASSTYPE_VFIELDS): Move definition.\n\n2000-01-02  Mark Mitchell  <mark@codesourcery.com>\n\n\t* cp-tree.h (CLASSTYPE_VFIELDS): Move definition.\n\t(BINFO_PRIMARY_MARKED_P): Use flag 5.\n\t(SET_BINFO_PRIMARY_MARKED_P): Likewise.\n\t(CLEAR_BINFO_PRIMARY_MARKED_P): Likewise.\n\t(unmark_primary_bases): Remove declaration.\n\t(unmarkedp): Declare.\n\t(dfs_vbase_unmark): Likewise.\n\t* class.c (determine_primary_base): Return immediately if there\n\tare no base classes.  Call mark_primary_bases here.\n\t(modify_all_direct_vtables): Remove.\n\t(modify_all_indirect_vtables): Remove.\n\t(dfs_modify_vtables_queue_p): New function.\n\t(dfs_modify_vtables): New function.\n\t(modify_all_vtables): Use them.\n\t(build_base_fields): Build FIELD_DECLs for primary virtual base\n\tclasses.\n\t(create_vtable_ptr): Don't call determine_primary_base here.\n\t(dfs_mark_primary_bases_and_set_vbase_offsets): Rename to ...\n\t(dfs_set_offset_for_vbases): ... this.\n\t(layout_virtual_bases): Use it.\n\t(layout_class_type): Call determine_primary_base here.\n\t* search.c (unmarkedp): Make it global.\n\t(shared_marked_p): Simplify.\n\t(shared_unmarked_p): Likewise.\n\t(dfs_primary_bases_queue_p): Remove.\n\t(dfs_unmark_primary_bases): Likewise.\n\t(unmark_primary_bases): Likewise.\n\t(mark_primary_bases): Simplify.\n\t(get_pure_virtuals): Don't call mark_primary_bases here.\n\t(dfs_vbase_unmark): New function.\n\t(get_vbase_types): Simplify.\n\nFrom-SVN: r31175", "tree": {"sha": "72cafa3720b3e797d7cbf4cd918035d92ba9da74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72cafa3720b3e797d7cbf4cd918035d92ba9da74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8026246fa2c7841f839987fef0117b18bfd374fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8026246fa2c7841f839987fef0117b18bfd374fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8026246fa2c7841f839987fef0117b18bfd374fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8026246fa2c7841f839987fef0117b18bfd374fe/comments", "author": null, "committer": null, "parents": [{"sha": "d2c5305bdbe4a625a341df26803cd475ffe2f478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c5305bdbe4a625a341df26803cd475ffe2f478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2c5305bdbe4a625a341df26803cd475ffe2f478"}], "stats": {"total": 377, "additions": 174, "deletions": 203}, "files": [{"sha": "6dc83940d52c989c51b2aab7b79464a9754b5ab2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8026246fa2c7841f839987fef0117b18bfd374fe", "patch": "@@ -1,5 +1,37 @@\n 2000-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (CLASSTYPE_VFIELDS): Move definition.\n+\t(BINFO_PRIMARY_MARKED_P): Use flag 5.\n+\t(SET_BINFO_PRIMARY_MARKED_P): Likewise.\n+\t(CLEAR_BINFO_PRIMARY_MARKED_P): Likewise.\n+\t(unmark_primary_bases): Remove declaration.\n+\t(unmarkedp): Declare.\n+\t(dfs_vbase_unmark): Likewise.\n+\t* class.c (determine_primary_base): Return immediately if there\n+\tare no base classes.  Call mark_primary_bases here.\n+\t(modify_all_direct_vtables): Remove.\n+\t(modify_all_indirect_vtables): Remove.\n+\t(dfs_modify_vtables_queue_p): New function.\t\n+\t(dfs_modify_vtables): New function.\n+\t(modify_all_vtables): Use them.\n+\t(build_base_fields): Build FIELD_DECLs for primary virtual base\n+\tclasses.\n+\t(create_vtable_ptr): Don't call determine_primary_base here.\n+\t(dfs_mark_primary_bases_and_set_vbase_offsets): Rename to ...\n+\t(dfs_set_offset_for_vbases): ... this.\n+\t(layout_virtual_bases): Use it.\n+\t(layout_class_type): Call determine_primary_base here.\n+\t* search.c (unmarkedp): Make it global.\n+\t(shared_marked_p): Simplify.\n+\t(shared_unmarked_p): Likewise.\n+\t(dfs_primary_bases_queue_p): Remove.\n+\t(dfs_unmark_primary_bases): Likewise.\n+\t(unmark_primary_bases): Likewise.\n+\t(mark_primary_bases): Simplify.\n+\t(get_pure_virtuals): Don't call mark_primary_bases here.\n+\t(dfs_vbase_unmark): New function.\n+\t(get_vbase_types): Simplify.\n+\n \t* class.c (struct base_info): Remove.\n \t(determine_primary_base): Take has_virtual_p rather than a\n \tbase_info as input.  Don't calculate max_has_virtual.\n@@ -9,7 +41,7 @@\n \t(layout_basetypes): Likewise.\n \t(layout_class_type): Remove max_has_virtual_p argument.\n \t(finish_struct_1): Remove max_has_virtual.\n-\t\n+\n \t* cp-tree.h (dfs_mark_primary_bases_queue_p): New function.\n \t(layout_basetypes): Remove.\n \t* class.c (propagate_binfo_offsets): Moved here from tree.c.\n@@ -145,7 +177,6 @@\n \t(build_vtbl_initializer): Likewise.\n \t(override_one_vtable): Likewise.\n \t(check_methods): Likewise.\n-\n \t* decl.c (duplicate_decls): Likewise.\n \t(redeclaration_error_message): Likewise.\n \t(lang_mark_tree): Likewise."}, {"sha": "0a8fbf7a620267367989675ddf3da39eece7e9d6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 89, "deletions": 110, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8026246fa2c7841f839987fef0117b18bfd374fe", "patch": "@@ -102,9 +102,9 @@ static void check_for_override PROTO((tree, tree));\n static tree get_class_offset_1 PROTO((tree, tree, tree, tree, tree));\n static tree get_class_offset PROTO((tree, tree, tree, tree));\n static void modify_one_vtable PROTO((tree, tree, tree));\n+static tree dfs_modify_vtables_queue_p PROTO((tree, void *));\n+static tree dfs_modify_vtables PROTO((tree, void *));\n static void modify_all_vtables PROTO((tree, tree));\n-static void modify_all_direct_vtables PROTO((tree, int, tree, tree));\n-static void modify_all_indirect_vtables PROTO((tree, int, int, tree, tree));\n static void determine_primary_base PROTO((tree, int *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n@@ -138,7 +138,7 @@ static void fixup_inline_methods PROTO((tree));\n static void set_primary_base PROTO((tree, int, int *));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static void layout_basetypes PROTO((tree));\n-static tree dfs_mark_primary_bases_and_set_vbase_offsets PROTO((tree, void *));\n+static tree dfs_set_offset_for_vbases PROTO((tree, void *));\n static void layout_virtual_bases PROTO((tree));\n static void remove_base_fields PROTO((tree));\n \n@@ -1651,6 +1651,10 @@ determine_primary_base (t, has_virtual_p)\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n+  /* If there are no baseclasses, there is certainly no primary base.  */\n+  if (n_baseclasses == 0)\n+    return;\n+\n   *has_virtual_p = 0;\n \n   for (i = 0; i < n_baseclasses; i++)\n@@ -1666,7 +1670,9 @@ determine_primary_base (t, has_virtual_p)\n \t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t    CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n \n-\t  /* A virtual baseclass can't be the primary base.  */\n+\t  /* A virtual baseclass can't be the primary base under the\n+\t     old ABI.  And under the new ABI we still prefer a\n+\t     non-virtual base.  */\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n \n@@ -1698,6 +1704,11 @@ determine_primary_base (t, has_virtual_p)\n \n   if (!TYPE_VFIELD (t))\n     CLASSTYPE_VFIELD_PARENT (t) = -1;\n+\n+  /* Now that we know what the primary base class is, we can run\n+     through the entire hierarchy marking the primary bases for future\n+     reference.  */\n+  mark_primary_bases (t);\n }\n \f\n /* Set memoizing fields and bits of T (and its variants) for later\n@@ -2479,29 +2490,63 @@ modify_one_vtable (binfo, t, fndecl)\n     }\n }\n \n-/* These are the ones that are not through virtual base classes.  */\n+/* Called from modify_all_vtables via dfs_walk.  */\n \n-static void\n-modify_all_direct_vtables (binfo, do_self, t, fndecl)\n+static tree\n+dfs_modify_vtables_queue_p (binfo, data)\n      tree binfo;\n-     int do_self;\n-     tree t, fndecl;\n+     void *data;\n {\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  tree list = (tree) data;\n \n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    modify_one_vtable (binfo, t, fndecl);\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n \n-  for (i = 0; i < n_baselinks; i++)\n+  return (TREE_ADDRESSABLE (list) \n+\t  ? markedp (binfo, NULL) \n+\t  : unmarkedp (binfo, NULL));\n+}\n+\n+/* Called from modify_all_vtables via dfs_walk.  */\n+\n+static tree\n+dfs_modify_vtables (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  if (/* There's no need to modify the vtable for a primary base;\n+\t we're not going to use that vtable anyhow.  */\n+      !BINFO_PRIMARY_MARKED_P (binfo)\n+      /* Similarly, a base without a vtable needs no modification.  */\n+      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tmodify_all_direct_vtables (base_binfo, is_not_base_vtable, t, fndecl);\n+      tree list = (tree) data;\n+\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\tbinfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n+      modify_one_vtable (binfo, TREE_PURPOSE (list), TREE_VALUE (list)); \n     }\n+\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+static void\n+modify_all_vtables (t, fndecl)\n+     tree t;\n+     tree fndecl;\n+{\n+  tree list;\n+\n+  list = build_tree_list (t, fndecl);\n+  dfs_walk (TYPE_BINFO (t), dfs_modify_vtables, dfs_modify_vtables_queue_p,\n+\t    list);\n+  /* Let dfs_modify_vtables_queue_p know to check that the mark is\n+     present before queueing a base, rather than checking to see that\n+     it is *not* present.  */\n+  TREE_ADDRESSABLE (list) = 1;\n+  dfs_walk (TYPE_BINFO (t), dfs_unmark, dfs_modify_vtables_queue_p, list);\n }\n \n /* Fixup all the delta entries in this one vtable that need updating.  */\n@@ -2595,47 +2640,6 @@ fixup_vtable_deltas (binfo, init_self, t)\n     fixup_vtable_deltas1 (binfo, t);\n }\n \n-/* These are the ones that are through virtual base classes.  */\n-\n-static void\n-modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl)\n-     tree binfo;\n-     int do_self, via_virtual;\n-     tree t, fndecl;\n-{\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (do_self && via_virtual && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    modify_one_vtable (binfo, t, fndecl);\n-\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  via_virtual = 1;\n-\t  base_binfo = BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), t);\n-\t}\n-      modify_all_indirect_vtables (base_binfo, is_not_base_vtable, via_virtual, t, fndecl);\n-    }\n-}\n-\n-static void\n-modify_all_vtables (t, fndecl)\n-     tree t;\n-     tree fndecl;\n-{\n-  /* Do these first, so that we will make use of any non-virtual class's\n-     vtable, over a virtual classes vtable.  */\n-  modify_all_direct_vtables (TYPE_BINFO (t), 1, t, fndecl);\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    modify_all_indirect_vtables (TYPE_BINFO (t), 1, 0, t, fndecl);\n-}\n-\n /* Here, we already know that they match in every respect.\n    All we have to check is where they had their declarations.  */\n \n@@ -3765,7 +3769,11 @@ build_base_fields (rec, empty_p)\n \t   location information.  */\n \tcontinue;\n \n-      if (TREE_VIA_VIRTUAL (base_binfo))\n+      /* A primary virtual base class is allocated just like any other\n+\t base class, but a non-primary virtual base is allocated\n+\t later, in layout_basetypes.  */\n+      if (TREE_VIA_VIRTUAL (base_binfo) \n+\t  && i != CLASSTYPE_VFIELD_PARENT (rec))\n \tcontinue;\n \n       decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n@@ -3998,12 +4006,6 @@ create_vtable_ptr (t, empty_p, has_virtual_p,\n {\n   tree fn;\n \n-  /* If possible, we reuse the virtual function table pointer from one\n-     of our base classes.  */\n-  if (CLASSTYPE_N_BASECLASSES (t))\n-    /* Remember where we got our vfield from.  */\n-    determine_primary_base (t, has_virtual_p);\n-\n   /* Loop over the virtual functions, adding them to our various\n      vtables.  */\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n@@ -4270,31 +4272,21 @@ remove_base_fields (t)\n /* Called via dfs_walk from layout_virtual_bases.  */\n \n static tree\n-dfs_mark_primary_bases_and_set_vbase_offsets (binfo, data)\n+dfs_set_offset_for_vbases (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+  /* If this is a primary virtual base that we have not encountered\n+     before, give it an offset.  */\n+  if (TREE_VIA_VIRTUAL (binfo) \n+      && BINFO_PRIMARY_MARKED_P (binfo)\n+      && !BINFO_MARKED (binfo))\n     {\n-      int i;\n-      tree base_binfo;\n-\n-      i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      base_binfo = BINFO_BASETYPE (binfo, i);\n-      \n-      /* If this is a virtual base class, and we've just now\n-\t discovered it to be a primary base, then reuse this copy as\n-\t the virtual base class for the complete object. */\n-      if (TREE_VIA_VIRTUAL (base_binfo)\n-\t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n-\t{\n-\t  tree vbase;\n-\n-\t  vbase = BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), (tree) data);\n-\t  BINFO_OFFSET (vbase) = BINFO_OFFSET (base_binfo);\n-\t}\n+      tree vbase;\n \n-      SET_BINFO_PRIMARY_MARKED_P (BINFO_BASETYPE (binfo, i));\n+      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), (tree) data);\n+      BINFO_OFFSET (vbase) = BINFO_OFFSET (binfo);\n+      SET_BINFO_VBASE_MARKED (binfo);\n     }\n \n   SET_BINFO_MARKED (binfo);\n@@ -4312,15 +4304,6 @@ layout_virtual_bases (t)\n   tree vbase;\n   int dsize;\n \n-  /* Mark the primary base classes.  Only virtual bases that are not\n-     also primary base classes need to be laid out (since otherwise we\n-     can just reuse one of the places in the hierarchy where the\n-     virtual base already occurs.)  */\n-  dfs_walk (TYPE_BINFO (t), \n-\t    dfs_mark_primary_bases_and_set_vbase_offsets,\n-\t    dfs_mark_primary_bases_queue_p, \n-\t    t);\n-\n   /* DSIZE is the size of the class without the virtual bases.  */\n   dsize = TREE_INT_CST_LOW (TYPE_SIZE (t));\n   /* Make every class have alignment of at least one.  */\n@@ -4349,27 +4332,19 @@ layout_virtual_bases (t)\n \t   take it's address and get something different for each base.  */\n \tdsize += MAX (BITS_PER_UNIT,\n \t\t      TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n-\n-\t/* Now that we've laid out this virtual base class, some of\n-\t   the remaining virtual bases might have been implicitly laid\n-\t   out as well -- they could be primary base classes of\n-\t   classes in BASETYPE.  */\n-\tdfs_walk (vbase,\n-\t\t  dfs_mark_primary_bases_and_set_vbase_offsets,\n-\t\t  dfs_mark_primary_bases_queue_p, \n-\t\t  t);\n       }\n \n-  /* We're done with the various marks, now, so clear them.  */\n-  unmark_primary_bases (t);\n-  dfs_walk (TYPE_BINFO (t), dfs_unmark, markedp, 0);\n-\n   /* Now, make sure that the total size of the type is a multiple of\n      its alignment.  */\n   dsize = CEIL (dsize, TYPE_ALIGN (t)) * TYPE_ALIGN (t);\n   TYPE_SIZE (t) = size_int (dsize);\n   TYPE_SIZE_UNIT (t) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n \t\t\t\t   size_int (BITS_PER_UNIT));\n+\n+  /* Run through the hierarchy now, setting up all the BINFO_OFFSETs\n+     for those virtual base classes that we did not allocate above.  */\n+  dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_vbases, unmarkedp, t);\n+  dfs_walk (TYPE_BINFO (t), dfs_vbase_unmark, markedp, NULL);\n }\n \n /* Finish the work of layout_record, now taking virtual bases into account.\n@@ -4431,6 +4406,10 @@ layout_class_type (t, empty_p, has_virtual_p,\n      tree *pending_virtuals_p;\n      tree *pending_hard_virtuals_p;\n {\n+  /* If possible, we reuse the virtual function table pointer from one\n+     of our base classes.  */\n+  determine_primary_base (t, has_virtual_p);\n+\n   /* Add pointers to all of our virtual base-classes.  */\n   TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, empty_p),\n \t\t\t     TYPE_FIELDS (t));"}, {"sha": "e5daa86505cd4597c654f25cace71ffc0844e861", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8026246fa2c7841f839987fef0117b18bfd374fe", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C++ parsing and type checking.\n-   Copyright (C) 1987, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 92-97, 1998, 1999, 2000 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1415,9 +1415,6 @@ struct lang_type\n #define BINFO_FOR_VBASE(T, C) \\\n   (binfo_member (T, CLASSTYPE_VBASECLASSES (C)))\n \n-/* The virtual function pointer fields that this type contains.  */\n-#define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC(NODE)->vfields)\n-\n /* Number of direct baseclasses of NODE.  */\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n@@ -1563,20 +1560,35 @@ struct lang_type\n #define CLEAR_BINFO_PUSHDECLS_MARKED(NODE) CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n \n /* Nonzero if this BINFO has been marked as a primary base class.  */\n-#define BINFO_PRIMARY_MARKED_P(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n+#define BINFO_PRIMARY_MARKED_P(NODE)\t\t\\\n+  (TREE_VIA_VIRTUAL (NODE) \t\t\t\\\n+   ? CLASSTYPE_MARKED5 (BINFO_TYPE (NODE))\t\\\n+   : TREE_LANG_FLAG_5 (NODE))\n \n /* Mark NODE as a primary base class.  */\n-#define SET_BINFO_PRIMARY_MARKED_P(NODE) SET_BINFO_VTABLE_PATH_MARKED (NODE)\n+#define SET_BINFO_PRIMARY_MARKED_P(NODE)\t\\\n+  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n+   ? SET_CLASSTYPE_MARKED5 (BINFO_TYPE (NODE))\t\\\n+   : (TREE_LANG_FLAG_5 (NODE) = 1))\n \n /* Clear the primary base class mark.  */\n-#define CLEAR_BINFO_PRIMARY_MARKED_P(NODE) \\\n-  CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n+#define CLEAR_BINFO_PRIMARY_MARKED_P(NODE) \t\t\\\n+  (TREE_VIA_VIRTUAL (NODE)\t\t\t\t\\\n+   ? CLEAR_CLASSTYPE_MARKED5 (BINFO_TYPE (NODE))\t\\\n+   : (TREE_LANG_FLAG_5 (NODE) = 0))\n \n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n /* Accessor macros for the vfield slots in structures.  */\n \n+/* The virtual function pointer fields that this type contains.  For a\n+   vfield defined just for this class, or from a primary base, the\n+   TREE_PURPOSE is NULL.  Otherwise, the TREE_PURPOSE is the BINFO for\n+   the class containing the vfield.  The TREE_VALUE is the class where\n+   the vfield was first defined.  */\n+#define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC(NODE)->vfields)\n+\n /* Get the assoc info that caused this vfield to exist.  */\n #define VF_BINFO_VALUE(NODE) TREE_PURPOSE (NODE)\n \n@@ -3908,10 +3920,11 @@ extern tree dfs_walk                            PROTO((tree,\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       void *));\n extern tree dfs_unmark                          PROTO((tree, void *));\n+extern tree dfs_vbase_unmark                    PROTO((tree, void *));\n extern tree markedp                             PROTO((tree, void *));\n+extern tree unmarkedp                           PROTO((tree, void *));\n extern tree dfs_mark_primary_bases_queue_p      PROTO((tree, void *));\n extern void mark_primary_bases                  PROTO((tree));\n-extern void unmark_primary_bases                PROTO((tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "130f9bf232f7da54024f1165ac62848b746c7535", "filename": "gcc/cp/search.c", "status": "modified", "additions": 30, "deletions": 82, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8026246fa2c7841f839987fef0117b18bfd374fe/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8026246fa2c7841f839987fef0117b18bfd374fe", "patch": "@@ -1,6 +1,6 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n-   Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92-97, 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -95,7 +95,6 @@ static void expand_upcast_fixups\n static void fixup_virtual_upcast_offsets\n \tPROTO((tree, tree, int, int, tree, tree, tree, tree,\n \t       tree *));\n-static tree unmarkedp PROTO((tree, void *));\n static tree marked_vtable_pathp PROTO((tree, void *));\n static tree unmarked_vtable_pathp PROTO((tree, void *));\n static tree marked_new_vtablep PROTO((tree, void *));\n@@ -152,7 +151,6 @@ static void setup_class_bindings PROTO ((tree, int));\n static int template_self_reference_p PROTO ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n static tree dfs_mark_primary_bases PROTO((tree, void *));\n-static tree dfs_unmark_primary_bases PROTO((tree, void *));\n \n /* Allocate a level of searching.  */\n \n@@ -777,7 +775,7 @@ shared_marked_p (binfo, data)\n      void *data;\n {\n   binfo = canonical_binfo (binfo);\n-  return markedp (binfo, data) ? binfo : NULL_TREE;\n+  return markedp (binfo, data);\n }\n \n /* If BINFO is not marked, return a canonical version of BINFO.\n@@ -789,7 +787,7 @@ shared_unmarked_p (binfo, data)\n      void *data;\n {\n   binfo = canonical_binfo (binfo);\n-  return unmarkedp (binfo, data) ? binfo : NULL_TREE;\n+  return unmarkedp (binfo, data);\n }\n \n /* Called from access_in_type via dfs_walk.  Calculate the access to\n@@ -2124,65 +2122,15 @@ dfs_mark_primary_bases (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Called via dfs_walk from mark_primary_bases.  */\n-\n-tree\n-dfs_mark_primary_bases_queue_p (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  /* Don't walk into virtual baseclasses that are not primary \n-     bases.  */\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree derived_class;\n-      tree primary_base;\n-      \n-      derived_class = BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo));\n-      primary_base = CLASSTYPE_PRIMARY_BINFO (derived_class);\n-      if (!primary_base || !same_type_p (BINFO_TYPE (primary_base),\n-\t\t\t\t\t BINFO_TYPE (binfo)))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* But do walk into everything else.  */\n-  return binfo;\n-}\n-\n /* Set BINFO_PRIMARY_MARKED_P for all binfos in the hierarchy\n-   dominated by TYPE that are primary bases.  (In addition,\n-   BINFO_MARKED is set for all classes in the hierarchy; callers\n-   should clear BINFO_MARKED.)  */\n+   dominated by BINFO that are primary bases.  */\n \n void\n mark_primary_bases (type)\n      tree type;\n {\n-  dfs_walk (TYPE_BINFO (type), \n-\t    dfs_mark_primary_bases,\n-\t    dfs_mark_primary_bases_queue_p,\n-\t    NULL);\n-}\n-\n-/* Called from unmark_primary_bases via dfs_walk.  */\n-\n-static tree\n-dfs_unmark_primary_bases (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  CLEAR_BINFO_PRIMARY_MARKED_P (binfo);\n-  return NULL_TREE;\n-}\n-\n-/* Clear BINFO_PRIMARY_MARKED_P for all binfo in the hierarchy\n-   dominated by TYPE.  */\n-\n-void\n-unmark_primary_bases (type)\n-     tree type;\n-{\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark_primary_bases, NULL, NULL);\n+  dfs_walk (TYPE_BINFO (type), dfs_mark_primary_bases, unmarkedp, NULL);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, NULL);\n }\n \n /* Called via dfs_walk from dfs_get_pure_virtuals.  */\n@@ -2219,8 +2167,8 @@ dfs_get_pure_virtuals (binfo, data)\n \t    = tree_cons (NULL_TREE, TREE_VALUE (virtuals),\n \t\t\t CLASSTYPE_PURE_VIRTUALS (type));\n     }\n-\n-  CLEAR_BINFO_MARKED (binfo);\n+  \n+  SET_BINFO_MARKED (binfo);\n \n   return NULL_TREE;\n }\n@@ -2236,17 +2184,15 @@ get_pure_virtuals (type)\n   /* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there\n      is going to be overridden.  */\n   CLASSTYPE_PURE_VIRTUALS (type) = NULL_TREE;\n-  /* Find all the primary bases.  */\n-  mark_primary_bases (type);\n   /* Now, run through all the bases which are not primary bases, and\n      collect the pure virtual functions.  We look at the vtable in\n      each class to determine what pure virtual functions are present.\n      (A primary base is not interesting because the derived class of\n      which it is a primary base will contain vtable entries for the\n      pure virtuals in the base class.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, markedp, type);\n-  /* Now, clear the BINFO_PRIMARY_MARKED_P bit.  */\n-  unmark_primary_bases (type);\n+  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, unmarkedp, type);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, 0);\n+\n   /* Put the pure virtuals in dfs order.  */\n   CLASSTYPE_PURE_VIRTUALS (type) = nreverse (CLASSTYPE_PURE_VIRTUALS (type));\n \n@@ -2317,14 +2263,15 @@ convert_pointer_to_single_level (to_type, expr)\n   return NULL_TREE;\n }\n \n-tree markedp (binfo, data) \n+tree \n+markedp (binfo, data) \n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n { \n   return BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n-static tree\n+tree\n unmarkedp (binfo, data) \n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n@@ -2415,6 +2362,17 @@ dfs_unmark (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Clear both BINFO_MARKED and BINFO_VBASE_MARKED.  */\n+\n+tree\n+dfs_vbase_unmark (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  CLEAR_BINFO_VBASE_MARKED (binfo);\n+  return dfs_unmark (binfo, data);\n+}\n+\n #if 0\n static void\n dfs_mark_vtable_path (binfo) tree binfo;\n@@ -2973,23 +2931,13 @@ void\n get_vbase_types (type)\n      tree type;\n {\n-  tree vbase_types;\n-  tree vbases;\n-  tree binfo;\n-\n-  binfo = TYPE_BINFO (type);\n-  vbase_types = NULL_TREE;\n-  dfs_walk (binfo, dfs_get_vbase_types, unmarkedp, &vbase_types);\n-  dfs_walk (binfo, dfs_unmark, markedp, 0);\n+  CLASSTYPE_VBASECLASSES (type) = NULL_TREE;\n+  dfs_walk (TYPE_BINFO (type), dfs_get_vbase_types, unmarkedp,\n+\t    &CLASSTYPE_VBASECLASSES (type));\n   /* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now\n      reverse it so that we get normal dfs ordering.  */\n-  vbase_types = nreverse (vbase_types);\n-\n-  /* unmark marked vbases */\n-  for (vbases = vbase_types; vbases; vbases = TREE_CHAIN (vbases))\n-    CLEAR_BINFO_VBASE_MARKED (vbases);\n-\n-  CLASSTYPE_VBASECLASSES (type) = vbase_types;\n+  CLASSTYPE_VBASECLASSES (type) = nreverse (CLASSTYPE_VBASECLASSES (type));\n+  dfs_walk (TYPE_BINFO (type), dfs_vbase_unmark, markedp, 0);\n }\n \f\n /* Debug info for C++ classes can get very large; try to avoid"}]}