{"sha": "f53aff92acef9d5291ffed72995adc33e91fa209", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUzYWZmOTJhY2VmOWQ1MjkxZmZlZDcyOTk1YWRjMzNlOTFmYTIwOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T08:34:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T08:34:48Z"}, "message": "Fix spurious No_Elaboration violation for Size attribute\n\nWe optimize the associated range check but nevertheless flag a violation.\n\ngcc/ada/\n\t* gcc-interface/trans.c (Call_to_gnu): Minor tweaks.\n\t(gnat_to_gnu_external): Likewise.\n\t(Raise_Error_to_gnu): Return an empty statement list if there is a\n\tcondition and it is always false.\n\t(gnat_to_gnu): Do not check for elaboration code a priori during the\n\ttranslation but a posteriori instead.", "tree": {"sha": "36eaab03e2c46a8416ee689e508a152e4d4a2e51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36eaab03e2c46a8416ee689e508a152e4d4a2e51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f53aff92acef9d5291ffed72995adc33e91fa209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53aff92acef9d5291ffed72995adc33e91fa209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f53aff92acef9d5291ffed72995adc33e91fa209", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53aff92acef9d5291ffed72995adc33e91fa209/comments", "author": null, "committer": null, "parents": [{"sha": "b1cd7461ecc4d6572b3984e889d59e6e5b651a5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cd7461ecc4d6572b3984e889d59e6e5b651a5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1cd7461ecc4d6572b3984e889d59e6e5b651a5f"}], "stats": {"total": 58, "additions": 30, "deletions": 28}, "files": [{"sha": "8ce0d8ac9e807cba57eae5a8af5d75699edc0421", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53aff92acef9d5291ffed72995adc33e91fa209/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53aff92acef9d5291ffed72995adc33e91fa209/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f53aff92acef9d5291ffed72995adc33e91fa209", "patch": "@@ -4471,8 +4471,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   tree gnu_after_list = NULL_TREE;\n   tree gnu_retval = NULL_TREE;\n   tree gnu_call, gnu_result;\n-  bool went_into_elab_proc = false;\n-  bool pushed_binding_level = false;\n+  bool went_into_elab_proc;\n+  bool pushed_binding_level;\n   bool variadic;\n   bool by_descriptor;\n   Entity_Id gnat_formal;\n@@ -4555,6 +4555,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       current_function_decl = get_elaboration_procedure ();\n       went_into_elab_proc = true;\n     }\n+  else\n+    went_into_elab_proc = false;\n \n   /* First, create the temporary for the return value when:\n \n@@ -4624,6 +4626,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       gnat_pushlevel ();\n       pushed_binding_level = true;\n     }\n+  else\n+    pushed_binding_level = false;\n \n   /* Create the list of the actual parameters as GCC expects it, namely a\n      chain of TREE_LIST nodes in which the TREE_VALUE field of each node\n@@ -6146,6 +6150,8 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t{\n \t  if (!gnu_cond)\n \t    gnu_cond = gnat_to_gnu (gnat_cond);\n+\t  if (integer_zerop (gnu_cond))\n+\t    return alloc_stmt_list ();\n \t  gnu_result = build3 (COND_EXPR, void_type_node, gnu_cond, gnu_result,\n \t\t\t       alloc_stmt_list ());\n \t}\n@@ -6271,12 +6277,12 @@ tree\n gnat_to_gnu (Node_Id gnat_node)\n {\n   const Node_Kind kind = Nkind (gnat_node);\n-  bool went_into_elab_proc = false;\n   tree gnu_result = error_mark_node; /* Default to no value.  */\n   tree gnu_result_type = void_type_node;\n   tree gnu_expr, gnu_lhs, gnu_rhs;\n   Node_Id gnat_temp;\n   atomic_acces_t aa_type;\n+  bool went_into_elab_proc;\n   bool aa_sync;\n \n   /* Save node number for error message and set location information.  */\n@@ -6308,32 +6314,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   build_call_raise (CE_Range_Check_Failed, gnat_node,\n \t\t\t\t     N_Raise_Constraint_Error));\n \n-  if ((statement_node_p (gnat_node) && kind != N_Null_Statement)\n-      || kind == N_Handled_Sequence_Of_Statements\n-      || kind == N_Implicit_Label_Declaration)\n+  /* If this is a statement and we are at top level, it must be part of the\n+     elaboration procedure, so mark us as being in that procedure.  */\n+  if ((statement_node_p (gnat_node)\n+       || kind == N_Handled_Sequence_Of_Statements\n+       || kind == N_Implicit_Label_Declaration)\n+      && !current_function_decl)\n     {\n-      tree current_elab_proc = get_elaboration_procedure ();\n-\n-      /* If this is a statement and we are at top level, it must be part of\n-\t the elaboration procedure, so mark us as being in that procedure.  */\n-      if (!current_function_decl)\n-\t{\n-\t  current_function_decl = current_elab_proc;\n-\t  went_into_elab_proc = true;\n-\t}\n-\n-      /* If we are in the elaboration procedure, check if we are violating a\n-\t No_Elaboration_Code restriction by having a statement there.  Don't\n-\t check for a possible No_Elaboration_Code restriction violation on\n-\t N_Handled_Sequence_Of_Statements, as we want to signal an error on\n-\t every nested real statement instead.  This also avoids triggering\n-\t spurious errors on dummy (empty) sequences created by the front-end\n-\t for package bodies in some cases.  */\n-      if (current_function_decl == current_elab_proc\n-\t  && kind != N_Handled_Sequence_Of_Statements\n-\t  && kind != N_Implicit_Label_Declaration)\n-\tCheck_Elaboration_Code_Allowed (gnat_node);\n+      current_function_decl = get_elaboration_procedure ();\n+      went_into_elab_proc = true;\n     }\n+  else\n+    went_into_elab_proc = false;\n \n   switch (kind)\n     {\n@@ -8235,6 +8227,14 @@ gnat_to_gnu (Node_Id gnat_node)\n       gcc_unreachable ();\n     }\n \n+  /* If we are in the elaboration procedure, check if we are violating the\n+     No_Elaboration_Code restriction by having a non-empty statement.  */\n+  if (statement_node_p (gnat_node)\n+      && !(TREE_CODE (gnu_result) == STATEMENT_LIST\n+\t   && empty_stmt_list_p (gnu_result))\n+      && current_function_decl == get_elaboration_procedure ())\n+    Check_Elaboration_Code_Allowed (gnat_node);\n+\n   /* If we pushed the processing of the elaboration routine, pop it back.  */\n   if (went_into_elab_proc)\n     current_function_decl = NULL_TREE;\n@@ -8423,7 +8423,7 @@ tree\n gnat_to_gnu_external (Node_Id gnat_node)\n {\n   const int save_force_global = force_global;\n-  bool went_into_elab_proc = false;\n+  bool went_into_elab_proc;\n \n   /* Force the local context and create a fake scope that we zap\n      at the end so declarations will not be stuck either in the\n@@ -8433,6 +8433,8 @@ gnat_to_gnu_external (Node_Id gnat_node)\n       current_function_decl = get_elaboration_procedure ();\n       went_into_elab_proc = true;\n     }\n+  else\n+    went_into_elab_proc = false;\n   force_global = 0;\n   gnat_pushlevel ();\n "}]}