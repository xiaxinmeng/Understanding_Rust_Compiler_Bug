{"sha": "e0040bc3d97f11063fe0a5156a2d27d36069fb34", "node_id": "C_kwDOANBUbNoAKGUwMDQwYmMzZDk3ZjExMDYzZmUwYTUxNTZhMmQyN2QzNjA2OWZiMzQ", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T17:21:12Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T17:21:12Z"}, "message": "Add finalize method to modref summary.\n\ngcc/ChangeLog:\n\n\t* ipa-modref.c (modref_summary::global_memory_read_p): Remove.\n\t(modref_summary::global_memory_written_p): Remove.\n\t(modref_summary::dump): Dump new flags.\n\t(modref_summary::finalize): New member function.\n\t(analyze_function): Call it.\n\t(read_section): Call it.\n\t(update_signature): Call it.\n\t(pass_ipa_modref::execute): Call it.\n\t* ipa-modref.h (struct modref_summary): Remove\n\tglobal_memory_read_p and global_memory_written_p.\n\tAdd global_memory_read, global_memory_written.\n\t* tree-ssa-structalias.c (determine_global_memory_access):\n\tUpdate.", "tree": {"sha": "77b1c7bb0aefa2331155ae41cc1117b65419ce01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77b1c7bb0aefa2331155ae41cc1117b65419ce01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0040bc3d97f11063fe0a5156a2d27d36069fb34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0040bc3d97f11063fe0a5156a2d27d36069fb34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0040bc3d97f11063fe0a5156a2d27d36069fb34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0040bc3d97f11063fe0a5156a2d27d36069fb34/comments", "author": null, "committer": null, "parents": [{"sha": "2af63f0f53a12a7275b99d92b271d3dff5112690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2af63f0f53a12a7275b99d92b271d3dff5112690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2af63f0f53a12a7275b99d92b271d3dff5112690"}], "stats": {"total": 65, "additions": 36, "deletions": 29}, "files": [{"sha": "84a32ecd32df94ff3a5e36627cd14b3e9cb02323", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0040bc3d97f11063fe0a5156a2d27d36069fb34/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0040bc3d97f11063fe0a5156a2d27d36069fb34/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=e0040bc3d97f11063fe0a5156a2d27d36069fb34", "patch": "@@ -276,7 +276,8 @@ static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n \n modref_summary::modref_summary ()\n   : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n-    writes_errno (false), side_effects (false)\n+    writes_errno (false), side_effects (false), global_memory_read (false),\n+    global_memory_written (false)\n {\n }\n \n@@ -339,26 +340,6 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n   return stores && !stores->every_base;\n }\n \n-/* Return true if global memory is read\n-   (that is loads summary contains global memory access).  */\n-bool\n-modref_summary::global_memory_read_p ()\n-{\n-  if (!loads)\n-    return true;\n-  return loads->global_access_p ();\n-}\n-\n-/* Return true if global memory is written.  */\n-bool\n-modref_summary::global_memory_written_p ()\n-{\n-  if (!stores)\n-    return true;\n-  return stores->global_access_p ();\n-}\n-\n-\n /* Single function summary used for LTO.  */\n \n typedef modref_tree <tree> modref_records_lto;\n@@ -621,6 +602,10 @@ modref_summary::dump (FILE *out)\n     fprintf (out, \"  Writes errno\\n\");\n   if (side_effects)\n     fprintf (out, \"  Side effects\\n\");\n+  if (global_memory_read)\n+    fprintf (out, \"  Global memory read\\n\");\n+  if (global_memory_written)\n+    fprintf (out, \"  Global memory written\\n\");\n   if (arg_flags.length ())\n     {\n       for (unsigned int i = 0; i < arg_flags.length (); i++)\n@@ -676,6 +661,15 @@ modref_summary_lto::dump (FILE *out)\n     }\n }\n \n+/* Called after summary is produced and before it is used by local analysis.\n+   Can be called multiple times in case summary needs to update signature.  */\n+void\n+modref_summary::finalize ()\n+{\n+  global_memory_read = !loads || loads->global_access_p ();\n+  global_memory_written = !stores || stores->global_access_p ();\n+}\n+\n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n \n modref_summary *\n@@ -2809,8 +2803,7 @@ analyze_function (function *f, bool ipa)\n \t  first = false;\n \t}\n     }\n-  if (summary && !summary->global_memory_written_p () && !summary->side_effects\n-      && !finite_function_p ())\n+  if (summary && !summary->side_effects && !finite_function_p ())\n     summary->side_effects = true;\n   if (summary_lto && !summary_lto->side_effects && !finite_function_p ())\n     summary_lto->side_effects = true;\n@@ -2838,6 +2831,8 @@ analyze_function (function *f, bool ipa)\n \tsummaries->remove (fnode);\n       summary = NULL;\n     }\n+  if (summary)\n+    summary->finalize ();\n   if (summary_lto && !summary_lto->useful_p (ecf_flags))\n     {\n       summaries_lto->remove (fnode);\n@@ -3557,6 +3552,8 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t      modref_read_escape_summary (&bp, e);\n \t    }\n \t}\n+      if (flag_ltrans)\n+\tmodref_sum->finalize ();\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Read modref for %s\\n\",\n@@ -3713,6 +3710,8 @@ update_signature (struct cgraph_node *node)\n       if (r_lto)\n \tr_lto->dump (dump_file);\n     }\n+  if (r)\n+    r->finalize ();\n   return;\n }\n \n@@ -4914,6 +4913,11 @@ pass_ipa_modref::execute (function *)\n \n       pureconst |= modref_propagate_in_scc (component_node);\n       modref_propagate_flags_in_scc (component_node);\n+      if (optimization_summaries)\n+\tfor (struct cgraph_node *cur = component_node; cur;\n+\t     cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n+\t  if (modref_summary *sum = optimization_summaries->get (cur))\n+\t    sum->finalize ();\n       if (dump_file)\n \tmodref_propagate_dump_scc (component_node);\n     }"}, {"sha": "9a8d565d7700c5cd820f14f74c47406040fb452c", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0040bc3d97f11063fe0a5156a2d27d36069fb34/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0040bc3d97f11063fe0a5156a2d27d36069fb34/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=e0040bc3d97f11063fe0a5156a2d27d36069fb34", "patch": "@@ -33,15 +33,18 @@ struct GTY(()) modref_summary\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;\n-  bool writes_errno;\n-  bool side_effects;\n+  unsigned writes_errno : 1;\n+  unsigned side_effects : 1;\n+  /* Flags coputed by finalize method.  */\n+  unsigned global_memory_read : 1;\n+  unsigned global_memory_written : 1;\n+\n \n   modref_summary ();\n   ~modref_summary ();\n   void dump (FILE *);\n   bool useful_p (int ecf_flags, bool check_flags = true);\n-  bool global_memory_read_p ();\n-  bool global_memory_written_p ();\n+  void finalize ();\n };\n \n modref_summary *get_modref_function_summary (cgraph_node *func);"}, {"sha": "6141e944b9fcb9f15b1a85c0ef26497e6a5fd306", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0040bc3d97f11063fe0a5156a2d27d36069fb34/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0040bc3d97f11063fe0a5156a2d27d36069fb34/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=e0040bc3d97f11063fe0a5156a2d27d36069fb34", "patch": "@@ -4262,9 +4262,9 @@ determine_global_memory_access (gcall *stmt,\n       && (summary = get_modref_function_summary (node)))\n     {\n       if (writes_global_memory && *writes_global_memory)\n-\t*writes_global_memory = summary->global_memory_written_p ();\n+\t*writes_global_memory = summary->global_memory_written;\n       if (reads_global_memory && *reads_global_memory)\n-\t*reads_global_memory = summary->global_memory_read_p ();\n+\t*reads_global_memory = summary->global_memory_read;\n       if (reads_global_memory && uses_global_memory\n \t  && !*reads_global_memory && node->binds_to_current_def_p ())\n \t*uses_global_memory = false;"}]}