{"sha": "c4274b22b9982dadb0df1caa103bce6018d232ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQyNzRiMjJiOTk4MmRhZGIwZGYxY2FhMTAzYmNlNjAxOGQyMzJjYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-01-17T02:34:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-17T02:34:04Z"}, "message": "dwarf2out.c (struct file_table): Remove.\n\n        * dwarf2out.c (struct file_table): Remove.\n        (FILE_TABLE_INCREMENT): Remove.\n        (file_table): Make a varray; mark for GC.  Update all users.\n        (file_table_last_lookup_index): Extract from struct file_table.\n        (output_file_names): Fix unsigned compare warnings.\n        (add_name_attribute): Remove inline marker.\n        (add_comp_dir_attribute): Split out from gen_compile_unit_die.\n        (lookup_filename): Don't manage size of file_table.\n        (init_file_table): Allocate file_table with GC.\n        (dwarf2out_init): Don't record main_input_filename here.\n        (dwarf2out_finish): Do it here instead.\n\nFrom-SVN: r61418", "tree": {"sha": "aaf925bd2db91a84ec56af9d16339ef1ba547d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaf925bd2db91a84ec56af9d16339ef1ba547d5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4274b22b9982dadb0df1caa103bce6018d232ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4274b22b9982dadb0df1caa103bce6018d232ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4274b22b9982dadb0df1caa103bce6018d232ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4274b22b9982dadb0df1caa103bce6018d232ca/comments", "author": null, "committer": null, "parents": [{"sha": "19162d0e2b2ed2caec713c39002b72d47ef5d5cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19162d0e2b2ed2caec713c39002b72d47ef5d5cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19162d0e2b2ed2caec713c39002b72d47ef5d5cb"}], "stats": {"total": 163, "additions": 88, "deletions": 75}, "files": [{"sha": "0d6d87b23265350318f62bb05dc1c620aa6bd0db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4274b22b9982dadb0df1caa103bce6018d232ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4274b22b9982dadb0df1caa103bce6018d232ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4274b22b9982dadb0df1caa103bce6018d232ca", "patch": "@@ -1,3 +1,17 @@\n+2003-01-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (struct file_table): Remove.\n+\t(FILE_TABLE_INCREMENT): Remove.\n+\t(file_table): Make a varray; mark for GC.  Update all users.\n+\t(file_table_last_lookup_index): Extract from struct file_table.\n+\t(output_file_names): Fix unsigned compare warnings.\n+\t(add_name_attribute): Remove inline marker.\n+\t(add_comp_dir_attribute): Split out from gen_compile_unit_die.\n+\t(lookup_filename): Don't manage size of file_table.\n+\t(init_file_table): Allocate file_table with GC.\n+\t(dwarf2out_init): Don't record main_input_filename here.\n+\t(dwarf2out_finish): Do it here instead.\n+\n 2003-01-16  Bruce Korb  <bkorb@gnu.org>\n \n \t* gcc/fixinc/inclhack.def(limits_ifndef): QNX needs a bypass, too."}, {"sha": "b2a043871951f29fda40d1c61aa8dbed00a7df93", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4274b22b9982dadb0df1caa103bce6018d232ca/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4274b22b9982dadb0df1caa103bce6018d232ca/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c4274b22b9982dadb0df1caa103bce6018d232ca", "patch": "@@ -3458,23 +3458,9 @@ static int is_main_source;\n /* A list of DIEs with a NULL parent waiting to be relocated.  */\n static GTY(()) limbo_die_node *limbo_die_list;\n \n-/* Structure used by lookup_filename to manage sets of filenames.  */\n-struct file_table\n-{\n-  char **table;\n-  unsigned allocated;\n-  unsigned in_use;\n-  unsigned last_lookup_index;\n-};\n-\n-/* Size (in elements) of increments by which we may expand the filename\n-   table.  */\n-#define FILE_TABLE_INCREMENT 64\n-\n-#ifdef DWARF2_DEBUGGING_INFO\n /* Filenames referenced by this compilation unit.  */\n-static struct file_table file_table;\n-#endif\n+static GTY(()) varray_type file_table;\n+static GTY(()) size_t file_table_last_lookup_index;\n \n /* A pointer to the base of a table of references to DIE's that describe\n    declarations.  The table is indexed by DECL_UID() which is a unique\n@@ -3789,6 +3775,7 @@ static rtx rtl_for_decl_location\tPARAMS ((tree));\n static void add_location_or_const_value_attribute PARAMS ((dw_die_ref, tree));\n static void tree_add_const_value_attribute PARAMS ((dw_die_ref, tree));\n static void add_name_attribute\t\tPARAMS ((dw_die_ref, const char *));\n+static void add_comp_dir_attribute\tPARAMS ((dw_die_ref));\n static void add_bound_info\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute, tree));\n static void add_subscript_info\t\tPARAMS ((dw_die_ref, tree));\n@@ -5452,7 +5439,8 @@ print_dwarf_line_table (outfile)\n     {\n       line_info = &line_info_table[i];\n       fprintf (outfile, \"%5d: \", i);\n-      fprintf (outfile, \"%-20s\", file_table.table[line_info->dw_file_num]);\n+      fprintf (outfile, \"%-20s\",\n+\t       VARRAY_CHAR_PTR (file_table, line_info->dw_file_num));\n       fprintf (outfile, \"%6ld\", line_info->dw_line_num);\n       fprintf (outfile, \"\\n\");\n     }\n@@ -7298,24 +7286,24 @@ output_file_names ()\n   int *saved;\n   int *savehere;\n   int *backmap;\n-  int ndirs;\n+  size_t ndirs;\n   int idx_offset;\n-  int i;\n+  size_t i;\n   int idx;\n \n   /* Allocate the various arrays we need.  */\n-  files = (struct file_info *) alloca (file_table.in_use\n+  files = (struct file_info *) alloca (VARRAY_ACTIVE_SIZE (file_table)\n \t\t\t\t       * sizeof (struct file_info));\n-  dirs = (struct dir_info *) alloca (file_table.in_use\n+  dirs = (struct dir_info *) alloca (VARRAY_ACTIVE_SIZE (file_table)\n \t\t\t\t     * sizeof (struct dir_info));\n \n   /* Sort the file names.  */\n-  for (i = 1; i < (int) file_table.in_use; i++)\n+  for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n     {\n       char *f;\n \n       /* Skip all leading \"./\".  */\n-      f = file_table.table[i];\n+      f = VARRAY_CHAR_PTR (file_table, i);\n       while (f[0] == '.' && f[1] == '/')\n \tf += 2;\n \n@@ -7329,7 +7317,8 @@ output_file_names ()\n       files[i].fname = f == NULL ? files[i].path : f + 1;\n     }\n \n-  qsort (files + 1, file_table.in_use - 1, sizeof (files[0]), file_info_cmp);\n+  qsort (files + 1, VARRAY_ACTIVE_SIZE (file_table) - 1,\n+\t sizeof (files[0]), file_info_cmp);\n \n   /* Find all the different directories used.  */\n   dirs[0].path = files[1].path;\n@@ -7341,7 +7330,7 @@ output_file_names ()\n   files[1].dir_idx = 0;\n   ndirs = 1;\n \n-  for (i = 2; i < (int) file_table.in_use; i++)\n+  for (i = 2; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n     if (files[i].fname - files[i].path == dirs[ndirs - 1].length\n \t&& memcmp (dirs[ndirs - 1].path, files[i].path,\n \t\t   dirs[ndirs - 1].length) == 0)\n@@ -7352,7 +7341,7 @@ output_file_names ()\n       }\n     else\n       {\n-\tint j;\n+\tsize_t j;\n \n \t/* This is a new directory.  */\n \tdirs[ndirs].path = files[i].path;\n@@ -7387,7 +7376,7 @@ output_file_names ()\n   memset (saved, '\\0', ndirs * sizeof (saved[0]));\n   for (i = 0; i < ndirs; i++)\n     {\n-      int j;\n+      size_t j;\n       int total;\n \n       /* We can always save some space for the current directory.  But this\n@@ -7405,10 +7394,10 @@ output_file_names ()\n \t      int k;\n \n \t      k = dirs[j].prefix;\n-\t      while (k != -1 && k != i)\n+\t      while (k != -1 && k != (int) i)\n \t\tk = dirs[k].prefix;\n \n-\t      if (k == i)\n+\t      if (k == (int) i)\n \t\t{\n \t\t  /* Yes it is.  We can possibly safe some memory but\n \t\t     writing the filenames in dirs[j] relative to\n@@ -7439,8 +7428,8 @@ output_file_names ()\n   /* We have to emit them in the order they appear in the file_table array\n      since the index is used in the debug info generation.  To do this\n      efficiently we generate a back-mapping of the indices first.  */\n-  backmap = (int *) alloca (file_table.in_use * sizeof (int));\n-  for (i = 1; i < (int) file_table.in_use; i++)\n+  backmap = (int *) alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (int));\n+  for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n     {\n       backmap[files[i].file_idx] = i;\n \n@@ -7471,7 +7460,7 @@ output_file_names ()\n     dirs[0].used = 0;\n \n   /* Now write all the file names.  */\n-  for (i = 1; i < (int) file_table.in_use; i++)\n+  for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n     {\n       int file_idx = backmap[i];\n       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n@@ -7630,7 +7619,8 @@ output_line_info ()\n \t  current_file = line_info->dw_file_num;\n \t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n \t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n-\t\t\t\t       file_table.table[current_file]);\n+\t\t\t\t       VARRAY_CHAR_PTR (file_table,\n+\t\t\t\t\t\t\tcurrent_file));\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -7738,7 +7728,8 @@ output_line_info ()\n \t  current_file = line_info->dw_file_num;\n \t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n \t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n-\t\t\t\t       file_table.table[current_file]);\n+\t\t\t\t       VARRAY_CHAR_PTR (file_table,\n+\t\t\t\t\t\t\tcurrent_file));\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -9602,7 +9593,7 @@ tree_add_const_value_attribute (var_die, decl)\n /* Generate an DW_AT_name attribute given some string value to be included as\n    the value of the attribute.  */\n \n-static inline void\n+static void\n add_name_attribute (die, name_string)\n      dw_die_ref die;\n      const char *name_string;\n@@ -9616,6 +9607,17 @@ add_name_attribute (die, name_string)\n     }\n }\n \n+/* Generate an DW_AT_comp_dir attribute for DIE.  */\n+\n+static void\n+add_comp_dir_attribute (die)\n+     dw_die_ref die;\n+{\n+  const char *wd = getpwd ();\n+  if (wd != NULL)\n+    add_AT_string (die, DW_AT_comp_dir, wd);\n+}\n+\n /* Given a tree node describing an array bound (either lower or upper) output\n    a representation for that bound.  */\n \n@@ -11294,15 +11296,17 @@ gen_compile_unit_die (filename)\n {\n   dw_die_ref die;\n   char producer[250];\n-  const char *wd = getpwd ();\n   const char *language_string = lang_hooks.name;\n   int language;\n \n   die = new_die (DW_TAG_compile_unit, NULL, NULL);\n-  add_name_attribute (die, filename);\n \n-  if (wd != NULL && filename[0] != DIR_SEPARATOR)\n-    add_AT_string (die, DW_AT_comp_dir, wd);\n+  if (filename)\n+    {\n+      add_name_attribute (die, filename);\n+      if (filename[0] != DIR_SEPARATOR)\n+\tadd_comp_dir_attribute (die);\n+    }\n \n   sprintf (producer, \"%s %s\", language_string, version_string);\n \n@@ -12310,7 +12314,8 @@ static unsigned\n lookup_filename (file_name)\n      const char *file_name;\n {\n-  unsigned i;\n+  size_t i, n;\n+  char *save_file_name;\n \n   /* ??? Why isn't DECL_SOURCE_FILE left null instead.  */\n   if (strcmp (file_name, \"<internal>\") == 0\n@@ -12319,34 +12324,27 @@ lookup_filename (file_name)\n \n   /* Check to see if the file name that was searched on the previous\n      call matches this file name.  If so, return the index.  */\n-  if (file_table.last_lookup_index != 0)\n-    if (0 == strcmp (file_name,\n-\t\t     file_table.table[file_table.last_lookup_index]))\n-      return file_table.last_lookup_index;\n+  if (file_table_last_lookup_index != 0)\n+    {\n+      const char *last\n+\t= VARRAY_CHAR_PTR (file_table, file_table_last_lookup_index);\n+      if (strcmp (file_name, last) == 0)\n+        return file_table_last_lookup_index;\n+    }\n \n   /* Didn't match the previous lookup, search the table */\n-  for (i = 1; i < file_table.in_use; i++)\n-    if (strcmp (file_name, file_table.table[i]) == 0)\n+  n = VARRAY_ACTIVE_SIZE (file_table);\n+  for (i = 1; i < n; i++)\n+    if (strcmp (file_name, VARRAY_CHAR_PTR (file_table, i)) == 0)\n       {\n-\tfile_table.last_lookup_index = i;\n+\tfile_table_last_lookup_index = i;\n \treturn i;\n       }\n \n-  /* Prepare to add a new table entry by making sure there is enough space in\n-     the table to do so.  If not, expand the current table.  */\n-  if (i == file_table.allocated)\n-    {\n-      file_table.allocated = i + FILE_TABLE_INCREMENT;\n-      file_table.table = (char **)\n-\txrealloc (file_table.table, file_table.allocated * sizeof (char *));\n-      memset (file_table.table + i, 0,\n-\t      FILE_TABLE_INCREMENT * sizeof (char *));\n-    }\n-\n   /* Add the new entry to the end of the filename table.  */\n-  file_table.table[i] = xstrdup (file_name);\n-  file_table.in_use = i + 1;\n-  file_table.last_lookup_index = i;\n+  file_table_last_lookup_index = n;\n+  save_file_name = (char *) ggc_strdup (file_name);\n+  VARRAY_PUSH_CHAR_PTR (file_table, save_file_name);\n \n   if (DWARF2_ASM_LINE_DEBUG_INFO)\n     {\n@@ -12362,12 +12360,11 @@ static void\n init_file_table ()\n {\n   /* Allocate the initial hunk of the file_table.  */\n-  file_table.table = (char **) xcalloc (FILE_TABLE_INCREMENT, sizeof (char *));\n-  file_table.allocated = FILE_TABLE_INCREMENT;\n+  VARRAY_CHAR_PTR_INIT (file_table, 64, \"file_table\");\n \n   /* Skip the first entry - file numbers begin at 1.  */\n-  file_table.in_use = 1;\n-  file_table.last_lookup_index = 0;\n+  VARRAY_PUSH_CHAR_PTR (file_table, NULL);\n+  file_table_last_lookup_index = 0;\n }\n \n /* Output a label to mark the beginning of a source code line entry\n@@ -12544,16 +12541,11 @@ dwarf2out_undef (lineno, buffer)\n /* Set up for Dwarf output at the start of compilation.  */\n \n static void\n-dwarf2out_init (main_input_filename)\n-     const char *main_input_filename;\n+dwarf2out_init (input_filename)\n+     const char *input_filename ATTRIBUTE_UNUSED;\n {\n   init_file_table ();\n \n-  /* Add the name of the primary input file to the file table first,\n-     under the assumption that we'll be emitting line number data for\n-     it first, which avoids having to add an initial DW_LNS_set_file.  */\n-  lookup_filename (main_input_filename);\n-\n   /* Allocate the initial hunk of the decl_die_table.  */\n   decl_die_table = ggc_alloc_cleared (DECL_DIE_TABLE_INCREMENT \n \t\t\t\t      * sizeof (dw_die_ref));\n@@ -12582,8 +12574,9 @@ dwarf2out_init (main_input_filename)\n      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n      will (typically) be a relative pathname and that this pathname should be\n      taken as being relative to the directory from which the compiler was\n-     invoked when the given (base) source file was compiled.  */\n-  comp_unit_die = gen_compile_unit_die (main_input_filename);\n+     invoked when the given (base) source file was compiled.  We will fill\n+     in this value in dwarf2out_finish.  */\n+  comp_unit_die = gen_compile_unit_die (NULL);\n   is_main_source = 1;\n \n   VARRAY_TREE_INIT (incomplete_types, 64, \"incomplete_types\");\n@@ -12651,11 +12644,17 @@ output_indirect_string (h, v)\n \n static void\n dwarf2out_finish (input_filename)\n-     const char *input_filename ATTRIBUTE_UNUSED;\n+     const char *input_filename;\n {\n   limbo_die_node *node, *next_node;\n   dw_die_ref die = 0;\n \n+  /* Add the name for the main input file now.  We delayed this from\n+     dwarf2out_init to avoid complications with PCH.  */\n+  add_name_attribute (comp_unit_die, input_filename);\n+  if (input_filename[0] != DIR_SEPARATOR)\n+    add_comp_dir_attribute (comp_unit_die);\n+\n   /* Traverse the limbo die list, and add parent/child links.  The only\n      dies without parents that should be here are concrete instances of\n      inline functions, and the comp_unit_die.  We can ignore the comp_unit_die."}]}