{"sha": "ecb0eecefbd769b20dc9842fb0881db7492ec225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiMGVlY2VmYmQ3NjliMjBkYzk4NDJmYjA4ODFkYjc0OTJlYzIyNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-03-15T07:11:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-15T07:11:14Z"}, "message": "c-decl.c: Include c-pragma.h.\n\n        * c-decl.c: Include c-pragma.h.\n        (start_decl, start_function): Invoke maybe_apply_pragma_weak.\n        (finish_function): Tidy.\n        * c-pragma.c: Include c-common.h.\n        (pending_weaks, apply_pragma_weak, maybe_apply_pragma_weak): New.\n        (handle_pragma_weak): Use them.\n        (init_pragma): Register pending_weaks.\n        * c-pragma.h (maybe_apply_pragma_weak): Declare.\n        * print-tree.c (print_node): Print DECL_WEAK.\n        * varasm.c (mark_weak_decls): Remove.\n        (remove_from_pending_weak_list): Remove.\n        (add_weak): Remove.\n        (asm_emit_uninitialised): Call globalize_decl for weak commons.\n        (weak_decls): Make a tree_list.\n        (declare_weak): Cons weak_decls directly.\n        (globalize_decl): Remove weak_decls elements directly.\n        (weak_finish): Simplify weak_decls walk.  Don't weaken unused\n        symbols.  Don't pretend to handle aliases.\n        (init_varasm_once): Update weak_decls registry.\n\t* Makefile.in: Update dependencies.\n\n        * cp/decl.c: Include c-pragma.h.\n        (start_decl, start_function): Invoke maybe_apply_pragma_weak.\n\t* cp/Make-lang.in: Update dependencies.\n\n\t* gcc.dg/weak-1.c: New.\n\nFrom-SVN: r50797", "tree": {"sha": "a4832f691fe7468c7db7811469b930a129616f84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4832f691fe7468c7db7811469b930a129616f84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecb0eecefbd769b20dc9842fb0881db7492ec225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb0eecefbd769b20dc9842fb0881db7492ec225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb0eecefbd769b20dc9842fb0881db7492ec225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb0eecefbd769b20dc9842fb0881db7492ec225/comments", "author": null, "committer": null, "parents": [{"sha": "98d2b17e0c941e8e60055d10b36e2ceef522be92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d2b17e0c941e8e60055d10b36e2ceef522be92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d2b17e0c941e8e60055d10b36e2ceef522be92"}], "stats": {"total": 325, "additions": 210, "deletions": 115}, "files": [{"sha": "a1f9c16f4203827c0ba03a6d4c81b5fbe5e7d0bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -1,3 +1,26 @@\n+2002-03-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-decl.c: Include c-pragma.h.\n+\t(start_decl, start_function): Invoke maybe_apply_pragma_weak.\n+\t(finish_function): Tidy.\n+\t* c-pragma.c: Include c-common.h.\n+\t(pending_weaks, apply_pragma_weak, maybe_apply_pragma_weak): New.\n+\t(handle_pragma_weak): Use them.\n+\t(init_pragma): Register pending_weaks.\n+\t* c-pragma.h (maybe_apply_pragma_weak): Declare.\n+\t* print-tree.c (print_node): Print DECL_WEAK.\n+\t* varasm.c (mark_weak_decls): Remove.\n+\t(remove_from_pending_weak_list): Remove.\n+\t(add_weak): Remove.\n+\t(asm_emit_uninitialised): Call globalize_decl for weak commons.\n+\t(weak_decls): Make a tree_list.\n+\t(declare_weak): Cons weak_decls directly.\n+\t(globalize_decl): Remove weak_decls elements directly.\n+\t(weak_finish): Simplify weak_decls walk.  Don't weaken unused\n+\tsymbols.  Don't pretend to handle aliases.\n+\t(init_varasm_once): Update weak_decls registry.\n+\t* Makefile.in: Update dependencies.\n+\n 2002-03-14  Richard Henderson  <rth@redhat.com>\n \n \tPR target/5312"}, {"sha": "df8281f945e52796f210fbce499a6ca12118d4a1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -1148,7 +1148,7 @@ $(srcdir)/c-parse.y: c-parse.in\n \n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) $(C_TREE_H) \\\n     $(GGC_H) $(TARGET_H) c-lex.h flags.h function.h output.h $(EXPR_H) \\\n-    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H)\n+    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n@@ -1165,7 +1165,7 @@ c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     flags.h toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h toplev.h\n c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) function.h \\\n-    c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H)\n+    c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) $(C_COMMON_H)\n mbchar.o: mbchar.c $(CONFIG_H) $(SYSTEM_H) mbchar.h\n graph.o: graph.c $(CONFIG_H) $(SYSTEM_H) toplev.h flags.h output.h $(RTL_H) \\\n     function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h"}, {"sha": "9242b03b3f996a74304c1f5ccba1e645eed377ef", "filename": "gcc/c-decl.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -46,6 +46,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"debug.h\"\n #include \"timevar.h\"\n #include \"c-common.h\"\n+#include \"c-pragma.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -3403,6 +3404,10 @@ start_decl (declarator, declspecs, initialized, attributes)\n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n   decl_attributes (&decl, attributes, 0);\n \n+  /* If #pragma weak was used, mark the decl weak now.  */\n+  if (current_binding_level == global_binding_level)\n+    maybe_apply_pragma_weak (decl);\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n@@ -6042,6 +6047,10 @@ start_function (declspecs, declarator, attributes)\n \n   decl_attributes (&decl1, attributes, 0);\n \n+  /* If #pragma weak was used, mark the decl weak now.  */\n+  if (current_binding_level == global_binding_level)\n+    maybe_apply_pragma_weak (decl1);\n+\n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl1)))\n@@ -6691,9 +6700,11 @@ finish_function (nested)\n {\n   tree fndecl = current_function_decl;\n \n-/*  TREE_READONLY (fndecl) = 1;\n-    This caused &foo to be of type ptr-to-const-function\n-    which then got a warning when stored in a ptr-to-function variable.  */\n+#if 0\n+  /* This caused &foo to be of type ptr-to-const-function which then\n+     got a warning when stored in a ptr-to-function variable.  */\n+  TREE_READONLY (fndecl) = 1;\n+#endif\n \n   poplevel (1, 0, 1);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n@@ -6755,6 +6766,7 @@ finish_function (nested)\n     {\n       /* Generate RTL for the body of this function.  */\n       c_expand_body (fndecl, nested, 1);\n+\n       /* Let the error reporting routines know that we're outside a\n \t function.  For a nested function, this value is used in\n \t pop_c_function_context and then reset via pop_function_context.  */"}, {"sha": "1a17e67f1c51cd81ee865e5b864b4db7dd84bbb6", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"ggc.h\"\n #include \"c-lex.h\"\n+#include \"c-common.h\"\n #include \"output.h\"\n #include \"tm_p.h\"\n \n@@ -55,9 +56,9 @@ static struct align_stack * alignment_stack = NULL;\n    maximum_field_alignment in effect.  When the final pop_alignment() \n    happens, we restore the value to this, not to a value of 0 for\n    maximum_field_alignment.  Value is in bits.  */\n-static int  default_alignment;\n+static int default_alignment;\n #define SET_GLOBAL_ALIGNMENT(ALIGN) \\\n-(default_alignment = maximum_field_alignment = (ALIGN))\n+  (default_alignment = maximum_field_alignment = (ALIGN))\n \n static void push_alignment PARAMS ((int, tree));\n static void pop_alignment  PARAMS ((tree));\n@@ -69,7 +70,6 @@ push_alignment (alignment, id)\n      int alignment;\n      tree id;\n {\n-  \n   if (alignment_stack == NULL\n       || alignment_stack->alignment != alignment\n       || id != NULL_TREE)\n@@ -274,14 +274,53 @@ handle_pragma_pack (dummy)\n #endif  /* HANDLE_PRAGMA_PACK */\n \n #ifdef HANDLE_PRAGMA_WEAK\n+static void apply_pragma_weak PARAMS ((tree, tree));\n static void handle_pragma_weak PARAMS ((cpp_reader *));\n \n+static tree pending_weaks;\n+\n+static void\n+apply_pragma_weak (decl, value)\n+     tree decl, value;\n+{\n+  if (value)\n+    decl_attributes (&decl, build_tree_list (get_identifier (\"alias\"),\n+\t\t\t\t             build_tree_list (NULL, value)),\n+\t\t     0);\n+  declare_weak (decl);\n+}\n+\n+void\n+maybe_apply_pragma_weak (decl)\n+     tree decl;\n+{\n+  tree *p, t, id;\n+\n+  /* Copied from the check in set_decl_assembler_name.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      || (TREE_CODE (decl) == VAR_DECL \n+          && (TREE_STATIC (decl) \n+              || DECL_EXTERNAL (decl) \n+              || TREE_PUBLIC (decl))))\n+    id = DECL_ASSEMBLER_NAME (decl);\n+  else\n+    return;\n+\n+  for (p = &pending_weaks; (t = *p) ; p = &TREE_CHAIN (t))\n+    if (id == TREE_PURPOSE (t))\n+      {\n+\tapply_pragma_weak (decl, TREE_VALUE (t));\n+\t*p = TREE_CHAIN (t);\n+\tbreak;\n+      }\n+}\n+\n /* #pragma weak name [= value] */\n static void\n handle_pragma_weak (dummy)\n      cpp_reader *dummy ATTRIBUTE_UNUSED;\n {\n-  tree name, value, x;\n+  tree name, value, x, decl;\n   enum cpp_ttype t;\n \n   value = 0;\n@@ -298,10 +337,19 @@ handle_pragma_weak (dummy)\n   if (t != CPP_EOF)\n     warning (\"junk at end of #pragma weak\");\n \n-  add_weak (NULL_TREE, IDENTIFIER_POINTER (name),\n-\t    value ? IDENTIFIER_POINTER (value) : NULL);\n+  decl = identifier_global_value (name);\n+  if (decl && TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+    apply_pragma_weak (decl, value);\n+  else\n+    pending_weaks = tree_cons (name, value, pending_weaks);\n }\n-#endif\n+#else\n+void\n+maybe_apply_pragma_weak (decl)\n+     tree decl ATTRIBUTE_UNUSED;\n+{\n+}\n+#endif /* HANDLE_PRAGMA_WEAK */\n \n void\n init_pragma ()\n@@ -311,6 +359,7 @@ init_pragma ()\n #endif\n #ifdef HANDLE_PRAGMA_WEAK\n   cpp_register_pragma (parse_in, 0, \"weak\", handle_pragma_weak);\n+  ggc_add_tree_root (&pending_weaks, 1);\n #endif\n #ifdef REGISTER_TARGET_PRAGMAS\n   REGISTER_TARGET_PRAGMAS (parse_in);"}, {"sha": "ea5a9826d6149f0b6315be7c779bc2a63dfdd8ff", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -53,4 +53,6 @@ extern void cpp_register_pragma PARAMS ((cpp_reader *,\n \t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n #endif\n \n+extern void maybe_apply_pragma_weak PARAMS ((tree));\n+\n #endif /* GCC_C_PRAGMA_H */"}, {"sha": "2c9b1e55df235156b72ba10189f7f0cf323c2d83", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -1,3 +1,9 @@\n+2002-03-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c: Include c-pragma.h.\n+\t(start_decl, start_function): Invoke maybe_apply_pragma_weak.\n+\t* Make-lang.in: Update dependencies.\n+\n 2002-03-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/5908"}, {"sha": "a4e8299382e8bf2a77ce925adb55339a762d9b53", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -255,7 +255,7 @@ cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) toplev.h langhooks.h langhooks-def.h \\\n   c-common.h\n cp/decl.o: cp/decl.c $(CXX_TREE_H) flags.h cp/lex.h cp/decl.h stack.h \\\n   output.h $(EXPR_H) except.h toplev.h hash.h $(GGC_H) $(RTL_H) \\\n-  cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h\n+  cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(GGC_H) $(RTL_H)\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) flags.h toplev.h output.h $(TM_P_H) \\"}, {"sha": "a1f128ff95c87902d987cf144b1ba5250a43566a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"c-common.h\"\n+#include \"c-pragma.h\"\n #include \"diagnostic.h\"\n \n extern const struct attribute_spec *lang_attribute_table;\n@@ -7256,6 +7257,10 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n   cplus_decl_attributes (&decl, attributes, 0);\n \n+  /* If #pragma weak was used, mark the decl weak now.  */\n+  if (current_binding_level == global_binding_level)\n+    maybe_apply_pragma_weak (decl);\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n@@ -13476,6 +13481,10 @@ start_function (declspecs, declarator, attrs, flags)\n \n       cplus_decl_attributes (&decl1, attrs, 0);\n \n+      /* If #pragma weak was used, mark the decl weak now.  */\n+      if (current_binding_level == global_binding_level)\n+\tmaybe_apply_pragma_weak (decl1);\n+\n       fntype = TREE_TYPE (decl1);\n \n       restype = TREE_TYPE (fntype);"}, {"sha": "f5c7d88c1f618b32b44be194e6bf2991559e2606", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -317,6 +317,8 @@ print_node (file, prefix, node, indent)\n \tfputs (\" common\", file);\n       if (DECL_EXTERNAL (node))\n \tfputs (\" external\", file);\n+      if (DECL_WEAK (node))\n+\tfputs (\" weak\", file);\n       if (DECL_REGISTER (node) && TREE_CODE (node) != FIELD_DECL\n \t  && TREE_CODE (node) != FUNCTION_DECL\n \t  && TREE_CODE (node) != LABEL_DECL)"}, {"sha": "95e56f098a6491b7a7e1aed81da24d0b82d2cdae", "filename": "gcc/testsuite/gcc.dg/weak-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Ftestsuite%2Fgcc.dg%2Fweak-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Ftestsuite%2Fgcc.dg%2Fweak-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fweak-1.c?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* COFF does not support weak, and dg doesn't support UNSUPPORTED.  */\n+/* { dg-do compile { xfail *-*-coff i?86-pc-cygwin } } */\n+\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?a\" } } */\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?b\" } } */\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?c\" } } */\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?d\" } } */\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?e\" } } */\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?g\" } } */\n+/* { dg-final { scan-assembler-not \"weak[^ \t]*[ \t]_?i\" } } */\n+/* { dg-final { scan-assembler \"weak[^ \t]*[ \t]_?j\" } } */\n+\n+#pragma weak a\n+int a;\n+\n+int b;\n+#pragma weak b\n+\n+#pragma weak c\n+extern int c;\n+int c;\n+\n+extern int d;\n+#pragma weak d\n+int d;\n+\n+#pragma weak e\n+void e(void) { }\n+\n+#if 0\n+/* This permutation is illegal.  */\n+void f(void) { }\n+#pragma weak f\n+#endif\n+\n+#pragma weak g\n+int g = 1;\n+\n+#if 0\n+/* This permutation is illegal.  */\n+int h = 1;\n+#pragma weak h\n+#endif\n+\n+#pragma weak i\n+extern int i;\n+\n+#pragma weak j\n+extern int j;\n+int use_j() { return j; }"}, {"sha": "06ee8b82db9b2f3be9a8366bebb4147095820a6c", "filename": "gcc/varasm.c", "status": "modified", "additions": 43, "deletions": 102, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb0eecefbd769b20dc9842fb0881db7492ec225/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ecb0eecefbd769b20dc9842fb0881db7492ec225", "patch": "@@ -167,10 +167,6 @@ static unsigned HOST_WIDE_INT array_size_for_constructor PARAMS ((tree));\n static unsigned min_align\t\tPARAMS ((unsigned, unsigned));\n static void output_constructor\t\tPARAMS ((tree, HOST_WIDE_INT,\n \t\t\t\t\t\t unsigned int));\n-static void mark_weak_decls\t\tPARAMS ((void *));\n-#if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)\n-static void remove_from_pending_weak_list\tPARAMS ((const char *));\n-#endif\n static void globalize_decl\t\tPARAMS ((tree));\n static void maybe_assemble_visibility\tPARAMS ((tree));\n static int in_named_entry_eq\t\tPARAMS ((const PTR, const PTR));\n@@ -1399,6 +1395,17 @@ asm_emit_uninitialised (decl, name, size, rounded)\n \tdestination = asm_dest_common;\n     }\n \n+  switch (destination)\n+    {\n+    case asm_dest_common:\n+      if (! DECL_WEAK (decl))\n+\tbreak;\n+    case asm_dest_bss:\n+      globalize_decl (decl);\n+    default:\n+      break;\n+    }\n+\n   if (flag_shared_data)\n     {\n       switch (destination)\n@@ -1429,7 +1436,6 @@ asm_emit_uninitialised (decl, name, size, rounded)\n     {\n #ifdef ASM_EMIT_BSS\n     case asm_dest_bss:\n-      globalize_decl (decl);\n       ASM_EMIT_BSS (decl, name, size, rounded);\n       break;\n #endif\n@@ -4994,55 +5000,9 @@ output_constructor (exp, size, align)\n     assemble_zeros (size - total_bytes);\n }\n \n-\n-/* This structure contains any weak symbol declarations waiting\n+/* This TREE_LIST contains any weak symbol declarations waiting\n    to be emitted.  */\n-struct weak_syms\n-{\n-  struct weak_syms * next;\n-  tree decl;\n-  const char * name;\n-  const char * value;\n-};\n-\n-static struct weak_syms * weak_decls;\n-\n-/* Mark weak_decls for garbage collection.  */\n-\n-static void\n-mark_weak_decls (arg)\n-     void *arg;\n-{\n-  struct weak_syms *t;\n-\n-  for (t = *(struct weak_syms **) arg; t != NULL; t = t->next)\n-    ggc_mark_tree (t->decl);\n-}\n-\n-/* Add function NAME to the weak symbols list.  VALUE is a weak alias\n-   associated with NAME.  */\n-\n-int\n-add_weak (decl, name, value)\n-     tree decl;\n-     const char *name;\n-     const char *value;\n-{\n-  struct weak_syms *weak;\n-\n-  weak = (struct weak_syms *) xmalloc (sizeof (struct weak_syms));\n-\n-  if (weak == NULL)\n-    return 0;\n-\n-  weak->next = weak_decls;\n-  weak->decl = decl;\n-  weak->name = name;\n-  weak->value = value;\n-  weak_decls = weak;\n-\n-  return 1;\n-}\n+static tree weak_decls;\n \n /* Declare DECL to be a weak symbol.  */\n \n@@ -5055,7 +5015,10 @@ declare_weak (decl)\n   else if (TREE_ASM_WRITTEN (decl))\n     error_with_decl (decl, \"weak declaration of `%s' must precede definition\");\n   else if (SUPPORTS_WEAK)\n-    add_weak (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), NULL);\n+    {\n+      if (! DECL_WEAK (decl))\n+\tweak_decls = tree_cons (NULL, decl, weak_decls);\n+    }\n   else\n     warning_with_decl (decl, \"weak declaration of `%s' not supported\");\n \n@@ -5067,59 +5030,30 @@ declare_weak (decl)\n void\n weak_finish ()\n {\n-  if (SUPPORTS_WEAK)\n+  tree t;\n+\n+  for (t = weak_decls; t ; t = TREE_CHAIN (t))\n     {\n-      struct weak_syms *t;\n-      for (t = weak_decls; t != NULL; t = t->next)\n-\t{\n+      tree decl = TREE_VALUE (t);\n+      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+      if (! TREE_USED (decl))\n+\tcontinue;\n+\n #ifdef ASM_WEAKEN_DECL\n-\t  tree decl = t->decl;\n-\t  if (decl == NULL_TREE)\n-\t    {\n-\t      tree name = get_identifier (t->name);\n-\t      if (name)\n-\t\tdecl = lookup_name (name);\n-\t    }\n-\t  ASM_WEAKEN_DECL (asm_out_file, decl, t->name, t->value);\n-#else\n-#ifdef ASM_OUTPUT_WEAK_ALIAS\n-\t  ASM_OUTPUT_WEAK_ALIAS (asm_out_file, t->name, t->value);\n+      ASM_WEAKEN_DECL (asm_out_file, decl, name, NULL);\n #else\n #ifdef ASM_WEAKEN_LABEL\n-\t  if (t->value)\n-\t    abort ();\n-\t  ASM_WEAKEN_LABEL (asm_out_file, t->name);\n+      ASM_WEAKEN_LABEL (asm_out_file, name);\n+#else\n+#ifdef ASM_OUTPUT_WEAK_ALIAS\n+      warning (\"only weak aliases are supported in this configuration\");\n+      return;\n #endif\n #endif\n #endif\n-\t}\n-    }\n-}\n-\n-/* Remove NAME from the pending list of weak symbols.  This prevents\n-   the compiler from emitting multiple .weak directives which confuses\n-   some assemblers.  */\n-#if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)\n-static void\n-remove_from_pending_weak_list (name)\n-     const char *name;\n-{\n-  struct weak_syms *t;\n-  struct weak_syms **p;\n-\n-  for (p = &weak_decls; *p; )\n-    {\n-      t = *p;\n-      if (strcmp (name, t->name) == 0)\n-        {\n-          *p = t->next;\n-          free (t);\n-        }\n-      else\n-        p = &(t->next);\n     }\n }\n-#endif /* defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL) */\n \n /* Emit the assembly bits to indicate that DECL is globally visible.  */\n \n@@ -5132,18 +5066,26 @@ globalize_decl (decl)\n #if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)\n   if (DECL_WEAK (decl))\n     {\n+      tree *p, t;\n+\n #ifdef ASM_WEAKEN_DECL\n       ASM_WEAKEN_DECL (asm_out_file, decl, name, 0);\n #else\n       ASM_WEAKEN_LABEL (asm_out_file, name);\n #endif\n+\n       /* Remove this function from the pending weak list so that\n \t we do not emit multiple .weak directives for it.  */\n-      remove_from_pending_weak_list (name);\n+      for (p = &weak_decls; (t = *p) ; p = &TREE_CHAIN (t))\n+\tif (TREE_VALUE (t) == decl)\n+\t  {\n+\t    *p = TREE_CHAIN (t);\n+\t    break;\n+\t  }\n       return;\n     }\n-  /* else */\n #endif\n+\n   ASM_GLOBALIZE_LABEL (asm_out_file, name);\n }\n \n@@ -5168,7 +5110,6 @@ assemble_alias (decl, target)\n   if (TREE_PUBLIC (decl))\n     {\n       globalize_decl (decl);\n-\n       maybe_assemble_visibility (decl);\n     }\n \n@@ -5282,7 +5223,7 @@ init_varasm_once ()\n \t\tmark_const_hash_entry);\n   ggc_add_root (&const_str_htab, 1, sizeof const_str_htab,\n \t\tmark_const_str_htab);\n-  ggc_add_root (&weak_decls, 1, sizeof weak_decls, mark_weak_decls);\n+  ggc_add_tree_root (&weak_decls, 1);\n \n   const_alias_set = new_alias_set ();\n }"}]}