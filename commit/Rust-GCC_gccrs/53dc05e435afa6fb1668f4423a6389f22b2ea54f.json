{"sha": "53dc05e435afa6fb1668f4423a6389f22b2ea54f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkYzA1ZTQzNWFmYTZmYjE2NjhmNDQyM2E2Mzg5ZjIyYjJlYTU0Zg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-01-28T15:28:14Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-01-28T15:28:14Z"}, "message": "loop.c (recombine_givs): New parameter unroll_p.\n\n\t* loop.c (recombine_givs): New parameter unroll_p.  If set, don't\n\tgenerate complex adds.  Changed caller.\n\tDon't generate adds that cost more than the original one.\n\t(strength_reduce): Warning fixes.\n\nFrom-SVN: r24895", "tree": {"sha": "0bd67f50ac8ba7880d64e01e710648a10662760d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bd67f50ac8ba7880d64e01e710648a10662760d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53dc05e435afa6fb1668f4423a6389f22b2ea54f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dc05e435afa6fb1668f4423a6389f22b2ea54f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53dc05e435afa6fb1668f4423a6389f22b2ea54f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dc05e435afa6fb1668f4423a6389f22b2ea54f/comments", "author": null, "committer": null, "parents": [{"sha": "c7a932b1cff62ab30552ce88caf48272243f108e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a932b1cff62ab30552ce88caf48272243f108e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a932b1cff62ab30552ce88caf48272243f108e"}], "stats": {"total": 28, "additions": 23, "deletions": 5}, "files": [{"sha": "3edd78099076df8382f0587d89a94e08a03ab1a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc05e435afa6fb1668f4423a6389f22b2ea54f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc05e435afa6fb1668f4423a6389f22b2ea54f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53dc05e435afa6fb1668f4423a6389f22b2ea54f", "patch": "@@ -1,3 +1,10 @@\n+Thu Jan 28 23:24:08 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (recombine_givs): New parameter unroll_p.  If set, don't\n+\tgenerate complex adds.  Changed caller.\n+\tDon't generate adds that cost more than the original one.\n+\t(strength_reduce): Warning fixes.\n+\n Thu Jan 28 09:41:11 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* configure.in (hppa1.0-hp-hpux10*): Use t-pa."}, {"sha": "a19bf38149d4de6c7320ad6dd04f8ada19fab10d", "filename": "gcc/loop.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dc05e435afa6fb1668f4423a6389f22b2ea54f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dc05e435afa6fb1668f4423a6389f22b2ea54f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=53dc05e435afa6fb1668f4423a6389f22b2ea54f", "patch": "@@ -325,7 +325,7 @@ static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n static void combine_givs PROTO((struct iv_class *));\n struct recombine_givs_stats;\n static int find_life_end (rtx,  struct recombine_givs_stats *, rtx, rtx);\n-static void recombine_givs PROTO((struct iv_class *, rtx, rtx));\n+static void recombine_givs PROTO((struct iv_class *, rtx, rtx, int));\n static int product_cheap_p PROTO((rtx, rtx));\n static int maybe_eliminate_biv PROTO((struct iv_class *, rtx, rtx, int, int, int));\n static int maybe_eliminate_biv_1 PROTO((rtx, rtx, struct iv_class *, int, rtx));\n@@ -3924,7 +3924,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* Look at the each biv and see if we can say anything better about its\n      initial value from any initializing insns set up above.  (This is done\n      in two passes to avoid missing SETs in a PARALLEL.)  */\n-  for (backbl = &loop_iv_list; bl = *backbl; backbl = &bl->next)\n+  for (backbl = &loop_iv_list; (bl = *backbl); backbl = &bl->next)\n     {\n       rtx src;\n       rtx note;\n@@ -4019,7 +4019,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t    {\n \t      int loop_num = uid_loop_num[INSN_UID (loop_start)];\n \t      rtx dominator = loop_number_cont_dominator[loop_num];\n-\t      rtx cont = loop_number_loop_cont[loop_num];\n \t      rtx giv = bl->biv->src_reg;\n \t      rtx giv_insn = bl->biv->insn;\n \t      rtx after_giv = NEXT_INSN (giv_insn);\n@@ -4584,7 +4583,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n       /* Now that we know which givs will be reduced, try to rearrange the\n          combinations to reduce register pressure.  */\n-      recombine_givs (bl, loop_start, loop_end);\n+      recombine_givs (bl, loop_start, loop_end, unroll_p);\n \n       /* Reduce each giv that we decided to reduce.  */\n \n@@ -7030,9 +7029,10 @@ find_life_end (x, stats, insn, biv)\n    This tends to shorten giv lifetimes, and helps the next step:\n    try to derive givs from other givs.  */\n static void\n-recombine_givs (bl, loop_start, loop_end)\n+recombine_givs (bl, loop_start, loop_end, unroll_p)\n      struct iv_class *bl;\n      rtx loop_start, loop_end;\n+     int unroll_p;\n {\n   struct induction *v, **giv_array, *last_giv;\n   struct recombine_givs_stats *stats;\n@@ -7284,6 +7284,17 @@ recombine_givs (bl, loop_start, loop_end)\n \t\t validity of last_giv.  */\n \t      && (v->always_executed || ! v->combined_with)\n \t      && (sum = express_from (last_giv, v))\n+\t      /* Make sure we don't make the add more expensive.  ADD_COST\n+\t\t doesn't take different costs of registers and constants into\n+\t\t account, so compare the cost of the actual SET_SRCs.  */\n+\t      && (rtx_cost (sum, SET)\n+\t\t  <= rtx_cost (SET_SRC (single_set (v->insn)), SET))\n+\t      /* ??? unroll can't understand anything but reg + const_int\n+\t\t sums.  It would be cleaner to fix unroll.  */\n+\t      && ((GET_CODE (sum) == PLUS\n+\t\t   && GET_CODE (XEXP (sum, 0)) == REG\n+\t\t   && GET_CODE (XEXP (sum, 1)) == CONST_INT)\n+\t\t  || ! unroll_p)\n \t      && validate_change (v->insn, &PATTERN (v->insn),\n \t\t\t\t  gen_rtx_SET (GET_MODE (v->dest_reg),\n \t\t\t\t\t       v->dest_reg, sum), 0))"}]}