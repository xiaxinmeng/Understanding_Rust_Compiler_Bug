{"sha": "93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhYTNjNGFjYTM2NDc2NDVjZDViY2U3MjRmOWQyMTI2ZGU0YjVlYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-01-15T08:11:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-01-15T08:11:00Z"}, "message": "re PR tree-optimization/88775 (Optimize std::string assignment)\n\n\tPR tree-optimization/88775\n\t* match.pd (cmp (convert1?@2 addr@0) (convert2? addr@1)): Optimize\n\tequal == 0 equality pointer comparisons some more if compared in\n\tintegral types and either one points to an automatic var and the\n\tother to a global, or we can prove at least one points to the middle\n\tor both point to start or both point to end.\n\n\t* gcc.dg/tree-ssa/pr88775-1.c: New test.\n\t* gcc.dg/tree-ssa/pr88775-2.c: New test.\n\nFrom-SVN: r267931", "tree": {"sha": "b8edaf2086c909d4288a6456d875c07bcd0e9202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8edaf2086c909d4288a6456d875c07bcd0e9202"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6facd01f982ddeffccb2a66dec2041322f3a9b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6facd01f982ddeffccb2a66dec2041322f3a9b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6facd01f982ddeffccb2a66dec2041322f3a9b76"}], "stats": {"total": 193, "additions": 183, "deletions": 10}, "files": [{"sha": "c350d1cec0f661da64603593ceb22a33d77146d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "patch": "@@ -1,3 +1,12 @@\n+2019-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/88775\n+\t* match.pd (cmp (convert1?@2 addr@0) (convert2? addr@1)): Optimize\n+\tequal == 0 equality pointer comparisons some more if compared in\n+\tintegral types and either one points to an automatic var and the\n+\tother to a global, or we can prove at least one points to the middle\n+\tor both point to start or both point to end.\n+\n 2019-01-14  Andi Kleen  <ak@linux.intel.com>\n \n \t* Makefile.in: Lower autofdo sampling rate by 10x."}, {"sha": "bccf4df05a2f94785446719b3097b3f912fafe96", "filename": "gcc/match.pd", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "patch": "@@ -3896,6 +3896,52 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t\t    || TREE_CODE (base1) == SSA_NAME\n \t\t    || TREE_CODE (base1) == STRING_CST))\n          equal = (base0 == base1);\n+       if (equal == 0)\n+\t {\n+\t   if (!DECL_P (base0) || !DECL_P (base1))\n+\t     equal = 2;\n+\t   else if (cmp != EQ_EXPR && cmp != NE_EXPR)\n+\t     equal = 2;\n+\t   /* If this is a pointer comparison, ignore for now even\n+\t      valid equalities where one pointer is the offset zero\n+\t      of one object and the other to one past end of another one.  */\n+\t   else if (!INTEGRAL_TYPE_P (TREE_TYPE (@2)))\n+\t     ;\n+\t   /* Assume that automatic variables can't be adjacent to global\n+\t      variables.  */\n+\t   else if (is_global_var (base0) != is_global_var (base1))\n+\t     ;\n+\t   else\n+\t     {\n+\t       tree sz0 = DECL_SIZE_UNIT (base0);\n+\t       tree sz1 = DECL_SIZE_UNIT (base1);\n+\t       /* If sizes are unknown, e.g. VLA or not representable,\n+\t\t  punt.  */\n+\t       if (!tree_fits_poly_int64_p (sz0)\n+\t\t   || !tree_fits_poly_int64_p (sz1))\n+\t\t equal = 2;\n+\t       else\n+\t\t {\n+\t\t   poly_int64 size0 = tree_to_poly_int64 (sz0);\n+\t\t   poly_int64 size1 = tree_to_poly_int64 (sz1);\n+\t\t   /* If one offset is pointing (or could be) to the beginning\n+\t\t      of one object and the other is pointing to one past the\n+\t\t      last byte of the other object, punt.  */\n+\t\t   if (maybe_eq (off0, 0) && maybe_eq (off1, size1))\n+\t\t     equal = 2;\n+\t\t   else if (maybe_eq (off1, 0) && maybe_eq (off0, size0))\n+\t\t     equal = 2;\n+\t\t   /* If both offsets are the same, there are some cases\n+\t\t      we know that are ok.  Either if we know they aren't\n+\t\t      zero, or if we know both sizes are no zero.  */\n+\t\t   if (equal == 2\n+\t\t       && known_eq (off0, off1)\n+\t\t       && (known_ne (off0, 0)\n+\t\t\t   || (known_ne (size0, 0) && known_ne (size1, 0))))\n+\t\t     equal = 0;\n+\t\t }\n+\t     }\n+\t }\n      }\n      (if (equal == 1\n \t  && (cmp == EQ_EXPR || cmp == NE_EXPR\n@@ -3918,16 +3964,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t{ constant_boolean_node (known_ge (off0, off1), type); })\n        (if (cmp == GT_EXPR && (known_gt (off0, off1) || known_le (off0, off1)))\n \t{ constant_boolean_node (known_gt (off0, off1), type); }))\n-      (if (equal == 0\n-\t   && DECL_P (base0) && DECL_P (base1)\n-\t   /* If we compare this as integers require equal offset.  */\n-\t   && (!INTEGRAL_TYPE_P (TREE_TYPE (@2))\n-\t       || known_eq (off0, off1)))\n-       (switch\n-\t(if (cmp == EQ_EXPR)\n-\t { constant_boolean_node (false, type); })\n-\t(if (cmp == NE_EXPR)\n-\t { constant_boolean_node (true, type); })))))))))\n+      (if (equal == 0)\n+\t(switch\n+\t (if (cmp == EQ_EXPR)\n+\t  { constant_boolean_node (false, type); })\n+\t (if (cmp == NE_EXPR)\n+\t  { constant_boolean_node (true, type); })))))))))\n \n /* Simplify pointer equality compares using PTA.  */\n (for neeq (ne eq)"}, {"sha": "810c45780a78d3713aae0a2e996499fa531026fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "patch": "@@ -1,3 +1,9 @@\n+2019-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/88775\n+\t* gcc.dg/tree-ssa/pr88775-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr88775-2.c: New test.\n+\n 2019-01-14  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/88825 - ICE with bogus function return type deduction."}, {"sha": "779b2b7830054b942e7fe298cb7ecb386350232a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88775-1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-1.c?ref=93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "patch": "@@ -0,0 +1,73 @@\n+/* PR tree-optimization/88775 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"return 1;\" 10 \"optimized\" } } */\n+\n+int a[64] = {};\n+int b[64] = {};\n+\n+int\n+f1 (void)\n+{\n+  return (__UINTPTR_TYPE__) &a[2] != (__UINTPTR_TYPE__) &b[2];\n+}\n+\n+int\n+f2 (void)\n+{\n+  return (__UINTPTR_TYPE__) &a[2] != (__UINTPTR_TYPE__) &b[10];\n+}\n+\n+int\n+f3 (void)\n+{\n+  return (__UINTPTR_TYPE__) &a[0] != (__UINTPTR_TYPE__) &b[0];\n+}\n+\n+int\n+f4 (void)\n+{\n+  return (__UINTPTR_TYPE__) &a[64] != (__UINTPTR_TYPE__) &b[64];\n+}\n+\n+int\n+f5 (void)\n+{\n+  int c[64] = {};\n+  return (__UINTPTR_TYPE__) &a[0] != (__UINTPTR_TYPE__) &c[64];\n+}\n+\n+int\n+f6 (void)\n+{\n+  int c[64] = {};\n+  return (__UINTPTR_TYPE__) &b[64] != (__UINTPTR_TYPE__) &c[0];\n+}\n+\n+int\n+f7 (void)\n+{\n+  int c[64] = {}, d[64] = {};\n+  return (__UINTPTR_TYPE__) &c[2] != (__UINTPTR_TYPE__) &d[2];\n+}\n+\n+int\n+f8 (void)\n+{\n+  int c[64] = {}, d[64] = {};\n+  return (__UINTPTR_TYPE__) &c[2] != (__UINTPTR_TYPE__) &d[10];\n+}\n+\n+int\n+f9 (void)\n+{\n+  int c[64] = {}, d[64] = {};\n+  return (__UINTPTR_TYPE__) &c[0] != (__UINTPTR_TYPE__) &d[0];\n+}\n+\n+int\n+f10 (void)\n+{\n+  int c[64] = {}, d[64] = {};\n+  return (__UINTPTR_TYPE__) &c[64] != (__UINTPTR_TYPE__) &d[64];\n+}"}, {"sha": "292ce6edefc9913320eaadd745ad2368b4ecf528", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88775-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93aa3c4aca3647645cd5bce724f9d2126de4b5ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-2.c?ref=93aa3c4aca3647645cd5bce724f9d2126de4b5ea", "patch": "@@ -0,0 +1,43 @@\n+/* PR tree-optimization/88775 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* These can't be decided until we know how the variables will\n+   be laid out in memory.  */\n+/* { dg-final { scan-tree-dump-not \"return 1;\" \"optimized\" } } */\n+\n+int a[64] = {};\n+int b[64] = {};\n+int e[0] = {};\n+int f[0] = {};\n+\n+int\n+f1 (void)\n+{\n+  return (__UINTPTR_TYPE__) &a[0] != (__UINTPTR_TYPE__) &b[64];\n+}\n+\n+int\n+f2 (void)\n+{\n+  return (__UINTPTR_TYPE__) &a[64] != (__UINTPTR_TYPE__) &b[0];\n+}\n+\n+int\n+f3 (void)\n+{\n+  return (__UINTPTR_TYPE__) &e[0] != (__UINTPTR_TYPE__) &f[0];\n+}\n+\n+int\n+f4 (void)\n+{\n+  int c[64] = {}, d[64] = {};\n+  return (__UINTPTR_TYPE__) &c[0] != (__UINTPTR_TYPE__) &d[64];\n+}\n+\n+int\n+f5 (void)\n+{\n+  int c[64] = {}, d[64] = {};\n+  return (__UINTPTR_TYPE__) &c[64] != (__UINTPTR_TYPE__) &d[0];\n+}"}]}