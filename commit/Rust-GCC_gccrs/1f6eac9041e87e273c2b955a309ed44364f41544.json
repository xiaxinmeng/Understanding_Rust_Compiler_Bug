{"sha": "1f6eac9041e87e273c2b955a309ed44364f41544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2ZWFjOTA0MWU4N2UyNzNjMmI5NTVhMzA5ZWQ0NDM2NGY0MTU0NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-07-06T09:34:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-07-06T09:34:17Z"}, "message": "re PR target/29776 (result of ffs/clz/ctz/popcount/parity are already sign-extended)\n\n\tPR target/29776\n\t* fold-const.c (tree_call_nonnegative_warnv_p): Return true\n\tfor BUILT_IN_C{LZ,LRSB}*.\n\t* tree.h (CASE_INT_FN): Add FN##IMAX case.\n\t* tree-vrp.c (extract_range_basic): Handle\n\tBUILT_IN_{FFS,PARITY,POPCOUNT,C{LZ,TZ,LRSB}}*.  For\n\tBUILT_IN_CONSTANT_P if argument isn't (D) of PARM_DECL,\n\tfall thru to code calling set_value*.\n\t* builtins.c (expand_builtin): Remove *IMAX cases.\n\t(fold_builtin_bitop): For BUILT_IN_CLRSB* return NULL_TREE\n\tif width is bigger than 2*HWI.\n\n\t* libgcc2.c (__floattisf): Avoid undefined signed overflow.\n\n\t* gcc.dg/tree-ssa/vrp89.c: New test.\n\nFrom-SVN: r200731", "tree": {"sha": "5c06ed10d38755e166140f77dd83928e972b3462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c06ed10d38755e166140f77dd83928e972b3462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6eac9041e87e273c2b955a309ed44364f41544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6eac9041e87e273c2b955a309ed44364f41544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6eac9041e87e273c2b955a309ed44364f41544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6eac9041e87e273c2b955a309ed44364f41544/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5504e5d864f7b9c83727669847396c639abdf77b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5504e5d864f7b9c83727669847396c639abdf77b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5504e5d864f7b9c83727669847396c639abdf77b"}], "stats": {"total": 287, "additions": 265, "deletions": 22}, "files": [{"sha": "cc23efbd8be84b40828332113162817abb34647a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -1,3 +1,17 @@\n+2013-07-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/29776\n+\t* fold-const.c (tree_call_nonnegative_warnv_p): Return true\n+\tfor BUILT_IN_C{LZ,LRSB}*.\n+\t* tree.h (CASE_INT_FN): Add FN##IMAX case.\n+\t* tree-vrp.c (extract_range_basic): Handle\n+\tBUILT_IN_{FFS,PARITY,POPCOUNT,C{LZ,TZ,LRSB}}*.  For\n+\tBUILT_IN_CONSTANT_P if argument isn't (D) of PARM_DECL,\n+\tfall thru to code calling set_value*.\n+\t* builtins.c (expand_builtin): Remove *IMAX cases.\n+\t(fold_builtin_bitop): For BUILT_IN_CLRSB* return NULL_TREE\n+\tif width is bigger than 2*HWI.\n+\n 2013-07-05  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/55342"}, {"sha": "78b0d842cc03a2ae42c654a6a09c683f5a4d9f87", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -6107,47 +6107,41 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       break;\n \n     CASE_INT_FN (BUILT_IN_FFS):\n-    case BUILT_IN_FFSIMAX:\n       target = expand_builtin_unop (target_mode, exp, target,\n \t\t\t\t    subtarget, ffs_optab);\n       if (target)\n \treturn target;\n       break;\n \n     CASE_INT_FN (BUILT_IN_CLZ):\n-    case BUILT_IN_CLZIMAX:\n       target = expand_builtin_unop (target_mode, exp, target,\n \t\t\t\t    subtarget, clz_optab);\n       if (target)\n \treturn target;\n       break;\n \n     CASE_INT_FN (BUILT_IN_CTZ):\n-    case BUILT_IN_CTZIMAX:\n       target = expand_builtin_unop (target_mode, exp, target,\n \t\t\t\t    subtarget, ctz_optab);\n       if (target)\n \treturn target;\n       break;\n \n     CASE_INT_FN (BUILT_IN_CLRSB):\n-    case BUILT_IN_CLRSBIMAX:\n       target = expand_builtin_unop (target_mode, exp, target,\n \t\t\t\t    subtarget, clrsb_optab);\n       if (target)\n \treturn target;\n       break;\n \n     CASE_INT_FN (BUILT_IN_POPCOUNT):\n-    case BUILT_IN_POPCOUNTIMAX:\n       target = expand_builtin_unop (target_mode, exp, target,\n \t\t\t\t    subtarget, popcount_optab);\n       if (target)\n \treturn target;\n       break;\n \n     CASE_INT_FN (BUILT_IN_PARITY):\n-    case BUILT_IN_PARITYIMAX:\n       target = expand_builtin_unop (target_mode, exp, target,\n \t\t\t\t    subtarget, parity_optab);\n       if (target)\n@@ -8152,6 +8146,8 @@ fold_builtin_bitop (tree fndecl, tree arg)\n \t  break;\n \n \tCASE_INT_FN (BUILT_IN_CLRSB):\n+\t  if (width > 2 * HOST_BITS_PER_WIDE_INT)\n+\t    return NULL_TREE;\n \t  if (width > HOST_BITS_PER_WIDE_INT\n \t      && (hi & ((unsigned HOST_WIDE_INT) 1\n \t\t\t<< (width - HOST_BITS_PER_WIDE_INT - 1))) != 0)"}, {"sha": "6506ae7bbfba7017b3aa6c1bff27dd7b034b47fd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -15606,6 +15606,8 @@ tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n \tCASE_INT_FN (BUILT_IN_FFS):\n \tCASE_INT_FN (BUILT_IN_PARITY):\n \tCASE_INT_FN (BUILT_IN_POPCOUNT):\n+\tCASE_INT_FN (BUILT_IN_CLZ):\n+\tCASE_INT_FN (BUILT_IN_CLRSB):\n       case BUILT_IN_BSWAP32:\n       case BUILT_IN_BSWAP64:\n \t/* Always true.  */"}, {"sha": "2bc61c01ae92e2b9f4995af15a9631c39465b2a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -1,3 +1,8 @@\n+2013-07-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/29776\n+\t* gcc.dg/tree-ssa/vrp89.c: New test.\n+\n 2013-07-06  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/28262"}, {"sha": "3e1d96e42afd3fcb874f4c44399a2f0b6188f3b2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp89.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp89.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp89.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp89.c?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -0,0 +1,57 @@\n+/* PR target/29776 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-final { scan-tree-dump-not \"link_error\" \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n+\n+#define A(fn, arg, min, max) \\\n+  if (__builtin_##fn (arg) < min || __builtin_##fn (arg) > max) \\\n+    link_error ();\n+#define B(fn, min, max) \\\n+  A (fn, a, min, max) A (fn##l, b, min, max) A (fn##ll, c, min, max)\n+#define C(fn, min, sub) \\\n+  A (fn, a, min, ((int) sizeof (a) * __CHAR_BIT__ - sub)) \\\n+  A (fn##l, b, min, ((int) sizeof (b) * __CHAR_BIT__ - sub)) \\\n+  A (fn##ll, c, min, ((int) sizeof (c) * __CHAR_BIT__ - sub))\n+#define D(fn, sub1, sub2) \\\n+  A (fn, a, ((int) sizeof (a) * __CHAR_BIT__ - sub1), \\\n+     ((int) sizeof (a) * __CHAR_BIT__ - sub2)) \\\n+  A (fn##l, b, ((int) sizeof (b) * __CHAR_BIT__ - sub1), \\\n+     ((int) sizeof (b) * __CHAR_BIT__ - sub2)) \\\n+  A (fn##ll, c, ((int) sizeof (c) * __CHAR_BIT__ - sub1), \\\n+     ((int) sizeof (c) * __CHAR_BIT__ - sub2))\n+\n+extern void link_error (void);\n+\n+unsigned int d;\n+unsigned long e;\n+unsigned long long f;\n+\n+void\n+foo (unsigned int a, unsigned long b, unsigned long long c)\n+{\n+  B (parity, 0, 1)\n+  C (ffs, 0, 0)\n+  C (popcount, 0, 0)\n+  C (clz, 0, 0)\n+  C (ctz, -1, 0)\n+  a &= 63;\n+  b &= 63;\n+  c &= 63;\n+  B (ffs, 0, 6)\n+  B (popcount, 0, 6)\n+  a += 3; b += 3; c += 3;\n+  B (ffs, 1, 7)\n+  B (popcount, 1, 7)\n+  a = 32U + (d & 1023U);\n+  b = 32UL + (e & 1023UL);\n+  c = 32ULL + (f & 1023ULL);\n+  D (clz, 11, 6)\n+  B (ctz, 0, 10)\n+}\n+\n+void\n+bar (int a, long b, long long c)\n+{\n+  C (clrsb, 0, 1)\n+}"}, {"sha": "ca9d8bdb30587fcfac169d964e444d94a6bfce1d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 178, "deletions": 14, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -3565,20 +3565,184 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n   bool sop = false;\n   tree type = gimple_expr_type (stmt);\n \n-  /* If the call is __builtin_constant_p and the argument is a\n-     function parameter resolve it to false.  This avoids bogus\n-     array bound warnings.\n-     ???  We could do this as early as inlining is finished.  */\n-  if (gimple_call_builtin_p (stmt, BUILT_IN_CONSTANT_P))\n-    {\n-      tree arg = gimple_call_arg (stmt, 0);\n-      if (TREE_CODE (arg) == SSA_NAME\n-\t  && SSA_NAME_IS_DEFAULT_DEF (arg)\n-\t  && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL)\n-\tset_value_range_to_null (vr, type);\n-    }\n-  else if (INTEGRAL_TYPE_P (type)\n-\t   && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      tree fndecl = gimple_call_fndecl (stmt), arg;\n+      int mini, maxi, zerov = 0, prec;\n+\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tcase BUILT_IN_CONSTANT_P:\n+\t  /* If the call is __builtin_constant_p and the argument is a\n+\t     function parameter resolve it to false.  This avoids bogus\n+\t     array bound warnings.\n+\t     ???  We could do this as early as inlining is finished.  */\n+\t  arg = gimple_call_arg (stmt, 0);\n+\t  if (TREE_CODE (arg) == SSA_NAME\n+\t      && SSA_NAME_IS_DEFAULT_DEF (arg)\n+\t      && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL)\n+\t    {\n+\t      set_value_range_to_null (vr, type);\n+\t      return;\n+\t    }\n+\t  break;\n+\t  /* Both __builtin_ffs* and __builtin_popcount return\n+\t     [0, prec].  */\n+\tCASE_INT_FN (BUILT_IN_FFS):\n+\tCASE_INT_FN (BUILT_IN_POPCOUNT):\n+\t  arg = gimple_call_arg (stmt, 0);\n+\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n+\t  mini = 0;\n+\t  maxi = prec;\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      value_range_t *vr0 = get_value_range (arg);\n+\t      /* If arg is non-zero, then ffs or popcount\n+\t\t are non-zero.  */\n+\t      if (((vr0->type == VR_RANGE\n+\t\t    && integer_nonzerop (vr0->min))\n+\t\t   || (vr0->type == VR_ANTI_RANGE\n+\t\t       && integer_zerop (vr0->min)))\n+\t\t  && !TREE_OVERFLOW (vr0->min))\n+\t\tmini = 1;\n+\t      /* If some high bits are known to be zero,\n+\t\t we can decrease the maximum.  */\n+\t      if (vr0->type == VR_RANGE\n+\t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (vr0->max))\n+\t\tmaxi = tree_floor_log2 (vr0->max) + 1;\n+\t    }\n+\t  goto bitop_builtin;\n+\t  /* __builtin_parity* returns [0, 1].  */\n+\tCASE_INT_FN (BUILT_IN_PARITY):\n+\t  mini = 0;\n+\t  maxi = 1;\n+\t  goto bitop_builtin;\n+\t  /* __builtin_c[lt]z* return [0, prec-1], except for\n+\t     when the argument is 0, but that is undefined behavior.\n+\t     On many targets where the CLZ RTL or optab value is defined\n+\t     for 0 the value is prec, so include that in the range\n+\t     by default.  */\n+\tCASE_INT_FN (BUILT_IN_CLZ):\n+\t  arg = gimple_call_arg (stmt, 0);\n+\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n+\t  mini = 0;\n+\t  maxi = prec;\n+\t  if (optab_handler (clz_optab, TYPE_MODE (TREE_TYPE (arg)))\n+\t      != CODE_FOR_nothing\n+\t      && CLZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (TREE_TYPE (arg)),\n+\t\t\t\t\t    zerov)\n+\t      /* Handle only the single common value.  */\n+\t      && zerov != prec)\n+\t    /* Magic value to give up, unless vr0 proves\n+\t       arg is non-zero.  */\n+\t    mini = -2;\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      value_range_t *vr0 = get_value_range (arg);\n+\t      /* From clz of VR_RANGE minimum we can compute\n+\t\t result maximum.  */\n+\t      if (vr0->type == VR_RANGE\n+\t\t  && TREE_CODE (vr0->min) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (vr0->min))\n+\t\t{\n+\t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min);\n+\t\t  if (maxi != prec)\n+\t\t    mini = 0;\n+\t\t}\n+\t      else if (vr0->type == VR_ANTI_RANGE\n+\t\t       && integer_zerop (vr0->min)\n+\t\t       && !TREE_OVERFLOW (vr0->min))\n+\t\t{\n+\t\t  maxi = prec - 1;\n+\t\t  mini = 0;\n+\t\t}\n+\t      if (mini == -2)\n+\t\tbreak;\n+\t      /* From clz of VR_RANGE maximum we can compute\n+\t\t result minimum.  */\n+\t      if (vr0->type == VR_RANGE\n+\t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (vr0->max))\n+\t\t{\n+\t\t  mini = prec - 1 - tree_floor_log2 (vr0->max);\n+\t\t  if (mini == prec)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (mini == -2)\n+\t    break;\n+\t  goto bitop_builtin;\n+\t  /* __builtin_ctz* return [0, prec-1], except for\n+\t     when the argument is 0, but that is undefined behavior.\n+\t     If there is a ctz optab for this mode and\n+\t     CTZ_DEFINED_VALUE_AT_ZERO, include that in the range,\n+\t     otherwise just assume 0 won't be seen.  */\n+\tCASE_INT_FN (BUILT_IN_CTZ):\n+\t  arg = gimple_call_arg (stmt, 0);\n+\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n+\t  mini = 0;\n+\t  maxi = prec - 1;\n+\t  if (optab_handler (ctz_optab, TYPE_MODE (TREE_TYPE (arg)))\n+\t      != CODE_FOR_nothing\n+\t      && CTZ_DEFINED_VALUE_AT_ZERO (TYPE_MODE (TREE_TYPE (arg)),\n+\t\t\t\t\t    zerov))\n+\t    {\n+\t      /* Handle only the two common values.  */\n+\t      if (zerov == -1)\n+\t\tmini = -1;\n+\t      else if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      else\n+\t\t/* Magic value to give up, unless vr0 proves\n+\t\t   arg is non-zero.  */\n+\t\tmini = -2;\n+\t    }\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      value_range_t *vr0 = get_value_range (arg);\n+\t      /* If arg is non-zero, then use [0, prec - 1].  */\n+\t      if (((vr0->type == VR_RANGE\n+\t\t    && integer_nonzerop (vr0->min))\n+\t\t   || (vr0->type == VR_ANTI_RANGE\n+\t\t       && integer_zerop (vr0->min)))\n+\t\t  && !TREE_OVERFLOW (vr0->min))\n+\t\t{\n+\t\t  mini = 0;\n+\t\t  maxi = prec - 1;\n+\t\t}\n+\t      /* If some high bits are known to be zero,\n+\t\t we can decrease the result maximum.  */\n+\t      if (vr0->type == VR_RANGE\n+\t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (vr0->max))\n+\t\t{\n+\t\t  maxi = tree_floor_log2 (vr0->max);\n+\t\t  /* For vr0 [0, 0] give up.  */\n+\t\t  if (maxi == -1)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (mini == -2)\n+\t    break;\n+\t  goto bitop_builtin;\n+\t  /* __builtin_clrsb* returns [0, prec-1].  */\n+\tCASE_INT_FN (BUILT_IN_CLRSB):\n+\t  arg = gimple_call_arg (stmt, 0);\n+\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n+\t  mini = 0;\n+\t  maxi = prec - 1;\n+\t  goto bitop_builtin;\n+\tbitop_builtin:\n+\t  set_value_range (vr, VR_RANGE, build_int_cst (type, mini),\n+\t\t\t   build_int_cst (type, maxi), NULL);\n+\t  return;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  if (INTEGRAL_TYPE_P (type)\n+      && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n     set_value_range_to_nonnegative (vr, type,\n \t\t\t\t    sop || stmt_overflow_infinity (stmt));\n   else if (vrp_stmt_computes_nonzero (stmt, &sop)"}, {"sha": "6297b49c39951c9b6f0dbe92ab5a888f8487d72e", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -322,7 +322,7 @@ extern const char * built_in_names[(int) END_BUILTINS];\n \n #define CASE_FLT_FN(FN) case FN: case FN##F: case FN##L\n #define CASE_FLT_FN_REENT(FN) case FN##_R: case FN##F_R: case FN##L_R\n-#define CASE_INT_FN(FN) case FN: case FN##L: case FN##LL\n+#define CASE_INT_FN(FN) case FN: case FN##L: case FN##LL: case FN##IMAX\n \f\n /* In an OMP_CLAUSE node.  */\n "}, {"sha": "6fa31d7720e0dd5fefe075024dd070e95014faa2", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -1,3 +1,8 @@\n+2013-07-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/29776\n+\t* libgcc2.c (__floattisf): Avoid undefined signed overflow.\n+\n 2013-06-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/36041"}, {"sha": "641bc1521eda4f36ce732630e8c612ba7114742c", "filename": "libgcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6eac9041e87e273c2b955a309ed44364f41544/libgcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6eac9041e87e273c2b955a309ed44364f41544/libgcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcc2.c?ref=1f6eac9041e87e273c2b955a309ed44364f41544", "patch": "@@ -1571,7 +1571,7 @@ FUNC (DWtype u)\n   /* Otherwise, find the power of two.  */\n   Wtype hi = u >> W_TYPE_SIZE;\n   if (hi < 0)\n-    hi = -hi;\n+    hi = -(UWtype) hi;\n \n   UWtype count, shift;\n   count_leading_zeros (count, hi);"}]}