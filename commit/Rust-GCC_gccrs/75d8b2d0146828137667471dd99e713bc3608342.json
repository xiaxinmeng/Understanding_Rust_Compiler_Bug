{"sha": "75d8b2d0146828137667471dd99e713bc3608342", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkOGIyZDAxNDY4MjgxMzc2Njc0NzFkZDk5ZTcxM2JjMzYwODM0Mg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-04-25T11:49:27Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-04-25T11:49:27Z"}, "message": "genmodes.c (make_vector_mode): Allow making VECTOR_MODE_INT of a MODE_PARTIAL_INT mode.\n\n\t* genmodes.c (make_vector_mode): Allow making VECTOR_MODE_INT of a\n\tMODE_PARTIAL_INT mode.\n\t* config/bfin/bfin-modes.def: Add V2PDI and V2SI.\n\t* config/bfin/bfin.c (print_operand): Add macflag and mac/msu modifiers\n\tfor CONST_INTs.\n\t(hard_regno_mode_ok): V2PDImode is ok for accumulators.\n\t* config/bfin/bfin.h (CLASS_MAX_NREGS, HARD_REGNO_NREGS): Handle\n\tV2PDImode.\n\t* config/bfin/predicates.md (const01_operand, vec_shift_operand):\n\tNew predicates.\n\t* config/bfin/bfin.md (UNSPEC_MUL_WITH_FLAG, UNSPEC_MAC_WITH_FLAG):\n\tNew constants.\n\t(MACFLAG_NONE, MACFLAG_T, MACFLAG_FU, MACFLAG_TFU, MACFLAG_IS,\n\tMACFLAG_IU, MACFLAG_W32, MACFLAG_M, MACFLAG_S2RND, MACFLAG_ISS2,\n\tMACFLAG_IH): Likewise.\n\t(movstricthi_1): Renamed from \"*movstricthi\".\n\t(load_accumulator, load_accumulator_pair, movsi_insv, insv,\n\tssaddsi3, sssubsi3, ssnegsi2, signbitssi2, smaxhi3, sminhi3,\n\tabshi2, neghi2, ssneghi2, signbitshi2, movhi_low2high,\n\tmovhi_high2high, movhi_low2low, movhi_high2low, movhiv2hi_low,\n\tmovhiv2hi_high, composev2hi, movv2hi_hi, movv2hi_hi_low,\n\tmovv2hi_hi_high, ssaddhi3, sssubhi3, ssaddv2hi3, sssubv2hi3,\n\taddsubv2hi3, subaddv2hi3, ssaddsubv2hi3, sssubaddv2hi3,\n\tsublohiv2hi3, subhilov2hi3, sssublohiv2hi3, sssubhilov2hi3,\n\taddlohiv2hi3, addhilov2hi3, ssaddlohiv2hi3, ssaddhilov2hi3,\n\tmulhisi_ll, mulhisi_lh, mulhisi_hl, mulhisi_hh, ssnegv2hi2,\n\tssashiftv2hi3, ssashifthi3, lshiftv2hi3, lshifthi3, packv2hi,\n\tflag_mulhi, flag_mulhisi_parts, flag_machi, flag_machi_acconly,\n\tflag_macinithi, flag_macinit1hi, flag_mulv2hi, flag_mulv2hi_parts,\n\tflag_macv2hi_parts, flag_macv2hi_parts_acconly,\n\tflag_macinitv2hi_parts, flag_macinit1v2hi_parts): New patterns.\n\nFrom-SVN: r113245", "tree": {"sha": "500771ec031e37624bec547531c843b22f39b1ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500771ec031e37624bec547531c843b22f39b1ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75d8b2d0146828137667471dd99e713bc3608342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d8b2d0146828137667471dd99e713bc3608342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d8b2d0146828137667471dd99e713bc3608342", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d8b2d0146828137667471dd99e713bc3608342/comments", "author": null, "committer": null, "parents": [{"sha": "ec23e15b4ca127eb25fa1ff125fdce2944cee416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec23e15b4ca127eb25fa1ff125fdce2944cee416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec23e15b4ca127eb25fa1ff125fdce2944cee416"}], "stats": {"total": 1076, "additions": 1049, "deletions": 27}, "files": [{"sha": "23c64a7860c09785dde8047224b7c75062dea349", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -1,3 +1,37 @@\n+2006-04-25  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* genmodes.c (make_vector_mode): Allow making VECTOR_MODE_INT of a\n+\tMODE_PARTIAL_INT mode.\n+\t* config/bfin/bfin-modes.def: Add V2PDI and V2SI.\n+\t* config/bfin/bfin.c (print_operand): Add macflag and mac/msu modifiers\n+\tfor CONST_INTs.\n+\t(hard_regno_mode_ok): V2PDImode is ok for accumulators.\n+\t* config/bfin/bfin.h (CLASS_MAX_NREGS, HARD_REGNO_NREGS): Handle\n+\tV2PDImode.\n+\t* config/bfin/predicates.md (const01_operand, vec_shift_operand):\n+\tNew predicates.\n+\t* config/bfin/bfin.md (UNSPEC_MUL_WITH_FLAG, UNSPEC_MAC_WITH_FLAG):\n+\tNew constants.\n+\t(MACFLAG_NONE, MACFLAG_T, MACFLAG_FU, MACFLAG_TFU, MACFLAG_IS,\n+\tMACFLAG_IU, MACFLAG_W32, MACFLAG_M, MACFLAG_S2RND, MACFLAG_ISS2,\n+\tMACFLAG_IH): Likewise.\n+\t(movstricthi_1): Renamed from \"*movstricthi\".\n+\t(load_accumulator, load_accumulator_pair, movsi_insv, insv,\n+\tssaddsi3, sssubsi3, ssnegsi2, signbitssi2, smaxhi3, sminhi3,\n+\tabshi2, neghi2, ssneghi2, signbitshi2, movhi_low2high,\n+\tmovhi_high2high, movhi_low2low, movhi_high2low, movhiv2hi_low,\n+\tmovhiv2hi_high, composev2hi, movv2hi_hi, movv2hi_hi_low,\n+\tmovv2hi_hi_high, ssaddhi3, sssubhi3, ssaddv2hi3, sssubv2hi3,\n+\taddsubv2hi3, subaddv2hi3, ssaddsubv2hi3, sssubaddv2hi3,\n+\tsublohiv2hi3, subhilov2hi3, sssublohiv2hi3, sssubhilov2hi3,\n+\taddlohiv2hi3, addhilov2hi3, ssaddlohiv2hi3, ssaddhilov2hi3,\n+\tmulhisi_ll, mulhisi_lh, mulhisi_hl, mulhisi_hh, ssnegv2hi2,\n+\tssashiftv2hi3, ssashifthi3, lshiftv2hi3, lshifthi3, packv2hi,\n+\tflag_mulhi, flag_mulhisi_parts, flag_machi, flag_machi_acconly,\n+\tflag_macinithi, flag_macinit1hi, flag_mulv2hi, flag_mulv2hi_parts,\n+\tflag_macv2hi_parts, flag_macv2hi_parts_acconly,\n+\tflag_macinitv2hi_parts, flag_macinit1v2hi_parts): New patterns.\n+\n 2006-04-24  Geoffrey Keating  <geoffk@apple.com>\n \n \t* dwarf2out.c (verify_marks_clear): New."}, {"sha": "b48665fd12d678852a47b309d8c688443874e970", "filename": "gcc/config/bfin/bfin-modes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-modes.def?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -22,4 +22,8 @@\n /* PDImode for the 40 bit accumulators.  */\n PARTIAL_INT_MODE (DI);\n \n+/* Two of those - covering both accumulators for vector multiplications.  */\n+VECTOR_MODE (INT, PDI, 2);\n+\n VECTOR_MODE (INT, HI, 2); /* V2HI */\n+VECTOR_MODE (INT, SI, 2); /* V2SI - occasionally used.  */"}, {"sha": "f451e910e0e8ce04117c2cde579f19dba43bbe79", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -1259,9 +1259,60 @@ print_operand (FILE *file, rtx x, char code)\n \t  break;\n \n \tcase CONST_INT:\n+\t  if (code == 'M')\n+\t    {\n+\t      switch (INTVAL (x))\n+\t\t{\n+\t\tcase MACFLAG_NONE:\n+\t\t  break;\n+\t\tcase MACFLAG_FU:\n+\t\t  fputs (\"(FU)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_T:\n+\t\t  fputs (\"(T)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_TFU:\n+\t\t  fputs (\"(TFU)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_W32:\n+\t\t  fputs (\"(W32)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_IS:\n+\t\t  fputs (\"(IS)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_IU:\n+\t\t  fputs (\"(IU)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_IH:\n+\t\t  fputs (\"(IH)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_M:\n+\t\t  fputs (\"(M)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_ISS2:\n+\t\t  fputs (\"(ISS2)\", file);\n+\t\t  break;\n+\t\tcase MACFLAG_S2RND:\n+\t\t  fputs (\"(S2RND)\", file);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      break;\n+\t    }\n+\t  else if (code == 'b')\n+\t    {\n+\t      if (INTVAL (x) == 0)\n+\t\tfputs (\"+=\", file);\n+\t      else if (INTVAL (x) == 1)\n+\t\tfputs (\"-=\", file);\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      break;\n+\t    }\n \t  /* Moves to half registers with d or h modifiers always use unsigned\n \t     constants.  */\n-\t  if (code == 'd')\n+\t  else if (code == 'd')\n \t    x = GEN_INT ((INTVAL (x) >> 16) & 0xffff);\n \t  else if (code == 'h')\n \t    x = GEN_INT (INTVAL (x) & 0xffff);\n@@ -1672,7 +1723,7 @@ hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return D_REGNO_P (regno);\n   if (class == CCREGS)\n     return mode == BImode;\n-  if (mode == PDImode)\n+  if (mode == PDImode || mode == V2PDImode)\n     return regno == REG_A0 || regno == REG_A1;\n   if (mode == SImode\n       && TEST_HARD_REG_BIT (reg_class_contents[PROLOGUE_REGS], regno))"}, {"sha": "2d1cd390fc74c7749640c26d0cc992f32258af4c", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -509,12 +509,14 @@ enum reg_class\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  ((MODE) == V2PDImode && (CLASS) == AREGS ? 2\t\t\t\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n-((MODE) == PDImode && ((REGNO) == REG_A0 || (REGNO) == REG_A1) \\\n- ? 1 : CLASS_MAX_NREGS (GENERAL_REGS, MODE))\n+  ((MODE) == PDImode && ((REGNO) == REG_A0 || (REGNO) == REG_A1) ? 1\t\\\n+   : (MODE) == V2PDImode && ((REGNO) == REG_A0 || (REGNO) == REG_A1) ? 2 \\\n+   : CLASS_MAX_NREGS (GENERAL_REGS, MODE))\n \n /* A C expression that is nonzero if hard register TO can be\n    considered for use as a rename register for FROM register */"}, {"sha": "e8659922107291449b1c88762bf6c34c40010e17", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 941, "deletions": 20, "changes": 961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -119,13 +119,29 @@\n    (UNSPEC_RETURN 2)\n    (UNSPEC_MOVE_PIC 3)\n    (UNSPEC_LIBRARY_OFFSET 4)\n-   (UNSPEC_PUSH_MULTIPLE 5)])\n+   (UNSPEC_PUSH_MULTIPLE 5)\n+   ;; Multiply or MAC with extra CONST_INT operand specifying the macflag\n+   (UNSPEC_MUL_WITH_FLAG 6)\n+   (UNSPEC_MAC_WITH_FLAG 7)])\n \n (define_constants\n   [(UNSPEC_VOLATILE_EH_RETURN 0)\n    (UNSPEC_VOLATILE_CSYNC 1)\n    (UNSPEC_VOLATILE_SSYNC 2)])\n \n+(define_constants\n+  [(MACFLAG_NONE 0)\n+   (MACFLAG_T 1)\n+   (MACFLAG_FU 2)\n+   (MACFLAG_TFU 3)\n+   (MACFLAG_IS 4)\n+   (MACFLAG_IU 5)\n+   (MACFLAG_W32 6)\n+   (MACFLAG_M 7)\n+   (MACFLAG_S2RND 8)\n+   (MACFLAG_ISS2 9)\n+   (MACFLAG_IH 10)])\n+\n (define_attr \"type\"\n   \"move,mvi,mcld,mcst,dsp32,mult,alu0,shft,brcc,br,call,misc,sync,compare,dummy\"\n   (const_string \"misc\"))\n@@ -369,6 +385,28 @@\n    %w0 = %1; %x0 = %1;\"\n   [(set_attr \"type\" \"move,mcst,mcld\")])\n \n+(define_insn \"load_accumulator\"\n+  [(set (match_operand:PDI 0 \"register_operand\" \"=e\")\n+        (sign_extend:PDI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1;\"\n+  [(set_attr \"type\" \"move\")])\n+\n+(define_insn_and_split \"load_accumulator_pair\"\n+  [(set (match_operand:V2PDI 0 \"register_operand\" \"=e\")\n+        (sign_extend:V2PDI (vec_concat:V2SI\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 3) (sign_extend:PDI (match_dup 1)))\n+   (set (match_dup 4) (sign_extend:PDI (match_dup 2)))]\n+{\n+  operands[3] = gen_rtx_REG (PDImode, REGNO (operands[0]));\n+  operands[4] = gen_rtx_REG (PDImode, REGNO (operands[0]) + 1);\n+})\n+\n (define_insn \"*pushsi_insn\"\n   [(set (mem:SI (pre_dec:SI (reg:SI REG_SP)))\n         (match_operand:SI 0 \"register_operand\" \"xy\"))]\n@@ -405,14 +443,28 @@\n   [(set_attr \"type\" \"move,move,mvi,mvi,mvi,*,mcld,mcst\")\n    (set_attr \"length\" \"2,2,2,4,4,*,*,*\")])\n \n-(define_insn \"*movv2hi_insn\"\n-  [(set (match_operand:V2HI 0 \"nonimmediate_operand\" \"=da,d,m\")\n-        (match_operand:V2HI 1 \"general_operand\" \"d,m,d\"))]\n+(define_insn_and_split \"*movv2hi_insn\"\n+  [(set (match_operand:V2HI 0 \"nonimmediate_operand\" \"=da,da,d,dm\")\n+        (match_operand:V2HI 1 \"general_operand\" \"i,di,md,d\"))]\n \n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"%0 = %1;\"\n-  [(set_attr \"type\" \"move,mcld,mcst\")\n-   (set_attr \"length\" \"2,*,*\")])\n+  \"@\n+   #\n+   %0 = %1;\n+   %0 = %1;\n+   %0 = %1;\"\n+  \"reload_completed && GET_CODE (operands[1]) == CONST_VECTOR\"\n+  [(set (match_dup 0) (high:SI (match_dup 2)))\n+   (set (match_dup 0) (lo_sum:SI (match_dup 0) (match_dup 3)))]\n+{\n+  HOST_WIDE_INT intval = INTVAL (XVECEXP (operands[1], 0, 1)) << 16;\n+  intval |= INTVAL (XVECEXP (operands[1], 0, 0)) & 0xFFFF;\n+  \n+  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+  operands[2] = operands[3] = GEN_INT (trunc_int_for_mode (intval, SImode));\n+}\n+  [(set_attr \"type\" \"move,move,mcld,mcst\")\n+   (set_attr \"length\" \"2,2,*,*\")])\n \n (define_insn \"*movhi_insn\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=x,da,x,d,mr\")\n@@ -490,6 +542,34 @@\n     }\n })\n \n+;; Storing halfwords.\n+(define_insn \"*movsi_insv\"\n+  [(set (zero_extract:SI (match_operand 0 \"register_operand\" \"+d,x\")\n+\t\t\t (const_int 16)\n+\t\t\t (const_int 16))\n+\t(match_operand:SI 1 \"nonmemory_operand\" \"d,n\"))]\n+  \"\"\n+  \"@\n+   %d0 = %h1 << 0;\n+   %d0 = %1;\"\n+  [(set_attr \"type\" \"dsp32,mvi\")])\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\"))\n+        (match_operand:SI 3 \"nonmemory_operand\" \"\"))]\n+  \"\"\n+{\n+  if (INTVAL (operands[1]) != 16 || INTVAL (operands[2]) != 16)\n+    FAIL;\n+\n+  /* From mips.md: insert_bit_field doesn't verify that our source\n+     matches the predicate, so check it again here.  */\n+  if (! register_operand (operands[0], VOIDmode))\n+    FAIL;\n+})\n+\n ;; This is the main \"hook\" for PIC code.  When generating\n ;; PIC, movsi is responsible for determining when the source address\n ;; needs PIC relocation and appropriately calling legitimize_pic_address\n@@ -589,7 +669,7 @@\n ;; Note that the asm instruction is defined by the manual to take an unsigned\n ;; constant, but it doesn't matter to the assembler, and the compiler only\n ;; deals with sign-extended constants.  Hence \"Ksh\".\n-(define_insn \"*movstricthi\"\n+(define_insn \"movstricthi_1\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+x\"))\n \t(match_operand:HI 1 \"immediate_operand\" \"Ksh\"))]\n   \"\"\n@@ -956,6 +1036,14 @@\n   [(set_attr \"type\" \"alu0\")\n    (set_attr \"length\" \"2,2,2\")])\n \n+(define_insn \"ssaddsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ss_plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 + %2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -987,6 +1075,14 @@\n }\n   [(set_attr \"type\" \"alu0\")])\n \n+(define_insn \"sssubsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ss_minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 - %2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n ;; Bit test instructions\n \n (define_insn \"*not_bittst\"\n@@ -1093,45 +1189,108 @@\n \t(smax:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"%0 =max(%1,%2);\"\n+  \"%0 = max(%1,%2);\"\n   [(set_attr \"type\" \"dsp32\")])\n \n (define_insn \"sminsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(smin:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"%0 =min(%1,%2);\"\n+  \"%0 = min(%1,%2);\"\n   [(set_attr \"type\" \"dsp32\")])\n \n (define_insn \"abssi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(abs:SI (match_operand:SI 1 \"register_operand\" \" d\")))]\n+\t(abs:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"%0 =abs %1;\"\n+  \"%0 = abs %1;\"\n   [(set_attr \"type\" \"dsp32\")])\n \n-\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \" d\")))]\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"%0 =-%1;\"\n+  \"%0 = -%1;\"\n   [(set_attr \"type\" \"alu0\")])\n \n+(define_insn \"ssnegsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ss_neg:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = -%1 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \" d\")))]\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"%0 =~%1;\"\n+  \"%0 = ~%1;\"\n   [(set_attr \"type\" \"alu0\")])\n \n+(define_insn \"signbitssi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(if_then_else:HI\n+\t (lt (match_operand:SI 1 \"register_operand\" \"d\") (const_int 0))\n+\t (clz:HI (not:SI (match_dup 1)))\n+\t (clz:HI (match_dup 1))))]\n+  \"\"\n+  \"%h0 = signbits %1;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"smaxhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(smax:HI (match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = max(%1,%2) (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sminhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(smin:HI (match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = min(%1,%2) (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"abshi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(abs:HI (match_operand:HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = abs %1 (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(neg:HI (match_operand:HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = -%1;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"ssneghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_neg:HI (match_operand:HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = -%1 (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"signbitshi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(if_then_else:HI\n+\t (lt (match_operand:HI 1 \"register_operand\" \"d\") (const_int 0))\n+\t (clz:HI (not:HI (match_dup 1)))\n+\t (clz:HI (match_dup 1))))]\n+  \"\"\n+  \"%h0 = signbits %h1;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"%0 *=%2;\"\n+  \"%0 *= %2;\"\n   [(set_attr \"type\" \"mult\")])\n \n (define_expand \"ashlsi3\"\n@@ -2048,6 +2207,159 @@\n \n ;;; Vector instructions\n \n+;; First, all sorts of move variants\n+\n+(define_insn \"movhi_low2high\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0\")\n+\t\t\t(parallel [(const_int 0)]))\n+\t (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(const_int 0)]))))]\n+  \"\"\n+  \"%d0 = %h2 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"movhi_high2high\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0\")\n+\t\t\t(parallel [(const_int 0)]))\n+\t (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%d0 = %d2 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"movhi_low2low\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(const_int 0)]))\n+\t (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0\")\n+\t\t\t(parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %h2 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"movhi_high2low\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(const_int 1)]))\n+\t (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0\")\n+\t\t\t(parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %d2 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"movhiv2hi_low\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (match_operand:HI 2 \"register_operand\" \"d\")\n+\t (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0\")\n+\t\t\t(parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %h2 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"movhiv2hi_high\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0\")\n+\t\t\t(parallel [(const_int 0)]))\n+\t (match_operand:HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%d0 = %h2 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+;; No earlyclobber on alternative two since our sequence ought to be safe.\n+;; The order of operands is intentional to match the VDSP builtin (high word\n+;; is passed first).\n+(define_insn_and_split \"composev2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d,d\")\n+\t(vec_concat:V2HI (match_operand:HI 2 \"register_operand\" \"0,d\")\n+\t\t\t (match_operand:HI 1 \"register_operand\" \"d,d\")))]\n+  \"\"\n+  \"@\n+   %d0 = %h2 << 0;\n+   #\"\n+  \"reload_completed\"\n+  [(set (match_dup 0)\n+\t(vec_concat:V2HI\n+\t (vec_select:HI (match_dup 0) (parallel [(const_int 0)]))\n+\t (match_dup 2)))\n+   (set (match_dup 0)\n+\t(vec_concat:V2HI\n+\t (match_dup 1)\n+\t (vec_select:HI (match_dup 0) (parallel [(const_int 1)]))))]\n+  \"\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+; Like composev2hi, but operating on elements of V2HI vectors.\n+; Useful on its own, and as a combiner bridge for the multiply and\n+; mac patterns.\n+(define_insn \"packv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(vec_concat:V2HI (vec_select:HI\n+\t\t\t  (match_operand:V2HI 1 \"register_operand\" \"d,d,d,d\")\n+\t\t\t  (parallel [(match_operand 3 \"const01_operand\" \"P0,P1,P0,P1\")]))\n+\t\t\t (vec_select:HI\n+\t\t\t  (match_operand:V2HI 2 \"register_operand\" \"d,d,d,d\")\n+\t\t\t  (parallel [(match_operand 4 \"const01_operand\" \"P0,P0,P1,P1\")]))))]\n+  \"\"\n+  \"@\n+   %0 = PACK (%h2,%h1);\n+   %0 = PACK (%h2,%d1);\n+   %0 = PACK (%d2,%h1);\n+   %0 = PACK (%d2,%d1);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"movv2hi_hi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,d\")\n+\t(vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"0,d,d\")\n+\t\t       (parallel [(match_operand:SI 2 \"const01_operand\" \"P0,P0,P1\")])))]\n+  \"\"\n+  \"@\n+   /* optimized out */\n+   %h0 = %h1 << 0;\n+   %h0 = %d1 << 0;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_expand \"movv2hi_hi_low\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"\")\n+\t\t       (parallel [(const_int 0)])))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"movv2hi_hi_high\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"\")\n+\t\t       (parallel [(const_int 1)])))]\n+  \"\"\n+  \"\")\n+\n+;; Unusual arithmetic operations on 16 bit registers.\n+\n+(define_insn \"ssaddhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_plus:HI (match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%h0 = %h1 + %h2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sssubhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_minus:HI (match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%h0 = %h1 - %h2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+;; V2HI vector insns\n+\n (define_insn \"addv2hi3\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n \t(plus:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n@@ -2056,6 +2368,14 @@\n   \"%0 = %1 +|+ %2;\"\n   [(set_attr \"type\" \"dsp32\")])\n \n+(define_insn \"ssaddv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(ss_plus:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 +|+ %2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n (define_insn \"subv2hi3\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n \t(minus:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n@@ -2064,6 +2384,146 @@\n   \"%0 = %1 -|- %2;\"\n   [(set_attr \"type\" \"dsp32\")])\n \n+(define_insn \"sssubv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(ss_minus:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t       (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 -|- %2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"addsubv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (plus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 0)]))\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 0)])))\n+\t (minus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 1)]))\n+\t\t   (vec_select:HI (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"\"\n+  \"%0 = %1 +|- %2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"subaddv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (minus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t  (parallel [(const_int 0)]))\n+\t\t   (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t  (parallel [(const_int 0)])))\n+\t (plus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 1)]))\n+\t\t  (vec_select:HI (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"\"\n+  \"%0 = %1 -|+ %2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"ssaddsubv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (ss_plus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t    (parallel [(const_int 0)]))\n+\t\t     (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t    (parallel [(const_int 0)])))\n+\t (ss_minus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 1)]))\n+\t\t      (vec_select:HI (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"\"\n+  \"%0 = %1 +|- %2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sssubaddv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(vec_concat:V2HI\n+\t (ss_minus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t     (parallel [(const_int 0)]))\n+\t\t      (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t     (parallel [(const_int 0)])))\n+\t (ss_plus:HI (vec_select:HI (match_dup 1) (parallel [(const_int 1)]))\n+\t\t     (vec_select:HI (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"\"\n+  \"%0 = %1 -|+ %2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sublohiv2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(minus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 1)]))\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 0)]))))]\n+  \"\"\n+  \"%h0 = %d1 - %h2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"subhilov2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(minus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 0)]))\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %h1 - %d2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sssublohiv2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_minus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t    (parallel [(const_int 1)]))\n+\t\t     (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t    (parallel [(const_int 0)]))))]\n+  \"\"\n+  \"%h0 = %d1 - %h2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sssubhilov2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_minus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t    (parallel [(const_int 0)]))\n+\t\t     (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t    (parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %h1 - %d2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"addlohiv2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(plus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t(parallel [(const_int 1)]))\n+\t\t (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t(parallel [(const_int 0)]))))]\n+  \"\"\n+  \"%h0 = %d1 + %h2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"addhilov2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(plus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t(parallel [(const_int 0)]))\n+\t\t (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t(parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %h1 + %d2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"ssaddlohiv2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_plus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t   (parallel [(const_int 1)]))\n+\t\t    (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t   (parallel [(const_int 0)]))))]\n+  \"\"\n+  \"%h0 = %d1 + %h2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"ssaddhilov2hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(ss_plus:HI (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t\t   (parallel [(const_int 0)]))\n+\t\t    (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t   (parallel [(const_int 1)]))))]\n+  \"\"\n+  \"%h0 = %h1 + %d2 (S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n (define_insn \"sminv2hi3\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n \t(smin:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n@@ -2080,6 +2540,113 @@\n   \"%0 = MAX (%1, %2) (V);\"\n   [(set_attr \"type\" \"dsp32\")])\n \n+;; Multiplications.\n+\n+;; The Blackfin allows a lot of different options, and we need many patterns to\n+;; cover most of the hardware's abilities.\n+;; There are a few simple patterns using MULT rtx codes, but most of them use\n+;; an unspec with a const_int operand that determines which flag to use in the\n+;; instruction.\n+;; There are variants for single and parallel multiplications.\n+;; There are variants which just use 16 bit lowparts as inputs, and variants\n+;; which allow the user to choose just which halves to use as input values.\n+;; There are variants which set D registers, variants which set accumulators,\n+;; variants which set both, some of them optionally using the accumulators as\n+;; inputs for multiply-accumulate operations.\n+\n+(define_insn \"flag_mulhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(unspec:HI [(match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:HI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t   UNSPEC_MUL_WITH_FLAG))]\n+  \"\"\n+  \"%h0 = %h1 * %h2 %M3;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_mulhisi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:HI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t   UNSPEC_MUL_WITH_FLAG))]\n+  \"\"\n+  \"%0 = %h1 * %h2 %M3;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_mulhisi_parts\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(vec_select:HI\n+\t\t     (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t     (parallel [(match_operand:SI 3 \"const01_operand\" \"P0P1\")]))\n+\t\t    (vec_select:HI\n+\t\t     (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t     (parallel [(match_operand:SI 4 \"const01_operand\" \"P0P1\")]))\n+\t\t    (match_operand 5 \"const_int_operand\" \"n\")]\n+\t\t   UNSPEC_MUL_WITH_FLAG))]\n+  \"\"\n+{\n+  const char *templates[] = {\n+    \"%0 = %h1 * %h2 %M5;\",\n+    \"%0 = %d1 * %h2 %M5;\",\n+    \"%0 = %h1 * %d2 %M5;\",\n+    \"%0 = %d1 * %d2 %M5;\" };\n+  int alt = INTVAL (operands[3]) + (INTVAL (operands[4]) << 1);\n+  return templates[alt];\n+}\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_machi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(unspec:HI [(match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:HI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand 3 \"register_operand\" \"A\")\n+\t\t    (match_operand 4 \"const01_operand\" \"P0P1\")\n+\t\t    (match_operand 5 \"const_int_operand\" \"n\")]\n+\t\t   UNSPEC_MAC_WITH_FLAG))\n+   (set (match_operand:PDI 6 \"register_operand\" \"=A\")\n+\t(unspec:PDI [(match_dup 1) (match_dup 2) (match_dup 3)\n+\t\t     (match_dup 4) (match_dup 5)]\n+\t\t    UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+  \"%h0 = (A0 %b4 %h1 * %h2) %M6;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_machi_acconly\"\n+  [(set (match_operand:PDI 0 \"register_operand\" \"=e\")\n+\t(unspec:PDI [(match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:HI 2 \"register_operand\" \"d\")\n+\t\t     (match_operand 3 \"register_operand\" \"A\")\n+\t\t     (match_operand 4 \"const01_operand\" \"P0P1\")\n+\t\t     (match_operand 5 \"const_int_operand\" \"n\")]\n+\t\t    UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+  \"%0 %b4 %h1 * %h2 %M6;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_macinithi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(unspec:HI [(match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:HI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t   UNSPEC_MAC_WITH_FLAG))\n+   (set (match_operand:PDI 4 \"register_operand\" \"=A\")\n+\t(unspec:PDI [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t    UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+  \"%h0 = (A0 = %h1 * %h2) %M3;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_macinit1hi\"\n+  [(set (match_operand:PDI 0 \"register_operand\" \"=e\")\n+\t(unspec:PDI [(match_operand:HI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:HI 2 \"register_operand\" \"d\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t    UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+  \"%0 = %h1 * %h2 %M3;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n (define_insn \"mulv2hi3\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n \t(mult:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n@@ -2088,9 +2655,305 @@\n   \"%h0 = %h1 * %h2, %d0 = %d1 * %d2 (IS);\"\n   [(set_attr \"type\" \"dsp32\")])\n \n-(define_insn \"negv2hi2\"\n+(define_insn \"flag_mulv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_MUL_WITH_FLAG))]\n+  \"\"\n+  \"%h0 = %h1 * %h2, %d0 = %d1 * %d2 %M3;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_mulv2hi_parts\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(vec_concat:V2HI\n+\t\t       (vec_select:HI\n+\t\t\t(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 3 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI\n+\t\t\t(match_dup 1)\n+\t\t\t(parallel [(match_operand:SI 4 \"const01_operand\" \"P0P1\")])))\n+\t\t      (vec_concat:V2HI\n+\t\t       (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 5 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI (match_dup 2)\n+\t\t\t(parallel [(match_operand:SI 6 \"const01_operand\" \"P0P1\")])))\n+\t\t      (match_operand 7 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_MUL_WITH_FLAG))]\n+  \"\"\n+{\n+  const char *templates[] = {\n+    \"%h0 = %h1 * %h2, %d0 = %h1 * %h2 %M7;\",\n+    \"%h0 = %d1 * %h2, %d0 = %h1 * %h2 %M7;\",\n+    \"%h0 = %h1 * %h2, %d0 = %d1 * %h2 %M7;\",\n+    \"%h0 = %d1 * %h2, %d0 = %d1 * %h2 %M7;\",\n+    \"%h0 = %h1 * %d2, %d0 = %h1 * %h2 %M7;\",\n+    \"%h0 = %d1 * %d2, %d0 = %h1 * %h2 %M7;\",\n+    \"%h0 = %h1 * %d2, %d0 = %d1 * %h2 %M7;\",\n+    \"%h0 = %d1 * %d2, %d0 = %d1 * %h2 %M7;\",\n+    \"%h0 = %h1 * %h2, %d0 = %h1 * %d2 %M7;\",\n+    \"%h0 = %d1 * %h2, %d0 = %h1 * %d2 %M7;\",\n+    \"%h0 = %h1 * %h2, %d0 = %d1 * %d2 %M7;\",\n+    \"%h0 = %d1 * %h2, %d0 = %d1 * %d2 %M7;\",\n+    \"%h0 = %h1 * %d2, %d0 = %h1 * %d2 %M7;\",\n+    \"%h0 = %d1 * %d2, %d0 = %h1 * %d2 %M7;\",\n+    \"%h0 = %h1 * %d2, %d0 = %d1 * %d2 %M7;\",\n+    \"%h0 = %d1 * %d2, %d0 = %d1 * %d2 %M7;\" };\n+  int alt = (INTVAL (operands[3]) + (INTVAL (operands[4]) << 1)\n+\t     + (INTVAL (operands[5]) << 2)  + (INTVAL (operands[6]) << 3));\n+  return templates[alt];\n+}\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+;; A slightly complicated pattern.\n+;; Operand 0 is the halfword output; operand 11 is the accumulator output\n+;; Halfword inputs are operands 1 and 2; operands 3, 4, 5 and 6 specify which\n+;; parts of these 2x16 bit registers to use.\n+;; Operand 7 is the accumulator input.\n+;; Operands 8/9 specify whether low/high parts are mac (0) or msu (1)\n+;; Operand 10 is the macflag to be used.\n+(define_insn \"flag_macv2hi_parts\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(vec_concat:V2HI\n+\t\t       (vec_select:HI\n+\t\t\t(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 3 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI\n+\t\t\t(match_dup 1)\n+\t\t\t(parallel [(match_operand:SI 4 \"const01_operand\" \"P0P1\")])))\n+\t\t      (vec_concat:V2HI\n+\t\t       (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 5 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI (match_dup 2)\n+\t\t\t(parallel [(match_operand:SI 6 \"const01_operand\" \"P0P1\")])))\n+\t\t      (match_operand:V2PDI 7 \"register_operand\" \"e\")\n+\t\t      (match_operand 8 \"const01_operand\" \"P0P1\")\n+\t\t      (match_operand 9 \"const01_operand\" \"P0P1\")\n+\t\t      (match_operand 10 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_MAC_WITH_FLAG))\n+   (set (match_operand:V2PDI 11 \"register_operand\" \"=e\")\n+\t(unspec:V2PDI [(vec_concat:V2HI\n+\t\t\t(vec_select:HI (match_dup 1) (parallel [(match_dup 3)]))\n+\t\t\t(vec_select:HI (match_dup 1) (parallel [(match_dup 4)])))\n+\t\t       (vec_concat:V2HI\n+\t\t\t(vec_select:HI (match_dup 2) (parallel [(match_dup 5)]))\n+\t\t\t(vec_select:HI (match_dup 2) (parallel [(match_dup 5)])))\n+\t\t       (match_dup 7) (match_dup 8) (match_dup 9) (match_dup 10)]\n+\t\t      UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+{\n+  const char *templates[] = {\n+    \"%h0 = (A0 %b8 %h1 * %h2), %d0 = (A1 %b9 %h1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %h2), %d0 = (A1 %b9 %h1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %h2), %d0 = (A1 %b9 %d1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %h2), %d0 = (A1 %b9 %d1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %d2), %d0 = (A1 %b9 %h1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %d2), %d0 = (A1 %b9 %h1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %d2), %d0 = (A1 %b9 %d1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %d2), %d0 = (A1 %b9 %d1 * %h2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %h2), %d0 = (A1 %b9 %h1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %h2), %d0 = (A1 %b9 %h1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %h2), %d0 = (A1 %b9 %d1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %h2), %d0 = (A1 %b9 %d1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %d2), %d0 = (A1 %b9 %h1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %d2), %d0 = (A1 %b9 %h1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %h1 * %d2), %d0 = (A1 %b9 %d1 * %d2) %M10;\",\n+    \"%h0 = (A0 %b8 %d1 * %d2), %d0 = (A1 %b9 %d1 * %d2) %M10;\" };\n+  int alt = (INTVAL (operands[3]) + (INTVAL (operands[4]) << 1)\n+\t     + (INTVAL (operands[5]) << 2)  + (INTVAL (operands[6]) << 3));\n+  return templates[alt];\n+}\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_macv2hi_parts_acconly\"\n+  [(set (match_operand:V2PDI 0 \"register_operand\" \"=e\")\n+\t(unspec:V2PDI [(vec_concat:V2HI\n+\t\t\t(vec_select:HI\n+\t\t\t (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t (parallel [(match_operand:SI 3 \"const01_operand\" \"P0P1\")]))\n+\t\t\t(vec_select:HI\n+\t\t\t (match_dup 1)\n+\t\t\t (parallel [(match_operand:SI 4 \"const01_operand\" \"P0P1\")])))\n+\t\t       (vec_concat:V2HI\n+\t\t\t(vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t       (parallel [(match_operand:SI 5 \"const01_operand\" \"P0P1\")]))\n+\t\t\t(vec_select:HI (match_dup 2)\n+\t\t\t\t       (parallel [(match_operand:SI 6 \"const01_operand\" \"P0P1\")])))\n+\t\t       (match_operand:V2PDI 7 \"register_operand\" \"e\")\n+\t\t       (match_operand 8 \"const01_operand\" \"P0P1\")\n+\t\t       (match_operand 9 \"const01_operand\" \"P0P1\")\n+\t\t       (match_operand 10 \"const_int_operand\" \"n\")]\n+\t\t      UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+{\n+  const char *templates[] = {\n+    \"A0 %b8 %h1 * %h2, A1 %b9 %h1 * %h2 %M10;\",\n+    \"A0 %b8 %d1 * %h2, A1 %b9 %h1 * %h2 %M10;\",\n+    \"A0 %b8 %h1 * %h2, A1 %b9 %d1 * %h2 %M10;\",\n+    \"A0 %b8 %d1 * %h2, A1 %b9 %d1 * %h2 %M10;\",\n+    \"A0 %b8 %h1 * %d2, A1 %b9 %h1 * %h2 %M10;\",\n+    \"A0 %b8 %d1 * %d2, A1 %b9 %h1 * %h2 %M10;\",\n+    \"A0 %b8 %h1 * %d2, A1 %b9 %d1 * %h2 %M10;\",\n+    \"A0 %b8 %d1 * %d2, A1 %b9 %d1 * %h2 %M10;\",\n+    \"A0 %b8 %h1 * %h2, A1 %b9 %h1 * %d2 %M10;\",\n+    \"A0 %b8 %d1 * %h2, A1 %b9 %h1 * %d2 %M10;\",\n+    \"A0 %b8 %h1 * %h2, A1 %b9 %d1 * %d2 %M10;\",\n+    \"A0 %b8 %d1 * %h2, A1 %b9 %d1 * %d2 %M10;\",\n+    \"A0 %b8 %h1 * %d2, A1 %b9 %h1 * %d2 %M10;\",\n+    \"A0 %b8 %d1 * %d2, A1 %b9 %h1 * %d2 %M10;\",\n+    \"A0 %b8 %h1 * %d2, A1 %b9 %d1 * %d2 %M10;\",\n+    \"A0 %b8 %d1 * %d2, A1 %b9 %d1 * %d2 %M10;\" };\n+  int alt = (INTVAL (operands[3]) + (INTVAL (operands[4]) << 1)\n+\t     + (INTVAL (operands[5]) << 2)  + (INTVAL (operands[6]) << 3));\n+  return templates[alt];\n+}\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+;; Same as above, but initializing the accumulators and therefore a couple fewer\n+;; necessary operands.\n+(define_insn \"flag_macinitv2hi_parts\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n-\t(neg:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")))]\n+\t(unspec:V2HI [(vec_concat:V2HI\n+\t\t       (vec_select:HI\n+\t\t\t(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 3 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI\n+\t\t\t(match_dup 1)\n+\t\t\t(parallel [(match_operand:SI 4 \"const01_operand\" \"P0P1\")])))\n+\t\t      (vec_concat:V2HI\n+\t\t       (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 5 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI (match_dup 2)\n+\t\t\t(parallel [(match_operand:SI 6 \"const01_operand\" \"P0P1\")])))\n+\t\t      (match_operand 7 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_MAC_WITH_FLAG))\n+   (set (match_operand:V2PDI 8 \"register_operand\" \"=e\")\n+\t(unspec:V2PDI [(vec_concat:V2HI\n+\t\t\t(vec_select:HI (match_dup 1) (parallel [(match_dup 3)]))\n+\t\t\t(vec_select:HI (match_dup 1) (parallel [(match_dup 4)])))\n+\t\t       (vec_concat:V2HI\n+\t\t\t(vec_select:HI (match_dup 2) (parallel [(match_dup 5)]))\n+\t\t\t(vec_select:HI (match_dup 2) (parallel [(match_dup 5)])))\n+\t\t       (match_dup 7)]\n+\t\t      UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+{\n+  const char *templates[] = {\n+    \"%h0 = (A0 = %h1 * %h2), %d0 = (A1 = %h1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %h2), %d0 = (A1 = %h1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %h2), %d0 = (A1 = %d1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %h2), %d0 = (A1 = %d1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %d2), %d0 = (A1 = %h1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %d2), %d0 = (A1 = %h1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %d2), %d0 = (A1 = %d1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %d2), %d0 = (A1 = %d1 * %h2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %h2), %d0 = (A1 = %h1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %h2), %d0 = (A1 = %h1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %h2), %d0 = (A1 = %d1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %h2), %d0 = (A1 = %d1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %d2), %d0 = (A1 = %h1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %d2), %d0 = (A1 = %h1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %h1 * %d2), %d0 = (A1 = %d1 * %d2) %M7;\",\n+    \"%h0 = (A0 = %d1 * %d2), %d0 = (A1 = %d1 * %d2) %M7;\" };\n+  int alt = (INTVAL (operands[3]) + (INTVAL (operands[4]) << 1)\n+\t     + (INTVAL (operands[5]) << 2)  + (INTVAL (operands[6]) << 3));\n+  return templates[alt];\n+}\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"flag_macinit1v2hi_parts\"\n+  [(set (match_operand:V2PDI 0 \"register_operand\" \"=e\")\n+\t(unspec:V2PDI [(vec_concat:V2HI\n+\t\t       (vec_select:HI\n+\t\t\t(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 3 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI\n+\t\t\t(match_dup 1)\n+\t\t\t(parallel [(match_operand:SI 4 \"const01_operand\" \"P0P1\")])))\n+\t\t      (vec_concat:V2HI\n+\t\t       (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t(parallel [(match_operand:SI 5 \"const01_operand\" \"P0P1\")]))\n+\t\t       (vec_select:HI (match_dup 2)\n+\t\t\t(parallel [(match_operand:SI 6 \"const01_operand\" \"P0P1\")])))\n+\t\t      (match_operand 7 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_MAC_WITH_FLAG))]\n+  \"\"\n+{\n+  const char *templates[] = {\n+    \"A0 = %h1 * %h2, A1 = %h1 * %h2 %M7;\",\n+    \"A0 = %d1 * %h2, A1 = %h1 * %h2 %M7;\",\n+    \"A0 = %h1 * %h2, A1 = %d1 * %h2 %M7;\",\n+    \"A0 = %d1 * %h2, A1 = %d1 * %h2 %M7;\",\n+    \"A0 = %h1 * %d2, A1 = %h1 * %h2 %M7;\",\n+    \"A0 = %d1 * %d2, A1 = %h1 * %h2 %M7;\",\n+    \"A0 = %h1 * %d2, A1 = %d1 * %h2 %M7;\",\n+    \"A0 = %d1 * %d2, A1 = %d1 * %h2 %M7;\",\n+    \"A0 = %h1 * %h2, A1 = %h1 * %d2 %M7;\",\n+    \"A0 = %d1 * %h2, A1 = %h1 * %d2 %M7;\",\n+    \"A0 = %h1 * %h2, A1 = %d1 * %d2 %M7;\",\n+    \"A0 = %d1 * %h2, A1 = %d1 * %d2 %M7;\",\n+    \"A0 = %h1 * %d2, A1 = %h1 * %d2 %M7;\",\n+    \"A0 = %d1 * %d2, A1 = %h1 * %d2 %M7;\",\n+    \"A0 = %h1 * %d2, A1 = %d1 * %d2 %M7;\",\n+    \"A0 = %d1 * %d2, A1 = %d1 * %d2 %M7;\" };\n+  int alt = (INTVAL (operands[3]) + (INTVAL (operands[4]) << 1)\n+\t     + (INTVAL (operands[5]) << 2)  + (INTVAL (operands[6]) << 3));\n+  return templates[alt];\n+}\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"mulhisi_ll\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"%d\")\n+\t\t\t\t (parallel [(const_int 0)])))\n+\t\t (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 0)])))))]\n+  \"\"\n+  \"%0 = %h1 * %h2 (IS);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"mulhisi_lh\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"%d\")\n+\t\t\t\t (parallel [(const_int 0)])))\n+\t\t (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 1)])))))]\n+  \"\"\n+  \"%0 = %h1 * %d2 (IS);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"mulhisi_hl\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"%d\")\n+\t\t\t\t (parallel [(const_int 1)])))\n+\t\t (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 0)])))))]\n+  \"\"\n+  \"%0 = %d1 * %h2 (IS);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"mulhisi_hh\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 1 \"register_operand\" \"%d\")\n+\t\t\t\t (parallel [(const_int 1)])))\n+\t\t (sign_extend:SI\n+\t\t  (vec_select:HI (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t\t\t (parallel [(const_int 1)])))))]\n+  \"\"\n+  \"%0 = %d1 * %d2 (IS);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"ssnegv2hi2\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(ss_neg:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")))]\n   \"\"\n   \"%0 = - %1 (V);\"\n   [(set_attr \"type\" \"dsp32\")])\n@@ -2102,3 +2965,61 @@\n   \"%0 = ABS %1 (V);\"\n   [(set_attr \"type\" \"dsp32\")])\n \n+;; Shifts.\n+\n+(define_insn \"ssashiftv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d,d,d\")\n+\t(if_then_else:V2HI\n+\t (lt (match_operand:SI 2 \"vec_shift_operand\" \"d,Ku4,Ks4\") (const_int 0))\n+\t (ashiftrt:V2HI (match_operand:V2HI 1 \"register_operand\" \"d,d,d\")\n+\t\t\t(match_dup 2))\n+\t (ss_ashift:V2HI (match_dup 1) (match_dup 2))))]\n+  \"\"\n+  \"@\n+   %0 = ASHIFT %1 BY %2 (V, S);\n+   %0 = %1 >>> %2 (V,S);\n+   %0 = %1 << %2 (V,S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"ssashifthi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,d\")\n+\t(if_then_else:HI\n+\t (lt (match_operand:SI 2 \"vec_shift_operand\" \"d,Ku4,Ks4\") (const_int 0))\n+\t (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"d,d,d\")\n+\t\t      (match_dup 2))\n+\t (ss_ashift:HI (match_dup 1) (match_dup 2))))]\n+  \"\"\n+  \"@\n+   %0 = ASHIFT %1 BY %2 (V, S);\n+   %0 = %1 >>> %2 (V,S);\n+   %0 = %1 << %2 (V,S);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"lshiftv2hi3\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d,d,d\")\n+\t(if_then_else:V2HI\n+\t (lt (match_operand:SI 2 \"vec_shift_operand\" \"d,Ku4,Ks4\") (const_int 0))\n+\t (lshiftrt:V2HI (match_operand:V2HI 1 \"register_operand\" \"d,d,d\")\n+\t\t\t(match_dup 2))\n+\t (ashift:V2HI (match_dup 1) (match_dup 2))))]\n+  \"\"\n+  \"@\n+   %0 = LSHIFT %1 BY %2 (V);\n+   %0 = %1 >> %2 (V);\n+   %0 = %1 << %2 (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"lshifthi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,d\")\n+\t(if_then_else:HI\n+\t (lt (match_operand:SI 2 \"vec_shift_operand\" \"d,Ku4,Ks4\") (const_int 0))\n+\t (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"d,d,d\")\n+\t\t      (match_dup 2))\n+\t (ashift:HI (match_dup 1) (match_dup 2))))]\n+  \"\"\n+  \"@\n+   %0 = LSHIFT %1 BY %2 (V);\n+   %0 = %1 >> %2 (V);\n+   %0 = %1 << %2 (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+"}, {"sha": "ee7de7af31575afa325ddeb5cac2167c5408d0a7", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -56,6 +56,14 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_code \"const_int\")))\n \n+(define_predicate \"const01_operand\"\n+  (match_test \"op == const0_rtx || op == const1_rtx\"))\n+\n+(define_predicate \"vec_shift_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"INTVAL (op) >= -16 && INTVAL (op) < 15\"))\n+       (match_operand 0 \"register_operand\")))\n+\n ;; Like register_operand, but make sure that hard regs have a valid mode.\n (define_predicate \"valid_reg_operand\"\n   (match_operand 0 \"register_operand\")"}, {"sha": "0a70dea23e6f86a9ea489d19709050238c94c6c4", "filename": "gcc/genmodes.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d8b2d0146828137667471dd99e713bc3608342/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=75d8b2d0146828137667471dd99e713bc3608342", "patch": "@@ -635,7 +635,9 @@ make_vector_mode (enum mode_class bclass,\n       error (\"%s:%d: no mode \\\"%s\\\"\", file, line, base);\n       return;\n     }\n-  if (component->cl != bclass)\n+  if (component->cl != bclass\n+      && (component->cl != MODE_PARTIAL_INT\n+\t  || bclass != MODE_INT))\n     {\n       error (\"%s:%d: mode \\\"%s\\\" is not class %s\",\n \t     file, line, base, mode_class_names[bclass] + 5);"}]}