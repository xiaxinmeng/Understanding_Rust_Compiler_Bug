{"sha": "473fd99a4ca248ade8f6d648e4b688695055c1ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczZmQ5OWE0Y2EyNDhhZGU4ZjZkNjQ4ZTRiNjg4Njk1MDU1YzFlZQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2014-04-11T18:12:53Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2014-04-11T18:12:53Z"}, "message": "re PR rtl-optimization/60651 (Mode switching instructions are sometimes emitted in the wrong order)\n\ngcc:\n        PR rtl-optimization/60651\n        * mode-switching.c (optimize_mode_switching): Make sure to emit\n        sets of a lower numbered entity before sets of a higher numbered\n        entity to a mode of the same or lower priority.\n        When creating a seginfo for a basic block that starts with a code\n        label, move the insertion point past the code label.\n        (new_seginfo): Document and enforce requirement that\n        NOTE_INSN_BASIC_BLOCK only appears for empty blocks.\n        * doc/tm.texi.in: Document ordering constraint for emitted mode sets.\n        * doc/tm.texi: Regenerate.\ngcc/testsuite:\n        PR rtl-optimization/60651\n        * gcc.target/epiphany/mode-switch.c: New test.\n\nFrom-SVN: r209312", "tree": {"sha": "905e1d1e868f4a9ffc9623f4e3fc998cb02a312a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/905e1d1e868f4a9ffc9623f4e3fc998cb02a312a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473fd99a4ca248ade8f6d648e4b688695055c1ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473fd99a4ca248ade8f6d648e4b688695055c1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473fd99a4ca248ade8f6d648e4b688695055c1ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473fd99a4ca248ade8f6d648e4b688695055c1ee/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ace1161e62a9f09b36ef2dc0dacad97371e9dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ace1161e62a9f09b36ef2dc0dacad97371e9dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ace1161e62a9f09b36ef2dc0dacad97371e9dd0"}], "stats": {"total": 48, "additions": 45, "deletions": 3}, "files": [{"sha": "32ed05f445221159cf5e892af598893951f2449c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=473fd99a4ca248ade8f6d648e4b688695055c1ee", "patch": "@@ -1,3 +1,16 @@\n+2014-04-11  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR rtl-optimization/60651\n+\t* mode-switching.c (optimize_mode_switching): Make sure to emit\n+\tsets of a lower numbered entity before sets of a higher numbered\n+\tentity to a mode of the same or lower priority.\n+\tWhen creating a seginfo for a basic block that starts with a code\n+\tlabel, move the insertion point past the code label.\n+\t(new_seginfo): Document and enforce requirement that\n+\tNOTE_INSN_BASIC_BLOCK only appears for empty blocks.\n+\t* doc/tm.texi.in: Document ordering constraint for emitted mode sets.\n+\t* doc/tm.texi: Regenerate.\n+\n 2014-01-11  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR target/60811"}, {"sha": "b8ca17e001d2176bb973e535fa66c3b2141f7eb5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=473fd99a4ca248ade8f6d648e4b688695055c1ee", "patch": "@@ -9778,6 +9778,8 @@ for @var{entity}.  For any fixed @var{entity}, @code{mode_priority_to_mode}\n Generate one or more insns to set @var{entity} to @var{mode}.\n @var{hard_reg_live} is the set of hard registers live at the point where\n the insn(s) are to be inserted.\n+Sets of a lower numbered entity will be emitted before sets of a higher\n+numbered entity to a mode of the same or lower priority.\n @end defmac\n \n @node Target Attributes"}, {"sha": "d793d265cbea1f05b6d2437511419d24cf411339", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=473fd99a4ca248ade8f6d648e4b688695055c1ee", "patch": "@@ -7447,6 +7447,8 @@ for @var{entity}.  For any fixed @var{entity}, @code{mode_priority_to_mode}\n Generate one or more insns to set @var{entity} to @var{mode}.\n @var{hard_reg_live} is the set of hard registers live at the point where\n the insn(s) are to be inserted.\n+Sets of a lower numbered entity will be emitted before sets of a higher\n+numbered entity to a mode of the same or lower priority.\n @end defmac\n \n @node Target Attributes"}, {"sha": "2848da34c1f6b8950cfe82221cc7d19dcbfa2ec4", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=473fd99a4ca248ade8f6d648e4b688695055c1ee", "patch": "@@ -96,12 +96,18 @@ static void make_preds_opaque (basic_block, int);\n \f\n \n /* This function will allocate a new BBINFO structure, initialized\n-   with the MODE, INSN, and basic block BB parameters.  */\n+   with the MODE, INSN, and basic block BB parameters.\n+   INSN may not be a NOTE_INSN_BASIC_BLOCK, unless it is an empty\n+   basic block; that allows us later to insert instructions in a FIFO-like\n+   manner.  */\n \n static struct seginfo *\n new_seginfo (int mode, rtx insn, int bb, HARD_REG_SET regs_live)\n {\n   struct seginfo *ptr;\n+\n+  gcc_assert (!NOTE_INSN_BASIC_BLOCK_P (insn)\n+\t      || insn == BB_END (NOTE_BASIC_BLOCK (insn)));\n   ptr = XNEW (struct seginfo);\n   ptr->mode = mode;\n   ptr->insn_ptr = insn;\n@@ -534,7 +540,13 @@ optimize_mode_switching (void)\n \t\tbreak;\n \t    if (e)\n \t      {\n-\t\tptr = new_seginfo (no_mode, BB_HEAD (bb), bb->index, live_now);\n+\t\trtx ins_pos = BB_HEAD (bb);\n+\t\tif (LABEL_P (ins_pos))\n+\t\t  ins_pos = NEXT_INSN (ins_pos);\n+\t\tgcc_assert (NOTE_INSN_BASIC_BLOCK_P (ins_pos));\n+\t\tif (ins_pos != BB_END (bb))\n+\t\t  ins_pos = NEXT_INSN (ins_pos);\n+\t\tptr = new_seginfo (no_mode, ins_pos, bb->index, live_now);\n \t\tadd_seginfo (info + bb->index, ptr);\n \t\tbitmap_clear_bit (transp[bb->index], j);\n \t      }\n@@ -733,7 +745,15 @@ optimize_mode_switching (void)\n \t\t    {\n \t\t      emitted = true;\n \t\t      if (NOTE_INSN_BASIC_BLOCK_P (ptr->insn_ptr))\n-\t\t\temit_insn_after (mode_set, ptr->insn_ptr);\n+\t\t\t/* We need to emit the insns in a FIFO-like manner,\n+\t\t\t   i.e. the first to be emitted at our insertion\n+\t\t\t   point ends up first in the instruction steam.\n+\t\t\t   Because we made sure that NOTE_INSN_BASIC_BLOCK is\n+\t\t\t   only used for initially empty basic blocks, we\n+\t\t\t   can archive this by appending at the end of\n+\t\t\t   the block.  */\n+\t\t\temit_insn_after\n+\t\t\t  (mode_set, BB_END (NOTE_BASIC_BLOCK (ptr->insn_ptr)));\n \t\t      else\n \t\t\temit_insn_before (mode_set, ptr->insn_ptr);\n \t\t    }"}, {"sha": "e7f800a1cb1aafa9669ecbdc7946235a062076ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fd99a4ca248ade8f6d648e4b688695055c1ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=473fd99a4ca248ade8f6d648e4b688695055c1ee", "patch": "@@ -1,3 +1,8 @@\n+2014-04-11  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR rtl-optimization/60651\n+\t* gcc.target/epiphany/mode-switch.c: New test.\n+\n 2014-04-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58600"}]}