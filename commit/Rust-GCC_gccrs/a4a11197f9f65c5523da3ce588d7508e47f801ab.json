{"sha": "a4a11197f9f65c5523da3ce588d7508e47f801ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRhMTExOTdmOWY2NWM1NTIzZGEzY2U1ODhkNzUwOGU0N2Y4MDFhYg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-20T04:30:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-20T04:30:48Z"}, "message": "re PR fortran/25049 (TRANSPOSE not allowed in initialisation expression)\n\n2006-06-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25049\n\tPR fortran/25050\n\t* check.c (non_init_transformational): New function.\n\t(find_substring_ref): New function to signal use of disallowed\n\ttransformational intrinsic in an initialization expression.\n\t(gfc_check_all_any): Call previous if initialization expr.\n\t(gfc_check_count): The same.\n\t(gfc_check_cshift): The same.\n\t(gfc_check_dot_product): The same.\n\t(gfc_check_eoshift): The same.\n\t(gfc_check_minloc_maxloc): The same.\n\t(gfc_check_minval_maxval): The same.\n\t(gfc_check_gfc_check_product_sum): The same.\n\t(gfc_check_pack): The same.\n\t(gfc_check_spread): The same.\n\t(gfc_check_transpose): The same.\n\t(gfc_check_unpack): The same.\n\n\tPR fortran/18769\n\t*intrinsic.c (add_functions): Add gfc_simplify_transfer.\n\t*intrinsic.h : Add prototype for gfc_simplify_transfer.\n\t*simplify.c (gfc_simplify_transfer) : New function to act as\n\tplaceholder for eventual implementation.  Emit error for now.\n\n\tPR fortran/16206\n\t* expr.c (find_array_element): Eliminate condition on length of\n\toffset. Add bounds checking. Rearrange exit. Return try and\n\tput gfc_constructor result as an argument.\n\t(find_array_section): New function.\n\t(find_substring_ref): New function.\n\t(simplify_const_ref): Add calls to previous.\n\t(simplify_parameter_variable): Return on NULL expr.\n\t(gfc_simplify_expr): Only call gfc_expand_constructor for full\n\tarrays.\n\n\tPR fortran/20876\n\t* match.c (gfc_match_forall): Add missing locus to gfc_code.\n\n2006-06-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR libfortran/28005\n\t* m4/matmul.m4: aystride = 1 does not uniquely detect the\n\tpresence of a temporary transpose; an array element in the\n\tfirst dimension produces the same signature.  Detect this\n\tusing the rank of a and add specific code.\n\t* generated/matmul_r4.c: Regenerate.\n\t* generated/matmul_r8.c: Regenerate.\n\t* generated/matmul_r10.c: Regenerate.\n\t* generated/matmul_r16.c: Regenerate.\n\t* generated/matmul_c4.c: Regenerate.\n\t* generated/matmul_c8.c: Regenerate.\n\t* generated/matmul_c10.c: Regenerate.\n\t* generated/matmul_c16.c: Regenerate.\n\t* generated/matmul_i4.c: Regenerate.\n\t* generated/matmul_i8.c: Regenerate.\n\t* generated/matmul_i16.c: Regenerate.\n\n2006-06-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16206\n\t* gfortran.dg/array_initializer_1.f90: New test.\n\n\tPR fortran/28005\n\t* gfortran.dg/matmul_3.f90: New test.\n\nFrom-SVN: r114802", "tree": {"sha": "ac18f8deb5aff7c9354a8879e1c428d69345b10f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac18f8deb5aff7c9354a8879e1c428d69345b10f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4a11197f9f65c5523da3ce588d7508e47f801ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4a11197f9f65c5523da3ce588d7508e47f801ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4a11197f9f65c5523da3ce588d7508e47f801ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4a11197f9f65c5523da3ce588d7508e47f801ab/comments", "author": null, "committer": null, "parents": [{"sha": "73dab33bce6cc186f05ac0cf45e42c58f9086b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73dab33bce6cc186f05ac0cf45e42c58f9086b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73dab33bce6cc186f05ac0cf45e42c58f9086b3c"}], "stats": {"total": 1011, "additions": 851, "deletions": 160}, "files": [{"sha": "d872fe7f2a35b3f36112734f0c1fe747b18cf336", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -1,3 +1,43 @@\n+2006-06-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25049\n+\tPR fortran/25050\n+\t* check.c (non_init_transformational): New function.\n+\t(find_substring_ref): New function to signal use of disallowed\n+\ttransformational intrinsic in an initialization expression.\n+\t(gfc_check_all_any): Call previous if initialization expr.\n+\t(gfc_check_count): The same.\n+\t(gfc_check_cshift): The same.\n+\t(gfc_check_dot_product): The same.\n+\t(gfc_check_eoshift): The same.\n+\t(gfc_check_minloc_maxloc): The same.\n+\t(gfc_check_minval_maxval): The same.\n+\t(gfc_check_gfc_check_product_sum): The same.\n+\t(gfc_check_pack): The same.\n+\t(gfc_check_spread): The same.\n+\t(gfc_check_transpose): The same.\n+\t(gfc_check_unpack): The same.\n+\n+\tPR fortran/18769\n+\t*intrinsic.c (add_functions): Add gfc_simplify_transfer.\n+\t*intrinsic.h : Add prototype for gfc_simplify_transfer.\n+\t*simplify.c (gfc_simplify_transfer) : New function to act as\n+\tplaceholder for eventual implementation.  Emit error for now.\n+\n+\tPR fortran/16206\n+\t* expr.c (find_array_element): Eliminate condition on length of\n+\toffset. Add bounds checking. Rearrange exit. Return try and\n+\tput gfc_constructor result as an argument.\n+\t(find_array_section): New function.\n+\t(find_substring_ref): New function.\n+\t(simplify_const_ref): Add calls to previous.\n+\t(simplify_parameter_variable): Return on NULL expr.\n+\t(gfc_simplify_expr): Only call gfc_expand_constructor for full\n+\tarrays.\n+\n+\tPR fortran/20876\n+\t* match.c (gfc_match_forall): Add missing locus to gfc_code.\n+\n 2006-06-18  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/26801"}, {"sha": "6ca52466fb4065a5b0239328ef1f134595ab0e5b", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -378,6 +378,18 @@ identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n   return ret;\n }\n \n+/* Error return for transformational intrinsics not allowed in\n+   initalization expressions.  */\n+ \n+static try\n+non_init_transformational (void)\n+{\n+  gfc_error (\"transformational intrinsic '%s' at %L is not permitted \"\n+\t     \"in an initialization expression\", gfc_current_intrinsic,\n+\t     gfc_current_intrinsic_where);\n+  return FAILURE;\n+}\n+\n /***** Check functions *****/\n \n /* Check subroutine suitable for intrinsics taking a real argument and\n@@ -439,6 +451,9 @@ gfc_check_all_any (gfc_expr * mask, gfc_expr * dim)\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -724,6 +739,9 @@ gfc_check_count (gfc_expr * mask, gfc_expr * dim)\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -747,6 +765,9 @@ gfc_check_cshift (gfc_expr * array, gfc_expr * shift, gfc_expr * dim)\n   if (dim_check (dim, 2, 1) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -848,6 +869,9 @@ gfc_check_dot_product (gfc_expr * vector_a, gfc_expr * vector_b)\n       return FAILURE;\n     }\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -883,6 +907,9 @@ gfc_check_eoshift (gfc_expr * array, gfc_expr * shift, gfc_expr * boundary,\n   if (dim_check (dim, 1, 1) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -1545,6 +1572,9 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n       return FAILURE;\n     }\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -1605,6 +1635,9 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n \treturn FAILURE;\n     }\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -1673,6 +1706,9 @@ gfc_check_minval_maxval (gfc_actual_arglist * ap)\n       || array_check (ap->expr, 0) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return check_reduction (ap);\n }\n \n@@ -1684,6 +1720,9 @@ gfc_check_product_sum (gfc_actual_arglist * ap)\n       || array_check (ap->expr, 0) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return check_reduction (ap);\n }\n \n@@ -1781,6 +1820,9 @@ gfc_check_pack (gfc_expr * array, gfc_expr * mask, gfc_expr * vector)\n       /* TODO: More constraints here.  */\n     }\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -2152,6 +2194,9 @@ gfc_check_spread (gfc_expr * source, gfc_expr * dim, gfc_expr * ncopies)\n   if (scalar_check (ncopies, 2) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -2367,6 +2412,9 @@ gfc_check_transpose (gfc_expr * matrix)\n   if (rank_check (matrix, 0, 2) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n \n@@ -2405,6 +2453,9 @@ gfc_check_unpack (gfc_expr * vector, gfc_expr * mask, gfc_expr * field)\n   if (same_type_check (vector, 0, field, 2) == FAILURE)\n     return FAILURE;\n \n+  if (gfc_init_expr)\n+    return non_init_transformational ();\n+\n   return SUCCESS;\n }\n "}, {"sha": "4b037983616f56769a021ead2287499bb862be16", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 309, "deletions": 27, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -902,50 +902,70 @@ simplify_constructor (gfc_constructor * c, int type)\n \n /* Pull a single array element out of an array constructor.  */\n \n-static gfc_constructor *\n-find_array_element (gfc_constructor * cons, gfc_array_ref * ar)\n+static try\n+find_array_element (gfc_constructor * cons, gfc_array_ref * ar,\n+\t\t    gfc_constructor ** rval)\n {\n   unsigned long nelemen;\n   int i;\n   mpz_t delta;\n   mpz_t offset;\n+  gfc_expr *e;\n+  try t;\n+\n+  t = SUCCESS;\n+  e = NULL;\n \n   mpz_init_set_ui (offset, 0);\n   mpz_init (delta);\n   for (i = 0; i < ar->dimen; i++)\n     {\n-      if (ar->start[i]->expr_type != EXPR_CONSTANT)\n+      e = gfc_copy_expr (ar->start[i]);\n+      if (e->expr_type != EXPR_CONSTANT)\n \t{\n \t  cons = NULL;\n-\t  break;\n+\t  goto depart;\n \t}\n-      mpz_sub (delta, ar->start[i]->value.integer,\n+\n+      /* Check the bounds.  */\n+      if (ar->as->upper[i]\n+\t    && (mpz_cmp (e->value.integer,\n+\t\t\tar->as->upper[i]->value.integer) > 0\n+\t    || mpz_cmp (e->value.integer,\n+\t\t\tar->as->lower[i]->value.integer) < 0))\n+\t{\n+\t  gfc_error (\"index in dimension %d is out of bounds \"\n+\t\t     \"at %L\", i + 1, &ar->c_where[i]);\n+\t  cons = NULL;\n+\t  t = FAILURE;\n+\t  goto depart;\n+\t}\n+\n+      mpz_sub (delta, e->value.integer,\n \t       ar->as->lower[i]->value.integer);\n       mpz_add (offset, offset, delta);\n     }\n \n   if (cons)\n     {\n-      if (mpz_fits_ulong_p (offset))\n+      for (nelemen = mpz_get_ui (offset); nelemen > 0; nelemen--)\n \t{\n-\t  for (nelemen = mpz_get_ui (offset); nelemen > 0; nelemen--)\n+\t  if (cons->iterator)\n \t    {\n-\t      if (cons->iterator)\n-\t\t{\n-\t\t  cons = NULL;\n-\t\t  break;\n-\t\t}\n-\t      cons = cons->next;\n+\t      cons = NULL;\n+\t      goto depart;\n \t    }\n+\t  cons = cons->next;\n \t}\n-      else\n-\tcons = NULL;\n     }\n \n+depart:\n   mpz_clear (delta);\n   mpz_clear (offset);\n-\n-  return cons;\n+  if (e)\n+    gfc_free_expr (e);\n+  *rval = cons;\n+  return t;\n }\n \n \n@@ -985,13 +1005,248 @@ remove_subobject_ref (gfc_expr * p, gfc_constructor * cons)\n }\n \n \n+/* Pull an array section out of an array constructor.  */\n+\n+static try\n+find_array_section (gfc_expr *expr, gfc_ref *ref)\n+{\n+  int idx;\n+  int rank;\n+  int d;\n+  long unsigned one = 1;\n+  mpz_t end[GFC_MAX_DIMENSIONS];\n+  mpz_t stride[GFC_MAX_DIMENSIONS];\n+  mpz_t delta[GFC_MAX_DIMENSIONS];\n+  mpz_t ctr[GFC_MAX_DIMENSIONS];\n+  mpz_t delta_mpz;\n+  mpz_t tmp_mpz;\n+  mpz_t nelts;\n+  mpz_t ptr;\n+  mpz_t stop;\n+  mpz_t index;\n+  gfc_constructor *cons;\n+  gfc_constructor *base;\n+  gfc_expr *begin;\n+  gfc_expr *finish;\n+  gfc_expr *step;\n+  gfc_expr *upper;\n+  gfc_expr *lower;\n+  try t;\n+\n+  t = SUCCESS;\n+\n+  base = expr->value.constructor;\n+  expr->value.constructor = NULL;\n+\n+  rank = ref->u.ar.as->rank;\n+\n+  if (expr->shape == NULL)\n+    expr->shape = gfc_get_shape (rank);\n+\n+  mpz_init_set_ui (delta_mpz, one);\n+  mpz_init_set_ui (nelts, one);\n+  mpz_init (tmp_mpz);\n+\n+  /* Do the initialization now, so that we can cleanup without\n+     keeping track of where we were.  */\n+  for (d = 0; d < rank; d++)\n+    {\n+      mpz_init (delta[d]);\n+      mpz_init (end[d]);\n+      mpz_init (ctr[d]);\n+      mpz_init (stride[d]);\n+    }\n+\n+  /* Build the counters to clock through the array reference.  */\n+  for (d = 0; d < rank; d++)\n+    {\n+      /* Make this stretch of code easier on the eye!  */\n+      begin = ref->u.ar.start[d];\n+      finish = ref->u.ar.end[d];\n+      step = ref->u.ar.stride[d];\n+      lower = ref->u.ar.as->lower[d];\n+      upper = ref->u.ar.as->upper[d];\n+\n+      if ((begin && begin->expr_type != EXPR_CONSTANT)\n+\t    || (finish && finish->expr_type != EXPR_CONSTANT)\n+\t    || (step && step->expr_type != EXPR_CONSTANT))\n+\t{\n+\t  t = FAILURE;\n+\t  goto cleanup;\n+\t}\n+\n+      /* Obtain the stride.  */\n+      if (step)\n+\tmpz_set (stride[d], step->value.integer);\n+      else\n+\tmpz_set_ui (stride[d], one);\n+\n+      if (mpz_cmp_ui (stride[d], 0) == 0)\n+\tmpz_set_ui (stride[d], one);\n+\n+      /* Obtain the start value for the index.  */\n+      if (begin->value.integer)\n+\t  mpz_set (ctr[d], begin->value.integer);\n+      else\n+\t{\n+\t  if (mpz_cmp_si (stride[d], 0) < 0)\n+\t    mpz_set (ctr[d], upper->value.integer);\n+\t  else\n+\t    mpz_set (ctr[d], lower->value.integer);\n+\t}\n+\n+      /* Obtain the end value for the index.  */\n+      if (finish)\n+        mpz_set (end[d], finish->value.integer);\n+      else\n+\t{\n+\t  if (mpz_cmp_si (stride[d], 0) < 0)\n+\t    mpz_set (end[d], lower->value.integer);\n+\t  else\n+\t    mpz_set (end[d], upper->value.integer);\n+\t}\n+\n+      /* Separate 'if' because elements sometimes arrive with\n+\t non-null end.  */\n+      if (ref->u.ar.dimen_type[d] == DIMEN_ELEMENT)\n+\tmpz_set (end [d], begin->value.integer);\n+\n+      /* Check the bounds.  */\n+      if (mpz_cmp (ctr[d], upper->value.integer) > 0\n+\t    || mpz_cmp (end[d], upper->value.integer) > 0\n+\t    || mpz_cmp (ctr[d], lower->value.integer) < 0\n+\t    || mpz_cmp (end[d], lower->value.integer) < 0)\n+\t{\n+\t  gfc_error (\"index in dimension %d is out of bounds \"\n+\t\t     \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n+\t  t = FAILURE;\n+\t  goto cleanup;\n+\t}\n+\n+      /* Calculate the number of elements and the shape.  */\n+      mpz_abs (tmp_mpz, stride[d]);\n+      mpz_div (tmp_mpz, stride[d], tmp_mpz);\n+      mpz_add (tmp_mpz, end[d], tmp_mpz);\n+      mpz_sub (tmp_mpz, tmp_mpz, ctr[d]);\n+      mpz_div (tmp_mpz, tmp_mpz, stride[d]);\n+      mpz_mul (nelts, nelts, tmp_mpz);\n+\n+      mpz_set (expr->shape[d], tmp_mpz);\n+\n+      /* Calculate the 'stride' (=delta) for conversion of the\n+\t counter values into the index along the constructor.  */\n+      mpz_set (delta[d], delta_mpz);\n+      mpz_sub (tmp_mpz, upper->value.integer, lower->value.integer);\n+      mpz_add_ui (tmp_mpz, tmp_mpz, one);\n+      mpz_mul (delta_mpz, delta_mpz, tmp_mpz);\n+    }\n+\n+  mpz_init (index);\n+  mpz_init (ptr);\n+  mpz_init (stop);\n+  cons = base;\n+\n+  /* Now clock through the array reference, calculating the index in\n+     the source constructor and transferring the elements to the new\n+     constructor.  */  \n+  for (idx = 0; idx < (int)mpz_get_si (nelts); idx++)\n+    {\n+      if (ref->u.ar.offset)\n+\tmpz_set (ptr, ref->u.ar.offset->value.integer);\n+      else\n+\tmpz_init_set_ui (ptr, 0);\n+\n+      mpz_set_ui (stop, one);\n+      for (d = 0; d < rank; d++)\n+\t{\n+\t  mpz_set (tmp_mpz, ctr[d]);\n+\t  mpz_sub_ui (tmp_mpz, tmp_mpz, one);\n+\t  mpz_mul (tmp_mpz, tmp_mpz, delta[d]);\n+\t  mpz_add (ptr, ptr, tmp_mpz);\n+\n+\t  mpz_mul (tmp_mpz, stride[d], stop);\n+\t  mpz_add (ctr[d], ctr[d], tmp_mpz); \n+\n+\t  mpz_set (tmp_mpz, end[d]);\n+\t  if (mpz_cmp_ui (stride[d], 0) > 0 ?\n+\t\tmpz_cmp (ctr[d], tmp_mpz) > 0 :\n+\t\tmpz_cmp (ctr[d], tmp_mpz) < 0)\n+\t    mpz_set (ctr[d], ref->u.ar.start[d]->value.integer);\n+\t  else\n+\t    mpz_set_ui (stop, 0);\n+\t}\n+\n+      /* There must be a better way of dealing with negative strides\n+\t than resetting the index and the constructor pointer!  */ \n+      if (mpz_cmp (ptr, index) < 0)\n+\t{\n+\t  mpz_set_ui (index, 0);\n+\t  cons = base;\n+\t}\n+\n+      while (mpz_cmp (ptr, index) > 0)\n+\t{\n+\t  mpz_add_ui (index, index, one);\n+\t  cons = cons->next;\n+\t}\n+\n+      gfc_append_constructor (expr, gfc_copy_expr (cons->expr));\n+    }\n+\n+  mpz_clear (ptr);\n+  mpz_clear (index);\n+  mpz_clear (stop);\n+\n+cleanup:\n+\n+  mpz_clear (delta_mpz);\n+  mpz_clear (tmp_mpz);\n+  mpz_clear (nelts);\n+  for (d = 0; d < rank; d++)\n+    {\n+      mpz_clear (delta[d]);\n+      mpz_clear (end[d]);\n+      mpz_clear (ctr[d]);\n+      mpz_clear (stride[d]);\n+    }\n+  gfc_free_constructor (base);\n+  return t;\n+}\n+\n+/* Pull a substring out of an expression.  */\n+\n+static try\n+find_substring_ref (gfc_expr *p, gfc_expr **newp)\n+{\n+  int end;\n+  int start;\n+  char *chr;\n+\n+  if (p->ref->u.ss.start->expr_type != EXPR_CONSTANT\n+\t|| p->ref->u.ss.end->expr_type != EXPR_CONSTANT)\n+    return FAILURE;\n+\n+  *newp = gfc_copy_expr (p);\n+  chr = p->value.character.string;\n+  end = (int)mpz_get_ui (p->ref->u.ss.end->value.integer);\n+  start = (int)mpz_get_ui (p->ref->u.ss.start->value.integer);\n+\n+  (*newp)->value.character.length = end - start + 1;\n+  strncpy ((*newp)->value.character.string, &chr[start - 1],\n+\t   (*newp)->value.character.length);\n+  return SUCCESS;\n+}\n+\n+\n+\n /* Simplify a subobject reference of a constructor.  This occurs when\n    parameter variable values are substituted.  */\n \n static try\n simplify_const_ref (gfc_expr * p)\n {\n   gfc_constructor *cons;\n+  gfc_expr *newp;\n \n   while (p->ref)\n     {\n@@ -1001,24 +1256,40 @@ simplify_const_ref (gfc_expr * p)\n \t  switch (p->ref->u.ar.type)\n \t    {\n \t    case AR_ELEMENT:\n-\t      cons = find_array_element (p->value.constructor, &p->ref->u.ar);\n+\t      if (find_array_element (p->value.constructor,\n+\t\t\t\t      &p->ref->u.ar,\n+\t\t\t\t      &cons) == FAILURE)\n+\t\treturn FAILURE;\n+\n \t      if (!cons)\n \t\treturn SUCCESS;\n+\n \t      remove_subobject_ref (p, cons);\n \t      break;\n \n+\t    case AR_SECTION:\n+\t      if (find_array_section (p, p->ref) == FAILURE)\n+\t\treturn FAILURE;\n+\t      p->ref->u.ar.type = AR_FULL;\n+\n+\t    /* FALLTHROUGH  */\n+\n \t    case AR_FULL:\n-\t      if (p->ref->next != NULL)\n+\t      if (p->ref->next != NULL\n+\t\t    && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))\n \t\t{\n-\t\t  /* TODO: Simplify array subobject references.  */\n-\t\t  return SUCCESS;\n+\t\t  cons = p->value.constructor;\n+\t\t  for (; cons; cons = cons->next)\n+\t\t    {\n+\t\t      cons->expr->ref = copy_ref (p->ref->next);\n+\t\t      simplify_const_ref (cons->expr);\n+\t\t    }\n \t\t}\n-\t\tgfc_free_ref_list (p->ref);\n-\t\tp->ref = NULL;\n+\t      gfc_free_ref_list (p->ref);\n+\t      p->ref = NULL;\n \t      break;\n \n \t    default:\n-\t      /* TODO: Simplify array subsections.  */\n \t      return SUCCESS;\n \t    }\n \n@@ -1030,8 +1301,13 @@ simplify_const_ref (gfc_expr * p)\n \t  break;\n \n \tcase REF_SUBSTRING:\n-\t  /* TODO: Constant substrings.  */\n-\t  return SUCCESS;\n+  \t  if (find_substring_ref (p, &newp) == FAILURE)\n+\t    return FAILURE;\n+\n+\t  gfc_replace_expr (p, newp);\n+\t  gfc_free_ref_list (p->ref);\n+\t  p->ref = NULL;\n+\t  break;\n \t}\n     }\n \n@@ -1062,6 +1338,7 @@ simplify_ref_chain (gfc_ref * ref, int type)\n \t      if (gfc_simplify_expr (ref->u.ar.stride[n], type)\n \t\t     == FAILURE)\n \t\treturn FAILURE;\n+\n \t    }\n \t  break;\n \n@@ -1088,6 +1365,9 @@ simplify_parameter_variable (gfc_expr * p, int type)\n   try t;\n \n   e = gfc_copy_expr (p->symtree->n.sym->value);\n+  if (e == NULL)\n+    return FAILURE;\n+\n   /* Do not copy subobject refs for constant.  */\n   if (e->expr_type != EXPR_CONSTANT && p->ref != NULL)\n     e->ref = copy_ref (p->ref);\n@@ -1211,7 +1491,9 @@ gfc_simplify_expr (gfc_expr * p, int type)\n       if (simplify_constructor (p->value.constructor, type) == FAILURE)\n \treturn FAILURE;\n \n-      if (p->expr_type == EXPR_ARRAY)\n+      if (p->expr_type == EXPR_ARRAY\n+\t    && p->ref && p->ref->type == REF_ARRAY\n+\t    && p->ref->u.ar.type == AR_FULL)\n \t  gfc_expand_constructor (p);\n \n       if (simplify_const_ref (p) == FAILURE)"}, {"sha": "46c25f6c35fedcab23d59cc1b775c20601e8af44", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -2139,7 +2139,7 @@ add_functions (void)\n   make_generic (\"tiny\", GFC_ISYM_NONE, GFC_STD_F95);\n \n   add_sym_3 (\"transfer\", 0, 1, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_transfer, NULL, gfc_resolve_transfer,\n+\t     gfc_check_transfer, gfc_simplify_transfer, gfc_resolve_transfer,\n \t     src, BT_REAL, dr, REQUIRED, mo, BT_REAL, dr, REQUIRED,\n \t     sz, BT_INTEGER, di, OPTIONAL);\n "}, {"sha": "4028f79164975c52ff4ac985b7cbf3f86d0ba35f", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -276,6 +276,7 @@ gfc_expr *gfc_simplify_sqrt (gfc_expr *);\n gfc_expr *gfc_simplify_tan (gfc_expr *);\n gfc_expr *gfc_simplify_tanh (gfc_expr *);\n gfc_expr *gfc_simplify_tiny (gfc_expr *);\n+gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "448d927ce86524535fb3b954f9fd2bbd77bdd191", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -3578,6 +3578,7 @@ gfc_match_forall (gfc_statement * st)\n \n   c = gfc_get_code ();\n   *c = new_st;\n+  c->loc = gfc_current_locus;\n \n   if (gfc_match_eos () != MATCH_YES)\n     goto syntax;"}, {"sha": "7bf79fc5403aad1612abedcde4f40e07c42aca3b", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -3714,6 +3714,19 @@ gfc_simplify_tiny (gfc_expr * e)\n }\n \n \n+gfc_expr *\n+gfc_simplify_transfer (gfc_expr * source, gfc_expr *mold, gfc_expr * size)\n+{\n+\n+  /* Reference mold and size to suppress warning.  */\n+  if (gfc_init_expr && (mold || size))\n+    gfc_error (\"TRANSFER intrinsic not implemented for initialization at %L\",\n+\t       &source->where);\n+\n+  return NULL;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_trim (gfc_expr * e)\n {"}, {"sha": "fb97bc7a038fa5da0d9e121b53d0bdcccf4fc1d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -1,3 +1,11 @@\n+2006-06-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16206\n+\t* gfortran.dg/array_initializer_1.f90: New test.\n+\n+\tPR fortran/28005\n+\t* gfortran.dg/matmul_3.f90: New test.\n+\n 2006-06-19  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR middle-end/28075"}, {"sha": "a0d576149daf0c12875b8d10af057f442ea6cf9d", "filename": "gcc/testsuite/gfortran.dg/array_initializer_1.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_1.f90?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\r\n+! Check the fix for PR16206, in which array sections would not work\r\n+! in array initializers. Use of implied do loop variables for indices\r\n+! and substrings, with and without implied do loops, were fixed at the\r\n+! same time.\r\n+!\r\n+! Contributed by Paul Thomas   <pault@gcc.gnu.org>\r\n+! based on testcase from Harald Anlauf  <anlauf@gmx.de>  \r\n+!\r\n+  real, parameter :: x(4,4) = reshape((/(i, i = 1, 16)/), (/4,4/))\r\n+  real, parameter :: y(4) = (/ x(1:2, 2), x(3:4, 4)/)\r\n+  real, parameter :: z(2) = x(2:3, 3) + 1\r\n+  real, parameter :: r(6) = (/(x(i:i +1, i), i = 1,3)/)\r\n+  real, parameter :: s(12) = (/((x(i, i:j-1:-1), i = 3,4), j = 2,3)/)\r\n+  real, parameter :: t(8) = (/(z, &\r\n+\treal (i)**3, y(i), i = 2, 3)/) ! { dg-warning \"nonstandard\" }\r\n+\r\n+  integer, parameter :: ii = 4\r\n+\r\n+  character(4), parameter :: chr(4) = (/\"abcd\", \"efgh\", \"ijkl\", \"mnop\"/)\r\n+  character(4), parameter :: chrs = chr(ii)(2:3)//chr(2)(ii-3:ii-2) \r\n+  character(4), parameter :: chrt(2) = (/chr(2:2)(2:3), chr(ii-1)(3:ii)/)\r\n+  character(2), parameter :: chrx(2) = (/(chr(i)(i:i+1), i=2,3)/)\r\n+\r\n+  if (any (y .ne. (/5., 6., 15., 16./))) call abort ()\r\n+  if (any (z .ne. (/11., 12./))) call abort ()\r\n+  if (any (r .ne. (/1., 2., 6., 7., 11., 12./))) call abort ()\r\n+  if (any (s .ne. (/11., 7., 3., 16., 12., 8., 4., &\r\n+\t\t    11., 7.,     16., 12., 8. /))) call abort ()\r\n+\r\n+  if (any (t .ne. (/11., 12., 8., 6., 11., 12., 27., 15. /))) call abort ()\r\n+\r\n+  if (chrs .ne. \"noef\") call abort ()\r\n+  if (any (chrt .ne. (/\"fg\", \"kl\"/))) call abort ()\r\n+  if (any (chrx .ne. (/\"fg\", \"kl\"/))) call abort ()\r\n+end\r"}, {"sha": "65290feccaa1a6e87f01913b1d2206bc4b286a11", "filename": "gcc/testsuite/gfortran.dg/matmul_3.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_3.f90?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\r\n+! Check the fix for PR28005, in which the mechanism for dealing\r\n+! with matmul (transpose (a), b) would cause wrong results for\r\n+! matmul (a(i, 1:n), b(1:n, 1:n)).\r\n+!\r\n+! Based on the original testcase contributed by\r\n+! Tobias Burnus  <tobias.burnus@physik.fu-berlin.de>\r\n+!   \r\n+   implicit none\r\n+   integer, parameter         ::  nmax = 3\r\n+   integer                    ::  i, n = 2\r\n+   integer, dimension(nmax,nmax) ::  iB=0 , iC=1\r\n+   integer, dimension(nmax,nmax) ::  iX1=99, iX2=99, iChk\r\n+   iChk = reshape((/30,66,102,36,81,126,42,96,150/),(/3,3/))\r\n+\r\n+! This would give 3, 3, 99\r\n+   iB = reshape((/1 ,3 ,0 ,2 ,5 ,0 ,0 ,0 ,0 /),(/3,3/))\r\n+   iX1(1:n,1) = matmul( iB(2,1:n),iC(1:n,1:n) )\r\n+\r\n+! This would give 4, 4, 99\r\n+   ib(3,1) = 1\r\n+   iX2(1:n,1) = matmul( iB(2,1:n),iC(1:n,1:n) )\r\n+\r\n+! Whereas, we should have 8, 8, 99\r\n+   if (any (iX1(1:n,1) .ne. (/8, 8, 99/))) call abort ()\r\n+   if (any (iX1 .ne. iX2)) call abort ()\r\n+\r\n+! Make sure that the fix does not break transpose temporaries.\r\n+   iB = reshape((/(i, i = 1, 9)/),(/3,3/))\r\n+   ic = transpose (iB)\r\n+   iX1 = transpose (iB)\r\n+   iX1 = matmul (iX1, iC)\r\n+   iX2 = matmul (transpose (iB), iC)\r\n+   if (any (iX1 .ne. iX2)) call abort ()\r\n+   if (any (iX1 .ne. iChk)) call abort ()\r\n+end\r"}, {"sha": "8ab88b750377d59e900afa0fcb71bfda7b533413", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -1,3 +1,22 @@\n+2006-06-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR libfortran/28005\n+\t* m4/matmul.m4: aystride = 1 does not uniquely detect the\n+\tpresence of a temporary transpose; an array element in the\n+\tfirst dimension produces the same signature.  Detect this\n+\tusing the rank of a and add specific code.\n+\t* generated/matmul_r4.c: Regenerate.\n+\t* generated/matmul_r8.c: Regenerate.\n+\t* generated/matmul_r10.c: Regenerate.\n+\t* generated/matmul_r16.c: Regenerate.\n+\t* generated/matmul_c4.c: Regenerate.\n+\t* generated/matmul_c8.c: Regenerate.\n+\t* generated/matmul_c10.c: Regenerate.\n+\t* generated/matmul_c16.c: Regenerate.\n+\t* generated/matmul_i4.c: Regenerate.\n+\t* generated/matmul_i8.c: Regenerate.\n+\t* generated/matmul_i16.c: Regenerate.\n+\n 2006-06-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR libgomp/27254"}, {"sha": "7b67ddd86a92a3d98a945b7e094324efbc04a783", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_10 *restrict abase_x;\n-      const GFC_COMPLEX_10 *restrict bbase_y;\n-      GFC_COMPLEX_10 *restrict dest_y;\n-      GFC_COMPLEX_10 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_COMPLEX_10) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "c17bcaaa42ccdd4fc216d2451f127493cd19f9d3", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_16 *restrict abase_x;\n-      const GFC_COMPLEX_16 *restrict bbase_y;\n-      GFC_COMPLEX_16 *restrict dest_y;\n-      GFC_COMPLEX_16 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_COMPLEX_16) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "d85bd277fde347d578e8decdd86e8ad6641f565c", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_4 *restrict abase_x;\n-      const GFC_COMPLEX_4 *restrict bbase_y;\n-      GFC_COMPLEX_4 *restrict dest_y;\n-      GFC_COMPLEX_4 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_COMPLEX_4) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "be4ee6ce6b598a2779d6d912d1f2b50470d2e16a", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_8 *restrict abase_x;\n-      const GFC_COMPLEX_8 *restrict bbase_y;\n-      GFC_COMPLEX_8 *restrict dest_y;\n-      GFC_COMPLEX_8 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_COMPLEX_8) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "c4de78a9282a7d1aa42c42d76013b9b263fb3ca0", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_16 *restrict abase_x;\n-      const GFC_INTEGER_16 *restrict bbase_y;\n-      GFC_INTEGER_16 *restrict dest_y;\n-      GFC_INTEGER_16 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_INTEGER_16) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "cd506a03943b48d51cd8d91961797a39c6217387", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_4 *restrict abase_x;\n-      const GFC_INTEGER_4 *restrict bbase_y;\n-      GFC_INTEGER_4 *restrict dest_y;\n-      GFC_INTEGER_4 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_INTEGER_4) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "7bdfb6f715431fc7bdc11a682ecfe75eb27a9bb5", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_8 *restrict abase_x;\n-      const GFC_INTEGER_8 *restrict bbase_y;\n-      GFC_INTEGER_8 *restrict dest_y;\n-      GFC_INTEGER_8 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_8 *restrict abase_x;\n+\t  const GFC_INTEGER_8 *restrict bbase_y;\n+\t  GFC_INTEGER_8 *restrict dest_y;\n+\t  GFC_INTEGER_8 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_INTEGER_8 *restrict bbase_y;\n+\t  GFC_INTEGER_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_INTEGER_8) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "2bdaaf51c5bb6201739c5db681494dd71e104e13", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_10 *restrict abase_x;\n-      const GFC_REAL_10 *restrict bbase_y;\n-      GFC_REAL_10 *restrict dest_y;\n-      GFC_REAL_10 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_10 *restrict abase_x;\n+\t  const GFC_REAL_10 *restrict bbase_y;\n+\t  GFC_REAL_10 *restrict dest_y;\n+\t  GFC_REAL_10 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_REAL_10 *restrict bbase_y;\n+\t  GFC_REAL_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_REAL_10) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "f120e7fdc56673a772c27b621062cded1933ec4b", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_16 *restrict abase_x;\n-      const GFC_REAL_16 *restrict bbase_y;\n-      GFC_REAL_16 *restrict dest_y;\n-      GFC_REAL_16 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_16 *restrict abase_x;\n+\t  const GFC_REAL_16 *restrict bbase_y;\n+\t  GFC_REAL_16 *restrict dest_y;\n+\t  GFC_REAL_16 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_REAL_16 *restrict bbase_y;\n+\t  GFC_REAL_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_REAL_16) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "085513346e08a6076ff264d45000a4af9b0201c6", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_4 *restrict abase_x;\n-      const GFC_REAL_4 *restrict bbase_y;\n-      GFC_REAL_4 *restrict dest_y;\n-      GFC_REAL_4 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_4 *restrict abase_x;\n+\t  const GFC_REAL_4 *restrict bbase_y;\n+\t  GFC_REAL_4 *restrict dest_y;\n+\t  GFC_REAL_4 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_REAL_4 *restrict bbase_y;\n+\t  GFC_REAL_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_REAL_4) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "ba177a8e473ed32953d283fa61d99727ae7985bb", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -210,22 +210,39 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_8 *restrict abase_x;\n-      const GFC_REAL_8 *restrict bbase_y;\n-      GFC_REAL_8 *restrict dest_y;\n-      GFC_REAL_8 s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_8 *restrict abase_x;\n+\t  const GFC_REAL_8 *restrict bbase_y;\n+\t  GFC_REAL_8 *restrict dest_y;\n+\t  GFC_REAL_8 s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const GFC_REAL_8 *restrict bbase_y;\n+\t  GFC_REAL_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (GFC_REAL_8) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}, {"sha": "f55e2cfaa64c9a1360f49ff78a6f13c82d6ad04b", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a11197f9f65c5523da3ce588d7508e47f801ab/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=a4a11197f9f65c5523da3ce588d7508e47f801ab", "patch": "@@ -212,22 +212,39 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n-      const rtype_name *restrict abase_x;\n-      const rtype_name *restrict bbase_y;\n-      rtype_name *restrict dest_y;\n-      rtype_name s;\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const rtype_name *restrict abase_x;\n+\t  const rtype_name *restrict bbase_y;\n+\t  rtype_name *restrict dest_y;\n+\t  rtype_name s;\n \n-      for (y = 0; y < ycount; y++)\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (rtype_name) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  bbase_y = &bbase[y*bystride];\n-\t  dest_y = &dest[y*rystride];\n-\t  for (x = 0; x < xcount; x++)\n+\t  const rtype_name *restrict bbase_y;\n+\t  rtype_name s;\n+\n+\t  for (y = 0; y < ycount; y++)\n \t    {\n-\t      abase_x = &abase[x*axstride];\n+\t      bbase_y = &bbase[y*bystride];\n \t      s = (rtype_name) 0;\n \t      for (n = 0; n < count; n++)\n-\t\ts += abase_x[n] * bbase_y[n];\n-\t      dest_y[x] = s;\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n \t    }\n \t}\n     }"}]}