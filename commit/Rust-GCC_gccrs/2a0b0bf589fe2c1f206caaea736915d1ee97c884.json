{"sha": "2a0b0bf589fe2c1f206caaea736915d1ee97c884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEwYjBiZjU4OWZlMmMxZjIwNmNhYWVhNzM2OTE1ZDFlZTk3Yzg4NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-10-24T18:38:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-10-24T18:38:30Z"}, "message": "Permit sign_extend operands\n\nFrom-SVN: r13028", "tree": {"sha": "f1c9b1e41fb858d59c949260fdfe29934b0e67fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1c9b1e41fb858d59c949260fdfe29934b0e67fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a0b0bf589fe2c1f206caaea736915d1ee97c884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a0b0bf589fe2c1f206caaea736915d1ee97c884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a0b0bf589fe2c1f206caaea736915d1ee97c884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a0b0bf589fe2c1f206caaea736915d1ee97c884/comments", "author": null, "committer": null, "parents": [{"sha": "7f423031c0b5c54dd088dd25fb8d64ca3c3bb94a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f423031c0b5c54dd088dd25fb8d64ca3c3bb94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f423031c0b5c54dd088dd25fb8d64ca3c3bb94a"}], "stats": {"total": 200, "additions": 196, "deletions": 4}, "files": [{"sha": "10545bb5bd170216de1410d6ebf64d6dbe783618", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 196, "deletions": 4, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0b0bf589fe2c1f206caaea736915d1ee97c884/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0b0bf589fe2c1f206caaea736915d1ee97c884/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=2a0b0bf589fe2c1f206caaea736915d1ee97c884", "patch": "@@ -719,6 +719,151 @@ move_operand (op, mode)\n \t  && ! (mips_split_addresses && mips_check_split (op, mode)));\n }\n \n+/* Return true if OPERAND is valid as a source operand for movdi.\n+   This accepts not only general_operand, but also sign extended\n+   constants and registers.  We need to accept sign extended constants\n+   in case a sign extended register which is used in an expression,\n+   and is equivalent to a constant, is spilled.  */\n+\n+int\n+movdi_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && (GET_MODE (XEXP (op, 0)) == SImode\n+\t  || (GET_CODE (XEXP (op, 0)) == CONST_INT\n+\t      && GET_MODE (XEXP (op, 0)) == VOIDmode))\n+      && (register_operand (XEXP (op, 0), SImode)\n+\t  || immediate_operand (XEXP (op, 0), SImode)))\n+    return 1;\n+\n+  return general_operand (op, mode);\n+}\n+\n+/* Like register_operand, but when in 64 bit mode also accept a sign\n+   extend of a 32 bit register, since the value is known to be already\n+   sign extended.  */\n+\n+int\n+se_register_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && register_operand (XEXP (op, 0), SImode))\n+    return 1;\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Like reg_or_0_operand, but when in 64 bit mode also accept a sign\n+   extend of a 32 bit register, since the value is known to be already\n+   sign extended.  */\n+\n+int\n+se_reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && register_operand (XEXP (op, 0), SImode))\n+    return 1;\n+\n+  return reg_or_0_operand (op, mode);\n+}\n+\n+/* Like uns_arith_operand, but when in 64 bit mode also accept a sign\n+   extend of a 32 bit register, since the value is known to be already\n+   sign extended.  */\n+\n+int\n+se_uns_arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && register_operand (XEXP (op, 0), SImode))\n+    return 1;\n+\n+  return uns_arith_operand (op, mode);\n+}\n+\n+/* Like arith_operand, but when in 64 bit mode also accept a sign\n+   extend of a 32 bit register, since the value is known to be already\n+   sign extended.  */\n+\n+int\n+se_arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && register_operand (XEXP (op, 0), SImode))\n+    return 1;\n+\n+  return arith_operand (op, mode);\n+}\n+\n+/* Like nonmemory_operand, but when in 64 bit mode also accept a sign\n+   extend of a 32 bit register, since the value is known to be already\n+   sign extended.  */\n+\n+int\n+se_nonmemory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && register_operand (XEXP (op, 0), SImode))\n+    return 1;\n+\n+  return nonmemory_operand (op, mode);\n+}\n+\n+/* Like nonimmediate_operand, but when in 64 bit mode also accept a\n+   sign extend of a 32 bit register, since the value is known to be\n+   already sign extended.  */\n+\n+int\n+se_nonimmediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_64BIT\n+      && mode == DImode\n+      && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (op) == DImode\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && register_operand (XEXP (op, 0), SImode))\n+    return 1;\n+\n+  return nonimmediate_operand (op, mode);\n+}\n+\n /* Return true if we split the address into high and low parts.  */\n \n /* ??? We should also handle reg+array somewhere.  We get four\n@@ -1382,13 +1527,25 @@ mips_move_2words (operands, insn)\n       code0 = GET_CODE (op0);\n     }\n \n+  if (code1 == SIGN_EXTEND)\n+    {\n+      op1 = XEXP (op1, 0);\n+      code1 = GET_CODE (op1);\n+    }\n+\n   while (code1 == SUBREG)\n     {\n       subreg_word1 += SUBREG_WORD (op1);\n       op1 = SUBREG_REG (op1);\n       code1 = GET_CODE (op1);\n     }\n       \n+  /* Sanity check.  */\n+  if (GET_CODE (operands[1]) == SIGN_EXTEND\n+      && code1 != REG\n+      && code1 != CONST_INT)\n+    abort ();\n+\n   if (code0 == REG)\n     {\n       int regno0 = REGNO (op0) + subreg_word0;\n@@ -1567,7 +1724,9 @@ mips_move_2words (operands, insn)\n \t{\n \t  if (TARGET_64BIT)\n \t    {\n-\t      if (HOST_BITS_PER_WIDE_INT < 64)\n+\t      if (GET_CODE (operands[1]) == SIGN_EXTEND)\n+\t\tret = \"li\\t%0,%1\\t\\t# %X1\";\n+\t      else if (HOST_BITS_PER_WIDE_INT < 64)\n \t\t/* We can't use 'X' for negative numbers, because then we won't\n \t\t   get the right value for the upper 32 bits.  */\n \t\tret = ((INTVAL (op1) < 0) ? \"dli\\t%0,%1\\t\\t\\t# %X1\"\n@@ -3862,6 +4021,13 @@ print_operand (file, op, letter)\n     }\n \n   code = GET_CODE (op);\n+\n+  if (code == SIGN_EXTEND)\n+    {\n+      op = XEXP (op, 0);\n+      code = GET_CODE (op);\n+    }\n+\n   if (letter == 'C')\n     switch (code)\n       {\n@@ -3919,9 +4085,14 @@ print_operand (file, op, letter)\n \tfprintf (file, \"%s,\", reg_names[regnum]);\n     }\n \n-  else if (code == REG)\n+  else if (code == REG || code == SUBREG)\n     {\n-      register int regnum = REGNO (op);\n+      register int regnum;\n+\n+      if (code == REG)\n+\tregnum = REGNO (op);\n+      else\n+\tregnum = true_regnum (op);\n \n       if ((letter == 'M' && ! WORDS_BIG_ENDIAN)\n \t  || (letter == 'L' && WORDS_BIG_ENDIAN)\n@@ -5832,7 +6003,28 @@ mips_secondary_reload_class (class, mode, x, in_p)\n {\n   int regno = -1;\n \n-  if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+  if (GET_CODE (x) == SIGN_EXTEND)\n+    {\n+      int off = 0;\n+\n+      x = XEXP (x, 0);\n+\n+      /* We may be called with reg_renumber NULL from regclass.\n+\t ??? This is probably a bug.  */\n+      if (reg_renumber)\n+\tregno = true_regnum (x);\n+      else\n+\t{\n+\t  while (GET_CODE (x) == SUBREG)\n+\t    {\n+\t      off += SUBREG_WORD (x);\n+\t      x = SUBREG_REG (x);\n+\t    }\n+\t  if (GET_CODE (x) == REG)\n+\t    regno = REGNO (x) + off;\n+\t}\n+    }\n+  else if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n     regno = true_regnum (x);\n \n   /* We always require a general register when copying anything to"}]}