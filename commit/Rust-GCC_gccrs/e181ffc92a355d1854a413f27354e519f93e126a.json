{"sha": "e181ffc92a355d1854a413f27354e519f93e126a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4MWZmYzkyYTM1NWQxODU0YTQxM2YyNzM1NGU1MTlmOTNlMTI2YQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-02-03T23:25:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-02-03T23:25:07Z"}, "message": "Optimize vec_extract of vectors in memory with a PC-relative address.\n\n2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (adjust_vec_address_pcrel): New helper\n\tfunction to adjust PC-relative vector addresses.\n\t(rs6000_adjust_vec_address): Call adjust_vec_address_pcrel to\n\thandle vectors with PC-relative addresses.", "tree": {"sha": "00836d49c47a2d6f89cacbd1def4d9eee11062d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00836d49c47a2d6f89cacbd1def4d9eee11062d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e181ffc92a355d1854a413f27354e519f93e126a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e181ffc92a355d1854a413f27354e519f93e126a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e181ffc92a355d1854a413f27354e519f93e126a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e181ffc92a355d1854a413f27354e519f93e126a/comments", "author": null, "committer": null, "parents": [{"sha": "fb47dc28d2d38f56af65e9f244af8870bd568b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb47dc28d2d38f56af65e9f244af8870bd568b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb47dc28d2d38f56af65e9f244af8870bd568b0b"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "350f18d1161a2f080679d3cf8a8f76bc3ddcbe94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e181ffc92a355d1854a413f27354e519f93e126a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e181ffc92a355d1854a413f27354e519f93e126a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e181ffc92a355d1854a413f27354e519f93e126a", "patch": "@@ -1,3 +1,10 @@\n+2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (adjust_vec_address_pcrel): New helper\n+\tfunction to adjust PC-relative vector addresses.\n+\t(rs6000_adjust_vec_address): Call adjust_vec_address_pcrel to\n+\thandle vectors with PC-relative addresses.\n+\n 2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/rs6000.c (reg_to_non_prefixed): Add forward"}, {"sha": "bf0dc97405ed1dd639244b15675fb94e2872001d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e181ffc92a355d1854a413f27354e519f93e126a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e181ffc92a355d1854a413f27354e519f93e126a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e181ffc92a355d1854a413f27354e519f93e126a", "patch": "@@ -6767,6 +6767,60 @@ get_vector_offset (rtx mem, rtx element, rtx base_tmp, unsigned scalar_size)\n   return base_tmp;\n }\n \n+/* Helper function update PC-relative addresses when we are adjusting a memory\n+   address (ADDR) to a vector to point to a scalar field within the vector with\n+   a constant offset (ELEMENT_OFFSET).  If the address is not valid, we can\n+   use the base register temporary (BASE_TMP) to form the address.  */\n+\n+static rtx\n+adjust_vec_address_pcrel (rtx addr, rtx element_offset, rtx base_tmp)\n+{\n+  rtx new_addr = NULL;\n+\n+  gcc_assert (CONST_INT_P (element_offset));\n+\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+\n+      if (CONST_INT_P (op1))\n+\t{\n+\t  HOST_WIDE_INT offset\n+\t    = INTVAL (XEXP (addr, 1)) + INTVAL (element_offset);\n+\n+\t  if (offset == 0)\n+\t    new_addr = op0;\n+\n+\t  else\n+\t    {\n+\t      rtx plus = gen_rtx_PLUS (Pmode, op0, GEN_INT (offset));\n+\t      new_addr = gen_rtx_CONST (Pmode, plus);\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  emit_move_insn (base_tmp, addr);\n+\t  new_addr = gen_rtx_PLUS (Pmode, base_tmp, element_offset);\n+\t}\n+    }\n+\n+  else if (SYMBOL_REF_P (addr) || LABEL_REF_P (addr))\n+    {\n+      rtx plus = gen_rtx_PLUS (Pmode, addr, element_offset);\n+      new_addr = gen_rtx_CONST (Pmode, plus);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return new_addr;\n+}\n+\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -6807,6 +6861,11 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n   else if (REG_P (addr) || SUBREG_P (addr))\n     new_addr = gen_rtx_PLUS (Pmode, addr, element_offset);\n \n+  /* For references to local static variables, fold a constant offset into the\n+     address.  */\n+  else if (pcrel_local_address (addr, Pmode) && CONST_INT_P (element_offset))\n+    new_addr = adjust_vec_address_pcrel (addr, element_offset, base_tmp);\n+\n   /* Optimize D-FORM addresses with constant offset with a constant element, to\n      include the element offset in the address directly.  */\n   else if (GET_CODE (addr) == PLUS)"}]}