{"sha": "ded1aca9022faa4a72a97f117ace085ecb34487f", "node_id": "C_kwDOANBUbNoAKGRlZDFhY2E5MDIyZmFhNGE3MmE5N2YxMTdhY2UwODVlY2IzNDQ4N2Y", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-21T12:49:40Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-22T11:06:27Z"}, "message": "substitute_repetition: Substitute repetitions properly", "tree": {"sha": "754d0ffcc539e159a04df095e5e6b62312206c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/754d0ffcc539e159a04df095e5e6b62312206c39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ded1aca9022faa4a72a97f117ace085ecb34487f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded1aca9022faa4a72a97f117ace085ecb34487f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ded1aca9022faa4a72a97f117ace085ecb34487f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded1aca9022faa4a72a97f117ace085ecb34487f/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "143aad62e16ea96e8c562b96857c2497f74ba7c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143aad62e16ea96e8c562b96857c2497f74ba7c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143aad62e16ea96e8c562b96857c2497f74ba7c7"}], "stats": {"total": 104, "additions": 81, "deletions": 23}, "files": [{"sha": "668b89f6ca9564b3057d45fb8579e67e41e74155", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 75, "deletions": 19, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded1aca9022faa4a72a97f117ace085ecb34487f/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded1aca9022faa4a72a97f117ace085ecb34487f/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=ded1aca9022faa4a72a97f117ace085ecb34487f", "patch": "@@ -3882,7 +3882,6 @@ MacroExpander::substitute_metavar (\n {\n   auto metavar_name = metavar->get_str ();\n \n-  rust_debug (\"expanding metavar: %s\", metavar_name.c_str ());\n   std::vector<std::unique_ptr<AST::Token>> expanded;\n   auto it = fragments.find (metavar_name);\n   if (it == fragments.end ())\n@@ -3908,40 +3907,95 @@ MacroExpander::substitute_metavar (\n std::vector<std::unique_ptr<AST::Token>>\n MacroExpander::substitute_repetition (\n   std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::map<std::string, MatchedFragment> &fragments,\n-  std::vector<std::unique_ptr<AST::Token>> &pattern)\n+  std::vector<std::unique_ptr<AST::Token>> &macro,\n+  std::map<std::string, MatchedFragment> &fragments, size_t pattern_start,\n+  size_t pattern_end)\n {\n-  // If the repetition is not anything we know (ie no declared metavars, or\n-  // metavars which aren't present in the fragment), we can just error out. No\n-  // need to paste the tokens as if nothing had happened.\n-  for (auto &token : pattern)\n-    rust_debug (\"[repetition pattern]: %s\", token->as_string ().c_str ());\n+  rust_assert (pattern_end < macro.size ());\n+\n+  rust_debug (\"pattern start: %lu\", pattern_start);\n+  rust_debug (\"pattern end: %lu\", pattern_end);\n+\n+  std::vector<std::unique_ptr<AST::Token>> expanded;\n+\n+  for (size_t i = pattern_start; i < pattern_end; i++)\n+    rust_debug (\"[repetition pattern]: %s\",\n+\t\tmacro.at (i)->as_string ().c_str ());\n+\n+  // Find the first fragment and get the amount of repetitions that we should\n+  // perform\n+  size_t repeat_amount = 0;\n+  for (size_t i = pattern_start; i < pattern_end; i++)\n+    {\n+      if (macro.at (i)->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  auto &frag_token = macro.at (i + 1);\n+\t  if (frag_token->get_id () == IDENTIFIER)\n+\t    {\n+\t      auto it = fragments.find (frag_token->get_str ());\n+\t      if (it == fragments.end ())\n+\t\t{\n+\t\t  // If the repetition is not anything we know (ie no declared\n+\t\t  // metavars, or metavars which aren't present in the\n+\t\t  // fragment), we can just error out. No need to paste the\n+\t\t  // tokens as if nothing had happened.\n+\t\t  rust_error_at (frag_token->get_locus (),\n+\t\t\t\t \"metavar used in repetition does not exist\");\n+\t\t  return expanded;\n+\t\t}\n \n-  return std::vector<std::unique_ptr<AST::Token>> ();\n+\t      repeat_amount = it->second.match_amount;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<std::unique_ptr<AST::Token>> new_macro;\n+  for (size_t tok_idx = pattern_start; tok_idx < pattern_end; tok_idx++)\n+    {\n+      new_macro.emplace_back (macro.at (tok_idx)->clone_token ());\n+      rust_debug (\"new macro token: %s\",\n+\t\t  macro.at (tok_idx)->as_string ().c_str ());\n+    }\n+\n+  // FIXME: We have to be careful and not push the repetition token\n+  auto new_tokens = substitute_tokens (input, new_macro, fragments);\n+\n+  rust_debug (\"repetition amount to use: %lu\", repeat_amount);\n+  for (size_t i = 0; i < repeat_amount; i++)\n+    {\n+      for (auto &new_token : new_tokens)\n+\texpanded.emplace_back (new_token->clone_token ());\n+    }\n+\n+  // FIXME: We also need to make sure that all subsequent fragments\n+  // contain the same amount of repetitions as the first one\n+\n+  return expanded;\n }\n \n std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n MacroExpander::substitute_token (\n-  std::vector<std::unique_ptr<AST::Token>> &macro,\n   std::vector<std::unique_ptr<AST::Token>> &input,\n+  std::vector<std::unique_ptr<AST::Token>> &macro,\n   std::map<std::string, MatchedFragment> &fragments, size_t token_idx)\n {\n   auto &token = macro.at (token_idx);\n   switch (token->get_id ())\n     {\n     case IDENTIFIER:\n-      rust_debug (\"expanding metavar\");\n+      rust_debug (\"expanding metavar: %s\", token->get_str ().c_str ());\n       return {substitute_metavar (input, fragments, token), 1};\n       case LEFT_PAREN: {\n \t// We need to parse up until the closing delimiter and expand this\n \t// fragment->n times.\n \trust_debug (\"expanding repetition\");\n \tstd::vector<std::unique_ptr<AST::Token>> repetition_pattern;\n-\tfor (size_t rep_idx = token_idx + 1;\n-\t     rep_idx < macro.size ()\n-\t     && macro.at (rep_idx)->get_id () != RIGHT_PAREN;\n-\t     rep_idx++)\n-\t  repetition_pattern.emplace_back (macro.at (rep_idx)->clone_token ());\n+\tsize_t pattern_start = token_idx + 1;\n+\tsize_t pattern_end = pattern_start;\n+\tfor (; pattern_end < macro.size ()\n+\t       && macro.at (pattern_end)->get_id () != RIGHT_PAREN;\n+\t     pattern_end++)\n+\t  ;\n \n \t// FIXME: This skips whitespaces... Is that okay??\n \t// FIXME: Is there any existing parsing function that allows us to parse\n@@ -3953,9 +4007,11 @@ MacroExpander::substitute_token (\n \t// FIXME: We need to parse the repetition token now\n \n \treturn {\n-\t  substitute_repetition (input, fragments, repetition_pattern),\n+\t  substitute_repetition (input, macro, fragments, pattern_start,\n+\t\t\t\t pattern_end),\n \t  // + 2 for the opening and closing parenthesis which are mandatory\n-\t  repetition_pattern.size () + 2};\n+\t  // + 1 for the repetitor (+, *, ?)\n+\t  pattern_end - pattern_start + 3};\n       }\n       // TODO: We need to check if the $ was alone. In that case, do\n       // not error out: Simply act as if there was an empty identifier\n@@ -3996,7 +4052,7 @@ MacroExpander::substitute_tokens (\n \t{\n \t  // Aaaaah, if only we had C++17 :)\n \t  // auto [expanded, tok_to_skip] = ...\n-\t  auto p = substitute_token (macro, input, fragments, i + 1);\n+\t  auto p = substitute_token (input, macro, fragments, i + 1);\n \t  auto expanded = std::move (p.first);\n \t  auto tok_to_skip = p.second;\n "}, {"sha": "51e5ad19506a7ccbc674c345162aba899fa81da1", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded1aca9022faa4a72a97f117ace085ecb34487f/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded1aca9022faa4a72a97f117ace085ecb34487f/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=ded1aca9022faa4a72a97f117ace085ecb34487f", "patch": "@@ -204,14 +204,16 @@ struct MacroExpander\n    *\n    * @param input Tokens given to the transcribing context\n    * @param fragments Fragments given to the macro substitution\n-   * @param repetition Set of tokens to substitute and replace\n+   * @param pattern_start Start index of the pattern tokens\n+   * @param pattern_end Index  Amount of tokens in the pattern\n    *\n    * @return A vector containing the repeated pattern\n    */\n   static std::vector<std::unique_ptr<AST::Token>>\n   substitute_repetition (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t\t std::vector<std::unique_ptr<AST::Token>> &macro,\n \t\t\t std::map<std::string, MatchedFragment> &fragments,\n-\t\t\t std::vector<std::unique_ptr<AST::Token>> &pattern);\n+\t\t\t size_t pattern_start, size_t pattern_end);\n \n   /**\n    * Substitute a given token by its appropriate representation\n@@ -228,8 +230,8 @@ struct MacroExpander\n    * ahead of the input to avoid mis-substitutions\n    */\n   static std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n-  substitute_token (std::vector<std::unique_ptr<AST::Token>> &macro,\n-\t\t    std::vector<std::unique_ptr<AST::Token>> &input,\n+  substitute_token (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t    std::vector<std::unique_ptr<AST::Token>> &macro,\n \t\t    std::map<std::string, MatchedFragment> &fragments,\n \t\t    size_t token_idx);\n "}]}