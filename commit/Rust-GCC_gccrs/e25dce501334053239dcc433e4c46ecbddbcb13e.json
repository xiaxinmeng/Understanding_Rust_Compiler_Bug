{"sha": "e25dce501334053239dcc433e4c46ecbddbcb13e", "node_id": "C_kwDOANBUbNoAKGUyNWRjZTUwMTMzNDA1MzIzOWRjYzQzM2U0YzQ2ZWNiZGRiY2IxM2U", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-02-24T12:04:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-02-25T12:20:40Z"}, "message": "tree-optimization/103037 - PRE simplifying valueized expressions\n\nThis fixes a long-standing issue in PRE where we track valueized\nexpressions in our expression sets that we use for PHI translation,\ncode insertion but also feed into match-and-simplify via\nvn_nary_simplify.  But that's not what is expected from vn_nary_simplify\nor match-and-simplify which assume we are simplifying with operands\navailable at the point of the expression so they can use contextual\ninformation on the SSA names like ranges.  While the VN side was\nupdated to ensure this with the rewrite to RPO VN, thereby removing\nall workarounds that nullified such contextual info on all SSA names,\nthe PRE side still suffers from this.\n\nThe following patch tries to apply minimal surgery at this point\nand makes PRE track un-valueized expressions in the expression sets\nbut only for the NARY kind (both NAME and CONSTANT do not suffer\nfrom this issue), leaving the REFERENCE kind alone.  The REFERENCE\nkind is important when trying to remove the workarounds still in\nplace in compute_avail for code hoisting, but that's a separate issue\nand we have a working workaround in place.\n\nDoing this comes at the cost of duplicating the VN IL on the PRE side\nfor NARY and eventually some extra overhead for translated expressions\nthat is difficult to assess.\n\n2022-02-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/103037\n\t* tree-ssa-sccvn.h (alloc_vn_nary_op_noinit): Declare.\n\t(vn_nary_length_from_stmt): Likewise.\n\t(init_vn_nary_op_from_stmt): Likewise.\n\t(vn_nary_op_compute_hash): Likewise.\n\t* tree-ssa-sccvn.cc (alloc_vn_nary_op_noinit): Export.\n\t(vn_nary_length_from_stmt): Likewise.\n\t(init_vn_nary_op_from_stmt): Likewise.\n\t(vn_nary_op_compute_hash): Likewise.\n\t* tree-ssa-pre.cc (pre_expr_obstack): New obstack.\n\t(get_or_alloc_expr_for_nary): Pass in the value-id to use,\n\t(re-)compute the hash value and if the expression is not\n\tfound allocate it from pre_expr_obstack.\n\t(phi_translate_1): Do not insert the NARY found in the\n\tVN tables but build a PRE expression from the valueized\n\tNARY with the value-id we eventually found.\n\t(find_or_generate_expression): Assert we have an entry\n\tfor constant values.\n\t(compute_avail): Insert not valueized expressions into\n\tEXP_GEN using the value-id from the VN tables.\n\t(init_pre): Allocate pre_expr_obstack.\n\t(fini_pre): Free pre_expr_obstack.\n\n\t* gcc.dg/torture/pr103037.c: New testcase.", "tree": {"sha": "c882a208594320c0ff9711840c978b3566c72f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c882a208594320c0ff9711840c978b3566c72f1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e25dce501334053239dcc433e4c46ecbddbcb13e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25dce501334053239dcc433e4c46ecbddbcb13e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25dce501334053239dcc433e4c46ecbddbcb13e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25dce501334053239dcc433e4c46ecbddbcb13e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eabf7bbe601f2c0d87bd0a1012d7a602df2037da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eabf7bbe601f2c0d87bd0a1012d7a602df2037da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eabf7bbe601f2c0d87bd0a1012d7a602df2037da"}], "stats": {"total": 90, "additions": 68, "deletions": 22}, "files": [{"sha": "8b3bb1e4c8b8b9eafe9ff815fabd21d566df8bce", "filename": "gcc/testsuite/gcc.dg/torture/pr103037.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr103037.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr103037.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr103037.c?ref=e25dce501334053239dcc433e4c46ecbddbcb13e", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+static inline const unsigned short *\n+min(unsigned short *d, const unsigned short *e)\n+{\n+  return *e < *d ? e : d;\n+}\n+\n+unsigned short __attribute__((noipa))\n+test(unsigned short arr, unsigned short val)\n+{\n+  unsigned short tem = 1;\n+  unsigned short tem2 = *min(&arr, &tem);\n+  return tem2 / (arr ? arr : val);\n+}\n+\n+int\n+main()\n+{\n+  if (test (2, 2) != 0)\n+    __builtin_abort();\n+  return 0;\n+}"}, {"sha": "d6c83a72dd8c89bb5293804d160eb761c0d94d79", "filename": "gcc/tree-ssa-pre.cc", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftree-ssa-pre.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftree-ssa-pre.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.cc?ref=e25dce501334053239dcc433e4c46ecbddbcb13e", "patch": "@@ -323,6 +323,7 @@ static unsigned int next_expression_id;\n static vec<pre_expr> expressions;\n static hash_table<pre_expr_d> *expression_to_id;\n static vec<unsigned> name_to_id;\n+static obstack pre_expr_obstack;\n \n /* Allocate an expression id for EXPR.  */\n \n@@ -430,18 +431,23 @@ get_or_alloc_expr_for_name (tree name)\n   return result;\n }\n \n-/* Given an NARY, get or create a pre_expr to represent it.  */\n+/* Given an NARY, get or create a pre_expr to represent it.  Assign\n+   VALUE_ID to it or allocate a new value-id if it is zero.  Record\n+   LOC as the original location of the expression.  */\n \n static pre_expr\n-get_or_alloc_expr_for_nary (vn_nary_op_t nary,\n+get_or_alloc_expr_for_nary (vn_nary_op_t nary, unsigned value_id,\n \t\t\t    location_t loc = UNKNOWN_LOCATION)\n {\n   struct pre_expr_d expr;\n   pre_expr result;\n   unsigned int result_id;\n \n+  gcc_assert (value_id == 0 || !value_id_constant_p (value_id));\n+\n   expr.kind = NARY;\n   expr.id = 0;\n+  nary->hashcode = vn_nary_op_compute_hash (nary);\n   PRE_EXPR_NARY (&expr) = nary;\n   result_id = lookup_expression_id (&expr);\n   if (result_id != 0)\n@@ -450,8 +456,10 @@ get_or_alloc_expr_for_nary (vn_nary_op_t nary,\n   result = pre_expr_pool.allocate ();\n   result->kind = NARY;\n   result->loc = loc;\n-  result->value_id = nary->value_id;\n-  PRE_EXPR_NARY (result) = nary;\n+  result->value_id = value_id ? value_id : get_next_value_id ();\n+  PRE_EXPR_NARY (result)\n+    = alloc_vn_nary_op_noinit (nary->length, &pre_expr_obstack);\n+  memcpy (PRE_EXPR_NARY (result), nary, sizeof_vn_nary_op (nary->length));\n   alloc_expression_id (result);\n   return result;\n }\n@@ -1517,15 +1525,10 @@ phi_translate_1 (bitmap_set_t dest,\n \t      return get_or_alloc_expr_for_constant (result);\n \n \t    if (!nary || nary->predicated_values)\n-\t      {\n-\t\tnew_val_id = get_next_value_id ();\n-\t\tnary = vn_nary_op_insert_pieces (newnary->length,\n-\t\t\t\t\t\t newnary->opcode,\n-\t\t\t\t\t\t newnary->type,\n-\t\t\t\t\t\t &newnary->op[0],\n-\t\t\t\t\t\t result, new_val_id);\n-\t      }\n-\t    expr = get_or_alloc_expr_for_nary (nary, expr_loc);\n+\t      new_val_id = 0;\n+\t    else\n+\t      new_val_id = nary->value_id;\n+\t    expr = get_or_alloc_expr_for_nary (newnary, new_val_id, expr_loc);\n \t    add_to_value (get_expr_value_id (expr), expr);\n \t  }\n \treturn expr;\n@@ -2789,6 +2792,7 @@ find_or_generate_expression (basic_block block, tree op, gimple_seq *stmts)\n       /* Defer.  */\n       return NULL_TREE;\n     }\n+  gcc_assert (!value_id_constant_p (lookfor));\n \n   /* It must be a complex expression, so generate it recursively.  Note\n      that this is only necessary to handle gcc.dg/tree-ssa/ssa-pre28.c\n@@ -3993,8 +3997,14 @@ compute_avail (function *fun)\n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n \t    {\n \t      pre_expr e = get_or_alloc_expr_for_name (op);\n+\t      unsigned value_id = get_expr_value_id (e);\n+\t      if (value_id_constant_p (value_id))\n+\t\t{\n+\t\t  get_or_alloc_expr_for_constant (VN_INFO (op)->valnum);\n+\t\t  continue;\n+\t\t}\n \n-\t      add_to_value (get_expr_value_id (e), e);\n+\t      add_to_value (value_id, e);\n \t      bitmap_insert_into_set (TMP_GEN (block), e);\n \t      bitmap_value_insert_into_set (AVAIL_OUT (block), e);\n \t    }\n@@ -4073,6 +4083,16 @@ compute_avail (function *fun)\n \t\t      if (!nary || nary->predicated_values)\n \t\t\tcontinue;\n \n+\t\t      unsigned value_id = nary->value_id;\n+\t\t      if (value_id_constant_p (value_id))\n+\t\t\tcontinue;\n+\n+\t\t      /* Record the un-valueized expression for EXP_GEN.  */\n+\t\t      nary = XALLOCAVAR (struct vn_nary_op_s,\n+\t\t\t\t\t sizeof_vn_nary_op\n+\t\t\t\t\t   (vn_nary_length_from_stmt (stmt)));\n+\t\t      init_vn_nary_op_from_stmt (nary, as_a <gassign *> (stmt));\n+\n \t\t      /* If the NARY traps and there was a preceding\n \t\t         point in the block that might not return avoid\n \t\t\t adding the nary to EXP_GEN.  */\n@@ -4081,7 +4101,7 @@ compute_avail (function *fun)\n \t\t\tcontinue;\n \n \t\t      result = get_or_alloc_expr_for_nary\n-\t\t\t\t (nary, gimple_location (stmt));\n+\t\t\t\t (nary, value_id, gimple_location (stmt));\n \t\t      break;\n \t\t    }\n \n@@ -4275,6 +4295,7 @@ init_pre (void)\n   constant_value_expressions.create (get_max_constant_value_id () + 1);\n   constant_value_expressions.quick_grow_cleared (get_max_constant_value_id () + 1);\n   name_to_id.create (0);\n+  gcc_obstack_init (&pre_expr_obstack);\n \n   inserted_exprs = BITMAP_ALLOC (NULL);\n \n@@ -4312,6 +4333,7 @@ fini_pre ()\n   delete expression_to_id;\n   expression_to_id = NULL;\n   name_to_id.release ();\n+  obstack_free (&pre_expr_obstack, NULL);\n \n   basic_block bb;\n   FOR_ALL_BB_FN (bb, cfun)"}, {"sha": "d4d0aba880cd34f64a1b537b778824b72b806680", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=e25dce501334053239dcc433e4c46ecbddbcb13e", "patch": "@@ -426,11 +426,8 @@ typedef hash_table<vn_ssa_aux_hasher>::iterator vn_ssa_aux_iterator_type;\n static struct obstack vn_ssa_aux_obstack;\n \n static vn_nary_op_t vn_nary_op_insert_stmt (gimple *, tree);\n-static unsigned int vn_nary_length_from_stmt (gimple *);\n-static vn_nary_op_t alloc_vn_nary_op_noinit (unsigned int, obstack *);\n static vn_nary_op_t vn_nary_op_insert_into (vn_nary_op_t,\n \t\t\t\t\t    vn_nary_op_table_type *);\n-static void init_vn_nary_op_from_stmt (vn_nary_op_t, gassign *);\n static void init_vn_nary_op_from_pieces (vn_nary_op_t, unsigned int,\n \t\t\t\t\t enum tree_code, tree, tree *);\n static tree vn_lookup_simplify_result (gimple_match_op *);\n@@ -3854,7 +3851,7 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set,\n \n /* Compute and return the hash value for nary operation VBO1.  */\n \n-static hashval_t\n+hashval_t\n vn_nary_op_compute_hash (const vn_nary_op_t vno1)\n {\n   inchash::hash hstate;\n@@ -3927,7 +3924,7 @@ init_vn_nary_op_from_pieces (vn_nary_op_t vno, unsigned int length,\n \n /* Return the number of operands for a vn_nary ops structure from STMT.  */\n \n-static unsigned int\n+unsigned int\n vn_nary_length_from_stmt (gimple *stmt)\n {\n   switch (gimple_assign_rhs_code (stmt))\n@@ -3950,7 +3947,7 @@ vn_nary_length_from_stmt (gimple *stmt)\n \n /* Initialize VNO from STMT.  */\n \n-static void\n+void\n init_vn_nary_op_from_stmt (vn_nary_op_t vno, gassign *stmt)\n {\n   unsigned i;\n@@ -4047,7 +4044,7 @@ vn_nary_op_lookup_stmt (gimple *stmt, vn_nary_op_t *vnresult)\n \n /* Allocate a vn_nary_op_t with LENGTH operands on STACK.  */\n \n-static vn_nary_op_t\n+vn_nary_op_t\n alloc_vn_nary_op_noinit (unsigned int length, struct obstack *stack)\n {\n   return (vn_nary_op_t) obstack_alloc (stack, sizeof_vn_nary_op (length));"}, {"sha": "c4e341021e821e45532cab657f4cbad1d56ab2c7", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25dce501334053239dcc433e4c46ecbddbcb13e/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=e25dce501334053239dcc433e4c46ecbddbcb13e", "patch": "@@ -249,6 +249,10 @@ bool has_VN_INFO (tree);\n extern vn_ssa_aux_t VN_INFO (tree);\n tree vn_get_expr_for (tree);\n void scc_vn_restore_ssa_info (void);\n+vn_nary_op_t alloc_vn_nary_op_noinit (unsigned int, struct obstack *);\n+unsigned int vn_nary_length_from_stmt (gimple *);\n+void init_vn_nary_op_from_stmt (vn_nary_op_t, gassign *);\n+hashval_t vn_nary_op_compute_hash (const vn_nary_op_t);\n tree vn_nary_op_lookup_stmt (gimple *, vn_nary_op_t *);\n tree vn_nary_op_lookup_pieces (unsigned int, enum tree_code,\n \t\t\t       tree, tree *, vn_nary_op_t *);"}]}