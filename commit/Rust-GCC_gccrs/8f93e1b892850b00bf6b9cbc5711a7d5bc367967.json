{"sha": "8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5M2UxYjg5Mjg1MGIwMGJmNmI5Y2JjNTcxMWE3ZDViYzM2Nzk2Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-11T21:06:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-12T21:50:03Z"}, "message": "Expunge namespace-scope IDENTIFIER_TYPE_VALUE & global_type_name [PR 99039]\n\nIDENTIFIER_TYPE_VALUE and friends is a remnant of G++'s C origins.  It\nholds elaborated types on identifier-nodes.  While this is fine for C\nand for local and class-scopes in C++, it fails badly for namespaces.\nIn that case a marker 'global_type_node' was used, which essentially\nsignified 'this is a namespace-scope type *somewhere*', and you'd have\nto do a regular name_lookup to find it.  As the parser and\nsubstitution machinery has avanced over the last 25 years or so,\nthere's not much outside of actual name-lookup that uses that.\nAmusingly the IDENTIFIER_HAS_TYPE_VALUE predicate will do an actual\nname-lookup and then users would repeat that lookup to find the\nnow-known to be there type.\n\nRather late I realized that this interferes with the lazy loading of\nmodule entities, because we were setting IDENTIFIER_TYPE_VALUE to\nglobal_type_node.  But we could be inside some local scope where that\nidentifier is bound to some local type.  Not good!\n\nRather than add more cruft to look at an identifier's shadow stack and\nalter that as necessary, this takes the approach of removing the\nexisting cruft.\n\nWe nuke the few places outside of name lookup that use\nIDENTIFIER_TYPE_VALUE.  Replacing them with either proper name\nlookups, alternative sequences, or in some cases asserting that they\n(no longer) happen.  Class template instantiation was calling pushtag\nafter setting IDENTIFIER_TYPE_VALUE in order to stop pushtag creating\nan implicit typedef and pushing it, but to get the bookkeeping it\nneeded.  Let's just do the bookkeeping directly.\n\nThen we can stop having a 'bound at namespace-scope' marker at all,\nwhich means lazy loading won't screw up local shadow stacks.  Also, it\nsimplifies set_identifier_type_value_with_scope, as it never needs to\ninspect the scope stack.  When developing this patch, I discovered a\nnumber of places we'd put an actual namespace-scope type on the\ntype_value slot, rather than global_type_node.  You might notice this\nis killing at least two 'why are we doing this?' comments.\n\nWhile this doesn't fix the two PRs mentioned, it is a necessary step.\n\n\tPR c++/99039\n\tPR c++/99040\n\tgcc/cp/\n\t* cp-tree.h (CPTI_GLOBAL_TYPE): Delete.\n\t(global_type_node): Delete.\n\t(IDENTIFIER_TYPE_VALUE): Delete.\n\t(IDENTIFIER_HAS_TYPE_VALUE): Delete.\n\t(get_type_value): Delete.\n\t* name-lookup.h (identifier_type_value): Delete.\n\t* name-lookup.c (check_module_override): Don't\n\tSET_IDENTIFIER_TYPE_VALUE here.\n\t(do_pushdecl): Nor here.\n\t(identifier_type_value_1, identifier_type_value): Delete.\n\t(set_identifier_type_value_with_scope): Only\n\tSET_IDENTIFIER_TYPE_VALUE for local and class scopes.\n\t(pushdecl_nanmespace_level): Remove shadow stack nadgering.\n\t(do_pushtag): Use REAL_IDENTIFIER_TYPE_VALUE.\n\t* call.c (check_dtor_name): Use lookup_name.\n\t* decl.c (cxx_init_decl_processing): Drop global_type_node.\n\t* decl2.c (cplus_decl_attributes): Don't SET_IDENTIFIER_TYPE_VALUE\n\there.\n\t* init.c (get_type_value): Delete.\n\t* pt.c (instantiate_class_template_1): Don't call pushtag or\n\tSET_IDENTIFIER_TYPE_VALUE here.\n\t(tsubst): Assert never an identifier.\n\t(dependent_type_p): Drop global_type_node assert.\n\t* typeck.c (error_args_num): Don't use IDENTIFIER_HAS_TYPE_VALUE\n\tto determine ctorness.\n\tgcc/testsuite/\n\t* g++.dg/lookup/pr99039.C: New.", "tree": {"sha": "3bf9b0f6db39e47d52073a8eb290f1ed0360dd1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bf9b0f6db39e47d52073a8eb290f1ed0360dd1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9769564e7456453e2273071d0faa5aab2554ff78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9769564e7456453e2273071d0faa5aab2554ff78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9769564e7456453e2273071d0faa5aab2554ff78"}], "stats": {"total": 268, "additions": 106, "deletions": 162}, "files": [{"sha": "186feef6fe33e0128ad89502d7e7cf9c39927d7f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -236,8 +236,15 @@ check_dtor_name (tree basetype, tree name)\n \t   || TREE_CODE (basetype) == ENUMERAL_TYPE)\n \t  && name == constructor_name (basetype))\n \treturn true;\n-      else\n-\tname = get_type_value (name);\n+\n+      /* Otherwise lookup the name, it could be an unrelated typedef\n+\t of the correct type.  */\n+      name = lookup_name (name, LOOK_want::TYPE);\n+      if (!name)\n+\treturn false;\n+      name = TREE_TYPE (name);\n+      if (name == error_mark_node)\n+\treturn false;\n     }\n   else\n     {\n@@ -252,8 +259,6 @@ check_dtor_name (tree basetype, tree name)\n       return false;\n     }\n \n-  if (!name || name == error_mark_node)\n-    return false;\n   return same_type_p (TYPE_MAIN_VARIANT (basetype), TYPE_MAIN_VARIANT (name));\n }\n "}, {"sha": "38b31e3908f0ab5d77d2147e73e5c193334404b7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -129,7 +129,6 @@ enum cp_tree_index\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_GLOBAL,\n-    CPTI_GLOBAL_TYPE,\n     CPTI_ABORT_FNDECL,\n     CPTI_AGGR_TAG,\n     CPTI_CONV_OP_MARKER,\n@@ -250,7 +249,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n #define abi_node\t\t\tcp_global_trees[CPTI_ABI]\n #define global_namespace\t\tcp_global_trees[CPTI_GLOBAL]\n-#define global_type_node\t\tcp_global_trees[CPTI_GLOBAL_TYPE]\n #define const_type_info_type_node\tcp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]\n #define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n #define conv_op_marker\t\t\tcp_global_trees[CPTI_CONV_OP_MARKER]\n@@ -1149,24 +1147,16 @@ enum GTY(()) abstract_class_use {\n \n /* Macros for access to language-specific slots in an identifier.  */\n \n-/* The IDENTIFIER_BINDING is the innermost cxx_binding for the\n-    identifier.  Its PREVIOUS is the next outermost binding.  Each\n-    VALUE field is a DECL for the associated declaration.  Thus,\n-    name lookup consists simply of pulling off the node at the front\n-    of the list (modulo oddities for looking up the names of types,\n-    and such.)  You can use SCOPE field to determine the scope\n-    that bound the name.  */\n+/* Identifiers map directly to block or class-scope bindings.\n+   Namespace-scope bindings are held in hash tables on the respective\n+   namespaces.  The identifier bindings are the innermost active\n+   binding, from whence you can get the decl and/or implicit-typedef\n+   of an elaborated type.   When not bound to a local entity the\n+   values are NULL.  */\n #define IDENTIFIER_BINDING(NODE) \\\n   (LANG_IDENTIFIER_CAST (NODE)->bindings)\n-\n-/* TREE_TYPE only indicates on local and class scope the current\n-   type. For namespace scope, the presence of a type in any namespace\n-   is indicated with global_type_node, and the real type behind must\n-   be found through lookup.  */\n-#define IDENTIFIER_TYPE_VALUE(NODE) identifier_type_value (NODE)\n #define REAL_IDENTIFIER_TYPE_VALUE(NODE) TREE_TYPE (NODE)\n #define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = (TYPE))\n-#define IDENTIFIER_HAS_TYPE_VALUE(NODE) (IDENTIFIER_TYPE_VALUE (NODE) ? 1 : 0)\n \n /* Kinds of identifiers.  Values are carefully chosen.  */\n enum cp_identifier_kind {\n@@ -6862,7 +6852,6 @@ extern void emit_mem_initializers\t\t(tree);\n extern tree build_aggr_init\t\t\t(tree, tree, int,\n                                                  tsubst_flags_t);\n extern int is_class_type\t\t\t(tree, int);\n-extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree, tsubst_flags_t);\n extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);"}, {"sha": "6f3414f058eb8b6a28fdb8a0134332de975bc2b0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -4510,9 +4510,6 @@ cxx_init_decl_processing (void)\n   abi_node = current_namespace;\n   pop_namespace ();\n \n-  global_type_node = make_node (LANG_TYPE);\n-  record_unknown_type (global_type_node, \"global type\");\n-\n   any_targ_node = make_node (LANG_TYPE);\n   record_unknown_type (any_targ_node, \"any type\");\n "}, {"sha": "c46100de89a69959fd05b1b0f9e3fc4c7e959874", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -1596,9 +1596,6 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n       decl_attributes (decl, attributes, flags, last_decl);\n     }\n \n-  if (TREE_CODE (*decl) == TYPE_DECL)\n-    SET_IDENTIFIER_TYPE_VALUE (DECL_NAME (*decl), TREE_TYPE (*decl));\n-\n   /* Propagate deprecation out to the template.  */\n   if (TREE_DEPRECATED (*decl))\n     if (tree ti = get_template_info (*decl))"}, {"sha": "49950d405216ab2ae986d6443e108eea90275a6f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -2118,18 +2118,6 @@ is_class_type (tree type, int or_else)\n   return 1;\n }\n \n-tree\n-get_type_value (tree name)\n-{\n-  if (name == error_mark_node)\n-    return NULL_TREE;\n-\n-  if (IDENTIFIER_HAS_TYPE_VALUE (name))\n-    return IDENTIFIER_TYPE_VALUE (name);\n-  else\n-    return NULL_TREE;\n-}\n-\n /* Build a reference to a member of an aggregate.  This is not a C++\n    `&', but really something which can have its address taken, and\n    then act as a pointer to member, for example TYPE :: FIELD can have"}, {"sha": "8aa490db6340aab05ae679fff0bad0f1c9c8543c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 105, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -3620,14 +3620,7 @@ check_module_override (tree decl, tree mvec, bool hiding,\n \t  if (iter.using_p ())\n \t    ;\n \t  else if (tree match = duplicate_decls (decl, *iter, hiding))\n-\t    {\n-\t      if (TREE_CODE (match) == TYPE_DECL)\n-\t\t/* The IDENTIFIER will have the type referring to the\n-\t\t   now-smashed TYPE_DECL, because ...?  Reset it.  */\n-\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (match));\n-\n-\t      return match;\n-\t    }\n+\t    return match;\n       }\n \n   if (TREE_PUBLIC (scope) && TREE_PUBLIC (decl) && !not_module_p ()\n@@ -3649,11 +3642,7 @@ check_module_override (tree decl, tree mvec, bool hiding,\n \t  tree match = *iter;\n \t  \n \t  if (duplicate_decls (decl, match, hiding))\n-\t    {\n-\t      if (TREE_CODE (match) == TYPE_DECL)\n-\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (match));\n-\t      return match;\n-\t    }\n+\t    return match;\n \t}\n     }\n \n@@ -3736,9 +3725,14 @@ do_pushdecl (tree decl, bool hiding)\n \t    if (match == error_mark_node)\n \t      ;\n \t    else if (TREE_CODE (match) == TYPE_DECL)\n-\t      /* The IDENTIFIER will have the type referring to the\n-\t\t now-smashed TYPE_DECL, because ...?  Reset it.  */\n-\t      SET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (match));\n+\t      {\n+\t\tauto *l = level;\n+\t\twhile (l->kind == sk_template_parms)\n+\t\t  l = l->level_chain;\n+\t\tgcc_checking_assert (REAL_IDENTIFIER_TYPE_VALUE (name)\n+\t\t\t\t     == (l->kind == sk_namespace\n+\t\t\t\t\t ? NULL_TREE : TREE_TYPE (match)));\n+\t      }\n \t    else if (iter.hidden_p () && !hiding)\n \t      {\n \t\t/* Unhiding a previously hidden decl.  */\n@@ -4748,37 +4742,6 @@ print_binding_stack (void)\n   print_binding_level (NAMESPACE_LEVEL (global_namespace));\n }\n \f\n-/* Return the type associated with ID.  */\n-\n-static tree\n-identifier_type_value_1 (tree id)\n-{\n-  /* There is no type with that name, anywhere.  */\n-  if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n-    return NULL_TREE;\n-  /* This is not the type marker, but the real thing.  */\n-  if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n-    return REAL_IDENTIFIER_TYPE_VALUE (id);\n-  /* Have to search for it. It must be on the global level, now.\n-     Ask lookup_name not to return non-types.  */\n-  id = lookup_name (id, LOOK_where::BLOCK_NAMESPACE, LOOK_want::TYPE);\n-  if (id)\n-    return TREE_TYPE (id);\n-  return NULL_TREE;\n-}\n-\n-/* Wrapper for identifier_type_value_1.  */\n-\n-tree\n-identifier_type_value (tree id)\n-{\n-  tree ret;\n-  timevar_start (TV_NAME_LOOKUP);\n-  ret = identifier_type_value_1 (id);\n-  timevar_stop (TV_NAME_LOOKUP);\n-  return ret;\n-}\n-\n /* Push a definition of struct, union or enum tag named ID.  into\n    binding_level B.  DECL is a TYPE_DECL for the type.  DECL has\n    already been pushed into its binding level.  This is bookkeeping to\n@@ -4787,26 +4750,21 @@ identifier_type_value (tree id)\n static void\n set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n {\n-  tree type;\n+  while (b->kind == sk_template_parms)\n+    b = b->level_chain;\n \n-  if (b->kind != sk_namespace)\n-    {\n-      /* Shadow the marker, not the real thing, so that the marker\n-\t gets restored later.  */\n-      tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-      b->type_shadowed = tree_cons (id, old_type_value, b->type_shadowed);\n-      type = decl ? TREE_TYPE (decl) : NULL_TREE;\n-      TREE_TYPE (b->type_shadowed) = type;\n-    }\n+  if (b->kind == sk_namespace)\n+    /* At namespace scope we should not see an identifier type value.  */\n+    gcc_checking_assert (!REAL_IDENTIFIER_TYPE_VALUE (id));\n   else\n     {\n-      gcc_assert (decl);\n-\n-      /* Store marker instead of real type.  */\n-      type = global_type_node;\n+      /* Push the current type value, so we can restore it later  */\n+      tree old = REAL_IDENTIFIER_TYPE_VALUE (id);\n+      b->type_shadowed = tree_cons (id, old, b->type_shadowed);\n+      tree type = decl ? TREE_TYPE (decl) : NULL_TREE;\n+      TREE_TYPE (b->type_shadowed) = type;\n+      SET_IDENTIFIER_TYPE_VALUE (id, type);\n     }\n-\n-  SET_IDENTIFIER_TYPE_VALUE (id, type);\n }\n \n /* As set_identifier_type_value_with_scope, but using\n@@ -6238,51 +6196,17 @@ do_namespace_alias (tree alias, tree name_space)\n     (*debug_hooks->early_global_decl) (alias);\n }\n \n-/* Like pushdecl, only it places X in the current namespace,\n+/* Like pushdecl, only it places DECL in the current namespace,\n    if appropriate.  */\n \n tree\n-pushdecl_namespace_level (tree x, bool hiding)\n+pushdecl_namespace_level (tree decl, bool hiding)\n {\n-  cp_binding_level *b = current_binding_level;\n-  tree t;\n-\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  t = do_pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace), hiding);\n-\n-  /* Now, the type_shadowed stack may screw us.  Munge it so it does\n-     what we want.  */\n-  if (TREE_CODE (t) == TYPE_DECL)\n-    {\n-      tree name = DECL_NAME (t);\n-      tree newval;\n-      tree *ptr = (tree *)0;\n-      for (; !global_scope_p (b); b = b->level_chain)\n-\t{\n-\t  tree shadowed = b->type_shadowed;\n-\t  for (; shadowed; shadowed = TREE_CHAIN (shadowed))\n-\t    if (TREE_PURPOSE (shadowed) == name)\n-\t      {\n-\t\tptr = &TREE_VALUE (shadowed);\n-\t\t/* Can't break out of the loop here because sometimes\n-\t\t   a binding level will have duplicate bindings for\n-\t\t   PT names.  It's gross, but I haven't time to fix it.  */\n-\t      }\n-\t}\n-      newval = TREE_TYPE (t);\n-      if (ptr == (tree *)0)\n-\t{\n-\t  /* @@ This shouldn't be needed.  My test case \"zstring.cc\" trips\n-\t     up here if this is changed to an assertion.  --KR  */\n-\t  SET_IDENTIFIER_TYPE_VALUE (name, t);\n-\t}\n-      else\n-\t{\n-\t  *ptr = newval;\n-\t}\n-    }\n+  tree res = do_pushdecl_with_scope (decl, NAMESPACE_LEVEL (current_namespace),\n+\t\t\t\t     hiding);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return t;\n+  return res;\n }\n \n /* Wrapper around push_local_binding to push the bindings for\n@@ -8257,6 +8181,8 @@ do_pushtag (tree name, tree type, TAG_how how)\n {\n   tree decl;\n \n+  gcc_assert (identifier_p (name));\n+\n   cp_binding_level *b = current_binding_level;\n   while (true)\n     {\n@@ -8282,10 +8208,8 @@ do_pushtag (tree name, tree type, TAG_how how)\n \tbreak;\n     }\n \n-  gcc_assert (identifier_p (name));\n-\n   /* Do C++ gratuitous typedefing.  */\n-  if (identifier_type_value_1 (name) != type)\n+  if (REAL_IDENTIFIER_TYPE_VALUE (name) != type)\n     {\n       tree tdef;\n       tree context = TYPE_CONTEXT (type);"}, {"sha": "e159942eda44bbd29c9c674d62ca1f15a294e8e7", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -188,7 +188,6 @@ struct GTY(()) tree_binding_vec {\n #define BINDING_VECTOR_PENDING_IS_PARTITION_P(NODE) \\\n   (BINDING_VECTOR_CHECK (NODE)->base.private_flag)\n \n-extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n extern void push_binding (tree, tree, cp_binding_level*);\n extern void pop_local_binding (tree, tree);"}, {"sha": "60de8e93ff73a6338d39664c2359673b569b5e72", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -11971,14 +11971,13 @@ instantiate_class_template_1 (tree type)\n \t\t       instantiation, but the TYPE is not.) */\n \t\t    CLASSTYPE_USE_TEMPLATE (newtag) = 0;\n \n-\t\t  /* Now, we call pushtag to put this NEWTAG into the scope of\n-\t\t     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid\n-\t\t     pushtag calling push_template_decl.  We don't have to do\n-\t\t     this for enums because it will already have been done in\n-\t\t     tsubst_enum.  */\n-\t\t  if (name)\n-\t\t    SET_IDENTIFIER_TYPE_VALUE (name, newtag);\n-\t\t  pushtag (name, newtag);\n+\t\t  /* Now, install the tag.  We don't use pushtag\n+\t\t     because that does too much work -- creating an\n+\t\t     implicit typedef, which we've already done.  */\n+\t\t  set_identifier_type_value (name, TYPE_NAME (newtag));\n+\t\t  maybe_add_class_template_decl_list (type, newtag, false);\n+\t\t  TREE_PUBLIC (TYPE_NAME (newtag)) = true;\n+\t\t  determine_visibility (TYPE_NAME (newtag));\n \t\t}\n \t    }\n \t  else if (DECL_DECLARES_FUNCTION_P (t))\n@@ -15424,10 +15423,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n   code = TREE_CODE (t);\n \n-  if (code == IDENTIFIER_NODE)\n-    type = IDENTIFIER_TYPE_VALUE (t);\n-  else\n-    type = TREE_TYPE (t);\n+  gcc_assert (code != IDENTIFIER_NODE);\n+  type = TREE_TYPE (t);\n \n   gcc_assert (type != unknown_type_node);\n \n@@ -26774,10 +26771,6 @@ dependent_type_p (tree type)\n   if (type == error_mark_node)\n     return false;\n \n-  /* Getting here with global_type_node means we improperly called this\n-     function on the TREE_TYPE of an IDENTIFIER_NODE.  */\n-  gcc_checking_assert (type != global_type_node);\n-\n   /* If we have not already computed the appropriate value for TYPE,\n      do so now.  */\n   if (!TYPE_DEPENDENT_P_VALID (type))"}, {"sha": "d06d7440d5cd1fd66040abf49a9b37345c96bc3c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -4060,7 +4060,8 @@ error_args_num (location_t loc, tree fndecl, bool too_many_p)\n       if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE)\n \t{\n \t  if (DECL_NAME (fndecl) == NULL_TREE\n-\t      || IDENTIFIER_HAS_TYPE_VALUE (DECL_NAME (fndecl)))\n+\t      || (DECL_NAME (fndecl)\n+\t\t  == DECL_NAME (TYPE_NAME (DECL_CONTEXT (fndecl)))))\n \t    error_at (loc,\n \t\t      too_many_p\n \t\t      ? G_(\"too many arguments to constructor %q#D\")"}, {"sha": "982a991daa7ea4cab92d6cefc4110e78b09f45ed", "filename": "gcc/testsuite/g++.dg/lookup/pr99039.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr99039.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f93e1b892850b00bf6b9cbc5711a7d5bc367967/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr99039.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr99039.C?ref=8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "patch": "@@ -0,0 +1,51 @@\n+// PR 99039, we need to remove the namespace-scope meaning of\n+// IDENTIFIER_TYPE_VALUE.\n+\n+namespace std\n+{\n+typedef long unsigned int size_t;\n+\n+template<typename _CharT>\n+struct char_traits\n+{\n+  typedef _CharT char_type;\n+\n+  template<typename U>\n+  static int\n+    compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n+};\n+\n+template<typename _CharT>\n+template<typename U>\n+int\n+char_traits<_CharT>::\n+compare(const char_type* __s1, const char_type* __s2, std::size_t __n)\n+{\n+  return 0;\n+}\n+\n+}\n+\n+struct CHAR_TRAITS;\n+namespace std\n+{\n+typedef long unsigned int size_t;\n+\n+struct CHAR_TRAITS\n+{\n+  typedef char char_type;\n+\n+  static int\n+    compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n+};\n+\n+int\n+CHAR_TRAITS::\n+compare(const char_type* __s1, const char_type* __s2, std::size_t __n)\n+{\n+  return 0;\n+}\n+\n+}\n+\n+struct CHAR_TRAITS;"}]}