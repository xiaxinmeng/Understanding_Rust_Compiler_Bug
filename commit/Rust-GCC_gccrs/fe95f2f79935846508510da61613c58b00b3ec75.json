{"sha": "fe95f2f79935846508510da61613c58b00b3ec75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5NWYyZjc5OTM1ODQ2NTA4NTEwZGE2MTYxM2M1OGIwMGIzZWM3NQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2007-01-12T09:19:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-01-12T09:19:52Z"}, "message": "200x-xx-xx Julian Brown <julian@codesourcery.com> Richard Sandiford <richard@codesourcery.com>\n\ngcc/\n200x-xx-xx  Julian Brown  <julian@codesourcery.com>\n\t    Richard Sandiford  <richard@codesourcery.com>\n\n\t* config/m68k/m68k.h (TARGET_CPU_CPP_BUILTINS): Use TUNE_68030\n\tinstead of TARGET_68030, TUNE_68040 instead of TARGET_68040,\n\tTUNE_68060 instead of TARGET_68060 and TUNE_CPU32 instead of\n\tTARGET_CPU32.\n\t(TARGET_CPU32): Rename to...\n\t(TUNE_CPU32): ...this.\n\t(TUNE_68000_10, TUNE_68030, TUNE_68040, TUNE_68060)\n\t(TUNE_CFV2): New macros.\n\t* config/m68k/netbsd-elf.h (LONG_DOUBLE_TYPE_SIZE): Simplify;\n\tremove conditions that are implied by TARGET_68020.\n\t* config/m68k/m68k.c (m68k_output_function_prologue): Use TUNE_68040\n\tinstead of TARGET_68040 and TUNE_CPU32 instead of TARGET_CPU32.\n\t(m68k_output_function_epilogue): Likewise.\n\t(m68k_rtx_costs): Likewise.  Use TUNE_68060 instead of TARGET_68060\n\tand TUNE_CFV2 instead of TARGET_5200.  Use TUNE_68000_10 instead of\n\t\"!TARGET_68020 && !TARGET_COLDFIRE\" to choose between 68000 and\n\tnon-68000 timings.  Refactor multiplication and division costs.\n\t(output_addsi3): Use TUNE_68040 instead of TARGET_68040 and\n\tTUNE_CPU32 instead of TARGET_CPU32.\n\t(standard_68881_constant_p): Use TUNE_68040 instead of TARGET_68040\n\tand TUNE_68060 instead of TARGET_68060.\n\t* config/m68k/m68k.md: Use TUNE_68040 instead of TARGET_68040,\n\tTUNE_68060 instead of TARGET_68060, and TUNE_CPU32 instead of\n\tTARGET_CPU32.\n\t(movsi_const0): Use TUNE_68000_10 rather than \"!TARGET_68020\n\t&& !TARGET_COLDFIRE\" to choose between moveq and clr.\n\tLikewise in the unnamed movsf pattern.\n\t(ashlsi_17_24, lshrsi_17_24): Guard with TUNE_68000_10 rather than\n\t\"!TARGET_68020 && !TARGET_COLDFIRE\".  Likewise the unnamed\n\tashiftrt pattern.\n\nCo-Authored-By: Richard Sandiford <richard@codesourcery.com>\n\nFrom-SVN: r120706", "tree": {"sha": "8364e45ff06ba0a5d596adbd45b777a238a29452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8364e45ff06ba0a5d596adbd45b777a238a29452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe95f2f79935846508510da61613c58b00b3ec75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe95f2f79935846508510da61613c58b00b3ec75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe95f2f79935846508510da61613c58b00b3ec75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe95f2f79935846508510da61613c58b00b3ec75/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c6de4a1df06e33048d2dfbe155d27f58b0a87ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c6de4a1df06e33048d2dfbe155d27f58b0a87ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c6de4a1df06e33048d2dfbe155d27f58b0a87ea"}], "stats": {"total": 241, "additions": 144, "deletions": 97}, "files": [{"sha": "a8e0835c34cbbbfc3edaa54e584599cd8067fa58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe95f2f79935846508510da61613c58b00b3ec75", "patch": "@@ -1,3 +1,37 @@\n+2007-01-12  Julian Brown  <julian@codesourcery.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/m68k/m68k.h (TARGET_CPU_CPP_BUILTINS): Use TUNE_68030\n+\tinstead of TARGET_68030, TUNE_68040 instead of TARGET_68040,\n+\tTUNE_68060 instead of TARGET_68060 and TUNE_CPU32 instead of\n+\tTARGET_CPU32.\n+\t(TARGET_CPU32): Rename to...\n+\t(TUNE_CPU32): ...this.\n+\t(TUNE_68000_10, TUNE_68030, TUNE_68040, TUNE_68060)\n+\t(TUNE_CFV2): New macros.\n+\t* config/m68k/netbsd-elf.h (LONG_DOUBLE_TYPE_SIZE): Simplify;\n+\tremove conditions that are implied by TARGET_68020.\n+\t* config/m68k/m68k.c (m68k_output_function_prologue): Use TUNE_68040\n+\tinstead of TARGET_68040 and TUNE_CPU32 instead of TARGET_CPU32.\n+\t(m68k_output_function_epilogue): Likewise.\n+\t(m68k_rtx_costs): Likewise.  Use TUNE_68060 instead of TARGET_68060\n+\tand TUNE_CFV2 instead of TARGET_5200.  Use TUNE_68000_10 instead of\n+\t\"!TARGET_68020 && !TARGET_COLDFIRE\" to choose between 68000 and\n+\tnon-68000 timings.  Refactor multiplication and division costs.\n+\t(output_addsi3): Use TUNE_68040 instead of TARGET_68040 and\n+\tTUNE_CPU32 instead of TARGET_CPU32.\n+\t(standard_68881_constant_p): Use TUNE_68040 instead of TARGET_68040\n+\tand TUNE_68060 instead of TARGET_68060.\n+\t* config/m68k/m68k.md: Use TUNE_68040 instead of TARGET_68040,\n+\tTUNE_68060 instead of TARGET_68060, and TUNE_CPU32 instead of\n+\tTARGET_CPU32.\n+\t(movsi_const0): Use TUNE_68000_10 rather than \"!TARGET_68020\n+\t&& !TARGET_COLDFIRE\" to choose between moveq and clr.\n+\tLikewise in the unnamed movsf pattern.\n+\t(ashlsi_17_24, lshrsi_17_24): Guard with TUNE_68000_10 rather than\n+\t\"!TARGET_68020 && !TARGET_COLDFIRE\".  Likewise the unnamed\n+\tashiftrt pattern.\n+\n 2007-01-12  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/m68k/m68k.h (TARGET_CPU_CPP_BUILTINS): Increase amount"}, {"sha": "0fae1d902a06645bfef17a439ff5506301083072", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=fe95f2f79935846508510da61613c58b00b3ec75", "patch": "@@ -550,7 +550,7 @@ m68k_output_function_prologue (FILE *stream,\n \n   if (frame_pointer_needed)\n     {\n-      if (current_frame.size == 0 && TARGET_68040)\n+      if (current_frame.size == 0 && TUNE_68040)\n \t/* on the 68040, pea + move is faster than link.w 0 */\n \tfprintf (stream, (MOTOROLA\n \t\t\t  ? \"\\tpea (%s)\\n\\tmove.l %s,%s\\n\"\n@@ -584,14 +584,14 @@ m68k_output_function_prologue (FILE *stream,\n \t\tasm_fprintf (stream, \"\\tsubq\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n \t\t             fsize_with_regs);\n \t    }\n-\t  else if (fsize_with_regs <= 16 && TARGET_CPU32)\n+\t  else if (fsize_with_regs <= 16 && TUNE_CPU32)\n \t    /* On the CPU32 it is faster to use two subqw instructions to\n \t       subtract a small integer (8 < N <= 16) to a register.  */\n \t    asm_fprintf (stream,\n \t\t\t \"\\tsubq\" ASM_DOT \"w %I8,%Rsp\\n\"\n \t\t\t \"\\tsubq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n \t\t\t fsize_with_regs - 8);\n-\t  else if (TARGET_68040)\n+\t  else if (TUNE_68040)\n \t    /* Adding negative number is faster on the 68040.  */\n \t    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n \t\t\t -fsize_with_regs);\n@@ -1054,7 +1054,7 @@ m68k_output_function_epilogue (FILE *stream,\n \t    asm_fprintf (stream, \"\\taddq\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n \t\t\t fsize_with_regs);\n \t}\n-      else if (fsize_with_regs <= 16 && TARGET_CPU32)\n+      else if (fsize_with_regs <= 16 && TUNE_CPU32)\n \t{\n \t  /* On the CPU32 it is faster to use two addqw instructions to\n \t     add a small integer (8 < N <= 16) to a register.  */\n@@ -1065,7 +1065,7 @@ m68k_output_function_epilogue (FILE *stream,\n \t}\n       else if (fsize_with_regs < 0x8000)\n \t{\n-\t  if (TARGET_68040)\n+\t  if (TUNE_68040)\n \t    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n \t\t\t fsize_with_regs);\n \t  else\n@@ -1634,12 +1634,21 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n        sometimes move insns are needed.  */\n     /* div?.w is relatively cheaper on 68000 counted in COSTS_N_INSNS\n        terms.  */\n-#define MULL_COST (TARGET_68060 ? 2 : TARGET_68040 ? 5\t\t\\\n-\t\t   : (TARGET_COLDFIRE && !TARGET_5200) ? 3\t\\\n-\t\t   : TARGET_COLDFIRE ? 10 : 13)\n-#define MULW_COST (TARGET_68060 ? 2 : TARGET_68040 ? 3 : TARGET_68020 ? 8 \\\n-\t\t   : (TARGET_COLDFIRE && !TARGET_5200) ? 2 : 5)\n-#define DIVW_COST (TARGET_68020 ? 27 : TARGET_CF_HWDIV ? 11 : 12)\n+#define MULL_COST\t\t\t\t\\\n+  (TUNE_68060 ? 2\t\t\t\t\\\n+   : TUNE_68040 ? 5\t\t\t\t\\\n+   : TUNE_CFV2 ? 10\t\t\t\t\\\n+   : TARGET_COLDFIRE ? 3 : 13)\n+\n+#define MULW_COST\t\t\t\t\\\n+  (TUNE_68060 ? 2\t\t\t\t\\\n+   : TUNE_68040 ? 3\t\t\t\t\\\n+   : TUNE_68000_10 || TUNE_CFV2 ? 5\t\t\\\n+   : TARGET_COLDFIRE ? 2 : 8)\n+\n+#define DIVW_COST\t\t\t\t\\\n+  (TARGET_CF_HWDIV ? 11\t\t\t\t\\\n+   : TUNE_68000_10 || TARGET_COLDFIRE ? 12 : 27)\n \n     case PLUS:\n       /* An lea costs about three times as much as a simple add.  */\n@@ -1661,12 +1670,12 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n-      if (TARGET_68060)\n+      if (TUNE_68060)\n \t{\n           *total = COSTS_N_INSNS(1);\n \t  return true;\n \t}\n-      if (! TARGET_68020 && ! TARGET_COLDFIRE)\n+      if (TUNE_68000_10)\n         {\n \t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t    {\n@@ -2560,7 +2569,7 @@ output_addsi3 (rtx *operands)\n       /* On the CPU32 it is faster to use two addql instructions to\n \t add a small integer (8 < N <= 16) to a register.\n \t Likewise for subql.  */\n-      if (TARGET_CPU32 && REG_P (operands[0]))\n+      if (TUNE_CPU32 && REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[2]) > 8\n \t      && INTVAL (operands[2]) <= 16)\n@@ -2579,7 +2588,7 @@ output_addsi3 (rtx *operands)\n \t  && INTVAL (operands[2]) >= -0x8000\n \t  && INTVAL (operands[2]) < 0x8000)\n \t{\n-\t  if (TARGET_68040)\n+\t  if (TUNE_68040)\n \t    return \"add%.w %2,%0\";\n \t  else\n \t    return MOTOROLA ? \"lea (%c2,%0),%0\" : \"lea %0@(%c2),%0\";\n@@ -2780,7 +2789,7 @@ standard_68881_constant_p (rtx x)\n \n   /* fmovecr must be emulated on the 68040 and 68060, so it shouldn't be\n      used at all on those chips.  */\n-  if (TARGET_68040 || TARGET_68060)\n+  if (TUNE_68040 || TUNE_68060)\n     return 0;\n \n   if (! inited_68881_table)"}, {"sha": "b50bf10c550bbfc2e82d6962c64089bac7af9819", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=fe95f2f79935846508510da61613c58b00b3ec75", "patch": "@@ -42,31 +42,31 @@ Boston, MA 02110-1301, USA.  */\n       builtin_define_std (\"mc68000\");\t\t\t\t\t\\\n       if (TARGET_68040_ONLY)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (TARGET_68060)\t\t\t\t\t\t\\\n+\t  if (TUNE_68060)\t\t\t\t\t\t\\\n \t    builtin_define_std (\"mc68060\");\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    builtin_define_std (\"mc68040\");\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      else if (TARGET_68060) /* -m68020-60 */\t\t\t\t\\\n+      else if (TUNE_68060) /* -m68020-60 */\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  builtin_define_std (\"mc68060\");\t\t\t\t\\\n \t  builtin_define_std (\"mc68040\");\t\t\t\t\\\n \t  builtin_define_std (\"mc68030\");\t\t\t\t\\\n \t  builtin_define_std (\"mc68020\");\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      else if (TARGET_68040) /* -m68020-40 */\t\t\t\t\\\n+      else if (TUNE_68040) /* -m68020-40 */\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  builtin_define_std (\"mc68040\");\t\t\t\t\\\n \t  builtin_define_std (\"mc68030\");\t\t\t\t\\\n \t  builtin_define_std (\"mc68020\");\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      else if (TARGET_68030)\t\t\t\t\t\t\\\n+      else if (TUNE_68030)\t\t\t\t\t\t\\\n \tbuiltin_define_std (\"mc68030\");\t\t\t\t\t\\\n       else if (TARGET_68020)\t\t\t\t\t\t\\\n \tbuiltin_define_std (\"mc68020\");\t\t\t\t\t\\\n       if (TARGET_68881)\t\t\t\t\t\t\t\\\n \tbuiltin_define (\"__HAVE_68881__\");\t\t\t\t\\\n-      if (TARGET_CPU32)\t\t\t\t\t\t\t\\\n+      if (TUNE_CPU32)\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  builtin_define_std (\"mc68332\");\t\t\t\t\\\n \t  builtin_define_std (\"mcpu32\");\t\t\t\t\\\n@@ -113,7 +113,7 @@ Boston, MA 02110-1301, USA.  */\n \n /* Compile for a CPU32.  A 68020 without bitfields is a good\n    heuristic for a CPU32.  */\n-#define TARGET_CPU32\t(TARGET_68020 && !TARGET_BITFIELD)\n+#define TUNE_CPU32\t(TARGET_68020 && !TARGET_BITFIELD)\n \n /* Is the target a ColdFire?  */\n #define MASK_COLDFIRE \\\n@@ -126,6 +126,11 @@ Boston, MA 02110-1301, USA.  */\n /* Size (in bytes) of FPU registers.  */\n #define TARGET_FP_REG_SIZE\t(TARGET_COLDFIRE ? 8 : 12)\n \n+#define TUNE_68000_10\t(!TARGET_68020 && !TARGET_COLDFIRE)\n+#define TUNE_68030\tTARGET_68030\n+#define TUNE_68040\tTARGET_68040\n+#define TUNE_68060\tTARGET_68060\n+#define TUNE_CFV2\tTARGET_5200\n \n #define OVERRIDE_OPTIONS   override_options()\n "}, {"sha": "92fd31c38a4e2cd9d4125982258d9ad482e02186", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 73, "deletions": 72, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=fe95f2f79935846508510da61613c58b00b3ec75", "patch": "@@ -82,7 +82,7 @@\n ;;- be emulated in software by the OS.  It is faster to avoid these\n ;;- instructions and issue a library call rather than trapping into\n ;;- the kernel.  The affected instructions are fintrz and fscale.  The\n-;;- TARGET_68040 flag turns the use of the opcodes off.\n+;;- TUNE_68040 flag turns the use of the opcodes off.\n \n ;;- The '040 also implements a set of new floating-point instructions\n ;;- which specify the rounding precision in the opcode.  This finally\n@@ -104,7 +104,7 @@\n ;;- instructions and issue a library call rather than trapping into\n ;;- the kernel.  The affected instructions are: divs.l <ea>,Dr:Dq;\n ;;- divu.l <ea>,Dr:Dq; muls.l <ea>,Dr:Dq; mulu.l <ea>,Dr:Dq; and\n-;;- fscale.  The TARGET_68060 flag turns the use of the opcodes off.\n+;;- fscale.  The TUNE_68060 flag turns the use of the opcodes off.\n \n ;;- Some of these insn's are composites of several m68000 op codes.\n ;;- The assembler (or final @@??) insures that the appropriate one is\n@@ -618,13 +618,13 @@\n   if (ADDRESS_REG_P (operands[0]))\n     {\n       /* On the '040, 'subl an,an' takes 2 clocks while lea takes only 1 */\n-      if (!TARGET_68040 && !TARGET_68060)\n+      if (!TUNE_68040 && !TUNE_68060)\n \treturn \"sub%.l %0,%0\";\n       else\n \treturn MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n     }\n   /* moveq is faster on the 68000.  */\n-  if (DATA_REG_P (operands[0]) && (!TARGET_68020 && !TARGET_COLDFIRE))\n+  if (DATA_REG_P (operands[0]) && TUNE_68000_10)\n     return \"moveq #0,%0\";\n   return \"clr%.l %0\";\n })\n@@ -846,16 +846,14 @@\n       if (ADDRESS_REG_P (operands[0]))\n \t{\n \t  /* On the '040, 'subl an,an' takes 2 clocks while lea takes only 1 */\n-\t  if (!TARGET_68040 && !TARGET_68060)\n+\t  if (!TUNE_68040 && !TUNE_68060)\n \t    return \"sub%.l %0,%0\";\n \t  else\n \t    return MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n \t}\n       /* moveq is faster on the 68000.  */\n-      if (DATA_REG_P (operands[0]) && !(TARGET_68020 || TARGET_COLDFIRE))\n-\t{\n-\t  return \"moveq #0,%0\";\n-\t}\n+      if (DATA_REG_P (operands[0]) && TUNE_68000_10)\n+\treturn \"moveq #0,%0\";\n       return \"clr%.l %0\";\n     }\n   return \"move%.l %1,%0\";\n@@ -1760,7 +1758,7 @@\n \t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n    (clobber (match_scratch:SI 2 \"=d\"))\n    (clobber (match_scratch:SI 3 \"=d\"))]\n-  \"TARGET_68881 && TARGET_68040\"\n+  \"TARGET_68881 && TUNE_68040\"\n {\n   CC_STATUS_INIT;\n   return \"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.l %1,%0\\;fmovem%.l %2,%!\";\n@@ -1771,7 +1769,7 @@\n \t(fix:HI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n    (clobber (match_scratch:SI 2 \"=d\"))\n    (clobber (match_scratch:SI 3 \"=d\"))]\n-  \"TARGET_68881 && TARGET_68040\"\n+  \"TARGET_68881 && TUNE_68040\"\n {\n   CC_STATUS_INIT;\n   return \"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.w %1,%0\\;fmovem%.l %2,%!\";\n@@ -1782,7 +1780,7 @@\n \t(fix:QI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n    (clobber (match_scratch:SI 2 \"=d\"))\n    (clobber (match_scratch:SI 3 \"=d\"))]\n-  \"TARGET_68881 && TARGET_68040\"\n+  \"TARGET_68881 && TUNE_68040\"\n {\n   CC_STATUS_INIT;\n   return \"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.b %1,%0\\;fmovem%.l %2,%!\";\n@@ -1794,13 +1792,13 @@\n (define_expand \"ftrunc<mode>2\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n \t(fix:FP (match_operand:FP 1 \"general_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && !TARGET_68040\"\n+  \"TARGET_HARD_FLOAT && !TUNE_68040\"\n   \"\")\n \n (define_insn \"ftrunc<mode>2_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(fix:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m\")))]\n-  \"TARGET_68881 && !TARGET_68040\"\n+  \"TARGET_68881 && !TUNE_68040\"\n {\n   if (FP_REG_P (operands[1]))\n     return \"fintrz%.x %f1,%0\";\n@@ -2130,7 +2128,7 @@\n       /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to a register.  \n \t Likewise for subqw.  */\n-      if (TARGET_CPU32 && REG_P (operands[0]))\n+      if (TUNE_CPU32 && REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[2]) > 8\n \t      && INTVAL (operands[2]) <= 16)\n@@ -2145,7 +2143,7 @@\n \t      return \"subq%.w #8,%0\\;subq%.w %2,%0\";\n \t    }\n \t}\n-      if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n+      if (ADDRESS_REG_P (operands[0]) && !TUNE_68040)\n \treturn MOTOROLA ? \"lea (%c2,%0),%0\" : \"lea %0@(%c2),%0\";\n     }\n   return \"add%.w %2,%0\";\n@@ -2185,7 +2183,7 @@\n       /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to a register. \n \t Likewise for subqw.  */\n-      if (TARGET_CPU32 && REG_P (operands[0]))\n+      if (TUNE_CPU32 && REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[1]) > 8\n \t      && INTVAL (operands[1]) <= 16)\n@@ -2200,7 +2198,7 @@\n \t      return \"subq%.w #8,%0\\;subq%.w %1,%0\";\n \t    }\n \t}\n-      if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n+      if (ADDRESS_REG_P (operands[0]) && !TUNE_68040)\n \treturn MOTOROLA ? \"lea (%c1,%0),%0\" : \"lea %0@(%c1),%0\";\n     }\n   return \"add%.w %1,%0\";\n@@ -2234,7 +2232,7 @@\n       /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to a register.\n \t Likewise for subqw.  */\n-      if (TARGET_CPU32 && REG_P (operands[0])) \n+      if (TUNE_CPU32 && REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[1]) > 8\n \t      && INTVAL (operands[1]) <= 16)\n@@ -2249,7 +2247,7 @@\n \t      return \"subq%.w #8,%0\\;subq%.w %1,%0\";\n \t    }\n \t}\n-      if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n+      if (ADDRESS_REG_P (operands[0]) && !TUNE_68040)\n \treturn MOTOROLA ? \"lea (%c1,%0),%0\" : \"lea %0@(%c1),%0\";\n     }\n   return \"add%.w %1,%0\";\n@@ -2670,7 +2668,7 @@\n \t  (truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n \t\t\t\t\t     (zero_extend:DI (match_dup 2)))\n \t\t\t\t    (const_int 32))))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"\")\n \n (define_insn \"\"\n@@ -2681,7 +2679,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n \t\t\t\t\t   (zero_extend:DI (match_dup 2)))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"mulu%.l %2,%3:%0\")\n \n ; Match immediate case.  For 2.4 only match things < 2^31.\n@@ -2696,7 +2694,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n \t\t\t\t\t   (match_dup 2))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\n    && (unsigned) INTVAL (operands[2]) <= 0x7fffffff\"\n   \"mulu%.l %2,%3:%0\")\n \n@@ -2709,7 +2707,7 @@\n \t  (truncate:SI (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n \t\t\t\t\t     (sign_extend:DI (match_dup 2)))\n \t\t\t\t    (const_int 32))))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"\")\n \n (define_insn \"\"\n@@ -2720,7 +2718,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n \t\t\t\t\t   (sign_extend:DI (match_dup 2)))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %2,%3:%0\")\n \n (define_insn \"\"\n@@ -2731,7 +2729,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n \t\t\t\t\t   (match_dup 2))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %2,%3:%0\")\n \n (define_expand \"umulsi3_highpart\"\n@@ -2743,7 +2741,7 @@\n \t\t     (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"\")))\n \t    (const_int 32))))\n      (clobber (match_dup 3))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n {\n   operands[3] = gen_reg_rtx (SImode);\n \n@@ -2767,7 +2765,7 @@\n \t\t   (zero_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"dm\")))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"mulu%.l %3,%0:%1\")\n \n (define_insn \"const_umulsi3_highpart\"\n@@ -2778,7 +2776,7 @@\n \t\t   (match_operand:DI 3 \"const_uint32_operand\" \"n\"))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"mulu%.l %3,%0:%1\")\n \n (define_expand \"smulsi3_highpart\"\n@@ -2790,7 +2788,7 @@\n \t\t     (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"\")))\n \t    (const_int 32))))\n      (clobber (match_dup 3))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n {\n   operands[3] = gen_reg_rtx (SImode);\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -2810,7 +2808,7 @@\n \t\t   (sign_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"dm\")))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %3,%0:%1\")\n \n (define_insn \"const_smulsi3_highpart\"\n@@ -2821,7 +2819,7 @@\n \t\t   (match_operand:DI 3 \"const_sint32_operand\" \"n\"))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n+  \"TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %3,%0:%1\")\n \n (define_expand \"mul<mode>3\"\n@@ -2871,7 +2869,7 @@\n   \"TARGET_68881\"\n {\n   if (GET_CODE (operands[2]) == CONST_DOUBLE\n-      && floating_exact_log2 (operands[2]) && !TARGET_68040 && !TARGET_68060)\n+      && floating_exact_log2 (operands[2]) && !TUNE_68040 && !TUNE_68060)\n     {\n       int i = floating_exact_log2 (operands[2]);\n       operands[2] = GEN_INT (i);\n@@ -4174,7 +4172,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (const_int 16)))]\n-  \"!TARGET_68060\"\n+  \"!TUNE_68060\"\n {\n   CC_STATUS_INIT;\n   return \"swap %0\\;clr%.w %0\";\n@@ -4189,8 +4187,9 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(! TARGET_68020 && !TARGET_COLDFIRE\n-    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n+  \"TUNE_68000_10\n+   && INTVAL (operands[2]) > 16\n+   && INTVAL (operands[2]) <= 24\"\n {\n   CC_STATUS_INIT;\n \n@@ -4246,7 +4245,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (const_int 16)))]\n-  \"!TARGET_68060\"\n+  \"!TUNE_68060\"\n   \"swap %0\\;ext%.l %0\")\n \n ;; On the 68000, this makes faster code in a special case.\n@@ -4255,8 +4254,9 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(! TARGET_68020 && !TARGET_COLDFIRE\n-    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n+  \"TUNE_68000_10\n+   && INTVAL (operands[2]) > 16\n+   && INTVAL (operands[2]) <= 24\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) - 16);\n   return \"swap %0\\;asr%.w %2,%0\\;ext%.l %0\";\n@@ -4548,7 +4548,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (const_int 16)))]\n-  \"!TARGET_68060\"\n+  \"!TUNE_68060\"\n {\n   CC_STATUS_INIT;\n   return \"clr%.w %0\\;swap %0\";\n@@ -4560,8 +4560,9 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(! TARGET_68020 && !TARGET_COLDFIRE\n-    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n+  \"TUNE_68000_10\n+   && INTVAL (operands[2]) > 16\n+   && INTVAL (operands[2]) <= 24\"\n {\n   /* I think lsr%.w sets the CC properly.  */\n   operands[2] = GEN_INT (INTVAL (operands[2]) - 16);\n@@ -5201,7 +5202,7 @@\n \t(eq:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n       && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n@@ -5223,7 +5224,7 @@\n \t(ne:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n       && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n@@ -5245,7 +5246,7 @@\n \t(gt:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n       && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n@@ -5282,7 +5283,7 @@\n \t(lt:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n       && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n@@ -5319,7 +5320,7 @@\n \t(ge:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n       && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n@@ -5356,7 +5357,7 @@\n \t(le:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n       && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n@@ -5391,7 +5392,7 @@\n (define_expand \"sordered\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ordered:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5400,7 +5401,7 @@\n (define_insn \"*sordered_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ordered:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsor %0\";\n@@ -5409,7 +5410,7 @@\n (define_expand \"sunordered\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(unordered:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5418,7 +5419,7 @@\n (define_insn \"*sunordered_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unordered:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsun %0\";\n@@ -5427,7 +5428,7 @@\n (define_expand \"suneq\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(uneq:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5436,7 +5437,7 @@\n (define_insn \"*suneq_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(uneq:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsueq %0\";\n@@ -5445,7 +5446,7 @@\n (define_expand \"sunge\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(unge:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5454,7 +5455,7 @@\n (define_insn \"*sunge_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unge:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsuge %0\";\n@@ -5463,7 +5464,7 @@\n (define_expand \"sungt\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ungt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5472,7 +5473,7 @@\n (define_insn \"*sungt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ungt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsugt %0\";\n@@ -5481,7 +5482,7 @@\n (define_expand \"sunle\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(unle:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5490,7 +5491,7 @@\n (define_insn \"*sunle_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unle:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsule %0\";\n@@ -5499,7 +5500,7 @@\n (define_expand \"sunlt\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(unlt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5508,7 +5509,7 @@\n (define_insn \"*sunlt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unlt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsult %0\";\n@@ -5517,7 +5518,7 @@\n (define_expand \"sltgt\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ltgt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   gcc_assert (m68k_last_compare_had_fp_operands);\n   m68k_last_compare_had_fp_operands = 0;\n@@ -5526,7 +5527,7 @@\n (define_insn \"*sltgt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ltgt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsogl %0\";\n@@ -5535,7 +5536,7 @@\n (define_insn \"*fsogt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(not:QI (unle:QI (cc0) (const_int 0))))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsogt %0\";\n@@ -5544,7 +5545,7 @@\n (define_insn \"*fsoge_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(not:QI (unlt:QI (cc0) (const_int 0))))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsoge %0\";\n@@ -5553,7 +5554,7 @@\n (define_insn \"*fsolt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(not:QI (unge:QI (cc0) (const_int 0))))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsolt %0\";\n@@ -5562,7 +5563,7 @@\n (define_insn \"*fsole_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(not:QI (ungt:QI (cc0) (const_int 0))))]\n-  \"TARGET_68881 && !TARGET_68060\"\n+  \"TARGET_68881 && !TUNE_68060\"\n {\n   cc_status = cc_prev_status;\n   return \"fsole %0\";\n@@ -6625,14 +6626,14 @@\n \t  else\n \t    output_asm_insn (\"addq%.l %1,%0\", xoperands);\n \t}\n-      else if (TARGET_CPU32 && INTVAL (xoperands[1]) <= 16) \n+      else if (TUNE_CPU32 && INTVAL (xoperands[1]) <= 16)\n \t{\n \t  xoperands[1] = GEN_INT (INTVAL (xoperands[1]) - 8);\n \t  output_asm_insn (\"addq%.w #8,%0\\;addq%.w %1,%0\", xoperands);\n \t}\n       else if (INTVAL (xoperands[1]) <= 0x7FFF)\n         {\n-\t  if (TARGET_68040)\n+\t  if (TUNE_68040)\n \t    output_asm_insn (\"add%.w %1,%0\", xoperands);\n \t  else if (MOTOROLA)\n \t    output_asm_insn (\"lea (%c1,%0),%0\", xoperands);\n@@ -6669,14 +6670,14 @@\n \t  else\n \t    output_asm_insn (\"addq%.l %1,%0\", xoperands);\n \t}\n-      else if (TARGET_CPU32 && INTVAL (xoperands[1]) <= 16)\n+      else if (TUNE_CPU32 && INTVAL (xoperands[1]) <= 16)\n \t{\n \t  xoperands[1] = GEN_INT (INTVAL (xoperands[1]) - 8);\n \t  output_asm_insn (\"addq%.w #8,%0\\;addq%.w %1,%0\", xoperands);\n \t}\n       else if (INTVAL (xoperands[1]) <= 0x7FFF)\n         {\n-\t  if (TARGET_68040)\n+\t  if (TUNE_68040)\n \t    output_asm_insn (\"add%.w %1,%0\", xoperands);\n \t  else if (MOTOROLA)\n \t    output_asm_insn (\"lea (%c1,%0),%0\", xoperands);"}, {"sha": "c2fb111b108faa2eaef74208ddb1472f5b9c7990", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe95f2f79935846508510da61613c58b00b3ec75/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=fe95f2f79935846508510da61613c58b00b3ec75", "patch": "@@ -41,9 +41,7 @@ Boston, MA 02110-1301, USA.  */\n \n /* Don't try using XFmode on the 68010.  */ \n #undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE\t\t\t\\\n-  ((TARGET_68020 || TARGET_68040 || TARGET_68040_ONLY || \\\n-    TARGET_68060) ? 80 : 64)\n+#define LONG_DOUBLE_TYPE_SIZE (TARGET_68020 ? 80 : 64)\n \n #ifdef __mc68010__\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64"}]}