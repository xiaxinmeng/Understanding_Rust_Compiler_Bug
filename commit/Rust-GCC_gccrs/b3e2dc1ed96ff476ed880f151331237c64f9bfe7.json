{"sha": "b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNlMmRjMWVkOTZmZjQ3NmVkODgwZjE1MTMzMTIzN2M2NGY5YmZlNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-01-02T16:30:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-01-02T16:30:49Z"}, "message": "Add more testcases for class template argument deduction of maps\n\nThis adds additional tests for std::map and std::multimap CTAD. The\ntests ensure that deduction works for braced-init-list of value_type\nobjects, and for pairs of input iterators (with both std::pair<Key, T>\nand value_type as the iterator's value_type). This ensures deduction\nfrom value_type still works, as well as the non-value_type cases in LWG\n3025.\n\nSimilar tests for unordered maps do not work, apparently because the\nconstructor taking an initializer_list<value_type> is not usable for\ndeduction, and the deduction guide taking initializer_list<pair<Key, T>>\ndeduces key_type to be const. I am not addressing that.\n\n\t* testsuite/23_containers/map/cons/deduction.cc: Test deduction from\n\tinitializer_list<value_type> and from input iterator ranges.\n\t* testsuite/23_containers/multimap/cons/deduction.cc: Likewise.\n\nFrom-SVN: r267518", "tree": {"sha": "6455aa0942d23f6e057fb7bb895f20813d87f831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6455aa0942d23f6e057fb7bb895f20813d87f831"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f11aa6aa130b9a8e6be7f6aeea34af9a5badb8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f11aa6aa130b9a8e6be7f6aeea34af9a5badb8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f11aa6aa130b9a8e6be7f6aeea34af9a5badb8a"}], "stats": {"total": 268, "additions": 244, "deletions": 24}, "files": [{"sha": "ba96526848430de1dbd47737cee0c8fa4b00907c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "patch": "@@ -1,5 +1,9 @@\n 2019-01-02  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* testsuite/23_containers/map/cons/deduction.cc: Test deduction from\n+\tinitializer_list<value_type> and from input iterator ranges.\n+\t* testsuite/23_containers/multimap/cons/deduction.cc: Likewise.\n+\n \t* testsuite/experimental/string_view/element_access/char/empty.cc:\n \tFix year range in copyright header.\n "}, {"sha": "f4195257e9c18c93ffb1a754039776a943e965db", "filename": "libstdc++-v3/testsuite/23_containers/map/cons/deduction.cc", "status": "modified", "additions": 121, "deletions": 14, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fcons%2Fdeduction.cc?ref=b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "patch": "@@ -3,32 +3,58 @@\n \n #include <map>\n #include <testsuite_allocator.h>\n+#include <testsuite_iterators.h>\n \n using __gnu_test::SimpleAllocator;\n+using value_type = std::map<int, double>::value_type;\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::map{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}}),\n+\t      std::map<int, double>>);\n \n static_assert(std::is_same_v<\n \t      decltype(std::map{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}),\n \t      std::map<int, double>>);\n \n+static_assert(std::is_same_v<\n+\t      decltype(std::map{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}}}),\n+\t      std::map<int, double>>);\n+\n static_assert(std::is_same_v<\n \t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}}),\n \t      std::map<int, double>>);\n \n static_assert(std::is_same_v<\n-\t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n-\t\t    std::less<int>{}, {}}),\n+\t      decltype(std::map{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}},\n+\t\t\t\tstd::less<int>{}, {}}),\n \t      std::map<int, double>>);\n \n static_assert(std::is_same_v<\n \t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n-\t\t    {}}),\n+\t\t\t\tstd::less<int>{}, {}}),\n+\t      std::map<int, double>>);\n+\n+/* This is not deducible, {} could be deduced as _Compare or _Allocator.\n+static_assert(std::is_same_v<\n+\t      decltype(std::map{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}}, {}}),\n \t      std::map<int, double>>);\n+*/\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}, {}}),\n+\t      std::map<int, double>>);\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::map{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}},\n+\t\t\t\t{}, SimpleAllocator<value_type>{}}),\n+\t      std::map<int, double, std::less<int>,\n+\t\t       SimpleAllocator<value_type>>>);\n \n static_assert(std::is_same_v<\n \t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n-\t\t    {}, SimpleAllocator<std::pair<const int, double>>{}}),\n+\t\t\t\t{}, SimpleAllocator<value_type>{}}),\n \t      std::map<int, double, std::less<int>,\n-\t      SimpleAllocator<std::pair<const int, double>>>>);\n+\t\t       SimpleAllocator<value_type>>>);\n \n void f()\n {\n@@ -39,13 +65,94 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::map{x.begin(), x.end(),\n-\t\t      std::less<int>{},\n-\t\t      std::allocator<std::pair<const int, double>>{}}),\n+\t\t\t\t  std::less<int>{},\n+\t\t\t\t  std::allocator<value_type>{}}),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  std::less<int>{}, {}}),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map(x.begin(), x.end(),\n+\t\t\t\t  {})),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  {},\n+\t\t\t\t  std::allocator<value_type>{}}),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  {},\n+\t\t\t\t  SimpleAllocator<value_type>{}}),\n+\t\tstd::map<int, double, std::less<int>,\n+\t\t\t SimpleAllocator<value_type>>>);\n+}\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+\n+void g()\n+{\n+  value_type array[1];\n+  test_container<value_type, input_iterator_wrapper> x(array);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map(x.begin(), x.end())),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  std::less<int>{},\n+\t\t\t\t  std::allocator<value_type>{}}),\n \t\tstd::map<int, double>>);\n-  \n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  std::less<int>{}, {}}),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map(x.begin(), x.end(),\n+\t\t\t\t  {})),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  {},\n+\t\t\t\t  std::allocator<value_type>{}}),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  {},\n+\t\t\t\t  SimpleAllocator<value_type>{}}),\n+\t\tstd::map<int, double, std::less<int>,\n+\t\t\t SimpleAllocator<value_type>>>);\n+}\n+\n+void h()\n+{\n+  std::pair<int, double> array[1];\n+  test_container<std::pair<int, double>, input_iterator_wrapper> x(array);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map(x.begin(), x.end())),\n+\t\tstd::map<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::map{x.begin(), x.end(),\n+\t\t\t\t  std::less<int>{},\n+\t\t\t\t  std::allocator<value_type>{}}),\n+\t\tstd::map<int, double>>);\n+\n   static_assert(std::is_same_v<\n \t\tdecltype(std::map{x.begin(), x.end(),\n-\t\t      std::less<int>{}, {}}),\n+\t\t\t\t  std::less<int>{}, {}}),\n \t\tstd::map<int, double>>);\n \n   static_assert(std::is_same_v<\n@@ -55,14 +162,14 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::map{x.begin(), x.end(),\n-\t\t      {},\n-\t\t      std::allocator<std::pair<const int, double>>{}}),\n+\t\t\t\t  {},\n+\t\t\t\t  std::allocator<value_type>{}}),\n \t\tstd::map<int, double>>);\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::map{x.begin(), x.end(),\n-\t\t      {},\n-\t\t      SimpleAllocator<std::pair<const int, double>>{}}),\n+\t\t\t\t  {},\n+\t\t\t\t  SimpleAllocator<value_type>{}}),\n \t\tstd::map<int, double, std::less<int>,\n-\t\tSimpleAllocator<std::pair<const int, double>>>>);\n+\t\t\t SimpleAllocator<value_type>>>);\n }"}, {"sha": "2f9373a5befd092a076a814484dc6ce3538a0258", "filename": "libstdc++-v3/testsuite/23_containers/multimap/cons/deduction.cc", "status": "modified", "additions": 119, "deletions": 10, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3e2dc1ed96ff476ed880f151331237c64f9bfe7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fcons%2Fdeduction.cc?ref=b3e2dc1ed96ff476ed880f151331237c64f9bfe7", "patch": "@@ -3,32 +3,60 @@\n \n #include <map>\n #include <testsuite_allocator.h>\n+#include <testsuite_iterators.h>\n \n using __gnu_test::SimpleAllocator;\n+using value_type = std::multimap<int, double>::value_type;\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::multimap{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}}),\n+\t      std::multimap<int, double>>);\n \n static_assert(std::is_same_v<\n \t      decltype(std::multimap{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}),\n \t      std::multimap<int, double>>);\n \n+static_assert(std::is_same_v<\n+\t      decltype(std::multimap{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}}}),\n+\t      std::multimap<int, double>>);\n+\n static_assert(std::is_same_v<\n \t      decltype(std::multimap{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}}),\n \t      std::multimap<int, double>>);\n \n+static_assert(std::is_same_v<\n+\t      decltype(std::multimap{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}},\n+\t\t\t\tstd::less<int>{}, {}}),\n+\t      std::multimap<int, double>>);\n+\n static_assert(std::is_same_v<\n \t      decltype(std::multimap{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n \t\t    std::less<int>{}, {}}),\n \t      std::multimap<int, double>>);\n \n+/* This is not deducible, {} could be deduced as _Compare or _Allocator.\n+static_assert(std::is_same_v<\n+\t      decltype(std::multimap{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}},\n+\t\t\t\t     {}}),\n+\t      std::multimap<int, double>>);\n+*/\n+\n static_assert(std::is_same_v<\n \t      decltype(std::multimap{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n \t\t    {}}),\n \t      std::multimap<int, double>>);\n \n+static_assert(std::is_same_v<\n+\t      decltype(std::multimap{{value_type{1, 2.0}, {2, 3.0}, {3, 4.0}},\n+\t\t\t\t     {}, SimpleAllocator<value_type>{}}),\n+\t      std::multimap<int, double, std::less<int>,\n+\t\t       SimpleAllocator<value_type>>>);\n+\n static_assert(std::is_same_v<\n \t      decltype(std::multimap{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n-\t\t    {}, SimpleAllocator<std::pair<const int, double>>{}}),\n+\t\t\t\t     {}, SimpleAllocator<value_type>{}}),\n \t      std::multimap<int, double, std::less<int>,\n-\t      SimpleAllocator<std::pair<const int, double>>>>);\n+\t\t\t    SimpleAllocator<value_type>>>);\n \n void f()\n {\n@@ -39,30 +67,111 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap{x.begin(), x.end(),\n-\t\t      std::less<int>{},\n-\t\t      std::allocator<std::pair<const int, double>>{}}),\n+\t\t\t\t       std::less<int>{},\n+\t\t\t\t       std::allocator<value_type>{}}),\n \t\tstd::multimap<int, double>>);\n   \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap{x.begin(), x.end(),\n-\t\t      std::less<int>{}, {}}),\n+\t\t\t\t       std::less<int>{}, {}}),\n \t\tstd::multimap<int, double>>);\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t       {})),\n \t\tstd::multimap<int, double>>);\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap{x.begin(), x.end(),\n \t\t      {},\n-\t\t      std::allocator<std::pair<const int, double>>{}}),\n+\t\t      std::allocator<value_type>{}}),\n \t\tstd::multimap<int, double>>);\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap{x.begin(), x.end(),\n-\t\t      {},\n-\t\t      SimpleAllocator<std::pair<const int, double>>{}}),\n+\t\t\t\t       {},\n+\t\t\t\t       SimpleAllocator<value_type>{}}),\n+\t\tstd::multimap<int, double, std::less<int>,\n+\t\t\t      SimpleAllocator<value_type>>>);\n+}\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+\n+void g()\n+{\n+  value_type array[1];\n+  test_container<value_type, input_iterator_wrapper> x(array);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap(x.begin(), x.end())),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       std::less<int>{},\n+\t\t\t\t       std::allocator<value_type>{}}),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       std::less<int>{}, {}}),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap(x.begin(), x.end(),\n+\t\t\t\t       {})),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       {},\n+\t\t\t\t       std::allocator<value_type>{}}),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       {},\n+\t\t\t\t       SimpleAllocator<value_type>{}}),\n+\t\tstd::multimap<int, double, std::less<int>,\n+\t\t\t SimpleAllocator<value_type>>>);\n+}\n+\n+void h()\n+{\n+  std::pair<int, double> array[1];\n+  test_container<std::pair<int, double>, input_iterator_wrapper> x(array);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap(x.begin(), x.end())),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       std::less<int>{},\n+\t\t\t\t       std::allocator<value_type>{}}),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       std::less<int>{}, {}}),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap(x.begin(), x.end(),\n+\t\t\t\t       {})),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       {},\n+\t\t\t\t       std::allocator<value_type>{}}),\n+\t\tstd::multimap<int, double>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::multimap{x.begin(), x.end(),\n+\t\t\t\t       {},\n+\t\t\t\t       SimpleAllocator<value_type>{}}),\n \t\tstd::multimap<int, double, std::less<int>,\n-\t\tSimpleAllocator<std::pair<const int, double>>>>);\n+\t\t\t      SimpleAllocator<value_type>>>);\n }"}]}