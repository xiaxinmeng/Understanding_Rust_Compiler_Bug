{"sha": "5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQzODA1ZmNhM2U5YTE5OWZiYWExOGFlZTNjMDVlY2IzMGViY2E2MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-10-19T11:23:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-10-19T11:23:59Z"}, "message": "ubsan.c (ubsan_expand_null_ifn): Use _v1 suffixed type mismatch builtins...\n\n\t* ubsan.c (ubsan_expand_null_ifn): Use _v1 suffixed type mismatch\n\tbuiltins, store max (log2 (align), 0) into uchar field instead of\n\talign into uptr field.\n\t(ubsan_expand_objsize_ifn): Use _v1 suffixed type mismatch builtins,\n\tstore uchar 0 field instead of uptr 0 field.\n\t(instrument_nonnull_return): Use _v1 suffixed nonnull return builtin,\n\tinstead of passing one address of struct with 2 locations pass\n\ttwo addresses of structs with 1 location each.\n\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH,\n\tBUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT,\n\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN,\n\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_ABORT): Removed.\n\t(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1,\n\tBUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1_ABORT,\n\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1,\n\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1_ABORT): New builtins.\n\n\t* c-c++-common/ubsan/float-cast-overflow-1.c: Drop value keyword\n\tfrom expected output regexps.\n\t* c-c++-common/ubsan/float-cast-overflow-2.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-3.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-4.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-5.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-6.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-8.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-9.c: Likewise.\n\t* c-c++-common/ubsan/float-cast-overflow-10.c: Likewise.\n\t* g++.dg/ubsan/float-cast-overflow-bf.C: Likewise.\n\t* gcc.dg/ubsan/float-cast-overflow-bf.c: Likewise.\n\t* g++.dg/asan/default-options-1.C (__asan_default_options): Add\n\tused attribute.\n\t* g++.dg/asan/asan_test.C: Run with ASAN_OPTIONS=handle_segv=2\n\tin the environment.\n\n\t* All source files: Merge from upstream 315899.\n        * asan/Makefile.am (nodist_saninclude_HEADERS): Add\n\tinclude/sanitizer/tsan_interface.h.\n        * asan/libtool-version: Bump the libasan SONAME.\n\t* lsan/Makefile.am (sanitizer_lsan_files): Add lsan_common_mac.cc.\n\t(lsan_files): Add lsan_linux.cc, lsan_mac.cc and lsan_malloc_mac.cc.\n        * sanitizer_common/Makefile.am (sanitizer_common_files): Add\n\tsancov_flags.cc, sanitizer_allocator_checks.cc,\n\tsanitizer_coverage_libcdep_new.cc, sanitizer_errno.cc,\n\tsanitizer_file.cc, sanitizer_mac_libcdep.cc and\n\tsanitizer_stoptheworld_mac.cc.  Remove sanitizer_coverage_libcdep.cc\n\tand sanitizer_coverage_mapping_libcdep.cc.\n        * tsan/Makefile.am (tsan_files): Add tsan_external.cc.\n\t* ubsan/Makefile.am (DEFS): Add -DUBSAN_CAN_USE_CXXABI=1.\n\t(ubsan_files): Add ubsan_init_standalone.cc and\n\tubsan_signals_standalone.cc.\n\t* ubsan/libtool-version: Bump the libubsan SONAME.\n        * asan/Makefile.in: Regenerate.\n        * lsan/Makefile.in: Regenerate.\n        * sanitizer_common/Makefile.in: Regenerate.\n        * tsan/Makefile.in: Regenerate.\n\t* ubsan/Makefile.in: Regenerate.\n\nFrom-SVN: r253887", "tree": {"sha": "22f091462fe7932142888d43abb6ff39f610e7f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22f091462fe7932142888d43abb6ff39f610e7f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93659712d9807d7ef01d472dc58119f4ac15cbad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93659712d9807d7ef01d472dc58119f4ac15cbad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93659712d9807d7ef01d472dc58119f4ac15cbad"}], "stats": {"total": 20772, "additions": 14651, "deletions": 6121}, "files": [{"sha": "2af78595b206f9c4f958d9d4766332d5387f539d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -1,3 +1,22 @@\n+2017-10-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* ubsan.c (ubsan_expand_null_ifn): Use _v1 suffixed type mismatch\n+\tbuiltins, store max (log2 (align), 0) into uchar field instead of\n+\talign into uptr field.\n+\t(ubsan_expand_objsize_ifn): Use _v1 suffixed type mismatch builtins,\n+\tstore uchar 0 field instead of uptr 0 field.\n+\t(instrument_nonnull_return): Use _v1 suffixed nonnull return builtin,\n+\tinstead of passing one address of struct with 2 locations pass\n+\ttwo addresses of structs with 1 location each.\n+\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH,\n+\tBUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT,\n+\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN,\n+\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_ABORT): Removed.\n+\t(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1,\n+\tBUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1_ABORT,\n+\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1,\n+\tBUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1_ABORT): New builtins.\n+\n 2017-10-19  Martin Liska  <mliska@suse.cz>\n \n \tPR driver/81829"}, {"sha": "27eb20c9b280678cc7259fda0ae5526a63c4ca7c", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -424,8 +424,8 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_VLA_BOUND_NOT_POSITIVE,\n \t\t      \"__ubsan_handle_vla_bound_not_positive\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n-DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH,\n-\t\t      \"__ubsan_handle_type_mismatch\",\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1,\n+\t\t      \"__ubsan_handle_type_mismatch_v1\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_ADD_OVERFLOW,\n@@ -464,8 +464,8 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_VLA_BOUND_NOT_POSITIVE_ABORT,\n \t\t      \"__ubsan_handle_vla_bound_not_positive_abort\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n-DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT,\n-\t\t      \"__ubsan_handle_type_mismatch_abort\",\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1_ABORT,\n+\t\t      \"__ubsan_handle_type_mismatch_v1_abort\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_ADD_OVERFLOW_ABORT,\n@@ -516,13 +516,13 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NONNULL_ARG_ABORT,\n \t\t      \"__ubsan_handle_nonnull_arg_abort\",\n \t\t      BT_FN_VOID_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n-DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN,\n-\t\t      \"__ubsan_handle_nonnull_return\",\n-\t\t      BT_FN_VOID_PTR,\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1,\n+\t\t      \"__ubsan_handle_nonnull_return_v1\",\n+\t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n-DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_ABORT,\n-\t\t      \"__ubsan_handle_nonnull_return_abort\",\n-\t\t      BT_FN_VOID_PTR,\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1_ABORT,\n+\t\t      \"__ubsan_handle_nonnull_return_v1_abort\",\n+\t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS,\n \t\t      \"__ubsan_handle_dynamic_type_cache_miss\","}, {"sha": "43d32c4afad33eebda4577b9cb3955983f59cc29", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -1,5 +1,22 @@\n 2017-10-19  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/ubsan/float-cast-overflow-1.c: Drop value keyword\n+\tfrom expected output regexps.\n+\t* c-c++-common/ubsan/float-cast-overflow-2.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-3.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-4.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-5.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-6.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-8.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-9.c: Likewise.\n+\t* c-c++-common/ubsan/float-cast-overflow-10.c: Likewise.\n+\t* g++.dg/ubsan/float-cast-overflow-bf.C: Likewise.\n+\t* gcc.dg/ubsan/float-cast-overflow-bf.c: Likewise.\n+\t* g++.dg/asan/default-options-1.C (__asan_default_options): Add\n+\tused attribute.\n+\t* g++.dg/asan/asan_test.C: Run with ASAN_OPTIONS=handle_segv=2\n+\tin the environment.\n+\n \tPR target/82580\n \t* gcc.target/i386/pr82580.c: Use {\\msbb} instead of \"sbb\" in\n \tscan-assembler-times.  Check that there are no movzb* instructions"}, {"sha": "8139cc1723fbc6050579fec772883ca747b1e501", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-1.c", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-1.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -91,115 +91,115 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value -133 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -129.5 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 128 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 128.5 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 132 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 256 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 256.5 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 260 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32773 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32769.5 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 32768 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 32768.5 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 32772 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 65536 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 65536.5 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 65540 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type 'long long unsigned int'\" } */\n+/* { dg-output \" -133 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -129.5 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 128 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 128.5 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 132 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 256 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 256.5 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 260 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32773 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32769.5 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 32768 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 32768.5 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 32772 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 65536 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 65536.5 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 65540 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 9.22337e\\\\\\+18 is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.84467e\\\\\\+19 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type 'long long unsigned int'\" } */"}, {"sha": "a4e8ec457b53ef3ac8acb431ecce2d02e1b522cc", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-10.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-10.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -9,38 +9,38 @@\n #include \"float-cast-overflow-8.c\"\n \n /* _Decimal32 */\n-/* { dg-output \"value <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \" <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* _Decimal64 */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* _Decimal128 */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "426c625fc6b5841cd27525294e076705e9514718", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-2.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-2.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -30,44 +30,44 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value nan is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -?nan is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value inf is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -inf is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -5 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -1.5 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value nan is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -?nan is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value inf is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*runtime error: value -inf is outside the range of representable values of type '__int128 unsigned'\" } */\n+/* { dg-output \"runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 1.70141e\\\\\\+38 is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: nan is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -?nan is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: inf is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -inf is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: 3.40282e\\\\\\+38 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -5 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -1.5 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: nan is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -?nan is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: inf is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*runtime error: -inf is outside the range of representable values of type '__int128 unsigned'\" } */"}, {"sha": "6567ca9a4442c72c5776e4060f891581f6317191", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-3.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-3.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -26,15 +26,15 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value -133* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -129.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -129 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 128 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 128.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 132 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 256 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 256.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 260 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\" } */\n+/* { dg-output \" -133* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -129.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -129 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 128 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 128.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 132 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 256 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 256.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 260 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\" } */"}, {"sha": "48ad257c641005fd3be0de223234e264ac2d0ecd", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-4.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-4.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -30,23 +30,23 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -?nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value inf is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -inf is outside the range of representable values of type\" } */\n+/* { dg-output \" -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -?nan is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* inf is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -inf is outside the range of representable values of type\" } */"}, {"sha": "25a94950970fe81a09c4b1554c05a4514a1ef3a4", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-5.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-5.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -26,15 +26,15 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[^\\n\\r]* is outside the range of representable values of type\" } */\n+/* { dg-output \" \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[^\\n\\r]* is outside the range of representable values of type\" } */"}, {"sha": "90ec26838f8fc1915783c6553b04ac4f7d498b35", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-6.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-6.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -26,15 +26,15 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value -133 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -129.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -129 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 128 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 128.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 132 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 256 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 256.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 260 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\" } */\n+/* { dg-output \" -133 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -129.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -129 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 128 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 128.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 132 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 256 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 256.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 260 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\" } */"}, {"sha": "4e7beeb08db36135c21981a9560a5366cc27233b", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-8.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-8.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -99,45 +99,45 @@ main ()\n }\n \n /* float */\n-/* { dg-output \"value -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n+/* { dg-output \" -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n /* No error for float and __int128 unsigned max value, as ui128_MAX is +Inf in float.  */\n /* double */\n-/* { dg-output \"\\[^\\n\\r]*value -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n /* long double */\n-/* { dg-output \"\\[^\\n\\r]*value -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { ilp32 || lp64 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target { int128 } } } */"}, {"sha": "ca9b425d23ee0d06d3fc11359847c04cbc86dedc", "filename": "gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-9.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Ffloat-cast-overflow-9.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -6,30 +6,30 @@\n #include \"float-cast-overflow-8.c\"\n \n /* __float80 */\n-/* { dg-output \"value -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n+/* { dg-output \" -129 is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* (-129|-1) is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -32769 is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* \\[0-9.e+-]* is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n /* __float128 */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n-/* { dg-output \"\\[^\\n\\r]*value <unknown> is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'short unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type 'long long unsigned int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type '__int128'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */\n+/* { dg-output \"\\[^\\n\\r]* <unknown> is outside the range of representable values of type '__int128 unsigned'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target int128 } } */"}, {"sha": "f3f7626ef3be8f8796fdad37535c1729fc5c1e68", "filename": "gcc/testsuite/g++.dg/asan/asan_test.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -8,6 +8,7 @@\n // { dg-additional-options \"-DASAN_AVOID_EXPENSIVE_TESTS=1\" { target { ! run_expensive_tests } } }\n // { dg-additional-options \"-msse2\" { target { i?86-*-linux* x86_64-*-linux* } } }\n // { dg-additional-options \"-D__NO_INLINE__\" { target { *-*-linux-gnu } } }\n+// { dg-set-target-env-var ASAN_OPTIONS \"handle_segv=2\" }\n // { dg-final { asan-gtest } }\n \n #include \"asan_test.cc\""}, {"sha": "98abdfbd3ff17829ee11498ab7cf356f228183c6", "filename": "gcc/testsuite/g++.dg/asan/default-options-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdefault-options-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdefault-options-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fdefault-options-1.C?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -3,7 +3,7 @@\n const char *kAsanDefaultOptions=\"verbosity=1 foo=bar\";\n \n extern \"C\"\n-__attribute__((no_sanitize_address))\n+__attribute__((no_sanitize_address, used))\n const char *__asan_default_options() {\n   return kAsanDefaultOptions;\n }"}, {"sha": "385a109c359e86ddcf7b55c72d34910990347ef8", "filename": "gcc/testsuite/g++.dg/ubsan/float-cast-overflow-bf.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Ffloat-cast-overflow-bf.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Ffloat-cast-overflow-bf.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Ffloat-cast-overflow-bf.C?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -52,11 +52,11 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\" } */\n+/* { dg-output \" -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.14748e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 4.29497e\\\\\\+09 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\" } */"}, {"sha": "538d900b0ab99493d319134127bca94d86e20584", "filename": "gcc/testsuite/gcc.dg/ubsan/float-cast-overflow-bf.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Ffloat-cast-overflow-bf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Ffloat-cast-overflow-bf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Ffloat-cast-overflow-bf.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -48,25 +48,25 @@ main (void)\n   return 0;\n }\n \n-/* { dg-output \"value -2.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*value 2.5 is outside the range of representable values of type\" } */\n+/* { dg-output \" -2.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1.5 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* -1 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2 is outside the range of representable values of type\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]* 2.5 is outside the range of representable values of type\" } */"}, {"sha": "0a0b4dd0b7613fe89ac6ea060f9d3e8ab8f7f205", "filename": "gcc/ubsan.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -830,15 +830,17 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n       enum built_in_function bcode\n \t= (flag_sanitize_recover & ((check_align ? SANITIZE_ALIGNMENT : 0)\n \t\t\t\t    | (check_null ? SANITIZE_NULL : 0)))\n-\t  ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH\n-\t  : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n+\t  ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1\n+\t  : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1_ABORT;\n       tree fn = builtin_decl_implicit (bcode);\n+      int align_log = tree_log2 (align);\n       tree data\n \t= ubsan_create_data (\"__ubsan_null_data\", 1, &loc,\n \t\t\t     ubsan_type_descriptor (TREE_TYPE (ckind),\n \t\t\t\t\t\t    UBSAN_PRINT_POINTER),\n \t\t\t     NULL_TREE,\n-\t\t\t     align,\n+\t\t\t     build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t    MAX (align_log, 0)),\n \t\t\t     fold_convert (unsigned_char_type_node, ckind),\n \t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n@@ -1001,14 +1003,14 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n \t\t\t\t ubsan_type_descriptor (TREE_TYPE (ptr),\n \t\t\t\t\t\t\tUBSAN_PRINT_POINTER),\n \t\t\t\t NULL_TREE,\n-\t\t\t\t build_zero_cst (pointer_sized_int_node),\n+\t\t\t\t build_zero_cst (unsigned_char_type_node),\n \t\t\t\t ckind,\n \t\t\t\t NULL_TREE);\n \t  data = build_fold_addr_expr_loc (loc, data);\n \t  enum built_in_function bcode\n \t    = (flag_sanitize_recover & SANITIZE_OBJECT_SIZE)\n-\t      ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH\n-\t      : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n+\t      ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1\n+\t      : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1_ABORT;\n \t  tree p = make_ssa_name (pointer_sized_int_node);\n \t  g = gimple_build_assign (p, NOP_EXPR, ptr);\n \t  gimple_set_location (g, loc);\n@@ -2024,15 +2026,18 @@ instrument_nonnull_return (gimple_stmt_iterator *gsi)\n       else\n \t{\n \t  tree data = ubsan_create_data (\"__ubsan_nonnull_return_data\",\n-\t\t\t\t\t 2, loc, NULL_TREE, NULL_TREE);\n+\t\t\t\t\t 1, &loc[1], NULL_TREE, NULL_TREE);\n \t  data = build_fold_addr_expr_loc (loc[0], data);\n+\t  tree data2 = ubsan_create_data (\"__ubsan_nonnull_return_data\",\n+\t\t\t\t\t  1, &loc[0], NULL_TREE, NULL_TREE);\n+\t  data2 = build_fold_addr_expr_loc (loc[0], data2);\n \t  enum built_in_function bcode\n \t    = (flag_sanitize_recover & SANITIZE_RETURNS_NONNULL_ATTRIBUTE)\n-\t      ? BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN\n-\t      : BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_ABORT;\n+\t      ? BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1\n+\t      : BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_V1_ABORT;\n \t  tree fn = builtin_decl_explicit (bcode);\n \n-\t  g = gimple_build_call (fn, 1, data);\n+\t  g = gimple_build_call (fn, 2, data, data2);\n \t}\n       gimple_set_location (g, loc[0]);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);"}, {"sha": "1cd9a1bf32089fd22204992a1965fbe7fb854648", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -1,3 +1,28 @@\n+2017-10-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* All source files: Merge from upstream 315899.\n+        * asan/Makefile.am (nodist_saninclude_HEADERS): Add\n+\tinclude/sanitizer/tsan_interface.h.\n+        * asan/libtool-version: Bump the libasan SONAME.\n+\t* lsan/Makefile.am (sanitizer_lsan_files): Add lsan_common_mac.cc.\n+\t(lsan_files): Add lsan_linux.cc, lsan_mac.cc and lsan_malloc_mac.cc.\n+        * sanitizer_common/Makefile.am (sanitizer_common_files): Add\n+\tsancov_flags.cc, sanitizer_allocator_checks.cc,\n+\tsanitizer_coverage_libcdep_new.cc, sanitizer_errno.cc,\n+\tsanitizer_file.cc, sanitizer_mac_libcdep.cc and\n+\tsanitizer_stoptheworld_mac.cc.  Remove sanitizer_coverage_libcdep.cc\n+\tand sanitizer_coverage_mapping_libcdep.cc.\n+        * tsan/Makefile.am (tsan_files): Add tsan_external.cc.\n+\t* ubsan/Makefile.am (DEFS): Add -DUBSAN_CAN_USE_CXXABI=1.\n+\t(ubsan_files): Add ubsan_init_standalone.cc and\n+\tubsan_signals_standalone.cc.\n+\t* ubsan/libtool-version: Bump the libubsan SONAME.\n+        * asan/Makefile.in: Regenerate.\n+        * lsan/Makefile.in: Regenerate.\n+        * sanitizer_common/Makefile.in: Regenerate.\n+        * tsan/Makefile.in: Regenerate.\n+\t* ubsan/Makefile.in: Regenerate.\n+\n 2017-10-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR sanitizer/82379"}, {"sha": "c92f826445ebad6ff8477fb3c218f0a57aa10584", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -1,4 +1,4 @@\n-285547\n+315899\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "018f0b0682328a37a0f489d21755c2acafdb0198", "filename": "libsanitizer/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.am?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -17,7 +17,8 @@ endif\n SUBDIRS += lsan asan ubsan\n nodist_saninclude_HEADERS += \\\n   include/sanitizer/lsan_interface.h \\\n-  include/sanitizer/asan_interface.h\n+  include/sanitizer/asan_interface.h \\\n+  include/sanitizer/tsan_interface.h\n if TSAN_SUPPORTED\n SUBDIRS += tsan\n endif"}, {"sha": "fd0f7fd78f9ea1e7b26b9599bbfbbeafa3a42d8c", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -54,7 +54,8 @@ host_triplet = @host@\n target_triplet = @target@\n @SANITIZER_SUPPORTED_TRUE@am__append_1 = include/sanitizer/common_interface_defs.h \\\n @SANITIZER_SUPPORTED_TRUE@\tinclude/sanitizer/lsan_interface.h \\\n-@SANITIZER_SUPPORTED_TRUE@\tinclude/sanitizer/asan_interface.h\n+@SANITIZER_SUPPORTED_TRUE@\tinclude/sanitizer/asan_interface.h \\\n+@SANITIZER_SUPPORTED_TRUE@\tinclude/sanitizer/tsan_interface.h\n @SANITIZER_SUPPORTED_TRUE@@USING_MAC_INTERPOSE_FALSE@am__append_2 = interception\n @LIBBACKTRACE_SUPPORTED_TRUE@@SANITIZER_SUPPORTED_TRUE@am__append_3 = libbacktrace\n @SANITIZER_SUPPORTED_TRUE@@TSAN_SUPPORTED_TRUE@am__append_4 = tsan"}, {"sha": "709b6c8d75ba2152da616ea70319bbab94d96cab", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -25,6 +25,7 @@ asan_files = \\\n \tasan_flags.cc \\\n \tasan_globals.cc \\\n \tasan_interceptors.cc \\\n+\tasan_interceptors_memintrinsics.cc \\\n \tasan_linux.cc \\\n \tasan_mac.cc \\\n \tasan_malloc_linux.cc \\\n@@ -36,6 +37,7 @@ asan_files = \\\n \tasan_posix.cc \\\n \tasan_report.cc \\\n \tasan_rtl.cc \\\n+\tasan_shadow_setup.cc \\\n \tasan_stack.cc \\\n \tasan_stats.cc \\\n \tasan_suppressions.cc \\"}, {"sha": "db3c3ced8b904282e673cad304136ef42e9f800c", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -114,12 +114,13 @@ libasan_la_DEPENDENCIES =  \\\n am__objects_1 = asan_activation.lo asan_allocator.lo asan_debugging.lo \\\n \tasan_descriptions.lo asan_errors.lo asan_fake_stack.lo \\\n \tasan_flags.lo asan_globals.lo asan_interceptors.lo \\\n-\tasan_linux.lo asan_mac.lo asan_malloc_linux.lo \\\n-\tasan_malloc_mac.lo asan_malloc_win.lo asan_memory_profile.lo \\\n-\tasan_new_delete.lo asan_poisoning.lo asan_posix.lo \\\n-\tasan_report.lo asan_rtl.lo asan_stack.lo asan_stats.lo \\\n-\tasan_suppressions.lo asan_thread.lo asan_win.lo \\\n-\tasan_win_dll_thunk.lo asan_win_dynamic_runtime_thunk.lo\n+\tasan_interceptors_memintrinsics.lo asan_linux.lo asan_mac.lo \\\n+\tasan_malloc_linux.lo asan_malloc_mac.lo asan_malloc_win.lo \\\n+\tasan_memory_profile.lo asan_new_delete.lo asan_poisoning.lo \\\n+\tasan_posix.lo asan_report.lo asan_rtl.lo asan_shadow_setup.lo \\\n+\tasan_stack.lo asan_stats.lo asan_suppressions.lo \\\n+\tasan_thread.lo asan_win.lo asan_win_dll_thunk.lo \\\n+\tasan_win_dynamic_runtime_thunk.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -317,6 +318,7 @@ asan_files = \\\n \tasan_flags.cc \\\n \tasan_globals.cc \\\n \tasan_interceptors.cc \\\n+\tasan_interceptors_memintrinsics.cc \\\n \tasan_linux.cc \\\n \tasan_mac.cc \\\n \tasan_malloc_linux.cc \\\n@@ -328,6 +330,7 @@ asan_files = \\\n \tasan_posix.cc \\\n \tasan_report.cc \\\n \tasan_rtl.cc \\\n+\tasan_shadow_setup.cc \\\n \tasan_stack.cc \\\n \tasan_stats.cc \\\n \tasan_suppressions.cc \\\n@@ -466,6 +469,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors_memintrinsics.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_linux.Plo@am__quote@\n@@ -477,6 +481,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_report.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_shadow_setup.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_suppressions.Plo@am__quote@"}, {"sha": "599e56b9e3f2888f48cb9f594398ac85d59fe159", "filename": "libsanitizer/asan/asan_activation.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_activation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_activation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -75,13 +75,16 @@ static struct AsanDeactivatedFlags {\n \n   void Print() {\n     Report(\n-        \"quarantine_size_mb %d, max_redzone %d, poison_heap %d, \"\n-        \"malloc_context_size %d, alloc_dealloc_mismatch %d, \"\n-        \"allocator_may_return_null %d, coverage %d, coverage_dir %s\\n\",\n-        allocator_options.quarantine_size_mb, allocator_options.max_redzone,\n-        poison_heap, malloc_context_size,\n+        \"quarantine_size_mb %d, thread_local_quarantine_size_kb %d, \"\n+        \"max_redzone %d, poison_heap %d, malloc_context_size %d, \"\n+        \"alloc_dealloc_mismatch %d, allocator_may_return_null %d, coverage %d, \"\n+        \"coverage_dir %s, allocator_release_to_os_interval_ms %d\\n\",\n+        allocator_options.quarantine_size_mb,\n+        allocator_options.thread_local_quarantine_size_kb,\n+        allocator_options.max_redzone, poison_heap, malloc_context_size,\n         allocator_options.alloc_dealloc_mismatch,\n-        allocator_options.may_return_null, coverage, coverage_dir);\n+        allocator_options.may_return_null, coverage, coverage_dir,\n+        allocator_options.release_to_os_interval_ms);\n   }\n } asan_deactivated_flags;\n \n@@ -101,10 +104,10 @@ void AsanDeactivate() {\n   // Deactivate the runtime.\n   SetCanPoisonMemory(false);\n   SetMallocContextSize(1);\n-  ReInitializeCoverage(false, nullptr);\n \n   AllocatorOptions disabled = asan_deactivated_flags.allocator_options;\n   disabled.quarantine_size_mb = 0;\n+  disabled.thread_local_quarantine_size_kb = 0;\n   disabled.min_redzone = 16;  // Redzone must be at least 16 bytes long.\n   disabled.max_redzone = 16;\n   disabled.alloc_dealloc_mismatch = false;\n@@ -124,8 +127,6 @@ void AsanActivate() {\n \n   SetCanPoisonMemory(asan_deactivated_flags.poison_heap);\n   SetMallocContextSize(asan_deactivated_flags.malloc_context_size);\n-  ReInitializeCoverage(asan_deactivated_flags.coverage,\n-                       asan_deactivated_flags.coverage_dir);\n   ReInitializeAllocator(asan_deactivated_flags.allocator_options);\n \n   asan_is_deactivated = false;"}, {"sha": "e71abb96e5b77775d66ff86c26d3d247317c867b", "filename": "libsanitizer/asan/asan_activation_flags.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_activation_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_activation_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation_flags.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -22,6 +22,7 @@\n ASAN_ACTIVATION_FLAG(int, redzone)\n ASAN_ACTIVATION_FLAG(int, max_redzone)\n ASAN_ACTIVATION_FLAG(int, quarantine_size_mb)\n+ASAN_ACTIVATION_FLAG(int, thread_local_quarantine_size_kb)\n ASAN_ACTIVATION_FLAG(bool, alloc_dealloc_mismatch)\n ASAN_ACTIVATION_FLAG(bool, poison_heap)\n \n@@ -31,3 +32,4 @@ COMMON_ACTIVATION_FLAG(bool, coverage)\n COMMON_ACTIVATION_FLAG(const char *, coverage_dir)\n COMMON_ACTIVATION_FLAG(int, verbosity)\n COMMON_ACTIVATION_FLAG(bool, help)\n+COMMON_ACTIVATION_FLAG(s32, allocator_release_to_os_interval_ms)"}, {"sha": "1b465469c757870c11b284d1df60ef62dc933160", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "modified", "additions": 125, "deletions": 68, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -19,7 +19,9 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_allocator_checks.h\"\n #include \"sanitizer_common/sanitizer_allocator_interface.h\"\n+#include \"sanitizer_common/sanitizer_errno.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n@@ -158,7 +160,11 @@ struct QuarantineCallback {\n   }\n \n   void *Allocate(uptr size) {\n-    return get_allocator().Allocate(cache_, size, 1, false);\n+    void *res = get_allocator().Allocate(cache_, size, 1);\n+    // TODO(alekseys): Consider making quarantine OOM-friendly.\n+    if (UNLIKELY(!res))\n+      return DieOnFailure::OnOOM();\n+    return res;\n   }\n \n   void Deallocate(void *p) {\n@@ -205,32 +211,36 @@ QuarantineCache *GetQuarantineCache(AsanThreadLocalMallocStorage *ms) {\n \n void AllocatorOptions::SetFrom(const Flags *f, const CommonFlags *cf) {\n   quarantine_size_mb = f->quarantine_size_mb;\n+  thread_local_quarantine_size_kb = f->thread_local_quarantine_size_kb;\n   min_redzone = f->redzone;\n   max_redzone = f->max_redzone;\n   may_return_null = cf->allocator_may_return_null;\n   alloc_dealloc_mismatch = f->alloc_dealloc_mismatch;\n+  release_to_os_interval_ms = cf->allocator_release_to_os_interval_ms;\n }\n \n void AllocatorOptions::CopyTo(Flags *f, CommonFlags *cf) {\n   f->quarantine_size_mb = quarantine_size_mb;\n+  f->thread_local_quarantine_size_kb = thread_local_quarantine_size_kb;\n   f->redzone = min_redzone;\n   f->max_redzone = max_redzone;\n   cf->allocator_may_return_null = may_return_null;\n   f->alloc_dealloc_mismatch = alloc_dealloc_mismatch;\n+  cf->allocator_release_to_os_interval_ms = release_to_os_interval_ms;\n }\n \n struct Allocator {\n   static const uptr kMaxAllowedMallocSize =\n       FIRST_32_SECOND_64(3UL << 30, 1ULL << 40);\n-  static const uptr kMaxThreadLocalQuarantine =\n-      FIRST_32_SECOND_64(1 << 18, 1 << 20);\n \n   AsanAllocator allocator;\n   AsanQuarantine quarantine;\n   StaticSpinMutex fallback_mutex;\n   AllocatorCache fallback_allocator_cache;\n   QuarantineCache fallback_quarantine_cache;\n \n+  atomic_uint8_t rss_limit_exceeded;\n+\n   // ------------------- Options --------------------------\n   atomic_uint16_t min_redzone;\n   atomic_uint16_t max_redzone;\n@@ -252,43 +262,53 @@ struct Allocator {\n   void SharedInitCode(const AllocatorOptions &options) {\n     CheckOptions(options);\n     quarantine.Init((uptr)options.quarantine_size_mb << 20,\n-                    kMaxThreadLocalQuarantine);\n+                    (uptr)options.thread_local_quarantine_size_kb << 10);\n     atomic_store(&alloc_dealloc_mismatch, options.alloc_dealloc_mismatch,\n                  memory_order_release);\n     atomic_store(&min_redzone, options.min_redzone, memory_order_release);\n     atomic_store(&max_redzone, options.max_redzone, memory_order_release);\n   }\n \n   void Initialize(const AllocatorOptions &options) {\n-    allocator.Init(options.may_return_null);\n+    SetAllocatorMayReturnNull(options.may_return_null);\n+    allocator.Init(options.release_to_os_interval_ms);\n     SharedInitCode(options);\n   }\n \n+  bool RssLimitExceeded() {\n+    return atomic_load(&rss_limit_exceeded, memory_order_relaxed);\n+  }\n+\n+  void SetRssLimitExceeded(bool limit_exceeded) {\n+    atomic_store(&rss_limit_exceeded, limit_exceeded, memory_order_relaxed);\n+  }\n+\n   void RePoisonChunk(uptr chunk) {\n-    // This could a user-facing chunk (with redzones), or some internal\n+    // This could be a user-facing chunk (with redzones), or some internal\n     // housekeeping chunk, like TransferBatch. Start by assuming the former.\n     AsanChunk *ac = GetAsanChunk((void *)chunk);\n     uptr allocated_size = allocator.GetActuallyAllocatedSize((void *)ac);\n     uptr beg = ac->Beg();\n     uptr end = ac->Beg() + ac->UsedSize(true);\n     uptr chunk_end = chunk + allocated_size;\n-    if (chunk < beg && beg < end && end <= chunk_end) {\n-      // Looks like a valid AsanChunk. Or maybe not. Be conservative and only\n-      // poison the redzones.\n+    if (chunk < beg && beg < end && end <= chunk_end &&\n+        ac->chunk_state == CHUNK_ALLOCATED) {\n+      // Looks like a valid AsanChunk in use, poison redzones only.\n       PoisonShadow(chunk, beg - chunk, kAsanHeapLeftRedzoneMagic);\n       uptr end_aligned_down = RoundDownTo(end, SHADOW_GRANULARITY);\n       FastPoisonShadowPartialRightRedzone(\n           end_aligned_down, end - end_aligned_down,\n           chunk_end - end_aligned_down, kAsanHeapLeftRedzoneMagic);\n     } else {\n-      // This can not be an AsanChunk. Poison everything. It may be reused as\n-      // AsanChunk later.\n+      // This is either not an AsanChunk or freed or quarantined AsanChunk.\n+      // In either case, poison everything.\n       PoisonShadow(chunk, allocated_size, kAsanHeapLeftRedzoneMagic);\n     }\n   }\n \n   void ReInitialize(const AllocatorOptions &options) {\n-    allocator.SetMayReturnNull(options.may_return_null);\n+    SetAllocatorMayReturnNull(options.may_return_null);\n+    allocator.SetReleaseToOSIntervalMs(options.release_to_os_interval_ms);\n     SharedInitCode(options);\n \n     // Poison all existing allocation's redzones.\n@@ -305,11 +325,13 @@ struct Allocator {\n \n   void GetOptions(AllocatorOptions *options) const {\n     options->quarantine_size_mb = quarantine.GetSize() >> 20;\n+    options->thread_local_quarantine_size_kb = quarantine.GetCacheSize() >> 10;\n     options->min_redzone = atomic_load(&min_redzone, memory_order_acquire);\n     options->max_redzone = atomic_load(&max_redzone, memory_order_acquire);\n-    options->may_return_null = allocator.MayReturnNull();\n+    options->may_return_null = AllocatorMayReturnNull();\n     options->alloc_dealloc_mismatch =\n         atomic_load(&alloc_dealloc_mismatch, memory_order_acquire);\n+    options->release_to_os_interval_ms = allocator.ReleaseToOSIntervalMs();\n   }\n \n   // -------------------- Helper methods. -------------------------\n@@ -356,6 +378,8 @@ struct Allocator {\n                  AllocType alloc_type, bool can_fill) {\n     if (UNLIKELY(!asan_inited))\n       AsanInitFromRtl();\n+    if (RssLimitExceeded())\n+      return AsanAllocator::FailureHandler::OnOOM();\n     Flags &fl = *flags();\n     CHECK(stack);\n     const uptr min_alignment = SHADOW_GRANULARITY;\n@@ -388,24 +412,21 @@ struct Allocator {\n     if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n       Report(\"WARNING: AddressSanitizer failed to allocate 0x%zx bytes\\n\",\n              (void*)size);\n-      return allocator.ReturnNullOrDieOnBadRequest();\n+      return AsanAllocator::FailureHandler::OnBadRequest();\n     }\n \n     AsanThread *t = GetCurrentThread();\n     void *allocated;\n-    bool check_rss_limit = true;\n     if (t) {\n       AllocatorCache *cache = GetAllocatorCache(&t->malloc_storage());\n-      allocated =\n-          allocator.Allocate(cache, needed_size, 8, false, check_rss_limit);\n+      allocated = allocator.Allocate(cache, needed_size, 8);\n     } else {\n       SpinMutexLock l(&fallback_mutex);\n       AllocatorCache *cache = &fallback_allocator_cache;\n-      allocated =\n-          allocator.Allocate(cache, needed_size, 8, false, check_rss_limit);\n+      allocated = allocator.Allocate(cache, needed_size, 8);\n     }\n-\n-    if (!allocated) return allocator.ReturnNullOrDieOnOOM();\n+    if (!allocated)\n+      return nullptr;\n \n     if (*(u8 *)MEM_TO_SHADOW((uptr)allocated) == 0 && CanPoisonMemory()) {\n       // Heap poisoning is enabled, but the allocator provides an unpoisoned\n@@ -507,15 +528,26 @@ struct Allocator {\n \n   // Expects the chunk to already be marked as quarantined by using\n   // AtomicallySetQuarantineFlagIfAllocated.\n-  void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack,\n-                       AllocType alloc_type) {\n+  void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack) {\n     CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n     CHECK_GE(m->alloc_tid, 0);\n     if (SANITIZER_WORDSIZE == 64)  // On 32-bits this resides in user area.\n       CHECK_EQ(m->free_tid, kInvalidTid);\n     AsanThread *t = GetCurrentThread();\n     m->free_tid = t ? t->tid() : 0;\n     m->free_context_id = StackDepotPut(*stack);\n+\n+    Flags &fl = *flags();\n+    if (fl.max_free_fill_size > 0) {\n+      // We have to skip the chunk header, it contains free_context_id.\n+      uptr scribble_start = (uptr)m + kChunkHeaderSize + kChunkHeader2Size;\n+      if (m->UsedSize() >= kChunkHeader2Size) {  // Skip Header2 in user area.\n+        uptr size_to_fill = m->UsedSize() - kChunkHeader2Size;\n+        size_to_fill = Min(size_to_fill, (uptr)fl.max_free_fill_size);\n+        REAL(memset)((void *)scribble_start, fl.free_fill_byte, size_to_fill);\n+      }\n+    }\n+\n     // Poison the region.\n     PoisonShadow(m->Beg(),\n                  RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n@@ -547,7 +579,17 @@ struct Allocator {\n     uptr chunk_beg = p - kChunkHeaderSize;\n     AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n \n+    // On Windows, uninstrumented DLLs may allocate memory before ASan hooks\n+    // malloc. Don't report an invalid free in this case.\n+    if (SANITIZER_WINDOWS &&\n+        !get_allocator().PointerIsMine(ptr)) {\n+      if (!IsSystemHeapAddress(p))\n+        ReportFreeNotMalloced(p, stack);\n+      return;\n+    }\n+\n     ASAN_FREE_HOOK(ptr);\n+\n     // Must mark the chunk as quarantined before any changes to its metadata.\n     // Do not quarantine given chunk if we failed to set CHUNK_QUARANTINE flag.\n     if (!AtomicallySetQuarantineFlagIfAllocated(m, ptr, stack)) return;\n@@ -564,7 +606,7 @@ struct Allocator {\n       ReportNewDeleteSizeMismatch(p, delete_size, stack);\n     }\n \n-    QuarantineChunk(m, ptr, stack, alloc_type);\n+    QuarantineChunk(m, ptr, stack);\n   }\n \n   void *Reallocate(void *old_ptr, uptr new_size, BufferedStackTrace *stack) {\n@@ -593,8 +635,8 @@ struct Allocator {\n   }\n \n   void *Calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n-    if (CallocShouldReturnNullDueToOverflow(size, nmemb))\n-      return allocator.ReturnNullOrDieOnBadRequest();\n+    if (CheckForCallocOverflow(size, nmemb))\n+      return AsanAllocator::FailureHandler::OnBadRequest();\n     void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n     // If the memory comes from the secondary allocator no need to clear it\n     // as it comes directly from mmap.\n@@ -674,6 +716,7 @@ struct Allocator {\n \n   void PrintStats() {\n     allocator.PrintStats();\n+    quarantine.PrintStats();\n   }\n \n   void ForceLock() {\n@@ -685,8 +728,6 @@ struct Allocator {\n     fallback_mutex.Unlock();\n     allocator.ForceUnlock();\n   }\n-\n-  void ReleaseToOS() { allocator.ReleaseToOS(); }\n };\n \n static Allocator instance(LINKER_INITIALIZED);\n@@ -695,18 +736,21 @@ static AsanAllocator &get_allocator() {\n   return instance.allocator;\n }\n \n-bool AsanChunkView::IsValid() {\n+bool AsanChunkView::IsValid() const {\n   return chunk_ && chunk_->chunk_state != CHUNK_AVAILABLE;\n }\n-bool AsanChunkView::IsAllocated() {\n+bool AsanChunkView::IsAllocated() const {\n   return chunk_ && chunk_->chunk_state == CHUNK_ALLOCATED;\n }\n-uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n-uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n-uptr AsanChunkView::UsedSize() { return chunk_->UsedSize(); }\n-uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n-uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n-AllocType AsanChunkView::GetAllocType() {\n+bool AsanChunkView::IsQuarantined() const {\n+  return chunk_ && chunk_->chunk_state == CHUNK_QUARANTINE;\n+}\n+uptr AsanChunkView::Beg() const { return chunk_->Beg(); }\n+uptr AsanChunkView::End() const { return Beg() + UsedSize(); }\n+uptr AsanChunkView::UsedSize() const { return chunk_->UsedSize(); }\n+uptr AsanChunkView::AllocTid() const { return chunk_->alloc_tid; }\n+uptr AsanChunkView::FreeTid() const { return chunk_->free_tid; }\n+AllocType AsanChunkView::GetAllocType() const {\n   return (AllocType)chunk_->alloc_type;\n }\n \n@@ -717,22 +761,19 @@ static StackTrace GetStackTraceFromId(u32 id) {\n   return res;\n }\n \n-u32 AsanChunkView::GetAllocStackId() { return chunk_->alloc_context_id; }\n-u32 AsanChunkView::GetFreeStackId() { return chunk_->free_context_id; }\n+u32 AsanChunkView::GetAllocStackId() const { return chunk_->alloc_context_id; }\n+u32 AsanChunkView::GetFreeStackId() const { return chunk_->free_context_id; }\n \n-StackTrace AsanChunkView::GetAllocStack() {\n+StackTrace AsanChunkView::GetAllocStack() const {\n   return GetStackTraceFromId(GetAllocStackId());\n }\n \n-StackTrace AsanChunkView::GetFreeStack() {\n+StackTrace AsanChunkView::GetFreeStack() const {\n   return GetStackTraceFromId(GetFreeStackId());\n }\n \n-void ReleaseToOS() { instance.ReleaseToOS(); }\n-\n void InitializeAllocator(const AllocatorOptions &options) {\n   instance.Initialize(options);\n-  SetAllocatorReleaseToOSCallback(ReleaseToOS);\n }\n \n void ReInitializeAllocator(const AllocatorOptions &options) {\n@@ -758,11 +799,6 @@ void PrintInternalAllocatorStats() {\n   instance.PrintStats();\n }\n \n-void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n-                    AllocType alloc_type) {\n-  return instance.Allocate(size, alignment, stack, alloc_type, true);\n-}\n-\n void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type) {\n   instance.Deallocate(ptr, 0, stack, alloc_type);\n }\n@@ -773,40 +809,63 @@ void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n }\n \n void *asan_malloc(uptr size, BufferedStackTrace *stack) {\n-  return instance.Allocate(size, 8, stack, FROM_MALLOC, true);\n+  return SetErrnoOnNull(instance.Allocate(size, 8, stack, FROM_MALLOC, true));\n }\n \n void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n-  return instance.Calloc(nmemb, size, stack);\n+  return SetErrnoOnNull(instance.Calloc(nmemb, size, stack));\n }\n \n void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack) {\n   if (!p)\n-    return instance.Allocate(size, 8, stack, FROM_MALLOC, true);\n+    return SetErrnoOnNull(instance.Allocate(size, 8, stack, FROM_MALLOC, true));\n   if (size == 0) {\n-    instance.Deallocate(p, 0, stack, FROM_MALLOC);\n-    return nullptr;\n+    if (flags()->allocator_frees_and_returns_null_on_realloc_zero) {\n+      instance.Deallocate(p, 0, stack, FROM_MALLOC);\n+      return nullptr;\n+    }\n+    // Allocate a size of 1 if we shouldn't free() on Realloc to 0\n+    size = 1;\n   }\n-  return instance.Reallocate(p, size, stack);\n+  return SetErrnoOnNull(instance.Reallocate(p, size, stack));\n }\n \n void *asan_valloc(uptr size, BufferedStackTrace *stack) {\n-  return instance.Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC, true);\n+  return SetErrnoOnNull(\n+      instance.Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC, true));\n }\n \n void *asan_pvalloc(uptr size, BufferedStackTrace *stack) {\n   uptr PageSize = GetPageSizeCached();\n-  size = RoundUpTo(size, PageSize);\n-  if (size == 0) {\n-    // pvalloc(0) should allocate one page.\n-    size = PageSize;\n+  if (UNLIKELY(CheckForPvallocOverflow(size, PageSize))) {\n+    errno = errno_ENOMEM;\n+    return AsanAllocator::FailureHandler::OnBadRequest();\n   }\n-  return instance.Allocate(size, PageSize, stack, FROM_MALLOC, true);\n+  // pvalloc(0) should allocate one page.\n+  size = size ? RoundUpTo(size, PageSize) : PageSize;\n+  return SetErrnoOnNull(\n+      instance.Allocate(size, PageSize, stack, FROM_MALLOC, true));\n+}\n+\n+void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n+                    AllocType alloc_type) {\n+  if (UNLIKELY(!IsPowerOfTwo(alignment))) {\n+    errno = errno_EINVAL;\n+    return AsanAllocator::FailureHandler::OnBadRequest();\n+  }\n+  return SetErrnoOnNull(\n+      instance.Allocate(size, alignment, stack, alloc_type, true));\n }\n \n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                         BufferedStackTrace *stack) {\n+  if (UNLIKELY(!CheckPosixMemalignAlignment(alignment))) {\n+    AsanAllocator::FailureHandler::OnBadRequest();\n+    return errno_EINVAL;\n+  }\n   void *ptr = instance.Allocate(size, alignment, stack, FROM_MALLOC, true);\n+  if (UNLIKELY(!ptr))\n+    return errno_ENOMEM;\n   CHECK(IsAligned((uptr)ptr, alignment));\n   *memptr = ptr;\n   return 0;\n@@ -834,8 +893,8 @@ void asan_mz_force_unlock() {\n   instance.ForceUnlock();\n }\n \n-void AsanSoftRssLimitExceededCallback(bool exceeded) {\n-  instance.allocator.SetRssLimitIsExceeded(exceeded);\n+void AsanSoftRssLimitExceededCallback(bool limit_exceeded) {\n+  instance.SetRssLimitExceeded(limit_exceeded);\n }\n \n } // namespace __asan\n@@ -952,15 +1011,13 @@ uptr __sanitizer_get_allocated_size(const void *p) {\n \n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default (no-op) implementation of malloc hooks.\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_malloc_hook(void *ptr, uptr size) {\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_malloc_hook,\n+                             void *ptr, uptr size) {\n   (void)ptr;\n   (void)size;\n }\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_free_hook(void *ptr) {\n+\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_free_hook, void *ptr) {\n   (void)ptr;\n }\n-} // extern \"C\"\n #endif"}, {"sha": "63260ff9895fc0874e26957b9337e5ce16628c80", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -31,10 +31,12 @@ struct AsanChunk;\n \n struct AllocatorOptions {\n   u32 quarantine_size_mb;\n+  u32 thread_local_quarantine_size_kb;\n   u16 min_redzone;\n   u16 max_redzone;\n   u8 may_return_null;\n   u8 alloc_dealloc_mismatch;\n+  s32 release_to_os_interval_ms;\n \n   void SetFrom(const Flags *f, const CommonFlags *cf);\n   void CopyTo(Flags *f, CommonFlags *cf);\n@@ -47,36 +49,37 @@ void GetAllocatorOptions(AllocatorOptions *options);\n class AsanChunkView {\n  public:\n   explicit AsanChunkView(AsanChunk *chunk) : chunk_(chunk) {}\n-  bool IsValid();        // Checks if AsanChunkView points to a valid allocated\n-                         // or quarantined chunk.\n-  bool IsAllocated();    // Checks if the memory is currently allocated.\n-  uptr Beg();            // First byte of user memory.\n-  uptr End();            // Last byte of user memory.\n-  uptr UsedSize();       // Size requested by the user.\n-  uptr AllocTid();\n-  uptr FreeTid();\n+  bool IsValid() const;        // Checks if AsanChunkView points to a valid\n+                               // allocated or quarantined chunk.\n+  bool IsAllocated() const;    // Checks if the memory is currently allocated.\n+  bool IsQuarantined() const;  // Checks if the memory is currently quarantined.\n+  uptr Beg() const;            // First byte of user memory.\n+  uptr End() const;            // Last byte of user memory.\n+  uptr UsedSize() const;       // Size requested by the user.\n+  uptr AllocTid() const;\n+  uptr FreeTid() const;\n   bool Eq(const AsanChunkView &c) const { return chunk_ == c.chunk_; }\n-  u32 GetAllocStackId();\n-  u32 GetFreeStackId();\n-  StackTrace GetAllocStack();\n-  StackTrace GetFreeStack();\n-  AllocType GetAllocType();\n-  bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) {\n+  u32 GetAllocStackId() const;\n+  u32 GetFreeStackId() const;\n+  StackTrace GetAllocStack() const;\n+  StackTrace GetFreeStack() const;\n+  AllocType GetAllocType() const;\n+  bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) const {\n     if (addr >= Beg() && (addr + access_size) <= End()) {\n       *offset = addr - Beg();\n       return true;\n     }\n     return false;\n   }\n-  bool AddrIsAtLeft(uptr addr, uptr access_size, sptr *offset) {\n+  bool AddrIsAtLeft(uptr addr, uptr access_size, sptr *offset) const {\n     (void)access_size;\n     if (addr < Beg()) {\n       *offset = Beg() - addr;\n       return true;\n     }\n     return false;\n   }\n-  bool AddrIsAtRight(uptr addr, uptr access_size, sptr *offset) {\n+  bool AddrIsAtRight(uptr addr, uptr access_size, sptr *offset) const {\n     if (addr + access_size > End()) {\n       *offset = addr - End();\n       return true;\n@@ -114,7 +117,11 @@ struct AsanMapUnmapCallback {\n };\n \n #if SANITIZER_CAN_USE_ALLOCATOR64\n-# if defined(__powerpc64__)\n+# if SANITIZER_FUCHSIA\n+const uptr kAllocatorSpace = ~(uptr)0;\n+const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n+typedef DefaultSizeClassMap SizeClassMap;\n+# elif defined(__powerpc64__)\n const uptr kAllocatorSpace =  0xa0000000000ULL;\n const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n typedef DefaultSizeClassMap SizeClassMap;\n@@ -156,10 +163,17 @@ typedef FlatByteMap<kNumRegions> ByteMap;\n typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n # endif\n typedef CompactSizeClassMap SizeClassMap;\n-typedef SizeClassAllocator32<0, SANITIZER_MMAP_RANGE_SIZE, 16,\n-  SizeClassMap, kRegionSizeLog,\n-  ByteMap,\n-  AsanMapUnmapCallback> PrimaryAllocator;\n+struct AP32 {\n+  static const uptr kSpaceBeg = 0;\n+  static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n+  static const uptr kMetadataSize = 16;\n+  typedef __asan::SizeClassMap SizeClassMap;\n+  static const uptr kRegionSizeLog = __asan::kRegionSizeLog;\n+  typedef __asan::ByteMap ByteMap;\n+  typedef AsanMapUnmapCallback MapUnmapCallback;\n+  static const uptr kFlags = 0;\n+};\n+typedef SizeClassAllocator32<AP32> PrimaryAllocator;\n #endif  // SANITIZER_CAN_USE_ALLOCATOR64\n \n static const uptr kNumberOfSizeClasses = SizeClassMap::kNumClasses;"}, {"sha": "d46962adf2769cbbbc9b29852c9c9e61d975a3ae", "filename": "libsanitizer/asan/asan_descriptions.cc", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_descriptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_descriptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -148,7 +148,7 @@ static void PrintHeapChunkAccess(uptr addr, const ChunkAccess &descr) {\n   str.append(\" %zu-byte region [%p,%p)\\n\", descr.chunk_size,\n              (void *)descr.chunk_begin,\n              (void *)(descr.chunk_begin + descr.chunk_size));\n-  str.append(\"%s\", d.EndLocation());\n+  str.append(\"%s\", d.Default());\n   Printf(\"%s\", str.data());\n }\n \n@@ -250,12 +250,15 @@ static void PrintAccessAndVarIntersection(const StackVarDescr &var, uptr addr,\n     str.append(\"%c\", var.name_pos[i]);\n   }\n   str.append(\"'\");\n+  if (var.line > 0) {\n+    str.append(\" (line %d)\", var.line);\n+  }\n   if (pos_descr) {\n     Decorator d;\n     // FIXME: we may want to also print the size of the access here,\n     // but in case of accesses generated by memset it may be confusing.\n     str.append(\"%s <== Memory access at offset %zd %s this variable%s\\n\",\n-               d.Location(), addr, pos_descr, d.EndLocation());\n+               d.Location(), addr, pos_descr, d.Default());\n   } else {\n     str.append(\"\\n\");\n   }\n@@ -290,7 +293,7 @@ static void DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n              MaybeDemangleGlobalName(g.name));\n   PrintGlobalLocation(&str, g);\n   str.append(\"' (0x%zx) of size %zu\\n\", g.beg, g.size);\n-  str.append(\"%s\", d.EndLocation());\n+  str.append(\"%s\", d.Default());\n   PrintGlobalNameIfASCII(&str, g);\n   Printf(\"%s\", str.data());\n }\n@@ -338,10 +341,10 @@ void StackAddressDescription::Print() const {\n          ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n \n   if (!frame_descr) {\n-    Printf(\"%s\\n\", d.EndLocation());\n+    Printf(\"%s\\n\", d.Default());\n     return;\n   }\n-  Printf(\" at offset %zu in frame%s\\n\", offset, d.EndLocation());\n+  Printf(\" at offset %zu in frame%s\\n\", offset, d.Default());\n \n   // Now we print the frame where the alloca has happened.\n   // We print this frame as a stack trace with one element.\n@@ -350,7 +353,7 @@ void StackAddressDescription::Print() const {\n   // previously. That's unfortunate, but I have no better solution,\n   // especially given that the alloca may be from entirely different place\n   // (e.g. use-after-scope, or different thread's stack).\n-  Printf(\"%s\", d.EndLocation());\n+  Printf(\"%s\", d.Default());\n   StackTrace alloca_stack(&frame_pc, 1);\n   alloca_stack.Print();\n \n@@ -400,18 +403,18 @@ void HeapAddressDescription::Print() const {\n     Printf(\"%sfreed by thread T%d%s here:%s\\n\", d.Allocation(),\n            free_thread->tid,\n            ThreadNameWithParenthesis(free_thread, tname, sizeof(tname)),\n-           d.EndAllocation());\n+           d.Default());\n     StackTrace free_stack = GetStackTraceFromId(free_stack_id);\n     free_stack.Print();\n     Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\", d.Allocation(),\n            alloc_thread->tid,\n            ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n-           d.EndAllocation());\n+           d.Default());\n   } else {\n     Printf(\"%sallocated by thread T%d%s here:%s\\n\", d.Allocation(),\n            alloc_thread->tid,\n            ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n-           d.EndAllocation());\n+           d.Default());\n   }\n   alloc_stack.Print();\n   DescribeThread(GetCurrentThread());"}, {"sha": "0fbb531492a928093470f442422ee4c15d66a7c9", "filename": "libsanitizer/asan/asan_descriptions.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_descriptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_descriptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -32,11 +32,8 @@ class Decorator : public __sanitizer::SanitizerCommonDecorator {\n  public:\n   Decorator() : SanitizerCommonDecorator() {}\n   const char *Access() { return Blue(); }\n-  const char *EndAccess() { return Default(); }\n   const char *Location() { return Green(); }\n-  const char *EndLocation() { return Default(); }\n   const char *Allocation() { return Magenta(); }\n-  const char *EndAllocation() { return Default(); }\n \n   const char *ShadowByte(u8 byte) {\n     switch (byte) {\n@@ -70,9 +67,6 @@ class Decorator : public __sanitizer::SanitizerCommonDecorator {\n         return Default();\n     }\n   }\n-  const char *EndShadowByte() { return Default(); }\n-  const char *MemoryByte() { return Magenta(); }\n-  const char *EndMemoryByte() { return Default(); }\n };\n \n enum ShadowKind : u8 {"}, {"sha": "b469b16f004236ac3d66cbd27013deacf1ae778a", "filename": "libsanitizer/asan/asan_errors.cc", "status": "modified", "additions": 51, "deletions": 87, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_errors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_errors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -20,94 +20,57 @@\n \n namespace __asan {\n \n-void ErrorStackOverflow::Print() {\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\n-      \"ERROR: AddressSanitizer: stack-overflow on address %p\"\n-      \" (pc %p bp %p sp %p T%d)\\n\",\n-      (void *)addr, (void *)pc, (void *)bp, (void *)sp, tid);\n-  Printf(\"%s\", d.EndWarning());\n-  scariness.Print();\n-  BufferedStackTrace stack;\n-  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,\n-                                  common_flags()->fast_unwind_on_fatal);\n-  stack.Print();\n-  ReportErrorSummary(\"stack-overflow\", &stack);\n-}\n-\n-static void MaybeDumpInstructionBytes(uptr pc) {\n-  if (!flags()->dump_instruction_bytes || (pc < GetPageSizeCached())) return;\n-  InternalScopedString str(1024);\n-  str.append(\"First 16 instruction bytes at pc: \");\n-  if (IsAccessibleMemoryRange(pc, 16)) {\n-    for (int i = 0; i < 16; ++i) {\n-      PrintMemoryByte(&str, \"\", ((u8 *)pc)[i], /*in_shadow*/ false, \" \");\n-    }\n-    str.append(\"\\n\");\n-  } else {\n-    str.append(\"unaccessible\\n\");\n-  }\n-  Report(\"%s\", str.data());\n+static void OnStackUnwind(const SignalContext &sig,\n+                          const void *callback_context,\n+                          BufferedStackTrace *stack) {\n+  bool fast = common_flags()->fast_unwind_on_fatal;\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n+  // On FreeBSD the slow unwinding that leverages _Unwind_Backtrace()\n+  // yields the call stack of the signal's handler and not of the code\n+  // that raised the signal (as it does on Linux).\n+  fast = true;\n+#endif\n+  // Tests and maybe some users expect that scariness is going to be printed\n+  // just before the stack. As only asan has scariness score we have no\n+  // corresponding code in the sanitizer_common and we use this callback to\n+  // print it.\n+  static_cast<const ScarinessScoreBase *>(callback_context)->Print();\n+  GetStackTraceWithPcBpAndContext(stack, kStackTraceMax, sig.pc, sig.bp,\n+                                  sig.context, fast);\n }\n \n void ErrorDeadlySignal::Print() {\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  const char *description = DescribeSignalOrException(signo);\n-  Report(\n-      \"ERROR: AddressSanitizer: %s on unknown address %p (pc %p bp %p sp %p \"\n-      \"T%d)\\n\",\n-      description, (void *)addr, (void *)pc, (void *)bp, (void *)sp, tid);\n-  Printf(\"%s\", d.EndWarning());\n-  if (pc < GetPageSizeCached()) Report(\"Hint: pc points to the zero page.\\n\");\n-  if (is_memory_access) {\n-    const char *access_type =\n-        write_flag == SignalContext::WRITE\n-            ? \"WRITE\"\n-            : (write_flag == SignalContext::READ ? \"READ\" : \"UNKNOWN\");\n-    Report(\"The signal is caused by a %s memory access.\\n\", access_type);\n-    if (addr < GetPageSizeCached())\n-      Report(\"Hint: address points to the zero page.\\n\");\n-  }\n-  scariness.Print();\n-  BufferedStackTrace stack;\n-  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,\n-                                  common_flags()->fast_unwind_on_fatal);\n-  stack.Print();\n-  MaybeDumpInstructionBytes(pc);\n-  Printf(\"AddressSanitizer can not provide additional info.\\n\");\n-  ReportErrorSummary(description, &stack);\n+  ReportDeadlySignal(signal, tid, &OnStackUnwind, &scariness);\n }\n \n void ErrorDoubleFree::Print() {\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   char tname[128];\n   Report(\n-      \"ERROR: AddressSanitizer: attempting double-free on %p in \"\n+      \"ERROR: AddressSanitizer: attempting %s on %p in \"\n       \"thread T%d%s:\\n\",\n-      addr_description.addr, tid,\n+      scariness.GetDescription(), addr_description.addr, tid,\n       ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   scariness.Print();\n   GET_STACK_TRACE_FATAL(second_free_stack->trace[0],\n                         second_free_stack->top_frame_bp);\n   stack.Print();\n   addr_description.Print();\n-  ReportErrorSummary(\"double-free\", &stack);\n+  ReportErrorSummary(scariness.GetDescription(), &stack);\n }\n \n void ErrorNewDeleteSizeMismatch::Print() {\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   char tname[128];\n   Report(\n-      \"ERROR: AddressSanitizer: new-delete-type-mismatch on %p in thread \"\n+      \"ERROR: AddressSanitizer: %s on %p in thread \"\n       \"T%d%s:\\n\",\n-      addr_description.addr, tid,\n+      scariness.GetDescription(), addr_description.addr, tid,\n       ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n-  Printf(\"%s  object passed to delete has wrong type:\\n\", d.EndWarning());\n+  Printf(\"%s  object passed to delete has wrong type:\\n\", d.Default());\n   Printf(\n       \"  size of the allocated type:   %zd bytes;\\n\"\n       \"  size of the deallocated type: %zd bytes.\\n\",\n@@ -117,7 +80,7 @@ void ErrorNewDeleteSizeMismatch::Print() {\n   GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n   stack.Print();\n   addr_description.Print();\n-  ReportErrorSummary(\"new-delete-type-mismatch\", &stack);\n+  ReportErrorSummary(scariness.GetDescription(), &stack);\n   Report(\n       \"HINT: if you don't care about these errors you may set \"\n       \"ASAN_OPTIONS=new_delete_type_mismatch=0\\n\");\n@@ -132,13 +95,13 @@ void ErrorFreeNotMalloced::Print() {\n       \"which was not malloc()-ed: %p in thread T%d%s\\n\",\n       addr_description.Address(), tid,\n       ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   CHECK_GT(free_stack->size, 0);\n   scariness.Print();\n   GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n   stack.Print();\n   addr_description.Print();\n-  ReportErrorSummary(\"bad-free\", &stack);\n+  ReportErrorSummary(scariness.GetDescription(), &stack);\n }\n \n void ErrorAllocTypeMismatch::Print() {\n@@ -149,16 +112,17 @@ void ErrorAllocTypeMismatch::Print() {\n   CHECK_NE(alloc_type, dealloc_type);\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: alloc-dealloc-mismatch (%s vs %s) on %p\\n\",\n+  Report(\"ERROR: AddressSanitizer: %s (%s vs %s) on %p\\n\",\n+         scariness.GetDescription(),\n          alloc_names[alloc_type], dealloc_names[dealloc_type],\n          addr_description.addr);\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   CHECK_GT(dealloc_stack->size, 0);\n   scariness.Print();\n   GET_STACK_TRACE_FATAL(dealloc_stack->trace[0], dealloc_stack->top_frame_bp);\n   stack.Print();\n   addr_description.Print();\n-  ReportErrorSummary(\"alloc-dealloc-mismatch\", &stack);\n+  ReportErrorSummary(scariness.GetDescription(), &stack);\n   Report(\n       \"HINT: if you don't care about these errors you may set \"\n       \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n@@ -171,10 +135,10 @@ void ErrorMallocUsableSizeNotOwned::Print() {\n       \"ERROR: AddressSanitizer: attempting to call malloc_usable_size() for \"\n       \"pointer which is not owned: %p\\n\",\n       addr_description.Address());\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   stack->Print();\n   addr_description.Print();\n-  ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n }\n \n void ErrorSanitizerGetAllocatedSizeNotOwned::Print() {\n@@ -184,10 +148,10 @@ void ErrorSanitizerGetAllocatedSizeNotOwned::Print() {\n       \"ERROR: AddressSanitizer: attempting to call \"\n       \"__sanitizer_get_allocated_size() for pointer which is not owned: %p\\n\",\n       addr_description.Address());\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   stack->Print();\n   addr_description.Print();\n-  ReportErrorSummary(\"bad-__sanitizer_get_allocated_size\", stack);\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n }\n \n void ErrorStringFunctionMemoryRangesOverlap::Print() {\n@@ -201,7 +165,7 @@ void ErrorStringFunctionMemoryRangesOverlap::Print() {\n       bug_type, addr1_description.Address(),\n       addr1_description.Address() + length1, addr2_description.Address(),\n       addr2_description.Address() + length2);\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   scariness.Print();\n   stack->Print();\n   addr1_description.Print();\n@@ -212,13 +176,13 @@ void ErrorStringFunctionMemoryRangesOverlap::Print() {\n void ErrorStringFunctionSizeOverflow::Print() {\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n-  const char *bug_type = \"negative-size-param\";\n-  Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\", bug_type, size);\n-  Printf(\"%s\", d.EndWarning());\n+  Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\",\n+         scariness.GetDescription(), size);\n+  Printf(\"%s\", d.Default());\n   scariness.Print();\n   stack->Print();\n   addr_description.Print();\n-  ReportErrorSummary(bug_type, stack);\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n }\n \n void ErrorBadParamsToAnnotateContiguousContainer::Print() {\n@@ -234,14 +198,15 @@ void ErrorBadParamsToAnnotateContiguousContainer::Print() {\n   if (!IsAligned(beg, granularity))\n     Report(\"ERROR: beg is not aligned by %d\\n\", granularity);\n   stack->Print();\n-  ReportErrorSummary(\"bad-__sanitizer_annotate_contiguous_container\", stack);\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n }\n \n void ErrorODRViolation::Print() {\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: odr-violation (%p):\\n\", global1.beg);\n-  Printf(\"%s\", d.EndWarning());\n+  Report(\"ERROR: AddressSanitizer: %s (%p):\\n\", scariness.GetDescription(),\n+         global1.beg);\n+  Printf(\"%s\", d.Default());\n   InternalScopedString g1_loc(256), g2_loc(256);\n   PrintGlobalLocation(&g1_loc, global1);\n   PrintGlobalLocation(&g2_loc, global2);\n@@ -260,23 +225,22 @@ void ErrorODRViolation::Print() {\n       \"HINT: if you don't care about these errors you may set \"\n       \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n   InternalScopedString error_msg(256);\n-  error_msg.append(\"odr-violation: global '%s' at %s\",\n+  error_msg.append(\"%s: global '%s' at %s\", scariness.GetDescription(),\n                    MaybeDemangleGlobalName(global1.name), g1_loc.data());\n   ReportErrorSummary(error_msg.data());\n }\n \n void ErrorInvalidPointerPair::Print() {\n-  const char *bug_type = \"invalid-pointer-pair\";\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: invalid-pointer-pair: %p %p\\n\",\n+  Report(\"ERROR: AddressSanitizer: %s: %p %p\\n\", scariness.GetDescription(),\n          addr1_description.Address(), addr2_description.Address());\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n   GET_STACK_TRACE_FATAL(pc, bp);\n   stack.Print();\n   addr1_description.Print();\n   addr2_description.Print();\n-  ReportErrorSummary(bug_type, &stack);\n+  ReportErrorSummary(scariness.GetDescription(), &stack);\n }\n \n static bool AdjacentShadowValuesAreFullyPoisoned(u8 *s) {\n@@ -470,13 +434,13 @@ void ErrorGeneric::Print() {\n   uptr addr = addr_description.Address();\n   Report(\"ERROR: AddressSanitizer: %s on address %p at pc %p bp %p sp %p\\n\",\n          bug_descr, (void *)addr, pc, bp, sp);\n-  Printf(\"%s\", d.EndWarning());\n+  Printf(\"%s\", d.Default());\n \n   char tname[128];\n   Printf(\"%s%s of size %zu at %p thread T%d%s%s\\n\", d.Access(),\n          access_size ? (is_write ? \"WRITE\" : \"READ\") : \"ACCESS\", access_size,\n          (void *)addr, tid,\n-         ThreadNameWithParenthesis(tid, tname, sizeof(tname)), d.EndAccess());\n+         ThreadNameWithParenthesis(tid, tname, sizeof(tname)), d.Default());\n \n   scariness.Print();\n   GET_STACK_TRACE_FATAL(pc, bp);"}, {"sha": "ea8fd01e28755d93ab170a33b827e21fc7f38053", "filename": "libsanitizer/asan/asan_errors.h", "status": "modified", "additions": 31, "deletions": 53, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -25,61 +25,28 @@ struct ErrorBase {\n   u32 tid;\n };\n \n-struct ErrorStackOverflow : ErrorBase {\n-  uptr addr, pc, bp, sp;\n-  // ErrorStackOverflow never owns the context.\n-  void *context;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorStackOverflow() = default;\n-  ErrorStackOverflow(u32 tid, const SignalContext &sig)\n-      : ErrorBase(tid),\n-        addr(sig.addr),\n-        pc(sig.pc),\n-        bp(sig.bp),\n-        sp(sig.sp),\n-        context(sig.context) {\n-    scariness.Clear();\n-    scariness.Scare(10, \"stack-overflow\");\n-  }\n-  void Print();\n-};\n-\n struct ErrorDeadlySignal : ErrorBase {\n-  uptr addr, pc, bp, sp;\n-  // ErrorDeadlySignal never owns the context.\n-  void *context;\n-  int signo;\n-  SignalContext::WriteFlag write_flag;\n-  bool is_memory_access;\n+  SignalContext signal;\n   // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n   // constructor\n   ErrorDeadlySignal() = default;\n-  ErrorDeadlySignal(u32 tid, const SignalContext &sig, int signo_)\n-      : ErrorBase(tid),\n-        addr(sig.addr),\n-        pc(sig.pc),\n-        bp(sig.bp),\n-        sp(sig.sp),\n-        context(sig.context),\n-        signo(signo_),\n-        write_flag(sig.write_flag),\n-        is_memory_access(sig.is_memory_access) {\n+  ErrorDeadlySignal(u32 tid, const SignalContext &sig)\n+      : ErrorBase(tid), signal(sig) {\n     scariness.Clear();\n-    if (is_memory_access) {\n-      if (addr < GetPageSizeCached()) {\n-        scariness.Scare(10, \"null-deref\");\n-      } else if (addr == pc) {\n-        scariness.Scare(60, \"wild-jump\");\n-      } else if (write_flag == SignalContext::WRITE) {\n-        scariness.Scare(30, \"wild-addr-write\");\n-      } else if (write_flag == SignalContext::READ) {\n-        scariness.Scare(20, \"wild-addr-read\");\n-      } else {\n-        scariness.Scare(25, \"wild-addr\");\n-      }\n-    } else {\n+    if (signal.IsStackOverflow()) {\n+      scariness.Scare(10, \"stack-overflow\");\n+    } else if (!signal.is_memory_access) {\n       scariness.Scare(10, \"signal\");\n+    } else if (signal.addr < GetPageSizeCached()) {\n+      scariness.Scare(10, \"null-deref\");\n+    } else if (signal.addr == signal.pc) {\n+      scariness.Scare(60, \"wild-jump\");\n+    } else if (signal.write_flag == SignalContext::WRITE) {\n+      scariness.Scare(30, \"wild-addr-write\");\n+    } else if (signal.write_flag == SignalContext::READ) {\n+      scariness.Scare(20, \"wild-addr-read\");\n+    } else {\n+      scariness.Scare(25, \"wild-addr\");\n     }\n   }\n   void Print();\n@@ -170,6 +137,7 @@ struct ErrorMallocUsableSizeNotOwned : ErrorBase {\n         stack(stack_),\n         addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n     scariness.Clear();\n+    scariness.Scare(10, \"bad-malloc_usable_size\");\n   }\n   void Print();\n };\n@@ -187,6 +155,7 @@ struct ErrorSanitizerGetAllocatedSizeNotOwned : ErrorBase {\n         stack(stack_),\n         addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n     scariness.Clear();\n+    scariness.Scare(10, \"bad-__sanitizer_get_allocated_size\");\n   }\n   void Print();\n };\n@@ -256,7 +225,10 @@ struct ErrorBadParamsToAnnotateContiguousContainer : ErrorBase {\n         beg(beg_),\n         end(end_),\n         old_mid(old_mid_),\n-        new_mid(new_mid_) {}\n+        new_mid(new_mid_) {\n+    scariness.Clear();\n+    scariness.Scare(10, \"bad-__sanitizer_annotate_contiguous_container\");\n+  }\n   void Print();\n };\n \n@@ -272,7 +244,10 @@ struct ErrorODRViolation : ErrorBase {\n         global1(*g1),\n         global2(*g2),\n         stack_id1(stack_id1_),\n-        stack_id2(stack_id2_) {}\n+        stack_id2(stack_id2_) {\n+    scariness.Clear();\n+    scariness.Scare(10, \"odr-violation\");\n+  }\n   void Print();\n };\n \n@@ -290,7 +265,10 @@ struct ErrorInvalidPointerPair : ErrorBase {\n         bp(bp_),\n         sp(sp_),\n         addr1_description(p1, 1, /*shouldLockThreadRegistry=*/false),\n-        addr2_description(p2, 1, /*shouldLockThreadRegistry=*/false) {}\n+        addr2_description(p2, 1, /*shouldLockThreadRegistry=*/false)  {\n+    scariness.Clear();\n+    scariness.Scare(10, \"invalid-pointer-pair\");\n+  }\n   void Print();\n };\n \n@@ -311,7 +289,6 @@ struct ErrorGeneric : ErrorBase {\n \n // clang-format off\n #define ASAN_FOR_EACH_ERROR_KIND(macro)         \\\n-  macro(StackOverflow)                          \\\n   macro(DeadlySignal)                           \\\n   macro(DoubleFree)                             \\\n   macro(NewDeleteSizeMismatch)                  \\\n@@ -348,6 +325,7 @@ struct ErrorDescription {\n   // We can add a wrapper around it to make it \"more c++-like\", but that would\n   // add a lot of code and the benefit wouldn't be that big.\n   union {\n+    ErrorBase Base;\n     ASAN_FOR_EACH_ERROR_KIND(ASAN_ERROR_DESCRIPTION_MEMBER)\n   };\n "}, {"sha": "3140f9a2aebe46c7da1664dc47991b8668591f01", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -169,7 +169,7 @@ void FakeStack::ForEachFakeFrame(RangeIteratorCallback callback, void *arg) {\n   }\n }\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_FUCHSIA\n static THREADLOCAL FakeStack *fake_stack_tls;\n \n FakeStack *GetTLSFakeStack() {\n@@ -181,7 +181,7 @@ void SetTLSFakeStack(FakeStack *fs) {\n #else\n FakeStack *GetTLSFakeStack() { return 0; }\n void SetTLSFakeStack(FakeStack *fs) { }\n-#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#endif  // (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_FUCHSIA\n \n static FakeStack *GetFakeStack() {\n   AsanThread *t = GetCurrentThread();"}, {"sha": "0c83dac6747eb85af9b7354f51149b15e206265b", "filename": "libsanitizer/asan/asan_flags.cc", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -59,7 +59,7 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.detect_leaks = CAN_SANITIZE_LEAKS;\n+    cf.detect_leaks = cf.detect_leaks && CAN_SANITIZE_LEAKS;\n     cf.external_symbolizer_path = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n     cf.malloc_context_size = kDefaultMallocContextSize;\n     cf.intercept_tls_get_addr = true;\n@@ -93,6 +93,18 @@ void InitializeFlags() {\n   RegisterCommonFlags(&ubsan_parser);\n #endif\n \n+  if (SANITIZER_MAC) {\n+    // Support macOS MallocScribble and MallocPreScribble:\n+    // <https://developer.apple.com/library/content/documentation/Performance/\n+    // Conceptual/ManagingMemory/Articles/MallocDebug.html>\n+    if (GetEnv(\"MallocScribble\")) {\n+      f->max_free_fill_size = 0x1000;\n+    }\n+    if (GetEnv(\"MallocPreScribble\")) {\n+      f->malloc_fill_byte = 0xaa;\n+    }\n+  }\n+\n   // Override from ASan compile definition.\n   const char *asan_compile_def = MaybeUseAsanDefaultOptionsCompileDefinition();\n   asan_parser.ParseString(asan_compile_def);\n@@ -104,6 +116,10 @@ void InitializeFlags() {\n   const char *ubsan_default_options = __ubsan::MaybeCallUbsanDefaultOptions();\n   ubsan_parser.ParseString(ubsan_default_options);\n #endif\n+#if CAN_SANITIZE_LEAKS\n+  const char *lsan_default_options = __lsan::MaybeCallLsanDefaultOptions();\n+  lsan_parser.ParseString(lsan_default_options);\n+#endif\n \n   // Override from command line.\n   asan_parser.ParseString(GetEnv(\"ASAN_OPTIONS\"));\n@@ -154,9 +170,24 @@ void InitializeFlags() {\n     f->quarantine_size_mb = f->quarantine_size >> 20;\n   if (f->quarantine_size_mb < 0) {\n     const int kDefaultQuarantineSizeMb =\n-        (ASAN_LOW_MEMORY) ? 1UL << 6 : 1UL << 8;\n+        (ASAN_LOW_MEMORY) ? 1UL << 4 : 1UL << 8;\n     f->quarantine_size_mb = kDefaultQuarantineSizeMb;\n   }\n+  if (f->thread_local_quarantine_size_kb < 0) {\n+    const u32 kDefaultThreadLocalQuarantineSizeKb =\n+        // It is not advised to go lower than 64Kb, otherwise quarantine batches\n+        // pushed from thread local quarantine to global one will create too\n+        // much overhead. One quarantine batch size is 8Kb and it  holds up to\n+        // 1021 chunk, which amounts to 1/8 memory overhead per batch when\n+        // thread local quarantine is set to 64Kb.\n+        (ASAN_LOW_MEMORY) ? 1 << 6 : FIRST_32_SECOND_64(1 << 8, 1 << 10);\n+    f->thread_local_quarantine_size_kb = kDefaultThreadLocalQuarantineSizeKb;\n+  }\n+  if (f->thread_local_quarantine_size_kb == 0 && f->quarantine_size_mb > 0) {\n+    Report(\"%s: thread_local_quarantine_size_kb can be set to 0 only when \"\n+           \"quarantine_size_mb is set to 0\\n\", SanitizerToolName);\n+    Die();\n+  }\n   if (!f->replace_str && common_flags()->intercept_strlen) {\n     Report(\"WARNING: strlen interceptor is enabled even though replace_str=0. \"\n            \"Use intercept_strlen=0 to disable it.\");\n@@ -165,13 +196,14 @@ void InitializeFlags() {\n     Report(\"WARNING: strchr* interceptors are enabled even though \"\n            \"replace_str=0. Use intercept_strchr=0 to disable them.\");\n   }\n+  if (!f->replace_str && common_flags()->intercept_strndup) {\n+    Report(\"WARNING: strndup* interceptors are enabled even though \"\n+           \"replace_str=0. Use intercept_strndup=0 to disable them.\");\n+  }\n }\n \n }  // namespace __asan\n \n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-const char* __asan_default_options() { return \"\"; }\n-}  // extern \"C\"\n-#endif\n+SANITIZER_INTERFACE_WEAK_DEF(const char*, __asan_default_options, void) {\n+  return \"\";\n+}"}, {"sha": "3784f065be6bc4f07d984c03533da889e0a9e799", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -21,6 +21,12 @@ ASAN_FLAG(int, quarantine_size_mb, -1,\n           \"Size (in Mb) of quarantine used to detect use-after-free \"\n           \"errors. Lower value may reduce memory usage but increase the \"\n           \"chance of false negatives.\")\n+ASAN_FLAG(int, thread_local_quarantine_size_kb, -1,\n+          \"Size (in Kb) of thread local quarantine used to detect \"\n+          \"use-after-free errors. Lower value may reduce memory usage but \"\n+          \"increase the chance of false negatives. It is not advised to go \"\n+          \"lower than 64Kb, otherwise frequent transfers to global quarantine \"\n+          \"might affect performance.\")\n ASAN_FLAG(int, redzone, 16,\n           \"Minimal size (in bytes) of redzones around heap objects. \"\n           \"Requirement: redzone >= 16, is a power of two.\")\n@@ -55,8 +61,14 @@ ASAN_FLAG(\n     int, max_malloc_fill_size, 0x1000,  // By default, fill only the first 4K.\n     \"ASan allocator flag. max_malloc_fill_size is the maximal amount of \"\n     \"bytes that will be filled with malloc_fill_byte on malloc.\")\n+ASAN_FLAG(\n+    int, max_free_fill_size, 0,\n+    \"ASan allocator flag. max_free_fill_size is the maximal amount of \"\n+    \"bytes that will be filled with free_fill_byte during free.\")\n ASAN_FLAG(int, malloc_fill_byte, 0xbe,\n           \"Value used to fill the newly allocated memory.\")\n+ASAN_FLAG(int, free_fill_byte, 0x55,\n+          \"Value used to fill deallocated memory.\")\n ASAN_FLAG(bool, allow_user_poisoning, true,\n           \"If set, user may manually mark memory regions as poisoned or \"\n           \"unpoisoned.\")\n@@ -65,6 +77,10 @@ ASAN_FLAG(\n     \"Number of seconds to sleep between printing an error report and \"\n     \"terminating the program. Useful for debugging purposes (e.g. when one \"\n     \"needs to attach gdb).\")\n+ASAN_FLAG(\n+    int, sleep_after_init, 0,\n+    \"Number of seconds to sleep after AddressSanitizer is initialized. \"\n+    \"Useful for debugging purposes (e.g. when one needs to attach gdb).\")\n ASAN_FLAG(bool, check_malloc_usable_size, true,\n           \"Allows the users to work around the bug in Nvidia drivers prior to \"\n           \"295.*.\")\n@@ -129,11 +145,16 @@ ASAN_FLAG(int, detect_odr_violation, 2,\n           \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n           \"If ==1, detect ODR-violation only if the two variables \"\n           \"have different sizes\")\n-ASAN_FLAG(bool, dump_instruction_bytes, false,\n-          \"If true, dump 16 bytes starting at the instruction that caused SEGV\")\n ASAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n ASAN_FLAG(bool, halt_on_error, true,\n           \"Crash the program after printing the first error report \"\n           \"(WARNING: USE AT YOUR OWN RISK!)\")\n ASAN_FLAG(bool, use_odr_indicator, false,\n           \"Use special ODR indicator symbol for ODR violation detection\")\n+ASAN_FLAG(bool, allocator_frees_and_returns_null_on_realloc_zero, true,\n+          \"realloc(p, 0) is equivalent to free(p) by default (Same as the \"\n+          \"POSIX standard). If set to false, realloc(p, 0) will return a \"\n+          \"pointer to an allocated space which can not be used.\")\n+ASAN_FLAG(bool, verify_asan_link_order, true,\n+          \"Check position of ASan runtime in library list (needs to be disabled\"\n+          \" when other library has to be preloaded system-wide)\")"}, {"sha": "6b1b48921ef522d06ef7b662ab091dc967b29ef1", "filename": "libsanitizer/asan/asan_fuchsia.cc", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fuchsia.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,216 @@\n+//===-- asan_fuchsia.cc --------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Fuchsia-specific details.\n+//===---------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_fuchsia.h\"\n+#if SANITIZER_FUCHSIA\n+\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_thread.h\"\n+\n+#include <limits.h>\n+#include <zircon/sanitizer.h>\n+#include <zircon/syscalls.h>\n+#include <zircon/threads.h>\n+\n+namespace __asan {\n+\n+// The system already set up the shadow memory for us.\n+// __sanitizer::GetMaxVirtualAddress has already been called by\n+// AsanInitInternal->InitializeHighMemEnd (asan_rtl.cc).\n+// Just do some additional sanity checks here.\n+void InitializeShadowMemory() {\n+  if (Verbosity()) PrintAddressSpaceLayout();\n+\n+  // Make sure SHADOW_OFFSET doesn't use __asan_shadow_memory_dynamic_address.\n+  __asan_shadow_memory_dynamic_address = kDefaultShadowSentinel;\n+  DCHECK(kLowShadowBeg != kDefaultShadowSentinel);\n+  __asan_shadow_memory_dynamic_address = kLowShadowBeg;\n+\n+  CHECK_EQ(kShadowGapEnd, kHighShadowBeg - 1);\n+  CHECK_EQ(kHighMemEnd, __sanitizer::ShadowBounds.memory_limit - 1);\n+  CHECK_EQ(kHighMemBeg, __sanitizer::ShadowBounds.shadow_limit);\n+  CHECK_EQ(kHighShadowBeg, __sanitizer::ShadowBounds.shadow_base);\n+  CHECK_EQ(kShadowGapEnd, __sanitizer::ShadowBounds.shadow_base - 1);\n+  CHECK_EQ(kLowShadowEnd, 0);\n+  CHECK_EQ(kLowShadowBeg, 0);\n+}\n+\n+void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n+  UNIMPLEMENTED();\n+}\n+\n+void AsanCheckDynamicRTPrereqs() {}\n+void AsanCheckIncompatibleRT() {}\n+void InitializeAsanInterceptors() {}\n+\n+void *AsanDoesNotSupportStaticLinkage() { return nullptr; }\n+\n+void InitializePlatformExceptionHandlers() {}\n+void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n+  UNIMPLEMENTED();\n+}\n+\n+// We can use a plain thread_local variable for TSD.\n+static thread_local void *per_thread;\n+\n+void *AsanTSDGet() { return per_thread; }\n+\n+void AsanTSDSet(void *tsd) { per_thread = tsd; }\n+\n+// There's no initialization needed, and the passed-in destructor\n+// will never be called.  Instead, our own thread destruction hook\n+// (below) will call AsanThread::TSDDtor directly.\n+void AsanTSDInit(void (*destructor)(void *tsd)) {\n+  DCHECK(destructor == &PlatformTSDDtor);\n+}\n+\n+void PlatformTSDDtor(void *tsd) { UNREACHABLE(__func__); }\n+\n+static inline size_t AsanThreadMmapSize() {\n+  return RoundUpTo(sizeof(AsanThread), PAGE_SIZE);\n+}\n+\n+struct AsanThread::InitOptions {\n+  uptr stack_bottom, stack_size;\n+};\n+\n+// Shared setup between thread creation and startup for the initial thread.\n+static AsanThread *CreateAsanThread(StackTrace *stack, u32 parent_tid,\n+                                    uptr user_id, bool detached,\n+                                    const char *name, uptr stack_bottom,\n+                                    uptr stack_size) {\n+  // In lieu of AsanThread::Create.\n+  AsanThread *thread = (AsanThread *)MmapOrDie(AsanThreadMmapSize(), __func__);\n+\n+  AsanThreadContext::CreateThreadContextArgs args = {thread, stack};\n+  u32 tid =\n+      asanThreadRegistry().CreateThread(user_id, detached, parent_tid, &args);\n+  asanThreadRegistry().SetThreadName(tid, name);\n+\n+  // On other systems, AsanThread::Init() is called from the new\n+  // thread itself.  But on Fuchsia we already know the stack address\n+  // range beforehand, so we can do most of the setup right now.\n+  const AsanThread::InitOptions options = {stack_bottom, stack_size};\n+  thread->Init(&options);\n+\n+  return thread;\n+}\n+\n+// This gets the same arguments passed to Init by CreateAsanThread, above.\n+// We're in the creator thread before the new thread is actually started,\n+// but its stack address range is already known.  We don't bother tracking\n+// the static TLS address range because the system itself already uses an\n+// ASan-aware allocator for that.\n+void AsanThread::SetThreadStackAndTls(const AsanThread::InitOptions *options) {\n+  DCHECK_NE(GetCurrentThread(), this);\n+  DCHECK_NE(GetCurrentThread(), nullptr);\n+  CHECK_NE(options->stack_bottom, 0);\n+  CHECK_NE(options->stack_size, 0);\n+  stack_bottom_ = options->stack_bottom;\n+  stack_top_ = options->stack_bottom + options->stack_size;\n+}\n+\n+// Called by __asan::AsanInitInternal (asan_rtl.c).\n+AsanThread *CreateMainThread() {\n+  thrd_t self = thrd_current();\n+  char name[ZX_MAX_NAME_LEN];\n+  CHECK_NE(__sanitizer::MainThreadStackBase, 0);\n+  CHECK_GT(__sanitizer::MainThreadStackSize, 0);\n+  AsanThread *t = CreateAsanThread(\n+      nullptr, 0, reinterpret_cast<uptr>(self), true,\n+      _zx_object_get_property(thrd_get_zx_handle(self), ZX_PROP_NAME, name,\n+                              sizeof(name)) == ZX_OK\n+          ? name\n+          : nullptr,\n+      __sanitizer::MainThreadStackBase, __sanitizer::MainThreadStackSize);\n+  SetCurrentThread(t);\n+  return t;\n+}\n+\n+// This is called before each thread creation is attempted.  So, in\n+// its first call, the calling thread is the initial and sole thread.\n+static void *BeforeThreadCreateHook(uptr user_id, bool detached,\n+                                    const char *name, uptr stack_bottom,\n+                                    uptr stack_size) {\n+  EnsureMainThreadIDIsCorrect();\n+  // Strict init-order checking is thread-hostile.\n+  if (flags()->strict_init_order) StopInitOrderChecking();\n+\n+  GET_STACK_TRACE_THREAD;\n+  u32 parent_tid = GetCurrentTidOrInvalid();\n+\n+  return CreateAsanThread(&stack, parent_tid, user_id, detached, name,\n+                          stack_bottom, stack_size);\n+}\n+\n+// This is called after creating a new thread (in the creating thread),\n+// with the pointer returned by BeforeThreadCreateHook (above).\n+static void ThreadCreateHook(void *hook, bool aborted) {\n+  AsanThread *thread = static_cast<AsanThread *>(hook);\n+  if (!aborted) {\n+    // The thread was created successfully.\n+    // ThreadStartHook is already running in the new thread.\n+  } else {\n+    // The thread wasn't created after all.\n+    // Clean up everything we set up in BeforeThreadCreateHook.\n+    asanThreadRegistry().FinishThread(thread->tid());\n+    UnmapOrDie(thread, AsanThreadMmapSize());\n+  }\n+}\n+\n+// This is called in the newly-created thread before it runs anything else,\n+// with the pointer returned by BeforeThreadCreateHook (above).\n+// cf. asan_interceptors.cc:asan_thread_start\n+static void ThreadStartHook(void *hook, uptr os_id) {\n+  AsanThread *thread = static_cast<AsanThread *>(hook);\n+  SetCurrentThread(thread);\n+\n+  // In lieu of AsanThread::ThreadStart.\n+  asanThreadRegistry().StartThread(thread->tid(), os_id, /*workerthread*/ false,\n+                                   nullptr);\n+}\n+\n+// Each thread runs this just before it exits,\n+// with the pointer returned by BeforeThreadCreateHook (above).\n+// All per-thread destructors have already been called.\n+static void ThreadExitHook(void *hook, uptr os_id) {\n+  AsanThread::TSDDtor(per_thread);\n+}\n+\n+}  // namespace __asan\n+\n+// These are declared (in extern \"C\") by <zircon/sanitizer.h>.\n+// The system runtime will call our definitions directly.\n+\n+void *__sanitizer_before_thread_create_hook(thrd_t thread, bool detached,\n+                                            const char *name, void *stack_base,\n+                                            size_t stack_size) {\n+  return __asan::BeforeThreadCreateHook(\n+      reinterpret_cast<uptr>(thread), detached, name,\n+      reinterpret_cast<uptr>(stack_base), stack_size);\n+}\n+\n+void __sanitizer_thread_create_hook(void *hook, thrd_t thread, int error) {\n+  __asan::ThreadCreateHook(hook, error != thrd_success);\n+}\n+\n+void __sanitizer_thread_start_hook(void *hook, thrd_t self) {\n+  __asan::ThreadStartHook(hook, reinterpret_cast<uptr>(self));\n+}\n+\n+void __sanitizer_thread_exit_hook(void *hook, thrd_t self) {\n+  __asan::ThreadExitHook(hook, reinterpret_cast<uptr>(self));\n+}\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "c33b0ac75612a407064fecd214d9e2d61121b255", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -311,6 +311,26 @@ void __asan_unregister_image_globals(uptr *flag) {\n   *flag = 0;\n }\n \n+void __asan_register_elf_globals(uptr *flag, void *start, void *stop) {\n+  if (*flag) return;\n+  if (!start) return;\n+  CHECK_EQ(0, ((uptr)stop - (uptr)start) % sizeof(__asan_global));\n+  __asan_global *globals_start = (__asan_global*)start;\n+  __asan_global *globals_stop = (__asan_global*)stop;\n+  __asan_register_globals(globals_start, globals_stop - globals_start);\n+  *flag = 1;\n+}\n+\n+void __asan_unregister_elf_globals(uptr *flag, void *start, void *stop) {\n+  if (!*flag) return;\n+  if (!start) return;\n+  CHECK_EQ(0, ((uptr)stop - (uptr)start) % sizeof(__asan_global));\n+  __asan_global *globals_start = (__asan_global*)start;\n+  __asan_global *globals_stop = (__asan_global*)stop;\n+  __asan_unregister_globals(globals_start, globals_stop - globals_start);\n+  *flag = 0;\n+}\n+\n // Register an array of globals.\n void __asan_register_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n@@ -327,8 +347,26 @@ void __asan_register_globals(__asan_global *globals, uptr n) {\n     Printf(\"=== ID %d; %p %p\\n\", stack_id, &globals[0], &globals[n - 1]);\n   }\n   for (uptr i = 0; i < n; i++) {\n+    if (SANITIZER_WINDOWS && globals[i].beg == 0) {\n+      // The MSVC incremental linker may pad globals out to 256 bytes. As long\n+      // as __asan_global is less than 256 bytes large and its size is a power\n+      // of two, we can skip over the padding.\n+      static_assert(\n+          sizeof(__asan_global) < 256 &&\n+              (sizeof(__asan_global) & (sizeof(__asan_global) - 1)) == 0,\n+          \"sizeof(__asan_global) incompatible with incremental linker padding\");\n+      // If these are padding bytes, the rest of the global should be zero.\n+      CHECK(globals[i].size == 0 && globals[i].size_with_redzone == 0 &&\n+            globals[i].name == nullptr && globals[i].module_name == nullptr &&\n+            globals[i].odr_indicator == 0);\n+      continue;\n+    }\n     RegisterGlobal(&globals[i]);\n   }\n+\n+  // Poison the metadata. It should not be accessible to user code.\n+  PoisonShadow(reinterpret_cast<uptr>(globals), n * sizeof(__asan_global),\n+               kAsanGlobalRedzoneMagic);\n }\n \n // Unregister an array of globals.\n@@ -337,8 +375,16 @@ void __asan_unregister_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n   BlockingMutexLock lock(&mu_for_globals);\n   for (uptr i = 0; i < n; i++) {\n+    if (SANITIZER_WINDOWS && globals[i].beg == 0) {\n+      // Skip globals that look like padding from the MSVC incremental linker.\n+      // See comment in __asan_register_globals.\n+      continue;\n+    }\n     UnregisterGlobal(&globals[i]);\n   }\n+\n+  // Unpoison the metadata.\n+  PoisonShadow(reinterpret_cast<uptr>(globals), n * sizeof(__asan_global), 0);\n }\n \n // This method runs immediately prior to dynamic initialization in each TU,"}, {"sha": "118c0ac991c980d0e974ddb26b40201398dec3d8", "filename": "libsanitizer/asan/asan_globals_win.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_globals_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_globals_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals_win.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,60 @@\n+//===-- asan_globals_win.cc -----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Global registration code that is linked into every Windows DLL and EXE.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_interface_internal.h\"\n+#if SANITIZER_WINDOWS\n+\n+namespace __asan {\n+\n+#pragma section(\".ASAN$GA\", read, write)  // NOLINT\n+#pragma section(\".ASAN$GZ\", read, write)  // NOLINT\n+extern \"C\" __declspec(allocate(\".ASAN$GA\"))\n+__asan_global __asan_globals_start = {};\n+extern \"C\" __declspec(allocate(\".ASAN$GZ\"))\n+__asan_global __asan_globals_end = {};\n+#pragma comment(linker, \"/merge:.ASAN=.data\")\n+\n+static void call_on_globals(void (*hook)(__asan_global *, uptr)) {\n+  __asan_global *start = &__asan_globals_start + 1;\n+  __asan_global *end = &__asan_globals_end;\n+  uptr bytediff = (uptr)end - (uptr)start;\n+  if (bytediff % sizeof(__asan_global) != 0) {\n+#ifdef SANITIZER_DLL_THUNK\n+    __debugbreak();\n+#else\n+    CHECK(\"corrupt asan global array\");\n+#endif\n+  }\n+  // We know end >= start because the linker sorts the portion after the dollar\n+  // sign alphabetically.\n+  uptr n = end - start;\n+  hook(start, n);\n+}\n+\n+static void register_dso_globals() {\n+  call_on_globals(&__asan_register_globals);\n+}\n+\n+static void unregister_dso_globals() {\n+  call_on_globals(&__asan_unregister_globals);\n+}\n+\n+// Register globals\n+#pragma section(\".CRT$XCU\", long, read)  // NOLINT\n+#pragma section(\".CRT$XTX\", long, read)  // NOLINT\n+extern \"C\" __declspec(allocate(\".CRT$XCU\"))\n+void (*const __asan_dso_reg_hook)() = &register_dso_globals;\n+extern \"C\" __declspec(allocate(\".CRT$XTX\"))\n+void (*const __asan_dso_unreg_hook)() = &unregister_dso_globals;\n+\n+} // namespace __asan\n+\n+#endif  // SANITIZER_WINDOWS"}, {"sha": "a8f4b72723fe8eb13e4422ce10e8586df9ffe876", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 56, "deletions": 236, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -22,6 +22,11 @@\n #include \"lsan/lsan_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n+// There is no general interception at all on Fuchsia.\n+// Only the functions in asan_interceptors_memintrinsics.cc are\n+// really defined to replace libc functions.\n+#if !SANITIZER_FUCHSIA\n+\n #if SANITIZER_POSIX\n #include \"sanitizer_common/sanitizer_posix.h\"\n #endif\n@@ -34,80 +39,13 @@\n \n namespace __asan {\n \n-// Return true if we can quickly decide that the region is unpoisoned.\n-static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n-  if (size == 0) return true;\n-  if (size <= 32)\n-    return !AddressIsPoisoned(beg) &&\n-           !AddressIsPoisoned(beg + size - 1) &&\n-           !AddressIsPoisoned(beg + size / 2);\n-  return false;\n-}\n-\n-struct AsanInterceptorContext {\n-  const char *interceptor_name;\n-};\n-\n-// We implement ACCESS_MEMORY_RANGE, ASAN_READ_RANGE,\n-// and ASAN_WRITE_RANGE as macro instead of function so\n-// that no extra frames are created, and stack trace contains\n-// relevant information only.\n-// We check all shadow bytes.\n-#define ACCESS_MEMORY_RANGE(ctx, offset, size, isWrite) do {            \\\n-    uptr __offset = (uptr)(offset);                                     \\\n-    uptr __size = (uptr)(size);                                         \\\n-    uptr __bad = 0;                                                     \\\n-    if (__offset > __offset + __size) {                                 \\\n-      GET_STACK_TRACE_FATAL_HERE;                                       \\\n-      ReportStringFunctionSizeOverflow(__offset, __size, &stack);       \\\n-    }                                                                   \\\n-    if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n-        (__bad = __asan_region_is_poisoned(__offset, __size))) {        \\\n-      AsanInterceptorContext *_ctx = (AsanInterceptorContext *)ctx;     \\\n-      bool suppressed = false;                                          \\\n-      if (_ctx) {                                                       \\\n-        suppressed = IsInterceptorSuppressed(_ctx->interceptor_name);   \\\n-        if (!suppressed && HaveStackTraceBasedSuppressions()) {         \\\n-          GET_STACK_TRACE_FATAL_HERE;                                   \\\n-          suppressed = IsStackTraceSuppressed(&stack);                  \\\n-        }                                                               \\\n-      }                                                                 \\\n-      if (!suppressed) {                                                \\\n-        GET_CURRENT_PC_BP_SP;                                           \\\n-        ReportGenericError(pc, bp, sp, __bad, isWrite, __size, 0, false);\\\n-      }                                                                 \\\n-    }                                                                   \\\n-  } while (0)\n-\n-#define ASAN_READ_RANGE(ctx, offset, size) \\\n-  ACCESS_MEMORY_RANGE(ctx, offset, size, false)\n-#define ASAN_WRITE_RANGE(ctx, offset, size) \\\n-  ACCESS_MEMORY_RANGE(ctx, offset, size, true)\n-\n #define ASAN_READ_STRING_OF_LEN(ctx, s, len, n)                 \\\n   ASAN_READ_RANGE((ctx), (s),                                   \\\n     common_flags()->strict_string_checks ? (len) + 1 : (n))\n \n #define ASAN_READ_STRING(ctx, s, n)                             \\\n   ASAN_READ_STRING_OF_LEN((ctx), (s), REAL(strlen)(s), (n))\n \n-// Behavior of functions like \"memcpy\" or \"strcpy\" is undefined\n-// if memory intervals overlap. We report error in this case.\n-// Macro is used to avoid creation of new frames.\n-static inline bool RangesOverlap(const char *offset1, uptr length1,\n-                                 const char *offset2, uptr length2) {\n-  return !((offset1 + length1 <= offset2) || (offset2 + length2 <= offset1));\n-}\n-#define CHECK_RANGES_OVERLAP(name, _offset1, length1, _offset2, length2) do { \\\n-  const char *offset1 = (const char*)_offset1; \\\n-  const char *offset2 = (const char*)_offset2; \\\n-  if (RangesOverlap(offset1, length1, offset2, length2)) { \\\n-    GET_STACK_TRACE_FATAL_HERE; \\\n-    ReportStringFunctionMemoryRangesOverlap(name, offset1, length1, \\\n-                                            offset2, length2, &stack); \\\n-  } \\\n-} while (0)\n-\n static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n #if SANITIZER_INTERCEPT_STRNLEN\n   if (REAL(strnlen)) {\n@@ -124,6 +62,10 @@ void SetThreadName(const char *name) {\n }\n \n int OnExit() {\n+  if (CAN_SANITIZE_LEAKS && common_flags()->detect_leaks &&\n+      __lsan::HasReportedLeaks()) {\n+    return common_flags()->exitcode;\n+  }\n   // FIXME: ask frontend whether we need to return failure.\n   return 0;\n }\n@@ -181,13 +123,14 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n // Strict init-order checking is dlopen-hostile:\n // https://github.com/google/sanitizers/issues/178\n #define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag)                           \\\n-  if (flags()->strict_init_order) {                                            \\\n-    StopInitOrderChecking();                                                   \\\n-  }\n+  do {                                                                         \\\n+    if (flags()->strict_init_order)                                            \\\n+      StopInitOrderChecking();                                                 \\\n+    CheckNoDeepBind(filename, flag);                                           \\\n+  } while (false)\n #define COMMON_INTERCEPTOR_ON_EXIT(ctx) OnExit()\n-#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) \\\n-  CoverageUpdateMapping()\n-#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() CoverageUpdateMapping()\n+#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle)\n+#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED()\n #define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (!asan_inited)\n #define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end)                           \\\n   if (AsanThread *t = GetCurrentThread()) {                                    \\\n@@ -196,11 +139,27 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   } else {                                                                     \\\n     *begin = *end = 0;                                                         \\\n   }\n-// Asan needs custom handling of these:\n-#undef SANITIZER_INTERCEPT_MEMSET\n-#undef SANITIZER_INTERCEPT_MEMMOVE\n-#undef SANITIZER_INTERCEPT_MEMCPY\n+\n+#define COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size) \\\n+  do {                                                       \\\n+    ASAN_INTERCEPTOR_ENTER(ctx, memmove);                    \\\n+    ASAN_MEMMOVE_IMPL(ctx, to, from, size);                  \\\n+  } while (false)\n+\n+#define COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size) \\\n+  do {                                                      \\\n+    ASAN_INTERCEPTOR_ENTER(ctx, memcpy);                    \\\n+    ASAN_MEMCPY_IMPL(ctx, to, from, size);                  \\\n+  } while (false)\n+\n+#define COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size) \\\n+  do {                                                      \\\n+    ASAN_INTERCEPTOR_ENTER(ctx, memset);                    \\\n+    ASAN_MEMSET_IMPL(ctx, block, c, size);                  \\\n+  } while (false)\n+\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n+#include \"sanitizer_common/sanitizer_signal_interceptors.inc\"\n \n // Syscall interceptors don't have contexts, we don't support suppressions\n // for them.\n@@ -282,48 +241,6 @@ INTERCEPTOR(int, pthread_join, void *t, void **arg) {\n DEFINE_REAL_PTHREAD_FUNCTIONS\n #endif  // ASAN_INTERCEPT_PTHREAD_CREATE\n \n-#if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n-\n-#if SANITIZER_ANDROID\n-INTERCEPTOR(void*, bsd_signal, int signum, void *handler) {\n-  if (!IsHandledDeadlySignal(signum) ||\n-      common_flags()->allow_user_segv_handler) {\n-    return REAL(bsd_signal)(signum, handler);\n-  }\n-  return 0;\n-}\n-#endif\n-\n-INTERCEPTOR(void*, signal, int signum, void *handler) {\n-  if (!IsHandledDeadlySignal(signum) ||\n-      common_flags()->allow_user_segv_handler) {\n-    return REAL(signal)(signum, handler);\n-  }\n-  return nullptr;\n-}\n-\n-INTERCEPTOR(int, sigaction, int signum, const struct sigaction *act,\n-                            struct sigaction *oldact) {\n-  if (!IsHandledDeadlySignal(signum) ||\n-      common_flags()->allow_user_segv_handler) {\n-    return REAL(sigaction)(signum, act, oldact);\n-  }\n-  return 0;\n-}\n-\n-namespace __sanitizer {\n-int real_sigaction(int signum, const void *act, void *oldact) {\n-  return REAL(sigaction)(signum, (const struct sigaction *)act,\n-                         (struct sigaction *)oldact);\n-}\n-} // namespace __sanitizer\n-\n-#elif SANITIZER_POSIX\n-// We need to have defined REAL(sigaction) on posix systems.\n-DEFINE_REAL(int, sigaction, int signum, const struct sigaction *act,\n-    struct sigaction *oldact)\n-#endif  // ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n-\n #if ASAN_INTERCEPT_SWAPCONTEXT\n static void ClearShadowMemoryForContextStack(uptr stack, uptr ssize) {\n   // Align to page size.\n@@ -360,6 +277,11 @@ INTERCEPTOR(int, swapcontext, struct ucontext_t *oucp,\n }\n #endif  // ASAN_INTERCEPT_SWAPCONTEXT\n \n+#if SANITIZER_NETBSD\n+#define longjmp __longjmp14\n+#define siglongjmp __siglongjmp14\n+#endif\n+\n INTERCEPTOR(void, longjmp, void *env, int val) {\n   __asan_handle_no_return();\n   REAL(longjmp)(env, val);\n@@ -372,6 +294,13 @@ INTERCEPTOR(void, _longjmp, void *env, int val) {\n }\n #endif\n \n+#if ASAN_INTERCEPT___LONGJMP_CHK\n+INTERCEPTOR(void, __longjmp_chk, void *env, int val) {\n+  __asan_handle_no_return();\n+  REAL(__longjmp_chk)(env, val);\n+}\n+#endif\n+\n #if ASAN_INTERCEPT_SIGLONGJMP\n INTERCEPTOR(void, siglongjmp, void *env, int val) {\n   __asan_handle_no_return();\n@@ -387,90 +316,6 @@ INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n }\n #endif\n \n-// memcpy is called during __asan_init() from the internals of printf(...).\n-// We do not treat memcpy with to==from as a bug.\n-// See http://llvm.org/bugs/show_bug.cgi?id=11763.\n-#define ASAN_MEMCPY_IMPL(ctx, to, from, size) do {                             \\\n-    if (UNLIKELY(!asan_inited)) return internal_memcpy(to, from, size);        \\\n-    if (asan_init_is_running) {                                                \\\n-      return REAL(memcpy)(to, from, size);                                     \\\n-    }                                                                          \\\n-    ENSURE_ASAN_INITED();                                                      \\\n-    if (flags()->replace_intrin) {                                             \\\n-      if (to != from) {                                                        \\\n-        CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size);                  \\\n-      }                                                                        \\\n-      ASAN_READ_RANGE(ctx, from, size);                                        \\\n-      ASAN_WRITE_RANGE(ctx, to, size);                                         \\\n-    }                                                                          \\\n-    return REAL(memcpy)(to, from, size);                                       \\\n-  } while (0)\n-\n-\n-void *__asan_memcpy(void *to, const void *from, uptr size) {\n-  ASAN_MEMCPY_IMPL(nullptr, to, from, size);\n-}\n-\n-// memset is called inside Printf.\n-#define ASAN_MEMSET_IMPL(ctx, block, c, size) do {                             \\\n-    if (UNLIKELY(!asan_inited)) return internal_memset(block, c, size);        \\\n-    if (asan_init_is_running) {                                                \\\n-      return REAL(memset)(block, c, size);                                     \\\n-    }                                                                          \\\n-    ENSURE_ASAN_INITED();                                                      \\\n-    if (flags()->replace_intrin) {                                             \\\n-      ASAN_WRITE_RANGE(ctx, block, size);                                      \\\n-    }                                                                          \\\n-    return REAL(memset)(block, c, size);                                       \\\n-  } while (0)\n-\n-void *__asan_memset(void *block, int c, uptr size) {\n-  ASAN_MEMSET_IMPL(nullptr, block, c, size);\n-}\n-\n-#define ASAN_MEMMOVE_IMPL(ctx, to, from, size) do {                            \\\n-    if (UNLIKELY(!asan_inited))                                                \\\n-      return internal_memmove(to, from, size);                                 \\\n-    ENSURE_ASAN_INITED();                                                      \\\n-    if (flags()->replace_intrin) {                                             \\\n-      ASAN_READ_RANGE(ctx, from, size);                                        \\\n-      ASAN_WRITE_RANGE(ctx, to, size);                                         \\\n-    }                                                                          \\\n-    return internal_memmove(to, from, size);                                   \\\n-  } while (0)\n-\n-void *__asan_memmove(void *to, const void *from, uptr size) {\n-  ASAN_MEMMOVE_IMPL(nullptr, to, from, size);\n-}\n-\n-INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, memmove);\n-  ASAN_MEMMOVE_IMPL(ctx, to, from, size);\n-}\n-\n-INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, memcpy);\n-#if !SANITIZER_MAC\n-  ASAN_MEMCPY_IMPL(ctx, to, from, size);\n-#else\n-  // At least on 10.7 and 10.8 both memcpy() and memmove() are being replaced\n-  // with WRAP(memcpy). As a result, false positives are reported for memmove()\n-  // calls. If we just disable error reporting with\n-  // ASAN_OPTIONS=replace_intrin=0, memmove() is still replaced with\n-  // internal_memcpy(), which may lead to crashes, see\n-  // http://llvm.org/bugs/show_bug.cgi?id=16362.\n-  ASAN_MEMMOVE_IMPL(ctx, to, from, size);\n-#endif  // !SANITIZER_MAC\n-}\n-\n-INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, memset);\n-  ASAN_MEMSET_IMPL(ctx, block, c, size);\n-}\n-\n #if ASAN_INTERCEPT_INDEX\n # if ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n INTERCEPTOR(char*, index, const char *string, int c)\n@@ -580,17 +425,6 @@ INTERCEPTOR(char*, __strdup, const char *s) {\n }\n #endif // ASAN_INTERCEPT___STRDUP\n \n-INTERCEPTOR(SIZE_T, wcslen, const wchar_t *s) {\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, wcslen);\n-  SIZE_T length = internal_wcslen(s);\n-  if (!asan_init_is_running) {\n-    ENSURE_ASAN_INITED();\n-    ASAN_READ_RANGE(ctx, s, (length + 1) * sizeof(wchar_t));\n-  }\n-  return length;\n-}\n-\n INTERCEPTOR(char*, strncpy, char *to, const char *from, uptr size) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, strncpy);\n@@ -707,9 +541,7 @@ INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n #if ASAN_INTERCEPT_FORK\n INTERCEPTOR(int, fork, void) {\n   ENSURE_ASAN_INITED();\n-  if (common_flags()->coverage) CovBeforeFork();\n   int pid = REAL(fork)();\n-  if (common_flags()->coverage) CovAfterFork(pid);\n   return pid;\n }\n #endif  // ASAN_INTERCEPT_FORK\n@@ -721,22 +553,11 @@ void InitializeAsanInterceptors() {\n   CHECK(!was_called_once);\n   was_called_once = true;\n   InitializeCommonInterceptors();\n-\n-  // Intercept mem* functions.\n-  ASAN_INTERCEPT_FUNC(memmove);\n-  ASAN_INTERCEPT_FUNC(memset);\n-  if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n-    // In asan, REAL(memmove) is not used, but it is used in msan.\n-    ASAN_INTERCEPT_FUNC(memcpy);\n-  } else {\n-    ASSIGN_REAL(memcpy, memmove);\n-  }\n-  CHECK(REAL(memcpy));\n+  InitializeSignalInterceptors();\n \n   // Intercept str* functions.\n   ASAN_INTERCEPT_FUNC(strcat);  // NOLINT\n   ASAN_INTERCEPT_FUNC(strcpy);  // NOLINT\n-  ASAN_INTERCEPT_FUNC(wcslen);\n   ASAN_INTERCEPT_FUNC(strncat);\n   ASAN_INTERCEPT_FUNC(strncpy);\n   ASAN_INTERCEPT_FUNC(strdup);\n@@ -755,21 +576,18 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(strtoll);\n #endif\n \n-  // Intecept signal- and jump-related functions.\n+  // Intecept jump-related functions.\n   ASAN_INTERCEPT_FUNC(longjmp);\n-#if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n-  ASAN_INTERCEPT_FUNC(sigaction);\n-#if SANITIZER_ANDROID\n-  ASAN_INTERCEPT_FUNC(bsd_signal);\n-#endif\n-  ASAN_INTERCEPT_FUNC(signal);\n-#endif\n+\n #if ASAN_INTERCEPT_SWAPCONTEXT\n   ASAN_INTERCEPT_FUNC(swapcontext);\n #endif\n #if ASAN_INTERCEPT__LONGJMP\n   ASAN_INTERCEPT_FUNC(_longjmp);\n #endif\n+#if ASAN_INTERCEPT___LONGJMP_CHK\n+  ASAN_INTERCEPT_FUNC(__longjmp_chk);\n+#endif\n #if ASAN_INTERCEPT_SIGLONGJMP\n   ASAN_INTERCEPT_FUNC(siglongjmp);\n #endif\n@@ -804,3 +622,5 @@ void InitializeAsanInterceptors() {\n }\n \n } // namespace __asan\n+\n+#endif  // !SANITIZER_FUCHSIA"}, {"sha": "e20d1af15a60b77057b7d86ab9d201a89096cca6", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,9 +13,30 @@\n #define ASAN_INTERCEPTORS_H\n \n #include \"asan_internal.h\"\n+#include \"asan_interceptors_memintrinsics.h\"\n #include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n+namespace __asan {\n+\n+void InitializeAsanInterceptors();\n+void InitializePlatformInterceptors();\n+\n+#define ENSURE_ASAN_INITED()      \\\n+  do {                            \\\n+    CHECK(!asan_init_is_running); \\\n+    if (UNLIKELY(!asan_inited)) { \\\n+      AsanInitFromRtl();          \\\n+    }                             \\\n+  } while (0)\n+\n+}  // namespace __asan\n+\n+// There is no general interception at all on Fuchsia.\n+// Only the functions in asan_interceptors_memintrinsics.h are\n+// really defined to replace libc functions.\n+#if !SANITIZER_FUCHSIA\n+\n // Use macro to describe if specific function should be\n // intercepted on a given platform.\n #if !SANITIZER_WINDOWS\n@@ -32,7 +53,7 @@\n # define ASAN_INTERCEPT_FORK 0\n #endif\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n #else\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n@@ -45,15 +66,15 @@\n #endif\n \n #if !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 1\n+# define ASAN_INTERCEPT_SIGLONGJMP 1\n #else\n-# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 0\n+# define ASAN_INTERCEPT_SIGLONGJMP 0\n #endif\n \n-#if !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT_SIGLONGJMP 1\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+# define ASAN_INTERCEPT___LONGJMP_CHK 1\n #else\n-# define ASAN_INTERCEPT_SIGLONGJMP 0\n+# define ASAN_INTERCEPT___LONGJMP_CHK 0\n #endif\n \n // Android bug: https://code.google.com/p/android/issues/detail?id=61799\n@@ -77,8 +98,6 @@\n #endif\n \n DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n-DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n-DECLARE_REAL(void*, memset, void *block, int c, uptr size)\n DECLARE_REAL(char*, strchr, const char *str, int c)\n DECLARE_REAL(SIZE_T, strlen, const char *s)\n DECLARE_REAL(char*, strncpy, char *to, const char *from, uptr size)\n@@ -105,18 +124,6 @@ DECLARE_REAL(int, sigaction, int signum, const struct sigaction *act,\n #define ASAN_INTERCEPT_FUNC(name)\n #endif  // SANITIZER_MAC\n \n-namespace __asan {\n-\n-void InitializeAsanInterceptors();\n-void InitializePlatformInterceptors();\n-\n-#define ENSURE_ASAN_INITED() do { \\\n-  CHECK(!asan_init_is_running); \\\n-  if (UNLIKELY(!asan_inited)) { \\\n-    AsanInitFromRtl(); \\\n-  } \\\n-} while (0)\n-\n-}  // namespace __asan\n+#endif  // !SANITIZER_FUCHSIA\n \n #endif  // ASAN_INTERCEPTORS_H"}, {"sha": "16de54cfeef62e4c3f1a5026bb650ae7025747ef", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,42 @@\n+//===-- asan_interceptors_memintrinsics.cc --------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan versions of memcpy, memmove, and memset.\n+//===---------------------------------------------------------------------===//\n+\n+#include \"asan_interceptors_memintrinsics.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"asan_suppressions.h\"\n+\n+using namespace __asan;  // NOLINT\n+\n+void *__asan_memcpy(void *to, const void *from, uptr size) {\n+  ASAN_MEMCPY_IMPL(nullptr, to, from, size);\n+}\n+\n+void *__asan_memset(void *block, int c, uptr size) {\n+  ASAN_MEMSET_IMPL(nullptr, block, c, size);\n+}\n+\n+void *__asan_memmove(void *to, const void *from, uptr size) {\n+  ASAN_MEMMOVE_IMPL(nullptr, to, from, size);\n+}\n+\n+#if SANITIZER_FUCHSIA\n+\n+// Fuchsia doesn't use sanitizer_common_interceptors.inc, but the only\n+// things there it wants are these three.  Just define them as aliases\n+// here rather than repeating the contents.\n+\n+decltype(memcpy) memcpy[[gnu::alias(\"__asan_memcpy\")]];\n+decltype(memmove) memmove[[gnu::alias(\"__asan_memmove\")]];\n+decltype(memset) memset[[gnu::alias(\"__asan_memset\")]];\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "1dc4d64c7fa3c0ea8fed30c41a9be2f2a2839952", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,146 @@\n+//===-- asan_interceptors_memintrinsics.h -----------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_memintrin.cc\n+//===---------------------------------------------------------------------===//\n+#ifndef ASAN_MEMINTRIN_H\n+#define ASAN_MEMINTRIN_H\n+\n+#include \"asan_interface_internal.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+#include \"interception/interception.h\"\n+\n+DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n+DECLARE_REAL(void*, memset, void *block, int c, uptr size)\n+\n+namespace __asan {\n+\n+// Return true if we can quickly decide that the region is unpoisoned.\n+// We assume that a redzone is at least 16 bytes.\n+static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n+  if (size == 0) return true;\n+  if (size <= 32)\n+    return !AddressIsPoisoned(beg) &&\n+           !AddressIsPoisoned(beg + size - 1) &&\n+           !AddressIsPoisoned(beg + size / 2);\n+  if (size <= 64)\n+    return !AddressIsPoisoned(beg) &&\n+           !AddressIsPoisoned(beg + size / 4) &&\n+           !AddressIsPoisoned(beg + size - 1) &&\n+           !AddressIsPoisoned(beg + 3 * size / 4) &&\n+           !AddressIsPoisoned(beg + size / 2);\n+  return false;\n+}\n+\n+struct AsanInterceptorContext {\n+  const char *interceptor_name;\n+};\n+\n+// We implement ACCESS_MEMORY_RANGE, ASAN_READ_RANGE,\n+// and ASAN_WRITE_RANGE as macro instead of function so\n+// that no extra frames are created, and stack trace contains\n+// relevant information only.\n+// We check all shadow bytes.\n+#define ACCESS_MEMORY_RANGE(ctx, offset, size, isWrite) do {            \\\n+    uptr __offset = (uptr)(offset);                                     \\\n+    uptr __size = (uptr)(size);                                         \\\n+    uptr __bad = 0;                                                     \\\n+    if (__offset > __offset + __size) {                                 \\\n+      GET_STACK_TRACE_FATAL_HERE;                                       \\\n+      ReportStringFunctionSizeOverflow(__offset, __size, &stack);       \\\n+    }                                                                   \\\n+    if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n+        (__bad = __asan_region_is_poisoned(__offset, __size))) {        \\\n+      AsanInterceptorContext *_ctx = (AsanInterceptorContext *)ctx;     \\\n+      bool suppressed = false;                                          \\\n+      if (_ctx) {                                                       \\\n+        suppressed = IsInterceptorSuppressed(_ctx->interceptor_name);   \\\n+        if (!suppressed && HaveStackTraceBasedSuppressions()) {         \\\n+          GET_STACK_TRACE_FATAL_HERE;                                   \\\n+          suppressed = IsStackTraceSuppressed(&stack);                  \\\n+        }                                                               \\\n+      }                                                                 \\\n+      if (!suppressed) {                                                \\\n+        GET_CURRENT_PC_BP_SP;                                           \\\n+        ReportGenericError(pc, bp, sp, __bad, isWrite, __size, 0, false);\\\n+      }                                                                 \\\n+    }                                                                   \\\n+  } while (0)\n+\n+// memcpy is called during __asan_init() from the internals of printf(...).\n+// We do not treat memcpy with to==from as a bug.\n+// See http://llvm.org/bugs/show_bug.cgi?id=11763.\n+#define ASAN_MEMCPY_IMPL(ctx, to, from, size)                           \\\n+  do {                                                                  \\\n+    if (UNLIKELY(!asan_inited)) return internal_memcpy(to, from, size); \\\n+    if (asan_init_is_running) {                                         \\\n+      return REAL(memcpy)(to, from, size);                              \\\n+    }                                                                   \\\n+    ENSURE_ASAN_INITED();                                               \\\n+    if (flags()->replace_intrin) {                                      \\\n+      if (to != from) {                                                 \\\n+        CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size);           \\\n+      }                                                                 \\\n+      ASAN_READ_RANGE(ctx, from, size);                                 \\\n+      ASAN_WRITE_RANGE(ctx, to, size);                                  \\\n+    }                                                                   \\\n+    return REAL(memcpy)(to, from, size);                                \\\n+  } while (0)\n+\n+// memset is called inside Printf.\n+#define ASAN_MEMSET_IMPL(ctx, block, c, size)                           \\\n+  do {                                                                  \\\n+    if (UNLIKELY(!asan_inited)) return internal_memset(block, c, size); \\\n+    if (asan_init_is_running) {                                         \\\n+      return REAL(memset)(block, c, size);                              \\\n+    }                                                                   \\\n+    ENSURE_ASAN_INITED();                                               \\\n+    if (flags()->replace_intrin) {                                      \\\n+      ASAN_WRITE_RANGE(ctx, block, size);                               \\\n+    }                                                                   \\\n+    return REAL(memset)(block, c, size);                                \\\n+  } while (0)\n+\n+#define ASAN_MEMMOVE_IMPL(ctx, to, from, size)                           \\\n+  do {                                                                   \\\n+    if (UNLIKELY(!asan_inited)) return internal_memmove(to, from, size); \\\n+    ENSURE_ASAN_INITED();                                                \\\n+    if (flags()->replace_intrin) {                                       \\\n+      ASAN_READ_RANGE(ctx, from, size);                                  \\\n+      ASAN_WRITE_RANGE(ctx, to, size);                                   \\\n+    }                                                                    \\\n+    return internal_memmove(to, from, size);                             \\\n+  } while (0)\n+\n+#define ASAN_READ_RANGE(ctx, offset, size) \\\n+  ACCESS_MEMORY_RANGE(ctx, offset, size, false)\n+#define ASAN_WRITE_RANGE(ctx, offset, size) \\\n+  ACCESS_MEMORY_RANGE(ctx, offset, size, true)\n+\n+// Behavior of functions like \"memcpy\" or \"strcpy\" is undefined\n+// if memory intervals overlap. We report error in this case.\n+// Macro is used to avoid creation of new frames.\n+static inline bool RangesOverlap(const char *offset1, uptr length1,\n+                                 const char *offset2, uptr length2) {\n+  return !((offset1 + length1 <= offset2) || (offset2 + length2 <= offset1));\n+}\n+#define CHECK_RANGES_OVERLAP(name, _offset1, length1, _offset2, length2) do { \\\n+  const char *offset1 = (const char*)_offset1; \\\n+  const char *offset2 = (const char*)_offset2; \\\n+  if (RangesOverlap(offset1, length1, offset2, length2)) { \\\n+    GET_STACK_TRACE_FATAL_HERE; \\\n+    ReportStringFunctionMemoryRangesOverlap(name, offset1, length1, \\\n+                                            offset2, length2, &stack); \\\n+  } \\\n+} while (0)\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_MEMINTRIN_H"}, {"sha": "b2fcde1c770152d42f4374dead43b950bdff622f", "filename": "libsanitizer/asan/asan_interface.inc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,167 @@\n+//===-- asan_interface.inc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// Asan interface list.\n+//===----------------------------------------------------------------------===//\n+INTERFACE_FUNCTION(__asan_addr_is_in_fake_stack)\n+INTERFACE_FUNCTION(__asan_address_is_poisoned)\n+INTERFACE_FUNCTION(__asan_after_dynamic_init)\n+INTERFACE_FUNCTION(__asan_alloca_poison)\n+INTERFACE_FUNCTION(__asan_allocas_unpoison)\n+INTERFACE_FUNCTION(__asan_before_dynamic_init)\n+INTERFACE_FUNCTION(__asan_describe_address)\n+INTERFACE_FUNCTION(__asan_exp_load1)\n+INTERFACE_FUNCTION(__asan_exp_load2)\n+INTERFACE_FUNCTION(__asan_exp_load4)\n+INTERFACE_FUNCTION(__asan_exp_load8)\n+INTERFACE_FUNCTION(__asan_exp_load16)\n+INTERFACE_FUNCTION(__asan_exp_loadN)\n+INTERFACE_FUNCTION(__asan_exp_store1)\n+INTERFACE_FUNCTION(__asan_exp_store2)\n+INTERFACE_FUNCTION(__asan_exp_store4)\n+INTERFACE_FUNCTION(__asan_exp_store8)\n+INTERFACE_FUNCTION(__asan_exp_store16)\n+INTERFACE_FUNCTION(__asan_exp_storeN)\n+INTERFACE_FUNCTION(__asan_get_alloc_stack)\n+INTERFACE_FUNCTION(__asan_get_current_fake_stack)\n+INTERFACE_FUNCTION(__asan_get_free_stack)\n+INTERFACE_FUNCTION(__asan_get_report_access_size)\n+INTERFACE_FUNCTION(__asan_get_report_access_type)\n+INTERFACE_FUNCTION(__asan_get_report_address)\n+INTERFACE_FUNCTION(__asan_get_report_bp)\n+INTERFACE_FUNCTION(__asan_get_report_description)\n+INTERFACE_FUNCTION(__asan_get_report_pc)\n+INTERFACE_FUNCTION(__asan_get_report_sp)\n+INTERFACE_FUNCTION(__asan_get_shadow_mapping)\n+INTERFACE_FUNCTION(__asan_handle_no_return)\n+INTERFACE_FUNCTION(__asan_init)\n+INTERFACE_FUNCTION(__asan_load_cxx_array_cookie)\n+INTERFACE_FUNCTION(__asan_load1)\n+INTERFACE_FUNCTION(__asan_load2)\n+INTERFACE_FUNCTION(__asan_load4)\n+INTERFACE_FUNCTION(__asan_load8)\n+INTERFACE_FUNCTION(__asan_load16)\n+INTERFACE_FUNCTION(__asan_loadN)\n+INTERFACE_FUNCTION(__asan_load1_noabort)\n+INTERFACE_FUNCTION(__asan_load2_noabort)\n+INTERFACE_FUNCTION(__asan_load4_noabort)\n+INTERFACE_FUNCTION(__asan_load8_noabort)\n+INTERFACE_FUNCTION(__asan_load16_noabort)\n+INTERFACE_FUNCTION(__asan_loadN_noabort)\n+INTERFACE_FUNCTION(__asan_locate_address)\n+INTERFACE_FUNCTION(__asan_memcpy)\n+INTERFACE_FUNCTION(__asan_memmove)\n+INTERFACE_FUNCTION(__asan_memset)\n+INTERFACE_FUNCTION(__asan_poison_cxx_array_cookie)\n+INTERFACE_FUNCTION(__asan_poison_intra_object_redzone)\n+INTERFACE_FUNCTION(__asan_poison_memory_region)\n+INTERFACE_FUNCTION(__asan_poison_stack_memory)\n+INTERFACE_FUNCTION(__asan_print_accumulated_stats)\n+INTERFACE_FUNCTION(__asan_region_is_poisoned)\n+INTERFACE_FUNCTION(__asan_register_globals)\n+INTERFACE_FUNCTION(__asan_register_elf_globals)\n+INTERFACE_FUNCTION(__asan_register_image_globals)\n+INTERFACE_FUNCTION(__asan_report_error)\n+INTERFACE_FUNCTION(__asan_report_exp_load1)\n+INTERFACE_FUNCTION(__asan_report_exp_load2)\n+INTERFACE_FUNCTION(__asan_report_exp_load4)\n+INTERFACE_FUNCTION(__asan_report_exp_load8)\n+INTERFACE_FUNCTION(__asan_report_exp_load16)\n+INTERFACE_FUNCTION(__asan_report_exp_load_n)\n+INTERFACE_FUNCTION(__asan_report_exp_store1)\n+INTERFACE_FUNCTION(__asan_report_exp_store2)\n+INTERFACE_FUNCTION(__asan_report_exp_store4)\n+INTERFACE_FUNCTION(__asan_report_exp_store8)\n+INTERFACE_FUNCTION(__asan_report_exp_store16)\n+INTERFACE_FUNCTION(__asan_report_exp_store_n)\n+INTERFACE_FUNCTION(__asan_report_load1)\n+INTERFACE_FUNCTION(__asan_report_load2)\n+INTERFACE_FUNCTION(__asan_report_load4)\n+INTERFACE_FUNCTION(__asan_report_load8)\n+INTERFACE_FUNCTION(__asan_report_load16)\n+INTERFACE_FUNCTION(__asan_report_load_n)\n+INTERFACE_FUNCTION(__asan_report_load1_noabort)\n+INTERFACE_FUNCTION(__asan_report_load2_noabort)\n+INTERFACE_FUNCTION(__asan_report_load4_noabort)\n+INTERFACE_FUNCTION(__asan_report_load8_noabort)\n+INTERFACE_FUNCTION(__asan_report_load16_noabort)\n+INTERFACE_FUNCTION(__asan_report_load_n_noabort)\n+INTERFACE_FUNCTION(__asan_report_present)\n+INTERFACE_FUNCTION(__asan_report_store1)\n+INTERFACE_FUNCTION(__asan_report_store2)\n+INTERFACE_FUNCTION(__asan_report_store4)\n+INTERFACE_FUNCTION(__asan_report_store8)\n+INTERFACE_FUNCTION(__asan_report_store16)\n+INTERFACE_FUNCTION(__asan_report_store_n)\n+INTERFACE_FUNCTION(__asan_report_store1_noabort)\n+INTERFACE_FUNCTION(__asan_report_store2_noabort)\n+INTERFACE_FUNCTION(__asan_report_store4_noabort)\n+INTERFACE_FUNCTION(__asan_report_store8_noabort)\n+INTERFACE_FUNCTION(__asan_report_store16_noabort)\n+INTERFACE_FUNCTION(__asan_report_store_n_noabort)\n+INTERFACE_FUNCTION(__asan_set_death_callback)\n+INTERFACE_FUNCTION(__asan_set_error_report_callback)\n+INTERFACE_FUNCTION(__asan_set_shadow_00)\n+INTERFACE_FUNCTION(__asan_set_shadow_f1)\n+INTERFACE_FUNCTION(__asan_set_shadow_f2)\n+INTERFACE_FUNCTION(__asan_set_shadow_f3)\n+INTERFACE_FUNCTION(__asan_set_shadow_f5)\n+INTERFACE_FUNCTION(__asan_set_shadow_f8)\n+INTERFACE_FUNCTION(__asan_stack_free_0)\n+INTERFACE_FUNCTION(__asan_stack_free_1)\n+INTERFACE_FUNCTION(__asan_stack_free_2)\n+INTERFACE_FUNCTION(__asan_stack_free_3)\n+INTERFACE_FUNCTION(__asan_stack_free_4)\n+INTERFACE_FUNCTION(__asan_stack_free_5)\n+INTERFACE_FUNCTION(__asan_stack_free_6)\n+INTERFACE_FUNCTION(__asan_stack_free_7)\n+INTERFACE_FUNCTION(__asan_stack_free_8)\n+INTERFACE_FUNCTION(__asan_stack_free_9)\n+INTERFACE_FUNCTION(__asan_stack_free_10)\n+INTERFACE_FUNCTION(__asan_stack_malloc_0)\n+INTERFACE_FUNCTION(__asan_stack_malloc_1)\n+INTERFACE_FUNCTION(__asan_stack_malloc_2)\n+INTERFACE_FUNCTION(__asan_stack_malloc_3)\n+INTERFACE_FUNCTION(__asan_stack_malloc_4)\n+INTERFACE_FUNCTION(__asan_stack_malloc_5)\n+INTERFACE_FUNCTION(__asan_stack_malloc_6)\n+INTERFACE_FUNCTION(__asan_stack_malloc_7)\n+INTERFACE_FUNCTION(__asan_stack_malloc_8)\n+INTERFACE_FUNCTION(__asan_stack_malloc_9)\n+INTERFACE_FUNCTION(__asan_stack_malloc_10)\n+INTERFACE_FUNCTION(__asan_store1)\n+INTERFACE_FUNCTION(__asan_store2)\n+INTERFACE_FUNCTION(__asan_store4)\n+INTERFACE_FUNCTION(__asan_store8)\n+INTERFACE_FUNCTION(__asan_store16)\n+INTERFACE_FUNCTION(__asan_storeN)\n+INTERFACE_FUNCTION(__asan_store1_noabort)\n+INTERFACE_FUNCTION(__asan_store2_noabort)\n+INTERFACE_FUNCTION(__asan_store4_noabort)\n+INTERFACE_FUNCTION(__asan_store8_noabort)\n+INTERFACE_FUNCTION(__asan_store16_noabort)\n+INTERFACE_FUNCTION(__asan_storeN_noabort)\n+INTERFACE_FUNCTION(__asan_unpoison_intra_object_redzone)\n+INTERFACE_FUNCTION(__asan_unpoison_memory_region)\n+INTERFACE_FUNCTION(__asan_unpoison_stack_memory)\n+INTERFACE_FUNCTION(__asan_unregister_globals)\n+INTERFACE_FUNCTION(__asan_unregister_elf_globals)\n+INTERFACE_FUNCTION(__asan_unregister_image_globals)\n+INTERFACE_FUNCTION(__asan_version_mismatch_check_v8)\n+INTERFACE_FUNCTION(__sanitizer_finish_switch_fiber)\n+INTERFACE_FUNCTION(__sanitizer_print_stack_trace)\n+INTERFACE_FUNCTION(__sanitizer_ptr_cmp)\n+INTERFACE_FUNCTION(__sanitizer_ptr_sub)\n+INTERFACE_FUNCTION(__sanitizer_start_switch_fiber)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_load16)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_load32)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_load64)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_store16)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_store32)\n+INTERFACE_FUNCTION(__sanitizer_unaligned_store64)\n+INTERFACE_WEAK_FUNCTION(__asan_default_options)\n+INTERFACE_WEAK_FUNCTION(__asan_default_suppressions)\n+INTERFACE_WEAK_FUNCTION(__asan_on_error)"}, {"sha": "be9605d9e6e5ed7e66b46e17ba6ebde764673cb8", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -65,6 +65,11 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_unregister_image_globals(uptr *flag);\n \n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_register_elf_globals(uptr *flag, void *start, void *stop);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_unregister_elf_globals(uptr *flag, void *start, void *stop);\n+\n   // These two functions should be called by the instrumented code.\n   // 'globals' is an array of structures describing 'n' globals.\n   SANITIZER_INTERFACE_ATTRIBUTE\n@@ -163,12 +168,12 @@ extern \"C\" {\n   void __asan_set_error_report_callback(void (*callback)(const char*));\n \n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  /* OPTIONAL */ void __asan_on_error();\n+  void __asan_on_error();\n \n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_print_accumulated_stats();\n \n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  /* OPTIONAL */ const char* __asan_default_options();\n+  const char* __asan_default_options();\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n   extern uptr __asan_shadow_memory_dynamic_address;\n@@ -240,6 +245,9 @@ extern \"C\" {\n   void __asan_alloca_poison(uptr addr, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_allocas_unpoison(uptr top, uptr bottom);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  const char* __asan_default_suppressions();\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "a3fe755f523db1880ba4fcb49a59e73215da171f", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -34,7 +34,7 @@\n // If set, values like allocator chunk size, as well as defaults for some flags\n // will be changed towards less memory overhead.\n #ifndef ASAN_LOW_MEMORY\n-# if SANITIZER_IOS || (SANITIZER_WORDSIZE == 32)\n+# if SANITIZER_IOS || SANITIZER_ANDROID\n #  define ASAN_LOW_MEMORY 1\n # else\n #  define ASAN_LOW_MEMORY 0\n@@ -62,21 +62,29 @@ void AsanInitFromRtl();\n \n // asan_win.cc\n void InitializePlatformExceptionHandlers();\n-\n-// asan_win.cc / asan_posix.cc\n-const char *DescribeSignalOrException(int signo);\n+// Returns whether an address is a valid allocated system heap block.\n+// 'addr' must point to the beginning of the block.\n+bool IsSystemHeapAddress(uptr addr);\n \n // asan_rtl.cc\n+void PrintAddressSpaceLayout();\n void NORETURN ShowStatsAndAbort();\n \n+// asan_shadow_setup.cc\n+void InitializeShadowMemory();\n+\n // asan_malloc_linux.cc / asan_malloc_mac.cc\n void ReplaceSystemMalloc();\n \n // asan_linux.cc / asan_mac.cc / asan_win.cc\n+uptr FindDynamicShadowStart();\n void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n void AsanCheckIncompatibleRT();\n \n+// asan_thread.cc\n+AsanThread *CreateMainThread();\n+\n // Support function for __asan_(un)register_image_globals. Searches for the\n // loaded image containing `needle' and then enumerates all global metadata\n // structures declared in that image, applying `op' (e.g.,\n@@ -101,17 +109,6 @@ void *AsanDlSymNext(const char *sym);\n \n void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name);\n \n-// Platform-specific options.\n-#if SANITIZER_MAC\n-bool PlatformHasDifferentMemcpyAndMemmove();\n-# define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\\n-    (PlatformHasDifferentMemcpyAndMemmove())\n-#elif SANITIZER_WINDOWS64\n-# define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n-#else\n-# define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n-#endif  // SANITIZER_MAC\n-\n // Add convenient macro for interface functions that may be represented as\n // weak hooks.\n #define ASAN_MALLOC_HOOK(ptr, size)                                   \\"}, {"sha": "a43243e3b4302cf22fcc2dadfdd920342e80a092", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -11,7 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n@@ -40,6 +40,10 @@\n #if SANITIZER_ANDROID || SANITIZER_FREEBSD\n #include <ucontext.h>\n extern \"C\" void* _DYNAMIC;\n+#elif SANITIZER_NETBSD\n+#include <link_elf.h>\n+#include <ucontext.h>\n+extern Elf_Dyn _DYNAMIC;\n #else\n #include <sys/ucontext.h>\n #include <link.h>\n@@ -68,12 +72,18 @@ namespace __asan {\n \n void InitializePlatformInterceptors() {}\n void InitializePlatformExceptionHandlers() {}\n+bool IsSystemHeapAddress (uptr addr) { return false; }\n \n void *AsanDoesNotSupportStaticLinkage() {\n   // This will fail to link with -static.\n   return &_DYNAMIC;  // defined in link.h\n }\n \n+uptr FindDynamicShadowStart() {\n+  UNREACHABLE(\"FindDynamicShadowStart is not available\");\n+  return 0;\n+}\n+\n void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n   UNIMPLEMENTED();\n }\n@@ -93,6 +103,15 @@ static int FindFirstDSOCallback(struct dl_phdr_info *info, size_t size,\n   if (internal_strncmp(info->dlpi_name, \"linux-\", sizeof(\"linux-\") - 1) == 0)\n     return 0;\n \n+#if SANITIZER_NETBSD\n+  // Ignore first entry (the main program)\n+  char **p = (char **)data;\n+  if (!(*p)) {\n+    *p = (char *)-1;\n+    return 0;\n+  }\n+#endif\n+\n   *(const char **)data = info->dlpi_name;\n   return 1;\n }\n@@ -108,7 +127,7 @@ static void ReportIncompatibleRT() {\n }\n \n void AsanCheckDynamicRTPrereqs() {\n-  if (!ASAN_DYNAMIC)\n+  if (!ASAN_DYNAMIC || !flags()->verify_asan_link_order)\n     return;\n \n   // Ensure that dynamic RT is the first DSO in the list\n@@ -137,9 +156,9 @@ void AsanCheckIncompatibleRT() {\n       // system libraries, causing crashes later in ASan initialization.\n       MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n       char filename[128];\n-      while (proc_maps.Next(nullptr, nullptr, nullptr, filename,\n-                            sizeof(filename), nullptr)) {\n-        if (IsDynamicRTName(filename)) {\n+      MemoryMappedSegment segment(filename, sizeof(filename));\n+      while (proc_maps.Next(&segment)) {\n+        if (IsDynamicRTName(segment.filename)) {\n           Report(\"Your application is linked against \"\n                  \"incompatible ASan runtimes.\\n\");\n           Die();\n@@ -171,4 +190,4 @@ void *AsanDlSymNext(const char *sym) {\n \n } // namespace __asan\n \n-#endif // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD"}, {"sha": "45c66d8645cd5eecd907f896dc0da8c33142eced", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -46,21 +46,36 @@ namespace __asan {\n \n void InitializePlatformInterceptors() {}\n void InitializePlatformExceptionHandlers() {}\n-\n-bool PlatformHasDifferentMemcpyAndMemmove() {\n-  // On OS X 10.7 memcpy() and memmove() are both resolved\n-  // into memmove$VARIANT$sse42.\n-  // See also https://github.com/google/sanitizers/issues/34.\n-  // TODO(glider): need to check dynamically that memcpy() and memmove() are\n-  // actually the same function.\n-  return GetMacosVersion() == MACOS_VERSION_SNOW_LEOPARD;\n-}\n+bool IsSystemHeapAddress (uptr addr) { return false; }\n \n // No-op. Mac does not support static linkage anyway.\n void *AsanDoesNotSupportStaticLinkage() {\n   return 0;\n }\n \n+uptr FindDynamicShadowStart() {\n+  uptr granularity = GetMmapGranularity();\n+  uptr alignment = 8 * granularity;\n+  uptr left_padding = granularity;\n+  uptr space_size = kHighShadowEnd + left_padding;\n+\n+  uptr largest_gap_found = 0;\n+  uptr shadow_start = FindAvailableMemoryRange(space_size, alignment,\n+                                               granularity, &largest_gap_found);\n+  // If the shadow doesn't fit, restrict the address space to make it fit.\n+  if (shadow_start == 0) {\n+    uptr new_max_vm = RoundDownTo(largest_gap_found << SHADOW_SCALE, alignment);\n+    RestrictMemoryToMaxAddress(new_max_vm);\n+    kHighMemEnd = new_max_vm - 1;\n+    space_size = kHighShadowEnd + left_padding;\n+    shadow_start =\n+        FindAvailableMemoryRange(space_size, alignment, granularity, nullptr);\n+  }\n+  CHECK_NE((uptr)0, shadow_start);\n+  CHECK(IsAligned(shadow_start, alignment));\n+  return shadow_start;\n+}\n+\n // No-op. Mac does not support static linkage anyway.\n void AsanCheckDynamicRTPrereqs() {}\n \n@@ -145,7 +160,8 @@ void asan_register_worker_thread(int parent_tid, StackTrace *stack) {\n     t = AsanThread::Create(/* start_routine */ nullptr, /* arg */ nullptr,\n                            parent_tid, stack, /* detached */ true);\n     t->Init();\n-    asanThreadRegistry().StartThread(t->tid(), 0, 0);\n+    asanThreadRegistry().StartThread(t->tid(), GetTid(),\n+                                     /* workerthread */ true, 0);\n     SetCurrentThread(t);\n   }\n }"}, {"sha": "19f45fc3cee330556544638e96d953967ae37e3b", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,7 +13,8 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_FUCHSIA || SANITIZER_LINUX || \\\n+    SANITIZER_NETBSD\n \n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"asan_allocator.h\"\n@@ -28,9 +29,9 @@ static uptr allocated_for_dlsym;\n static const uptr kDlsymAllocPoolSize = 1024;\n static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n \n-static bool IsInDlsymAllocPool(const void *ptr) {\n+static INLINE bool IsInDlsymAllocPool(const void *ptr) {\n   uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-  return off < sizeof(alloc_memory_for_dlsym);\n+  return off < allocated_for_dlsym * sizeof(alloc_memory_for_dlsym[0]);\n }\n \n static void *AllocateFromLocalPool(uptr size_in_bytes) {\n@@ -41,77 +42,96 @@ static void *AllocateFromLocalPool(uptr size_in_bytes) {\n   return mem;\n }\n \n+static INLINE bool MaybeInDlsym() {\n+  // Fuchsia doesn't use dlsym-based interceptors.\n+  return !SANITIZER_FUCHSIA && asan_init_is_running;\n+}\n+\n+static void *ReallocFromLocalPool(void *ptr, uptr size) {\n+  const uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n+  const uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n+  void *new_ptr;\n+  if (UNLIKELY(MaybeInDlsym())) {\n+    new_ptr = AllocateFromLocalPool(size);\n+  } else {\n+    ENSURE_ASAN_INITED();\n+    GET_STACK_TRACE_MALLOC;\n+    new_ptr = asan_malloc(size, &stack);\n+  }\n+  internal_memcpy(new_ptr, ptr, copy_size);\n+  return new_ptr;\n+}\n+\n INTERCEPTOR(void, free, void *ptr) {\n   GET_STACK_TRACE_FREE;\n   if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n     return;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n+#if SANITIZER_INTERCEPT_CFREE\n INTERCEPTOR(void, cfree, void *ptr) {\n   GET_STACK_TRACE_FREE;\n   if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n     return;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n+#endif // SANITIZER_INTERCEPT_CFREE\n \n INTERCEPTOR(void*, malloc, uptr size) {\n-  if (UNLIKELY(!asan_inited))\n+  if (UNLIKELY(MaybeInDlsym()))\n     // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n     return AllocateFromLocalPool(size);\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_malloc(size, &stack);\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n-  if (UNLIKELY(!asan_inited))\n+  if (UNLIKELY(MaybeInDlsym()))\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n     return AllocateFromLocalPool(nmemb * size);\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_calloc(nmemb, size, &stack);\n }\n \n INTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n+  if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n+    return ReallocFromLocalPool(ptr, size);\n+  if (UNLIKELY(MaybeInDlsym()))\n+    return AllocateFromLocalPool(size);\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n-    uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-    uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n-    void *new_ptr;\n-    if (UNLIKELY(!asan_inited)) {\n-      new_ptr = AllocateFromLocalPool(size);\n-    } else {\n-      copy_size = size;\n-      new_ptr = asan_malloc(copy_size, &stack);\n-    }\n-    internal_memcpy(new_ptr, ptr, copy_size);\n-    return new_ptr;\n-  }\n   return asan_realloc(ptr, size, &stack);\n }\n \n+#if SANITIZER_INTERCEPT_MEMALIGN\n INTERCEPTOR(void*, memalign, uptr boundary, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n }\n \n-INTERCEPTOR(void*, aligned_alloc, uptr boundary, uptr size) {\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n-}\n-\n INTERCEPTOR(void*, __libc_memalign, uptr boundary, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   void *res = asan_memalign(boundary, size, &stack, FROM_MALLOC);\n   DTLS_on_libc_memalign(res, size);\n   return res;\n }\n+#endif // SANITIZER_INTERCEPT_MEMALIGN\n+\n+INTERCEPTOR(void*, aligned_alloc, uptr boundary, uptr size) {\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n+}\n \n INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n   GET_CURRENT_PC_BP_SP;\n   (void)sp;\n   return asan_malloc_usable_size(ptr, pc, bp);\n }\n \n+#if SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n // We avoid including malloc.h for portability reasons.\n // man mallinfo says the fields are \"long\", but the implementation uses int.\n // It doesn't matter much -- we just need to make sure that the libc's mallinfo\n@@ -129,6 +149,7 @@ INTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n INTERCEPTOR(int, mallopt, int cmd, int value) {\n   return -1;\n }\n+#endif // SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n \n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n@@ -141,10 +162,12 @@ INTERCEPTOR(void*, valloc, uptr size) {\n   return asan_valloc(size, &stack);\n }\n \n+#if SANITIZER_INTERCEPT_PVALLOC\n INTERCEPTOR(void*, pvalloc, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_pvalloc(size, &stack);\n }\n+#endif // SANITIZER_INTERCEPT_PVALLOC\n \n INTERCEPTOR(void, malloc_stats, void) {\n   __asan_print_accumulated_stats();\n@@ -210,4 +233,5 @@ void ReplaceSystemMalloc() {\n }  // namespace __asan\n #endif  // SANITIZER_ANDROID\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_FUCHSIA || SANITIZER_LINUX ||\n+        // SANITIZER_NETBSD"}, {"sha": "017481d0b81511d093e78bde5e0c42431bf1b321", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -53,11 +53,6 @@ void _free_base(void *ptr) {\n   free(ptr);\n }\n \n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void cfree(void *ptr) {\n-  CHECK(!\"cfree() should not be used on Windows\");\n-}\n-\n ALLOCATION_FUNCTION_ATTRIBUTE\n void *malloc(size_t size) {\n   GET_STACK_TRACE_MALLOC;\n@@ -103,7 +98,7 @@ void *realloc(void *ptr, size_t size) {\n \n ALLOCATION_FUNCTION_ATTRIBUTE\n void *_realloc_dbg(void *ptr, size_t size, int) {\n-  CHECK(!\"_realloc_dbg should not exist!\");\n+  UNREACHABLE(\"_realloc_dbg should not exist!\");\n   return 0;\n }\n "}, {"sha": "5496df66deb6634abf8679a6374bb62d7a31f99e", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -113,6 +113,13 @@\n // || `[0x40000000, 0x47ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x3fffffff]` || LowMem     ||\n //\n+// Shadow mapping on NetBSD/x86-64 with SHADOW_OFFSET == 0x400000000000:\n+// || `[0x4feffffffe01, 0x7f7ffffff000]` || HighMem    ||\n+// || `[0x49fdffffffc0, 0x4feffffffe00]` || HighShadow ||\n+// || `[0x480000000000, 0x49fdffffffbf]` || ShadowGap  ||\n+// || `[0x400000000000, 0x47ffffffffff]` || LowShadow  ||\n+// || `[0x000000000000, 0x3fffffffffff]` || LowMem     ||\n+//\n // Default Windows/i386 mapping:\n // (the exact location of HighShadow/HighMem may vary depending\n //  on WoW64, /LARGEADDRESSAWARE, etc).\n@@ -138,12 +145,14 @@ static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n+static const u64 kNetBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n \n #define SHADOW_SCALE kDefaultShadowScale\n \n-\n-#if SANITIZER_WORDSIZE == 32\n+#if SANITIZER_FUCHSIA\n+#  define SHADOW_OFFSET (0)\n+#elif SANITIZER_WORDSIZE == 32\n #  if SANITIZER_ANDROID\n #    define SHADOW_OFFSET (0)\n #  elif defined(__mips__)\n@@ -176,6 +185,8 @@ static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n #    define SHADOW_OFFSET kSystemZ_ShadowOffset64\n #  elif SANITIZER_FREEBSD\n #    define SHADOW_OFFSET kFreeBSD_ShadowOffset64\n+#  elif SANITIZER_NETBSD\n+#    define SHADOW_OFFSET kNetBSD_ShadowOffset64\n #  elif SANITIZER_MAC\n #   define SHADOW_OFFSET kDefaultShadowOffset64\n #  elif defined(__mips64)\n@@ -189,7 +200,6 @@ static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n \n #define SHADOW_GRANULARITY (1ULL << SHADOW_SCALE)\n #define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) + (SHADOW_OFFSET))\n-#define SHADOW_TO_MEM(shadow) (((shadow) - SHADOW_OFFSET) << SHADOW_SCALE)\n \n #define kLowMemBeg      0\n #define kLowMemEnd      (SHADOW_OFFSET ? SHADOW_OFFSET - 1 : 0)"}, {"sha": "42d07c705f1564da8326188a1e8bbd48aebfad29", "filename": "libsanitizer/asan/asan_memory_profile.cc", "status": "modified", "additions": 61, "deletions": 31, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_memory_profile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_memory_profile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_memory_profile.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -30,69 +30,99 @@ struct AllocationSite {\n class HeapProfile {\n  public:\n   HeapProfile() : allocations_(1024) {}\n-  void Insert(u32 id, uptr size) {\n-    total_allocated_ += size;\n-    total_count_++;\n-    // Linear lookup will be good enough for most cases (although not all).\n-    for (uptr i = 0; i < allocations_.size(); i++) {\n-      if (allocations_[i].id == id) {\n-        allocations_[i].total_size += size;\n-        allocations_[i].count++;\n-        return;\n-      }\n+\n+  void ProcessChunk(const AsanChunkView& cv) {\n+    if (cv.IsAllocated()) {\n+      total_allocated_user_size_ += cv.UsedSize();\n+      total_allocated_count_++;\n+      u32 id = cv.GetAllocStackId();\n+      if (id)\n+        Insert(id, cv.UsedSize());\n+    } else if (cv.IsQuarantined()) {\n+      total_quarantined_user_size_ += cv.UsedSize();\n+      total_quarantined_count_++;\n+    } else {\n+      total_other_count_++;\n     }\n-    allocations_.push_back({id, size, 1});\n   }\n \n-  void Print(uptr top_percent) {\n+  void Print(uptr top_percent, uptr max_number_of_contexts) {\n     InternalSort(&allocations_, allocations_.size(),\n                  [](const AllocationSite &a, const AllocationSite &b) {\n                    return a.total_size > b.total_size;\n                  });\n-    CHECK(total_allocated_);\n+    CHECK(total_allocated_user_size_);\n     uptr total_shown = 0;\n-    Printf(\"Live Heap Allocations: %zd bytes from %zd allocations; \"\n-           \"showing top %zd%%\\n\", total_allocated_, total_count_, top_percent);\n-    for (uptr i = 0; i < allocations_.size(); i++) {\n+    Printf(\"Live Heap Allocations: %zd bytes in %zd chunks; quarantined: \"\n+           \"%zd bytes in %zd chunks; %zd other chunks; total chunks: %zd; \"\n+           \"showing top %zd%% (at most %zd unique contexts)\\n\",\n+           total_allocated_user_size_, total_allocated_count_,\n+           total_quarantined_user_size_, total_quarantined_count_,\n+           total_other_count_, total_allocated_count_ +\n+           total_quarantined_count_ + total_other_count_, top_percent,\n+           max_number_of_contexts);\n+    for (uptr i = 0; i < Min(allocations_.size(), max_number_of_contexts);\n+         i++) {\n       auto &a = allocations_[i];\n       Printf(\"%zd byte(s) (%zd%%) in %zd allocation(s)\\n\", a.total_size,\n-             a.total_size * 100 / total_allocated_, a.count);\n+             a.total_size * 100 / total_allocated_user_size_, a.count);\n       StackDepotGet(a.id).Print();\n       total_shown += a.total_size;\n-      if (total_shown * 100 / total_allocated_ > top_percent)\n+      if (total_shown * 100 / total_allocated_user_size_ > top_percent)\n         break;\n     }\n   }\n \n  private:\n-  uptr total_allocated_ = 0;\n-  uptr total_count_ = 0;\n+  uptr total_allocated_user_size_ = 0;\n+  uptr total_allocated_count_ = 0;\n+  uptr total_quarantined_user_size_ = 0;\n+  uptr total_quarantined_count_ = 0;\n+  uptr total_other_count_ = 0;\n   InternalMmapVector<AllocationSite> allocations_;\n+\n+  void Insert(u32 id, uptr size) {\n+    // Linear lookup will be good enough for most cases (although not all).\n+    for (uptr i = 0; i < allocations_.size(); i++) {\n+      if (allocations_[i].id == id) {\n+        allocations_[i].total_size += size;\n+        allocations_[i].count++;\n+        return;\n+      }\n+    }\n+    allocations_.push_back({id, size, 1});\n+  }\n };\n \n static void ChunkCallback(uptr chunk, void *arg) {\n-  HeapProfile *hp = reinterpret_cast<HeapProfile*>(arg);\n-  AsanChunkView cv = FindHeapChunkByAllocBeg(chunk);\n-  if (!cv.IsAllocated()) return;\n-  u32 id = cv.GetAllocStackId();\n-  if (!id) return;\n-  hp->Insert(id, cv.UsedSize());\n+  reinterpret_cast<HeapProfile*>(arg)->ProcessChunk(\n+      FindHeapChunkByAllocBeg(chunk));\n }\n \n static void MemoryProfileCB(const SuspendedThreadsList &suspended_threads_list,\n                             void *argument) {\n   HeapProfile hp;\n   __lsan::ForEachChunk(ChunkCallback, &hp);\n-  hp.Print(reinterpret_cast<uptr>(argument));\n+  uptr *Arg = reinterpret_cast<uptr*>(argument);\n+  hp.Print(Arg[0], Arg[1]);\n+\n+  if (Verbosity())\n+    __asan_print_accumulated_stats();\n }\n \n }  // namespace __asan\n \n+#endif  // CAN_SANITIZE_LEAKS\n+\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_print_memory_profile(uptr top_percent) {\n-  __sanitizer::StopTheWorld(__asan::MemoryProfileCB, (void*)top_percent);\n+void __sanitizer_print_memory_profile(uptr top_percent,\n+                                      uptr max_number_of_contexts) {\n+#if CAN_SANITIZE_LEAKS\n+  uptr Arg[2];\n+  Arg[0] = top_percent;\n+  Arg[1] = max_number_of_contexts;\n+  __sanitizer::StopTheWorld(__asan::MemoryProfileCB, Arg);\n+#endif  // CAN_SANITIZE_LEAKS\n }\n }  // extern \"C\"\n-\n-#endif  // CAN_SANITIZE_LEAKS"}, {"sha": "e95b5287191e89e74d1dc2aca1a4977dd5833a31", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -23,22 +23,26 @@\n // dllexport would normally do. We need to export them in order to make the\n // VS2015 dynamic CRT (MD) work.\n #if SANITIZER_WINDOWS\n-# define CXX_OPERATOR_ATTRIBUTE\n-# ifdef _WIN64\n-#  pragma comment(linker, \"/export:??2@YAPEAX_K@Z\")   // operator new\n-#  pragma comment(linker, \"/export:??3@YAXPEAX@Z\")    // operator delete\n-#  pragma comment(linker, \"/export:??3@YAXPEAX_K@Z\")  // sized operator delete\n-#  pragma comment(linker, \"/export:??_U@YAPEAX_K@Z\")  // operator new[]\n-#  pragma comment(linker, \"/export:??_V@YAXPEAX@Z\")   // operator delete[]\n-# else\n-#  pragma comment(linker, \"/export:??2@YAPAXI@Z\")   // operator new\n-#  pragma comment(linker, \"/export:??3@YAXPAX@Z\")   // operator delete\n-#  pragma comment(linker, \"/export:??3@YAXPAXI@Z\")  // sized operator delete\n-#  pragma comment(linker, \"/export:??_U@YAPAXI@Z\")  // operator new[]\n-#  pragma comment(linker, \"/export:??_V@YAXPAX@Z\")  // operator delete[]\n-# endif\n+#define CXX_OPERATOR_ATTRIBUTE\n+#define COMMENT_EXPORT(sym) __pragma(comment(linker, \"/export:\" sym))\n+#ifdef _WIN64\n+COMMENT_EXPORT(\"??2@YAPEAX_K@Z\")                     // operator new\n+COMMENT_EXPORT(\"??2@YAPEAX_KAEBUnothrow_t@std@@@Z\")  // operator new nothrow\n+COMMENT_EXPORT(\"??3@YAXPEAX@Z\")                      // operator delete\n+COMMENT_EXPORT(\"??3@YAXPEAX_K@Z\")                    // sized operator delete\n+COMMENT_EXPORT(\"??_U@YAPEAX_K@Z\")                    // operator new[]\n+COMMENT_EXPORT(\"??_V@YAXPEAX@Z\")                     // operator delete[]\n #else\n-# define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE\n+COMMENT_EXPORT(\"??2@YAPAXI@Z\")                    // operator new\n+COMMENT_EXPORT(\"??2@YAPAXIABUnothrow_t@std@@@Z\")  // operator new nothrow\n+COMMENT_EXPORT(\"??3@YAXPAX@Z\")                    // operator delete\n+COMMENT_EXPORT(\"??3@YAXPAXI@Z\")                   // sized operator delete\n+COMMENT_EXPORT(\"??_U@YAPAXI@Z\")                   // operator new[]\n+COMMENT_EXPORT(\"??_V@YAXPAX@Z\")                   // operator delete[]\n+#endif\n+#undef COMMENT_EXPORT\n+#else\n+#define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE\n #endif\n \n using namespace __asan;  // NOLINT\n@@ -61,12 +65,17 @@ struct nothrow_t {};\n enum class align_val_t: size_t {};\n }  // namespace std\n \n-#define OPERATOR_NEW_BODY(type) \\\n+// TODO(alekseys): throw std::bad_alloc instead of dying on OOM.\n+#define OPERATOR_NEW_BODY(type, nothrow) \\\n   GET_STACK_TRACE_MALLOC;\\\n-  return asan_memalign(0, size, &stack, type);\n-#define OPERATOR_NEW_BODY_ALIGN(type) \\\n+  void *res = asan_memalign(0, size, &stack, type);\\\n+  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();\\\n+  return res;\n+#define OPERATOR_NEW_BODY_ALIGN(type, nothrow) \\\n   GET_STACK_TRACE_MALLOC;\\\n-  return asan_memalign((uptr)align, size, &stack, type);\n+  void *res = asan_memalign((uptr)align, size, &stack, type);\\\n+  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();\\\n+  return res;\n \n // On OS X it's not enough to just provide our own 'operator new' and\n // 'operator delete' implementations, because they're going to be in the\n@@ -77,40 +86,42 @@ enum class align_val_t: size_t {};\n // OS X we need to intercept them using their mangled names.\n #if !SANITIZER_MAC\n CXX_OPERATOR_ATTRIBUTE\n-void *operator new(size_t size) { OPERATOR_NEW_BODY(FROM_NEW); }\n+void *operator new(size_t size)\n+{ OPERATOR_NEW_BODY(FROM_NEW, false /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n-void *operator new[](size_t size) { OPERATOR_NEW_BODY(FROM_NEW_BR); }\n+void *operator new[](size_t size)\n+{ OPERATOR_NEW_BODY(FROM_NEW_BR, false /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n void *operator new(size_t size, std::nothrow_t const&)\n-{ OPERATOR_NEW_BODY(FROM_NEW); }\n+{ OPERATOR_NEW_BODY(FROM_NEW, true /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n void *operator new[](size_t size, std::nothrow_t const&)\n-{ OPERATOR_NEW_BODY(FROM_NEW_BR); }\n+{ OPERATOR_NEW_BODY(FROM_NEW_BR, true /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n void *operator new(size_t size, std::align_val_t align)\n-{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW); }\n+{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW, false /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n void *operator new[](size_t size, std::align_val_t align)\n-{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW_BR); }\n+{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW_BR, false /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n void *operator new(size_t size, std::align_val_t align, std::nothrow_t const&)\n-{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW); }\n+{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW, true /*nothrow*/); }\n CXX_OPERATOR_ATTRIBUTE\n void *operator new[](size_t size, std::align_val_t align, std::nothrow_t const&)\n-{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW_BR); }\n+{ OPERATOR_NEW_BODY_ALIGN(FROM_NEW_BR, true /*nothrow*/); }\n \n #else  // SANITIZER_MAC\n INTERCEPTOR(void *, _Znwm, size_t size) {\n-  OPERATOR_NEW_BODY(FROM_NEW);\n+  OPERATOR_NEW_BODY(FROM_NEW, false /*nothrow*/);\n }\n INTERCEPTOR(void *, _Znam, size_t size) {\n-  OPERATOR_NEW_BODY(FROM_NEW_BR);\n+  OPERATOR_NEW_BODY(FROM_NEW_BR, false /*nothrow*/);\n }\n INTERCEPTOR(void *, _ZnwmRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n-  OPERATOR_NEW_BODY(FROM_NEW);\n+  OPERATOR_NEW_BODY(FROM_NEW, true /*nothrow*/);\n }\n INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n-  OPERATOR_NEW_BODY(FROM_NEW_BR);\n+  OPERATOR_NEW_BODY(FROM_NEW_BR, true /*nothrow*/);\n }\n #endif\n "}, {"sha": "15cd8eaac3e0688730847d226c15a68548dbdb08", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -62,12 +62,9 @@ struct ShadowSegmentEndpoint {\n };\n \n void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n-    // Since asan's mapping is compacting, the shadow chunk may be\n-    // not page-aligned, so we only flush the page-aligned portion.\n-    uptr page_size = GetPageSizeCached();\n-    uptr shadow_beg = RoundUpTo(MemToShadow(p), page_size);\n-    uptr shadow_end = RoundDownTo(MemToShadow(p + size), page_size);\n-    ReleaseMemoryToOS(shadow_beg, shadow_end - shadow_beg);\n+  // Since asan's mapping is compacting, the shadow chunk may be\n+  // not page-aligned, so we only flush the page-aligned portion.\n+  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n }\n \n void AsanPoisonOrUnpoisonIntraObjectRedzone(uptr ptr, uptr size, bool poison) {\n@@ -410,7 +407,7 @@ const void *__sanitizer_contiguous_container_find_bad_address(\n   // ending with end.\n   uptr kMaxRangeToCheck = 32;\n   uptr r1_beg = beg;\n-  uptr r1_end = Min(end + kMaxRangeToCheck, mid);\n+  uptr r1_end = Min(beg + kMaxRangeToCheck, mid);\n   uptr r2_beg = Max(beg, mid - kMaxRangeToCheck);\n   uptr r2_end = Min(end, mid + kMaxRangeToCheck);\n   uptr r3_beg = Max(end - kMaxRangeToCheck, mid);"}, {"sha": "942e74174c2f7c4c36a00410234e4fe014eda144", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -44,8 +44,11 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n   // for mapping shadow and zeroing out pages doesn't \"just work\", so we should\n   // probably provide higher-level interface for these operations.\n   // For now, just memset on Windows.\n-  if (value ||\n-      SANITIZER_WINDOWS == 1 ||\n+  if (value || SANITIZER_WINDOWS == 1 ||\n+      // TODO(mcgrathr): Fuchsia doesn't allow the shadow mapping to be\n+      // changed at all.  It doesn't currently have an efficient means\n+      // to zero a bunch of pages, but maybe we should add one.\n+      SANITIZER_FUCHSIA == 1 ||\n       shadow_end - shadow_beg < common_flags()->clear_shadow_mmap_threshold) {\n     REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n   } else {\n@@ -84,8 +87,8 @@ ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n   }\n }\n \n-// Calls __sanitizer::ReleaseMemoryToOS() on\n-// [MemToShadow(p), MemToShadow(p+size)] with proper rounding.\n+// Calls __sanitizer::ReleaseMemoryPagesToOS() on\n+// [MemToShadow(p), MemToShadow(p+size)].\n void FlushUnneededASanShadowMemory(uptr p, uptr size);\n \n }  // namespace __asan"}, {"sha": "e113c02a8cc7cefd87d59640e7889814f061c24b", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -31,72 +31,10 @@\n \n namespace __asan {\n \n-const char *DescribeSignalOrException(int signo) {\n-  switch (signo) {\n-    case SIGFPE:\n-      return \"FPE\";\n-    case SIGILL:\n-      return \"ILL\";\n-    case SIGABRT:\n-      return \"ABRT\";\n-    default:\n-      return \"SEGV\";\n-  }\n-}\n-\n void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n-  ScopedDeadlySignal signal_scope(GetCurrentThread());\n-  int code = (int)((siginfo_t*)siginfo)->si_code;\n-  // Write the first message using fd=2, just in case.\n-  // It may actually fail to write in case stderr is closed.\n-  internal_write(2, \"ASAN:DEADLYSIGNAL\\n\", 18);\n-  SignalContext sig = SignalContext::Create(siginfo, context);\n-\n-  // Access at a reasonable offset above SP, or slightly below it (to account\n-  // for x86_64 or PowerPC redzone, ARM push of multiple registers, etc) is\n-  // probably a stack overflow.\n-#ifdef __s390__\n-  // On s390, the fault address in siginfo points to start of the page, not\n-  // to the precise word that was accessed.  Mask off the low bits of sp to\n-  // take it into account.\n-  bool IsStackAccess = sig.addr >= (sig.sp & ~0xFFF) &&\n-                       sig.addr < sig.sp + 0xFFFF;\n-#else\n-  bool IsStackAccess = sig.addr + 512 > sig.sp && sig.addr < sig.sp + 0xFFFF;\n-#endif\n-\n-#if __powerpc__\n-  // Large stack frames can be allocated with e.g.\n-  //   lis r0,-10000\n-  //   stdux r1,r1,r0 # store sp to [sp-10000] and update sp by -10000\n-  // If the store faults then sp will not have been updated, so test above\n-  // will not work, becase the fault address will be more than just \"slightly\"\n-  // below sp.\n-  if (!IsStackAccess && IsAccessibleMemoryRange(sig.pc, 4)) {\n-    u32 inst = *(unsigned *)sig.pc;\n-    u32 ra = (inst >> 16) & 0x1F;\n-    u32 opcd = inst >> 26;\n-    u32 xo = (inst >> 1) & 0x3FF;\n-    // Check for store-with-update to sp. The instructions we accept are:\n-    //   stbu rs,d(ra)          stbux rs,ra,rb\n-    //   sthu rs,d(ra)          sthux rs,ra,rb\n-    //   stwu rs,d(ra)          stwux rs,ra,rb\n-    //   stdu rs,ds(ra)         stdux rs,ra,rb\n-    // where ra is r1 (the stack pointer).\n-    if (ra == 1 &&\n-        (opcd == 39 || opcd == 45 || opcd == 37 || opcd == 62 ||\n-         (opcd == 31 && (xo == 247 || xo == 439 || xo == 183 || xo == 181))))\n-      IsStackAccess = true;\n-  }\n-#endif // __powerpc__\n-\n-  // We also check si_code to filter out SEGV caused by something else other\n-  // then hitting the guard page or unmapped memory, like, for example,\n-  // unaligned memory access.\n-  if (IsStackAccess && (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n-    ReportStackOverflow(sig);\n-  else\n-    ReportDeadlySignal(signo, sig);\n+  StartReportDeadlySignal();\n+  SignalContext sig(siginfo, context);\n+  ReportDeadlySignal(sig);\n }\n \n // ---------------------- TSD ---------------- {{{1"}, {"sha": "51bad6e45e3e1f1c73f78a73d0ac76dac8f24830", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 42, "deletions": 88, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -58,9 +58,8 @@ void PrintMemoryByte(InternalScopedString *str, const char *before, u8 byte,\n                      bool in_shadow, const char *after) {\n   Decorator d;\n   str->append(\"%s%s%x%x%s%s\", before,\n-              in_shadow ? d.ShadowByte(byte) : d.MemoryByte(),\n-              byte >> 4, byte & 15,\n-              in_shadow ? d.EndShadowByte() : d.EndMemoryByte(), after);\n+              in_shadow ? d.ShadowByte(byte) : d.MemoryByte(), byte >> 4,\n+              byte & 15, d.Default(), after);\n }\n \n static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n@@ -86,7 +85,8 @@ bool ParseFrameDescription(const char *frame_descr,\n   char *p;\n   // This string is created by the compiler and has the following form:\n   // \"n alloc_1 alloc_2 ... alloc_n\"\n-  // where alloc_i looks like \"offset size len ObjectName\".\n+  // where alloc_i looks like \"offset size len ObjectName\"\n+  // or                       \"offset size len ObjectName:line\".\n   uptr n_objects = (uptr)internal_simple_strtoll(frame_descr, &p, 10);\n   if (n_objects == 0)\n     return false;\n@@ -99,7 +99,14 @@ bool ParseFrameDescription(const char *frame_descr,\n       return false;\n     }\n     p++;\n-    StackVarDescr var = {beg, size, p, len};\n+    char *colon_pos = internal_strchr(p, ':');\n+    uptr line = 0;\n+    uptr name_len = len;\n+    if (colon_pos != nullptr && colon_pos < p + len) {\n+      name_len = colon_pos - p;\n+      line = (uptr)internal_simple_strtoll(colon_pos + 1, nullptr, 10);\n+    }\n+    StackVarDescr var = {beg, size, p, name_len, line};\n     vars->push_back(var);\n     p += len;\n   }\n@@ -113,53 +120,15 @@ bool ParseFrameDescription(const char *frame_descr,\n // immediately after printing error report.\n class ScopedInErrorReport {\n  public:\n-  explicit ScopedInErrorReport(bool fatal = false) {\n-    halt_on_error_ = fatal || flags()->halt_on_error;\n-\n-    if (lock_.TryLock()) {\n-      StartReporting();\n-      return;\n-    }\n-\n-    // ASan found two bugs in different threads simultaneously.\n-\n-    u32 current_tid = GetCurrentTidOrInvalid();\n-    if (reporting_thread_tid_ == current_tid ||\n-        reporting_thread_tid_ == kInvalidTid) {\n-      // This is either asynch signal or nested error during error reporting.\n-      // Fail simple to avoid deadlocks in Report().\n-\n-      // Can't use Report() here because of potential deadlocks\n-      // in nested signal handlers.\n-      const char msg[] = \"AddressSanitizer: nested bug in the same thread, \"\n-                         \"aborting.\\n\";\n-      WriteToFile(kStderrFd, msg, sizeof(msg));\n-\n-      internal__exit(common_flags()->exitcode);\n-    }\n-\n-    if (halt_on_error_) {\n-      // Do not print more than one report, otherwise they will mix up.\n-      // Error reporting functions shouldn't return at this situation, as\n-      // they are effectively no-returns.\n-\n-      Report(\"AddressSanitizer: while reporting a bug found another one. \"\n-             \"Ignoring.\\n\");\n-\n-      // Sleep long enough to make sure that the thread which started\n-      // to print an error report will finish doing it.\n-      SleepForSeconds(Max(100, flags()->sleep_before_dying + 1));\n-\n-      // If we're still not dead for some reason, use raw _exit() instead of\n-      // Die() to bypass any additional checks.\n-      internal__exit(common_flags()->exitcode);\n-    } else {\n-      // The other thread will eventually finish reporting\n-      // so it's safe to wait\n-      lock_.Lock();\n-    }\n-\n-    StartReporting();\n+  explicit ScopedInErrorReport(bool fatal = false)\n+      : halt_on_error_(fatal || flags()->halt_on_error) {\n+    // Make sure the registry and sanitizer report mutexes are locked while\n+    // we're printing an error report.\n+    // We can lock them only here to avoid self-deadlock in case of\n+    // recursive reports.\n+    asanThreadRegistry().Lock();\n+    Printf(\n+        \"=================================================================\\n\");\n   }\n \n   ~ScopedInErrorReport() {\n@@ -177,6 +146,8 @@ class ScopedInErrorReport {\n     if (common_flags()->print_cmdline)\n       PrintCmdline();\n \n+    if (common_flags()->print_module_map == 2) PrintModuleMap();\n+\n     // Copy the message buffer so that we could start logging without holding a\n     // lock that gets aquired during printing.\n     InternalScopedBuffer<char> buffer_copy(kErrorMessageBufferSize);\n@@ -192,14 +163,19 @@ class ScopedInErrorReport {\n       error_report_callback(buffer_copy.data());\n     }\n \n+    if (halt_on_error_ && common_flags()->abort_on_error) {\n+      // On Android the message is truncated to 512 characters.\n+      // FIXME: implement \"compact\" error format, possibly without, or with\n+      // highly compressed stack traces?\n+      // FIXME: or just use the summary line as abort message?\n+      SetAbortMessage(buffer_copy.data());\n+    }\n+\n     // In halt_on_error = false mode, reset the current error object (before\n     // unlocking).\n     if (!halt_on_error_)\n       internal_memset(&current_error_, 0, sizeof(current_error_));\n \n-    CommonSanitizerReportMutex.Unlock();\n-    reporting_thread_tid_ = kInvalidTid;\n-    lock_.Unlock();\n     if (halt_on_error_) {\n       Report(\"ABORTING\\n\");\n       Die();\n@@ -217,39 +193,18 @@ class ScopedInErrorReport {\n   }\n \n  private:\n-  void StartReporting() {\n-    // Make sure the registry and sanitizer report mutexes are locked while\n-    // we're printing an error report.\n-    // We can lock them only here to avoid self-deadlock in case of\n-    // recursive reports.\n-    asanThreadRegistry().Lock();\n-    CommonSanitizerReportMutex.Lock();\n-    reporting_thread_tid_ = GetCurrentTidOrInvalid();\n-    Printf(\"====================================================\"\n-           \"=============\\n\");\n-  }\n-\n-  static StaticSpinMutex lock_;\n-  static u32 reporting_thread_tid_;\n+  ScopedErrorReportLock error_report_lock_;\n   // Error currently being reported. This enables the destructor to interact\n   // with the debugger and point it to an error description.\n   static ErrorDescription current_error_;\n   bool halt_on_error_;\n };\n \n-StaticSpinMutex ScopedInErrorReport::lock_;\n-u32 ScopedInErrorReport::reporting_thread_tid_ = kInvalidTid;\n ErrorDescription ScopedInErrorReport::current_error_;\n \n-void ReportStackOverflow(const SignalContext &sig) {\n+void ReportDeadlySignal(const SignalContext &sig) {\n   ScopedInErrorReport in_report(/*fatal*/ true);\n-  ErrorStackOverflow error(GetCurrentTidOrInvalid(), sig);\n-  in_report.ReportError(error);\n-}\n-\n-void ReportDeadlySignal(int signo, const SignalContext &sig) {\n-  ScopedInErrorReport in_report(/*fatal*/ true);\n-  ErrorDeadlySignal error(GetCurrentTidOrInvalid(), sig, signo);\n+  ErrorDeadlySignal error(GetCurrentTidOrInvalid(), sig);\n   in_report.ReportError(error);\n }\n \n@@ -425,7 +380,7 @@ void __asan_describe_address(uptr addr) {\n }\n \n int __asan_report_present() {\n-  return ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric;\n+  return ScopedInErrorReport::CurrentError().kind != kErrorKindInvalid;\n }\n \n uptr __asan_get_report_pc() {\n@@ -447,9 +402,11 @@ uptr __asan_get_report_sp() {\n }\n \n uptr __asan_get_report_address() {\n-  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n-    return ScopedInErrorReport::CurrentError()\n-        .Generic.addr_description.Address();\n+  ErrorDescription &err = ScopedInErrorReport::CurrentError();\n+  if (err.kind == kErrorKindGeneric)\n+    return err.Generic.addr_description.Address();\n+  else if (err.kind == kErrorKindDoubleFree)\n+    return err.DoubleFree.addr_description.addr;\n   return 0;\n }\n \n@@ -468,7 +425,7 @@ uptr __asan_get_report_access_size() {\n const char *__asan_get_report_description() {\n   if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n     return ScopedInErrorReport::CurrentError().Generic.bug_descr;\n-  return nullptr;\n+  return ScopedInErrorReport::CurrentError().Base.scariness.GetDescription();\n }\n \n extern \"C\" {\n@@ -482,9 +439,6 @@ void __sanitizer_ptr_cmp(void *a, void *b) {\n }\n } // extern \"C\"\n \n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default implementation of __asan_on_error that does nothing\n // and may be overriden by user.\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n-void __asan_on_error() {}\n-#endif\n+SANITIZER_INTERFACE_WEAK_DEF(void, __asan_on_error, void) {}"}, {"sha": "5d47712bd2d2407e3bc1dc89710b396a98fa229e", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -21,6 +21,7 @@ struct StackVarDescr {\n   uptr size;\n   const char *name_pos;\n   uptr name_len;\n+  uptr line;\n };\n \n // Returns the number of globals close to the provided address and copies\n@@ -43,8 +44,7 @@ bool ParseFrameDescription(const char *frame_descr,\n // Different kinds of error reports.\n void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n                         uptr access_size, u32 exp, bool fatal);\n-void ReportStackOverflow(const SignalContext &sig);\n-void ReportDeadlySignal(int signo, const SignalContext &sig);\n+void ReportDeadlySignal(const SignalContext &sig);\n void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n                                  BufferedStackTrace *free_stack);\n void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);"}, {"sha": "3905658a494218b9b910c4855cc214bf64f2249f", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 16, "deletions": 137, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -44,6 +44,7 @@ static void AsanDie() {\n     // Don't die twice - run a busy loop.\n     while (1) { }\n   }\n+  if (common_flags()->print_module_map >= 1) PrintModuleMap();\n   if (flags()->sleep_before_dying) {\n     Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_before_dying);\n     SleepForSeconds(flags()->sleep_before_dying);\n@@ -81,26 +82,6 @@ void ShowStatsAndAbort() {\n   Die();\n }\n \n-// ---------------------- mmap -------------------- {{{1\n-// Reserve memory range [beg, end].\n-// We need to use inclusive range because end+1 may not be representable.\n-void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n-  CHECK_EQ((beg % GetMmapGranularity()), 0);\n-  CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n-  uptr size = end - beg + 1;\n-  DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n-  void *res = MmapFixedNoReserve(beg, size, name);\n-  if (res != (void*)beg) {\n-    Report(\"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n-           \"Perhaps you're using ulimit -v\\n\", size);\n-    Abort();\n-  }\n-  if (common_flags()->no_huge_pages_for_shadow)\n-    NoHugePagesInRegion(beg, size);\n-  if (common_flags()->use_madv_dontdump)\n-    DontDumpShadowMemory(beg, size);\n-}\n-\n // --------------- LowLevelAllocateCallbac ---------- {{{1\n static void OnLowLevelAllocate(uptr ptr, uptr size) {\n   PoisonShadow(ptr, size, kAsanInternalHeapMagic);\n@@ -332,46 +313,7 @@ static void InitializeHighMemEnd() {\n   CHECK_EQ((kHighMemBeg % GetMmapGranularity()), 0);\n }\n \n-static void ProtectGap(uptr addr, uptr size) {\n-  if (!flags()->protect_shadow_gap) {\n-    // The shadow gap is unprotected, so there is a chance that someone\n-    // is actually using this memory. Which means it needs a shadow...\n-    uptr GapShadowBeg = RoundDownTo(MEM_TO_SHADOW(addr), GetPageSizeCached());\n-    uptr GapShadowEnd =\n-        RoundUpTo(MEM_TO_SHADOW(addr + size), GetPageSizeCached()) - 1;\n-    if (Verbosity())\n-      Printf(\"protect_shadow_gap=0:\"\n-             \" not protecting shadow gap, allocating gap's shadow\\n\"\n-             \"|| `[%p, %p]` || ShadowGap's shadow ||\\n\", GapShadowBeg,\n-             GapShadowEnd);\n-    ReserveShadowMemoryRange(GapShadowBeg, GapShadowEnd,\n-                             \"unprotected gap shadow\");\n-    return;\n-  }\n-  void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n-  if (addr == (uptr)res)\n-    return;\n-  // A few pages at the start of the address space can not be protected.\n-  // But we really want to protect as much as possible, to prevent this memory\n-  // being returned as a result of a non-FIXED mmap().\n-  if (addr == kZeroBaseShadowStart) {\n-    uptr step = GetMmapGranularity();\n-    while (size > step && addr < kZeroBaseMaxShadowStart) {\n-      addr += step;\n-      size -= step;\n-      void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n-      if (addr == (uptr)res)\n-        return;\n-    }\n-  }\n-\n-  Report(\"ERROR: Failed to protect the shadow gap. \"\n-         \"ASan cannot proceed correctly. ABORTING.\\n\");\n-  DumpProcessMap();\n-  Die();\n-}\n-\n-static void PrintAddressSpaceLayout() {\n+void PrintAddressSpaceLayout() {\n   Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n          (void*)kHighMemBeg, (void*)kHighMemEnd);\n   Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n@@ -408,6 +350,8 @@ static void PrintAddressSpaceLayout() {\n   Printf(\"redzone=%zu\\n\", (uptr)flags()->redzone);\n   Printf(\"max_redzone=%zu\\n\", (uptr)flags()->max_redzone);\n   Printf(\"quarantine_size_mb=%zuM\\n\", (uptr)flags()->quarantine_size_mb);\n+  Printf(\"thread_local_quarantine_size_kb=%zuK\\n\",\n+         (uptr)flags()->thread_local_quarantine_size_kb);\n   Printf(\"malloc_context_size=%zu\\n\",\n          (uptr)common_flags()->malloc_context_size);\n \n@@ -472,78 +416,9 @@ static void AsanInitInternal() {\n \n   ReplaceSystemMalloc();\n \n-  // Set the shadow memory address to uninitialized.\n-  __asan_shadow_memory_dynamic_address = kDefaultShadowSentinel;\n-\n-  uptr shadow_start = kLowShadowBeg;\n-  // Detect if a dynamic shadow address must used and find a available location\n-  // when necessary. When dynamic address is used, the macro |kLowShadowBeg|\n-  // expands to |__asan_shadow_memory_dynamic_address| which is\n-  // |kDefaultShadowSentinel|.\n-  if (shadow_start == kDefaultShadowSentinel) {\n-    __asan_shadow_memory_dynamic_address = 0;\n-    CHECK_EQ(0, kLowShadowBeg);\n-\n-    uptr granularity = GetMmapGranularity();\n-    uptr alignment = 8 * granularity;\n-    uptr left_padding = granularity;\n-    uptr space_size = kHighShadowEnd + left_padding;\n-\n-    shadow_start = FindAvailableMemoryRange(space_size, alignment, granularity);\n-    CHECK_NE((uptr)0, shadow_start);\n-    CHECK(IsAligned(shadow_start, alignment));\n-  }\n-  // Update the shadow memory address (potentially) used by instrumentation.\n-  __asan_shadow_memory_dynamic_address = shadow_start;\n-\n-  if (kLowShadowBeg)\n-    shadow_start -= GetMmapGranularity();\n-  bool full_shadow_is_available =\n-      MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n-\n-#if SANITIZER_LINUX && defined(__x86_64__) && defined(_LP64) &&                \\\n-    !ASAN_FIXED_MAPPING\n-  if (!full_shadow_is_available) {\n-    kMidMemBeg = kLowMemEnd < 0x3000000000ULL ? 0x3000000000ULL : 0;\n-    kMidMemEnd = kLowMemEnd < 0x3000000000ULL ? 0x4fffffffffULL : 0;\n-  }\n-#endif\n-\n-  if (Verbosity()) PrintAddressSpaceLayout();\n-\n   DisableCoreDumperIfNecessary();\n \n-  if (full_shadow_is_available) {\n-    // mmap the low shadow plus at least one page at the left.\n-    if (kLowShadowBeg)\n-      ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n-    // mmap the high shadow.\n-    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n-    // protect the gap.\n-    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n-    CHECK_EQ(kShadowGapEnd, kHighShadowBeg - 1);\n-  } else if (kMidMemBeg &&\n-      MemoryRangeIsAvailable(shadow_start, kMidMemBeg - 1) &&\n-      MemoryRangeIsAvailable(kMidMemEnd + 1, kHighShadowEnd)) {\n-    CHECK(kLowShadowBeg != kLowShadowEnd);\n-    // mmap the low shadow plus at least one page at the left.\n-    ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n-    // mmap the mid shadow.\n-    ReserveShadowMemoryRange(kMidShadowBeg, kMidShadowEnd, \"mid shadow\");\n-    // mmap the high shadow.\n-    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n-    // protect the gaps.\n-    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n-    ProtectGap(kShadowGap2Beg, kShadowGap2End - kShadowGap2Beg + 1);\n-    ProtectGap(kShadowGap3Beg, kShadowGap3End - kShadowGap3Beg + 1);\n-  } else {\n-    Report(\"Shadow memory range interleaves with an existing memory mapping. \"\n-           \"ASan cannot proceed correctly. ABORTING.\\n\");\n-    Report(\"ASan shadow was supposed to be located in the [%p-%p] range.\\n\",\n-           shadow_start, kHighShadowEnd);\n-    DumpProcessMap();\n-    Die();\n-  }\n+  InitializeShadowMemory();\n \n   AsanTSDInit(PlatformTSDDtor);\n   InstallDeadlySignalHandlers(AsanOnDeadlySignal);\n@@ -574,20 +449,18 @@ static void AsanInitInternal() {\n   InitTlsSize();\n \n   // Create main thread.\n-  AsanThread *main_thread = AsanThread::Create(\n-      /* start_routine */ nullptr, /* arg */ nullptr, /* parent_tid */ 0,\n-      /* stack */ nullptr, /* detached */ true);\n+  AsanThread *main_thread = CreateMainThread();\n   CHECK_EQ(0, main_thread->tid());\n-  SetCurrentThread(main_thread);\n-  main_thread->ThreadStart(internal_getpid(),\n-                           /* signal_thread_is_registered */ nullptr);\n   force_interface_symbols();  // no-op.\n   SanitizerInitializeUnwinder();\n \n   if (CAN_SANITIZE_LEAKS) {\n     __lsan::InitCommonLsan();\n     if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n-      Atexit(__lsan::DoLeakCheck);\n+      if (flags()->halt_on_error)\n+        Atexit(__lsan::DoLeakCheck);\n+      else\n+        Atexit(__lsan::DoRecoverableLeakCheckVoid);\n     }\n   }\n \n@@ -607,6 +480,11 @@ static void AsanInitInternal() {\n   }\n \n   VReport(1, \"AddressSanitizer Init done\\n\");\n+\n+  if (flags()->sleep_after_init) {\n+    Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_after_init);\n+    SleepForSeconds(flags()->sleep_after_init);\n+  }\n }\n \n // Initialize as requested from some part of ASan runtime library (interceptors,\n@@ -646,6 +524,7 @@ void NOINLINE __asan_handle_no_return() {\n     top = curr_thread->stack_top();\n     bottom = ((uptr)&local_stack - PageSize) & ~(PageSize - 1);\n   } else {\n+    CHECK(!SANITIZER_FUCHSIA);\n     // If we haven't seen this thread, try asking the OS for stack bounds.\n     uptr tls_addr, tls_size, stack_size;\n     GetThreadStackAndTls(/*main=*/false, &bottom, &stack_size, &tls_addr,"}, {"sha": "aa947ed2732afb91ee2df1f860b85d1ee197ceb1", "filename": "libsanitizer/asan/asan_scariness_score.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_scariness_score.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_scariness_score.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_scariness_score.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -45,7 +45,7 @@ struct ScarinessScoreBase {\n   };\n   int GetScore() const { return score; }\n   const char *GetDescription() const { return descr; }\n-  void Print() {\n+  void Print() const {\n     if (score && flags()->print_scariness)\n       Printf(\"SCARINESS: %d (%s)\\n\", score, descr);\n   }"}, {"sha": "9629b36798ff565e30412e5a82314892da0c4a58", "filename": "libsanitizer/asan/asan_shadow_setup.cc", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_shadow_setup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_shadow_setup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_shadow_setup.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,159 @@\n+//===-- asan_shadow_setup.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Set up the shadow memory.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+// asan_fuchsia.cc has its own InitializeShadowMemory implementation.\n+#if !SANITIZER_FUCHSIA\n+\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+\n+namespace __asan {\n+\n+// ---------------------- mmap -------------------- {{{1\n+// Reserve memory range [beg, end].\n+// We need to use inclusive range because end+1 may not be representable.\n+void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n+  CHECK_EQ((beg % GetMmapGranularity()), 0);\n+  CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n+  uptr size = end - beg + 1;\n+  DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n+  void *res = MmapFixedNoReserve(beg, size, name);\n+  if (res != (void *)beg) {\n+    Report(\n+        \"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n+        \"Perhaps you're using ulimit -v\\n\",\n+        size);\n+    Abort();\n+  }\n+  if (common_flags()->no_huge_pages_for_shadow) NoHugePagesInRegion(beg, size);\n+  if (common_flags()->use_madv_dontdump) DontDumpShadowMemory(beg, size);\n+}\n+\n+static void ProtectGap(uptr addr, uptr size) {\n+  if (!flags()->protect_shadow_gap) {\n+    // The shadow gap is unprotected, so there is a chance that someone\n+    // is actually using this memory. Which means it needs a shadow...\n+    uptr GapShadowBeg = RoundDownTo(MEM_TO_SHADOW(addr), GetPageSizeCached());\n+    uptr GapShadowEnd =\n+        RoundUpTo(MEM_TO_SHADOW(addr + size), GetPageSizeCached()) - 1;\n+    if (Verbosity())\n+      Printf(\n+          \"protect_shadow_gap=0:\"\n+          \" not protecting shadow gap, allocating gap's shadow\\n\"\n+          \"|| `[%p, %p]` || ShadowGap's shadow ||\\n\",\n+          GapShadowBeg, GapShadowEnd);\n+    ReserveShadowMemoryRange(GapShadowBeg, GapShadowEnd,\n+                             \"unprotected gap shadow\");\n+    return;\n+  }\n+  void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n+  if (addr == (uptr)res) return;\n+  // A few pages at the start of the address space can not be protected.\n+  // But we really want to protect as much as possible, to prevent this memory\n+  // being returned as a result of a non-FIXED mmap().\n+  if (addr == kZeroBaseShadowStart) {\n+    uptr step = GetMmapGranularity();\n+    while (size > step && addr < kZeroBaseMaxShadowStart) {\n+      addr += step;\n+      size -= step;\n+      void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n+      if (addr == (uptr)res) return;\n+    }\n+  }\n+\n+  Report(\n+      \"ERROR: Failed to protect the shadow gap. \"\n+      \"ASan cannot proceed correctly. ABORTING.\\n\");\n+  DumpProcessMap();\n+  Die();\n+}\n+\n+static void MaybeReportLinuxPIEBug() {\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__aarch64__))\n+  Report(\"This might be related to ELF_ET_DYN_BASE change in Linux 4.12.\\n\");\n+  Report(\n+      \"See https://github.com/google/sanitizers/issues/856 for possible \"\n+      \"workarounds.\\n\");\n+#endif\n+}\n+\n+void InitializeShadowMemory() {\n+  // Set the shadow memory address to uninitialized.\n+  __asan_shadow_memory_dynamic_address = kDefaultShadowSentinel;\n+\n+  uptr shadow_start = kLowShadowBeg;\n+  // Detect if a dynamic shadow address must used and find a available location\n+  // when necessary. When dynamic address is used, the macro |kLowShadowBeg|\n+  // expands to |__asan_shadow_memory_dynamic_address| which is\n+  // |kDefaultShadowSentinel|.\n+  if (shadow_start == kDefaultShadowSentinel) {\n+    __asan_shadow_memory_dynamic_address = 0;\n+    CHECK_EQ(0, kLowShadowBeg);\n+    shadow_start = FindDynamicShadowStart();\n+  }\n+  // Update the shadow memory address (potentially) used by instrumentation.\n+  __asan_shadow_memory_dynamic_address = shadow_start;\n+\n+  if (kLowShadowBeg) shadow_start -= GetMmapGranularity();\n+  bool full_shadow_is_available =\n+      MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n+\n+#if SANITIZER_LINUX && defined(__x86_64__) && defined(_LP64) && \\\n+    !ASAN_FIXED_MAPPING\n+  if (!full_shadow_is_available) {\n+    kMidMemBeg = kLowMemEnd < 0x3000000000ULL ? 0x3000000000ULL : 0;\n+    kMidMemEnd = kLowMemEnd < 0x3000000000ULL ? 0x4fffffffffULL : 0;\n+  }\n+#endif\n+\n+  if (Verbosity()) PrintAddressSpaceLayout();\n+\n+  if (full_shadow_is_available) {\n+    // mmap the low shadow plus at least one page at the left.\n+    if (kLowShadowBeg)\n+      ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n+    // mmap the high shadow.\n+    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n+    // protect the gap.\n+    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n+    CHECK_EQ(kShadowGapEnd, kHighShadowBeg - 1);\n+  } else if (kMidMemBeg &&\n+             MemoryRangeIsAvailable(shadow_start, kMidMemBeg - 1) &&\n+             MemoryRangeIsAvailable(kMidMemEnd + 1, kHighShadowEnd)) {\n+    CHECK(kLowShadowBeg != kLowShadowEnd);\n+    // mmap the low shadow plus at least one page at the left.\n+    ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n+    // mmap the mid shadow.\n+    ReserveShadowMemoryRange(kMidShadowBeg, kMidShadowEnd, \"mid shadow\");\n+    // mmap the high shadow.\n+    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n+    // protect the gaps.\n+    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n+    ProtectGap(kShadowGap2Beg, kShadowGap2End - kShadowGap2Beg + 1);\n+    ProtectGap(kShadowGap3Beg, kShadowGap3End - kShadowGap3Beg + 1);\n+  } else {\n+    Report(\n+        \"Shadow memory range interleaves with an existing memory mapping. \"\n+        \"ASan cannot proceed correctly. ABORTING.\\n\");\n+    Report(\"ASan shadow was supposed to be located in the [%p-%p] range.\\n\",\n+           shadow_start, kHighShadowEnd);\n+    MaybeReportLinuxPIEBug();\n+    DumpProcessMap();\n+    Die();\n+  }\n+}\n+\n+}  // namespace __asan\n+\n+#endif  // !SANITIZER_FUCHSIA"}, {"sha": "aa8c4cdc2f2db4498353f6d99e2d84b09ac14b08", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -39,10 +39,6 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n   stack->size = 0;\n   if (LIKELY(asan_inited)) {\n     if ((t = GetCurrentThread()) && !t->isUnwinding()) {\n-      // On FreeBSD the slow unwinding that leverages _Unwind_Backtrace()\n-      // yields the call stack of the signal's handler and not of the code\n-      // that raised the signal (as it does on Linux).\n-      if (SANITIZER_FREEBSD && t->isInDeadlySignal()) fast = true;\n       uptr stack_top = t->stack_top();\n       uptr stack_bottom = t->stack_bottom();\n       ScopedUnwinding unwind_scope(t);"}, {"sha": "00406020054df144dea0f1e53bac948022c6b29e", "filename": "libsanitizer/asan/asan_suppressions.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -29,15 +29,9 @@ static const char *kSuppressionTypes[] = {\n     kInterceptorName, kInterceptorViaFunction, kInterceptorViaLibrary,\n     kODRViolation};\n \n-extern \"C\" {\n-#if SANITIZER_SUPPORTS_WEAK_HOOKS\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-const char *__asan_default_suppressions();\n-#else\n-// No week hooks, provide empty implementation.\n-const char *__asan_default_suppressions() { return \"\"; }\n-#endif  // SANITIZER_SUPPORTS_WEAK_HOOKS\n-}  // extern \"C\"\n+SANITIZER_INTERFACE_WEAK_DEF(const char *, __asan_default_suppressions, void) {\n+  return \"\";\n+}\n \n void InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);"}, {"sha": "d0fdf6e984787242a62587fe7b16c3eeb6cf1bd8", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -25,11 +25,6 @@ namespace __asan {\n \n // AsanThreadContext implementation.\n \n-struct CreateThreadContextArgs {\n-  AsanThread *thread;\n-  StackTrace *stack;\n-};\n-\n void AsanThreadContext::OnCreated(void *arg) {\n   CreateThreadContextArgs *args = static_cast<CreateThreadContextArgs*>(arg);\n   if (args->stack)\n@@ -86,7 +81,7 @@ AsanThread *AsanThread::Create(thread_callback_t start_routine, void *arg,\n   AsanThread *thread = (AsanThread*)MmapOrDie(size, __func__);\n   thread->start_routine_ = start_routine;\n   thread->arg_ = arg;\n-  CreateThreadContextArgs args = { thread, stack };\n+  AsanThreadContext::CreateThreadContextArgs args = {thread, stack};\n   asanThreadRegistry().CreateThread(*reinterpret_cast<uptr *>(thread), detached,\n                                     parent_tid, &args);\n \n@@ -164,16 +159,19 @@ void AsanThread::FinishSwitchFiber(FakeStack *fake_stack_save,\n }\n \n inline AsanThread::StackBounds AsanThread::GetStackBounds() const {\n-  if (!atomic_load(&stack_switching_, memory_order_acquire))\n-    return StackBounds{stack_bottom_, stack_top_};  // NOLINT\n+  if (!atomic_load(&stack_switching_, memory_order_acquire)) {\n+    // Make sure the stack bounds are fully initialized.\n+    if (stack_bottom_ >= stack_top_) return {0, 0};\n+    return {stack_bottom_, stack_top_};\n+  }\n   char local;\n   const uptr cur_stack = (uptr)&local;\n   // Note: need to check next stack first, because FinishSwitchFiber\n   // may be in process of overwriting stack_top_/bottom_. But in such case\n   // we are already on the next stack.\n   if (cur_stack >= next_stack_bottom_ && cur_stack < next_stack_top_)\n-    return StackBounds{next_stack_bottom_, next_stack_top_};  // NOLINT\n-  return StackBounds{stack_bottom_, stack_top_};              // NOLINT\n+    return {next_stack_bottom_, next_stack_top_};\n+  return {stack_bottom_, stack_top_};\n }\n \n uptr AsanThread::stack_top() {\n@@ -218,12 +216,12 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n   return nullptr;\n }\n \n-void AsanThread::Init() {\n+void AsanThread::Init(const InitOptions *options) {\n   next_stack_top_ = next_stack_bottom_ = 0;\n   atomic_store(&stack_switching_, false, memory_order_release);\n   fake_stack_ = nullptr;  // Will be initialized lazily if needed.\n   CHECK_EQ(this->stack_size(), 0U);\n-  SetThreadStackAndTls();\n+  SetThreadStackAndTls(options);\n   CHECK_GT(this->stack_size(), 0U);\n   CHECK(AddrIsInMem(stack_bottom_));\n   CHECK(AddrIsInMem(stack_top_ - 1));\n@@ -234,10 +232,15 @@ void AsanThread::Init() {\n           &local);\n }\n \n+// Fuchsia doesn't use ThreadStart.\n+// asan_fuchsia.c defines CreateMainThread and SetThreadStackAndTls.\n+#if !SANITIZER_FUCHSIA\n+\n thread_return_t AsanThread::ThreadStart(\n-    uptr os_id, atomic_uintptr_t *signal_thread_is_registered) {\n+    tid_t os_id, atomic_uintptr_t *signal_thread_is_registered) {\n   Init();\n-  asanThreadRegistry().StartThread(tid(), os_id, nullptr);\n+  asanThreadRegistry().StartThread(tid(), os_id, /*workerthread*/ false,\n+                                   nullptr);\n   if (signal_thread_is_registered)\n     atomic_store(signal_thread_is_registered, 1, memory_order_release);\n \n@@ -264,7 +267,21 @@ thread_return_t AsanThread::ThreadStart(\n   return res;\n }\n \n-void AsanThread::SetThreadStackAndTls() {\n+AsanThread *CreateMainThread() {\n+  AsanThread *main_thread = AsanThread::Create(\n+      /* start_routine */ nullptr, /* arg */ nullptr, /* parent_tid */ 0,\n+      /* stack */ nullptr, /* detached */ true);\n+  SetCurrentThread(main_thread);\n+  main_thread->ThreadStart(internal_getpid(),\n+                           /* signal_thread_is_registered */ nullptr);\n+  return main_thread;\n+}\n+\n+// This implementation doesn't use the argument, which is just passed down\n+// from the caller of Init (which see, above).  It's only there to support\n+// OS-specific implementations that need more information passed through.\n+void AsanThread::SetThreadStackAndTls(const InitOptions *options) {\n+  DCHECK_EQ(options, nullptr);\n   uptr tls_size = 0;\n   uptr stack_size = 0;\n   GetThreadStackAndTls(tid() == 0, const_cast<uptr *>(&stack_bottom_),\n@@ -277,6 +294,8 @@ void AsanThread::SetThreadStackAndTls() {\n   CHECK(AddrIsInStack((uptr)&local));\n }\n \n+#endif  // !SANITIZER_FUCHSIA\n+\n void AsanThread::ClearShadowForThreadStackAndTLS() {\n   PoisonShadow(stack_bottom_, stack_top_ - stack_bottom_, 0);\n   if (tls_begin_ != tls_end_)\n@@ -297,24 +316,27 @@ bool AsanThread::GetStackFrameAccessByAddr(uptr addr,\n     return true;\n   }\n   uptr aligned_addr = addr & ~(SANITIZER_WORDSIZE/8 - 1);  // align addr.\n+  uptr mem_ptr = RoundDownTo(aligned_addr, SHADOW_GRANULARITY);\n   u8 *shadow_ptr = (u8*)MemToShadow(aligned_addr);\n   u8 *shadow_bottom = (u8*)MemToShadow(bottom);\n \n   while (shadow_ptr >= shadow_bottom &&\n          *shadow_ptr != kAsanStackLeftRedzoneMagic) {\n     shadow_ptr--;\n+    mem_ptr -= SHADOW_GRANULARITY;\n   }\n \n   while (shadow_ptr >= shadow_bottom &&\n          *shadow_ptr == kAsanStackLeftRedzoneMagic) {\n     shadow_ptr--;\n+    mem_ptr -= SHADOW_GRANULARITY;\n   }\n \n   if (shadow_ptr < shadow_bottom) {\n     return false;\n   }\n \n-  uptr* ptr = (uptr*)SHADOW_TO_MEM((uptr)(shadow_ptr + 1));\n+  uptr* ptr = (uptr*)(mem_ptr + SHADOW_GRANULARITY);\n   CHECK(ptr[0] == kCurrentStackFrameMagic);\n   access->offset = addr - (uptr)ptr;\n   access->frame_pc = ptr[2];\n@@ -389,7 +411,7 @@ void EnsureMainThreadIDIsCorrect() {\n     context->os_id = GetTid();\n }\n \n-__asan::AsanThread *GetAsanThreadByOsIDLocked(uptr os_id) {\n+__asan::AsanThread *GetAsanThreadByOsIDLocked(tid_t os_id) {\n   __asan::AsanThreadContext *context = static_cast<__asan::AsanThreadContext *>(\n       __asan::asanThreadRegistry().FindThreadContextByOsIDLocked(os_id));\n   if (!context) return nullptr;\n@@ -399,7 +421,7 @@ __asan::AsanThread *GetAsanThreadByOsIDLocked(uptr os_id) {\n \n // --- Implementation of LSan-specific functions --- {{{1\n namespace __lsan {\n-bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n+bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n                            uptr *cache_end, DTLS **dtls) {\n   __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);\n@@ -415,7 +437,7 @@ bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n   return true;\n }\n \n-void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n+void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n                             void *arg) {\n   __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);\n   if (t && t->has_fake_stack())"}, {"sha": "f7a91f3e73b0a2413531b45abf1dcb874429aed4", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -47,6 +47,11 @@ class AsanThreadContext : public ThreadContextBase {\n \n   void OnCreated(void *arg) override;\n   void OnFinished() override;\n+\n+  struct CreateThreadContextArgs {\n+    AsanThread *thread;\n+    StackTrace *stack;\n+  };\n };\n \n // AsanThreadContext objects are never freed, so we need many of them.\n@@ -60,8 +65,10 @@ class AsanThread {\n   static void TSDDtor(void *tsd);\n   void Destroy();\n \n-  void Init();  // Should be called from the thread itself.\n-  thread_return_t ThreadStart(uptr os_id,\n+  struct InitOptions;\n+  void Init(const InitOptions *options = nullptr);\n+\n+  thread_return_t ThreadStart(tid_t os_id,\n                               atomic_uintptr_t *signal_thread_is_registered);\n \n   uptr stack_top();\n@@ -116,17 +123,15 @@ class AsanThread {\n   bool isUnwinding() const { return unwinding_; }\n   void setUnwinding(bool b) { unwinding_ = b; }\n \n-  // True if we are in a deadly signal handler.\n-  bool isInDeadlySignal() const { return in_deadly_signal_; }\n-  void setInDeadlySignal(bool b) { in_deadly_signal_ = b; }\n-\n   AsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n   AsanStats &stats() { return stats_; }\n \n  private:\n   // NOTE: There is no AsanThread constructor. It is allocated\n   // via mmap() and *must* be valid in zero-initialized state.\n-  void SetThreadStackAndTls();\n+\n+  void SetThreadStackAndTls(const InitOptions *options);\n+\n   void ClearShadowForThreadStackAndTLS();\n   FakeStack *AsyncSignalSafeLazyInitFakeStack();\n \n@@ -156,7 +161,6 @@ class AsanThread {\n   AsanThreadLocalMallocStorage malloc_storage_;\n   AsanStats stats_;\n   bool unwinding_;\n-  bool in_deadly_signal_;\n };\n \n // ScopedUnwinding is a scope for stacktracing member of a context\n@@ -171,20 +175,6 @@ class ScopedUnwinding {\n   AsanThread *thread;\n };\n \n-// ScopedDeadlySignal is a scope for handling deadly signals.\n-class ScopedDeadlySignal {\n- public:\n-  explicit ScopedDeadlySignal(AsanThread *t) : thread(t) {\n-    if (thread) thread->setInDeadlySignal(true);\n-  }\n-  ~ScopedDeadlySignal() {\n-    if (thread) thread->setInDeadlySignal(false);\n-  }\n-\n- private:\n-  AsanThread *thread;\n-};\n-\n // Returns a single instance of registry.\n ThreadRegistry &asanThreadRegistry();\n "}, {"sha": "02c7ed11628c4f89efd53d5ed3cd440675d3c5e1", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 76, "deletions": 75, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -25,6 +25,8 @@\n #include \"asan_mapping.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n+#include \"sanitizer_common/sanitizer_win.h\"\n+#include \"sanitizer_common/sanitizer_win_defs.h\"\n \n using namespace __asan;  // NOLINT\n \n@@ -40,35 +42,50 @@ uptr __asan_get_shadow_memory_dynamic_address() {\n   __asan_init();\n   return __asan_shadow_memory_dynamic_address;\n }\n-\n-// -------------------- A workaround for the absence of weak symbols ----- {{{\n-// We don't have a direct equivalent of weak symbols when using MSVC, but we can\n-// use the /alternatename directive to tell the linker to default a specific\n-// symbol to a specific value, which works nicely for allocator hooks and\n-// __asan_default_options().\n-void __sanitizer_default_malloc_hook(void *ptr, uptr size) { }\n-void __sanitizer_default_free_hook(void *ptr) { }\n-const char* __asan_default_default_options() { return \"\"; }\n-const char* __asan_default_default_suppressions() { return \"\"; }\n-void __asan_default_on_error() {}\n-// 64-bit msvc will not prepend an underscore for symbols.\n-#ifdef _WIN64\n-#pragma comment(linker, \"/alternatename:__sanitizer_malloc_hook=__sanitizer_default_malloc_hook\")  // NOLINT\n-#pragma comment(linker, \"/alternatename:__sanitizer_free_hook=__sanitizer_default_free_hook\")      // NOLINT\n-#pragma comment(linker, \"/alternatename:__asan_default_options=__asan_default_default_options\")    // NOLINT\n-#pragma comment(linker, \"/alternatename:__asan_default_suppressions=__asan_default_default_suppressions\")    // NOLINT\n-#pragma comment(linker, \"/alternatename:__asan_on_error=__asan_default_on_error\")                  // NOLINT\n-#else\n-#pragma comment(linker, \"/alternatename:___sanitizer_malloc_hook=___sanitizer_default_malloc_hook\")  // NOLINT\n-#pragma comment(linker, \"/alternatename:___sanitizer_free_hook=___sanitizer_default_free_hook\")      // NOLINT\n-#pragma comment(linker, \"/alternatename:___asan_default_options=___asan_default_default_options\")    // NOLINT\n-#pragma comment(linker, \"/alternatename:___asan_default_suppressions=___asan_default_default_suppressions\")    // NOLINT\n-#pragma comment(linker, \"/alternatename:___asan_on_error=___asan_default_on_error\")                  // NOLINT\n-#endif\n-// }}}\n }  // extern \"C\"\n \n // ---------------------- Windows-specific interceptors ---------------- {{{\n+static LPTOP_LEVEL_EXCEPTION_FILTER default_seh_handler;\n+static LPTOP_LEVEL_EXCEPTION_FILTER user_seh_handler;\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+long __asan_unhandled_exception_filter(EXCEPTION_POINTERS *info) {\n+  EXCEPTION_RECORD *exception_record = info->ExceptionRecord;\n+  CONTEXT *context = info->ContextRecord;\n+\n+  // FIXME: Handle EXCEPTION_STACK_OVERFLOW here.\n+\n+  SignalContext sig(exception_record, context);\n+  ReportDeadlySignal(sig);\n+  UNREACHABLE(\"returned from reporting deadly signal\");\n+}\n+\n+// Wrapper SEH Handler. If the exception should be handled by asan, we call\n+// __asan_unhandled_exception_filter, otherwise, we execute the user provided\n+// exception handler or the default.\n+static long WINAPI SEHHandler(EXCEPTION_POINTERS *info) {\n+  DWORD exception_code = info->ExceptionRecord->ExceptionCode;\n+  if (__sanitizer::IsHandledDeadlyException(exception_code))\n+    return __asan_unhandled_exception_filter(info);\n+  if (user_seh_handler)\n+    return user_seh_handler(info);\n+  // Bubble out to the default exception filter.\n+  if (default_seh_handler)\n+    return default_seh_handler(info);\n+  return EXCEPTION_CONTINUE_SEARCH;\n+}\n+\n+INTERCEPTOR_WINAPI(LPTOP_LEVEL_EXCEPTION_FILTER, SetUnhandledExceptionFilter,\n+    LPTOP_LEVEL_EXCEPTION_FILTER ExceptionFilter) {\n+  CHECK(REAL(SetUnhandledExceptionFilter));\n+  if (ExceptionFilter == &SEHHandler)\n+    return REAL(SetUnhandledExceptionFilter)(ExceptionFilter);\n+  // We record the user provided exception handler to be called for all the\n+  // exceptions unhandled by asan.\n+  Swap(ExceptionFilter, user_seh_handler);\n+  return ExceptionFilter;\n+}\n+\n INTERCEPTOR_WINAPI(void, RtlRaiseException, EXCEPTION_RECORD *ExceptionRecord) {\n   CHECK(REAL(RtlRaiseException));\n   // This is a noreturn function, unless it's one of the exceptions raised to\n@@ -141,6 +158,7 @@ namespace __asan {\n \n void InitializePlatformInterceptors() {\n   ASAN_INTERCEPT_FUNC(CreateThread);\n+  ASAN_INTERCEPT_FUNC(SetUnhandledExceptionFilter);\n \n #ifdef _WIN64\n   ASAN_INTERCEPT_FUNC(__C_specific_handler);\n@@ -197,6 +215,18 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return 0;\n }\n \n+uptr FindDynamicShadowStart() {\n+  uptr granularity = GetMmapGranularity();\n+  uptr alignment = 8 * granularity;\n+  uptr left_padding = granularity;\n+  uptr space_size = kHighShadowEnd + left_padding;\n+  uptr shadow_start =\n+      FindAvailableMemoryRange(space_size, alignment, granularity, nullptr);\n+  CHECK_NE((uptr)0, shadow_start);\n+  CHECK(IsAligned(shadow_start, alignment));\n+  return shadow_start;\n+}\n+\n void AsanCheckDynamicRTPrereqs() {}\n \n void AsanCheckIncompatibleRT() {}\n@@ -257,52 +287,8 @@ void InitializePlatformExceptionHandlers() {\n #endif\n }\n \n-static LPTOP_LEVEL_EXCEPTION_FILTER default_seh_handler;\n-\n-// Check based on flags if we should report this exception.\n-static bool ShouldReportDeadlyException(unsigned code) {\n-  switch (code) {\n-    case EXCEPTION_ACCESS_VIOLATION:\n-    case EXCEPTION_IN_PAGE_ERROR:\n-      return common_flags()->handle_segv;\n-    case EXCEPTION_BREAKPOINT:\n-    case EXCEPTION_ILLEGAL_INSTRUCTION: {\n-      return common_flags()->handle_sigill;\n-    }\n-  }\n-  return false;\n-}\n-\n-// Return the textual name for this exception.\n-const char *DescribeSignalOrException(int signo) {\n-  unsigned code = signo;\n-  // Get the string description of the exception if this is a known deadly\n-  // exception.\n-  switch (code) {\n-    case EXCEPTION_ACCESS_VIOLATION:\n-      return \"access-violation\";\n-    case EXCEPTION_IN_PAGE_ERROR:\n-      return \"in-page-error\";\n-    case EXCEPTION_BREAKPOINT:\n-      return \"breakpoint\";\n-    case EXCEPTION_ILLEGAL_INSTRUCTION:\n-      return \"illegal-instruction\";\n-  }\n-  return nullptr;\n-}\n-\n-static long WINAPI SEHHandler(EXCEPTION_POINTERS *info) {\n-  EXCEPTION_RECORD *exception_record = info->ExceptionRecord;\n-  CONTEXT *context = info->ContextRecord;\n-\n-  if (ShouldReportDeadlyException(exception_record->ExceptionCode)) {\n-    SignalContext sig = SignalContext::Create(exception_record, context);\n-    ReportDeadlySignal(exception_record->ExceptionCode, sig);\n-  }\n-\n-  // FIXME: Handle EXCEPTION_STACK_OVERFLOW here.\n-\n-  return default_seh_handler(info);\n+bool IsSystemHeapAddress(uptr addr) {\n+  return ::HeapValidate(GetProcessHeap(), 0, (void*)addr) != FALSE;\n }\n \n // We want to install our own exception handler (EH) to print helpful reports\n@@ -341,10 +327,25 @@ int __asan_set_seh_filter() {\n // immediately after the CRT runs. This way, our exception filter is called\n // first and we can delegate to their filter if appropriate.\n #pragma section(\".CRT$XCAB\", long, read)  // NOLINT\n-__declspec(allocate(\".CRT$XCAB\"))\n-    int (*__intercept_seh)() = __asan_set_seh_filter;\n+__declspec(allocate(\".CRT$XCAB\")) int (*__intercept_seh)() =\n+    __asan_set_seh_filter;\n+\n+// Piggyback on the TLS initialization callback directory to initialize asan as\n+// early as possible. Initializers in .CRT$XL* are called directly by ntdll,\n+// which run before the CRT. Users also add code to .CRT$XLC, so it's important\n+// to run our initializers first.\n+static void NTAPI asan_thread_init(void *module, DWORD reason, void *reserved) {\n+  if (reason == DLL_PROCESS_ATTACH) __asan_init();\n+}\n+\n+#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XLAB\")) void (NTAPI *__asan_tls_init)(void *,\n+    unsigned long, void *) = asan_thread_init;\n #endif\n+\n+WIN_FORCE_LINK(__asan_dso_reg_hook)\n+\n // }}}\n }  // namespace __asan\n \n-#endif  // _WIN32\n+#endif  // SANITIZER_WINDOWS"}, {"sha": "31847efe77a080d0f8e5fcde43a199a9e051e357", "filename": "libsanitizer/asan/asan_win_dll_thunk.cc", "status": "modified", "additions": 83, "deletions": 390, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,375 +13,41 @@\n // See https://github.com/google/sanitizers/issues/209 for the details.\n //===----------------------------------------------------------------------===//\n \n-// Only compile this code when building asan_dll_thunk.lib\n-// Using #ifdef rather than relying on Makefiles etc.\n-// simplifies the build procedure.\n-#ifdef ASAN_DLL_THUNK\n+#ifdef SANITIZER_DLL_THUNK\n #include \"asan_init_version.h\"\n #include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_win_defs.h\"\n+#include \"sanitizer_common/sanitizer_win_dll_thunk.h\"\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n-// ---------- Function interception helper functions and macros ----------- {{{1\n-extern \"C\" {\n-void *__stdcall GetModuleHandleA(const char *module_name);\n-void *__stdcall GetProcAddress(void *module, const char *proc_name);\n-void abort();\n-}\n-\n-using namespace __sanitizer;\n-\n-static uptr getRealProcAddressOrDie(const char *name) {\n-  uptr ret =\n-      __interception::InternalGetProcAddress((void *)GetModuleHandleA(0), name);\n-  if (!ret)\n-    abort();\n-  return ret;\n-}\n-\n-// We need to intercept some functions (e.g. ASan interface, memory allocator --\n-// let's call them \"hooks\") exported by the DLL thunk and forward the hooks to\n-// the runtime in the main module.\n-// However, we don't want to keep two lists of these hooks.\n-// To avoid that, the list of hooks should be defined using the\n-// INTERCEPT_WHEN_POSSIBLE macro. Then, all these hooks can be intercepted\n-// at once by calling INTERCEPT_HOOKS().\n-\n-// Use macro+template magic to automatically generate the list of hooks.\n-// Each hook at line LINE defines a template class with a static\n-// FunctionInterceptor<LINE>::Execute() method intercepting the hook.\n-// The default implementation of FunctionInterceptor<LINE> is to call\n-// the Execute() method corresponding to the previous line.\n-template<int LINE>\n-struct FunctionInterceptor {\n-  static void Execute() { FunctionInterceptor<LINE-1>::Execute(); }\n-};\n-\n-// There shouldn't be any hooks with negative definition line number.\n-template<>\n-struct FunctionInterceptor<0> {\n-  static void Execute() {}\n-};\n-\n-#define INTERCEPT_WHEN_POSSIBLE(main_function, dll_function)                   \\\n-  template <> struct FunctionInterceptor<__LINE__> {                           \\\n-    static void Execute() {                                                    \\\n-      uptr wrapper = getRealProcAddressOrDie(main_function);                   \\\n-      if (!__interception::OverrideFunction((uptr)dll_function, wrapper, 0))   \\\n-        abort();                                                               \\\n-      FunctionInterceptor<__LINE__ - 1>::Execute();                            \\\n-    }                                                                          \\\n-  };\n-\n-// Special case of hooks -- ASan own interface functions.  Those are only called\n-// after __asan_init, thus an empty implementation is sufficient.\n-#define INTERFACE_FUNCTION(name)                                               \\\n-  extern \"C\" __declspec(noinline) void name() {                                \\\n-    volatile int prevent_icf = (__LINE__ << 8); (void)prevent_icf;             \\\n-    __debugbreak();                                                            \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name)\n-\n-// INTERCEPT_HOOKS must be used after the last INTERCEPT_WHEN_POSSIBLE.\n-#define INTERCEPT_HOOKS FunctionInterceptor<__LINE__>::Execute\n-\n-// We can't define our own version of strlen etc. because that would lead to\n-// link-time or even type mismatch errors.  Instead, we can declare a function\n-// just to be able to get its address.  Me may miss the first few calls to the\n-// functions since it can be called before __asan_init, but that would lead to\n-// false negatives in the startup code before user's global initializers, which\n-// isn't a big deal.\n-#define INTERCEPT_LIBRARY_FUNCTION(name)                                       \\\n-  extern \"C\" void name();                                                      \\\n-  INTERCEPT_WHEN_POSSIBLE(WRAPPER_NAME(name), name)\n-\n-// Disable compiler warnings that show up if we declare our own version\n-// of a compiler intrinsic (e.g. strlen).\n-#pragma warning(disable: 4391)\n-#pragma warning(disable: 4392)\n-\n-static void InterceptHooks();\n-// }}}\n-\n-// ---------- Function wrapping helpers ----------------------------------- {{{1\n-#define WRAP_V_V(name)                                                         \\\n-  extern \"C\" void name() {                                                     \\\n-    typedef void (*fntype)();                                                  \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    fn();                                                                      \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_V_W(name)                                                         \\\n-  extern \"C\" void name(void *arg) {                                            \\\n-    typedef void (*fntype)(void *arg);                                         \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    fn(arg);                                                                   \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_V_WW(name)                                                        \\\n-  extern \"C\" void name(void *arg1, void *arg2) {                               \\\n-    typedef void (*fntype)(void *, void *);                                    \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    fn(arg1, arg2);                                                            \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_V_WWW(name)                                                       \\\n-  extern \"C\" void name(void *arg1, void *arg2, void *arg3) {                   \\\n-    typedef void *(*fntype)(void *, void *, void *);                           \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    fn(arg1, arg2, arg3);                                                      \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_V(name)                                                         \\\n-  extern \"C\" void *name() {                                                    \\\n-    typedef void *(*fntype)();                                                 \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn();                                                               \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_W(name)                                                         \\\n-  extern \"C\" void *name(void *arg) {                                           \\\n-    typedef void *(*fntype)(void *arg);                                        \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn(arg);                                                            \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_WW(name)                                                        \\\n-  extern \"C\" void *name(void *arg1, void *arg2) {                              \\\n-    typedef void *(*fntype)(void *, void *);                                   \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn(arg1, arg2);                                                     \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_WWW(name)                                                       \\\n-  extern \"C\" void *name(void *arg1, void *arg2, void *arg3) {                  \\\n-    typedef void *(*fntype)(void *, void *, void *);                           \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn(arg1, arg2, arg3);                                               \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_WWWW(name)                                                      \\\n-  extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4) {      \\\n-    typedef void *(*fntype)(void *, void *, void *, void *);                   \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn(arg1, arg2, arg3, arg4);                                         \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_WWWWW(name)                                                     \\\n-  extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4,        \\\n-                        void *arg5) {                                          \\\n-    typedef void *(*fntype)(void *, void *, void *, void *, void *);           \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn(arg1, arg2, arg3, arg4, arg5);                                   \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-\n-#define WRAP_W_WWWWWW(name)                                                    \\\n-  extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4,        \\\n-                        void *arg5, void *arg6) {                              \\\n-    typedef void *(*fntype)(void *, void *, void *, void *, void *, void *);   \\\n-    static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n-    return fn(arg1, arg2, arg3, arg4, arg5, arg6);                             \\\n-  }                                                                            \\\n-  INTERCEPT_WHEN_POSSIBLE(#name, name);\n-// }}}\n-\n-// ----------------- ASan own interface functions --------------------\n-// Don't use the INTERFACE_FUNCTION machinery for this function as we actually\n-// want to call it in the __asan_init interceptor.\n-WRAP_W_V(__asan_should_detect_stack_use_after_return)\n-WRAP_W_V(__asan_get_shadow_memory_dynamic_address)\n-\n-extern \"C\" {\n-  int __asan_option_detect_stack_use_after_return;\n-  uptr __asan_shadow_memory_dynamic_address;\n-\n-  // Manually wrap __asan_init as we need to initialize\n-  // __asan_option_detect_stack_use_after_return afterwards.\n-  void __asan_init() {\n-    typedef void (*fntype)();\n-    static fntype fn = 0;\n-    // __asan_init is expected to be called by only one thread.\n-    if (fn) return;\n-\n-    fn = (fntype)getRealProcAddressOrDie(\"__asan_init\");\n-    fn();\n-    __asan_option_detect_stack_use_after_return =\n-        (__asan_should_detect_stack_use_after_return() != 0);\n-    __asan_shadow_memory_dynamic_address =\n-        (uptr)__asan_get_shadow_memory_dynamic_address();\n-    InterceptHooks();\n-  }\n-}\n-\n-extern \"C\" void __asan_version_mismatch_check() {\n-  // Do nothing.\n-}\n-\n-INTERFACE_FUNCTION(__asan_handle_no_return)\n-\n-INTERFACE_FUNCTION(__asan_report_store1)\n-INTERFACE_FUNCTION(__asan_report_store2)\n-INTERFACE_FUNCTION(__asan_report_store4)\n-INTERFACE_FUNCTION(__asan_report_store8)\n-INTERFACE_FUNCTION(__asan_report_store16)\n-INTERFACE_FUNCTION(__asan_report_store_n)\n-\n-INTERFACE_FUNCTION(__asan_report_load1)\n-INTERFACE_FUNCTION(__asan_report_load2)\n-INTERFACE_FUNCTION(__asan_report_load4)\n-INTERFACE_FUNCTION(__asan_report_load8)\n-INTERFACE_FUNCTION(__asan_report_load16)\n-INTERFACE_FUNCTION(__asan_report_load_n)\n-\n-INTERFACE_FUNCTION(__asan_store1)\n-INTERFACE_FUNCTION(__asan_store2)\n-INTERFACE_FUNCTION(__asan_store4)\n-INTERFACE_FUNCTION(__asan_store8)\n-INTERFACE_FUNCTION(__asan_store16)\n-INTERFACE_FUNCTION(__asan_storeN)\n-\n-INTERFACE_FUNCTION(__asan_load1)\n-INTERFACE_FUNCTION(__asan_load2)\n-INTERFACE_FUNCTION(__asan_load4)\n-INTERFACE_FUNCTION(__asan_load8)\n-INTERFACE_FUNCTION(__asan_load16)\n-INTERFACE_FUNCTION(__asan_loadN)\n-\n-INTERFACE_FUNCTION(__asan_memcpy);\n-INTERFACE_FUNCTION(__asan_memset);\n-INTERFACE_FUNCTION(__asan_memmove);\n-\n-INTERFACE_FUNCTION(__asan_set_shadow_00);\n-INTERFACE_FUNCTION(__asan_set_shadow_f1);\n-INTERFACE_FUNCTION(__asan_set_shadow_f2);\n-INTERFACE_FUNCTION(__asan_set_shadow_f3);\n-INTERFACE_FUNCTION(__asan_set_shadow_f5);\n-INTERFACE_FUNCTION(__asan_set_shadow_f8);\n-\n-INTERFACE_FUNCTION(__asan_alloca_poison);\n-INTERFACE_FUNCTION(__asan_allocas_unpoison);\n-\n-INTERFACE_FUNCTION(__asan_register_globals)\n-INTERFACE_FUNCTION(__asan_unregister_globals)\n-\n-INTERFACE_FUNCTION(__asan_before_dynamic_init)\n-INTERFACE_FUNCTION(__asan_after_dynamic_init)\n-\n-INTERFACE_FUNCTION(__asan_poison_stack_memory)\n-INTERFACE_FUNCTION(__asan_unpoison_stack_memory)\n+// ASan own interface functions.\n+#define INTERFACE_FUNCTION(Name) INTERCEPT_SANITIZER_FUNCTION(Name)\n+#define INTERFACE_WEAK_FUNCTION(Name) INTERCEPT_SANITIZER_WEAK_FUNCTION(Name)\n+#include \"asan_interface.inc\"\n \n-INTERFACE_FUNCTION(__asan_poison_memory_region)\n-INTERFACE_FUNCTION(__asan_unpoison_memory_region)\n+// Memory allocation functions.\n+INTERCEPT_WRAP_V_W(free)\n+INTERCEPT_WRAP_V_W(_free_base)\n+INTERCEPT_WRAP_V_WW(_free_dbg)\n \n-INTERFACE_FUNCTION(__asan_address_is_poisoned)\n-INTERFACE_FUNCTION(__asan_region_is_poisoned)\n+INTERCEPT_WRAP_W_W(malloc)\n+INTERCEPT_WRAP_W_W(_malloc_base)\n+INTERCEPT_WRAP_W_WWWW(_malloc_dbg)\n \n-INTERFACE_FUNCTION(__asan_get_current_fake_stack)\n-INTERFACE_FUNCTION(__asan_addr_is_in_fake_stack)\n+INTERCEPT_WRAP_W_WW(calloc)\n+INTERCEPT_WRAP_W_WW(_calloc_base)\n+INTERCEPT_WRAP_W_WWWWW(_calloc_dbg)\n+INTERCEPT_WRAP_W_WWW(_calloc_impl)\n \n-INTERFACE_FUNCTION(__asan_stack_malloc_0)\n-INTERFACE_FUNCTION(__asan_stack_malloc_1)\n-INTERFACE_FUNCTION(__asan_stack_malloc_2)\n-INTERFACE_FUNCTION(__asan_stack_malloc_3)\n-INTERFACE_FUNCTION(__asan_stack_malloc_4)\n-INTERFACE_FUNCTION(__asan_stack_malloc_5)\n-INTERFACE_FUNCTION(__asan_stack_malloc_6)\n-INTERFACE_FUNCTION(__asan_stack_malloc_7)\n-INTERFACE_FUNCTION(__asan_stack_malloc_8)\n-INTERFACE_FUNCTION(__asan_stack_malloc_9)\n-INTERFACE_FUNCTION(__asan_stack_malloc_10)\n+INTERCEPT_WRAP_W_WW(realloc)\n+INTERCEPT_WRAP_W_WW(_realloc_base)\n+INTERCEPT_WRAP_W_WWW(_realloc_dbg)\n+INTERCEPT_WRAP_W_WWW(_recalloc)\n+INTERCEPT_WRAP_W_WWW(_recalloc_base)\n \n-INTERFACE_FUNCTION(__asan_stack_free_0)\n-INTERFACE_FUNCTION(__asan_stack_free_1)\n-INTERFACE_FUNCTION(__asan_stack_free_2)\n-INTERFACE_FUNCTION(__asan_stack_free_4)\n-INTERFACE_FUNCTION(__asan_stack_free_5)\n-INTERFACE_FUNCTION(__asan_stack_free_6)\n-INTERFACE_FUNCTION(__asan_stack_free_7)\n-INTERFACE_FUNCTION(__asan_stack_free_8)\n-INTERFACE_FUNCTION(__asan_stack_free_9)\n-INTERFACE_FUNCTION(__asan_stack_free_10)\n-\n-// FIXME: we might want to have a sanitizer_win_dll_thunk?\n-INTERFACE_FUNCTION(__sanitizer_annotate_contiguous_container)\n-INTERFACE_FUNCTION(__sanitizer_contiguous_container_find_bad_address)\n-INTERFACE_FUNCTION(__sanitizer_cov)\n-INTERFACE_FUNCTION(__sanitizer_cov_dump)\n-INTERFACE_FUNCTION(__sanitizer_cov_indir_call16)\n-INTERFACE_FUNCTION(__sanitizer_cov_init)\n-INTERFACE_FUNCTION(__sanitizer_cov_module_init)\n-INTERFACE_FUNCTION(__sanitizer_cov_trace_basic_block)\n-INTERFACE_FUNCTION(__sanitizer_cov_trace_func_enter)\n-INTERFACE_FUNCTION(__sanitizer_cov_with_check)\n-INTERFACE_FUNCTION(__sanitizer_get_allocated_size)\n-INTERFACE_FUNCTION(__sanitizer_get_coverage_guards)\n-INTERFACE_FUNCTION(__sanitizer_get_current_allocated_bytes)\n-INTERFACE_FUNCTION(__sanitizer_get_estimated_allocated_size)\n-INTERFACE_FUNCTION(__sanitizer_get_free_bytes)\n-INTERFACE_FUNCTION(__sanitizer_get_heap_size)\n-INTERFACE_FUNCTION(__sanitizer_get_ownership)\n-INTERFACE_FUNCTION(__sanitizer_get_total_unique_caller_callee_pairs)\n-INTERFACE_FUNCTION(__sanitizer_get_total_unique_coverage)\n-INTERFACE_FUNCTION(__sanitizer_get_unmapped_bytes)\n-INTERFACE_FUNCTION(__sanitizer_maybe_open_cov_file)\n-INTERFACE_FUNCTION(__sanitizer_print_stack_trace)\n-INTERFACE_FUNCTION(__sanitizer_symbolize_pc)\n-INTERFACE_FUNCTION(__sanitizer_symbolize_global)\n-INTERFACE_FUNCTION(__sanitizer_ptr_cmp)\n-INTERFACE_FUNCTION(__sanitizer_ptr_sub)\n-INTERFACE_FUNCTION(__sanitizer_report_error_summary)\n-INTERFACE_FUNCTION(__sanitizer_reset_coverage)\n-INTERFACE_FUNCTION(__sanitizer_get_number_of_counters)\n-INTERFACE_FUNCTION(__sanitizer_update_counter_bitset_and_clear_counters)\n-INTERFACE_FUNCTION(__sanitizer_sandbox_on_notify)\n-INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n-INTERFACE_FUNCTION(__sanitizer_set_report_path)\n-INTERFACE_FUNCTION(__sanitizer_set_report_fd)\n-INTERFACE_FUNCTION(__sanitizer_unaligned_load16)\n-INTERFACE_FUNCTION(__sanitizer_unaligned_load32)\n-INTERFACE_FUNCTION(__sanitizer_unaligned_load64)\n-INTERFACE_FUNCTION(__sanitizer_unaligned_store16)\n-INTERFACE_FUNCTION(__sanitizer_unaligned_store32)\n-INTERFACE_FUNCTION(__sanitizer_unaligned_store64)\n-INTERFACE_FUNCTION(__sanitizer_verify_contiguous_container)\n-INTERFACE_FUNCTION(__sanitizer_install_malloc_and_free_hooks)\n-INTERFACE_FUNCTION(__sanitizer_start_switch_fiber)\n-INTERFACE_FUNCTION(__sanitizer_finish_switch_fiber)\n-\n-// TODO(timurrrr): Add more interface functions on the as-needed basis.\n-\n-// ----------------- Memory allocation functions ---------------------\n-WRAP_V_W(free)\n-WRAP_V_W(_free_base)\n-WRAP_V_WW(_free_dbg)\n-\n-WRAP_W_W(malloc)\n-WRAP_W_W(_malloc_base)\n-WRAP_W_WWWW(_malloc_dbg)\n-\n-WRAP_W_WW(calloc)\n-WRAP_W_WW(_calloc_base)\n-WRAP_W_WWWWW(_calloc_dbg)\n-WRAP_W_WWW(_calloc_impl)\n-\n-WRAP_W_WW(realloc)\n-WRAP_W_WW(_realloc_base)\n-WRAP_W_WWW(_realloc_dbg)\n-WRAP_W_WWW(_recalloc)\n-WRAP_W_WWW(_recalloc_base)\n-\n-WRAP_W_W(_msize)\n-WRAP_W_W(_expand)\n-WRAP_W_W(_expand_dbg)\n+INTERCEPT_WRAP_W_W(_msize)\n+INTERCEPT_WRAP_W_W(_expand)\n+INTERCEPT_WRAP_W_W(_expand_dbg)\n \n // TODO(timurrrr): Might want to add support for _aligned_* allocation\n // functions to detect a bit more bugs.  Those functions seem to wrap malloc().\n@@ -390,20 +56,6 @@ WRAP_W_W(_expand_dbg)\n \n INTERCEPT_LIBRARY_FUNCTION(atoi);\n INTERCEPT_LIBRARY_FUNCTION(atol);\n-\n-#ifdef _WIN64\n-INTERCEPT_LIBRARY_FUNCTION(__C_specific_handler);\n-#else\n-INTERCEPT_LIBRARY_FUNCTION(_except_handler3);\n-\n-// _except_handler4 checks -GS cookie which is different for each module, so we\n-// can't use INTERCEPT_LIBRARY_FUNCTION(_except_handler4).\n-INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n-  __asan_handle_no_return();\n-  return REAL(_except_handler4)(a, b, c, d);\n-}\n-#endif\n-\n INTERCEPT_LIBRARY_FUNCTION(frexp);\n INTERCEPT_LIBRARY_FUNCTION(longjmp);\n #if SANITIZER_INTERCEPT_MEMCHR\n@@ -428,30 +80,71 @@ INTERCEPT_LIBRARY_FUNCTION(strpbrk);\n INTERCEPT_LIBRARY_FUNCTION(strrchr);\n INTERCEPT_LIBRARY_FUNCTION(strspn);\n INTERCEPT_LIBRARY_FUNCTION(strstr);\n+INTERCEPT_LIBRARY_FUNCTION(strtok);\n INTERCEPT_LIBRARY_FUNCTION(strtol);\n INTERCEPT_LIBRARY_FUNCTION(wcslen);\n+INTERCEPT_LIBRARY_FUNCTION(wcsnlen);\n+\n+#ifdef _WIN64\n+INTERCEPT_LIBRARY_FUNCTION(__C_specific_handler);\n+#else\n+INTERCEPT_LIBRARY_FUNCTION(_except_handler3);\n+// _except_handler4 checks -GS cookie which is different for each module, so we\n+// can't use INTERCEPT_LIBRARY_FUNCTION(_except_handler4).\n+INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n+  __asan_handle_no_return();\n+  return REAL(_except_handler4)(a, b, c, d);\n+}\n+#endif\n+\n+// Window specific functions not included in asan_interface.inc.\n+INTERCEPT_WRAP_W_V(__asan_should_detect_stack_use_after_return)\n+INTERCEPT_WRAP_W_V(__asan_get_shadow_memory_dynamic_address)\n+INTERCEPT_WRAP_W_W(__asan_unhandled_exception_filter)\n+\n+using namespace __sanitizer;\n+\n+extern \"C\" {\n+int __asan_option_detect_stack_use_after_return;\n+uptr __asan_shadow_memory_dynamic_address;\n+} // extern \"C\"\n+\n+static int asan_dll_thunk_init() {\n+  typedef void (*fntype)();\n+  static fntype fn = 0;\n+  // asan_dll_thunk_init is expected to be called by only one thread.\n+  if (fn) return 0;\n+\n+  // Ensure all interception was executed.\n+  __dll_thunk_init();\n+\n+  fn = (fntype) dllThunkGetRealAddrOrDie(\"__asan_init\");\n+  fn();\n+  __asan_option_detect_stack_use_after_return =\n+      (__asan_should_detect_stack_use_after_return() != 0);\n+  __asan_shadow_memory_dynamic_address =\n+      (uptr)__asan_get_shadow_memory_dynamic_address();\n \n-// Must be after all the interceptor declarations due to the way INTERCEPT_HOOKS\n-// is defined.\n-void InterceptHooks() {\n-  INTERCEPT_HOOKS();\n #ifndef _WIN64\n   INTERCEPT_FUNCTION(_except_handler4);\n #endif\n+  // In DLLs, the callbacks are expected to return 0,\n+  // otherwise CRT initialization fails.\n+  return 0;\n }\n \n-// We want to call __asan_init before C/C++ initializers/constructors are\n-// executed, otherwise functions like memset might be invoked.\n-// For some strange reason, merely linking in asan_preinit.cc doesn't work\n-// as the callback is never called...  Is link.exe doing something too smart?\n+#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XIB\")) int (*__asan_preinit)() = asan_dll_thunk_init;\n \n-// In DLLs, the callbacks are expected to return 0,\n-// otherwise CRT initialization fails.\n-static int call_asan_init() {\n-  __asan_init();\n-  return 0;\n+static void WINAPI asan_thread_init(void *mod, unsigned long reason,\n+                                    void *reserved) {\n+  if (reason == /*DLL_PROCESS_ATTACH=*/1) asan_dll_thunk_init();\n }\n-#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n-__declspec(allocate(\".CRT$XIB\")) int (*__asan_preinit)() = call_asan_init;\n \n-#endif // ASAN_DLL_THUNK\n+#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XLAB\")) void (WINAPI *__asan_tls_init)(void *,\n+    unsigned long, void *) = asan_thread_init;\n+\n+WIN_FORCE_LINK(__asan_dso_reg_hook)\n+\n+#endif // SANITIZER_DLL_THUNK"}, {"sha": "d431b78d605b5af09c666687a7d4c631eda7fc66", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cc", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -12,24 +12,31 @@\n // using the default \"import library\" generated when linking the DLL RTL.\n //\n // This includes:\n+//  - creating weak aliases to default implementation imported from asan dll.\n //  - forwarding the detect_stack_use_after_return runtime option\n //  - working around deficiencies of the MD runtime\n //  - installing a custom SEH handler\n //\n //===----------------------------------------------------------------------===//\n \n-// Only compile this code when building asan_dynamic_runtime_thunk.lib\n-// Using #ifdef rather than relying on Makefiles etc.\n-// simplifies the build procedure.\n-#ifdef ASAN_DYNAMIC_RUNTIME_THUNK\n+#ifdef SANITIZER_DYNAMIC_RUNTIME_THUNK\n+#define SANITIZER_IMPORT_INTERFACE 1\n+#include \"sanitizer_common/sanitizer_win_defs.h\"\n #define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n \n+// Define weak alias for all weak functions imported from asan dll.\n+#define INTERFACE_FUNCTION(Name)\n+#define INTERFACE_WEAK_FUNCTION(Name) WIN_WEAK_IMPORT_DEF(Name)\n+#include \"asan_interface.inc\"\n+\n // First, declare CRT sections we'll be using in this file\n+#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n #pragma section(\".CRT$XID\", long, read)  // NOLINT\n #pragma section(\".CRT$XCAB\", long, read)  // NOLINT\n #pragma section(\".CRT$XTW\", long, read)  // NOLINT\n #pragma section(\".CRT$XTY\", long, read)  // NOLINT\n+#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n \n ////////////////////////////////////////////////////////////////////////////////\n // Define a copy of __asan_option_detect_stack_use_after_return that should be\n@@ -44,14 +51,33 @@\n // after initialization anyways.\n extern \"C\" {\n __declspec(dllimport) int __asan_should_detect_stack_use_after_return();\n-int __asan_option_detect_stack_use_after_return =\n-    __asan_should_detect_stack_use_after_return();\n+int __asan_option_detect_stack_use_after_return;\n \n __declspec(dllimport) void* __asan_get_shadow_memory_dynamic_address();\n-void* __asan_shadow_memory_dynamic_address =\n+void* __asan_shadow_memory_dynamic_address;\n+}\n+\n+static int InitializeClonedVariables() {\n+  __asan_option_detect_stack_use_after_return =\n+    __asan_should_detect_stack_use_after_return();\n+  __asan_shadow_memory_dynamic_address =\n     __asan_get_shadow_memory_dynamic_address();\n+  return 0;\n }\n \n+static void NTAPI asan_thread_init(void *mod, unsigned long reason,\n+    void *reserved) {\n+  if (reason == DLL_PROCESS_ATTACH) InitializeClonedVariables();\n+}\n+\n+// Our cloned variables must be initialized before C/C++ constructors.  If TLS\n+// is used, our .CRT$XLAB initializer will run first. If not, our .CRT$XIB\n+// initializer is needed as a backup.\n+__declspec(allocate(\".CRT$XIB\")) int (*__asan_initialize_cloned_variables)() =\n+    InitializeClonedVariables;\n+__declspec(allocate(\".CRT$XLAB\")) void (NTAPI *__asan_tls_init)(void *,\n+    unsigned long, void *) = asan_thread_init;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // For some reason, the MD CRT doesn't call the C/C++ terminators during on DLL\n // unload or on exit.  ASan relies on LLVM global_dtors to call\n@@ -98,4 +124,6 @@ __declspec(allocate(\".CRT$XCAB\")) int (*__asan_seh_interceptor)() =\n     SetSEHFilter;\n }\n \n-#endif // ASAN_DYNAMIC_RUNTIME_THUNK\n+WIN_FORCE_LINK(__asan_dso_reg_hook)\n+\n+#endif // SANITIZER_DYNAMIC_RUNTIME_THUNK"}, {"sha": "74c1dcdb729e547143048f4915018601c033cdd3", "filename": "libsanitizer/asan/asan_win_weak_interception.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win_weak_interception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Fasan_win_weak_interception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_weak_interception.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,21 @@\n+//===-- asan_win_weak_interception.cc -------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// This module should be included in Address Sanitizer when it is implemented as\n+// a shared library on Windows (dll), in order to delegate the calls of weak\n+// functions to the implementation in the main executable when a strong\n+// definition is provided.\n+//===----------------------------------------------------------------------===//\n+#ifdef SANITIZER_DYNAMIC\n+#include \"sanitizer_common/sanitizer_win_weak_interception.h\"\n+#include \"asan_interface_internal.h\"\n+// Check if strong definitions for weak functions are present in the main\n+// executable. If that is the case, override dll functions to point to strong\n+// implementations.\n+#define INTERFACE_FUNCTION(Name)\n+#define INTERFACE_WEAK_FUNCTION(Name) INTERCEPT_SANITIZER_WEAK_FUNCTION(Name)\n+#include \"asan_interface.inc\"\n+#endif // SANITIZER_DYNAMIC"}, {"sha": "e3138f3b9f800e61d5f769b843e4bf0d2355aba5", "filename": "libsanitizer/asan/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fasan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Flibtool-version?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -3,4 +3,4 @@\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-4:0:0\n+5:0:0"}, {"sha": "3f5e59b25442a91d2b21fbd331f84d4bfc635dd3", "filename": "libsanitizer/builtins/assembly.h", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fbuiltins%2Fassembly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fbuiltins%2Fassembly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fbuiltins%2Fassembly.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -44,7 +44,8 @@\n #endif\n #define CONST_SECTION .section .rodata\n \n-#if defined(__GNU__) || defined(__ANDROID__) || defined(__FreeBSD__)\n+#if defined(__GNU__) || defined(__FreeBSD__) || defined(__Fuchsia__) || \\\n+    defined(__linux__)\n #define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,\"\",%progbits\n #else\n #define NO_EXEC_STACK_DIRECTIVE\n@@ -67,10 +68,42 @@\n #endif\n \n #if defined(__arm__)\n+\n+/*\n+ * Determine actual [ARM][THUMB[1][2]] ISA using compiler predefined macros:\n+ * - for '-mthumb -march=armv6' compiler defines '__thumb__'\n+ * - for '-mthumb -march=armv7' compiler defines '__thumb__' and '__thumb2__'\n+ */\n+#if defined(__thumb2__) || defined(__thumb__)\n+#define DEFINE_CODE_STATE .thumb SEPARATOR\n+#define DECLARE_FUNC_ENCODING    .thumb_func SEPARATOR\n+#if defined(__thumb2__)\n+#define USE_THUMB_2\n+#define IT(cond)  it cond\n+#define ITT(cond) itt cond\n+#define ITE(cond) ite cond\n+#else\n+#define USE_THUMB_1\n+#define IT(cond)\n+#define ITT(cond)\n+#define ITE(cond)\n+#endif // defined(__thumb__2)\n+#else // !defined(__thumb2__) && !defined(__thumb__)\n+#define DEFINE_CODE_STATE .arm SEPARATOR\n+#define DECLARE_FUNC_ENCODING\n+#define IT(cond)\n+#define ITT(cond)\n+#define ITE(cond)\n+#endif\n+\n+#if defined(USE_THUMB_1) && defined(USE_THUMB_2)\n+#error \"USE_THUMB_1 and USE_THUMB_2 can't be defined together.\"\n+#endif\n+\n #if defined(__ARM_ARCH_4T__) || __ARM_ARCH >= 5\n #define ARM_HAS_BX\n #endif\n-#if !defined(__ARM_FEATURE_CLZ) &&                                             \\\n+#if !defined(__ARM_FEATURE_CLZ) && !defined(USE_THUMB_1) &&  \\\n     (__ARM_ARCH >= 6 || (__ARM_ARCH == 5 && !defined(__ARM_ARCH_5__)))\n #define __ARM_FEATURE_CLZ\n #endif\n@@ -92,19 +125,14 @@\n   JMP(ip)\n #endif\n \n-#if __ARM_ARCH_ISA_THUMB == 2\n-#define IT(cond)  it cond\n-#define ITT(cond) itt cond\n-#else\n-#define IT(cond)\n-#define ITT(cond)\n-#endif\n-\n-#if __ARM_ARCH_ISA_THUMB == 2\n+#if defined(USE_THUMB_2)\n #define WIDE(op) op.w\n #else\n #define WIDE(op) op\n #endif\n+#else // !defined(__arm)\n+#define DECLARE_FUNC_ENCODING\n+#define DEFINE_CODE_STATE\n #endif\n \n #define GLUE2(a, b) a##b\n@@ -119,13 +147,16 @@\n #endif\n \n #define DEFINE_COMPILERRT_FUNCTION(name)                                       \\\n+  DEFINE_CODE_STATE                                                            \\\n   FILE_LEVEL_DIRECTIVE SEPARATOR                                               \\\n   .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n   SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n   DECLARE_SYMBOL_VISIBILITY(name)                                              \\\n+  DECLARE_FUNC_ENCODING                                                        \\\n   SYMBOL_NAME(name):\n \n #define DEFINE_COMPILERRT_THUMB_FUNCTION(name)                                 \\\n+  DEFINE_CODE_STATE                                                            \\\n   FILE_LEVEL_DIRECTIVE SEPARATOR                                               \\\n   .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n   SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n@@ -134,16 +165,20 @@\n   SYMBOL_NAME(name):\n \n #define DEFINE_COMPILERRT_PRIVATE_FUNCTION(name)                               \\\n+  DEFINE_CODE_STATE                                                            \\\n   FILE_LEVEL_DIRECTIVE SEPARATOR                                               \\\n   .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n   SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n   HIDDEN(SYMBOL_NAME(name)) SEPARATOR                                          \\\n+  DECLARE_FUNC_ENCODING                                                        \\\n   SYMBOL_NAME(name):\n \n #define DEFINE_COMPILERRT_PRIVATE_FUNCTION_UNMANGLED(name)                     \\\n+  DEFINE_CODE_STATE                                                            \\\n   .globl name SEPARATOR                                                        \\\n   SYMBOL_IS_FUNC(name) SEPARATOR                                               \\\n   HIDDEN(name) SEPARATOR                                                       \\\n+  DECLARE_FUNC_ENCODING                                                        \\\n   name:\n \n #define DEFINE_COMPILERRT_FUNCTION_ALIAS(name, target)                         \\"}, {"sha": "ad69ab46c9256cf1ac6c047f82604a7f9fcb4f6d", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -142,6 +142,10 @@ extern \"C\" {\n   void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n                                      void **end);\n \n+  // Performs cleanup before a [[noreturn]] function.  Must be called\n+  // before things like _exit and execl to avoid false positives on stack.\n+  void __asan_handle_no_return(void);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "a66c932b0ae6eca3f7044ebaa74f1639bfa49e0f", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -156,8 +156,10 @@ extern \"C\" {\n   // Prints stack traces for all live heap allocations ordered by total\n   // allocation size until `top_percent` of total live heap is shown.\n   // `top_percent` should be between 1 and 100.\n+  // At most `max_number_of_contexts` contexts (stack traces) is printed.\n   // Experimental feature currently available only with asan on Linux/x86_64.\n-  void __sanitizer_print_memory_profile(size_t top_percent);\n+  void __sanitizer_print_memory_profile(size_t top_percent,\n+                                        size_t max_number_of_contexts);\n \n   // Fiber annotation interface.\n   // Before switching to a different stack, one must call\n@@ -180,6 +182,13 @@ extern \"C\" {\n   void __sanitizer_finish_switch_fiber(void *fake_stack_save,\n                                        const void **bottom_old,\n                                        size_t *size_old);\n+\n+  // Get full module name and calculate pc offset within it.\n+  // Returns 1 if pc belongs to some module, 0 if module was not found.\n+  int __sanitizer_get_module_and_offset_for_pc(void *pc, char *module_path,\n+                                               size_t module_path_len,\n+                                               void **pc_offset);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "85447b68a463eff3ab46a195b2fd9b0efbd9145e", "filename": "libsanitizer/include/sanitizer/coverage_interface.h", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -17,45 +17,15 @@\n extern \"C\" {\n #endif\n \n-  // Initialize coverage.\n-  void __sanitizer_cov_init();\n   // Record and dump coverage info.\n   void __sanitizer_cov_dump();\n-  // Open <name>.sancov.packed in the coverage directory and return the file\n-  // descriptor. Returns -1 on failure, or if coverage dumping is disabled.\n-  // This is intended for use by sandboxing code.\n-  intptr_t __sanitizer_maybe_open_cov_file(const char *name);\n-  // Get the number of unique covered blocks (or edges).\n-  // This can be useful for coverage-directed in-process fuzzers.\n-  uintptr_t __sanitizer_get_total_unique_coverage();\n-  // Get the number of unique indirect caller-callee pairs.\n-  uintptr_t __sanitizer_get_total_unique_caller_callee_pairs();\n \n-  // Reset the basic-block (edge) coverage to the initial state.\n-  // Useful for in-process fuzzing to start collecting coverage from scratch.\n-  // Experimental, will likely not work for multi-threaded process.\n-  void __sanitizer_reset_coverage();\n-  // Set *data to the array of covered PCs and return the size of that array.\n-  // Some of the entries in *data will be zero.\n-  uintptr_t __sanitizer_get_coverage_guards(uintptr_t **data);\n+  // Clear collected coverage info.\n+  void __sanitizer_cov_reset();\n \n-  // The coverage instrumentation may optionally provide imprecise counters.\n-  // Rather than exposing the counter values to the user we instead map\n-  // the counters to a bitset.\n-  // Every counter is associated with 8 bits in the bitset.\n-  // We define 8 value ranges: 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+\n-  // The i-th bit is set to 1 if the counter value is in the i-th range.\n-  // This counter-based coverage implementation is *not* thread-safe.\n-\n-  // Returns the number of registered coverage counters.\n-  uintptr_t __sanitizer_get_number_of_counters();\n-  // Updates the counter 'bitset', clears the counters and returns the number of\n-  // new bits in 'bitset'.\n-  // If 'bitset' is nullptr, only clears the counters.\n-  // Otherwise 'bitset' should be at least\n-  // __sanitizer_get_number_of_counters bytes long and 8-aligned.\n-  uintptr_t\n-  __sanitizer_update_counter_bitset_and_clear_counters(uint8_t *bitset);\n+  // Dump collected coverage info. Sorts pcs by module into individual .sancov\n+  // files.\n+  void __sanitizer_dump_coverage(const uintptr_t *pcs, uintptr_t len);\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "32051e62a002a7cce643a71d1cf950909caac6b1", "filename": "libsanitizer/include/sanitizer/lsan_interface.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -62,8 +62,14 @@ extern \"C\" {\n   // for the program it is linked into (if the return value is non-zero). This\n   // function must be defined as returning a constant value; any behavior beyond\n   // that is unsupported.\n+  // To avoid dead stripping, you may need to define this function with\n+  // __attribute__((used))\n   int __lsan_is_turned_off();\n \n+  // This function may be optionally provided by user and should return\n+  // a string containing LSan runtime options. See lsan_flags.inc for details.\n+  const char *__lsan_default_options();\n+\n   // This function may be optionally provided by the user and should return\n   // a string containing LSan suppressions.\n   const char *__lsan_default_suppressions();"}, {"sha": "9d9119262f8299137ca50616ce334b91a85a1e4d", "filename": "libsanitizer/include/sanitizer/tsan_interface.h", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,136 @@\n+//===-- tsan_interface.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Public interface header for TSan.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_TSAN_INTERFACE_H\n+#define SANITIZER_TSAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+// __tsan_release establishes a happens-before relation with a preceding\n+// __tsan_acquire on the same address.\n+void __tsan_acquire(void *addr);\n+void __tsan_release(void *addr);\n+\n+// Annotations for custom mutexes.\n+// The annotations allow to get better reports (with sets of locked mutexes),\n+// detect more types of bugs (e.g. mutex misuses, races between lock/unlock and\n+// destruction and potential deadlocks) and improve precision and performance\n+// (by ignoring individual atomic operations in mutex code). However, the\n+// downside is that annotated mutex code itself is not checked for correctness.\n+\n+// Mutex creation flags are passed to __tsan_mutex_create annotation.\n+// If mutex has no constructor and __tsan_mutex_create is not called,\n+// the flags may be passed to __tsan_mutex_pre_lock/__tsan_mutex_post_lock\n+// annotations.\n+\n+// Mutex has static storage duration and no-op constructor and destructor.\n+// This effectively makes tsan ignore destroy annotation.\n+const unsigned __tsan_mutex_linker_init      = 1 << 0;\n+// Mutex is write reentrant.\n+const unsigned __tsan_mutex_write_reentrant  = 1 << 1;\n+// Mutex is read reentrant.\n+const unsigned __tsan_mutex_read_reentrant   = 1 << 2;\n+\n+// Mutex operation flags:\n+\n+// Denotes read lock operation.\n+const unsigned __tsan_mutex_read_lock        = 1 << 3;\n+// Denotes try lock operation.\n+const unsigned __tsan_mutex_try_lock         = 1 << 4;\n+// Denotes that a try lock operation has failed to acquire the mutex.\n+const unsigned __tsan_mutex_try_lock_failed  = 1 << 5;\n+// Denotes that the lock operation acquires multiple recursion levels.\n+// Number of levels is passed in recursion parameter.\n+// This is useful for annotation of e.g. Java builtin monitors,\n+// for which wait operation releases all recursive acquisitions of the mutex.\n+const unsigned __tsan_mutex_recursive_lock   = 1 << 6;\n+// Denotes that the unlock operation releases all recursion levels.\n+// Number of released levels is returned and later must be passed to\n+// the corresponding __tsan_mutex_post_lock annotation.\n+const unsigned __tsan_mutex_recursive_unlock = 1 << 7;\n+\n+// Annotate creation of a mutex.\n+// Supported flags: mutex creation flags.\n+void __tsan_mutex_create(void *addr, unsigned flags);\n+\n+// Annotate destruction of a mutex.\n+// Supported flags:\n+//   - __tsan_mutex_linker_init\n+void __tsan_mutex_destroy(void *addr, unsigned flags);\n+\n+// Annotate start of lock operation.\n+// Supported flags:\n+//   - __tsan_mutex_read_lock\n+//   - __tsan_mutex_try_lock\n+//   - all mutex creation flags\n+void __tsan_mutex_pre_lock(void *addr, unsigned flags);\n+\n+// Annotate end of lock operation.\n+// Supported flags:\n+//   - __tsan_mutex_read_lock (must match __tsan_mutex_pre_lock)\n+//   - __tsan_mutex_try_lock (must match __tsan_mutex_pre_lock)\n+//   - __tsan_mutex_try_lock_failed\n+//   - __tsan_mutex_recursive_lock\n+//   - all mutex creation flags\n+void __tsan_mutex_post_lock(void *addr, unsigned flags, int recursion);\n+\n+// Annotate start of unlock operation.\n+// Supported flags:\n+//   - __tsan_mutex_read_lock\n+//   - __tsan_mutex_recursive_unlock\n+int __tsan_mutex_pre_unlock(void *addr, unsigned flags);\n+\n+// Annotate end of unlock operation.\n+// Supported flags:\n+//   - __tsan_mutex_read_lock (must match __tsan_mutex_pre_unlock)\n+void __tsan_mutex_post_unlock(void *addr, unsigned flags);\n+\n+// Annotate start/end of notify/signal/broadcast operation.\n+// Supported flags: none.\n+void __tsan_mutex_pre_signal(void *addr, unsigned flags);\n+void __tsan_mutex_post_signal(void *addr, unsigned flags);\n+\n+// Annotate start/end of a region of code where lock/unlock/signal operation\n+// diverts to do something else unrelated to the mutex. This can be used to\n+// annotate, for example, calls into cooperative scheduler or contention\n+// profiling code.\n+// These annotations must be called only from within\n+// __tsan_mutex_pre/post_lock, __tsan_mutex_pre/post_unlock,\n+// __tsan_mutex_pre/post_signal regions.\n+// Supported flags: none.\n+void __tsan_mutex_pre_divert(void *addr, unsigned flags);\n+void __tsan_mutex_post_divert(void *addr, unsigned flags);\n+\n+// External race detection API.\n+// Can be used by non-instrumented libraries to detect when their objects are\n+// being used in an unsafe manner.\n+//   - __tsan_external_read/__tsan_external_write annotates the logical reads\n+//       and writes of the object at the specified address. 'caller_pc' should\n+//       be the PC of the library user, which the library can obtain with e.g.\n+//       `__builtin_return_address(0)`.\n+//   - __tsan_external_register_tag registers a 'tag' with the specified name,\n+//       which is later used in read/write annotations to denote the object type\n+//   - __tsan_external_assign_tag can optionally mark a heap object with a tag\n+void *__tsan_external_register_tag(const char *object_type);\n+void __tsan_external_register_header(void *tag, const char *header);\n+void __tsan_external_assign_tag(void *addr, void *tag);\n+void __tsan_external_read(void *addr, void *caller_pc, void *tag);\n+void __tsan_external_write(void *addr, void *caller_pc, void *tag);\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // SANITIZER_TSAN_INTERFACE_H"}, {"sha": "75631da55ee2c602aa3a649ed1a675411bc7e288", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,8 +13,8 @@\n #ifndef INTERCEPTION_H\n #define INTERCEPTION_H\n \n-#if !defined(__linux__) && !defined(__FreeBSD__) && \\\n-  !defined(__APPLE__) && !defined(_WIN32)\n+#if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__APPLE__) && \\\n+    !defined(__NetBSD__) && !defined(_WIN32) && !defined(__Fuchsia__)\n # error \"Interception doesn't work on this operating system.\"\n #endif\n \n@@ -127,7 +127,7 @@ const interpose_substitution substitution_##func_name[] \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n # define DECLARE_WRAPPER_WINAPI(ret_type, func, ...) \\\n     extern \"C\" __declspec(dllimport) ret_type __stdcall func(__VA_ARGS__);\n-#elif defined(__FreeBSD__)\n+#elif defined(__FreeBSD__) || defined(__NetBSD__)\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n@@ -137,7 +137,7 @@ const interpose_substitution substitution_##func_name[] \\\n # define DECLARE_WRAPPER(ret_type, func, ...) \\\n      extern \"C\" ret_type func(__VA_ARGS__) \\\n      __attribute__((alias(\"__interceptor_\" #func), visibility(\"default\")));\n-#else\n+#elif !defined(__Fuchsia__)\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n@@ -146,7 +146,15 @@ const interpose_substitution substitution_##func_name[] \\\n     __attribute__((weak, alias(\"__interceptor_\" #func), visibility(\"default\")));\n #endif\n \n-#if !defined(__APPLE__)\n+#if defined(__Fuchsia__)\n+// There is no general interception at all on Fuchsia.\n+// Sanitizer runtimes just define functions directly to preempt them,\n+// and have bespoke ways to access the underlying libc functions.\n+# include <zircon/sanitizer.h>\n+# define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n+# define REAL(x) __unsanitized_##x\n+# define DECLARE_REAL(ret_type, func, ...)\n+#elif !defined(__APPLE__)\n # define PTR_TO_REAL(x) real_##x\n # define REAL(x) __interception::PTR_TO_REAL(x)\n # define FUNC_TYPE(x) x##_f\n@@ -164,15 +172,19 @@ const interpose_substitution substitution_##func_name[] \\\n # define ASSIGN_REAL(x, y)\n #endif  // __APPLE__\n \n+#if !defined(__Fuchsia__)\n #define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n   DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n   extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n+#else\n+#define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...)\n+#endif\n \n // Generally, you don't need to use DEFINE_REAL by itself, as INTERCEPTOR\n // macros does its job. In exceptional cases you may need to call REAL(foo)\n // without defining INTERCEPTOR(..., foo, ...). For example, if you override\n // foo with an interceptor for other function.\n-#if !defined(__APPLE__)\n+#if !defined(__APPLE__) && !defined(__Fuchsia__)\n # define DEFINE_REAL(ret_type, func, ...) \\\n     typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception { \\\n@@ -182,7 +194,18 @@ const interpose_substitution substitution_##func_name[] \\\n # define DEFINE_REAL(ret_type, func, ...)\n #endif\n \n-#if !defined(__APPLE__)\n+#if defined(__Fuchsia__)\n+\n+// We need to define the __interceptor_func name just to get\n+// sanitizer_common/scripts/gen_dynamic_list.py to export func.\n+// But we don't need to export __interceptor_func to get that.\n+#define INTERCEPTOR(ret_type, func, ...)                                \\\n+  extern \"C\"[[ gnu::alias(#func), gnu::visibility(\"hidden\") ]] ret_type \\\n+      __interceptor_##func(__VA_ARGS__);                                \\\n+  extern \"C\" INTERCEPTOR_ATTRIBUTE ret_type func(__VA_ARGS__)\n+\n+#elif !defined(__APPLE__)\n+\n #define INTERCEPTOR(ret_type, func, ...) \\\n   DEFINE_REAL(ret_type, func, __VA_ARGS__) \\\n   DECLARE_WRAPPER(ret_type, func, __VA_ARGS__) \\\n@@ -239,7 +262,7 @@ typedef unsigned long uptr;  // NOLINT\n \n #define INCLUDED_FROM_INTERCEPTION_LIB\n \n-#if defined(__linux__) || defined(__FreeBSD__)\n+#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n # include \"interception_linux.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\\n@@ -249,7 +272,7 @@ typedef unsigned long uptr;  // NOLINT\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\\n     INTERCEPT_FUNCTION_VER_MAC(func, symver)\n-#else  // defined(_WIN32)\n+#elif defined(_WIN32)\n # include \"interception_win.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_WIN(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\"}, {"sha": "888b2ceac13eb3584786c844cc25a181b8912ec1", "filename": "libsanitizer/interception/interception_linux.cc", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -10,14 +10,22 @@\n // Linux-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#if defined(__linux__) || defined(__FreeBSD__)\n+#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n #include \"interception.h\"\n \n #include <dlfcn.h>   // for dlsym() and dlvsym()\n \n+#ifdef __NetBSD__\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#endif\n+\n namespace __interception {\n bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n     uptr real, uptr wrapper) {\n+#ifdef __NetBSD__\n+  // XXX: Find a better way to handle renames\n+  if (internal_strcmp(func_name, \"sigaction\") == 0) func_name = \"__sigaction14\";\n+#endif\n   *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);\n   return real == wrapper;\n }\n@@ -30,5 +38,4 @@ void *GetFuncAddrVer(const char *func_name, const char *ver) {\n \n }  // namespace __interception\n \n-\n-#endif  // __linux__ || __FreeBSD__\n+#endif  // __linux__ || __FreeBSD__ || __NetBSD__"}, {"sha": "f5965180888feff831f8bbe26e1dc9ffd05e305f", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -10,7 +10,7 @@\n // Linux-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#if defined(__linux__) || defined(__FreeBSD__)\n+#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n \n #if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n # error \"interception_linux.h should be included from interception library only\"\n@@ -42,4 +42,4 @@ void *GetFuncAddrVer(const char *func_name, const char *ver);\n #endif  // !defined(__ANDROID__)\n \n #endif  // INTERCEPTION_LINUX_H\n-#endif  // __linux__ || __FreeBSD__\n+#endif  // __linux__ || __FreeBSD__ || __NetBSD__"}, {"sha": "1957397bdaddb2acb69fe78a13957da12dc7f902", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -146,10 +146,16 @@ static void InterceptionFailed() {\n }\n \n static bool DistanceIsWithin2Gig(uptr from, uptr target) {\n+#if SANITIZER_WINDOWS64\n   if (from < target)\n     return target - from <= (uptr)0x7FFFFFFFU;\n   else\n     return from - target <= (uptr)0x80000000U;\n+#else\n+  // In a 32-bit address space, the address calculation will wrap, so this check\n+  // is unnecessary.\n+  return true;\n+#endif\n }\n \n static uptr GetMmapGranularity() {\n@@ -215,9 +221,8 @@ static bool IsMemoryPadding(uptr address, uptr size) {\n   return true;\n }\n \n-static const u8 kHintNop10Bytes[] = {\n-  0x66, 0x66, 0x0F, 0x1F, 0x84,\n-  0x00, 0x00, 0x00, 0x00, 0x00\n+static const u8 kHintNop9Bytes[] = {\n+  0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00\n };\n \n template<class T>\n@@ -232,8 +237,8 @@ static bool FunctionHasPrefix(uptr address, const T &pattern) {\n static bool FunctionHasPadding(uptr address, uptr size) {\n   if (IsMemoryPadding(address - size, size))\n     return true;\n-  if (size <= sizeof(kHintNop10Bytes) &&\n-      FunctionHasPrefix(address, kHintNop10Bytes))\n+  if (size <= sizeof(kHintNop9Bytes) &&\n+      FunctionHasPrefix(address, kHintNop9Bytes))\n     return true;\n   return false;\n }\n@@ -469,7 +474,7 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n   switch (*(u8*)address) {\n     case 0xA1:  // A1 XX XX XX XX XX XX XX XX :\n                 //   movabs eax, dword ptr ds:[XXXXXXXX]\n-      return 8;\n+      return 9;\n   }\n \n   switch (*(u16*)address) {\n@@ -487,6 +492,11 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n     case 0x5741:  // push r15\n     case 0x9066:  // Two-byte NOP\n       return 2;\n+\n+    case 0x058B:  // 8B 05 XX XX XX XX : mov eax, dword ptr [XX XX XX XX]\n+      if (rel_offset)\n+        *rel_offset = 2;\n+      return 6;\n   }\n \n   switch (0x00FFFFFF & *(u32*)address) {\n@@ -870,6 +880,8 @@ uptr InternalGetProcAddress(void *module, const char *func_name) {\n \n   IMAGE_DATA_DIRECTORY *export_directory =\n       &headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];\n+  if (export_directory->Size == 0)\n+    return 0;\n   RVAPtr<IMAGE_EXPORT_DIRECTORY> exports(module,\n                                          export_directory->VirtualAddress);\n   RVAPtr<DWORD> functions(module, exports->AddressOfFunctions);"}, {"sha": "9638f30da1aaf3f20cab6dfe8d7e1a66da39969d", "filename": "libsanitizer/lsan/Makefile.am", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.am?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -16,11 +16,15 @@ endif\n \n sanitizer_lsan_files = \\\n \tlsan_common.cc \\\n-\tlsan_common_linux.cc\n+\tlsan_common_linux.cc \\\n+\tlsan_common_mac.cc\n \n lsan_files = \\\n \t$(sanitizer_lsan_files) \\\n \tlsan.cc \\\n+\tlsan_linux.cc \\\n+\tlsan_mac.cc \\\n+\tlsan_malloc_mac.cc \\\n \tlsan_allocator.cc \\\n \tlsan_interceptors.cc \\\n \tlsan_preinit.cc \\"}, {"sha": "f0d1e0f37da4a60c65310e4d6d3a534fae8b0fd1", "filename": "libsanitizer/lsan/Makefile.in", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.in?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -107,9 +107,10 @@ liblsan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(top_builddir)/interception/libinterception.la \\\n \t$(am__append_1) $(am__DEPENDENCIES_1)\n-am__objects_1 = lsan_common.lo lsan_common_linux.lo\n-am__objects_2 = $(am__objects_1) lsan.lo lsan_allocator.lo \\\n-\tlsan_interceptors.lo lsan_preinit.lo lsan_thread.lo\n+am__objects_1 = lsan_common.lo lsan_common_linux.lo lsan_common_mac.lo\n+am__objects_2 = $(am__objects_1) lsan.lo lsan_linux.lo lsan_mac.lo \\\n+\tlsan_malloc_mac.lo lsan_allocator.lo lsan_interceptors.lo \\\n+\tlsan_preinit.lo lsan_thread.lo\n am_liblsan_la_OBJECTS = $(am__objects_2)\n liblsan_la_OBJECTS = $(am_liblsan_la_OBJECTS)\n liblsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -299,11 +300,15 @@ noinst_LTLIBRARIES = libsanitizer_lsan.la\n @LSAN_SUPPORTED_TRUE@toolexeclib_LTLIBRARIES = liblsan.la\n sanitizer_lsan_files = \\\n \tlsan_common.cc \\\n-\tlsan_common_linux.cc\n+\tlsan_common_linux.cc \\\n+\tlsan_common_mac.cc\n \n lsan_files = \\\n \t$(sanitizer_lsan_files) \\\n \tlsan.cc \\\n+\tlsan_linux.cc \\\n+\tlsan_mac.cc \\\n+\tlsan_malloc_mac.cc \\\n \tlsan_allocator.cc \\\n \tlsan_interceptors.cc \\\n \tlsan_preinit.cc \\\n@@ -446,7 +451,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_malloc_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_preinit.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_thread.Plo@am__quote@\n "}, {"sha": "7540aeb327b46ee8789cf98c0d4f043f6554ff86", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -54,6 +54,9 @@ static void InitializeFlags() {\n   RegisterLsanFlags(&parser, f);\n   RegisterCommonFlags(&parser);\n \n+  // Override from user-specified string.\n+  const char *lsan_default_options = MaybeCallLsanDefaultOptions();\n+  parser.ParseString(lsan_default_options);\n   parser.ParseString(GetEnv(\"LSAN_OPTIONS\"));\n \n   SetVerbosity(common_flags()->verbosity);\n@@ -63,6 +66,18 @@ static void InitializeFlags() {\n   if (common_flags()->help) parser.PrintFlagDescriptions();\n }\n \n+static void OnStackUnwind(const SignalContext &sig, const void *,\n+                          BufferedStackTrace *stack) {\n+  GetStackTraceWithPcBpAndContext(stack, kStackTraceMax, sig.pc, sig.bp,\n+                                  sig.context,\n+                                  common_flags()->fast_unwind_on_fatal);\n+}\n+\n+void LsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n+  HandleDeadlySignal(siginfo, context, GetCurrentThread(), &OnStackUnwind,\n+                     nullptr);\n+}\n+\n extern \"C\" void __lsan_init() {\n   CHECK(!lsan_init_is_running);\n   if (lsan_inited)\n@@ -74,9 +89,11 @@ extern \"C\" void __lsan_init() {\n   InitializeFlags();\n   InitCommonLsan();\n   InitializeAllocator();\n+  ReplaceSystemMalloc();\n   InitTlsSize();\n   InitializeInterceptors();\n   InitializeThreadRegistry();\n+  InstallDeadlySignalHandlers(LsanOnDeadlySignal);\n   u32 tid = ThreadCreate(0, 0, true);\n   CHECK_EQ(tid, 0);\n   ThreadStart(tid, GetTid());"}, {"sha": "1cd1c36dbc4da3c9acec7eb830468275b81ff950", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -10,24 +10,15 @@\n //\n //===----------------------------------------------------------------------===//\n \n+#include \"lsan_thread.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n \n-#define GET_STACK_TRACE(max_size, fast)                                        \\\n-  BufferedStackTrace stack;                                                    \\\n-  {                                                                            \\\n-    uptr stack_top = 0, stack_bottom = 0;                                      \\\n-    ThreadContext *t;                                                          \\\n-    if (fast && (t = CurrentThreadContext())) {                                \\\n-      stack_top = t->stack_end();                                              \\\n-      stack_bottom = t->stack_begin();                                         \\\n-    }                                                                          \\\n-    if (!SANITIZER_MIPS ||                                                     \\\n-        IsValidFrame(GET_CURRENT_FRAME(), stack_top, stack_bottom)) {          \\\n-      stack.Unwind(max_size, StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(),  \\\n-                   /* context */ 0, stack_top, stack_bottom, fast);            \\\n-    }                                                                          \\\n-  }\n+#define GET_STACK_TRACE(max_size, fast)                       \\\n+  __sanitizer::BufferedStackTrace stack;                      \\\n+  GetStackTraceWithPcBpAndContext(&stack, max_size,           \\\n+                                  StackTrace::GetCurrentPc(), \\\n+                                  GET_CURRENT_FRAME(), nullptr, fast);\n \n #define GET_STACK_TRACE_FATAL \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n@@ -36,9 +27,37 @@\n   GET_STACK_TRACE(__sanitizer::common_flags()->malloc_context_size, \\\n                   common_flags()->fast_unwind_on_malloc)\n \n+#define GET_STACK_TRACE_THREAD GET_STACK_TRACE(kStackTraceMax, true)\n+\n namespace __lsan {\n \n void InitializeInterceptors();\n+void ReplaceSystemMalloc();\n+\n+#define ENSURE_LSAN_INITED do {   \\\n+  CHECK(!lsan_init_is_running);   \\\n+  if (!lsan_inited)               \\\n+    __lsan_init();                \\\n+} while (0)\n+\n+// Get the stack trace with the given pc and bp.\n+// The pc will be in the position 0 of the resulting stack trace.\n+// The bp may refer to the current frame or to the caller's frame.\n+ALWAYS_INLINE\n+void GetStackTraceWithPcBpAndContext(__sanitizer::BufferedStackTrace *stack,\n+                                     __sanitizer::uptr max_depth,\n+                                     __sanitizer::uptr pc, __sanitizer::uptr bp,\n+                                     void *context, bool fast) {\n+  uptr stack_top = 0, stack_bottom = 0;\n+  ThreadContext *t;\n+  if (fast && (t = CurrentThreadContext())) {\n+    stack_top = t->stack_end();\n+    stack_bottom = t->stack_begin();\n+  }\n+  if (!SANITIZER_MIPS || IsValidFrame(bp, stack_top, stack_bottom)) {\n+    stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom, fast);\n+  }\n+}\n \n }  // namespace __lsan\n "}, {"sha": "9e166807791c706477845418c0a99e78f6fca361", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 70, "deletions": 39, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,7 +13,9 @@\n #include \"lsan_allocator.h\"\n \n #include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_allocator_checks.h\"\n #include \"sanitizer_common/sanitizer_allocator_interface.h\"\n+#include \"sanitizer_common/sanitizer_errno.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n@@ -22,51 +24,27 @@\n extern \"C\" void *memset(void *ptr, int value, uptr num);\n \n namespace __lsan {\n-\n-struct ChunkMetadata {\n-  u8 allocated : 8;  // Must be first.\n-  ChunkTag tag : 2;\n-  uptr requested_size : 54;\n-  u32 stack_trace_id;\n-};\n-\n-#if defined(__mips64) || defined(__aarch64__)\n+#if defined(__i386__) || defined(__arm__)\n+static const uptr kMaxAllowedMallocSize = 1UL << 30;\n+#elif defined(__mips64) || defined(__aarch64__)\n static const uptr kMaxAllowedMallocSize = 4UL << 30;\n-static const uptr kRegionSizeLog = 20;\n-static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n-typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n-typedef CompactSizeClassMap SizeClassMap;\n-typedef SizeClassAllocator32<0, SANITIZER_MMAP_RANGE_SIZE,\n-    sizeof(ChunkMetadata), SizeClassMap, kRegionSizeLog, ByteMap>\n-    PrimaryAllocator;\n #else\n static const uptr kMaxAllowedMallocSize = 8UL << 30;\n-\n-struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n-  static const uptr kSpaceBeg = 0x600000000000ULL;\n-  static const uptr kSpaceSize =  0x40000000000ULL; // 4T.\n-  static const uptr kMetadataSize = sizeof(ChunkMetadata);\n-  typedef DefaultSizeClassMap SizeClassMap;\n-  typedef NoOpMapUnmapCallback MapUnmapCallback;\n-  static const uptr kFlags = 0;\n-};\n-\n-typedef SizeClassAllocator64<AP64> PrimaryAllocator;\n #endif\n-typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<> SecondaryAllocator;\n typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n           SecondaryAllocator> Allocator;\n \n static Allocator allocator;\n-static THREADLOCAL AllocatorCache cache;\n \n void InitializeAllocator() {\n-  allocator.InitLinkerInitialized(common_flags()->allocator_may_return_null);\n+  SetAllocatorMayReturnNull(common_flags()->allocator_may_return_null);\n+  allocator.InitLinkerInitialized(\n+      common_flags()->allocator_release_to_os_interval_ms);\n }\n \n void AllocatorThreadFinish() {\n-  allocator.SwallowCache(&cache);\n+  allocator.SwallowCache(GetAllocatorCache());\n }\n \n static ChunkMetadata *Metadata(const void *p) {\n@@ -96,9 +74,9 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n     size = 1;\n   if (size > kMaxAllowedMallocSize) {\n     Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", size);\n-    return nullptr;\n+    return Allocator::FailureHandler::OnBadRequest();\n   }\n-  void *p = allocator.Allocate(&cache, size, alignment, false);\n+  void *p = allocator.Allocate(GetAllocatorCache(), size, alignment);\n   // Do not rely on the allocator to clear the memory (it's slow).\n   if (cleared && allocator.FromPrimary(p))\n     memset(p, 0, size);\n@@ -108,29 +86,36 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n   return p;\n }\n \n+static void *Calloc(uptr nmemb, uptr size, const StackTrace &stack) {\n+  if (UNLIKELY(CheckForCallocOverflow(size, nmemb)))\n+    return Allocator::FailureHandler::OnBadRequest();\n+  size *= nmemb;\n+  return Allocate(stack, size, 1, true);\n+}\n+\n void Deallocate(void *p) {\n   if (&__sanitizer_free_hook) __sanitizer_free_hook(p);\n   RunFreeHooks(p);\n   RegisterDeallocation(p);\n-  allocator.Deallocate(&cache, p);\n+  allocator.Deallocate(GetAllocatorCache(), p);\n }\n \n void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n                  uptr alignment) {\n   RegisterDeallocation(p);\n   if (new_size > kMaxAllowedMallocSize) {\n     Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", new_size);\n-    allocator.Deallocate(&cache, p);\n-    return nullptr;\n+    allocator.Deallocate(GetAllocatorCache(), p);\n+    return Allocator::FailureHandler::OnBadRequest();\n   }\n-  p = allocator.Reallocate(&cache, p, new_size, alignment);\n+  p = allocator.Reallocate(GetAllocatorCache(), p, new_size, alignment);\n   RegisterAllocation(stack, p, new_size);\n   return p;\n }\n \n void GetAllocatorCacheRange(uptr *begin, uptr *end) {\n-  *begin = (uptr)&cache;\n-  *end = *begin + sizeof(cache);\n+  *begin = (uptr)GetAllocatorCache();\n+  *end = *begin + sizeof(AllocatorCache);\n }\n \n uptr GetMallocUsableSize(const void *p) {\n@@ -139,6 +124,39 @@ uptr GetMallocUsableSize(const void *p) {\n   return m->requested_size;\n }\n \n+void *lsan_memalign(uptr alignment, uptr size, const StackTrace &stack) {\n+  if (UNLIKELY(!IsPowerOfTwo(alignment))) {\n+    errno = errno_EINVAL;\n+    return Allocator::FailureHandler::OnBadRequest();\n+  }\n+  return SetErrnoOnNull(Allocate(stack, size, alignment, kAlwaysClearMemory));\n+}\n+\n+void *lsan_malloc(uptr size, const StackTrace &stack) {\n+  return SetErrnoOnNull(Allocate(stack, size, 1, kAlwaysClearMemory));\n+}\n+\n+void lsan_free(void *p) {\n+  Deallocate(p);\n+}\n+\n+void *lsan_realloc(void *p, uptr size, const StackTrace &stack) {\n+  return SetErrnoOnNull(Reallocate(stack, p, size, 1));\n+}\n+\n+void *lsan_calloc(uptr nmemb, uptr size, const StackTrace &stack) {\n+  return SetErrnoOnNull(Calloc(nmemb, size, stack));\n+}\n+\n+void *lsan_valloc(uptr size, const StackTrace &stack) {\n+  return SetErrnoOnNull(\n+      Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory));\n+}\n+\n+uptr lsan_mz_size(const void *p) {\n+  return GetMallocUsableSize(p);\n+}\n+\n ///// Interface to the common LSan module. /////\n \n void LockAllocator() {\n@@ -254,4 +272,17 @@ SANITIZER_INTERFACE_ATTRIBUTE\n uptr __sanitizer_get_allocated_size(const void *p) {\n   return GetMallocUsableSize(p);\n }\n+\n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+// Provide default (no-op) implementation of malloc hooks.\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_malloc_hook(void *ptr, uptr size) {\n+  (void)ptr;\n+  (void)size;\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_free_hook(void *ptr) {\n+  (void)ptr;\n+}\n+#endif\n } // extern \"C\""}, {"sha": "b0c0ec241d967484a61a40545b450601af2c70d5", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,8 +13,10 @@\n #ifndef LSAN_ALLOCATOR_H\n #define LSAN_ALLOCATOR_H\n \n+#include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"lsan_common.h\"\n \n namespace __lsan {\n \n@@ -32,6 +34,61 @@ void GetAllocatorCacheRange(uptr *begin, uptr *end);\n void AllocatorThreadFinish();\n void InitializeAllocator();\n \n+const bool kAlwaysClearMemory = true;\n+\n+struct ChunkMetadata {\n+  u8 allocated : 8;  // Must be first.\n+  ChunkTag tag : 2;\n+#if SANITIZER_WORDSIZE == 64\n+  uptr requested_size : 54;\n+#else\n+  uptr requested_size : 32;\n+  uptr padding : 22;\n+#endif\n+  u32 stack_trace_id;\n+};\n+\n+#if defined(__mips64) || defined(__aarch64__) || defined(__i386__) || \\\n+    defined(__arm__)\n+static const uptr kRegionSizeLog = 20;\n+static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n+typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n+\n+struct AP32 {\n+  static const uptr kSpaceBeg = 0;\n+  static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n+  static const uptr kMetadataSize = sizeof(ChunkMetadata);\n+  typedef __sanitizer::CompactSizeClassMap SizeClassMap;\n+  static const uptr kRegionSizeLog = __lsan::kRegionSizeLog;\n+  typedef __lsan::ByteMap ByteMap;\n+  typedef NoOpMapUnmapCallback MapUnmapCallback;\n+  static const uptr kFlags = 0;\n+};\n+typedef SizeClassAllocator32<AP32> PrimaryAllocator;\n+#elif defined(__x86_64__) || defined(__powerpc64__)\n+struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n+  static const uptr kSpaceBeg = 0x600000000000ULL;\n+  static const uptr kSpaceSize =  0x40000000000ULL; // 4T.\n+  static const uptr kMetadataSize = sizeof(ChunkMetadata);\n+  typedef DefaultSizeClassMap SizeClassMap;\n+  typedef NoOpMapUnmapCallback MapUnmapCallback;\n+  static const uptr kFlags = 0;\n+};\n+\n+typedef SizeClassAllocator64<AP64> PrimaryAllocator;\n+#endif\n+typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n+\n+AllocatorCache *GetAllocatorCache();\n+\n+void *lsan_memalign(uptr alignment, uptr size, const StackTrace &stack);\n+void *lsan_malloc(uptr size, const StackTrace &stack);\n+void lsan_free(void *p);\n+void *lsan_realloc(void *p, uptr size, const StackTrace &stack);\n+void *lsan_calloc(uptr nmemb, uptr size, const StackTrace &stack);\n+void *lsan_valloc(uptr size, const StackTrace &stack);\n+uptr lsan_mz_size(const void *p);\n+\n }  // namespace __lsan\n \n #endif  // LSAN_ALLOCATOR_H"}, {"sha": "a3274d5c1c3dffe2e573b81e7ea1e1a930d8e91a", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 184, "deletions": 69, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -30,20 +30,15 @@ namespace __lsan {\n // also to protect the global list of root regions.\n BlockingMutex global_mutex(LINKER_INITIALIZED);\n \n-__attribute__((tls_model(\"initial-exec\")))\n-THREADLOCAL int disable_counter;\n-bool DisabledInThisThread() { return disable_counter > 0; }\n-void DisableInThisThread() { disable_counter++; }\n-void EnableInThisThread() {\n-  if (!disable_counter && common_flags()->detect_leaks) {\n+Flags lsan_flags;\n+\n+void DisableCounterUnderflow() {\n+  if (common_flags()->detect_leaks) {\n     Report(\"Unmatched call to __lsan_enable().\\n\");\n     Die();\n   }\n-  disable_counter--;\n }\n \n-Flags lsan_flags;\n-\n void Flags::SetDefaults() {\n #define LSAN_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n #include \"lsan_flags.inc\"\n@@ -71,6 +66,19 @@ ALIGNED(64) static char suppression_placeholder[sizeof(SuppressionContext)];\n static SuppressionContext *suppression_ctx = nullptr;\n static const char kSuppressionLeak[] = \"leak\";\n static const char *kSuppressionTypes[] = { kSuppressionLeak };\n+static const char kStdSuppressions[] =\n+#if SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT\n+  // For more details refer to the SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT\n+  // definition.\n+  \"leak:*pthread_exit*\\n\"\n+#endif  // SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT\n+#if SANITIZER_MAC\n+  // For Darwin and os_log/os_trace: https://reviews.llvm.org/D35173\n+  \"leak:*_os_trace*\\n\"\n+#endif\n+  // TLS leak in some glibc versions, described in\n+  // https://sourceware.org/bugzilla/show_bug.cgi?id=12650.\n+  \"leak:*tls_get_addr*\\n\";\n \n void InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);\n@@ -79,26 +87,28 @@ void InitializeSuppressions() {\n   suppression_ctx->ParseFromFile(flags()->suppressions);\n   if (&__lsan_default_suppressions)\n     suppression_ctx->Parse(__lsan_default_suppressions());\n+  suppression_ctx->Parse(kStdSuppressions);\n }\n \n static SuppressionContext *GetSuppressionContext() {\n   CHECK(suppression_ctx);\n   return suppression_ctx;\n }\n \n-struct RootRegion {\n-  const void *begin;\n-  uptr size;\n-};\n+static InternalMmapVector<RootRegion> *root_regions;\n \n-InternalMmapVector<RootRegion> *root_regions;\n+InternalMmapVector<RootRegion> const *GetRootRegions() { return root_regions; }\n \n void InitializeRootRegions() {\n   CHECK(!root_regions);\n   ALIGNED(64) static char placeholder[sizeof(InternalMmapVector<RootRegion>)];\n   root_regions = new(placeholder) InternalMmapVector<RootRegion>(1);\n }\n \n+const char *MaybeCallLsanDefaultOptions() {\n+  return (&__lsan_default_options) ? __lsan_default_options() : \"\";\n+}\n+\n void InitCommonLsan() {\n   InitializeRootRegions();\n   if (common_flags()->detect_leaks) {\n@@ -114,7 +124,6 @@ class Decorator: public __sanitizer::SanitizerCommonDecorator {\n   Decorator() : SanitizerCommonDecorator() { }\n   const char *Error() { return Red(); }\n   const char *Leak() { return Blue(); }\n-  const char *End() { return Default(); }\n };\n \n static inline bool CanBeAHeapPointer(uptr p) {\n@@ -178,6 +187,23 @@ void ScanRangeForPointers(uptr begin, uptr end,\n   }\n }\n \n+// Scans a global range for pointers\n+void ScanGlobalRange(uptr begin, uptr end, Frontier *frontier) {\n+  uptr allocator_begin = 0, allocator_end = 0;\n+  GetAllocatorGlobalRange(&allocator_begin, &allocator_end);\n+  if (begin <= allocator_begin && allocator_begin < end) {\n+    CHECK_LE(allocator_begin, allocator_end);\n+    CHECK_LE(allocator_end, end);\n+    if (begin < allocator_begin)\n+      ScanRangeForPointers(begin, allocator_begin, frontier, \"GLOBAL\",\n+                           kReachable);\n+    if (allocator_end < end)\n+      ScanRangeForPointers(allocator_end, end, frontier, \"GLOBAL\", kReachable);\n+  } else {\n+    ScanRangeForPointers(begin, end, frontier, \"GLOBAL\", kReachable);\n+  }\n+}\n+\n void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg) {\n   Frontier *frontier = reinterpret_cast<Frontier *>(arg);\n   ScanRangeForPointers(begin, end, frontier, \"FAKE STACK\", kReachable);\n@@ -186,11 +212,11 @@ void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg) {\n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            Frontier *frontier) {\n-  InternalScopedBuffer<uptr> registers(SuspendedThreadsList::RegisterCount());\n+  InternalScopedBuffer<uptr> registers(suspended_threads.RegisterCount());\n   uptr registers_begin = reinterpret_cast<uptr>(registers.data());\n   uptr registers_end = registers_begin + registers.size();\n-  for (uptr i = 0; i < suspended_threads.thread_count(); i++) {\n-    uptr os_id = static_cast<uptr>(suspended_threads.GetThreadID(i));\n+  for (uptr i = 0; i < suspended_threads.ThreadCount(); i++) {\n+    tid_t os_id = static_cast<tid_t>(suspended_threads.GetThreadID(i));\n     LOG_THREADS(\"Processing thread %d.\\n\", os_id);\n     uptr stack_begin, stack_end, tls_begin, tls_end, cache_begin, cache_end;\n     DTLS *dtls;\n@@ -204,11 +230,13 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n       continue;\n     }\n     uptr sp;\n-    bool have_registers =\n-        (suspended_threads.GetRegistersAndSP(i, registers.data(), &sp) == 0);\n-    if (!have_registers) {\n-      Report(\"Unable to get registers from thread %d.\\n\");\n-      // If unable to get SP, consider the entire stack to be reachable.\n+    PtraceRegistersStatus have_registers =\n+        suspended_threads.GetRegistersAndSP(i, registers.data(), &sp);\n+    if (have_registers != REGISTERS_AVAILABLE) {\n+      Report(\"Unable to get registers from thread %d.\\n\", os_id);\n+      // If unable to get SP, consider the entire stack to be reachable unless\n+      // GetRegistersAndSP failed with ESRCH.\n+      if (have_registers == REGISTERS_UNAVAILABLE_FATAL) continue;\n       sp = stack_begin;\n     }\n \n@@ -242,21 +270,23 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n     }\n \n     if (flags()->use_tls) {\n-      LOG_THREADS(\"TLS at %p-%p.\\n\", tls_begin, tls_end);\n-      if (cache_begin == cache_end) {\n-        ScanRangeForPointers(tls_begin, tls_end, frontier, \"TLS\", kReachable);\n-      } else {\n-        // Because LSan should not be loaded with dlopen(), we can assume\n-        // that allocator cache will be part of static TLS image.\n-        CHECK_LE(tls_begin, cache_begin);\n-        CHECK_GE(tls_end, cache_end);\n-        if (tls_begin < cache_begin)\n-          ScanRangeForPointers(tls_begin, cache_begin, frontier, \"TLS\",\n-                               kReachable);\n-        if (tls_end > cache_end)\n-          ScanRangeForPointers(cache_end, tls_end, frontier, \"TLS\", kReachable);\n+      if (tls_begin) {\n+        LOG_THREADS(\"TLS at %p-%p.\\n\", tls_begin, tls_end);\n+        // If the tls and cache ranges don't overlap, scan full tls range,\n+        // otherwise, only scan the non-overlapping portions\n+        if (cache_begin == cache_end || tls_end < cache_begin ||\n+            tls_begin > cache_end) {\n+          ScanRangeForPointers(tls_begin, tls_end, frontier, \"TLS\", kReachable);\n+        } else {\n+          if (tls_begin < cache_begin)\n+            ScanRangeForPointers(tls_begin, cache_begin, frontier, \"TLS\",\n+                                 kReachable);\n+          if (tls_end > cache_end)\n+            ScanRangeForPointers(cache_end, tls_end, frontier, \"TLS\",\n+                                 kReachable);\n+        }\n       }\n-      if (dtls) {\n+      if (dtls && !DTLSInDestruction(dtls)) {\n         for (uptr j = 0; j < dtls->dtv_size; ++j) {\n           uptr dtls_beg = dtls->dtv[j].beg;\n           uptr dtls_end = dtls_beg + dtls->dtv[j].size;\n@@ -266,28 +296,36 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                                  kReachable);\n           }\n         }\n+      } else {\n+        // We are handling a thread with DTLS under destruction. Log about\n+        // this and continue.\n+        LOG_THREADS(\"Thread %d has DTLS under destruction.\\n\", os_id);\n       }\n     }\n   }\n }\n \n-static void ProcessRootRegion(Frontier *frontier, uptr root_begin,\n-                              uptr root_end) {\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n-  uptr begin, end, prot;\n-  while (proc_maps.Next(&begin, &end,\n-                        /*offset*/ nullptr, /*filename*/ nullptr,\n-                        /*filename_size*/ 0, &prot)) {\n-    uptr intersection_begin = Max(root_begin, begin);\n-    uptr intersection_end = Min(end, root_end);\n-    if (intersection_begin >= intersection_end) continue;\n-    bool is_readable = prot & MemoryMappingLayout::kProtectionRead;\n-    LOG_POINTERS(\"Root region %p-%p intersects with mapped region %p-%p (%s)\\n\",\n-                 root_begin, root_end, begin, end,\n-                 is_readable ? \"readable\" : \"unreadable\");\n-    if (is_readable)\n-      ScanRangeForPointers(intersection_begin, intersection_end, frontier,\n-                           \"ROOT\", kReachable);\n+void ScanRootRegion(Frontier *frontier, const RootRegion &root_region,\n+                    uptr region_begin, uptr region_end, bool is_readable) {\n+  uptr intersection_begin = Max(root_region.begin, region_begin);\n+  uptr intersection_end = Min(region_end, root_region.begin + root_region.size);\n+  if (intersection_begin >= intersection_end) return;\n+  LOG_POINTERS(\"Root region %p-%p intersects with mapped region %p-%p (%s)\\n\",\n+               root_region.begin, root_region.begin + root_region.size,\n+               region_begin, region_end,\n+               is_readable ? \"readable\" : \"unreadable\");\n+  if (is_readable)\n+    ScanRangeForPointers(intersection_begin, intersection_end, frontier, \"ROOT\",\n+                         kReachable);\n+}\n+\n+static void ProcessRootRegion(Frontier *frontier,\n+                              const RootRegion &root_region) {\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/ true);\n+  MemoryMappedSegment segment;\n+  while (proc_maps.Next(&segment)) {\n+    ScanRootRegion(frontier, root_region, segment.start, segment.end,\n+                   segment.IsReadable());\n   }\n }\n \n@@ -296,9 +334,7 @@ static void ProcessRootRegions(Frontier *frontier) {\n   if (!flags()->use_root_regions) return;\n   CHECK(root_regions);\n   for (uptr i = 0; i < root_regions->size(); i++) {\n-    RootRegion region = (*root_regions)[i];\n-    uptr begin_addr = reinterpret_cast<uptr>(region.begin);\n-    ProcessRootRegion(frontier, begin_addr, begin_addr + region.size);\n+    ProcessRootRegion(frontier, (*root_regions)[i]);\n   }\n }\n \n@@ -336,6 +372,72 @@ static void CollectIgnoredCb(uptr chunk, void *arg) {\n   }\n }\n \n+static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n+  CHECK(stack_id);\n+  StackTrace stack = map->Get(stack_id);\n+  // The top frame is our malloc/calloc/etc. The next frame is the caller.\n+  if (stack.size >= 2)\n+    return stack.trace[1];\n+  return 0;\n+}\n+\n+struct InvalidPCParam {\n+  Frontier *frontier;\n+  StackDepotReverseMap *stack_depot_reverse_map;\n+  bool skip_linker_allocations;\n+};\n+\n+// ForEachChunk callback. If the caller pc is invalid or is within the linker,\n+// mark as reachable. Called by ProcessPlatformSpecificAllocations.\n+static void MarkInvalidPCCb(uptr chunk, void *arg) {\n+  CHECK(arg);\n+  InvalidPCParam *param = reinterpret_cast<InvalidPCParam *>(arg);\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (m.allocated() && m.tag() != kReachable && m.tag() != kIgnored) {\n+    u32 stack_id = m.stack_trace_id();\n+    uptr caller_pc = 0;\n+    if (stack_id > 0)\n+      caller_pc = GetCallerPC(stack_id, param->stack_depot_reverse_map);\n+    // If caller_pc is unknown, this chunk may be allocated in a coroutine. Mark\n+    // it as reachable, as we can't properly report its allocation stack anyway.\n+    if (caller_pc == 0 || (param->skip_linker_allocations &&\n+                           GetLinker()->containsAddress(caller_pc))) {\n+      m.set_tag(kReachable);\n+      param->frontier->push_back(chunk);\n+    }\n+  }\n+}\n+\n+// On Linux, handles dynamically allocated TLS blocks by treating all chunks\n+// allocated from ld-linux.so as reachable.\n+// Dynamic TLS blocks contain the TLS variables of dynamically loaded modules.\n+// They are allocated with a __libc_memalign() call in allocate_and_init()\n+// (elf/dl-tls.c). Glibc won't tell us the address ranges occupied by those\n+// blocks, but we can make sure they come from our own allocator by intercepting\n+// __libc_memalign(). On top of that, there is no easy way to reach them. Their\n+// addresses are stored in a dynamically allocated array (the DTV) which is\n+// referenced from the static TLS. Unfortunately, we can't just rely on the DTV\n+// being reachable from the static TLS, and the dynamic TLS being reachable from\n+// the DTV. This is because the initial DTV is allocated before our interception\n+// mechanism kicks in, and thus we don't recognize it as allocated memory. We\n+// can't special-case it either, since we don't know its size.\n+// Our solution is to include in the root set all allocations made from\n+// ld-linux.so (which is where allocate_and_init() is implemented). This is\n+// guaranteed to include all dynamic TLS blocks (and possibly other allocations\n+// which we don't care about).\n+// On all other platforms, this simply checks to ensure that the caller pc is\n+// valid before reporting chunks as leaked.\n+void ProcessPC(Frontier *frontier) {\n+  StackDepotReverseMap stack_depot_reverse_map;\n+  InvalidPCParam arg;\n+  arg.frontier = frontier;\n+  arg.stack_depot_reverse_map = &stack_depot_reverse_map;\n+  arg.skip_linker_allocations =\n+      flags()->use_tls && flags()->use_ld_allocations && GetLinker() != nullptr;\n+  ForEachChunk(MarkInvalidPCCb, &arg);\n+}\n+\n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n   // Holds the flood fill frontier.\n@@ -347,11 +449,13 @@ static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n   ProcessRootRegions(&frontier);\n   FloodFillTag(&frontier, kReachable);\n \n+  CHECK_EQ(0, frontier.size());\n+  ProcessPC(&frontier);\n+\n   // The check here is relatively expensive, so we do this in a separate flood\n   // fill. That way we can skip the check for chunks that are reachable\n   // otherwise.\n   LOG_POINTERS(\"Processing platform-specific allocations.\\n\");\n-  CHECK_EQ(0, frontier.size());\n   ProcessPlatformSpecificAllocations(&frontier);\n   FloodFillTag(&frontier, kReachable);\n \n@@ -461,7 +565,7 @@ static bool CheckForLeaks() {\n            \"\\n\");\n     Printf(\"%s\", d.Error());\n     Report(\"ERROR: LeakSanitizer: detected memory leaks\\n\");\n-    Printf(\"%s\", d.End());\n+    Printf(\"%s\", d.Default());\n     param.leak_report.ReportTopLeaks(flags()->max_leaks);\n   }\n   if (common_flags()->print_suppressions)\n@@ -473,18 +577,16 @@ static bool CheckForLeaks() {\n   return false;\n }\n \n+static bool has_reported_leaks = false;\n+bool HasReportedLeaks() { return has_reported_leaks; }\n+\n void DoLeakCheck() {\n   BlockingMutexLock l(&global_mutex);\n   static bool already_done;\n   if (already_done) return;\n   already_done = true;\n-  bool have_leaks = CheckForLeaks();\n-  if (!have_leaks) {\n-    return;\n-  }\n-  if (common_flags()->exitcode) {\n-    Die();\n-  }\n+  has_reported_leaks = CheckForLeaks();\n+  if (has_reported_leaks) HandleLeaks();\n }\n \n static int DoRecoverableLeakCheck() {\n@@ -493,6 +595,8 @@ static int DoRecoverableLeakCheck() {\n   return have_leaks ? 1 : 0;\n }\n \n+void DoRecoverableLeakCheckVoid() { DoRecoverableLeakCheck(); }\n+\n static Suppression *GetSuppressionForAddr(uptr addr) {\n   Suppression *s = nullptr;\n \n@@ -597,7 +701,7 @@ void LeakReport::PrintReportForLeak(uptr index) {\n   Printf(\"%s leak of %zu byte(s) in %zu object(s) allocated from:\\n\",\n          leaks_[index].is_directly_leaked ? \"Direct\" : \"Indirect\",\n          leaks_[index].total_size, leaks_[index].hit_count);\n-  Printf(\"%s\", d.End());\n+  Printf(\"%s\", d.Default());\n \n   PrintStackTraceById(leaks_[index].stack_trace_id);\n \n@@ -655,6 +759,7 @@ uptr LeakReport::UnsuppressedLeakCount() {\n namespace __lsan {\n void InitCommonLsan() { }\n void DoLeakCheck() { }\n+void DoRecoverableLeakCheckVoid() { }\n void DisableInThisThread() { }\n void EnableInThisThread() { }\n }\n@@ -687,7 +792,7 @@ void __lsan_register_root_region(const void *begin, uptr size) {\n #if CAN_SANITIZE_LEAKS\n   BlockingMutexLock l(&global_mutex);\n   CHECK(root_regions);\n-  RootRegion region = {begin, size};\n+  RootRegion region = {reinterpret_cast<uptr>(begin), size};\n   root_regions->push_back(region);\n   VReport(1, \"Registered root region at %p of size %llu\\n\", begin, size);\n #endif // CAN_SANITIZE_LEAKS\n@@ -701,7 +806,7 @@ void __lsan_unregister_root_region(const void *begin, uptr size) {\n   bool removed = false;\n   for (uptr i = 0; i < root_regions->size(); i++) {\n     RootRegion region = (*root_regions)[i];\n-    if (region.begin == begin && region.size == size) {\n+    if (region.begin == reinterpret_cast<uptr>(begin) && region.size == size) {\n       removed = true;\n       uptr last_index = root_regions->size() - 1;\n       (*root_regions)[i] = (*root_regions)[last_index];\n@@ -752,9 +857,19 @@ int __lsan_do_recoverable_leak_check() {\n }\n \n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char * __lsan_default_options() {\n+  return \"\";\n+}\n+\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n int __lsan_is_turned_off() {\n   return 0;\n }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char *__lsan_default_suppressions() {\n+  return \"\";\n+}\n #endif\n } // extern \"C\""}, {"sha": "e99cd9e1b5276f831db48bc7106854ed6965aaaa", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 75, "deletions": 8, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -20,8 +20,24 @@\n #include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID) && (SANITIZER_WORDSIZE == 64) \\\n-     && (defined(__x86_64__) ||  defined(__mips64) ||  defined(__aarch64__))\n+// LeakSanitizer relies on some Glibc's internals (e.g. TLS machinery) thus\n+// supported for Linux only. Also, LSan doesn't like 32 bit architectures\n+// because of \"small\" (4 bytes) pointer size that leads to high false negative\n+// ratio on large leaks. But we still want to have it for some 32 bit arches\n+// (e.g. x86), see https://github.com/google/sanitizers/issues/403.\n+// To enable LeakSanitizer on new architecture, one need to implement\n+// internal_clone function as well as (probably) adjust TLS machinery for\n+// new architecture inside sanitizer library.\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID || SANITIZER_MAC) && \\\n+    (SANITIZER_WORDSIZE == 64) &&                               \\\n+    (defined(__x86_64__) || defined(__mips64) || defined(__aarch64__) || \\\n+     defined(__powerpc64__))\n+#define CAN_SANITIZE_LEAKS 1\n+#elif defined(__i386__) && \\\n+    (SANITIZER_LINUX && !SANITIZER_ANDROID || SANITIZER_MAC)\n+#define CAN_SANITIZE_LEAKS 1\n+#elif defined(__arm__) && \\\n+    SANITIZER_LINUX && !SANITIZER_ANDROID\n #define CAN_SANITIZE_LEAKS 1\n #else\n #define CAN_SANITIZE_LEAKS 0\n@@ -42,6 +58,8 @@ enum ChunkTag {\n   kIgnored = 3\n };\n \n+const u32 kInvalidTid = (u32) -1;\n+\n struct Flags {\n #define LSAN_FLAG(Type, Name, DefaultValue, Description) Type Name;\n #include \"lsan_flags.inc\"\n@@ -99,12 +117,22 @@ typedef InternalMmapVector<uptr> Frontier;\n void InitializePlatformSpecificModules();\n void ProcessGlobalRegions(Frontier *frontier);\n void ProcessPlatformSpecificAllocations(Frontier *frontier);\n+\n+struct RootRegion {\n+  uptr begin;\n+  uptr size;\n+};\n+\n+InternalMmapVector<RootRegion> const *GetRootRegions();\n+void ScanRootRegion(Frontier *frontier, RootRegion const &region,\n+                    uptr region_begin, uptr region_end, bool is_readable);\n // Run stoptheworld while holding any platform-specific locks.\n void DoStopTheWorld(StopTheWorldCallback callback, void* argument);\n \n void ScanRangeForPointers(uptr begin, uptr end,\n                           Frontier *frontier,\n                           const char *region_type, ChunkTag tag);\n+void ScanGlobalRange(uptr begin, uptr end, Frontier *frontier);\n \n enum IgnoreObjectResult {\n   kIgnoreObjectSuccess,\n@@ -113,8 +141,11 @@ enum IgnoreObjectResult {\n };\n \n // Functions called from the parent tool.\n+const char *MaybeCallLsanDefaultOptions();\n void InitCommonLsan();\n void DoLeakCheck();\n+void DoRecoverableLeakCheckVoid();\n+void DisableCounterUnderflow();\n bool DisabledInThisThread();\n \n // Used to implement __lsan::ScopedDisabler.\n@@ -127,13 +158,36 @@ struct ScopedInterceptorDisabler {\n   ~ScopedInterceptorDisabler() { EnableInThisThread(); }\n };\n \n+// According to Itanium C++ ABI array cookie is a one word containing\n+// size of allocated array.\n+static inline bool IsItaniumABIArrayCookie(uptr chunk_beg, uptr chunk_size,\n+                                           uptr addr) {\n+  return chunk_size == sizeof(uptr) && chunk_beg + chunk_size == addr &&\n+         *reinterpret_cast<uptr *>(chunk_beg) == 0;\n+}\n+\n+// According to ARM C++ ABI array cookie consists of two words:\n+// struct array_cookie {\n+//   std::size_t element_size; // element_size != 0\n+//   std::size_t element_count;\n+// };\n+static inline bool IsARMABIArrayCookie(uptr chunk_beg, uptr chunk_size,\n+                                       uptr addr) {\n+  return chunk_size == 2 * sizeof(uptr) && chunk_beg + chunk_size == addr &&\n+         *reinterpret_cast<uptr *>(chunk_beg + sizeof(uptr)) == 0;\n+}\n+\n // Special case for \"new T[0]\" where T is a type with DTOR.\n-// new T[0] will allocate one word for the array size (0) and store a pointer\n-// to the end of allocated chunk.\n+// new T[0] will allocate a cookie (one or two words) for the array size (0)\n+// and store a pointer to the end of allocated chunk. The actual cookie layout\n+// varies between platforms according to their C++ ABI implementation.\n inline bool IsSpecialCaseOfOperatorNew0(uptr chunk_beg, uptr chunk_size,\n                                         uptr addr) {\n-  return chunk_size == sizeof(uptr) && chunk_beg + chunk_size == addr &&\n-         *reinterpret_cast<uptr *>(chunk_beg) == 0;\n+#if defined(__arm__)\n+  return IsARMABIArrayCookie(chunk_beg, chunk_size, addr);\n+#else\n+  return IsItaniumABIArrayCookie(chunk_beg, chunk_size, addr);\n+#endif\n }\n \n // The following must be implemented in the parent tool.\n@@ -149,10 +203,10 @@ bool WordIsPoisoned(uptr addr);\n // Wrappers for ThreadRegistry access.\n void LockThreadRegistry();\n void UnlockThreadRegistry();\n-bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n+bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n                            uptr *cache_end, DTLS **dtls);\n-void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n+void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n                             void *arg);\n // If called from the main thread, updates the main thread's TID in the thread\n // registry. We need this to handle processes that fork() without a subsequent\n@@ -168,6 +222,16 @@ uptr PointsIntoChunk(void *p);\n uptr GetUserBegin(uptr chunk);\n // Helper for __lsan_ignore_object().\n IgnoreObjectResult IgnoreObjectLocked(const void *p);\n+\n+// Return the linker module, if valid for the platform.\n+LoadedModule *GetLinker();\n+\n+// Return true if LSan has finished leak checking and reported leaks.\n+bool HasReportedLeaks();\n+\n+// Run platform-specific leak handlers.\n+void HandleLeaks();\n+\n // Wrapper for chunk metadata operations.\n class LsanMetadata {\n  public:\n@@ -185,6 +249,9 @@ class LsanMetadata {\n }  // namespace __lsan\n \n extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char *__lsan_default_options();\n+\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n int __lsan_is_turned_off();\n "}, {"sha": "677727229b1e9632d9d95dc4ab303a39babb8177", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "modified", "additions": 25, "deletions": 79, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -32,6 +32,17 @@ static bool IsLinker(const char* full_name) {\n   return LibraryNameIs(full_name, kLinkerName);\n }\n \n+__attribute__((tls_model(\"initial-exec\")))\n+THREADLOCAL int disable_counter;\n+bool DisabledInThisThread() { return disable_counter > 0; }\n+void DisableInThisThread() { disable_counter++; }\n+void EnableInThisThread() {\n+  if (disable_counter == 0) {\n+    DisableCounterUnderflow();\n+  }\n+  disable_counter--;\n+}\n+\n void InitializePlatformSpecificModules() {\n   ListOfModules modules;\n   modules.init();\n@@ -49,8 +60,10 @@ void InitializePlatformSpecificModules() {\n       return;\n     }\n   }\n-  VReport(1, \"LeakSanitizer: Dynamic linker not found. \"\n-             \"TLS will not be handled correctly.\\n\");\n+  if (linker == nullptr) {\n+    VReport(1, \"LeakSanitizer: Dynamic linker not found. \"\n+               \"TLS will not be handled correctly.\\n\");\n+  }\n }\n \n static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n@@ -65,20 +78,7 @@ static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n       continue;\n     uptr begin = info->dlpi_addr + phdr->p_vaddr;\n     uptr end = begin + phdr->p_memsz;\n-    uptr allocator_begin = 0, allocator_end = 0;\n-    GetAllocatorGlobalRange(&allocator_begin, &allocator_end);\n-    if (begin <= allocator_begin && allocator_begin < end) {\n-      CHECK_LE(allocator_begin, allocator_end);\n-      CHECK_LE(allocator_end, end);\n-      if (begin < allocator_begin)\n-        ScanRangeForPointers(begin, allocator_begin, frontier, \"GLOBAL\",\n-                             kReachable);\n-      if (allocator_end < end)\n-        ScanRangeForPointers(allocator_end, end, frontier, \"GLOBAL\",\n-                             kReachable);\n-    } else {\n-      ScanRangeForPointers(begin, end, frontier, \"GLOBAL\", kReachable);\n-    }\n+    ScanGlobalRange(begin, end, frontier);\n   }\n   return 0;\n }\n@@ -89,76 +89,22 @@ void ProcessGlobalRegions(Frontier *frontier) {\n   dl_iterate_phdr(ProcessGlobalRegionsCallback, frontier);\n }\n \n-static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n-  CHECK(stack_id);\n-  StackTrace stack = map->Get(stack_id);\n-  // The top frame is our malloc/calloc/etc. The next frame is the caller.\n-  if (stack.size >= 2)\n-    return stack.trace[1];\n-  return 0;\n-}\n+LoadedModule *GetLinker() { return linker; }\n \n-struct ProcessPlatformAllocParam {\n-  Frontier *frontier;\n-  StackDepotReverseMap *stack_depot_reverse_map;\n-  bool skip_linker_allocations;\n-};\n-\n-// ForEachChunk callback. Identifies unreachable chunks which must be treated as\n-// reachable. Marks them as reachable and adds them to the frontier.\n-static void ProcessPlatformSpecificAllocationsCb(uptr chunk, void *arg) {\n-  CHECK(arg);\n-  ProcessPlatformAllocParam *param =\n-      reinterpret_cast<ProcessPlatformAllocParam *>(arg);\n-  chunk = GetUserBegin(chunk);\n-  LsanMetadata m(chunk);\n-  if (m.allocated() && m.tag() != kReachable && m.tag() != kIgnored) {\n-    u32 stack_id = m.stack_trace_id();\n-    uptr caller_pc = 0;\n-    if (stack_id > 0)\n-      caller_pc = GetCallerPC(stack_id, param->stack_depot_reverse_map);\n-    // If caller_pc is unknown, this chunk may be allocated in a coroutine. Mark\n-    // it as reachable, as we can't properly report its allocation stack anyway.\n-    if (caller_pc == 0 || (param->skip_linker_allocations &&\n-                           linker->containsAddress(caller_pc))) {\n-      m.set_tag(kReachable);\n-      param->frontier->push_back(chunk);\n-    }\n-  }\n-}\n-\n-// Handles dynamically allocated TLS blocks by treating all chunks allocated\n-// from ld-linux.so as reachable.\n-// Dynamic TLS blocks contain the TLS variables of dynamically loaded modules.\n-// They are allocated with a __libc_memalign() call in allocate_and_init()\n-// (elf/dl-tls.c). Glibc won't tell us the address ranges occupied by those\n-// blocks, but we can make sure they come from our own allocator by intercepting\n-// __libc_memalign(). On top of that, there is no easy way to reach them. Their\n-// addresses are stored in a dynamically allocated array (the DTV) which is\n-// referenced from the static TLS. Unfortunately, we can't just rely on the DTV\n-// being reachable from the static TLS, and the dynamic TLS being reachable from\n-// the DTV. This is because the initial DTV is allocated before our interception\n-// mechanism kicks in, and thus we don't recognize it as allocated memory. We\n-// can't special-case it either, since we don't know its size.\n-// Our solution is to include in the root set all allocations made from\n-// ld-linux.so (which is where allocate_and_init() is implemented). This is\n-// guaranteed to include all dynamic TLS blocks (and possibly other allocations\n-// which we don't care about).\n-void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n-  StackDepotReverseMap stack_depot_reverse_map;\n-  ProcessPlatformAllocParam arg;\n-  arg.frontier = frontier;\n-  arg.stack_depot_reverse_map = &stack_depot_reverse_map;\n-  arg.skip_linker_allocations =\n-      flags()->use_tls && flags()->use_ld_allocations && linker != nullptr;\n-  ForEachChunk(ProcessPlatformSpecificAllocationsCb, &arg);\n-}\n+void ProcessPlatformSpecificAllocations(Frontier *frontier) {}\n \n struct DoStopTheWorldParam {\n   StopTheWorldCallback callback;\n   void *argument;\n };\n \n+// While calling Die() here is undefined behavior and can potentially\n+// cause race conditions, it isn't possible to intercept exit on linux,\n+// so we have no choice but to call Die() from the atexit handler.\n+void HandleLeaks() {\n+  if (common_flags()->exitcode) Die();\n+}\n+\n static int DoStopTheWorldCallback(struct dl_phdr_info *info, size_t size,\n                                   void *data) {\n   DoStopTheWorldParam *param = reinterpret_cast<DoStopTheWorldParam *>(data);"}, {"sha": "e60b3d0f195db81763940f5be01f30f91061e7dd", "filename": "libsanitizer/lsan/lsan_common_mac.cc", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_common_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,197 @@\n+//=-- lsan_common_mac.cc --------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+// Implementation of common leak checking functionality. Darwin-specific code.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"lsan_common.h\"\n+\n+#if CAN_SANITIZE_LEAKS && SANITIZER_MAC\n+\n+#include \"sanitizer_common/sanitizer_allocator_internal.h\"\n+#include \"lsan_allocator.h\"\n+\n+#include <pthread.h>\n+\n+#include <mach/mach.h>\n+\n+namespace __lsan {\n+\n+typedef struct {\n+  int disable_counter;\n+  u32 current_thread_id;\n+  AllocatorCache cache;\n+} thread_local_data_t;\n+\n+static pthread_key_t key;\n+static pthread_once_t key_once = PTHREAD_ONCE_INIT;\n+\n+// The main thread destructor requires the current thread id,\n+// so we can't destroy it until it's been used and reset to invalid tid\n+void restore_tid_data(void *ptr) {\n+  thread_local_data_t *data = (thread_local_data_t *)ptr;\n+  if (data->current_thread_id != kInvalidTid)\n+    pthread_setspecific(key, data);\n+}\n+\n+static void make_tls_key() {\n+  CHECK_EQ(pthread_key_create(&key, restore_tid_data), 0);\n+}\n+\n+static thread_local_data_t *get_tls_val(bool alloc) {\n+  pthread_once(&key_once, make_tls_key);\n+\n+  thread_local_data_t *ptr = (thread_local_data_t *)pthread_getspecific(key);\n+  if (ptr == NULL && alloc) {\n+    ptr = (thread_local_data_t *)InternalAlloc(sizeof(*ptr));\n+    ptr->disable_counter = 0;\n+    ptr->current_thread_id = kInvalidTid;\n+    ptr->cache = AllocatorCache();\n+    pthread_setspecific(key, ptr);\n+  }\n+\n+  return ptr;\n+}\n+\n+bool DisabledInThisThread() {\n+  thread_local_data_t *data = get_tls_val(false);\n+  return data ? data->disable_counter > 0 : false;\n+}\n+\n+void DisableInThisThread() { ++get_tls_val(true)->disable_counter; }\n+\n+void EnableInThisThread() {\n+  int *disable_counter = &get_tls_val(true)->disable_counter;\n+  if (*disable_counter == 0) {\n+    DisableCounterUnderflow();\n+  }\n+  --*disable_counter;\n+}\n+\n+u32 GetCurrentThread() {\n+  thread_local_data_t *data = get_tls_val(false);\n+  return data ? data->current_thread_id : kInvalidTid;\n+}\n+\n+void SetCurrentThread(u32 tid) { get_tls_val(true)->current_thread_id = tid; }\n+\n+AllocatorCache *GetAllocatorCache() { return &get_tls_val(true)->cache; }\n+\n+LoadedModule *GetLinker() { return nullptr; }\n+\n+// Required on Linux for initialization of TLS behavior, but should not be\n+// required on Darwin.\n+void InitializePlatformSpecificModules() {}\n+\n+// Sections which can't contain contain global pointers. This list errs on the\n+// side of caution to avoid false positives, at the expense of performance.\n+//\n+// Other potentially safe sections include:\n+// __all_image_info, __crash_info, __const, __got, __interpose, __objc_msg_break\n+//\n+// Sections which definitely cannot be included here are:\n+// __objc_data, __objc_const, __data, __bss, __common, __thread_data,\n+// __thread_bss, __thread_vars, __objc_opt_rw, __objc_opt_ptrs\n+static const char *kSkippedSecNames[] = {\n+    \"__cfstring\",       \"__la_symbol_ptr\",  \"__mod_init_func\",\n+    \"__mod_term_func\",  \"__nl_symbol_ptr\",  \"__objc_classlist\",\n+    \"__objc_classrefs\", \"__objc_imageinfo\", \"__objc_nlclslist\",\n+    \"__objc_protolist\", \"__objc_selrefs\",   \"__objc_superrefs\"};\n+\n+// Scans global variables for heap pointers.\n+void ProcessGlobalRegions(Frontier *frontier) {\n+  for (auto name : kSkippedSecNames) CHECK(ARRAY_SIZE(name) < kMaxSegName);\n+\n+  MemoryMappingLayout memory_mapping(false);\n+  InternalMmapVector<LoadedModule> modules(/*initial_capacity*/ 128);\n+  memory_mapping.DumpListOfModules(&modules);\n+  for (uptr i = 0; i < modules.size(); ++i) {\n+    // Even when global scanning is disabled, we still need to scan\n+    // system libraries for stashed pointers\n+    if (!flags()->use_globals && modules[i].instrumented()) continue;\n+\n+    for (const __sanitizer::LoadedModule::AddressRange &range :\n+         modules[i].ranges()) {\n+      // Sections storing global variables are writable and non-executable\n+      if (range.executable || !range.writable) continue;\n+\n+      for (auto name : kSkippedSecNames) {\n+        if (!internal_strcmp(range.name, name)) continue;\n+      }\n+\n+      ScanGlobalRange(range.beg, range.end, frontier);\n+    }\n+  }\n+}\n+\n+void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n+  mach_port_name_t port;\n+  if (task_for_pid(mach_task_self(), internal_getpid(), &port)\n+      != KERN_SUCCESS) {\n+    return;\n+  }\n+\n+  unsigned depth = 1;\n+  vm_size_t size = 0;\n+  vm_address_t address = 0;\n+  kern_return_t err = KERN_SUCCESS;\n+  mach_msg_type_number_t count = VM_REGION_SUBMAP_INFO_COUNT_64;\n+\n+  InternalMmapVector<RootRegion> const *root_regions = GetRootRegions();\n+\n+  while (err == KERN_SUCCESS) {\n+    struct vm_region_submap_info_64 info;\n+    err = vm_region_recurse_64(port, &address, &size, &depth,\n+                               (vm_region_info_t)&info, &count);\n+\n+    uptr end_address = address + size;\n+\n+    // libxpc stashes some pointers in the Kernel Alloc Once page,\n+    // make sure not to report those as leaks.\n+    if (info.user_tag == VM_MEMORY_OS_ALLOC_ONCE) {\n+      ScanRangeForPointers(address, end_address, frontier, \"GLOBAL\",\n+                           kReachable);\n+\n+      // Recursing over the full memory map is very slow, break out\n+      // early if we don't need the full iteration.\n+      if (!flags()->use_root_regions || !root_regions->size())\n+        break;\n+    }\n+\n+    // This additional root region scan is required on Darwin in order to\n+    // detect root regions contained within mmap'd memory regions, because\n+    // the Darwin implementation of sanitizer_procmaps traverses images\n+    // as loaded by dyld, and not the complete set of all memory regions.\n+    //\n+    // TODO(fjricci) - remove this once sanitizer_procmaps_mac has the same\n+    // behavior as sanitizer_procmaps_linux and traverses all memory regions\n+    if (flags()->use_root_regions) {\n+      for (uptr i = 0; i < root_regions->size(); i++) {\n+        ScanRootRegion(frontier, (*root_regions)[i], address, end_address,\n+                       info.protection & kProtectionRead);\n+      }\n+    }\n+\n+    address = end_address;\n+  }\n+}\n+\n+// On darwin, we can intercept _exit gracefully, and return a failing exit code\n+// if required at that point. Calling Die() here is undefined behavior and\n+// causes rare race conditions.\n+void HandleLeaks() {}\n+\n+void DoStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+  StopTheWorld(callback, argument);\n+}\n+\n+} // namespace __lsan\n+\n+#endif // CAN_SANITIZE_LEAKS && SANITIZER_MAC"}, {"sha": "c9279aad676697c0e9765566b4ee1e27dcd3caef", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 186, "deletions": 50, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -17,13 +17,18 @@\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n+#include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n+#include \"sanitizer_common/sanitizer_platform_limits_netbsd.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_common/sanitizer_posix.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"lsan.h\"\n #include \"lsan_allocator.h\"\n #include \"lsan_common.h\"\n #include \"lsan_thread.h\"\n \n+#include <stddef.h>\n+\n using namespace __lsan;\n \n extern \"C\" {\n@@ -34,29 +39,23 @@ int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n int pthread_setspecific(unsigned key, const void *v);\n }\n \n-#define ENSURE_LSAN_INITED do {   \\\n-  CHECK(!lsan_init_is_running);   \\\n-  if (!lsan_inited)               \\\n-    __lsan_init();                \\\n-} while (0)\n-\n ///// Malloc/free interceptors. /////\n \n-const bool kAlwaysClearMemory = true;\n-\n namespace std {\n   struct nothrow_t;\n+  enum class align_val_t: size_t;\n }\n \n+#if !SANITIZER_MAC\n INTERCEPTOR(void*, malloc, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  return Allocate(stack, size, 1, kAlwaysClearMemory);\n+  return lsan_malloc(size, stack);\n }\n \n INTERCEPTOR(void, free, void *p) {\n   ENSURE_LSAN_INITED;\n-  Deallocate(p);\n+  lsan_free(p);\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n@@ -71,60 +70,76 @@ INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n     CHECK(allocated < kCallocPoolSize);\n     return mem;\n   }\n-  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return nullptr;\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  size *= nmemb;\n-  return Allocate(stack, size, 1, true);\n+  return lsan_calloc(nmemb, size, stack);\n }\n \n INTERCEPTOR(void*, realloc, void *q, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  return Reallocate(stack, q, size, 1);\n+  return lsan_realloc(q, size, stack);\n }\n \n-INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n+INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  return Allocate(stack, size, alignment, kAlwaysClearMemory);\n+  *memptr = lsan_memalign(alignment, size, stack);\n+  // FIXME: Return ENOMEM if user requested more than max alloc size.\n+  return 0;\n }\n \n-INTERCEPTOR(void*, aligned_alloc, uptr alignment, uptr size) {\n+INTERCEPTOR(void*, valloc, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  return Allocate(stack, size, alignment, kAlwaysClearMemory);\n+  return lsan_valloc(size, stack);\n }\n+#endif\n \n-INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n+#if SANITIZER_INTERCEPT_MEMALIGN\n+INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  *memptr = Allocate(stack, size, alignment, kAlwaysClearMemory);\n-  // FIXME: Return ENOMEM if user requested more than max alloc size.\n-  return 0;\n+  return lsan_memalign(alignment, size, stack);\n }\n+#define LSAN_MAYBE_INTERCEPT_MEMALIGN INTERCEPT_FUNCTION(memalign)\n \n INTERCEPTOR(void *, __libc_memalign, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  void *res = Allocate(stack, size, alignment, kAlwaysClearMemory);\n+  void *res = lsan_memalign(alignment, size, stack);\n   DTLS_on_libc_memalign(res, size);\n   return res;\n }\n+#define LSAN_MAYBE_INTERCEPT___LIBC_MEMALIGN INTERCEPT_FUNCTION(__libc_memalign)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_MEMALIGN\n+#define LSAN_MAYBE_INTERCEPT___LIBC_MEMALIGN\n+#endif // SANITIZER_INTERCEPT_MEMALIGN\n \n-INTERCEPTOR(void*, valloc, uptr size) {\n+#if SANITIZER_INTERCEPT_ALIGNED_ALLOC\n+INTERCEPTOR(void*, aligned_alloc, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  if (size == 0)\n-    size = GetPageSizeCached();\n-  return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n+  return lsan_memalign(alignment, size, stack);\n }\n+#define LSAN_MAYBE_INTERCEPT_ALIGNED_ALLOC INTERCEPT_FUNCTION(aligned_alloc)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_ALIGNED_ALLOC\n+#endif\n \n+#if SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE\n INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n   ENSURE_LSAN_INITED;\n   return GetMallocUsableSize(ptr);\n }\n+#define LSAN_MAYBE_INTERCEPT_MALLOC_USABLE_SIZE \\\n+        INTERCEPT_FUNCTION(malloc_usable_size)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_MALLOC_USABLE_SIZE\n+#endif\n \n+#if SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n struct fake_mallinfo {\n   int x[10];\n };\n@@ -134,11 +149,18 @@ INTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n   internal_memset(&res, 0, sizeof(res));\n   return res;\n }\n+#define LSAN_MAYBE_INTERCEPT_MALLINFO INTERCEPT_FUNCTION(mallinfo)\n \n INTERCEPTOR(int, mallopt, int cmd, int value) {\n   return -1;\n }\n+#define LSAN_MAYBE_INTERCEPT_MALLOPT INTERCEPT_FUNCTION(mallopt)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_MALLINFO\n+#define LSAN_MAYBE_INTERCEPT_MALLOPT\n+#endif // SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n \n+#if SANITIZER_INTERCEPT_PVALLOC\n INTERCEPTOR(void*, pvalloc, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n@@ -150,26 +172,81 @@ INTERCEPTOR(void*, pvalloc, uptr size) {\n   }\n   return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n }\n+#define LSAN_MAYBE_INTERCEPT_PVALLOC INTERCEPT_FUNCTION(pvalloc)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_PVALLOC\n+#endif // SANITIZER_INTERCEPT_PVALLOC\n \n+#if SANITIZER_INTERCEPT_CFREE\n INTERCEPTOR(void, cfree, void *p) ALIAS(WRAPPER_NAME(free));\n+#define LSAN_MAYBE_INTERCEPT_CFREE INTERCEPT_FUNCTION(cfree)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_CFREE\n+#endif // SANITIZER_INTERCEPT_CFREE\n+\n+#if SANITIZER_INTERCEPT_MCHECK_MPROBE\n+INTERCEPTOR(int, mcheck, void (*abortfunc)(int mstatus)) {\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, mcheck_pedantic, void (*abortfunc)(int mstatus)) {\n+  return 0;\n+}\n \n-#define OPERATOR_NEW_BODY                              \\\n-  ENSURE_LSAN_INITED;                                  \\\n-  GET_STACK_TRACE_MALLOC;                              \\\n-  return Allocate(stack, size, 1, kAlwaysClearMemory);\n+INTERCEPTOR(int, mprobe, void *ptr) {\n+  return 0;\n+}\n+#endif // SANITIZER_INTERCEPT_MCHECK_MPROBE\n+\n+\n+// TODO(alekseys): throw std::bad_alloc instead of dying on OOM.\n+#define OPERATOR_NEW_BODY(nothrow)                         \\\n+  ENSURE_LSAN_INITED;                                      \\\n+  GET_STACK_TRACE_MALLOC;                                  \\\n+  void *res = lsan_malloc(size, stack);                    \\\n+  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();   \\\n+  return res;\n+#define OPERATOR_NEW_BODY_ALIGN(nothrow)                   \\\n+  ENSURE_LSAN_INITED;                                      \\\n+  GET_STACK_TRACE_MALLOC;                                  \\\n+  void *res = lsan_memalign((uptr)align, size, stack);     \\\n+  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();   \\\n+  return res;\n+\n+#define OPERATOR_DELETE_BODY \\\n+  ENSURE_LSAN_INITED;        \\\n+  lsan_free(ptr);\n+\n+// On OS X it's not enough to just provide our own 'operator new' and\n+// 'operator delete' implementations, because they're going to be in the runtime\n+// dylib, and the main executable will depend on both the runtime dylib and\n+// libstdc++, each of has its implementation of new and delete.\n+// To make sure that C++ allocation/deallocation operators are overridden on\n+// OS X we need to intercept them using their mangled names.\n+#if !SANITIZER_MAC\n \n INTERCEPTOR_ATTRIBUTE\n-void *operator new(uptr size) { OPERATOR_NEW_BODY; }\n+void *operator new(size_t size) { OPERATOR_NEW_BODY(false /*nothrow*/); }\n INTERCEPTOR_ATTRIBUTE\n-void *operator new[](uptr size) { OPERATOR_NEW_BODY; }\n+void *operator new[](size_t size) { OPERATOR_NEW_BODY(false /*nothrow*/); }\n INTERCEPTOR_ATTRIBUTE\n-void *operator new(uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n+void *operator new(size_t size, std::nothrow_t const&)\n+{ OPERATOR_NEW_BODY(true /*nothrow*/); }\n INTERCEPTOR_ATTRIBUTE\n-void *operator new[](uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n-\n-#define OPERATOR_DELETE_BODY \\\n-  ENSURE_LSAN_INITED;        \\\n-  Deallocate(ptr);\n+void *operator new[](size_t size, std::nothrow_t const&)\n+{ OPERATOR_NEW_BODY(true /*nothrow*/); }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new(size_t size, std::align_val_t align)\n+{ OPERATOR_NEW_BODY_ALIGN(false /*nothrow*/); }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new[](size_t size, std::align_val_t align)\n+{ OPERATOR_NEW_BODY_ALIGN(false /*nothrow*/); }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new(size_t size, std::align_val_t align, std::nothrow_t const&)\n+{ OPERATOR_NEW_BODY_ALIGN(true /*nothrow*/); }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new[](size_t size, std::align_val_t align, std::nothrow_t const&)\n+{ OPERATOR_NEW_BODY_ALIGN(true /*nothrow*/); }\n \n INTERCEPTOR_ATTRIBUTE\n void operator delete(void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n@@ -178,9 +255,55 @@ void operator delete[](void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n void operator delete(void *ptr, std::nothrow_t const&) { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n-void operator delete[](void *ptr, std::nothrow_t const &) {\n-  OPERATOR_DELETE_BODY;\n-}\n+void operator delete[](void *ptr, std::nothrow_t const &)\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr, size_t size) NOEXCEPT\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr, size_t size) NOEXCEPT\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr, std::align_val_t) NOEXCEPT\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr, std::align_val_t) NOEXCEPT\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr, std::align_val_t, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr, std::align_val_t, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr, size_t size, std::align_val_t) NOEXCEPT\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr, size_t size, std::align_val_t) NOEXCEPT\n+{ OPERATOR_DELETE_BODY; }\n+\n+#else  // SANITIZER_MAC\n+\n+INTERCEPTOR(void *, _Znwm, size_t size)\n+{ OPERATOR_NEW_BODY(false /*nothrow*/); }\n+INTERCEPTOR(void *, _Znam, size_t size)\n+{ OPERATOR_NEW_BODY(false /*nothrow*/); }\n+INTERCEPTOR(void *, _ZnwmRKSt9nothrow_t, size_t size, std::nothrow_t const&)\n+{ OPERATOR_NEW_BODY(true /*nothrow*/); }\n+INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&)\n+{ OPERATOR_NEW_BODY(true /*nothrow*/); }\n+\n+INTERCEPTOR(void, _ZdlPv, void *ptr)\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR(void, _ZdaPv, void *ptr)\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR(void, _ZdlPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY; }\n+INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY; }\n+\n+#endif  // !SANITIZER_MAC\n+\n \n ///// Thread initialization and finalization. /////\n \n@@ -250,7 +373,8 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr,\n     res = REAL(pthread_create)(th, attr, __lsan_thread_start_func, &p);\n   }\n   if (res == 0) {\n-    int tid = ThreadCreate(GetCurrentThread(), *(uptr *)th, detached);\n+    int tid = ThreadCreate(GetCurrentThread(), *(uptr *)th,\n+                           IsStateDetached(detached));\n     CHECK_NE(tid, 0);\n     atomic_store(&p.tid, tid, memory_order_release);\n     while (atomic_load(&p.tid, memory_order_acquire) != 0)\n@@ -270,24 +394,36 @@ INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n   return res;\n }\n \n+INTERCEPTOR(void, _exit, int status) {\n+  if (status == 0 && HasReportedLeaks()) status = common_flags()->exitcode;\n+  REAL(_exit)(status);\n+}\n+\n+#define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n+#include \"sanitizer_common/sanitizer_signal_interceptors.inc\"\n+\n namespace __lsan {\n \n void InitializeInterceptors() {\n+  InitializeSignalInterceptors();\n+\n   INTERCEPT_FUNCTION(malloc);\n   INTERCEPT_FUNCTION(free);\n-  INTERCEPT_FUNCTION(cfree);\n+  LSAN_MAYBE_INTERCEPT_CFREE;\n   INTERCEPT_FUNCTION(calloc);\n   INTERCEPT_FUNCTION(realloc);\n-  INTERCEPT_FUNCTION(memalign);\n+  LSAN_MAYBE_INTERCEPT_MEMALIGN;\n+  LSAN_MAYBE_INTERCEPT___LIBC_MEMALIGN;\n+  LSAN_MAYBE_INTERCEPT_ALIGNED_ALLOC;\n   INTERCEPT_FUNCTION(posix_memalign);\n-  INTERCEPT_FUNCTION(__libc_memalign);\n   INTERCEPT_FUNCTION(valloc);\n-  INTERCEPT_FUNCTION(pvalloc);\n-  INTERCEPT_FUNCTION(malloc_usable_size);\n-  INTERCEPT_FUNCTION(mallinfo);\n-  INTERCEPT_FUNCTION(mallopt);\n+  LSAN_MAYBE_INTERCEPT_PVALLOC;\n+  LSAN_MAYBE_INTERCEPT_MALLOC_USABLE_SIZE;\n+  LSAN_MAYBE_INTERCEPT_MALLINFO;\n+  LSAN_MAYBE_INTERCEPT_MALLOPT;\n   INTERCEPT_FUNCTION(pthread_create);\n   INTERCEPT_FUNCTION(pthread_join);\n+  INTERCEPT_FUNCTION(_exit);\n \n   if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n     Report(\"LeakSanitizer: failed to create thread key.\\n\");"}, {"sha": "aa6445a98777e5b1ecad770bc2b0cbaeeaa67216", "filename": "libsanitizer/lsan/lsan_linux.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,31 @@\n+//=-- lsan_linux.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer. Linux-specific code.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+#if SANITIZER_LINUX\n+\n+#include \"lsan_allocator.h\"\n+\n+namespace __lsan {\n+\n+static THREADLOCAL u32 current_thread_tid = kInvalidTid;\n+u32 GetCurrentThread() { return current_thread_tid; }\n+void SetCurrentThread(u32 tid) { current_thread_tid = tid; }\n+\n+static THREADLOCAL AllocatorCache allocator_cache;\n+AllocatorCache *GetAllocatorCache() { return &allocator_cache; }\n+\n+void ReplaceSystemMalloc() {}\n+\n+} // namespace __lsan\n+\n+#endif // SANITIZER_LINUX"}, {"sha": "ca38c1c6f8a6fd187f2e3e2569205ce548a7805b", "filename": "libsanitizer/lsan/lsan_mac.cc", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,190 @@\n+//===-- lsan_mac.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer, a memory leak checker.\n+//\n+// Mac-specific details.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+\n+#include \"interception/interception.h\"\n+#include \"lsan.h\"\n+#include \"lsan_allocator.h\"\n+#include \"lsan_thread.h\"\n+\n+#include <pthread.h>\n+\n+namespace __lsan {\n+// Support for the following functions from libdispatch on Mac OS:\n+//   dispatch_async_f()\n+//   dispatch_async()\n+//   dispatch_sync_f()\n+//   dispatch_sync()\n+//   dispatch_after_f()\n+//   dispatch_after()\n+//   dispatch_group_async_f()\n+//   dispatch_group_async()\n+// TODO(glider): libdispatch API contains other functions that we don't support\n+// yet.\n+//\n+// dispatch_sync() and dispatch_sync_f() are synchronous, although chances are\n+// they can cause jobs to run on a thread different from the current one.\n+// TODO(glider): if so, we need a test for this (otherwise we should remove\n+// them).\n+//\n+// The following functions use dispatch_barrier_async_f() (which isn't a library\n+// function but is exported) and are thus supported:\n+//   dispatch_source_set_cancel_handler_f()\n+//   dispatch_source_set_cancel_handler()\n+//   dispatch_source_set_event_handler_f()\n+//   dispatch_source_set_event_handler()\n+//\n+// The reference manual for Grand Central Dispatch is available at\n+//   http://developer.apple.com/library/mac/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html\n+// The implementation details are at\n+//   http://libdispatch.macosforge.org/trac/browser/trunk/src/queue.c\n+\n+typedef void *dispatch_group_t;\n+typedef void *dispatch_queue_t;\n+typedef void *dispatch_source_t;\n+typedef u64 dispatch_time_t;\n+typedef void (*dispatch_function_t)(void *block);\n+typedef void *(*worker_t)(void *block);\n+\n+// A wrapper for the ObjC blocks used to support libdispatch.\n+typedef struct {\n+  void *block;\n+  dispatch_function_t func;\n+  u32 parent_tid;\n+} lsan_block_context_t;\n+\n+ALWAYS_INLINE\n+void lsan_register_worker_thread(int parent_tid) {\n+  if (GetCurrentThread() == kInvalidTid) {\n+    u32 tid = ThreadCreate(parent_tid, 0, true);\n+    ThreadStart(tid, GetTid());\n+    SetCurrentThread(tid);\n+  }\n+}\n+\n+// For use by only those functions that allocated the context via\n+// alloc_lsan_context().\n+extern \"C\" void lsan_dispatch_call_block_and_release(void *block) {\n+  lsan_block_context_t *context = (lsan_block_context_t *)block;\n+  VReport(2,\n+          \"lsan_dispatch_call_block_and_release(): \"\n+          \"context: %p, pthread_self: %p\\n\",\n+          block, pthread_self());\n+  lsan_register_worker_thread(context->parent_tid);\n+  // Call the original dispatcher for the block.\n+  context->func(context->block);\n+  lsan_free(context);\n+}\n+\n+}  // namespace __lsan\n+\n+using namespace __lsan;  // NOLINT\n+\n+// Wrap |ctxt| and |func| into an lsan_block_context_t.\n+// The caller retains control of the allocated context.\n+extern \"C\" lsan_block_context_t *alloc_lsan_context(void *ctxt,\n+                                                    dispatch_function_t func) {\n+  GET_STACK_TRACE_THREAD;\n+  lsan_block_context_t *lsan_ctxt =\n+      (lsan_block_context_t *)lsan_malloc(sizeof(lsan_block_context_t), stack);\n+  lsan_ctxt->block = ctxt;\n+  lsan_ctxt->func = func;\n+  lsan_ctxt->parent_tid = GetCurrentThread();\n+  return lsan_ctxt;\n+}\n+\n+// Define interceptor for dispatch_*_f function with the three most common\n+// parameters: dispatch_queue_t, context, dispatch_function_t.\n+#define INTERCEPT_DISPATCH_X_F_3(dispatch_x_f)                        \\\n+  INTERCEPTOR(void, dispatch_x_f, dispatch_queue_t dq, void *ctxt,    \\\n+              dispatch_function_t func) {                             \\\n+    lsan_block_context_t *lsan_ctxt = alloc_lsan_context(ctxt, func); \\\n+    return REAL(dispatch_x_f)(dq, (void *)lsan_ctxt,                  \\\n+                              lsan_dispatch_call_block_and_release);  \\\n+  }\n+\n+INTERCEPT_DISPATCH_X_F_3(dispatch_async_f)\n+INTERCEPT_DISPATCH_X_F_3(dispatch_sync_f)\n+INTERCEPT_DISPATCH_X_F_3(dispatch_barrier_async_f)\n+\n+INTERCEPTOR(void, dispatch_after_f, dispatch_time_t when, dispatch_queue_t dq,\n+            void *ctxt, dispatch_function_t func) {\n+  lsan_block_context_t *lsan_ctxt = alloc_lsan_context(ctxt, func);\n+  return REAL(dispatch_after_f)(when, dq, (void *)lsan_ctxt,\n+                                lsan_dispatch_call_block_and_release);\n+}\n+\n+INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n+            dispatch_queue_t dq, void *ctxt, dispatch_function_t func) {\n+  lsan_block_context_t *lsan_ctxt = alloc_lsan_context(ctxt, func);\n+  REAL(dispatch_group_async_f)\n+  (group, dq, (void *)lsan_ctxt, lsan_dispatch_call_block_and_release);\n+}\n+\n+#if !defined(MISSING_BLOCKS_SUPPORT)\n+extern \"C\" {\n+void dispatch_async(dispatch_queue_t dq, void (^work)(void));\n+void dispatch_group_async(dispatch_group_t dg, dispatch_queue_t dq,\n+                          void (^work)(void));\n+void dispatch_after(dispatch_time_t when, dispatch_queue_t queue,\n+                    void (^work)(void));\n+void dispatch_source_set_cancel_handler(dispatch_source_t ds,\n+                                        void (^work)(void));\n+void dispatch_source_set_event_handler(dispatch_source_t ds,\n+                                       void (^work)(void));\n+}\n+\n+#define GET_LSAN_BLOCK(work)                 \\\n+  void (^lsan_block)(void);                  \\\n+  int parent_tid = GetCurrentThread();       \\\n+  lsan_block = ^(void) {                     \\\n+    lsan_register_worker_thread(parent_tid); \\\n+    work();                                  \\\n+  }\n+\n+INTERCEPTOR(void, dispatch_async, dispatch_queue_t dq, void (^work)(void)) {\n+  GET_LSAN_BLOCK(work);\n+  REAL(dispatch_async)(dq, lsan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_group_async, dispatch_group_t dg,\n+            dispatch_queue_t dq, void (^work)(void)) {\n+  GET_LSAN_BLOCK(work);\n+  REAL(dispatch_group_async)(dg, dq, lsan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_after, dispatch_time_t when, dispatch_queue_t queue,\n+            void (^work)(void)) {\n+  GET_LSAN_BLOCK(work);\n+  REAL(dispatch_after)(when, queue, lsan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_source_set_cancel_handler, dispatch_source_t ds,\n+            void (^work)(void)) {\n+  if (!work) {\n+    REAL(dispatch_source_set_cancel_handler)(ds, work);\n+    return;\n+  }\n+  GET_LSAN_BLOCK(work);\n+  REAL(dispatch_source_set_cancel_handler)(ds, lsan_block);\n+}\n+\n+INTERCEPTOR(void, dispatch_source_set_event_handler, dispatch_source_t ds,\n+            void (^work)(void)) {\n+  GET_LSAN_BLOCK(work);\n+  REAL(dispatch_source_set_event_handler)(ds, lsan_block);\n+}\n+#endif\n+\n+#endif  // SANITIZER_MAC"}, {"sha": "2d810af841fe5cacbf4a30e9ce2290b4952b1c59", "filename": "libsanitizer/lsan/lsan_malloc_mac.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_malloc_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,53 @@\n+//===-- lsan_malloc_mac.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer (LSan), a memory leak detector.\n+//\n+// Mac-specific malloc interception.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+\n+#include \"lsan.h\"\n+#include \"lsan_allocator.h\"\n+#include \"lsan_thread.h\"\n+\n+using namespace __lsan;\n+#define COMMON_MALLOC_ZONE_NAME \"lsan\"\n+#define COMMON_MALLOC_ENTER() ENSURE_LSAN_INITED\n+#define COMMON_MALLOC_SANITIZER_INITIALIZED lsan_inited\n+#define COMMON_MALLOC_FORCE_LOCK()\n+#define COMMON_MALLOC_FORCE_UNLOCK()\n+#define COMMON_MALLOC_MEMALIGN(alignment, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = lsan_memalign(alignment, size, stack)\n+#define COMMON_MALLOC_MALLOC(size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = lsan_malloc(size, stack)\n+#define COMMON_MALLOC_REALLOC(ptr, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = lsan_realloc(ptr, size, stack)\n+#define COMMON_MALLOC_CALLOC(count, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = lsan_calloc(count, size, stack)\n+#define COMMON_MALLOC_VALLOC(size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = lsan_valloc(size, stack)\n+#define COMMON_MALLOC_FREE(ptr) \\\n+  lsan_free(ptr)\n+#define COMMON_MALLOC_SIZE(ptr) \\\n+  uptr size = lsan_mz_size(ptr)\n+#define COMMON_MALLOC_FILL_STATS(zone, stats)\n+#define COMMON_MALLOC_REPORT_UNKNOWN_REALLOC(ptr, zone_ptr, zone_name) \\\n+  (void)zone_name; \\\n+  Report(\"mz_realloc(%p) -- attempting to realloc unallocated memory.\\n\", ptr);\n+#define COMMON_MALLOC_NAMESPACE __lsan\n+\n+#include \"sanitizer_common/sanitizer_malloc_mac.inc\"\n+\n+#endif // SANITIZER_MAC"}, {"sha": "e03e8766ae1e42e5bafa72cadb6bc6709f27a035", "filename": "libsanitizer/lsan/lsan_thread.cc", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -17,13 +17,11 @@\n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"lsan_allocator.h\"\n+#include \"lsan_common.h\"\n \n namespace __lsan {\n \n-const u32 kInvalidTid = (u32) -1;\n-\n static ThreadRegistry *thread_registry;\n-static THREADLOCAL u32 current_thread_tid = kInvalidTid;\n \n static ThreadContextBase *CreateThreadContext(u32 tid) {\n   void *mem = MmapOrDie(sizeof(ThreadContext), \"ThreadContext\");\n@@ -39,14 +37,6 @@ void InitializeThreadRegistry() {\n     ThreadRegistry(CreateThreadContext, kMaxThreads, kThreadQuarantineSize);\n }\n \n-u32 GetCurrentThread() {\n-  return current_thread_tid;\n-}\n-\n-void SetCurrentThread(u32 tid) {\n-  current_thread_tid = tid;\n-}\n-\n ThreadContext::ThreadContext(int tid)\n     : ThreadContextBase(tid),\n       stack_begin_(0),\n@@ -85,7 +75,7 @@ u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached) {\n                                        /* arg */ nullptr);\n }\n \n-void ThreadStart(u32 tid, uptr os_id) {\n+void ThreadStart(u32 tid, tid_t os_id, bool workerthread) {\n   OnStartedArgs args;\n   uptr stack_size = 0;\n   uptr tls_size = 0;\n@@ -95,11 +85,12 @@ void ThreadStart(u32 tid, uptr os_id) {\n   args.tls_end = args.tls_begin + tls_size;\n   GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n   args.dtls = DTLS_Get();\n-  thread_registry->StartThread(tid, os_id, &args);\n+  thread_registry->StartThread(tid, os_id, workerthread, &args);\n }\n \n void ThreadFinish() {\n   thread_registry->FinishThread(GetCurrentThread());\n+  SetCurrentThread(kInvalidTid);\n }\n \n ThreadContext *CurrentThreadContext() {\n@@ -134,7 +125,7 @@ void EnsureMainThreadIDIsCorrect() {\n \n ///// Interface to the common LSan module. /////\n \n-bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n+bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n                            uptr *cache_end, DTLS **dtls) {\n   ThreadContext *context = static_cast<ThreadContext *>(\n@@ -150,7 +141,7 @@ bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n   return true;\n }\n \n-void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n+void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n                             void *arg) {\n }\n "}, {"sha": "867583474326ee9e7e3f89dd11198cab5e2a996c", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -43,7 +43,7 @@ class ThreadContext : public ThreadContextBase {\n \n void InitializeThreadRegistry();\n \n-void ThreadStart(u32 tid, uptr os_id);\n+void ThreadStart(u32 tid, tid_t os_id, bool workerthread = false);\n void ThreadFinish();\n u32 ThreadCreate(u32 tid, uptr uid, bool detached);\n void ThreadJoin(u32 tid);"}, {"sha": "adaab4cee5485ac7310d82677e22d06b046e1774", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -19,13 +19,16 @@ ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n \n sanitizer_common_files = \\\n+\tsancov_flags.cc \\\n \tsanitizer_allocator.cc \\\n+\tsanitizer_allocator_checks.cc \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n-\tsanitizer_coverage_libcdep.cc \\\n-\tsanitizer_coverage_mapping_libcdep.cc \\\n+\tsanitizer_coverage_libcdep_new.cc \\\n \tsanitizer_deadlock_detector1.cc \\\n \tsanitizer_deadlock_detector2.cc \\\n+\tsanitizer_errno.cc \\\n+\tsanitizer_file.cc \\\n \tsanitizer_flags.cc \\\n \tsanitizer_flag_parser.cc \\\n \tsanitizer_libc.cc \\\n@@ -34,6 +37,7 @@ sanitizer_common_files = \\\n \tsanitizer_linux_libcdep.cc \\\n \tsanitizer_linux_s390.cc \\\n \tsanitizer_mac.cc \\\n+\tsanitizer_mac_libcdep.cc \\\n \tsanitizer_persistent_allocator.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n@@ -50,6 +54,7 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_mac.cc \\\n \tsanitizer_stacktrace_printer.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n+\tsanitizer_stoptheworld_mac.cc \\\n \tsanitizer_suppressions.cc \\\n \tsanitizer_symbolizer.cc \\\n \tsanitizer_symbolizer_libbacktrace.cc \\"}, {"sha": "b2acc5caf56c2c5412b8dccb4651a4aff70c8942", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -80,15 +80,16 @@ CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n-\tsanitizer_common_libcdep.lo sanitizer_coverage_libcdep.lo \\\n-\tsanitizer_coverage_mapping_libcdep.lo \\\n+am__objects_1 = sancov_flags.lo sanitizer_allocator.lo \\\n+\tsanitizer_allocator_checks.lo sanitizer_common.lo \\\n+\tsanitizer_common_libcdep.lo sanitizer_coverage_libcdep_new.lo \\\n \tsanitizer_deadlock_detector1.lo \\\n-\tsanitizer_deadlock_detector2.lo sanitizer_flags.lo \\\n-\tsanitizer_flag_parser.lo sanitizer_libc.lo \\\n-\tsanitizer_libignore.lo sanitizer_linux.lo \\\n+\tsanitizer_deadlock_detector2.lo sanitizer_errno.lo \\\n+\tsanitizer_file.lo sanitizer_flags.lo sanitizer_flag_parser.lo \\\n+\tsanitizer_libc.lo sanitizer_libignore.lo sanitizer_linux.lo \\\n \tsanitizer_linux_libcdep.lo sanitizer_linux_s390.lo \\\n-\tsanitizer_mac.lo sanitizer_persistent_allocator.lo \\\n+\tsanitizer_mac.lo sanitizer_mac_libcdep.lo \\\n+\tsanitizer_persistent_allocator.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n \tsanitizer_platform_limits_posix.lo sanitizer_posix.lo \\\n \tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n@@ -98,8 +99,8 @@ am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_stacktrace_libcdep.lo sanitizer_symbolizer_mac.lo \\\n \tsanitizer_stacktrace_printer.lo \\\n \tsanitizer_stoptheworld_linux_libcdep.lo \\\n-\tsanitizer_suppressions.lo sanitizer_symbolizer.lo \\\n-\tsanitizer_symbolizer_libbacktrace.lo \\\n+\tsanitizer_stoptheworld_mac.lo sanitizer_suppressions.lo \\\n+\tsanitizer_symbolizer.lo sanitizer_symbolizer_libbacktrace.lo \\\n \tsanitizer_symbolizer_libcdep.lo \\\n \tsanitizer_symbolizer_posix_libcdep.lo \\\n \tsanitizer_symbolizer_win.lo sanitizer_termination.lo \\\n@@ -300,13 +301,16 @@ AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n sanitizer_common_files = \\\n+\tsancov_flags.cc \\\n \tsanitizer_allocator.cc \\\n+\tsanitizer_allocator_checks.cc \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n-\tsanitizer_coverage_libcdep.cc \\\n-\tsanitizer_coverage_mapping_libcdep.cc \\\n+\tsanitizer_coverage_libcdep_new.cc \\\n \tsanitizer_deadlock_detector1.cc \\\n \tsanitizer_deadlock_detector2.cc \\\n+\tsanitizer_errno.cc \\\n+\tsanitizer_file.cc \\\n \tsanitizer_flags.cc \\\n \tsanitizer_flag_parser.cc \\\n \tsanitizer_libc.cc \\\n@@ -315,6 +319,7 @@ sanitizer_common_files = \\\n \tsanitizer_linux_libcdep.cc \\\n \tsanitizer_linux_s390.cc \\\n \tsanitizer_mac.cc \\\n+\tsanitizer_mac_libcdep.cc \\\n \tsanitizer_persistent_allocator.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n@@ -331,6 +336,7 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_mac.cc \\\n \tsanitizer_stacktrace_printer.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n+\tsanitizer_stoptheworld_mac.cc \\\n \tsanitizer_suppressions.cc \\\n \tsanitizer_symbolizer.cc \\\n \tsanitizer_symbolizer_libbacktrace.cc \\\n@@ -439,13 +445,16 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sancov_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator_checks.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_mapping_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_libcdep_new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_errno.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_file.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flag_parser.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n@@ -456,6 +465,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_s390.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_x86_64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_persistent_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_posix.Plo@am__quote@\n@@ -471,6 +481,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_printer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_suppressions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo@am__quote@"}, {"sha": "e600cdac33cd6d43f771a5e4e6ccb979d4e95a09", "filename": "libsanitizer/sanitizer_common/sancov_flags.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsancov_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsancov_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_flags.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,57 @@\n+//===-- sancov_flags.cc -----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Sanitizer Coverage runtime flags.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sancov_flags.h\"\n+#include \"sanitizer_flag_parser.h\"\n+#include \"sanitizer_platform.h\"\n+\n+SANITIZER_INTERFACE_WEAK_DEF(const char*, __sancov_default_options, void) {\n+  return \"\";\n+}\n+\n+using namespace __sanitizer;\n+\n+namespace __sancov {\n+\n+SancovFlags sancov_flags_dont_use_directly;  // use via flags();\n+\n+void SancovFlags::SetDefaults() {\n+#define SANCOV_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n+#include \"sancov_flags.inc\"\n+#undef SANCOV_FLAG\n+}\n+\n+static void RegisterSancovFlags(FlagParser *parser, SancovFlags *f) {\n+#define SANCOV_FLAG(Type, Name, DefaultValue, Description) \\\n+  RegisterFlag(parser, #Name, Description, &f->Name);\n+#include \"sancov_flags.inc\"\n+#undef SANCOV_FLAG\n+}\n+\n+static const char *MaybeCallSancovDefaultOptions() {\n+  return (&__sancov_default_options) ? __sancov_default_options() : \"\";\n+}\n+\n+void InitializeSancovFlags() {\n+  SancovFlags *f = sancov_flags();\n+  f->SetDefaults();\n+\n+  FlagParser parser;\n+  RegisterSancovFlags(&parser, f);\n+\n+  parser.ParseString(MaybeCallSancovDefaultOptions());\n+  parser.ParseString(GetEnv(\"SANCOV_OPTIONS\"));\n+\n+  ReportUnrecognizedFlags();\n+  if (f->help) parser.PrintFlagDescriptions();\n+}\n+\n+}  // namespace __sancov"}, {"sha": "f7e0186c5112afe2299dab01892f186bd76077c8", "filename": "libsanitizer/sanitizer_common/sancov_flags.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsancov_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsancov_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_flags.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,38 @@\n+//===-- sancov_flags.h ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Sanitizer Coverage runtime flags.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANCOV_FLAGS_H\n+#define SANCOV_FLAGS_H\n+\n+#include \"sanitizer_flag_parser.h\"\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sancov {\n+\n+struct SancovFlags {\n+#define SANCOV_FLAG(Type, Name, DefaultValue, Description) Type Name;\n+#include \"sancov_flags.inc\"\n+#undef SANCOV_FLAG\n+\n+  void SetDefaults();\n+};\n+\n+extern SancovFlags sancov_flags_dont_use_directly;\n+\n+inline SancovFlags* sancov_flags() { return &sancov_flags_dont_use_directly; }\n+\n+void InitializeSancovFlags();\n+\n+}  // namespace __sancov\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE const char*\n+__sancov_default_options();\n+\n+#endif"}, {"sha": "a6107cc85839d64537da6befa9ef42fc36a726f6", "filename": "libsanitizer/sanitizer_common/sancov_flags.inc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsancov_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsancov_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_flags.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,19 @@\n+//===-- sancov_flags.inc ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Sanitizer Coverage runtime flags.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANCOV_FLAG\n+#error \"Defnine SANCOV_FLAG prior to including this file!\"\n+#endif\n+\n+SANCOV_FLAG(bool, symbolize, true,\n+            \"If set, converage information will be symbolized by sancov tool \"\n+            \"after dumping.\")\n+\n+SANCOV_FLAG(bool, help, false, \"Print flags help.\")"}, {"sha": "a67ec84373ef4a784e809e34b7cd74793f52f04b", "filename": "libsanitizer/sanitizer_common/sanitizer_addrhashmap.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -71,6 +71,8 @@ class AddrHashMap {\n \n     ~Handle();\n     T *operator->();\n+    T &operator*();\n+    const T &operator*() const;\n     bool created() const;\n     bool exists() const;\n \n@@ -134,6 +136,16 @@ T *AddrHashMap<T, kSize>::Handle::operator->() {\n   return &cell_->val;\n }\n \n+template <typename T, uptr kSize>\n+const T &AddrHashMap<T, kSize>::Handle::operator*() const {\n+  return cell_->val;\n+}\n+\n+template <typename T, uptr kSize>\n+T &AddrHashMap<T, kSize>::Handle::operator*() {\n+  return cell_->val;\n+}\n+\n template<typename T, uptr kSize>\n bool AddrHashMap<T, kSize>::Handle::created() const {\n   return created_;"}, {"sha": "895efcf1be0553b94f009399adebf0ac2f94dc3e", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -12,6 +12,7 @@\n \n #include \"sanitizer_allocator.h\"\n \n+#include \"sanitizer_allocator_checks.h\"\n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n@@ -92,7 +93,7 @@ InternalAllocator *internal_allocator() {\n     SpinMutexLock l(&internal_alloc_init_mu);\n     if (atomic_load(&internal_allocator_initialized, memory_order_relaxed) ==\n         0) {\n-      internal_allocator_instance->Init(/* may_return_null*/ false);\n+      internal_allocator_instance->Init(kReleaseToOSIntervalNever);\n       atomic_store(&internal_allocator_initialized, 1, memory_order_release);\n     }\n   }\n@@ -105,9 +106,9 @@ static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache,\n   if (cache == 0) {\n     SpinMutexLock l(&internal_allocator_cache_mu);\n     return internal_allocator()->Allocate(&internal_allocator_cache, size,\n-                                          alignment, false);\n+                                          alignment);\n   }\n-  return internal_allocator()->Allocate(cache, size, alignment, false);\n+  return internal_allocator()->Allocate(cache, size, alignment);\n }\n \n static void *RawInternalRealloc(void *ptr, uptr size,\n@@ -158,8 +159,8 @@ void *InternalRealloc(void *addr, uptr size, InternalAllocatorCache *cache) {\n }\n \n void *InternalCalloc(uptr count, uptr size, InternalAllocatorCache *cache) {\n-  if (CallocShouldReturnNullDueToOverflow(count, size))\n-    return internal_allocator()->ReturnNullOrDieOnBadRequest();\n+  if (UNLIKELY(CheckForCallocOverflow(count, size)))\n+    return InternalAllocator::FailureHandler::OnBadRequest();\n   void *p = InternalAlloc(count * size, cache);\n   if (p) internal_memset(p, 0, count * size);\n   return p;\n@@ -200,23 +201,51 @@ void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback) {\n   low_level_alloc_callback = callback;\n }\n \n-bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n) {\n-  if (!size) return false;\n-  uptr max = (uptr)-1L;\n-  return (max / size) < n;\n-}\n-\n-static atomic_uint8_t reporting_out_of_memory = {0};\n+static atomic_uint8_t allocator_out_of_memory = {0};\n+static atomic_uint8_t allocator_may_return_null = {0};\n \n-bool IsReportingOOM() { return atomic_load_relaxed(&reporting_out_of_memory); }\n+bool IsAllocatorOutOfMemory() {\n+  return atomic_load_relaxed(&allocator_out_of_memory);\n+}\n \n-void NORETURN ReportAllocatorCannotReturnNull(bool out_of_memory) {\n-  if (out_of_memory) atomic_store_relaxed(&reporting_out_of_memory, 1);\n+// Prints error message and kills the program.\n+void NORETURN ReportAllocatorCannotReturnNull() {\n   Report(\"%s's allocator is terminating the process instead of returning 0\\n\",\n          SanitizerToolName);\n   Report(\"If you don't like this behavior set allocator_may_return_null=1\\n\");\n   CHECK(0);\n   Die();\n }\n \n+bool AllocatorMayReturnNull() {\n+  return atomic_load(&allocator_may_return_null, memory_order_relaxed);\n+}\n+\n+void SetAllocatorMayReturnNull(bool may_return_null) {\n+  atomic_store(&allocator_may_return_null, may_return_null,\n+               memory_order_relaxed);\n+}\n+\n+void *ReturnNullOrDieOnFailure::OnBadRequest() {\n+  if (AllocatorMayReturnNull())\n+    return nullptr;\n+  ReportAllocatorCannotReturnNull();\n+}\n+\n+void *ReturnNullOrDieOnFailure::OnOOM() {\n+  atomic_store_relaxed(&allocator_out_of_memory, 1);\n+  if (AllocatorMayReturnNull())\n+    return nullptr;\n+  ReportAllocatorCannotReturnNull();\n+}\n+\n+void NORETURN *DieOnFailure::OnBadRequest() {\n+  ReportAllocatorCannotReturnNull();\n+}\n+\n+void NORETURN *DieOnFailure::OnOOM() {\n+  atomic_store_relaxed(&allocator_out_of_memory, 1);\n+  ReportAllocatorCannotReturnNull();\n+}\n+\n } // namespace __sanitizer"}, {"sha": "523578a9d6001407ed753320b42de6eb1b5e0659", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -22,12 +22,28 @@\n \n namespace __sanitizer {\n \n-// Returns true if ReportAllocatorCannotReturnNull(true) was called.\n-// Can be use to avoid memory hungry operations.\n-bool IsReportingOOM();\n+// Since flags are immutable and allocator behavior can be changed at runtime\n+// (unit tests or ASan on Android are some examples), allocator_may_return_null\n+// flag value is cached here and can be altered later.\n+bool AllocatorMayReturnNull();\n+void SetAllocatorMayReturnNull(bool may_return_null);\n \n-// Prints error message and kills the program.\n-void NORETURN ReportAllocatorCannotReturnNull(bool out_of_memory);\n+// Allocator failure handling policies:\n+// Implements AllocatorMayReturnNull policy, returns null when the flag is set,\n+// dies otherwise.\n+struct ReturnNullOrDieOnFailure {\n+  static void *OnBadRequest();\n+  static void *OnOOM();\n+};\n+// Always dies on the failure.\n+struct DieOnFailure {\n+  static void NORETURN *OnBadRequest();\n+  static void NORETURN *OnOOM();\n+};\n+\n+// Returns true if allocator detected OOM condition. Can be used to avoid memory\n+// hungry operations. Set when AllocatorReturnNullOrDieOnOOM() is called.\n+bool IsAllocatorOutOfMemory();\n \n // Allocators call these callbacks on mmap/munmap.\n struct NoOpMapUnmapCallback {\n@@ -38,9 +54,6 @@ struct NoOpMapUnmapCallback {\n // Callback type for iterating over chunks.\n typedef void (*ForEachChunkCallback)(uptr chunk, void *arg);\n \n-// Returns true if calloc(size, n) should return 0 due to overflow in size*n.\n-bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n);\n-\n #include \"sanitizer_allocator_size_class_map.h\"\n #include \"sanitizer_allocator_stats.h\"\n #include \"sanitizer_allocator_primary64.h\""}, {"sha": "3e6eb61a7d5df9269bad39b2e8d06b2053f8d0c6", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,21 @@\n+//===-- sanitizer_allocator_checks.cc ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Various checks shared between ThreadSanitizer, MemorySanitizer, etc. memory\n+// allocators.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_errno.h\"\n+\n+namespace __sanitizer {\n+\n+void SetErrnoToENOMEM() {\n+  errno = errno_ENOMEM;\n+}\n+\n+} // namespace __sanitizer"}, {"sha": "978813222b50a1000dafe80a60c8f4f7f75e9987", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,73 @@\n+//===-- sanitizer_allocator_checks.h ----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Various checks shared between ThreadSanitizer, MemorySanitizer, etc. memory\n+// allocators.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ALLOCATOR_CHECKS_H\n+#define SANITIZER_ALLOCATOR_CHECKS_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_platform.h\"\n+\n+namespace __sanitizer {\n+\n+// The following is defined in a separate compilation unit to avoid pulling in\n+// sanitizer_errno.h in this header, which leads to conflicts when other system\n+// headers include errno.h. This is usually the result of an unlikely event,\n+// and as such we do not care as much about having it inlined.\n+void SetErrnoToENOMEM();\n+\n+// A common errno setting logic shared by almost all sanitizer allocator APIs.\n+INLINE void *SetErrnoOnNull(void *ptr) {\n+  if (UNLIKELY(!ptr))\n+    SetErrnoToENOMEM();\n+  return ptr;\n+}\n+\n+// In case of the check failure, the caller of the following Check... functions\n+// should \"return POLICY::OnBadRequest();\" where POLICY is the current allocator\n+// failure handling policy.\n+\n+// Checks aligned_alloc() parameters, verifies that the alignment is a power of\n+// two and that the size is a multiple of alignment for POSIX implementation,\n+// and a bit relaxed requirement for non-POSIX ones, that the size is a multiple\n+// of alignment.\n+INLINE bool CheckAlignedAllocAlignmentAndSize(uptr alignment, uptr size) {\n+#if SANITIZER_POSIX\n+  return IsPowerOfTwo(alignment) && (size & (alignment - 1)) == 0;\n+#else\n+  return size % alignment == 0;\n+#endif\n+}\n+\n+// Checks posix_memalign() parameters, verifies that alignment is a power of two\n+// and a multiple of sizeof(void *).\n+INLINE bool CheckPosixMemalignAlignment(uptr alignment) {\n+  return IsPowerOfTwo(alignment) && (alignment % sizeof(void *)) == 0; // NOLINT\n+}\n+\n+// Returns true if calloc(size, n) call overflows on size*n calculation.\n+INLINE bool CheckForCallocOverflow(uptr size, uptr n) {\n+  if (!size)\n+    return false;\n+  uptr max = (uptr)-1L;\n+  return (max / size) < n;\n+}\n+\n+// Returns true if the size passed to pvalloc overflows when rounded to the next\n+// multiple of page_size.\n+INLINE bool CheckForPvallocOverflow(uptr size, uptr page_size) {\n+  return RoundUpTo(size, page_size) < size;\n+}\n+\n+} // namespace __sanitizer\n+\n+#endif  // SANITIZER_ALLOCATOR_CHECKS_H"}, {"sha": "99e411f4378f2ff758dbbe3cf6b727ffbceb049d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "modified", "additions": 29, "deletions": 48, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -22,72 +22,57 @@ template <class PrimaryAllocator, class AllocatorCache,\n           class SecondaryAllocator>  // NOLINT\n class CombinedAllocator {\n  public:\n-  void InitCommon(bool may_return_null) {\n-    primary_.Init();\n-    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n-  }\n+  typedef typename SecondaryAllocator::FailureHandler FailureHandler;\n \n-  void InitLinkerInitialized(bool may_return_null) {\n-    secondary_.InitLinkerInitialized(may_return_null);\n+  void InitLinkerInitialized(s32 release_to_os_interval_ms) {\n+    primary_.Init(release_to_os_interval_ms);\n+    secondary_.InitLinkerInitialized();\n     stats_.InitLinkerInitialized();\n-    InitCommon(may_return_null);\n   }\n \n-  void Init(bool may_return_null) {\n-    secondary_.Init(may_return_null);\n+  void Init(s32 release_to_os_interval_ms) {\n+    primary_.Init(release_to_os_interval_ms);\n+    secondary_.Init();\n     stats_.Init();\n-    InitCommon(may_return_null);\n   }\n \n-  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,\n-                 bool cleared = false, bool check_rss_limit = false) {\n+  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment) {\n     // Returning 0 on malloc(0) may break a lot of code.\n     if (size == 0)\n       size = 1;\n-    if (size + alignment < size) return ReturnNullOrDieOnBadRequest();\n-    if (check_rss_limit && RssLimitIsExceeded()) return ReturnNullOrDieOnOOM();\n+    if (size + alignment < size)\n+      return FailureHandler::OnBadRequest();\n+    uptr original_size = size;\n+    // If alignment requirements are to be fulfilled by the frontend allocator\n+    // rather than by the primary or secondary, passing an alignment lower than\n+    // or equal to 8 will prevent any further rounding up, as well as the later\n+    // alignment check.\n     if (alignment > 8)\n       size = RoundUpTo(size, alignment);\n+    // The primary allocator should return a 2^x aligned allocation when\n+    // requested 2^x bytes, hence using the rounded up 'size' when being\n+    // serviced by the primary (this is no longer true when the primary is\n+    // using a non-fixed base address). The secondary takes care of the\n+    // alignment without such requirement, and allocating 'size' would use\n+    // extraneous memory, so we employ 'original_size'.\n     void *res;\n-    bool from_primary = primary_.CanAllocate(size, alignment);\n-    if (from_primary)\n+    if (primary_.CanAllocate(size, alignment))\n       res = cache->Allocate(&primary_, primary_.ClassID(size));\n     else\n-      res = secondary_.Allocate(&stats_, size, alignment);\n+      res = secondary_.Allocate(&stats_, original_size, alignment);\n+    if (!res)\n+      return FailureHandler::OnOOM();\n     if (alignment > 8)\n       CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n-    if (cleared && res && from_primary)\n-      internal_bzero_aligned16(res, RoundUpTo(size, 16));\n     return res;\n   }\n \n-  bool MayReturnNull() const {\n-    return atomic_load(&may_return_null_, memory_order_acquire);\n-  }\n-\n-  void *ReturnNullOrDieOnBadRequest() {\n-    if (MayReturnNull())\n-      return nullptr;\n-    ReportAllocatorCannotReturnNull(false);\n-  }\n-\n-  void *ReturnNullOrDieOnOOM() {\n-    if (MayReturnNull()) return nullptr;\n-    ReportAllocatorCannotReturnNull(true);\n+  s32 ReleaseToOSIntervalMs() const {\n+    return primary_.ReleaseToOSIntervalMs();\n   }\n \n-  void SetMayReturnNull(bool may_return_null) {\n-    secondary_.SetMayReturnNull(may_return_null);\n-    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n-  }\n-\n-  bool RssLimitIsExceeded() {\n-    return atomic_load(&rss_limit_is_exceeded_, memory_order_acquire);\n-  }\n-\n-  void SetRssLimitIsExceeded(bool rss_limit_is_exceeded) {\n-    atomic_store(&rss_limit_is_exceeded_, rss_limit_is_exceeded,\n-                 memory_order_release);\n+  void SetReleaseToOSIntervalMs(s32 release_to_os_interval_ms) {\n+    primary_.SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n   }\n \n   void Deallocate(AllocatorCache *cache, void *p) {\n@@ -191,8 +176,6 @@ class CombinedAllocator {\n     primary_.ForceUnlock();\n   }\n \n-  void ReleaseToOS() { primary_.ReleaseToOS(); }\n-\n   // Iterate over all existing chunks.\n   // The allocator must be locked when calling this function.\n   void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n@@ -204,6 +187,4 @@ class CombinedAllocator {\n   PrimaryAllocator primary_;\n   SecondaryAllocator secondary_;\n   AllocatorGlobalStats stats_;\n-  atomic_uint8_t may_return_null_;\n-  atomic_uint8_t rss_limit_is_exceeded_;\n };"}, {"sha": "fa74f8ca6402a0acfa4beb08f912d6071e8f3cbd", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_interface.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -32,13 +32,12 @@ SANITIZER_INTERFACE_ATTRIBUTE int __sanitizer_install_malloc_and_free_hooks(\n     void (*free_hook)(const void *));\n \n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-    /* OPTIONAL */ void __sanitizer_malloc_hook(void *ptr, uptr size);\n+    void __sanitizer_malloc_hook(void *ptr, uptr size);\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-    /* OPTIONAL */ void __sanitizer_free_hook(void *ptr);\n+    void __sanitizer_free_hook(void *ptr);\n \n-\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-    void __sanitizer_print_memory_profile(int top_percent);\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_print_memory_profile(uptr top_percent, uptr max_number_of_contexts);\n }  // extern \"C\"\n \n #endif  // SANITIZER_ALLOCATOR_INTERFACE_H"}, {"sha": "f1aed0f3bec09dcbbf8a9a019976d558619f683e", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -21,27 +21,32 @@ namespace __sanitizer {\n // purposes.\n typedef CompactSizeClassMap InternalSizeClassMap;\n \n-static const uptr kInternalAllocatorSpace = 0;\n-static const u64 kInternalAllocatorSize = SANITIZER_MMAP_RANGE_SIZE;\n static const uptr kInternalAllocatorRegionSizeLog = 20;\n-#if SANITIZER_WORDSIZE == 32\n static const uptr kInternalAllocatorNumRegions =\n-    kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n+    SANITIZER_MMAP_RANGE_SIZE >> kInternalAllocatorRegionSizeLog;\n+#if SANITIZER_WORDSIZE == 32\n typedef FlatByteMap<kInternalAllocatorNumRegions> ByteMap;\n #else\n-static const uptr kInternalAllocatorNumRegions =\n-    kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n typedef TwoLevelByteMap<(kInternalAllocatorNumRegions >> 12), 1 << 12> ByteMap;\n #endif\n-typedef SizeClassAllocator32<\n-    kInternalAllocatorSpace, kInternalAllocatorSize, 0, InternalSizeClassMap,\n-    kInternalAllocatorRegionSizeLog, ByteMap> PrimaryInternalAllocator;\n+struct AP32 {\n+  static const uptr kSpaceBeg = 0;\n+  static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n+  static const uptr kMetadataSize = 0;\n+  typedef InternalSizeClassMap SizeClassMap;\n+  static const uptr kRegionSizeLog = kInternalAllocatorRegionSizeLog;\n+  typedef __sanitizer::ByteMap ByteMap;\n+  typedef NoOpMapUnmapCallback MapUnmapCallback;\n+  static const uptr kFlags = 0;\n+};\n+typedef SizeClassAllocator32<AP32> PrimaryInternalAllocator;\n \n typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n     InternalAllocatorCache;\n \n typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n-                          LargeMmapAllocator<> > InternalAllocator;\n+                          LargeMmapAllocator<NoOpMapUnmapCallback, DieOnFailure>\n+                         > InternalAllocator;\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache = nullptr,\n                     uptr alignment = 0);"}, {"sha": "99013e37f8a3ca458f13fc9592a1f3c55666ba42", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_local_cache.h", "status": "modified", "additions": 84, "deletions": 61, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -24,9 +24,6 @@ struct SizeClassAllocatorLocalCache\n template <class SizeClassAllocator>\n struct SizeClassAllocator64LocalCache {\n   typedef SizeClassAllocator Allocator;\n-  static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n-  typedef typename Allocator::SizeClassMapT SizeClassMap;\n-  typedef typename Allocator::CompactPtrT CompactPtrT;\n \n   void Init(AllocatorGlobalStats *s) {\n     stats_.Init();\n@@ -43,10 +40,12 @@ struct SizeClassAllocator64LocalCache {\n   void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n-    stats_.Add(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n     PerClass *c = &per_class_[class_id];\n-    if (UNLIKELY(c->count == 0))\n-      Refill(c, allocator, class_id);\n+    if (UNLIKELY(c->count == 0)) {\n+      if (UNLIKELY(!Refill(c, allocator, class_id)))\n+        return nullptr;\n+    }\n+    stats_.Add(AllocatorStatAllocated, c->class_size);\n     CHECK_GT(c->count, 0);\n     CompactPtrT chunk = c->chunks[--c->count];\n     void *res = reinterpret_cast<void *>(allocator->CompactPtrToPointer(\n@@ -60,8 +59,8 @@ struct SizeClassAllocator64LocalCache {\n     // If the first allocator call on a new thread is a deallocation, then\n     // max_count will be zero, leading to check failure.\n     InitCache();\n-    stats_.Sub(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n     PerClass *c = &per_class_[class_id];\n+    stats_.Sub(AllocatorStatAllocated, c->class_size);\n     CHECK_NE(c->max_count, 0UL);\n     if (UNLIKELY(c->count == c->max_count))\n       Drain(c, allocator, class_id, c->max_count / 2);\n@@ -72,38 +71,46 @@ struct SizeClassAllocator64LocalCache {\n   }\n \n   void Drain(SizeClassAllocator *allocator) {\n-    for (uptr class_id = 0; class_id < kNumClasses; class_id++) {\n-      PerClass *c = &per_class_[class_id];\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      PerClass *c = &per_class_[i];\n       while (c->count > 0)\n-        Drain(c, allocator, class_id, c->count);\n+        Drain(c, allocator, i, c->count);\n     }\n   }\n \n-  // private:\n+ private:\n+  typedef typename Allocator::SizeClassMapT SizeClassMap;\n+  static const uptr kNumClasses = SizeClassMap::kNumClasses;\n+  typedef typename Allocator::CompactPtrT CompactPtrT;\n+\n   struct PerClass {\n     u32 count;\n     u32 max_count;\n+    uptr class_size;\n     CompactPtrT chunks[2 * SizeClassMap::kMaxNumCachedHint];\n   };\n   PerClass per_class_[kNumClasses];\n   AllocatorStats stats_;\n \n   void InitCache() {\n-    if (per_class_[1].max_count)\n+    if (LIKELY(per_class_[1].max_count))\n       return;\n     for (uptr i = 0; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n       c->max_count = 2 * SizeClassMap::MaxCachedHint(i);\n+      c->class_size = Allocator::ClassIdToSize(i);\n     }\n   }\n \n-  NOINLINE void Refill(PerClass *c, SizeClassAllocator *allocator,\n+  NOINLINE bool Refill(PerClass *c, SizeClassAllocator *allocator,\n                        uptr class_id) {\n     InitCache();\n-    uptr num_requested_chunks = SizeClassMap::MaxCachedHint(class_id);\n-    allocator->GetFromAllocator(&stats_, class_id, c->chunks,\n-                                num_requested_chunks);\n+    uptr num_requested_chunks = c->max_count / 2;\n+    if (UNLIKELY(!allocator->GetFromAllocator(&stats_, class_id, c->chunks,\n+                                              num_requested_chunks)))\n+      return false;\n     c->count = num_requested_chunks;\n+    return true;\n   }\n \n   NOINLINE void Drain(PerClass *c, SizeClassAllocator *allocator, uptr class_id,\n@@ -122,14 +129,28 @@ template <class SizeClassAllocator>\n struct SizeClassAllocator32LocalCache {\n   typedef SizeClassAllocator Allocator;\n   typedef typename Allocator::TransferBatch TransferBatch;\n-  static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n \n   void Init(AllocatorGlobalStats *s) {\n     stats_.Init();\n     if (s)\n       s->Register(&stats_);\n   }\n \n+  // Returns a TransferBatch suitable for class_id.\n+  TransferBatch *CreateBatch(uptr class_id, SizeClassAllocator *allocator,\n+                             TransferBatch *b) {\n+    if (uptr batch_class_id = per_class_[class_id].batch_class_id)\n+      return (TransferBatch*)Allocate(allocator, batch_class_id);\n+    return b;\n+  }\n+\n+  // Destroys TransferBatch b.\n+  void DestroyBatch(uptr class_id, SizeClassAllocator *allocator,\n+                    TransferBatch *b) {\n+    if (uptr batch_class_id = per_class_[class_id].batch_class_id)\n+      Deallocate(allocator, batch_class_id, b);\n+  }\n+\n   void Destroy(SizeClassAllocator *allocator, AllocatorGlobalStats *s) {\n     Drain(allocator);\n     if (s)\n@@ -139,10 +160,12 @@ struct SizeClassAllocator32LocalCache {\n   void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n-    stats_.Add(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n     PerClass *c = &per_class_[class_id];\n-    if (UNLIKELY(c->count == 0))\n-      Refill(allocator, class_id);\n+    if (UNLIKELY(c->count == 0)) {\n+      if (UNLIKELY(!Refill(allocator, class_id)))\n+        return nullptr;\n+    }\n+    stats_.Add(AllocatorStatAllocated, c->class_size);\n     void *res = c->batch[--c->count];\n     PREFETCH(c->batch[c->count - 1]);\n     return res;\n@@ -154,81 +177,77 @@ struct SizeClassAllocator32LocalCache {\n     // If the first allocator call on a new thread is a deallocation, then\n     // max_count will be zero, leading to check failure.\n     InitCache();\n-    stats_.Sub(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n     PerClass *c = &per_class_[class_id];\n+    stats_.Sub(AllocatorStatAllocated, c->class_size);\n     CHECK_NE(c->max_count, 0UL);\n     if (UNLIKELY(c->count == c->max_count))\n       Drain(allocator, class_id);\n     c->batch[c->count++] = p;\n   }\n \n   void Drain(SizeClassAllocator *allocator) {\n-    for (uptr class_id = 0; class_id < kNumClasses; class_id++) {\n-      PerClass *c = &per_class_[class_id];\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      PerClass *c = &per_class_[i];\n       while (c->count > 0)\n-        Drain(allocator, class_id);\n+        Drain(allocator, i);\n     }\n   }\n \n-  // private:\n-  typedef typename SizeClassAllocator::SizeClassMapT SizeClassMap;\n+ private:\n+  typedef typename Allocator::SizeClassMapT SizeClassMap;\n+  static const uptr kBatchClassID = SizeClassMap::kBatchClassID;\n+  static const uptr kNumClasses = SizeClassMap::kNumClasses;\n+  // If kUseSeparateSizeClassForBatch is true, all TransferBatch objects are\n+  // allocated from kBatchClassID size class (except for those that are needed\n+  // for kBatchClassID itself). The goal is to have TransferBatches in a totally\n+  // different region of RAM to improve security.\n+  static const bool kUseSeparateSizeClassForBatch =\n+      Allocator::kUseSeparateSizeClassForBatch;\n+\n   struct PerClass {\n     uptr count;\n     uptr max_count;\n+    uptr class_size;\n+    uptr batch_class_id;\n     void *batch[2 * TransferBatch::kMaxNumCached];\n   };\n   PerClass per_class_[kNumClasses];\n   AllocatorStats stats_;\n \n   void InitCache() {\n-    if (per_class_[1].max_count)\n+    if (LIKELY(per_class_[1].max_count))\n       return;\n+    const uptr batch_class_id = SizeClassMap::ClassID(sizeof(TransferBatch));\n     for (uptr i = 0; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n-      c->max_count = 2 * TransferBatch::MaxCached(i);\n+      uptr max_cached = TransferBatch::MaxCached(i);\n+      c->max_count = 2 * max_cached;\n+      c->class_size = Allocator::ClassIdToSize(i);\n+      // Precompute the class id to use to store batches for the current class\n+      // id. 0 means the class size is large enough to store a batch within one\n+      // of the chunks. If using a separate size class, it will always be\n+      // kBatchClassID, except for kBatchClassID itself.\n+      if (kUseSeparateSizeClassForBatch) {\n+        c->batch_class_id = (i == kBatchClassID) ? 0 : kBatchClassID;\n+      } else {\n+        c->batch_class_id = (c->class_size <\n+          TransferBatch::AllocationSizeRequiredForNElements(max_cached)) ?\n+              batch_class_id : 0;\n+      }\n     }\n   }\n \n-  // TransferBatch class is declared in SizeClassAllocator.\n-  // We transfer chunks between central and thread-local free lists in batches.\n-  // For small size classes we allocate batches separately.\n-  // For large size classes we may use one of the chunks to store the batch.\n-  // sizeof(TransferBatch) must be a power of 2 for more efficient allocation.\n-  static uptr SizeClassForTransferBatch(uptr class_id) {\n-    if (Allocator::ClassIdToSize(class_id) <\n-        TransferBatch::AllocationSizeRequiredForNElements(\n-            TransferBatch::MaxCached(class_id)))\n-      return SizeClassMap::ClassID(sizeof(TransferBatch));\n-    return 0;\n-  }\n-\n-  // Returns a TransferBatch suitable for class_id.\n-  // For small size classes allocates the batch from the allocator.\n-  // For large size classes simply returns b.\n-  TransferBatch *CreateBatch(uptr class_id, SizeClassAllocator *allocator,\n-                             TransferBatch *b) {\n-    if (uptr batch_class_id = SizeClassForTransferBatch(class_id))\n-      return (TransferBatch*)Allocate(allocator, batch_class_id);\n-    return b;\n-  }\n-\n-  // Destroys TransferBatch b.\n-  // For small size classes deallocates b to the allocator.\n-  // Does notthing for large size classes.\n-  void DestroyBatch(uptr class_id, SizeClassAllocator *allocator,\n-                    TransferBatch *b) {\n-    if (uptr batch_class_id = SizeClassForTransferBatch(class_id))\n-      Deallocate(allocator, batch_class_id, b);\n-  }\n-\n-  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {\n+  NOINLINE bool Refill(SizeClassAllocator *allocator, uptr class_id) {\n     InitCache();\n     PerClass *c = &per_class_[class_id];\n     TransferBatch *b = allocator->AllocateBatch(&stats_, this, class_id);\n+    if (UNLIKELY(!b))\n+      return false;\n     CHECK_GT(b->Count(), 0);\n     b->CopyToArray(c->batch);\n     c->count = b->Count();\n     DestroyBatch(class_id, allocator, b);\n+    return true;\n   }\n \n   NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {\n@@ -238,6 +257,10 @@ struct SizeClassAllocator32LocalCache {\n     uptr first_idx_to_drain = c->count - cnt;\n     TransferBatch *b = CreateBatch(\n         class_id, allocator, (TransferBatch *)c->batch[first_idx_to_drain]);\n+    // Failure to allocate a batch while releasing memory is non recoverable.\n+    // TODO(alekseys): Figure out how to do it without allocating a new batch.\n+    if (UNLIKELY(!b))\n+      DieOnFailure::OnOOM();\n     b->SetFromArray(allocator->GetRegionBeginBySizeClass(class_id),\n                     &c->batch[first_idx_to_drain], cnt);\n     c->count -= cnt;"}, {"sha": "90a57dbb6cf97765cc35fa276b12a5087a8f03b4", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -22,7 +22,8 @@ template<class SizeClassAllocator> struct SizeClassAllocator32LocalCache;\n // be returned by MmapOrDie().\n //\n // Region:\n-//   a result of a single call to MmapAlignedOrDie(kRegionSize, kRegionSize).\n+//   a result of a single call to MmapAlignedOrDieOnFatalError(kRegionSize,\n+//                                                             kRegionSize).\n // Since the regions are aligned by kRegionSize, there are exactly\n // kNumPossibleRegions possible regions in the address space and so we keep\n // a ByteMap possible_regions to store the size classes of each Region.\n@@ -34,13 +35,30 @@ template<class SizeClassAllocator> struct SizeClassAllocator32LocalCache;\n //\n // In order to avoid false sharing the objects of this class should be\n // chache-line aligned.\n-template <const uptr kSpaceBeg, const u64 kSpaceSize,\n-          const uptr kMetadataSize, class SizeClassMap,\n-          const uptr kRegionSizeLog,\n-          class ByteMap,\n-          class MapUnmapCallback = NoOpMapUnmapCallback>\n+\n+struct SizeClassAllocator32FlagMasks {  //  Bit masks.\n+  enum {\n+    kRandomShuffleChunks = 1,\n+    kUseSeparateSizeClassForBatch = 2,\n+  };\n+};\n+\n+template <class Params>\n class SizeClassAllocator32 {\n  public:\n+  static const uptr kSpaceBeg = Params::kSpaceBeg;\n+  static const u64 kSpaceSize = Params::kSpaceSize;\n+  static const uptr kMetadataSize = Params::kMetadataSize;\n+  typedef typename Params::SizeClassMap SizeClassMap;\n+  static const uptr kRegionSizeLog = Params::kRegionSizeLog;\n+  typedef typename Params::ByteMap ByteMap;\n+  typedef typename Params::MapUnmapCallback MapUnmapCallback;\n+\n+  static const bool kRandomShuffleChunks = Params::kFlags &\n+      SizeClassAllocator32FlagMasks::kRandomShuffleChunks;\n+  static const bool kUseSeparateSizeClassForBatch = Params::kFlags &\n+      SizeClassAllocator32FlagMasks::kUseSeparateSizeClassForBatch;\n+\n   struct TransferBatch {\n     static const uptr kMaxNumCached = SizeClassMap::kMaxNumCachedHint - 2;\n     void SetFromArray(uptr region_beg_unused, void *batch[], uptr count) {\n@@ -77,24 +95,30 @@ class SizeClassAllocator32 {\n \n   static const uptr kBatchSize = sizeof(TransferBatch);\n   COMPILER_CHECK((kBatchSize & (kBatchSize - 1)) == 0);\n-  COMPILER_CHECK(sizeof(TransferBatch) ==\n-                 SizeClassMap::kMaxNumCachedHint * sizeof(uptr));\n+  COMPILER_CHECK(kBatchSize == SizeClassMap::kMaxNumCachedHint * sizeof(uptr));\n \n   static uptr ClassIdToSize(uptr class_id) {\n-    return SizeClassMap::Size(class_id);\n+    return (class_id == SizeClassMap::kBatchClassID) ?\n+        kBatchSize : SizeClassMap::Size(class_id);\n   }\n \n-  typedef SizeClassAllocator32<kSpaceBeg, kSpaceSize, kMetadataSize,\n-      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;\n+  typedef SizeClassAllocator32<Params> ThisT;\n   typedef SizeClassAllocator32LocalCache<ThisT> AllocatorCache;\n \n-  void Init() {\n+  void Init(s32 release_to_os_interval_ms) {\n     possible_regions.TestOnlyInit();\n     internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));\n   }\n \n+  s32 ReleaseToOSIntervalMs() const {\n+    return kReleaseToOSIntervalNever;\n+  }\n+\n+  void SetReleaseToOSIntervalMs(s32 release_to_os_interval_ms) {\n+    // This is empty here. Currently only implemented in 64-bit allocator.\n+  }\n+\n   void *MapWithCallback(uptr size) {\n-    size = RoundUpTo(size, GetPageSizeCached());\n     void *res = MmapOrDie(size, \"SizeClassAllocator32\");\n     MapUnmapCallback().OnMap((uptr)res, size);\n     return res;\n@@ -126,8 +150,9 @@ class SizeClassAllocator32 {\n     CHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n-    if (sci->free_list.empty())\n-      PopulateFreeList(stat, c, sci, class_id);\n+    if (sci->free_list.empty() &&\n+        UNLIKELY(!PopulateFreeList(stat, c, sci, class_id)))\n+      return nullptr;\n     CHECK(!sci->free_list.empty());\n     TransferBatch *b = sci->free_list.front();\n     sci->free_list.pop_front();\n@@ -137,9 +162,9 @@ class SizeClassAllocator32 {\n   NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id,\n                                 TransferBatch *b) {\n     CHECK_LT(class_id, kNumClasses);\n+    CHECK_GT(b->Count(), 0);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n-    CHECK_GT(b->Count(), 0);\n     sci->free_list.push_front(b);\n   }\n \n@@ -227,10 +252,6 @@ class SizeClassAllocator32 {\n     return 0;\n   }\n \n-  // This is empty here. Currently only implemented in 64-bit allocator.\n-  void ReleaseToOS() { }\n-\n-\n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n \n@@ -258,11 +279,13 @@ class SizeClassAllocator32 {\n \n   uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n-    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,\n-                                      \"SizeClassAllocator32\"));\n+    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDieOnFatalError(\n+        kRegionSize, kRegionSize, \"SizeClassAllocator32\"));\n+    if (UNLIKELY(!res))\n+      return 0;\n     MapUnmapCallback().OnMap(res, kRegionSize);\n     stat->Add(AllocatorStatMapped, kRegionSize);\n-    CHECK_EQ(0U, (res & (kRegionSize - 1)));\n+    CHECK(IsAligned(res, kRegionSize));\n     possible_regions.set(ComputeRegionId(res), static_cast<u8>(class_id));\n     return res;\n   }\n@@ -272,21 +295,25 @@ class SizeClassAllocator32 {\n     return &size_class_info_array[class_id];\n   }\n \n-  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n+  bool PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n                         SizeClassInfo *sci, uptr class_id) {\n     uptr size = ClassIdToSize(class_id);\n     uptr reg = AllocateRegion(stat, class_id);\n+    if (UNLIKELY(!reg))\n+      return false;\n     uptr n_chunks = kRegionSize / (size + kMetadataSize);\n     uptr max_count = TransferBatch::MaxCached(class_id);\n+    CHECK_GT(max_count, 0);\n     TransferBatch *b = nullptr;\n     for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n       if (!b) {\n         b = c->CreateBatch(class_id, this, (TransferBatch*)i);\n+        if (UNLIKELY(!b))\n+          return false;\n         b->Clear();\n       }\n       b->Add((void*)i);\n       if (b->Count() == max_count) {\n-        CHECK_GT(b->Count(), 0);\n         sci->free_list.push_back(b);\n         b = nullptr;\n       }\n@@ -295,6 +322,7 @@ class SizeClassAllocator32 {\n       CHECK_GT(b->Count(), 0);\n       sci->free_list.push_back(b);\n     }\n+    return true;\n   }\n \n   ByteMap possible_regions;"}, {"sha": "4ae59c8b6b16e6ac6d2baef46dc318b91c46670f", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 450, "deletions": 132, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -60,14 +60,14 @@ class SizeClassAllocator64 {\n   // as a 4-byte integer (offset from the region start shifted right by 4).\n   typedef u32 CompactPtrT;\n   static const uptr kCompactPtrScale = 4;\n-  CompactPtrT PointerToCompactPtr(uptr base, uptr ptr) {\n+  CompactPtrT PointerToCompactPtr(uptr base, uptr ptr) const {\n     return static_cast<CompactPtrT>((ptr - base) >> kCompactPtrScale);\n   }\n-  uptr CompactPtrToPointer(uptr base, CompactPtrT ptr32) {\n+  uptr CompactPtrToPointer(uptr base, CompactPtrT ptr32) const {\n     return base + (static_cast<uptr>(ptr32) << kCompactPtrScale);\n   }\n \n-  void Init() {\n+  void Init(s32 release_to_os_interval_ms) {\n     uptr TotalSpaceSize = kSpaceSize + AdditionalSize();\n     if (kUsingConstantSpaceBeg) {\n       CHECK_EQ(kSpaceBeg, reinterpret_cast<uptr>(\n@@ -77,17 +77,17 @@ class SizeClassAllocator64 {\n           reinterpret_cast<uptr>(MmapNoAccess(TotalSpaceSize));\n       CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n     }\n-    MapWithCallback(SpaceEnd(), AdditionalSize());\n+    SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n+    MapWithCallbackOrDie(SpaceEnd(), AdditionalSize());\n   }\n \n-  void MapWithCallback(uptr beg, uptr size) {\n-    CHECK_EQ(beg, reinterpret_cast<uptr>(MmapFixedOrDie(beg, size)));\n-    MapUnmapCallback().OnMap(beg, size);\n+  s32 ReleaseToOSIntervalMs() const {\n+    return atomic_load(&release_to_os_interval_ms_, memory_order_relaxed);\n   }\n \n-  void UnmapWithCallback(uptr beg, uptr size) {\n-    MapUnmapCallback().OnUnmap(beg, size);\n-    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n+  void SetReleaseToOSIntervalMs(s32 release_to_os_interval_ms) {\n+    atomic_store(&release_to_os_interval_ms_, release_to_os_interval_ms,\n+                 memory_order_relaxed);\n   }\n \n   static bool CanAllocate(uptr size, uptr alignment) {\n@@ -104,33 +104,40 @@ class SizeClassAllocator64 {\n     BlockingMutexLock l(&region->mutex);\n     uptr old_num_chunks = region->num_freed_chunks;\n     uptr new_num_freed_chunks = old_num_chunks + n_chunks;\n-    EnsureFreeArraySpace(region, region_beg, new_num_freed_chunks);\n+    // Failure to allocate free array space while releasing memory is non\n+    // recoverable.\n+    if (UNLIKELY(!EnsureFreeArraySpace(region, region_beg,\n+                                       new_num_freed_chunks)))\n+      DieOnFailure::OnOOM();\n     for (uptr i = 0; i < n_chunks; i++)\n       free_array[old_num_chunks + i] = chunks[i];\n     region->num_freed_chunks = new_num_freed_chunks;\n-    region->n_freed += n_chunks;\n+    region->stats.n_freed += n_chunks;\n+\n+    MaybeReleaseToOS(class_id);\n   }\n \n-  NOINLINE void GetFromAllocator(AllocatorStats *stat, uptr class_id,\n+  NOINLINE bool GetFromAllocator(AllocatorStats *stat, uptr class_id,\n                                  CompactPtrT *chunks, uptr n_chunks) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     uptr region_beg = GetRegionBeginBySizeClass(class_id);\n     CompactPtrT *free_array = GetFreeArray(region_beg);\n \n     BlockingMutexLock l(&region->mutex);\n     if (UNLIKELY(region->num_freed_chunks < n_chunks)) {\n-      PopulateFreeArray(stat, class_id, region,\n-                        n_chunks - region->num_freed_chunks);\n+      if (UNLIKELY(!PopulateFreeArray(stat, class_id, region,\n+                                      n_chunks - region->num_freed_chunks)))\n+        return false;\n       CHECK_GE(region->num_freed_chunks, n_chunks);\n     }\n     region->num_freed_chunks -= n_chunks;\n     uptr base_idx = region->num_freed_chunks;\n     for (uptr i = 0; i < n_chunks; i++)\n       chunks[i] = free_array[base_idx + i];\n-    region->n_allocated += n_chunks;\n+    region->stats.n_allocated += n_chunks;\n+    return true;\n   }\n \n-\n   bool PointerIsMine(const void *p) {\n     uptr P = reinterpret_cast<uptr>(p);\n     if (kUsingConstantSpaceBeg && (kSpaceBeg % kSpaceSize) == 0)\n@@ -146,7 +153,7 @@ class SizeClassAllocator64 {\n         space_beg;\n   }\n \n-  uptr GetRegionBeginBySizeClass(uptr class_id) {\n+  uptr GetRegionBeginBySizeClass(uptr class_id) const {\n     return SpaceBeg() + kRegionSize * class_id;\n   }\n \n@@ -197,7 +204,7 @@ class SizeClassAllocator64 {\n \n   // Test-only.\n   void TestOnlyUnmap() {\n-    UnmapWithCallback(SpaceBeg(), kSpaceSize + AdditionalSize());\n+    UnmapWithCallbackOrDie(SpaceBeg(), kSpaceSize + AdditionalSize());\n   }\n \n   static void FillMemoryProfile(uptr start, uptr rss, bool file, uptr *stats,\n@@ -210,16 +217,18 @@ class SizeClassAllocator64 {\n   void PrintStats(uptr class_id, uptr rss) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     if (region->mapped_user == 0) return;\n-    uptr in_use = region->n_allocated - region->n_freed;\n+    uptr in_use = region->stats.n_allocated - region->stats.n_freed;\n     uptr avail_chunks = region->allocated_user / ClassIdToSize(class_id);\n     Printf(\n-        \"  %02zd (%zd): mapped: %zdK allocs: %zd frees: %zd inuse: %zd \"\n-        \"num_freed_chunks %zd\"\n-        \" avail: %zd rss: %zdK releases: %zd\\n\",\n-        class_id, ClassIdToSize(class_id), region->mapped_user >> 10,\n-        region->n_allocated, region->n_freed, in_use,\n-        region->num_freed_chunks, avail_chunks, rss >> 10,\n-        region->rtoi.num_releases);\n+        \"%s %02zd (%6zd): mapped: %6zdK allocs: %7zd frees: %7zd inuse: %6zd \"\n+        \"num_freed_chunks %7zd avail: %6zd rss: %6zdK releases: %6zd \"\n+        \"last released: %6zdK region: 0x%zx\\n\",\n+        region->exhausted ? \"F\" : \" \", class_id, ClassIdToSize(class_id),\n+        region->mapped_user >> 10, region->stats.n_allocated,\n+        region->stats.n_freed, in_use, region->num_freed_chunks, avail_chunks,\n+        rss >> 10, region->rtoi.num_releases,\n+        region->rtoi.last_released_bytes >> 10,\n+        SpaceBeg() + kRegionSize * class_id);\n   }\n \n   void PrintStats() {\n@@ -229,8 +238,8 @@ class SizeClassAllocator64 {\n     for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n       RegionInfo *region = GetRegionInfo(class_id);\n       total_mapped += region->mapped_user;\n-      n_allocated += region->n_allocated;\n-      n_freed += region->n_freed;\n+      n_allocated += region->stats.n_allocated;\n+      n_freed += region->stats.n_freed;\n     }\n     Printf(\"Stats: SizeClassAllocator64: %zdM mapped in %zd allocations; \"\n            \"remains %zd\\n\",\n@@ -282,16 +291,244 @@ class SizeClassAllocator64 {\n                      GetPageSizeCached());\n   }\n \n-  void ReleaseToOS() {\n-    for (uptr class_id = 1; class_id < kNumClasses; class_id++)\n-      ReleaseToOS(class_id);\n-  }\n-\n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n   static const uptr kNumClassesRounded = SizeClassMap::kNumClassesRounded;\n \n+  // A packed array of counters. Each counter occupies 2^n bits, enough to store\n+  // counter's max_value. Ctor will try to allocate the required buffer via\n+  // mapper->MapPackedCounterArrayBuffer and the caller is expected to check\n+  // whether the initialization was successful by checking IsAllocated() result.\n+  // For the performance sake, none of the accessors check the validity of the\n+  // arguments, it is assumed that index is always in [0, n) range and the value\n+  // is not incremented past max_value.\n+  template<class MemoryMapperT>\n+  class PackedCounterArray {\n+   public:\n+    PackedCounterArray(u64 num_counters, u64 max_value, MemoryMapperT *mapper)\n+        : n(num_counters), memory_mapper(mapper) {\n+      CHECK_GT(num_counters, 0);\n+      CHECK_GT(max_value, 0);\n+      constexpr u64 kMaxCounterBits = sizeof(*buffer) * 8ULL;\n+      // Rounding counter storage size up to the power of two allows for using\n+      // bit shifts calculating particular counter's index and offset.\n+      uptr counter_size_bits =\n+          RoundUpToPowerOfTwo(MostSignificantSetBitIndex(max_value) + 1);\n+      CHECK_LE(counter_size_bits, kMaxCounterBits);\n+      counter_size_bits_log = Log2(counter_size_bits);\n+      counter_mask = ~0ULL >> (kMaxCounterBits - counter_size_bits);\n+\n+      uptr packing_ratio = kMaxCounterBits >> counter_size_bits_log;\n+      CHECK_GT(packing_ratio, 0);\n+      packing_ratio_log = Log2(packing_ratio);\n+      bit_offset_mask = packing_ratio - 1;\n+\n+      buffer_size =\n+          (RoundUpTo(n, 1ULL << packing_ratio_log) >> packing_ratio_log) *\n+          sizeof(*buffer);\n+      buffer = reinterpret_cast<u64*>(\n+          memory_mapper->MapPackedCounterArrayBuffer(buffer_size));\n+    }\n+    ~PackedCounterArray() {\n+      if (buffer) {\n+        memory_mapper->UnmapPackedCounterArrayBuffer(\n+            reinterpret_cast<uptr>(buffer), buffer_size);\n+      }\n+    }\n+\n+    bool IsAllocated() const {\n+      return !!buffer;\n+    }\n+\n+    u64 GetCount() const {\n+      return n;\n+    }\n+\n+    uptr Get(uptr i) const {\n+      DCHECK_LT(i, n);\n+      uptr index = i >> packing_ratio_log;\n+      uptr bit_offset = (i & bit_offset_mask) << counter_size_bits_log;\n+      return (buffer[index] >> bit_offset) & counter_mask;\n+    }\n+\n+    void Inc(uptr i) const {\n+      DCHECK_LT(Get(i), counter_mask);\n+      uptr index = i >> packing_ratio_log;\n+      uptr bit_offset = (i & bit_offset_mask) << counter_size_bits_log;\n+      buffer[index] += 1ULL << bit_offset;\n+    }\n+\n+    void IncRange(uptr from, uptr to) const {\n+      DCHECK_LE(from, to);\n+      for (uptr i = from; i <= to; i++)\n+        Inc(i);\n+    }\n+\n+   private:\n+    const u64 n;\n+    u64 counter_size_bits_log;\n+    u64 counter_mask;\n+    u64 packing_ratio_log;\n+    u64 bit_offset_mask;\n+\n+    MemoryMapperT* const memory_mapper;\n+    u64 buffer_size;\n+    u64* buffer;\n+  };\n+\n+  template<class MemoryMapperT>\n+  class FreePagesRangeTracker {\n+   public:\n+    explicit FreePagesRangeTracker(MemoryMapperT* mapper)\n+        : memory_mapper(mapper),\n+          page_size_scaled_log(Log2(GetPageSizeCached() >> kCompactPtrScale)),\n+          in_the_range(false), current_page(0), current_range_start_page(0) {}\n+\n+    void NextPage(bool freed) {\n+      if (freed) {\n+        if (!in_the_range) {\n+          current_range_start_page = current_page;\n+          in_the_range = true;\n+        }\n+      } else {\n+        CloseOpenedRange();\n+      }\n+      current_page++;\n+    }\n+\n+    void Done() {\n+      CloseOpenedRange();\n+    }\n+\n+   private:\n+    void CloseOpenedRange() {\n+      if (in_the_range) {\n+        memory_mapper->ReleasePageRangeToOS(\n+            current_range_start_page << page_size_scaled_log,\n+            current_page << page_size_scaled_log);\n+        in_the_range = false;\n+      }\n+    }\n+\n+    MemoryMapperT* const memory_mapper;\n+    const uptr page_size_scaled_log;\n+    bool in_the_range;\n+    uptr current_page;\n+    uptr current_range_start_page;\n+  };\n+\n+  // Iterates over the free_array to identify memory pages containing freed\n+  // chunks only and returns these pages back to OS.\n+  // allocated_pages_count is the total number of pages allocated for the\n+  // current bucket.\n+  template<class MemoryMapperT>\n+  static void ReleaseFreeMemoryToOS(CompactPtrT *free_array,\n+                                    uptr free_array_count, uptr chunk_size,\n+                                    uptr allocated_pages_count,\n+                                    MemoryMapperT *memory_mapper) {\n+    const uptr page_size = GetPageSizeCached();\n+\n+    // Figure out the number of chunks per page and whether we can take a fast\n+    // path (the number of chunks per page is the same for all pages).\n+    uptr full_pages_chunk_count_max;\n+    bool same_chunk_count_per_page;\n+    if (chunk_size <= page_size && page_size % chunk_size == 0) {\n+      // Same number of chunks per page, no cross overs.\n+      full_pages_chunk_count_max = page_size / chunk_size;\n+      same_chunk_count_per_page = true;\n+    } else if (chunk_size <= page_size && page_size % chunk_size != 0 &&\n+        chunk_size % (page_size % chunk_size) == 0) {\n+      // Some chunks are crossing page boundaries, which means that the page\n+      // contains one or two partial chunks, but all pages contain the same\n+      // number of chunks.\n+      full_pages_chunk_count_max = page_size / chunk_size + 1;\n+      same_chunk_count_per_page = true;\n+    } else if (chunk_size <= page_size) {\n+      // Some chunks are crossing page boundaries, which means that the page\n+      // contains one or two partial chunks.\n+      full_pages_chunk_count_max = page_size / chunk_size + 2;\n+      same_chunk_count_per_page = false;\n+    } else if (chunk_size > page_size && chunk_size % page_size == 0) {\n+      // One chunk covers multiple pages, no cross overs.\n+      full_pages_chunk_count_max = 1;\n+      same_chunk_count_per_page = true;\n+    } else if (chunk_size > page_size) {\n+      // One chunk covers multiple pages, Some chunks are crossing page\n+      // boundaries. Some pages contain one chunk, some contain two.\n+      full_pages_chunk_count_max = 2;\n+      same_chunk_count_per_page = false;\n+    } else {\n+      UNREACHABLE(\"All chunk_size/page_size ratios must be handled.\");\n+    }\n+\n+    PackedCounterArray<MemoryMapperT> counters(allocated_pages_count,\n+                                               full_pages_chunk_count_max,\n+                                               memory_mapper);\n+    if (!counters.IsAllocated())\n+      return;\n+\n+    const uptr chunk_size_scaled = chunk_size >> kCompactPtrScale;\n+    const uptr page_size_scaled = page_size >> kCompactPtrScale;\n+    const uptr page_size_scaled_log = Log2(page_size_scaled);\n+\n+    // Iterate over free chunks and count how many free chunks affect each\n+    // allocated page.\n+    if (chunk_size <= page_size && page_size % chunk_size == 0) {\n+      // Each chunk affects one page only.\n+      for (uptr i = 0; i < free_array_count; i++)\n+        counters.Inc(free_array[i] >> page_size_scaled_log);\n+    } else {\n+      // In all other cases chunks might affect more than one page.\n+      for (uptr i = 0; i < free_array_count; i++) {\n+        counters.IncRange(\n+            free_array[i] >> page_size_scaled_log,\n+            (free_array[i] + chunk_size_scaled - 1) >> page_size_scaled_log);\n+      }\n+    }\n+\n+    // Iterate over pages detecting ranges of pages with chunk counters equal\n+    // to the expected number of chunks for the particular page.\n+    FreePagesRangeTracker<MemoryMapperT> range_tracker(memory_mapper);\n+    if (same_chunk_count_per_page) {\n+      // Fast path, every page has the same number of chunks affecting it.\n+      for (uptr i = 0; i < counters.GetCount(); i++)\n+        range_tracker.NextPage(counters.Get(i) == full_pages_chunk_count_max);\n+    } else {\n+      // Show path, go through the pages keeping count how many chunks affect\n+      // each page.\n+      const uptr pn =\n+          chunk_size < page_size ? page_size_scaled / chunk_size_scaled : 1;\n+      const uptr pnc = pn * chunk_size_scaled;\n+      // The idea is to increment the current page pointer by the first chunk\n+      // size, middle portion size (the portion of the page covered by chunks\n+      // except the first and the last one) and then the last chunk size, adding\n+      // up the number of chunks on the current page and checking on every step\n+      // whether the page boundary was crossed.\n+      uptr prev_page_boundary = 0;\n+      uptr current_boundary = 0;\n+      for (uptr i = 0; i < counters.GetCount(); i++) {\n+        uptr page_boundary = prev_page_boundary + page_size_scaled;\n+        uptr chunks_per_page = pn;\n+        if (current_boundary < page_boundary) {\n+          if (current_boundary > prev_page_boundary)\n+            chunks_per_page++;\n+          current_boundary += pnc;\n+          if (current_boundary < page_boundary) {\n+            chunks_per_page++;\n+            current_boundary += chunk_size_scaled;\n+          }\n+        }\n+        prev_page_boundary = page_boundary;\n+\n+        range_tracker.NextPage(counters.Get(i) == chunks_per_page);\n+      }\n+    }\n+    range_tracker.Done();\n+  }\n+\n  private:\n+  friend class MemoryMapper;\n+\n   static const uptr kRegionSize = kSpaceSize / kNumClassesRounded;\n   // FreeArray is the array of free-d chunks (stored as 4-byte offsets).\n   // In the worst case it may reguire kRegionSize/SizeClassMap::kMinSize\n@@ -315,12 +552,19 @@ class SizeClassAllocator64 {\n   static const uptr kMetaMapSize = 1 << 16;\n   // Call mmap for free array memory with at least this size.\n   static const uptr kFreeArrayMapSize = 1 << 16;\n-  // Granularity of ReleaseToOs (aka madvise).\n-  static const uptr kReleaseToOsGranularity = 1 << 12;\n+\n+  atomic_sint32_t release_to_os_interval_ms_;\n+\n+  struct Stats {\n+    uptr n_allocated;\n+    uptr n_freed;\n+  };\n \n   struct ReleaseToOsInfo {\n     uptr n_freed_at_last_release;\n     uptr num_releases;\n+    u64 last_release_at_ns;\n+    u64 last_released_bytes;\n   };\n \n   struct RegionInfo {\n@@ -331,8 +575,9 @@ class SizeClassAllocator64 {\n     uptr allocated_meta;  // Bytes allocated for metadata.\n     uptr mapped_user;  // Bytes mapped for user memory.\n     uptr mapped_meta;  // Bytes mapped for metadata.\n-    u32 rand_state; // Seed for random shuffle, used if kRandomShuffleChunks.\n-    uptr n_allocated, n_freed;  // Just stats.\n+    u32 rand_state;  // Seed for random shuffle, used if kRandomShuffleChunks.\n+    bool exhausted;  // Whether region is out of space for new chunks.\n+    Stats stats;\n     ReleaseToOsInfo rtoi;\n   };\n   COMPILER_CHECK(sizeof(RegionInfo) >= kCacheLineSize);\n@@ -349,18 +594,18 @@ class SizeClassAllocator64 {\n       Swap(a[i], a[RandN(rand_state, i + 1)]);\n   }\n \n-  RegionInfo *GetRegionInfo(uptr class_id) {\n+  RegionInfo *GetRegionInfo(uptr class_id) const {\n     CHECK_LT(class_id, kNumClasses);\n     RegionInfo *regions =\n         reinterpret_cast<RegionInfo *>(SpaceBeg() + kSpaceSize);\n     return &regions[class_id];\n   }\n \n-  uptr GetMetadataEnd(uptr region_beg) {\n+  uptr GetMetadataEnd(uptr region_beg) const {\n     return region_beg + kRegionSize - kFreeArraySize;\n   }\n \n-  uptr GetChunkIdx(uptr chunk, uptr size) {\n+  uptr GetChunkIdx(uptr chunk, uptr size) const {\n     if (!kUsingConstantSpaceBeg)\n       chunk -= SpaceBeg();\n \n@@ -372,132 +617,205 @@ class SizeClassAllocator64 {\n     return (u32)offset / (u32)size;\n   }\n \n-  CompactPtrT *GetFreeArray(uptr region_beg) {\n-    return reinterpret_cast<CompactPtrT *>(region_beg + kRegionSize -\n-                                           kFreeArraySize);\n+  CompactPtrT *GetFreeArray(uptr region_beg) const {\n+    return reinterpret_cast<CompactPtrT *>(GetMetadataEnd(region_beg));\n   }\n \n-  void EnsureFreeArraySpace(RegionInfo *region, uptr region_beg,\n+  bool MapWithCallback(uptr beg, uptr size) {\n+    uptr mapped = reinterpret_cast<uptr>(MmapFixedOrDieOnFatalError(beg, size));\n+    if (UNLIKELY(!mapped))\n+      return false;\n+    CHECK_EQ(beg, mapped);\n+    MapUnmapCallback().OnMap(beg, size);\n+    return true;\n+  }\n+\n+  void MapWithCallbackOrDie(uptr beg, uptr size) {\n+    CHECK_EQ(beg, reinterpret_cast<uptr>(MmapFixedOrDie(beg, size)));\n+    MapUnmapCallback().OnMap(beg, size);\n+  }\n+\n+  void UnmapWithCallbackOrDie(uptr beg, uptr size) {\n+    MapUnmapCallback().OnUnmap(beg, size);\n+    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n+  }\n+\n+  bool EnsureFreeArraySpace(RegionInfo *region, uptr region_beg,\n                             uptr num_freed_chunks) {\n     uptr needed_space = num_freed_chunks * sizeof(CompactPtrT);\n     if (region->mapped_free_array < needed_space) {\n-      CHECK_LE(needed_space, kFreeArraySize);\n       uptr new_mapped_free_array = RoundUpTo(needed_space, kFreeArrayMapSize);\n+      CHECK_LE(new_mapped_free_array, kFreeArraySize);\n       uptr current_map_end = reinterpret_cast<uptr>(GetFreeArray(region_beg)) +\n                              region->mapped_free_array;\n       uptr new_map_size = new_mapped_free_array - region->mapped_free_array;\n-      MapWithCallback(current_map_end, new_map_size);\n+      if (UNLIKELY(!MapWithCallback(current_map_end, new_map_size)))\n+        return false;\n       region->mapped_free_array = new_mapped_free_array;\n     }\n+    return true;\n   }\n \n-\n-  NOINLINE void PopulateFreeArray(AllocatorStats *stat, uptr class_id,\n+  NOINLINE bool PopulateFreeArray(AllocatorStats *stat, uptr class_id,\n                                   RegionInfo *region, uptr requested_count) {\n     // region->mutex is held.\n-    uptr size = ClassIdToSize(class_id);\n-    uptr beg_idx = region->allocated_user;\n-    uptr end_idx = beg_idx + requested_count * size;\n-    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n-    if (end_idx > region->mapped_user) {\n+    const uptr size = ClassIdToSize(class_id);\n+    const uptr new_space_beg = region->allocated_user;\n+    const uptr new_space_end = new_space_beg + requested_count * size;\n+    const uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+\n+    // Map more space for chunks, if necessary.\n+    if (new_space_end > region->mapped_user) {\n       if (!kUsingConstantSpaceBeg && region->mapped_user == 0)\n         region->rand_state = static_cast<u32>(region_beg >> 12);  // From ASLR.\n       // Do the mmap for the user memory.\n       uptr map_size = kUserMapSize;\n-      while (end_idx > region->mapped_user + map_size)\n+      while (new_space_end > region->mapped_user + map_size)\n         map_size += kUserMapSize;\n-      CHECK_GE(region->mapped_user + map_size, end_idx);\n-      MapWithCallback(region_beg + region->mapped_user, map_size);\n+      CHECK_GE(region->mapped_user + map_size, new_space_end);\n+      if (UNLIKELY(!MapWithCallback(region_beg + region->mapped_user,\n+                                    map_size)))\n+        return false;\n       stat->Add(AllocatorStatMapped, map_size);\n       region->mapped_user += map_size;\n     }\n-    CompactPtrT *free_array = GetFreeArray(region_beg);\n-    uptr total_count = (region->mapped_user - beg_idx) / size;\n-    uptr num_freed_chunks = region->num_freed_chunks;\n-    EnsureFreeArraySpace(region, region_beg, num_freed_chunks + total_count);\n-    for (uptr i = 0; i < total_count; i++) {\n-      uptr chunk = beg_idx + i * size;\n-      free_array[num_freed_chunks + total_count - 1 - i] =\n-          PointerToCompactPtr(0, chunk);\n+    const uptr new_chunks_count = (region->mapped_user - new_space_beg) / size;\n+\n+    // Calculate the required space for metadata.\n+    const uptr requested_allocated_meta =\n+        region->allocated_meta + new_chunks_count * kMetadataSize;\n+    uptr requested_mapped_meta = region->mapped_meta;\n+    while (requested_allocated_meta > requested_mapped_meta)\n+      requested_mapped_meta += kMetaMapSize;\n+    // Check whether this size class is exhausted.\n+    if (region->mapped_user + requested_mapped_meta >\n+        kRegionSize - kFreeArraySize) {\n+      if (!region->exhausted) {\n+        region->exhausted = true;\n+        Printf(\"%s: Out of memory. \", SanitizerToolName);\n+        Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n+               kRegionSize >> 20, size);\n+      }\n+      return false;\n+    }\n+    // Map more space for metadata, if necessary.\n+    if (requested_mapped_meta > region->mapped_meta) {\n+      if (UNLIKELY(!MapWithCallback(\n+              GetMetadataEnd(region_beg) - requested_mapped_meta,\n+              requested_mapped_meta - region->mapped_meta)))\n+        return false;\n+      region->mapped_meta = requested_mapped_meta;\n     }\n+\n+    // If necessary, allocate more space for the free array and populate it with\n+    // newly allocated chunks.\n+    const uptr total_freed_chunks = region->num_freed_chunks + new_chunks_count;\n+    if (UNLIKELY(!EnsureFreeArraySpace(region, region_beg, total_freed_chunks)))\n+      return false;\n+    CompactPtrT *free_array = GetFreeArray(region_beg);\n+    for (uptr i = 0, chunk = new_space_beg; i < new_chunks_count;\n+         i++, chunk += size)\n+      free_array[total_freed_chunks - 1 - i] = PointerToCompactPtr(0, chunk);\n     if (kRandomShuffleChunks)\n-      RandomShuffle(&free_array[num_freed_chunks], total_count,\n+      RandomShuffle(&free_array[region->num_freed_chunks], new_chunks_count,\n                     &region->rand_state);\n-    region->num_freed_chunks += total_count;\n-    region->allocated_user += total_count * size;\n-    CHECK_LE(region->allocated_user, region->mapped_user);\n \n-    region->allocated_meta += total_count * kMetadataSize;\n-    if (region->allocated_meta > region->mapped_meta) {\n-      uptr map_size = kMetaMapSize;\n-      while (region->allocated_meta > region->mapped_meta + map_size)\n-        map_size += kMetaMapSize;\n-      // Do the mmap for the metadata.\n-      CHECK_GE(region->mapped_meta + map_size, region->allocated_meta);\n-      MapWithCallback(GetMetadataEnd(region_beg) -\n-                      region->mapped_meta - map_size, map_size);\n-      region->mapped_meta += map_size;\n-    }\n+    // All necessary memory is mapped and now it is safe to advance all\n+    // 'allocated_*' counters.\n+    region->num_freed_chunks += new_chunks_count;\n+    region->allocated_user += new_chunks_count * size;\n+    CHECK_LE(region->allocated_user, region->mapped_user);\n+    region->allocated_meta = requested_allocated_meta;\n     CHECK_LE(region->allocated_meta, region->mapped_meta);\n-    if (region->mapped_user + region->mapped_meta >\n-        kRegionSize - kFreeArraySize) {\n-      Printf(\"%s: Out of memory. Dying. \", SanitizerToolName);\n-      Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n-          kRegionSize / 1024 / 1024, size);\n-      Die();\n-    }\n-  }\n+    region->exhausted = false;\n+\n+    // TODO(alekseyshl): Consider bumping last_release_at_ns here to prevent\n+    // MaybeReleaseToOS from releasing just allocated pages or protect these\n+    // not yet used chunks some other way.\n \n-  bool MaybeReleaseChunkRange(uptr region_beg, uptr chunk_size,\n-                              CompactPtrT first, CompactPtrT last) {\n-    uptr beg_ptr = CompactPtrToPointer(region_beg, first);\n-    uptr end_ptr = CompactPtrToPointer(region_beg, last) + chunk_size;\n-    CHECK_GE(end_ptr - beg_ptr, kReleaseToOsGranularity);\n-    beg_ptr = RoundUpTo(beg_ptr, kReleaseToOsGranularity);\n-    end_ptr = RoundDownTo(end_ptr, kReleaseToOsGranularity);\n-    if (end_ptr == beg_ptr) return false;\n-    ReleaseMemoryToOS(beg_ptr, end_ptr - beg_ptr);\n     return true;\n   }\n \n-  // Releases some RAM back to OS.\n-  // Algorithm:\n-  // * Lock the region.\n-  // * Sort the chunks.\n-  // * Find ranges fully covered by free-d chunks\n-  // * Release them to OS with madvise.\n-  //\n-  // TODO(kcc): make sure we don't do it too frequently.\n-  void ReleaseToOS(uptr class_id) {\n+  class MemoryMapper {\n+   public:\n+    MemoryMapper(const ThisT& base_allocator, uptr class_id)\n+        : allocator(base_allocator),\n+          region_base(base_allocator.GetRegionBeginBySizeClass(class_id)),\n+          released_ranges_count(0),\n+          released_bytes(0) {\n+    }\n+\n+    uptr GetReleasedRangesCount() const {\n+      return released_ranges_count;\n+    }\n+\n+    uptr GetReleasedBytes() const {\n+      return released_bytes;\n+    }\n+\n+    uptr MapPackedCounterArrayBuffer(uptr buffer_size) {\n+      // TODO(alekseyshl): The idea to explore is to check if we have enough\n+      // space between num_freed_chunks*sizeof(CompactPtrT) and\n+      // mapped_free_array to fit buffer_size bytes and use that space instead\n+      // of mapping a temporary one.\n+      return reinterpret_cast<uptr>(\n+          MmapOrDieOnFatalError(buffer_size, \"ReleaseToOSPageCounters\"));\n+    }\n+\n+    void UnmapPackedCounterArrayBuffer(uptr buffer, uptr buffer_size) {\n+      UnmapOrDie(reinterpret_cast<void *>(buffer), buffer_size);\n+    }\n+\n+    // Releases [from, to) range of pages back to OS.\n+    void ReleasePageRangeToOS(CompactPtrT from, CompactPtrT to) {\n+      const uptr from_page = allocator.CompactPtrToPointer(region_base, from);\n+      const uptr to_page = allocator.CompactPtrToPointer(region_base, to);\n+      ReleaseMemoryPagesToOS(from_page, to_page);\n+      released_ranges_count++;\n+      released_bytes += to_page - from_page;\n+    }\n+\n+   private:\n+    const ThisT& allocator;\n+    const uptr region_base;\n+    uptr released_ranges_count;\n+    uptr released_bytes;\n+  };\n+\n+  // Attempts to release RAM occupied by freed chunks back to OS. The region is\n+  // expected to be locked.\n+  void MaybeReleaseToOS(uptr class_id) {\n     RegionInfo *region = GetRegionInfo(class_id);\n-    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n-    CompactPtrT *free_array = GetFreeArray(region_beg);\n-    uptr chunk_size = ClassIdToSize(class_id);\n-    uptr scaled_chunk_size = chunk_size >> kCompactPtrScale;\n-    const uptr kScaledGranularity = kReleaseToOsGranularity >> kCompactPtrScale;\n-    BlockingMutexLock l(&region->mutex);\n+    const uptr chunk_size = ClassIdToSize(class_id);\n+    const uptr page_size = GetPageSizeCached();\n+\n     uptr n = region->num_freed_chunks;\n-    if (n * chunk_size < kReleaseToOsGranularity)\n-      return;   // No chance to release anything.\n-    if ((region->rtoi.n_freed_at_last_release - region->n_freed) * chunk_size <\n-        kReleaseToOsGranularity)\n+    if (n * chunk_size < page_size)\n+      return;  // No chance to release anything.\n+    if ((region->stats.n_freed -\n+         region->rtoi.n_freed_at_last_release) * chunk_size < page_size) {\n       return;  // Nothing new to release.\n-    SortArray(free_array, n);\n-    uptr beg = free_array[0];\n-    uptr prev = free_array[0];\n-    for (uptr i = 1; i < n; i++) {\n-      uptr chunk = free_array[i];\n-      CHECK_GT(chunk, prev);\n-      if (chunk - prev != scaled_chunk_size) {\n-        CHECK_GT(chunk - prev, scaled_chunk_size);\n-        if (prev + scaled_chunk_size - beg >= kScaledGranularity) {\n-          MaybeReleaseChunkRange(region_beg, chunk_size, beg, prev);\n-          region->rtoi.n_freed_at_last_release = region->n_freed;\n-          region->rtoi.num_releases++;\n-        }\n-        beg = chunk;\n-      }\n-      prev = chunk;\n     }\n+\n+    s32 interval_ms = ReleaseToOSIntervalMs();\n+    if (interval_ms < 0)\n+      return;\n+\n+    if (region->rtoi.last_release_at_ns + interval_ms * 1000000ULL > NanoTime())\n+      return;  // Memory was returned recently.\n+\n+    MemoryMapper memory_mapper(*this, class_id);\n+\n+    ReleaseFreeMemoryToOS<MemoryMapper>(\n+        GetFreeArray(GetRegionBeginBySizeClass(class_id)), n, chunk_size,\n+        RoundUpTo(region->allocated_user, page_size) / page_size,\n+        &memory_mapper);\n+\n+    if (memory_mapper.GetReleasedRangesCount() > 0) {\n+      region->rtoi.n_freed_at_last_release = region->stats.n_freed;\n+      region->rtoi.num_releases += memory_mapper.GetReleasedRangesCount();\n+      region->rtoi.last_released_bytes = memory_mapper.GetReleasedBytes();\n+    }\n+    region->rtoi.last_release_at_ns = NanoTime();\n   }\n };"}, {"sha": "9a9b83a884f0a616bb26bc37523f50fe647790bf", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -15,17 +15,19 @@\n // This class can (de)allocate only large chunks of memory using mmap/unmap.\n // The main purpose of this allocator is to cover large and rare allocation\n // sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).\n-template <class MapUnmapCallback = NoOpMapUnmapCallback>\n+template <class MapUnmapCallback = NoOpMapUnmapCallback,\n+          class FailureHandlerT = ReturnNullOrDieOnFailure>\n class LargeMmapAllocator {\n  public:\n-  void InitLinkerInitialized(bool may_return_null) {\n+  typedef FailureHandlerT FailureHandler;\n+\n+  void InitLinkerInitialized() {\n     page_size_ = GetPageSizeCached();\n-    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n   }\n \n-  void Init(bool may_return_null) {\n+  void Init() {\n     internal_memset(this, 0, sizeof(*this));\n-    InitLinkerInitialized(may_return_null);\n+    InitLinkerInitialized();\n   }\n \n   void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {\n@@ -34,9 +36,12 @@ class LargeMmapAllocator {\n     if (alignment > page_size_)\n       map_size += alignment;\n     // Overflow.\n-    if (map_size < size) return ReturnNullOrDieOnBadRequest();\n+    if (map_size < size)\n+      return FailureHandler::OnBadRequest();\n     uptr map_beg = reinterpret_cast<uptr>(\n-        MmapOrDie(map_size, \"LargeMmapAllocator\"));\n+        MmapOrDieOnFatalError(map_size, \"LargeMmapAllocator\"));\n+    if (!map_beg)\n+      return FailureHandler::OnOOM();\n     CHECK(IsAligned(map_beg, page_size_));\n     MapUnmapCallback().OnMap(map_beg, map_size);\n     uptr map_end = map_beg + map_size;\n@@ -70,24 +75,6 @@ class LargeMmapAllocator {\n     return reinterpret_cast<void*>(res);\n   }\n \n-  bool MayReturnNull() const {\n-    return atomic_load(&may_return_null_, memory_order_acquire);\n-  }\n-\n-  void *ReturnNullOrDieOnBadRequest() {\n-    if (MayReturnNull()) return nullptr;\n-    ReportAllocatorCannotReturnNull(false);\n-  }\n-\n-  void *ReturnNullOrDieOnOOM() {\n-    if (MayReturnNull()) return nullptr;\n-    ReportAllocatorCannotReturnNull(true);\n-  }\n-\n-  void SetMayReturnNull(bool may_return_null) {\n-    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n-  }\n-\n   void Deallocate(AllocatorStats *stat, void *p) {\n     Header *h = GetHeader(p);\n     {\n@@ -159,23 +146,25 @@ class LargeMmapAllocator {\n     return GetUser(h);\n   }\n \n+  void EnsureSortedChunks() {\n+    if (chunks_sorted_) return;\n+    SortArray(reinterpret_cast<uptr*>(chunks_), n_chunks_);\n+    for (uptr i = 0; i < n_chunks_; i++)\n+      chunks_[i]->chunk_idx = i;\n+    chunks_sorted_ = true;\n+  }\n+\n   // This function does the same as GetBlockBegin, but is much faster.\n   // Must be called with the allocator locked.\n   void *GetBlockBeginFastLocked(void *ptr) {\n     mutex_.CheckLocked();\n     uptr p = reinterpret_cast<uptr>(ptr);\n     uptr n = n_chunks_;\n     if (!n) return nullptr;\n-    if (!chunks_sorted_) {\n-      // Do one-time sort. chunks_sorted_ is reset in Allocate/Deallocate.\n-      SortArray(reinterpret_cast<uptr*>(chunks_), n);\n-      for (uptr i = 0; i < n; i++)\n-        chunks_[i]->chunk_idx = i;\n-      chunks_sorted_ = true;\n-      min_mmap_ = reinterpret_cast<uptr>(chunks_[0]);\n-      max_mmap_ = reinterpret_cast<uptr>(chunks_[n - 1]) +\n-          chunks_[n - 1]->map_size;\n-    }\n+    EnsureSortedChunks();\n+    auto min_mmap_ = reinterpret_cast<uptr>(chunks_[0]);\n+    auto max_mmap_ =\n+        reinterpret_cast<uptr>(chunks_[n - 1]) + chunks_[n - 1]->map_size;\n     if (p < min_mmap_ || p >= max_mmap_)\n       return nullptr;\n     uptr beg = 0, end = n - 1;\n@@ -228,8 +217,14 @@ class LargeMmapAllocator {\n   // Iterate over all existing chunks.\n   // The allocator must be locked when calling this function.\n   void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n-    for (uptr i = 0; i < n_chunks_; i++)\n+    EnsureSortedChunks();  // Avoid doing the sort while iterating.\n+    for (uptr i = 0; i < n_chunks_; i++) {\n+      auto t = chunks_[i];\n       callback(reinterpret_cast<uptr>(GetUser(chunks_[i])), arg);\n+      // Consistency check: verify that the array did not change.\n+      CHECK_EQ(chunks_[i], t);\n+      CHECK_EQ(chunks_[i]->chunk_idx, i);\n+    }\n   }\n \n  private:\n@@ -261,11 +256,9 @@ class LargeMmapAllocator {\n   uptr page_size_;\n   Header *chunks_[kMaxNumChunks];\n   uptr n_chunks_;\n-  uptr min_mmap_, max_mmap_;\n   bool chunks_sorted_;\n   struct Stats {\n     uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n   } stats;\n-  atomic_uint8_t may_return_null_;\n   SpinMutex mutex_;\n };"}, {"sha": "19af55138d15e395215491b8c1bcac33d6aae508", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_size_class_map.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -132,15 +132,21 @@ class SizeClassMap {\n \n   static const uptr kMaxSize = 1UL << kMaxSizeLog;\n   static const uptr kNumClasses =\n-      kMidClass + ((kMaxSizeLog - kMidSizeLog) << S) + 1;\n+      kMidClass + ((kMaxSizeLog - kMidSizeLog) << S) + 1 + 1;\n   static const uptr kLargestClassID = kNumClasses - 2;\n+  static const uptr kBatchClassID = kNumClasses - 1;\n   COMPILER_CHECK(kNumClasses >= 16 && kNumClasses <= 256);\n   static const uptr kNumClassesRounded =\n       kNumClasses <= 32  ? 32 :\n       kNumClasses <= 64  ? 64 :\n       kNumClasses <= 128 ? 128 : 256;\n \n   static uptr Size(uptr class_id) {\n+    // Estimate the result for kBatchClassID because this class does not know\n+    // the exact size of TransferBatch. It's OK since we are using the actual\n+    // sizeof(TransferBatch) where it matters.\n+    if (UNLIKELY(class_id == kBatchClassID))\n+      return kMaxNumCachedHint * sizeof(uptr);\n     if (class_id <= kMidClass)\n       return kMinSize * class_id;\n     class_id -= kMidClass;\n@@ -149,9 +155,10 @@ class SizeClassMap {\n   }\n \n   static uptr ClassID(uptr size) {\n+    if (UNLIKELY(size > kMaxSize))\n+      return 0;\n     if (size <= kMidSize)\n       return (size + kMinSize - 1) >> kMinSizeLog;\n-    if (size > kMaxSize) return 0;\n     uptr l = MostSignificantSetBitIndex(size);\n     uptr hbits = (size >> (l - S)) & M;\n     uptr lbits = size & ((1 << (l - S)) - 1);\n@@ -160,7 +167,13 @@ class SizeClassMap {\n   }\n \n   static uptr MaxCachedHint(uptr class_id) {\n-    if (class_id == 0) return 0;\n+    // Estimate the result for kBatchClassID because this class does not know\n+    // the exact size of TransferBatch. We need to cache fewer batches than user\n+    // chunks, so this number can be small.\n+    if (UNLIKELY(class_id == kBatchClassID))\n+      return 16;\n+    if (UNLIKELY(class_id == 0))\n+      return 0;\n     uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);\n     return Max<uptr>(1, Min(kMaxNumCachedHint, n));\n   }\n@@ -176,6 +189,8 @@ class SizeClassMap {\n       uptr p = prev_s ? (d * 100 / prev_s) : 0;\n       uptr l = s ? MostSignificantSetBitIndex(s) : 0;\n       uptr cached = MaxCachedHint(i) * s;\n+      if (i == kBatchClassID)\n+        d = p = l = 0;\n       Printf(\"c%02zd => s: %zd diff: +%zd %02zd%% l %zd \"\n              \"cached: %zd %zd; id %zd\\n\",\n              i, Size(i), d, p, l, MaxCachedHint(i), cached, ClassID(s));\n@@ -190,12 +205,13 @@ class SizeClassMap {\n       // Printf(\"Validate: c%zd\\n\", c);\n       uptr s = Size(c);\n       CHECK_NE(s, 0U);\n+      if (c == kBatchClassID)\n+        continue;\n       CHECK_EQ(ClassID(s), c);\n-      if (c != kNumClasses - 1)\n+      if (c < kLargestClassID)\n         CHECK_EQ(ClassID(s + 1), c + 1);\n       CHECK_EQ(ClassID(s - 1), c);\n-      if (c)\n-        CHECK_GT(Size(c), Size(c-1));\n+      CHECK_GT(Size(c), Size(c - 1));\n     }\n     CHECK_EQ(ClassID(kMaxSize + 1), 0);\n \n@@ -205,7 +221,7 @@ class SizeClassMap {\n       CHECK_LT(c, kNumClasses);\n       CHECK_GE(Size(c), s);\n       if (c > 0)\n-        CHECK_LT(Size(c-1), s);\n+        CHECK_LT(Size(c - 1), s);\n     }\n   }\n };"}, {"sha": "82de0c6d44605106a5d96f357996ac9509c90bf6", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -35,6 +35,11 @@ struct atomic_uint16_t {\n   volatile Type val_dont_use;\n };\n \n+struct atomic_sint32_t {\n+  typedef s32 Type;\n+  volatile Type val_dont_use;\n+};\n+\n struct atomic_uint32_t {\n   typedef u32 Type;\n   volatile Type val_dont_use;"}, {"sha": "dcdcd0ea4adc501868ae9077fe1d893a05024e90", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -69,16 +69,25 @@ INLINE typename T::Type atomic_exchange(volatile T *a,\n   return v;\n }\n \n-template<typename T>\n-INLINE bool atomic_compare_exchange_strong(volatile T *a,\n-                                           typename T::Type *cmp,\n+template <typename T>\n+INLINE bool atomic_compare_exchange_strong(volatile T *a, typename T::Type *cmp,\n                                            typename T::Type xchg,\n                                            memory_order mo) {\n   typedef typename T::Type Type;\n   Type cmpv = *cmp;\n-  Type prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n-  if (prev == cmpv)\n-    return true;\n+  Type prev;\n+#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n+  if (sizeof(*a) == 8) {\n+    Type volatile *val_ptr = const_cast<Type volatile *>(&a->val_dont_use);\n+    prev = __mips_sync_val_compare_and_swap<u64>(\n+        reinterpret_cast<u64 volatile *>(val_ptr), (u64)cmpv, (u64)xchg);\n+  } else {\n+    prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n+  }\n+#else\n+  prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n+#endif\n+  if (prev == cmpv) return true;\n   *cmp = prev;\n   return false;\n }"}, {"sha": "a0605bbbd82dd2bd64891d7506c28b268647d0a7", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_other.h", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -15,6 +15,56 @@\n \n namespace __sanitizer {\n \n+// MIPS32 does not support atomic > 4 bytes. To address this lack of\n+// functionality, the sanitizer library provides helper methods which use an\n+// internal spin lock mechanism to emulate atomic oprations when the size is\n+// 8 bytes.\n+#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n+static void __spin_lock(volatile int *lock) {\n+  while (__sync_lock_test_and_set(lock, 1))\n+    while (*lock) {\n+    }\n+}\n+\n+static void __spin_unlock(volatile int *lock) { __sync_lock_release(lock); }\n+\n+\n+// Make sure the lock is on its own cache line to prevent false sharing.\n+// Put it inside a struct that is aligned and padded to the typical MIPS\n+// cacheline which is 32 bytes.\n+static struct {\n+  int lock;\n+  char pad[32 - sizeof(int)];\n+} __attribute__((aligned(32))) lock = {0};\n+\n+template <class T>\n+T __mips_sync_fetch_and_add(volatile T *ptr, T val) {\n+  T ret;\n+\n+  __spin_lock(&lock.lock);\n+\n+  ret = *ptr;\n+  *ptr = ret + val;\n+\n+  __spin_unlock(&lock.lock);\n+\n+  return ret;\n+}\n+\n+template <class T>\n+T __mips_sync_val_compare_and_swap(volatile T *ptr, T oldval, T newval) {\n+  T ret;\n+  __spin_lock(&lock.lock);\n+\n+  ret = *ptr;\n+  if (ret == oldval) *ptr = newval;\n+\n+  __spin_unlock(&lock.lock);\n+\n+  return ret;\n+}\n+#endif\n+\n INLINE void proc_yield(int cnt) {\n   __asm__ __volatile__(\"\" ::: \"memory\");\n }\n@@ -51,8 +101,15 @@ INLINE typename T::Type atomic_load(\n     // 64-bit load on 32-bit platform.\n     // Gross, but simple and reliable.\n     // Assume that it is not in read-only memory.\n+#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n+    typename T::Type volatile *val_ptr =\n+        const_cast<typename T::Type volatile *>(&a->val_dont_use);\n+    v = __mips_sync_fetch_and_add<u64>(\n+        reinterpret_cast<u64 volatile *>(val_ptr), 0);\n+#else\n     v = __sync_fetch_and_add(\n         const_cast<typename T::Type volatile *>(&a->val_dont_use), 0);\n+#endif\n   }\n   return v;\n }\n@@ -82,7 +139,14 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n     typename T::Type cmp = a->val_dont_use;\n     typename T::Type cur;\n     for (;;) {\n+#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n+      typename T::Type volatile *val_ptr =\n+          const_cast<typename T::Type volatile *>(&a->val_dont_use);\n+      cur = __mips_sync_val_compare_and_swap<u64>(\n+          reinterpret_cast<u64 volatile *>(val_ptr), (u64)cmp, (u64)v);\n+#else\n       cur = __sync_val_compare_and_swap(&a->val_dont_use, cmp, v);\n+#endif\n       if (cmp == v)\n         break;\n       cmp = cur;"}, {"sha": "8d7e9fae64eb290c3a80c2a8a808e6402d512cfe", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 31, "deletions": 157, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -25,79 +25,15 @@ const char *SanitizerToolName = \"SanitizerTool\";\n atomic_uint32_t current_verbosity;\n uptr PageSizeCached;\n \n-StaticSpinMutex report_file_mu;\n-ReportFile report_file = {&report_file_mu, kStderrFd, \"\", \"\", 0};\n-\n-void RawWrite(const char *buffer) {\n-  report_file.Write(buffer, internal_strlen(buffer));\n-}\n-\n-void ReportFile::ReopenIfNecessary() {\n-  mu->CheckLocked();\n-  if (fd == kStdoutFd || fd == kStderrFd) return;\n-\n-  uptr pid = internal_getpid();\n-  // If in tracer, use the parent's file.\n-  if (pid == stoptheworld_tracer_pid)\n-    pid = stoptheworld_tracer_ppid;\n-  if (fd != kInvalidFd) {\n-    // If the report file is already opened by the current process,\n-    // do nothing. Otherwise the report file was opened by the parent\n-    // process, close it now.\n-    if (fd_pid == pid)\n-      return;\n-    else\n-      CloseFile(fd);\n-  }\n-\n-  const char *exe_name = GetProcessName();\n-  if (common_flags()->log_exe_name && exe_name) {\n-    internal_snprintf(full_path, kMaxPathLength, \"%s.%s.%zu\", path_prefix,\n-                      exe_name, pid);\n-  } else {\n-    internal_snprintf(full_path, kMaxPathLength, \"%s.%zu\", path_prefix, pid);\n-  }\n-  fd = OpenFile(full_path, WrOnly);\n-  if (fd == kInvalidFd) {\n-    const char *ErrorMsgPrefix = \"ERROR: Can't open file: \";\n-    WriteToFile(kStderrFd, ErrorMsgPrefix, internal_strlen(ErrorMsgPrefix));\n-    WriteToFile(kStderrFd, full_path, internal_strlen(full_path));\n-    Die();\n-  }\n-  fd_pid = pid;\n-}\n-\n-void ReportFile::SetReportPath(const char *path) {\n-  if (!path)\n-    return;\n-  uptr len = internal_strlen(path);\n-  if (len > sizeof(path_prefix) - 100) {\n-    Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n-           path[0], path[1], path[2], path[3],\n-           path[4], path[5], path[6], path[7]);\n-    Die();\n-  }\n-\n-  SpinMutexLock l(mu);\n-  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)\n-    CloseFile(fd);\n-  fd = kInvalidFd;\n-  if (internal_strcmp(path, \"stdout\") == 0) {\n-    fd = kStdoutFd;\n-  } else if (internal_strcmp(path, \"stderr\") == 0) {\n-    fd = kStderrFd;\n-  } else {\n-    internal_snprintf(path_prefix, kMaxPathLength, \"%s\", path);\n-  }\n-}\n-\n // PID of the tracer task in StopTheWorld. It shares the address space with the\n // main process, but has a different PID and thus requires special handling.\n uptr stoptheworld_tracer_pid = 0;\n // Cached pid of parent process - if the parent process dies, we want to keep\n // writing to the same log file.\n uptr stoptheworld_tracer_ppid = 0;\n \n+StaticSpinMutex CommonSanitizerReportMutex;\n+\n void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                       const char *mmap_type, error_t err,\n                                       bool raw_report) {\n@@ -118,42 +54,6 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n   UNREACHABLE(\"unable to mmap\");\n }\n \n-bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n-                      uptr *read_len, uptr max_len, error_t *errno_p) {\n-  uptr PageSize = GetPageSizeCached();\n-  uptr kMinFileLen = PageSize;\n-  *buff = nullptr;\n-  *buff_size = 0;\n-  *read_len = 0;\n-  // The files we usually open are not seekable, so try different buffer sizes.\n-  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n-    fd_t fd = OpenFile(file_name, RdOnly, errno_p);\n-    if (fd == kInvalidFd) return false;\n-    UnmapOrDie(*buff, *buff_size);\n-    *buff = (char*)MmapOrDie(size, __func__);\n-    *buff_size = size;\n-    *read_len = 0;\n-    // Read up to one page at a time.\n-    bool reached_eof = false;\n-    while (*read_len + PageSize <= size) {\n-      uptr just_read;\n-      if (!ReadFromFile(fd, *buff + *read_len, PageSize, &just_read, errno_p)) {\n-        UnmapOrDie(*buff, *buff_size);\n-        return false;\n-      }\n-      if (just_read == 0) {\n-        reached_eof = true;\n-        break;\n-      }\n-      *read_len += just_read;\n-    }\n-    CloseFile(fd);\n-    if (reached_eof)  // We've read the whole file.\n-      break;\n-  }\n-  return true;\n-}\n-\n typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);\n typedef bool U32ComparisonFunction(const u32 &a, const u32 &b);\n \n@@ -197,23 +97,24 @@ const char *StripModuleName(const char *module) {\n   return module;\n }\n \n-void ReportErrorSummary(const char *error_message) {\n+void ReportErrorSummary(const char *error_message, const char *alt_tool_name) {\n   if (!common_flags()->print_summary)\n     return;\n   InternalScopedString buff(kMaxSummaryLength);\n-  buff.append(\"SUMMARY: %s: %s\", SanitizerToolName, error_message);\n+  buff.append(\"SUMMARY: %s: %s\",\n+              alt_tool_name ? alt_tool_name : SanitizerToolName, error_message);\n   __sanitizer_report_error_summary(buff.data());\n }\n \n #if !SANITIZER_GO\n-void ReportErrorSummary(const char *error_type, const AddressInfo &info) {\n-  if (!common_flags()->print_summary)\n-    return;\n+void ReportErrorSummary(const char *error_type, const AddressInfo &info,\n+                        const char *alt_tool_name) {\n+  if (!common_flags()->print_summary) return;\n   InternalScopedString buff(kMaxSummaryLength);\n   buff.append(\"%s \", error_type);\n   RenderFrame(&buff, \"%L %F\", 0, info, common_flags()->symbolize_vs_style,\n               common_flags()->strip_path_prefix);\n-  ReportErrorSummary(buff.data());\n+  ReportErrorSummary(buff.data(), alt_tool_name);\n }\n #endif\n \n@@ -257,20 +158,38 @@ void LoadedModule::set(const char *module_name, uptr base_address) {\n   base_address_ = base_address;\n }\n \n+void LoadedModule::set(const char *module_name, uptr base_address,\n+                       ModuleArch arch, u8 uuid[kModuleUUIDSize],\n+                       bool instrumented) {\n+  set(module_name, base_address);\n+  arch_ = arch;\n+  internal_memcpy(uuid_, uuid, sizeof(uuid_));\n+  instrumented_ = instrumented;\n+}\n+\n void LoadedModule::clear() {\n   InternalFree(full_name_);\n+  base_address_ = 0;\n+  max_executable_address_ = 0;\n   full_name_ = nullptr;\n+  arch_ = kModuleArchUnknown;\n+  internal_memset(uuid_, 0, kModuleUUIDSize);\n+  instrumented_ = false;\n   while (!ranges_.empty()) {\n     AddressRange *r = ranges_.front();\n     ranges_.pop_front();\n     InternalFree(r);\n   }\n }\n \n-void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {\n+void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable,\n+                                   bool writable, const char *name) {\n   void *mem = InternalAlloc(sizeof(AddressRange));\n-  AddressRange *r = new(mem) AddressRange(beg, end, executable);\n+  AddressRange *r =\n+      new(mem) AddressRange(beg, end, executable, writable, name);\n   ranges_.push_back(r);\n+  if (executable && end > max_executable_address_)\n+    max_executable_address_ = end;\n }\n \n bool LoadedModule::containsAddress(uptr address) const {\n@@ -339,36 +258,6 @@ bool TemplateMatch(const char *templ, const char *str) {\n   return true;\n }\n \n-static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';\n-\n-char *FindPathToBinary(const char *name) {\n-  if (FileExists(name)) {\n-    return internal_strdup(name);\n-  }\n-\n-  const char *path = GetEnv(\"PATH\");\n-  if (!path)\n-    return nullptr;\n-  uptr name_len = internal_strlen(name);\n-  InternalScopedBuffer<char> buffer(kMaxPathLength);\n-  const char *beg = path;\n-  while (true) {\n-    const char *end = internal_strchrnul(beg, kPathSeparator);\n-    uptr prefix_len = end - beg;\n-    if (prefix_len + name_len + 2 <= kMaxPathLength) {\n-      internal_memcpy(buffer.data(), beg, prefix_len);\n-      buffer[prefix_len] = '/';\n-      internal_memcpy(&buffer[prefix_len + 1], name, name_len);\n-      buffer[prefix_len + 1 + name_len] = '\\0';\n-      if (FileExists(buffer.data()))\n-        return internal_strdup(buffer.data());\n-    }\n-    if (*end == '\\0') break;\n-    beg = end + 1;\n-  }\n-  return nullptr;\n-}\n-\n static char binary_name_cache_str[kMaxPathLength];\n static char process_name_cache_str[kMaxPathLength];\n \n@@ -462,16 +351,8 @@ static int InstallMallocFreeHooks(void (*malloc_hook)(const void *, uptr),\n using namespace __sanitizer;  // NOLINT\n \n extern \"C\" {\n-void __sanitizer_set_report_path(const char *path) {\n-  report_file.SetReportPath(path);\n-}\n-\n-void __sanitizer_set_report_fd(void *fd) {\n-  report_file.fd = (fd_t)reinterpret_cast<uptr>(fd);\n-  report_file.fd_pid = internal_getpid();\n-}\n-\n-void __sanitizer_report_error_summary(const char *error_summary) {\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_report_error_summary,\n+                             const char *error_summary) {\n   Printf(\"%s\\n\", error_summary);\n }\n \n@@ -486,11 +367,4 @@ int __sanitizer_install_malloc_and_free_hooks(void (*malloc_hook)(const void *,\n                                               void (*free_hook)(const void *)) {\n   return InstallMallocFreeHooks(malloc_hook, free_hook);\n }\n-\n-#if !SANITIZER_GO && !SANITIZER_SUPPORTS_WEAK_HOOKS\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_print_memory_profile(int top_percent) {\n-  (void)top_percent;\n-}\n-#endif\n } // extern \"C\""}, {"sha": "dd207d72e292d13fd5b129bde3ccc39bd62ca95f", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 204, "deletions": 128, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -27,8 +27,11 @@ extern \"C\" void _ReadWriteBarrier();\n #endif\n \n namespace __sanitizer {\n-struct StackTrace;\n+\n struct AddressInfo;\n+struct BufferedStackTrace;\n+struct SignalContext;\n+struct StackTrace;\n \n // Constants.\n const uptr kWordSize = SANITIZER_WORDSIZE / 8;\n@@ -70,7 +73,7 @@ INLINE uptr GetPageSizeCached() {\n uptr GetMmapGranularity();\n uptr GetMaxVirtualAddress();\n // Threads\n-uptr GetTid();\n+tid_t GetTid();\n uptr GetThreadSelf();\n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                 uptr *stack_bottom);\n@@ -83,25 +86,36 @@ INLINE void *MmapOrDieQuietly(uptr size, const char *mem_type) {\n   return MmapOrDie(size, mem_type, /*raw_report*/ true);\n }\n void UnmapOrDie(void *addr, uptr size);\n+// Behaves just like MmapOrDie, but tolerates out of memory condition, in that\n+// case returns nullptr.\n+void *MmapOrDieOnFatalError(uptr size, const char *mem_type);\n void *MmapFixedNoReserve(uptr fixed_addr, uptr size,\n                          const char *name = nullptr);\n void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n void *MmapFixedOrDie(uptr fixed_addr, uptr size);\n+// Behaves just like MmapFixedOrDie, but tolerates out of memory condition, in\n+// that case returns nullptr.\n+void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size);\n void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name = nullptr);\n void *MmapNoAccess(uptr size);\n // Map aligned chunk of address space; size and alignment are powers of two.\n-void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type);\n+// Dies on all but out of memory errors, in the latter case returns nullptr.\n+void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n+                                   const char *mem_type);\n // Disallow access to a memory range.  Use MmapFixedNoAccess to allocate an\n // unaccessible memory.\n bool MprotectNoAccess(uptr addr, uptr size);\n bool MprotectReadOnly(uptr addr, uptr size);\n \n // Find an available address space.\n-uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding);\n+uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n+                              uptr *largest_gap_found);\n \n // Used to check if we can map shadow memory to a fixed location.\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n-void ReleaseMemoryToOS(uptr addr, uptr size);\n+// Releases memory pages entirely within the [beg, end] address range. Noop if\n+// the provided range does not contain at least one entire page.\n+void ReleaseMemoryPagesToOS(uptr beg, uptr end);\n void IncreaseTotalMmap(uptr size);\n void DecreaseTotalMmap(uptr size);\n uptr GetRSS();\n@@ -112,6 +126,14 @@ void CheckVMASize();\n void RunMallocHooks(const void *ptr, uptr size);\n void RunFreeHooks(const void *ptr);\n \n+typedef void (*fill_profile_f)(uptr start, uptr rss, bool file,\n+                               /*out*/uptr *stats, uptr stats_size);\n+\n+// Parse the contents of /proc/self/smaps and generate a memory profile.\n+// |cb| is a tool-specific callback that fills the |stats| array containing\n+// |stats_size| elements.\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size);\n+\n // InternalScopedBuffer can be used instead of large stack arrays to\n // keep frame size low.\n // FIXME: use InternalAlloc instead of MmapOrDie once\n@@ -172,6 +194,7 @@ typedef void (*LowLevelAllocateCallback)(uptr ptr, uptr size);\n void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n \n // IO\n+void CatastrophicErrorWrite(const char *buffer, uptr length);\n void RawWrite(const char *buffer);\n bool ColorizeReports();\n void RemoveANSIEscapeSequencesFromString(char *buffer);\n@@ -188,66 +211,21 @@ void SetPrintfAndReportCallback(void (*callback)(const char *));\n   } while (0)\n \n // Can be used to prevent mixing error reports from different sanitizers.\n+// FIXME: Replace with ScopedErrorReportLock and hide.\n extern StaticSpinMutex CommonSanitizerReportMutex;\n \n-struct ReportFile {\n-  void Write(const char *buffer, uptr length);\n-  bool SupportsColors();\n-  void SetReportPath(const char *path);\n-\n-  // Don't use fields directly. They are only declared public to allow\n-  // aggregate initialization.\n-\n-  // Protects fields below.\n-  StaticSpinMutex *mu;\n-  // Opened file descriptor. Defaults to stderr. It may be equal to\n-  // kInvalidFd, in which case new file will be opened when necessary.\n-  fd_t fd;\n-  // Path prefix of report file, set via __sanitizer_set_report_path.\n-  char path_prefix[kMaxPathLength];\n-  // Full path to report, obtained as <path_prefix>.PID\n-  char full_path[kMaxPathLength];\n-  // PID of the process that opened fd. If a fork() occurs,\n-  // the PID of child will be different from fd_pid.\n-  uptr fd_pid;\n+// Lock sanitizer error reporting and protects against nested errors.\n+class ScopedErrorReportLock {\n+ public:\n+  ScopedErrorReportLock();\n+  ~ScopedErrorReportLock();\n \n- private:\n-  void ReopenIfNecessary();\n+  static void CheckLocked();\n };\n-extern ReportFile report_file;\n \n extern uptr stoptheworld_tracer_pid;\n extern uptr stoptheworld_tracer_ppid;\n \n-enum FileAccessMode {\n-  RdOnly,\n-  WrOnly,\n-  RdWr\n-};\n-\n-// Returns kInvalidFd on error.\n-fd_t OpenFile(const char *filename, FileAccessMode mode,\n-              error_t *errno_p = nullptr);\n-void CloseFile(fd_t);\n-\n-// Return true on success, false on error.\n-bool ReadFromFile(fd_t fd, void *buff, uptr buff_size,\n-                  uptr *bytes_read = nullptr, error_t *error_p = nullptr);\n-bool WriteToFile(fd_t fd, const void *buff, uptr buff_size,\n-                 uptr *bytes_written = nullptr, error_t *error_p = nullptr);\n-\n-bool RenameFile(const char *oldpath, const char *newpath,\n-                error_t *error_p = nullptr);\n-\n-// Scoped file handle closer.\n-struct FileCloser {\n-  explicit FileCloser(fd_t fd) : fd(fd) {}\n-  ~FileCloser() { CloseFile(fd); }\n-  fd_t fd;\n-};\n-\n-bool SupportsColoredOutput(fd_t fd);\n-\n // Opens the file 'file_name\" and reads up to 'max_len' bytes.\n // The resulting buffer is mmaped and stored in '*buff'.\n // The size of the mmaped region is stored in '*buff_size'.\n@@ -256,11 +234,6 @@ bool SupportsColoredOutput(fd_t fd);\n bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n                       uptr *read_len, uptr max_len = 1 << 26,\n                       error_t *errno_p = nullptr);\n-// Maps given file to virtual memory, and returns pointer to it\n-// (or NULL if mapping fails). Stores the size of mmaped region\n-// in '*buff_size'.\n-void *MapFileToMemory(const char *file_name, uptr *buff_size);\n-void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset);\n \n bool IsAccessibleMemoryRange(uptr beg, uptr size);\n \n@@ -279,27 +252,9 @@ void UpdateProcessName();\n void CacheBinaryName();\n void DisableCoreDumperIfNecessary();\n void DumpProcessMap();\n-bool FileExists(const char *filename);\n+void PrintModuleMap();\n const char *GetEnv(const char *name);\n bool SetEnv(const char *name, const char *value);\n-const char *GetPwd();\n-char *FindPathToBinary(const char *name);\n-bool IsPathSeparator(const char c);\n-bool IsAbsolutePath(const char *path);\n-// Starts a subprocess and returs its pid.\n-// If *_fd parameters are not kInvalidFd their corresponding input/output\n-// streams will be redirect to the file. The files will always be closed\n-// in parent process even in case of an error.\n-// The child process will close all fds after STDERR_FILENO\n-// before passing control to a program.\n-pid_t StartSubprocess(const char *filename, const char *const argv[],\n-                      fd_t stdin_fd = kInvalidFd, fd_t stdout_fd = kInvalidFd,\n-                      fd_t stderr_fd = kInvalidFd);\n-// Checks if specified process is still running\n-bool IsProcessRunning(pid_t pid);\n-// Waits for the process to finish and returns its exit code.\n-// Returns -1 in case of an error.\n-int WaitForProcess(pid_t pid);\n \n u32 GetUid();\n void ReExec();\n@@ -312,15 +267,9 @@ bool AddressSpaceIsUnlimited();\n void SetAddressSpaceUnlimited();\n void AdjustStackSize(void *attr);\n void PrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n-void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n void SetSandboxingCallback(void (*f)());\n \n-void CoverageUpdateMapping();\n-void CovBeforeFork();\n-void CovAfterFork(int child_pid);\n-\n void InitializeCoverage(bool enabled, const char *coverage_dir);\n-void ReInitializeCoverage(bool enabled, const char *coverage_dir);\n \n void InitTlsSize();\n uptr GetTlsSize();\n@@ -373,16 +322,28 @@ void SetCheckFailedCallback(CheckFailedCallbackType callback);\n // The callback should be registered once at the tool init time.\n void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded));\n \n-// Callback to be called when we want to try releasing unused allocator memory\n-// back to the OS.\n-typedef void (*AllocatorReleaseToOSCallback)();\n-// The callback should be registered once at the tool init time.\n-void SetAllocatorReleaseToOSCallback(AllocatorReleaseToOSCallback Callback);\n-\n // Functions related to signal handling.\n typedef void (*SignalHandlerType)(int, void *, void *);\n-bool IsHandledDeadlySignal(int signum);\n+HandleSignalMode GetHandleSignalMode(int signum);\n void InstallDeadlySignalHandlers(SignalHandlerType handler);\n+\n+// Signal reporting.\n+// Each sanitizer uses slightly different implementation of stack unwinding.\n+typedef void (*UnwindSignalStackCallbackType)(const SignalContext &sig,\n+                                              const void *callback_context,\n+                                              BufferedStackTrace *stack);\n+// Print deadly signal report and die.\n+void HandleDeadlySignal(void *siginfo, void *context, u32 tid,\n+                        UnwindSignalStackCallbackType unwind,\n+                        const void *unwind_context);\n+\n+// Part of HandleDeadlySignal, exposed for asan.\n+void StartReportDeadlySignal();\n+// Part of HandleDeadlySignal, exposed for asan.\n+void ReportDeadlySignal(const SignalContext &sig, u32 tid,\n+                        UnwindSignalStackCallbackType unwind,\n+                        const void *unwind_context);\n+\n // Alternative signal stack (POSIX-only).\n void SetAlternateSignalStack();\n void UnsetAlternateSignalStack();\n@@ -392,12 +353,16 @@ const int kMaxSummaryLength = 1024;\n // Construct a one-line string:\n //   SUMMARY: SanitizerToolName: error_message\n // and pass it to __sanitizer_report_error_summary.\n-void ReportErrorSummary(const char *error_message);\n+// If alt_tool_name is provided, it's used in place of SanitizerToolName.\n+void ReportErrorSummary(const char *error_message,\n+                        const char *alt_tool_name = nullptr);\n // Same as above, but construct error_message as:\n //   error_type file:line[:column][ function]\n-void ReportErrorSummary(const char *error_type, const AddressInfo &info);\n+void ReportErrorSummary(const char *error_type, const AddressInfo &info,\n+                        const char *alt_tool_name = nullptr);\n // Same as above, but obtains AddressInfo by symbolizing top stack trace frame.\n-void ReportErrorSummary(const char *error_type, const StackTrace *trace);\n+void ReportErrorSummary(const char *error_type, const StackTrace *trace,\n+                        const char *alt_tool_name = nullptr);\n \n // Math\n #if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\n@@ -549,6 +514,13 @@ class InternalMmapVectorNoCtor {\n   uptr capacity() const {\n     return capacity_;\n   }\n+  void resize(uptr new_size) {\n+    Resize(new_size);\n+    if (new_size > size_) {\n+      internal_memset(&data_[size_], 0, sizeof(T) * (new_size - size_));\n+    }\n+    size_ = new_size;\n+  }\n \n   void clear() { size_ = 0; }\n   bool empty() const { return size() == 0; }\n@@ -633,60 +605,130 @@ void InternalSort(Container *v, uptr size, Compare comp) {\n   }\n }\n \n-template<class Container, class Value, class Compare>\n-uptr InternalBinarySearch(const Container &v, uptr first, uptr last,\n-                          const Value &val, Compare comp) {\n-  uptr not_found = last + 1;\n-  while (last >= first) {\n+// Works like std::lower_bound: finds the first element that is not less\n+// than the val.\n+template <class Container, class Value, class Compare>\n+uptr InternalLowerBound(const Container &v, uptr first, uptr last,\n+                        const Value &val, Compare comp) {\n+  while (last > first) {\n     uptr mid = (first + last) / 2;\n     if (comp(v[mid], val))\n       first = mid + 1;\n-    else if (comp(val, v[mid]))\n-      last = mid - 1;\n     else\n-      return mid;\n+      last = mid;\n+  }\n+  return first;\n+}\n+\n+enum ModuleArch {\n+  kModuleArchUnknown,\n+  kModuleArchI386,\n+  kModuleArchX86_64,\n+  kModuleArchX86_64H,\n+  kModuleArchARMV6,\n+  kModuleArchARMV7,\n+  kModuleArchARMV7S,\n+  kModuleArchARMV7K,\n+  kModuleArchARM64\n+};\n+\n+// When adding a new architecture, don't forget to also update\n+// script/asan_symbolize.py and sanitizer_symbolizer_libcdep.cc.\n+inline const char *ModuleArchToString(ModuleArch arch) {\n+  switch (arch) {\n+    case kModuleArchUnknown:\n+      return \"\";\n+    case kModuleArchI386:\n+      return \"i386\";\n+    case kModuleArchX86_64:\n+      return \"x86_64\";\n+    case kModuleArchX86_64H:\n+      return \"x86_64h\";\n+    case kModuleArchARMV6:\n+      return \"armv6\";\n+    case kModuleArchARMV7:\n+      return \"armv7\";\n+    case kModuleArchARMV7S:\n+      return \"armv7s\";\n+    case kModuleArchARMV7K:\n+      return \"armv7k\";\n+    case kModuleArchARM64:\n+      return \"arm64\";\n   }\n-  return not_found;\n+  CHECK(0 && \"Invalid module arch\");\n+  return \"\";\n }\n \n+const uptr kModuleUUIDSize = 16;\n+const uptr kMaxSegName = 16;\n+\n // Represents a binary loaded into virtual memory (e.g. this can be an\n // executable or a shared object).\n class LoadedModule {\n  public:\n-  LoadedModule() : full_name_(nullptr), base_address_(0) { ranges_.clear(); }\n+  LoadedModule()\n+      : full_name_(nullptr),\n+        base_address_(0),\n+        max_executable_address_(0),\n+        arch_(kModuleArchUnknown),\n+        instrumented_(false) {\n+    internal_memset(uuid_, 0, kModuleUUIDSize);\n+    ranges_.clear();\n+  }\n   void set(const char *module_name, uptr base_address);\n+  void set(const char *module_name, uptr base_address, ModuleArch arch,\n+           u8 uuid[kModuleUUIDSize], bool instrumented);\n   void clear();\n-  void addAddressRange(uptr beg, uptr end, bool executable);\n+  void addAddressRange(uptr beg, uptr end, bool executable, bool writable,\n+                       const char *name = nullptr);\n   bool containsAddress(uptr address) const;\n \n   const char *full_name() const { return full_name_; }\n   uptr base_address() const { return base_address_; }\n+  uptr max_executable_address() const { return max_executable_address_; }\n+  ModuleArch arch() const { return arch_; }\n+  const u8 *uuid() const { return uuid_; }\n+  bool instrumented() const { return instrumented_; }\n \n   struct AddressRange {\n     AddressRange *next;\n     uptr beg;\n     uptr end;\n     bool executable;\n-\n-    AddressRange(uptr beg, uptr end, bool executable)\n-        : next(nullptr), beg(beg), end(end), executable(executable) {}\n+    bool writable;\n+    char name[kMaxSegName];\n+\n+    AddressRange(uptr beg, uptr end, bool executable, bool writable,\n+                 const char *name)\n+        : next(nullptr),\n+          beg(beg),\n+          end(end),\n+          executable(executable),\n+          writable(writable) {\n+      internal_strncpy(this->name, (name ? name : \"\"), ARRAY_SIZE(this->name));\n+    }\n   };\n \n   const IntrusiveList<AddressRange> &ranges() const { return ranges_; }\n \n  private:\n   char *full_name_;  // Owned.\n   uptr base_address_;\n+  uptr max_executable_address_;\n+  ModuleArch arch_;\n+  u8 uuid_[kModuleUUIDSize];\n+  bool instrumented_;\n   IntrusiveList<AddressRange> ranges_;\n };\n \n // List of LoadedModules. OS-dependent implementation is responsible for\n // filling this information.\n class ListOfModules {\n  public:\n-  ListOfModules() : modules_(kInitialCapacity) {}\n+  ListOfModules() : initialized(false) {}\n   ~ListOfModules() { clear(); }\n   void init();\n+  void fallbackInit();  // Uses fallback init if available, otherwise clears\n   const LoadedModule *begin() const { return modules_.begin(); }\n   LoadedModule *begin() { return modules_.begin(); }\n   const LoadedModule *end() const { return modules_.end(); }\n@@ -702,10 +744,15 @@ class ListOfModules {\n     for (auto &module : modules_) module.clear();\n     modules_.clear();\n   }\n+  void clearOrInit() {\n+    initialized ? clear() : modules_.Initialize(kInitialCapacity);\n+    initialized = true;\n+  }\n \n-  InternalMmapVector<LoadedModule> modules_;\n+  InternalMmapVectorNoCtor<LoadedModule> modules_;\n   // We rarely have more than 16K loaded modules.\n   static const uptr kInitialCapacity = 1 << 14;\n+  bool initialized;\n };\n \n // Callback type for iterating over a set of memory ranges.\n@@ -737,8 +784,11 @@ INLINE void LogMessageOnPrintf(const char *str) {}\n #if SANITIZER_LINUX\n // Initialize Android logging. Any writes before this are silently lost.\n void AndroidLogInit();\n+void SetAbortMessage(const char *);\n #else\n INLINE void AndroidLogInit() {}\n+// FIXME: MacOS implementation could use CRSetCrashLogMessage.\n+INLINE void SetAbortMessage(const char *) {}\n #endif\n \n #if SANITIZER_ANDROID\n@@ -778,33 +828,49 @@ static inline void SanitizerBreakOptimization(void *arg) {\n }\n \n struct SignalContext {\n+  void *siginfo;\n   void *context;\n   uptr addr;\n   uptr pc;\n   uptr sp;\n   uptr bp;\n   bool is_memory_access;\n-\n   enum WriteFlag { UNKNOWN, READ, WRITE } write_flag;\n \n-  SignalContext(void *context, uptr addr, uptr pc, uptr sp, uptr bp,\n-                bool is_memory_access, WriteFlag write_flag)\n-      : context(context),\n-        addr(addr),\n-        pc(pc),\n-        sp(sp),\n-        bp(bp),\n-        is_memory_access(is_memory_access),\n-        write_flag(write_flag) {}\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  SignalContext() = default;\n \n   // Creates signal context in a platform-specific manner.\n-  static SignalContext Create(void *siginfo, void *context);\n+  // SignalContext is going to keep pointers to siginfo and context without\n+  // owning them.\n+  SignalContext(void *siginfo, void *context)\n+      : siginfo(siginfo),\n+        context(context),\n+        addr(GetAddress()),\n+        is_memory_access(IsMemoryAccess()),\n+        write_flag(GetWriteFlag()) {\n+    InitPcSpBp();\n+  }\n \n-  // Returns true if the \"context\" indicates a memory write.\n-  static WriteFlag GetWriteFlag(void *context);\n-};\n+  static void DumpAllRegisters(void *context);\n+\n+  // Type of signal e.g. SIGSEGV or EXCEPTION_ACCESS_VIOLATION.\n+  int GetType() const;\n+\n+  // String description of the signal.\n+  const char *Describe() const;\n+\n+  // Returns true if signal is stack overflow.\n+  bool IsStackOverflow() const;\n \n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp);\n+ private:\n+  // Platform specific initialization.\n+  void InitPcSpBp();\n+  uptr GetAddress() const;\n+  WriteFlag GetWriteFlag() const;\n+  bool IsMemoryAccess() const;\n+};\n \n void MaybeReexec();\n \n@@ -840,6 +906,16 @@ struct StackDepotStats {\n   uptr allocated;\n };\n \n+// The default value for allocator_release_to_os_interval_ms common flag to\n+// indicate that sanitizer allocator should not attempt to release memory to OS.\n+const s32 kReleaseToOSIntervalNever = -1;\n+\n+void CheckNoDeepBind(const char *filename, int flag);\n+\n+// Returns the requested amount of random data (up to 256 bytes) that can then\n+// be used to seed a PRNG. Defaults to blocking like the underlying syscall.\n+bool GetRandom(void *buffer, uptr length, bool blocking = true);\n+\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,"}, {"sha": "3f32b2f78ef93e13f01c17680650a7495a4b0056", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 497, "deletions": 127, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -22,32 +22,34 @@\n //   COMMON_INTERCEPTOR_SET_THREAD_NAME\n //   COMMON_INTERCEPTOR_ON_DLOPEN\n //   COMMON_INTERCEPTOR_ON_EXIT\n-//   COMMON_INTERCEPTOR_MUTEX_LOCK\n+//   COMMON_INTERCEPTOR_MUTEX_PRE_LOCK\n+//   COMMON_INTERCEPTOR_MUTEX_POST_LOCK\n //   COMMON_INTERCEPTOR_MUTEX_UNLOCK\n //   COMMON_INTERCEPTOR_MUTEX_REPAIR\n //   COMMON_INTERCEPTOR_SET_PTHREAD_NAME\n //   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n //   COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n+//   COMMON_INTERCEPTOR_MEMSET_IMPL\n+//   COMMON_INTERCEPTOR_MEMMOVE_IMPL\n+//   COMMON_INTERCEPTOR_MEMCPY_IMPL\n+//   COMMON_INTERCEPTOR_COPY_STRING\n+//   COMMON_INTERCEPTOR_STRNDUP_IMPL\n //===----------------------------------------------------------------------===//\n \n #include \"interception/interception.h\"\n #include \"sanitizer_addrhashmap.h\"\n+#include \"sanitizer_errno.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_platform_interceptors.h\"\n+#include \"sanitizer_symbolizer.h\"\n #include \"sanitizer_tls_get_addr.h\"\n \n #include <stdarg.h>\n \n #if SANITIZER_INTERCEPTOR_HOOKS\n-#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)                                     \\\n-  do {                                                                         \\\n-    if (f)                                                                     \\\n-      f(__VA_ARGS__);                                                          \\\n-  } while (false);\n-#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)                                  \\\n-  extern \"C\" {                                                                 \\\n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void f(__VA_ARGS__);  \\\n-  } // extern \"C\"\n+#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...) f(__VA_ARGS__);\n+#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...) \\\n+  SANITIZER_INTERFACE_WEAK_DEF(void, f, __VA_ARGS__) {}\n #else\n #define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)\n #define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)\n@@ -65,6 +67,19 @@\n #define iconv __bsd_iconv\n #endif\n \n+// Platform-specific options.\n+#if SANITIZER_MAC\n+namespace __sanitizer {\n+bool PlatformHasDifferentMemcpyAndMemmove();\n+}\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\\n+  (__sanitizer::PlatformHasDifferentMemcpyAndMemmove())\n+#elif SANITIZER_WINDOWS64\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n+#else\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n+#endif  // SANITIZER_MAC\n+\n #ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n #define COMMON_INTERCEPTOR_INITIALIZE_RANGE(p, size) {}\n #endif\n@@ -77,8 +92,12 @@\n #define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) {}\n #endif\n \n-#ifndef COMMON_INTERCEPTOR_MUTEX_LOCK\n-#define COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m) {}\n+#ifndef COMMON_INTERCEPTOR_MUTEX_PRE_LOCK\n+#define COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_MUTEX_POST_LOCK\n+#define COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m) {}\n #endif\n \n #ifndef COMMON_INTERCEPTOR_MUTEX_UNLOCK\n@@ -122,15 +141,13 @@\n #define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (0)\n #endif\n \n-#define COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, n)       \\\n-    COMMON_INTERCEPTOR_READ_RANGE((ctx), (s),                       \\\n-      common_flags()->strict_string_checks ? (len) + 1 : (n) )\n-\n #define COMMON_INTERCEPTOR_READ_STRING(ctx, s, n)                   \\\n-    COMMON_INTERCEPTOR_READ_STRING_OF_LEN((ctx), (s), REAL(strlen)(s), (n))\n+    COMMON_INTERCEPTOR_READ_RANGE((ctx), (s),                       \\\n+      common_flags()->strict_string_checks ? (REAL(strlen)(s)) + 1 : (n) )\n \n #ifndef COMMON_INTERCEPTOR_ON_DLOPEN\n-#define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag) {}\n+#define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag) \\\n+  CheckNoDeepBind(filename, flag);\n #endif\n \n #ifndef COMMON_INTERCEPTOR_GET_TLS_RANGE\n@@ -161,6 +178,65 @@\n     COMMON_INTERCEPT_FUNCTION(fn)\n #endif\n \n+#ifndef COMMON_INTERCEPTOR_MEMSET_IMPL\n+#define COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, dst, v, size) \\\n+  {                                                       \\\n+    if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)        \\\n+      return internal_memset(dst, v, size);               \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, memset, dst, v, size);  \\\n+    if (common_flags()->intercept_intrin)                 \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);     \\\n+    return REAL(memset)(dst, v, size);                    \\\n+  }\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_MEMMOVE_IMPL\n+#define COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size) \\\n+  {                                                          \\\n+    if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)           \\\n+      return internal_memmove(dst, src, size);               \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, memmove, dst, src, size);  \\\n+    if (common_flags()->intercept_intrin) {                  \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);        \\\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);         \\\n+    }                                                        \\\n+    return REAL(memmove)(dst, src, size);                    \\\n+  }\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_MEMCPY_IMPL\n+#define COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, dst, src, size) \\\n+  {                                                         \\\n+    if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED) {        \\\n+      return internal_memmove(dst, src, size);              \\\n+    }                                                       \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, memcpy, dst, src, size);  \\\n+    if (common_flags()->intercept_intrin) {                 \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);       \\\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);        \\\n+    }                                                       \\\n+    return REAL(memcpy)(dst, src, size);                    \\\n+  }\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_COPY_STRING\n+#define COMMON_INTERCEPTOR_COPY_STRING(ctx, to, from, size) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_STRNDUP_IMPL\n+#define COMMON_INTERCEPTOR_STRNDUP_IMPL(ctx, s, size)                         \\\n+  COMMON_INTERCEPTOR_ENTER(ctx, strndup, s, size);                            \\\n+  uptr copy_length = internal_strnlen(s, size);                               \\\n+  char *new_mem = (char *)WRAP(malloc)(copy_length + 1);                      \\\n+  if (common_flags()->intercept_strndup) {                                    \\\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s, Min(size, copy_length + 1));       \\\n+  }                                                                           \\\n+  COMMON_INTERCEPTOR_COPY_STRING(ctx, new_mem, s, copy_length);               \\\n+  internal_memcpy(new_mem, s, copy_length);                                   \\\n+  new_mem[copy_length] = '\\0';                                                \\\n+  return new_mem;\n+#endif\n+\n struct FileMetadata {\n   // For open_memstream().\n   char **addr;\n@@ -181,7 +257,7 @@ typedef AddrHashMap<CommonInterceptorMetadata, 31051> MetadataHashMap;\n \n static MetadataHashMap *interceptor_metadata_map;\n \n-#if SI_NOT_WINDOWS\n+#if SI_POSIX\n UNUSED static void SetInterceptorMetadata(__sanitizer_FILE *addr,\n                                           const FileMetadata &file) {\n   MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr);\n@@ -208,7 +284,7 @@ UNUSED static void DeleteInterceptorMetadata(void *addr) {\n   MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr, true);\n   CHECK(h.exists());\n }\n-#endif  // SI_NOT_WINDOWS\n+#endif  // SI_POSIX\n \n #if SANITIZER_INTERCEPT_STRLEN\n INTERCEPTOR(SIZE_T, strlen, const char *s) {\n@@ -244,11 +320,31 @@ INTERCEPTOR(SIZE_T, strnlen, const char *s, SIZE_T maxlen) {\n #define INIT_STRNLEN\n #endif\n \n+#if SANITIZER_INTERCEPT_STRNDUP\n+INTERCEPTOR(char*, strndup, const char *s, uptr size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_STRNDUP_IMPL(ctx, s, size);\n+}\n+#define INIT_STRNDUP COMMON_INTERCEPT_FUNCTION(strndup)\n+#else\n+#define INIT_STRNDUP\n+#endif // SANITIZER_INTERCEPT_STRNDUP\n+\n+#if SANITIZER_INTERCEPT___STRNDUP\n+INTERCEPTOR(char*, __strndup, const char *s, uptr size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_STRNDUP_IMPL(ctx, s, size);\n+}\n+#define INIT___STRNDUP COMMON_INTERCEPT_FUNCTION(__strndup)\n+#else\n+#define INIT___STRNDUP\n+#endif // SANITIZER_INTERCEPT___STRNDUP\n+\n #if SANITIZER_INTERCEPT_TEXTDOMAIN\n INTERCEPTOR(char*, textdomain, const char *domainname) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, textdomain, domainname);\n-  COMMON_INTERCEPTOR_READ_STRING(ctx, domainname, 0);\n+  if (domainname) COMMON_INTERCEPTOR_READ_STRING(ctx, domainname, 0);\n   char *domain = REAL(textdomain)(domainname);\n   if (domain) {\n     COMMON_INTERCEPTOR_INITIALIZE_RANGE(domain, REAL(strlen)(domain) + 1);\n@@ -302,8 +398,14 @@ INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n     c2 = (unsigned char)s2[i];\n     if (c1 != c2 || c1 == '\\0') break;\n   }\n-  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, Min(i + 1, size));\n-  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, Min(i + 1, size));\n+  uptr i1 = i;\n+  uptr i2 = i;\n+  if (common_flags()->strict_string_checks) {\n+    for (; i1 < size && s1[i1]; i1++) {}\n+    for (; i2 < size && s2[i2]; i2++) {}\n+  }\n+  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s1), Min(i1 + 1, size));\n+  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s2), Min(i2 + 1, size));\n   int result = CharCmpX(c1, c2);\n   CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, GET_CALLER_PC(), s1,\n                              s2, size, result);\n@@ -346,24 +448,30 @@ INTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n }\n \n DECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncasecmp, uptr called_pc,\n-                              const char *s1, const char *s2, uptr n,\n+                              const char *s1, const char *s2, uptr size,\n                               int result)\n \n-INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T n) {\n+INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T size) {\n   void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, strncasecmp, s1, s2, n);\n+  COMMON_INTERCEPTOR_ENTER(ctx, strncasecmp, s1, s2, size);\n   unsigned char c1 = 0, c2 = 0;\n   uptr i;\n-  for (i = 0; i < n; i++) {\n+  for (i = 0; i < size; i++) {\n     c1 = (unsigned char)s1[i];\n     c2 = (unsigned char)s2[i];\n     if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n   }\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, n));\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, n));\n+  uptr i1 = i;\n+  uptr i2 = i;\n+  if (common_flags()->strict_string_checks) {\n+    for (; i1 < size && s1[i1]; i1++) {}\n+    for (; i2 < size && s2[i2]; i2++) {}\n+  }\n+  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s1), Min(i1 + 1, size));\n+  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s2), Min(i2 + 1, size));\n   int result = CharCaseCmp(c1, c2);\n   CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncasecmp, GET_CALLER_PC(),\n-                             s1, s2, n, result);\n+                             s1, s2, size, result);\n   return result;\n }\n \n@@ -379,8 +487,7 @@ static inline void StrstrCheck(void *ctx, char *r, const char *s1,\n                                const char *s2) {\n     uptr len1 = REAL(strlen)(s1);\n     uptr len2 = REAL(strlen)(s2);\n-    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s1, len1,\n-                                          r ? r - s1 + len2 : len1 + 1);\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r ? r - s1 + len2 : len1 + 1);\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, len2 + 1);\n }\n #endif\n@@ -429,6 +536,52 @@ INTERCEPTOR(char*, strcasestr, const char *s1, const char *s2) {\n #define INIT_STRCASESTR\n #endif\n \n+#if SANITIZER_INTERCEPT_STRTOK\n+\n+INTERCEPTOR(char*, strtok, char *str, const char *delimiters) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strtok, str, delimiters);\n+  if (!common_flags()->intercept_strtok) {\n+    return REAL(strtok)(str, delimiters);\n+  }\n+  if (common_flags()->strict_string_checks) {\n+    // If strict_string_checks is enabled, we check the whole first argument\n+    // string on the first call (strtok saves this string in a static buffer\n+    // for subsequent calls). We do not need to check strtok's result.\n+    // As the delimiters can change, we check them every call.\n+    if (str != nullptr) {\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, str, REAL(strlen)(str) + 1);\n+    }\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, delimiters,\n+                                  REAL(strlen)(delimiters) + 1);\n+    return REAL(strtok)(str, delimiters);\n+  } else {\n+    // However, when strict_string_checks is disabled we cannot check the\n+    // whole string on the first call. Instead, we check the result string\n+    // which is guaranteed to be a NULL-terminated substring of the first\n+    // argument. We also conservatively check one character of str and the\n+    // delimiters.\n+    if (str != nullptr) {\n+      COMMON_INTERCEPTOR_READ_STRING(ctx, str, 1);\n+    }\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, delimiters, 1);\n+    char *result = REAL(strtok)(str, delimiters);\n+    if (result != nullptr) {\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, result, REAL(strlen)(result) + 1);\n+    } else if (str != nullptr) {\n+      // No delimiter were found, it's safe to assume that the entire str was\n+      // scanned.\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, str, REAL(strlen)(str) + 1);\n+    }\n+    return result;\n+  }\n+}\n+\n+#define INIT_STRTOK COMMON_INTERCEPT_FUNCTION(strtok)\n+#else\n+#define INIT_STRTOK\n+#endif\n+\n #if SANITIZER_INTERCEPT_MEMMEM\n DECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memmem, uptr called_pc,\n                               const void *s1, SIZE_T len1, const void *s2,\n@@ -460,10 +613,11 @@ INTERCEPTOR(char*, strchr, const char *s, int c) {\n     return internal_strchr(s, c);\n   COMMON_INTERCEPTOR_ENTER(ctx, strchr, s, c);\n   char *result = REAL(strchr)(s, c);\n-  uptr len = internal_strlen(s);\n-  uptr n = result ? result - s + 1 : len + 1;\n-  if (common_flags()->intercept_strchr)\n-    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, n);\n+  if (common_flags()->intercept_strchr) {\n+    // Keep strlen as macro argument, as macro may ignore it.\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s,\n+      (result ? result - s : REAL(strlen)(s)) + 1);\n+  }\n   return result;\n }\n #define INIT_STRCHR COMMON_INTERCEPT_FUNCTION(strchr)\n@@ -492,9 +646,8 @@ INTERCEPTOR(char*, strrchr, const char *s, int c) {\n   if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n     return internal_strrchr(s, c);\n   COMMON_INTERCEPTOR_ENTER(ctx, strrchr, s, c);\n-  uptr len = internal_strlen(s);\n   if (common_flags()->intercept_strchr)\n-    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, len + 1);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n   return REAL(strrchr)(s, c);\n }\n #define INIT_STRRCHR COMMON_INTERCEPT_FUNCTION(strrchr)\n@@ -551,14 +704,9 @@ INTERCEPTOR(char *, strpbrk, const char *s1, const char *s2) {\n #endif\n \n #if SANITIZER_INTERCEPT_MEMSET\n-INTERCEPTOR(void*, memset, void *dst, int v, uptr size) {\n-  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n-    return internal_memset(dst, v, size);\n+INTERCEPTOR(void *, memset, void *dst, int v, uptr size) {\n   void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, memset, dst, v, size);\n-  if (common_flags()->intercept_intrin)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);\n-  return REAL(memset)(dst, v, size);\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, dst, v, size);\n }\n \n #define INIT_MEMSET COMMON_INTERCEPT_FUNCTION(memset)\n@@ -567,16 +715,9 @@ INTERCEPTOR(void*, memset, void *dst, int v, uptr size) {\n #endif\n \n #if SANITIZER_INTERCEPT_MEMMOVE\n-INTERCEPTOR(void*, memmove, void *dst, const void *src, uptr size) {\n-  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n-    return internal_memmove(dst, src, size);\n+INTERCEPTOR(void *, memmove, void *dst, const void *src, uptr size) {\n   void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, memmove, dst, src, size);\n-  if (common_flags()->intercept_intrin) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);\n-  }\n-  return REAL(memmove)(dst, src, size);\n+  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n }\n \n #define INIT_MEMMOVE COMMON_INTERCEPT_FUNCTION(memmove)\n@@ -585,25 +726,30 @@ INTERCEPTOR(void*, memmove, void *dst, const void *src, uptr size) {\n #endif\n \n #if SANITIZER_INTERCEPT_MEMCPY\n-INTERCEPTOR(void*, memcpy, void *dst, const void *src, uptr size) {\n-  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED) {\n-    // On OS X, calling internal_memcpy here will cause memory corruptions,\n-    // because memcpy and memmove are actually aliases of the same\n-    // implementation.  We need to use internal_memmove here.\n-    return internal_memmove(dst, src, size);\n-  }\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, memcpy, dst, src, size);\n-  if (common_flags()->intercept_intrin) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);\n-  }\n+INTERCEPTOR(void *, memcpy, void *dst, const void *src, uptr size) {\n+  // On OS X, calling internal_memcpy here will cause memory corruptions,\n+  // because memcpy and memmove are actually aliases of the same\n+  // implementation.  We need to use internal_memmove here.\n   // N.B.: If we switch this to internal_ we'll have to use internal_memmove\n   // due to memcpy being an alias of memmove on OS X.\n-  return REAL(memcpy)(dst, src, size);\n+  void *ctx;\n+  if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n+    COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, dst, src, size);\n+  } else {\n+    COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n+  }\n }\n \n-#define INIT_MEMCPY COMMON_INTERCEPT_FUNCTION(memcpy)\n+#define INIT_MEMCPY                                  \\\n+  do {                                               \\\n+    if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) { \\\n+      COMMON_INTERCEPT_FUNCTION(memcpy);             \\\n+    } else {                                         \\\n+      ASSIGN_REAL(memcpy, memmove);                  \\\n+    }                                                \\\n+    CHECK(REAL(memcpy));                             \\\n+  } while (false)\n+\n #else\n #define INIT_MEMCPY\n #endif\n@@ -739,7 +885,7 @@ INTERCEPTOR(long double, frexpl, long double x, int *exp) {\n #define INIT_FREXPF_FREXPL\n #endif  // SANITIZER_INTERCEPT_FREXPF_FREXPL\n \n-#if SI_NOT_WINDOWS\n+#if SI_POSIX\n static void write_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n                         SIZE_T iovlen, SIZE_T maxlen) {\n   for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n@@ -778,6 +924,23 @@ INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n #define INIT_READ\n #endif\n \n+#if SANITIZER_INTERCEPT_FREAD\n+INTERCEPTOR(SIZE_T, fread, void *ptr, SIZE_T size, SIZE_T nmemb, void *file) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fread, ptr, size, nmemb, file);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://github.com/google/sanitizers/issues/321.\n+  SIZE_T res = REAL(fread)(ptr, size, nmemb, file);\n+  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res * size);\n+  return res;\n+}\n+#define INIT_FREAD COMMON_INTERCEPT_FUNCTION(fread)\n+#else\n+#define INIT_FREAD\n+#endif\n+\n #if SANITIZER_INTERCEPT_PREAD\n INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n   void *ctx;\n@@ -878,6 +1041,20 @@ INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n #define INIT_WRITE\n #endif\n \n+#if SANITIZER_INTERCEPT_FWRITE\n+INTERCEPTOR(SIZE_T, fwrite, const void *p, uptr size, uptr nmemb, void *file) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fwrite, p, size, nmemb, file);\n+  SIZE_T res = REAL(fwrite)(p, size, nmemb, file);\n+  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, p, res * size);\n+  return res;\n+}\n+#define INIT_FWRITE COMMON_INTERCEPT_FUNCTION(fwrite)\n+#else\n+#define INIT_FWRITE\n+#endif\n+\n #if SANITIZER_INTERCEPT_PWRITE\n INTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n   void *ctx;\n@@ -1225,12 +1402,12 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n \n #if SANITIZER_INTERCEPT_SCANF\n #define INIT_SCANF                    \\\n-  COMMON_INTERCEPT_FUNCTION(scanf);   \\\n-  COMMON_INTERCEPT_FUNCTION(sscanf);  \\\n-  COMMON_INTERCEPT_FUNCTION(fscanf);  \\\n-  COMMON_INTERCEPT_FUNCTION(vscanf);  \\\n-  COMMON_INTERCEPT_FUNCTION(vsscanf); \\\n-  COMMON_INTERCEPT_FUNCTION(vfscanf);\n+  COMMON_INTERCEPT_FUNCTION_LDBL(scanf);   \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(sscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(fscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vsscanf); \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vfscanf);\n #else\n #define INIT_SCANF\n #endif\n@@ -1403,16 +1580,16 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n \n #if SANITIZER_INTERCEPT_PRINTF\n #define INIT_PRINTF                     \\\n-  COMMON_INTERCEPT_FUNCTION(printf);    \\\n-  COMMON_INTERCEPT_FUNCTION(sprintf);   \\\n-  COMMON_INTERCEPT_FUNCTION(snprintf);  \\\n-  COMMON_INTERCEPT_FUNCTION(asprintf);  \\\n-  COMMON_INTERCEPT_FUNCTION(fprintf);   \\\n-  COMMON_INTERCEPT_FUNCTION(vprintf);   \\\n-  COMMON_INTERCEPT_FUNCTION(vsprintf);  \\\n-  COMMON_INTERCEPT_FUNCTION(vsnprintf); \\\n-  COMMON_INTERCEPT_FUNCTION(vasprintf); \\\n-  COMMON_INTERCEPT_FUNCTION(vfprintf);\n+  COMMON_INTERCEPT_FUNCTION_LDBL(printf);    \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(sprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(snprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(asprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(fprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vsprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vsnprintf); \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vasprintf); \\\n+  COMMON_INTERCEPT_FUNCTION_LDBL(vfprintf);\n #else\n #define INIT_PRINTF\n #endif\n@@ -3187,31 +3364,45 @@ INTERCEPTOR(char *, strerror, int errnum) {\n #endif\n \n #if SANITIZER_INTERCEPT_STRERROR_R\n+// There are 2 versions of strerror_r:\n+//  * POSIX version returns 0 on success, negative error code on failure,\n+//    writes message to buf.\n+//  * GNU version returns message pointer, which points to either buf or some\n+//    static storage.\n+#if ((_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE) || \\\n+    SANITIZER_MAC || SANITIZER_ANDROID\n+// POSIX version. Spec is not clear on whether buf is NULL-terminated.\n+// At least on OSX, buf contents are valid even when the call fails.\n+INTERCEPTOR(int, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://github.com/google/sanitizers/issues/321.\n+  int res = REAL(strerror_r)(errnum, buf, buflen);\n+\n+  SIZE_T sz = internal_strnlen(buf, buflen);\n+  if (sz < buflen) ++sz;\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n+  return res;\n+}\n+#else\n+// GNU version.\n INTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n   char *res = REAL(strerror_r)(errnum, buf, buflen);\n-  // There are 2 versions of strerror_r:\n-  //  * POSIX version returns 0 on success, negative error code on failure,\n-  //    writes message to buf.\n-  //  * GNU version returns message pointer, which points to either buf or some\n-  //    static storage.\n-  SIZE_T posix_res = (SIZE_T)res;\n-  if (posix_res < 1024 || posix_res > (SIZE_T) - 1024) {\n-    // POSIX version. Spec is not clear on whether buf is NULL-terminated.\n-    // At least on OSX, buf contents are valid even when the call fails.\n-    SIZE_T sz = internal_strnlen(buf, buflen);\n-    if (sz < buflen) ++sz;\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n-  } else {\n-    // GNU version.\n+  if (res == buf)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n-  }\n+  else\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n   return res;\n }\n+#endif //(_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE ||\n+       //SANITIZER_MAC\n #define INIT_STRERROR_R COMMON_INTERCEPT_FUNCTION(strerror_r);\n #else\n #define INIT_STRERROR_R\n@@ -3397,7 +3588,7 @@ INTERCEPTOR(int, ppoll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n   if (fds && nfds) read_pollfd(ctx, fds, nfds);\n   if (timeout_ts)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout_ts, struct_timespec_sz);\n-  // FIXME: read sigmask when all of sigemptyset, etc are intercepted.\n+  if (sigmask) COMMON_INTERCEPTOR_READ_RANGE(ctx, sigmask, sizeof(*sigmask));\n   int res =\n       COMMON_INTERCEPTOR_BLOCK_REAL(ppoll)(fds, nfds, timeout_ts, sigmask);\n   if (fds && nfds) write_pollfd(ctx, fds, nfds);\n@@ -3438,7 +3629,7 @@ INTERCEPTOR(int, wordexp, char *s, __sanitizer_wordexp_t *p, int flags) {\n INTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigwait, set, sig);\n-  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n@@ -3455,7 +3646,7 @@ INTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n INTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigwaitinfo, set, info);\n-  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n@@ -3474,7 +3665,7 @@ INTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigtimedwait, set, info, timeout);\n   if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n-  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n@@ -3537,7 +3728,7 @@ INTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n             __sanitizer_sigset_t *oldset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigprocmask, how, set, oldset);\n-  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n@@ -3606,11 +3797,12 @@ INTERCEPTOR(void, _exit, int status) {\n INTERCEPTOR(int, pthread_mutex_lock, void *m) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_lock, m);\n+  COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m);\n   int res = REAL(pthread_mutex_lock)(m);\n   if (res == errno_EOWNERDEAD)\n     COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m);\n   if (res == 0 || res == errno_EOWNERDEAD)\n-    COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m);\n+    COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m);\n   if (res == errno_EINVAL)\n     COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n   return res;\n@@ -4484,7 +4676,7 @@ INTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n   SIZE_T res = REAL(iconv)(cd, inbuf, inbytesleft, outbuf, outbytesleft);\n-  if (res != (SIZE_T) - 1 && outbuf && *outbuf > outbuf_orig) {\n+  if (outbuf && *outbuf > outbuf_orig) {\n     SIZE_T sz = (char *)*outbuf - (char *)outbuf_orig;\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, outbuf_orig, sz);\n   }\n@@ -4839,47 +5031,67 @@ INTERCEPTOR(int, capset, void *hdrp, const void *datap) {\n #endif\n \n #if SANITIZER_INTERCEPT_AEABI_MEM\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memmove, void *, const void *, uptr)\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memcpy, void *, const void *, uptr)\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr)\n-\n INTERCEPTOR(void *, __aeabi_memmove, void *to, const void *from, uptr size) {\n-  return WRAP(memmove)(to, from, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memmove4, void *to, const void *from, uptr size) {\n-  return WRAP(memmove)(to, from, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memmove8, void *to, const void *from, uptr size) {\n-  return WRAP(memmove)(to, from, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memcpy, void *to, const void *from, uptr size) {\n-  return WRAP(memcpy)(to, from, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memcpy4, void *to, const void *from, uptr size) {\n-  return WRAP(memcpy)(to, from, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memcpy8, void *to, const void *from, uptr size) {\n-  return WRAP(memcpy)(to, from, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size);\n }\n+\n // Note the argument order.\n INTERCEPTOR(void *, __aeabi_memset, void *block, uptr size, int c) {\n-  return WRAP(memset)(block, c, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memset4, void *block, uptr size, int c) {\n-  return WRAP(memset)(block, c, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memset8, void *block, uptr size, int c) {\n-  return WRAP(memset)(block, c, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memclr, void *block, uptr size) {\n-  return WRAP(memset)(block, 0, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memclr4, void *block, uptr size) {\n-  return WRAP(memset)(block, 0, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n }\n+\n INTERCEPTOR(void *, __aeabi_memclr8, void *block, uptr size) {\n-  return WRAP(memset)(block, 0, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n }\n+\n #define INIT_AEABI_MEM                         \\\n   COMMON_INTERCEPT_FUNCTION(__aeabi_memmove);  \\\n   COMMON_INTERCEPT_FUNCTION(__aeabi_memmove4); \\\n@@ -4898,11 +5110,11 @@ INTERCEPTOR(void *, __aeabi_memclr8, void *block, uptr size) {\n #endif  // SANITIZER_INTERCEPT_AEABI_MEM\n \n #if SANITIZER_INTERCEPT___BZERO\n-DECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr);\n-\n INTERCEPTOR(void *, __bzero, void *block, uptr size) {\n-  return WRAP(memset)(block, 0, size);\n+  void *ctx;\n+  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n }\n+\n #define INIT___BZERO COMMON_INTERCEPT_FUNCTION(__bzero);\n #else\n #define INIT___BZERO\n@@ -5362,6 +5574,7 @@ INTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n   if (filename) COMMON_INTERCEPTOR_READ_STRING(ctx, filename, 0);\n   COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag);\n   void *res = REAL(dlopen)(filename, flag);\n+  Symbolizer::GetOrInit()->InvalidateModuleList();\n   COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res);\n   return res;\n }\n@@ -5370,6 +5583,7 @@ INTERCEPTOR(int, dlclose, void *handle) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlclose, handle);\n   int res = REAL(dlclose)(handle);\n+  Symbolizer::GetOrInit()->InvalidateModuleList();\n   COMMON_INTERCEPTOR_LIBRARY_UNLOADED();\n   return res;\n }\n@@ -5892,13 +6106,161 @@ INTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n \n // FIXME: add other *stat interceptor\n \n+#if SANITIZER_INTERCEPT_UTMP\n+INTERCEPTOR(void *, getutent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getutent, dummy);\n+  void *res = REAL(getutent)(dummy);\n+  if (res)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmp_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getutid, void *ut) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getutid, ut);\n+  void *res = REAL(getutid)(ut);\n+  if (res)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmp_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getutline, void *ut) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getutline, ut);\n+  void *res = REAL(getutline)(ut);\n+  if (res)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmp_sz);\n+  return res;\n+}\n+#define INIT_UTMP                      \\\n+  COMMON_INTERCEPT_FUNCTION(getutent); \\\n+  COMMON_INTERCEPT_FUNCTION(getutid);  \\\n+  COMMON_INTERCEPT_FUNCTION(getutline);\n+#else\n+#define INIT_UTMP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_UTMPX\n+INTERCEPTOR(void *, getutxent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getutxent, dummy);\n+  void *res = REAL(getutxent)(dummy);\n+  if (res)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmpx_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getutxid, void *ut) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getutxid, ut);\n+  void *res = REAL(getutxid)(ut);\n+  if (res)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmpx_sz);\n+  return res;\n+}\n+INTERCEPTOR(void *, getutxline, void *ut) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getutxline, ut);\n+  void *res = REAL(getutxline)(ut);\n+  if (res)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmpx_sz);\n+  return res;\n+}\n+#define INIT_UTMPX                      \\\n+  COMMON_INTERCEPT_FUNCTION(getutxent); \\\n+  COMMON_INTERCEPT_FUNCTION(getutxid);  \\\n+  COMMON_INTERCEPT_FUNCTION(getutxline);\n+#else\n+#define INIT_UTMPX\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETLOADAVG\n+INTERCEPTOR(int, getloadavg, double *loadavg, int nelem) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getloadavg, loadavg, nelem);\n+  int res = REAL(getloadavg)(loadavg, nelem);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, loadavg, res * sizeof(*loadavg));\n+  return res;\n+}\n+#define INIT_GETLOADAVG                      \\\n+  COMMON_INTERCEPT_FUNCTION(getloadavg);\n+#else\n+#define INIT_GETLOADAVG\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MCHECK_MPROBE\n+INTERCEPTOR(int, mcheck, void (*abortfunc)(int mstatus)) {\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, mcheck_pedantic, void (*abortfunc)(int mstatus)) {\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, mprobe, void *ptr) {\n+  return 0;\n+}\n+#endif\n+\n+INTERCEPTOR(SIZE_T, wcslen, const wchar_t *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcslen, s);\n+  SIZE_T res = REAL(wcslen)(s);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, sizeof(wchar_t) * (res + 1));\n+  return res;\n+}\n+\n+INTERCEPTOR(SIZE_T, wcsnlen, const wchar_t *s, SIZE_T n) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcsnlen, s, n);\n+  SIZE_T res = REAL(wcsnlen)(s, n);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, sizeof(wchar_t) * Min(res + 1, n));\n+  return res;\n+}\n+#define INIT_WCSLEN                  \\\n+  COMMON_INTERCEPT_FUNCTION(wcslen); \\\n+  COMMON_INTERCEPT_FUNCTION(wcsnlen);\n+\n+#if SANITIZER_INTERCEPT_WCSCAT\n+INTERCEPTOR(wchar_t *, wcscat, wchar_t *dst, const wchar_t *src) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcscat, dst, src);\n+  SIZE_T src_size = REAL(wcslen)(src);\n+  SIZE_T dst_size = REAL(wcslen)(dst);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, src, (src_size + 1) * sizeof(wchar_t));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, dst, (dst_size + 1) * sizeof(wchar_t));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst + dst_size,\n+                                 (src_size + 1) * sizeof(wchar_t));\n+  return REAL(wcscat)(dst, src);  // NOLINT\n+}\n+\n+INTERCEPTOR(wchar_t *, wcsncat, wchar_t *dst, const wchar_t *src, SIZE_T n) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, wcsncat, dst, src, n);\n+  SIZE_T src_size = REAL(wcsnlen)(src, n);\n+  SIZE_T dst_size = REAL(wcslen)(dst);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, src,\n+                                Min(src_size + 1, n) * sizeof(wchar_t));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, dst, (dst_size + 1) * sizeof(wchar_t));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst + dst_size,\n+                                 (src_size + 1) * sizeof(wchar_t));\n+  return REAL(wcsncat)(dst, src, n);  // NOLINT\n+}\n+#define INIT_WCSCAT                  \\\n+  COMMON_INTERCEPT_FUNCTION(wcscat); \\\n+  COMMON_INTERCEPT_FUNCTION(wcsncat);\n+#else\n+#define INIT_WCSCAT\n+#endif\n+\n static void InitializeCommonInterceptors() {\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n   interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n \n   INIT_TEXTDOMAIN;\n   INIT_STRLEN;\n   INIT_STRNLEN;\n+  INIT_STRNDUP;\n+  INIT___STRNDUP;\n   INIT_STRCMP;\n   INIT_STRNCMP;\n   INIT_STRCASECMP;\n@@ -5909,6 +6271,7 @@ static void InitializeCommonInterceptors() {\n   INIT_STRCHRNUL;\n   INIT_STRRCHR;\n   INIT_STRSPN;\n+  INIT_STRTOK;\n   INIT_STRPBRK;\n   INIT_MEMSET;\n   INIT_MEMMOVE;\n@@ -5918,12 +6281,14 @@ static void InitializeCommonInterceptors() {\n   INIT_MEMRCHR;\n   INIT_MEMMEM;\n   INIT_READ;\n+  INIT_FREAD;\n   INIT_PREAD;\n   INIT_PREAD64;\n   INIT_READV;\n   INIT_PREADV;\n   INIT_PREADV64;\n   INIT_WRITE;\n+  INIT_FWRITE;\n   INIT_PWRITE;\n   INIT_PWRITE64;\n   INIT_WRITEV;\n@@ -6088,4 +6453,9 @@ static void InitializeCommonInterceptors() {\n   INIT___LXSTAT;\n   INIT___LXSTAT64;\n   // FIXME: add other *stat interceptors.\n+  INIT_UTMP;\n+  INIT_UTMPX;\n+  INIT_GETLOADAVG;\n+  INIT_WCSLEN;\n+  INIT_WCSCAT;\n }"}, {"sha": "30927d2a2290639708dbc995aa21dbb7ba1b9eba", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_format.inc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -323,8 +323,8 @@ static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n       continue;\n     int size = scanf_get_value_size(&dir);\n     if (size == FSS_INVALID) {\n-      Report(\"WARNING: unexpected format specifier in scanf interceptor: \"\n-        \"%.*s\\n\", dir.end - dir.begin, dir.begin);\n+      Report(\"%s: WARNING: unexpected format specifier in scanf interceptor: \",\n+             SanitizerToolName, \"%.*s\\n\", dir.end - dir.begin, dir.begin);\n       break;\n     }\n     void *argp = va_arg(aq, void *);\n@@ -433,10 +433,6 @@ static const char *printf_parse_next(const char *p, PrintfDirective *dir) {\n }\n \n static int printf_get_value_size(PrintfDirective *dir) {\n-  if (dir->convSpecifier == 'm') {\n-    return sizeof(char *);\n-  }\n-\n   if (char_is_one_of(dir->convSpecifier, \"cCsS\")) {\n     unsigned charSize =\n         format_get_char_size(dir->convSpecifier, dir->lengthModifier);\n@@ -517,10 +513,17 @@ static void printf_common(void *ctx, const char *format, va_list aq) {\n       // Dynamic precision\n       SKIP_SCALAR_ARG(&aq, 'd', sizeof(int));\n     }\n+    // %m does not require an argument: strlen(errno).\n+    if (dir.convSpecifier == 'm')\n+      continue;\n     int size = printf_get_value_size(&dir);\n     if (size == FSS_INVALID) {\n-      Report(\"WARNING: unexpected format specifier in printf \"\n-             \"interceptor: %.*s\\n\", dir.end - dir.begin, dir.begin);\n+      static int ReportedOnce;\n+      if (!ReportedOnce++)\n+        Report(\n+            \"%s: WARNING: unexpected format specifier in printf \"\n+            \"interceptor: %.*s (reported once per process)\\n\",\n+            SanitizerToolName, dir.end - dir.begin, dir.begin);\n       break;\n     }\n     if (dir.convSpecifier == 'n') {"}, {"sha": "bd296f6decef9cc063cb509e2f5bc17a24be8397", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface.inc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,37 @@\n+//===-- sanitizer_common_interface.inc ------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// Sanitizer Common interface list.\n+//===----------------------------------------------------------------------===//\n+INTERFACE_FUNCTION(__sanitizer_annotate_contiguous_container)\n+INTERFACE_FUNCTION(__sanitizer_contiguous_container_find_bad_address)\n+INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n+INTERFACE_FUNCTION(__sanitizer_set_report_path)\n+INTERFACE_FUNCTION(__sanitizer_set_report_fd)\n+INTERFACE_FUNCTION(__sanitizer_verify_contiguous_container)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_report_error_summary)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_sandbox_on_notify)\n+// Sanitizer weak hooks\n+INTERFACE_WEAK_FUNCTION(__sanitizer_weak_hook_memcmp)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_weak_hook_strcmp)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_weak_hook_strncmp)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_weak_hook_strstr)\n+// Stacktrace interface.\n+INTERFACE_FUNCTION(__sanitizer_get_module_and_offset_for_pc)\n+INTERFACE_FUNCTION(__sanitizer_symbolize_global)\n+INTERFACE_FUNCTION(__sanitizer_symbolize_pc)\n+// Allocator interface.\n+INTERFACE_FUNCTION(__sanitizer_get_allocated_size)\n+INTERFACE_FUNCTION(__sanitizer_get_current_allocated_bytes)\n+INTERFACE_FUNCTION(__sanitizer_get_estimated_allocated_size)\n+INTERFACE_FUNCTION(__sanitizer_get_free_bytes)\n+INTERFACE_FUNCTION(__sanitizer_get_heap_size)\n+INTERFACE_FUNCTION(__sanitizer_get_ownership)\n+INTERFACE_FUNCTION(__sanitizer_get_unmapped_bytes)\n+INTERFACE_FUNCTION(__sanitizer_install_malloc_and_free_hooks)\n+INTERFACE_FUNCTION(__sanitizer_print_memory_profile)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_free_hook)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_malloc_hook)"}, {"sha": "d3b72a8eeb70089e6ca70b3a67707f2510e42db1", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface_posix.inc", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface_posix.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface_posix.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface_posix.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,12 @@\n+//===-- sanitizer_common_interface_posix.inc ------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// Sanitizer Common interface list only available for Posix systems.\n+//===----------------------------------------------------------------------===//\n+INTERFACE_WEAK_FUNCTION(__sanitizer_symbolize_code)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_symbolize_data)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_symbolize_demangle)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_symbolize_flush)"}, {"sha": "a3f35319e23fa52d011fc5d0d8c7763d108f874c", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "modified", "additions": 184, "deletions": 15, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -12,7 +12,10 @@\n #include \"sanitizer_common.h\"\n \n #include \"sanitizer_allocator_interface.h\"\n+#include \"sanitizer_file.h\"\n #include \"sanitizer_flags.h\"\n+#include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_report_decorator.h\"\n #include \"sanitizer_stackdepot.h\"\n #include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_symbolizer.h\"\n@@ -23,12 +26,25 @@\n \n namespace __sanitizer {\n \n+#if !SANITIZER_FUCHSIA\n+\n bool ReportFile::SupportsColors() {\n   SpinMutexLock l(mu);\n   ReopenIfNecessary();\n   return SupportsColoredOutput(fd);\n }\n \n+static INLINE bool ReportSupportsColors() {\n+  return report_file.SupportsColors();\n+}\n+\n+#else  // SANITIZER_FUCHSIA\n+\n+// Fuchsia's logs always go through post-processing that handles colorization.\n+static INLINE bool ReportSupportsColors() { return true; }\n+\n+#endif  // !SANITIZER_FUCHSIA\n+\n bool ColorizeReports() {\n   // FIXME: Add proper Windows support to AnsiColorDecorator and re-enable color\n   // printing on Windows.\n@@ -37,15 +53,16 @@ bool ColorizeReports() {\n \n   const char *flag = common_flags()->color;\n   return internal_strcmp(flag, \"always\") == 0 ||\n-         (internal_strcmp(flag, \"auto\") == 0 && report_file.SupportsColors());\n+         (internal_strcmp(flag, \"auto\") == 0 && ReportSupportsColors());\n }\n \n static void (*sandboxing_callback)();\n void SetSandboxingCallback(void (*f)()) {\n   sandboxing_callback = f;\n }\n \n-void ReportErrorSummary(const char *error_type, const StackTrace *stack) {\n+void ReportErrorSummary(const char *error_type, const StackTrace *stack,\n+                        const char *alt_tool_name) {\n #if !SANITIZER_GO\n   if (!common_flags()->print_summary)\n     return;\n@@ -57,7 +74,7 @@ void ReportErrorSummary(const char *error_type, const StackTrace *stack) {\n   // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n   uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n   SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n-  ReportErrorSummary(error_type, frame->info);\n+  ReportErrorSummary(error_type, frame->info, alt_tool_name);\n   frame->ClearAll();\n #endif\n }\n@@ -68,18 +85,11 @@ void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded)) {\n   SoftRssLimitExceededCallback = Callback;\n }\n \n-static AllocatorReleaseToOSCallback ReleseCallback;\n-void SetAllocatorReleaseToOSCallback(AllocatorReleaseToOSCallback Callback) {\n-  CHECK_EQ(ReleseCallback, nullptr);\n-  ReleseCallback = Callback;\n-}\n-\n #if SANITIZER_LINUX && !SANITIZER_GO\n void BackgroundThread(void *arg) {\n   uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n   uptr soft_rss_limit_mb = common_flags()->soft_rss_limit_mb;\n   bool heap_profile = common_flags()->heap_profile;\n-  bool allocator_release_to_os = common_flags()->allocator_release_to_os;\n   uptr prev_reported_rss = 0;\n   uptr prev_reported_stack_depot_size = 0;\n   bool reached_soft_rss_limit = false;\n@@ -125,17 +135,137 @@ void BackgroundThread(void *arg) {\n           SoftRssLimitExceededCallback(false);\n       }\n     }\n-    if (allocator_release_to_os && ReleseCallback) ReleseCallback();\n     if (heap_profile &&\n         current_rss_mb > rss_during_last_reported_profile * 1.1) {\n       Printf(\"\\n\\nHEAP PROFILE at RSS %zdMb\\n\", current_rss_mb);\n-      __sanitizer_print_memory_profile(90);\n+      __sanitizer_print_memory_profile(90, 20);\n       rss_during_last_reported_profile = current_rss_mb;\n     }\n   }\n }\n #endif\n \n+#if !SANITIZER_FUCHSIA && !SANITIZER_GO\n+void StartReportDeadlySignal() {\n+  // Write the first message using fd=2, just in case.\n+  // It may actually fail to write in case stderr is closed.\n+  CatastrophicErrorWrite(SanitizerToolName, internal_strlen(SanitizerToolName));\n+  static const char kDeadlySignal[] = \":DEADLYSIGNAL\\n\";\n+  CatastrophicErrorWrite(kDeadlySignal, sizeof(kDeadlySignal) - 1);\n+}\n+\n+static void MaybeReportNonExecRegion(uptr pc) {\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/ true);\n+  MemoryMappedSegment segment;\n+  while (proc_maps.Next(&segment)) {\n+    if (pc >= segment.start && pc < segment.end && !segment.IsExecutable())\n+      Report(\"Hint: PC is at a non-executable region. Maybe a wild jump?\\n\");\n+  }\n+#endif\n+}\n+\n+static void PrintMemoryByte(InternalScopedString *str, const char *before,\n+                            u8 byte) {\n+  SanitizerCommonDecorator d;\n+  str->append(\"%s%s%x%x%s \", before, d.MemoryByte(), byte >> 4, byte & 15,\n+              d.Default());\n+}\n+\n+static void MaybeDumpInstructionBytes(uptr pc) {\n+  if (!common_flags()->dump_instruction_bytes || (pc < GetPageSizeCached()))\n+    return;\n+  InternalScopedString str(1024);\n+  str.append(\"First 16 instruction bytes at pc: \");\n+  if (IsAccessibleMemoryRange(pc, 16)) {\n+    for (int i = 0; i < 16; ++i) {\n+      PrintMemoryByte(&str, \"\", ((u8 *)pc)[i]);\n+    }\n+    str.append(\"\\n\");\n+  } else {\n+    str.append(\"unaccessible\\n\");\n+  }\n+  Report(\"%s\", str.data());\n+}\n+\n+static void MaybeDumpRegisters(void *context) {\n+  if (!common_flags()->dump_registers) return;\n+  SignalContext::DumpAllRegisters(context);\n+}\n+\n+static void ReportStackOverflowImpl(const SignalContext &sig, u32 tid,\n+                                    UnwindSignalStackCallbackType unwind,\n+                                    const void *unwind_context) {\n+  SanitizerCommonDecorator d;\n+  Printf(\"%s\", d.Warning());\n+  static const char kDescription[] = \"stack-overflow\";\n+  Report(\"ERROR: %s: %s on address %p (pc %p bp %p sp %p T%d)\\n\",\n+         SanitizerToolName, kDescription, (void *)sig.addr, (void *)sig.pc,\n+         (void *)sig.bp, (void *)sig.sp, tid);\n+  Printf(\"%s\", d.Default());\n+  InternalScopedBuffer<BufferedStackTrace> stack_buffer(1);\n+  BufferedStackTrace *stack = stack_buffer.data();\n+  stack->Reset();\n+  unwind(sig, unwind_context, stack);\n+  stack->Print();\n+  ReportErrorSummary(kDescription, stack);\n+}\n+\n+static void ReportDeadlySignalImpl(const SignalContext &sig, u32 tid,\n+                                   UnwindSignalStackCallbackType unwind,\n+                                   const void *unwind_context) {\n+  SanitizerCommonDecorator d;\n+  Printf(\"%s\", d.Warning());\n+  const char *description = sig.Describe();\n+  Report(\"ERROR: %s: %s on unknown address %p (pc %p bp %p sp %p T%d)\\n\",\n+         SanitizerToolName, description, (void *)sig.addr, (void *)sig.pc,\n+         (void *)sig.bp, (void *)sig.sp, tid);\n+  Printf(\"%s\", d.Default());\n+  if (sig.pc < GetPageSizeCached())\n+    Report(\"Hint: pc points to the zero page.\\n\");\n+  if (sig.is_memory_access) {\n+    const char *access_type =\n+        sig.write_flag == SignalContext::WRITE\n+            ? \"WRITE\"\n+            : (sig.write_flag == SignalContext::READ ? \"READ\" : \"UNKNOWN\");\n+    Report(\"The signal is caused by a %s memory access.\\n\", access_type);\n+    if (sig.addr < GetPageSizeCached())\n+      Report(\"Hint: address points to the zero page.\\n\");\n+  }\n+  MaybeReportNonExecRegion(sig.pc);\n+  InternalScopedBuffer<BufferedStackTrace> stack_buffer(1);\n+  BufferedStackTrace *stack = stack_buffer.data();\n+  stack->Reset();\n+  unwind(sig, unwind_context, stack);\n+  stack->Print();\n+  MaybeDumpInstructionBytes(sig.pc);\n+  MaybeDumpRegisters(sig.context);\n+  Printf(\"%s can not provide additional info.\\n\", SanitizerToolName);\n+  ReportErrorSummary(description, stack);\n+}\n+\n+void ReportDeadlySignal(const SignalContext &sig, u32 tid,\n+                        UnwindSignalStackCallbackType unwind,\n+                        const void *unwind_context) {\n+  if (sig.IsStackOverflow())\n+    ReportStackOverflowImpl(sig, tid, unwind, unwind_context);\n+  else\n+    ReportDeadlySignalImpl(sig, tid, unwind, unwind_context);\n+}\n+\n+void HandleDeadlySignal(void *siginfo, void *context, u32 tid,\n+                        UnwindSignalStackCallbackType unwind,\n+                        const void *unwind_context) {\n+  StartReportDeadlySignal();\n+  ScopedErrorReportLock rl;\n+  SignalContext sig(siginfo, context);\n+  ReportDeadlySignal(sig, tid, unwind, unwind_context);\n+  Report(\"ABORTING\\n\");\n+  Die();\n+}\n+\n+#endif  // !SANITIZER_FUCHSIA && !SANITIZER_GO\n+\n void WriteToSyslog(const char *msg) {\n   InternalScopedString msg_copy(kErrorMessageBufferSize);\n   msg_copy.append(\"%s\", msg);\n@@ -160,17 +290,56 @@ void MaybeStartBackgroudThread() {\n   // Start the background thread if one of the rss limits is given.\n   if (!common_flags()->hard_rss_limit_mb &&\n       !common_flags()->soft_rss_limit_mb &&\n-      !common_flags()->allocator_release_to_os &&\n       !common_flags()->heap_profile) return;\n   if (!&real_pthread_create) return;  // Can't spawn the thread anyway.\n   internal_start_thread(BackgroundThread, nullptr);\n #endif\n }\n \n+static atomic_uintptr_t reporting_thread = {0};\n+\n+ScopedErrorReportLock::ScopedErrorReportLock() {\n+  uptr current = GetThreadSelf();\n+  for (;;) {\n+    uptr expected = 0;\n+    if (atomic_compare_exchange_strong(&reporting_thread, &expected, current,\n+                                       memory_order_relaxed)) {\n+      // We've claimed reporting_thread so proceed.\n+      CommonSanitizerReportMutex.Lock();\n+      return;\n+    }\n+\n+    if (expected == current) {\n+      // This is either asynch signal or nested error during error reporting.\n+      // Fail simple to avoid deadlocks in Report().\n+\n+      // Can't use Report() here because of potential deadlocks in nested\n+      // signal handlers.\n+      CatastrophicErrorWrite(SanitizerToolName,\n+                             internal_strlen(SanitizerToolName));\n+      static const char msg[] = \": nested bug in the same thread, aborting.\\n\";\n+      CatastrophicErrorWrite(msg, sizeof(msg) - 1);\n+\n+      internal__exit(common_flags()->exitcode);\n+    }\n+\n+    internal_sched_yield();\n+  }\n+}\n+\n+ScopedErrorReportLock::~ScopedErrorReportLock() {\n+  CommonSanitizerReportMutex.Unlock();\n+  atomic_store_relaxed(&reporting_thread, 0);\n+}\n+\n+void ScopedErrorReportLock::CheckLocked() {\n+  CommonSanitizerReportMutex.CheckLocked();\n+}\n+\n }  // namespace __sanitizer\n \n-void NOINLINE\n-__sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args) {\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_sandbox_on_notify,\n+                             __sanitizer_sandbox_arguments *args) {\n   __sanitizer::PrepareForSandboxing(args);\n   if (__sanitizer::sandboxing_callback)\n     __sanitizer::sandboxing_callback();"}, {"sha": "7397a011098c4580699908ccdc6ecf1b44b57959", "filename": "libsanitizer/sanitizer_common/sanitizer_common_nolibc.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,34 @@\n+//===-- sanitizer_common_nolibc.cc ----------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file contains stubs for libc function to facilitate optional use of\n+// libc in no-libcdep sources.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+\n+namespace __sanitizer {\n+\n+// The Windows implementations of these functions use the win32 API directly,\n+// bypassing libc.\n+#if !SANITIZER_WINDOWS\n+#if SANITIZER_LINUX\n+bool ShouldLogAfterPrintf() { return false; }\n+void LogMessageOnPrintf(const char *str) {}\n+#endif\n+void WriteToSyslog(const char *buffer) {}\n+void Abort() { internal__exit(1); }\n+void SleepForSeconds(int seconds) { internal_sleep(seconds); }\n+#endif // !SANITIZER_WINDOWS\n+\n+#if !SANITIZER_WINDOWS && !SANITIZER_MAC\n+void ListOfModules::init() {}\n+#endif\n+\n+}  // namespace __sanitizer"}, {"sha": "7f294512e9a17daa118f5a04c0fd221a080bbf74", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_fuchsia.cc", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,238 @@\n+//===-- sanitizer_coverage_fuchsia.cc ------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// Sanitizer Coverage Controller for Trace PC Guard, Fuchsia-specific version.\n+//\n+// This Fuchsia-specific implementation uses the same basic scheme and the\n+// same simple '.sancov' file format as the generic implementation.  The\n+// difference is that we just produce a single blob of output for the whole\n+// program, not a separate one per DSO.  We do not sort the PC table and do\n+// not prune the zeros, so the resulting file is always as large as it\n+// would be to report 100% coverage.  Implicit tracing information about\n+// the address ranges of DSOs allows offline tools to split the one big\n+// blob into separate files that the 'sancov' tool can understand.\n+//\n+// Unlike the traditional implementation that uses an atexit hook to write\n+// out data files at the end, the results on Fuchsia do not go into a file\n+// per se.  The 'coverage_dir' option is ignored.  Instead, they are stored\n+// directly into a shared memory object (a Zircon VMO).  At exit, that VMO\n+// is handed over to a system service that's responsible for getting the\n+// data out to somewhere that it can be fed into the sancov tool (where and\n+// how is not our problem).\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_FUCHSIA\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_internal_defs.h\"\n+\n+#include <zircon/process.h>\n+#include <zircon/sanitizer.h>\n+#include <zircon/syscalls.h>\n+\n+using namespace __sanitizer;  // NOLINT\n+\n+namespace __sancov {\n+namespace {\n+\n+// TODO(mcgrathr): Move the constant into a header shared with other impls.\n+constexpr u64 Magic64 = 0xC0BFFFFFFFFFFF64ULL;\n+static_assert(SANITIZER_WORDSIZE == 64, \"Fuchsia is always LP64\");\n+\n+constexpr const char kSancovSinkName[] = \"sancov\";\n+\n+// Collects trace-pc guard coverage.\n+// This class relies on zero-initialization.\n+class TracePcGuardController {\n+ public:\n+  // For each PC location being tracked, there is a u32 reserved in global\n+  // data called the \"guard\".  At startup, we assign each guard slot a\n+  // unique index into the big results array.  Later during runtime, the\n+  // first call to TracePcGuard (below) will store the corresponding PC at\n+  // that index in the array.  (Each later call with the same guard slot is\n+  // presumed to be from the same PC.)  Then it clears the guard slot back\n+  // to zero, which tells the compiler not to bother calling in again.  At\n+  // the end of the run, we have a big array where each element is either\n+  // zero or is a tracked PC location that was hit in the trace.\n+\n+  // This is called from global constructors.  Each translation unit has a\n+  // contiguous array of guard slots, and a constructor that calls here\n+  // with the bounds of its array.  Those constructors are allowed to call\n+  // here more than once for the same array.  Usually all of these\n+  // constructors run in the initial thread, but it's possible that a\n+  // dlopen call on a secondary thread will run constructors that get here.\n+  void InitTracePcGuard(u32 *start, u32 *end) {\n+    if (end > start && *start == 0 && common_flags()->coverage) {\n+      // Complete the setup before filling in any guards with indices.\n+      // This avoids the possibility of code called from Setup reentering\n+      // TracePcGuard.\n+      u32 idx = Setup(end - start);\n+      for (u32 *p = start; p < end; ++p) {\n+        *p = idx++;\n+      }\n+    }\n+  }\n+\n+  void TracePcGuard(u32 *guard, uptr pc) {\n+    atomic_uint32_t *guard_ptr = reinterpret_cast<atomic_uint32_t *>(guard);\n+    u32 idx = atomic_exchange(guard_ptr, 0, memory_order_relaxed);\n+    if (idx > 0) array_[idx] = pc;\n+  }\n+\n+  void Dump() {\n+    BlockingMutexLock locked(&setup_lock_);\n+    if (array_) {\n+      CHECK_NE(vmo_, ZX_HANDLE_INVALID);\n+\n+      // Publish the VMO to the system, where it can be collected and\n+      // analyzed after this process exits.  This always consumes the VMO\n+      // handle.  Any failure is just logged and not indicated to us.\n+      __sanitizer_publish_data(kSancovSinkName, vmo_);\n+      vmo_ = ZX_HANDLE_INVALID;\n+\n+      // This will route to __sanitizer_log_write, which will ensure that\n+      // information about shared libraries is written out.  This message\n+      // uses the `dumpfile` symbolizer markup element to highlight the\n+      // dump.  See the explanation for this in:\n+      // https://fuchsia.googlesource.com/zircon/+/master/docs/symbolizer_markup.md\n+      Printf(\"SanitizerCoverage: {{{dumpfile:%s:%s}}} with up to %u PCs\\n\",\n+             kSancovSinkName, vmo_name_, next_index_ - 1);\n+    }\n+  }\n+\n+ private:\n+  // We map in the largest possible view into the VMO: one word\n+  // for every possible 32-bit index value.  This avoids the need\n+  // to change the mapping when increasing the size of the VMO.\n+  // We can always spare the 32G of address space.\n+  static constexpr size_t MappingSize = sizeof(uptr) << 32;\n+\n+  BlockingMutex setup_lock_;\n+  uptr *array_;\n+  u32 next_index_;\n+  zx_handle_t vmo_;\n+  char vmo_name_[ZX_MAX_NAME_LEN];\n+\n+  size_t DataSize() const { return next_index_ * sizeof(uintptr_t); }\n+\n+  u32 Setup(u32 num_guards) {\n+    BlockingMutexLock locked(&setup_lock_);\n+    DCHECK(common_flags()->coverage);\n+\n+    if (next_index_ == 0) {\n+      CHECK_EQ(vmo_, ZX_HANDLE_INVALID);\n+      CHECK_EQ(array_, nullptr);\n+\n+      // The first sample goes at [1] to reserve [0] for the magic number.\n+      next_index_ = 1 + num_guards;\n+\n+      zx_status_t status = _zx_vmo_create(DataSize(), 0, &vmo_);\n+      CHECK_EQ(status, ZX_OK);\n+\n+      // Give the VMO a name including our process KOID so it's easy to spot.\n+      internal_snprintf(vmo_name_, sizeof(vmo_name_), \"%s.%zu\", kSancovSinkName,\n+                        internal_getpid());\n+      _zx_object_set_property(vmo_, ZX_PROP_NAME, vmo_name_,\n+                              internal_strlen(vmo_name_));\n+\n+      // Map the largest possible view we might need into the VMO.  Later\n+      // we might need to increase the VMO's size before we can use larger\n+      // indices, but we'll never move the mapping address so we don't have\n+      // any multi-thread synchronization issues with that.\n+      uintptr_t mapping;\n+      status =\n+          _zx_vmar_map(_zx_vmar_root_self(), 0, vmo_, 0, MappingSize,\n+                       ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE, &mapping);\n+      CHECK_EQ(status, ZX_OK);\n+\n+      // Hereafter other threads are free to start storing into\n+      // elements [1, next_index_) of the big array.\n+      array_ = reinterpret_cast<uptr *>(mapping);\n+\n+      // Store the magic number.\n+      // Hereafter, the VMO serves as the contents of the '.sancov' file.\n+      array_[0] = Magic64;\n+\n+      return 1;\n+    } else {\n+      // The VMO is already mapped in, but it's not big enough to use the\n+      // new indices.  So increase the size to cover the new maximum index.\n+\n+      CHECK_NE(vmo_, ZX_HANDLE_INVALID);\n+      CHECK_NE(array_, nullptr);\n+\n+      uint32_t first_index = next_index_;\n+      next_index_ += num_guards;\n+\n+      zx_status_t status = _zx_vmo_set_size(vmo_, DataSize());\n+      CHECK_EQ(status, ZX_OK);\n+\n+      return first_index;\n+    }\n+  }\n+};\n+\n+static TracePcGuardController pc_guard_controller;\n+\n+}  // namespace\n+}  // namespace __sancov\n+\n+namespace __sanitizer {\n+void InitializeCoverage(bool enabled, const char *dir) {\n+  CHECK_EQ(enabled, common_flags()->coverage);\n+  CHECK_EQ(dir, common_flags()->coverage_dir);\n+\n+  static bool coverage_enabled = false;\n+  if (!coverage_enabled) {\n+    coverage_enabled = enabled;\n+    Atexit(__sanitizer_cov_dump);\n+    AddDieCallback(__sanitizer_cov_dump);\n+  }\n+}\n+}  // namespace __sanitizer\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(  // NOLINT\n+    const uptr *pcs, uptr len) {\n+  UNIMPLEMENTED();\n+}\n+\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard, u32 *guard) {\n+  if (!*guard) return;\n+  __sancov::pc_guard_controller.TracePcGuard(guard, GET_CALLER_PC() - 1);\n+}\n+\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard_init,\n+                             u32 *start, u32 *end) {\n+  if (start == end || *start) return;\n+  __sancov::pc_guard_controller.InitTracePcGuard(start, end);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_trace_pc_guard_coverage() {\n+  __sancov::pc_guard_controller.Dump();\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() {\n+  __sanitizer_dump_trace_pc_guard_coverage();\n+}\n+// Default empty implementations (weak). Users should redefine them.\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp1, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp2, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp4, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp8, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp1, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp2, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp4, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp8, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_switch, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div4, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div8, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_gep, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_indir, void) {}\n+}  // extern \"C\"\n+\n+#endif  // !SANITIZER_FUCHSIA"}, {"sha": "fb78cc00f7008ea165e167efff5f1f6c1914121e", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_interface.inc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,31 @@\n+//===-- sanitizer_coverage_interface.inc ----------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// Sanitizer Coverage interface list.\n+//===----------------------------------------------------------------------===//\n+INTERFACE_FUNCTION(__sanitizer_cov_dump)\n+INTERFACE_FUNCTION(__sanitizer_cov_reset)\n+INTERFACE_FUNCTION(__sanitizer_dump_coverage)\n+INTERFACE_FUNCTION(__sanitizer_dump_trace_pc_guard_coverage)\n+INTERFACE_WEAK_FUNCTION(__sancov_default_options)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_cmp)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_cmp1)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_cmp2)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_cmp4)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_cmp8)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_const_cmp1)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_const_cmp2)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_const_cmp4)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_const_cmp8)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_div4)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_div8)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_gep)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_guard)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_guard_init)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_indir)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_switch)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_8bit_counters_init)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_pcs_init)"}, {"sha": "dd8620beaac0a9b945127e047b4000ef3baa89af", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep.cc", "status": "removed", "additions": 0, "deletions": 1043, "changes": 1043, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93659712d9807d7ef01d472dc58119f4ac15cbad/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93659712d9807d7ef01d472dc58119f4ac15cbad/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc?ref=93659712d9807d7ef01d472dc58119f4ac15cbad", "patch": "@@ -1,1043 +0,0 @@\n-//===-- sanitizer_coverage.cc ---------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// Sanitizer Coverage.\n-// This file implements run-time support for a poor man's coverage tool.\n-//\n-// Compiler instrumentation:\n-// For every interesting basic block the compiler injects the following code:\n-// if (Guard < 0) {\n-//    __sanitizer_cov(&Guard);\n-// }\n-// At the module start up time __sanitizer_cov_module_init sets the guards\n-// to consecutive negative numbers (-1, -2, -3, ...).\n-// It's fine to call __sanitizer_cov more than once for a given block.\n-//\n-// Run-time:\n-//  - __sanitizer_cov(): record that we've executed the PC (GET_CALLER_PC).\n-//    and atomically set Guard to -Guard.\n-//  - __sanitizer_cov_dump: dump the coverage data to disk.\n-//  For every module of the current process that has coverage data\n-//  this will create a file module_name.PID.sancov.\n-//\n-// The file format is simple: the first 8 bytes is the magic,\n-// one of 0xC0BFFFFFFFFFFF64 and 0xC0BFFFFFFFFFFF32. The last byte of the\n-// magic defines the size of the following offsets.\n-// The rest of the data is the offsets in the module.\n-//\n-// Eventually, this coverage implementation should be obsoleted by a more\n-// powerful general purpose Clang/LLVM coverage instrumentation.\n-// Consider this implementation as prototype.\n-//\n-// FIXME: support (or at least test with) dlclose.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_allocator_internal.h\"\n-#include \"sanitizer_common.h\"\n-#include \"sanitizer_libc.h\"\n-#include \"sanitizer_mutex.h\"\n-#include \"sanitizer_procmaps.h\"\n-#include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_symbolizer.h\"\n-#include \"sanitizer_flags.h\"\n-\n-using namespace __sanitizer;\n-\n-static const u64 kMagic64 = 0xC0BFFFFFFFFFFF64ULL;\n-static const u64 kMagic32 = 0xC0BFFFFFFFFFFF32ULL;\n-static const uptr kNumWordsForMagic = SANITIZER_WORDSIZE == 64 ? 1 : 2;\n-static const u64 kMagic = SANITIZER_WORDSIZE == 64 ? kMagic64 : kMagic32;\n-\n-static atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n-\n-static atomic_uintptr_t coverage_counter;\n-static atomic_uintptr_t caller_callee_counter;\n-\n-static void ResetGlobalCounters() {\n-  return atomic_store(&coverage_counter, 0, memory_order_relaxed);\n-  return atomic_store(&caller_callee_counter, 0, memory_order_relaxed);\n-}\n-\n-// pc_array is the array containing the covered PCs.\n-// To make the pc_array thread- and async-signal-safe it has to be large enough.\n-// 128M counters \"ought to be enough for anybody\" (4M on 32-bit).\n-\n-// With coverage_direct=1 in ASAN_OPTIONS, pc_array memory is mapped to a file.\n-// In this mode, __sanitizer_cov_dump does nothing, and CovUpdateMapping()\n-// dump current memory layout to another file.\n-\n-static bool cov_sandboxed = false;\n-static fd_t cov_fd = kInvalidFd;\n-static unsigned int cov_max_block_size = 0;\n-static bool coverage_enabled = false;\n-static const char *coverage_dir;\n-\n-namespace __sanitizer {\n-\n-class CoverageData {\n- public:\n-  void Init();\n-  void Enable();\n-  void Disable();\n-  void ReInit();\n-  void BeforeFork();\n-  void AfterFork(int child_pid);\n-  void Extend(uptr npcs);\n-  void Add(uptr pc, u32 *guard);\n-  void IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n-                 uptr cache_size);\n-  void DumpCallerCalleePairs();\n-  void DumpTrace();\n-  void DumpAsBitSet();\n-  void DumpCounters();\n-  void DumpOffsets();\n-  void DumpAll();\n-\n-  ALWAYS_INLINE\n-  void TraceBasicBlock(u32 *id);\n-\n-  void InitializeGuardArray(s32 *guards);\n-  void InitializeGuards(s32 *guards, uptr n, const char *module_name,\n-                        uptr caller_pc);\n-  void InitializeCounters(u8 *counters, uptr n);\n-  void ReinitializeGuards();\n-  uptr GetNumberOf8bitCounters();\n-  uptr Update8bitCounterBitsetAndClearCounters(u8 *bitset);\n-\n-  uptr *data();\n-  uptr size() const;\n-\n- private:\n-  struct NamedPcRange {\n-    const char *copied_module_name;\n-    uptr beg, end; // elements [beg,end) in pc_array.\n-  };\n-\n-  void DirectOpen();\n-  void UpdateModuleNameVec(uptr caller_pc, uptr range_beg, uptr range_end);\n-  void GetRangeOffsets(const NamedPcRange& r, Symbolizer* s,\n-      InternalMmapVector<uptr>* offsets) const;\n-\n-  // Maximal size pc array may ever grow.\n-  // We MmapNoReserve this space to ensure that the array is contiguous.\n-  static const uptr kPcArrayMaxSize =\n-      FIRST_32_SECOND_64(1 << (SANITIZER_ANDROID ? 24 : 26), 1 << 27);\n-  // The amount file mapping for the pc array is grown by.\n-  static const uptr kPcArrayMmapSize = 64 * 1024;\n-\n-  // pc_array is allocated with MmapNoReserveOrDie and so it uses only as\n-  // much RAM as it really needs.\n-  uptr *pc_array;\n-  // Index of the first available pc_array slot.\n-  atomic_uintptr_t pc_array_index;\n-  // Array size.\n-  atomic_uintptr_t pc_array_size;\n-  // Current file mapped size of the pc array.\n-  uptr pc_array_mapped_size;\n-  // Descriptor of the file mapped pc array.\n-  fd_t pc_fd;\n-\n-  // Vector of coverage guard arrays, protected by mu.\n-  InternalMmapVectorNoCtor<s32*> guard_array_vec;\n-\n-  // Vector of module and compilation unit pc ranges.\n-  InternalMmapVectorNoCtor<NamedPcRange> comp_unit_name_vec;\n-  InternalMmapVectorNoCtor<NamedPcRange> module_name_vec;\n-\n-  struct CounterAndSize {\n-    u8 *counters;\n-    uptr n;\n-  };\n-\n-  InternalMmapVectorNoCtor<CounterAndSize> counters_vec;\n-  uptr num_8bit_counters;\n-\n-  // Caller-Callee (cc) array, size and current index.\n-  static const uptr kCcArrayMaxSize = FIRST_32_SECOND_64(1 << 18, 1 << 24);\n-  uptr **cc_array;\n-  atomic_uintptr_t cc_array_index;\n-  atomic_uintptr_t cc_array_size;\n-\n-  // Tracing event array, size and current pointer.\n-  // We record all events (basic block entries) in a global buffer of u32\n-  // values. Each such value is the index in pc_array.\n-  // So far the tracing is highly experimental:\n-  //   - not thread-safe;\n-  //   - does not support long traces;\n-  //   - not tuned for performance.\n-  static const uptr kTrEventArrayMaxSize = FIRST_32_SECOND_64(1 << 22, 1 << 30);\n-  u32 *tr_event_array;\n-  uptr tr_event_array_size;\n-  u32 *tr_event_pointer;\n-  static const uptr kTrPcArrayMaxSize    = FIRST_32_SECOND_64(1 << 22, 1 << 27);\n-\n-  StaticSpinMutex mu;\n-};\n-\n-static CoverageData coverage_data;\n-\n-void CovUpdateMapping(const char *path, uptr caller_pc = 0);\n-\n-void CoverageData::DirectOpen() {\n-  InternalScopedString path(kMaxPathLength);\n-  internal_snprintf((char *)path.data(), path.size(), \"%s/%zd.sancov.raw\",\n-                    coverage_dir, internal_getpid());\n-  pc_fd = OpenFile(path.data(), RdWr);\n-  if (pc_fd == kInvalidFd) {\n-    Report(\"Coverage: failed to open %s for reading/writing\\n\", path.data());\n-    Die();\n-  }\n-\n-  pc_array_mapped_size = 0;\n-  CovUpdateMapping(coverage_dir);\n-}\n-\n-void CoverageData::Init() {\n-  pc_fd = kInvalidFd;\n-}\n-\n-void CoverageData::Enable() {\n-  if (pc_array)\n-    return;\n-  pc_array = reinterpret_cast<uptr *>(\n-      MmapNoReserveOrDie(sizeof(uptr) * kPcArrayMaxSize, \"CovInit\"));\n-  atomic_store(&pc_array_index, 0, memory_order_relaxed);\n-  if (common_flags()->coverage_direct) {\n-    atomic_store(&pc_array_size, 0, memory_order_relaxed);\n-  } else {\n-    atomic_store(&pc_array_size, kPcArrayMaxSize, memory_order_relaxed);\n-  }\n-\n-  cc_array = reinterpret_cast<uptr **>(MmapNoReserveOrDie(\n-      sizeof(uptr *) * kCcArrayMaxSize, \"CovInit::cc_array\"));\n-  atomic_store(&cc_array_size, kCcArrayMaxSize, memory_order_relaxed);\n-  atomic_store(&cc_array_index, 0, memory_order_relaxed);\n-\n-  // Allocate tr_event_array with a guard page at the end.\n-  tr_event_array = reinterpret_cast<u32 *>(MmapNoReserveOrDie(\n-      sizeof(tr_event_array[0]) * kTrEventArrayMaxSize + GetMmapGranularity(),\n-      \"CovInit::tr_event_array\"));\n-  MprotectNoAccess(\n-      reinterpret_cast<uptr>(&tr_event_array[kTrEventArrayMaxSize]),\n-      GetMmapGranularity());\n-  tr_event_array_size = kTrEventArrayMaxSize;\n-  tr_event_pointer = tr_event_array;\n-\n-  num_8bit_counters = 0;\n-}\n-\n-void CoverageData::InitializeGuardArray(s32 *guards) {\n-  Enable();  // Make sure coverage is enabled at this point.\n-  s32 n = guards[0];\n-  for (s32 j = 1; j <= n; j++) {\n-    uptr idx = atomic_load_relaxed(&pc_array_index);\n-    atomic_store_relaxed(&pc_array_index, idx + 1);\n-    guards[j] = -static_cast<s32>(idx + 1);\n-  }\n-}\n-\n-void CoverageData::Disable() {\n-  if (pc_array) {\n-    UnmapOrDie(pc_array, sizeof(uptr) * kPcArrayMaxSize);\n-    pc_array = nullptr;\n-  }\n-  if (cc_array) {\n-    UnmapOrDie(cc_array, sizeof(uptr *) * kCcArrayMaxSize);\n-    cc_array = nullptr;\n-  }\n-  if (tr_event_array) {\n-    UnmapOrDie(tr_event_array,\n-               sizeof(tr_event_array[0]) * kTrEventArrayMaxSize +\n-                   GetMmapGranularity());\n-    tr_event_array = nullptr;\n-    tr_event_pointer = nullptr;\n-  }\n-  if (pc_fd != kInvalidFd) {\n-    CloseFile(pc_fd);\n-    pc_fd = kInvalidFd;\n-  }\n-}\n-\n-void CoverageData::ReinitializeGuards() {\n-  // Assuming single thread.\n-  atomic_store(&pc_array_index, 0, memory_order_relaxed);\n-  for (uptr i = 0; i < guard_array_vec.size(); i++)\n-    InitializeGuardArray(guard_array_vec[i]);\n-}\n-\n-void CoverageData::ReInit() {\n-  Disable();\n-  if (coverage_enabled) {\n-    if (common_flags()->coverage_direct) {\n-      // In memory-mapped mode we must extend the new file to the known array\n-      // size.\n-      uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n-      uptr npcs = size / sizeof(uptr);\n-      Enable();\n-      if (size) Extend(npcs);\n-      if (coverage_enabled) CovUpdateMapping(coverage_dir);\n-    } else {\n-      Enable();\n-    }\n-  }\n-  // Re-initialize the guards.\n-  // We are single-threaded now, no need to grab any lock.\n-  CHECK_EQ(atomic_load(&pc_array_index, memory_order_relaxed), 0);\n-  ReinitializeGuards();\n-}\n-\n-void CoverageData::BeforeFork() {\n-  mu.Lock();\n-}\n-\n-void CoverageData::AfterFork(int child_pid) {\n-  // We are single-threaded so it's OK to release the lock early.\n-  mu.Unlock();\n-  if (child_pid == 0) ReInit();\n-}\n-\n-// Extend coverage PC array to fit additional npcs elements.\n-void CoverageData::Extend(uptr npcs) {\n-  if (!common_flags()->coverage_direct) return;\n-  SpinMutexLock l(&mu);\n-\n-  uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n-  size += npcs * sizeof(uptr);\n-\n-  if (coverage_enabled && size > pc_array_mapped_size) {\n-    if (pc_fd == kInvalidFd) DirectOpen();\n-    CHECK_NE(pc_fd, kInvalidFd);\n-\n-    uptr new_mapped_size = pc_array_mapped_size;\n-    while (size > new_mapped_size) new_mapped_size += kPcArrayMmapSize;\n-    CHECK_LE(new_mapped_size, sizeof(uptr) * kPcArrayMaxSize);\n-\n-    // Extend the file and map the new space at the end of pc_array.\n-    uptr res = internal_ftruncate(pc_fd, new_mapped_size);\n-    int err;\n-    if (internal_iserror(res, &err)) {\n-      Printf(\"failed to extend raw coverage file: %d\\n\", err);\n-      Die();\n-    }\n-\n-    uptr next_map_base = ((uptr)pc_array) + pc_array_mapped_size;\n-    void *p = MapWritableFileToMemory((void *)next_map_base,\n-                                      new_mapped_size - pc_array_mapped_size,\n-                                      pc_fd, pc_array_mapped_size);\n-    CHECK_EQ((uptr)p, next_map_base);\n-    pc_array_mapped_size = new_mapped_size;\n-  }\n-\n-  atomic_store(&pc_array_size, size, memory_order_release);\n-}\n-\n-void CoverageData::InitializeCounters(u8 *counters, uptr n) {\n-  if (!counters) return;\n-  CHECK_EQ(reinterpret_cast<uptr>(counters) % 16, 0);\n-  n = RoundUpTo(n, 16); // The compiler must ensure that counters is 16-aligned.\n-  SpinMutexLock l(&mu);\n-  counters_vec.push_back({counters, n});\n-  num_8bit_counters += n;\n-}\n-\n-void CoverageData::UpdateModuleNameVec(uptr caller_pc, uptr range_beg,\n-                                       uptr range_end) {\n-  auto sym = Symbolizer::GetOrInit();\n-  if (!sym)\n-    return;\n-  const char *module_name = sym->GetModuleNameForPc(caller_pc);\n-  if (!module_name) return;\n-  if (module_name_vec.empty() ||\n-      module_name_vec.back().copied_module_name != module_name)\n-    module_name_vec.push_back({module_name, range_beg, range_end});\n-  else\n-    module_name_vec.back().end = range_end;\n-}\n-\n-void CoverageData::InitializeGuards(s32 *guards, uptr n,\n-                                    const char *comp_unit_name,\n-                                    uptr caller_pc) {\n-  // The array 'guards' has n+1 elements, we use the element zero\n-  // to store 'n'.\n-  CHECK_LT(n, 1 << 30);\n-  guards[0] = static_cast<s32>(n);\n-  InitializeGuardArray(guards);\n-  SpinMutexLock l(&mu);\n-  uptr range_end = atomic_load(&pc_array_index, memory_order_relaxed);\n-  uptr range_beg = range_end - n;\n-  comp_unit_name_vec.push_back({comp_unit_name, range_beg, range_end});\n-  guard_array_vec.push_back(guards);\n-  UpdateModuleNameVec(caller_pc, range_beg, range_end);\n-}\n-\n-static const uptr kBundleCounterBits = 16;\n-\n-// When coverage_order_pcs==true and SANITIZER_WORDSIZE==64\n-// we insert the global counter into the first 16 bits of the PC.\n-uptr BundlePcAndCounter(uptr pc, uptr counter) {\n-  if (SANITIZER_WORDSIZE != 64 || !common_flags()->coverage_order_pcs)\n-    return pc;\n-  static const uptr kMaxCounter = (1 << kBundleCounterBits) - 1;\n-  if (counter > kMaxCounter)\n-    counter = kMaxCounter;\n-  CHECK_EQ(0, pc >> (SANITIZER_WORDSIZE - kBundleCounterBits));\n-  return pc | (counter << (SANITIZER_WORDSIZE - kBundleCounterBits));\n-}\n-\n-uptr UnbundlePc(uptr bundle) {\n-  if (SANITIZER_WORDSIZE != 64 || !common_flags()->coverage_order_pcs)\n-    return bundle;\n-  return (bundle << kBundleCounterBits) >> kBundleCounterBits;\n-}\n-\n-uptr UnbundleCounter(uptr bundle) {\n-  if (SANITIZER_WORDSIZE != 64 || !common_flags()->coverage_order_pcs)\n-    return 0;\n-  return bundle >> (SANITIZER_WORDSIZE - kBundleCounterBits);\n-}\n-\n-// If guard is negative, atomically set it to -guard and store the PC in\n-// pc_array.\n-void CoverageData::Add(uptr pc, u32 *guard) {\n-  atomic_uint32_t *atomic_guard = reinterpret_cast<atomic_uint32_t*>(guard);\n-  s32 guard_value = atomic_load(atomic_guard, memory_order_relaxed);\n-  if (guard_value >= 0) return;\n-\n-  atomic_store(atomic_guard, -guard_value, memory_order_relaxed);\n-  if (!pc_array) return;\n-\n-  uptr idx = -guard_value - 1;\n-  if (idx >= atomic_load(&pc_array_index, memory_order_acquire))\n-    return;  // May happen after fork when pc_array_index becomes 0.\n-  CHECK_LT(idx * sizeof(uptr),\n-           atomic_load(&pc_array_size, memory_order_acquire));\n-  uptr counter = atomic_fetch_add(&coverage_counter, 1, memory_order_relaxed);\n-  pc_array[idx] = BundlePcAndCounter(pc, counter);\n-}\n-\n-// Registers a pair caller=>callee.\n-// When a given caller is seen for the first time, the callee_cache is added\n-// to the global array cc_array, callee_cache[0] is set to caller and\n-// callee_cache[1] is set to cache_size.\n-// Then we are trying to add callee to callee_cache [2,cache_size) if it is\n-// not there yet.\n-// If the cache is full we drop the callee (may want to fix this later).\n-void CoverageData::IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n-                             uptr cache_size) {\n-  if (!cc_array) return;\n-  atomic_uintptr_t *atomic_callee_cache =\n-      reinterpret_cast<atomic_uintptr_t *>(callee_cache);\n-  uptr zero = 0;\n-  if (atomic_compare_exchange_strong(&atomic_callee_cache[0], &zero, caller,\n-                                     memory_order_seq_cst)) {\n-    uptr idx = atomic_fetch_add(&cc_array_index, 1, memory_order_relaxed);\n-    CHECK_LT(idx * sizeof(uptr),\n-             atomic_load(&cc_array_size, memory_order_acquire));\n-    callee_cache[1] = cache_size;\n-    cc_array[idx] = callee_cache;\n-  }\n-  CHECK_EQ(atomic_load(&atomic_callee_cache[0], memory_order_relaxed), caller);\n-  for (uptr i = 2; i < cache_size; i++) {\n-    uptr was = 0;\n-    if (atomic_compare_exchange_strong(&atomic_callee_cache[i], &was, callee,\n-                                       memory_order_seq_cst)) {\n-      atomic_fetch_add(&caller_callee_counter, 1, memory_order_relaxed);\n-      return;\n-    }\n-    if (was == callee)  // Already have this callee.\n-      return;\n-  }\n-}\n-\n-uptr CoverageData::GetNumberOf8bitCounters() {\n-  return num_8bit_counters;\n-}\n-\n-// Map every 8bit counter to a 8-bit bitset and clear the counter.\n-uptr CoverageData::Update8bitCounterBitsetAndClearCounters(u8 *bitset) {\n-  uptr num_new_bits = 0;\n-  uptr cur = 0;\n-  // For better speed we map 8 counters to 8 bytes of bitset at once.\n-  static const uptr kBatchSize = 8;\n-  CHECK_EQ(reinterpret_cast<uptr>(bitset) % kBatchSize, 0);\n-  for (uptr i = 0, len = counters_vec.size(); i < len; i++) {\n-    u8 *c = counters_vec[i].counters;\n-    uptr n = counters_vec[i].n;\n-    CHECK_EQ(n % 16, 0);\n-    CHECK_EQ(cur % kBatchSize, 0);\n-    CHECK_EQ(reinterpret_cast<uptr>(c) % kBatchSize, 0);\n-    if (!bitset) {\n-      internal_bzero_aligned16(c, n);\n-      cur += n;\n-      continue;\n-    }\n-    for (uptr j = 0; j < n; j += kBatchSize, cur += kBatchSize) {\n-      CHECK_LT(cur, num_8bit_counters);\n-      u64 *pc64 = reinterpret_cast<u64*>(c + j);\n-      u64 *pb64 = reinterpret_cast<u64*>(bitset + cur);\n-      u64 c64 = *pc64;\n-      u64 old_bits_64 = *pb64;\n-      u64 new_bits_64 = old_bits_64;\n-      if (c64) {\n-        *pc64 = 0;\n-        for (uptr k = 0; k < kBatchSize; k++) {\n-          u64 x = (c64 >> (8 * k)) & 0xff;\n-          if (x) {\n-            u64 bit = 0;\n-            /**/ if (x >= 128) bit = 128;\n-            else if (x >= 32) bit = 64;\n-            else if (x >= 16) bit = 32;\n-            else if (x >= 8) bit = 16;\n-            else if (x >= 4) bit = 8;\n-            else if (x >= 3) bit = 4;\n-            else if (x >= 2) bit = 2;\n-            else if (x >= 1) bit = 1;\n-            u64 mask = bit << (8 * k);\n-            if (!(new_bits_64 & mask)) {\n-              num_new_bits++;\n-              new_bits_64 |= mask;\n-            }\n-          }\n-        }\n-        *pb64 = new_bits_64;\n-      }\n-    }\n-  }\n-  CHECK_EQ(cur, num_8bit_counters);\n-  return num_new_bits;\n-}\n-\n-uptr *CoverageData::data() {\n-  return pc_array;\n-}\n-\n-uptr CoverageData::size() const {\n-  return atomic_load(&pc_array_index, memory_order_relaxed);\n-}\n-\n-// Block layout for packed file format: header, followed by module name (no\n-// trailing zero), followed by data blob.\n-struct CovHeader {\n-  int pid;\n-  unsigned int module_name_length;\n-  unsigned int data_length;\n-};\n-\n-static void CovWritePacked(int pid, const char *module, const void *blob,\n-                           unsigned int blob_size) {\n-  if (cov_fd == kInvalidFd) return;\n-  unsigned module_name_length = internal_strlen(module);\n-  CovHeader header = {pid, module_name_length, blob_size};\n-\n-  if (cov_max_block_size == 0) {\n-    // Writing to a file. Just go ahead.\n-    WriteToFile(cov_fd, &header, sizeof(header));\n-    WriteToFile(cov_fd, module, module_name_length);\n-    WriteToFile(cov_fd, blob, blob_size);\n-  } else {\n-    // Writing to a socket. We want to split the data into appropriately sized\n-    // blocks.\n-    InternalScopedBuffer<char> block(cov_max_block_size);\n-    CHECK_EQ((uptr)block.data(), (uptr)(CovHeader *)block.data());\n-    uptr header_size_with_module = sizeof(header) + module_name_length;\n-    CHECK_LT(header_size_with_module, cov_max_block_size);\n-    unsigned int max_payload_size =\n-        cov_max_block_size - header_size_with_module;\n-    char *block_pos = block.data();\n-    internal_memcpy(block_pos, &header, sizeof(header));\n-    block_pos += sizeof(header);\n-    internal_memcpy(block_pos, module, module_name_length);\n-    block_pos += module_name_length;\n-    char *block_data_begin = block_pos;\n-    const char *blob_pos = (const char *)blob;\n-    while (blob_size > 0) {\n-      unsigned int payload_size = Min(blob_size, max_payload_size);\n-      blob_size -= payload_size;\n-      internal_memcpy(block_data_begin, blob_pos, payload_size);\n-      blob_pos += payload_size;\n-      ((CovHeader *)block.data())->data_length = payload_size;\n-      WriteToFile(cov_fd, block.data(), header_size_with_module + payload_size);\n-    }\n-  }\n-}\n-\n-// If packed = false: <name>.<pid>.<sancov> (name = module name).\n-// If packed = true and name == 0: <pid>.<sancov>.<packed>.\n-// If packed = true and name != 0: <name>.<sancov>.<packed> (name is\n-// user-supplied).\n-static fd_t CovOpenFile(InternalScopedString *path, bool packed,\n-                       const char *name, const char *extension = \"sancov\") {\n-  path->clear();\n-  if (!packed) {\n-    CHECK(name);\n-    path->append(\"%s/%s.%zd.%s\", coverage_dir, name, internal_getpid(),\n-                extension);\n-  } else {\n-    if (!name)\n-      path->append(\"%s/%zd.%s.packed\", coverage_dir, internal_getpid(),\n-                  extension);\n-    else\n-      path->append(\"%s/%s.%s.packed\", coverage_dir, name, extension);\n-  }\n-  error_t err;\n-  fd_t fd = OpenFile(path->data(), WrOnly, &err);\n-  if (fd == kInvalidFd)\n-    Report(\"SanitizerCoverage: failed to open %s for writing (reason: %d)\\n\",\n-           path->data(), err);\n-  return fd;\n-}\n-\n-// Dump trace PCs and trace events into two separate files.\n-void CoverageData::DumpTrace() {\n-  uptr max_idx = tr_event_pointer - tr_event_array;\n-  if (!max_idx) return;\n-  auto sym = Symbolizer::GetOrInit();\n-  if (!sym)\n-    return;\n-  InternalScopedString out(32 << 20);\n-  for (uptr i = 0, n = size(); i < n; i++) {\n-    const char *module_name = \"<unknown>\";\n-    uptr module_address = 0;\n-    sym->GetModuleNameAndOffsetForPC(UnbundlePc(pc_array[i]), &module_name,\n-                                     &module_address);\n-    out.append(\"%s 0x%zx\\n\", module_name, module_address);\n-  }\n-  InternalScopedString path(kMaxPathLength);\n-  fd_t fd = CovOpenFile(&path, false, \"trace-points\");\n-  if (fd == kInvalidFd) return;\n-  WriteToFile(fd, out.data(), out.length());\n-  CloseFile(fd);\n-\n-  fd = CovOpenFile(&path, false, \"trace-compunits\");\n-  if (fd == kInvalidFd) return;\n-  out.clear();\n-  for (uptr i = 0; i < comp_unit_name_vec.size(); i++)\n-    out.append(\"%s\\n\", comp_unit_name_vec[i].copied_module_name);\n-  WriteToFile(fd, out.data(), out.length());\n-  CloseFile(fd);\n-\n-  fd = CovOpenFile(&path, false, \"trace-events\");\n-  if (fd == kInvalidFd) return;\n-  uptr bytes_to_write = max_idx * sizeof(tr_event_array[0]);\n-  u8 *event_bytes = reinterpret_cast<u8*>(tr_event_array);\n-  // The trace file could be huge, and may not be written with a single syscall.\n-  while (bytes_to_write) {\n-    uptr actually_written;\n-    if (WriteToFile(fd, event_bytes, bytes_to_write, &actually_written) &&\n-        actually_written <= bytes_to_write) {\n-      bytes_to_write -= actually_written;\n-      event_bytes += actually_written;\n-    } else {\n-      break;\n-    }\n-  }\n-  CloseFile(fd);\n-  VReport(1, \" CovDump: Trace: %zd PCs written\\n\", size());\n-  VReport(1, \" CovDump: Trace: %zd Events written\\n\", max_idx);\n-}\n-\n-// This function dumps the caller=>callee pairs into a file as a sequence of\n-// lines like \"module_name offset\".\n-void CoverageData::DumpCallerCalleePairs() {\n-  uptr max_idx = atomic_load(&cc_array_index, memory_order_relaxed);\n-  if (!max_idx) return;\n-  auto sym = Symbolizer::GetOrInit();\n-  if (!sym)\n-    return;\n-  InternalScopedString out(32 << 20);\n-  uptr total = 0;\n-  for (uptr i = 0; i < max_idx; i++) {\n-    uptr *cc_cache = cc_array[i];\n-    CHECK(cc_cache);\n-    uptr caller = cc_cache[0];\n-    uptr n_callees = cc_cache[1];\n-    const char *caller_module_name = \"<unknown>\";\n-    uptr caller_module_address = 0;\n-    sym->GetModuleNameAndOffsetForPC(caller, &caller_module_name,\n-                                     &caller_module_address);\n-    for (uptr j = 2; j < n_callees; j++) {\n-      uptr callee = cc_cache[j];\n-      if (!callee) break;\n-      total++;\n-      const char *callee_module_name = \"<unknown>\";\n-      uptr callee_module_address = 0;\n-      sym->GetModuleNameAndOffsetForPC(callee, &callee_module_name,\n-                                       &callee_module_address);\n-      out.append(\"%s 0x%zx\\n%s 0x%zx\\n\", caller_module_name,\n-                 caller_module_address, callee_module_name,\n-                 callee_module_address);\n-    }\n-  }\n-  InternalScopedString path(kMaxPathLength);\n-  fd_t fd = CovOpenFile(&path, false, \"caller-callee\");\n-  if (fd == kInvalidFd) return;\n-  WriteToFile(fd, out.data(), out.length());\n-  CloseFile(fd);\n-  VReport(1, \" CovDump: %zd caller-callee pairs written\\n\", total);\n-}\n-\n-// Record the current PC into the event buffer.\n-// Every event is a u32 value (index in tr_pc_array_index) so we compute\n-// it once and then cache in the provided 'cache' storage.\n-//\n-// This function will eventually be inlined by the compiler.\n-void CoverageData::TraceBasicBlock(u32 *id) {\n-  // Will trap here if\n-  //  1. coverage is not enabled at run-time.\n-  //  2. The array tr_event_array is full.\n-  *tr_event_pointer = *id - 1;\n-  tr_event_pointer++;\n-}\n-\n-void CoverageData::DumpCounters() {\n-  if (!common_flags()->coverage_counters) return;\n-  uptr n = coverage_data.GetNumberOf8bitCounters();\n-  if (!n) return;\n-  InternalScopedBuffer<u8> bitset(n);\n-  coverage_data.Update8bitCounterBitsetAndClearCounters(bitset.data());\n-  InternalScopedString path(kMaxPathLength);\n-\n-  for (uptr m = 0; m < module_name_vec.size(); m++) {\n-    auto r = module_name_vec[m];\n-    CHECK(r.copied_module_name);\n-    CHECK_LE(r.beg, r.end);\n-    CHECK_LE(r.end, size());\n-    const char *base_name = StripModuleName(r.copied_module_name);\n-    fd_t fd =\n-        CovOpenFile(&path, /* packed */ false, base_name, \"counters-sancov\");\n-    if (fd == kInvalidFd) return;\n-    WriteToFile(fd, bitset.data() + r.beg, r.end - r.beg);\n-    CloseFile(fd);\n-    VReport(1, \" CovDump: %zd counters written for '%s'\\n\", r.end - r.beg,\n-            base_name);\n-  }\n-}\n-\n-void CoverageData::DumpAsBitSet() {\n-  if (!common_flags()->coverage_bitset) return;\n-  if (!size()) return;\n-  InternalScopedBuffer<char> out(size());\n-  InternalScopedString path(kMaxPathLength);\n-  for (uptr m = 0; m < module_name_vec.size(); m++) {\n-    uptr n_set_bits = 0;\n-    auto r = module_name_vec[m];\n-    CHECK(r.copied_module_name);\n-    CHECK_LE(r.beg, r.end);\n-    CHECK_LE(r.end, size());\n-    for (uptr i = r.beg; i < r.end; i++) {\n-      uptr pc = UnbundlePc(pc_array[i]);\n-      out[i] = pc ? '1' : '0';\n-      if (pc)\n-        n_set_bits++;\n-    }\n-    const char *base_name = StripModuleName(r.copied_module_name);\n-    fd_t fd = CovOpenFile(&path, /* packed */false, base_name, \"bitset-sancov\");\n-    if (fd == kInvalidFd) return;\n-    WriteToFile(fd, out.data() + r.beg, r.end - r.beg);\n-    CloseFile(fd);\n-    VReport(1,\n-            \" CovDump: bitset of %zd bits written for '%s', %zd bits are set\\n\",\n-            r.end - r.beg, base_name, n_set_bits);\n-  }\n-}\n-\n-\n-void CoverageData::GetRangeOffsets(const NamedPcRange& r, Symbolizer* sym,\n-    InternalMmapVector<uptr>* offsets) const {\n-  offsets->clear();\n-  for (uptr i = 0; i < kNumWordsForMagic; i++)\n-    offsets->push_back(0);\n-  CHECK(r.copied_module_name);\n-  CHECK_LE(r.beg, r.end);\n-  CHECK_LE(r.end, size());\n-  for (uptr i = r.beg; i < r.end; i++) {\n-    uptr pc = UnbundlePc(pc_array[i]);\n-    uptr counter = UnbundleCounter(pc_array[i]);\n-    if (!pc) continue; // Not visited.\n-    uptr offset = 0;\n-    sym->GetModuleNameAndOffsetForPC(pc, nullptr, &offset);\n-    offsets->push_back(BundlePcAndCounter(offset, counter));\n-  }\n-\n-  CHECK_GE(offsets->size(), kNumWordsForMagic);\n-  SortArray(offsets->data(), offsets->size());\n-  for (uptr i = 0; i < offsets->size(); i++)\n-    (*offsets)[i] = UnbundlePc((*offsets)[i]);\n-}\n-\n-static void GenerateHtmlReport(const InternalMmapVector<char *> &cov_files) {\n-  if (!common_flags()->html_cov_report) {\n-    return;\n-  }\n-  char *sancov_path = FindPathToBinary(common_flags()->sancov_path);\n-  if (sancov_path == nullptr) {\n-    return;\n-  }\n-\n-  InternalMmapVector<char *> sancov_argv(cov_files.size() * 2 + 3);\n-  sancov_argv.push_back(sancov_path);\n-  sancov_argv.push_back(internal_strdup(\"-html-report\"));\n-  auto argv_deleter = at_scope_exit([&] {\n-    for (uptr i = 0; i < sancov_argv.size(); ++i) {\n-      InternalFree(sancov_argv[i]);\n-    }\n-  });\n-\n-  for (const auto &cov_file : cov_files) {\n-    sancov_argv.push_back(internal_strdup(cov_file));\n-  }\n-\n-  {\n-    ListOfModules modules;\n-    modules.init();\n-    for (const LoadedModule &module : modules) {\n-      sancov_argv.push_back(internal_strdup(module.full_name()));\n-    }\n-  }\n-\n-  InternalScopedString report_path(kMaxPathLength);\n-  fd_t report_fd =\n-      CovOpenFile(&report_path, false /* packed */, GetProcessName(), \"html\");\n-  int pid = StartSubprocess(sancov_argv[0], sancov_argv.data(),\n-                            kInvalidFd /* stdin */, report_fd /* std_out */);\n-  if (pid > 0) {\n-    int result = WaitForProcess(pid);\n-    if (result == 0)\n-      Printf(\"coverage report generated to %s\\n\", report_path.data());\n-  }\n-}\n-\n-void CoverageData::DumpOffsets() {\n-  auto sym = Symbolizer::GetOrInit();\n-  if (!common_flags()->coverage_pcs) return;\n-  CHECK_NE(sym, nullptr);\n-  InternalMmapVector<uptr> offsets(0);\n-  InternalScopedString path(kMaxPathLength);\n-\n-  InternalMmapVector<char *> cov_files(module_name_vec.size());\n-  auto cov_files_deleter = at_scope_exit([&] {\n-    for (uptr i = 0; i < cov_files.size(); ++i) {\n-      InternalFree(cov_files[i]);\n-    }\n-  });\n-\n-  for (uptr m = 0; m < module_name_vec.size(); m++) {\n-    auto r = module_name_vec[m];\n-    GetRangeOffsets(r, sym, &offsets);\n-\n-    uptr num_offsets = offsets.size() - kNumWordsForMagic;\n-    u64 *magic_p = reinterpret_cast<u64*>(offsets.data());\n-    CHECK_EQ(*magic_p, 0ULL);\n-    // FIXME: we may want to write 32-bit offsets even in 64-mode\n-    // if all the offsets are small enough.\n-    *magic_p = kMagic;\n-\n-    const char *module_name = StripModuleName(r.copied_module_name);\n-    if (cov_sandboxed) {\n-      if (cov_fd != kInvalidFd) {\n-        CovWritePacked(internal_getpid(), module_name, offsets.data(),\n-                       offsets.size() * sizeof(offsets[0]));\n-        VReport(1, \" CovDump: %zd PCs written to packed file\\n\", num_offsets);\n-      }\n-    } else {\n-      // One file per module per process.\n-      fd_t fd = CovOpenFile(&path, false /* packed */, module_name);\n-      if (fd == kInvalidFd) continue;\n-      WriteToFile(fd, offsets.data(), offsets.size() * sizeof(offsets[0]));\n-      CloseFile(fd);\n-      cov_files.push_back(internal_strdup(path.data()));\n-      VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(), num_offsets);\n-    }\n-  }\n-  if (cov_fd != kInvalidFd)\n-    CloseFile(cov_fd);\n-\n-  GenerateHtmlReport(cov_files);\n-}\n-\n-void CoverageData::DumpAll() {\n-  if (!coverage_enabled || common_flags()->coverage_direct) return;\n-  if (atomic_fetch_add(&dump_once_guard, 1, memory_order_relaxed))\n-    return;\n-  DumpAsBitSet();\n-  DumpCounters();\n-  DumpTrace();\n-  DumpOffsets();\n-  DumpCallerCalleePairs();\n-}\n-\n-void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n-  if (!args) return;\n-  if (!coverage_enabled) return;\n-  cov_sandboxed = args->coverage_sandboxed;\n-  if (!cov_sandboxed) return;\n-  cov_max_block_size = args->coverage_max_block_size;\n-  if (args->coverage_fd >= 0) {\n-    cov_fd = (fd_t)args->coverage_fd;\n-  } else {\n-    InternalScopedString path(kMaxPathLength);\n-    // Pre-open the file now. The sandbox won't allow us to do it later.\n-    cov_fd = CovOpenFile(&path, true /* packed */, nullptr);\n-  }\n-}\n-\n-fd_t MaybeOpenCovFile(const char *name) {\n-  CHECK(name);\n-  if (!coverage_enabled) return kInvalidFd;\n-  InternalScopedString path(kMaxPathLength);\n-  return CovOpenFile(&path, true /* packed */, name);\n-}\n-\n-void CovBeforeFork() {\n-  coverage_data.BeforeFork();\n-}\n-\n-void CovAfterFork(int child_pid) {\n-  coverage_data.AfterFork(child_pid);\n-}\n-\n-static void MaybeDumpCoverage() {\n-  if (common_flags()->coverage)\n-    __sanitizer_cov_dump();\n-}\n-\n-void InitializeCoverage(bool enabled, const char *dir) {\n-  if (coverage_enabled)\n-    return;  // May happen if two sanitizer enable coverage in the same process.\n-  coverage_enabled = enabled;\n-  coverage_dir = dir;\n-  coverage_data.Init();\n-  if (enabled) coverage_data.Enable();\n-  if (!common_flags()->coverage_direct) Atexit(__sanitizer_cov_dump);\n-  AddDieCallback(MaybeDumpCoverage);\n-}\n-\n-void ReInitializeCoverage(bool enabled, const char *dir) {\n-  coverage_enabled = enabled;\n-  coverage_dir = dir;\n-  coverage_data.ReInit();\n-}\n-\n-void CoverageUpdateMapping() {\n-  if (coverage_enabled)\n-    CovUpdateMapping(coverage_dir);\n-}\n-\n-} // namespace __sanitizer\n-\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(u32 *guard) {\n-  coverage_data.Add(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()),\n-                    guard);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_with_check(u32 *guard) {\n-  atomic_uint32_t *atomic_guard = reinterpret_cast<atomic_uint32_t*>(guard);\n-  if (static_cast<s32>(\n-          __sanitizer::atomic_load(atomic_guard, memory_order_relaxed)) < 0)\n-    __sanitizer_cov(guard);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE void\n-__sanitizer_cov_indir_call16(uptr callee, uptr callee_cache16[]) {\n-  coverage_data.IndirCall(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()),\n-                          callee, callee_cache16, 16);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init() {\n-  coverage_enabled = true;\n-  coverage_dir = common_flags()->coverage_dir;\n-  coverage_data.Init();\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() {\n-  coverage_data.DumpAll();\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE void\n-__sanitizer_cov_module_init(s32 *guards, uptr npcs, u8 *counters,\n-                            const char *comp_unit_name) {\n-  coverage_data.InitializeGuards(guards, npcs, comp_unit_name, GET_CALLER_PC());\n-  coverage_data.InitializeCounters(counters, npcs);\n-  if (!common_flags()->coverage_direct) return;\n-  if (SANITIZER_ANDROID && coverage_enabled) {\n-    // dlopen/dlclose interceptors do not work on Android, so we rely on\n-    // Extend() calls to update .sancov.map.\n-    CovUpdateMapping(coverage_dir, GET_CALLER_PC());\n-  }\n-  coverage_data.Extend(npcs);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE\n-sptr __sanitizer_maybe_open_cov_file(const char *name) {\n-  return (sptr)MaybeOpenCovFile(name);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE\n-uptr __sanitizer_get_total_unique_coverage() {\n-  return atomic_load(&coverage_counter, memory_order_relaxed);\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-uptr __sanitizer_get_total_unique_caller_callee_pairs() {\n-  return atomic_load(&caller_callee_counter, memory_order_relaxed);\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_cov_trace_func_enter(u32 *id) {\n-  __sanitizer_cov_with_check(id);\n-  coverage_data.TraceBasicBlock(id);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_cov_trace_basic_block(u32 *id) {\n-  __sanitizer_cov_with_check(id);\n-  coverage_data.TraceBasicBlock(id);\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_reset_coverage() {\n-  ResetGlobalCounters();\n-  coverage_data.ReinitializeGuards();\n-  internal_bzero_aligned16(\n-      coverage_data.data(),\n-      RoundUpTo(coverage_data.size() * sizeof(coverage_data.data()[0]), 16));\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE\n-uptr __sanitizer_get_coverage_guards(uptr **data) {\n-  *data = coverage_data.data();\n-  return coverage_data.size();\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-uptr __sanitizer_get_number_of_counters() {\n-  return coverage_data.GetNumberOf8bitCounters();\n-}\n-\n-SANITIZER_INTERFACE_ATTRIBUTE\n-uptr __sanitizer_update_counter_bitset_and_clear_counters(u8 *bitset) {\n-  return coverage_data.Update8bitCounterBitsetAndClearCounters(bitset);\n-}\n-// Default empty implementations (weak). Users should redefine them.\n-#if !SANITIZER_WINDOWS  // weak does not work on Windows.\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_cmp() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_cmp1() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_cmp2() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_cmp4() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_cmp8() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_switch() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_div4() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_div8() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_gep() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_pc_guard() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_pc_indir() {}\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __sanitizer_cov_trace_pc_guard_init() {}\n-#endif  // !SANITIZER_WINDOWS\n-} // extern \"C\""}, {"sha": "25a5001bd3e9a8d07dd8d1a63a25039da49823ee", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cc", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,218 @@\n+//===-- sanitizer_coverage_libcdep_new.cc ---------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// Sanitizer Coverage Controller for Trace PC Guard.\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if !SANITIZER_FUCHSIA\n+#include \"sancov_flags.h\"\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_file.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+using namespace __sanitizer;\n+\n+using AddressRange = LoadedModule::AddressRange;\n+\n+namespace __sancov {\n+namespace {\n+\n+static const u64 Magic64 = 0xC0BFFFFFFFFFFF64ULL;\n+static const u64 Magic32 = 0xC0BFFFFFFFFFFF32ULL;\n+static const u64 Magic = SANITIZER_WORDSIZE == 64 ? Magic64 : Magic32;\n+\n+static fd_t OpenFile(const char* path) {\n+  error_t err;\n+  fd_t fd = OpenFile(path, WrOnly, &err);\n+  if (fd == kInvalidFd)\n+    Report(\"SanitizerCoverage: failed to open %s for writing (reason: %d)\\n\",\n+           path, err);\n+  return fd;\n+}\n+\n+static void GetCoverageFilename(char* path, const char* name,\n+                                const char* extension) {\n+  CHECK(name);\n+  internal_snprintf(path, kMaxPathLength, \"%s/%s.%zd.%s\",\n+                    common_flags()->coverage_dir, name, internal_getpid(),\n+                    extension);\n+}\n+\n+static void WriteModuleCoverage(char* file_path, const char* module_name,\n+                                const uptr* pcs, uptr len) {\n+  GetCoverageFilename(file_path, StripModuleName(module_name), \"sancov\");\n+  fd_t fd = OpenFile(file_path);\n+  WriteToFile(fd, &Magic, sizeof(Magic));\n+  WriteToFile(fd, pcs, len * sizeof(*pcs));\n+  CloseFile(fd);\n+  Printf(\"SanitizerCoverage: %s: %zd PCs written\\n\", file_path, len);\n+}\n+\n+static void SanitizerDumpCoverage(const uptr* unsorted_pcs, uptr len) {\n+  if (!len) return;\n+\n+  char* file_path = static_cast<char*>(InternalAlloc(kMaxPathLength));\n+  char* module_name = static_cast<char*>(InternalAlloc(kMaxPathLength));\n+  uptr* pcs = static_cast<uptr*>(InternalAlloc(len * sizeof(uptr)));\n+\n+  internal_memcpy(pcs, unsorted_pcs, len * sizeof(uptr));\n+  SortArray(pcs, len);\n+\n+  bool module_found = false;\n+  uptr last_base = 0;\n+  uptr module_start_idx = 0;\n+\n+  for (uptr i = 0; i < len; ++i) {\n+    const uptr pc = pcs[i];\n+    if (!pc) continue;\n+\n+    if (!__sanitizer_get_module_and_offset_for_pc(pc, nullptr, 0, &pcs[i])) {\n+      Printf(\"ERROR: unknown pc 0x%x (may happen if dlclose is used)\\n\", pc);\n+      continue;\n+    }\n+    uptr module_base = pc - pcs[i];\n+\n+    if (module_base != last_base || !module_found) {\n+      if (module_found) {\n+        WriteModuleCoverage(file_path, module_name, &pcs[module_start_idx],\n+                            i - module_start_idx);\n+      }\n+\n+      last_base = module_base;\n+      module_start_idx = i;\n+      module_found = true;\n+      __sanitizer_get_module_and_offset_for_pc(pc, module_name, kMaxPathLength,\n+                                               &pcs[i]);\n+    }\n+  }\n+\n+  if (module_found) {\n+    WriteModuleCoverage(file_path, module_name, &pcs[module_start_idx],\n+                        len - module_start_idx);\n+  }\n+\n+  InternalFree(file_path);\n+  InternalFree(module_name);\n+  InternalFree(pcs);\n+}\n+\n+// Collects trace-pc guard coverage.\n+// This class relies on zero-initialization.\n+class TracePcGuardController {\n+ public:\n+  void Initialize() {\n+    CHECK(!initialized);\n+\n+    initialized = true;\n+    InitializeSancovFlags();\n+\n+    pc_vector.Initialize(0);\n+  }\n+\n+  void InitTracePcGuard(u32* start, u32* end) {\n+    if (!initialized) Initialize();\n+    CHECK(!*start);\n+    CHECK_NE(start, end);\n+\n+    u32 i = pc_vector.size();\n+    for (u32* p = start; p < end; p++) *p = ++i;\n+    pc_vector.resize(i);\n+  }\n+\n+  void TracePcGuard(u32* guard, uptr pc) {\n+    u32 idx = *guard;\n+    if (!idx) return;\n+    // we start indices from 1.\n+    atomic_uintptr_t* pc_ptr =\n+        reinterpret_cast<atomic_uintptr_t*>(&pc_vector[idx - 1]);\n+    if (atomic_load(pc_ptr, memory_order_relaxed) == 0)\n+      atomic_store(pc_ptr, pc, memory_order_relaxed);\n+  }\n+\n+  void Reset() {\n+    internal_memset(&pc_vector[0], 0, sizeof(pc_vector[0]) * pc_vector.size());\n+  }\n+\n+  void Dump() {\n+    if (!initialized || !common_flags()->coverage) return;\n+    __sanitizer_dump_coverage(pc_vector.data(), pc_vector.size());\n+  }\n+\n+ private:\n+  bool initialized;\n+  InternalMmapVectorNoCtor<uptr> pc_vector;\n+};\n+\n+static TracePcGuardController pc_guard_controller;\n+\n+}  // namespace\n+}  // namespace __sancov\n+\n+namespace __sanitizer {\n+void InitializeCoverage(bool enabled, const char *dir) {\n+  static bool coverage_enabled = false;\n+  if (coverage_enabled)\n+    return;  // May happen if two sanitizer enable coverage in the same process.\n+  coverage_enabled = enabled;\n+  Atexit(__sanitizer_cov_dump);\n+  AddDieCallback(__sanitizer_cov_dump);\n+}\n+} // namespace __sanitizer\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(  // NOLINT\n+    const uptr* pcs, uptr len) {\n+  return __sancov::SanitizerDumpCoverage(pcs, len);\n+}\n+\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard, u32* guard) {\n+  if (!*guard) return;\n+  __sancov::pc_guard_controller.TracePcGuard(guard, GET_CALLER_PC() - 1);\n+}\n+\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard_init,\n+                             u32* start, u32* end) {\n+  if (start == end || *start) return;\n+  __sancov::pc_guard_controller.InitTracePcGuard(start, end);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_trace_pc_guard_coverage() {\n+  __sancov::pc_guard_controller.Dump();\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() {\n+  __sanitizer_dump_trace_pc_guard_coverage();\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_reset() {\n+  __sancov::pc_guard_controller.Reset();\n+}\n+// Default empty implementations (weak). Users should redefine them.\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp1, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp2, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp4, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_cmp8, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp1, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp2, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp4, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_const_cmp8, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_switch, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div4, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div8, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_gep, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_indir, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_8bit_counters_init, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_pcs_init, void) {}\n+}  // extern \"C\"\n+// Weak definition for code instrumented with -fsanitize-coverage=stack-depth\n+// and later linked with code containing a strong definition.\n+// E.g., -fsanitize=fuzzer-no-link\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+SANITIZER_TLS_INITIAL_EXEC_ATTRIBUTE uptr __sancov_lowest_stack;\n+\n+#endif  // !SANITIZER_FUCHSIA"}, {"sha": "b2e724ab221a8a3aa56d2c7ec15bde8f71a4fe4b", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_mapping_libcdep.cc", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93659712d9807d7ef01d472dc58119f4ac15cbad/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93659712d9807d7ef01d472dc58119f4ac15cbad/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc?ref=93659712d9807d7ef01d472dc58119f4ac15cbad", "patch": "@@ -1,120 +0,0 @@\n-//===-- sanitizer_coverage_mapping.cc -------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// Mmap-based implementation of sanitizer coverage.\n-//\n-// This is part of the implementation of code coverage that does not require\n-// __sanitizer_cov_dump() call. Data is stored in 2 files per process.\n-//\n-// $pid.sancov.map describes process memory layout in the following text-based\n-// format:\n-// <pointer size in bits>  // 1 line, 32 or 64\n-// <mapping start> <mapping end> <base address> <dso name> // repeated\n-// ...\n-// Mapping lines are NOT sorted. This file is updated every time memory layout\n-// is changed (i.e. in dlopen() and dlclose() interceptors).\n-//\n-// $pid.sancov.raw is a binary dump of PC values, sizeof(uptr) each. Again, not\n-// sorted. This file is extended by 64Kb at a time and mapped into memory. It\n-// contains one or more 0 words at the end, up to the next 64Kb aligned offset.\n-//\n-// To convert these 2 files to the usual .sancov format, run sancov.py rawunpack\n-// $pid.sancov.raw.\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_allocator_internal.h\"\n-#include \"sanitizer_libc.h\"\n-#include \"sanitizer_procmaps.h\"\n-\n-namespace __sanitizer {\n-\n-static const uptr kMaxTextSize = 64 * 1024;\n-\n-struct CachedMapping {\n- public:\n-  bool NeedsUpdate(uptr pc) {\n-    int new_pid = internal_getpid();\n-    if (last_pid == new_pid && pc && pc >= last_range_start &&\n-        pc < last_range_end)\n-      return false;\n-    last_pid = new_pid;\n-    return true;\n-  }\n-\n-  void SetModuleRange(uptr start, uptr end) {\n-    last_range_start = start;\n-    last_range_end = end;\n-  }\n-\n- private:\n-  uptr last_range_start, last_range_end;\n-  int last_pid;\n-};\n-\n-static CachedMapping cached_mapping;\n-static StaticSpinMutex mapping_mu;\n-\n-void CovUpdateMapping(const char *coverage_dir, uptr caller_pc) {\n-  if (!common_flags()->coverage_direct) return;\n-\n-  SpinMutexLock l(&mapping_mu);\n-\n-  if (!cached_mapping.NeedsUpdate(caller_pc))\n-    return;\n-\n-  InternalScopedString text(kMaxTextSize);\n-\n-  {\n-    text.append(\"%d\\n\", sizeof(uptr) * 8);\n-    ListOfModules modules;\n-    modules.init();\n-    for (const LoadedModule &module : modules) {\n-      const char *module_name = StripModuleName(module.full_name());\n-      uptr base = module.base_address();\n-      for (const auto &range : module.ranges()) {\n-        if (range.executable) {\n-          uptr start = range.beg;\n-          uptr end = range.end;\n-          text.append(\"%zx %zx %zx %s\\n\", start, end, base, module_name);\n-          if (caller_pc && caller_pc >= start && caller_pc < end)\n-            cached_mapping.SetModuleRange(start, end);\n-        }\n-      }\n-    }\n-  }\n-\n-  error_t err;\n-  InternalScopedString tmp_path(64 + internal_strlen(coverage_dir));\n-  uptr res = internal_snprintf((char *)tmp_path.data(), tmp_path.size(),\n-                               \"%s/%zd.sancov.map.tmp\", coverage_dir,\n-                               internal_getpid());\n-  CHECK_LE(res, tmp_path.size());\n-  fd_t map_fd = OpenFile(tmp_path.data(), WrOnly, &err);\n-  if (map_fd == kInvalidFd) {\n-    Report(\"Coverage: failed to open %s for writing: %d\\n\", tmp_path.data(),\n-           err);\n-    Die();\n-  }\n-\n-  if (!WriteToFile(map_fd, text.data(), text.length(), nullptr, &err)) {\n-    Printf(\"sancov.map write failed: %d\\n\", err);\n-    Die();\n-  }\n-  CloseFile(map_fd);\n-\n-  InternalScopedString path(64 + internal_strlen(coverage_dir));\n-  res = internal_snprintf((char *)path.data(), path.size(), \"%s/%zd.sancov.map\",\n-                          coverage_dir, internal_getpid());\n-  CHECK_LE(res, path.size());\n-  if (!RenameFile(tmp_path.data(), path.data(), &err)) {\n-    Printf(\"sancov.map rename failed: %d\\n\", err);\n-    Die();\n-  }\n-}\n-\n-} // namespace __sanitizer"}, {"sha": "5aea1203dbfe6976d0a50c0a4f200e8f8eb08f2f", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_dll_thunk.cc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dll_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,19 @@\n+//===-- sanitizer_coverage_win_dll_thunk.cc -------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines a family of thunks that should be statically linked into\n+// the DLLs that have instrumentation in order to delegate the calls to the\n+// shared runtime that lives in the main binary.\n+// See https://github.com/google/sanitizers/issues/209 for the details.\n+//===----------------------------------------------------------------------===//\n+#ifdef SANITIZER_DLL_THUNK\n+#include \"sanitizer_win_dll_thunk.h\"\n+// Sanitizer Coverage interface functions.\n+#define INTERFACE_FUNCTION(Name) INTERCEPT_SANITIZER_FUNCTION(Name)\n+#define INTERFACE_WEAK_FUNCTION(Name) INTERCEPT_SANITIZER_WEAK_FUNCTION(Name)\n+#include \"sanitizer_coverage_interface.inc\"\n+#endif // SANITIZER_DLL_THUNK"}, {"sha": "939f395071b81baf88cc331320c8daae2100adf9", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_dynamic_runtime_thunk.cc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dynamic_runtime_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,19 @@\n+//===-- sanitizer_coverage_win_dynamic_runtime_thunk.cc -------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines things that need to be present in the application modules\n+// to interact with Sanitizer Coverage, when it is included in a dll.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifdef SANITIZER_DYNAMIC_RUNTIME_THUNK\n+#define SANITIZER_IMPORT_INTERFACE 1\n+#include \"sanitizer_win_defs.h\"\n+// Define weak alias for all weak functions imported from sanitizer coverage.\n+#define INTERFACE_FUNCTION(Name)\n+#define INTERFACE_WEAK_FUNCTION(Name) WIN_WEAK_IMPORT_DEF(Name)\n+#include \"sanitizer_coverage_interface.inc\"\n+#endif // SANITIZER_DYNAMIC_RUNTIME_THUNK"}, {"sha": "485dd45e14bb60ad2d3b144e9ffd5efdfbd1d467", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_sections.cc", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,20 @@\n+//===-- sanitizer_coverage_win_sections.cc --------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines delimiters for Sanitizer Coverage's section.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_WINDOWS\n+#include <stdint.h>\n+#pragma section(\".SCOV$A\", read, write)  // NOLINT\n+#pragma section(\".SCOV$Z\", read, write)  // NOLINT\n+extern \"C\" {\n+__declspec(allocate(\".SCOV$A\")) uint32_t __start___sancov_guards = 0;\n+__declspec(allocate(\".SCOV$Z\")) uint32_t __stop___sancov_guards = 0;\n+}\n+#endif // SANITIZER_WINDOWS"}, {"sha": "64718dfc507d0903aa9b0aab7ebb666a4ff2a529", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_weak_interception.cc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_weak_interception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_weak_interception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_weak_interception.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,22 @@\n+//===-- sanitizer_coverage_win_weak_interception.cc -----------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+// This module should be included in Sanitizer Coverage when it implemented as a\n+// shared library on Windows (dll), in order to delegate the calls of weak\n+// functions to the implementation in the main executable when a strong\n+// definition is provided.\n+//===----------------------------------------------------------------------===//\n+#ifdef SANITIZER_DYNAMIC\n+#include \"sanitizer_win_weak_interception.h\"\n+#include \"sanitizer_interface_internal.h\"\n+#include \"sancov_flags.h\"\n+// Check if strong definitions for weak functions are present in the main\n+// executable. If that is the case, override dll functions to point to strong\n+// implementations.\n+#define INTERFACE_FUNCTION(Name)\n+#define INTERFACE_WEAK_FUNCTION(Name) INTERCEPT_SANITIZER_WEAK_FUNCTION(Name)\n+#include \"sanitizer_coverage_interface.inc\"\n+#endif // SANITIZER_DYNAMIC"}, {"sha": "bad17a91eb86dda133026feb8b9e7f0d92eaca5b", "filename": "libsanitizer/sanitizer_common/sanitizer_dbghelp.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_dbghelp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_dbghelp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_dbghelp.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,40 @@\n+//===-- sanitizer_dbghelp.h ------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Wrappers for lazy loaded dbghelp.dll. Provides function pointers and a\n+// callback to initialize them.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_SYMBOLIZER_WIN_H\n+#define SANITIZER_SYMBOLIZER_WIN_H\n+\n+#if !SANITIZER_WINDOWS\n+#error \"sanitizer_dbghelp.h is a Windows-only header\"\n+#endif\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+#include <dbghelp.h>\n+\n+namespace __sanitizer {\n+\n+extern decltype(::StackWalk64) *StackWalk64;\n+extern decltype(::SymCleanup) *SymCleanup;\n+extern decltype(::SymFromAddr) *SymFromAddr;\n+extern decltype(::SymFunctionTableAccess64) *SymFunctionTableAccess64;\n+extern decltype(::SymGetLineFromAddr64) *SymGetLineFromAddr64;\n+extern decltype(::SymGetModuleBase64) *SymGetModuleBase64;\n+extern decltype(::SymGetSearchPathW) *SymGetSearchPathW;\n+extern decltype(::SymInitialize) *SymInitialize;\n+extern decltype(::SymSetOptions) *SymSetOptions;\n+extern decltype(::SymSetSearchPathW) *SymSetSearchPathW;\n+extern decltype(::UnDecorateSymbolName) *UnDecorateSymbolName;\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_SYMBOLIZER_WIN_H"}, {"sha": "b65f0e7ddf15668edf3f248ad2681a235885d1ce", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,33 @@\n+//===-- sanitizer_errno.cc --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between sanitizers run-time libraries.\n+//\n+// Defines errno to avoid including errno.h and its dependencies into other\n+// files (e.g. interceptors are not supposed to include any system headers).\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_errno_codes.h\"\n+#include \"sanitizer_internal_defs.h\"\n+\n+#include <errno.h>\n+\n+namespace __sanitizer {\n+\n+COMPILER_CHECK(errno_ENOMEM == ENOMEM);\n+COMPILER_CHECK(errno_EBUSY == EBUSY);\n+COMPILER_CHECK(errno_EINVAL == EINVAL);\n+\n+// EOWNERDEAD is not present in some older platforms.\n+#if defined(EOWNERDEAD)\n+extern const int errno_EOWNERDEAD = EOWNERDEAD;\n+#else\n+extern const int errno_EOWNERDEAD = -1;\n+#endif\n+\n+}  // namespace __sanitizer"}, {"sha": "e9fc00f6c2a3a0c47cf3b92261c459209d823fda", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,35 @@\n+//===-- sanitizer_errno.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between sanitizers run-time libraries.\n+//\n+// Defines errno to avoid including errno.h and its dependencies into sensitive\n+// files (e.g. interceptors are not supposed to include any system headers).\n+// It's ok to use errno.h directly when your file already depend on other system\n+// includes though.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ERRNO_H\n+#define SANITIZER_ERRNO_H\n+\n+#include \"sanitizer_errno_codes.h\"\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_FREEBSD || SANITIZER_MAC\n+#  define __errno_location __error\n+#elif SANITIZER_ANDROID || SANITIZER_NETBSD\n+#  define __errno_location __errno\n+#elif SANITIZER_WINDOWS\n+#  define __errno_location _errno\n+#endif\n+\n+extern \"C\" int *__errno_location();\n+\n+#define errno (*__errno_location())\n+\n+#endif  // SANITIZER_ERRNO_H"}, {"sha": "709f43b768929ce55626ab060e4dca7bb3fa3003", "filename": "libsanitizer/sanitizer_common/sanitizer_errno_codes.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,32 @@\n+//===-- sanitizer_errno_codes.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between sanitizers run-time libraries.\n+//\n+// Defines errno codes to avoid including errno.h and its dependencies into\n+// sensitive files (e.g. interceptors are not supposed to include any system\n+// headers).\n+// It's ok to use errno.h directly when your file already depend on other system\n+// includes though.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ERRNO_CODES_H\n+#define SANITIZER_ERRNO_CODES_H\n+\n+namespace __sanitizer {\n+\n+#define errno_ENOMEM 12\n+#define errno_EBUSY 16\n+#define errno_EINVAL 22\n+\n+// Those might not present or their value differ on different platforms.\n+extern const int errno_EOWNERDEAD;\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ERRNO_CODES_H"}, {"sha": "8740dbb5b6f830b8fabc2551e892c4d4626b002f", "filename": "libsanitizer/sanitizer_common/sanitizer_file.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,175 @@\n+//===-- sanitizer_file.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.  It defines filesystem-related interfaces.  This\n+// is separate from sanitizer_common.cc so that it's simpler to disable\n+// all the filesystem support code for a port that doesn't use it.\n+//\n+//===---------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if !SANITIZER_FUCHSIA\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_file.h\"\n+\n+namespace __sanitizer {\n+\n+void CatastrophicErrorWrite(const char *buffer, uptr length) {\n+  WriteToFile(kStderrFd, buffer, length);\n+}\n+\n+StaticSpinMutex report_file_mu;\n+ReportFile report_file = {&report_file_mu, kStderrFd, \"\", \"\", 0};\n+\n+void RawWrite(const char *buffer) {\n+  report_file.Write(buffer, internal_strlen(buffer));\n+}\n+\n+void ReportFile::ReopenIfNecessary() {\n+  mu->CheckLocked();\n+  if (fd == kStdoutFd || fd == kStderrFd) return;\n+\n+  uptr pid = internal_getpid();\n+  // If in tracer, use the parent's file.\n+  if (pid == stoptheworld_tracer_pid)\n+    pid = stoptheworld_tracer_ppid;\n+  if (fd != kInvalidFd) {\n+    // If the report file is already opened by the current process,\n+    // do nothing. Otherwise the report file was opened by the parent\n+    // process, close it now.\n+    if (fd_pid == pid)\n+      return;\n+    else\n+      CloseFile(fd);\n+  }\n+\n+  const char *exe_name = GetProcessName();\n+  if (common_flags()->log_exe_name && exe_name) {\n+    internal_snprintf(full_path, kMaxPathLength, \"%s.%s.%zu\", path_prefix,\n+                      exe_name, pid);\n+  } else {\n+    internal_snprintf(full_path, kMaxPathLength, \"%s.%zu\", path_prefix, pid);\n+  }\n+  fd = OpenFile(full_path, WrOnly);\n+  if (fd == kInvalidFd) {\n+    const char *ErrorMsgPrefix = \"ERROR: Can't open file: \";\n+    WriteToFile(kStderrFd, ErrorMsgPrefix, internal_strlen(ErrorMsgPrefix));\n+    WriteToFile(kStderrFd, full_path, internal_strlen(full_path));\n+    Die();\n+  }\n+  fd_pid = pid;\n+}\n+\n+void ReportFile::SetReportPath(const char *path) {\n+  if (!path)\n+    return;\n+  uptr len = internal_strlen(path);\n+  if (len > sizeof(path_prefix) - 100) {\n+    Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n+           path[0], path[1], path[2], path[3],\n+           path[4], path[5], path[6], path[7]);\n+    Die();\n+  }\n+\n+  SpinMutexLock l(mu);\n+  if (fd != kStdoutFd && fd != kStderrFd && fd != kInvalidFd)\n+    CloseFile(fd);\n+  fd = kInvalidFd;\n+  if (internal_strcmp(path, \"stdout\") == 0) {\n+    fd = kStdoutFd;\n+  } else if (internal_strcmp(path, \"stderr\") == 0) {\n+    fd = kStderrFd;\n+  } else {\n+    internal_snprintf(path_prefix, kMaxPathLength, \"%s\", path);\n+  }\n+}\n+\n+bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n+                      uptr *read_len, uptr max_len, error_t *errno_p) {\n+  uptr PageSize = GetPageSizeCached();\n+  uptr kMinFileLen = PageSize;\n+  *buff = nullptr;\n+  *buff_size = 0;\n+  *read_len = 0;\n+  // The files we usually open are not seekable, so try different buffer sizes.\n+  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n+    fd_t fd = OpenFile(file_name, RdOnly, errno_p);\n+    if (fd == kInvalidFd) return false;\n+    UnmapOrDie(*buff, *buff_size);\n+    *buff = (char*)MmapOrDie(size, __func__);\n+    *buff_size = size;\n+    *read_len = 0;\n+    // Read up to one page at a time.\n+    bool reached_eof = false;\n+    while (*read_len + PageSize <= size) {\n+      uptr just_read;\n+      if (!ReadFromFile(fd, *buff + *read_len, PageSize, &just_read, errno_p)) {\n+        UnmapOrDie(*buff, *buff_size);\n+        return false;\n+      }\n+      if (just_read == 0) {\n+        reached_eof = true;\n+        break;\n+      }\n+      *read_len += just_read;\n+    }\n+    CloseFile(fd);\n+    if (reached_eof)  // We've read the whole file.\n+      break;\n+  }\n+  return true;\n+}\n+\n+static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';\n+\n+char *FindPathToBinary(const char *name) {\n+  if (FileExists(name)) {\n+    return internal_strdup(name);\n+  }\n+\n+  const char *path = GetEnv(\"PATH\");\n+  if (!path)\n+    return nullptr;\n+  uptr name_len = internal_strlen(name);\n+  InternalScopedBuffer<char> buffer(kMaxPathLength);\n+  const char *beg = path;\n+  while (true) {\n+    const char *end = internal_strchrnul(beg, kPathSeparator);\n+    uptr prefix_len = end - beg;\n+    if (prefix_len + name_len + 2 <= kMaxPathLength) {\n+      internal_memcpy(buffer.data(), beg, prefix_len);\n+      buffer[prefix_len] = '/';\n+      internal_memcpy(&buffer[prefix_len + 1], name, name_len);\n+      buffer[prefix_len + 1 + name_len] = '\\0';\n+      if (FileExists(buffer.data()))\n+        return internal_strdup(buffer.data());\n+    }\n+    if (*end == '\\0') break;\n+    beg = end + 1;\n+  }\n+  return nullptr;\n+}\n+\n+} // namespace __sanitizer\n+\n+using namespace __sanitizer;  // NOLINT\n+\n+extern \"C\" {\n+void __sanitizer_set_report_path(const char *path) {\n+  report_file.SetReportPath(path);\n+}\n+\n+void __sanitizer_set_report_fd(void *fd) {\n+  report_file.fd = (fd_t)reinterpret_cast<uptr>(fd);\n+  report_file.fd_pid = internal_getpid();\n+}\n+} // extern \"C\"\n+\n+#endif  // !SANITIZER_FUCHSIA"}, {"sha": "3f9e8ab284967f058be6d8cc193dc49252d49ec5", "filename": "libsanitizer/sanitizer_common/sanitizer_file.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,108 @@\n+//===-- sanitizer_file.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is shared between run-time libraries of sanitizers.\n+// It declares filesystem-related interfaces.  This is separate from\n+// sanitizer_common.h so that it's simpler to disable all the filesystem\n+// support code for a port that doesn't use it.\n+//\n+//===---------------------------------------------------------------------===//\n+#ifndef SANITIZER_FILE_H\n+#define SANITIZER_FILE_H\n+\n+#include \"sanitizer_interface_internal.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_mutex.h\"\n+\n+namespace __sanitizer {\n+\n+struct ReportFile {\n+  void Write(const char *buffer, uptr length);\n+  bool SupportsColors();\n+  void SetReportPath(const char *path);\n+\n+  // Don't use fields directly. They are only declared public to allow\n+  // aggregate initialization.\n+\n+  // Protects fields below.\n+  StaticSpinMutex *mu;\n+  // Opened file descriptor. Defaults to stderr. It may be equal to\n+  // kInvalidFd, in which case new file will be opened when necessary.\n+  fd_t fd;\n+  // Path prefix of report file, set via __sanitizer_set_report_path.\n+  char path_prefix[kMaxPathLength];\n+  // Full path to report, obtained as <path_prefix>.PID\n+  char full_path[kMaxPathLength];\n+  // PID of the process that opened fd. If a fork() occurs,\n+  // the PID of child will be different from fd_pid.\n+  uptr fd_pid;\n+\n+ private:\n+  void ReopenIfNecessary();\n+};\n+extern ReportFile report_file;\n+\n+enum FileAccessMode {\n+  RdOnly,\n+  WrOnly,\n+  RdWr\n+};\n+\n+// Returns kInvalidFd on error.\n+fd_t OpenFile(const char *filename, FileAccessMode mode,\n+              error_t *errno_p = nullptr);\n+void CloseFile(fd_t);\n+\n+// Return true on success, false on error.\n+bool ReadFromFile(fd_t fd, void *buff, uptr buff_size,\n+                  uptr *bytes_read = nullptr, error_t *error_p = nullptr);\n+bool WriteToFile(fd_t fd, const void *buff, uptr buff_size,\n+                 uptr *bytes_written = nullptr, error_t *error_p = nullptr);\n+\n+bool RenameFile(const char *oldpath, const char *newpath,\n+                error_t *error_p = nullptr);\n+\n+// Scoped file handle closer.\n+struct FileCloser {\n+  explicit FileCloser(fd_t fd) : fd(fd) {}\n+  ~FileCloser() { CloseFile(fd); }\n+  fd_t fd;\n+};\n+\n+bool SupportsColoredOutput(fd_t fd);\n+\n+// OS\n+const char *GetPwd();\n+bool FileExists(const char *filename);\n+char *FindPathToBinary(const char *name);\n+bool IsPathSeparator(const char c);\n+bool IsAbsolutePath(const char *path);\n+// Starts a subprocess and returs its pid.\n+// If *_fd parameters are not kInvalidFd their corresponding input/output\n+// streams will be redirect to the file. The files will always be closed\n+// in parent process even in case of an error.\n+// The child process will close all fds after STDERR_FILENO\n+// before passing control to a program.\n+pid_t StartSubprocess(const char *filename, const char *const argv[],\n+                      fd_t stdin_fd = kInvalidFd, fd_t stdout_fd = kInvalidFd,\n+                      fd_t stderr_fd = kInvalidFd);\n+// Checks if specified process is still running\n+bool IsProcessRunning(pid_t pid);\n+// Waits for the process to finish and returns its exit code.\n+// Returns -1 in case of an error.\n+int WaitForProcess(pid_t pid);\n+\n+// Maps given file to virtual memory, and returns pointer to it\n+// (or NULL if mapping fails). Stores the size of mmaped region\n+// in '*buff_size'.\n+void *MapFileToMemory(const char *file_name, uptr *buff_size);\n+void *MapWritableFileToMemory(void *addr, uptr size, fd_t fd, OFF_T offset);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FILE_H"}, {"sha": "13677c0ea6870afd7f90a2919beebc9dd0f08fe8", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.h", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -32,27 +32,48 @@ class FlagHandler : public FlagHandlerBase {\n   bool Parse(const char *value) final;\n };\n \n-template <>\n-inline bool FlagHandler<bool>::Parse(const char *value) {\n+inline bool ParseBool(const char *value, bool *b) {\n   if (internal_strcmp(value, \"0\") == 0 ||\n       internal_strcmp(value, \"no\") == 0 ||\n       internal_strcmp(value, \"false\") == 0) {\n-    *t_ = false;\n+    *b = false;\n     return true;\n   }\n   if (internal_strcmp(value, \"1\") == 0 ||\n       internal_strcmp(value, \"yes\") == 0 ||\n       internal_strcmp(value, \"true\") == 0) {\n-    *t_ = true;\n+    *b = true;\n     return true;\n   }\n+  return false;\n+}\n+\n+template <>\n+inline bool FlagHandler<bool>::Parse(const char *value) {\n+  if (ParseBool(value, t_)) return true;\n   Printf(\"ERROR: Invalid value for bool option: '%s'\\n\", value);\n   return false;\n }\n \n+template <>\n+inline bool FlagHandler<HandleSignalMode>::Parse(const char *value) {\n+  bool b;\n+  if (ParseBool(value, &b)) {\n+    *t_ = b ? kHandleSignalYes : kHandleSignalNo;\n+    return true;\n+  }\n+  if (internal_strcmp(value, \"2\") == 0 ||\n+      internal_strcmp(value, \"exclusive\") == 0) {\n+    *t_ = kHandleSignalExclusive;\n+    return true;\n+  }\n+  Printf(\"ERROR: Invalid value for signal handler option: '%s'\\n\", value);\n+  return false;\n+}\n+\n template <>\n inline bool FlagHandler<const char *>::Parse(const char *value) {\n-  *t_ = internal_strdup(value);\n+  *t_ = value;\n   return true;\n }\n "}, {"sha": "2e3739e915d9ee05a10713df6a400880731c5957", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -16,6 +16,12 @@\n \n namespace __sanitizer {\n \n+enum HandleSignalMode {\n+  kHandleSignalNo,\n+  kHandleSignalYes,\n+  kHandleSignalExclusive,\n+};\n+\n struct CommonFlags {\n #define COMMON_FLAG(Type, Name, DefaultValue, Description) Type Name;\n #include \"sanitizer_flags.inc\""}, {"sha": "9e9b8a7daa630c47a87562b69c8e893e557c4ad2", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -60,7 +60,7 @@ COMMON_FLAG(\n COMMON_FLAG(\n     int, verbosity, 0,\n     \"Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\")\n-COMMON_FLAG(bool, detect_leaks, true, \"Enable memory leak detection.\")\n+COMMON_FLAG(bool, detect_leaks, !SANITIZER_MAC, \"Enable memory leak detection.\")\n COMMON_FLAG(\n     bool, leak_check_at_exit, true,\n     \"Invoke leak checking in an atexit handler. Has no effect if \"\n@@ -72,18 +72,28 @@ COMMON_FLAG(bool, allocator_may_return_null, false,\n COMMON_FLAG(bool, print_summary, true,\n             \"If false, disable printing error summaries in addition to error \"\n             \"reports.\")\n+COMMON_FLAG(int, print_module_map, 0,\n+            \"OS X only (0 - don't print, 1 - print only once before process \"\n+            \"exits, 2 - print after each report).\")\n COMMON_FLAG(bool, check_printf, true, \"Check printf arguments.\")\n-COMMON_FLAG(bool, handle_segv, true,\n-            \"If set, registers the tool's custom SIGSEGV/SIGBUS handler.\")\n-COMMON_FLAG(bool, handle_abort, false,\n-            \"If set, registers the tool's custom SIGABRT handler.\")\n-COMMON_FLAG(bool, handle_sigill, false,\n-            \"If set, registers the tool's custom SIGILL handler.\")\n-COMMON_FLAG(bool, handle_sigfpe, true,\n-            \"If set, registers the tool's custom SIGFPE handler.\")\n-COMMON_FLAG(bool, allow_user_segv_handler, false,\n-            \"If set, allows user to register a SEGV handler even if the tool \"\n-            \"registers one.\")\n+#define COMMON_FLAG_HANDLE_SIGNAL_HELP(signal) \\\n+    \"Controls custom tool's \" #signal \" handler (0 - do not registers the \" \\\n+    \"handler, 1 - register the handler and allow user to set own, \" \\\n+    \"2 - registers the handler and block user from changing it). \"\n+COMMON_FLAG(HandleSignalMode, handle_segv, kHandleSignalYes,\n+            COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGSEGV))\n+COMMON_FLAG(HandleSignalMode, handle_sigbus, kHandleSignalYes,\n+            COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGBUS))\n+COMMON_FLAG(HandleSignalMode, handle_abort, kHandleSignalNo,\n+            COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGABRT))\n+COMMON_FLAG(HandleSignalMode, handle_sigill, kHandleSignalNo,\n+            COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGILL))\n+COMMON_FLAG(HandleSignalMode, handle_sigfpe, kHandleSignalYes,\n+            COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGFPE))\n+#undef COMMON_FLAG_HANDLE_SIGNAL_HELP\n+COMMON_FLAG(bool, allow_user_segv_handler, true,\n+            \"Deprecated. True has no effect, use handle_sigbus=1. If false, \"\n+            \"handle_*=1 will be upgraded to handle_*=2.\")\n COMMON_FLAG(bool, use_sigaltstack, true,\n             \"If set, uses alternate stack for signal handling.\")\n COMMON_FLAG(bool, detect_deadlocks, false,\n@@ -117,32 +127,18 @@ COMMON_FLAG(uptr, soft_rss_limit_mb, 0,\n             \" This limit does not affect memory allocations other than\"\n             \" malloc/new.\")\n COMMON_FLAG(bool, heap_profile, false, \"Experimental heap profiler, asan-only\")\n-COMMON_FLAG(bool, allocator_release_to_os, false,\n-            \"Experimental. If true, try to periodically release unused\"\n-            \" memory to the OS.\\n\")\n+COMMON_FLAG(s32, allocator_release_to_os_interval_ms, kReleaseToOSIntervalNever,\n+            \"Experimental. Only affects a 64-bit allocator. If set, tries to \"\n+            \"release unused memory to the OS, but not more often than this \"\n+            \"interval (in milliseconds). Negative values mean do not attempt \"\n+            \"to release memory to the OS.\\n\")\n COMMON_FLAG(bool, can_use_proc_maps_statm, true,\n             \"If false, do not attempt to read /proc/maps/statm.\"\n             \" Mostly useful for testing sanitizers.\")\n COMMON_FLAG(\n     bool, coverage, false,\n     \"If set, coverage information will be dumped at program shutdown (if the \"\n     \"coverage instrumentation was enabled at compile time).\")\n-COMMON_FLAG(bool, coverage_pcs, true,\n-            \"If set (and if 'coverage' is set too), the coverage information \"\n-            \"will be dumped as a set of PC offsets for every module.\")\n-COMMON_FLAG(bool, coverage_order_pcs, false,\n-             \"If true, the PCs will be dumped in the order they've\"\n-             \" appeared during the execution.\")\n-COMMON_FLAG(bool, coverage_bitset, false,\n-            \"If set (and if 'coverage' is set too), the coverage information \"\n-            \"will also be dumped as a bitset to a separate file.\")\n-COMMON_FLAG(bool, coverage_counters, false,\n-            \"If set (and if 'coverage' is set too), the bitmap that corresponds\"\n-            \" to coverage counters will be dumped.\")\n-COMMON_FLAG(bool, coverage_direct, SANITIZER_ANDROID,\n-            \"If set, coverage information will be dumped directly to a memory \"\n-            \"mapped file. This way data is not lost even if the process is \"\n-            \"suddenly killed.\")\n COMMON_FLAG(const char *, coverage_dir, \".\",\n             \"Target directory for coverage dumps. Defaults to the current \"\n             \"directory.\")\n@@ -183,12 +179,18 @@ COMMON_FLAG(bool, intercept_strstr, true,\n COMMON_FLAG(bool, intercept_strspn, true,\n             \"If set, uses custom wrappers for strspn and strcspn function \"\n             \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_strtok, true,\n+            \"If set, uses a custom wrapper for the strtok function \"\n+            \"to find more errors.\")\n COMMON_FLAG(bool, intercept_strpbrk, true,\n             \"If set, uses custom wrappers for strpbrk function \"\n             \"to find more errors.\")\n COMMON_FLAG(bool, intercept_strlen, true,\n             \"If set, uses custom wrappers for strlen and strnlen functions \"\n             \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_strndup, true,\n+            \"If set, uses custom wrappers for strndup functions \"\n+            \"to find more errors.\")\n COMMON_FLAG(bool, intercept_strchr, true,\n             \"If set, uses custom wrappers for strchr, strchrnul, and strrchr \"\n             \"functions to find more errors.\")\n@@ -225,3 +227,8 @@ COMMON_FLAG(bool, print_cmdline, false, \"Print command line on crash \"\n             \"(asan only).\")\n COMMON_FLAG(bool, html_cov_report, false, \"Generate html coverage report.\")\n COMMON_FLAG(const char *, sancov_path, \"sancov\", \"Sancov tool location.\")\n+COMMON_FLAG(bool, dump_instruction_bytes, false,\n+          \"If true, dump 16 bytes starting at the instruction that caused SEGV\")\n+COMMON_FLAG(bool, dump_registers, true,\n+          \"If true, dump values of CPU registers when SEGV happens. Only \"\n+          \"available on OS X for now.\")"}, {"sha": "da7018ca33daa0e14f1688b3d2e0dba49a5700bc", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cc", "status": "added", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,517 @@\n+//===-- sanitizer_fuchsia.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and other sanitizer\n+// run-time libraries and implements Fuchsia-specific functions from\n+// sanitizer_common.h.\n+//===---------------------------------------------------------------------===//\n+\n+#include \"sanitizer_fuchsia.h\"\n+#if SANITIZER_FUCHSIA\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_stacktrace.h\"\n+\n+#include <limits.h>\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <unwind.h>\n+#include <zircon/errors.h>\n+#include <zircon/process.h>\n+#include <zircon/syscalls.h>\n+\n+namespace __sanitizer {\n+\n+void NORETURN internal__exit(int exitcode) { _zx_process_exit(exitcode); }\n+\n+uptr internal_sched_yield() {\n+  zx_status_t status = _zx_nanosleep(0);\n+  CHECK_EQ(status, ZX_OK);\n+  return 0;  // Why doesn't this return void?\n+}\n+\n+static void internal_nanosleep(zx_time_t ns) {\n+  zx_status_t status = _zx_nanosleep(_zx_deadline_after(ns));\n+  CHECK_EQ(status, ZX_OK);\n+}\n+\n+unsigned int internal_sleep(unsigned int seconds) {\n+  internal_nanosleep(ZX_SEC(seconds));\n+  return 0;\n+}\n+\n+u64 NanoTime() { return _zx_time_get(ZX_CLOCK_UTC); }\n+\n+uptr internal_getpid() {\n+  zx_info_handle_basic_t info;\n+  zx_status_t status =\n+      _zx_object_get_info(_zx_process_self(), ZX_INFO_HANDLE_BASIC, &info,\n+                          sizeof(info), NULL, NULL);\n+  CHECK_EQ(status, ZX_OK);\n+  uptr pid = static_cast<uptr>(info.koid);\n+  CHECK_EQ(pid, info.koid);\n+  return pid;\n+}\n+\n+uptr GetThreadSelf() { return reinterpret_cast<uptr>(thrd_current()); }\n+\n+uptr GetTid() { return GetThreadSelf(); }\n+\n+void Abort() { abort(); }\n+\n+int Atexit(void (*function)(void)) { return atexit(function); }\n+\n+void SleepForSeconds(int seconds) { internal_sleep(seconds); }\n+\n+void SleepForMillis(int millis) { internal_nanosleep(ZX_MSEC(millis)); }\n+\n+void GetThreadStackTopAndBottom(bool, uptr *stack_top, uptr *stack_bottom) {\n+  pthread_attr_t attr;\n+  CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n+  void *base;\n+  size_t size;\n+  CHECK_EQ(pthread_attr_getstack(&attr, &base, &size), 0);\n+  CHECK_EQ(pthread_attr_destroy(&attr), 0);\n+\n+  *stack_bottom = reinterpret_cast<uptr>(base);\n+  *stack_top = *stack_bottom + size;\n+}\n+\n+void MaybeReexec() {}\n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {}\n+void DisableCoreDumperIfNecessary() {}\n+void InstallDeadlySignalHandlers(SignalHandlerType handler) {}\n+void StartReportDeadlySignal() {}\n+void ReportDeadlySignal(const SignalContext &sig, u32 tid,\n+                        UnwindSignalStackCallbackType unwind,\n+                        const void *unwind_context) {}\n+void SetAlternateSignalStack() {}\n+void UnsetAlternateSignalStack() {}\n+void InitTlsSize() {}\n+\n+void PrintModuleMap() {}\n+\n+bool SignalContext::IsStackOverflow() const { return false; }\n+void SignalContext::DumpAllRegisters(void *context) { UNIMPLEMENTED(); }\n+const char *SignalContext::Describe() const { UNIMPLEMENTED(); }\n+\n+struct UnwindTraceArg {\n+  BufferedStackTrace *stack;\n+  u32 max_depth;\n+};\n+\n+_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n+  UnwindTraceArg *arg = static_cast<UnwindTraceArg *>(param);\n+  CHECK_LT(arg->stack->size, arg->max_depth);\n+  uptr pc = _Unwind_GetIP(ctx);\n+  if (pc < PAGE_SIZE) return _URC_NORMAL_STOP;\n+  arg->stack->trace_buffer[arg->stack->size++] = pc;\n+  return (arg->stack->size == arg->max_depth ? _URC_NORMAL_STOP\n+                                             : _URC_NO_REASON);\n+}\n+\n+void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n+  CHECK_GE(max_depth, 2);\n+  size = 0;\n+  UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n+  _Unwind_Backtrace(Unwind_Trace, &arg);\n+  CHECK_GT(size, 0);\n+  // We need to pop a few frames so that pc is on top.\n+  uptr to_pop = LocatePcInTrace(pc);\n+  // trace_buffer[0] belongs to the current function so we always pop it,\n+  // unless there is only 1 frame in the stack trace (1 frame is always better\n+  // than 0!).\n+  PopStackFrames(Min(to_pop, static_cast<uptr>(1)));\n+  trace_buffer[0] = pc;\n+}\n+\n+void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n+                                                    u32 max_depth) {\n+  CHECK_NE(context, nullptr);\n+  UNREACHABLE(\"signal context doesn't exist\");\n+}\n+\n+enum MutexState : int { MtxUnlocked = 0, MtxLocked = 1, MtxSleeping = 2 };\n+\n+BlockingMutex::BlockingMutex() {\n+  // NOTE!  It's important that this use internal_memset, because plain\n+  // memset might be intercepted (e.g., actually be __asan_memset).\n+  // Defining this so the compiler initializes each field, e.g.:\n+  //   BlockingMutex::BlockingMutex() : BlockingMutex(LINKER_INITIALIZED) {}\n+  // might result in the compiler generating a call to memset, which would\n+  // have the same problem.\n+  internal_memset(this, 0, sizeof(*this));\n+}\n+\n+void BlockingMutex::Lock() {\n+  CHECK_EQ(owner_, 0);\n+  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+  if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n+    return;\n+  while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked) {\n+    zx_status_t status = _zx_futex_wait(reinterpret_cast<zx_futex_t *>(m),\n+                                        MtxSleeping, ZX_TIME_INFINITE);\n+    if (status != ZX_ERR_BAD_STATE)  // Normal race.\n+      CHECK_EQ(status, ZX_OK);\n+  }\n+}\n+\n+void BlockingMutex::Unlock() {\n+  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_release);\n+  CHECK_NE(v, MtxUnlocked);\n+  if (v == MtxSleeping) {\n+    zx_status_t status = _zx_futex_wake(reinterpret_cast<zx_futex_t *>(m), 1);\n+    CHECK_EQ(status, ZX_OK);\n+  }\n+}\n+\n+void BlockingMutex::CheckLocked() {\n+  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+  CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n+}\n+\n+uptr GetPageSize() { return PAGE_SIZE; }\n+\n+uptr GetMmapGranularity() { return PAGE_SIZE; }\n+\n+sanitizer_shadow_bounds_t ShadowBounds;\n+\n+uptr GetMaxVirtualAddress() {\n+  ShadowBounds = __sanitizer_shadow_bounds();\n+  return ShadowBounds.memory_limit - 1;\n+}\n+\n+static void *DoAnonymousMmapOrDie(uptr size, const char *mem_type,\n+                                  bool raw_report, bool die_for_nomem) {\n+  size = RoundUpTo(size, PAGE_SIZE);\n+\n+  zx_handle_t vmo;\n+  zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n+  if (status != ZX_OK) {\n+    if (status != ZX_ERR_NO_MEMORY || die_for_nomem)\n+      ReportMmapFailureAndDie(size, mem_type, \"zx_vmo_create\", status,\n+                              raw_report);\n+    return nullptr;\n+  }\n+  _zx_object_set_property(vmo, ZX_PROP_NAME, mem_type,\n+                          internal_strlen(mem_type));\n+\n+  // TODO(mcgrathr): Maybe allocate a VMAR for all sanitizer heap and use that?\n+  uintptr_t addr;\n+  status = _zx_vmar_map(_zx_vmar_root_self(), 0, vmo, 0, size,\n+                        ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE, &addr);\n+  _zx_handle_close(vmo);\n+\n+  if (status != ZX_OK) {\n+    if (status != ZX_ERR_NO_MEMORY || die_for_nomem)\n+      ReportMmapFailureAndDie(size, mem_type, \"zx_vmar_map\", status,\n+                              raw_report);\n+    return nullptr;\n+  }\n+\n+  IncreaseTotalMmap(size);\n+\n+  return reinterpret_cast<void *>(addr);\n+}\n+\n+void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n+  return DoAnonymousMmapOrDie(size, mem_type, raw_report, true);\n+}\n+\n+void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n+  return MmapOrDie(size, mem_type);\n+}\n+\n+void *MmapOrDieOnFatalError(uptr size, const char *mem_type) {\n+  return DoAnonymousMmapOrDie(size, mem_type, false, false);\n+}\n+\n+// MmapNoAccess and MmapFixedOrDie are used only by sanitizer_allocator.\n+// Instead of doing exactly what they say, we make MmapNoAccess actually\n+// just allocate a VMAR to reserve the address space.  Then MmapFixedOrDie\n+// uses that VMAR instead of the root.\n+\n+zx_handle_t allocator_vmar = ZX_HANDLE_INVALID;\n+uintptr_t allocator_vmar_base;\n+size_t allocator_vmar_size;\n+\n+void *MmapNoAccess(uptr size) {\n+  size = RoundUpTo(size, PAGE_SIZE);\n+  CHECK_EQ(allocator_vmar, ZX_HANDLE_INVALID);\n+  uintptr_t base;\n+  zx_status_t status =\n+      _zx_vmar_allocate(_zx_vmar_root_self(), 0, size,\n+                        ZX_VM_FLAG_CAN_MAP_READ | ZX_VM_FLAG_CAN_MAP_WRITE |\n+                            ZX_VM_FLAG_CAN_MAP_SPECIFIC,\n+                        &allocator_vmar, &base);\n+  if (status != ZX_OK)\n+    ReportMmapFailureAndDie(size, \"sanitizer allocator address space\",\n+                            \"zx_vmar_allocate\", status);\n+\n+  allocator_vmar_base = base;\n+  allocator_vmar_size = size;\n+  return reinterpret_cast<void *>(base);\n+}\n+\n+constexpr const char kAllocatorVmoName[] = \"sanitizer_allocator\";\n+\n+static void *DoMmapFixedOrDie(uptr fixed_addr, uptr size, bool die_for_nomem) {\n+  size = RoundUpTo(size, PAGE_SIZE);\n+\n+  zx_handle_t vmo;\n+  zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n+  if (status != ZX_OK) {\n+    if (status != ZX_ERR_NO_MEMORY || die_for_nomem)\n+      ReportMmapFailureAndDie(size, kAllocatorVmoName, \"zx_vmo_create\", status);\n+    return nullptr;\n+  }\n+  _zx_object_set_property(vmo, ZX_PROP_NAME, kAllocatorVmoName,\n+                          sizeof(kAllocatorVmoName) - 1);\n+\n+  DCHECK_GE(fixed_addr, allocator_vmar_base);\n+  uintptr_t offset = fixed_addr - allocator_vmar_base;\n+  DCHECK_LE(size, allocator_vmar_size);\n+  DCHECK_GE(allocator_vmar_size - offset, size);\n+\n+  uintptr_t addr;\n+  status = _zx_vmar_map(\n+      allocator_vmar, offset, vmo, 0, size,\n+      ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE | ZX_VM_FLAG_SPECIFIC,\n+      &addr);\n+  _zx_handle_close(vmo);\n+  if (status != ZX_OK) {\n+    if (status != ZX_ERR_NO_MEMORY || die_for_nomem)\n+      ReportMmapFailureAndDie(size, kAllocatorVmoName, \"zx_vmar_map\", status);\n+    return nullptr;\n+  }\n+\n+  IncreaseTotalMmap(size);\n+\n+  return reinterpret_cast<void *>(addr);\n+}\n+\n+void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n+  return DoMmapFixedOrDie(fixed_addr, size, true);\n+}\n+\n+void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size) {\n+  return DoMmapFixedOrDie(fixed_addr, size, false);\n+}\n+\n+// This should never be called.\n+void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name) {\n+  UNIMPLEMENTED();\n+}\n+\n+void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n+                                   const char *mem_type) {\n+  CHECK_GE(size, PAGE_SIZE);\n+  CHECK(IsPowerOfTwo(size));\n+  CHECK(IsPowerOfTwo(alignment));\n+\n+  zx_handle_t vmo;\n+  zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n+  if (status != ZX_OK) {\n+    if (status != ZX_ERR_NO_MEMORY)\n+      ReportMmapFailureAndDie(size, mem_type, \"zx_vmo_create\", status, false);\n+    return nullptr;\n+  }\n+  _zx_object_set_property(vmo, ZX_PROP_NAME, mem_type,\n+                          internal_strlen(mem_type));\n+\n+  // TODO(mcgrathr): Maybe allocate a VMAR for all sanitizer heap and use that?\n+\n+  // Map a larger size to get a chunk of address space big enough that\n+  // it surely contains an aligned region of the requested size.  Then\n+  // overwrite the aligned middle portion with a mapping from the\n+  // beginning of the VMO, and unmap the excess before and after.\n+  size_t map_size = size + alignment;\n+  uintptr_t addr;\n+  status = _zx_vmar_map(_zx_vmar_root_self(), 0, vmo, 0, map_size,\n+                        ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE, &addr);\n+  if (status == ZX_OK) {\n+    uintptr_t map_addr = addr;\n+    uintptr_t map_end = map_addr + map_size;\n+    addr = RoundUpTo(map_addr, alignment);\n+    uintptr_t end = addr + size;\n+    if (addr != map_addr) {\n+      zx_info_vmar_t info;\n+      status = _zx_object_get_info(_zx_vmar_root_self(), ZX_INFO_VMAR, &info,\n+                                   sizeof(info), NULL, NULL);\n+      if (status == ZX_OK) {\n+        uintptr_t new_addr;\n+        status =\n+            _zx_vmar_map(_zx_vmar_root_self(), addr - info.base, vmo, 0, size,\n+                         ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE |\n+                             ZX_VM_FLAG_SPECIFIC_OVERWRITE,\n+                         &new_addr);\n+        if (status == ZX_OK) CHECK_EQ(new_addr, addr);\n+      }\n+    }\n+    if (status == ZX_OK && addr != map_addr)\n+      status = _zx_vmar_unmap(_zx_vmar_root_self(), map_addr, addr - map_addr);\n+    if (status == ZX_OK && end != map_end)\n+      status = _zx_vmar_unmap(_zx_vmar_root_self(), end, map_end - end);\n+  }\n+  _zx_handle_close(vmo);\n+\n+  if (status != ZX_OK) {\n+    if (status != ZX_ERR_NO_MEMORY)\n+      ReportMmapFailureAndDie(size, mem_type, \"zx_vmar_map\", status, false);\n+    return nullptr;\n+  }\n+\n+  IncreaseTotalMmap(size);\n+\n+  return reinterpret_cast<void *>(addr);\n+}\n+\n+void UnmapOrDie(void *addr, uptr size) {\n+  if (!addr || !size) return;\n+  size = RoundUpTo(size, PAGE_SIZE);\n+\n+  zx_status_t status = _zx_vmar_unmap(_zx_vmar_root_self(),\n+                                      reinterpret_cast<uintptr_t>(addr), size);\n+  if (status != ZX_OK) {\n+    Report(\"ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n+           SanitizerToolName, size, size, addr);\n+    CHECK(\"unable to unmap\" && 0);\n+  }\n+\n+  DecreaseTotalMmap(size);\n+}\n+\n+// This is used on the shadow mapping, which cannot be changed.\n+// Zircon doesn't have anything like MADV_DONTNEED.\n+void ReleaseMemoryPagesToOS(uptr beg, uptr end) {}\n+\n+void DumpProcessMap() {\n+  UNIMPLEMENTED();  // TODO(mcgrathr): write it\n+}\n+\n+bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n+  // TODO(mcgrathr): Figure out a better way.\n+  zx_handle_t vmo;\n+  zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n+  if (status == ZX_OK) {\n+    while (size > 0) {\n+      size_t wrote;\n+      status = _zx_vmo_write(vmo, reinterpret_cast<const void *>(beg), 0, size,\n+                             &wrote);\n+      if (status != ZX_OK) break;\n+      CHECK_GT(wrote, 0);\n+      CHECK_LE(wrote, size);\n+      beg += wrote;\n+      size -= wrote;\n+    }\n+    _zx_handle_close(vmo);\n+  }\n+  return status == ZX_OK;\n+}\n+\n+// FIXME implement on this platform.\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {}\n+\n+bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n+                      uptr *read_len, uptr max_len, error_t *errno_p) {\n+  zx_handle_t vmo;\n+  zx_status_t status = __sanitizer_get_configuration(file_name, &vmo);\n+  if (status == ZX_OK) {\n+    uint64_t vmo_size;\n+    status = _zx_vmo_get_size(vmo, &vmo_size);\n+    if (status == ZX_OK) {\n+      if (vmo_size < max_len) max_len = vmo_size;\n+      size_t map_size = RoundUpTo(max_len, PAGE_SIZE);\n+      uintptr_t addr;\n+      status = _zx_vmar_map(_zx_vmar_root_self(), 0, vmo, 0, map_size,\n+                            ZX_VM_FLAG_PERM_READ, &addr);\n+      if (status == ZX_OK) {\n+        *buff = reinterpret_cast<char *>(addr);\n+        *buff_size = map_size;\n+        *read_len = max_len;\n+      }\n+    }\n+    _zx_handle_close(vmo);\n+  }\n+  if (status != ZX_OK && errno_p) *errno_p = status;\n+  return status == ZX_OK;\n+}\n+\n+void RawWrite(const char *buffer) {\n+  __sanitizer_log_write(buffer, internal_strlen(buffer));\n+}\n+\n+void CatastrophicErrorWrite(const char *buffer, uptr length) {\n+  __sanitizer_log_write(buffer, length);\n+}\n+\n+char **StoredArgv;\n+char **StoredEnviron;\n+\n+char **GetArgv() { return StoredArgv; }\n+\n+const char *GetEnv(const char *name) {\n+  if (StoredEnviron) {\n+    uptr NameLen = internal_strlen(name);\n+    for (char **Env = StoredEnviron; *Env != 0; Env++) {\n+      if (internal_strncmp(*Env, name, NameLen) == 0 && (*Env)[NameLen] == '=')\n+        return (*Env) + NameLen + 1;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+uptr ReadBinaryName(/*out*/ char *buf, uptr buf_len) {\n+  const char *argv0 = StoredArgv[0];\n+  if (!argv0) argv0 = \"<UNKNOWN>\";\n+  internal_strncpy(buf, argv0, buf_len);\n+  return internal_strlen(buf);\n+}\n+\n+uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {\n+  return ReadBinaryName(buf, buf_len);\n+}\n+\n+uptr MainThreadStackBase, MainThreadStackSize;\n+\n+bool GetRandom(void *buffer, uptr length, bool blocking) {\n+  CHECK_LE(length, ZX_CPRNG_DRAW_MAX_LEN);\n+  size_t size;\n+  CHECK_EQ(_zx_cprng_draw(buffer, length, &size), ZX_OK);\n+  CHECK_EQ(size, length);\n+  return true;\n+}\n+\n+}  // namespace __sanitizer\n+\n+using namespace __sanitizer;  // NOLINT\n+\n+extern \"C\" {\n+void __sanitizer_startup_hook(int argc, char **argv, char **envp,\n+                              void *stack_base, size_t stack_size) {\n+  __sanitizer::StoredArgv = argv;\n+  __sanitizer::StoredEnviron = envp;\n+  __sanitizer::MainThreadStackBase = reinterpret_cast<uintptr_t>(stack_base);\n+  __sanitizer::MainThreadStackSize = stack_size;\n+}\n+\n+void __sanitizer_set_report_path(const char *path) {\n+  // Handle the initialization code in each sanitizer, but no other calls.\n+  // This setting is never consulted on Fuchsia.\n+  DCHECK_EQ(path, common_flags()->log_path);\n+}\n+\n+void __sanitizer_set_report_fd(void *fd) {\n+  UNREACHABLE(\"not available on Fuchsia\");\n+}\n+}  // extern \"C\"\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "59b679d6c7faf1de74592648a1abb59fbc504220", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,29 @@\n+//===-- sanitizer_fuchsia.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===---------------------------------------------------------------------===//\n+//\n+// Fuchsia-specific sanitizer support.\n+//\n+//===---------------------------------------------------------------------===//\n+#ifndef SANITIZER_FUCHSIA_H\n+#define SANITIZER_FUCHSIA_H\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_FUCHSIA\n+\n+#include \"sanitizer_common.h\"\n+\n+#include <zircon/sanitizer.h>\n+\n+namespace __sanitizer {\n+\n+extern uptr MainThreadStackBase, MainThreadStackSize;\n+extern sanitizer_shadow_bounds_t ShadowBounds;\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FUCHSIA\n+#endif  // SANITIZER_FUCHSIA_H"}, {"sha": "08c110c707c9a780b11ba4309c0159afdfb5c69b", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -45,7 +45,10 @@ extern \"C\" {\n   void __sanitizer_report_error_summary(const char *error_summary);\n \n   SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump();\n-  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init();\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(\n+      const __sanitizer::uptr *pcs, const __sanitizer::uptr len);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_trace_pc_guard_coverage();\n+\n   SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(__sanitizer::u32 *guard);\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_annotate_contiguous_container(const void *beg,\n@@ -58,6 +61,49 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   const void *__sanitizer_contiguous_container_find_bad_address(\n       const void *beg, const void *mid, const void *end);\n-  } // extern \"C\"\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __sanitizer_get_module_and_offset_for_pc(\n+      __sanitizer::uptr pc, char *module_path,\n+      __sanitizer::uptr module_path_len, __sanitizer::uptr *pc_offset);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_cmp();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_cmp1();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_cmp2();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_cmp4();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_cmp8();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_const_cmp1();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_const_cmp2();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_const_cmp4();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_const_cmp8();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_switch();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_div4();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_div8();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_gep();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_pc_indir();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_pc_guard(__sanitizer::u32*);\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_trace_pc_guard_init(__sanitizer::u32*,\n+                                           __sanitizer::u32*);\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_8bit_counters_init();\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+  void __sanitizer_cov_pcs_init();\n+} // extern \"C\"\n \n #endif  // SANITIZER_INTERFACE_INTERNAL_H"}, {"sha": "ef405dec04854d551fcc26c172c60ea16b418949", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 75, "deletions": 24, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -19,8 +19,11 @@\n \n // Only use SANITIZER_*ATTRIBUTE* before the function return type!\n #if SANITIZER_WINDOWS\n+#if SANITIZER_IMPORT_INTERFACE\n+# define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllimport)\n+#else\n # define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllexport)\n-// FIXME find out what we need on Windows, if anything.\n+#endif\n # define SANITIZER_WEAK_ATTRIBUTE\n #elif SANITIZER_GO\n # define SANITIZER_INTERFACE_ATTRIBUTE\n@@ -30,11 +33,56 @@\n # define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n #endif\n \n-#if (SANITIZER_LINUX || SANITIZER_WINDOWS) && !SANITIZER_GO\n+// TLS is handled differently on different platforms\n+#if SANITIZER_LINUX\n+# define SANITIZER_TLS_INITIAL_EXEC_ATTRIBUTE \\\n+    __attribute__((tls_model(\"initial-exec\"))) thread_local\n+#else\n+# define SANITIZER_TLS_INITIAL_EXEC_ATTRIBUTE\n+#endif\n+\n+//--------------------------- WEAK FUNCTIONS ---------------------------------//\n+// When working with weak functions, to simplify the code and make it more\n+// portable, when possible define a default implementation using this macro:\n+//\n+// SANITIZER_INTERFACE_WEAK_DEF(<return_type>, <name>, <parameter list>)\n+//\n+// For example:\n+//   SANITIZER_INTERFACE_WEAK_DEF(bool, compare, int a, int b) { return a > b; }\n+//\n+#if SANITIZER_WINDOWS\n+#include \"sanitizer_win_defs.h\"\n+# define SANITIZER_INTERFACE_WEAK_DEF(ReturnType, Name, ...)                   \\\n+  WIN_WEAK_EXPORT_DEF(ReturnType, Name, __VA_ARGS__)\n+#else\n+# define SANITIZER_INTERFACE_WEAK_DEF(ReturnType, Name, ...)                   \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE            \\\n+  ReturnType Name(__VA_ARGS__)\n+#endif\n+\n+// SANITIZER_SUPPORTS_WEAK_HOOKS means that we support real weak functions that\n+// will evaluate to a null pointer when not defined.\n+#ifndef SANITIZER_SUPPORTS_WEAK_HOOKS\n+#if (SANITIZER_LINUX || SANITIZER_MAC) && !SANITIZER_GO\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n #else\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n #endif\n+#endif // SANITIZER_SUPPORTS_WEAK_HOOKS\n+// For some weak hooks that will be called very often and we want to avoid the\n+// overhead of executing the default implementation when it is not necessary,\n+// we can use the flag SANITIZER_SUPPORTS_WEAK_HOOKS to only define the default\n+// implementation for platforms that doesn't support weak symbols. For example:\n+//\n+//   #if !SANITIZER_SUPPORT_WEAK_HOOKS\n+//     SANITIZER_INTERFACE_WEAK_DEF(bool, compare_hook, int a, int b) {\n+//       return a > b;\n+//     }\n+//   #endif\n+//\n+// And then use it as: if (compare_hook) compare_hook(a, b);\n+//----------------------------------------------------------------------------//\n+\n \n // We can use .preinit_array section on Linux to call sanitizer initialization\n // functions very early in the process startup (unless PIC macro is defined).\n@@ -89,12 +137,8 @@ typedef int error_t;\n #endif\n typedef int pid_t;\n \n-// WARNING: OFF_T may be different from OS type off_t, depending on the value of\n-// _FILE_OFFSET_BITS. This definition of OFF_T matches the ABI of system calls\n-// like pread and mmap, as opposed to pread64 and mmap64.\n-// FreeBSD, Mac and Linux/x86-64 are special.\n-#if SANITIZER_FREEBSD || SANITIZER_MAC || \\\n-  (SANITIZER_LINUX && defined(__x86_64__))\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_MAC || \\\n+    (SANITIZER_LINUX && defined(__x86_64__))\n typedef u64 OFF_T;\n #else\n typedef uptr OFF_T;\n@@ -112,6 +156,12 @@ typedef u32 operator_new_size_type;\n # endif\n #endif\n \n+#if SANITIZER_MAC\n+// On Darwin, thread IDs are 64-bit even on 32-bit systems.\n+typedef u64 tid_t;\n+#else\n+typedef uptr tid_t;\n+#endif\n \n // ----------- ATTENTION -------------\n // This header should NOT include any other headers to avoid portability issues.\n@@ -211,8 +261,8 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n \n #define CHECK_IMPL(c1, op, c2) \\\n   do { \\\n-    __sanitizer::u64 v1 = (u64)(c1); \\\n-    __sanitizer::u64 v2 = (u64)(c2); \\\n+    __sanitizer::u64 v1 = (__sanitizer::u64)(c1); \\\n+    __sanitizer::u64 v2 = (__sanitizer::u64)(c2); \\\n     if (UNLIKELY(!(v1 op v2))) \\\n       __sanitizer::CheckFailed(__FILE__, __LINE__, \\\n         \"(\" #c1 \") \" #op \" (\" #c2 \")\", v1, v2); \\\n@@ -287,13 +337,13 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n enum LinkerInitialized { LINKER_INITIALIZED = 0 };\n \n #if !defined(_MSC_VER) || defined(__clang__)\n-# if SANITIZER_S390_31\n-#  define GET_CALLER_PC() \\\n-  (uptr)__builtin_extract_return_addr(__builtin_return_address(0))\n-# else\n-#  define GET_CALLER_PC() (uptr)__builtin_return_address(0)\n-# endif\n-# define GET_CURRENT_FRAME() (uptr)__builtin_frame_address(0)\n+#if SANITIZER_S390_31\n+#define GET_CALLER_PC() \\\n+  (__sanitizer::uptr) __builtin_extract_return_addr(__builtin_return_address(0))\n+#else\n+#define GET_CALLER_PC() (__sanitizer::uptr) __builtin_return_address(0)\n+#endif\n+#define GET_CURRENT_FRAME() (__sanitizer::uptr) __builtin_frame_address(0)\n inline void Trap() {\n   __builtin_trap();\n }\n@@ -302,9 +352,10 @@ extern \"C\" void* _ReturnAddress(void);\n extern \"C\" void* _AddressOfReturnAddress(void);\n # pragma intrinsic(_ReturnAddress)\n # pragma intrinsic(_AddressOfReturnAddress)\n-# define GET_CALLER_PC() (uptr)_ReturnAddress()\n+#define GET_CALLER_PC() (__sanitizer::uptr) _ReturnAddress()\n // CaptureStackBackTrace doesn't need to know BP on Windows.\n-# define GET_CURRENT_FRAME() (((uptr)_AddressOfReturnAddress()) + sizeof(uptr))\n+#define GET_CURRENT_FRAME() \\\n+  (((__sanitizer::uptr)_AddressOfReturnAddress()) + sizeof(__sanitizer::uptr))\n \n extern \"C\" void __ud2(void);\n # pragma intrinsic(__ud2)\n@@ -322,11 +373,11 @@ inline void Trap() {\n   }\n \n // Forces the compiler to generate a frame pointer in the function.\n-#define ENABLE_FRAME_POINTER                                       \\\n-  do {                                                             \\\n-    volatile uptr enable_fp;                                       \\\n-    enable_fp = GET_CURRENT_FRAME();                               \\\n-    (void)enable_fp;                                               \\\n+#define ENABLE_FRAME_POINTER              \\\n+  do {                                    \\\n+    volatile __sanitizer::uptr enable_fp; \\\n+    enable_fp = GET_CURRENT_FRAME();      \\\n+    (void)enable_fp;                      \\\n   } while (0)\n \n }  // namespace __sanitizer"}, {"sha": "e20c7559b8e1490ae05fe478a53a760e41998633", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -7,7 +7,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || SANITIZER_NETBSD\n \n #include \"sanitizer_libignore.h\"\n #include \"sanitizer_flags.h\"\n@@ -48,23 +48,23 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n   }\n \n   // Scan suppressions list and find newly loaded and unloaded libraries.\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n-  InternalScopedString module(kMaxPathLength);\n+  ListOfModules modules;\n+  modules.init();\n   for (uptr i = 0; i < count_; i++) {\n     Lib *lib = &libs_[i];\n     bool loaded = false;\n-    proc_maps.Reset();\n-    uptr b, e, off, prot;\n-    while (proc_maps.Next(&b, &e, &off, module.data(), module.size(), &prot)) {\n-      if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n-        continue;\n-      if (TemplateMatch(lib->templ, module.data()) ||\n-          (lib->real_name &&\n-          internal_strcmp(lib->real_name, module.data()) == 0)) {\n+    for (const auto &mod : modules) {\n+      for (const auto &range : mod.ranges()) {\n+        if (!range.executable)\n+          continue;\n+        if (!TemplateMatch(lib->templ, mod.full_name()) &&\n+            !(lib->real_name &&\n+            internal_strcmp(lib->real_name, mod.full_name()) == 0))\n+          continue;\n         if (loaded) {\n           Report(\"%s: called_from_lib suppression '%s' is matched against\"\n                  \" 2 libraries: '%s' and '%s'\\n\",\n-                 SanitizerToolName, lib->templ, lib->name, module.data());\n+                 SanitizerToolName, lib->templ, lib->name, mod.full_name());\n           Die();\n         }\n         loaded = true;\n@@ -73,13 +73,16 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n         VReport(1,\n                 \"Matched called_from_lib suppression '%s' against library\"\n                 \" '%s'\\n\",\n-                lib->templ, module.data());\n+                lib->templ, mod.full_name());\n         lib->loaded = true;\n-        lib->name = internal_strdup(module.data());\n-        const uptr idx = atomic_load(&loaded_count_, memory_order_relaxed);\n-        code_ranges_[idx].begin = b;\n-        code_ranges_[idx].end = e;\n-        atomic_store(&loaded_count_, idx + 1, memory_order_release);\n+        lib->name = internal_strdup(mod.full_name());\n+        const uptr idx =\n+            atomic_load(&ignored_ranges_count_, memory_order_relaxed);\n+        CHECK_LT(idx, kMaxLibs);\n+        ignored_code_ranges_[idx].begin = range.beg;\n+        ignored_code_ranges_[idx].end = range.end;\n+        atomic_store(&ignored_ranges_count_, idx + 1, memory_order_release);\n+        break;\n       }\n     }\n     if (lib->loaded && !loaded) {\n@@ -89,6 +92,29 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n       Die();\n     }\n   }\n+\n+  // Track instrumented ranges.\n+  if (track_instrumented_libs_) {\n+    for (const auto &mod : modules) {\n+      if (!mod.instrumented())\n+        continue;\n+      for (const auto &range : mod.ranges()) {\n+        if (!range.executable)\n+          continue;\n+        if (IsPcInstrumented(range.beg) && IsPcInstrumented(range.end - 1))\n+          continue;\n+        VReport(1, \"Adding instrumented range %p-%p from library '%s'\\n\",\n+                range.beg, range.end, mod.full_name());\n+        const uptr idx =\n+            atomic_load(&instrumented_ranges_count_, memory_order_relaxed);\n+        CHECK_LT(idx, kMaxLibs);\n+        instrumented_code_ranges_[idx].begin = range.beg;\n+        instrumented_code_ranges_[idx].end = range.end;\n+        atomic_store(&instrumented_ranges_count_, idx + 1,\n+                     memory_order_release);\n+      }\n+    }\n+  }\n }\n \n void LibIgnore::OnLibraryUnloaded() {\n@@ -97,4 +123,5 @@ void LibIgnore::OnLibraryUnloaded() {\n \n } // namespace __sanitizer\n \n-#endif // #if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC ||\n+        // SANITIZER_NETBSD"}, {"sha": "e7627ee025650a154a0e60b99eec646c833093f6", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.h", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -28,15 +28,24 @@ class LibIgnore {\n \n   // Must be called during initialization.\n   void AddIgnoredLibrary(const char *name_templ);\n+  void IgnoreNoninstrumentedModules(bool enable) {\n+    track_instrumented_libs_ = enable;\n+  }\n \n   // Must be called after a new dynamic library is loaded.\n   void OnLibraryLoaded(const char *name);\n \n   // Must be called after a dynamic library is unloaded.\n   void OnLibraryUnloaded();\n \n-  // Checks whether the provided PC belongs to one of the ignored libraries.\n-  bool IsIgnored(uptr pc) const;\n+  // Checks whether the provided PC belongs to one of the ignored libraries or\n+  // the PC should be ignored because it belongs to an non-instrumented module\n+  // (when ignore_noninstrumented_modules=1). Also returns true via\n+  // \"pc_in_ignored_lib\" if the PC is in an ignored library, false otherwise.\n+  bool IsIgnored(uptr pc, bool *pc_in_ignored_lib) const;\n+\n+  // Checks whether the provided PC belongs to an instrumented module.\n+  bool IsPcInstrumented(uptr pc) const;\n \n  private:\n   struct Lib {\n@@ -51,26 +60,48 @@ class LibIgnore {\n     uptr end;\n   };\n \n+  inline bool IsInRange(uptr pc, const LibCodeRange &range) const {\n+    return (pc >= range.begin && pc < range.end);\n+  }\n+\n   static const uptr kMaxLibs = 128;\n \n   // Hot part:\n-  atomic_uintptr_t loaded_count_;\n-  LibCodeRange code_ranges_[kMaxLibs];\n+  atomic_uintptr_t ignored_ranges_count_;\n+  LibCodeRange ignored_code_ranges_[kMaxLibs];\n+\n+  atomic_uintptr_t instrumented_ranges_count_;\n+  LibCodeRange instrumented_code_ranges_[kMaxLibs];\n \n   // Cold part:\n   BlockingMutex mutex_;\n   uptr count_;\n   Lib libs_[kMaxLibs];\n+  bool track_instrumented_libs_;\n \n   // Disallow copying of LibIgnore objects.\n   LibIgnore(const LibIgnore&);  // not implemented\n   void operator = (const LibIgnore&);  // not implemented\n };\n \n-inline bool LibIgnore::IsIgnored(uptr pc) const {\n-  const uptr n = atomic_load(&loaded_count_, memory_order_acquire);\n+inline bool LibIgnore::IsIgnored(uptr pc, bool *pc_in_ignored_lib) const {\n+  const uptr n = atomic_load(&ignored_ranges_count_, memory_order_acquire);\n+  for (uptr i = 0; i < n; i++) {\n+    if (IsInRange(pc, ignored_code_ranges_[i])) {\n+      *pc_in_ignored_lib = true;\n+      return true;\n+    }\n+  }\n+  *pc_in_ignored_lib = false;\n+  if (track_instrumented_libs_ && !IsPcInstrumented(pc))\n+    return true;\n+  return false;\n+}\n+\n+inline bool LibIgnore::IsPcInstrumented(uptr pc) const {\n+  const uptr n = atomic_load(&instrumented_ranges_count_, memory_order_acquire);\n   for (uptr i = 0; i < n; i++) {\n-    if (pc >= code_ranges_[i].begin && pc < code_ranges_[i].end)\n+    if (IsInRange(pc, instrumented_code_ranges_[i]))\n       return true;\n   }\n   return false;"}, {"sha": "2826cc89e202aea512f7af63b40576ff92f2a9a3", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 503, "deletions": 60, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -12,7 +12,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n@@ -25,10 +25,14 @@\n #include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_symbolizer.h\"\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n #include <asm/param.h>\n #endif\n \n+#if SANITIZER_NETBSD\n+#include <lwp.h>\n+#endif\n+\n // For mips64, syscall(__NR_stat) fills the buffer in the 'struct kernel_stat'\n // format. Struct kernel_stat is defined as 'struct stat' in asm/stat.h. To\n // access stat from asm/stat.h, without conflicting with definition in\n@@ -57,11 +61,17 @@\n #include <ucontext.h>\n #include <unistd.h>\n \n+#if SANITIZER_LINUX\n+#include <sys/utsname.h>\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#include <sys/personality.h>\n+#endif\n+\n #if SANITIZER_FREEBSD\n #include <sys/exec.h>\n #include <sys/sysctl.h>\n-#include <vm/vm_param.h>\n-#include <vm/pmap.h>\n #include <machine/atomic.h>\n extern \"C\" {\n // <sys/umtx.h> must be included after <errno.h> and <sys/types.h> on\n@@ -71,10 +81,30 @@ extern \"C\" {\n extern char **environ;  // provided by crt1\n #endif  // SANITIZER_FREEBSD\n \n+#if SANITIZER_NETBSD\n+#include <limits.h>  // For NAME_MAX\n+#include <sys/sysctl.h>\n+extern char **environ;  // provided by crt1\n+#endif                  // SANITIZER_NETBSD\n+\n #if !SANITIZER_ANDROID\n #include <sys/signal.h>\n #endif\n \n+#ifndef __GLIBC_PREREQ\n+#define __GLIBC_PREREQ(x, y) 0\n+#endif\n+\n+#if SANITIZER_LINUX && __GLIBC_PREREQ(2, 16)\n+# define SANITIZER_USE_GETAUXVAL 1\n+#else\n+# define SANITIZER_USE_GETAUXVAL 0\n+#endif\n+\n+#if SANITIZER_USE_GETAUXVAL\n+#include <sys/auxv.h>\n+#endif\n+\n #if SANITIZER_LINUX\n // <linux/time.h>\n struct kernel_timeval {\n@@ -103,6 +133,15 @@ extern void internal_sigreturn();\n }\n #endif\n \n+#if SANITIZER_LINUX && defined(__NR_getrandom)\n+# if !defined(GRND_NONBLOCK)\n+#  define GRND_NONBLOCK 1\n+# endif\n+# define SANITIZER_USE_GETRANDOM 1\n+#else\n+# define SANITIZER_USE_GETRANDOM 0\n+#endif  // SANITIZER_LINUX && defined(__NR_getrandom)\n+\n namespace __sanitizer {\n \n #if SANITIZER_LINUX && defined(__x86_64__)\n@@ -117,7 +156,10 @@ namespace __sanitizer {\n #if !SANITIZER_S390\n uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n                    OFF_T offset) {\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+#if SANITIZER_NETBSD\n+  return internal_syscall_ptr(SYSCALL(mmap), addr, length, prot, flags, fd,\n+                              (long)0, offset);\n+#elif SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   return internal_syscall(SYSCALL(mmap), (uptr)addr, length, prot, flags, fd,\n                           offset);\n #else\n@@ -160,26 +202,38 @@ uptr internal_open(const char *filename, int flags, u32 mode) {\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   sptr res;\n+#if SANITIZER_NETBSD\n+  HANDLE_EINTR(res, internal_syscall_ptr(SYSCALL(read), fd, buf, count));\n+#else\n   HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(read), fd, (uptr)buf,\n                count));\n+#endif\n   return res;\n }\n \n uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   sptr res;\n+#if SANITIZER_NETBSD\n+  HANDLE_EINTR(res, internal_syscall_ptr(SYSCALL(write), fd, buf, count));\n+#else\n   HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(write), fd, (uptr)buf,\n                count));\n+#endif\n   return res;\n }\n \n uptr internal_ftruncate(fd_t fd, uptr size) {\n   sptr res;\n+#if SANITIZER_NETBSD\n+  HANDLE_EINTR(res, internal_syscall(SYSCALL(ftruncate), fd, 0, (s64)size));\n+#else\n   HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(ftruncate), fd,\n                (OFF_T)size));\n+#endif\n   return res;\n }\n \n-#if !SANITIZER_LINUX_USES_64BIT_SYSCALLS && !SANITIZER_FREEBSD\n+#if !SANITIZER_LINUX_USES_64BIT_SYSCALLS && SANITIZER_LINUX\n static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n   internal_memset(out, 0, sizeof(*out));\n   out->st_dev = in->st_dev;\n@@ -195,11 +249,25 @@ static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n   out->st_atime = in->st_atime;\n   out->st_mtime = in->st_mtime;\n   out->st_ctime = in->st_ctime;\n-  out->st_ino = in->st_ino;\n }\n #endif\n \n #if defined(__mips64)\n+// Undefine compatibility macros from <sys/stat.h>\n+// so that they would not clash with the kernel_stat\n+// st_[a|m|c]time fields\n+#undef st_atime\n+#undef st_mtime\n+#undef st_ctime\n+#if defined(SANITIZER_ANDROID)\n+// Bionic sys/stat.h defines additional macros\n+// for compatibility with the old NDKs and\n+// they clash with the kernel_stat structure\n+// st_[a|m|c]time_nsec fields.\n+#undef st_atime_nsec\n+#undef st_mtime_nsec\n+#undef st_ctime_nsec\n+#endif\n static void kernel_stat_to_stat(struct kernel_stat *in, struct stat *out) {\n   internal_memset(out, 0, sizeof(*out));\n   out->st_dev = in->st_dev;\n@@ -212,16 +280,30 @@ static void kernel_stat_to_stat(struct kernel_stat *in, struct stat *out) {\n   out->st_size = in->st_size;\n   out->st_blksize = in->st_blksize;\n   out->st_blocks = in->st_blocks;\n-  out->st_atime = in->st_atime_nsec;\n-  out->st_mtime = in->st_mtime_nsec;\n-  out->st_ctime = in->st_ctime_nsec;\n-  out->st_ino = in->st_ino;\n+#if defined(__USE_MISC)     || \\\n+    defined(__USE_XOPEN2K8) || \\\n+    defined(SANITIZER_ANDROID)\n+  out->st_atim.tv_sec = in->st_atime;\n+  out->st_atim.tv_nsec = in->st_atime_nsec;\n+  out->st_mtim.tv_sec = in->st_mtime;\n+  out->st_mtim.tv_nsec = in->st_mtime_nsec;\n+  out->st_ctim.tv_sec = in->st_ctime;\n+  out->st_ctim.tv_nsec = in->st_ctime_nsec;\n+#else\n+  out->st_atime = in->st_atime;\n+  out->st_atimensec = in->st_atime_nsec;\n+  out->st_mtime = in->st_mtime;\n+  out->st_mtimensec = in->st_mtime_nsec;\n+  out->st_ctime = in->st_ctime;\n+  out->st_atimensec = in->st_ctime_nsec;\n+#endif\n }\n #endif\n \n uptr internal_stat(const char *path, void *buf) {\n-#if SANITIZER_FREEBSD\n-  return internal_syscall(SYSCALL(stat), path, buf);\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n+  return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path,\n+                          (uptr)buf, 0);\n #elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n                           (uptr)buf, 0);\n@@ -244,8 +326,11 @@ uptr internal_stat(const char *path, void *buf) {\n }\n \n uptr internal_lstat(const char *path, void *buf) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_NETBSD\n   return internal_syscall(SYSCALL(lstat), path, buf);\n+#elif SANITIZER_FREEBSD\n+  return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path,\n+                          (uptr)buf, AT_SYMLINK_NOFOLLOW);\n #elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n                          (uptr)buf, AT_SYMLINK_NOFOLLOW);\n@@ -268,7 +353,7 @@ uptr internal_lstat(const char *path, void *buf) {\n }\n \n uptr internal_fstat(fd_t fd, void *buf) {\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS || SANITIZER_NETBSD\n # if SANITIZER_MIPS64\n   // For mips64, fstat syscall fills buffer in the format of kernel_stat\n   struct kernel_stat kbuf;\n@@ -302,7 +387,9 @@ uptr internal_dup2(int oldfd, int newfd) {\n }\n \n uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n-#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+#if SANITIZER_NETBSD\n+  return internal_syscall_ptr(SYSCALL(readlink), path, buf, bufsize);\n+#elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(readlinkat), AT_FDCWD,\n                           (uptr)path, (uptr)buf, bufsize);\n #else\n@@ -332,7 +419,7 @@ uptr internal_sched_yield() {\n }\n \n void internal__exit(int exitcode) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n   internal_syscall(SYSCALL(exit), exitcode);\n #else\n   internal_syscall(SYSCALL(exit_group), exitcode);\n@@ -368,30 +455,36 @@ bool FileExists(const char *filename) {\n   return S_ISREG(st.st_mode);\n }\n \n-uptr GetTid() {\n+tid_t GetTid() {\n #if SANITIZER_FREEBSD\n   return (uptr)pthread_self();\n+#elif SANITIZER_NETBSD\n+  return _lwp_self();\n #else\n   return internal_syscall(SYSCALL(gettid));\n #endif\n }\n \n u64 NanoTime() {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n   timeval tv;\n #else\n   kernel_timeval tv;\n #endif\n   internal_memset(&tv, 0, sizeof(tv));\n+#if SANITIZER_NETBSD\n+  internal_syscall_ptr(SYSCALL(gettimeofday), &tv, NULL);\n+#else\n   internal_syscall(SYSCALL(gettimeofday), (uptr)&tv, 0);\n+#endif\n   return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n }\n \n // Like getenv, but reads env directly from /proc (on Linux) or parses the\n // 'environ' array (on FreeBSD) and does not use libc. This function should be\n // called first inside __asan_init.\n const char *GetEnv(const char *name) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n   if (::environ != 0) {\n     uptr NameLen = internal_strlen(name);\n     for (char **Env = ::environ; *Env != 0; Env++) {\n@@ -525,6 +618,8 @@ void BlockingMutex::Lock() {\n   while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked) {\n #if SANITIZER_FREEBSD\n     _umtx_op(m, UMTX_OP_WAIT_UINT, MtxSleeping, 0, 0);\n+#elif SANITIZER_NETBSD\n+    sched_yield(); /* No userspace futex-like synchromization */\n #else\n     internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n #endif\n@@ -533,11 +628,13 @@ void BlockingMutex::Lock() {\n \n void BlockingMutex::Unlock() {\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n-  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_relaxed);\n+  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_release);\n   CHECK_NE(v, MtxUnlocked);\n   if (v == MtxSleeping) {\n #if SANITIZER_FREEBSD\n     _umtx_op(m, UMTX_OP_WAKE, 1, 0, 0);\n+#elif SANITIZER_NETBSD\n+                   /* No userspace futex-like synchromization */\n #else\n     internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAKE, 1, 0, 0, 0);\n #endif\n@@ -553,6 +650,17 @@ void BlockingMutex::CheckLocked() {\n // The actual size of this structure is specified by d_reclen.\n // Note that getdents64 uses a different structure format. We only provide the\n // 32-bit syscall here.\n+#if SANITIZER_NETBSD\n+// struct dirent is different for Linux and us. At this moment, we use only\n+// d_fileno (Linux call this d_ino), d_reclen, and d_name.\n+struct linux_dirent {\n+  u64 d_ino;  // d_fileno\n+  u16 d_reclen;\n+  u16 d_namlen;  // not used\n+  u8 d_type;     // not used\n+  char d_name[NAME_MAX + 1];\n+};\n+#else\n struct linux_dirent {\n #if SANITIZER_X32 || defined(__aarch64__)\n   u64 d_ino;\n@@ -567,16 +675,34 @@ struct linux_dirent {\n #endif\n   char               d_name[256];\n };\n+#endif\n \n // Syscall wrappers.\n uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n+#if SANITIZER_NETBSD\n+  // XXX We need additional work for ptrace:\n+  //   - for request, we use PT_FOO whereas Linux uses PTRACE_FOO\n+  //   - data is int for us, but void * for Linux\n+  //   - Linux sometimes uses data in the case where we use addr instead\n+  // At this moment, this function is used only within\n+  // \"#if SANITIZER_LINUX && defined(__x86_64__)\" block in\n+  // sanitizer_stoptheworld_linux_libcdep.cc.\n+  return internal_syscall_ptr(SYSCALL(ptrace), request, pid, (uptr)addr,\n+                              (uptr)data);\n+#else\n   return internal_syscall(SYSCALL(ptrace), request, pid, (uptr)addr,\n                           (uptr)data);\n+#endif\n }\n \n uptr internal_waitpid(int pid, int *status, int options) {\n+#if SANITIZER_NETBSD\n+  return internal_syscall(SYSCALL(wait4), pid, status, options,\n+                          NULL /* rusage */);\n+#else\n   return internal_syscall(SYSCALL(wait4), pid, (uptr)status, options,\n                           0 /* rusage */);\n+#endif\n }\n \n uptr internal_getpid() {\n@@ -588,15 +714,23 @@ uptr internal_getppid() {\n }\n \n uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count) {\n-#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+#if SANITIZER_NETBSD\n+  return internal_syscall(SYSCALL(getdents), fd, dirp, (uptr)count);\n+#elif SANITIZER_FREEBSD\n+  return internal_syscall(SYSCALL(getdirentries), fd, (uptr)dirp, count, NULL);\n+#elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(getdents64), fd, (uptr)dirp, count);\n #else\n   return internal_syscall(SYSCALL(getdents), fd, (uptr)dirp, count);\n #endif\n }\n \n uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {\n+#if SANITIZER_NETBSD\n+  return internal_syscall64(SYSCALL(lseek), fd, 0, offset, whence);\n+#else\n   return internal_syscall(SYSCALL(lseek), fd, offset, whence);\n+#endif\n }\n \n #if SANITIZER_LINUX\n@@ -687,7 +821,7 @@ int internal_sigaction_syscall(int signum, const void *act, void *oldact) {\n \n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n     __sanitizer_sigset_t *oldset) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n   return internal_syscall(SYSCALL(sigprocmask), how, set, oldset);\n #else\n   __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n@@ -796,20 +930,94 @@ bool ThreadLister::GetDirectoryEntries() {\n   return true;\n }\n \n+#if SANITIZER_WORDSIZE == 32\n+// Take care of unusable kernel area in top gigabyte.\n+static uptr GetKernelAreaSize() {\n+#if SANITIZER_LINUX && !SANITIZER_X32\n+  const uptr gbyte = 1UL << 30;\n+\n+  // Firstly check if there are writable segments\n+  // mapped to top gigabyte (e.g. stack).\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+  MemoryMappedSegment segment;\n+  while (proc_maps.Next(&segment)) {\n+    if ((segment.end >= 3 * gbyte) && segment.IsWritable()) return 0;\n+  }\n+\n+#if !SANITIZER_ANDROID\n+  // Even if nothing is mapped, top Gb may still be accessible\n+  // if we are running on 64-bit kernel.\n+  // Uname may report misleading results if personality type\n+  // is modified (e.g. under schroot) so check this as well.\n+  struct utsname uname_info;\n+  int pers = personality(0xffffffffUL);\n+  if (!(pers & PER_MASK)\n+      && uname(&uname_info) == 0\n+      && internal_strstr(uname_info.machine, \"64\"))\n+    return 0;\n+#endif  // SANITIZER_ANDROID\n+\n+  // Top gigabyte is reserved for kernel.\n+  return gbyte;\n+#else\n+  return 0;\n+#endif  // SANITIZER_LINUX && !SANITIZER_X32\n+}\n+#endif  // SANITIZER_WORDSIZE == 32\n+\n+uptr GetMaxVirtualAddress() {\n+#if SANITIZER_NETBSD && defined(__x86_64__)\n+  return 0x7f7ffffff000ULL;  // (0x00007f8000000000 - PAGE_SIZE)\n+#elif SANITIZER_WORDSIZE == 64\n+# if defined(__powerpc64__) || defined(__aarch64__)\n+  // On PowerPC64 we have two different address space layouts: 44- and 46-bit.\n+  // We somehow need to figure out which one we are using now and choose\n+  // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n+  // Note that with 'ulimit -s unlimited' the stack is moved away from the top\n+  // of the address space, so simply checking the stack address is not enough.\n+  // This should (does) work for both PowerPC64 Endian modes.\n+  // Similarly, aarch64 has multiple address space layouts: 39, 42 and 47-bit.\n+  return (1ULL << (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1)) - 1;\n+# elif defined(__mips64)\n+  return (1ULL << 40) - 1;  // 0x000000ffffffffffUL;\n+# elif defined(__s390x__)\n+  return (1ULL << 53) - 1;  // 0x001fffffffffffffUL;\n+# else\n+  return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n+# endif\n+#else  // SANITIZER_WORDSIZE == 32\n+# if defined(__s390__)\n+  return (1ULL << 31) - 1;  // 0x7fffffff;\n+# else\n+  uptr res = (1ULL << 32) - 1;  // 0xffffffff;\n+  if (!common_flags()->full_address_space)\n+    res -= GetKernelAreaSize();\n+  CHECK_LT(reinterpret_cast<uptr>(&res), res);\n+  return res;\n+# endif\n+#endif  // SANITIZER_WORDSIZE\n+}\n+\n uptr GetPageSize() {\n // Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n #if SANITIZER_ANDROID\n   return 4096;\n #elif SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n   return EXEC_PAGESIZE;\n+#elif SANITIZER_USE_GETAUXVAL\n+  return getauxval(AT_PAGESZ);\n #else\n   return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.\n #endif\n }\n \n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n #if SANITIZER_FREEBSD\n-  const int Mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };\n+  const int Mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};\n+#else\n+  const int Mib[4] = {CTL_KERN, KERN_PROC_ARGS, -1, KERN_PROC_PATHNAME};\n+#endif\n   const char *default_module_name = \"kern.proc.pathname\";\n   size_t Size = buf_len;\n   bool IsErr = (sysctl(Mib, ARRAY_SIZE(Mib), buf, &Size, NULL, 0) != 0);\n@@ -1094,36 +1302,50 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n   long long res;\n-/* Stack frame offsets.  */\n-#if _CALL_ELF != 2\n-#define FRAME_MIN_SIZE         112\n-#define FRAME_TOC_SAVE         40\n+// Stack frame structure.\n+#if SANITIZER_PPC64V1\n+//   Back chain == 0        (SP + 112)\n+// Frame (112 bytes):\n+//   Parameter save area    (SP + 48), 8 doublewords\n+//   TOC save area          (SP + 40)\n+//   Link editor doubleword (SP + 32)\n+//   Compiler doubleword    (SP + 24)\n+//   LR save area           (SP + 16)\n+//   CR save area           (SP + 8)\n+//   Back chain             (SP + 0)\n+# define FRAME_SIZE 112\n+# define FRAME_TOC_SAVE_OFFSET 40\n+#elif SANITIZER_PPC64V2\n+//   Back chain == 0        (SP + 32)\n+// Frame (32 bytes):\n+//   TOC save area          (SP + 24)\n+//   LR save area           (SP + 16)\n+//   CR save area           (SP + 8)\n+//   Back chain             (SP + 0)\n+# define FRAME_SIZE 32\n+# define FRAME_TOC_SAVE_OFFSET 24\n #else\n-#define FRAME_MIN_SIZE         32\n-#define FRAME_TOC_SAVE         24\n+# error \"Unsupported PPC64 ABI\"\n #endif\n   if (!fn || !child_stack)\n     return -EINVAL;\n   CHECK_EQ(0, (uptr)child_stack % 16);\n-  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n-  ((unsigned long long *)child_stack)[0] = (uptr)fn;\n-  ((unsigned long long *)child_stack)[1] = (uptr)arg;\n \n   register int (*__fn)(void *) __asm__(\"r3\") = fn;\n   register void *__cstack      __asm__(\"r4\") = child_stack;\n   register int __flags         __asm__(\"r5\") = flags;\n-  register void * __arg        __asm__(\"r6\") = arg;\n-  register int * __ptidptr     __asm__(\"r7\") = parent_tidptr;\n-  register void * __newtls     __asm__(\"r8\") = newtls;\n-  register int * __ctidptr     __asm__(\"r9\") = child_tidptr;\n+  register void *__arg         __asm__(\"r6\") = arg;\n+  register int *__ptidptr      __asm__(\"r7\") = parent_tidptr;\n+  register void *__newtls      __asm__(\"r8\") = newtls;\n+  register int *__ctidptr      __asm__(\"r9\") = child_tidptr;\n \n  __asm__ __volatile__(\n-           /* fn, arg, child_stack are saved acrVoss the syscall */\n+           /* fn and arg are saved across the syscall */\n            \"mr 28, %5\\n\\t\"\n-           \"mr 29, %6\\n\\t\"\n            \"mr 27, %8\\n\\t\"\n \n            /* syscall\n+             r0 == __NR_clone\n              r3 == flags\n              r4 == child_stack\n              r5 == parent_tidptr\n@@ -1141,15 +1363,21 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n            \"crandc cr1*4+eq, cr1*4+eq, cr0*4+so\\n\\t\"\n            \"bne-   cr1, 1f\\n\\t\"\n \n+           /* Set up stack frame */\n+           \"li    29, 0\\n\\t\"\n+           \"stdu  29, -8(1)\\n\\t\"\n+           \"stdu  1, -%12(1)\\n\\t\"\n            /* Do the function call */\n            \"std   2, %13(1)\\n\\t\"\n-#if _CALL_ELF != 2\n+#if SANITIZER_PPC64V1\n            \"ld    0, 0(28)\\n\\t\"\n            \"ld    2, 8(28)\\n\\t\"\n            \"mtctr 0\\n\\t\"\n-#else\n+#elif SANITIZER_PPC64V2\n            \"mr    12, 28\\n\\t\"\n            \"mtctr 12\\n\\t\"\n+#else\n+# error \"Unsupported PPC64 ABI\"\n #endif\n            \"mr    3, 27\\n\\t\"\n            \"bctrl\\n\\t\"\n@@ -1163,13 +1391,151 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n            \"1:\\n\\t\"\n            \"mr %0, 3\\n\\t\"\n              : \"=r\" (res)\n-             : \"0\" (-1), \"i\" (EINVAL),\n-               \"i\" (__NR_clone), \"i\" (__NR_exit),\n-               \"r\" (__fn), \"r\" (__cstack), \"r\" (__flags),\n-               \"r\" (__arg), \"r\" (__ptidptr), \"r\" (__newtls),\n-               \"r\" (__ctidptr), \"i\" (FRAME_MIN_SIZE), \"i\" (FRAME_TOC_SAVE)\n-             : \"cr0\", \"cr1\", \"memory\", \"ctr\",\n-               \"r0\", \"r29\", \"r27\", \"r28\");\n+             : \"0\" (-1),\n+               \"i\" (EINVAL),\n+               \"i\" (__NR_clone),\n+               \"i\" (__NR_exit),\n+               \"r\" (__fn),\n+               \"r\" (__cstack),\n+               \"r\" (__flags),\n+               \"r\" (__arg),\n+               \"r\" (__ptidptr),\n+               \"r\" (__newtls),\n+               \"r\" (__ctidptr),\n+               \"i\" (FRAME_SIZE),\n+               \"i\" (FRAME_TOC_SAVE_OFFSET)\n+             : \"cr0\", \"cr1\", \"memory\", \"ctr\", \"r0\", \"r27\", \"r28\", \"r29\");\n+  return res;\n+}\n+#elif defined(__i386__) && SANITIZER_LINUX\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  int res;\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  child_stack = (char *)child_stack - 7 * sizeof(unsigned int);\n+  ((unsigned int *)child_stack)[0] = (uptr)flags;\n+  ((unsigned int *)child_stack)[1] = (uptr)0;\n+  ((unsigned int *)child_stack)[2] = (uptr)fn;\n+  ((unsigned int *)child_stack)[3] = (uptr)arg;\n+  __asm__ __volatile__(\n+                       /* %eax = syscall(%eax = SYSCALL(clone),\n+                        *                %ebx = flags,\n+                        *                %ecx = child_stack,\n+                        *                %edx = parent_tidptr,\n+                        *                %esi  = new_tls,\n+                        *                %edi = child_tidptr)\n+                        */\n+\n+                        /* Obtain flags */\n+                        \"movl    (%%ecx), %%ebx\\n\"\n+                        /* Do the system call */\n+                        \"pushl   %%ebx\\n\"\n+                        \"pushl   %%esi\\n\"\n+                        \"pushl   %%edi\\n\"\n+                        /* Remember the flag value.  */\n+                        \"movl    %%ebx, (%%ecx)\\n\"\n+                        \"int     $0x80\\n\"\n+                        \"popl    %%edi\\n\"\n+                        \"popl    %%esi\\n\"\n+                        \"popl    %%ebx\\n\"\n+\n+                        /* if (%eax != 0)\n+                         *   return;\n+                         */\n+\n+                        \"test    %%eax,%%eax\\n\"\n+                        \"jnz    1f\\n\"\n+\n+                        /* terminate the stack frame */\n+                        \"xorl   %%ebp,%%ebp\\n\"\n+                        /* Call FN. */\n+                        \"call    *%%ebx\\n\"\n+#ifdef PIC\n+                        \"call    here\\n\"\n+                        \"here:\\n\"\n+                        \"popl    %%ebx\\n\"\n+                        \"addl    $_GLOBAL_OFFSET_TABLE_+[.-here], %%ebx\\n\"\n+#endif\n+                        /* Call exit */\n+                        \"movl    %%eax, %%ebx\\n\"\n+                        \"movl    %2, %%eax\\n\"\n+                        \"int     $0x80\\n\"\n+                        \"1:\\n\"\n+                       : \"=a\" (res)\n+                       : \"a\"(SYSCALL(clone)), \"i\"(SYSCALL(exit)),\n+                         \"c\"(child_stack),\n+                         \"d\"(parent_tidptr),\n+                         \"S\"(newtls),\n+                         \"D\"(child_tidptr)\n+                       : \"memory\");\n+  return res;\n+}\n+#elif defined(__arm__) && SANITIZER_LINUX\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  unsigned int res;\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  child_stack = (char *)child_stack - 2 * sizeof(unsigned int);\n+  ((unsigned int *)child_stack)[0] = (uptr)fn;\n+  ((unsigned int *)child_stack)[1] = (uptr)arg;\n+  register int r0 __asm__(\"r0\") = flags;\n+  register void *r1 __asm__(\"r1\") = child_stack;\n+  register int *r2 __asm__(\"r2\") = parent_tidptr;\n+  register void *r3 __asm__(\"r3\") = newtls;\n+  register int *r4 __asm__(\"r4\") = child_tidptr;\n+  register int r7 __asm__(\"r7\") = __NR_clone;\n+\n+#if __ARM_ARCH > 4 || defined (__ARM_ARCH_4T__)\n+# define ARCH_HAS_BX\n+#endif\n+#if __ARM_ARCH > 4\n+# define ARCH_HAS_BLX\n+#endif\n+\n+#ifdef ARCH_HAS_BX\n+# ifdef ARCH_HAS_BLX\n+#  define BLX(R) \"blx \"  #R \"\\n\"\n+# else\n+#  define BLX(R) \"mov lr, pc; bx \" #R \"\\n\"\n+# endif\n+#else\n+# define BLX(R)  \"mov lr, pc; mov pc,\" #R \"\\n\"\n+#endif\n+\n+  __asm__ __volatile__(\n+                       /* %r0 = syscall(%r7 = SYSCALL(clone),\n+                        *               %r0 = flags,\n+                        *               %r1 = child_stack,\n+                        *               %r2 = parent_tidptr,\n+                        *               %r3  = new_tls,\n+                        *               %r4 = child_tidptr)\n+                        */\n+\n+                       /* Do the system call */\n+                       \"swi 0x0\\n\"\n+\n+                       /* if (%r0 != 0)\n+                        *   return %r0;\n+                        */\n+                       \"cmp r0, #0\\n\"\n+                       \"bne 1f\\n\"\n+\n+                       /* In the child, now. Call \"fn(arg)\". */\n+                       \"ldr r0, [sp, #4]\\n\"\n+                       \"ldr ip, [sp], #8\\n\"\n+                       BLX(ip)\n+                       /* Call _exit(%r0). */\n+                       \"mov r7, %7\\n\"\n+                       \"swi 0x0\\n\"\n+                       \"1:\\n\"\n+                       \"mov %0, r0\\n\"\n+                       : \"=r\"(res)\n+                       : \"r\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3), \"r\"(r4), \"r\"(r7),\n+                         \"i\"(__NR_exit)\n+                       : \"memory\");\n   return res;\n }\n #endif  // defined(__x86_64__) && SANITIZER_LINUX\n@@ -1217,14 +1583,27 @@ AndroidApiLevel AndroidGetApiLevel() {\n \n #endif\n \n-bool IsHandledDeadlySignal(int signum) {\n-  if (common_flags()->handle_abort && signum == SIGABRT)\n-    return true;\n-  if (common_flags()->handle_sigill && signum == SIGILL)\n-    return true;\n-  if (common_flags()->handle_sigfpe && signum == SIGFPE)\n-    return true;\n-  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n+static HandleSignalMode GetHandleSignalModeImpl(int signum) {\n+  switch (signum) {\n+    case SIGABRT:\n+      return common_flags()->handle_abort;\n+    case SIGILL:\n+      return common_flags()->handle_sigill;\n+    case SIGFPE:\n+      return common_flags()->handle_sigfpe;\n+    case SIGSEGV:\n+      return common_flags()->handle_segv;\n+    case SIGBUS:\n+      return common_flags()->handle_sigbus;\n+  }\n+  return kHandleSignalNo;\n+}\n+\n+HandleSignalMode GetHandleSignalMode(int signum) {\n+  HandleSignalMode result = GetHandleSignalModeImpl(signum);\n+  if (result == kHandleSignalYes && !common_flags()->allow_user_segv_handler)\n+    return kHandleSignalExclusive;\n+  return result;\n }\n \n #if !SANITIZER_GO\n@@ -1276,12 +1655,14 @@ static bool Aarch64GetESR(ucontext_t *ucontext, u64 *esr) {\n }\n #endif\n \n-SignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n+SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n   ucontext_t *ucontext = (ucontext_t *)context;\n #if defined(__x86_64__) || defined(__i386__)\n   static const uptr PF_WRITE = 1U << 1;\n #if SANITIZER_FREEBSD\n   uptr err = ucontext->uc_mcontext.mc_err;\n+#elif SANITIZER_NETBSD\n+  uptr err = ucontext->uc_mcontext.__gregs[_REG_ERR];\n #else\n   uptr err = ucontext->uc_mcontext.gregs[REG_ERR];\n #endif\n@@ -1301,7 +1682,11 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n #endif\n }\n \n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+void SignalContext::DumpAllRegisters(void *context) {\n+  // FIXME: Implement this.\n+}\n+\n+static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n #if defined(__arm__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.arm_pc;\n@@ -1324,6 +1709,11 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.mc_rip;\n   *bp = ucontext->uc_mcontext.mc_rbp;\n   *sp = ucontext->uc_mcontext.mc_rsp;\n+#elif SANITIZER_NETBSD\n+  ucontext_t *ucontext = (ucontext_t *)context;\n+  *pc = ucontext->uc_mcontext.__gregs[_REG_RIP];\n+  *bp = ucontext->uc_mcontext.__gregs[_REG_RBP];\n+  *sp = ucontext->uc_mcontext.__gregs[_REG_RSP];\n # else\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_RIP];\n@@ -1336,6 +1726,11 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.mc_eip;\n   *bp = ucontext->uc_mcontext.mc_ebp;\n   *sp = ucontext->uc_mcontext.mc_esp;\n+#elif SANITIZER_NETBSD\n+  ucontext_t *ucontext = (ucontext_t *)context;\n+  *pc = ucontext->uc_mcontext.__gregs[_REG_EIP];\n+  *bp = ucontext->uc_mcontext.__gregs[_REG_EBP];\n+  *sp = ucontext->uc_mcontext.__gregs[_REG_ESP];\n # else\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n@@ -1382,15 +1777,63 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n #endif\n }\n \n+void SignalContext::InitPcSpBp() { GetPcSpBp(context, &pc, &sp, &bp); }\n+\n void MaybeReexec() {\n   // No need to re-exec on Linux.\n }\n \n-uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding) {\n+void PrintModuleMap() { }\n+\n+void CheckNoDeepBind(const char *filename, int flag) {\n+#ifdef RTLD_DEEPBIND\n+  if (flag & RTLD_DEEPBIND) {\n+    Report(\n+        \"You are trying to dlopen a %s shared library with RTLD_DEEPBIND flag\"\n+        \" which is incompatibe with sanitizer runtime \"\n+        \"(see https://github.com/google/sanitizers/issues/611 for details\"\n+        \"). If you want to run %s library under sanitizers please remove \"\n+        \"RTLD_DEEPBIND from dlopen flags.\\n\",\n+        filename, filename);\n+    Die();\n+  }\n+#endif\n+}\n+\n+uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n+                              uptr *largest_gap_found) {\n   UNREACHABLE(\"FindAvailableMemoryRange is not available\");\n   return 0;\n }\n \n+bool GetRandom(void *buffer, uptr length, bool blocking) {\n+  if (!buffer || !length || length > 256)\n+    return false;\n+#if SANITIZER_USE_GETRANDOM\n+  static atomic_uint8_t skip_getrandom_syscall;\n+  if (!atomic_load_relaxed(&skip_getrandom_syscall)) {\n+    // Up to 256 bytes, getrandom will not be interrupted.\n+    uptr res = internal_syscall(SYSCALL(getrandom), buffer, length,\n+                                blocking ? 0 : GRND_NONBLOCK);\n+    int rverrno = 0;\n+    if (internal_iserror(res, &rverrno) && rverrno == ENOSYS)\n+      atomic_store_relaxed(&skip_getrandom_syscall, 1);\n+    else if (res == length)\n+      return true;\n+  }\n+#endif  // SANITIZER_USE_GETRANDOM\n+  // Up to 256 bytes, a read off /dev/urandom will not be interrupted.\n+  // blocking is moot here, O_NONBLOCK has no effect when opening /dev/urandom.\n+  uptr fd = internal_open(\"/dev/urandom\", O_RDONLY);\n+  if (internal_iserror(fd))\n+    return false;\n+  uptr res = internal_read(fd, buffer, length);\n+  if (internal_iserror(res))\n+    return false;\n+  internal_close(fd);\n+  return true;\n+}\n+\n } // namespace __sanitizer\n \n-#endif // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD"}, {"sha": "910703d8b2939446815411304f696e2d2bf58649", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -12,11 +12,12 @@\n #define SANITIZER_LINUX_H\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n-#include \"sanitizer_posix.h\"\n+#include \"sanitizer_platform_limits_netbsd.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_posix.h\"\n \n struct link_map;  // Opaque type returned by dlopen().\n \n@@ -25,6 +26,19 @@ namespace __sanitizer {\n // the one in <dirent.h>, which is used by readdir().\n struct linux_dirent;\n \n+struct ProcSelfMapsBuff {\n+  char *data;\n+  uptr mmaped_size;\n+  uptr len;\n+};\n+\n+struct MemoryMappingLayoutData {\n+  ProcSelfMapsBuff proc_self_maps;\n+  const char *current;\n+};\n+\n+void ReadProcMaps(ProcSelfMapsBuff *proc_maps);\n+\n // Syscall wrappers.\n uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n uptr internal_sigaltstack(const void* ss, void* oss);\n@@ -44,7 +58,8 @@ int internal_sigaction_syscall(int signum, const void *act, void *oldact);\n #endif\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n #if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) \\\n-  || defined(__powerpc64__) || defined(__s390__)\n+  || defined(__powerpc64__) || defined(__s390__) || defined(__i386__) \\\n+  || defined(__arm__)\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif\n@@ -83,7 +98,47 @@ bool LibraryNameIs(const char *full_name, const char *base_name);\n \n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n+\n+#if SANITIZER_ANDROID\n+\n+#if defined(__aarch64__)\n+# define __get_tls() \\\n+    ({ void** __v; __asm__(\"mrs %0, tpidr_el0\" : \"=r\"(__v)); __v; })\n+#elif defined(__arm__)\n+# define __get_tls() \\\n+    ({ void** __v; __asm__(\"mrc p15, 0, %0, c13, c0, 3\" : \"=r\"(__v)); __v; })\n+#elif defined(__mips__)\n+// On mips32r1, this goes via a kernel illegal instruction trap that's\n+// optimized for v1.\n+# define __get_tls() \\\n+    ({ register void** __v asm(\"v1\"); \\\n+       __asm__(\".set    push\\n\" \\\n+               \".set    mips32r2\\n\" \\\n+               \"rdhwr   %0,$29\\n\" \\\n+               \".set    pop\\n\" : \"=r\"(__v)); \\\n+       __v; })\n+#elif defined(__i386__)\n+# define __get_tls() \\\n+    ({ void** __v; __asm__(\"movl %%gs:0, %0\" : \"=r\"(__v)); __v; })\n+#elif defined(__x86_64__)\n+# define __get_tls() \\\n+    ({ void** __v; __asm__(\"mov %%fs:0, %0\" : \"=r\"(__v)); __v; })\n+#else\n+#error \"Unsupported architecture.\"\n+#endif\n+\n+// The Android Bionic team has allocated a TLS slot for TSan starting with N,\n+// given that Android currently doesn't support ELF TLS. It is used to store\n+// Sanitizers thread specific data.\n+static const int TLS_SLOT_TSAN = 8;\n+\n+ALWAYS_INLINE uptr *get_android_tls_ptr() {\n+  return reinterpret_cast<uptr *>(&__get_tls()[TLS_SLOT_TSAN]);\n+}\n+\n+#endif  // SANITIZER_ANDROID\n+\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n #endif  // SANITIZER_LINUX_H"}, {"sha": "b279cf3135f7cd638477e64e538506299b530c28", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 75, "deletions": 42, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -12,22 +12,20 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n \n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_file.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_freebsd.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n \n-#if SANITIZER_ANDROID || SANITIZER_FREEBSD\n #include <dlfcn.h>  // for dlsym()\n-#endif\n-\n #include <link.h>\n #include <pthread.h>\n #include <signal.h>\n@@ -82,28 +80,25 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n \n     // Find the mapping that contains a stack variable.\n     MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n-    uptr start, end, offset;\n+    MemoryMappedSegment segment;\n     uptr prev_end = 0;\n-    while (proc_maps.Next(&start, &end, &offset, nullptr, 0,\n-          /* protection */nullptr)) {\n-      if ((uptr)&rl < end)\n-        break;\n-      prev_end = end;\n+    while (proc_maps.Next(&segment)) {\n+      if ((uptr)&rl < segment.end) break;\n+      prev_end = segment.end;\n     }\n-    CHECK((uptr)&rl >= start && (uptr)&rl < end);\n+    CHECK((uptr)&rl >= segment.start && (uptr)&rl < segment.end);\n \n     // Get stacksize from rlimit, but clip it so that it does not overlap\n     // with other mappings.\n     uptr stacksize = rl.rlim_cur;\n-    if (stacksize > end - prev_end)\n-      stacksize = end - prev_end;\n+    if (stacksize > segment.end - prev_end) stacksize = segment.end - prev_end;\n     // When running with unlimited stack size, we still want to set some limit.\n     // The unlimited stack size is caused by 'ulimit -s unlimited'.\n     // Also, for some reason, GNU make spawns subprocesses with unlimited stack.\n     if (stacksize > kMaxThreadStackSize)\n       stacksize = kMaxThreadStackSize;\n-    *stack_top = end;\n-    *stack_bottom = end - stacksize;\n+    *stack_top = segment.end;\n+    *stack_bottom = segment.end - stacksize;\n     return;\n   }\n   pthread_attr_t attr;\n@@ -114,7 +109,6 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   my_pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n   pthread_attr_destroy(&attr);\n \n-  CHECK_LE(stacksize, kMaxThreadStackSize);  // Sanity check.\n   *stack_top = (uptr)stackaddr + stacksize;\n   *stack_bottom = (uptr)stackaddr;\n }\n@@ -153,7 +147,8 @@ bool SanitizerGetThreadName(char *name, int max_len) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n+#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO && \\\n+    !SANITIZER_NETBSD\n static uptr g_tls_size;\n \n #ifdef __i386__\n@@ -181,26 +176,27 @@ void InitTlsSize() {\n }\n #else\n void InitTlsSize() { }\n-#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n+#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO &&\n+        // !SANITIZER_NETBSD\n \n #if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) \\\n-    || defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__)) \\\n-    && SANITIZER_LINUX && !SANITIZER_ANDROID\n+    || defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__) \\\n+    || defined(__arm__)) && SANITIZER_LINUX && !SANITIZER_ANDROID\n // sizeof(struct pthread) from glibc.\n static atomic_uintptr_t kThreadDescriptorSize;\n \n uptr ThreadDescriptorSize() {\n   uptr val = atomic_load(&kThreadDescriptorSize, memory_order_relaxed);\n   if (val)\n     return val;\n-#if defined(__x86_64__) || defined(__i386__)\n+#if defined(__x86_64__) || defined(__i386__) || defined(__arm__)\n #ifdef _CS_GNU_LIBC_VERSION\n   char buf[64];\n   uptr len = confstr(_CS_GNU_LIBC_VERSION, buf, sizeof(buf));\n   if (len < sizeof(buf) && internal_strncmp(buf, \"glibc 2.\", 8) == 0) {\n     char *end;\n     int minor = internal_simple_strtoll(buf + 8, &end, 10);\n-    if (end != buf + 8 && (*end == '\\0' || *end == '.')) {\n+    if (end != buf + 8 && (*end == '\\0' || *end == '.' || *end == '-')) {\n       int patch = 0;\n       if (*end == '.')\n         // strtoll will return 0 if no valid conversion could be performed\n@@ -209,6 +205,9 @@ uptr ThreadDescriptorSize() {\n       /* sizeof(struct pthread) values from various glibc versions.  */\n       if (SANITIZER_X32)\n         val = 1728;  // Assume only one particular version for x32.\n+      // For ARM sizeof(struct pthread) changed in Glibc 2.23.\n+      else if (SANITIZER_ARM)\n+        val = minor <= 22 ? 1120 : 1216;\n       else if (minor <= 3)\n         val = FIRST_32_SECOND_64(1104, 1696);\n       else if (minor == 4)\n@@ -271,9 +270,7 @@ static uptr TlsPreTcbSize() {\n # endif\n   const uptr kTlsAlign = 16;\n   const uptr kTlsPreTcbSize =\n-    (ThreadDescriptorSize() + kTcbHead + kTlsAlign - 1) & ~(kTlsAlign - 1);\n-  InitTlsSize();\n-  g_tls_size = (g_tls_size + kTlsPreTcbSize + kTlsAlign -1) & ~(kTlsAlign - 1);\n+      RoundUpTo(ThreadDescriptorSize() + kTcbHead, kTlsAlign);\n   return kTlsPreTcbSize;\n }\n #endif\n@@ -296,7 +293,7 @@ uptr ThreadSelf() {\n                 rdhwr %0,$29;\\\n                 .set pop\" : \"=r\" (thread_pointer));\n   descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n-# elif defined(__aarch64__)\n+# elif defined(__aarch64__) || defined(__arm__)\n   descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer()) -\n                                       ThreadDescriptorSize();\n # elif defined(__s390__)\n@@ -335,7 +332,9 @@ static void **ThreadSelfSegbase() {\n uptr ThreadSelf() {\n   return (uptr)ThreadSelfSegbase()[2];\n }\n-#endif  // SANITIZER_FREEBSD\n+#elif SANITIZER_NETBSD\n+uptr ThreadSelf() { return (uptr)pthread_self(); }\n+#endif  // SANITIZER_NETBSD\n \n #if !SANITIZER_GO\n static void GetTls(uptr *addr, uptr *size) {\n@@ -345,7 +344,8 @@ static void GetTls(uptr *addr, uptr *size) {\n   *size = GetTlsSize();\n   *addr -= *size;\n   *addr += ThreadDescriptorSize();\n-# elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__)\n+# elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__) \\\n+    || defined(__arm__)\n   *addr = ThreadSelf();\n   *size = GetTlsSize();\n # else\n@@ -365,7 +365,7 @@ static void GetTls(uptr *addr, uptr *size) {\n     *addr = (uptr) dtv[2];\n     *size = (*addr == 0) ? 0 : ((uptr) segbase[0] - (uptr) dtv[2]);\n   }\n-#elif SANITIZER_ANDROID\n+#elif SANITIZER_ANDROID || SANITIZER_NETBSD\n   *addr = 0;\n   *size = 0;\n #else\n@@ -376,10 +376,12 @@ static void GetTls(uptr *addr, uptr *size) {\n \n #if !SANITIZER_GO\n uptr GetTlsSize() {\n-#if SANITIZER_FREEBSD || SANITIZER_ANDROID\n+#if SANITIZER_FREEBSD || SANITIZER_ANDROID || SANITIZER_NETBSD\n   uptr addr, size;\n   GetTls(&addr, &size);\n   return size;\n+#elif defined(__mips__) || defined(__powerpc64__)\n+  return RoundUpTo(g_tls_size + TlsPreTcbSize(), 16);\n #else\n   return g_tls_size;\n #endif\n@@ -420,7 +422,7 @@ typedef ElfW(Phdr) Elf_Phdr;\n # endif\n \n struct DlIteratePhdrData {\n-  InternalMmapVector<LoadedModule> *modules;\n+  InternalMmapVectorNoCtor<LoadedModule> *modules;\n   bool first;\n };\n \n@@ -444,7 +446,9 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n       uptr cur_beg = info->dlpi_addr + phdr->p_vaddr;\n       uptr cur_end = cur_beg + phdr->p_memsz;\n       bool executable = phdr->p_flags & PF_X;\n-      cur_module.addAddressRange(cur_beg, cur_end, executable);\n+      bool writable = phdr->p_flags & PF_W;\n+      cur_module.addAddressRange(cur_beg, cur_end, executable,\n+                                 writable);\n     }\n   }\n   data->modules->push_back(cur_module);\n@@ -456,21 +460,41 @@ extern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n     int (*)(struct dl_phdr_info *, size_t, void *), void *);\n #endif\n \n-void ListOfModules::init() {\n-  clear();\n+static bool requiresProcmaps() {\n #if SANITIZER_ANDROID && __ANDROID_API__ <= 22\n-  u32 api_level = AndroidGetApiLevel();\n   // Fall back to /proc/maps if dl_iterate_phdr is unavailable or broken.\n   // The runtime check allows the same library to work with\n   // both K and L (and future) Android releases.\n-  if (api_level <= ANDROID_LOLLIPOP_MR1) { // L or earlier\n-    MemoryMappingLayout memory_mapping(false);\n-    memory_mapping.DumpListOfModules(&modules_);\n-    return;\n-  }\n+  return AndroidGetApiLevel() <= ANDROID_LOLLIPOP_MR1;\n+#else\n+  return false;\n #endif\n-  DlIteratePhdrData data = {&modules_, true};\n-  dl_iterate_phdr(dl_iterate_phdr_cb, &data);\n+}\n+\n+static void procmapsInit(InternalMmapVectorNoCtor<LoadedModule> *modules) {\n+  MemoryMappingLayout memory_mapping(/*cache_enabled*/true);\n+  memory_mapping.DumpListOfModules(modules);\n+}\n+\n+void ListOfModules::init() {\n+  clearOrInit();\n+  if (requiresProcmaps()) {\n+    procmapsInit(&modules_);\n+  } else {\n+    DlIteratePhdrData data = {&modules_, true};\n+    dl_iterate_phdr(dl_iterate_phdr_cb, &data);\n+  }\n+}\n+\n+// When a custom loader is used, dl_iterate_phdr may not contain the full\n+// list of modules. Allow callers to fall back to using procmaps.\n+void ListOfModules::fallbackInit() {\n+  if (!requiresProcmaps()) {\n+    clearOrInit();\n+    procmapsInit(&modules_);\n+  } else {\n+    clear();\n+  }\n }\n \n // getrusage does not give us the current RSS, only the max RSS.\n@@ -547,6 +571,15 @@ void LogMessageOnPrintf(const char *str) {\n     WriteToSyslog(str);\n }\n \n+#if SANITIZER_ANDROID\n+extern \"C\" __attribute__((weak)) void android_set_abort_message(const char *);\n+void SetAbortMessage(const char *str) {\n+  if (&android_set_abort_message) android_set_abort_message(str);\n+}\n+#else\n+void SetAbortMessage(const char *str) {}\n+#endif\n+\n #endif // SANITIZER_LINUX\n \n } // namespace __sanitizer"}, {"sha": "b836447bd5d28b1e5ad12fb76143e38451bffa04", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_s390.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -176,6 +176,13 @@ static bool FixedCVE_2016_2143() {\n     // 4.4.6+ is OK.\n     if (minor == 4 && patch >= 6)\n       return true;\n+    if (minor == 4 && patch == 0 && ptr[0] == '-' &&\n+        internal_strstr(buf.version, \"Ubuntu\")) {\n+      // Check Ubuntu 16.04\n+      int r1 = internal_simple_strtoll(ptr+1, &ptr, 10);\n+      if (r1 >= 13) // 4.4.0-13 or later\n+        return true;\n+    }\n     // Otherwise, OK if 4.5+.\n     return minor >= 5;\n   } else {"}, {"sha": "d7e8b501a6eeabaf0460cb86a3a1d23d5fd99cc6", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -68,6 +68,17 @@ struct IntrusiveList {\n     size_--;\n   }\n \n+  void extract(Item *prev, Item *x) {\n+    CHECK(!empty());\n+    CHECK_NE(prev, nullptr);\n+    CHECK_NE(x, nullptr);\n+    CHECK_EQ(prev->next, x);\n+    prev->next = x->next;\n+    if (last_ == x)\n+      last_ = prev;\n+    size_--;\n+  }\n+\n   Item *front() { return first_; }\n   const Item *front() const { return first_; }\n   Item *back() { return last_; }"}, {"sha": "8c78494e81a83c0471d7c8372af093775a21d107", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 232, "deletions": 29, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -21,6 +21,7 @@\n #include <stdio.h>\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_file.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n@@ -100,12 +101,12 @@ extern \"C\" int __munmap(void *, size_t) SANITIZER_WEAK_ATTRIBUTE;\n uptr internal_mmap(void *addr, size_t length, int prot, int flags,\n                    int fd, u64 offset) {\n   if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_ANALYSIS_TOOL);\n-  if (__mmap) return (uptr)__mmap(addr, length, prot, flags, fd, offset);\n+  if (&__mmap) return (uptr)__mmap(addr, length, prot, flags, fd, offset);\n   return (uptr)mmap(addr, length, prot, flags, fd, offset);\n }\n \n uptr internal_munmap(void *addr, uptr length) {\n-  if (__munmap) return __munmap(addr, length);\n+  if (&__munmap) return __munmap(addr, length);\n   return munmap(addr, length);\n }\n \n@@ -189,14 +190,15 @@ void internal_sigfillset(__sanitizer_sigset_t *set) { sigfillset(set); }\n \n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n                           __sanitizer_sigset_t *oldset) {\n-  return sigprocmask(how, set, oldset);\n+  // Don't use sigprocmask here, because it affects all threads.\n+  return pthread_sigmask(how, set, oldset);\n }\n \n // Doesn't call pthread_atfork() handlers (but not available on 10.6).\n extern \"C\" pid_t __fork(void) SANITIZER_WEAK_ATTRIBUTE;\n \n int internal_fork() {\n-  if (__fork)\n+  if (&__fork)\n     return __fork();\n   return fork();\n }\n@@ -250,9 +252,8 @@ bool FileExists(const char *filename) {\n   return S_ISREG(st.st_mode);\n }\n \n-uptr GetTid() {\n-  // FIXME: This can potentially get truncated on 32-bit, where uptr is 4 bytes.\n-  uint64_t tid;\n+tid_t GetTid() {\n+  tid_t tid;\n   pthread_threadid_np(nullptr, &tid);\n   return tid;\n }\n@@ -346,20 +347,16 @@ BlockingMutex::BlockingMutex() {\n void BlockingMutex::Lock() {\n   CHECK(sizeof(OSSpinLock) <= sizeof(opaque_storage_));\n   CHECK_EQ(OS_SPINLOCK_INIT, 0);\n-  CHECK_NE(owner_, (uptr)pthread_self());\n+  CHECK_EQ(owner_, 0);\n   OSSpinLockLock((OSSpinLock*)&opaque_storage_);\n-  CHECK(!owner_);\n-  owner_ = (uptr)pthread_self();\n }\n \n void BlockingMutex::Unlock() {\n-  CHECK(owner_ == (uptr)pthread_self());\n-  owner_ = 0;\n   OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n }\n \n void BlockingMutex::CheckLocked() {\n-  CHECK_EQ((uptr)pthread_self(), owner_);\n+  CHECK_NE(*(OSSpinLock*)&opaque_storage_, 0);\n }\n \n u64 NanoTime() {\n@@ -373,15 +370,36 @@ uptr GetTlsSize() {\n void InitTlsSize() {\n }\n \n+uptr TlsBaseAddr() {\n+  uptr segbase = 0;\n+#if defined(__x86_64__)\n+  asm(\"movq %%gs:0,%0\" : \"=r\"(segbase));\n+#elif defined(__i386__)\n+  asm(\"movl %%gs:0,%0\" : \"=r\"(segbase));\n+#endif\n+  return segbase;\n+}\n+\n+// The size of the tls on darwin does not appear to be well documented,\n+// however the vm memory map suggests that it is 1024 uptrs in size,\n+// with a size of 0x2000 bytes on x86_64 and 0x1000 bytes on i386.\n+uptr TlsSize() {\n+#if defined(__x86_64__) || defined(__i386__)\n+  return 1024 * sizeof(uptr);\n+#else\n+  return 0;\n+#endif\n+}\n+\n void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                           uptr *tls_addr, uptr *tls_size) {\n #if !SANITIZER_GO\n   uptr stack_top, stack_bottom;\n   GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n   *stk_addr = stack_bottom;\n   *stk_size = stack_top - stack_bottom;\n-  *tls_addr = 0;\n-  *tls_size = 0;\n+  *tls_addr = TlsBaseAddr();\n+  *tls_size = TlsSize();\n #else\n   *stk_addr = 0;\n   *stk_size = 0;\n@@ -391,18 +409,37 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n }\n \n void ListOfModules::init() {\n-  clear();\n+  clearOrInit();\n   MemoryMappingLayout memory_mapping(false);\n   memory_mapping.DumpListOfModules(&modules_);\n }\n \n-bool IsHandledDeadlySignal(int signum) {\n+void ListOfModules::fallbackInit() { clear(); }\n+\n+static HandleSignalMode GetHandleSignalModeImpl(int signum) {\n+  switch (signum) {\n+    case SIGABRT:\n+      return common_flags()->handle_abort;\n+    case SIGILL:\n+      return common_flags()->handle_sigill;\n+    case SIGFPE:\n+      return common_flags()->handle_sigfpe;\n+    case SIGSEGV:\n+      return common_flags()->handle_segv;\n+    case SIGBUS:\n+      return common_flags()->handle_sigbus;\n+  }\n+  return kHandleSignalNo;\n+}\n+\n+HandleSignalMode GetHandleSignalMode(int signum) {\n+  // Handling fatal signals on watchOS and tvOS devices is disallowed.\n   if ((SANITIZER_WATCHOS || SANITIZER_TVOS) && !(SANITIZER_IOSSIM))\n-    // Handling fatal signals on watchOS and tvOS devices is disallowed.\n-    return false;\n-  if (common_flags()->handle_abort && signum == SIGABRT)\n-    return true;\n-  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n+    return kHandleSignalNo;\n+  HandleSignalMode result = GetHandleSignalModeImpl(signum);\n+  if (result == kHandleSignalYes && !common_flags()->allow_user_segv_handler)\n+    return kHandleSignalExclusive;\n+  return result;\n }\n \n MacosVersion cached_macos_version = MACOS_VERSION_UNINITIALIZED;\n@@ -448,6 +485,15 @@ MacosVersion GetMacosVersion() {\n   return result;\n }\n \n+bool PlatformHasDifferentMemcpyAndMemmove() {\n+  // On OS X 10.7 memcpy() and memmove() are both resolved\n+  // into memmove$VARIANT$sse42.\n+  // See also https://github.com/google/sanitizers/issues/34.\n+  // TODO(glider): need to check dynamically that memcpy() and memmove() are\n+  // actually the same function.\n+  return GetMacosVersion() == MACOS_VERSION_SNOW_LEOPARD;\n+}\n+\n uptr GetRSS() {\n   struct task_basic_info info;\n   unsigned count = TASK_BASIC_INFO_COUNT;\n@@ -528,7 +574,7 @@ void LogFullErrorReport(const char *buffer) {\n #endif\n }\n \n-SignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n+SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n #if defined(__x86_64__) || defined(__i386__)\n   ucontext_t *ucontext = static_cast<ucontext_t*>(context);\n   return ucontext->uc_mcontext->__es.__err & 2 /*T_PF_WRITE*/ ? WRITE : READ;\n@@ -537,7 +583,7 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n #endif\n }\n \n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   ucontext_t *ucontext = (ucontext_t*)context;\n # if defined(__aarch64__)\n   *pc = ucontext->uc_mcontext->__ss.__pc;\n@@ -564,6 +610,8 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n # endif\n }\n \n+void SignalContext::InitPcSpBp() { GetPcSpBp(context, &pc, &sp, &bp); }\n+\n #if !SANITIZER_GO\n static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n LowLevelAllocator allocator_for_env;\n@@ -755,9 +803,69 @@ char **GetArgv() {\n   return *_NSGetArgv();\n }\n \n+#if defined(__aarch64__) && SANITIZER_IOS && !SANITIZER_IOSSIM\n+// The task_vm_info struct is normally provided by the macOS SDK, but we need\n+// fields only available in 10.12+. Declare the struct manually to be able to\n+// build against older SDKs.\n+struct __sanitizer_task_vm_info {\n+  mach_vm_size_t virtual_size;\n+  integer_t region_count;\n+  integer_t page_size;\n+  mach_vm_size_t resident_size;\n+  mach_vm_size_t resident_size_peak;\n+  mach_vm_size_t device;\n+  mach_vm_size_t device_peak;\n+  mach_vm_size_t internal;\n+  mach_vm_size_t internal_peak;\n+  mach_vm_size_t external;\n+  mach_vm_size_t external_peak;\n+  mach_vm_size_t reusable;\n+  mach_vm_size_t reusable_peak;\n+  mach_vm_size_t purgeable_volatile_pmap;\n+  mach_vm_size_t purgeable_volatile_resident;\n+  mach_vm_size_t purgeable_volatile_virtual;\n+  mach_vm_size_t compressed;\n+  mach_vm_size_t compressed_peak;\n+  mach_vm_size_t compressed_lifetime;\n+  mach_vm_size_t phys_footprint;\n+  mach_vm_address_t min_address;\n+  mach_vm_address_t max_address;\n+};\n+#define __SANITIZER_TASK_VM_INFO_COUNT ((mach_msg_type_number_t) \\\n+    (sizeof(__sanitizer_task_vm_info) / sizeof(natural_t)))\n+\n+uptr GetTaskInfoMaxAddress() {\n+  __sanitizer_task_vm_info vm_info = {};\n+  mach_msg_type_number_t count = __SANITIZER_TASK_VM_INFO_COUNT;\n+  int err = task_info(mach_task_self(), TASK_VM_INFO, (int *)&vm_info, &count);\n+  if (err == 0) {\n+    return vm_info.max_address - 1;\n+  } else {\n+    // xnu cannot provide vm address limit\n+    return 0x200000000 - 1;\n+  }\n+}\n+#endif\n+\n+uptr GetMaxVirtualAddress() {\n+#if SANITIZER_WORDSIZE == 64\n+# if defined(__aarch64__) && SANITIZER_IOS && !SANITIZER_IOSSIM\n+  // Get the maximum VM address\n+  static uptr max_vm = GetTaskInfoMaxAddress();\n+  CHECK(max_vm);\n+  return max_vm;\n+# else\n+  return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n+# endif\n+#else  // SANITIZER_WORDSIZE == 32\n+  return (1ULL << 32) - 1;  // 0xffffffff;\n+#endif  // SANITIZER_WORDSIZE\n+}\n+\n uptr FindAvailableMemoryRange(uptr shadow_size,\n                               uptr alignment,\n-                              uptr left_padding) {\n+                              uptr left_padding,\n+                              uptr *largest_gap_found) {\n   typedef vm_region_submap_short_info_data_64_t RegionInfo;\n   enum { kRegionInfoSize = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 };\n   // Start searching for available memory region past PAGEZERO, which is\n@@ -768,6 +876,7 @@ uptr FindAvailableMemoryRange(uptr shadow_size,\n   mach_vm_address_t address = start_address;\n   mach_vm_address_t free_begin = start_address;\n   kern_return_t kr = KERN_SUCCESS;\n+  if (largest_gap_found) *largest_gap_found = 0;\n   while (kr == KERN_SUCCESS) {\n     mach_vm_size_t vmsize = 0;\n     natural_t depth = 0;\n@@ -777,10 +886,15 @@ uptr FindAvailableMemoryRange(uptr shadow_size,\n                                 (vm_region_info_t)&vminfo, &count);\n     if (free_begin != address) {\n       // We found a free region [free_begin..address-1].\n-      uptr shadow_address = RoundUpTo((uptr)free_begin + left_padding,\n-                                      alignment);\n-      if (shadow_address + shadow_size < (uptr)address) {\n-        return shadow_address;\n+      uptr gap_start = RoundUpTo((uptr)free_begin + left_padding, alignment);\n+      uptr gap_end = RoundDownTo((uptr)address, alignment);\n+      uptr gap_size = gap_end > gap_start ? gap_end - gap_start : 0;\n+      if (shadow_size < gap_size) {\n+        return gap_start;\n+      }\n+\n+      if (largest_gap_found && *largest_gap_found < gap_size) {\n+        *largest_gap_found = gap_size;\n       }\n     }\n     // Move to the next region.\n@@ -795,6 +909,95 @@ uptr FindAvailableMemoryRange(uptr shadow_size,\n // FIXME implement on this platform.\n void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) { }\n \n+void SignalContext::DumpAllRegisters(void *context) {\n+  Report(\"Register values:\\n\");\n+\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+# define DUMPREG64(r) \\\n+    Printf(\"%s = 0x%016llx  \", #r, ucontext->uc_mcontext->__ss.__ ## r);\n+# define DUMPREG32(r) \\\n+    Printf(\"%s = 0x%08x  \", #r, ucontext->uc_mcontext->__ss.__ ## r);\n+# define DUMPREG_(r)   Printf(\" \"); DUMPREG(r);\n+# define DUMPREG__(r)  Printf(\"  \"); DUMPREG(r);\n+# define DUMPREG___(r) Printf(\"   \"); DUMPREG(r);\n+\n+# if defined(__x86_64__)\n+#  define DUMPREG(r) DUMPREG64(r)\n+  DUMPREG(rax); DUMPREG(rbx); DUMPREG(rcx); DUMPREG(rdx); Printf(\"\\n\");\n+  DUMPREG(rdi); DUMPREG(rsi); DUMPREG(rbp); DUMPREG(rsp); Printf(\"\\n\");\n+  DUMPREG_(r8); DUMPREG_(r9); DUMPREG(r10); DUMPREG(r11); Printf(\"\\n\");\n+  DUMPREG(r12); DUMPREG(r13); DUMPREG(r14); DUMPREG(r15); Printf(\"\\n\");\n+# elif defined(__i386__)\n+#  define DUMPREG(r) DUMPREG32(r)\n+  DUMPREG(eax); DUMPREG(ebx); DUMPREG(ecx); DUMPREG(edx); Printf(\"\\n\");\n+  DUMPREG(edi); DUMPREG(esi); DUMPREG(ebp); DUMPREG(esp); Printf(\"\\n\");\n+# elif defined(__aarch64__)\n+#  define DUMPREG(r) DUMPREG64(r)\n+  DUMPREG_(x[0]); DUMPREG_(x[1]); DUMPREG_(x[2]); DUMPREG_(x[3]); Printf(\"\\n\");\n+  DUMPREG_(x[4]); DUMPREG_(x[5]); DUMPREG_(x[6]); DUMPREG_(x[7]); Printf(\"\\n\");\n+  DUMPREG_(x[8]); DUMPREG_(x[9]); DUMPREG(x[10]); DUMPREG(x[11]); Printf(\"\\n\");\n+  DUMPREG(x[12]); DUMPREG(x[13]); DUMPREG(x[14]); DUMPREG(x[15]); Printf(\"\\n\");\n+  DUMPREG(x[16]); DUMPREG(x[17]); DUMPREG(x[18]); DUMPREG(x[19]); Printf(\"\\n\");\n+  DUMPREG(x[20]); DUMPREG(x[21]); DUMPREG(x[22]); DUMPREG(x[23]); Printf(\"\\n\");\n+  DUMPREG(x[24]); DUMPREG(x[25]); DUMPREG(x[26]); DUMPREG(x[27]); Printf(\"\\n\");\n+  DUMPREG(x[28]); DUMPREG___(fp); DUMPREG___(lr); DUMPREG___(sp); Printf(\"\\n\");\n+# elif defined(__arm__)\n+#  define DUMPREG(r) DUMPREG32(r)\n+  DUMPREG_(r[0]); DUMPREG_(r[1]); DUMPREG_(r[2]); DUMPREG_(r[3]); Printf(\"\\n\");\n+  DUMPREG_(r[4]); DUMPREG_(r[5]); DUMPREG_(r[6]); DUMPREG_(r[7]); Printf(\"\\n\");\n+  DUMPREG_(r[8]); DUMPREG_(r[9]); DUMPREG(r[10]); DUMPREG(r[11]); Printf(\"\\n\");\n+  DUMPREG(r[12]); DUMPREG___(sp); DUMPREG___(lr); DUMPREG___(pc); Printf(\"\\n\");\n+# else\n+# error \"Unknown architecture\"\n+# endif\n+\n+# undef DUMPREG64\n+# undef DUMPREG32\n+# undef DUMPREG_\n+# undef DUMPREG__\n+# undef DUMPREG___\n+# undef DUMPREG\n+}\n+\n+static inline bool CompareBaseAddress(const LoadedModule &a,\n+                                      const LoadedModule &b) {\n+  return a.base_address() < b.base_address();\n+}\n+\n+void FormatUUID(char *out, uptr size, const u8 *uuid) {\n+  internal_snprintf(out, size,\n+                    \"<%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-\"\n+                    \"%02X%02X%02X%02X%02X%02X>\",\n+                    uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5],\n+                    uuid[6], uuid[7], uuid[8], uuid[9], uuid[10], uuid[11],\n+                    uuid[12], uuid[13], uuid[14], uuid[15]);\n+}\n+\n+void PrintModuleMap() {\n+  Printf(\"Process module map:\\n\");\n+  MemoryMappingLayout memory_mapping(false);\n+  InternalMmapVector<LoadedModule> modules(/*initial_capacity*/ 128);\n+  memory_mapping.DumpListOfModules(&modules);\n+  InternalSort(&modules, modules.size(), CompareBaseAddress);\n+  for (uptr i = 0; i < modules.size(); ++i) {\n+    char uuid_str[128];\n+    FormatUUID(uuid_str, sizeof(uuid_str), modules[i].uuid());\n+    Printf(\"0x%zx-0x%zx %s (%s) %s\\n\", modules[i].base_address(),\n+           modules[i].max_executable_address(), modules[i].full_name(),\n+           ModuleArchToString(modules[i].arch()), uuid_str);\n+  }\n+  Printf(\"End of module map.\\n\");\n+}\n+\n+void CheckNoDeepBind(const char *filename, int flag) {\n+  // Do nothing.\n+}\n+\n+// FIXME: implement on this platform.\n+bool GetRandom(void *buffer, uptr length, bool blocking) {\n+  UNIMPLEMENTED();\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_MAC"}, {"sha": "4881b62ff575f08c594924785112085c8bbb2d2f", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -18,6 +18,17 @@\n \n namespace __sanitizer {\n \n+struct MemoryMappingLayoutData {\n+  int current_image;\n+  u32 current_magic;\n+  u32 current_filetype;\n+  ModuleArch current_arch;\n+  u8 current_uuid[kModuleUUIDSize];\n+  int current_load_cmd_count;\n+  char *current_load_cmd_addr;\n+  bool current_instrumented;\n+};\n+\n enum MacosVersion {\n   MACOS_VERSION_UNINITIALIZED = 0,\n   MACOS_VERSION_UNKNOWN,\n@@ -34,6 +45,8 @@ MacosVersion GetMacosVersion();\n \n char **GetEnviron();\n \n+void RestrictMemoryToMaxAddress(uptr max_address);\n+\n }  // namespace __sanitizer\n \n extern \"C\" {"}, {"sha": "b376a0710b9f7576274e54c615b87b4223361599", "filename": "libsanitizer/sanitizer_common/sanitizer_mac_libcdep.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,28 @@\n+//===-- sanitizer_mac_libcdep.cc ------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between various sanitizers' runtime libraries and\n+// implements OSX-specific functions.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+#include \"sanitizer_mac.h\"\n+\n+#include <sys/mman.h>\n+\n+namespace __sanitizer {\n+\n+void RestrictMemoryToMaxAddress(uptr max_address) {\n+  uptr size_to_mmap = GetMaxVirtualAddress() + 1 - max_address;\n+  void *res = MmapFixedNoAccess(max_address, size_to_mmap, \"high gap\");\n+  CHECK(res != MAP_FAILED);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_MAC"}, {"sha": "2ca4e061464408ce68a5ae02f6539140324c65aa", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -44,9 +44,48 @@ INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n     // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n     mprotect(new_zone, allocated_size, PROT_READ);\n   }\n+  // We're explicitly *NOT* registering the zone.\n   return new_zone;\n }\n \n+INTERCEPTOR(void, malloc_destroy_zone, malloc_zone_t *zone) {\n+  COMMON_MALLOC_ENTER();\n+  // We don't need to do anything here.  We're not registering new zones, so we\n+  // don't to unregister.  Just un-mprotect and free() the zone.\n+  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n+    uptr page_size = GetPageSizeCached();\n+    uptr allocated_size = RoundUpTo(sizeof(sanitizer_zone), page_size);\n+    mprotect(zone, allocated_size, PROT_READ | PROT_WRITE);\n+  }\n+  if (zone->zone_name) {\n+    COMMON_MALLOC_FREE((void *)zone->zone_name);\n+  }\n+  COMMON_MALLOC_FREE(zone);\n+}\n+\n+extern unsigned malloc_num_zones;\n+extern malloc_zone_t **malloc_zones;\n+\n+// We need to make sure that sanitizer_zone is registered as malloc_zones[0]. If\n+// libmalloc tries to set up a different zone as malloc_zones[0], it will call\n+// mprotect(malloc_zones, ..., PROT_READ).  This interceptor will catch that and\n+// make sure we are still the first (default) zone.\n+INTERCEPTOR(int, mprotect, void *addr, size_t len, int prot) {\n+  if (addr == malloc_zones && prot == PROT_READ) {\n+    if (malloc_num_zones > 1 && malloc_zones[0] != &sanitizer_zone) {\n+      for (unsigned i = 1; i < malloc_num_zones; i++) {\n+        if (malloc_zones[i] == &sanitizer_zone) {\n+          // Swap malloc_zones[0] and malloc_zones[i].\n+          malloc_zones[i] = malloc_zones[0];\n+          malloc_zones[0] = &sanitizer_zone;\n+          break;\n+        }\n+      }\n+    }\n+  }\n+  return REAL(mprotect)(addr, len, prot);\n+}\n+\n INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n   COMMON_MALLOC_ENTER();\n   return &sanitizer_zone;"}, {"sha": "1ec409def4176321331ce911a309bf1f5847fa9f", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -81,6 +81,14 @@ class BlockingMutex {\n   BlockingMutex();\n   void Lock();\n   void Unlock();\n+\n+  // This function does not guarantee an explicit check that the calling thread\n+  // is the thread which owns the mutex. This behavior, while more strictly\n+  // correct, causes problems in cases like StopTheWorld, where a parent thread\n+  // owns the mutex but a child checks that it is locked. Rather than\n+  // maintaining complex state to work around those situations, the check only\n+  // checks that the mutex is owned, and assumes callers to be generally\n+  // well-behaved.\n   void CheckLocked();\n  private:\n   uptr opaque_storage_[10];"}, {"sha": "1eb4d0c61c6d06b9c1be3d2b6fcf04da474a506e", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -11,8 +11,8 @@\n #ifndef SANITIZER_PLATFORM_H\n #define SANITIZER_PLATFORM_H\n \n-#if !defined(__linux__) && !defined(__FreeBSD__) && \\\n-  !defined(__APPLE__) && !defined(_WIN32)\n+#if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && \\\n+  !defined(__APPLE__) && !defined(_WIN32) && !defined(__Fuchsia__)\n # error \"This operating system is not supported\"\n #endif\n \n@@ -28,6 +28,12 @@\n # define SANITIZER_FREEBSD 0\n #endif\n \n+#if defined(__NetBSD__)\n+# define SANITIZER_NETBSD 1\n+#else\n+# define SANITIZER_NETBSD 0\n+#endif\n+\n #if defined(__APPLE__)\n # define SANITIZER_MAC     1\n # include <TargetConditionals.h>\n@@ -77,7 +83,14 @@\n # define SANITIZER_ANDROID 0\n #endif\n \n-#define SANITIZER_POSIX (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC)\n+#if defined(__Fuchsia__)\n+# define SANITIZER_FUCHSIA 1\n+#else\n+# define SANITIZER_FUCHSIA 0\n+#endif\n+\n+#define SANITIZER_POSIX \\\n+  (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || SANITIZER_NETBSD)\n \n #if __LP64__ || defined(_WIN64)\n #  define SANITIZER_WORDSIZE 64\n@@ -160,13 +173,19 @@\n # define SANITIZER_PPC64V2 0\n #endif\n \n+#if defined(__arm__)\n+# define SANITIZER_ARM 1\n+#else\n+# define SANITIZER_ARM 0\n+#endif\n+\n // By default we allow to use SizeClassAllocator64 on 64-bit platform.\n // But in some cases (e.g. AArch64's 39-bit address space) SizeClassAllocator64\n // does not work well and we need to fallback to SizeClassAllocator32.\n // For such platforms build this code with -DSANITIZER_CAN_USE_ALLOCATOR64=0 or\n // change the definition of SANITIZER_CAN_USE_ALLOCATOR64 here.\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n-# if SANITIZER_ANDROID && defined(__aarch64__)\n+# if (SANITIZER_ANDROID && defined(__aarch64__)) || SANITIZER_FUCHSIA\n #  define SANITIZER_CAN_USE_ALLOCATOR64 1\n # elif defined(__mips64) || defined(__aarch64__)\n #  define SANITIZER_CAN_USE_ALLOCATOR64 0\n@@ -251,4 +270,15 @@\n # define SANITIZER_GO 0\n #endif\n \n+// On PowerPC and ARM Thumb, calling pthread_exit() causes LSan to detect leaks.\n+// pthread_exit() performs unwinding that leads to dlopen'ing libgcc_s.so.\n+// dlopen mallocs \"libgcc_s.so\" string which confuses LSan, it fails to realize\n+// that this allocation happens in dynamic linker and should be ignored.\n+#if SANITIZER_PPC || defined(__thumb__)\n+# define SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT 1\n+#else\n+# define SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT 0\n+#endif\n+\n+\n #endif // SANITIZER_PLATFORM_H"}, {"sha": "b9eb09ad3bd8e083b92aaeb5d08b8f3707f7b09d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 209, "deletions": 137, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -14,11 +14,25 @@\n \n #include \"sanitizer_internal_defs.h\"\n \n+#if SANITIZER_POSIX\n+# define SI_POSIX 1\n+#else\n+# define SI_POSIX 0\n+#endif\n+\n #if !SANITIZER_WINDOWS\n-# define SI_NOT_WINDOWS 1\n-# include \"sanitizer_platform_limits_posix.h\"\n+# define SI_WINDOWS 0\n #else\n-# define SI_NOT_WINDOWS 0\n+# define SI_WINDOWS 1\n+#endif\n+\n+#if (SI_POSIX != 0) == (SI_WINDOWS != 0) && !SANITIZER_FUCHSIA\n+# error \"Windows is not POSIX!\"\n+#endif\n+\n+#if SI_POSIX\n+# include \"sanitizer_platform_limits_netbsd.h\"\n+# include \"sanitizer_platform_limits_posix.h\"\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n@@ -39,6 +53,12 @@\n # define SI_FREEBSD 0\n #endif\n \n+#if SANITIZER_NETBSD\n+# define SI_NETBSD 1\n+#else\n+# define SI_NETBSD 0\n+#endif\n+\n #if SANITIZER_LINUX\n # define SI_LINUX 1\n #else\n@@ -59,28 +79,43 @@\n # define SI_IOS 0\n #endif\n \n-#if !SANITIZER_WINDOWS && !SANITIZER_MAC\n-# define SI_UNIX_NOT_MAC 1\n+#if SANITIZER_FUCHSIA\n+# define SI_NOT_FUCHSIA 0\n+#else\n+# define SI_NOT_FUCHSIA 1\n+#endif\n+\n+#if SANITIZER_POSIX && !SANITIZER_MAC\n+# define SI_POSIX_NOT_MAC 1\n #else\n-# define SI_UNIX_NOT_MAC 0\n+# define SI_POSIX_NOT_MAC 0\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_FREEBSD\n+# define SI_LINUX_NOT_FREEBSD 1\n+# else\n+# define SI_LINUX_NOT_FREEBSD 0\n #endif\n \n-#define SANITIZER_INTERCEPT_STRLEN 1\n-#define SANITIZER_INTERCEPT_STRNLEN SI_NOT_MAC\n-#define SANITIZER_INTERCEPT_STRCMP 1\n-#define SANITIZER_INTERCEPT_STRSTR 1\n-#define SANITIZER_INTERCEPT_STRCASESTR SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_STRCHR 1\n-#define SANITIZER_INTERCEPT_STRCHRNUL SI_UNIX_NOT_MAC\n-#define SANITIZER_INTERCEPT_STRRCHR 1\n-#define SANITIZER_INTERCEPT_STRSPN 1\n-#define SANITIZER_INTERCEPT_STRPBRK 1\n+#define SANITIZER_INTERCEPT_STRLEN SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRNLEN (SI_NOT_MAC && SI_NOT_FUCHSIA)\n+#define SANITIZER_INTERCEPT_STRCMP SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRSTR SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRCASESTR SI_POSIX\n+#define SANITIZER_INTERCEPT_STRTOK SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRCHR SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRCHRNUL SI_POSIX_NOT_MAC\n+#define SANITIZER_INTERCEPT_STRRCHR SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRSPN SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRPBRK SI_NOT_FUCHSIA\n #define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRCASECMP SI_POSIX\n #define SANITIZER_INTERCEPT_MEMSET 1\n #define SANITIZER_INTERCEPT_MEMMOVE 1\n #define SANITIZER_INTERCEPT_MEMCPY 1\n-#define SANITIZER_INTERCEPT_MEMCMP 1\n+#define SANITIZER_INTERCEPT_MEMCMP SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_STRNDUP SI_POSIX\n+#define SANITIZER_INTERCEPT___STRNDUP SI_LINUX_NOT_FREEBSD\n #if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \\\n     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070\n # define SI_MAC_DEPLOYMENT_BELOW_10_7 1\n@@ -89,78 +124,83 @@\n #endif\n // memmem on Darwin doesn't exist on 10.6\n // FIXME: enable memmem on Windows.\n-#define SANITIZER_INTERCEPT_MEMMEM \\\n-  SI_NOT_WINDOWS && !SI_MAC_DEPLOYMENT_BELOW_10_7\n-#define SANITIZER_INTERCEPT_MEMCHR 1\n-#define SANITIZER_INTERCEPT_MEMRCHR SI_FREEBSD || SI_LINUX\n+#define SANITIZER_INTERCEPT_MEMMEM (SI_POSIX && !SI_MAC_DEPLOYMENT_BELOW_10_7)\n+#define SANITIZER_INTERCEPT_MEMCHR SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_MEMRCHR (SI_FREEBSD || SI_LINUX || SI_NETBSD)\n \n-#define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_WRITE  SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_PWRITE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_READ SI_POSIX\n+#define SANITIZER_INTERCEPT_PREAD SI_POSIX\n+#define SANITIZER_INTERCEPT_WRITE SI_POSIX\n+#define SANITIZER_INTERCEPT_PWRITE SI_POSIX\n+\n+#define SANITIZER_INTERCEPT_FREAD SI_POSIX\n+#define SANITIZER_INTERCEPT_FWRITE SI_POSIX\n \n #define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n \n-#define SANITIZER_INTERCEPT_READV SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_WRITEV SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_READV SI_POSIX\n+#define SANITIZER_INTERCEPT_WRITEV SI_POSIX\n \n-#define SANITIZER_INTERCEPT_PREADV SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PREADV \\\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_PWRITEV SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PREADV64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITEV64 SI_LINUX_NOT_ANDROID\n \n #define SANITIZER_INTERCEPT_PRCTL   SI_LINUX\n \n-#define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_STRPTIME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_POSIX\n+#define SANITIZER_INTERCEPT_STRPTIME SI_POSIX\n \n-#define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SCANF SI_POSIX\n #define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX_NOT_ANDROID\n \n #ifndef SANITIZER_INTERCEPT_PRINTF\n-# define SANITIZER_INTERCEPT_PRINTF SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PRINTF_L SI_FREEBSD\n+# define SANITIZER_INTERCEPT_PRINTF SI_POSIX\n+# define SANITIZER_INTERCEPT_PRINTF_L (SI_FREEBSD || SI_NETBSD)\n # define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX_NOT_ANDROID\n #endif\n \n-#define SANITIZER_INTERCEPT_FREXP 1\n-#define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FREXP SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_POSIX\n \n-#define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_POSIX\n #define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_GETPWENT \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETPWENT_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SETPWENT SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_FREEBSD || SI_LINUX\n-#define SANITIZER_INTERCEPT_GETITIMER SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_TIME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETPWENT_R \\\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_SETPWENT (SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_CLOCK_GETTIME (SI_FREEBSD || SI_NETBSD || SI_LINUX)\n+#define SANITIZER_INTERCEPT_GETITIMER SI_POSIX\n+#define SANITIZER_INTERCEPT_TIME SI_POSIX\n #define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_WAIT SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_INET SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETADDRINFO SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETNAMEINFO SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETSOCKNAME SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_FREEBSD || SI_LINUX\n-#define SANITIZER_INTERCEPT_GETHOSTBYNAME2_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETHOSTENT_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETSOCKOPT SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_ACCEPT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_WAIT SI_POSIX\n+#define SANITIZER_INTERCEPT_INET SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_POSIX\n+#define SANITIZER_INTERCEPT_GETADDRINFO SI_POSIX\n+#define SANITIZER_INTERCEPT_GETNAMEINFO SI_POSIX\n+#define SANITIZER_INTERCEPT_GETSOCKNAME SI_POSIX\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_POSIX\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R (SI_FREEBSD || SI_LINUX)\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME2_R \\\n+  (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_GETHOSTENT_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_GETSOCKOPT SI_POSIX\n+#define SANITIZER_INTERCEPT_ACCEPT SI_POSIX\n #define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_MODF SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_RECVMSG SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_SENDMSG SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETPEERNAME SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_IOCTL SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_INET_ATON SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MODF SI_POSIX\n+#define SANITIZER_INTERCEPT_RECVMSG SI_POSIX\n+#define SANITIZER_INTERCEPT_SENDMSG SI_POSIX\n+#define SANITIZER_INTERCEPT_GETPEERNAME SI_POSIX\n+#define SANITIZER_INTERCEPT_IOCTL SI_POSIX\n+#define SANITIZER_INTERCEPT_INET_ATON SI_POSIX\n #define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n-#define SANITIZER_INTERCEPT_READDIR SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_READDIR SI_POSIX\n #define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n #if SI_LINUX_NOT_ANDROID && \\\n   (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n@@ -170,152 +210,184 @@\n #else\n #define SANITIZER_INTERCEPT_PTRACE 0\n #endif\n-#define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SETLOCALE SI_POSIX\n+#define SANITIZER_INTERCEPT_GETCWD SI_POSIX\n #define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STRTOIMAX SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_MBSTOWCS SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_MBSNRTOWCS SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_WCSTOMBS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRTOIMAX SI_POSIX\n+#define SANITIZER_INTERCEPT_MBSTOWCS SI_POSIX\n+#define SANITIZER_INTERCEPT_MBSNRTOWCS (SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_WCSTOMBS SI_POSIX\n #define SANITIZER_INTERCEPT_WCSNRTOMBS \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_WCRTOMB \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_REALPATH SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_REALPATH SI_POSIX\n #define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_CONFSTR \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SCHED_GETPARAM SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STRERROR SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_STRERROR_R SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRERROR SI_POSIX\n+#define SANITIZER_INTERCEPT_STRERROR_R SI_POSIX\n #define SANITIZER_INTERCEPT_XPG_STRERROR_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SCANDIR \\\n-  SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETGROUPS SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_POLL SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETGROUPS SI_POSIX\n+#define SANITIZER_INTERCEPT_POLL SI_POSIX\n #define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WORDEXP \\\n-  SI_FREEBSD || (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SIGWAIT SI_NOT_WINDOWS\n+  (SI_FREEBSD || SI_NETBSD || (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_SIGWAIT SI_POSIX\n #define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGSETOPS \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_BACKTRACE SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_SIGPENDING SI_POSIX\n+#define SANITIZER_INTERCEPT_SIGPROCMASK SI_POSIX\n+#define SANITIZER_INTERCEPT_BACKTRACE \\\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n #define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STATFS SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STATFS \\\n+  (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATFS64 \\\n-  (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STATVFS SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+  ((SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_STATVFS \\\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_INITGROUPS SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_ETHER_NTOA_ATON SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_INITGROUPS SI_POSIX\n+#define SANITIZER_INTERCEPT_ETHER_NTOA_ATON SI_POSIX\n #define SANITIZER_INTERCEPT_ETHER_HOST \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_ETHER_R SI_FREEBSD || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SHMCTL \\\n-  ((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && SANITIZER_WORDSIZE == 64)\n+  (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_ETHER_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_SHMCTL                       \\\n+  (SI_NETBSD || ((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && \\\n+                 SANITIZER_WORDSIZE == 64))  // NOLINT\n #define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPROTOCOL \\\n-  SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_MAC || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPRIOCEILING \\\n-  SI_MAC || SI_LINUX_NOT_ANDROID\n+  (SI_MAC || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_TMPNAM SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_TMPNAM SI_POSIX\n #define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_TTYNAME_R SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_TEMPNAM SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_TTYNAME_R SI_POSIX\n+#define SANITIZER_INTERCEPT_TEMPNAM SI_POSIX\n #define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n-#define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_LGAMMA SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_LGAMMA_R SI_FREEBSD || SI_LINUX\n+#define SANITIZER_INTERCEPT_REMQUO SI_POSIX\n+#define SANITIZER_INTERCEPT_LGAMMA SI_POSIX\n+#define SANITIZER_INTERCEPT_LGAMMA_R (SI_FREEBSD || SI_LINUX)\n #define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_RAND_R \\\n-  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_ICONV SI_FREEBSD || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_TIMES SI_NOT_WINDOWS\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_ICONV \\\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_TIMES SI_POSIX\n \n // FIXME: getline seems to be available on OSX 10.7\n-#define SANITIZER_INTERCEPT_GETLINE SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETLINE \\\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n \n-#define SANITIZER_INTERCEPT__EXIT SI_LINUX || SI_FREEBSD || SI_MAC\n+#define SANITIZER_INTERCEPT__EXIT \\\n+  (SI_LINUX || SI_FREEBSD || SI_NETBSD || SI_MAC)\n \n-#define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n-  SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n \n #define SANITIZER_INTERCEPT_TLS_GET_ADDR \\\n-  SI_FREEBSD || SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n \n #define SANITIZER_INTERCEPT_LISTXATTR SI_LINUX\n #define SANITIZER_INTERCEPT_GETXATTR SI_LINUX\n #define SANITIZER_INTERCEPT_GETRESID SI_LINUX\n #define SANITIZER_INTERCEPT_GETIFADDRS \\\n-  SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_MAC)\n #define SANITIZER_INTERCEPT_IF_INDEXTONAME \\\n-  SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_MAC)\n #define SANITIZER_INTERCEPT_CAPGET SI_LINUX_NOT_ANDROID\n #if SI_LINUX && defined(__arm__)\n #define SANITIZER_INTERCEPT_AEABI_MEM 1\n #else\n #define SANITIZER_INTERCEPT_AEABI_MEM 0\n #endif\n #define SANITIZER_INTERCEPT___BZERO SI_MAC\n-#define SANITIZER_INTERCEPT_FTIME !SI_FREEBSD && SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FTIME (!SI_FREEBSD && !SI_NETBSD && SI_POSIX)\n #define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_TSEARCH SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_TSEARCH \\\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD)\n #define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_FOPEN SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FOPEN SI_POSIX\n #define SANITIZER_INTERCEPT_FOPEN64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_OPEN_MEMSTREAM SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_OPEN_MEMSTREAM (SI_LINUX_NOT_ANDROID || SI_NETBSD)\n #define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_FFLUSH SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_FCLOSE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FFLUSH SI_POSIX\n+#define SANITIZER_INTERCEPT_FCLOSE SI_POSIX\n \n #ifndef SANITIZER_INTERCEPT_DLOPEN_DLCLOSE\n #define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE \\\n-    SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_MAC)\n #endif\n \n-#define SANITIZER_INTERCEPT_GETPASS SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_GETPASS \\\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD)\n #define SANITIZER_INTERCEPT_TIMERFD SI_LINUX_NOT_ANDROID\n \n-#define SANITIZER_INTERCEPT_MLOCKX SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MLOCKX SI_POSIX\n #define SANITIZER_INTERCEPT_FOPENCOOKIE SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SEM SI_LINUX || SI_FREEBSD\n-#define SANITIZER_INTERCEPT_PTHREAD_SETCANCEL SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_MINCORE SI_LINUX\n+#define SANITIZER_INTERCEPT_SEM (SI_LINUX || SI_FREEBSD || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_PTHREAD_SETCANCEL SI_POSIX\n+#define SANITIZER_INTERCEPT_MINCORE (SI_LINUX || SI_NETBSD)\n #define SANITIZER_INTERCEPT_PROCESS_VM_READV SI_LINUX\n-#define SANITIZER_INTERCEPT_CTERMID SI_LINUX || SI_MAC || SI_FREEBSD\n-#define SANITIZER_INTERCEPT_CTERMID_R SI_MAC || SI_FREEBSD\n+#define SANITIZER_INTERCEPT_CTERMID \\\n+  (SI_LINUX || SI_MAC || SI_FREEBSD || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_CTERMID_R (SI_MAC || SI_FREEBSD)\n \n-#define SANITIZER_INTERCEPTOR_HOOKS SI_LINUX\n-#define SANITIZER_INTERCEPT_RECV_RECVFROM SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_SEND_SENDTO SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPTOR_HOOKS (SI_LINUX || SI_MAC || SI_WINDOWS)\n+#define SANITIZER_INTERCEPT_RECV_RECVFROM SI_POSIX\n+#define SANITIZER_INTERCEPT_SEND_SENDTO SI_POSIX\n #define SANITIZER_INTERCEPT_EVENTFD_READ_WRITE SI_LINUX\n \n-#define SANITIZER_INTERCEPT_STAT (SI_FREEBSD || SI_MAC || SI_ANDROID)\n-#define SANITIZER_INTERCEPT___XSTAT !SANITIZER_INTERCEPT_STAT && SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STAT \\\n+  (SI_FREEBSD || SI_MAC || SI_ANDROID || SI_NETBSD)\n+#define SANITIZER_INTERCEPT___XSTAT (!SANITIZER_INTERCEPT_STAT && SI_POSIX)\n #define SANITIZER_INTERCEPT___XSTAT64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT___LXSTAT SANITIZER_INTERCEPT___XSTAT\n #define SANITIZER_INTERCEPT___LXSTAT64 SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT_UTMP (SI_POSIX && !SI_MAC && !SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_UTMPX (SI_LINUX_NOT_ANDROID || SI_MAC || SI_FREEBSD)\n+\n+#define SANITIZER_INTERCEPT_GETLOADAVG \\\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_FREEBSD || SI_NETBSD)\n+\n+#define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO \\\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA)\n+#define SANITIZER_INTERCEPT_MEMALIGN (!SI_FREEBSD && !SI_MAC && !SI_NETBSD)\n+#define SANITIZER_INTERCEPT_PVALLOC \\\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA)\n+#define SANITIZER_INTERCEPT_CFREE \\\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA)\n+#define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC)\n+#define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC)\n+#define SANITIZER_INTERCEPT_MCHECK_MPROBE SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WCSCAT SI_POSIX\n+#define SANITIZER_INTERCEPT_SIGNAL_AND_SIGACTION (!SI_WINDOWS && SI_NOT_FUCHSIA)\n+#define SANITIZER_INTERCEPT_BSD_SIGNAL SI_ANDROID\n+\n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "3c18ca6ce25a89137cbcf5c2a7e79796fa44e88c", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.cc", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,357 @@\n+//===-- sanitizer_platform_limits_netbsd.cc -------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific NetBSD data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_NETBSD\n+#include <arpa/inet.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <grp.h>\n+#include <ifaddrs.h>\n+#include <limits.h>\n+#include <link_elf.h>\n+#include <net/if.h>\n+#include <net/if_ether.h>\n+#include <net/ppp_defs.h>\n+#include <net/route.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/ip_mroute.h>\n+#include <poll.h>\n+#include <pthread.h>\n+#include <pwd.h>\n+#include <semaphore.h>\n+#include <signal.h>\n+#include <stddef.h>\n+#include <sys/filio.h>\n+#include <sys/ipc.h>\n+#include <sys/mman.h>\n+#include <sys/mount.h>\n+#include <sys/mqueue.h>\n+#include <sys/msg.h>\n+#include <sys/mtio.h>\n+#include <sys/ptrace.h>\n+#include <sys/resource.h>\n+#include <sys/shm.h>\n+#include <sys/signal.h>\n+#include <sys/socket.h>\n+#include <sys/sockio.h>\n+#include <sys/soundcard.h>\n+#include <sys/stat.h>\n+#include <sys/statvfs.h>\n+#include <sys/time.h>\n+#include <sys/timeb.h>\n+#include <sys/times.h>\n+#include <sys/timespec.h>\n+#include <sys/timex.h>\n+#include <sys/types.h>\n+#include <sys/ucontext.h>\n+#include <sys/utsname.h>\n+#include <term.h>\n+#include <termios.h>\n+#include <time.h>\n+#include <utime.h>\n+#include <utmp.h>\n+#include <utmpx.h>\n+#include <wchar.h>\n+#include <wordexp.h>\n+\n+// Include these after system headers to avoid name clashes and ambiguities.\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_netbsd.h\"\n+\n+namespace __sanitizer {\n+unsigned struct_utsname_sz = sizeof(struct utsname);\n+unsigned struct_stat_sz = sizeof(struct stat);\n+unsigned struct_rusage_sz = sizeof(struct rusage);\n+unsigned struct_tm_sz = sizeof(struct tm);\n+unsigned struct_passwd_sz = sizeof(struct passwd);\n+unsigned struct_group_sz = sizeof(struct group);\n+unsigned siginfo_t_sz = sizeof(siginfo_t);\n+unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+unsigned struct_itimerval_sz = sizeof(struct itimerval);\n+unsigned pthread_t_sz = sizeof(pthread_t);\n+unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n+unsigned pid_t_sz = sizeof(pid_t);\n+unsigned timeval_sz = sizeof(timeval);\n+unsigned uid_t_sz = sizeof(uid_t);\n+unsigned gid_t_sz = sizeof(gid_t);\n+unsigned mbstate_t_sz = sizeof(mbstate_t);\n+unsigned sigset_t_sz = sizeof(sigset_t);\n+unsigned struct_timezone_sz = sizeof(struct timezone);\n+unsigned struct_tms_sz = sizeof(struct tms);\n+unsigned struct_sigevent_sz = sizeof(struct sigevent);\n+unsigned struct_sched_param_sz = sizeof(struct sched_param);\n+unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n+unsigned ucontext_t_sz = sizeof(ucontext_t);\n+unsigned struct_rlimit_sz = sizeof(struct rlimit);\n+unsigned struct_timespec_sz = sizeof(struct timespec);\n+unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n+unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n+unsigned struct_timex_sz = sizeof(struct timex);\n+unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n+unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n+unsigned struct_statvfs_sz = sizeof(struct statvfs);\n+\n+uptr sig_ign = (uptr)SIG_IGN;\n+uptr sig_dfl = (uptr)SIG_DFL;\n+uptr sa_siginfo = (uptr)SA_SIGINFO;\n+\n+int shmctl_ipc_stat = (int)IPC_STAT;\n+\n+unsigned struct_utmp_sz = sizeof(struct utmp);\n+unsigned struct_utmpx_sz = sizeof(struct utmpx);\n+\n+int map_fixed = MAP_FIXED;\n+\n+int af_inet = (int)AF_INET;\n+int af_inet6 = (int)AF_INET6;\n+\n+uptr __sanitizer_in_addr_sz(int af) {\n+  if (af == AF_INET)\n+    return sizeof(struct in_addr);\n+  else if (af == AF_INET6)\n+    return sizeof(struct in6_addr);\n+  else\n+    return 0;\n+}\n+\n+int glob_nomatch = GLOB_NOMATCH;\n+int glob_altdirfunc = GLOB_ALTDIRFUNC;\n+\n+unsigned path_max = PATH_MAX;\n+\n+// ioctl arguments\n+unsigned struct_ifreq_sz = sizeof(struct ifreq);\n+unsigned struct_termios_sz = sizeof(struct termios);\n+unsigned struct_winsize_sz = sizeof(struct winsize);\n+unsigned struct_mtget_sz = sizeof(struct mtget);\n+unsigned struct_mtop_sz = sizeof(struct mtop);\n+unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n+unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n+unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n+unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n+\n+const unsigned IOCTL_NOT_PRESENT = 0;\n+\n+unsigned IOCTL_FIOASYNC = FIOASYNC;\n+unsigned IOCTL_FIOCLEX = FIOCLEX;\n+unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n+unsigned IOCTL_FIONBIO = FIONBIO;\n+unsigned IOCTL_FIONCLEX = FIONCLEX;\n+unsigned IOCTL_FIOSETOWN = FIOSETOWN;\n+unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n+unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n+unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n+unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n+unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n+unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n+unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n+unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n+unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n+unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n+unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n+unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n+unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n+unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n+unsigned IOCTL_SIOCSIFDSTADDR = SIOCSIFDSTADDR;\n+unsigned IOCTL_SIOCSIFFLAGS = SIOCSIFFLAGS;\n+unsigned IOCTL_SIOCSIFMETRIC = SIOCSIFMETRIC;\n+unsigned IOCTL_SIOCSIFMTU = SIOCSIFMTU;\n+unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n+unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n+unsigned IOCTL_TIOCCONS = TIOCCONS;\n+unsigned IOCTL_TIOCEXCL = TIOCEXCL;\n+unsigned IOCTL_TIOCGETD = TIOCGETD;\n+unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n+unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n+unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n+unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n+unsigned IOCTL_TIOCMGET = TIOCMGET;\n+unsigned IOCTL_TIOCMSET = TIOCMSET;\n+unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n+unsigned IOCTL_TIOCNXCL = TIOCNXCL;\n+unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n+unsigned IOCTL_TIOCPKT = TIOCPKT;\n+unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n+unsigned IOCTL_TIOCSETD = TIOCSETD;\n+unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n+unsigned IOCTL_TIOCSTI = TIOCSTI;\n+unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n+unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n+unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n+\n+const int si_SEGV_MAPERR = SEGV_MAPERR;\n+const int si_SEGV_ACCERR = SEGV_ACCERR;\n+}  // namespace __sanitizer\n+\n+using namespace __sanitizer;\n+\n+COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n+\n+COMPILER_CHECK(sizeof(socklen_t) == sizeof(unsigned));\n+CHECK_TYPE_SIZE(pthread_key_t);\n+\n+// There are more undocumented fields in dl_phdr_info that we are not interested\n+// in.\n+COMPILER_CHECK(sizeof(__sanitizer_dl_phdr_info) <= sizeof(dl_phdr_info));\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_addr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n+\n+CHECK_TYPE_SIZE(glob_t);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_offs);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_flags);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_closedir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_readdir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_opendir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_lstat);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_stat);\n+\n+CHECK_TYPE_SIZE(addrinfo);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_flags);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_family);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_socktype);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addrlen);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_canonname);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addr);\n+\n+CHECK_TYPE_SIZE(hostent);\n+CHECK_SIZE_AND_OFFSET(hostent, h_name);\n+CHECK_SIZE_AND_OFFSET(hostent, h_aliases);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addrtype);\n+CHECK_SIZE_AND_OFFSET(hostent, h_length);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addr_list);\n+\n+CHECK_TYPE_SIZE(iovec);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_base);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_len);\n+\n+CHECK_TYPE_SIZE(msghdr);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_name);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_namelen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iov);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iovlen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_control);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_controllen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_flags);\n+\n+CHECK_TYPE_SIZE(cmsghdr);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_len);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_level);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_type);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_dirent) <= sizeof(dirent));\n+CHECK_SIZE_AND_OFFSET(dirent, d_fileno);\n+CHECK_SIZE_AND_OFFSET(dirent, d_reclen);\n+\n+CHECK_TYPE_SIZE(ifconf);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_len);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_ifcu);\n+\n+CHECK_TYPE_SIZE(pollfd);\n+CHECK_SIZE_AND_OFFSET(pollfd, fd);\n+CHECK_SIZE_AND_OFFSET(pollfd, events);\n+CHECK_SIZE_AND_OFFSET(pollfd, revents);\n+\n+CHECK_TYPE_SIZE(nfds_t);\n+\n+CHECK_TYPE_SIZE(sigset_t);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_sigaction) == sizeof(struct sigaction));\n+// Can't write checks for sa_handler and sa_sigaction due to them being\n+// preprocessor macros.\n+CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_mask);\n+\n+CHECK_TYPE_SIZE(wordexp_t);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordc);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordv);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_offs);\n+\n+CHECK_TYPE_SIZE(tm);\n+CHECK_SIZE_AND_OFFSET(tm, tm_sec);\n+CHECK_SIZE_AND_OFFSET(tm, tm_min);\n+CHECK_SIZE_AND_OFFSET(tm, tm_hour);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mon);\n+CHECK_SIZE_AND_OFFSET(tm, tm_year);\n+CHECK_SIZE_AND_OFFSET(tm, tm_wday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_yday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_isdst);\n+CHECK_SIZE_AND_OFFSET(tm, tm_gmtoff);\n+CHECK_SIZE_AND_OFFSET(tm, tm_zone);\n+\n+CHECK_TYPE_SIZE(ether_addr);\n+\n+CHECK_TYPE_SIZE(ipc_perm);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, _key);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, _seq);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, uid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, gid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, mode);\n+\n+CHECK_TYPE_SIZE(shmid_ds);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_perm);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_segsz);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_atime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_dtime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_ctime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_cpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_lpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_nattch);\n+\n+CHECK_TYPE_SIZE(clock_t);\n+\n+CHECK_TYPE_SIZE(ifaddrs);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_next);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_name);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_addr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_netmask);\n+// Compare against the union, because we can't reach into the union in a\n+// compliant way.\n+#ifdef ifa_dstaddr\n+#undef ifa_dstaddr\n+#endif\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n+\n+CHECK_TYPE_SIZE(timeb);\n+CHECK_SIZE_AND_OFFSET(timeb, time);\n+CHECK_SIZE_AND_OFFSET(timeb, millitm);\n+CHECK_SIZE_AND_OFFSET(timeb, timezone);\n+CHECK_SIZE_AND_OFFSET(timeb, dstflag);\n+\n+CHECK_TYPE_SIZE(passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_name);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_uid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_dir);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_shell);\n+\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gecos);\n+\n+CHECK_TYPE_SIZE(group);\n+CHECK_SIZE_AND_OFFSET(group, gr_name);\n+CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n+CHECK_SIZE_AND_OFFSET(group, gr_gid);\n+CHECK_SIZE_AND_OFFSET(group, gr_mem);\n+\n+#endif  // SANITIZER_NETBSD"}, {"sha": "e7034ed6b528976f5d54fe2d41f468589511d285", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.h", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -0,0 +1,566 @@\n+//===-- sanitizer_platform_limits_netbsd.h --------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific NetBSD data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_PLATFORM_LIMITS_NETBSD_H\n+#define SANITIZER_PLATFORM_LIMITS_NETBSD_H\n+\n+#if SANITIZER_NETBSD\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform.h\"\n+\n+#define _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, shift) \\\n+  ((link_map *)((handle) == nullptr ? nullptr : ((char *)(handle) + (shift))))\n+\n+#if defined(__x86_64__)\n+#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 608)\n+#elif defined(__i386__)\n+#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 324)\n+#endif\n+\n+namespace __sanitizer {\n+extern unsigned struct_utsname_sz;\n+extern unsigned struct_stat_sz;\n+extern unsigned struct_rusage_sz;\n+extern unsigned siginfo_t_sz;\n+extern unsigned struct_itimerval_sz;\n+extern unsigned pthread_t_sz;\n+extern unsigned pthread_cond_t_sz;\n+extern unsigned pid_t_sz;\n+extern unsigned timeval_sz;\n+extern unsigned uid_t_sz;\n+extern unsigned gid_t_sz;\n+extern unsigned mbstate_t_sz;\n+extern unsigned struct_timezone_sz;\n+extern unsigned struct_tms_sz;\n+extern unsigned struct_itimerspec_sz;\n+extern unsigned struct_sigevent_sz;\n+extern unsigned struct_sched_param_sz;\n+extern unsigned struct_statfs_sz;\n+extern unsigned struct_sockaddr_sz;\n+extern unsigned ucontext_t_sz;\n+\n+extern unsigned struct_rlimit_sz;\n+extern unsigned struct_utimbuf_sz;\n+extern unsigned struct_timespec_sz;\n+\n+struct __sanitizer_iocb {\n+  u64 aio_offset;\n+  uptr aio_buf;\n+  long aio_nbytes;\n+  u32 aio_fildes;\n+  u32 aio_lio_opcode;\n+  long aio_reqprio;\n+#if SANITIZER_WORDSIZE == 64\n+  u8 aio_sigevent[32];\n+#else\n+  u8 aio_sigevent[20];\n+#endif\n+  u32 _state;\n+  u32 _errno;\n+  long _retval;\n+};\n+\n+struct __sanitizer___sysctl_args {\n+  int *name;\n+  int nlen;\n+  void *oldval;\n+  uptr *oldlenp;\n+  void *newval;\n+  uptr newlen;\n+};\n+\n+struct __sanitizer_sem_t {\n+  uptr data[5];\n+};\n+\n+struct __sanitizer_ipc_perm {\n+  u32 uid;\n+  u32 gid;\n+  u32 cuid;\n+  u32 cgid;\n+  u32 mode;\n+  unsigned short _seq;\n+  long _key;\n+};\n+\n+struct __sanitizer_shmid_ds {\n+  __sanitizer_ipc_perm shm_perm;\n+  unsigned long shm_segsz;\n+  u32 shm_lpid;\n+  u32 shm_cpid;\n+  unsigned int shm_nattch;\n+  u64 shm_atime;\n+  u64 shm_dtime;\n+  u64 shm_ctime;\n+  void *_shm_internal;\n+};\n+\n+extern unsigned struct_msqid_ds_sz;\n+extern unsigned struct_mq_attr_sz;\n+extern unsigned struct_timex_sz;\n+extern unsigned struct_statvfs_sz;\n+\n+struct __sanitizer_iovec {\n+  void *iov_base;\n+  uptr iov_len;\n+};\n+\n+struct __sanitizer_ifaddrs {\n+  struct __sanitizer_ifaddrs *ifa_next;\n+  char *ifa_name;\n+  unsigned int ifa_flags;\n+  void *ifa_addr;     // (struct sockaddr *)\n+  void *ifa_netmask;  // (struct sockaddr *)\n+  void *ifa_dstaddr;  // (struct sockaddr *)\n+  void *ifa_data;\n+  unsigned int ifa_addrflags;\n+};\n+\n+typedef unsigned __sanitizer_pthread_key_t;\n+\n+typedef long long __sanitizer_time_t;\n+\n+struct __sanitizer_passwd {\n+  char *pw_name;\n+  char *pw_passwd;\n+  int pw_uid;\n+  int pw_gid;\n+  __sanitizer_time_t pw_change;\n+  char *pw_class;\n+  char *pw_gecos;\n+  char *pw_dir;\n+  char *pw_shell;\n+  __sanitizer_time_t pw_expire;\n+};\n+\n+struct __sanitizer_group {\n+  char *gr_name;\n+  char *gr_passwd;\n+  int gr_gid;\n+  char **gr_mem;\n+};\n+\n+struct __sanitizer_timeb {\n+  __sanitizer_time_t time;\n+  unsigned short millitm;\n+  short timezone;\n+  short dstflag;\n+};\n+\n+struct __sanitizer_ether_addr {\n+  u8 octet[6];\n+};\n+\n+struct __sanitizer_tm {\n+  int tm_sec;\n+  int tm_min;\n+  int tm_hour;\n+  int tm_mday;\n+  int tm_mon;\n+  int tm_year;\n+  int tm_wday;\n+  int tm_yday;\n+  int tm_isdst;\n+  long int tm_gmtoff;\n+  const char *tm_zone;\n+};\n+\n+struct __sanitizer_msghdr {\n+  void *msg_name;\n+  unsigned msg_namelen;\n+  struct __sanitizer_iovec *msg_iov;\n+  unsigned msg_iovlen;\n+  void *msg_control;\n+  unsigned msg_controllen;\n+  int msg_flags;\n+};\n+struct __sanitizer_cmsghdr {\n+  unsigned cmsg_len;\n+  int cmsg_level;\n+  int cmsg_type;\n+};\n+\n+struct __sanitizer_dirent {\n+  u64 d_fileno;\n+  u16 d_reclen;\n+  // more fields that we don't care about\n+};\n+\n+typedef int __sanitizer_clock_t;\n+typedef int __sanitizer_clockid_t;\n+\n+typedef u32 __sanitizer___kernel_uid_t;\n+typedef u32 __sanitizer___kernel_gid_t;\n+typedef u64 __sanitizer___kernel_off_t;\n+typedef struct {\n+  u32 fds_bits[8];\n+} __sanitizer___kernel_fd_set;\n+\n+typedef struct {\n+  unsigned int pta_magic;\n+  int pta_flags;\n+  void *pta_private;\n+} __sanitizer_pthread_attr_t;\n+\n+struct __sanitizer_sigset_t {\n+  // uint32_t * 4\n+  unsigned int __bits[4];\n+};\n+\n+struct __sanitizer_sigaction {\n+  union {\n+    void (*handler)(int sig);\n+    void (*sigaction)(int sig, void *siginfo, void *uctx);\n+  };\n+  __sanitizer_sigset_t sa_mask;\n+  int sa_flags;\n+};\n+\n+typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n+\n+struct __sanitizer_kernel_sigaction_t {\n+  union {\n+    void (*handler)(int signo);\n+    void (*sigaction)(int signo, void *info, void *ctx);\n+  };\n+  unsigned long sa_flags;\n+  void (*sa_restorer)(void);\n+  __sanitizer_kernel_sigset_t sa_mask;\n+};\n+\n+extern uptr sig_ign;\n+extern uptr sig_dfl;\n+extern uptr sa_siginfo;\n+\n+extern int af_inet;\n+extern int af_inet6;\n+uptr __sanitizer_in_addr_sz(int af);\n+\n+struct __sanitizer_dl_phdr_info {\n+  uptr dlpi_addr;\n+  const char *dlpi_name;\n+  const void *dlpi_phdr;\n+  short dlpi_phnum;\n+};\n+\n+extern unsigned struct_ElfW_Phdr_sz;\n+\n+struct __sanitizer_addrinfo {\n+  int ai_flags;\n+  int ai_family;\n+  int ai_socktype;\n+  int ai_protocol;\n+  unsigned ai_addrlen;\n+  char *ai_canonname;\n+  void *ai_addr;\n+  struct __sanitizer_addrinfo *ai_next;\n+};\n+\n+struct __sanitizer_hostent {\n+  char *h_name;\n+  char **h_aliases;\n+  int h_addrtype;\n+  int h_length;\n+  char **h_addr_list;\n+};\n+\n+struct __sanitizer_pollfd {\n+  int fd;\n+  short events;\n+  short revents;\n+};\n+\n+typedef unsigned __sanitizer_nfds_t;\n+\n+struct __sanitizer_glob_t {\n+  uptr gl_pathc;\n+  uptr gl_matchc;\n+  uptr gl_offs;\n+  int gl_flags;\n+  char **gl_pathv;\n+  int (*gl_errfunc)(const char *, int);\n+  void (*gl_closedir)(void *dirp);\n+  struct dirent *(*gl_readdir)(void *dirp);\n+  void *(*gl_opendir)(const char *);\n+  int (*gl_lstat)(const char *, void * /* struct stat* */);\n+  int (*gl_stat)(const char *, void * /* struct stat* */);\n+};\n+\n+extern int glob_nomatch;\n+extern int glob_altdirfunc;\n+\n+extern unsigned path_max;\n+\n+struct __sanitizer_wordexp_t {\n+  uptr we_wordc;\n+  char **we_wordv;\n+  uptr we_offs;\n+  char *we_strings;\n+  uptr we_nbytes;\n+};\n+\n+typedef void __sanitizer_FILE;\n+#define SANITIZER_HAS_STRUCT_FILE 0\n+\n+extern int shmctl_ipc_stat;\n+\n+// This simplifies generic code\n+#define struct_shminfo_sz -1\n+#define struct_shm_info_sz -1\n+#define shmctl_shm_stat -1\n+#define shmctl_ipc_info -1\n+#define shmctl_shm_info -1\n+\n+extern unsigned struct_utmp_sz;\n+extern unsigned struct_utmpx_sz;\n+\n+extern int map_fixed;\n+\n+// ioctl arguments\n+struct __sanitizer_ifconf {\n+  int ifc_len;\n+  union {\n+    void *ifcu_req;\n+  } ifc_ifcu;\n+};\n+\n+#define IOC_NRBITS 8\n+#define IOC_TYPEBITS 8\n+#define IOC_SIZEBITS 14\n+#define IOC_DIRBITS 2\n+#define IOC_NONE 0U\n+#define IOC_WRITE 1U\n+#define IOC_READ 2U\n+#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n+#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n+#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n+#undef IOC_DIRMASK\n+#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n+#define IOC_NRSHIFT 0\n+#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n+#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n+#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n+#define EVIOC_EV_MAX 0x1f\n+#define EVIOC_ABS_MAX 0x3f\n+\n+#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n+#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n+#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n+#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n+\n+extern unsigned struct_ifreq_sz;\n+extern unsigned struct_termios_sz;\n+extern unsigned struct_winsize_sz;\n+\n+extern unsigned struct_arpreq_sz;\n+\n+extern unsigned struct_mtget_sz;\n+extern unsigned struct_mtop_sz;\n+extern unsigned struct_rtentry_sz;\n+extern unsigned struct_sbi_instrument_sz;\n+extern unsigned struct_seq_event_rec_sz;\n+extern unsigned struct_synth_info_sz;\n+extern unsigned struct_vt_mode_sz;\n+extern unsigned struct_audio_buf_info_sz;\n+extern unsigned struct_ppp_stats_sz;\n+extern unsigned struct_sioc_sg_req_sz;\n+extern unsigned struct_sioc_vif_req_sz;\n+\n+// ioctl request identifiers\n+\n+// A special value to mark ioctls that are not present on the target platform,\n+// when it can not be determined without including any system headers.\n+extern const unsigned IOCTL_NOT_PRESENT;\n+\n+extern unsigned IOCTL_FIOASYNC;\n+extern unsigned IOCTL_FIOCLEX;\n+extern unsigned IOCTL_FIOGETOWN;\n+extern unsigned IOCTL_FIONBIO;\n+extern unsigned IOCTL_FIONCLEX;\n+extern unsigned IOCTL_FIOSETOWN;\n+extern unsigned IOCTL_SIOCADDMULTI;\n+extern unsigned IOCTL_SIOCATMARK;\n+extern unsigned IOCTL_SIOCDELMULTI;\n+extern unsigned IOCTL_SIOCGIFADDR;\n+extern unsigned IOCTL_SIOCGIFBRDADDR;\n+extern unsigned IOCTL_SIOCGIFCONF;\n+extern unsigned IOCTL_SIOCGIFDSTADDR;\n+extern unsigned IOCTL_SIOCGIFFLAGS;\n+extern unsigned IOCTL_SIOCGIFMETRIC;\n+extern unsigned IOCTL_SIOCGIFMTU;\n+extern unsigned IOCTL_SIOCGIFNETMASK;\n+extern unsigned IOCTL_SIOCGPGRP;\n+extern unsigned IOCTL_SIOCSIFADDR;\n+extern unsigned IOCTL_SIOCSIFBRDADDR;\n+extern unsigned IOCTL_SIOCSIFDSTADDR;\n+extern unsigned IOCTL_SIOCSIFFLAGS;\n+extern unsigned IOCTL_SIOCSIFMETRIC;\n+extern unsigned IOCTL_SIOCSIFMTU;\n+extern unsigned IOCTL_SIOCSIFNETMASK;\n+extern unsigned IOCTL_SIOCSPGRP;\n+extern unsigned IOCTL_TIOCCONS;\n+extern unsigned IOCTL_TIOCEXCL;\n+extern unsigned IOCTL_TIOCGETD;\n+extern unsigned IOCTL_TIOCGPGRP;\n+extern unsigned IOCTL_TIOCGWINSZ;\n+extern unsigned IOCTL_TIOCMBIC;\n+extern unsigned IOCTL_TIOCMBIS;\n+extern unsigned IOCTL_TIOCMGET;\n+extern unsigned IOCTL_TIOCMSET;\n+extern unsigned IOCTL_TIOCNOTTY;\n+extern unsigned IOCTL_TIOCNXCL;\n+extern unsigned IOCTL_TIOCOUTQ;\n+extern unsigned IOCTL_TIOCPKT;\n+extern unsigned IOCTL_TIOCSCTTY;\n+extern unsigned IOCTL_TIOCSETD;\n+extern unsigned IOCTL_TIOCSPGRP;\n+extern unsigned IOCTL_TIOCSTI;\n+extern unsigned IOCTL_TIOCSWINSZ;\n+extern unsigned IOCTL_SIOCGETSGCNT;\n+extern unsigned IOCTL_SIOCGETVIFCNT;\n+extern unsigned IOCTL_MTIOCGET;\n+extern unsigned IOCTL_MTIOCTOP;\n+extern unsigned IOCTL_SIOCADDRT;\n+extern unsigned IOCTL_SIOCDELRT;\n+extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n+extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n+extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n+extern unsigned IOCTL_SNDCTL_DSP_POST;\n+extern unsigned IOCTL_SNDCTL_DSP_RESET;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n+extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n+extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n+extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n+extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n+extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n+extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n+extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n+extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n+extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n+extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n+extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n+extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n+extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n+extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n+extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n+extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n+extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n+extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n+extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n+extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n+extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n+extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n+extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n+extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n+extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n+extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n+extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n+extern unsigned IOCTL_SNDCTL_TMR_START;\n+extern unsigned IOCTL_SNDCTL_TMR_STOP;\n+extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n+extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n+extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n+extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n+extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n+extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n+extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n+extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n+extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n+extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n+extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n+extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n+extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n+extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n+extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n+extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n+extern unsigned IOCTL_VT_ACTIVATE;\n+extern unsigned IOCTL_VT_GETMODE;\n+extern unsigned IOCTL_VT_OPENQRY;\n+extern unsigned IOCTL_VT_RELDISP;\n+extern unsigned IOCTL_VT_SETMODE;\n+extern unsigned IOCTL_VT_WAITACTIVE;\n+extern unsigned IOCTL_KDDISABIO;\n+extern unsigned IOCTL_KDENABIO;\n+extern unsigned IOCTL_KDGETLED;\n+extern unsigned IOCTL_KDGKBMODE;\n+extern unsigned IOCTL_KDGKBTYPE;\n+extern unsigned IOCTL_KDMKTONE;\n+extern unsigned IOCTL_KDSETLED;\n+extern unsigned IOCTL_KDSETMODE;\n+extern unsigned IOCTL_KDSKBMODE;\n+\n+extern const int si_SEGV_MAPERR;\n+extern const int si_SEGV_ACCERR;\n+}  // namespace __sanitizer\n+\n+#define CHECK_TYPE_SIZE(TYPE) \\\n+  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n+\n+#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n+  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *)NULL)->MEMBER) == \\\n+                 sizeof(((CLASS *)NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==         \\\n+                 offsetof(CLASS, MEMBER))\n+\n+// For sigaction, which is a function and struct at the same time,\n+// and thus requires explicit \"struct\" in sizeof() expression.\n+#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n+  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *)NULL)->MEMBER) == \\\n+                 sizeof(((struct CLASS *)NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n+                 offsetof(struct CLASS, MEMBER))\n+\n+#endif  // SANITIZER_NETBSD\n+\n+#endif"}, {"sha": "858bb2184505829ad7aae5def4cda515d3a48426", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -23,7 +23,6 @@\n #endif\n #include <arpa/inet.h>\n #include <dirent.h>\n-#include <errno.h>\n #include <grp.h>\n #include <limits.h>\n #include <net/if.h>\n@@ -44,6 +43,9 @@\n #include <termios.h>\n #include <time.h>\n #include <wchar.h>\n+#if !SANITIZER_MAC && !SANITIZER_FREEBSD\n+#include <utmp.h>\n+#endif\n \n #if !SANITIZER_IOS\n #include <net/route.h>\n@@ -52,6 +54,7 @@\n #if !SANITIZER_ANDROID\n #include <sys/mount.h>\n #include <sys/timeb.h>\n+#include <utmpx.h>\n #endif\n \n #if SANITIZER_LINUX\n@@ -277,6 +280,13 @@ namespace __sanitizer {\n   int shmctl_shm_stat = (int)SHM_STAT;\n #endif\n \n+#if !SANITIZER_MAC && !SANITIZER_FREEBSD\n+  unsigned struct_utmp_sz = sizeof(struct utmp);\n+#endif\n+#if !SANITIZER_ANDROID\n+  unsigned struct_utmpx_sz = sizeof(struct utmpx);\n+#endif\n+\n   int map_fixed = MAP_FIXED;\n \n   int af_inet = (int)AF_INET;\n@@ -918,14 +928,6 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_SNDCTL_DSP_GETOSPACE = SNDCTL_DSP_GETOSPACE;\n #endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n-  const int errno_EINVAL = EINVAL;\n-// EOWNERDEAD is not present in some older platforms.\n-#if defined(EOWNERDEAD)\n-  const int errno_EOWNERDEAD = EOWNERDEAD;\n-#else\n-  const int errno_EOWNERDEAD = -1;\n-#endif\n-\n   const int si_SEGV_MAPERR = SEGV_MAPERR;\n   const int si_SEGV_ACCERR = SEGV_ACCERR;\n } // namespace __sanitizer"}, {"sha": "4d11d071776c00e7e18d3356f8905d749509abe0", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61", "patch": "@@ -13,6 +13,8 @@\n #ifndef SANITIZER_PLATFORM_LIMITS_POSIX_H\n #define SANITIZER_PLATFORM_LIMITS_POSIX_H\n \n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC\n+\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n@@ -21,6 +23,9 @@\n // incorporates the map structure.\n # define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n     ((link_map*)((handle) == nullptr ? nullptr : ((char*)(handle) + 544)))\n+// Get sys/_types.h, because that tells us whether 64-bit inodes are\n+// used in struct dirent below.\n+#include <sys/_types.h>\n #else\n # define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) ((link_map*)(handle))\n #endif  // !SANITIZER_FREEBSD\n@@ -81,7 +86,7 @@ namespace __sanitizer {\n #elif defined(__mips__)\n   const unsigned struct_kernel_stat_sz =\n                  SANITIZER_ANDROID ? FIRST_32_SECOND_64(104, 128) :\n-                                     FIRST_32_SECOND_64(144, 216);\n+                                     FIRST_32_SECOND_64(160, 216);\n   const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n   const unsigned struct_kernel_stat_sz = 64;\n@@ -204,24 +209,24 @@ namespace __sanitizer {\n     unsigned __seq;\n     u64 __unused1;\n     u64 __unused2;\n-#elif defined(__mips__) || defined(__aarch64__) || defined(__s390x__)\n-    unsigned int mode;\n-    unsigned short __seq;\n-    unsigned short __pad1;\n-    unsigned long __unused1;\n-    unsigned long __unused2;\n #elif defined(__sparc__)\n-# if defined(__arch64__)\n+#if defined(__arch64__)\n     unsigned mode;\n     unsigned short __pad1;\n-# else\n+#else\n     unsigned short __pad1;\n     unsigned short mode;\n     unsigned short __pad2;\n-# endif\n+#endif\n     unsigned short __seq;\n     unsigned long long __unused1;\n     unsigned long long __unused2;\n+#elif defined(__mips__) || defined(__aarch64__) || defined(__s390x__)\n+    unsigned int mode;\n+    unsigned short __seq;\n+    unsigned short __pad1;\n+    unsigned long __unused1;\n+    unsigned long __unused2;\n #else\n     unsigned short mode;\n     unsigned short __pad1;\n@@ -240,17 +245,17 @@ namespace __sanitizer {\n   struct __sanitizer_shmid_ds {\n     __sanitizer_ipc_perm shm_perm;\n   #if defined(__sparc__)\n-  # if !defined(__arch64__)\n+  #if !defined(__arch64__)\n     u32 __pad1;\n-  # endif\n+  #endif\n     long shm_atime;\n-  # if !defined(__arch64__)\n+  #if !defined(__arch64__)\n     u32 __pad2;\n-  # endif\n+  #endif\n     long shm_dtime;\n-  # if !defined(__arch64__)\n+  #if !defined(__arch64__)\n     u32 __pad3;\n-  # endif\n+  #endif\n     long shm_ctime;\n     uptr shm_segsz;\n     int shm_cpid;\n@@ -483,7 +488,12 @@ namespace __sanitizer {\n   };\n #elif SANITIZER_FREEBSD\n   struct __sanitizer_dirent {\n+#if defined(__INO64)\n+    unsigned long long d_fileno;\n+    unsigned long long d_off;\n+#else\n     unsigned int d_fileno;\n+#endif\n     unsigned short d_reclen;\n     // more fields that we don't care about\n   };\n@@ -863,6 +873,13 @@ namespace __sanitizer {\n   extern int shmctl_shm_stat;\n #endif\n \n+#if !SANITIZER_MAC && !SANITIZER_FREEBSD\n+  extern unsigned struct_utmp_sz;\n+#endif\n+#if !SANITIZER_ANDROID\n+  extern unsigned struct_utmpx_sz;\n+#endif\n+\n   extern int map_fixed;\n \n   // ioctl arguments\n@@ -908,7 +925,8 @@ struct __sanitizer_cookie_io_functions_t {\n \n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n-#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__) || defined(__sparc__)\n+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__) || \\\n+    defined(__sparc__)\n #define IOC_SIZEBITS 13\n #define IOC_DIRBITS 3\n #define IOC_NONE 1U\n@@ -943,9 +961,8 @@ struct __sanitizer_cookie_io_functions_t {\n // In sparc the 14 bits SIZE field overlaps with the\n // least significant bit of DIR, so either IOC_READ or\n // IOC_WRITE shall be 1 in order to get a non-zero SIZE.\n-# define IOC_SIZE(nr)                       \\\n-  ((((((nr) >> 29) & 0x7) & (4U|2U)) == 0)? \\\n-   0 : (((nr) >> 16) & 0x3fff))\n+#define IOC_SIZE(nr) \\\n+  ((((((nr) >> 29) & 0x7) & (4U | 2U)) == 0) ? 0 : (((nr) >> 16) & 0x3fff))\n #else\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n #endif\n@@ -1447,9 +1464,6 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned IOCTL_PIO_SCRNMAP;\n #endif\n \n-  extern const int errno_EINVAL;\n-  extern const int errno_EOWNERDEAD;\n-\n   extern const int si_SEGV_MAPERR;\n   extern const int si_SEGV_ACCERR;\n }  // namespace __sanitizer\n@@ -1471,4 +1485,6 @@ struct __sanitizer_cookie_io_functions_t {\n   COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n                  offsetof(struct CLASS, MEMBER))\n \n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC\n+\n #endif"}, {"sha": "8f59deb23b317b2a6ed1bbd3c050e3945dc871cf", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9626654e53aad6e802b23eaa3180fe971aaa1e35", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "1a37118c29936890ba4dbe07aa11ffc266af8f84", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "1456c765b2c3196b3f47db623ed55ba26c814c43", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "040f6940f17235c4b59789420e34b1407caf5187", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "36b97b1166ea58ddfd4abfcc22e71e111effcc0a", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cc", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "ba5d1449c0e44941547ef635dbd4ef0411222c24", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_freebsd.cc", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_freebsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_freebsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_freebsd.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "b97d5f62dd2ce28aff1762e760eac4b98f51ecfd", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc", "status": "modified", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "34f0c207b0964b9ddc2ae54ceb3147c75d624a5f", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc", "status": "modified", "additions": 250, "deletions": 54, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "a90c8e3bdb86f1896625c1c9b78e242e474bbedc", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 152, "deletions": 31, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c0edfcf7437509c64c6cf1cc4666731da49f8f52", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "b278f82ce03f309da994030b798326b153aa52f3", "filename": "libsanitizer/sanitizer_common/sanitizer_signal_interceptors.inc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "816a35cfb4683990adddee6c3429ce8dbcd6da6c", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "83309d6ee38542345410a59ea326aec2c82b84ab", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "31e99f6b9dbeba9e99bacfb4c91dd1a1d4a100e1", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "f4c0f31b2af9712175b962f8b75ed79c9aea9af3", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "3c5bed3d75a694dd1ca07d4d8669cf04d26b8c3a", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cc", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "cf3cd4292dd1bef7bd2a9718dcf66fb34b391e92", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "8c3d2c055571ec65c686b7bd72ca20cad85af084", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld.h", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "d746fa5403a0d12cafca71e864ffce82654697b2", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "6282694fa8ca92fbfec58c6057d5b41d05a482ce", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "4095a0942a327b949243af448b5f54e331e69dd5", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9d3e0115eb296ca15569c301efcf4b61c1098037", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "5e2c843d86efdb9a75822f46b36ecfbb1abafcd2", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "04263205e16c036d307155a5ebe5625a550184bb", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_fuchsia.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "eae7509576e8236944192d594f7aab2dfb3433f0", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "eebc30b124d94620e13718d72ec6889794898904", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "df934412146644ed6b63cdfbf12f90e7fd9fa8a4", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc", "status": "modified", "additions": 126, "deletions": 55, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "afd6bbe7fbfdc32a5de9e72b2182863e6317f51f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 81, "deletions": 44, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "06375fc2f4e24b8197c23f8d904223918b048088", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "7c9a2719eea5e019c97f830d5caf7b7bc85f7c84", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "d58c93983c5d444847b7e366291a845704dc6bef", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "16c2f86e1f9859cb759961ee62ff3565d1ffc31c", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "ebf5ec09444217f7b153a7856728794740452786", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "19c8472c481db893f5b38a66320937f757e5beda", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "7dba9e7ccd2b4ca03bd6b9983fe687ce9a573655", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "84e66b43c99046c4b4b259c0583e0d4007a2c67a", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 187, "deletions": 51, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c2d53a46fedaf5d0152409e7afeaa69ff1be1ff0", "filename": "libsanitizer/sanitizer_common/sanitizer_win.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e71081db575c92912f3a4a964138a2416f494d7e", "filename": "libsanitizer/sanitizer_common/sanitizer_win_defs.h", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "6577a3606d116c587ce12451a5f46d3cf9ee2e63", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dll_thunk.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "5a475e0798e90addfa4ccfa74de7af94aa6b99c4", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dll_thunk.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "f3b3037b276c7c112ee4948bce6009ccfff04d0c", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dynamic_runtime_thunk.cc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dynamic_runtime_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "dffec0c79438fbbb78e3d5c39392fa9dc7b5f1e0", "filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "873f9b822ab75477c19fa9677aec64aa52f8f098", "filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c218983e2fe2d86ae7904991f83fb3a7798fbef3", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e32e9c0bfa103994eb5f9889910a7b03055984e3", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c2b5b582ca37ec4a015822d648ae910fa0f548cc", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 336, "deletions": 165, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c8eb8ee2d1a7678d30242f7aa2abfe1f68e58c45", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "modified", "additions": 155, "deletions": 58, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9a9c67fc42ed01c124c1a37dbad9875afec4ca44", "filename": "libsanitizer/tsan/tsan_debugging.cc", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_debugging.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "2c7eda69f927bb3aceed660631728d3e81a98d8c", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "197b96fdeedb2d44623ed12b1ce38c4c751868b9", "filename": "libsanitizer/tsan/tsan_dense_alloc.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "3dddc3a4f64480a2e84f9716113003d9d0e096c5", "filename": "libsanitizer/tsan/tsan_external.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_external.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_external.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_external.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "effa35ddeb5af1cf6e03f417b298f24f9e02348c", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "4217691658e6998acf769ad63cf03745c4d75baf", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "35b0efc1c6b57d6ef5a709f6f1d5b29b498909a9", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e9873f16ce4aa78f3439ec233a4fc64e66f94bb5", "filename": "libsanitizer/tsan/tsan_flags.inc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "15f20d4b668a65134561e48e779c99d9f5d048fb", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 120, "deletions": 115, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "de47466501da7097b6052f9331d2eb6e6b8fff54", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "913e9ed0e14e710b97743f8e791f7297e5a87f0c", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cc", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "d98ff15f56258cf4d99bc770be17e10a7d78eb38", "filename": "libsanitizer/tsan/tsan_interface.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "7dc676552762a09e3f86f272d712bd355e76bcf7", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "083138fc046fff6e3e59c26184deb32bb9283dc0", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 102, "deletions": 10, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c175d614764600070ae10c4af1116f7db48619aa", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "bf70cdce34ba5817013e5d8c7de453a59c2f31cd", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "d3f35a9bc82306342bdd4f46da628fc1aa1bbf3d", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "2dd49f05c682a4d651ae3a47c182a01ed284f885", "filename": "libsanitizer/tsan/tsan_interface_java.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "5200a791fc2f2a2c19ff2570870dfba9c2719bb2", "filename": "libsanitizer/tsan/tsan_libdispatch_mac.cc", "status": "modified", "additions": 66, "deletions": 22, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "b418a211b58aaa743330cd02fa38baa7b06d17fb", "filename": "libsanitizer/tsan/tsan_malloc_mac.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "18505aca70e429556f605da96f3bd9fcf870b99c", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 81, "deletions": 21, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "3443cb0d8f96e6e260396dbc6a500d51c062f02f", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "65ae61b816407dd5d9825ee5a53e5a6e154e182e", "filename": "libsanitizer/tsan/tsan_new_delete.cc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_new_delete.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "ddf4b13d05adddfbf6bfe8153c9d13fa511ce140", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "f8ae256747863c32284f927f27b4d1ddaeb8b78c", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "8eb22fa58ea05d7e1442b1ef49cabdd4b1aea7f7", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 115, "deletions": 10, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "6e62575f1ec59261ae94b2bb5d3eb9351f49c135", "filename": "libsanitizer/tsan/tsan_platform_posix.cc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "76883caabf1db26f3ded922f5ca752cceb57928c", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "f8cb3e73ca403c514185db2fe3c0f175a664f429", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "6eb043fc86667c65e77e969a9e5e31c688069e7d", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "4a1f50061a6d4ad32eac5000a3e732cd74df901f", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "7dd9779e42bba85dfd979215823d8c07f0c334d3", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "61171d635c18a6c8a71e05f463cdd22591a27cab", "filename": "libsanitizer/tsan/tsan_rtl_aarch64.S", "status": "modified", "additions": 103, "deletions": 24, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "98947fd2a1baa372b1af7c6b22f7c2df50ea4451", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "d10a87374ba2a0cf16eabf3fca30b7cbbe131f9f", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 86, "deletions": 46, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "a961139b61d91905dfc844c866c6c170d880df17", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e81669d3b770670be61e0e5211d20dd9f5ad8625", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "decb7a20b842d8494fb0fbc76e3f9071a70f8540", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c4859df52b09d76c3288f723c4043c0a6736e93a", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e40eb70ceec5877bf4278282c01a13a9b5fe9c60", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "0f840de1f11bd8566cfabec1cb58e587f0d82797", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "195279fc1f24fd5780dd40ce1e100b0130944fb4", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "5cc3f8f349863098e2c9cab131c1d4c13837402e", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "cce728ceecae18de68e972618de86af5dfb52d5e", "filename": "libsanitizer/ubsan/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.am?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9552ec1425de8a0affeb5b4b5eaa05be0b0fe0a3", "filename": "libsanitizer/ubsan/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.in?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "4b49476513088c41822e9ef430ce957716285816", "filename": "libsanitizer/ubsan/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Flibtool-version?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c4459245f3efc62b3b263959ee1f92dd2a4c0def", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "978d966f1c32a12caccf54119adc94cfcfc74a91", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e9e5ab67e3e93f2cc915024f2dbedfa94e1bfe53", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "ddc1be7018c451fefc87d47986e53a5fbae8a739", "filename": "libsanitizer/ubsan/ubsan_diag_standalone.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_diag_standalone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_diag_standalone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag_standalone.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9a3ea4b51e5489784df98381c8783e2448b5d4f3", "filename": "libsanitizer/ubsan/ubsan_flags.cc", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "4d29832ae0dd1bfec482356558e8289be6d99a60", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 120, "deletions": 46, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "c5e499cd68e44a74e27a9752dfdd709ac89f83f3", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "bf729db6ce0b197ceb3f7d5a19ef8c4fcff7cc2d", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cc", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "37382359b1e50ecf2c36ebe9ed20d390046899e1", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9ae17f59ea11dda26b714ebdeda6cce3a67f39bc", "filename": "libsanitizer/ubsan/ubsan_init.cc", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "73bd3f3580fb068474555138da97d228170b6b94", "filename": "libsanitizer/ubsan/ubsan_init.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "67223bea629528db9cbbcb7480a2e1a9b3bd2d11", "filename": "libsanitizer/ubsan/ubsan_init_standalone.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init_standalone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init_standalone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init_standalone.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "80b2f3c3fd4f16881101eb7a1d2a07689f318b77", "filename": "libsanitizer/ubsan/ubsan_init_standalone_preinit.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init_standalone_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_init_standalone_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init_standalone_preinit.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "1b0bc425da7641477a837acf2db3ac5ce1c71f13", "filename": "libsanitizer/ubsan/ubsan_interface.inc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_interface.inc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "e73df63230282e877938510d9fe476e71d498aab", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "eb9b99ce9ac0a4391fbd8cc78a9b8af068a4d456", "filename": "libsanitizer/ubsan/ubsan_signals_standalone.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "65e64f205ca32b7c01b565eee4d4c4fa388d9670", "filename": "libsanitizer/ubsan/ubsan_signals_standalone.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_signals_standalone.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_signals_standalone.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_signals_standalone.h?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "9df316e14be9b21316327b00e99faaafe8b2b66f", "filename": "libsanitizer/ubsan/ubsan_type_hash_itanium.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "1091ac0351a9ad9f357d01d2de85f87f5a051835", "filename": "libsanitizer/ubsan/ubsan_win_dll_thunk.cc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_win_dll_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "6ab5ae388a308ccc81302c9fa2127943694a2b86", "filename": "libsanitizer/ubsan/ubsan_win_dynamic_runtime_thunk.cc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_win_dynamic_runtime_thunk.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}, {"sha": "98c8c27b2fab2acf58e34a4d8cfc39bf819ffccc", "filename": "libsanitizer/ubsan/ubsan_win_weak_interception.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_win_weak_interception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d3805fca3e9a199fbaa18aee3c05ecb30ebca61/libsanitizer%2Fubsan%2Fubsan_win_weak_interception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_win_weak_interception.cc?ref=5d3805fca3e9a199fbaa18aee3c05ecb30ebca61"}]}