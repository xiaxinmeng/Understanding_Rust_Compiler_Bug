{"sha": "526e1639aa76b0a8496b0dc3a3ff2c450229544e", "node_id": "C_kwDOANBUbNoAKDUyNmUxNjM5YWE3NmIwYTg0OTZiMGRjM2EzZmYyYzQ1MDIyOTU0NGU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:00Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:00Z"}, "message": "aarch64: Detect more consecutive MEMs\n\nFor tests like:\n\n    int res[2];\n    void\n    f1 (int x, int y)\n    {\n      res[0] = res[1] = x + y;\n    }\n\nwe generated:\n\n        add     w0, w0, w1\n        adrp    x1, .LANCHOR0\n        add     x2, x1, :lo12:.LANCHOR0\n        str     w0, [x1, #:lo12:.LANCHOR0]\n        str     w0, [x2, 4]\n        ret\n\nUsing [x1, #:lo12:.LANCHOR0] for the first store prevented the\ntwo stores being recognised as a pair.  However, the MEM_EXPR\nand MEM_OFFSET information tell us that the MEMs really are\nconsecutive.  The peehole2 context then guarantees that the\nfirst address is equivalent to [x2, 0].\n\nWhile there: the reg_mentioned_p tests for loads were probably correct,\nbut seemed a bit indirect.  We're matching two consecutive loads,\nso the thing we need to test is that the second MEM in the original\nsequence doesn't depend on the result of the first load in the\noriginal sequence.\n\ngcc/\n\t* config/aarch64/aarch64.c: Include tree-dfa.h.\n\t(aarch64_check_consecutive_mems): New function that takes MEM_EXPR\n\tand MEM_OFFSET into account.\n\t(aarch64_swap_ldrstr_operands): Use it.\n\t(aarch64_operands_ok_for_ldpstp): Likewise.  Check that the\n\taddress of the second memory doesn't depend on the result of\n\tthe first load.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/stp_1.c: New test.", "tree": {"sha": "4fa1b1080f18d1e86749a97a8dfde1b9617d1bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fa1b1080f18d1e86749a97a8dfde1b9617d1bcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/526e1639aa76b0a8496b0dc3a3ff2c450229544e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526e1639aa76b0a8496b0dc3a3ff2c450229544e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/526e1639aa76b0a8496b0dc3a3ff2c450229544e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526e1639aa76b0a8496b0dc3a3ff2c450229544e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c6cac9caea1dc7c5f50ad3a736f6693e74a11b"}], "stats": {"total": 185, "additions": 133, "deletions": 52}, "files": [{"sha": "850288d0e01b5f313364818b7e892d5564b41df1", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 104, "deletions": 52, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526e1639aa76b0a8496b0dc3a3ff2c450229544e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526e1639aa76b0a8496b0dc3a3ff2c450229544e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=526e1639aa76b0a8496b0dc3a3ff2c450229544e", "patch": "@@ -79,6 +79,7 @@\n #include \"tree-ssa-loop-niter.h\"\n #include \"fractional-cost.h\"\n #include \"rtlanal.h\"\n+#include \"tree-dfa.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -24569,6 +24570,97 @@ aarch64_sched_adjust_priority (rtx_insn *insn, int priority)\n   return priority;\n }\n \n+/* Check if *MEM1 and *MEM2 are consecutive memory references and,\n+   if they are, try to make them use constant offsets from the same base\n+   register.  Return true on success.  When returning true, set *REVERSED\n+   to true if *MEM1 comes after *MEM2, false if *MEM1 comes before *MEM2.  */\n+static bool\n+aarch64_check_consecutive_mems (rtx *mem1, rtx *mem2, bool *reversed)\n+{\n+  *reversed = false;\n+  if (GET_RTX_CLASS (GET_CODE (XEXP (*mem1, 0))) == RTX_AUTOINC\n+      || GET_RTX_CLASS (GET_CODE (XEXP (*mem2, 0))) == RTX_AUTOINC)\n+    return false;\n+\n+  if (!MEM_SIZE_KNOWN_P (*mem1) || !MEM_SIZE_KNOWN_P (*mem2))\n+    return false;\n+\n+  auto size1 = MEM_SIZE (*mem1);\n+  auto size2 = MEM_SIZE (*mem2);\n+\n+  rtx base1, base2, offset1, offset2;\n+  extract_base_offset_in_addr (*mem1, &base1, &offset1);\n+  extract_base_offset_in_addr (*mem2, &base2, &offset2);\n+\n+  /* Make sure at least one memory is in base+offset form.  */\n+  if (!(base1 && offset1) && !(base2 && offset2))\n+    return false;\n+\n+  /* If both mems already use the same base register, just check the\n+     offsets.  */\n+  if (base1 && base2 && rtx_equal_p (base1, base2))\n+    {\n+      if (!offset1 || !offset2)\n+\treturn false;\n+\n+      if (known_eq (UINTVAL (offset1) + size1, UINTVAL (offset2)))\n+\treturn true;\n+\n+      if (known_eq (UINTVAL (offset2) + size2, UINTVAL (offset1)))\n+\t{\n+\t  *reversed = true;\n+\t  return true;\n+\t}\n+\n+      return false;\n+    }\n+\n+  /* Otherwise, check whether the MEM_EXPRs and MEM_OFFSETs together\n+     guarantee that the values are consecutive.  */\n+  if (MEM_EXPR (*mem1)\n+      && MEM_EXPR (*mem2)\n+      && MEM_OFFSET_KNOWN_P (*mem1)\n+      && MEM_OFFSET_KNOWN_P (*mem2))\n+    {\n+      poly_int64 expr_offset1;\n+      poly_int64 expr_offset2;\n+      tree expr_base1 = get_addr_base_and_unit_offset (MEM_EXPR (*mem1),\n+\t\t\t\t\t\t       &expr_offset1);\n+      tree expr_base2 = get_addr_base_and_unit_offset (MEM_EXPR (*mem2),\n+\t\t\t\t\t\t       &expr_offset2);\n+      if (!expr_base1\n+\t  || !expr_base2\n+\t  || !operand_equal_p (expr_base1, expr_base2, OEP_ADDRESS_OF))\n+\treturn false;\n+\n+      expr_offset1 += MEM_OFFSET (*mem1);\n+      expr_offset2 += MEM_OFFSET (*mem2);\n+\n+      if (known_eq (expr_offset1 + size1, expr_offset2))\n+\t;\n+      else if (known_eq (expr_offset2 + size2, expr_offset1))\n+\t*reversed = true;\n+      else\n+\treturn false;\n+\n+      if (base2)\n+\t{\n+\t  rtx addr1 = plus_constant (Pmode, XEXP (*mem2, 0),\n+\t\t\t\t     expr_offset1 - expr_offset2);\n+\t  *mem1 = replace_equiv_address_nv (*mem1, addr1);\n+\t}\n+      else\n+\t{\n+\t  rtx addr2 = plus_constant (Pmode, XEXP (*mem1, 0),\n+\t\t\t\t     expr_offset2 - expr_offset1);\n+\t  *mem2 = replace_equiv_address_nv (*mem2, addr2);\n+\t}\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Given OPERANDS of consecutive load/store, check if we can merge\n    them into ldp/stp.  LOAD is true if they are load instructions.\n    MODE is the mode of memory operands.  */\n@@ -24577,9 +24669,8 @@ bool\n aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n \t\t\t\tmachine_mode mode)\n {\n-  HOST_WIDE_INT offval_1, offval_2, msize;\n   enum reg_class rclass_1, rclass_2;\n-  rtx mem_1, mem_2, reg_1, reg_2, base_1, base_2, offset_1, offset_2;\n+  rtx mem_1, mem_2, reg_1, reg_2;\n \n   if (load)\n     {\n@@ -24590,6 +24681,8 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n       gcc_assert (REG_P (reg_1) && REG_P (reg_2));\n       if (REGNO (reg_1) == REGNO (reg_2))\n \treturn false;\n+      if (reg_overlap_mentioned_p (reg_1, mem_2))\n+\treturn false;\n     }\n   else\n     {\n@@ -24613,40 +24706,13 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n     return false;\n \n   /* Check if the addresses are in the form of [base+offset].  */\n-  extract_base_offset_in_addr (mem_1, &base_1, &offset_1);\n-  if (base_1 == NULL_RTX || offset_1 == NULL_RTX)\n-    return false;\n-  extract_base_offset_in_addr (mem_2, &base_2, &offset_2);\n-  if (base_2 == NULL_RTX || offset_2 == NULL_RTX)\n-    return false;\n-\n-  /* Check if the bases are same.  */\n-  if (!rtx_equal_p (base_1, base_2))\n+  bool reversed = false;\n+  if (!aarch64_check_consecutive_mems (&mem_1, &mem_2, &reversed))\n     return false;\n \n   /* The operands must be of the same size.  */\n   gcc_assert (known_eq (GET_MODE_SIZE (GET_MODE (mem_1)),\n-\t\t\t GET_MODE_SIZE (GET_MODE (mem_2))));\n-\n-  offval_1 = INTVAL (offset_1);\n-  offval_2 = INTVAL (offset_2);\n-  /* We should only be trying this for fixed-sized modes.  There is no\n-     SVE LDP/STP instruction.  */\n-  msize = GET_MODE_SIZE (mode).to_constant ();\n-  /* Check if the offsets are consecutive.  */\n-  if (offval_1 != (offval_2 + msize) && offval_2 != (offval_1 + msize))\n-    return false;\n-\n-  /* Check if the addresses are clobbered by load.  */\n-  if (load)\n-    {\n-      if (reg_mentioned_p (reg_1, mem_1))\n-\treturn false;\n-\n-      /* In increasing order, the last load can clobber the address.  */\n-      if (offval_1 > offval_2 && reg_mentioned_p (reg_2, mem_2))\n-\treturn false;\n-    }\n+\t\t\tGET_MODE_SIZE (GET_MODE (mem_2))));\n \n   /* One of the memory accesses must be a mempair operand.\n      If it is not the first one, they need to be swapped by the\n@@ -24677,27 +24743,13 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n void\n aarch64_swap_ldrstr_operands (rtx* operands, bool load)\n {\n-  rtx mem_1, mem_2, base_1, base_2, offset_1, offset_2;\n-  HOST_WIDE_INT offval_1, offval_2;\n-\n-  if (load)\n-    {\n-      mem_1 = operands[1];\n-      mem_2 = operands[3];\n-    }\n-  else\n-    {\n-      mem_1 = operands[0];\n-      mem_2 = operands[2];\n-    }\n-\n-  extract_base_offset_in_addr (mem_1, &base_1, &offset_1);\n-  extract_base_offset_in_addr (mem_2, &base_2, &offset_2);\n-\n-  offval_1 = INTVAL (offset_1);\n-  offval_2 = INTVAL (offset_2);\n+  int mem_op = load ? 1 : 0;\n+  bool reversed = false;\n+  if (!aarch64_check_consecutive_mems (operands + mem_op,\n+\t\t\t\t       operands + mem_op + 2, &reversed))\n+    gcc_unreachable ();\n \n-  if (offval_1 > offval_2)\n+  if (reversed)\n     {\n       /* Irrespective of whether this is a load or a store,\n \t we do the same swap.  */"}, {"sha": "c1a5e6b776da494b2f405f901a7781e87a806d25", "filename": "gcc/testsuite/gcc.target/aarch64/stp_1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526e1639aa76b0a8496b0dc3a3ff2c450229544e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstp_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526e1639aa76b0a8496b0dc3a3ff2c450229544e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstp_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstp_1.c?ref=526e1639aa76b0a8496b0dc3a3ff2c450229544e", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-options \"-O -fpeephole2\" } */\n+\n+int res[2];\n+\n+void\n+f1 (int x, int y)\n+{\n+  res[0] = res[1] = x + y;\n+}\n+\n+void\n+f2 (int x, int y, int *res)\n+{\n+  res[0] = res[1] = x + y;\n+}\n+\n+void\n+f3 (int x, int y)\n+{\n+  res[1] = res[0] = x + y;\n+}\n+\n+void\n+f4 (int x, int y, int *res)\n+{\n+  res[1] = res[0] = x + y;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tstp\\t} 4 } } */"}]}