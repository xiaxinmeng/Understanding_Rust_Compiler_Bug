{"sha": "72013ec51a97b6a709ac96845a247119e4602254", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIwMTNlYzUxYTk3YjZhNzA5YWM5Njg0NWEyNDcxMTllNDYwMjI1NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-12-20T18:38:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-12-20T18:38:37Z"}, "message": "re PR c++/67411 (internal compiler error: in tsubst_copy, at cp/pt.c:13473)\n\n\tPR c++/67411\n\n\t* lambda.c (generic_lambda_fn_p): Split out from...\n\t(maybe_add_lambda_conv_op): ...here.\n\t* semantics.c (process_outer_var_ref): Don't defer maybe-constant\n\tvariables in a generic lambda.\n\t* pt.c (instantiate_non_dependent_or_null): New.\n\t* init.c (constant_value_1): Use it.\n\t* cp-tree.h: Declare it and generic_lambda_fn_p.\n\nFrom-SVN: r231863", "tree": {"sha": "59fd6f52890fff5dd866d968ff4681528d076072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59fd6f52890fff5dd866d968ff4681528d076072"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72013ec51a97b6a709ac96845a247119e4602254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72013ec51a97b6a709ac96845a247119e4602254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72013ec51a97b6a709ac96845a247119e4602254", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72013ec51a97b6a709ac96845a247119e4602254/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6b990219342543d804a269a5409091a93e6d2ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b990219342543d804a269a5409091a93e6d2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6b990219342543d804a269a5409091a93e6d2ea"}], "stats": {"total": 122, "additions": 98, "deletions": 24}, "files": [{"sha": "e7adad382282b12d6752bef32d03e677b1371529", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -1,5 +1,14 @@\n 2015-12-20  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/67411\n+\t* lambda.c (generic_lambda_fn_p): Split out from...\n+\t(maybe_add_lambda_conv_op): ...here.\n+\t* semantics.c (process_outer_var_ref): Don't defer maybe-constant\n+\tvariables in a generic lambda.\n+\t* pt.c (instantiate_non_dependent_or_null): New.\n+\t* init.c (constant_value_1): Use it.\n+\t* cp-tree.h: Declare it and generic_lambda_fn_p.\n+\n \tPR c++/67411\n \t* decl2.c (decl_maybe_constant_var_p): A proxy isn't constant.\n "}, {"sha": "f0f7e36cbb4d905a15e6f0a7c35ad24c3df32967", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -6158,6 +6158,7 @@ extern bool reregister_specialization\t\t(tree, tree, tree);\n extern tree instantiate_non_dependent_expr\t(tree);\n extern tree instantiate_non_dependent_expr_sfinae (tree, tsubst_flags_t);\n extern tree instantiate_non_dependent_expr_internal (tree, tsubst_flags_t);\n+extern tree instantiate_non_dependent_or_null   (tree);\n extern bool variable_template_specialization_p  (tree);\n extern bool alias_type_or_template_p            (tree);\n extern bool alias_template_specialization_p     (const_tree);\n@@ -6473,6 +6474,7 @@ extern tree maybe_resolve_dummy\t\t\t(tree, bool);\n extern tree current_nonlambda_function\t\t(void);\n extern tree nonlambda_method_basetype\t\t(void);\n extern tree current_nonlambda_scope\t\t(void);\n+extern bool generic_lambda_fn_p\t\t\t(tree);\n extern void maybe_add_lambda_conv_op            (tree);\n extern bool is_lambda_ignored_entity            (tree);\n "}, {"sha": "09c1183157dd77fbe515357ce47e45543c20d80d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -2080,6 +2080,8 @@ constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p)\n \t  && TREE_CODE (init) == TREE_LIST\n \t  && TREE_CHAIN (init) == NULL_TREE)\n \tinit = TREE_VALUE (init);\n+      /* Instantiate a non-dependent initializer.  */\n+      init = instantiate_non_dependent_or_null (init);\n       if (!init\n \t  || !TREE_TYPE (init)\n \t  || !TREE_CONSTANT (init)"}, {"sha": "d50e48d71c378849a888548601dddd23e231047a", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -851,6 +851,16 @@ prepare_op_call (tree fn, int nargs)\n   return t;\n }\n \n+/* Return true iff CALLOP is the op() for a generic lambda.  */\n+\n+bool\n+generic_lambda_fn_p (tree callop)\n+{\n+  return (LAMBDA_FUNCTION_P (callop)\n+\t  && DECL_TEMPLATE_INFO (callop)\n+\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (callop)));\n+}\n+\n /* If the closure TYPE has a static op(), also add a conversion to function\n    pointer.  */\n \n@@ -867,9 +877,7 @@ maybe_add_lambda_conv_op (tree type)\n   if (processing_template_decl)\n     return;\n \n-  bool const generic_lambda_p\n-    = (DECL_TEMPLATE_INFO (callop)\n-    && DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (callop)) == callop);\n+  bool const generic_lambda_p = generic_lambda_fn_p (callop);\n \n   if (!generic_lambda_p && DECL_INITIAL (callop) == NULL_TREE)\n     {"}, {"sha": "209e65f23b6ccd99fbd0a50014910898bd295f9a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -5661,6 +5661,28 @@ instantiate_non_dependent_expr (tree expr)\n   return instantiate_non_dependent_expr_sfinae (expr, tf_error);\n }\n \n+/* Like instantiate_non_dependent_expr, but return NULL_TREE rather than\n+   an uninstantiated expression.  */\n+\n+tree\n+instantiate_non_dependent_or_null (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return NULL_TREE;\n+  if (processing_template_decl)\n+    {\n+      if (instantiation_dependent_expression_p (expr)\n+\t  || !potential_constant_expression (expr))\n+\texpr = NULL_TREE;\n+      else\n+\t{\n+\t  processing_template_decl_sentinel s;\n+\t  expr = instantiate_non_dependent_expr_internal (expr, tf_error);\n+\t}\n+    }\n+  return expr;\n+}\n+\n /* True iff T is a specialization of a variable template.  */\n \n bool"}, {"sha": "ab9989a5a122b907a3fda7218c6dc8dd7d06adeb", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -3231,27 +3231,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n   if (!mark_used (decl, complain) && !(complain & tf_error))\n     return error_mark_node;\n \n-  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n-     support for an approach in which a reference to a local\n-     [constant] automatic variable in a nested class or lambda body\n-     would enter the expression as an rvalue, which would reduce\n-     the complexity of the problem\"\n-\n-     FIXME update for final resolution of core issue 696.  */\n-  if (decl_maybe_constant_var_p (decl))\n-    {\n-      if (processing_template_decl)\n-\t/* In a template, the constant value may not be in a usable\n-\t   form, so wait until instantiation time.  */\n-\treturn decl;\n-      else if (decl_constant_var_p (decl))\n-\t{\n-\t  tree t = maybe_constant_value (convert_from_reference (decl));\n-\t  if (TREE_CONSTANT (t))\n-\t    return t;\n-\t}\n-    }\n-\n+  bool saw_generic_lambda = false;\n   if (parsing_nsdmi ())\n     containing_function = NULL_TREE;\n   else\n@@ -3265,6 +3245,9 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n \ttree closure = DECL_CONTEXT (containing_function);\n \tlambda_expr = CLASSTYPE_LAMBDA_EXPR (closure);\n \n+\tif (generic_lambda_fn_p (containing_function))\n+\t  saw_generic_lambda = true;\n+\n \tif (TYPE_CLASS_SCOPE_P (closure))\n \t  /* A lambda in an NSDMI (c++/64496).  */\n \t  break;\n@@ -3281,6 +3264,35 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n \t  = decl_function_context (containing_function);\n       }\n \n+  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n+     support for an approach in which a reference to a local\n+     [constant] automatic variable in a nested class or lambda body\n+     would enter the expression as an rvalue, which would reduce\n+     the complexity of the problem\"\n+\n+     FIXME update for final resolution of core issue 696.  */\n+  if (decl_maybe_constant_var_p (decl))\n+    {\n+      if (processing_template_decl && !saw_generic_lambda)\n+\t/* In a non-generic lambda within a template, wait until instantiation\n+\t   time to decide whether to capture.  For a generic lambda, we can't\n+\t   wait until we instantiate the op() because the closure class is\n+\t   already defined at that point.  FIXME to get the semantics exactly\n+\t   right we need to partially-instantiate the lambda body so the only\n+\t   dependencies left are on the generic parameters themselves.  This\n+\t   probably means moving away from our current model of lambdas in\n+\t   templates (instantiating the closure type) to one based on creating\n+\t   the closure type when instantiating the lambda context.  That is\n+\t   probably also the way to handle lambdas within pack expansions.  */\n+\treturn decl;\n+      else if (decl_constant_var_p (decl))\n+\t{\n+\t  tree t = maybe_constant_value (convert_from_reference (decl));\n+\t  if (TREE_CONSTANT (t))\n+\t    return t;\n+\t}\n+    }\n+\n   if (lambda_expr && VAR_P (decl)\n       && DECL_ANON_UNION_VAR_P (decl))\n     {"}, {"sha": "9a00e22eef990d70706a6e826b05a00a5adced98", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-const2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-const2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72013ec51a97b6a709ac96845a247119e4602254/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-const2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-const2.C?ref=72013ec51a97b6a709ac96845a247119e4602254", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/67411\n+// { dg-do compile { target c++14 } }\n+\n+template <class T>\n+void f()\n+{\n+  int i = 42;\n+  [=] {\n+    const int x = i;\n+    [&](auto) {\n+      [=] { return x; }();\n+    }(1);\n+  }();\n+}\n+\n+int main()\n+{\n+  f<int>();\n+}"}]}