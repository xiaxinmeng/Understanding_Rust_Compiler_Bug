{"sha": "eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVmZTlhOTk1Y2VlYzdmYzVjYTc5NTA1ZTk2YmRhMjE0ZTZiZDgyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-19T10:14:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-19T10:14:06Z"}, "message": "Makeifle-in (ipa-devirt.o): New.\n\n\n\t* Makeifle-in (ipa-devirt.o): New.\n\t(GTFILES): Add ipa-utils.h and ipa-devirt.c\n\t* cgraphunit.c (decide_is_symbol_needed): Do not care about virtuals.\n\t(analyze_functions): Look into possible targets of polymorphic call.\n\t* dumpfile.c (dump_files): Add type-inheritance dump.\n\t* dumpfile.h (TDI_inheritance): New.\n\t* ipa-devirt.c: New file.\n\t* ipa-utils.h (odr_type_d): Forward declare.\n\t(odr_type): New type.\n\t(build_type_inheritance_graph): Declare.\n\t(possible_polymorphic_call_targets): Declare and introduce inline\n\tvariant when only edge is pased.\n\t(dump_possible_polymorphic_call_targets): Likewise.\n\t* timevar.def (TV_IPA_INHERITANCE, TV_IPA_VIRTUAL_CALL): New.\n\t* tree.c (type_in_anonymous_namespace_p): Break out from ...\n\t(types_same_for_odr): ... here.\n\t* tree.h (type_in_anonymous_namespace_p): Declare.\n\n\t* g++.dg/ipa/type-inheritance-1.C: New testcase.\n\nFrom-SVN: r201836", "tree": {"sha": "6500dfce0eb1776cd3cf03771e785f6de3bc1607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6500dfce0eb1776cd3cf03771e785f6de3bc1607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/comments", "author": null, "committer": null, "parents": [{"sha": "5eb5ec2f3034a1c62262914b090f64a5d5f0bc86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eb5ec2f3034a1c62262914b090f64a5d5f0bc86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eb5ec2f3034a1c62262914b090f64a5d5f0bc86"}], "stats": {"total": 834, "additions": 818, "deletions": 16}, "files": [{"sha": "38216dcbc2834d458ce9e4b4d689cfe6da939c53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -1,3 +1,23 @@\n+2013-08-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makeifle-in (ipa-devirt.o): New.\n+\t(GTFILES): Add ipa-utils.h and ipa-devirt.c\n+\t* cgraphunit.c (decide_is_symbol_needed): Do not care about virtuals.\n+\t(analyze_functions): Look into possible targets of polymorphic call.\n+\t* dumpfile.c (dump_files): Add type-inheritance dump.\n+\t* dumpfile.h (TDI_inheritance): New.\n+\t* ipa-devirt.c: New file.\n+\t* ipa-utils.h (odr_type_d): Forward declare.\n+\t(odr_type): New type.\n+\t(build_type_inheritance_graph): Declare.\n+\t(possible_polymorphic_call_targets): Declare and introduce inline\n+\tvariant when only edge is pased.\n+\t(dump_possible_polymorphic_call_targets): Likewise.\n+\t* timevar.def (TV_IPA_INHERITANCE, TV_IPA_VIRTUAL_CALL): New.\n+\t* tree.c (type_in_anonymous_namespace_p): Break out from ...\n+\t(types_same_for_odr): ... here.\n+\t* tree.h (type_in_anonymous_namespace_p): Declare.\n+\n 2013-08-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/58006"}, {"sha": "6034046374a96e66b89d772d724fb400d304d2be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -1275,6 +1275,7 @@ OBJS = \\\n \tinit-regs.o \\\n \tinternal-fn.o \\\n \tipa-cp.o \\\n+\tipa-devirt.o \\\n \tipa-split.o \\\n \tipa-inline.o \\\n \tipa-inline-analysis.o \\\n@@ -2945,6 +2946,9 @@ ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \\\n    $(IPA_UTILS_H) tree-inline.h $(HASH_TABLE_H) profile.h $(PARAMS_H) \\\n    $(LTO_STREAMER_H) $(DATA_STREAMER_H)\n+ipa-devirt.o : ipa-devirt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n+   $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \\\n+   $(IPA_UTILS_H) $(HASH_TABLE_H) \n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\\n@@ -3784,7 +3788,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n-  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c \\\n+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-utils.h \\\n   $(srcdir)/dbxout.c \\\n   $(srcdir)/dwarf2out.h \\\n   $(srcdir)/dwarf2asm.c \\\n@@ -3826,7 +3830,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/ipa-inline.h \\\n   $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\\n-  $(srcdir)/tsan.c \\\n+  $(srcdir)/tsan.c $(srcdir)/ipa-devirt.c \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "c6850c60c316481d9bd31c6ee439ce19ce29cd2f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -1292,10 +1292,13 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       struct ipa_ref *ref;\n \n       cgraph_speculative_call_info (e, e, e2, ref);\n-      if (gimple_call_fndecl (e->call_stmt))\n-\te = cgraph_resolve_speculation (e, gimple_call_fndecl (e->call_stmt));\n-      if (!gimple_check_call_matching_types (e->call_stmt, e->callee->symbol.decl,\n-\t\t\t\t\t     true))\n+      /* If there already is an direct call (i.e. as a result of inliner's substitution),\n+ \t forget about speculating.  */\n+      if (decl)\n+\te = cgraph_resolve_speculation (e, decl);\n+      /* If types do not match, speculation was likely wrong.  */\n+      else if (!gimple_check_call_matching_types (e->call_stmt, e->callee->symbol.decl,\n+\t\t\t\t\t\t  true))\n \t{\n \t  e = cgraph_resolve_speculation (e, NULL);\n \t  if (dump_file)\n@@ -1304,6 +1307,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t\t     xstrdup (cgraph_node_name (e->caller)), e->caller->symbol.order,\n \t\t     xstrdup (cgraph_node_name (e->callee)), e->callee->symbol.order);\n \t}\n+      /* Expand speculation into GIMPLE code.  */\n       else\n \t{\n \t  if (dump_file)"}, {"sha": "0aa68c75e8063131a94e2c02c31ecdb07874154c", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -235,10 +235,6 @@ decide_is_symbol_needed (symtab_node node)\n   if (!node->symbol.definition)\n     return false;\n \n-  /* Devirtualization may access these.  */\n-  if (DECL_VIRTUAL_P (decl) && optimize)\n-    return true;\n-\n   if (DECL_EXTERNAL (decl))\n     return false;\n \n@@ -838,6 +834,7 @@ analyze_functions (void)\n   struct cgraph_node *first_handled = first_analyzed;\n   static struct varpool_node *first_analyzed_var;\n   struct varpool_node *first_handled_var = first_analyzed_var;\n+  struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n \n   symtab_node node, next;\n   int i;\n@@ -853,6 +850,8 @@ analyze_functions (void)\n     FOR_EACH_SYMBOL (node)\n       if (node->symbol.cpp_implicit_alias)\n \t  fixup_same_cpp_alias_visibility (node, symtab_alias_target (node));\n+  if (optimize && flag_devirtualize)\n+    build_type_inheritance_graph ();\n \n   /* Analysis adds static variables that in turn adds references to new functions.\n      So we need to iterate the process until it stabilize.  */\n@@ -875,6 +874,8 @@ analyze_functions (void)\n \t      changed = true;\n \t      if (cgraph_dump_file)\n \t\tfprintf (cgraph_dump_file, \" %s\", symtab_node_asm_name (node));\n+\t      if (!changed && cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file, \"\\n\");\n \t    }\n \t  if (node == (symtab_node)first_analyzed\n \t      || node == (symtab_node)first_analyzed_var)\n@@ -919,6 +920,29 @@ analyze_functions (void)\n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t\tif (edge->callee->symbol.definition)\n \t\t   enqueue_node ((symtab_node)edge->callee);\n+\t      if (optimize && flag_devirtualize)\n+\t\t{\n+\t          for (edge = cnode->indirect_calls; edge; edge = edge->next_callee)\n+\t\t    if (edge->indirect_info->polymorphic)\n+\t\t      {\n+\t\t\tunsigned int i;\n+\t\t\tvoid *cache_token;\n+\t\t\tvec <cgraph_node *>targets\n+\t\t\t  = possible_polymorphic_call_targets\n+\t\t\t      (edge, NULL, &cache_token);\n+\n+\t\t\tif (!pointer_set_insert (reachable_call_targets,\n+\t\t\t\t\t\t cache_token))\n+\t\t\t  {\n+\t\t\t    if (cgraph_dump_file)\n+\t\t\t      dump_possible_polymorphic_call_targets \n+\t\t\t\t(cgraph_dump_file, edge);\n+\n+\t\t\t    for (i = 0; i < targets.length(); i++)\n+\t\t\t      enqueue_node ((symtab_node) targets[i]);\n+\t\t\t  }\n+\t\t      }\n+\t\t}\n \n \t      /* If decl is a clone of an abstract function,\n \t      mark that abstract function so that we don't release its body.\n@@ -999,6 +1023,7 @@ analyze_functions (void)\n       dump_symtab (cgraph_dump_file);\n     }\n   bitmap_obstack_release (NULL);\n+  pointer_set_destroy (reachable_call_targets);\n   ggc_collect ();\n }\n "}, {"sha": "9c97512e7999aa980a552c34852219623f474003", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -52,6 +52,8 @@ static struct dump_file_info dump_files[TDI_end] =\n   {NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0},\n   {\".cgraph\", \"ipa-cgraph\", NULL, NULL, NULL, NULL, NULL, TDF_IPA,\n    0, 0, 0, 0, 0},\n+  {\".type-inheritance\", \"ipa-type-inheritance\", NULL, NULL, NULL, NULL, NULL, TDF_IPA,\n+   0, 0, 0, 0, 0},\n   {\".tu\", \"translation-unit\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n    0, 0, 0, 0, 1},\n   {\".class\", \"class-hierarchy\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,"}, {"sha": "da079bad7483f574d89a12fb3d31b1e83f870bab", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -29,6 +29,7 @@ enum tree_dump_index\n {\n   TDI_none,\t\t\t/* No dump */\n   TDI_cgraph,                   /* dump function call graph.  */\n+  TDI_inheritance,              /* dump type inheritance graph.  */\n   TDI_tu,\t\t\t/* dump the whole translation unit.  */\n   TDI_class,\t\t\t/* dump class hierarchy.  */\n   TDI_original,\t\t\t/* dump each function before optimizing it */"}, {"sha": "834cfb01dbb7d68111546e82eb8c40bc5ab31403", "filename": "gcc/ipa-devirt.c", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -0,0 +1,666 @@\n+/* Basic IPA utilities for type inheritance graph construction and\n+   devirtualization.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Brief vocalburary:\n+     ODR = One Definition Rule\n+        In short, the ODR states that:\n+\t1 In any translation unit, a template, type, function, or object can\n+\t  have no more than one definition. Some of these can have any number\n+\t  of declarations. A definition provides an instance.\n+        2 In the entire program, an object or non-inline function cannot have\n+\t  more than one definition; if an object or function is used, it must\n+\t  have exactly one definition. You can declare an object or function\n+\t  that is never used, in which case you don't have to provide\n+\t  a definition. In no event can there be more than one definition.\n+        3 Some things, like types, templates, and extern inline functions, can\n+\t  be defined in more than one translation unit. For a given entity,\n+\t  each definition must be the same. Non-extern objects and functions\n+\t  in different translation units are different entities, even if their\n+\t  names and types are the same.\n+\n+     OTR = OBJ_TYPE_REF\n+       This is Gimple representation of type information of a polymorphic call.\n+       It contains two parameters:\n+\t otr_type is a type of class whose method is called.\n+\t otr_token is index into virtual table where address is taken.\n+\n+     BINFO\n+       This is the type inheritance information attached to each tree\n+       RECORD_TYPE by the C++ frotend.  It provides information about base\n+       types and virtual tables.\n+\n+       BINFO is linked to the RECORD_TYPE by TYPE_BINFO.\n+       BINFO also links to its type by BINFO_TYPE and to the virtual table by\n+       BINFO_VTABLE.\n+\n+       Base types of a given type are enumerated by BINFO_BASE_BINFO\n+       vector.  Members of this vectors are not BINFOs associated\n+       with a base type.  Rather they are new copies of BINFOs\n+       (base BINFOs). Their virtual tables may differ from\n+       virtual table of the base type.  Also BINFO_OFFSET specify\n+       offset of the base within the type.\n+\n+       In the case of single inheritance, the virtual table is shared\n+       and BINFO_VTABLE of base BINFO is NULL.  In the case of multiple\n+       inheritance the individual virtual tables are pointer to by\n+       BINFO_VTABLE of base binfos (that differs of BINFO_VTABLE of \n+       binfo associated to the base type).\n+\n+       BINFO lookup for a given base type and offset can be done by\n+       get_binfo_at_offset.  It returns proper BINFO whose virtual table\n+       can be used for lookup of virtual methods associated with the\n+       base type.\n+\n+     token\n+       This is an index of virtual method in virtual table associated\n+       to the type defining it. Token can be looked up from OBJ_TYPE_REF\n+       or from DECL_VINDEX of given virtual table.\n+\n+     polymorphic (indirect) call\n+       This is callgraph represention of virtual method call.  Every\n+       polymorphic call contains otr_type and otr_token taken from\n+       original OBJ_TYPE_REF at callgraph construction time.\n+\n+   What we do here:\n+\n+   build_type_inheritance_graph triggers a construction of the type inheritance\n+   graph.\n+\n+     We reconstruct it based on types of methods we see in the unit.\n+     This means that the graph is not complete. Types with no methods are not\n+     inserted to the graph.  Also types without virtual methods are not\n+     represented at all, though it may be easy to add this.\n+  \n+     The inheritance graph is represented as follows:\n+\n+       Vertices are structures odr_type.  Every odr_type may correspond\n+       to one or more tree type nodes that are equivalent by ODR rule.\n+       (the multiple type nodes appear only with linktime optimization)\n+\n+       Edges are repsented by odr_type->base and odr_type->derived_types.\n+       At the moment we do not track offsets of types for multiple inheritance.\n+       Adding this is easy.\n+\n+  possible_polymorphic_call_targets returns, given an parameters found in\n+  indirect polymorphic edge all possible polymorphic call targets of the call.\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pass.h\"\n+#include \"ggc.h\"\n+#include \"pointer-set.h\"\n+#include \"target.h\"\n+#include \"hash-table.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"ipa-utils.h\"\n+#include \"gimple.h\"\n+\n+/* The node of type inheritance graph.  For each type unique in\n+   One Defintion Rule (ODR) sense, we produce one node linking all \n+   main variants of types equivalent to it, bases and derived types.  */\n+\n+struct GTY(()) odr_type_d\n+{\n+  /* Unique ID indexing the type in odr_types array.  */\n+  int id;\n+  /* leader type.  */\n+  tree type;\n+  /* All bases.  */\n+  vec<odr_type> GTY((skip)) bases;\n+  /* All derrived types with virtual methods seen in unit.  */\n+  vec<odr_type> GTY((skip)) derived_types;\n+  /* Is it in anonymous namespace? */\n+  bool anonymous_namespace;\n+};\n+\n+\n+/* Return true if BINFO corresponds to a type with virtual methods.  */\n+\n+static inline bool\n+polymorphic_type_binfo_p (tree binfo)\n+{\n+  /* See if BINFO's type has an virtual table associtated with it.  */\n+  return BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo)));\n+}\n+\n+/* One Definition Rule hashtable helpers.  */\n+\n+struct odr_hasher \n+{\n+  typedef odr_type_d value_type;\n+  typedef union tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+/* Produce hash based on type name.  */\n+\n+hashval_t\n+hash_type_name (tree t)\n+{\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t) == t);\n+\n+  /* If not in LTO, all main variants are unique, so we can do\n+     pointer hash.  */\n+  if (!in_lto_p)\n+    return htab_hash_pointer (t);\n+\n+  /* Anonymous types are unique.  */\n+  if (type_in_anonymous_namespace_p (t))\n+    return htab_hash_pointer (t);\n+\n+  /* Rest is not implemented yet.  */\n+  gcc_unreachable ();\n+}\n+\n+/* Return the computed hashcode for ODR_TYPE.  */\n+\n+inline hashval_t\n+odr_hasher::hash (const value_type *odr_type)\n+{\n+  return hash_type_name (odr_type->type);\n+}\n+\n+/* Compare types operations T1 and T2 and return true if they are\n+   equivalent.  */\n+\n+inline bool\n+odr_hasher::equal (const value_type *t1, const compare_type *ct2)\n+{\n+  tree t2 = const_cast <tree> (ct2);\n+\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (ct2) == ct2);\n+  if (t1->type == t2)\n+    return true;\n+  if (!in_lto_p)\n+    return false;\n+  return types_same_for_odr (t1->type, t2);\n+}\n+\n+/* Free a phi operation structure VP.  */\n+\n+inline void\n+odr_hasher::remove (value_type *v)\n+{\n+  v->bases.release ();\n+  v->derived_types.release ();\n+  ggc_free (v);\n+}\n+\n+/* ODR type hash used to lookup ODR type based on tree type node.  */\n+\n+typedef hash_table <odr_hasher> odr_hash_type;\n+static odr_hash_type odr_hash;\n+\n+/* ODR types are also stored into ODR_TYPE vector to allow consistent\n+   walking.  Bases appear before derived types.  Vector is garbage collected\n+   so we won't end up visiting empty types.  */\n+\n+static GTY(()) vec <odr_type, va_gc> *odr_types_ptr;\n+#define odr_types (*odr_types_ptr)\n+\n+/* Get ODR type hash entry for TYPE.  If INSERT is true, create\n+   possibly new entry.  */\n+\n+odr_type\n+get_odr_type (tree type, bool insert)\n+{\n+  odr_type_d **slot;\n+  odr_type val;\n+  hashval_t hash;\n+\n+  type = TYPE_MAIN_VARIANT (type);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (type) == type);\n+  hash = hash_type_name (type);\n+  slot = odr_hash.find_slot_with_hash (type, hash, insert ? INSERT : NO_INSERT);\n+  if (!slot)\n+    return NULL;\n+\n+  /* See if we already have entry for type.  */\n+  if (*slot)\n+    {\n+      val = *slot;\n+\n+      /* With LTO we will need to support multiple tree representation of\n+\t the same ODR type.  For now we ignore this.  */\n+      if (val->type == type)\n+\treturn val;\n+      gcc_unreachable ();\n+    }\n+  else\n+    {\n+      tree binfo = TYPE_BINFO (type);\n+      unsigned int i;\n+\n+      val = ggc_alloc_cleared_odr_type_d ();\n+      val->type = type;\n+      val->bases = vNULL;\n+      val->derived_types = vNULL;\n+      *slot = val;\n+      for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n+\t/* For now record only polymorphic types. other are\n+\t   pointless for devirtualization and we can not precisely\n+\t   determine ODR equivalency of these during LTO.  */\n+\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO (binfo, i)))\n+\t  {\n+\t    odr_type base = get_odr_type (BINFO_TYPE (BINFO_BASE_BINFO (binfo,\n+\t\t\t\t\t\t\t\t\ti)),\n+\t\t\t\t\t  true);\n+\t    base->derived_types.safe_push (val);\n+\t    val->bases.safe_push (base);\n+\t  }\n+      /* First record bases, then add into array so ids are increasing.  */\n+      if (odr_types_ptr)\n+        val->id = odr_types.length();\n+      vec_safe_push (odr_types_ptr, val);\n+    }\n+  return val;\n+}\n+\n+/* Dump ODR type T and all its derrived type.  INDENT specify indentation for\n+   recusive printing.  */\n+\n+static void\n+dump_odr_type (FILE *f, odr_type t, int indent=0)\n+{\n+  unsigned int i;\n+  fprintf (f, \"%*s type %i: \", indent * 2, \"\", t->id);\n+  print_generic_expr (f, t->type, TDF_SLIM);\n+  fprintf (f, \"\\n\");\n+  if (TYPE_NAME (t->type))\n+    {\n+      fprintf (f, \"%*s defined at: %s:%i\\n\", indent * 2, \"\",\n+\t       DECL_SOURCE_FILE (TYPE_NAME (t->type)),\n+\t       DECL_SOURCE_LINE (TYPE_NAME (t->type)));\n+    }\n+  if (t->bases.length())\n+    {\n+      fprintf (f, \"%*s base odr type ids: \", indent * 2, \"\");\n+      for (i = 0; i < t->bases.length(); i++)\n+\tfprintf (f, \" %i\", t->bases[i]->id);\n+      fprintf (f, \"\\n\");\n+    }\n+  if (t->derived_types.length())\n+    {\n+      fprintf (f, \"%*s derived types:\\n\", indent * 2, \"\");\n+      for (i = 0; i < t->derived_types.length(); i++)\n+        dump_odr_type (f, t->derived_types[i], indent + 1);\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Dump the type inheritance graph.  */\n+\n+static void\n+dump_type_inheritance_graph (FILE *f)\n+{\n+  unsigned int i;\n+  fprintf (f, \"\\n\\nType inheritance graph:\\n\");\n+  for (i = 0; i < odr_types.length(); i++)\n+    {\n+      if (odr_types[i]->bases.length() == 0)\n+\tdump_odr_type (f, odr_types[i]);\n+    }\n+}\n+\n+/* Given method type T, return type of class it belongs to.\n+   Lookup this pointer and get its type.    */\n+\n+static tree\n+method_class_type (tree t)\n+{\n+  tree first_parm_type = TREE_VALUE (TYPE_ARG_TYPES (t));\n+\n+  return TREE_TYPE (first_parm_type);\n+}\n+\n+/* Initialize IPA devirt and build inheritance tree graph.  */\n+\n+void\n+build_type_inheritance_graph (void)\n+{\n+  struct cgraph_node *n;\n+  FILE *inheritance_dump_file;\n+  int flags;\n+\n+  if (odr_hash.is_created ())\n+    return;\n+  timevar_push (TV_IPA_INHERITANCE);\n+  inheritance_dump_file = dump_begin (TDI_inheritance, &flags);\n+  odr_hash.create (23);\n+\n+  /* We reconstruct the graph starting of types of all methods seen in the\n+     the unit.  */\n+  FOR_EACH_FUNCTION (n)\n+    if (DECL_VIRTUAL_P (n->symbol.decl)\n+\t&& symtab_real_symbol_p ((symtab_node)n))\n+      get_odr_type (method_class_type (TREE_TYPE (n->symbol.decl)), true);\n+  if (inheritance_dump_file)\n+    {\n+      dump_type_inheritance_graph (inheritance_dump_file);\n+      dump_end (TDI_inheritance, inheritance_dump_file);\n+    }\n+  timevar_pop (TV_IPA_INHERITANCE);\n+}\n+\n+/* If TARGET has associated node, record it in the NODES array.  */\n+\n+static void\n+maybe_record_node (vec <cgraph_node *> &nodes,\n+\t\t   tree target, pointer_set_t *inserted)\n+{\n+  struct cgraph_node *target_node;\n+  enum built_in_function fcode;\n+\n+  if (target\n+      /* Those are used to mark impossible scenarios.  */\n+      && (fcode = DECL_FUNCTION_CODE (target))\n+\t  != BUILT_IN_UNREACHABLE\n+      && fcode != BUILT_IN_TRAP\n+      && !pointer_set_insert (inserted, target)\n+      && (target_node = cgraph_get_node (target)) != NULL\n+      && symtab_real_symbol_p ((symtab_node)target_node))\n+    nodes.safe_push (target_node);\n+}\n+\n+/* See if BINFO's type match OTR_TYPE.  If so, lookup method\n+   in vtable of TYPE_BINFO and insert method to NODES array.\n+   Otherwise recurse to base BINFOs.\n+   This match what get_binfo_at_offset does, but with offset\n+   being unknown.\n+\n+   TYPE_BINFO is binfo holding an virtual table matching\n+   BINFO's type.  In the case of single inheritance, this\n+   is binfo of BINFO's type ancestor (vtable is shared),\n+   otherwise it is binfo of BINFO's type.\n+\n+   MATCHED_VTABLES tracks virtual tables we already did lookup\n+   for virtual function in.\n+  */\n+\n+static void\n+record_binfo (vec <cgraph_node *> &nodes,\n+\t      tree binfo,\n+\t      tree otr_type,\n+\t      tree type_binfo,\n+\t      HOST_WIDE_INT otr_token,\n+\t      pointer_set_t *inserted,\n+\t      pointer_set_t *matched_vtables)\n+{\n+  tree type = BINFO_TYPE (binfo);\n+  int i;\n+  tree base_binfo;\n+\n+  gcc_checking_assert (BINFO_VTABLE (type_binfo));\n+\n+  if (types_same_for_odr (type, otr_type)\n+      && !pointer_set_insert (matched_vtables, BINFO_VTABLE (type_binfo)))\n+    {\n+      tree target = gimple_get_virt_method_for_binfo (otr_token, type_binfo);\n+      if (target)\n+\tmaybe_record_node (nodes, target, inserted);\n+      return;\n+    }\n+\n+  /* Walk bases.  */\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    /* Walking bases that have no virtual method is pointless excercise.  */\n+    if (polymorphic_type_binfo_p (base_binfo))\n+      record_binfo (nodes, base_binfo, otr_type,\n+\t\t    BINFO_VTABLE (base_binfo) ? base_binfo : type_binfo,\n+\t\t    otr_token, inserted,\n+\t\t    matched_vtables);\n+}\n+     \n+/* Lookup virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n+   of TYPE, insert them to NODES, recurse into derived nodes. \n+   INSERTED is used to avoid duplicate insertions of methods into NODES.\n+   MATCHED_VTABLES are used to avoid duplicate walking vtables.  */\n+\n+static void\n+possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n+\t\t\t\t     pointer_set_t *inserted,\n+\t\t\t\t     pointer_set_t *matched_vtables,\n+\t\t\t\t     tree otr_type,\n+\t\t\t\t     odr_type type,\n+\t\t\t\t     HOST_WIDE_INT otr_token)\n+{\n+  tree binfo = TYPE_BINFO (type->type);\n+  unsigned int i;\n+\n+  record_binfo (nodes, binfo, otr_type, binfo, otr_token, inserted,\n+\t        matched_vtables);\n+  for (i = 0; i < type->derived_types.length(); i++)\n+    possible_polymorphic_call_targets_1 (nodes, inserted, \n+\t\t\t\t\t matched_vtables,\n+\t\t\t\t\t otr_type,\n+\t\t\t\t\t type->derived_types[i],\n+\t\t\t\t\t otr_token);\n+}\n+\n+/* Cache of queries for polymorphic call targets.\n+\n+   Enumerating all call targets may get expensive when there are many\n+   polymorphic calls in the program, so we memoize all the previous\n+   queries and avoid duplicated work.  */\n+\n+struct polymorphic_call_target_d\n+{\n+  odr_type type;\n+  HOST_WIDE_INT otr_token;\n+  vec <cgraph_node *> targets;\n+};\n+\n+/* Polymorphic call target cache helpers.  */\n+\n+struct polymorphic_call_target_hasher \n+{\n+  typedef polymorphic_call_target_d value_type;\n+  typedef polymorphic_call_target_d compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+/* Return the computed hashcode for ODR_QUERY.  */\n+\n+inline hashval_t\n+polymorphic_call_target_hasher::hash (const value_type *odr_query)\n+{\n+  return iterative_hash_hashval_t (odr_query->type->id,\n+\t\t\t\t   odr_query->otr_token);\n+}\n+\n+/* Compare cache entries T1 and T2.  */\n+\n+inline bool\n+polymorphic_call_target_hasher::equal (const value_type *t1,\n+\t\t\t\t       const compare_type *t2)\n+{\n+  return t1->type == t2->type && t1->otr_token == t2->otr_token;\n+}\n+\n+/* Remove entry in polymorphic call target cache hash.  */\n+\n+inline void\n+polymorphic_call_target_hasher::remove (value_type *v)\n+{\n+  v->targets.release ();\n+  free (v);\n+}\n+\n+/* Polymorphic call target query cache.  */\n+\n+typedef hash_table <polymorphic_call_target_hasher>\n+   polymorphic_call_target_hash_type;\n+static polymorphic_call_target_hash_type polymorphic_call_target_hash;\n+pointer_set_t *cached_polymorphic_call_targets;\n+\n+/* Destroy polymorphic call target query cache.  */\n+\n+static void\n+free_polymorphic_call_targets_hash ()\n+{\n+  polymorphic_call_target_hash.dispose ();\n+  pointer_set_destroy (cached_polymorphic_call_targets);\n+  cached_polymorphic_call_targets = NULL;\n+}\n+\n+/* When virtual function is removed, we may need to flush the cache.  */\n+\n+static void\n+devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n+{\n+  if (pointer_set_contains (cached_polymorphic_call_targets, n))\n+    free_polymorphic_call_targets_hash ();\n+}\n+\n+/* Return vector containing possible targets of polymorphic call of type\n+   OTR_TYPE caling method OTR_TOKEN with OFFSET.  If FINALp is non-NULL,\n+   store true if the list is complette. \n+   CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n+   in the target cache.  If user needs to visit every target list\n+   just once, it can memoize them.\n+\n+   Returned vector is placed into cache.  It is NOT caller's responsibility\n+   to free it.  The vector can be freed on cgraph_remove_node call if\n+   the particular node is a virtual function present in the cache.  */\n+\n+vec <cgraph_node *>\n+possible_polymorphic_call_targets (tree otr_type,\n+\t\t\t           HOST_WIDE_INT otr_token,\n+\t\t\t           bool *finalp,\n+\t\t\t           void **cache_token)\n+{\n+  static struct cgraph_node_hook_list *node_removal_hook_holder;\n+  pointer_set_t *inserted;\n+  pointer_set_t *matched_vtables;\n+  vec <cgraph_node *> nodes=vNULL;\n+  odr_type type;\n+  polymorphic_call_target_d key;\n+  polymorphic_call_target_d **slot;\n+  unsigned int i;\n+  tree binfo, target;\n+\n+  if (finalp)\n+    *finalp = false;\n+\n+  type = get_odr_type (otr_type, false);\n+  /* If we do not have type in our hash it means we never seen any method\n+     in it.  */\n+  if (!type)\n+    return nodes;\n+\n+  /* For anonymous namespace types we can attempt to build full type.\n+     All derivations must be in this unit.  */\n+  if (type->anonymous_namespace && finalp && !flag_ltrans)\n+    *finalp = true;\n+\n+  /* Initialize query cache.  */\n+  if (!cached_polymorphic_call_targets)\n+    {\n+      cached_polymorphic_call_targets = pointer_set_create ();\n+      polymorphic_call_target_hash.create (23);\n+      if (!node_removal_hook_holder)\n+\tnode_removal_hook_holder =\n+\t  cgraph_add_node_removal_hook (&devirt_node_removal_hook, NULL);\n+    }\n+\n+  /* Lookup cached answer.  */\n+  key.type = type;\n+  key.otr_token = otr_token;\n+  slot = polymorphic_call_target_hash.find_slot (&key, INSERT);\n+  if (cache_token)\n+   *cache_token = (void *)*slot;\n+  if (*slot)\n+    return (*slot)->targets;\n+\n+  /* Do actual search.  */\n+  timevar_push (TV_IPA_VIRTUAL_CALL);\n+  *slot = XCNEW (polymorphic_call_target_d);\n+  if (cache_token)\n+   *cache_token = (void *)*slot;\n+  (*slot)->type = type;\n+  (*slot)->otr_token = otr_token;\n+\n+  inserted = pointer_set_create ();\n+  matched_vtables = pointer_set_create ();\n+\n+  /* First see virtual method of type itself.  */\n+\n+  binfo = TYPE_BINFO (type->type);\n+  target = gimple_get_virt_method_for_binfo (otr_token, binfo);\n+  if (target)\n+    maybe_record_node (nodes, target, inserted);\n+  pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n+\n+  /* TODO: If method is final, we can stop here and signaize that\n+     list is final.  We need C++ FE to pass our info about final\n+     methods and classes.  */\n+\n+  /* Walk recursively all derived types.  Here we need to lookup proper basetype\n+     via their BINFO walk that is done by record_binfo  */\n+  for (i = 0; i < type->derived_types.length(); i++)\n+    possible_polymorphic_call_targets_1 (nodes, inserted,\n+\t\t\t\t\t matched_vtables,\n+\t\t\t\t\t otr_type, type->derived_types[i],\n+\t\t\t\t\t otr_token);\n+  (*slot)->targets = nodes;\n+\n+  pointer_set_destroy (inserted);\n+  pointer_set_destroy (matched_vtables);\n+  timevar_pop (TV_IPA_VIRTUAL_CALL);\n+  return nodes;\n+}\n+\n+/* Dump all possible targets of a polymorphic call.  */\n+\n+void\n+dump_possible_polymorphic_call_targets (FILE *f,\n+\t\t\t\t    tree otr_type,\n+\t\t\t\t    HOST_WIDE_INT otr_token)\n+{\n+  vec <cgraph_node *> targets;\n+  bool final;\n+  odr_type type = get_odr_type (otr_type, false);\n+  unsigned int i;\n+\n+  if (!type)\n+    return;\n+  targets = possible_polymorphic_call_targets (otr_type, otr_token,\n+\t\t\t\t\t       &final);\n+  fprintf (f, \"Targets of polymorphic call of type %i \", type->id);\n+  print_generic_expr (f, type->type, TDF_SLIM);\n+  fprintf (f, \" token %i%s:\",\n+\t   (int)otr_token,\n+\t   final ? \" (full list)\" : \" (partial list, may call to other unit)\");\n+  for (i = 0; i < targets.length (); i++)\n+    fprintf (f, \" %s/%i\", cgraph_node_name (targets[i]),\n+\t     targets[i]->symbol.order);\n+  fprintf (f, \"\\n\");\n+}\n+\n+#include \"gt-ipa-devirt.h\""}, {"sha": "f35ddb5dc5436f9d5fb199bf55ab8be2af338617", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -36,7 +36,6 @@ struct ipa_dfs_info {\n };\n \n \n-\n /* In ipa-utils.c  */\n void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);\n int ipa_reduced_postorder (struct cgraph_node **, bool, bool,\n@@ -46,7 +45,48 @@ vec<cgraph_node_ptr> ipa_get_nodes_in_cycle (struct cgraph_node *);\n int ipa_reverse_postorder (struct cgraph_node **);\n tree get_base_var (tree);\n \n+/* In ipa-devirt.c  */\n+\n+struct odr_type_d;\n+typedef odr_type_d *odr_type;\n+void build_type_inheritance_graph (void);\n+vec <cgraph_node *>\n+possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n+\t\t\t\t   bool *final = NULL,\n+\t\t\t\t   void **cache_token = NULL);\n+odr_type get_odr_type (tree, bool insert = false);\n+void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT);\n+\n+/* Return vector containing possible targets of polymorphic call E.\n+   If FINALP is non-NULL, store true if the list is complette. \n+   CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n+   in the target cache.  If user needs to visit every target list\n+   just once, it can memoize them.\n+\n+   Returned vector is placed into cache.  It is NOT caller's responsibility\n+   to free it.  The vector can be freed on cgraph_remove_node call if\n+   the particular node is a virtual function present in the cache.  */\n+\n+inline vec <cgraph_node *>\n+possible_polymorphic_call_targets (struct cgraph_edge *e,\n+\t\t\t\t   bool *final = NULL,\n+\t\t\t\t   void **cache_token = NULL)\n+{\n+  gcc_checking_assert (e->indirect_info->polymorphic);\n+  return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n+\t\t\t\t\t    e->indirect_info->otr_token,\n+\t\t\t\t\t    final, cache_token);\n+}\n+\n+/* Dump possible targets of a polymorphic call E into F.  */\n \n+inline void\n+dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n+{\n+  gcc_checking_assert (e->indirect_info->polymorphic);\n+  dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n+\t\t\t\t\t  e->indirect_info->otr_token);\n+}\n #endif  /* GCC_IPA_UTILS_H  */\n \n "}, {"sha": "bbe5c1d87d2cbc3f1e394f29aec947b2ad8c8817", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -1,3 +1,7 @@\n+2013-08-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* g++.dg/ipa/type-inheritance-1.C: New testcase.\n+\n 2013-08-19  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/46271"}, {"sha": "818002ec1d598ccd1cfd378033060aab57814e5a", "filename": "gcc/testsuite/g++.dg/ipa/type-inheritance-1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Ftype-inheritance-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Ftype-inheritance-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Ftype-inheritance-1.C?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -0,0 +1,28 @@\n+/* Verify that callgraph construction keeps FOO for possible devirtualization\n+   and removes BAR.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-visibility\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  virtual int foo (void)\n+     {\n+\treturn 4;\n+     }\n+  virtual int bar (void)\n+     {\n+\treturn 5;\n+     }\n+};\n+\n+\n+int t(class A *a)\n+{\n+  return a->foo();\n+}\n+/* { dg-final { scan-ipa-dump \"A::foo\"  \"visibility\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"A::bar\"  \"visibility\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"visibility\" } } */"}, {"sha": "bd1ee7612dc58cae00a58621ee3adea50c3b39f6", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -64,6 +64,8 @@ DEFTIMEVAR (TV_PCH_CPP_RESTORE       , \"PCH preprocessor state restore\")\n \n DEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\n DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n+DEFTIMEVAR (TV_IPA_INHERITANCE       , \"ipa inheritance graph\")\n+DEFTIMEVAR (TV_IPA_VIRTUAL_CALL      , \"ipa virtual call target\")\n DEFTIMEVAR (TV_IPA_CONSTANT_PROP     , \"ipa cp\")\n DEFTIMEVAR (TV_IPA_INLINING          , \"ipa inlining heuristics\")\n DEFTIMEVAR (TV_IPA_FNSPLIT           , \"ipa function splitting\")"}, {"sha": "194710564a9be1be0dfa65153c645dfcb6e8f749", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -11845,11 +11845,8 @@ types_same_for_odr (tree type1, tree type2)\n \n   /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n      on the corresponding TYPE_STUB_DECL.  */\n-  if (TYPE_STUB_DECL (type1) != TYPE_STUB_DECL (type2)\n-      && (!TYPE_STUB_DECL (type1)\n-\t  || !TYPE_STUB_DECL (type2)\n-\t  || !TREE_PUBLIC (TYPE_STUB_DECL (type1))\n-\t  || !TREE_PUBLIC (TYPE_STUB_DECL (type2))))\n+  if (type_in_anonymous_namespace_p (type1)\n+      || type_in_anonymous_namespace_p (type2))\n     return false;\n \n   if (!TYPE_NAME (type1))\n@@ -11904,6 +11901,14 @@ obj_type_ref_class (tree ref)\n   return TREE_TYPE (ref);\n }\n \n+/* Return true if T is in anonymous namespace.  */\n+\n+bool\n+type_in_anonymous_namespace_p (tree t)\n+{\n+  return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n+}\n+\n /* Try to find a base info of BINFO that would have its field decl at offset\n    OFFSET within the BINFO type and which is of EXPECTED_TYPE.  If it can be\n    found, return, otherwise return NULL_TREE.  */"}, {"sha": "84bd69932d2db8ee0506a62d1876d3815967cfb3", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9a995ceec7fc5ca79505e96bda214e6bd82c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=eefe9a995ceec7fc5ca79505e96bda214e6bd82c", "patch": "@@ -5980,6 +5980,7 @@ extern bool types_same_for_odr (tree type1, tree type2);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n extern bool contains_bitfld_component_ref_p (const_tree);\n+extern bool type_in_anonymous_namespace_p (tree);\n \n /* In tree-nested.c */\n extern tree build_addr (tree, tree);"}]}