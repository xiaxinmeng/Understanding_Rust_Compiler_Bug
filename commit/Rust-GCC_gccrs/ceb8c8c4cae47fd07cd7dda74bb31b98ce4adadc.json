{"sha": "ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ViOGM4YzRjYWU0N2ZkMDdjZDdkZGE3NGJiMzFiOThjZTRhZGFkYw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2018-11-30T13:33:18Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2018-11-30T13:33:18Z"}, "message": "[RS6000] num_insns_constant ICE\n\nThis patch came about from investigating an ICE that appeared when I\nwas retesting an old half-baked patch of mine to rs6000_rtx_costs.\nIf a const_double is fed to rs6000_is_valid_and_mask and from there to\nrs6000_is_valid_mask where INTVAL is used, gcc will ICE.\n\nThe num_insns_constant ICE was introduced with git commit f337168d97.\nHowever, the code was buggy before that.  There was no point in\ntesting for a mask since the mask predicates only handle const_int.\nIn fact, I don't think the function ever handled floating point\nconstants that might match a load of minus one and mask.  It does now.\nI've added a few comments regarding splitters so the next person\nlooking at this code can see how this works.\n\nThe patch also extracts code out of num_insns_constant that needed to\nhandle multiple gprs for DFmode constants in 32-bit mode, to a\nfunction that handles multiple gprs a little more generally.  I don't\nthink there is any need for anything but the 32-bit DFmode case\ncurrently, but this allows for possible future uses.  The\nCONST_WIDE_INT case is also not used currently, and needed fixing.\nAdding CONST_WIDE_INT_NUNITS - 1 only makes sense if the elements of\nthe array were being shifted into a register of size larger than the\nelement size (which is 64-bits).\n\n\t* config/rs6000/rs6000.c (num_insns_constant_gpr): Renamed from\n\tnum_insns_constant_wide.  Make static.  Revise comment.\n\t(num_insns_constant_multi): New function.\n\t(num_insns_constant): Formatting.  Correct CONST_WIDE_INT\n\tcalculation.  Simplify and extract code common to both\n\tCONST_INT and CONST_DOUBLE.  Add gcc_unreachable for unhandled\n\tconst_double modes.\n\t* config/rs6000/rs6000-protos.h (num_insns_const_wide): Delete.\n\nFrom-SVN: r266662", "tree": {"sha": "23089fda67e1747910ad9f2b45f26840fed7944e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23089fda67e1747910ad9f2b45f26840fed7944e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f44697b78a06bf880ba25e9d4cd721f24282a797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44697b78a06bf880ba25e9d4cd721f24282a797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f44697b78a06bf880ba25e9d4cd721f24282a797"}], "stats": {"total": 134, "additions": 84, "deletions": 50}, "files": [{"sha": "617a3d64d2ae0292f8fe21ee8b84ea2ab91d4e21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "patch": "@@ -1,3 +1,14 @@\n+2018-11-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (num_insns_constant_gpr): Renamed from\n+\tnum_insns_constant_wide.  Make static.  Revise comment.\n+\t(num_insns_constant_multi): New function.\n+\t(num_insns_constant): Formatting.  Correct CONST_WIDE_INT\n+\tcalculation.  Simplify and extract code common to both\n+\tCONST_INT and CONST_DOUBLE.  Add gcc_unreachable for unhandled\n+\tconst_double modes.\n+\t* config/rs6000/rs6000-protos.h (num_insns_const_wide): Delete.\n+\n 2018-11-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/88274"}, {"sha": "dfee1f28aa9ed3d4907999ee21c576fb6342be3e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "patch": "@@ -36,7 +36,6 @@ extern int vspltis_shifted (rtx);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);\n extern bool macho_lo_sum_memory_operand (rtx, machine_mode);\n extern int num_insns_constant (rtx, machine_mode);\n-extern int num_insns_constant_wide (HOST_WIDE_INT);\n extern int small_data_operand (rtx, machine_mode);\n extern bool mem_operand_gpr (rtx, machine_mode);\n extern bool mem_operand_ds_form (rtx, machine_mode);"}, {"sha": "fe58bc1a3dddc96465281d8e689d07ee27623668", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ceb8c8c4cae47fd07cd7dda74bb31b98ce4adadc", "patch": "@@ -5821,11 +5821,12 @@ direct_return (void)\n   return 0;\n }\n \n-/* Return the number of instructions it takes to form a constant in an\n-   integer register.  */\n+/* Helper for num_insns_constant.  Calculate number of instructions to\n+   load VALUE to a single gpr using combinations of addi, addis, ori,\n+   oris and sldi instructions.  */\n \n-int\n-num_insns_constant_wide (HOST_WIDE_INT value)\n+static int\n+num_insns_constant_gpr (HOST_WIDE_INT value)\n {\n   /* signed constant loadable with addi */\n   if (((unsigned HOST_WIDE_INT) value + 0x8000) < 0x10000)\n@@ -5847,85 +5848,108 @@ num_insns_constant_wide (HOST_WIDE_INT value)\n       high >>= 1;\n \n       if (low == 0)\n-\treturn num_insns_constant_wide (high) + 1;\n+\treturn num_insns_constant_gpr (high) + 1;\n       else if (high == 0)\n-\treturn num_insns_constant_wide (low) + 1;\n+\treturn num_insns_constant_gpr (low) + 1;\n       else\n-\treturn (num_insns_constant_wide (high)\n-\t\t+ num_insns_constant_wide (low) + 1);\n+\treturn (num_insns_constant_gpr (high)\n+\t\t+ num_insns_constant_gpr (low) + 1);\n     }\n \n   else\n     return 2;\n }\n \n+/* Helper for num_insns_constant.  Allow constants formed by the\n+   num_insns_constant_gpr sequences, plus li -1, rldicl/rldicr/rlwinm,\n+   and handle modes that require multiple gprs.  */\n+\n+static int\n+num_insns_constant_multi (HOST_WIDE_INT value, machine_mode mode)\n+{\n+  int nregs = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  int total = 0;\n+  while (nregs-- > 0)\n+    {\n+      HOST_WIDE_INT low = sext_hwi (value, BITS_PER_WORD);\n+      int insns = num_insns_constant_gpr (low);\n+      if (insns > 2\n+\t  /* We won't get more than 2 from num_insns_constant_gpr\n+\t     except when TARGET_POWERPC64 and mode is DImode or\n+\t     wider, so the register mode must be DImode.  */\n+\t  && rs6000_is_valid_and_mask (GEN_INT (low), DImode))\n+\tinsns = 2;\n+      total += insns;\n+      value >>= BITS_PER_WORD;\n+    }\n+  return total;\n+}\n+\n+/* Return the number of instructions it takes to form a constant in as\n+   many gprs are needed for MODE.  */\n+\n int\n num_insns_constant (rtx op, machine_mode mode)\n {\n-  HOST_WIDE_INT low, high;\n+  HOST_WIDE_INT val;\n \n   switch (GET_CODE (op))\n     {\n     case CONST_INT:\n-      if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n-\t  && rs6000_is_valid_and_mask (op, mode))\n-\treturn 2;\n-      else\n-\treturn num_insns_constant_wide (INTVAL (op));\n+      val = INTVAL (op);\n+      break;\n \n     case CONST_WIDE_INT:\n       {\n-\tint i;\n-\tint ins = CONST_WIDE_INT_NUNITS (op) - 1;\n-\tfor (i = 0; i < CONST_WIDE_INT_NUNITS (op); i++)\n-\t  ins += num_insns_constant_wide (CONST_WIDE_INT_ELT (op, i));\n-\treturn ins;\n+\tint insns = 0;\n+\tfor (int i = 0; i < CONST_WIDE_INT_NUNITS (op); i++)\n+\t  insns += num_insns_constant_multi (CONST_WIDE_INT_ELT (op, i),\n+\t\t\t\t\t     DImode);\n+\treturn insns;\n       }\n \n-      case CONST_DOUBLE:\n+    case CONST_DOUBLE:\n+      {\n+\tconst struct real_value *rv = CONST_DOUBLE_REAL_VALUE (op);\n+\n \tif (mode == SFmode || mode == SDmode)\n \t  {\n \t    long l;\n \n-\t    if (DECIMAL_FLOAT_MODE_P (mode))\n-\t      REAL_VALUE_TO_TARGET_DECIMAL32\n-\t\t(*CONST_DOUBLE_REAL_VALUE (op), l);\n+\t    if (mode == SDmode)\n+\t      REAL_VALUE_TO_TARGET_DECIMAL32 (*rv, l);\n \t    else\n-\t      REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (op), l);\n-\t    return num_insns_constant_wide ((HOST_WIDE_INT) l);\n+\t      REAL_VALUE_TO_TARGET_SINGLE (*rv, l);\n+\t    /* See the first define_split in rs6000.md handling a\n+\t       const_double_operand.  */\n+\t    val = l;\n+\t    mode = SImode;\n \t  }\n-\n-\tlong l[2];\n-\tif (DECIMAL_FLOAT_MODE_P (mode))\n-\t  REAL_VALUE_TO_TARGET_DECIMAL64 (*CONST_DOUBLE_REAL_VALUE (op), l);\n-\telse\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (op), l);\n-\thigh = l[WORDS_BIG_ENDIAN == 0];\n-\tlow  = l[WORDS_BIG_ENDIAN != 0];\n-\n-\tif (TARGET_32BIT)\n-\t  return (num_insns_constant_wide (low)\n-\t\t  + num_insns_constant_wide (high));\n-\telse\n+\telse if (mode == DFmode || mode == DDmode)\n \t  {\n-\t    if ((high == 0 && low >= 0)\n-\t\t|| (high == -1 && low < 0))\n-\t      return num_insns_constant_wide (low);\n-\n-\t    else if (rs6000_is_valid_and_mask (op, mode))\n-\t      return 2;\n-\n-\t    else if (low == 0)\n-\t      return num_insns_constant_wide (high) + 1;\n+\t    long l[2];\n \n+\t    if (mode == DDmode)\n+\t      REAL_VALUE_TO_TARGET_DECIMAL64 (*rv, l);\n \t    else\n-\t      return (num_insns_constant_wide (high)\n-\t\t      + num_insns_constant_wide (low) + 1);\n+\t      REAL_VALUE_TO_TARGET_DOUBLE (*rv, l);\n+\n+\t    /* See the second (32-bit) and third (64-bit) define_split\n+\t       in rs6000.md handling a const_double_operand.  */\n+\t    val = (unsigned HOST_WIDE_INT) l[WORDS_BIG_ENDIAN ? 0 : 1] << 32;\n+\t    val |= l[WORDS_BIG_ENDIAN ? 1 : 0] & 0xffffffffUL;\n+\t    mode = DImode;\n \t  }\n+\telse\n+\t  gcc_unreachable ();\n+      }\n+      break;\n \n     default:\n       gcc_unreachable ();\n     }\n+\n+  return num_insns_constant_multi (val, mode);\n }\n \n /* Interpret element ELT of the CONST_VECTOR OP as an integer value."}]}