{"sha": "bc15d0efe4230e2f3636dc5255c331232211fb44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMxNWQwZWZlNDIzMGUyZjM2MzZkYzUyNTVjMzMxMjMyMjExZmI0NA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-07-08T08:45:05Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-07-08T08:45:05Z"}, "message": "re PR c/2511 (-pedantic not warning about bitfield overflow)\n\n2004-07-08  Joseph S. Myers  <jsm@polyomino.org.uk>\n            Neil Booth  <neil@daikokuya.co.uk>\n\n\tPR c/2511\n\tPR c/3325\n\t* c-decl.c (finish_struct): Ensure bit-fields are given the\n\tcorrect type.\n\t* c-common.c (c_common_signed_or_unsigned_type): For C, require\n\tthe precision to match as well as the mode.\n\t* expr.c (reduce_to_bit_field_precision): New function.\n\t(expand_expr_real_1): Reduce expressions of bit-field type to\n\tproper precision.\n\t* langhooks.h (reduce_bit_field_operations): New hook.\n\t* langhooks-def.h (LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS):\n\tDefine.\n\t* c-lang.c, objc/objc-lang.c\n\t(LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS): Define.\n\t* objc/objc-act.c (check_ivars): Convert types to bit-field types\n\tbefore checking.\n\t* tree.c (build_nonstandard_integer_type): New function.\n\t* tree.h (build_nonstandard_integer_type): New prototype.\n\t* tree-ssa.c (tree_ssa_useless_type_conversion_1): Don't treat\n\tconversions between integer and boolean types as useless.\n\ntestsuite:\n\t* gcc.c-torture/execute/bitfld-1.x: Remove.\n\t* gcc.c-torture/execute/bitfld-3.c: New test.\n\t* gcc.dg/bitfld-2.c: Remove XFAILs.\n\nCo-Authored-By: Neil Booth <neil@daikokuya.co.uk>\n\nFrom-SVN: r84279", "tree": {"sha": "69763a66482d42b14599835106ea027f80e7499e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69763a66482d42b14599835106ea027f80e7499e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc15d0efe4230e2f3636dc5255c331232211fb44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc15d0efe4230e2f3636dc5255c331232211fb44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc15d0efe4230e2f3636dc5255c331232211fb44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc15d0efe4230e2f3636dc5255c331232211fb44/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "942e59391c7a8ff8d57439229877257eb62b2eb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942e59391c7a8ff8d57439229877257eb62b2eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/942e59391c7a8ff8d57439229877257eb62b2eb0"}], "stats": {"total": 303, "additions": 251, "deletions": 52}, "files": [{"sha": "fa0aefcc4695edc05ddadcc4f33f993eb7eec2de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -1,3 +1,27 @@\n+2004-07-08  Joseph S. Myers  <jsm@polyomino.org.uk>\n+            Neil Booth  <neil@daikokuya.co.uk>\n+\n+\tPR c/2511\n+\tPR c/3325\n+\t* c-decl.c (finish_struct): Ensure bit-fields are given the\n+\tcorrect type.\n+\t* c-common.c (c_common_signed_or_unsigned_type): For C, require\n+\tthe precision to match as well as the mode.\n+\t* expr.c (reduce_to_bit_field_precision): New function.\n+\t(expand_expr_real_1): Reduce expressions of bit-field type to\n+\tproper precision.\n+\t* langhooks.h (reduce_bit_field_operations): New hook.\n+\t* langhooks-def.h (LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS):\n+\tDefine.\n+\t* c-lang.c, objc/objc-lang.c\n+\t(LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS): Define.\n+\t* objc/objc-act.c (check_ivars): Convert types to bit-field types\n+\tbefore checking.\n+\t* tree.c (build_nonstandard_integer_type): New function.\n+\t* tree.h (build_nonstandard_integer_type): New prototype.\n+\t* tree-ssa.c (tree_ssa_useless_type_conversion_1): Don't treat\n+\tconversions between integer and boolean types as useless.\n+\n 2004-07-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* c-common.c (c_common_nodes_and_builtins): Do not"}, {"sha": "ebb5e65e404a0aa1fba3b85e8fcddf8ef3e7befb", "filename": "gcc/c-common.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -1636,40 +1636,51 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)\n       || TYPE_UNSIGNED (type) == unsignedp)\n     return type;\n \n-  /* Must check the mode of the types, not the precision.  Enumeral types\n-     in C++ have precision set to match their range, but may use a wider\n-     mode to match an ABI.  If we change modes, we may wind up with bad\n-     conversions.  */\n-\n-  if (TYPE_MODE (type) == TYPE_MODE (signed_char_type_node))\n+  /* For ENUMERAL_TYPEs in C++, must check the mode of the types, not\n+     the precision; they have precision set to match their range, but\n+     may use a wider mode to match an ABI.  If we change modes, we may\n+     wind up with bad conversions.  For INTEGER_TYPEs in C, must check\n+     the precision as well, so as to yield correct results for\n+     bit-field types.  C++ does not have these separate bit-field\n+     types, and producing a signed or unsigned variant of an\n+     ENUMERAL_TYPE may cause other problems as well.  */\n+\n+#define TYPE_OK(node)\t\t\t\t\t\t\t    \\\n+  (TYPE_MODE (type) == TYPE_MODE (node)\t\t\t\t\t    \\\n+   && (c_dialect_cxx () || TYPE_PRECISION (type) == TYPE_PRECISION (node)))\n+  if (TYPE_OK (signed_char_type_node))\n     return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (integer_type_node))\n+  if (TYPE_OK (integer_type_node))\n     return unsignedp ? unsigned_type_node : integer_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (short_integer_type_node))\n+  if (TYPE_OK (short_integer_type_node))\n     return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (long_integer_type_node))\n+  if (TYPE_OK (long_integer_type_node))\n     return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (long_long_integer_type_node))\n+  if (TYPE_OK (long_long_integer_type_node))\n     return (unsignedp ? long_long_unsigned_type_node\n \t    : long_long_integer_type_node);\n-  if (TYPE_MODE (type) == TYPE_MODE (widest_integer_literal_type_node))\n+  if (TYPE_OK (widest_integer_literal_type_node))\n     return (unsignedp ? widest_unsigned_literal_type_node\n \t    : widest_integer_literal_type_node);\n \n #if HOST_BITS_PER_WIDE_INT >= 64\n-  if (TYPE_MODE (type) == TYPE_MODE (intTI_type_node))\n+  if (TYPE_OK (intTI_type_node))\n     return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n #endif\n-  if (TYPE_MODE (type) == TYPE_MODE (intDI_type_node))\n+  if (TYPE_OK (intDI_type_node))\n     return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (intSI_type_node))\n+  if (TYPE_OK (intSI_type_node))\n     return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (intHI_type_node))\n+  if (TYPE_OK (intHI_type_node))\n     return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-  if (TYPE_MODE (type) == TYPE_MODE (intQI_type_node))\n+  if (TYPE_OK (intQI_type_node))\n     return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n+#undef TYPE_OK\n \n-  return type;\n+  if (c_dialect_cxx ())\n+    return type;\n+  else\n+    return build_nonstandard_integer_type (TYPE_PRECISION (type), unsignedp);\n }\n \n /* The C version of the register_builtin_type langhook.  */"}, {"sha": "2a236aa51cf3c993f9339e59ec13e4b9e3e61e7c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -5162,9 +5162,11 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n     }\n \n   /* Install struct as DECL_CONTEXT of each field decl.\n-     Also process specified field sizes,m which is found in the DECL_INITIAL.\n-     Store 0 there, except for \": 0\" fields (so we can find them\n-     and delete them, below).  */\n+     Also process specified field sizes, found in the DECL_INITIAL,\n+     storing 0 there after the type has been changed to precision equal\n+     to its width, rather than the precision of the specified standard\n+     type.  (Correct layout requires the original type to have been preserved\n+     until now.)  */\n \n   saw_named_field = 0;\n   for (x = fieldlist; x; x = TREE_CHAIN (x))\n@@ -5208,8 +5210,6 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  SET_DECL_C_BIT_FIELD (x);\n \t}\n \n-      DECL_INITIAL (x) = 0;\n-\n       /* Detect flexible array member in an invalid context.  */\n       if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n \t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n@@ -5250,12 +5250,21 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \n   layout_type (t);\n \n-  /* Delete all zero-width bit-fields from the fieldlist.  */\n+  /* Give bit-fields their proper types.  */\n   {\n     tree *fieldlistp = &fieldlist;\n     while (*fieldlistp)\n-      if (TREE_CODE (*fieldlistp) == FIELD_DECL && DECL_INITIAL (*fieldlistp))\n-\t*fieldlistp = TREE_CHAIN (*fieldlistp);\n+      if (TREE_CODE (*fieldlistp) == FIELD_DECL && DECL_INITIAL (*fieldlistp)\n+\t  && TREE_TYPE (*fieldlistp) != error_mark_node)\n+\t{\n+\t  unsigned HOST_WIDE_INT width\n+\t    = tree_low_cst (DECL_INITIAL (*fieldlistp), 1);\n+\t  tree type = TREE_TYPE (*fieldlistp);\n+\t  if (width != TYPE_PRECISION (type))\n+\t    TREE_TYPE (*fieldlistp)\n+\t      = build_nonstandard_integer_type (width, TYPE_UNSIGNED (type));\n+\t  DECL_INITIAL (*fieldlistp) = 0;\n+\t}\n       else\n \tfieldlistp = &TREE_CHAIN (*fieldlistp);\n   }"}, {"sha": "8166698f7e742f1e4a04e216767b39c64c09a4ff", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -74,6 +74,8 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL c_finish_incomplete_decl\n #undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n #define LANG_HOOKS_UNSAFE_FOR_REEVAL c_common_unsafe_for_reeval\n+#undef LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS\n+#define LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS true\n #undef LANG_HOOKS_STATICP\n #define LANG_HOOKS_STATICP c_staticp\n #undef LANG_HOOKS_NO_BODY_BLOCKS"}, {"sha": "3be412dd56f09ac00f81fd1603b48e6ba7c429b6", "filename": "gcc/expr.c", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -154,6 +154,7 @@ static int is_aligning_offset (tree, tree);\n static rtx expand_increment (tree, int, int);\n static void expand_operands (tree, tree, rtx, rtx*, rtx*,\n \t\t\t     enum expand_modifier);\n+static rtx reduce_to_bit_field_precision (rtx, rtx, tree);\n static rtx do_store_flag (tree, rtx, enum machine_mode, int);\n #ifdef PUSH_ROUNDING\n static void emit_single_push_insn (enum machine_mode, rtx, tree);\n@@ -6430,9 +6431,26 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   rtx subtarget, original_target;\n   int ignore;\n   tree context;\n+  bool reduce_bit_field = false;\n+#define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field && !ignore\t\t  \\\n+\t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n+\t\t\t\t\t\t\t\t  target, \\\n+\t\t\t\t\t\t\t\t  type)\t  \\\n+\t\t\t\t : (expr))\n \n   mode = TYPE_MODE (type);\n   unsignedp = TYPE_UNSIGNED (type);\n+  if (lang_hooks.reduce_bit_field_operations\n+      && TREE_CODE (type) == INTEGER_TYPE\n+      && GET_MODE_PRECISION (mode) > TYPE_PRECISION (type))\n+    {\n+      /* An operation in what may be a bit-field type needs the\n+\t result to be reduced to the precision of the bit-field type,\n+\t which is narrower than that of the type's mode.  */\n+      reduce_bit_field = true;\n+      if (modifier == EXPAND_STACK_PARM)\n+\ttarget = 0;\n+    }\n \n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n   subtarget = get_subtarget (target);\n@@ -7423,10 +7441,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      && GET_CODE (op0) == SUBREG)\n \t    SUBREG_PROMOTED_VAR_P (op0) = 0;\n \n-\t  return op0;\n+\t  return REDUCE_BIT_FIELD (op0);\n \t}\n \n       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);\n+      op0 = REDUCE_BIT_FIELD (op0);\n       if (GET_MODE (op0) == mode)\n \treturn op0;\n \n@@ -7594,7 +7613,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      op1 = plus_constant (op1, INTVAL (constant_part));\n \t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t\top1 = force_operand (op1, target);\n-\t      return op1;\n+\t      return REDUCE_BIT_FIELD (op1);\n \t    }\n \n \t  else if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n@@ -7627,7 +7646,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      op0 = plus_constant (op0, INTVAL (constant_part));\n \t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t\top0 = force_operand (op0, target);\n-\t      return op0;\n+\t      return REDUCE_BIT_FIELD (op0);\n \t    }\n \t}\n \n@@ -7649,7 +7668,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n \t\t       subtarget, &op0, &op1, modifier);\n-      return simplify_gen_binary (PLUS, mode, op0, op1);\n+      return REDUCE_BIT_FIELD (simplify_gen_binary (PLUS, mode, op0, op1));\n \n     case MINUS_EXPR:\n       /* For initializers, we are allowed to return a MINUS of two\n@@ -7667,9 +7686,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  /* If the last operand is a CONST_INT, use plus_constant of\n \t     the negated constant.  Else make the MINUS.  */\n \t  if (GET_CODE (op1) == CONST_INT)\n-\t    return plus_constant (op0, - INTVAL (op1));\n+\t    return REDUCE_BIT_FIELD (plus_constant (op0, - INTVAL (op1)));\n \t  else\n-\t    return gen_rtx_MINUS (mode, op0, op1);\n+\t    return REDUCE_BIT_FIELD (gen_rtx_MINUS (mode, op0, op1));\n \t}\n \n       this_optab = ! unsignedp && flag_trapv\n@@ -7691,7 +7710,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (GET_CODE (op1) == CONST_INT)\n \t{\n \t  op1 = negate_rtx (mode, op1);\n-\t  return simplify_gen_binary (PLUS, mode, op0, op1);\n+\t  return REDUCE_BIT_FIELD (simplify_gen_binary (PLUS, mode, op0, op1));\n \t}\n \n       goto binop2;\n@@ -7723,9 +7742,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  if (!REG_P (op0))\n \t    op0 = copy_to_mode_reg (mode, op0);\n \n-\t  return gen_rtx_MULT (mode, op0,\n+\t  return REDUCE_BIT_FIELD (gen_rtx_MULT (mode, op0,\n \t\t\t       gen_int_mode (tree_low_cst (exp1, 0),\n-\t\t\t\t\t     TYPE_MODE (TREE_TYPE (exp1))));\n+\t\t\t\t\t     TYPE_MODE (TREE_TYPE (exp1)))));\n \t}\n \n       if (modifier == EXPAND_STACK_PARM)\n@@ -7803,13 +7822,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t      zextend_p);\n \t\t  if (htem != hipart)\n \t\t    emit_move_insn (hipart, htem);\n-\t\t  return temp;\n+\t\t  return REDUCE_BIT_FIELD (temp);\n \t\t}\n \t    }\n \t}\n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n \t\t       subtarget, &op0, &op1, 0);\n-      return expand_mult (mode, op0, op1, target, unsignedp);\n+      return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n     case TRUNC_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n@@ -7885,7 +7904,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t  ? negv_optab : neg_optab, op0, target, 0);\n       if (temp == 0)\n \tabort ();\n-      return temp;\n+      return REDUCE_BIT_FIELD (temp);\n \n     case ABS_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n@@ -8550,12 +8569,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n-      return expand_increment (exp, 0, ignore);\n+      return REDUCE_BIT_FIELD (expand_increment (exp, 0, ignore));\n \n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       /* Faster to treat as pre-increment if result is not used.  */\n-      return expand_increment (exp, ! ignore, ignore);\n+      return REDUCE_BIT_FIELD (expand_increment (exp, ! ignore, ignore));\n \n     case ADDR_EXPR:\n       if (modifier == EXPAND_STACK_PARM)\n@@ -8915,7 +8934,37 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t       unsignedp, OPTAB_LIB_WIDEN);\n   if (temp == 0)\n     abort ();\n-  return temp;\n+  return REDUCE_BIT_FIELD (temp);\n+}\n+#undef REDUCE_BIT_FIELD\n+\f\n+/* Subroutine of above: reduce EXP to the precision of TYPE (in the\n+   signedness of TYPE), possibly returning the result in TARGET.  */\n+static rtx\n+reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n+{\n+  HOST_WIDE_INT prec = TYPE_PRECISION (type);\n+  if (target && GET_MODE (target) != GET_MODE (exp))\n+    target = 0;\n+  if (TYPE_UNSIGNED (type))\n+    {\n+      rtx mask;\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tmask = immed_double_const (((unsigned HOST_WIDE_INT) 1 << prec) - 1, 0,\n+\t\t\t\t   GET_MODE (exp));\n+      else\n+\tmask = immed_double_const ((unsigned HOST_WIDE_INT) -1,\n+\t\t\t\t   ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t    << (prec - HOST_BITS_PER_WIDE_INT)) - 1,\n+\t\t\t\t   GET_MODE (exp));\n+      return expand_and (GET_MODE (exp), exp, mask, target);\n+    }\n+  else\n+    {\n+      tree count = build_int_2 (GET_MODE_BITSIZE (GET_MODE (exp)) - prec, 0);\n+      exp = expand_shift (LSHIFT_EXPR, GET_MODE (exp), exp, count, target, 0);\n+      return expand_shift (RSHIFT_EXPR, GET_MODE (exp), exp, count, target, 0);\n+    }\n }\n \f\n /* Subroutine of above: returns 1 if OFFSET corresponds to an offset that"}, {"sha": "85c77e585f184bc2b22e30c33e207630f7ddd4aa", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -116,6 +116,7 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n #define LANG_HOOKS_MAYBE_BUILD_CLEANUP\tlhd_return_null_tree\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n #define LANG_HOOKS_CAN_USE_BIT_FIELDS_P lhd_can_use_bit_fields_p\n+#define LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS false\n #define LANG_HOOKS_HONOR_READONLY\tfalse\n #define LANG_HOOKS_NO_BODY_BLOCKS\tfalse\n #define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n@@ -294,6 +295,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_MAYBE_BUILD_CLEANUP, \\\n   LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n   LANG_HOOKS_CAN_USE_BIT_FIELDS_P, \\\n+  LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS, \\\n   LANG_HOOKS_HONOR_READONLY, \\\n   LANG_HOOKS_NO_BODY_BLOCKS, \\\n   LANG_HOOKS_PRINT_STATISTICS, \\"}, {"sha": "4400aa3dc6f53d33a9348ea110384e5cd74c212b", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -347,6 +347,10 @@ struct lang_hooks\n      optimizations, for instance in fold_truthop().  */\n   bool (*can_use_bit_fields_p) (void);\n \n+  /* Nonzero if operations on types narrower than their mode should\n+     have their results reduced to the precision of the type.  */\n+  bool reduce_bit_field_operations;\n+\n   /* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */\n   bool honor_readonly;\n "}, {"sha": "308f2aca988b7f3893266bb3511e6ce59a817538", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -4257,6 +4257,16 @@ check_ivars (tree inter, tree imp)\n \n       t1 = TREE_TYPE (intdecls); t2 = TREE_TYPE (impdecls);\n \n+      if (TREE_VALUE (TREE_VALUE (rawimpdecls)))\n+\t{\n+\t  /* t1 is the bit-field type, so t2 must be converted to the\n+\t     bit-field type for comparison as well.  */\n+\t  unsigned HOST_WIDE_INT width\n+\t    = tree_low_cst (TREE_VALUE (TREE_VALUE (rawimpdecls)), 1);\n+\t  if (width != TYPE_PRECISION (t2))\n+\t    t2 = build_nonstandard_integer_type (width, TYPE_UNSIGNED (t2));\n+\t}\n+\n       if (!comptypes (t1, t2)\n \t  || !tree_int_cst_equal (TREE_VALUE (TREE_VALUE (rawintdecls)),\n \t\t\t\t  TREE_VALUE (TREE_VALUE (rawimpdecls))))"}, {"sha": "c5d099b63d3d34d89675e449fc8801c9ae237be2", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -71,6 +71,8 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL c_finish_incomplete_decl\n #undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n #define LANG_HOOKS_UNSAFE_FOR_REEVAL c_common_unsafe_for_reeval\n+#undef LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS\n+#define LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS true\n #undef LANG_HOOKS_STATICP\n #define LANG_HOOKS_STATICP c_staticp\n #undef LANG_HOOKS_NO_BODY_BLOCKS"}, {"sha": "54be7f9605d4f0ff3efef45ab0a90bbeccb184a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -1,3 +1,9 @@\n+2004-07-08  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.c-torture/execute/bitfld-1.x: Remove.\n+\t* gcc.c-torture/execute/bitfld-3.c: New test.\n+\t* gcc.dg/bitfld-2.c: Remove XFAILs.\n+\n 2004-07-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/16276"}, {"sha": "2f397b96e51b8dd77baecd30d403a01dfab48caf", "filename": "gcc/testsuite/gcc.c-torture/execute/bitfld-1.x", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942e59391c7a8ff8d57439229877257eb62b2eb0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942e59391c7a8ff8d57439229877257eb62b2eb0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.x?ref=942e59391c7a8ff8d57439229877257eb62b2eb0", "patch": "@@ -1,2 +0,0 @@\n-set torture_execute_xfail \"*-*-*\"\n-return 0"}, {"sha": "52a4147ccec11b0de0426488d54cc955f46f503a", "filename": "gcc/testsuite/gcc.c-torture/execute/bitfld-3.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-3.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -0,0 +1,54 @@\n+/* Test that operations on bit-fields yield results reduced to bit-field\n+   type.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+struct s {\n+  unsigned long long u33: 33;\n+  unsigned long long u40: 40;\n+  unsigned long long u41: 41;\n+};\n+\n+struct s a = { 0x100000, 0x100000, 0x100000 };\n+struct s b = { 0x100000000ULL, 0x100000000ULL, 0x100000000ULL };\n+struct s c = { 0x1FFFFFFFFULL, 0, 0 };\n+\n+int \n+main (void)\n+{\n+  if (a.u33 * a.u33 != 0 || a.u33 * a.u40 != 0 || a.u40 * a.u33 != 0\n+      || a.u40 * a.u40 != 0)\n+    abort ();\n+  if (a.u33 * a.u41 != 0x10000000000ULL\n+      || a.u40 * a.u41 != 0x10000000000ULL\n+      || a.u41 * a.u33 != 0x10000000000ULL\n+      || a.u41 * a.u40 != 0x10000000000ULL\n+      || a.u41 * a.u41 != 0x10000000000ULL)\n+    abort ();\n+  if (b.u33 + b.u33 != 0)\n+    abort ();\n+  if (b.u33 + b.u40 != 0x200000000ULL\n+      || b.u33 + b.u41 != 0x200000000ULL\n+      || b.u40 + b.u33 != 0x200000000ULL\n+      || b.u40 + b.u40 != 0x200000000ULL\n+      || b.u40 + b.u41 != 0x200000000ULL\n+      || b.u41 + b.u33 != 0x200000000ULL\n+      || b.u41 + b.u40 != 0x200000000ULL\n+      || b.u41 + b.u41 != 0x200000000ULL)\n+    abort ();\n+  if (a.u33 - b.u33 != 0x100100000ULL\n+      || a.u33 - b.u40 != 0xFF00100000ULL\n+      || a.u33 - b.u41 != 0x1FF00100000ULL\n+      || a.u40 - b.u33 != 0xFF00100000ULL\n+      || a.u40 - b.u40 != 0xFF00100000ULL\n+      || a.u40 - b.u41 != 0x1FF00100000ULL\n+      || a.u41 - b.u33 != 0x1FF00100000ULL\n+      || a.u41 - b.u40 != 0x1FF00100000ULL\n+      || a.u41 - b.u41 != 0x1FF00100000ULL)\n+    abort ();\n+  if (++c.u33 != 0 || --c.u40 != 0xFFFFFFFFFFULL || c.u41-- != 0)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "b61fec6084192271aa01d3051215ca5d550f2063", "filename": "gcc/testsuite/gcc.dg/bitfld-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -11,13 +11,13 @@ struct bf\n   int b: 2;\n };\n \n-struct bf p = {4, 0};\t\t/* { dg-warning \"truncated\" \"\" { xfail *-*-* } } */\n-struct bf q = {0, 2};\t\t/* { dg-warning \"overflow\" \"\" { xfail *-*-* } } */\n+struct bf p = {4, 0};\t\t/* { dg-warning \"truncated\" \"\" } */\n+struct bf q = {0, 2};\t\t/* { dg-warning \"overflow\" \"\" } */\n struct bf r = {3, -2};\t\t/* { dg-bogus \"(truncated|overflow)\" } */\n \n void foo ()\n {\n-  p.a = 4, p.b = 0;\t\t/* { dg-warning \"truncated\" \"\" { xfail *-*-* } } */\n-  q.a = 0, q.b = 2;\t\t/* { dg-warning \"overflow\" \"\" { xfail *-*-* } } */\n+  p.a = 4, p.b = 0;\t\t/* { dg-warning \"truncated\" \"\" } */\n+  q.a = 0, q.b = 2;\t\t/* { dg-warning \"overflow\" \"\" } */\n   r.a = 3, r.b = -2;\t\t/* { dg-bogus \"(truncated|overflow)\" } */\n }"}, {"sha": "ad1c1745c145626b0b91ea5e9a3ae2bdb3494e2b", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -572,17 +572,22 @@ tree_ssa_useless_type_conversion_1 (tree outer_type, tree inner_type)\n \n   /* If both the inner and outer types are integral types, then the\n      conversion is not necessary if they have the same mode and\n-     signedness and precision.  Note that type _Bool can have size of\n-     4 (only happens on powerpc-darwin right now but can happen on any\n-     target that defines BOOL_TYPE_SIZE to be INT_TYPE_SIZE) and a\n-     precision of 1 while unsigned int is the same expect for a\n-     precision of 4 so testing of precision is necessary.  */\n+     signedness and precision, and both or neither are boolean.  Some\n+     code assumes an invariant that boolean types stay boolean and do\n+     not become 1-bit bit-field types.  Note that types with precision\n+     not using all bits of the mode (such as bit-field types in C)\n+     mean that testing of precision is necessary.  */\n   else if (INTEGRAL_TYPE_P (inner_type)\n            && INTEGRAL_TYPE_P (outer_type)\n \t   && TYPE_MODE (inner_type) == TYPE_MODE (outer_type)\n \t   && TYPE_UNSIGNED (inner_type) == TYPE_UNSIGNED (outer_type)\n \t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type))\n-    return true;\n+    {\n+      bool first_boolean = (TREE_CODE (inner_type) == BOOLEAN_TYPE);\n+      bool second_boolean = (TREE_CODE (outer_type) == BOOLEAN_TYPE);\n+      if (first_boolean == second_boolean)\n+\treturn true;\n+    }\n \n   /* Recurse for complex types.  */\n   else if (TREE_CODE (inner_type) == COMPLEX_TYPE"}, {"sha": "3804d37cb44d7330878e81f3ca9ace04f4182511", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -4133,6 +4133,28 @@ build_index_type (tree maxval)\n     return itype;\n }\n \n+/* Builds a signed or unsigned integer type of precision PRECISION.\n+   Used for C bitfields whose precision does not match that of\n+   built-in target types.  */\n+tree\n+build_nonstandard_integer_type (unsigned HOST_WIDE_INT precision,\n+\t\t\t\tint unsignedp)\n+{\n+  tree itype = make_node (INTEGER_TYPE);\n+\n+  TYPE_PRECISION (itype) = precision;\n+\n+  if (unsignedp)\n+    fixup_unsigned_type (itype);\n+  else\n+    fixup_signed_type (itype);\n+\n+  if (host_integerp (TYPE_MAX_VALUE (itype), 1))\n+    return type_hash_canon (tree_low_cst (TYPE_MAX_VALUE (itype), 1), itype);\n+\n+  return itype;\n+}\n+\n /* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n    ENUMERAL_TYPE, BOOLEAN_TYPE, or CHAR_TYPE), with\n    low bound LOWVAL and high bound HIGHVAL."}, {"sha": "74cf79e6cbc436434f553450a6d91cf965474d7f", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc15d0efe4230e2f3636dc5255c331232211fb44/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bc15d0efe4230e2f3636dc5255c331232211fb44", "patch": "@@ -3472,6 +3472,7 @@ extern int real_minus_onep (tree);\n extern void init_ttree (void);\n extern void build_common_tree_nodes (int);\n extern void build_common_tree_nodes_2 (int);\n+extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n \n /* In function.c */"}]}