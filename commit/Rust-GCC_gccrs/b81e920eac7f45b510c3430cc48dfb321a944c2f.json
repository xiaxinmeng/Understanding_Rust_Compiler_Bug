{"sha": "b81e920eac7f45b510c3430cc48dfb321a944c2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxZTkyMGVhYzdmNDViNTEwYzM0MzBjYzQ4ZGZiMzIxYTk0NGMyZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-10-24T23:26:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-10-24T23:26:25Z"}, "message": "re PR libstdc++/49894 ([C++0x] Uniform initialization in constructor)\n\n\tPR libstdc++/49894\n\t* include/std/mutex (__mutex_base,__recursive_mutex_base): Define new\n\tbase classes to manage construction/destruction of native mutexes,\n\tusing NSDMI when INIT macros are defined.\n\t(mutex,recursive_mutex,timed_mutex,recursive_timed_mutex): Derive from\n\tnew base classes.\n\t* include/std/condition_variable (condition_variable): Use NSDMI when\n\tINIT macro is defined. Use noexcept.\n\t* src/condition_variable.cc (condition_variable): Explicitly-default\n\tconstructor/destructor when using NSDMI. Use noexcept.\n\t(condition_variable_any): Likewise.\n\nFrom-SVN: r180411", "tree": {"sha": "e3d52074dedc82f0f2c8c9061b21d1667c769f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3d52074dedc82f0f2c8c9061b21d1667c769f01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b81e920eac7f45b510c3430cc48dfb321a944c2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81e920eac7f45b510c3430cc48dfb321a944c2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81e920eac7f45b510c3430cc48dfb321a944c2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81e920eac7f45b510c3430cc48dfb321a944c2f/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca3f03dfe3b3ab4d06353e541e17daa700f019c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca3f03dfe3b3ab4d06353e541e17daa700f019c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca3f03dfe3b3ab4d06353e541e17daa700f019c"}], "stats": {"total": 258, "additions": 138, "deletions": 120}, "files": [{"sha": "a7d5335b51aab7d595bfb4f8b4cde7fcbdbf8468", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b81e920eac7f45b510c3430cc48dfb321a944c2f", "patch": "@@ -1,3 +1,17 @@\n+2011-10-25  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/49894\n+\t* include/std/mutex (__mutex_base,__recursive_mutex_base): Define new\n+\tbase classes to manage construction/destruction of native mutexes,\n+\tusing NSDMI when INIT macros are defined.\n+\t(mutex,recursive_mutex,timed_mutex,recursive_timed_mutex): Derive from\n+\tnew base classes.\n+\t* include/std/condition_variable (condition_variable): Use NSDMI when\n+\tINIT macro is defined. Use noexcept.\n+\t* src/condition_variable.cc (condition_variable): Explicitly-default\n+\tconstructor/destructor when using NSDMI. Use noexcept.\n+\t(condition_variable_any): Likewise.\n+\n 2011-10-24  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* testsuite/30_threads/async/49668.cc: Add missing dg-require."}, {"sha": "ef22a1dbf02f40e3fb8be57489ca02174336aee4", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=b81e920eac7f45b510c3430cc48dfb321a944c2f", "patch": "@@ -60,22 +60,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n     typedef chrono::system_clock\t__clock_t;\n     typedef __gthread_cond_t\t\t__native_type;\n+\n+#ifdef __GTHREAD_COND_INIT\n+    __native_type\t\t\t_M_cond = __GTHREAD_COND_INIT;\n+#else\n     __native_type\t\t\t_M_cond;\n+#endif\n \n   public:\n     typedef __native_type* \t\tnative_handle_type;\n \n-    condition_variable() throw ();\n-    ~condition_variable() throw ();\n+    condition_variable() noexcept;\n+    ~condition_variable() noexcept;\n \n     condition_variable(const condition_variable&) = delete;\n     condition_variable& operator=(const condition_variable&) = delete;\n \n     void\n-    notify_one();\n+    notify_one() noexcept;\n \n     void\n-    notify_all();\n+    notify_all() noexcept;\n \n     void\n     wait(unique_lock<mutex>& __lock);\n@@ -174,21 +179,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   public:\n     typedef condition_variable::native_handle_type\tnative_handle_type;\n \n-    condition_variable_any() throw ();\n-    ~condition_variable_any() throw ();\n+    condition_variable_any() noexcept;\n+    ~condition_variable_any() noexcept;\n \n     condition_variable_any(const condition_variable_any&) = delete;\n     condition_variable_any& operator=(const condition_variable_any&) = delete;\n \n     void\n-    notify_one()\n+    notify_one() noexcept\n     {\n       lock_guard<mutex> __lock(_M_mutex);\n       _M_cond.notify_one();\n     }\n \n     void\n-    notify_all()\n+    notify_all() noexcept\n     {\n       lock_guard<mutex> __lock(_M_mutex);\n       _M_cond.notify_all();"}, {"sha": "4d154ff6f0c4c37bae2d3f031540d080b05f39a3", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 101, "deletions": 100, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=b81e920eac7f45b510c3430cc48dfb321a944c2f", "patch": "@@ -52,6 +52,94 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  // Common base class for std::mutex and std::timed_mutex\n+  class __mutex_base\n+  {\n+  protected:\n+    typedef __gthread_mutex_t\t\t\t__native_type;\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+    __native_type  _M_mutex = __GTHREAD_MUTEX_INIT;\n+\n+    constexpr __mutex_base() noexcept = default;\n+#else\n+    __native_type  _M_mutex;\n+\n+    __mutex_base() noexcept\n+    {\n+      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n+      __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);\n+    }\n+\n+    ~__mutex_base() { __gthread_mutex_destroy(&_M_mutex); }\n+#endif\n+\n+    __mutex_base(const __mutex_base&) = delete;\n+    __mutex_base& operator=(const __mutex_base&) = delete;\n+  };\n+\n+  // Common base class for std::recursive_mutex and std::timed_recursive_mutex\n+  class __recursive_mutex_base\n+  {\n+  protected:\n+    typedef __gthread_recursive_mutex_t\t\t__native_type;\n+\n+    __recursive_mutex_base(const __recursive_mutex_base&) = delete;\n+    __recursive_mutex_base& operator=(const __recursive_mutex_base&) = delete;\n+\n+#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT\n+    __native_type  _M_mutex = __GTHREAD_RECURSIVE_MUTEX_INIT;\n+\n+    __recursive_mutex_base() = default;\n+#else\n+    __native_type  _M_mutex;\n+\n+    __recursive_mutex_base()\n+    {\n+      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n+      __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);\n+    }\n+\n+    ~__recursive_mutex_base()\n+    { _S_destroy(&_M_mutex); }\n+\n+  private:\n+    // FIXME: gthreads doesn't define __gthread_recursive_mutex_destroy\n+    // so we need to obtain a __gthread_mutex_t to destroy\n+\n+    // matches when there's only one mutex type\n+    template<typename _Rm>\n+      static\n+      typename enable_if<is_same<_Rm, __gthread_mutex_t>::value, void>::type\n+      _S_destroy(_Rm* __mx)\n+      { __gthread_mutex_destroy(__mx); }\n+\n+    // matches a recursive mutex with a member 'actual'\n+    template<typename _Rm>\n+      static typename enable_if<sizeof(&_Rm::actual), void>::type\n+      _S_destroy(_Rm* __mx)\n+      { __gthread_mutex_destroy(&__mx->actual); }\n+\n+    // matches a gthr-win32.h recursive mutex\n+    template<typename _Rm>\n+      static typename enable_if<sizeof(&_Rm::sema), void>::type\n+      _S_destroy(_Rm* __mx)\n+      {\n+        __gthread_mutex_t __tmp;\n+        _S_destroy_win32(&__tmp, __mx);\n+      }\n+\n+    template<typename _Mx, typename _Rm>\n+      static void\n+      _S_destroy_win32(_Mx* __mx, _Rm const* __rmx)\n+      {\n+        __mx->counter = __rmx->counter;\n+        __mx->sema = __rmx->sema;\n+        __gthread_mutex_destroy(__mx);\n+      }\n+#endif\n+  };\n+\n   /**\n    * @defgroup mutexes Mutexes\n    * @ingroup concurrency\n@@ -61,25 +149,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   /// mutex\n-  class mutex\n+  class mutex : private __mutex_base\n   {\n-    typedef __gthread_mutex_t\t\t\t__native_type;\n-    __native_type  _M_mutex;\n-\n   public:\n     typedef __native_type* \t\t\tnative_handle_type;\n \n #ifdef __GTHREAD_MUTEX_INIT\n-    constexpr mutex() noexcept : _M_mutex(__GTHREAD_MUTEX_INIT) { }\n-#else\n-    mutex() noexcept\n-    {\n-      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n-      __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);\n-    }\n-\n-    ~mutex() { __gthread_mutex_destroy(&_M_mutex); }\n+    constexpr\n #endif\n+    mutex() noexcept = default;\n+    ~mutex() = default;\n \n     mutex(const mutex&) = delete;\n     mutex& operator=(const mutex&) = delete;\n@@ -113,66 +192,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return &_M_mutex; }\n   };\n \n-#ifndef __GTHREAD_RECURSIVE_MUTEX_INIT\n-  // FIXME: gthreads doesn't define __gthread_recursive_mutex_destroy\n-  // so we need to obtain a __gthread_mutex_t to destroy\n-  class __destroy_recursive_mutex\n-  {\n-    template<typename _Mx, typename _Rm>\n-      static void\n-      _S_destroy_win32(_Mx* __mx, _Rm const* __rmx)\n-      {\n-        __mx->counter = __rmx->counter;\n-        __mx->sema = __rmx->sema;\n-        __gthread_mutex_destroy(__mx);\n-      }\n-\n-  public:\n-    // matches a gthr-win32.h recursive mutex\n-    template<typename _Rm>\n-      static typename enable_if<sizeof(&_Rm::sema), void>::type\n-      _S_destroy(_Rm* __mx)\n-      {\n-        __gthread_mutex_t __tmp;\n-        _S_destroy_win32(&__tmp, __mx);\n-      }\n-\n-    // matches a recursive mutex with a member 'actual'\n-    template<typename _Rm>\n-      static typename enable_if<sizeof(&_Rm::actual), void>::type\n-      _S_destroy(_Rm* __mx)\n-      { __gthread_mutex_destroy(&__mx->actual); }\n-\n-    // matches when there's only one mutex type\n-    template<typename _Rm>\n-      static\n-      typename enable_if<is_same<_Rm, __gthread_mutex_t>::value, void>::type\n-      _S_destroy(_Rm* __mx)\n-      { __gthread_mutex_destroy(__mx); }\n-  };\n-#endif\n-\n   /// recursive_mutex\n-  class recursive_mutex\n+  class recursive_mutex : private __recursive_mutex_base\n   {\n-    typedef __gthread_recursive_mutex_t\t\t__native_type;\n-    __native_type  _M_mutex;\n-\n   public:\n     typedef __native_type* \t\t\tnative_handle_type;\n \n-#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT\n-    recursive_mutex() : _M_mutex(__GTHREAD_RECURSIVE_MUTEX_INIT) { }\n-#else\n-    recursive_mutex()\n-    {\n-      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n-      __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);\n-    }\n-\n-    ~recursive_mutex()\n-    { __destroy_recursive_mutex::_S_destroy(&_M_mutex); }\n-#endif\n+    recursive_mutex() = default;\n+    ~recursive_mutex() = default;\n \n     recursive_mutex(const recursive_mutex&) = delete;\n     recursive_mutex& operator=(const recursive_mutex&) = delete;\n@@ -208,31 +235,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if _GTHREAD_USE_MUTEX_TIMEDLOCK\n   /// timed_mutex\n-  class timed_mutex\n+  class timed_mutex : private __mutex_base\n   {\n-    typedef __gthread_mutex_t \t\t  \t__native_type;\n-\n #ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n     typedef chrono::steady_clock \t  \t__clock_t;\n #else\n     typedef chrono::high_resolution_clock \t__clock_t;\n #endif\n \n-    __native_type  _M_mutex;\n-\n   public:\n     typedef __native_type* \t\t  \tnative_handle_type;\n \n-#ifdef __GTHREAD_MUTEX_INIT\n-    timed_mutex() : _M_mutex(__GTHREAD_MUTEX_INIT) { }\n-#else\n-    timed_mutex()\n-    {\n-      __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);\n-    }\n-\n-    ~timed_mutex() { __gthread_mutex_destroy(&_M_mutex); }\n-#endif\n+    timed_mutex() = default;\n+    ~timed_mutex() = default;\n \n     timed_mutex(const timed_mutex&) = delete;\n     timed_mutex& operator=(const timed_mutex&) = delete;\n@@ -313,33 +328,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n \n   /// recursive_timed_mutex\n-  class recursive_timed_mutex\n+  class recursive_timed_mutex : private __recursive_mutex_base\n   {\n-    typedef __gthread_recursive_mutex_t\t\t__native_type;\n-\n #ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n     typedef chrono::steady_clock \t\t__clock_t;\n #else\n     typedef chrono::high_resolution_clock \t__clock_t;\n #endif\n \n-    __native_type  _M_mutex;\n-\n   public:\n     typedef __native_type* \t\t\tnative_handle_type;\n \n-#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT\n-    recursive_timed_mutex() : _M_mutex(__GTHREAD_RECURSIVE_MUTEX_INIT) { }\n-#else\n-    recursive_timed_mutex()\n-    {\n-      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)\n-      __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);\n-    }\n-\n-    ~recursive_timed_mutex()\n-    { __destroy_recursive_mutex::_S_destroy(&_M_mutex); }\n-#endif\n+    recursive_timed_mutex() = default;\n+    ~recursive_timed_mutex() = default;\n \n     recursive_timed_mutex(const recursive_timed_mutex&) = delete;\n     recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;"}, {"sha": "6f9cd0b04b0c1df659cc2300d368a1b0a3071202", "filename": "libstdc++-v3/src/condition_variable.cc", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2Fsrc%2Fcondition_variable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81e920eac7f45b510c3430cc48dfb321a944c2f/libstdc%2B%2B-v3%2Fsrc%2Fcondition_variable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcondition_variable.cc?ref=b81e920eac7f45b510c3430cc48dfb321a944c2f", "patch": "@@ -30,25 +30,25 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  condition_variable::condition_variable() throw ()\n-  {\n #ifdef __GTHREAD_COND_INIT\n-    __native_type __tmp = __GTHREAD_COND_INIT;\n-    _M_cond = __tmp;\n+  condition_variable::condition_variable() = default;\n+  condition_variable::~condition_variable() = default;\n #else\n+  condition_variable::condition_variable() noexcept\n+  {\n     int __e = __gthread_cond_init(&_M_cond, 0);\n \n     if (__e)\n       __throw_system_error(__e);\n-#endif\n   }\n \n-  condition_variable::~condition_variable() throw ()\n+  condition_variable::~condition_variable() noexcept\n   {\n     // XXX no thread blocked\n     /* int __e = */ __gthread_cond_destroy(&_M_cond);\n     // if __e == EBUSY then blocked\n   }\n+#endif\n \n   void\n   condition_variable::wait(unique_lock<mutex>& __lock)\n@@ -60,7 +60,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   }\n \n   void\n-  condition_variable::notify_one()\n+  condition_variable::notify_one() noexcept\n   {\n     int __e = __gthread_cond_signal(&_M_cond);\n \n@@ -71,7 +71,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   }\n \n   void\n-  condition_variable::notify_all()\n+  condition_variable::notify_all() noexcept\n   {\n     int __e = __gthread_cond_broadcast(&_M_cond);\n \n@@ -81,11 +81,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __throw_system_error(__e);\n   }\n \n-  condition_variable_any::condition_variable_any() throw ()\n-  { }\n+  condition_variable_any::condition_variable_any() noexcept = default;\n \n-  condition_variable_any::~condition_variable_any() throw ()\n-  { }\n+  condition_variable_any::~condition_variable_any() noexcept = default;\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}]}