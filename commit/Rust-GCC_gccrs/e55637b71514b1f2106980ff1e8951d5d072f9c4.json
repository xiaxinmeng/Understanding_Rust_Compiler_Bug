{"sha": "e55637b71514b1f2106980ff1e8951d5d072f9c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU1NjM3YjcxNTE0YjFmMjEwNjk4MGZmMWU4OTUxZDVkMDcyZjljNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-07-01T06:45:26Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-07-01T06:45:26Z"}, "message": "IPA REF alias refactoring\n\n\t* cgraph.h (iterate_direct_aliases): New function.\n\t(FOR_EACH_ALIAS): New macro iterates all direct aliases for a node.\n\t* cgraph.c (cgraph_for_node_thunks_and_aliases): Usage of\n\tFOR_EACH_ALIAS added.\n\t(cgraph_for_node_and_aliases): Likewise.\n\t* cgraphunit.c (assemble_thunks_and_aliases): Likewise.\n\t* ipa-inline.c (reset_edge_caches): Likewise.\n\t(update_caller_keys): Likewise.\n\t* trans-mem.c (ipa_tm_execute): Likewise.\n\t*varpool.c (varpool_analyze_node): Likewise.\n\t(varpool_for_node_and_aliases): Likewise.\n\t* ipa-ref.h (first_alias): New function.\n\t(last_alias): Likewise.\n\t(has_aliases_p): Likewise.\n\t* ipa-ref.c (ipa_ref::remove_reference): Removal function\n\tis sensitive to IPA_REF_ALIASes.\n\t* symtab.c (symtab_node::add_reference): Node of IPA_REF_ALIAS type\n\tare put at the beginning of the list.\n\t(symtab_node::iterate_direct_aliases): New function.\n\n\t* lto-partition.c (add_symbol_to_partition_1): Usage of\n\tFOR_EACH_ALIAS added.\n\nFrom-SVN: r212191", "tree": {"sha": "affefec9f6097f6b283af2e7be5845ea0dd4ba45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/affefec9f6097f6b283af2e7be5845ea0dd4ba45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e55637b71514b1f2106980ff1e8951d5d072f9c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55637b71514b1f2106980ff1e8951d5d072f9c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e55637b71514b1f2106980ff1e8951d5d072f9c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55637b71514b1f2106980ff1e8951d5d072f9c4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "705c7d57092b46dc4ea6bba7e60823f828250488", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705c7d57092b46dc4ea6bba7e60823f828250488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705c7d57092b46dc4ea6bba7e60823f828250488"}], "stats": {"total": 278, "additions": 189, "deletions": 89}, "files": [{"sha": "f5a242641a8ce25db7b7daa718270311bfa9c19b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -1,3 +1,26 @@\n+2014-07-01  Martin Liska  <mliska@suse.cz>\n+\n+\tIPA REF alias refactoring\n+\t* cgraph.h (iterate_direct_aliases): New function.\n+\t(FOR_EACH_ALIAS): New macro iterates all direct aliases for a node.\n+\t* cgraph.c (cgraph_for_node_thunks_and_aliases): Usage of\n+\tFOR_EACH_ALIAS added.\n+\t(cgraph_for_node_and_aliases): Likewise.\n+\t* cgraphunit.c (assemble_thunks_and_aliases): Likewise.\n+\t* ipa-inline.c (reset_edge_caches): Likewise.\n+\t(update_caller_keys): Likewise.\n+\t* trans-mem.c (ipa_tm_execute): Likewise.\n+\t*varpool.c (varpool_analyze_node): Likewise.\n+\t(varpool_for_node_and_aliases): Likewise.\n+\t* ipa-ref.h (first_alias): New function.\n+\t(last_alias): Likewise.\n+\t(has_aliases_p): Likewise.\n+\t* ipa-ref.c (ipa_ref::remove_reference): Removal function\n+\tis sensitive to IPA_REF_ALIASes.\n+\t* symtab.c (symtab_node::add_reference): Node of IPA_REF_ALIAS type\n+\tare put at the beginning of the list.\n+\t(symtab_node::iterate_direct_aliases): New function.\n+\n 2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \tRevert:"}, {"sha": "41dcaf9e4a18168f523c205f23f943e3162e814c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -2198,8 +2198,7 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n \t\t\t\t    bool include_overwritable)\n {\n   struct cgraph_edge *e;\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n   if (callback (node, data))\n     return true;\n@@ -2210,16 +2209,16 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n       if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n \t\t\t\t\t      include_overwritable))\n \treturn true;\n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-\tif (include_overwritable\n-\t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n-\t  if (cgraph_for_node_thunks_and_aliases (alias, callback, data,\n-\t\t\t\t\t\t  include_overwritable))\n-\t    return true;\n-      }\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      if (include_overwritable\n+\t  || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n+\tif (cgraph_for_node_thunks_and_aliases (alias, callback, data,\n+\t\t\t\t\t\tinclude_overwritable))\n+\t  return true;\n+    }\n   return false;\n }\n \n@@ -2233,21 +2232,20 @@ cgraph_for_node_and_aliases (struct cgraph_node *node,\n \t\t\t     void *data,\n \t\t\t     bool include_overwritable)\n {\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-\tif (include_overwritable\n-\t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n-          if (cgraph_for_node_and_aliases (alias, callback, data,\n-\t\t\t\t\t   include_overwritable))\n-\t    return true;\n-      }\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      if (include_overwritable\n+\t  || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n+\tif (cgraph_for_node_and_aliases (alias, callback, data,\n+\t\t\t\t\t include_overwritable))\n+\t  return true;\n+    }\n   return false;\n }\n "}, {"sha": "3ab051615e3b55cbd9f1b30e75e802a71fde93fc", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -254,6 +254,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Iterates I-th referring item in the list, REF is also set.  */\n   struct ipa_ref *iterate_referring (unsigned i, struct ipa_ref *&ref);\n \n+  /* Iterates I-th referring alias item in the list, REF is also set.  */\n+  struct ipa_ref *iterate_direct_aliases (unsigned i, struct ipa_ref *&ref);\n+\n   /* Vectors of referring and referenced entities.  */\n   struct ipa_ref_list ref_list;\n \n@@ -281,6 +284,10 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   priority_type get_init_priority ();\n };\n \n+/* Walk all aliases for NODE.  */\n+#define FOR_EACH_ALIAS(node, alias) \\\n+   for (unsigned x_i = 0; node->iterate_direct_aliases (x_i, alias); x_i++)\n+\n enum availability\n {\n   /* Not yet set by cgraph_function_body_availability.  */"}, {"sha": "f7980ed51151bbcaef689d0ad6d49571c5289476", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -1711,8 +1711,7 @@ static void\n assemble_thunks_and_aliases (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n   for (e = node->callers; e;)\n     if (e->caller->thunk.thunk_p)\n@@ -1725,20 +1724,20 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n       }\n     else\n       e = e->next_caller;\n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-        bool saved_written = TREE_ASM_WRITTEN (node->decl);\n-\n-\t/* Force assemble_alias to really output the alias this time instead\n-\t   of buffering it in same alias pairs.  */\n-\tTREE_ASM_WRITTEN (node->decl) = 1;\n-\tdo_assemble_alias (alias->decl,\n-\t\t\t   DECL_ASSEMBLER_NAME (node->decl));\n-\tassemble_thunks_and_aliases (alias);\n-\tTREE_ASM_WRITTEN (node->decl) = saved_written;\n-      }\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      bool saved_written = TREE_ASM_WRITTEN (node->decl);\n+\n+      /* Force assemble_alias to really output the alias this time instead\n+\t of buffering it in same alias pairs.  */\n+      TREE_ASM_WRITTEN (node->decl) = 1;\n+      do_assemble_alias (alias->decl,\n+\t\t\t DECL_ASSEMBLER_NAME (node->decl));\n+      assemble_thunks_and_aliases (alias);\n+      TREE_ASM_WRITTEN (node->decl) = saved_written;\n+    }\n }\n \n /* Expand function specified by NODE.  */"}, {"sha": "c4095ec9b4fd50514d552960e03521e6b57d1ecf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -1119,8 +1119,7 @@ reset_edge_caches (struct cgraph_node *node)\n   struct cgraph_edge *edge;\n   struct cgraph_edge *e = node->callees;\n   struct cgraph_node *where = node;\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n   if (where->global.inlined_to)\n     where = where->global.inlined_to;\n@@ -1131,9 +1130,9 @@ reset_edge_caches (struct cgraph_node *node)\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n-  for (i = 0; where->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      reset_edge_caches (dyn_cast <cgraph_node *> (ref->referring));\n+\n+  FOR_EACH_ALIAS (where, ref)\n+    reset_edge_caches (dyn_cast <cgraph_node *> (ref->referring));\n \n   if (!e)\n     return;\n@@ -1172,21 +1171,19 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t    struct cgraph_edge *check_inlinablity_for)\n {\n   struct cgraph_edge *edge;\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n   if ((!node->alias && !inline_summary (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n \n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-        update_caller_keys (heap, alias, updated_nodes, check_inlinablity_for);\n-      }\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      update_caller_keys (heap, alias, updated_nodes, check_inlinablity_for);\n+    }\n \n   for (edge = node->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)"}, {"sha": "3c1001102bbfcbb95c339151e2df8e8270f46ee9", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -38,12 +38,33 @@ ipa_ref::remove_reference ()\n   struct ipa_ref *last;\n \n   gcc_assert (list->referring[referred_index] == this);\n+\n   last = list->referring.last ();\n   if (this != last)\n     {\n+      if (use == IPA_REF_ALIAS)\n+        {\n+\t  /* If deleted item is IPA_REF_ALIAS, we have to move last\n+\t  item of IPA_REF_LIST type to the deleted position. After that\n+\t  we replace last node with deletion slot.  */\n+\t  struct ipa_ref *last_alias = list->last_alias ();\n+\n+\t  if (last_alias && referred_index < last_alias->referred_index\n+\t      && last_alias != last)\n+\t  {\n+\t    unsigned last_alias_index = last_alias->referred_index;\n+\n+\t    list->referring[referred_index] = last_alias;\n+\t    list->referring[referred_index]->referred_index = referred_index;\n+\n+\t    /* New position for replacement is previous index\n+\t       of the last_alias.  */\n+\t    referred_index = last_alias_index;\n+\t  }\n+\t}\n+\n       list->referring[referred_index] = list->referring.last ();\n-      list->referring[referred_index]->referred_index\n-\t  = referred_index;\n+      list->referring[referred_index]->referred_index= referred_index;\n     }\n   list->referring.pop ();\n \n@@ -54,7 +75,7 @@ ipa_ref::remove_reference ()\n   if (ref != last)\n     {\n       *ref = *last;\n-      referred_ref_list ()->referring[referred_index] = ref;\n+      ref->referred_ref_list ()->referring[referred_index] = ref;\n     }\n   list2->references->pop ();\n   gcc_assert (list2->references == old_references);"}, {"sha": "b8b1f9e4216c920d152cac3878caba85861c09da", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -82,6 +82,32 @@ struct GTY(()) ipa_ref_list\n     return referring[0];\n   }\n \n+  /* Return first referring alias.  */\n+  struct ipa_ref *first_alias (void)\n+  {\n+    struct ipa_ref *r = first_referring ();\n+\n+    return r && r->use == IPA_REF_ALIAS ? r : NULL;\n+  }\n+\n+  /* Return last referring alias.  */\n+  struct ipa_ref *last_alias (void)\n+  {\n+    unsigned int i = 0;\n+\n+    for(i = 0; i < referring.length (); i++)\n+      if (referring[i]->use != IPA_REF_ALIAS)\n+\tbreak;\n+\n+    return i == 0 ? NULL : referring[i - 1];\n+  }\n+\n+  /* Return true if the symbol has an alias.  */\n+  bool inline has_aliases_p (void)\n+  {\n+    return first_alias ();\n+  }\n+\n   /* Clear reference list.  */\n   void clear (void)\n   {"}, {"sha": "78e32edaf95ad63cca1c6d484f6d622ed2a5cb52", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -1,3 +1,9 @@\n+2014-07-01  Martin Liska  <mliska@suse.cz>\n+\n+\tIPA REF alias refactoring\n+\t* lto-partition.c (add_symbol_to_partition_1): Usage of\n+\tFOR_EACH_ALIAS added.\n+\n 2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \tRevert:"}, {"sha": "944943cf1cc579037f2b867fe0a2607ba345afa2", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -113,8 +113,7 @@ static bool\n add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n {\n   enum symbol_partitioning_class c = symtab_get_symbol_partitioning_class (node);\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n   symtab_node *node1;\n \n   /* If NODE is already there, we have nothing to do.  */\n@@ -168,8 +167,9 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n   add_references_to_partition (part, node);\n \n   /* Add all aliases associated with the symbol.  */\n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS && !node->weakref)\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    if (!node->weakref)\n       add_symbol_to_partition_1 (part, ref->referring);\n \n   /* Ensure that SAME_COMDAT_GROUP lists all allways added in a group.  */"}, {"sha": "80ea94abbd3844d121e0721214157620cb9481dc", "filename": "gcc/symtab.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -558,8 +558,22 @@ symtab_node::add_reference (symtab_node *referred_node,\n   ref = &list->references->last ();\n \n   list2 = &referred_node->ref_list;\n-  list2->referring.safe_push (ref);\n-  ref->referred_index = list2->referring.length () - 1;\n+\n+  /* IPA_REF_ALIAS is always inserted at the beginning of the list.   */\n+  if(use_type == IPA_REF_ALIAS)\n+  {\n+    list2->referring.safe_insert (0, ref);\n+    ref->referred_index = 0;\n+\n+    for (unsigned int i = 1; i < list2->referring.length (); i++)\n+      list2->referring[i]->referred_index = i;\n+  }\n+  else\n+  {\n+    list2->referring.safe_push (ref);\n+    ref->referred_index = list2->referring.length () - 1;\n+  }\n+\n   ref->referring = this;\n   ref->referred = referred_node;\n   ref->stmt = stmt;\n@@ -796,6 +810,20 @@ symtab_node::iterate_referring (unsigned i, struct ipa_ref *&ref)\n   return ref;\n }\n \n+/* Iterates I-th referring alias item in the list, REF is also set.  */\n+\n+struct ipa_ref *\n+symtab_node::iterate_direct_aliases (unsigned i, struct ipa_ref *&ref)\n+{\n+  ref_list.referring.iterate (i, &ref);\n+\n+  if (ref && ref->use != IPA_REF_ALIAS)\n+    return NULL;\n+\n+  return ref;\n+}\n+\n+\n static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\"};\n \n /* Dump base fields of symtab nodes.  Not to be used directly.  */"}, {"sha": "12c0b3579b18e9f61ca6e647b20ce96f5aa76b38", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -5439,8 +5439,7 @@ ipa_tm_execute (void)\n     {\n       struct cgraph_node *caller;\n       struct cgraph_edge *e;\n-      struct ipa_ref *ref = NULL;\n-      unsigned j;\n+      struct ipa_ref *ref;\n \n       if (i > 256 && i == irr_worklist.length () / 8)\n \t{\n@@ -5466,11 +5465,10 @@ ipa_tm_execute (void)\n \t}\n \n       /* Propagate back to referring aliases as well.  */\n-      for (j = 0; node->iterate_referring (j, ref); j++)\n+      FOR_EACH_ALIAS (node, ref)\n \t{\n \t  caller = cgraph (ref->referring);\n-\t  if (ref->use == IPA_REF_ALIAS\n-\t      && !caller->local.tm_may_enter_irr)\n+\t  if (!caller->local.tm_may_enter_irr)\n \t    {\n \t      /* ?? Do not traverse aliases here.  */\n \t      d = get_cg_data (&caller, false);"}, {"sha": "79f07bfd2ff3abbcfa6b53a3444fc29feff654d0", "filename": "gcc/varpool.c", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55637b71514b1f2106980ff1e8951d5d072f9c4/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=e55637b71514b1f2106980ff1e8951d5d072f9c4", "patch": "@@ -424,17 +424,15 @@ varpool_analyze_node (varpool_node *node)\n static void\n assemble_aliases (varpool_node *node)\n {\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tvarpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n-\tdo_assemble_alias (alias->decl,\n-\t\t\t   DECL_ASSEMBLER_NAME (node->decl));\n-\tassemble_aliases (alias);\n-      }\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n+      do_assemble_alias (alias->decl,\n+\t\t\t DECL_ASSEMBLER_NAME (node->decl));\n+      assemble_aliases (alias);\n+    }\n }\n \n /* Output one variable, if necessary.  Return whether we output it.  */\n@@ -694,20 +692,19 @@ varpool_for_node_and_aliases (varpool_node *node,\n \t\t\t      void *data,\n \t\t\t      bool include_overwritable)\n {\n-  int i;\n-  struct ipa_ref *ref = NULL;\n+  struct ipa_ref *ref;\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; node->iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tvarpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n-\tif (include_overwritable\n-\t    || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n-          if (varpool_for_node_and_aliases (alias, callback, data,\n-\t\t\t\t\t   include_overwritable))\n-\t    return true;\n-      }\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n+      if (include_overwritable\n+\t  || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n+\tif (varpool_for_node_and_aliases (alias, callback, data,\n+\t\t\t\t\t include_overwritable))\n+\t  return true;\n+    }\n   return false;\n }"}]}