{"sha": "2c460d129131c95fc7b72e3600ab532a375562fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0NjBkMTI5MTMxYzk1ZmM3YjcyZTM2MDBhYjUzMmEzNzU1NjJmYQ==", "commit": {"author": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2008-01-06T15:24:10Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2008-01-06T15:24:10Z"}, "message": "Fix PR34263: Cleaning up latch blocks\n\nFrom-SVN: r131352", "tree": {"sha": "83b2a9169f3e5bf325fc44a792490598100f84b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83b2a9169f3e5bf325fc44a792490598100f84b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c460d129131c95fc7b72e3600ab532a375562fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c460d129131c95fc7b72e3600ab532a375562fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c460d129131c95fc7b72e3600ab532a375562fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c460d129131c95fc7b72e3600ab532a375562fa/comments", "author": null, "committer": null, "parents": [{"sha": "79ca8fc00bd24cc9111b24406953ce4e96ca3800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ca8fc00bd24cc9111b24406953ce4e96ca3800", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ca8fc00bd24cc9111b24406953ce4e96ca3800"}], "stats": {"total": 234, "additions": 233, "deletions": 1}, "files": [{"sha": "87bc032d1abbbe4cd2e40537351bc529f05405cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c460d129131c95fc7b72e3600ab532a375562fa", "patch": "@@ -1,3 +1,14 @@\n+2008-01-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\t    Mircea Namolaru  <namolaru@il.ibm.com>\n+\t    Vladimir Yanovsky  <yanov@il.ibm.com>\n+\t    Revital Eres  <eres@il.ibm.com>\n+\n+\tPR tree-optimization/34263\n+\t* tree-outof-ssa.c (process_single_block_loop_latch,\n+\tcontains_tree_r): New functions.\n+\t(analyze_edges_for_bb): Call process_single_block_loop_latch\n+\tfunction to empty single-basic-block latch block if possible.\n+\n 2008-01-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_builtin_reciprocal): Remove check"}, {"sha": "2b08e5793e2ab52380ff6ca2beef31f6f40ca447", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c460d129131c95fc7b72e3600ab532a375562fa", "patch": "@@ -1,3 +1,8 @@\n+2008-01-06  Revital Eres  <eres@il.ibm.com>\n+\n+\tPR tree-optimization/34263\n+\t* gcc.dg/pr34263.c:  New testcase.\n+\n 2008-01-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34654"}, {"sha": "10df9d81fc09cb99484c6b085025c4bdcae02d38", "filename": "gcc/testsuite/gcc.dg/pr34263.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34263.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34263.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34263.c?ref=2c460d129131c95fc7b72e3600ab532a375562fa", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* Same test as 990128-1.c.  */\n+\n+extern int printf (const char *,...);\n+extern void abort (void);\n+\n+struct s { struct s *n; } *p;\n+struct s ss;\n+#define MAX     10\n+struct s sss[MAX];\n+int count = 0;\n+\n+void sub( struct s *p, struct s **pp );\n+int look( struct s *p, struct s **pp );\n+\n+main()\n+{\n+    struct s *pp;\n+    struct s *next;\n+    int i;\n+\n+    p = &ss;\n+    next = p;\n+    for ( i = 0; i < MAX; i++ ) {\n+        next->n = &sss[i];\n+        next = next->n;\n+    }\n+    next->n = 0;\n+\n+    sub( p, &pp );\n+    if (count != MAX+2)\n+      abort ();\n+\n+    return( 0 );\n+}\n+\n+void sub( struct s *p, struct s **pp )\n+{\n+   for ( ; look( p, pp ); ) {\n+        if ( p )\n+            p = p->n;\n+        else\n+            break;\n+   }\n+}\n+\n+int look( struct s *p, struct s **pp )\n+{\n+    for ( ; p; p = p->n )\n+        ;\n+    *pp = p;\n+    count++;\n+    return( 1 );\n+}\n+\n+/* { dg-final { scan-tree-dump \"Cleaned-up latch block of loop with single BB\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+"}, {"sha": "be8a459f40270c7a8964a53f9b8c1abe0a8a00ee", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 158, "deletions": 1, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c460d129131c95fc7b72e3600ab532a375562fa/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=2c460d129131c95fc7b72e3600ab532a375562fa", "patch": "@@ -872,6 +872,158 @@ fini_analyze_edges_for_bb (void)\n   BITMAP_FREE (leader_has_match);\n }\n \n+/* A helper function to be called via walk_tree.  Return DATA if it is\n+  contained in subtree TP.  */\n+ \n+static tree\n+contains_tree_r (tree * tp, int *walk_subtrees, void *data)\n+{\n+  if (*tp == data)\n+    {\n+      *walk_subtrees = 0;\n+      return data;\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* A threshold for the number of insns contained in the latch block.\n+   It is used to prevent blowing the loop with too many copies from\n+   the latch.  */\n+#define MAX_STMTS_IN_LATCH 2\n+\n+/* Return TRUE if the stmts on SINGLE-EDGE can be moved to the\n+   body of the loop.  This should be permitted only if SINGLE-EDGE is a\n+   single-basic-block latch edge and thus cleaning the latch will help\n+   to create a single-basic-block loop.  Otherwise return FALSE.  */\n+\n+static bool\n+process_single_block_loop_latch (edge single_edge)\n+{\n+  tree stmts;\n+  basic_block b_exit, b_pheader, b_loop = single_edge->src;\n+  edge_iterator ei;\n+  edge e;\n+  block_stmt_iterator bsi, bsi_exit;\n+  tree_stmt_iterator tsi;\n+  tree expr, stmt;\n+  unsigned int count = 0;\n+\n+  if (single_edge == NULL || (single_edge->dest != single_edge->src)\n+      || (EDGE_COUNT (b_loop->succs) != 2)\n+      || (EDGE_COUNT (b_loop->preds) != 2))\n+    return false;\n+\n+  /* Get the stmts on the latch edge.  */\n+  stmts = PENDING_STMT (single_edge);\n+\n+  /* Find the successor edge which is not the latch edge.  */\n+  FOR_EACH_EDGE (e, ei, b_loop->succs) \n+   if (e->dest != b_loop)\n+    break;\n+\n+  b_exit = e->dest;\n+\n+  /* Check that the exit block has only the loop as a predecessor,\n+     and that there are no pending stmts on that edge as well.   */\n+  if (EDGE_COUNT (b_exit->preds) != 1 || PENDING_STMT (e))\n+    return false;\n+\n+  /* Find the predecessor edge which is not the latch edge.  */\n+  FOR_EACH_EDGE (e, ei, b_loop->preds) \n+   if (e->src != b_loop)\n+    break;\n+\n+  b_pheader = e->src;\n+\n+  if (b_exit == b_pheader || b_exit == b_loop || b_pheader == b_loop)\n+    return false;\n+\n+  bsi_exit = bsi_after_labels (b_exit);\n+\n+  /* Get the last stmt in the loop body.  */\n+  bsi = bsi_last (single_edge->src);\n+  stmt = bsi_stmt (bsi);\n+\n+  if (TREE_CODE (stmt) != COND_EXPR)\n+    return false;\n+\n+  expr = COND_EXPR_COND (stmt);\n+  /* Iterate over the insns on the latch and count them.  */\n+  for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n+    {\n+      tree stmt1 = tsi_stmt (tsi);\n+      tree var;\n+\n+      count++;\n+      /* Check that the condition does not contain any new definition\n+         created in the latch as the stmts from the latch intended\n+         to precede it.  */\n+      if (TREE_CODE (stmt1) != GIMPLE_MODIFY_STMT)\n+        return false;\n+      var = GIMPLE_STMT_OPERAND (stmt1, 0);\n+      if (TREE_THIS_VOLATILE (var)\n+\t  || TYPE_VOLATILE (TREE_TYPE (var))\n+\t  || walk_tree (&expr, contains_tree_r, var, NULL))\n+\treturn false;\n+    }\n+  /* Check that the latch does not contain more than MAX_STMTS_IN_LATCH\n+     insns.  The purpose of this restriction is to prevent blowing the\n+     loop with too many copies from the latch.  */\n+  if (count > MAX_STMTS_IN_LATCH)\n+    return false;\n+\n+  /* Apply the transformation - clean up the latch block:  \n+\n+     var = something; \n+     L1:\n+     x1 = expr;\n+     if (cond) goto L2 else goto L3;\n+     L2:\n+     var = x1;\n+     goto L1\n+     L3:\n+     ...\n+\n+     ==>\n+\n+     var = something;\n+     L1:\n+     x1 = expr;\n+     tmp_var = var;\n+     var = x1;\n+     if (cond) goto L1 else goto L2;\n+     L2:\n+     var = tmp_var;\n+     ... \n+   */\n+  for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n+    {\n+      tree stmt1 = tsi_stmt (tsi);\n+      tree var, tmp_var, copy;\n+\n+      /* Create a new variable to load back the value of var in case\n+         we exit the loop.  */\n+      var = GIMPLE_STMT_OPERAND (stmt1, 0);\n+      tmp_var = create_temp (var);\n+      copy = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (tmp_var), tmp_var, var);\n+      set_is_used (tmp_var);\n+      bsi_insert_before (&bsi, copy, BSI_SAME_STMT);\n+      copy = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (tmp_var), var, tmp_var);\n+      bsi_insert_before (&bsi_exit, copy, BSI_SAME_STMT);\n+    }\n+\n+  PENDING_STMT (single_edge) = 0;\n+  /* Insert the new stmts to the loop body.  */\n+  bsi_insert_before (&bsi, stmts, BSI_NEW_STMT);\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nCleaned-up latch block of loop with single BB: %d\\n\\n\",\n+\t     single_edge->dest->index);\n+\n+  return true;\n+}\n \n /* Look at all the incoming edges to block BB, and decide where the best place\n    to insert the stmts on each edge are, and perform those insertions.  */\n@@ -945,7 +1097,12 @@ analyze_edges_for_bb (basic_block bb)\n   if (count < 2)\n     {\n       if (single_edge)\n-        bsi_commit_one_edge_insert (single_edge, NULL);\n+      {\n+       /* Add stmts to the edge unless processed specially as a\n+          single-block loop latch edge. */\n+       if (!process_single_block_loop_latch (single_edge))\n+         bsi_commit_one_edge_insert (single_edge, NULL);\n+      }\n       return;\n     }\n "}]}