{"sha": "8a7f7fb6dec187cd95566e690e60293302fdd55d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE3ZjdmYjZkZWMxODdjZDk1NTY2ZTY5MGU2MDI5MzMwMmZkZDU1ZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-10-31T20:58:26Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-10-31T20:58:26Z"}, "message": "re PR libfortran/29627 ([4.1 only] partial unformatted reads shouldn't succeed)\n\n2006-10-31  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/29627\n\t* libgfortran.h: Add ERROR_SHORT_RECORD\n\t* runtime/error.c (translate_error): Add case\n\tfor ERROR_SHORT_RECORD.\n\t* io/transfer.c (read_block_direct):  Separate codepaths\n\tfor stream and record unformatted I/O.  Remove unneeded\n\ttests for standard input, padding and formatted I/O.\n\tIf the record is short, read in as much data as possible,\n\tthen raise the error.\n\n2006-10-31  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/29627\n\t* gfortran.dg/unf_short_record_1.f90:  New test.\n\nFrom-SVN: r118341", "tree": {"sha": "f4b1548a82d24a23fccb0e2105d38e471359f8da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4b1548a82d24a23fccb0e2105d38e471359f8da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a7f7fb6dec187cd95566e690e60293302fdd55d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7f7fb6dec187cd95566e690e60293302fdd55d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7f7fb6dec187cd95566e690e60293302fdd55d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7f7fb6dec187cd95566e690e60293302fdd55d/comments", "author": null, "committer": null, "parents": [{"sha": "401c8e8059870221603c8707272d0d66b3629167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401c8e8059870221603c8707272d0d66b3629167", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401c8e8059870221603c8707272d0d66b3629167"}], "stats": {"total": 129, "additions": 80, "deletions": 49}, "files": [{"sha": "f6f95b3159092f2ea02ee7f37b84129d1d0cc7ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7f7fb6dec187cd95566e690e60293302fdd55d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7f7fb6dec187cd95566e690e60293302fdd55d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a7f7fb6dec187cd95566e690e60293302fdd55d", "patch": "@@ -1,3 +1,8 @@\n+2006-10-31  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/29627\n+\t* gfortran.dg/unf_short_record_1.f90:  New test.\n+\n 2006-10-31  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/29067"}, {"sha": "1bb62736a361e421843f37504d9edf253a607632", "filename": "gcc/testsuite/gfortran.dg/unf_short_record_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7f7fb6dec187cd95566e690e60293302fdd55d/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_short_record_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7f7fb6dec187cd95566e690e60293302fdd55d/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_short_record_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_short_record_1.f90?ref=8a7f7fb6dec187cd95566e690e60293302fdd55d", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+! PR 29627 - partial reads of unformatted records\n+program main\n+  character a(3)\n+  character(len=50) msg\n+  open(10, form=\"unformatted\", status=\"unknown\")\n+  write (10) 'a'\n+  write (10) 'c'\n+  a = 'b'\n+  rewind 10\n+  read (10, err=20, iomsg=msg) a\n+  call abort\n+20 continue\n+  if (msg .ne. \"Short record on unformatted read\") call abort\n+  if (a(1) .ne. 'a' .or. a(2) .ne. 'b' .or. a(3) .ne. 'b') call abort\n+  close (10, status=\"delete\")\n+end program main"}, {"sha": "54849e08c9365d1dee700e53c651edf6aa7d9042", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8a7f7fb6dec187cd95566e690e60293302fdd55d", "patch": "@@ -1,3 +1,15 @@\n+2006-10-31  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/29627\n+\t* libgfortran.h: Add ERROR_SHORT_RECORD\n+\t* runtime/error.c (translate_error): Add case\n+\tfor ERROR_SHORT_RECORD.\n+\t* io/transfer.c (read_block_direct):  Separate codepaths\n+\tfor stream and record unformatted I/O.  Remove unneeded\n+\ttests for standard input, padding and formatted I/O.\n+\tIf the record is short, read in as much data as possible,\n+\tthen raise the error.\n+\n 2006-10-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/29452"}, {"sha": "b4c2bb65b0c1be0616efe47eb6df80d5a533e9af", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 41, "deletions": 49, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=8a7f7fb6dec187cd95566e690e60293302fdd55d", "patch": "@@ -359,82 +359,73 @@ read_block (st_parameter_dt *dtp, int *length)\n static void\n read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n-  int *length;\n-  void *data;\n   size_t nread;\n+  int short_record;\n \n-  if (!is_stream_io (dtp))\n+  if (is_stream_io (dtp))\n     {\n-      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n \t{\n-\t  /* For preconnected units with default record length, set\n-\t     bytes left to unit record length and proceed, otherwise\n-\t     error.  */\n-\t  if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n-\t      && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-\t    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n-\t  else\n-\t    {\n-\t      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n-\t\t{\n-\t\t  /* Not enough data left.  */\n-\t\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  \n-\t  if (dtp->u.p.current_unit->bytes_left == 0)\n-\t    {\n-\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      generate_error (&dtp->common, ERROR_END, NULL);\n-\t      return;\n-\t    }\n-\n-\t  *nbytes = (size_t) dtp->u.p.current_unit->bytes_left;\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return;\n \t}\n \n-      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n-\t  dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+      nread = *nbytes;\n+      if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n \t{\n-\t  length = (int *) nbytes;\n-\t  data = read_sf (dtp, length, 0);\t/* Special case.  */\n-\t  memcpy (buf, data, (size_t) *length);\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n \t  return;\n \t}\n \n-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) nread; \n+\n+      if (nread != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n+\tgenerate_error (&dtp->common, ERROR_END, NULL);\t  \n+\n+      return;\n     }\n-  else\n+\n+  /* Unformatted file with records */\n+  if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n     {\n-      if (sseek (dtp->u.p.current_unit->s,\n-\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n+      short_record = 1;\n+      nread = (size_t) dtp->u.p.current_unit->bytes_left;\n+      *nbytes = nread;\n+\n+      if (dtp->u.p.current_unit->bytes_left == 0)\n \t{\n+\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t  generate_error (&dtp->common, ERROR_END, NULL);\n \t  return;\n \t}\n     }\n \n-  nread = *nbytes;\n+  else\n+    {\n+      short_record = 0;\n+      nread = *nbytes;\n+    }\n+\n+  dtp->u.p.current_unit->bytes_left -= nread;\n+\n   if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n     {\n       generate_error (&dtp->common, ERROR_OS, NULL);\n       return;\n     }\n \n-  if (!is_stream_io (dtp))\n+  if (nread != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n     {\n-      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-\tdtp->u.p.size_used += (gfc_offset) nread;\n+      *nbytes = nread;\n+      generate_error (&dtp->common, ERROR_END, NULL);\n+      return;\n     }\n-  else\n-    dtp->u.p.current_unit->strm_pos += (gfc_offset) nread; \n \n-  if (nread != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n+  if (short_record)\n     {\n-      if (!is_stream_io (dtp))\n-\tgenerate_error (&dtp->common, ERROR_EOR, NULL);\n-      else\n-\tgenerate_error (&dtp->common, ERROR_END, NULL);\t  \n+      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+      return;\n     }\n }\n \n@@ -595,7 +586,8 @@ unformatted_read (st_parameter_dt *dtp, bt type,\n       /* By now, all complex variables have been split into their\n \t constituent reals.  For types with padding, we only need to\n \t read kind bytes.  We don't care about the contents\n-\t of the padding.  */\n+\t of the padding.  If we hit a short record, then sz is\n+\t adjusted accordingly, making later reads no-ops.  */\n       \n       sz = kind;\n       for (i=0; i<nelems; i++)"}, {"sha": "ff947655806e589bf2dc7e5025fc9aa65926a69e", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=8a7f7fb6dec187cd95566e690e60293302fdd55d", "patch": "@@ -413,6 +413,7 @@ typedef enum\n   ERROR_INTERNAL_UNIT,\n   ERROR_ALLOCATION,\n   ERROR_DIRECT_EOR,\n+  ERROR_SHORT_RECORD,\n   ERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n }\n error_codes;"}, {"sha": "245e04e31c2da130402b520458a715d6918f92e1", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a7f7fb6dec187cd95566e690e60293302fdd55d/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=8a7f7fb6dec187cd95566e690e60293302fdd55d", "patch": "@@ -436,6 +436,10 @@ translate_error (int code)\n       p = \"Write exceeds length of DIRECT access record\";\n       break;\n \n+    case ERROR_SHORT_RECORD:\n+      p = \"Short record on unformatted read\";\n+      break;\n+\n     default:\n       p = \"Unknown error code\";\n       break;"}]}