{"sha": "69958396d92cc0b3948572e8b2348c30ef22e0a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk5NTgzOTZkOTJjYzBiMzk0ODU3MmU4YjIzNDhjMzBlZjIyZTBhNQ==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2012-04-22T10:36:13Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2012-04-22T10:36:13Z"}, "message": "Correcting transform_to_exit_first_loop + fix to PR tree-optimization/46886\n\n2012-04-20  Razya Ladelsky  <razya@il.ibm.com>\n                 Correcting transform_to_exit_first_loop + fix to\n                 PR tree-optimization/46886\n                 * tree-parloops.c (transform_to_exit_first_loop):\n                 * Remove setting of number of iterations according to\n                 * the loop pattern.\n                 Duplicate from entry to exit->src instead of\nloop->latch.\n                 (pallelize_loops): Remove the condition preventing\ndo-while loops.\n                 * tree-cfg.c (bool bb_in_region_p): New.\n                 (gimple_duplicate_sese_tail): Adjust duplication of the\nthe subloops.\n                 Adjust redirection of the duplicated iteration.\n\nFrom-SVN: r186667", "tree": {"sha": "cebf71b4ea7eba71b04a1cce8154ce8b65a383b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cebf71b4ea7eba71b04a1cce8154ce8b65a383b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69958396d92cc0b3948572e8b2348c30ef22e0a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69958396d92cc0b3948572e8b2348c30ef22e0a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69958396d92cc0b3948572e8b2348c30ef22e0a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69958396d92cc0b3948572e8b2348c30ef22e0a5/comments", "author": null, "committer": null, "parents": [{"sha": "bf310e122b95cc6c849afe81fae5ef93a2722556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf310e122b95cc6c849afe81fae5ef93a2722556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf310e122b95cc6c849afe81fae5ef93a2722556"}], "stats": {"total": 83, "additions": 39, "deletions": 44}, "files": [{"sha": "c4cbdd644cfcb8564912c793fe311d62110549e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69958396d92cc0b3948572e8b2348c30ef22e0a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69958396d92cc0b3948572e8b2348c30ef22e0a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69958396d92cc0b3948572e8b2348c30ef22e0a5", "patch": "@@ -1,3 +1,12 @@\n+2012-04-22  Razya Ladelsky  <razya@il.ibm.com>\n+\t\n+\t\t Correcting transform_to_exit_first_loop + fix to PR46886\n+\t\t * tree-parloops.c (transform_to_exit_first_loop): Remove setting of number of iterations according to the loop pattern.\n+\t\t Duplicate from entry to exit->src instead of loop->latch.\n+\t\t (pallelize_loops): Remove the condition preventing do-while loops.\n+\t\t * tree-cfg.c (bool bb_in_region_p): New.\n+\t\t (gimple_duplicate_sese_tail): Adjust duplication of the the subloops.\n+\t  \t Adjust redirection of the duplicated iteration.\t\n 2012-04-21  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR bootstrap/53021"}, {"sha": "e32daa75e0f09ca118bcd89b62b7aed492fa2f09", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69958396d92cc0b3948572e8b2348c30ef22e0a5/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69958396d92cc0b3948572e8b2348c30ef22e0a5/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=69958396d92cc0b3948572e8b2348c30ef22e0a5", "patch": "@@ -5595,6 +5595,20 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n   return true;\n }\n \n+/* Checks if BB is part of the region defined by N_REGION BBS.  */\n+static bool \n+bb_part_of_region_p (basic_block bb, basic_block* bbs, unsigned n_region)\n+{\n+  unsigned int n;\n+\n+  for (n = 0; n < n_region; n++)\n+    {\n+     if (bb == bbs[n])\n+       return true;\n+    }\n+  return false;\n+}\n+\n /* Duplicates REGION consisting of N_REGION blocks.  The new blocks\n    are stored to REGION_COPY in the same order in that they appear\n    in REGION, if REGION_COPY is not NULL.  ENTRY is the entry to\n@@ -5645,6 +5659,7 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   gimple_stmt_iterator psi;\n   gimple phi;\n   tree def;\n+  struct loop *target, *aloop, *cloop;\n \n   gcc_assert (EDGE_COUNT (exit->src->succs) == 2);\n   exits[0] = exit;\n@@ -5655,7 +5670,16 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n \n   initialize_original_copy_tables ();\n   set_loop_copy (orig_loop, loop);\n-  duplicate_subloops (orig_loop, loop);\n+\n+  target= loop;\n+  for (aloop = orig_loop->inner; aloop; aloop = aloop->next)\n+    {\n+      if (bb_part_of_region_p (aloop->header, region, n_region))\n+\t{\n+\t  cloop = duplicate_loop (aloop, target);\n+\t  duplicate_subloops (aloop, cloop);\n+\t}\n+    }\n \n   if (!region_copy)\n     {\n@@ -5758,7 +5782,7 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n \t    add_phi_arg (phi, def, e, gimple_phi_arg_location_from_edge (phi, e));\n \t  }\n       }\n-  e = redirect_edge_and_branch (nexits[0], nexits[1]->dest);\n+  e = redirect_edge_and_branch (nexits[1], nexits[0]->dest);\n   PENDING_STMT (e) = NULL;\n   \n   /* Anything that is outside of the region, but was dominated by something"}, {"sha": "18bf645366e38edb392ac29897a1a5f2dff800c7", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69958396d92cc0b3948572e8b2348c30ef22e0a5/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69958396d92cc0b3948572e8b2348c30ef22e0a5/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=69958396d92cc0b3948572e8b2348c30ef22e0a5", "patch": "@@ -1481,8 +1481,6 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n   gimple phi, nphi, cond_stmt, stmt, cond_nit;\n   gimple_stmt_iterator gsi;\n   tree nit_1;\n-  edge exit_1;\n-  tree new_rhs;\n \n   split_block_after_labels (loop->header);\n   orig_header = single_succ (loop->header);\n@@ -1512,41 +1510,10 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \t}\n     }\n \n- /* Setting the condition towards peeling the last iteration:\n-    If the block consisting of the exit condition has the latch as\n-    successor, then the body of the loop is executed before\n-    the exit condition is tested.  In such case, moving the\n-    condition to the entry, causes that the loop will iterate\n-    one less iteration (which is the wanted outcome, since we\n-    peel out the last iteration).  If the body is executed after\n-    the condition, moving the condition to the entry requires\n-    decrementing one iteration.  */\n-  exit_1 = EDGE_SUCC (exit->src, EDGE_SUCC (exit->src, 0) == exit); \n-  if (exit_1->dest == loop->latch)\n-    new_rhs = gimple_cond_rhs (cond_stmt);\n-  else\n-  {\n-    new_rhs = fold_build2 (MINUS_EXPR, TREE_TYPE (gimple_cond_rhs (cond_stmt)),\n-\t\t\t   gimple_cond_rhs (cond_stmt),\n-\t\t\t   build_int_cst (TREE_TYPE (gimple_cond_rhs (cond_stmt)), 1));\n-    if (TREE_CODE (gimple_cond_rhs (cond_stmt)) == SSA_NAME)\n-      {\n- \tbasic_block preheader;\n-  \tgimple_stmt_iterator gsi1;\n-\n-  \tpreheader = loop_preheader_edge(loop)->src;\n-    \tgsi1 = gsi_after_labels (preheader);\n-\tnew_rhs = force_gimple_operand_gsi (&gsi1, new_rhs, true,\n-\t\t\t\t\t    NULL_TREE,false,GSI_CONTINUE_LINKING);\n-      }\n-  }\n-  gimple_cond_set_rhs (cond_stmt, unshare_expr (new_rhs));\n-  gimple_cond_set_lhs (cond_stmt, unshare_expr (gimple_cond_lhs (cond_stmt)));\n-  \n   bbs = get_loop_body_in_dom_order (loop);\n \n-  for (n = 0; bbs[n] != loop->latch; n++)\n-    continue;\n+  for (n = 0; bbs[n] != exit->src; n++)\n+   continue;\n   nbbs = XNEWVEC (basic_block, n);\n   ok = gimple_duplicate_sese_tail (single_succ_edge (loop->header), exit,\n \t\t\t\t   bbs + 1, n, nbbs);\n@@ -1557,7 +1524,7 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \n   /* Other than reductions, the only gimple reg that should be copied\n      out of the loop is the control variable.  */\n-\n+  exit = single_dom_exit (loop);\n   control_name = NULL_TREE;\n   for (gsi = gsi_start_phis (ex_bb); !gsi_end_p (gsi); )\n     {\n@@ -1574,8 +1541,6 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n          PHI_RESULT of this phi is the resulting value of the reduction\n          variable when exiting the loop.  */\n \n-      exit = single_dom_exit (loop);\n-\n       if (htab_elements (reduction_list) > 0)\n \t{\n \t  struct reduction_info *red;\n@@ -2187,10 +2152,7 @@ parallelize_loops (void)\n \t  || loop_has_blocks_with_irreducible_flag (loop)\n \t  || (loop_preheader_edge (loop)->src->flags & BB_IRREDUCIBLE_LOOP)\n \t  /* FIXME: the check for vector phi nodes could be removed.  */\n-\t  || loop_has_vector_phi_nodes (loop)\n-\t  /* FIXME: transform_to_exit_first_loop does not handle not\n-\t     header-copied loops correctly - see PR46886.  */\n-\t  || !do_while_loop_p (loop))\n+\t  || loop_has_vector_phi_nodes (loop))\n \tcontinue;\n \n       estimated = estimated_stmt_executions_int (loop);"}]}