{"sha": "319dcdd8bdbb242323d9618f96273ce5d160d095", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE5ZGNkZDhiZGJiMjQyMzIzZDk2MThmOTYyNzNjZTVkMTYwZDA5NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-05-04T23:45:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-05-04T23:45:57Z"}, "message": "Revert:\n\n\t2015-05-04  Jeff Law  <law@redhat.com>\n\n        * match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New\n        simplifier to narrow arithmetic.\n        * generic-match-head.c: (types_match, single_use): New functions.\n        * gimple-match-head.c: (types_match, single_use): New functions.\n\n\tRevert:\n\t2015-05-04  Jeff Law  <law@redhat.com>\n\t* gcc.dg/tree-ssa/shorten-1.c: New test.\n\nFrom-SVN: r222784", "tree": {"sha": "e953b99fed0775e626bb1bb0dc2caf55316465de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e953b99fed0775e626bb1bb0dc2caf55316465de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/319dcdd8bdbb242323d9618f96273ce5d160d095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319dcdd8bdbb242323d9618f96273ce5d160d095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/319dcdd8bdbb242323d9618f96273ce5d160d095", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319dcdd8bdbb242323d9618f96273ce5d160d095/comments", "author": null, "committer": null, "parents": [{"sha": "4e417af354507747882f17d09c616d6e572ab0ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e417af354507747882f17d09c616d6e572ab0ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e417af354507747882f17d09c616d6e572ab0ee"}], "stats": {"total": 183, "additions": 29, "deletions": 154}, "files": [{"sha": "3be0df54642ef87cb1bc84e7375d5dcd2c26f218", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=319dcdd8bdbb242323d9618f96273ce5d160d095", "patch": "@@ -1,3 +1,13 @@\n+2015-05-04  Jeff Law  <law@redhat.com>\n+\n+\tRevert:\n+\t2015-05-04  Jeff Law  <law@redhat.com>\n+\n+        * match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New\n+        simplifier to narrow arithmetic.\n+        * generic-match-head.c: (types_match, single_use): New functions.\n+        * gimple-match-head.c: (types_match, single_use): New functions.\n+\n 2015-05-04  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/65987"}, {"sha": "daa56aa370ec6c93024e2c541aa10a6c33e2c597", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=319dcdd8bdbb242323d9618f96273ce5d160d095", "patch": "@@ -70,20 +70,4 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"generic-match.h\"\n \n-/* Routine to determine if the types T1 and T2 are effectively\n-   the same for GENERIC.  */\n \n-inline bool\n-types_match (tree t1, tree t2)\n-{\n-  return TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2);\n-}\n-\n-/* Return if T has a single use.  For GENERIC, we assume this is\n-   always true.  */\n-\n-inline bool\n-single_use (tree t)\n-{\n-  return true;\n-}"}, {"sha": "c7b2f957baca4bd05c25988938d126d817404fbe", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=319dcdd8bdbb242323d9618f96273ce5d160d095", "patch": "@@ -861,21 +861,3 @@ do_valueize (tree (*valueize)(tree), tree op)\n   return op;\n }\n \n-/* Routine to determine if the types T1 and T2 are effectively\n-   the same for GIMPLE.  */\n-\n-inline bool\n-types_match (tree t1, tree t2)\n-{\n-  return types_compatible_p (t1, t2);\n-}\n-\n-/* Return if T has a single use.  For GIMPLE, we also allow any\n-   non-SSA_NAME (ie constants) and zero uses to cope with uses\n-   that aren't linked up yet.  */\n-\n-inline bool\n-single_use (tree t)\n-{\n-  return TREE_CODE (t) != SSA_NAME || has_zero_uses (t) || has_single_use (t);\n-}"}, {"sha": "87ecaf10140780243c58b90d0909d4b6c55799c9", "filename": "gcc/match.pd", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=319dcdd8bdbb242323d9618f96273ce5d160d095", "patch": "@@ -289,7 +289,8 @@ along with GCC; see the file COPYING3.  If not see\n   (if (((TREE_CODE (@1) == INTEGER_CST\n \t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n \t && int_fits_type_p (@1, TREE_TYPE (@0)))\n-\t|| types_match (TREE_TYPE (@0), TREE_TYPE (@1)))\n+\t|| (GIMPLE && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1)))\n+\t|| (GENERIC && TREE_TYPE (@0) == TREE_TYPE (@1)))\n        /* ???  This transform conflicts with fold-const.c doing\n \t  Convert (T)(x & c) into (T)x & (T)c, if c is an integer\n \t  constants (if x has signed type, the sign bit cannot be set\n@@ -948,7 +949,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Unordered tests if either argument is a NaN.  */\n (simplify\n  (bit_ior (unordered @0 @0) (unordered @1 @1))\n- (if (types_match (TREE_TYPE (@0), TREE_TYPE (@1)))\n+ (if ((GIMPLE && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1)))\n+      || (GENERIC && TREE_TYPE (@0) == TREE_TYPE (@1)))\n   (unordered @0 @1)))\n (simplify\n  (bit_ior:c (unordered @0 @0) (unordered:c@2 @0 @1))\n@@ -1052,7 +1054,7 @@ along with GCC; see the file COPYING3.  If not see\n    operation and convert the result to the desired type.  */\n (for op (plus minus)\n   (simplify\n-    (convert (op@4 (convert@2 @0) (convert@3 @1)))\n+    (convert (op (convert@2 @0) (convert@3 @1)))\n     (if (INTEGRAL_TYPE_P (type)\n \t /* We check for type compatibility between @0 and @1 below,\n \t    so there's no need to check that @1/@3 are integral types.  */\n@@ -1068,45 +1070,15 @@ along with GCC; see the file COPYING3.  If not see\n \t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n \t /* The inner conversion must be a widening conversion.  */\n \t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n-\t && types_match (TREE_TYPE (@0), TREE_TYPE (@1))\n-\t && types_match (TREE_TYPE (@0), type)\n-\t && single_use (@4))\n+\t && ((GENERIC \n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (@0))\n+\t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (@1)))\n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (@0))\n+\t\t  == TYPE_MAIN_VARIANT (type)))\n+\t     || (GIMPLE\n+\t\t && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1))\n+\t\t && types_compatible_p (TREE_TYPE (@0), type))))\n       (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n \t(convert (op @0 @1)))\n       (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n \t(convert (op (convert:utype @0) (convert:utype @1)))))))\n-\n-/* This is another case of narrowing, specifically when there's an outer\n-   BIT_AND_EXPR which masks off bits outside the type of the innermost\n-   operands.   Like the previous case we have to convert the operands\n-   to unsigned types to avoid introducing undefined behaviour for the\n-   arithmetic operation.  */\n-(for op (minus plus)\n-  (simplify\n-    (bit_and (op@5 (convert@2 @0) (convert@3 @1)) INTEGER_CST@4)\n-    (if (INTEGRAL_TYPE_P (type)\n-\t /* We check for type compatibility between @0 and @1 below,\n-\t    so there's no need to check that @1/@3 are integral types.  */\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n-\t /* The precision of the type of each operand must match the\n-\t    precision of the mode of each operand, similarly for the\n-\t    result.  */\n-\t && (TYPE_PRECISION (TREE_TYPE (@0))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n-\t && (TYPE_PRECISION (TREE_TYPE (@1))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n-\t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n-\t /* The inner conversion must be a widening conversion.  */\n-\t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n-\t && types_match (TREE_TYPE (@0), TREE_TYPE (@1))\n-\t && (tree_int_cst_min_precision (@4, UNSIGNED)\n-\t     <= TYPE_PRECISION (TREE_TYPE (@0)))\n-\t && single_use (@5))\n-      (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n-\t(with { tree ntype = TREE_TYPE (@0); }\n-\t  (convert (bit_and (op @0 @1) (convert:ntype @4)))))\n-      (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n-\t(convert (bit_and (op (convert:utype @0) (convert:utype @1))\n-\t\t\t  (convert:utype @4)))))))\n-"}, {"sha": "94ee3120469532f91a8285d11d58ba6638544d05", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319dcdd8bdbb242323d9618f96273ce5d160d095/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=319dcdd8bdbb242323d9618f96273ce5d160d095", "patch": "@@ -1,3 +1,9 @@\n+2015-05-04  Jeff Law  <law@redhat.com>\n+\n+\tRevert:\n+\t2015-05-04  Jeff Law  <law@redhat.com>\n+\t* gcc.dg/tree-ssa/shorten-1.c: New test.\n+\n 2015-05-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "c9015c58aa6d49d2e75b570bee2c22f082da611d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/shorten-1.c", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e417af354507747882f17d09c616d6e572ab0ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fshorten-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e417af354507747882f17d09c616d6e572ab0ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fshorten-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fshorten-1.c?ref=4e417af354507747882f17d09c616d6e572ab0ee", "patch": "@@ -1,79 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n-\n-extern const unsigned char mode_ibit[];\n-extern const unsigned char mode_fbit[];\n-extern const signed char smode_ibit[];\n-extern const signed char smode_fbit[];\n-\n-/* We use bit-and rather than modulo to ensure we're actually\n-   testing the desired match.pd pattern.  */\n-unsigned char\n-muufubar (int indx)\n-{\n-  int ret = (mode_fbit [indx] - mode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-signed char\n-msufubar (int indx)\n-{\n-  int ret = (mode_fbit [indx] - mode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-unsigned char\n-musfubar (int indx)\n-{\n-  int ret = (smode_fbit [indx] - smode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-signed char\n-mssfubar (int indx)\n-{\n-  int ret = (smode_fbit [indx] - smode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-\n-unsigned char\n-puufubar (int indx)\n-{\n-  int ret = (mode_fbit [indx] + mode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-signed char\n-psufubar (int indx)\n-{\n-  int ret = (mode_fbit [indx] + mode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-unsigned char\n-pusfubar (int indx)\n-{\n-  int ret = (smode_fbit [indx] + smode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-signed char\n-pssfubar (int indx)\n-{\n-  int ret = (smode_fbit [indx] + smode_ibit [indx]) & 3;\n-  return ret;\n-}\n-\n-/* The shortening patterns in match.pd should arrange to do the\n-   arithmetic in char modes and thus any casts to ints should\n-   have been removed.  */\n-/* { dg-final {scan-tree-dump-not \"\\\\(int\\\\)\" \"optimized\"} } */\n-\n-/* We should have casted 4 operands from signed to unsigned char types.  */\n-/* { dg-final {scan-tree-dump-times \"\\\\(unsigned char\\\\)\" 8 \"optimized\" } } */\n-\n-/* And two return values should have been casted from unsigned char to\n-   a normal char.  */\n-/* { dg-final {scan-tree-dump-times \"\\\\(signed char\\\\)\" 4 \"optimized\" } } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}