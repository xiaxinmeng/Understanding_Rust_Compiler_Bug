{"sha": "0f9b3ea686b1c5f6dbbe0626291342edc3883b98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5YjNlYTY4NmIxYzVmNmRiYmUwNjI2MjkxMzQyZWRjMzg4M2I5OA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-02-24T15:07:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-24T15:07:38Z"}, "message": "calls.c (finalize_must_preallocate): New function, extracted from expand_call.\n\n        * calls.c (finalize_must_preallocate): New function, extracted from\n        expand_call.\n        (expand_call): Use finalize_must_preallocate.\n        * calls.c (store_one_arg): Mark \"variable_size\" as possibly unused.\n\nFrom-SVN: r25407", "tree": {"sha": "21f09fab9b8b828b277ca1d398c5ea0ae6c23605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21f09fab9b8b828b277ca1d398c5ea0ae6c23605"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f9b3ea686b1c5f6dbbe0626291342edc3883b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9b3ea686b1c5f6dbbe0626291342edc3883b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f9b3ea686b1c5f6dbbe0626291342edc3883b98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9b3ea686b1c5f6dbbe0626291342edc3883b98/comments", "author": null, "committer": null, "parents": [{"sha": "518ee01e7590e4f31ef1037d1d81777025d585e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518ee01e7590e4f31ef1037d1d81777025d585e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518ee01e7590e4f31ef1037d1d81777025d585e3"}], "stats": {"total": 117, "additions": 72, "deletions": 45}, "files": [{"sha": "d380435a3f86cd0a65b9a0f56a8401a9972c88a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9b3ea686b1c5f6dbbe0626291342edc3883b98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9b3ea686b1c5f6dbbe0626291342edc3883b98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f9b3ea686b1c5f6dbbe0626291342edc3883b98", "patch": "@@ -1,5 +1,11 @@\n Wed Feb 24 14:03:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (finalize_must_preallocate): New function, extracted from\n+\texpand_call.\n+\t(expand_call): Use finalize_must_preallocate.\n+\n+\t* calls.c (store_one_arg): Mark \"variable_size\" as possibly unused.\n+\n \t* regclass.c (record_reg_classes, case 'p'): Set classes appropriately.\n \tAn alternative always fails if it needs a pseudo and no suitable\n \tregister class can be found."}, {"sha": "f7e5eb24ebceb21ac0fd8a227a170d5fb487b7e7", "filename": "gcc/calls.c", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9b3ea686b1c5f6dbbe0626291342edc3883b98/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9b3ea686b1c5f6dbbe0626291342edc3883b98/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0f9b3ea686b1c5f6dbbe0626291342edc3883b98", "patch": "@@ -137,6 +137,10 @@ static void store_one_arg\tPROTO ((struct arg_data *, rtx, int, int,\n \t\t\t\t\tint));\n static void store_unaligned_arguments_into_pseudos PROTO ((struct arg_data *,\n \t\t\t\t\t\t\t   int));\n+static int finalize_must_preallocate\t\tPROTO ((int, int,\n+\t\t\t\t\t\t\tstruct arg_data *,\n+\t\t\t\t\t\t\tstruct args_size *));\n+\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n static rtx save_fixed_argument_area\tPROTO ((int, rtx, int *, int *));\n@@ -822,6 +826,64 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n       }\n }\n \n+/* Given the current state of MUST_PREALLOCATE and information about\n+   arguments to a function call in NUM_ACTUALS, ARGS and ARGS_SIZE,\n+   compute and return the final value for MUST_PREALLOCATE.  */\n+\n+static int\n+finalize_must_preallocate (must_preallocate, num_actuals, args, args_size)\n+     int must_preallocate;\n+     int num_actuals;\n+     struct arg_data *args;\n+     struct args_size *args_size;\n+{\n+  /* See if we have or want to preallocate stack space.\n+\n+     If we would have to push a partially-in-regs parm\n+     before other stack parms, preallocate stack space instead.\n+\n+     If the size of some parm is not a multiple of the required stack\n+     alignment, we must preallocate.\n+\n+     If the total size of arguments that would otherwise create a copy in\n+     a temporary (such as a CALL) is more than half the total argument list\n+     size, preallocation is faster.\n+\n+     Another reason to preallocate is if we have a machine (like the m88k)\n+     where stack alignment is required to be maintained between every\n+     pair of insns, not just when the call is made.  However, we assume here\n+     that such machines either do not have push insns (and hence preallocation\n+     would occur anyway) or the problem is taken care of with\n+     PUSH_ROUNDING.  */\n+\n+  if (! must_preallocate)\n+    {\n+      int partial_seen = 0;\n+      int copy_to_evaluate_size = 0;\n+      int i;\n+\n+      for (i = 0; i < num_actuals && ! must_preallocate; i++)\n+\t{\n+\t  if (args[i].partial > 0 && ! args[i].pass_on_stack)\n+\t    partial_seen = 1;\n+\t  else if (partial_seen && args[i].reg == 0)\n+\t    must_preallocate = 1;\n+\n+\t  if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n+\t      && (TREE_CODE (args[i].tree_value) == CALL_EXPR\n+\t\t  || TREE_CODE (args[i].tree_value) == TARGET_EXPR\n+\t\t  || TREE_CODE (args[i].tree_value) == COND_EXPR\n+\t\t  || TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value))))\n+\t    copy_to_evaluate_size\n+\t      += int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\t}\n+\n+      if (copy_to_evaluate_size * 2 >= args_size->constant\n+\t  && args_size->constant > 0)\n+\tmust_preallocate = 1;\n+    }\n+  return must_preallocate;\n+}\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -1569,50 +1631,9 @@ expand_call (exp, target, ignore)\n #endif\n     }\n \n-  /* See if we have or want to preallocate stack space.\n-\n-     If we would have to push a partially-in-regs parm\n-     before other stack parms, preallocate stack space instead.\n-\n-     If the size of some parm is not a multiple of the required stack\n-     alignment, we must preallocate.\n-\n-     If the total size of arguments that would otherwise create a copy in\n-     a temporary (such as a CALL) is more than half the total argument list\n-     size, preallocation is faster.\n-\n-     Another reason to preallocate is if we have a machine (like the m88k)\n-     where stack alignment is required to be maintained between every\n-     pair of insns, not just when the call is made.  However, we assume here\n-     that such machines either do not have push insns (and hence preallocation\n-     would occur anyway) or the problem is taken care of with\n-     PUSH_ROUNDING.  */\n-\n-  if (! must_preallocate)\n-    {\n-      int partial_seen = 0;\n-      int copy_to_evaluate_size = 0;\n-\n-      for (i = 0; i < num_actuals && ! must_preallocate; i++)\n-\t{\n-\t  if (args[i].partial > 0 && ! args[i].pass_on_stack)\n-\t    partial_seen = 1;\n-\t  else if (partial_seen && args[i].reg == 0)\n-\t    must_preallocate = 1;\n-\n-\t  if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n-\t      && (TREE_CODE (args[i].tree_value) == CALL_EXPR\n-\t\t  || TREE_CODE (args[i].tree_value) == TARGET_EXPR\n-\t\t  || TREE_CODE (args[i].tree_value) == COND_EXPR\n-\t\t  || TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value))))\n-\t    copy_to_evaluate_size\n-\t      += int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n-\t}\n-\n-      if (copy_to_evaluate_size * 2 >= args_size.constant\n-\t  && args_size.constant > 0)\n-\tmust_preallocate = 1;\n-    }\n+  /* Now make final decision about preallocating stack space.  */\n+  must_preallocate = finalize_must_preallocate (must_preallocate,\n+\t\t\t\t\t\tnum_actuals, args, &args_size);\n \n   /* If the structure value address will reference the stack pointer, we must\n      stabilize it.  We don't need to do this if we know that we are not going\n@@ -3481,7 +3502,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n      struct arg_data *arg;\n      rtx argblock;\n      int may_be_alloca;\n-     int variable_size;\n+     int variable_size ATTRIBUTE_UNUSED;\n      int reg_parm_stack_space;\n {\n   register tree pval = arg->tree_value;"}]}