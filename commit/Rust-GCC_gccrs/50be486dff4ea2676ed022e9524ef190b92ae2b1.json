{"sha": "50be486dff4ea2676ed022e9524ef190b92ae2b1", "node_id": "C_kwDOANBUbNoAKDUwYmU0ODZkZmY0ZWEyNjc2ZWQwMjJlOTUyNGVmMTkwYjkyYWUyYjE", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-09-09T15:58:02Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-09-09T15:58:02Z"}, "message": "nvptx: libgomp+mkoffload.cc: Prepare for reverse offload fn lookup\n\nAdd support to nvptx for reverse lookup of function name to prepare for\n'omp target device(ancestor:1)'.\n\ngcc/ChangeLog:\n\n\t* config/nvptx/mkoffload.cc (struct id_map): Add 'dim' member.\n\t(record_id): Store func name without quotes, store dim separately.\n\t(process): For GOMP_REQUIRES_REVERSE_OFFLOAD, check that -march is\n\tat least sm_35, create '$offload_func_table' global array and init\n\twith reverse-offload function addresses.\n\t* config/nvptx/nvptx.cc (write_fn_proto_1, write_fn_proto): New\n\tforce_public attribute to force .visible.\n\t(nvptx_declare_function_name): For \"omp target\n\tdevice_ancestor_nohost\" attribut, force .visible/TREE_PUBLIC.\n\nlibgomp/ChangeLog:\n\n\t* plugin/plugin-nvptx.c (GOMP_OFFLOAD_load_image): Read offload\n\tfunction address table '$offload_func_table' if rev_fn_table\n\tis not NULL.", "tree": {"sha": "80a2284eb384c36807a1484f2ac670152422ab11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80a2284eb384c36807a1484f2ac670152422ab11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50be486dff4ea2676ed022e9524ef190b92ae2b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50be486dff4ea2676ed022e9524ef190b92ae2b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50be486dff4ea2676ed022e9524ef190b92ae2b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50be486dff4ea2676ed022e9524ef190b92ae2b1/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfd75bf7e9017e92b59be650fca97d2b4b331a82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd75bf7e9017e92b59be650fca97d2b4b331a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd75bf7e9017e92b59be650fca97d2b4b331a82"}], "stats": {"total": 158, "additions": 145, "deletions": 13}, "files": [{"sha": "834b2059aac2102d49a425c89fa95ab378835a9b", "filename": "gcc/config/nvptx/mkoffload.cc", "status": "modified", "additions": 114, "deletions": 5, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50be486dff4ea2676ed022e9524ef190b92ae2b1/gcc%2Fconfig%2Fnvptx%2Fmkoffload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50be486dff4ea2676ed022e9524ef190b92ae2b1/gcc%2Fconfig%2Fnvptx%2Fmkoffload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.cc?ref=50be486dff4ea2676ed022e9524ef190b92ae2b1", "patch": "@@ -47,6 +47,7 @@ struct id_map\n {\n   id_map *next;\n   char *ptx_name;\n+  char *dim;\n };\n \n static id_map *func_ids, **funcs_tail = &func_ids;\n@@ -108,15 +109,28 @@ xputenv (const char *string)\n static void\n record_id (const char *p1, id_map ***where)\n {\n-  const char *end = strchr (p1, '\\n');\n-  if (!end)\n+  gcc_assert (p1[0] == '\"');\n+  p1++;\n+  const char *end = strchr (p1, '\"');\n+  const char *end2 = strchr (p1, '\\n');\n+  if (!end || !end2 || end >= end2)\n     fatal_error (input_location, \"malformed ptx file\");\n \n   id_map *v = XNEW (id_map);\n   size_t len = end - p1;\n   v->ptx_name = XNEWVEC (char, len + 1);\n   memcpy (v->ptx_name, p1, len);\n   v->ptx_name[len] = '\\0';\n+  p1 = end + 1;\n+  if (*end != '\\n')\n+    {\n+      len = end2 - p1;\n+      v->dim = XNEWVEC (char, len + 1);\n+      memcpy (v->dim, p1, len);\n+      v->dim[len] = '\\0';\n+    }\n+  else\n+    v->dim = NULL;\n   v->next = NULL;\n   id_map **tail = *where;\n   *tail = v;\n@@ -242,6 +256,10 @@ process (FILE *in, FILE *out, uint32_t omp_requires)\n   id_map const *id;\n   unsigned obj_count = 0;\n   unsigned ix;\n+  const char *sm_ver = NULL, *version = NULL;\n+  const char *sm_ver2 = NULL, *version2 = NULL;\n+  size_t file_cnt = 0;\n+  size_t *file_idx = XALLOCAVEC (size_t, len);\n \n   fprintf (out, \"#include <stdint.h>\\n\\n\");\n \n@@ -250,6 +268,8 @@ process (FILE *in, FILE *out, uint32_t omp_requires)\n   for (size_t i = 0; i != len;)\n     {\n       char c;\n+      bool output_fn_ptr = false;\n+      file_idx[file_cnt++] = i;\n \n       fprintf (out, \"static const char ptx_code_%u[] =\\n\\t\\\"\", obj_count++);\n       while ((c = input[i++]))\n@@ -261,14 +281,27 @@ process (FILE *in, FILE *out, uint32_t omp_requires)\n \t    case '\\n':\n \t      fprintf (out, \"\\\\n\\\"\\n\\t\\\"\");\n \t      /* Look for mappings on subsequent lines.  */\n+\t      if (UNLIKELY (startswith (input + i, \".target sm_\")))\n+\t\t{\n+\t\t  sm_ver = input + i + strlen (\".target sm_\");\n+\t\t  continue;\n+\t\t}\n+\t      if (UNLIKELY (startswith (input + i, \".version \")))\n+\t\t{\n+\t\t  version = input + i + strlen (\".version \");\n+\t\t  continue;\n+\t\t}\n \t      while (startswith (input + i, \"//:\"))\n \t\t{\n \t\t  i += 3;\n \n \t\t  if (startswith (input + i, \"VAR_MAP \"))\n \t\t    record_id (input + i + 8, &vars_tail);\n \t\t  else if (startswith (input + i, \"FUNC_MAP \"))\n-\t\t    record_id (input + i + 9, &funcs_tail);\n+\t\t    {\n+\t\t      output_fn_ptr = true;\n+\t\t      record_id (input + i + 9, &funcs_tail);\n+\t\t    }\n \t\t  else\n \t\t    abort ();\n \t\t  /* Skip to next line. */\n@@ -286,6 +319,81 @@ process (FILE *in, FILE *out, uint32_t omp_requires)\n \t  putc (c, out);\n \t}\n       fprintf (out, \"\\\";\\n\\n\");\n+      if (output_fn_ptr\n+\t  && (omp_requires & GOMP_REQUIRES_REVERSE_OFFLOAD) != 0)\n+\t{\n+\t  if (sm_ver && sm_ver[0] == '3' && sm_ver[1] == '0'\n+\t      && sm_ver[2] == '\\n')\n+\t    fatal_error (input_location,\n+\t\t\t \"%<omp requires reverse_offload%> requires at least \"\n+\t\t\t \"%<sm_35%> for %<-misa=%>\");\n+\t  sm_ver2 = sm_ver;\n+\t  version2 = version;\n+\t}\n+    }\n+\n+  /* Create function-pointer array, required for reverse\n+     offload function-pointer lookup.  */\n+\n+  if (func_ids && (omp_requires & GOMP_REQUIRES_REVERSE_OFFLOAD) != 0)\n+    {\n+      const char needle[] = \"// BEGIN GLOBAL FUNCTION DECL: \";\n+      fprintf (out, \"static const char ptx_code_%u[] =\\n\", obj_count++);\n+      fprintf (out, \"\\t\\\".version \");\n+      for (size_t i = 0; version2[i] != '\\0' && version2[i] != '\\n'; i++)\n+\tfputc (version2[i], out);\n+      fprintf (out, \"\\\"\\n\\t\\\".target sm_\");\n+      for (size_t i = 0; version2[i] != '\\0' && sm_ver2[i] != '\\n'; i++)\n+\tfputc (sm_ver2[i], out);\n+      fprintf (out, \"\\\"\\n\\t\\\".file 1 \\\\\\\"<dummy>\\\\\\\"\\\"\\n\");\n+\n+      size_t fidx = 0;\n+      for (id = func_ids; id; id = id->next)\n+\t{\n+\t  /* Only 'nohost' functions are needed - use NULL for the rest.\n+\t     Alternatively, besides searching for 'BEGIN FUNCTION DECL',\n+\t     checking for '.visible .entry ' + id->ptx_name would be\n+\t     required.  */\n+\t  if (!endswith (id->ptx_name, \"$nohost\"))\n+\t    continue;\n+\t  fprintf (out, \"\\t\\\".extern \");\n+\t  const char *p = input + file_idx[fidx];\n+\t  while (true)\n+\t    {\n+\t      p = strstr (p, needle);\n+\t      if (!p)\n+\t\t{\n+\t\t  fidx++;\n+\t\t  if (fidx >= file_cnt)\n+\t\t    break;\n+\t\t  p = input + file_idx[fidx];\n+\t\t  continue;\n+\t\t}\n+\t      p += strlen (needle);\n+\t      if (!startswith (p, id->ptx_name))\n+\t\tcontinue;\n+\t      p += strlen (id->ptx_name);\n+\t      if (*p != '\\n')\n+\t\tcontinue;\n+\t      p++;\n+\t      gcc_assert (startswith (p, \".visible \"));\n+\t      p += strlen (\".visible \");\n+\t      for (; *p != '\\0' && *p != '\\n'; p++)\n+\t\tfputc (*p, out);\n+\t      break;\n+\t    }\n+\t  fprintf (out, \"\\\"\\n\");\n+\t  if (fidx == file_cnt)\n+\t    fatal_error (input_location,\n+\t\t\t \"Cannot find function declaration for %qs\",\n+\t\t\t id->ptx_name);\n+\t}\n+      fprintf (out, \"\\t\\\".visible .global .align 8 .u64 \"\n+\t\t    \"$offload_func_table[] = {\");\n+      for (comma = \"\", id = func_ids; id; comma = \",\", id = id->next)\n+\tfprintf (out, \"%s\\\"\\n\\t\\t\\\"%s\", comma,\n+\t\t endswith (id->ptx_name, \"$nohost\") ? id->ptx_name : \"0\");\n+      fprintf (out, \"};\\\\n\\\";\\n\\n\");\n     }\n \n   /* Dump out array of pointers to ptx object strings.  */\n@@ -300,7 +408,7 @@ process (FILE *in, FILE *out, uint32_t omp_requires)\n   /* Dump out variable idents.  */\n   fprintf (out, \"static const char *const var_mappings[] = {\");\n   for (comma = \"\", id = var_ids; id; comma = \",\", id = id->next)\n-    fprintf (out, \"%s\\n\\t%s\", comma, id->ptx_name);\n+    fprintf (out, \"%s\\n\\t\\\"%s\\\"\", comma, id->ptx_name);\n   fprintf (out, \"\\n};\\n\\n\");\n \n   /* Dump out function idents.  */\n@@ -309,7 +417,8 @@ process (FILE *in, FILE *out, uint32_t omp_requires)\n \t   \"  unsigned short dim[%d];\\n\"\n \t   \"} func_mappings[] = {\\n\", GOMP_DIM_MAX);\n   for (comma = \"\", id = func_ids; id; comma = \",\", id = id->next)\n-    fprintf (out, \"%s\\n\\t{%s}\", comma, id->ptx_name);\n+    fprintf (out, \"%s\\n\\t{\\\"%s\\\"%s}\", comma, id->ptx_name,\n+\t     id->dim ? id->dim : \"\");\n   fprintf (out, \"\\n};\\n\\n\");\n \n   fprintf (out,"}, {"sha": "49cc681417838b09660299cfea6fa273756dd89a", "filename": "gcc/config/nvptx/nvptx.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50be486dff4ea2676ed022e9524ef190b92ae2b1/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50be486dff4ea2676ed022e9524ef190b92ae2b1/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc?ref=50be486dff4ea2676ed022e9524ef190b92ae2b1", "patch": "@@ -988,15 +988,15 @@ write_var_marker (FILE *file, bool is_defn, bool globalize, const char *name)\n \n static void\n write_fn_proto_1 (std::stringstream &s, bool is_defn,\n-\t\t  const char *name, const_tree decl)\n+\t\t  const char *name, const_tree decl, bool force_public)\n {\n   if (lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl)) == NULL)\n-    write_fn_marker (s, is_defn, TREE_PUBLIC (decl), name);\n+    write_fn_marker (s, is_defn, TREE_PUBLIC (decl) || force_public, name);\n \n   /* PTX declaration.  */\n   if (DECL_EXTERNAL (decl))\n     s << \".extern \";\n-  else if (TREE_PUBLIC (decl))\n+  else if (TREE_PUBLIC (decl) || force_public)\n     s << (DECL_WEAK (decl) ? \".weak \" : \".visible \");\n   s << (write_as_kernel (DECL_ATTRIBUTES (decl)) ? \".entry \" : \".func \");\n \n@@ -1085,7 +1085,7 @@ write_fn_proto_1 (std::stringstream &s, bool is_defn,\n \n static void\n write_fn_proto (std::stringstream &s, bool is_defn,\n-\t\tconst char *name, const_tree decl)\n+\t\tconst char *name, const_tree decl, bool force_public=false)\n {\n   const char *replacement = nvptx_name_replacement (name);\n   char *replaced_dots = NULL;\n@@ -1102,9 +1102,9 @@ write_fn_proto (std::stringstream &s, bool is_defn,\n \n   if (is_defn)\n     /* Emit a declaration.  The PTX assembler gets upset without it.  */\n-    write_fn_proto_1 (s, false, name, decl);\n+    write_fn_proto_1 (s, false, name, decl, force_public);\n \n-  write_fn_proto_1 (s, is_defn, name, decl);\n+  write_fn_proto_1 (s, is_defn, name, decl, force_public);\n \n   if (replaced_dots)\n     XDELETE (replaced_dots);\n@@ -1480,7 +1480,13 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   tree fntype = TREE_TYPE (decl);\n   tree result_type = TREE_TYPE (fntype);\n   int argno = 0;\n+  bool force_public = false;\n \n+  /* For reverse-offload 'nohost' functions: In order to be collectable in\n+     '$offload_func_table', cf. mkoffload.cc, the function has to be visible. */\n+  if (lookup_attribute (\"omp target device_ancestor_nohost\",\n+\t\t\tDECL_ATTRIBUTES (decl)))\n+    force_public = true;\n   if (lookup_attribute (\"omp target entrypoint\", DECL_ATTRIBUTES (decl))\n       && !lookup_attribute (\"oacc function\", DECL_ATTRIBUTES (decl)))\n     {\n@@ -1492,7 +1498,7 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   /* We construct the initial part of the function into a string\n      stream, in order to share the prototype writing code.  */\n   std::stringstream s;\n-  write_fn_proto (s, true, name, decl);\n+  write_fn_proto (s, true, name, decl, force_public);\n   s << \"{\\n\";\n \n   bool return_in_mem = write_return_type (s, false, result_type);"}, {"sha": "ba6b2298050d6a37b4d476ff96f52613b617a7c4", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50be486dff4ea2676ed022e9524ef190b92ae2b1/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50be486dff4ea2676ed022e9524ef190b92ae2b1/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=50be486dff4ea2676ed022e9524ef190b92ae2b1", "patch": "@@ -1273,7 +1273,7 @@ nvptx_set_clocktick (CUmodule module, struct ptx_device *dev)\n int\n GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n \t\t\t struct addr_pair **target_table,\n-\t\t\t uint64_t **rev_fn_table __attribute__((unused)))\n+\t\t\t uint64_t **rev_fn_table)\n {\n   CUmodule module;\n   const char *const *var_names;\n@@ -1375,6 +1375,23 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n     /* The variable was not in this image.  */\n     targ_tbl->start = targ_tbl->end = 0;\n \n+  if (rev_fn_table && fn_entries == 0)\n+    *rev_fn_table = NULL;\n+  else if (rev_fn_table)\n+    {\n+      CUdeviceptr var;\n+      size_t bytes;\n+      r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &var, &bytes, module,\n+\t\t\t     \"$offload_func_table\");\n+      if (r != CUDA_SUCCESS)\n+\tGOMP_PLUGIN_fatal (\"cuModuleGetGlobal error: %s\", cuda_error (r));\n+      assert (bytes == sizeof (uint64_t) * fn_entries);\n+      *rev_fn_table = GOMP_PLUGIN_malloc (sizeof (uint64_t) * fn_entries);\n+      r = CUDA_CALL_NOCHECK (cuMemcpyDtoH, *rev_fn_table, var, bytes);\n+      if (r != CUDA_SUCCESS)\n+\tGOMP_PLUGIN_fatal (\"cuMemcpyDtoH error: %s\", cuda_error (r));\n+    }\n+\n   nvptx_set_clocktick (module, dev);\n \n   return fn_entries + var_entries + other_entries;"}]}