{"sha": "298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f", "node_id": "C_kwDOANBUbNoAKDI5OGJiZjNjOWJlOTZiNGViMTU4YTMxOWJmMGFlM2RmZDE4ZjllOGY", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-23T21:50:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-13T10:01:20Z"}, "message": "[Ada] Use actual types instead of formal types consistently in debug info\n\nThis makes sure that the objects present in instantiations always have the\nactual type instead of a local variant of the formal type in the debugging\ninformation generated by the compiler (this was already the case when the\nactual type is a record, a protected or a task type).\n\ngcc/ada/\n\n\t* gcc-interface/decl.cc (Gigi_Cloned_Subtype): New function.\n\t(gnat_to_gnu_entity) <E_Signed_Integer_Subtype>: Call it to get the\n\tcloned subtype, if any.\n\t<E_Floating_Point_Subtype>: Likewise.\n\t<E_Array_Subtype>: Likewise.\n\t<E_Record_Subtype>: Likewise.\n\t<E_Access_Subtype>: Likewise.\n\tDeal with all cloned subtypes on the main path.", "tree": {"sha": "db331e0148e6f775e5761bb0f97de2bf4b47f95d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db331e0148e6f775e5761bb0f97de2bf4b47f95d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45808a572bac3d1585c8b7de829f39a931f3555c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45808a572bac3d1585c8b7de829f39a931f3555c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45808a572bac3d1585c8b7de829f39a931f3555c"}], "stats": {"total": 120, "additions": 93, "deletions": 27}, "files": [{"sha": "8449c991e2b6e3b6df08abc01c5f955da94f31c7", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 93, "deletions": 27, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=298bbf3c9be96b4eb158a319bf0ae3dfd18f9e8f", "patch": "@@ -212,6 +212,7 @@ static tree gnat_to_gnu_subprog_type (Entity_Id, bool, bool, tree *);\n static int adjust_packed (tree, tree, int);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n static enum inline_status_t inline_status_for_subprog (Entity_Id);\n+static Entity_Id Gigi_Cloned_Subtype (Entity_Id);\n static tree gnu_ext_name_for_subprog (Entity_Id, tree);\n static void set_nonaliased_component_on_array_type (tree);\n static void set_reverse_storage_order_on_array_type (tree);\n@@ -301,8 +302,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n   const bool foreign = Has_Foreign_Convention (gnat_entity);\n   /* For a type, contains the equivalent GNAT node to be used in gigi.  */\n   Entity_Id gnat_equiv_type = Empty;\n-  /* For a type, contains the GNAT node to be used for back-annotation.  */\n-  Entity_Id gnat_annotate_type = Empty;\n+  /* For a subtype, contains the GNAT node to be used  as cloned subtype.  */\n+  Entity_Id gnat_cloned_subtype = Empty;\n   /* Temporary used to walk the GNAT tree.  */\n   Entity_Id gnat_temp;\n   /* Contains the GCC DECL node which is equivalent to the input GNAT node.\n@@ -1807,6 +1808,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     case E_Modular_Integer_Subtype:\n     case E_Ordinary_Fixed_Point_Subtype:\n     case E_Decimal_Fixed_Point_Subtype:\n+      gnat_cloned_subtype = Gigi_Cloned_Subtype (gnat_entity);\n+      if (Present (gnat_cloned_subtype))\n+\tbreak;\n \n       /* For integral subtypes, we make a new INTEGER_TYPE.  Note that we do\n \t not want to call create_range_type since we would like each subtype\n@@ -2035,6 +2039,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       break;\n \n     case E_Floating_Point_Subtype:\n+      gnat_cloned_subtype = Gigi_Cloned_Subtype (gnat_entity);\n+      if (Present (gnat_cloned_subtype))\n+\tbreak;\n+\n       /* See the E_Signed_Integer_Subtype case for the rationale.  */\n       if (!definition\n \t  && Present (Ancestor_Subtype (gnat_entity))\n@@ -2446,6 +2454,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       break;\n \n     case E_Array_Subtype:\n+      gnat_cloned_subtype = Gigi_Cloned_Subtype (gnat_entity);\n+      if (Present (gnat_cloned_subtype))\n+\tbreak;\n \n       /* This is the actual data type for array variables.  Multidimensional\n \t arrays are implemented as arrays of arrays.  Note that arrays which\n@@ -3443,18 +3454,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       /* ... fall through ... */\n \n     case E_Record_Subtype:\n-      /* If Cloned_Subtype is Present it means this record subtype has\n-\t identical layout to that type or subtype and we should use\n-\t that GCC type for this one.  The front-end guarantees that\n-\t the component list is shared.  */\n-      if (Present (Cloned_Subtype (gnat_entity)))\n-\t{\n-\t  gnu_decl = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity),\n-\t\t\t\t\t NULL_TREE, false);\n-\t  gnat_annotate_type = Cloned_Subtype (gnat_entity);\n-\t  maybe_present = true;\n-\t  break;\n-\t}\n+      gnat_cloned_subtype = Gigi_Cloned_Subtype (gnat_entity);\n+      if (Present (gnat_cloned_subtype))\n+\tbreak;\n \n       /* Otherwise, first ensure the base type is elaborated.  Then, if we are\n \t changing the type, make a new type with each field having the type of\n@@ -3865,6 +3867,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       break;\n \n     case E_Access_Subtype:\n+      gnat_cloned_subtype = Gigi_Cloned_Subtype (gnat_entity);\n+      if (Present (gnat_cloned_subtype))\n+\tbreak;\n+\n       /* We treat this as identical to its base type; any constraint is\n \t meaningful only to the front-end.  */\n       gnu_type = gnat_to_gnu_type (gnat_equiv_type);\n@@ -4277,6 +4283,27 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       gcc_unreachable ();\n     }\n \n+  /* If this is the clone of a subtype, just reuse the cloned subtype; another\n+     approach would be to set the cloned subtype as the DECL_ORIGINAL_TYPE of\n+     the entity, which would generate a DW_TAG_typedef in the debug info, but\n+     at the cost of the duplication of the GCC type and, more annoyingly, of\n+     the need to update the copy if the cloned subtype is not complete yet.  */\n+  if (Present (gnat_cloned_subtype))\n+    {\n+      gnu_decl = gnat_to_gnu_entity (gnat_cloned_subtype, NULL_TREE, false);\n+      maybe_present = true;\n+\n+      if (!TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n+\t{\n+\t  if (!Known_Alignment (gnat_entity))\n+\t    Copy_Alignment (gnat_entity, gnat_cloned_subtype);\n+\t  if (!Known_Esize (gnat_entity))\n+\t    Copy_Esize (gnat_entity, gnat_cloned_subtype);\n+\t  if (!Known_RM_Size (gnat_entity))\n+\t    Copy_RM_Size (gnat_entity, gnat_cloned_subtype);\n+\t}\n+    }\n+\n   /* If we had a case where we evaluated another type and it might have\n      defined this one, handle it here.  */\n   if (maybe_present && present_gnu_tree (gnat_entity))\n@@ -4768,19 +4795,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t}\n     }\n \n-  /* Otherwise, for a type reusing an existing DECL, back-annotate values.  */\n-  else if (is_type\n-\t   && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl))\n-\t   && Present (gnat_annotate_type))\n-    {\n-      if (!Known_Alignment (gnat_entity))\n-\tCopy_Alignment (gnat_entity, gnat_annotate_type);\n-      if (!Known_Esize (gnat_entity))\n-\tCopy_Esize (gnat_entity, gnat_annotate_type);\n-      if (!Known_RM_Size (gnat_entity))\n-\tCopy_RM_Size (gnat_entity, gnat_annotate_type);\n-    }\n-\n   /* If we haven't already, associate the ..._DECL node that we just made with\n      the input GNAT entity node.  */\n   if (!saved)\n@@ -5114,6 +5128,58 @@ finalize_from_limited_with (void)\n     }\n }\n \n+/* Return the cloned subtype to be used for GNAT_ENTITY, if the latter is a\n+   kind of subtype that needs to be considered as a clone by Gigi, otherwise\n+   return Empty.  */\n+\n+static Entity_Id\n+Gigi_Cloned_Subtype (Entity_Id gnat_entity)\n+{\n+  Node_Id gnat_decl;\n+\n+  switch (Ekind (gnat_entity))\n+    {\n+    case E_Class_Wide_Subtype:\n+      if (Present (Equivalent_Type (gnat_entity)))\n+\treturn Empty;\n+\n+      /* ... fall through ... */\n+\n+    case E_Record_Subtype:\n+      /* If Cloned_Subtype is Present, this means that this record subtype has\n+\t the same layout as that of the specified (sub)type, and also that the\n+\t front-end guarantees that the component list is shared.  */\n+      return Cloned_Subtype (gnat_entity);\n+\n+    case E_Access_Subtype:\n+    case E_Array_Subtype:\n+    case E_Signed_Integer_Subtype:\n+    case E_Enumeration_Subtype:\n+    case E_Modular_Integer_Subtype:\n+    case E_Ordinary_Fixed_Point_Subtype:\n+    case E_Decimal_Fixed_Point_Subtype:\n+    case E_Floating_Point_Subtype:\n+      if (Sloc (gnat_entity) == Standard_Location)\n+\tbreak;\n+\n+      /* We return true for the subtypes generated for the actuals of formal\n+\t private types in instantiations, so that these actuals are the types\n+\t of the instantiated objects in the debug info.  */\n+      gnat_decl = Declaration_Node (gnat_entity);\n+      if (Present (gnat_decl)\n+\t  && Nkind (gnat_decl) == N_Subtype_Declaration\n+\t  && Present (Generic_Parent_Type (gnat_decl))\n+\t  && Is_Entity_Name (Subtype_Indication (gnat_decl)))\n+\treturn Entity (Subtype_Indication (gnat_decl));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return Empty;\n+}\n+\n /* Return the equivalent type to be used for GNAT_ENTITY, if it's a kind\n    of type (such E_Task_Type) that has a different type which Gigi uses\n    for its representation.  If the type does not have a special type for"}]}