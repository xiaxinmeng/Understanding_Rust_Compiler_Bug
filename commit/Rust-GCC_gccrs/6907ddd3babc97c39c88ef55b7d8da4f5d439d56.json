{"sha": "6907ddd3babc97c39c88ef55b7d8da4f5d439d56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwN2RkZDNiYWJjOTdjMzljODhlZjU1YjdkOGRhNGY1ZDQzOWQ1Ng==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-07-24T20:44:01Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-07-24T20:44:01Z"}, "message": "c-decl.c (match_builtin_function_types): New subroutine of duplicate_decls to test whether a redeclaration of a builtin...\n\n\n\t* c-decl.c (match_builtin_function_types): New subroutine of\n\tduplicate_decls to test whether a redeclaration of a builtin\n\tfunction is suitably close, i.e. the return type and all of\n\tthe argument types have the same modes as the builtin expects.\n\t(duplicate_decls): Fuzzy type matching for builtin functions\n\tmoved to match_builtin_function_types.\n\nFrom-SVN: r69757", "tree": {"sha": "86d7822a80307d608a67cf5da2611b3f9510a81b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86d7822a80307d608a67cf5da2611b3f9510a81b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6907ddd3babc97c39c88ef55b7d8da4f5d439d56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6907ddd3babc97c39c88ef55b7d8da4f5d439d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6907ddd3babc97c39c88ef55b7d8da4f5d439d56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6907ddd3babc97c39c88ef55b7d8da4f5d439d56/comments", "author": null, "committer": null, "parents": [{"sha": "84d45ad160fc93e5271d3c01f1fe6fd6924584fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d45ad160fc93e5271d3c01f1fe6fd6924584fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d45ad160fc93e5271d3c01f1fe6fd6924584fd"}], "stats": {"total": 93, "additions": 56, "deletions": 37}, "files": [{"sha": "04e88122005cd53e3ebdaf335f2abf92f1d2963c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6907ddd3babc97c39c88ef55b7d8da4f5d439d56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6907ddd3babc97c39c88ef55b7d8da4f5d439d56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6907ddd3babc97c39c88ef55b7d8da4f5d439d56", "patch": "@@ -1,3 +1,12 @@\n+2003-07-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* c-decl.c (match_builtin_function_types): New subroutine of\n+\tduplicate_decls to test whether a redeclaration of a builtin\n+\tfunction is suitably close, i.e. the return type and all of\n+\tthe argument types have the same modes as the builtin expects.\n+\t(duplicate_decls): Fuzzy type matching for builtin functions\n+\tmoved to match_builtin_function_types.\n+\n 2003-07-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* cfgloopmanip.c (duplicate_loop_to_header_edge): Update irreducible"}, {"sha": "9f84f44a860ea3a2190c3a53a2dd589392c56cc2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6907ddd3babc97c39c88ef55b7d8da4f5d439d56/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6907ddd3babc97c39c88ef55b7d8da4f5d439d56/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6907ddd3babc97c39c88ef55b7d8da4f5d439d56", "patch": "@@ -262,6 +262,7 @@ tree static_ctors, static_dtors;\n \n static struct c_scope *make_scope (void);\n static void pop_scope (void);\n+static tree match_builtin_function_types (tree, tree);\n static int duplicate_decls (tree, tree, int, int);\n static int redeclaration_error_message (tree, tree);\n static tree make_label (tree, location_t);\n@@ -691,6 +692,46 @@ pushtag (tree name, tree type)\n   TYPE_CONTEXT (type) = DECL_CONTEXT (TYPE_STUB_DECL (type));\n }\n \f\n+/* Subroutine of duplicate_decls.  Allow harmless mismatches in return\n+   and argument types provided that the type modes match.  This function\n+   return a unified type given a suitable match, and 0 otherwise.  */\n+\n+static tree\n+match_builtin_function_types (tree oldtype, tree newtype)\n+{\n+  tree newrettype, oldrettype;\n+  tree newargs, oldargs;\n+  tree trytype, tryargs;\n+\n+  /* Accept the return type of the new declaration if same modes.  */\n+  oldrettype = TREE_TYPE (oldtype);\n+  newrettype = TREE_TYPE (newtype);\n+\n+  if (TYPE_MODE (oldrettype) != TYPE_MODE (newrettype))\n+    return 0;\n+\n+  oldargs = TYPE_ARG_TYPES (oldtype);\n+  newargs = TYPE_ARG_TYPES (newtype);\n+  tryargs = newargs;\n+\n+  while (oldargs || newargs)\n+    {\n+      if (! oldargs\n+\t  || ! newargs\n+\t  || ! TREE_VALUE (oldargs)\n+\t  || ! TREE_VALUE (newargs)\n+\t  || TYPE_MODE (TREE_VALUE (oldargs))\n+\t     != TYPE_MODE (TREE_VALUE (newargs)))\n+\treturn 0;\n+\n+      oldargs = TREE_CHAIN (oldargs);\n+      newargs = TREE_CHAIN (newargs);\n+    }\n+\n+  trytype = build_function_type (newrettype, tryargs);\n+  return build_type_attribute_variant (trytype, TYPE_ATTRIBUTES (oldtype));\n+}\n+\n /* Handle when a new declaration NEWDECL\n    has the same name as an old one OLDDECL\n    in the same binding contour.\n@@ -822,49 +863,18 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t}\n       else if (!types_match)\n \t{\n-\t  /* Accept the return type of the new declaration if same modes.  */\n-\t  tree oldreturntype = TREE_TYPE (oldtype);\n-\t  tree newreturntype = TREE_TYPE (newtype);\n-\n-\t  if (TYPE_MODE (oldreturntype) == TYPE_MODE (newreturntype))\n-\t    {\n-\t      /* Function types may be shared, so we can't just modify\n-\t\t the return type of olddecl's function type.  */\n-\t      tree trytype\n-\t\t= build_function_type (newreturntype,\n-\t\t\t\t       TYPE_ARG_TYPES (oldtype));\n-\t      trytype = build_type_attribute_variant (trytype,\n-\t\t\t\t\t\t      TYPE_ATTRIBUTES (oldtype));\n-\n-              types_match = comptypes (newtype, trytype, comptype_flags);\n-\t      if (types_match)\n-\t\toldtype = trytype;\n-\t    }\n-\t  /* Accept harmless mismatch in first argument type also.\n+\t  /* Accept harmless mismatch in function types.\n \t     This is for the ffs and fprintf builtins.  */\n-\t  if (TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != 0\n-\t      && TYPE_ARG_TYPES (oldtype) != 0\n-\t      && TREE_VALUE (TYPE_ARG_TYPES (newtype)) != 0\n-\t      && TREE_VALUE (TYPE_ARG_TYPES (oldtype)) != 0\n-\t      && (TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (newtype)))\n-\t\t  == TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (oldtype)))))\n-\t    {\n-\t      /* Function types may be shared, so we can't just modify\n-\t\t the return type of olddecl's function type.  */\n-\t      tree trytype\n-\t\t= build_function_type (TREE_TYPE (oldtype),\n-\t\t\t\t       tree_cons (NULL_TREE,\n-\t\t\t\t\t\t  TREE_VALUE (TYPE_ARG_TYPES (newtype)),\n-\t\t\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (oldtype))));\n-\t      trytype = build_type_attribute_variant (trytype,\n-\t\t\t\t\t\t      TYPE_ATTRIBUTES (oldtype));\n+\t  tree trytype = match_builtin_function_types (oldtype, newtype);\n \n+\t  if (trytype)\n+\t    {\n \t      types_match = comptypes (newtype, trytype, comptype_flags);\n \t      if (types_match)\n \t\toldtype = trytype;\n+\t      if (! different_binding_level)\n+\t\tTREE_TYPE (olddecl) = oldtype;\n \t    }\n-\t  if (! different_binding_level)\n-\t    TREE_TYPE (olddecl) = oldtype;\n \t}\n       else if (TYPE_ARG_TYPES (oldtype) == NULL\n \t       && TYPE_ARG_TYPES (newtype) != NULL)"}]}