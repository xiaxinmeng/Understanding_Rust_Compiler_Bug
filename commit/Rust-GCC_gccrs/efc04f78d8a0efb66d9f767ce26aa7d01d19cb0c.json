{"sha": "efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZjMDRmNzhkOGEwZWZiNjZkOWY3NjdjZTI2YWE3ZDAxZDE5Y2IwYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-01T21:52:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-01T21:52:21Z"}, "message": "re PR rtl-optimization/82778 (crash: insn does not satisfy its constraints)\n\n\tPR rtl-optimization/82778\n\tPR rtl-optimization/82597\n\t* compare-elim.c (struct comparison): Add in_a_setter field.\n\t(find_comparison_dom_walker::before_dom_children): Remove killed\n\tbitmap and df_simulate_find_defs call, instead walk the defs.\n\tCompute last_setter and initialize in_a_setter.  Merge definitions\n\twith first initialization for a few variables.\n\t(try_validate_parallel): Use insn_invalid_p instead of\n\trecog_memoized.  Return insn rather than just the pattern.\n\t(try_merge_compare): Fix up comment.  Don't uselessly test if\n\tin_a is a REG_P.  Use cmp->in_a_setter instead of walking UD\n\tchains.\n\t(execute_compare_elim_after_reload): Remove df_chain_add_problem\n\tcall.\n\n\t* g++.dg/opt/pr82778.C: New test.\n\n2017-11-01  Michael Collison  <michael.collison@arm.com>\n\n\tPR rtl-optimization/82597\n\t* gcc.dg/pr82597.c: New test.\n\nFrom-SVN: r254328", "tree": {"sha": "8e09ee941e9cc82242b067bfc23517090dff25aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e09ee941e9cc82242b067bfc23517090dff25aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/comments", "author": null, "committer": null, "parents": [{"sha": "fe1447a1d7ed8945404176fc0941a380682e5f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1447a1d7ed8945404176fc0941a380682e5f11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1447a1d7ed8945404176fc0941a380682e5f11"}], "stats": {"total": 221, "additions": 165, "deletions": 56}, "files": [{"sha": "b903d22ca7d9fd8542468a5873b4b7c2942b32ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "patch": "@@ -1,3 +1,25 @@\n+2017-11-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/82778\n+\tPR rtl-optimization/82597\n+\t* compare-elim.c (struct comparison): Add in_a_setter field.\n+\t(find_comparison_dom_walker::before_dom_children): Remove killed\n+\tbitmap and df_simulate_find_defs call, instead walk the defs.\n+\tCompute last_setter and initialize in_a_setter.  Merge definitions\n+\twith first initialization for a few variables.\n+\t(try_validate_parallel): Use insn_invalid_p instead of\n+\trecog_memoized.  Return insn rather than just the pattern.\n+\t(try_merge_compare): Fix up comment.  Don't uselessly test if\n+\tin_a is a REG_P.  Use cmp->in_a_setter instead of walking UD\n+\tchains.\n+\t(execute_compare_elim_after_reload): Remove df_chain_add_problem\n+\tcall.\n+\n+2017-11-01  Michael Collison  <michael.collison@arm.com>\n+\n+\tPR rtl-optimization/82597\n+\t* gcc.dg/pr82597.c: New test.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "17d08842d159783093a01524f5163179de6e5f42", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "patch": "@@ -97,6 +97,9 @@ struct comparison\n   /* The insn prior to the comparison insn that clobbers the flags.  */\n   rtx_insn *prev_clobber;\n \n+  /* The insn prior to the comparison insn that sets in_a REG.  */\n+  rtx_insn *in_a_setter;\n+\n   /* The two values being compared.  These will be either REGs or\n      constants.  */\n   rtx in_a, in_b;\n@@ -309,26 +312,22 @@ can_eliminate_compare (rtx compare, rtx eh_note, struct comparison *cmp)\n edge\n find_comparison_dom_walker::before_dom_children (basic_block bb)\n {\n-  struct comparison *last_cmp;\n-  rtx_insn *insn, *next, *last_clobber;\n-  bool last_cmp_valid;\n+  rtx_insn *insn, *next;\n   bool need_purge = false;\n-  bitmap killed;\n-\n-  killed = BITMAP_ALLOC (NULL);\n+  rtx_insn *last_setter[FIRST_PSEUDO_REGISTER];\n \n   /* The last comparison that was made.  Will be reset to NULL\n      once the flags are clobbered.  */\n-  last_cmp = NULL;\n+  struct comparison *last_cmp = NULL;\n \n   /* True iff the last comparison has not been clobbered, nor\n      have its inputs.  Used to eliminate duplicate compares.  */\n-  last_cmp_valid = false;\n+  bool last_cmp_valid = false;\n \n   /* The last insn that clobbered the flags, if that insn is of\n      a form that may be valid for eliminating a following compare.\n      To be reset to NULL once the flags are set otherwise.  */\n-  last_clobber = NULL;\n+  rtx_insn *last_clobber = NULL;\n \n   /* Propagate the last live comparison throughout the extended basic block. */\n   if (single_pred_p (bb))\n@@ -338,6 +337,7 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \tlast_cmp_valid = last_cmp->inputs_valid;\n     }\n \n+  memset (last_setter, 0, sizeof (last_setter));\n   for (insn = BB_HEAD (bb); insn; insn = next)\n     {\n       rtx src;\n@@ -346,10 +346,6 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n       if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n-      /* Compute the set of registers modified by this instruction.  */\n-      bitmap_clear (killed);\n-      df_simulate_find_defs (insn, killed);\n-\n       src = conforming_compare (insn);\n       if (src)\n \t{\n@@ -373,6 +369,13 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \t  last_cmp->in_b = XEXP (src, 1);\n \t  last_cmp->eh_note = eh_note;\n \t  last_cmp->orig_mode = GET_MODE (src);\n+\t  if (last_cmp->in_b == const0_rtx\n+\t      && last_setter[REGNO (last_cmp->in_a)])\n+\t    {\n+\t      rtx set = single_set (last_setter[REGNO (last_cmp->in_a)]);\n+\t      if (set && rtx_equal_p (SET_DEST (set), last_cmp->in_a))\n+\t\tlast_cmp->in_a_setter = last_setter[REGNO (last_cmp->in_a)];\n+\t    }\n \t  all_compares.safe_push (last_cmp);\n \n \t  /* It's unusual, but be prepared for comparison patterns that\n@@ -388,28 +391,36 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \t    find_flags_uses_in_insn (last_cmp, insn);\n \n \t  /* Notice if this instruction kills the flags register.  */\n-\t  if (bitmap_bit_p (killed, targetm.flags_regnum))\n-\t    {\n-\t      /* See if this insn could be the \"clobber\" that eliminates\n-\t\t a future comparison.   */\n-\t      last_clobber = (arithmetic_flags_clobber_p (insn) ? insn : NULL);\n-\n-\t      /* In either case, the previous compare is no longer valid.  */\n-\t      last_cmp = NULL;\n-\t      last_cmp_valid = false;\n-\t    }\n+\t  df_ref def;\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    if (DF_REF_REGNO (def) == targetm.flags_regnum)\n+\t      {\n+\t\t/* See if this insn could be the \"clobber\" that eliminates\n+\t\t   a future comparison.   */\n+\t\tlast_clobber = (arithmetic_flags_clobber_p (insn)\n+\t\t\t\t? insn : NULL);\n+\n+\t\t/* In either case, the previous compare is no longer valid.  */\n+\t\tlast_cmp = NULL;\n+\t\tlast_cmp_valid = false;\n+\t\tbreak;\n+\t      }\n \t}\n \n-      /* Notice if any of the inputs to the comparison have changed.  */\n-      if (last_cmp_valid\n-\t  && (bitmap_bit_p (killed, REGNO (last_cmp->in_a))\n-\t      || (REG_P (last_cmp->in_b)\n-\t\t  && bitmap_bit_p (killed, REGNO (last_cmp->in_b)))))\n-\tlast_cmp_valid = false;\n+      /* Notice if any of the inputs to the comparison have changed\n+\t and remember last insn that sets each register.  */\n+      df_ref def;\n+      FOR_EACH_INSN_DEF (def, insn)\n+\t{\n+\t  if (last_cmp_valid\n+\t      && (DF_REF_REGNO (def) == REGNO (last_cmp->in_a)\n+\t\t  || (REG_P (last_cmp->in_b)\n+\t\t      && DF_REF_REGNO (def) == REGNO (last_cmp->in_b))))\n+\t    last_cmp_valid = false;\n+\t  last_setter[DF_REF_REGNO (def)] = insn;\n+\t}\n     }\n \n-  BITMAP_FREE (killed);\n-\n   /* Remember the live comparison for subsequent members of\n      the extended basic block.  */\n   if (last_cmp)\n@@ -625,13 +636,19 @@ can_merge_compare_into_arith (rtx_insn *cmp_insn, rtx_insn *arith_insn)\n static rtx\n try_validate_parallel (rtx set_a, rtx set_b)\n {\n-  rtx par\n-    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set_a, set_b));\n+  rtx par = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set_a, set_b));\n+  rtx_insn *insn = make_insn_raw (par);\n \n-  rtx_insn *insn;\n-  insn = gen_rtx_INSN (VOIDmode, 0, 0, 0, par, 0, -1, 0);\n+  if (insn_invalid_p (insn, false))\n+    {\n+      crtl->emit.x_cur_insn_uid--;\n+      return NULL_RTX;\n+    }\n \n-  return recog_memoized (insn) > 0 ? par : NULL_RTX;\n+  SET_PREV_INSN (insn) = NULL_RTX;\n+  SET_NEXT_INSN (insn) = NULL_RTX;\n+  INSN_LOCATION (insn) = 0;\n+  return insn;\n }\n \n /* For a comparison instruction described by CMP check if it compares a\n@@ -643,7 +660,7 @@ try_validate_parallel (rtx set_a, rtx set_b)\n    <instructions that don't read the condition register>\n    I2: CC := CMP R1 0\n    I2 can be merged with I1 into:\n-   I1: { R1 := R2 + R3 ; CC := CMP (R2 + R3) 0 }\n+   I1: { CC := CMP (R2 + R3) 0 ; R1 := R2 + R3 }\n    This catches cases where R1 is used between I1 and I2 and therefore\n    combine and other RTL optimisations will not try to propagate it into\n    I2.  Return true if we succeeded in merging CMP.  */\n@@ -653,7 +670,7 @@ try_merge_compare (struct comparison *cmp)\n {\n   rtx_insn *cmp_insn = cmp->insn;\n \n-  if (!REG_P (cmp->in_a) || cmp->in_b != const0_rtx)\n+  if (cmp->in_b != const0_rtx || cmp->in_a_setter == NULL)\n     return false;\n   rtx in_a = cmp->in_a;\n   df_ref use;\n@@ -664,24 +681,8 @@ try_merge_compare (struct comparison *cmp)\n   if (!use)\n     return false;\n \n-  /* Validate the data flow information before attempting to\n-     find the instruction that defines in_a.  */\n-\n-  struct df_link *ref_chain;\n-  ref_chain = DF_REF_CHAIN (use);\n-  if (!ref_chain || !ref_chain->ref\n-      || !DF_REF_INSN_INFO (ref_chain->ref) || ref_chain->next != NULL)\n-    return false;\n-\n-  rtx_insn *def_insn = DF_REF_INSN (ref_chain->ref);\n-  /* We found the insn that defines in_a.  Only consider the cases where\n-     it is in the same block as the comparison.  */\n-  if (BLOCK_FOR_INSN (cmp_insn) != BLOCK_FOR_INSN (def_insn))\n-    return false;\n-\n+  rtx_insn *def_insn = cmp->in_a_setter;\n   rtx set = single_set (def_insn);\n-  if (!set)\n-    return false;\n \n   if (!can_merge_compare_into_arith (cmp_insn, def_insn))\n     return false;\n@@ -855,7 +856,6 @@ try_eliminate_compare (struct comparison *cmp)\n static unsigned int\n execute_compare_elim_after_reload (void)\n {\n-  df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n   df_analyze ();\n \n   gcc_checking_assert (!all_compares.exists ());"}, {"sha": "eba8154804f5af39e9ce02f2bf0687a72503191e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "patch": "@@ -1,3 +1,13 @@\n+2017-11-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/82778\n+\t* g++.dg/opt/pr82778.C: New test.\n+\n+2017-11-01  Michael Collison  <michael.collison@arm.com>\n+\n+\tPR rtl-optimization/82597\n+\t* gcc.dg/pr82597.c: New test.\n+\n 2017-11-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/alpha/sqrt.c: New test."}, {"sha": "eeac0c5f38b3e155b8c465f80019b2e5b932b07f", "filename": "gcc/testsuite/g++.dg/opt/pr82778.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr82778.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr82778.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr82778.C?ref=efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "patch": "@@ -0,0 +1,37 @@\n+// PR rtl-optimization/82778\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+\n+template <typename a, int b> struct c {\n+  typedef a d[b];\n+  static a e(d f, int g) { return f[g]; }\n+};\n+template <typename a, int b> struct B {\n+  typedef c<a, b> h;\n+  typename h::d i;\n+  long j;\n+  a at() { return h::e(i, j); }\n+};\n+int k, m, r, s, t;\n+char l, n, q;\n+short o, p, w;\n+struct C {\n+  int u;\n+};\n+B<C, 4> v;\n+void x() {\n+  if (((p > (q ? v.at().u : k)) >> l - 226) + !(n ^ r * m))\n+    s = ((-(((p > (q ? v.at().u : k)) >> l - 226) + !(n ^ r * m)) < 0) /\n+             (-(((p > (q ? v.at().u : k)) >> l - 226) + !(n ^ r * m)) ^\n+              -25 & o) &&\n+         p) >>\n+        (0 <= 0\n+             ? 0 ||\n+                   (-(((p > (q ? v.at().u : k)) >> l - 226) + !(n ^ r * m)) <\n+                    0) /\n+                       (-(((p > (q ? v.at().u : k)) >> l - 226) +\n+                          !(n ^ r * m)) ^ -25 & o)\n+             : 0);\n+  w = (p > (q ? v.at().u : k)) >> l - 226;\n+  t = !(n ^ r * m);\n+}"}, {"sha": "98ae264d1c9e68c1f5d4a58720ba4c9d7609f5fc", "filename": "gcc/testsuite/gcc.dg/pr82597.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr82597.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr82597.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr82597.c?ref=efc04f78d8a0efb66d9f767ce26aa7d01d19cb0c", "patch": "@@ -0,0 +1,40 @@\n+/* PR rtl-optimization/82597 */\n+/* { dg-do compile  }*/\n+/* { dg-options \"-O2 -funroll-loops\" } */\n+\n+int pb;\n+\n+void\n+ch (unsigned char np, char fc)\n+{\n+  unsigned char *y6 = &np;\n+\n+  if (fc != 0)\n+    {\n+      unsigned char *z1 = &np;\n+\n+      for (;;)\n+        if (*y6 != 0)\n+          for (fc = 0; fc < 12; ++fc)\n+            {\n+              int hh;\n+              int tp;\n+\n+              if (fc != 0)\n+                hh = (*z1 != 0) ? fc : 0;\n+              else\n+                hh = pb;\n+\n+              tp = fc > 0;\n+              if (hh == tp)\n+                *y6 = 1;\n+            }\n+    }\n+\n+  if (np != 0)\n+    y6 = (unsigned char *)&fc;\n+  if (pb != 0 && *y6 != 0)\n+    for (;;)\n+      {\n+      }\n+}"}]}