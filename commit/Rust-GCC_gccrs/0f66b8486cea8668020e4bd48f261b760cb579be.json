{"sha": "0f66b8486cea8668020e4bd48f261b760cb579be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY2NmI4NDg2Y2VhODY2ODAyMGU0YmQ0OGYyNjFiNzYwY2I1NzliZQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-07-11T07:49:33Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-07-16T21:01:52Z"}, "message": "coroutines: Correct frame capture of compiler temps [PR95591+4].\n\nWhen a full expression contains a co_await (or co_yield), this means\nthat it might be suspended; which would destroy temporary variables\n(on a stack for example).  However the language guarantees that such\ntemporaries are live until the end of the expression.\n\nIn order to preserve this, we 'promote' temporaries where necessary\nso that they are saved in the coroutine frame (which allows them to\nremain live potentially until the frame is destroyed).  In addition,\nsub-expressions that produce control flow (such as TRUTH_AND/OR_IF\nor COND_EXPR) must be handled specifically to ensure that await\nexpressions are properly expanded.\n\nThis patch corrects two mistakes in which we were (a) failing to\npromote some temporaries and (b) we we failing to sequence DTORs for\nthe captures properly. This manifests in a number of related (but not\nexact duplicate) PRs.\n\nThe revised code collects the actions into one place and maps all the\ncontrol flow into one form - a benefit of this is that co_returns are\nnow expanded earlier (which provides an opportunity to address PR95517\nin some future patch).\n\nWe replace a statement that contains await expression(s) with a bind\nscope that has a variable list describing the temporaries that have\nbeen 'promoted' and a statement list that contains a series of cleanup\nexpressions for each of those.  Where we encounter nested conditional\nexpressions, these are wrapped in a try-finally block with a guard var\nfor each sub-expression variable that needs a DTOR.  The guards are all\ndeclared and initialized to false before the first conditional sub-\nexpression.  The 'finally' block contains a series of if blocks (one\nper guard variable) enclosing the relevant DTOR.\n\nVariables listed in a bind scope in this manner are automatically moved\nto a coroutine frame version by existing code (so we re-use that rather\nthan having a separate mechanism).\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95591\n\tPR c++/95599\n\tPR c++/95823\n\tPR c++/95824\n\tPR c++/95895\n\t* coroutines.cc (struct coro_ret_data): Delete.\n\t(coro_maybe_expand_co_return): Delete.\n\t(co_return_expander): Delete.\n\t(expand_co_returns): Delete.\n\t(co_await_find_in_subtree): Remove unused name.\n\t(build_actor_fn): Remove unused parm, remove handling\n\tfor co_return expansion.\n\t(register_await_info): Demote duplicate info message to a\n\twarning.\n\t(coro_make_frame_entry): Move closer to use site.\n\t(struct susp_frame_data): Add fields for final suspend label\n\tand a flag to indicate await expressions with initializers.\n\t(captures_temporary): Delete.\n\t(register_awaits): Remove unused code, update comments.\n\t(find_any_await): New.\n\t(tmp_target_expr_p): New.\n\t(struct interesting): New.\n\t(find_interesting_subtree): New.\n\t(struct var_nest_node): New.\n\t(flatten_await_stmt): New.\n\t(handle_nested_conditionals): New.\n\t(process_conditional): New.\n\t(replace_statement_captures): Rename to...\n\t(maybe_promote_temps): ... this.\n\t(maybe_promote_captured_temps): Delete.\n\t(analyze_expression_awaits): Check for await expressions with\n\tinitializers.  Simplify handling for truth-and/or-if.\n\t(expand_one_truth_if): Simplify (map cases that need expansion\n\tto COND_EXPR).\n\t(await_statement_walker): Handle CO_RETURN_EXPR. Simplify the\n\thandling for truth-and/or-if expressions.\n\t(register_local_var_uses): Ensure that we create names in the\n\timplementation namespace.\n\t(morph_fn_to_coro): Add final suspend label to suspend frame\n\tcallback data and remove it from the build_actor_fn call.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95591\n\tPR c++/95599\n\tPR c++/95823\n\tPR c++/95824\n\tPR c++/95895\n\t* g++.dg/coroutines/pr95591.C: New test.\n\t* g++.dg/coroutines/pr95599.C: New test.\n\t* g++.dg/coroutines/pr95823.C: New test.\n\t* g++.dg/coroutines/pr95824.C: New test.", "tree": {"sha": "c47cbe9dec08a301132b30d155cc8af18f8e62ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c47cbe9dec08a301132b30d155cc8af18f8e62ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f66b8486cea8668020e4bd48f261b760cb579be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f66b8486cea8668020e4bd48f261b760cb579be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f66b8486cea8668020e4bd48f261b760cb579be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f66b8486cea8668020e4bd48f261b760cb579be/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75edc31f9ebe7f8b933860981a124f7f0993214b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75edc31f9ebe7f8b933860981a124f7f0993214b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75edc31f9ebe7f8b933860981a124f7f0993214b"}], "stats": {"total": 1290, "additions": 816, "deletions": 474}, "files": [{"sha": "84b6a4edec580a0295a0948755b4167266b9d604", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 654, "deletions": 474, "changes": 1128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=0f66b8486cea8668020e4bd48f261b760cb579be", "patch": "@@ -1390,119 +1390,6 @@ replace_proxy (tree *here, int *do_subtree, void *d)\n   return NULL_TREE;\n }\n \n-/* Support for expansion of co_return statements.  */\n-\n-struct coro_ret_data\n-{\n-  tree promise_proxy;\n-  tree real_promise;\n-  tree fs_label;\n-};\n-\n-/* If this is a coreturn statement (or one wrapped in a cleanup) then\n-   return the list of statements to replace it.  */\n-\n-static tree\n-coro_maybe_expand_co_return (tree co_ret_expr, coro_ret_data *data)\n-{\n-  /* Look inside <(void) (expr)> cleanup */\n-  if (TREE_CODE (co_ret_expr) == CLEANUP_POINT_EXPR)\n-    co_ret_expr = TREE_OPERAND (co_ret_expr, 0);\n-\n-  if (TREE_CODE (co_ret_expr) != CO_RETURN_EXPR)\n-    return NULL_TREE;\n-\n-  location_t loc = EXPR_LOCATION (co_ret_expr);\n-  tree expr = TREE_OPERAND (co_ret_expr, 0);\n-  tree call = TREE_OPERAND (co_ret_expr, 1);\n-  tree stmt_list = NULL;\n-  if (expr && VOID_TYPE_P (TREE_TYPE (expr)))\n-    {\n-       /* [stmt.return.coroutine], 2.2 \n-\t  If expr is present and void, it is placed immediately before\n-\t  the call for return_void;  */\n-      expr = maybe_cleanup_point_expr_void (expr);\n-      append_to_statement_list (expr, &stmt_list);\n-    }\n-\n-  /* Now replace the promise proxy with its real value.  */\n-  proxy_replace p_data;\n-  p_data.from = data->promise_proxy;\n-  p_data.to = data->real_promise;\n-  cp_walk_tree (&call, replace_proxy, &p_data, NULL);\n-\n-  /* The types of p.return_void and p.return_value are not explicitly stated\n-     at least in n4835, it is expected that they will return void.  */\n-  call = maybe_cleanup_point_expr_void (call);\n-  append_to_statement_list (call, &stmt_list);\n-  tree r = build1_loc (loc, GOTO_EXPR, void_type_node, data->fs_label);\n-  append_to_statement_list (r, &stmt_list);\n-  return stmt_list;\n-}\n-\n-/* Callback that rewrites co_return as per [stmt.return.coroutine]\n-   - for co_return;\n-   { p.return_void (); goto final_suspend; }\n-   - for co_return [void expr];\n-   { expr; p.return_void(); goto final_suspend;}\n-   - for co_return [non void expr];\n-   { p.return_value(expr); goto final_suspend; }  */\n-\n-static tree\n-co_return_expander (tree *stmt, int *do_subtree, void *d)\n-{\n-  coro_ret_data *data = (coro_ret_data *) d;\n-\n-  /* To avoid nesting statement lists, walk them and insert as needed.  */\n-  if (TREE_CODE (*stmt) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator i;\n-      for (i = tsi_start (*stmt); !tsi_end_p (i); tsi_next (&i))\n-\t{\n-\t  tree *new_stmt = tsi_stmt_ptr (i);\n-\t  tree replace = coro_maybe_expand_co_return (*new_stmt, data);\n-\t  /* If we got something, it will be list and we want to splice\n-\t     it in.  */\n-\t  if (replace != NULL_TREE)\n-\t    {\n-\t      /* Splice it in ... */\n-\t      tsi_link_before (&i, replace, TSI_SAME_STMT);\n-\t      /* ... and delete what we expanded.  */\n-\t      tsi_delink (&i);\n-\t      /* Maybe, even likely, we replaced the last in the list.  */\n-\t      if (tsi_end_p (i))\n-\t\tbreak;\n-\t    }\n-\t  else /* Continue the walk.  */\n-\t    cp_walk_tree (new_stmt, co_return_expander, d, NULL);\n-\t}\n-      *do_subtree = 0; /* Done subtrees.  */\n-    }\n-  else\n-    {\n-      /* We might have a single co_return statement, in which case, we do\n-\t have to replace it with a list.  */\n-      tree replace = coro_maybe_expand_co_return (*stmt, data);\n-      if (replace != NULL_TREE)\n-\t{\n-\t  *stmt = replace;\n-\t  *do_subtree = 0; /* Done here.  */\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Walk the original function body, rewriting co_returns.  */\n-\n-static tree\n-expand_co_returns (tree *fnbody, tree promise_proxy, tree promise,\n-\t\t   tree fs_label)\n-{\n-  coro_ret_data data = {promise_proxy, promise, fs_label};\n-  cp_walk_tree (fnbody, co_return_expander, &data, NULL);\n-  return *fnbody;\n-}\n-\n /* Support for expansion of co_await statements.  */\n \n struct coro_aw_data\n@@ -1527,7 +1414,7 @@ struct coro_aw_data\n    awaits.  */\n \n static tree\n-co_await_find_in_subtree (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n+co_await_find_in_subtree (tree *stmt, int *, void *d)\n {\n   tree **p = (tree **) d;\n   if (TREE_CODE (*stmt) == CO_AWAIT_EXPR)\n@@ -2090,8 +1977,7 @@ static void\n build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t\ttree orig, hash_map<tree, param_info> *param_uses,\n \t\thash_map<tree, local_var_info> *local_var_uses,\n-\t\tvec<tree, va_gc> *param_dtor_list,\n-\t\ttree fs_label, tree resume_fn_field,\n+\t\tvec<tree, va_gc> *param_dtor_list, tree resume_fn_field,\n \t\tunsigned body_count, tree frame_size)\n {\n   verify_stmt_tree (fnbody);\n@@ -2307,9 +2193,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   await_xform_data xform\n     = {actor, actor_frame, promise_proxy, ap, self_h_proxy, ash};\n \n-  /* Expand co_returns in the saved function body  */\n-  fnbody = expand_co_returns (&fnbody, promise_proxy, ap, fs_label);\n-\n   /* Transform the await expressions in the function body.  Only do each\n      await tree once!  */\n   hash_set<tree> pset;\n@@ -2645,7 +2528,7 @@ register_await_info (tree await_expr, tree aw_type, tree aw_nam)\n     = suspend_points->get_or_insert (await_expr, &seen);\n   if (seen)\n     {\n-      error_at (EXPR_LOCATION (await_expr), \"duplicate info for %qE\",\n+      warning_at (EXPR_LOCATION (await_expr), 0, \"duplicate info for %qE\",\n \t\tawait_expr);\n       return false;\n     }\n@@ -2654,26 +2537,14 @@ register_await_info (tree await_expr, tree aw_type, tree aw_nam)\n   return true;\n }\n \n-/* Small helper for the repetitive task of adding a new field to the coro\n-   frame type.  */\n-\n-static tree\n-coro_make_frame_entry (tree *field_list, const char *name, tree fld_type,\n-\t\t       location_t loc)\n-{\n-  tree id = get_identifier (name);\n-  tree decl = build_decl (loc, FIELD_DECL, id, fld_type);\n-  DECL_CHAIN (decl) = *field_list;\n-  *field_list = decl;\n-  return id;\n-}\n-\n /* This data set is used when analyzing statements for await expressions.  */\n+\n struct susp_frame_data\n {\n   /* Function-wide.  */\n   tree *field_list; /* The current coroutine frame field list.  */\n   tree handle_type; /* The self-handle type for this coroutine.  */\n+  tree fs_label;    /* The destination for co_returns.  */\n   vec<tree, va_gc> *block_stack; /* Track block scopes.  */\n   vec<tree, va_gc> *bind_stack;  /* Track current bind expr.  */\n   unsigned await_number;\t /* Which await in the function.  */\n@@ -2685,275 +2556,575 @@ struct susp_frame_data\n   unsigned saw_awaits;\t\t /* Count of awaits in this statement  */\n   bool captures_temporary;\t /* This expr captures temps by ref.  */\n   bool needs_truth_if_exp;\t /* We must expand a truth_if expression.  */\n+  bool has_awaiter_init;\t /* We must handle initializing an awaiter.  */\n };\n \n-/* Walk the sub-tree looking for call expressions that both capture\n-   references and have compiler-temporaries as parms.  */\n+/* If this is an await expression, then count it (both uniquely within the\n+   function and locally within a single statement).  */\n \n static tree\n-captures_temporary (tree *stmt, int *do_subtree, void *d)\n+register_awaits (tree *stmt, int *, void *d)\n {\n+  tree aw_expr = *stmt;\n+\n   /* We should have already lowered co_yields to their co_await.  */\n-  gcc_checking_assert (TREE_CODE (*stmt) != CO_YIELD_EXPR);\n+  gcc_checking_assert (TREE_CODE (aw_expr) != CO_YIELD_EXPR);\n+\n+  if (TREE_CODE (aw_expr) != CO_AWAIT_EXPR)\n+    return NULL_TREE;\n \n-  /* Stop recursing if we see an await expression, the subtrees\n-     of that will be handled when it is processed.  */\n+  /* Count how many awaits the current expression contains.  */\n+  susp_frame_data *data = (susp_frame_data *) d;\n+  data->saw_awaits++;\n+  /* Each await suspend context is unique, this is a function-wide value.  */\n+  data->await_number++;\n+\n+  /* Awaitables should either be user-locals or promoted to coroutine frame\n+     entries at this point, and their initializers should have been broken\n+     out.  */\n+  tree aw = TREE_OPERAND (aw_expr, 1);\n+  gcc_checking_assert (!TREE_OPERAND (aw_expr, 2));\n+\n+  tree aw_field_type = TREE_TYPE (aw);\n+  tree aw_field_nam = NULL_TREE;\n+  register_await_info (aw_expr, aw_field_type, aw_field_nam);\n+\n+  /* Rewrite target expressions on the await_suspend () to remove extraneous\n+     cleanups for the awaitables, which are now promoted to frame vars and\n+     managed via that.  */\n+  tree v = TREE_OPERAND (aw_expr, 3);\n+  tree o = TREE_VEC_ELT (v, 1);\n+  if (TREE_CODE (o) == TARGET_EXPR)\n+    TREE_VEC_ELT (v, 1) = get_target_expr (TREE_OPERAND (o, 1));\n+  return NULL_TREE;\n+}\n+\n+/* There are cases where any await expression is relevant.  */\n+static tree\n+find_any_await (tree *stmt, int *dosub, void *d)\n+{\n   if (TREE_CODE (*stmt) == CO_AWAIT_EXPR)\n     {\n-      *do_subtree = 0;\n-      return NULL_TREE;\n+      *dosub = 0; /* We don't need to consider this any further.  */\n+      tree **p = (tree **) d;\n+      *p = stmt;\n+      return *stmt;\n     }\n+  return NULL_TREE;\n+}\n \n-  /* We're only interested in calls.  */\n-  if (TREE_CODE (*stmt) != CALL_EXPR)\n-    return NULL_TREE;\n+static bool\n+tmp_target_expr_p (tree t)\n+{\n+  if (TREE_CODE (t) != TARGET_EXPR)\n+    return false;\n+  tree v = TREE_OPERAND (t, 0);\n+  if (!DECL_ARTIFICIAL (v))\n+    return false;\n+  if (DECL_NAME (v))\n+    return false;\n+  return true;\n+}\n+\n+/* Structure to record sub-expressions that need to be handled by the\n+   statement flattener.  */\n \n-  /* Does this call capture references?\n-     Strip the ADDRESS_EXPR to get the fn decl and inspect it.  */\n-  tree fn = TREE_OPERAND (CALL_EXPR_FN (*stmt), 0);\n-  bool is_meth = TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE;\n-  tree arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  unsigned offset = 3;\n-  for (unsigned anum = 0; arg != NULL; arg = TREE_CHAIN (arg), anum++)\n+struct coro_interesting_subtree\n+{\n+  tree* entry;\n+  hash_set<tree> *temps_used;\n+};\n+\n+/* tree-walk callback that returns the first encountered sub-expression of\n+   a kind that needs to be handled specifically by the statement flattener.  */\n+\n+static tree\n+find_interesting_subtree (tree *expr_p, int *dosub, void *d)\n+{\n+  tree expr = *expr_p;\n+  coro_interesting_subtree *p = (coro_interesting_subtree *)d;\n+  if (TREE_CODE (expr) == CO_AWAIT_EXPR)\n     {\n-      tree parm_type = TREE_VALUE (arg);\n-      if (anum == 0 && is_meth && INDIRECT_TYPE_P (parm_type))\n+      *dosub = 0; /* We don't need to consider this any further.  */\n+      if (TREE_OPERAND (expr, 2))\n \t{\n-\t  /* Account for 'this' when the fn is a method.  Unless it\n-\t     belongs to a CTOR or DTOR.  */\n-\t  if (DECL_CONSTRUCTOR_P (fn) || DECL_DESTRUCTOR_P (fn))\n-\t    continue;\n+\t  p->entry = expr_p;\n+\t  return expr;\n \t}\n-      else if (!TYPE_REF_P (parm_type))\n-\t/* If it's not a reference, we don't care.  */\n-\tcontinue;\n+    }\n+  else if (tmp_target_expr_p (expr)\n+\t   && !p->temps_used->contains (expr))\n+    {\n+      p->entry = expr_p;\n+      return expr;\n+    }\n \n-      /* Fetch the value presented to the fn.  */\n-      tree parm = TREE_OPERAND (*stmt, anum + offset);\n+  return NULL_TREE;\n+}\n \n-      while (TREE_CODE (parm) == NOP_EXPR)\n-\tparm = TREE_OPERAND (parm, 0);\n+/* Node for a doubly-linked list of promoted variables and their\n+   initializers.  When the initializer is a conditional expression\n+   the 'then' and 'else' clauses are represented by a linked list\n+   attached to then_cl and else_cl respectively.  */\n \n-      /* We only care if we're taking the addr of a temporary.  */\n-      if (TREE_CODE (parm) != ADDR_EXPR)\n-\tcontinue;\n+struct var_nest_node\n+{\n+  var_nest_node () = default;\n+  var_nest_node (tree v, tree i, var_nest_node *p, var_nest_node *n)\n+    : var(v), init(i), prev(p), next(n)\n+    {\n+      if (p)\n+\tp->next = this;\n+      if (n)\n+\tn->prev = this;\n+    }\n+  tree var;\n+  tree init;\n+  var_nest_node *prev;\n+  var_nest_node *next;\n+  var_nest_node *then_cl;\n+  var_nest_node *else_cl;\n+};\n \n-      parm = TREE_OPERAND (parm, 0);\n+/* This is called for single statements from the co-await statement walker.\n+   It checks to see if the statement contains any initializers for awaitables\n+   and if any of these capture items by reference.  */\n \n-      /* In case of component_ref, we need to capture the object of base\n-\t class as if it is temporary object.  There are two possibilities:\n-\t (*base).field and base->field.  */\n-      while (TREE_CODE (parm) == COMPONENT_REF)\n+static void\n+flatten_await_stmt (var_nest_node *n, hash_set<tree> *promoted,\n+\t\t    hash_set<tree> *temps_used, tree *replace_in)\n+{\n+  bool init_expr = false;\n+  switch (TREE_CODE (n->init))\n+    {\n+      default: break;\n+      /* Compound expressions must be flattened specifically.  */\n+      case COMPOUND_EXPR:\n \t{\n-\t  parm = TREE_OPERAND (parm, 0);\n-\t  if (TREE_CODE (parm) == INDIRECT_REF)\n-\t    parm = TREE_OPERAND (parm, 0);\n-\t  STRIP_NOPS (parm);\n+\t  tree first = TREE_OPERAND (n->init, 0);\n+\t  n->init = TREE_OPERAND (n->init, 1);\n+\t  var_nest_node *ins\n+\t    = new var_nest_node(NULL_TREE, first, n->prev, n);\n+\t  /* The compiler (but not the user) can generate temporaries with\n+\t     uses in the second arm of a compound expr.  */\n+\t  flatten_await_stmt (ins, promoted, temps_used, &n->init);\n+\t  flatten_await_stmt (n, promoted, temps_used, NULL);\n+\t  /* The two arms have been processed separately.  */\n+\t  return;\n \t}\n+\tbreak;\n+      /* Handle conditional expressions.  */\n+      case INIT_EXPR:\n+\tinit_expr = true;\n+\t/* FALLTHROUGH */\n+      case MODIFY_EXPR:\n+\t{\n+\t  tree old_expr = TREE_OPERAND (n->init, 1);\n+\t  if (TREE_CODE (old_expr) == COMPOUND_EXPR)\n+\t    {\n+\t      tree first = TREE_OPERAND (old_expr, 0);\n+\t      TREE_OPERAND (n->init, 1) = TREE_OPERAND (old_expr, 1);\n+\t      var_nest_node *ins\n+\t\t= new var_nest_node(NULL_TREE, first, n->prev, n);\n+\t      flatten_await_stmt (ins, promoted, temps_used,\n+\t\t\t\t  &TREE_OPERAND (n->init, 1));\n+\t      flatten_await_stmt (n, promoted, temps_used, NULL);\n+\t      return;\n+\t    }\n+\t  if (TREE_CODE (old_expr) != COND_EXPR)\n+\t    break;\n+\t  /* Reconstruct x = t ? y : z;\n+\t     as (void) t ? x = y : x = z;  */\n+\t  tree var = TREE_OPERAND (n->init, 0);\n+\t  tree var_type = TREE_TYPE (var);\n+\t  tree cond = COND_EXPR_COND (old_expr);\n+\t  /* We are allowed a void type throw in one or both of the cond\n+\t     expr arms.  */\n+\t  tree then_cl = COND_EXPR_THEN (old_expr);\n+\t  if (!VOID_TYPE_P (TREE_TYPE (then_cl)))\n+\t    {\n+\t      gcc_checking_assert (TREE_CODE (then_cl) != STATEMENT_LIST);\n+\t      then_cl\n+\t\t= build2 (init_expr ? INIT_EXPR : MODIFY_EXPR, var_type,\n+\t\t\t  var, then_cl);\n+\t    }\n+\t  tree else_cl = COND_EXPR_ELSE (old_expr);\n+\t  if (!VOID_TYPE_P (TREE_TYPE (else_cl)))\n+\t    {\n+\t      gcc_checking_assert (TREE_CODE (then_cl) != STATEMENT_LIST);\n+\t      else_cl\n+\t\t= build2 (init_expr ? INIT_EXPR : MODIFY_EXPR, var_type,\n+\t\t\t  var, else_cl);\n+\t    }\n+\t  n->init = build3 (COND_EXPR, var_type, cond, then_cl, else_cl);\n+\t}\n+\t/* FALLTHROUGH */\n+      case COND_EXPR:\n+\t{\n+\t  tree *found;\n+\t  tree cond = COND_EXPR_COND (n->init);\n+\t  /* If the condition contains an await expression, then we need to\n+\t     set that first and use a separate var.  */\n+\t  if (cp_walk_tree (&cond, find_any_await, &found, NULL))\n+\t    {\n+\t      tree cond_type = TREE_TYPE (cond);\n+\t      tree cond_var  = build_lang_decl (VAR_DECL, NULL_TREE, cond_type);\n+\t      DECL_ARTIFICIAL (cond_var) = true;\n+\t      layout_decl (cond_var, 0);\n+\t      gcc_checking_assert (!TYPE_NEEDS_CONSTRUCTING (cond_type));\n+\t      cond = build2 (INIT_EXPR, cond_type, cond_var, cond);\n+\t      var_nest_node *ins\n+\t\t= new var_nest_node (cond_var, cond, n->prev, n);\n+\t      COND_EXPR_COND (n->init) = cond_var;\n+\t      flatten_await_stmt (ins, promoted, temps_used, NULL);\n+\t    }\n \n-      /* This isn't a temporary.  */\n-      if ((VAR_P (parm)\n-\t   && (!DECL_ARTIFICIAL (parm) || DECL_HAS_VALUE_EXPR_P (parm)))\n-\t  || TREE_CODE (parm) == PARM_DECL\n-\t  || TREE_CODE (parm) == NON_LVALUE_EXPR)\n-\tcontinue;\n-\n-      if (TREE_CODE (parm) == TARGET_EXPR)\n+\t  n->then_cl\n+\t    = new var_nest_node (n->var, COND_EXPR_THEN (n->init), NULL, NULL);\n+\t  n->else_cl\n+\t    = new var_nest_node (n->var, COND_EXPR_ELSE (n->init), NULL, NULL);\n+\t  flatten_await_stmt (n->then_cl, promoted, temps_used, NULL);\n+\t  /* Point to the start of the flattened code.  */\n+\t  while (n->then_cl->prev)\n+\t    n->then_cl = n->then_cl->prev;\n+\t  flatten_await_stmt (n->else_cl, promoted, temps_used, NULL);\n+\t  while (n->else_cl->prev)\n+\t    n->else_cl = n->else_cl->prev;\n+\t  return;\n+\t}\n+\tbreak;\n+    }\n+  coro_interesting_subtree v = { NULL, temps_used };\n+  tree t = cp_walk_tree (&n->init, find_interesting_subtree, (void *)&v, NULL);\n+  if (!t)\n+    return;\n+  switch (TREE_CODE (t))\n+    {\n+      default: break;\n+      case CO_AWAIT_EXPR:\n \t{\n-\t  /* We're taking the address of a temporary and using it as a ref.  */\n-\t  tree tvar = TREE_OPERAND (parm, 0);\n-\t  gcc_checking_assert (DECL_ARTIFICIAL (tvar));\n-\n-\t  susp_frame_data *data = (susp_frame_data *) d;\n-\t  data->captures_temporary = true;\n-\t  /* Record this one so we don't duplicate, and on the first\n-\t     occurrence note the target expr to be replaced.  */\n-\t  if (!data->captured_temps.add (tvar))\n-\t    vec_safe_push (data->to_replace, parm);\n-\t  /* Now see if the initializer contains any more cases.  */\n-\t  hash_set<tree> visited;\n-\t  tree res = cp_walk_tree (&TREE_OPERAND (parm, 1),\n-\t\t\t\t   captures_temporary, d, &visited);\n-\t  if (res)\n-\t    return res;\n-\t  /* Otherwise, we're done with sub-trees for this.  */\n+\t  /* Await expressions with initializers have a compiler-temporary\n+\t     as the awaitable.  'promote' this.  */\n+\t  tree var = TREE_OPERAND (t, 1);\n+\t  bool already_present = promoted->add (var);\n+\t  gcc_checking_assert (!already_present);\n+\t  tree init = TREE_OPERAND (t, 2);\n+\t  switch (TREE_CODE (init))\n+\t    {\n+\t      default: break;\n+\t      case INIT_EXPR:\n+\t      case MODIFY_EXPR:\n+\t\t{\n+\t\t  tree inner = TREE_OPERAND (init, 1);\n+\t\t  /* We can have non-lvalue-expressions here, but when we see\n+\t\t     a target expression, mark it as already used.  */\n+\t\t  if (TREE_CODE (inner) == TARGET_EXPR)\n+\t\t    {\n+\t\t      temps_used->add (inner);\n+\t\t      gcc_checking_assert\n+\t\t\t(TREE_CODE (TREE_OPERAND (inner, 1)) != COND_EXPR);\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\t      case CALL_EXPR:\n+\t\t/* If this is a call and not a CTOR, then we didn't expect it.  */\n+\t\tgcc_checking_assert\n+\t\t  (DECL_CONSTRUCTOR_P (TREE_OPERAND (CALL_EXPR_FN (init), 0)));\n+\t\tbreak;\n+\t    }\n+\t  var_nest_node *ins = new var_nest_node (var, init, n->prev, n);\n+\t  TREE_OPERAND (t, 2) = NULL_TREE;\n+\t  flatten_await_stmt (ins, promoted, temps_used, NULL);\n+\t  flatten_await_stmt (n, promoted, temps_used, NULL);\n+\t  return;\n \t}\n-      else if (TREE_CODE (parm) == CO_AWAIT_EXPR)\n+\tbreak;\n+      case TARGET_EXPR:\n \t{\n-\t  /* CO_AWAIT expressions behave in a similar manner to target\n-\t     expressions when the await_resume call is contained in one.  */\n-\t  tree awr = TREE_OPERAND (parm, 3); /* call vector.  */\n-\t  awr = TREE_VEC_ELT (awr, 2); /* resume call.  */\n-\t  if (TREE_CODE (awr) == TARGET_EXPR)\n+\t  /* We have a temporary; promote it.  */\n+\t  tree init = t;\n+\t  temps_used->add (init);\n+\t  tree var_type = TREE_TYPE (init);\n+\t  char *buf = xasprintf (\"D.%d\", DECL_UID (TREE_OPERAND (init, 0)));\n+\t  tree var = build_lang_decl (VAR_DECL, get_identifier (buf), var_type);\n+\t  DECL_ARTIFICIAL (var) = true;\n+\t  free (buf);\n+\t  bool already_present = promoted->add (var);\n+\t  gcc_checking_assert (!already_present);\n+\t  tree inner = TREE_OPERAND (init, 1);\n+\t  gcc_checking_assert (TREE_CODE (inner) != COND_EXPR);\n+\t  if (TYPE_NEEDS_CONSTRUCTING (var_type))\n \t    {\n-\t      tree tvar = TREE_OPERAND (awr, 0);\n-\t      gcc_checking_assert (DECL_ARTIFICIAL (tvar));\n-\n-\t      susp_frame_data *data = (susp_frame_data *) d;\n-\t      data->captures_temporary = true;\n-\t      /* Use this as a place-holder.  */\n-\t      if (!data->captured_temps.add (tvar))\n-\t\tvec_safe_push (data->to_replace, parm);\n+\t      releasing_vec p_in (make_tree_vector_single (init));\n+\t      init = build_special_member_call (var, complete_ctor_identifier,\n+\t\t\t\t\t\t&p_in, var_type, LOOKUP_NORMAL,\n+\t\t\t\t\t\ttf_warning_or_error);\n \t    }\n-\t/* We will walk the sub-trees of this co_await separately.  */\n+\t  else\n+\t    init = build2 (INIT_EXPR, var_type, var, init);\n+\t  var_nest_node *ins\n+\t    = new var_nest_node (var, init, n->prev, n);\n+\t  /* We have to replace the target expr... */\n+\t  proxy_replace pr = {TREE_OPERAND (t, 0), var};\n+\t  *v.entry = var;\n+\t  /* ... and any uses of its var.  */\n+\t  cp_walk_tree (&n->init, replace_proxy, &pr, NULL);\n+\t  /* Compiler-generated temporaries can also have uses in following\n+\t     arms of compound expressions, which will be listed in 'replace_in'\n+\t     if present.  */\n+\t  if (replace_in)\n+\t    cp_walk_tree (replace_in, replace_proxy, &pr, NULL);\n+\t  flatten_await_stmt (ins, promoted, temps_used, NULL);\n+\t  flatten_await_stmt (n, promoted, temps_used, NULL);\n+\t  return;\n \t}\n-      else\n-\tgcc_unreachable ();\n+\tbreak;\n     }\n-  /* As far as it's necessary, we've walked the subtrees of the call\n-     expr.  */\n-  *do_subtree = 0;\n-  return NULL_TREE;\n }\n \n-/* If this is an await, then register it and decide on what coro\n-   frame storage is needed.\n-   If this is a co_yield (which embeds an await), drop the yield\n-   and record the await (the yield was kept for diagnostics only).  */\n+/* Helper for 'process_conditional' that handles recursion into nested\n+   conditionals.  */\n \n-static tree\n-register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n+static void\n+handle_nested_conditionals (var_nest_node *n, vec<tree>& list,\n+\t\t\t    hash_map<tree, tree>& map)\n {\n-  susp_frame_data *data = (susp_frame_data *) d;\n+  do\n+    {\n+      if (n->var && DECL_NAME (n->var))\n+\t{\n+\t  list.safe_push (n->var);\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (n->var)))\n+\t    {\n+\t      bool existed;\n+\t      tree& flag = map.get_or_insert (n->var, &existed);\n+\t      if (!existed)\n+\t\t{\n+\t\t  /* We didn't see this var before and it needs a DTOR, so\n+\t\t     build a guard variable for it.  */\n+\t\t  char *nam\n+\t\t    = xasprintf (\"%s_guard\",\n+\t\t\t\t IDENTIFIER_POINTER (DECL_NAME (n->var)));\n+\t\t  flag = build_lang_decl (VAR_DECL, get_identifier (nam),\n+\t\t\t\t\t  boolean_type_node);\n+\t\t  free (nam);\n+\t\t  DECL_ARTIFICIAL (flag) = true;\n+\t\t}\n+\n+\t      /* The initializer for this variable is replaced by a compound\n+\t\t expression that performs the init and then records that the\n+\t\t variable is live (and the DTOR should be run at the scope\n+\t\t exit.  */\n+\t      tree set_flag = build2 (INIT_EXPR, boolean_type_node,\n+\t\t\t\t      flag, boolean_true_node);\n+\t      n->init\n+\t\t= build2 (COMPOUND_EXPR, boolean_type_node, n->init, set_flag);\n+\t}\n+\t}\n+      if (TREE_CODE (n->init) == COND_EXPR)\n+\t{\n+\t  tree new_then = push_stmt_list ();\n+\t  handle_nested_conditionals (n->then_cl, list, map);\n+\t  new_then = pop_stmt_list (new_then);\n+\t  tree new_else = push_stmt_list ();\n+\t  handle_nested_conditionals (n->else_cl, list, map);\n+\t  new_else = pop_stmt_list (new_else);\n+\t  tree new_if\n+\t    = build4 (IF_STMT, void_type_node, COND_EXPR_COND (n->init),\n+\t\t      new_then, new_else, NULL_TREE);\n+\t  add_stmt (new_if);\n+\t}\n+      else\n+\tfinish_expr_stmt (n->init);\n+      n = n->next;\n+    } while (n);\n+}\n \n-  /* We should have already lowered co_yields to their co_await.  */\n-  gcc_checking_assert (TREE_CODE (*stmt) != CO_YIELD_EXPR);\n+/* helper for 'maybe_promote_temps'.\n \n-  if (TREE_CODE (*stmt) != CO_AWAIT_EXPR)\n-    return NULL_TREE;\n+   When we have a conditional expression which might embed await expressions\n+   and/or promoted variables, we need to handle it appropriately.\n \n-  tree aw_expr = *stmt;\n-  location_t aw_loc = EXPR_LOCATION (aw_expr); /* location of the co_xxxx.  */\n+   The linked lists for the 'then' and 'else' clauses in a conditional node\n+   identify the promoted variables (but these cannot be wrapped in a regular\n+   cleanup).\n \n-  /* If the awaitable is a parm or a local variable, then we already have\n-     a frame copy, so don't make a new one.  */\n-  tree aw = TREE_OPERAND (aw_expr, 1);\n-  tree o = TREE_OPERAND (aw_expr, 2); /* Initializer for the frame var.  */\n-  /* If we have an initializer, then the var is a temp and we need to make\n-     it in the frame.  */\n-  tree aw_field_type = TREE_TYPE (aw);\n-  tree aw_field_nam = NULL_TREE;\n-  if (o)\n+   So recurse through the lists and build up a composite list of captured vars.\n+   Declare these and any guard variables needed to decide if a DTOR should be\n+   run.  Then embed the conditional into a try-finally expression that handles\n+   running each DTOR conditionally on its guard variable.  */\n+\n+static void\n+process_conditional (var_nest_node *n, tree& vlist)\n+{\n+  tree init = n->init;\n+  hash_map<tree, tree> var_flags;\n+  vec<tree> var_list = vNULL;\n+  tree new_then = push_stmt_list ();\n+  handle_nested_conditionals (n->then_cl, var_list, var_flags);\n+  new_then = pop_stmt_list (new_then);\n+  tree new_else = push_stmt_list ();\n+  handle_nested_conditionals (n->else_cl, var_list, var_flags);\n+  new_else = pop_stmt_list (new_else);\n+  /* Declare the vars.  There are two loops so that the boolean flags are\n+     grouped in the frame.  */\n+  for (unsigned i = 0; i < var_list.length(); i++)\n     {\n-      /* The required field has the same type as the proxy stored in the\n-\t await expr.  */\n-      char *nam = xasprintf (\"__aw_s.%d\", data->await_number);\n-      aw_field_nam = coro_make_frame_entry (data->field_list, nam,\n-\t\t\t\t\t    aw_field_type, aw_loc);\n-      free (nam);\n-\n-      /* If the init is a target expression, then we need to remake it to\n-\t strip off any extra cleanups added.  */\n-      if (o && TREE_CODE (o) == TARGET_EXPR)\n-\tTREE_OPERAND (aw_expr, 2) = get_target_expr (TREE_OPERAND (o, 1));\n+      tree var = var_list[i];\n+      DECL_CHAIN (var) = vlist;\n+      vlist = var;\n+      add_decl_expr (var);\n     }\n+  /* Define the guard flags for variables that need a DTOR.  */\n+  for (unsigned i = 0; i < var_list.length(); i++)\n+    {\n+      tree *flag = var_flags.get (var_list[i]);\n+      if (flag)\n+\t{\n+\t  DECL_INITIAL (*flag) = boolean_false_node;\n+\t  DECL_CHAIN (*flag) = vlist;\n+\t  vlist = *flag;\n+\t  add_decl_expr (*flag);\n+\t}\n+    }\n+  tree new_if\n+    = build4 (IF_STMT, void_type_node, COND_EXPR_COND (init),\n+\t      new_then, new_else, NULL_TREE);\n+  /* Build a set of conditional DTORs.  */\n+  tree final_actions = push_stmt_list ();\n+  while (!var_list.is_empty())\n+    {\n+      tree var = var_list.pop ();\n+      tree *flag = var_flags.get (var);\n+      if (!flag)\n+\tcontinue;\n+      tree var_type = TREE_TYPE (var);\n+      tree cleanup\n+\t= build_special_member_call (var, complete_dtor_identifier,\n+\t\t\t\t     NULL, var_type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n+      tree cond_cleanup = begin_if_stmt ();\n+      finish_if_stmt_cond (*flag, cond_cleanup);\n+      finish_expr_stmt (cleanup);\n+      finish_then_clause (cond_cleanup);\n+      finish_if_stmt (cond_cleanup);\n+    }\n+  final_actions = pop_stmt_list (final_actions);\n+  tree try_finally\n+    = build2 (TRY_FINALLY_EXPR, void_type_node, new_if, final_actions);\n+  add_stmt (try_finally);\n+}\n \n-  tree v = TREE_OPERAND (aw_expr, 3);\n-  o = TREE_VEC_ELT (v, 1);\n-  if (TREE_CODE (o) == TARGET_EXPR)\n-    TREE_VEC_ELT (v, 1) = get_target_expr (TREE_OPERAND (o, 1));\n-\n-  register_await_info (aw_expr, aw_field_type, aw_field_nam);\n+/* Given *STMT, that contains at least one await expression.\n \n-  /* Count how many awaits the current expression contains.  */\n-  data->saw_awaits++;\n-  /* Each await suspend context is unique, this is a function-wide value.  */\n-  data->await_number++;\n+   The full expression represented in the original source code will contain\n+   suspension points, but it is still required that the lifetime of temporary\n+   values extends to the end of the expression.\n \n-  /* We now need to know if to take special action on lifetime extension\n-     of temporaries captured by reference.  This can only happen if such\n-     a case appears in the initializer for the awaitable.  The callback\n-     records captured temporaries including subtrees of initializers.  */\n-  hash_set<tree> visited;\n-  tree res = cp_walk_tree (&TREE_OPERAND (aw_expr, 2), captures_temporary, d,\n-\t\t\t   &visited);\n-  return res;\n-}\n+   We already have a mechanism to 'promote' user-authored local variables\n+   to a coroutine frame counterpart (which allows explicit management of the\n+   lifetime across suspensions).  The transform here re-writes STMT into\n+   a bind expression, promotes temporary values into local variables in that\n+   and flattens the statement into a series of cleanups.\n \n-/* The gimplifier correctly extends the lifetime of temporaries captured\n-   by reference (per. [class.temporary] (6.9) \"A temporary object bound\n-   to a reference parameter in a function call persists until the completion\n-   of the full-expression containing the call\").  However, that is not\n-   sufficient to work across a suspension - and we need to promote such\n-   temporaries to be regular vars that will then get a coro frame slot.\n-   We don't want to incur the effort of checking for this unless we have\n-   an await expression in the current full expression.  */\n-\n-/* This takes the statement which contains one or more temporaries that have\n-   been 'captured' by reference in the initializer(s) of co_await(s).\n-   The statement is replaced by a bind expression that has actual variables\n-   to replace the temporaries.  These variables will be added to the coro-\n-   frame in the same manner as user-authored ones.  */\n+   Conditional expressions are re-written to regular 'if' statements.\n+   The cleanups for variables initialized inside a conditional (including\n+   nested cases) are wrapped in a try-finally clause, with guard variables\n+   to determine which DTORs need to be run.  */\n \n-static void\n-replace_statement_captures (tree *stmt, void *d)\n+static tree\n+maybe_promote_temps (tree *stmt, void *d)\n {\n   susp_frame_data *awpts = (susp_frame_data *) d;\n+\n   location_t sloc = EXPR_LOCATION (*stmt);\n-  tree aw_bind\n-    = build3_loc (sloc, BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-\n-  /* Any cleanup point expression might no longer be necessary, since we\n-     are removing one or more temporaries.  */\n-  tree aw_statement_current = *stmt;\n-  if (TREE_CODE (aw_statement_current) == CLEANUP_POINT_EXPR)\n-    aw_statement_current = TREE_OPERAND (aw_statement_current, 0);\n-\n-  /* Collected the scope vars we need move the temps to regular. */\n-  tree aw_bind_body = push_stmt_list ();\n-  tree varlist = NULL_TREE;\n-  int vnum = -1;\n-  while (!awpts->to_replace->is_empty ())\n+  tree expr = *stmt;\n+  /* Strip off uninteresting wrappers.  */\n+  if (TREE_CODE (expr) == CLEANUP_POINT_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (expr) == EXPR_STMT)\n+    expr = EXPR_STMT_EXPR (expr);\n+  if (TREE_CODE (expr) == CONVERT_EXPR\n+      && VOID_TYPE_P (TREE_TYPE (expr)))\n+    expr = TREE_OPERAND (expr, 0);\n+  STRIP_NOPS (expr);\n+\n+  /* We walk the statement trees, flattening it into an ordered list of\n+     variables with initializers and fragments corresponding to compound\n+     expressions, truth or/and if and ternary conditionals.  Conditional\n+     expressions carry a nested list of fragments for the then and else\n+     clauses.  We anchor to the 'bottom' of the fragment list; we will write\n+     a cleanup nest with one shell for each variable initialized.  */\n+  var_nest_node *root = new var_nest_node (NULL_TREE, expr, NULL, NULL);\n+  /* Check to see we didn't promote one twice.  */\n+  hash_set<tree> promoted_vars;\n+  hash_set<tree> used_temps;\n+  flatten_await_stmt (root, &promoted_vars, &used_temps, NULL);\n+\n+  gcc_checking_assert (root->next == NULL);\n+  tree vlist = NULL_TREE;\n+  var_nest_node *t = root;\n+  gcc_checking_assert (!t->var);\n+  /* We build the bind scope expression from the bottom-up.\n+     EXPR_LIST holds the inner expression nest at the current cleanup\n+     level (becoming the final expression list when we've exhausted the\n+     number of sub-expression fragments).  */\n+  tree expr_list = NULL_TREE;\n+  do\n     {\n-      tree to_replace = awpts->to_replace->pop ();\n-      tree orig_temp;\n-      if (TREE_CODE (to_replace) == CO_AWAIT_EXPR)\n+      tree new_list = push_stmt_list ();\n+      /* When we have a promoted variable, then add that to the bind scope\n+\t and initialize it.  When there's no promoted variable, we just need\n+\t to run the initializer.\n+\t If the initializer is a conditional expression, we need to collect\n+\t and declare any promoted variables nested within it.  DTORs for such\n+\t variables must be run conditionally too.  */\n+      if (t->var && DECL_NAME (t->var))\n \t{\n-\t  orig_temp = TREE_OPERAND (to_replace, 3);\n-\t  orig_temp = TREE_VEC_ELT (orig_temp, 2);\n-\t  orig_temp = TREE_OPERAND (orig_temp, 0);\n+\t  tree var = t->var;\n+\t  DECL_CHAIN (var) = vlist;\n+\t  vlist = var;\n+\t  add_decl_expr (var);\n+\t  if (TREE_CODE (t->init) == COND_EXPR)\n+\t    process_conditional (t, vlist);\n+\t  else\n+\t    finish_expr_stmt (t->init);\n+\t  tree var_type = TREE_TYPE (var);\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (var_type))\n+\t    {\n+\t      tree cleanup\n+\t\t= build_special_member_call (var, complete_dtor_identifier,\n+\t\t\t\t\t     NULL, var_type, LOOKUP_NORMAL,\n+\t\t\t\t\t     tf_warning_or_error);\n+\t      tree cl = build_stmt (sloc, CLEANUP_STMT, expr_list, cleanup, var);\n+\t      add_stmt (cl); /* push this onto the level above.  */\n+\t    }\n+\t  else if (expr_list)\n+\t    add_stmt (expr_list);\n+\t  else\n+\t    gcc_unreachable ();\n \t}\n       else\n-\torig_temp = TREE_OPERAND (to_replace, 0);\n-\n-      tree var_type = TREE_TYPE (orig_temp);\n-      gcc_checking_assert (same_type_p (TREE_TYPE (to_replace), var_type));\n-      /* Build a variable to hold the captured value, this will be included\n-\t in the frame along with any user-authored locals.  */\n-      char *nam = xasprintf (\"aw_%d.tmp.%d\", awpts->await_number, ++vnum);\n-      tree newvar = build_lang_decl (VAR_DECL, get_identifier (nam), var_type);\n-      free (nam);\n-      /* If we have better location than the whole expression use that, else\n-\t fall back to the expression loc.  */\n-      DECL_CONTEXT (newvar) = DECL_CONTEXT (orig_temp);\n-      if (DECL_SOURCE_LOCATION (orig_temp))\n-\tsloc = DECL_SOURCE_LOCATION (orig_temp);\n-     else\n-\tsloc = EXPR_LOCATION (*stmt);\n-      DECL_SOURCE_LOCATION (newvar) = sloc;\n-      DECL_CHAIN (newvar) = varlist;\n-      varlist = newvar; /* Chain it onto the list for the bind expr.  */\n-      /* Declare and initialize it in the new bind scope.  */\n-      add_decl_expr (newvar);\n-      tree new_s = build2_loc (sloc, INIT_EXPR, var_type, newvar, to_replace);\n-      new_s = coro_build_cvt_void_expr_stmt (new_s, sloc);\n-      add_stmt (new_s);\n-\n-     /* Replace all instances of that temp in the original expr.  */\n-      proxy_replace pr = {to_replace, newvar};\n-       cp_walk_tree (&aw_statement_current, replace_proxy, &pr, NULL);\n-    }\n-\n-  /* What's left should be the original statement with any co_await captured\n-     temporaries broken out.  Other temporaries might remain so see if we\n-     need to wrap the revised statement in a cleanup.  */\n-  aw_statement_current = maybe_cleanup_point_expr_void (aw_statement_current);\n-  add_stmt (aw_statement_current);\n-\n-  BIND_EXPR_BODY (aw_bind) = pop_stmt_list (aw_bind_body);\n-  awpts->captured_temps.empty ();\n-\n-  BIND_EXPR_VARS (aw_bind) = nreverse (varlist);\n+\t{\n+\t  if (TREE_CODE (t->init) == COND_EXPR)\n+\t    process_conditional (t, vlist);\n+\t  else\n+\t    finish_expr_stmt (t->init);\n+\t  if (expr_list)\n+\t    add_stmt (expr_list);\n+\t}\n+      expr_list = pop_stmt_list (new_list);\n+      var_nest_node *old = t;\n+      t = t->prev;\n+      delete old;\n+    } while (t);\n+\n+  /* Now produce the bind expression containing the 'promoted' temporaries\n+     as its variable list, and the cleanup nest as the statement.  */\n+  tree await_bind = build3_loc (sloc, BIND_EXPR, void_type_node,\n+\t\t\t\tNULL, NULL, NULL);\n+  BIND_EXPR_BODY (await_bind) = expr_list;\n+  BIND_EXPR_VARS (await_bind) = nreverse (vlist);\n   tree b_block = make_node (BLOCK);\n   if (!awpts->block_stack->is_empty ())\n     {\n@@ -2965,37 +3136,12 @@ replace_statement_captures (tree *stmt, void *d)\n \tBLOCK_SUBBLOCKS (s_block) = b_block;\n \t}\n     }\n-  BIND_EXPR_BLOCK (aw_bind) = b_block;\n-  TREE_SIDE_EFFECTS (aw_bind) = TREE_SIDE_EFFECTS (BIND_EXPR_BODY (aw_bind));\n-  *stmt = aw_bind;\n-}\n-\n-/* This is called for single statements from the co-await statement walker.\n-   It checks to see if the statement contains any co-awaits and, if so,\n-   whether any of these 'capture' a temporary by reference.  */\n-\n-static tree\n-maybe_promote_captured_temps (tree *stmt, void *d)\n-{\n-  susp_frame_data *awpts = (susp_frame_data *) d;\n+  BLOCK_VARS (b_block) = BIND_EXPR_VARS (await_bind) ;\n+  BIND_EXPR_BLOCK (await_bind) = b_block;\n+  TREE_SIDE_EFFECTS (await_bind) = TREE_SIDE_EFFECTS (BIND_EXPR_BODY (await_bind));\n+  *stmt = await_bind;\n   hash_set<tree> visited;\n-  awpts->saw_awaits = 0;\n-\n-  /* When register_awaits sees an await, it walks the initializer for\n-     that await looking for temporaries captured by reference and notes\n-     them in awpts->captured_temps.  */\n-\n-  if (tree res = cp_walk_tree (stmt, register_awaits, d, &visited))\n-    return res; /* We saw some reason to abort the tree walk.  */\n-\n-  /* We only need to take any action here if the statement contained any\n-     awaits and any of those had temporaries captured by reference in their\n-     initializers. */\n-\n-  if (awpts->saw_awaits > 0 && !awpts->captured_temps.is_empty ())\n-    replace_statement_captures (stmt, d);\n-\n-  return NULL_TREE;\n+  return cp_walk_tree (stmt, register_awaits, d, &visited);\n }\n \n /* Lightweight callback to determine two key factors:\n@@ -3004,6 +3150,7 @@ maybe_promote_captured_temps (tree *stmt, void *d)\n       TRUTH_{AND,OR}IF_EXPRs since, in most cases, they will need expansion\n       so that the await expressions are not processed in the case of the\n       short-circuit arm.\n+\n    CO_YIELD expressions are re-written to their underlying co_await.  */\n \n static tree\n@@ -3020,6 +3167,9 @@ analyze_expression_awaits (tree *stmt, int *do_subtree, void *d)\n \t/* FALLTHROUGH */\n       case CO_AWAIT_EXPR:\n \tawpts->saw_awaits++;\n+\t/* A non-null initializer for the awaiter means we need to expand.  */\n+\tif (TREE_OPERAND (*stmt, 2))\n+\t  awpts->has_awaiter_init = true;\n \tbreak;\n       case TRUTH_ANDIF_EXPR:\n       case TRUTH_ORIF_EXPR:\n@@ -3053,15 +3203,13 @@ analyze_expression_awaits (tree *stmt, int *do_subtree, void *d)\n \n /* Given *EXPR\n    If EXPR contains a TRUTH_{AND,OR}IF_EXPR, TAOIE with an await expr on\n-   the conditional branch expand this to:\n+   the conditionally executed branch, change this in a ternary operator.\n \n    bool not_expr = TAOIE == TRUTH_ORIF_EXPR ? NOT : NOP;\n-   A) bool t = always exec expr\n-      if (not_expr (t))\n-   B)   t = conditionally exec expr\n-   c) EXPR' = EXPR with  TAOIE replaced by t.\n+   not_expr (always-exec expr) ? conditionally-exec expr : not_expr;\n \n-   Then repeat this for A, B and C.  */\n+   Apply this recursively to the condition and the conditionally-exec\n+   branch.  */\n \n struct truth_if_transform {\n   tree *orig_stmt;\n@@ -3087,47 +3235,26 @@ expand_one_truth_if (tree *expr, int *do_subtree, void *d)\n \t    break;\n \n \t  location_t sloc = EXPR_LOCATION (*expr);\n-\t  tree type = TREE_TYPE (xform->scratch_var);\n-\t  gcc_checking_assert (TREE_CODE (type) == BOOLEAN_TYPE);\n-\t  tree new_list = push_stmt_list ();\n-\t  /* Init our scratch with the unconditionally-evaluated expr.  */\n-\t  tree new_s = build2_loc (sloc, INIT_EXPR, boolean_type_node,\n-\t\t\t\t   xform->scratch_var,\n-\t\t\t\t   TREE_OPERAND (*expr, 0));\n-\t  finish_expr_stmt (new_s);\n-\t  tree *pre = tsi_stmt_ptr (tsi_last (new_list));\n-\t  tree if_cond = xform->scratch_var;\n+\t  /* Transform truth expression into a cond expression with\n+\t     * the always-executed arm as the condition.\n+\t     * the conditionally-executed arm as the then clause.\n+\t     * the 'else' clause is fixed: 'true' for ||,'false' for &&.  */\n+\t  tree cond = TREE_OPERAND (*expr, 0);\n+\t  tree test1 = TREE_OPERAND (*expr, 1);\n+\t  tree fixed = needs_not ? boolean_true_node : boolean_false_node;\n \t  if (needs_not)\n-\t    if_cond = build1 (TRUTH_NOT_EXPR, boolean_type_node, if_cond);\n-\t  tree if_stmt = begin_if_stmt ();\n-\t  finish_if_stmt_cond (if_cond, if_stmt);\n-\t  /* If we take the if branch, then overwrite scratch with the cond\n-\t     executed branch.  */\n-\t  new_s = build2 (INIT_EXPR, boolean_type_node,\n-\t\t\t  xform->scratch_var, TREE_OPERAND (*expr, 1));\n-\t  finish_expr_stmt (new_s);\n-\t  finish_then_clause (if_stmt);\n-\t  finish_if_stmt (if_stmt);\n-\t  *expr = xform->scratch_var; /* now contains the result.  */\n-\t  /* So now we've got a statement list expanding one TAOIe.  */\n-\t  add_stmt (*xform->orig_stmt);\n-\t  tree *post = tsi_stmt_ptr (tsi_last (new_list));\n-\t  *xform->orig_stmt = pop_stmt_list (new_list);\n-\t  /* Now recurse into the pre, if and post parts.  */\n-\t  truth_if_transform sub_data = {pre, xform->scratch_var,\n-\t\t\t\t\t xform->truth_aoif_to_expand};\n-\t  if (tree res = cp_walk_tree (pre, expand_one_truth_if, &sub_data,\n-\t\t\t\t       NULL))\n-\t    return res;\n-\t  sub_data.orig_stmt = &THEN_CLAUSE (if_stmt);\n-\t  if (tree res = cp_walk_tree (&THEN_CLAUSE (if_stmt),\n-\t\t\t\t       expand_one_truth_if, &sub_data, NULL))\n+\t    cond = build1 (TRUTH_NOT_EXPR, boolean_type_node, cond);\n+\t  tree cond_expr\n+\t    = build3_loc (sloc, COND_EXPR, boolean_type_node,\n+\t\t\t  cond, test1, fixed);\n+\t  *expr = cond_expr;\n+\t  if (tree res = cp_walk_tree (&COND_EXPR_COND (*expr),\n+\t\t\t\t       expand_one_truth_if, d, NULL))\n \t    return res;\n-\t  sub_data.orig_stmt = post;\n-\t  if (tree res = cp_walk_tree (post, expand_one_truth_if, &sub_data,\n-\t\t\t\t       NULL))\n+\t  if (tree res = cp_walk_tree (&COND_EXPR_THEN (*expr),\n+\t\t\t\t       expand_one_truth_if, d, NULL))\n \t    return res;\n-\t  /* We've done the sub-trees here.  */\n+\t  /* We've manually processed necessary sub-trees here.  */\n \t  *do_subtree = 0;\n \t}\n \tbreak;\n@@ -3142,7 +3269,6 @@ static tree\n add_var_to_bind (tree& bind, tree var_type,\n \t\t const char *nam_root, unsigned nam_vers)\n {\n-\n   tree b_vars = BIND_EXPR_VARS (bind);\n   /* Build a variable to hold the condition, this will be included in the\n      frame as a local var.  */\n@@ -3208,14 +3334,20 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n     }\n \n   /* We have something to be handled as a single statement.  */\n+  bool has_cleanup_wrapper = TREE_CODE (*stmt) == CLEANUP_POINT_EXPR;\n   hash_set<tree> visited;\n   awpts->saw_awaits = 0;\n   hash_set<tree> truth_aoif_to_expand;\n   awpts->truth_aoif_to_expand = &truth_aoif_to_expand;\n   awpts->needs_truth_if_exp = false;\n-\n-  if (STATEMENT_CLASS_P (*stmt))\n-    switch (TREE_CODE (*stmt))\n+  awpts->has_awaiter_init = false;\n+  tree expr = *stmt;\n+  if (has_cleanup_wrapper)\n+    expr = TREE_OPERAND (expr, 0);\n+  STRIP_NOPS (expr);\n+\n+  if (STATEMENT_CLASS_P (expr))\n+    switch (TREE_CODE (expr))\n       {\n \t/* Unless it's a special case, just walk the subtrees as usual.  */\n \tdefault: return NULL_TREE;\n@@ -3255,13 +3387,6 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    tree new_s = build2_loc (sloc, MODIFY_EXPR, boolean_type_node,\n \t\t\t\t     newvar, cond_inner);\n \t    finish_expr_stmt (new_s);\n-\t    if (awpts->needs_truth_if_exp)\n-\t      {\n-\t\ttree *sp = tsi_stmt_ptr (tsi_last (insert_list));\n-\t\ttruth_if_transform xf = {sp, newvar, &truth_aoif_to_expand};\n-\t\tif ((res = cp_walk_tree (sp, expand_one_truth_if, &xf, NULL)))\n-\t\t  return res;\n-\t      }\n \t    IF_COND (if_stmt) = newvar;\n \t    add_stmt (if_stmt);\n \t    *stmt = pop_stmt_list (insert_list);\n@@ -3327,7 +3452,6 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t\t\t\td, NULL);\n \t    *do_subtree = 0; /* Done subtrees.  */\n \t    return res;\n-\n \t  }\n \t  break;\n \tcase SWITCH_STMT:\n@@ -3371,40 +3495,77 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    return res;\n \t  }\n \t  break;\n+\tcase CO_RETURN_EXPR:\n+\t  {\n+\t    /* Expand the co_return as per [stmt.return.coroutine]\n+\t       - for co_return;\n+\t\t{ p.return_void (); goto final_suspend; }\n+\t       - for co_return [void expr];\n+\t\t{ expr; p.return_void(); goto final_suspend;}\n+\t       - for co_return [non void expr];\n+\t\t{ p.return_value(expr); goto final_suspend; }  */\n+\t    if ((res = cp_walk_tree (stmt, analyze_expression_awaits,\n+\t\t d, &visited)))\n+\t      return res;\n+\t    location_t loc = EXPR_LOCATION (expr);\n+\t    tree call = TREE_OPERAND (expr, 1);\n+\t    expr = TREE_OPERAND (expr, 0);\n+\t    tree ret_list = push_stmt_list ();\n+\t    /* [stmt.return.coroutine], 2.2\n+\t       If expr is present and void, it is placed immediately before\n+\t       the call for return_void;  */\n+\t    tree *maybe_await_stmt = NULL;\n+\t    if (expr && VOID_TYPE_P (TREE_TYPE (expr)))\n+\t      {\n+\t\tfinish_expr_stmt (expr);\n+\t\t/* If the return argument was a void expression, then any\n+\t\t   awaits must be contained in that.  */\n+\t\tmaybe_await_stmt = tsi_stmt_ptr (tsi_last (ret_list));\n+\t      }\n+\t    /* Insert p.return_{void,value(expr)}.  */\n+\t    finish_expr_stmt (call);\n+\t    /* Absent a return of a void expression, any awaits must be in\n+\t       the parameter to return_value().  */\n+\t    if (!maybe_await_stmt)\n+\t      maybe_await_stmt = tsi_stmt_ptr (tsi_last (ret_list));\n+\t    expr = build1_loc (loc, GOTO_EXPR, void_type_node, awpts->fs_label);\n+\t    finish_expr_stmt (expr);\n+\t    *stmt = pop_stmt_list (ret_list);\n+\t    /* Once this is complete, we will have processed subtrees.  */\n+\t    *do_subtree = 0;\n+\t    if (awpts->saw_awaits)\n+\t      {\n+\t\tgcc_checking_assert (maybe_await_stmt);\n+\t\tres = cp_walk_tree (maybe_await_stmt, await_statement_walker,\n+\t\t\t\t    d, NULL);\n+\t\tif (res)\n+\t\t  return res;\n+\t      }\n+\t    return NULL_TREE; /* Done.  */\n+\t  }\n+\tbreak;\n       }\n-  else if (EXPR_P (*stmt))\n+  else if (EXPR_P (expr))\n     {\n       if ((res = cp_walk_tree (stmt, analyze_expression_awaits, d, &visited)))\n \treturn res;\n       *do_subtree = 0; /* Done subtrees.  */\n       if (!awpts->saw_awaits)\n \treturn NULL_TREE; /* Nothing special to do here.  */\n \n-      /* Unless we need to expand any truth-and/or-if expressions, then the\n-\t remaining action is to check for temporaries to await expressions\n-\t captured by refence.  */\n-      if (!awpts->needs_truth_if_exp)\n-\treturn maybe_promote_captured_temps (stmt, d);\n-\n-      gcc_checking_assert (!awpts->bind_stack->is_empty());\n-      tree& bind_expr = awpts->bind_stack->last ();\n-      /* Build a variable to hold the condition, this will be\n-      included in the frame as a local var.  */\n-      tree newvar = add_var_to_bind (bind_expr, boolean_type_node,\n-\t\t\t\t     \"taoi\", awpts->cond_number++);\n-      tree insert_list = push_stmt_list ();\n-      add_decl_expr (newvar);\n-      add_stmt (*stmt);\n-      tree *sp = tsi_stmt_ptr (tsi_last (insert_list));\n-      *stmt = pop_stmt_list (insert_list);\n-\n-      truth_if_transform xf = {sp, newvar, &truth_aoif_to_expand};\n-      if ((res = cp_walk_tree (sp, expand_one_truth_if, &xf, NULL)))\n-\treturn res;\n-      /* Process the expanded trees.  */\n-      return cp_walk_tree (stmt, await_statement_walker, d, NULL);\n+      if (awpts->needs_truth_if_exp)\n+\t{\n+\t  /* If a truth-and/or-if expression has an await expression in the\n+\t     conditionally-taken branch, then it must be rewritten into a\n+\t     regular conditional.  */\n+\t  truth_if_transform xf = {stmt, NULL_TREE, &truth_aoif_to_expand};\n+\t  if ((res = cp_walk_tree (stmt, expand_one_truth_if, &xf, NULL)))\n+\t    return res;\n+\t}\n+      /* Process this statement, which contains at least one await expression\n+\t to 'promote' temporary values to a coroutine frame slot.  */\n+      return maybe_promote_temps (stmt, d);\n     }\n- \n   /* Continue recursion, if needed.  */\n   return res;\n }\n@@ -3420,6 +3581,9 @@ struct param_frame_data\n   bool param_seen;\n };\n \n+/* A tree-walk callback that records the use of parameters (to allow for\n+   optimizations where handling unused parameters may be omitted).  */\n+\n static tree\n register_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n {\n@@ -3455,7 +3619,21 @@ register_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n   return NULL_TREE;\n }\n \n-/* For figuring out what local variable usage we have.  */\n+/* Small helper for the repetitive task of adding a new field to the coro\n+   frame type.  */\n+\n+static tree\n+coro_make_frame_entry (tree *field_list, const char *name, tree fld_type,\n+\t\t       location_t loc)\n+{\n+  tree id = get_identifier (name);\n+  tree decl = build_decl (loc, FIELD_DECL, id, fld_type);\n+  DECL_CHAIN (decl) = *field_list;\n+  *field_list = decl;\n+  return id;\n+}\n+\n+/* For recording local variable usage.  */\n \n struct local_vars_frame_data\n {\n@@ -3467,6 +3645,10 @@ struct local_vars_frame_data\n   bool local_var_seen;\n };\n \n+/* A tree-walk callback that processes one bind expression noting local\n+   variables, and making a coroutine frame slot available for those that\n+   need it, so that they can be 'promoted' across suspension points.  */\n+\n static tree\n register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n {\n@@ -3523,11 +3705,11 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  tree lvname = DECL_NAME (lvar);\n \t  char *buf;\n \t  if (lvname != NULL_TREE)\n-\t    buf = xasprintf (\"__lv.%u.%u.%s\", lvd->bind_indx, lvd->nest_depth,\n-\t\t\t     IDENTIFIER_POINTER (lvname));\n+\t    buf = xasprintf (\"__%s.%u.%u\", IDENTIFIER_POINTER (lvname),\n+\t\t\t     lvd->nest_depth, lvd->bind_indx);\n \t  else\n-\t    buf = xasprintf (\"__lv.%u.%u.D%u\", lvd->bind_indx, lvd->nest_depth,\n-\t\t\t     DECL_UID (lvar));\n+\t    buf = xasprintf (\"_D%u.%u.%u\", DECL_UID (lvar), lvd->nest_depth,\n+\t\t\t     lvd->bind_indx);\n \t  /* TODO: Figure out if we should build a local type that has any\n \t     excess alignment or size from the original decl.  */\n \t  local_var.field_id\n@@ -3631,7 +3813,7 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody,\n \t\t\t\t\t fn_start, NULL, /*musthave=*/true);\n       /* Create and initialize the initial-await-resume-called variable per\n \t [dcl.fct.def.coroutine] / 5.3.  */\n-      tree i_a_r_c = build_lang_decl (VAR_DECL, get_identifier (\"__i_a_r_c\"),\n+      tree i_a_r_c = build_lang_decl (VAR_DECL, get_identifier (\"i_a_r_c\"),\n \t\t\t\t      boolean_type_node);\n       DECL_ARTIFICIAL (i_a_r_c) = true;\n       DECL_CHAIN (i_a_r_c) = var_list;\n@@ -3760,9 +3942,7 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody,\n   short __resume_at;\n   handle_type self_handle;\n   (maybe) parameter copies.\n-  coro1::suspend_never_prt __is;\n-  coro1::suspend_always_prt __fs;\n-  (maybe) local variables saved\n+  (maybe) local variables saved (including awaitables)\n   (maybe) trailing space.\n  };  */\n \n@@ -3966,8 +4146,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      to promote any temporaries that are captured by reference (to regular\n      vars) they will get added to the coro frame along with other locals.  */\n   susp_frame_data body_aw_points\n-    = {&field_list, handle_type, NULL, NULL, 0, 0,\n-       hash_set<tree> (), NULL, NULL, 0, false, false};\n+    = {&field_list, handle_type, fs_label, NULL, NULL, 0, 0,\n+       hash_set<tree> (), NULL, NULL, 0, false, false, false};\n   body_aw_points.block_stack = make_tree_vector ();\n   body_aw_points.bind_stack = make_tree_vector ();\n   body_aw_points.to_replace = make_tree_vector ();\n@@ -4555,7 +4735,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   /* Build the actor...  */\n   build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n-\t\t  &local_var_uses, param_dtor_list, fs_label, resume_fn_field,\n+\t\t  &local_var_uses, param_dtor_list, resume_fn_field,\n \t\t  body_aw_points.await_number, frame_size);\n \n   /* Destroyer ... */"}, {"sha": "664b1d39619ec7ad8b6c3dba316f2c7995ec2d36", "filename": "gcc/testsuite/g++.dg/coroutines/pr95591.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95591.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95591.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95591.C?ref=0f66b8486cea8668020e4bd48f261b760cb579be", "patch": "@@ -0,0 +1,26 @@\n+#if __has_include (<coroutine>)\n+#include <coroutine>\n+using namespace std;\n+#elif defined (__clang__) && __has_include (<experimental/coroutine>)\n+#include <experimental/coroutine>\n+namespace std { using namespace experimental; }\n+#endif\n+\n+struct generator {\n+    struct promise_type {\n+        generator get_return_object();\n+        void return_void();\n+        void unhandled_exception();\n+        suspend_always initial_suspend();\n+        suspend_always final_suspend();\n+\n+        template<typename Arg>\n+        suspend_always yield_value(Arg&&) {\n+            return {};\n+        }\n+    };\n+};\n+\n+generator x() {\n+    co_yield \"foo\";\n+}"}, {"sha": "9376359d378f0e7b4b8b205d520b27ac40420a77", "filename": "gcc/testsuite/g++.dg/coroutines/pr95599.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95599.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95599.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95599.C?ref=0f66b8486cea8668020e4bd48f261b760cb579be", "patch": "@@ -0,0 +1,69 @@\n+//  { dg-do run }\n+\n+// The simplest co_await we can do.\n+\n+#include \"coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"coro1-ret-int-yield-int.h\"\n+\n+int counter = 0;\n+int a, b, c, d;\n+int e, f, g;\n+\n+struct suspend_always_order {\n+  suspend_always_order (int *v) { \n+    PRINT (\"susp-always-order-ctor-value\"); *v = counter++;\n+  }\n+  suspend_always_order () { PRINT (\"susp-always-order-ctor\"); }\n+  constexpr bool await_ready() const noexcept { return false; }\n+  void await_suspend(coro1::handle_type) const noexcept { PRINT (\"susp-always-order-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-order-resume\");}\n+  ~suspend_always_order() { PRINT (\"susp-always-order-dtor\"); }\n+};\n+\n+coro1\n+my_coro ()\n+{\n+  (a = counter++, b = counter++, co_await suspend_always_order(&c), d = counter++);\n+  co_await (e = counter++, suspend_always_order (&f));\n+  co_return (g = counter++, 10);\n+}\n+\n+int main ()\n+{\n+  auto f_coro = my_coro ();\n+\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] co_await\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [3] co_await\");\n+  f_coro.handle.resume();\n+\n+  /* we should now have returned with the co_return */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 10)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 10\\n\", y);\n+      abort ();\n+    }\n+  if (a != 0 || b != 1 || c != 2 || d != 3\n+      || e != 4 || f != 5 || g != 6 )\n+    {\n+      PRINTF (\"something happened in the wrong order %d, %d, %d, %d, %d, %d, %d\\n\", a, b, c, d, e, f, g);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "14d4680206d946d76fb65006aa7504e1a6ed179d", "filename": "gcc/testsuite/g++.dg/coroutines/pr95823.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95823.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95823.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95823.C?ref=0f66b8486cea8668020e4bd48f261b760cb579be", "patch": "@@ -0,0 +1,30 @@\n+#include <coroutine>\n+#include <memory>\n+\n+struct task {\n+  struct promise_type {\n+    auto initial_suspend() noexcept { return std::suspend_always{}; }\n+    auto final_suspend() noexcept { return std::suspend_always{}; }\n+    void return_void() {}\n+    task get_return_object() { return task{}; }\n+    void unhandled_exception() noexcept {}\n+  };\n+\n+  ~task() noexcept {}\n+\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(std::coroutine_handle<>) noexcept {}\n+  void await_resume() noexcept {}\n+};\n+\n+struct Id\n+{\n+    std::unique_ptr<int> value;\n+};\n+\n+task g(int);\n+\n+task f() {\n+    std::unique_ptr<Id> id;\n+    co_await g(*id->value);\n+}"}, {"sha": "d44d70150906ca41377f3f7ebd817e4730ea0bce", "filename": "gcc/testsuite/g++.dg/coroutines/pr95824.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95824.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f66b8486cea8668020e4bd48f261b760cb579be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95824.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95824.C?ref=0f66b8486cea8668020e4bd48f261b760cb579be", "patch": "@@ -0,0 +1,37 @@\n+#include <coroutine>\n+\n+struct task {\n+  struct promise_type {\n+    auto initial_suspend() noexcept { return std::suspend_always{}; }\n+    auto final_suspend() noexcept { return std::suspend_always{}; }\n+    void return_void() {}\n+    task get_return_object() { return task{}; }\n+    void unhandled_exception() noexcept {}\n+  };\n+\n+  ~task() noexcept {}\n+\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(std::coroutine_handle<>) noexcept {}\n+  void await_resume() noexcept {}\n+};\n+\n+struct base\n+{\n+    virtual ~base() = default;\n+};\n+\n+class exception : public virtual base\n+{};\n+\n+struct factory\n+{\n+    virtual ~factory() = default;\n+    virtual int makeId() const;\n+};\n+\n+task g(int);\n+\n+task f(factory& factory) {\n+    co_await g(factory.makeId());\n+}"}]}