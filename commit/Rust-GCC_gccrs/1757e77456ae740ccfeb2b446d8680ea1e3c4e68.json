{"sha": "1757e77456ae740ccfeb2b446d8680ea1e3c4e68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc1N2U3NzQ1NmFlNzQwY2NmZWIyYjQ0NmQ4NjgwZWExZTNjNGU2OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-03-30T17:18:14Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-03-30T17:18:14Z"}, "message": "Prevent hoisting code from generating uninitialized accesses.\n\nFrom-SVN: r40971", "tree": {"sha": "6bb77525430822e52dfab40313ae1008f0f67372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bb77525430822e52dfab40313ae1008f0f67372"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1757e77456ae740ccfeb2b446d8680ea1e3c4e68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1757e77456ae740ccfeb2b446d8680ea1e3c4e68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1757e77456ae740ccfeb2b446d8680ea1e3c4e68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1757e77456ae740ccfeb2b446d8680ea1e3c4e68/comments", "author": null, "committer": null, "parents": [{"sha": "886cbb88812fc1989ec64efb02f2088852a9408c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886cbb88812fc1989ec64efb02f2088852a9408c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886cbb88812fc1989ec64efb02f2088852a9408c"}], "stats": {"total": 23, "additions": 20, "deletions": 3}, "files": [{"sha": "7f0266b425fa55df602bccc4248ba43875ea7fbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1757e77456ae740ccfeb2b446d8680ea1e3c4e68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1757e77456ae740ccfeb2b446d8680ea1e3c4e68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1757e77456ae740ccfeb2b446d8680ea1e3c4e68", "patch": "@@ -1,3 +1,8 @@\n+2001-03-30  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* loop.c (load_mems): When generating a load from a pseudo, update\n+\tREGNO_LAST_UID.\n+\n Fri Mar 30 17:36:43 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (ix86_split_long_move): Use change address to compensate"}, {"sha": "085b7c8b54a32633003ae10cf0da0bfeb411fb70", "filename": "gcc/loop.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1757e77456ae740ccfeb2b446d8680ea1e3c4e68/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1757e77456ae740ccfeb2b446d8680ea1e3c4e68/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1757e77456ae740ccfeb2b446d8680ea1e3c4e68", "patch": "@@ -8811,7 +8811,7 @@ load_mems (loop)\n   struct loop_regs *regs = LOOP_REGS (loop);\n   int maybe_never = 0;\n   int i;\n-  rtx p;\n+  rtx p, prev_ebb_head;\n   rtx label = NULL_RTX;\n   rtx end_label;\n   /* Nonzero if the next instruction may never be executed.  */\n@@ -8873,6 +8873,7 @@ load_mems (loop)\n        PREV_INSN (p) && GET_CODE (p) != CODE_LABEL;\n        p = PREV_INSN (p))\n     ;\n+  prev_ebb_head = p;\n \n   cselib_init ();\n \n@@ -8963,7 +8964,7 @@ load_mems (loop)\n       loop_info->mems[i].reg = reg;\n \n       /* Now, replace all references to the MEM with the\n-\t corresponding pesudos.  */\n+\t corresponding pseudos.  */\n       maybe_never = 0;\n       for (p = next_insn_in_loop (loop, loop->scan_start);\n \t   p != NULL_RTX;\n@@ -9034,7 +9035,7 @@ load_mems (loop)\n \t\t  if (CONSTANT_P (equiv->loc))\n \t\t    const_equiv = equiv;\n \t\t  else if (GET_CODE (equiv->loc) == REG\n-\t\t\t   /* Extending hard register lifetimes cuases crash\n+\t\t\t   /* Extending hard register lifetimes causes crash\n \t\t\t      on SRC targets.  Doing so on non-SRC is\n \t\t\t      probably also not good idea, since we most\n \t\t\t      probably have pseudoregister equivalence as\n@@ -9060,8 +9061,19 @@ load_mems (loop)\n \t      if (best_equiv)\n \t\tbest = copy_rtx (best_equiv->loc);\n \t    }\n+\n \t  set = gen_move_insn (reg, best);\n \t  set = loop_insn_hoist (loop, set);\n+\t  if (REG_P (best))\n+\t    {\n+\t      for (p = prev_ebb_head; p != loop->start; p = NEXT_INSN (p))\n+\t\tif (REGNO_LAST_UID (REGNO (best)) == INSN_UID (p))\n+\t\t  {\n+\t\t    REGNO_LAST_UID (REGNO (best)) = INSN_UID (set);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n \t  if (const_equiv)\n \t    REG_NOTES (set) = gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t\t\t\t copy_rtx (const_equiv->loc),"}]}