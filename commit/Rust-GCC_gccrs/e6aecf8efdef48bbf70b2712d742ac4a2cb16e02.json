{"sha": "e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZhZWNmOGVmZGVmNDhiYmY3MGIyNzEyZDc0MmFjNGEyY2IxNmUwMg==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2004-01-27T20:24:59Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2004-01-27T20:24:59Z"}, "message": "xtensa.c (xtensa_copy_incoming_a7): Remove SUBREG on CQImode and CHImode incoming arguments in register a7.\n\n\t* config/xtensa/xtensa.c (xtensa_copy_incoming_a7): Remove SUBREG\n\ton CQImode and CHImode incoming arguments in register a7.\n\t(function_arg): Wrap BLKmode argument in register a7 in a PARALLEL.\n\t* config/xtensa/xtensa.h (BLOCK_REG_PADDING): Define.\n\t* config/xtensa/xtensa.md (movdi, movdf): Only call force_reg or\n\txtensa_copy_incoming_a7 before reload.\n\nFrom-SVN: r76742", "tree": {"sha": "9036f0138122ff2a661af2ca521b93759da00ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9036f0138122ff2a661af2ca521b93759da00ac7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/comments", "author": null, "committer": null, "parents": [{"sha": "02307675eec294e5f6ff1fb235e32276743e0751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02307675eec294e5f6ff1fb235e32276743e0751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02307675eec294e5f6ff1fb235e32276743e0751"}], "stats": {"total": 79, "additions": 62, "deletions": 17}, "files": [{"sha": "2bd5d7d59b06bc0b118a0ca135e08d793ffe8199", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "patch": "@@ -1,3 +1,12 @@\n+2004-01-27  Bob Wilson  <bob.wilson@acm.org>\n+\t\n+\t* config/xtensa/xtensa.c (xtensa_copy_incoming_a7): Remove SUBREG\n+\ton CQImode and CHImode incoming arguments in register a7.\n+\t(function_arg): Wrap BLKmode argument in register a7 in a PARALLEL.\n+\t* config/xtensa/xtensa.h (BLOCK_REG_PADDING): Define.\n+\t* config/xtensa/xtensa.md (movdi, movdf): Only call force_reg or\n+\txtensa_copy_incoming_a7 before reload.\n+\t\n 2004-01-27  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* coverage.c (get_coverage_counts): Give a different message"}, {"sha": "7e7b03acadda71d6bae7aabd35ee38fa7d245485", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "patch": "@@ -1327,7 +1327,27 @@ xtensa_copy_incoming_a7 (rtx *operands, enum machine_mode mode)\n   if (a7_overlap_mentioned_p (operands[1])\n       && !cfun->machine->incoming_a7_copied)\n     {\n-      rtx mov;\n+      rtx mov, src;\n+\n+      /* Despite defining SPLIT_COMPLEX_ARGS, complex function\n+\t arguments may still appear if they are wrapped in a struct.\n+\t For CQImode and CHImode arguments, this results in a move\n+\t with a source operand of the form: \"(subreg:SI (reg:CHI a7)\n+\t 0)\".  The subreg is later removed by the reload pass,\n+\t resulting in the RTL for a7 being regenerated using\n+\t hard_frame_pointer_rtx, and making it impossible for us to\n+\t distinguish the function argument.  Detect this here when\n+\t generating the RTL and remove the subreg immediately so that\n+\t reload won't mess it up.  */\n+      src = operands[1];\n+      if (GET_CODE (src) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (src)) == REG\n+\t  && REGNO (SUBREG_REG (src)) == A7_REG\n+\t  && SUBREG_BYTE (src) == 0\n+\t  && (GET_MODE (SUBREG_REG (src)) == CHImode\n+\t      || GET_MODE (SUBREG_REG (src)) == CQImode))\n+\toperands[1] = gen_raw_REG (mode, A7_REG);\n+\n       switch (mode)\n \t{\n \tcase DFmode:\n@@ -1773,11 +1793,15 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n      rtx that is not equal to hard_frame_pointer_rtx.  For multi-word\n      modes for which we don't define move patterns, we can't control\n      the expansion unless we explicitly list the individual registers\n-     in a PARALLEL.  */\n-\n-  if (mode != DImode && mode != DFmode\n-      && regno < A7_REG\n-      && regno + words > A7_REG)\n+     in a PARALLEL.  Likewise, a single-word BLKmode argument passed\n+     in a7 must be wrapped in a PARALLEL to avoid code that takes the\n+     register number and builds a new REG.  This is extremely fragile\n+     but seems to be the best solution for now.  */\n+\n+  if ((mode != DImode && mode != DFmode\n+       && regno < A7_REG\n+       && regno + words > A7_REG)\n+      || (mode == BLKmode && regno == A7_REG))\n     {\n       rtx result;\n       int n;"}, {"sha": "677a5268285476763713e64986cf629821cb3f44", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "patch": "@@ -799,6 +799,12 @@ typedef struct xtensa_args {\n /* Pass complex arguments independently.  */\n #define SPLIT_COMPLEX_ARGS 1\n \n+/* Because Xtensa's function_arg() wraps BLKmode arguments passed in\n+   a7 inside a PARALLEL, BLOCK_REG_PADDING needs to be defined\n+   to get emit_group_store to do the right thing.  */\n+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n+  FUNCTION_ARG_PADDING (MODE, TYPE)\n+\n /* Profiling Xtensa code is typically done with the built-in profiling\n    feature of Tensilica's instruction set simulator, which does not\n    require any compiler support.  Profiling code on a real (i.e.,"}, {"sha": "d0c4474cb6049335884b835cfd4e94b78f4008c8", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6aecf8efdef48bbf70b2712d742ac4a2cb16e02/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=e6aecf8efdef48bbf70b2712d742ac4a2cb16e02", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for Tensilica's Xtensa architecture.\n-;; Copyright (C) 2001 Free Software Foundation, Inc.\n+;; Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n ;; Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n ;; This file is part of GCC.\n@@ -803,12 +803,15 @@\n   if (CONSTANT_P (operands[1]) && !TARGET_CONST16)\n     operands[1] = force_const_mem (DImode, operands[1]);\n \n-  if (!register_operand (operands[0], DImode)\n-      && !register_operand (operands[1], DImode))\n-    operands[1] = force_reg (DImode, operands[1]);\n+  if (!(reload_in_progress | reload_completed))\n+    {\n+      if (!register_operand (operands[0], DImode)\n+\t  && !register_operand (operands[1], DImode))\n+\toperands[1] = force_reg (DImode, operands[1]);\n \n-  if (xtensa_copy_incoming_a7 (operands, DImode))\n-    DONE;\n+      if (xtensa_copy_incoming_a7 (operands, DImode))\n+\tDONE;\n+    }\n })\n \n (define_insn_and_split \"movdi_internal\"\n@@ -1012,12 +1015,15 @@\n   if (CONSTANT_P (operands[1]) && !TARGET_CONST16)\n     operands[1] = force_const_mem (DFmode, operands[1]);\n \n-  if (!register_operand (operands[0], DFmode)\n-      && !register_operand (operands[1], DFmode))\n-    operands[1] = force_reg (DFmode, operands[1]);\n+  if (!(reload_in_progress | reload_completed))\n+    {\n+      if (!register_operand (operands[0], DFmode)\n+\t  && !register_operand (operands[1], DFmode))\n+\toperands[1] = force_reg (DFmode, operands[1]);\n \n-  if (xtensa_copy_incoming_a7 (operands, DFmode))\n-    DONE;\n+      if (xtensa_copy_incoming_a7 (operands, DFmode))\n+\tDONE;\n+    }\n })\n \n (define_insn_and_split \"movdf_internal\""}]}