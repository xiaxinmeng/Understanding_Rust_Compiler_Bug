{"sha": "46299de919c7e2d651b606c45f4327438ef8d6b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYyOTlkZTkxOWM3ZTJkNjUxYjYwNmM0NWY0MzI3NDM4ZWY4ZDZiNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1995-01-19T23:38:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1995-01-19T23:38:09Z"}, "message": "Add support for r4650, and permit HI/LO to be allocated\n\nFrom-SVN: r8774", "tree": {"sha": "c2b661cfae93efef86fbe5c2c6e81a4ed935a446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2b661cfae93efef86fbe5c2c6e81a4ed935a446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46299de919c7e2d651b606c45f4327438ef8d6b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46299de919c7e2d651b606c45f4327438ef8d6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46299de919c7e2d651b606c45f4327438ef8d6b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46299de919c7e2d651b606c45f4327438ef8d6b7/comments", "author": null, "committer": null, "parents": [{"sha": "2839cf45e09ac06b870fcf4b18b39e038e809e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2839cf45e09ac06b870fcf4b18b39e038e809e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2839cf45e09ac06b870fcf4b18b39e038e809e18"}], "stats": {"total": 650, "additions": 299, "deletions": 351}, "files": [{"sha": "f4880bb5d20055b89cd227a88ceaf2389398b9d4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46299de919c7e2d651b606c45f4327438ef8d6b7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46299de919c7e2d651b606c45f4327438ef8d6b7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=46299de919c7e2d651b606c45f4327438ef8d6b7", "patch": "@@ -3,7 +3,7 @@\n    Changes by     Michael Meissner, meissner@osf.org.\n    64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n    Brendan Eich, brendan@microunity.com.\n-   Copyright (C) 1989, 1990, 1991, 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 90, 91, 93, 94, 1995 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -2818,7 +2818,10 @@ function_arg (cum, mode, type, named)\n     case DFmode:\n       if (! TARGET_64BIT)\n \tcum->arg_words += (cum->arg_words & 1);\n-      regbase = (cum->gp_reg_found || TARGET_SOFT_FLOAT || cum->arg_number >= 2\n+      regbase = ((cum->gp_reg_found\n+\t\t  || TARGET_SOFT_FLOAT\n+\t\t  || TARGET_SINGLE_FLOAT\n+\t\t  || cum->arg_number >= 2)\n \t\t ? GP_ARG_FIRST\n \t\t : FP_ARG_FIRST);\n       break;\n@@ -3166,6 +3169,10 @@ override_options ()\n \t    mips_cpu = PROCESSOR_R4000;\n \t  else if (!strcmp (p, \"4600\"))\n \t    mips_cpu = PROCESSOR_R4600;\n+\t  /* Although the r4650 adds a couple of instructions, it uses\n+             the r4600 pipeline.  */\n+\t  else if (!strcmp (p, \"4650\"))\n+\t    mips_cpu = PROCESSOR_R4600;\n \t  break;\n \n \tcase '6':\n@@ -3350,12 +3357,14 @@ override_options ()\n \t    temp = ((TARGET_FLOAT64 || ((regno & 1) == 0))\n \t\t    && (class == MODE_FLOAT\n \t\t\t|| class == MODE_COMPLEX_FLOAT\n-\t\t\t|| (TARGET_DEBUG_H_MODE && class == MODE_INT)));\n+\t\t\t|| (TARGET_DEBUG_H_MODE && class == MODE_INT))\n+\t\t    && (! TARGET_SINGLE_FLOAT || size <= 4));\n \n \t  else if (MD_REG_P (regno))\n \t    {\n \t      if (TARGET_64BIT)\n \t\ttemp = (mode == DImode\n+\t\t\t|| mode == SImode\n \t\t\t|| (regno == MD_REG_FIRST && mode == TImode));\n \t      else\n \t\ttemp = (mode == SImode\n@@ -4401,7 +4410,7 @@ compute_frame_size (size)\n     }\n \n   /* Calculate space needed for fp registers.  */\n-  if (TARGET_FLOAT64)\n+  if (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT)\n     {\n       fp_inc = 1;\n       fp_bits = 1;\n@@ -4422,7 +4431,7 @@ compute_frame_size (size)\n     }\n \n   gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n-  total_size += gp_reg_rounded + fp_reg_size;\n+  total_size += gp_reg_rounded + MIPS_STACK_ALIGN (fp_reg_size);\n \n   if (total_size == extra_size)\n     total_size = extra_size = 0;\n@@ -4626,7 +4635,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n   /* Save floating point registers if needed.  */\n   if (fmask)\n     {\n-      int fp_inc = (TARGET_FLOAT64) ? 1 : 2;\n+      int fp_inc = (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT) ? 1 : 2;\n       int fp_size = fp_inc * UNITS_PER_FPREG;\n \n       /* Pick which pointer to use as a base register.  */\n@@ -4700,8 +4709,10 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t    {\n \t      if (file == (FILE *)0)\n \t\t{\n-\t\t  rtx reg_rtx = gen_rtx (REG, DFmode, regno);\n-\t\t  rtx mem_rtx = gen_rtx (MEM, DFmode,\n+\t\t  enum machine_mode sz =\n+\t\t    TARGET_SINGLE_FLOAT ? SFmode : DFmode;\n+\t\t  rtx reg_rtx = gen_rtx (REG, sz, regno);\n+\t\t  rtx mem_rtx = gen_rtx (MEM, sz,\n \t\t\t\t\t gen_rtx (PLUS, Pmode, base_reg_rtx,\n \t\t\t\t\t\t  GEN_INT (fp_offset - base_offset)));\n \n@@ -4712,7 +4723,9 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t}\n \t      else\n \t\tfprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n-\t\t\t (store_p) ? \"s.d\" : \"l.d\",\n+\t\t\t (TARGET_SINGLE_FLOAT\n+\t\t\t  ? ((store_p) ? \"s.s\" : \"l.s\")\n+\t\t\t  : ((store_p) ? \"s.d\" : \"l.d\")),\n \t\t\t reg_names[regno],\n \t\t\t fp_offset - base_offset,\n \t\t\t reg_names[REGNO(base_reg_rtx)]);\n@@ -5376,3 +5389,25 @@ mips_select_section (decl, reloc)\n \tdata_section ();\n     }\n }\n+\n+/* Moving the HI or LO register somewhere requires a general register.  */\n+\n+enum reg_class\n+mips_secondary_reload_class (class, mode, x)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  if (class != HI_REG && class != LO_REG && class != MD_REGS)\n+    return NO_REGS;\n+\n+  if (GET_CODE (x) == REG)\n+    {\n+      int regno = true_regnum (x);\n+\n+      if (regno >= GP_REG_FIRST && regno <= GP_REG_LAST)\n+\treturn NO_REGS;\n+    }\n+\n+  return GR_REGS;\n+}"}, {"sha": "25e6f09bbd87476e076bab2c93ccc0343375ecc6", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46299de919c7e2d651b606c45f4327438ef8d6b7/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46299de919c7e2d651b606c45f4327438ef8d6b7/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=46299de919c7e2d651b606c45f4327438ef8d6b7", "patch": "@@ -3,7 +3,7 @@\n    Changed by Michael Meissner,\t\tmeissner@osf.org\n    64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n    Brendan Eich, brendan@microunity.com.\n-   Copyright (C) 1989, 90, 91, 92, 93, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 90, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -260,8 +260,8 @@ extern char\t       *mktemp ();\n #define MASK_EMBEDDED_PIC 0x00004000\t/* Generate embedded PIC code */\n #define MASK_EMBEDDED_DATA 0x00008000\t/* Reduce RAM usage, not fast code */\n #define MASK_BIG_ENDIAN\t0x00010000\t/* Generate big endian code */\n-#define MASK_UNUSED3\t0x00020000\n-#define MASK_UNUSED2\t0x00040000\n+#define MASK_SINGLE_FLOAT 0x00020000\t/* Only single precision FPU.  */\n+#define MASK_MAD\t0x00040000\t/* Generate mad/madu as on 4650.  */\n #define MASK_UNUSED1\t0x00080000\n \n \t\t\t\t\t/* Dummy switches used only in spec's*/\n@@ -341,6 +341,11 @@ extern char\t       *mktemp ();\n \t\t\t\t\t/* generate big endian code.  */\n #define TARGET_BIG_ENDIAN\t(target_flags & MASK_BIG_ENDIAN)\n \n+#define TARGET_SINGLE_FLOAT\t(target_flags & MASK_SINGLE_FLOAT)\n+#define TARGET_DOUBLE_FLOAT\t(! TARGET_SINGLE_FLOAT)\n+\n+#define TARGET_MAD\t\t(target_flags & MASK_MAD)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -383,6 +388,11 @@ extern char\t       *mktemp ();\n   {\"no-embedded-data\",\t -MASK_EMBEDDED_DATA},\t\t\t\t\\\n   {\"eb\",\t\t  MASK_BIG_ENDIAN},\t\t\t\t\\\n   {\"el\",\t\t -MASK_BIG_ENDIAN},\t\t\t\t\\\n+  {\"single-float\",\t  MASK_SINGLE_FLOAT},\t\t\t\t\\\n+  {\"double-float\",\t -MASK_SINGLE_FLOAT},\t\t\t\t\\\n+  {\"mad\",\t\t  MASK_MAD},\t\t\t\t\t\\\n+  {\"no-mad\",\t\t -MASK_MAD},\t\t\t\t\t\\\n+  {\"4650\",\t\t  MASK_MAD | MASK_SINGLE_FLOAT},\t\t\\\n   {\"debug\",\t\t  MASK_DEBUG},\t\t\t\t\t\\\n   {\"debuga\",\t\t  MASK_DEBUG_A},\t\t\t\t\\\n   {\"debugb\",\t\t  MASK_DEBUG_B},\t\t\t\t\\\n@@ -575,7 +585,7 @@ while (0)\n \t%{pipe: %e-pipe is not supported.} \\\n \t%{K}} \\\n %{!mmips-as: \\\n-\t%{mcpu=*}} \\\n+\t%{mcpu=*} %{m4650} %{mmad:-m4650}} \\\n %{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{v} \\\n %{noasmopt:-O0} \\\n %{!noasmopt:%{O:-O2} %{O1:-O2} %{O2:-O2} %{O3:-O3}} \\\n@@ -594,7 +604,7 @@ while (0)\n \t%{pipe: %e-pipe is not supported.} \\\n \t%{K}} \\\n %{mgas: \\\n-\t%{mcpu=*}} \\\n+\t%{mcpu=*} %{m4650} %{mmad:-m4650}} \\\n %{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{v} \\\n %{noasmopt:-O0} \\\n %{!noasmopt:%{O:-O2} %{O1:-O2} %{O2:-O2} %{O3:-O3}} \\\n@@ -662,7 +672,11 @@ while (0)\n #ifndef CC1_SPEC\n #define CC1_SPEC \"\\\n %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n-%{mips1:-mfp32 -mgp32}%{mips2:-mfp32 -mgp32}%{mips3:-mfp64 -mgp64} \\\n+%{mips1:-mfp32 -mgp32}%{mips2:-mfp32 -mgp32}\\\n+%{mips3:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n+%{mfp64:%{msingle-float:%emay not use both -mfp64 and -msingle-float}} \\\n+%{mfp64:%{m4650:%emay not use both -mfp64 and -m4650}} \\\n+%{m4650:-mcpu=r4650} \\\n %{G*} %{EB:-meb} %{EL:-mel} %{EB:%{EL:%emay not use both -EB and -EL}} \\\n %{pic-none:   -mno-half-pic} \\\n %{pic-lib:    -mhalf-pic} \\\n@@ -1138,7 +1152,7 @@ do {\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  1, 1, 1\t\t\t\t\t\t\t\t\\\n+  0, 0, 1\t\t\t\t\t\t\t\t\\\n }\n \n \n@@ -1211,7 +1225,9 @@ do {\t\t\t\t\t\t\t\\\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (! FP_REG_P (REGNO)\t\t\t\t\t\t\t\\\n \t? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) \\\n-        : (((GET_MODE_SIZE (MODE) + 7) / 8) << (TARGET_FLOAT64 == 0)))\n+        : (TARGET_SINGLE_FLOAT\t\t\t\t\t\t\\\n+\t   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG) \\\n+\t   : (((GET_MODE_SIZE (MODE) + 7) / 8) << (TARGET_FLOAT64 == 0))))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n    MODE.  In 32 bit mode, require that DImode and DFmode be in even\n@@ -1534,6 +1550,16 @@ extern enum reg_class mips_char_to_class[];\n        && ((CLASS1 == GR_REGS && CLASS2 == FP_REGS)\t\t\t\\\n \t   || (CLASS2 == GR_REGS && CLASS1 == FP_REGS))))\n \n+/* The HI and LO registers can only be reloaded via the general\n+   registers.  */\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\t\\\n+  mips_secondary_reload_class (CLASS, MODE, X)\n+\n+/* Not declared above, with the other functions, because enum\n+   reg_class is not declared yet.  */\n+extern enum reg_class\tmips_secondary_reload_class ();\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n \n@@ -1816,9 +1842,11 @@ extern struct mips_frame_info current_frame_info;\n \n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n   gen_rtx (REG, MODE,\t\t\t\t\t\t\t\\\n-\t   (GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\\\n-\t\t? FP_RETURN\t\t\t\t\t\t\\\n-\t\t: GP_RETURN)\n+\t   ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+\t     && (! TARGET_SINGLE_FLOAT\t\t\t\t\t\\\n+\t\t || GET_MODE_SIZE (MODE) <= 4))\t\t\t\t\\\n+\t    ? FP_RETURN\t\t\t\t\t\t\t\\\n+\t    : GP_RETURN))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -2824,7 +2852,11 @@ while (0)\n    : (FROM) == FP_REGS && (TO) == FP_REGS ? 2\t\t\t\t\\\n    : (FROM) == GR_REGS && (TO) == FP_REGS ? 4\t\t\t\t\\\n    : (FROM) == FP_REGS && (TO) == GR_REGS ? 4\t\t\t\t\\\n-   : 6)\n+   : (((FROM) == HI_REG || (FROM) == LO_REG || (FROM) == MD_REGS)\t\\\n+      && (TO) == GR_REGS) ? 6\t\t\t\t\t\t\\\n+   : (((TO) == HI_REG || (TO) == LO_REG || (TO) == MD_REGS)\t\t\\\n+      && (FROM) == GR_REGS) ? 6\t\t\t\t\t\t\\\n+   : 12)\n \n #define MEMORY_MOVE_COST(MODE) \\\n   ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4)"}, {"sha": "32f02be82708e6264d04ce0b1c305eab029a8b08", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 211, "deletions": 330, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46299de919c7e2d651b606c45f4327438ef8d6b7/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46299de919c7e2d651b606c45f4327438ef8d6b7/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=46299de919c7e2d651b606c45f4327438ef8d6b7", "patch": "@@ -3,7 +3,7 @@\n ;;  Changes by       Michael Meissner, meissner@osf.org\n ;;  64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n ;;  Brendan Eich, brendan@microunity.com.\n-;;  Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+;;  Copyright (C) 1989, 90, 91, 92, 93, 94, 95 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -326,7 +326,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"add.d\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"fadd\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -563,7 +563,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"sub.d\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"fadd\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -787,7 +787,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"mul.d\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"fmul\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -803,13 +803,43 @@\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+;; ??? The R4000 (only) has a cpu bug.  If a double-word shift executes while\n+;; a multiply is in progress, it may give an incorrect result.  Avoid\n+;; this by keeping the mflo with the mult on the R4000.\n+\n+(define_expand \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"\"\n+  \"\n+{\n+  if (mips_cpu != PROCESSOR_R4000)\n+    emit_insn (gen_mulsi3_internal (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_mulsi3_r4000 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mulsi3_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n+  \"mips_cpu != PROCESSOR_R4000\"\n+  \"mult\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"mulsi3_r4000\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n+  \"mips_cpu == PROCESSOR_R4000\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -825,43 +855,39 @@\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"3\")])\t\t;; mult + mflo + delay\n \n-;; ??? The R4000 (only) has a cpu bug.  If a double-word shift executes while\n-;; a multiply is in progress, it may give an incorrect result.  We solve\n-;; this by not splitting on the r4000.\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n-  \"!TARGET_DEBUG_D_MODE && mips_cpu != PROCESSOR_R4000\"\n-  [(parallel [(set (reg:SI 65)\t\t;; low register\n-\t\t   (mult:SI (match_dup 1)\n-\t\t\t    (match_dup 2)))\n-\t      (clobber (reg:SI 64))])\n-   (set (match_dup 0)\n-\t(reg:SI 65))]\n-  \"\")\n+(define_expand \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:DI 3 \"=h\"))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  if (mips_cpu != PROCESSOR_R4000)\n+    emit_insn (gen_muldi3_internal (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_muldi3_r4000 (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n \n-(define_insn \"mulsi3_internal\"\n-  [(set (reg:SI 65)\t\t;; low register\n-\t(mult:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (clobber (reg:SI 64))]\n-  \"\"\n-  \"mult\\\\t%0,%1\"\n+(define_insn \"muldi3_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:DI 3 \"=h\"))]\n+  \"TARGET_64BIT && mips_cpu != PROCESSOR_R4000\"\n+  \"dmul\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"muldi3\"\n+(define_insn \"muldi3_r4000\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n-  \"TARGET_64BIT\"\n+   (clobber (match_scratch:DI 3 \"=h\"))\n+   (clobber (match_scratch:DI 4 \"=l\"))]\n+  \"TARGET_64BIT && mips_cpu == PROCESSOR_R4000\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -877,36 +903,6 @@\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"3\")])\t\t;; mult + mflo + delay\n \n-;; ??? The R4000 (only) has a cpu bug.  If a double-word shift executes while\n-;; a multiply is in progress, it may give an incorrect result.  We solve\n-;; this by not splitting on the r4000.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n-  \"TARGET_64BIT && !TARGET_DEBUG_D_MODE && mips_cpu != PROCESSOR_R4000\"\n-  [(parallel [(set (reg:DI 65)\t\t;; low register\n-\t\t   (mult:DI (match_dup 1)\n-\t\t\t    (match_dup 2)))\n-\t      (clobber (reg:DI 64))])\n-   (set (match_dup 0)\n-\t(reg:DI 65))]\n-  \"\")\n-\n-(define_insn \"muldi3_internal\"\n-  [(set (reg:DI 65)\t\t;; low register\n-\t(mult:DI (match_operand:DI 0 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 1 \"register_operand\" \"d\")))\n-   (clobber (reg:DI 64))]\n-  \"TARGET_64BIT\"\n-  \"dmult\\\\t%0,%1\"\n-  [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"1\")])\n-\n ;; In 64 bit mode the mult instruction still writes 32 bits each to HI\n ;; and LO, so to do mulsidi3 and umultsidi3 we need to pull the values\n ;; out and combine them by hand into the single output register.  Not\n@@ -915,272 +911,155 @@\n ;; ??? We could define a mulditi3 pattern when TARGET_64BIT.\n \n (define_insn \"mulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"!TARGET_64BIT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, DImode, MD_REG_FIRST);\n-\n-  output_asm_insn (\\\"mult\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_2words (xoperands, insn), xoperands);\n-  return \\\"\\\";\n-}\"\n+  \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4\")])\t\t;; mult + mflo + mfhi + delay\n+   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"smulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(truncate:SI\n-\t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t\t      (const_int 32))))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, SImode, HI_REGNUM);\n-\n-  output_asm_insn (\\\"mult\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_1word (xoperands, insn, TRUE), xoperands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"3\")])\t\t;; mult + mfhi + delay\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 32))))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n-  \"!TARGET_DEBUG_D_MODE\"\n-  [(parallel [(set (reg:SI 64)\t\t;; high register\n-\t\t   (truncate:SI\n-\t\t    (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n-\t\t\t\t\t  (sign_extend:DI (match_dup 2)))\n-\t\t\t\t (const_int 32))))\n-\t      (clobber (reg:SI 65))])\n-   (set (match_dup 0)\n-\t(reg:SI 64))]\n-  \"\")\n-\n-(define_insn \"smulsi3_highpart_internal\"\n-  [(set (reg:SI 64)\t\t\t;; high register\n-\t(truncate:SI\n-\t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t\t\t       (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\")))\n-\t\t      (const_int 32))))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"\"\n-  \"mult\\\\t%0,%1\"\n+  \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n (define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"!TARGET_64BIT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, DImode, MD_REG_FIRST);\n-\n-  output_asm_insn (\\\"multu\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_2words (xoperands, insn), xoperands);\n-  return \\\"\\\";\n-}\"\n+  \"multu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4\")])\t\t;; mult + mflo + mfhi + delay\n+   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"umulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(truncate:SI\n-\t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t\t      (const_int 32))))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, SImode, HI_REGNUM);\n-\n-  output_asm_insn (\\\"multu\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"3\")])\t\t;; multu + mfhi + delay\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 32))))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n-  \"!TARGET_DEBUG_D_MODE\"\n-  [(parallel [(set (reg:SI 64)\t\t;; high register\n-\t\t   (truncate:SI\n-\t\t    (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n-\t\t\t\t\t  (zero_extend:DI (match_dup 2)))\n-\t\t\t\t (const_int 32))))\n-\t      (clobber (reg:SI 65))])\n-   (set (match_dup 0)\n-\t(reg:SI 64))]\n-  \"\")\n-\n-(define_insn \"umulsi3_highpart_internal\"\n-  [(set (reg:SI 64)\t\t\t;; high register\n-\t(truncate:SI\n-\t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t\t\t       (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\")))\n-\t\t      (const_int 32))))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"\"\n-  \"multu\\\\t%0,%1\"\n+  \"multu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n (define_insn \"smuldi3_highpart\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(truncate:DI\n-\t (lshiftrt:TI (mult:TI (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n-\t\t\t       (sign_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n-\t\t      (const_int 64))))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n-  \"TARGET_64BIT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, DImode, HI_REGNUM);\n-\n-  output_asm_insn (\\\"dmult\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_1word (xoperands, insn, TRUE), xoperands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"3\")])\t\t;; mult + mfhi + delay\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(truncate:DI\n \t (lshiftrt:TI (mult:TI (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n \t\t\t       (sign_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 64))))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n-  \"TARGET_64BIT && !TARGET_DEBUG_D_MODE\"\n-  [(parallel [(set (reg:DI 64)\t\t;; high register\n-\t\t   (truncate:DI\n-\t\t    (lshiftrt:TI (mult:TI (sign_extend:TI (match_dup 1))\n-\t\t\t\t\t  (sign_extend:TI (match_dup 2)))\n-\t\t\t\t (const_int 64))))\n-\t      (clobber (reg:DI 65))])\n-   (set (match_dup 0)\n-\t(reg:DI 64))]\n-  \"\")\n-\n-(define_insn \"smuldi3_highpart_internal\"\n-  [(set (reg:DI 64)\t\t\t;; high register\n-\t(truncate:DI\n-\t (lshiftrt:TI (mult:TI (sign_extend:TI (match_operand:DI 0 \"register_operand\" \"d\"))\n-\t\t\t       (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"d\")))\n-\t\t      (const_int 64))))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 3 \"=l\"))]\n   \"TARGET_64BIT\"\n-  \"dmult\\\\t%0,%1\"\n+  \"dmult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"1\")])\n \n (define_insn \"umuldi3_highpart\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(truncate:DI\n \t (lshiftrt:TI (mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n \t\t\t       (zero_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 64))))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 3 \"=l\"))]\n   \"TARGET_64BIT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, DImode, HI_REGNUM);\n-\n-  output_asm_insn (\\\"dmultu\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n-  return \\\"\\\";\n-}\"\n+  \"dmultu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"3\")])\t\t;; multu + mfhi + delay\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(truncate:DI\n-\t (lshiftrt:TI (mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n-\t\t\t       (zero_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n-\t\t      (const_int 64))))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n-  \"TARGET_64BIT && !TARGET_DEBUG_D_MODE\"\n-  [(parallel [(set (reg:DI 64)\t\t;; high register\n-\t\t   (truncate:DI\n-\t\t    (lshiftrt:TI (mult:TI (zero_extend:TI (match_dup 1))\n-\t\t\t\t\t  (zero_extend:TI (match_dup 2)))\n-\t\t\t\t (const_int 64))))\n-\t      (clobber (reg:DI 65))])\n-   (set (match_dup 0)\n-\t(reg:DI 64))]\n-  \"\")\n+   (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"umuldi3_highpart_internal\"\n-  [(set (reg:DI 64)\t\t\t;; high register\n-\t(truncate:DI\n-\t (lshiftrt:TI (mult:TI (zero_extend:TI (match_operand:DI 0 \"register_operand\" \"d\"))\n-\t\t\t       (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"d\")))\n-\t\t      (const_int 64))))\n-   (clobber (reg:DI 65))]\n-  \"TARGET_64BIT\"\n-  \"dmultu\\\\t%0,%1\"\n+;; The R4650 supports a 32 bit multiply/ 64 bit accumulate\n+;; instruction.  The HI/LO registers are used as a 64 bit accumulator.\n+\n+(define_insn \"madsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+l\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"d\"))\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:SI 3 \"+h\"))]\n+  \"TARGET_MAD\"\n+  \"mad\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"1\")])\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n+\n+(define_insn \"madsi_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+h\")\n+\t(plus:SI (truncate:SI\n+\t\t  (lshiftrt:DI\n+\t\t   (mult:DI (sign_extend:DI\n+\t\t\t     (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t    (sign_extend:DI\n+\t\t\t     (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t\t   (const_int 32)))\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:SI 3 \"+l\"))]\n+  \"TARGET_MAD\"\n+  \"mad\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n+\n+(define_insn \"umadsi_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+h\")\n+\t(plus:SI (truncate:SI\n+\t\t  (lshiftrt:DI\n+\t\t   (mult:DI (zero_extend:DI\n+\t\t\t     (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t    (zero_extend:DI\n+\t\t\t     (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t\t   (const_int 32)))\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:SI 3 \"+l\"))]\n+  \"TARGET_MAD\"\n+  \"madu\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n+\n+;; ??? We can only refer to HI/LO as a register pair when not\n+;; compiling 64 bit code.  That's because we don't know how to extract\n+;; the two 32 bit values into a single 64 bit register.\n+\n+(define_insn \"maddi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+x\")\n+\t(plus:DI (mult:DI (sign_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t\t (match_dup 0)))]\n+  \"TARGET_MAD && ! TARGET_64BIT\"\n+  \"mad\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n+\n+(define_insn \"umaddi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+x\")\n+\t(plus:DI (mult:DI (zero_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t  (zero_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t\t (match_dup 0)))]\n+  \"TARGET_MAD && ! TARGET_64BIT\"\n+  \"madu\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n \f\n ;;\n ;;  ....................\n@@ -1194,7 +1073,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"div.d\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"fdiv\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1230,8 +1109,8 @@\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n \t(mod:SI (match_dup 1)\n \t\t(match_dup 2)))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 4 \"=l\"))\n+   (clobber (match_scratch:SI 5 \"=h\"))]\n   \"optimize\"\n   \"*\n {\n@@ -1254,8 +1133,8 @@\n    (set (match_operand:DI 3 \"register_operand\" \"=d\")\n \t(mod:DI (match_dup 1)\n \t\t(match_dup 2)))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 4 \"=l\"))\n+   (clobber (match_scratch:DI 5 \"=h\"))]\n   \"TARGET_64BIT && optimize\"\n   \"*\n {\n@@ -1278,8 +1157,8 @@\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n \t(umod:SI (match_dup 1)\n \t\t (match_dup 2)))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 4 \"=l\"))\n+   (clobber (match_scratch:SI 5 \"=h\"))]\n   \"optimize\"\n   \"*\n {\n@@ -1302,8 +1181,8 @@\n    (set (match_operand:DI 3 \"register_operand\" \"=d\")\n \t(umod:DI (match_dup 1)\n \t\t (match_dup 2)))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 4 \"=l\"))\n+   (clobber (match_scratch:DI 5 \"=h\"))]\n   \"TARGET_64BIT && optimize\"\n   \"*\n {\n@@ -1323,8 +1202,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n   \"!optimize\"\n   \"div\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1335,8 +1214,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t(match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddiv\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1347,8 +1226,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n   \"!optimize\"\n   \"rem\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1359,8 +1238,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(mod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t(match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"drem\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1371,8 +1250,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n   \"!optimize\"\n   \"divu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1383,8 +1262,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddivu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1395,8 +1274,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:SI 64))\n-   (clobber (reg:SI 65))]\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n   \"!optimize\"\n   \"remu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1407,8 +1286,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(umod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (reg:DI 64))\n-   (clobber (reg:DI 65))]\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"dremu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1426,7 +1305,7 @@\n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && HAVE_SQRT_P()\"\n+  \"TARGET_HARD_FLOAT && HAVE_SQRT_P() && TARGET_DOUBLE_FLOAT\"\n   \"sqrt.d\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fsqrt\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1498,7 +1377,7 @@\n (define_insn \"absdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(abs:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"abs.d\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fabs\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1661,7 +1540,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"negdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"neg.d\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fneg\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1939,7 +1818,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"cvt.s.d\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n@@ -2360,7 +2239,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"cvt.d.s\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -2384,7 +2263,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(fix:SI (match_operand:DF 1 \"register_operand\" \"f,*f,f,f\")))\n    (clobber (match_scratch:SI 2 \"=d,*d,&d,&d\"))\n    (clobber (match_scratch:DF 3 \"=f,*X,f,f\"))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -2442,7 +2321,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:DI 0 \"general_operand\" \"=d,*f,R,o\")\n \t(fix:DI (match_operand:DF 1 \"register_operand\" \"f,*f,f,f\")))\n    (clobber (match_scratch:DF 2 \"=f,*X,f,f\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT\"\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -2469,7 +2348,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:DI 0 \"general_operand\" \"=d,*f,R,o\")\n \t(fix:DI (match_operand:SF 1 \"register_operand\" \"f,*f,f,f\")))\n    (clobber (match_scratch:DF 2 \"=f,*X,f,f\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT\"\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -2492,7 +2371,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"floatsidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n \t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   dslots_load_total++;\n@@ -2509,7 +2388,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n \t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT\"\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   dslots_load_total++;\n@@ -2543,7 +2422,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"floatdisf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n \t(float:SF (match_operand:DI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT\"\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   dslots_load_total++;\n@@ -2560,7 +2439,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_expand \"fixuns_truncdfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n   rtx reg1 = gen_reg_rtx (DFmode);\n@@ -2603,7 +2482,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_expand \"fixuns_truncdfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(unsigned_fix:DI (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT\"\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n   rtx reg1 = gen_reg_rtx (DFmode);\n@@ -2690,7 +2569,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_expand \"fixuns_truncsfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(unsigned_fix:DI (match_operand:SF 1 \"register_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT\"\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n   rtx reg1 = gen_reg_rtx (SFmode);\n@@ -3211,6 +3090,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,R,o,f,*f,*d,*d,*d,*d,*R,*o\")\n \t(match_operand:DF 1 \"general_operand\" \"f,R,o,fG,fG,F,*d,*f,*d*G,*R,*o*F,*d,*d\"))]\n   \"TARGET_HARD_FLOAT && !(TARGET_FLOAT64 && !TARGET_64BIT)\n+   && TARGET_DOUBLE_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n@@ -3224,6 +3104,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,R,R,o,o,f,*d,*d,*d,*o,*R\")\n \t(match_operand:DF 1 \"general_operand\"      \" f,o,f,G,f,G,F,*F,*o,*R,*d,*d\"))]\n   \"TARGET_HARD_FLOAT && (TARGET_FLOAT64 && !TARGET_64BIT)\n+   && TARGET_DOUBLE_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\n        || (GET_CODE (operands [0]) == MEM\n@@ -3238,7 +3119,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"movdf_internal2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,R,o\")\n \t(match_operand:DF 1 \"general_operand\" \"dG,R,oF,d,d\"))]\n-  \"TARGET_SOFT_FLOAT\n+  \"(TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT)\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n@@ -4148,7 +4029,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (cc0)\n \t(compare:CC_FP (match_operand:DF 0 \"register_operand\" \"\")\n \t\t       (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n   if (operands[0])\t\t/* avoid unused code message */\n@@ -5273,7 +5154,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (reg:CC_FP 66)\n \t(eq:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -5291,7 +5172,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (reg:CC_REV_FP 66)\n \t(ne:CC_REV_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t      (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -5309,7 +5190,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (reg:CC_FP 66)\n \t(lt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -5327,7 +5208,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (reg:CC_FP 66)\n \t(le:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -5345,7 +5226,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (reg:CC_FP 66)\n \t(gt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -5363,7 +5244,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (reg:CC_FP 66)\n \t(ge:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n   rtx xoperands[10];"}]}