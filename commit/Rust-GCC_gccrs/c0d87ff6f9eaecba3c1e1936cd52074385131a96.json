{"sha": "c0d87ff6f9eaecba3c1e1936cd52074385131a96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBkODdmZjZmOWVhZWNiYTNjMWUxOTM2Y2Q1MjA3NDM4NTEzMWE5Ng==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-03-08T13:34:10Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-03-08T13:34:10Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r25640", "tree": {"sha": "f0bdea6323fef6f701c096b08fa20cb0bc307956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0bdea6323fef6f701c096b08fa20cb0bc307956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0d87ff6f9eaecba3c1e1936cd52074385131a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d87ff6f9eaecba3c1e1936cd52074385131a96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d87ff6f9eaecba3c1e1936cd52074385131a96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d87ff6f9eaecba3c1e1936cd52074385131a96/comments", "author": null, "committer": null, "parents": [{"sha": "78dd9906fec9205dbbe80bcaffe3f4b38d676b31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78dd9906fec9205dbbe80bcaffe3f4b38d676b31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78dd9906fec9205dbbe80bcaffe3f4b38d676b31"}], "stats": {"total": 104, "additions": 30, "deletions": 74}, "files": [{"sha": "6579a3d807c83d2026b8666569b266e12f16d107", "filename": "gcc/java/parse.c", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d87ff6f9eaecba3c1e1936cd52074385131a96/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d87ff6f9eaecba3c1e1936cd52074385131a96/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=c0d87ff6f9eaecba3c1e1936cd52074385131a96", "patch": "@@ -5139,20 +5139,24 @@ find_expr_with_wfl (node)\n       switch (TREE_CODE (node))\n \t{\n \tcase BLOCK:\n-\t  return find_expr_with_wfl (BLOCK_EXPR_BODY (node));\n+\t  node = BLOCK_EXPR_BODY (node);\n+\t  continue;\n \n \tcase COMPOUND_EXPR:\n \t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 0));\n \t  if (to_return)\n \t    return to_return;\n-\t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 1));\n-\t  return to_return;\n+\t  node = TREE_OPERAND (node, 1);\n+\t  continue;\n \n \tcase LOOP_EXPR:\n-\t  return find_expr_with_wfl (TREE_OPERAND (node, 0));\n+\t  node = TREE_OPERAND (node, 0);\n+\t  continue;\n \t  \n \tcase LABELED_BLOCK_EXPR:\n-\t  return find_expr_with_wfl (TREE_OPERAND (node, 1));\n+\t  node = TREE_OPERAND (node, 1);\n+\t  continue;\n+\n \tdefault:\n \t  code = TREE_CODE_CLASS (TREE_CODE (node));\n \t  if (((code == '1') || (code == '2') || (code == 'e'))\n@@ -5286,7 +5290,7 @@ build_array_from_name (type, type_wfl, name, ret_name)\n   /* If we have, then craft a new type for this variable */\n   if (more_dims)\n     {\n-      name = get_identifier (&more_dims [string]);\n+      name = get_identifier (&string [more_dims]);\n \n       /* If we have a pointer, use its type */\n       if (TREE_CODE (type) == POINTER_TYPE)\n@@ -5762,11 +5766,6 @@ register_fields (flags, type, variable_list)\n       if (must_chain)\n \tregister_incomplete_type (JDEP_FIELD, wfl, field_decl, type);\n \t  \n-      /* Default value of a static field is 0 and it is considered\n-\t initialized. */\n-      if (flags & ACC_STATIC)\n-\tINITIALIZED_P (field_decl) = 1;\n-      \n       /* If we have an initialization value tied to the field */\n       if (init)\n \t{\n@@ -5793,7 +5792,6 @@ register_fields (flags, type, variable_list)\n \t      TREE_CHAIN (init) = ctxp->non_static_initialized;\n \t      ctxp->non_static_initialized = init;\n \t    }\n-\t  INITIALIZED_P (field_decl) = 1;\n \t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n \t}\n     }\n@@ -5935,7 +5933,7 @@ method_header (flags, type, mdecl, throws)\n \n   /* Method declared within the scope of an interface are implicitly\n      abstract and public. Conflicts with other erroneously provided\n-     modifiers are check right after. */\n+     modifiers are checked right after. */\n \n   if (CLASS_INTERFACE (TYPE_NAME (this_class)))\n     {\n@@ -8059,7 +8057,6 @@ expand_start_java_method (fndecl)\n       DECL_ARG_TYPE (tem) = type;\n       layout_decl (tem, 0);\n       pushdecl (tem);\n-      INITIALIZED_P (tem) = 1;\t/* Parms are initialized */\n       *ptr = tem;\n       ptr = &TREE_CHAIN (tem);\n       tem = next;\n@@ -10153,7 +10150,6 @@ java_complete_lhs (node)\n \t{\n \t  DECL_CONTEXT (cn) = current_function_decl;\n \t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (cn)) = cn;\n-\t  INITIALIZED_P (cn) = 0;\n \t}\n       if (BLOCK_EXPR_BODY (node) == NULL_TREE)\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n@@ -10537,25 +10533,8 @@ java_complete_lhs (node)\n       else\n \tnn = java_complete_tree (TREE_OPERAND (node, 1));\n \n-      /* There are cases where the type of RHS is fixed. In those\n-\t cases, if the evaluation of the RHS fails, we further the\n-\t evaluation of the assignment to detect more errors. */\n       if (nn == error_mark_node)\n-\t{\n-\t  /* It's hopeless, but we can further things on to discover\n-\t     an error during the assignment. In any cases, the\n-\t     assignment operation fails. */\n-\t  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION\n-\t      && TREE_CODE (TREE_OPERAND (node, 1)) != NEW_ARRAY_INIT\n-\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node)\n-\t    patch_assignment (node, wfl_op1, wfl_op2);\n-\n-\t  /* Now, we still mark the lhs as initialized */\n-\t  if (JDECL_P (TREE_OPERAND (node, 0)))\n-\t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n-\n-\t  return error_mark_node;\n-\t}\n+\treturn error_mark_node;\n       TREE_OPERAND (node, 1) = nn;\n \n       /* In case we're handling = with a String as a RHS, we need to\n@@ -11050,7 +11029,6 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Lhs can be a named variable */\n   if (JDECL_P (lvalue))\n     {\n-      INITIALIZED_P (lvalue) = 1;\n       lhs_type = TREE_TYPE (lvalue);\n     }\n   /* Or Lhs can be a array acccess. Should that be lvalue ? FIXME +\n@@ -11988,13 +11966,13 @@ build_string_concatenation (op1, op2)\n   if ((result = string_constant_concatenation (op1, op2)))\n     return result;\n \n-  /* Discard null constants on either sides of the expression */\n-  if (TREE_CODE (op1) == STRING_CST && !TREE_STRING_LENGTH (op1))\n+  /* Discard empty strings on either side of the expression */\n+  if (TREE_CODE (op1) == STRING_CST && TREE_STRING_LENGTH (op1) == 0)\n     {\n       op1 = op2;\n       op2 = NULL_TREE;\n     }\n-  else if (TREE_CODE (op2) == STRING_CST && !TREE_STRING_LENGTH (op2))\n+  else if (TREE_CODE (op2) == STRING_CST && TREE_STRING_LENGTH (op2) == 0)\n     op2 = NULL_TREE;\n \n   /* If operands are string constant, turn then into object references */"}, {"sha": "c26a7cc97e08d25e0e829d1fbfab7de60cefeee5", "filename": "gcc/java/parse.y", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d87ff6f9eaecba3c1e1936cd52074385131a96/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d87ff6f9eaecba3c1e1936cd52074385131a96/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c0d87ff6f9eaecba3c1e1936cd52074385131a96", "patch": "@@ -2537,20 +2537,24 @@ find_expr_with_wfl (node)\n       switch (TREE_CODE (node))\n \t{\n \tcase BLOCK:\n-\t  return find_expr_with_wfl (BLOCK_EXPR_BODY (node));\n+\t  node = BLOCK_EXPR_BODY (node);\n+\t  continue;\n \n \tcase COMPOUND_EXPR:\n \t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 0));\n \t  if (to_return)\n \t    return to_return;\n-\t  to_return = find_expr_with_wfl (TREE_OPERAND (node, 1));\n-\t  return to_return;\n+\t  node = TREE_OPERAND (node, 1);\n+\t  continue;\n \n \tcase LOOP_EXPR:\n-\t  return find_expr_with_wfl (TREE_OPERAND (node, 0));\n+\t  node = TREE_OPERAND (node, 0);\n+\t  continue;\n \t  \n \tcase LABELED_BLOCK_EXPR:\n-\t  return find_expr_with_wfl (TREE_OPERAND (node, 1));\n+\t  node = TREE_OPERAND (node, 1);\n+\t  continue;\n+\n \tdefault:\n \t  code = TREE_CODE_CLASS (TREE_CODE (node));\n \t  if (((code == '1') || (code == '2') || (code == 'e'))\n@@ -2684,7 +2688,7 @@ build_array_from_name (type, type_wfl, name, ret_name)\n   /* If we have, then craft a new type for this variable */\n   if (more_dims)\n     {\n-      name = get_identifier (&more_dims [string]);\n+      name = get_identifier (&string [more_dims]);\n \n       /* If we have a pointer, use its type */\n       if (TREE_CODE (type) == POINTER_TYPE)\n@@ -3160,11 +3164,6 @@ register_fields (flags, type, variable_list)\n       if (must_chain)\n \tregister_incomplete_type (JDEP_FIELD, wfl, field_decl, type);\n \t  \n-      /* Default value of a static field is 0 and it is considered\n-\t initialized. */\n-      if (flags & ACC_STATIC)\n-\tINITIALIZED_P (field_decl) = 1;\n-      \n       /* If we have an initialization value tied to the field */\n       if (init)\n \t{\n@@ -3191,7 +3190,6 @@ register_fields (flags, type, variable_list)\n \t      TREE_CHAIN (init) = ctxp->non_static_initialized;\n \t      ctxp->non_static_initialized = init;\n \t    }\n-\t  INITIALIZED_P (field_decl) = 1;\n \t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n \t}\n     }\n@@ -3333,7 +3331,7 @@ method_header (flags, type, mdecl, throws)\n \n   /* Method declared within the scope of an interface are implicitly\n      abstract and public. Conflicts with other erroneously provided\n-     modifiers are check right after. */\n+     modifiers are checked right after. */\n \n   if (CLASS_INTERFACE (TYPE_NAME (this_class)))\n     {\n@@ -5457,7 +5455,6 @@ expand_start_java_method (fndecl)\n       DECL_ARG_TYPE (tem) = type;\n       layout_decl (tem, 0);\n       pushdecl (tem);\n-      INITIALIZED_P (tem) = 1;\t/* Parms are initialized */\n       *ptr = tem;\n       ptr = &TREE_CHAIN (tem);\n       tem = next;\n@@ -7551,7 +7548,6 @@ java_complete_lhs (node)\n \t{\n \t  DECL_CONTEXT (cn) = current_function_decl;\n \t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (cn)) = cn;\n-\t  INITIALIZED_P (cn) = 0;\n \t}\n       if (BLOCK_EXPR_BODY (node) == NULL_TREE)\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n@@ -7935,25 +7931,8 @@ java_complete_lhs (node)\n       else\n \tnn = java_complete_tree (TREE_OPERAND (node, 1));\n \n-      /* There are cases where the type of RHS is fixed. In those\n-\t cases, if the evaluation of the RHS fails, we further the\n-\t evaluation of the assignment to detect more errors. */\n       if (nn == error_mark_node)\n-\t{\n-\t  /* It's hopeless, but we can further things on to discover\n-\t     an error during the assignment. In any cases, the\n-\t     assignment operation fails. */\n-\t  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION\n-\t      && TREE_CODE (TREE_OPERAND (node, 1)) != NEW_ARRAY_INIT\n-\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node)\n-\t    patch_assignment (node, wfl_op1, wfl_op2);\n-\n-\t  /* Now, we still mark the lhs as initialized */\n-\t  if (JDECL_P (TREE_OPERAND (node, 0)))\n-\t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n-\n-\t  return error_mark_node;\n-\t}\n+\treturn error_mark_node;\n       TREE_OPERAND (node, 1) = nn;\n \n       /* In case we're handling = with a String as a RHS, we need to\n@@ -8448,7 +8427,6 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Lhs can be a named variable */\n   if (JDECL_P (lvalue))\n     {\n-      INITIALIZED_P (lvalue) = 1;\n       lhs_type = TREE_TYPE (lvalue);\n     }\n   /* Or Lhs can be a array acccess. Should that be lvalue ? FIXME +\n@@ -9386,13 +9364,13 @@ build_string_concatenation (op1, op2)\n   if ((result = string_constant_concatenation (op1, op2)))\n     return result;\n \n-  /* Discard null constants on either sides of the expression */\n-  if (TREE_CODE (op1) == STRING_CST && !TREE_STRING_LENGTH (op1))\n+  /* Discard empty strings on either side of the expression */\n+  if (TREE_CODE (op1) == STRING_CST && TREE_STRING_LENGTH (op1) == 0)\n     {\n       op1 = op2;\n       op2 = NULL_TREE;\n     }\n-  else if (TREE_CODE (op2) == STRING_CST && !TREE_STRING_LENGTH (op2))\n+  else if (TREE_CODE (op2) == STRING_CST && TREE_STRING_LENGTH (op2) == 0)\n     op2 = NULL_TREE;\n \n   /* If operands are string constant, turn then into object references */"}]}