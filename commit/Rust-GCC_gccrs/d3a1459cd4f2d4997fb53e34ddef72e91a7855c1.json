{"sha": "d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhMTQ1OWNkNGYyZDQ5OTdmYjUzZTM0ZGRlZjcyZTkxYTc4NTVjMQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-05-06T21:01:32Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-05-06T21:01:32Z"}, "message": "i386: Use generic division to generate INEXACT exception\n\nIntroduce math_force_eval_div to use generic division to generate\nINEXACT as well as INVALID and DIVZERO exceptions.\n\nlibgcc/ChangeLog:\n\n\t* config/i386/sfp-exceptions.c (__math_force_eval): Remove.\n\t(__math_force_eval_div): New define.\n\t(__sfp_handle_exceptions): Use __math_force_eval_div to use\n\tgeneric division to generate INVALID, DIVZERO and INEXACT\n\texceptions.\n\nlibatomic/ChangeLog:\n\n\t* config/x86/fenv.c (__math_force_eval): Remove.\n\t(__math_force_eval_div): New define.\n\t(__atomic_deraiseexcept): Use __math_force_eval_div to use\n\tgeneric division to generate INVALID, DIVZERO and INEXACT\n\texceptions.\n\nlibgfortran/ChangeLog:\n\n\t* config/fpu-387.h (__math_force_eval): Remove.\n\t(__math_force_eval_div): New define.\n\t(local_feraiseexcept): Use __math_force_eval_div to use\n\tgeneric division to generate INVALID, DIVZERO and INEXACT\n\texceptions.\n\t(struct fenv): Define named struct instead of typedef.", "tree": {"sha": "7a23bc1474d3f382a9b8e6044e53e5ee7b335347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a23bc1474d3f382a9b8e6044e53e5ee7b335347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc95e478febd35e0d1fb13c1833d2383ad0e7d18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc95e478febd35e0d1fb13c1833d2383ad0e7d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc95e478febd35e0d1fb13c1833d2383ad0e7d18"}], "stats": {"total": 117, "additions": 67, "deletions": 50}, "files": [{"sha": "e8ab8ecb047607643193e9e8be54d579690f798e", "filename": "libatomic/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libatomic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libatomic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FChangeLog?ref=d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "patch": "@@ -1,7 +1,15 @@\n+2020-05-06  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/x86/fenv.c (__math_force_eval): Remove.\n+\t(__math_force_eval_div): New define.\n+\t(__atomic_deraiseexcept): Use __math_force_eval_div to use\n+\tgeneric division to generate INVALID, DIVZERO and INEXACT\n+\texceptions.\n+\n 2020-05-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/x86/fenv.c (__math_force_eval): New define.\n-\t(__atomic_feraiseexcept): Use __math_force_eval to evaluete\n+\t(__atomic_feraiseexcept): Use __math_force_eval to evaluate\n \tgeneric division to generate INVALID and DIVZERO exceptions.\n \n 2020-04-19  Uro\u0161 Bizjak  <ubizjak@gmail.com>"}, {"sha": "88622c613f318c9f304466dae2fb4a6be91da39d", "filename": "libatomic/config/x86/fenv.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libatomic%2Fconfig%2Fx86%2Ffenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libatomic%2Fconfig%2Fx86%2Ffenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fx86%2Ffenv.c?ref=d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "patch": "@@ -48,9 +48,11 @@ struct fenv\n };\n \n #ifdef __SSE_MATH__\n-# define __math_force_eval(x) asm volatile (\"\" : : \"x\" (x));\n+# define __math_force_eval_div(x, y) \\\n+  do { asm (\"\" : \"+x\" (x)); asm volatile (\"\" : : \"x\" (x / y)); } while (0)\n #else\n-# define __math_force_eval(x) asm volatile (\"\" : : \"f\" (x));\n+# define __math_force_eval_div(x, y) \\\n+  do { asm (\"\" : \"+t\" (x)); asm volatile (\"\" : : \"f\" (x / y)); } while (0)\n #endif\n \n /* Raise the supported floating-point exceptions from EXCEPTS.  Other\n@@ -59,14 +61,15 @@ struct fenv\n void\n __atomic_feraiseexcept (int excepts)\n {\n+  struct fenv temp;\n+\n   if (excepts & FE_INVALID)\n     {\n       float f = 0.0f;\n-      __math_force_eval (f / f);\n+      __math_force_eval_div (f, f);\n     }\n   if (excepts & FE_DENORM)\n     {\n-      struct fenv temp;\n       asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= FE_DENORM;\n       asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n@@ -75,19 +78,17 @@ __atomic_feraiseexcept (int excepts)\n   if (excepts & FE_DIVBYZERO)\n     {\n       float f = 1.0f, g = 0.0f;\n-      __math_force_eval (f / g);\n+      __math_force_eval_div (f, g);\n     }\n   if (excepts & FE_OVERFLOW)\n     {\n-      struct fenv temp;\n       asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= FE_OVERFLOW;\n       asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n       asm volatile (\"fwait\");\n     }\n   if (excepts & FE_UNDERFLOW)\n     {\n-      struct fenv temp;\n       asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= FE_UNDERFLOW;\n       asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n@@ -96,11 +97,6 @@ __atomic_feraiseexcept (int excepts)\n   if (excepts & FE_INEXACT)\n     {\n       float f = 1.0f, g = 3.0f;\n-#ifdef __SSE_MATH__\n-      asm volatile (\"%vdivss\\t{%1, %d0|%d0, %1}\" : \"+x\" (f) : \"xm\" (g));\n-#else\n-      asm volatile (\"fdivs\\t%1\" : \"+t\" (f) : \"m\" (g));\n-      /* No need for fwait, exception is triggered by emitted fstp.  */\n-#endif\n+      __math_force_eval_div (f, g);\n     }\n }"}, {"sha": "33e8929f16a9301d9eb2747eefbb98be1f1c8c6e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "patch": "@@ -1,3 +1,11 @@\n+2020-05-06  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/sfp-exceptions.c (__math_force_eval): Remove.\n+\t(__math_force_eval_div): New define.\n+\t(__sfp_handle_exceptions): Use __math_force_eval_div to use\n+\tgeneric division to generate INVALID, DIVZERO and INEXACT\n+\texceptions.\n+\n 2020-05-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/lse-init.c (init_have_lse_atomics): Use __getauxval\n@@ -54,7 +62,7 @@\n 2020-05-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sfp-exceptions.c (__math_force_eval): New define.\n-\t(__sfp_handle_exceptions): Use __math_force_eval to evaluete\n+\t(__sfp_handle_exceptions): Use __math_force_eval to evaluate\n \tgeneric division to generate INVALID and DIVZERO exceptions.\n \n 2020-04-27  Sebastian Huber  <sebastian.huber@embedded-brains.de>"}, {"sha": "72cb0f4d3bb3bc5cbc2b960aeea25101f3f1ed14", "filename": "libgcc/config/i386/sfp-exceptions.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgcc%2Fconfig%2Fi386%2Fsfp-exceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgcc%2Fconfig%2Fi386%2Fsfp-exceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fsfp-exceptions.c?ref=d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "patch": "@@ -42,22 +42,25 @@ struct fenv\n };\n \n #ifdef __SSE_MATH__\n-# define __math_force_eval(x) asm volatile (\"\" : : \"x\" (x));\n+# define __math_force_eval_div(x, y) \\\n+  do { asm (\"\" : \"+x\" (x)); asm volatile (\"\" : : \"x\" (x / y)); } while (0)\n #else\n-# define __math_force_eval(x) asm volatile (\"\" : : \"f\" (x));\n+# define __math_force_eval_div(x, y) \\\n+  do { asm (\"\" : \"+t\" (x)); asm volatile (\"\" : : \"f\" (x / y)); } while (0)\n #endif\n \n void\n __sfp_handle_exceptions (int _fex)\n {\n+  struct fenv temp;\n+\n   if (_fex & FP_EX_INVALID)\n     {\n       float f = 0.0f;\n-      __math_force_eval (f / f);\n+      __math_force_eval_div (f, f);\n     }\n   if (_fex & FP_EX_DENORM)\n     {\n-      struct fenv temp;\n       asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= FP_EX_DENORM;\n       asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n@@ -66,19 +69,17 @@ __sfp_handle_exceptions (int _fex)\n   if (_fex & FP_EX_DIVZERO)\n     {\n       float f = 1.0f, g = 0.0f;\n-      __math_force_eval (f / g);\n+      __math_force_eval_div (f, g);\n     }\n   if (_fex & FP_EX_OVERFLOW)\n     {\n-      struct fenv temp;\n       asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= FP_EX_OVERFLOW;\n       asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n       asm volatile (\"fwait\");\n     }\n   if (_fex & FP_EX_UNDERFLOW)\n     {\n-      struct fenv temp;\n       asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= FP_EX_UNDERFLOW;\n       asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n@@ -87,12 +88,7 @@ __sfp_handle_exceptions (int _fex)\n   if (_fex & FP_EX_INEXACT)\n     {\n       float f = 1.0f, g = 3.0f;\n-#ifdef __SSE_MATH__\n-      asm volatile (\"%vdivss\\t{%1, %d0|%d0, %1}\" : \"+x\" (f) : \"xm\" (g));\n-#else\n-      asm volatile (\"fdivs\\t%1\" : \"+t\" (f) : \"m\" (g));\n-      /* No need for fwait, exception is triggered by emitted fstp.  */\n-#endif\n+      __math_force_eval_div (f, g);\n     }\n }\n #endif"}, {"sha": "94c7e0f105da0c348281bd9891802d427e3bcf15", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "patch": "@@ -1,7 +1,16 @@\n+2020-05-06  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/fpu-387.h (__math_force_eval): Remove.\n+\t(__math_force_eval_div): New define.\n+\t(local_feraiseexcept): Use __math_force_eval_div to use\n+\tgeneric division to generate INVALID, DIVZERO and INEXACT\n+\texceptions.\n+\t(struct fenv): Define named struct instead of typedef.\n+\n 2020-05-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/fpu-387.h (__math_force_eval): New define.\n-\t(local_feraiseexcept): Use __math_force_eval to evaluete\n+\t(local_feraiseexcept): Use __math_force_eval to evaluate\n \tgeneric division to generate INVALID and DIVZERO exceptions.\n \n 2020-04-22  Fritz Reese  <foreese@gcc.gnu.org>"}, {"sha": "8b5e758c2caa0b44f39b9baf9ede8117056b6d35", "filename": "libgfortran/config/fpu-387.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgfortran%2Fconfig%2Ffpu-387.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a1459cd4f2d4997fb53e34ddef72e91a7855c1/libgfortran%2Fconfig%2Ffpu-387.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-387.h?ref=d3a1459cd4f2d4997fb53e34ddef72e91a7855c1", "patch": "@@ -69,7 +69,7 @@ has_sse (void)\n \n /* This structure corresponds to the layout of the block\n    written by FSTENV.  */\n-typedef struct\n+struct fenv\n {\n   unsigned short int __control_word;\n   unsigned short int __unused1;\n@@ -79,22 +79,28 @@ typedef struct\n   unsigned short int __unused3;\n   unsigned int __eip;\n   unsigned short int __cs_selector;\n-  unsigned short int __opcode;\n+  unsigned int __opcode:11;\n+  unsigned int __unused4:5;\n   unsigned int __data_offset;\n   unsigned short int __data_selector;\n   unsigned short int __unused5;\n   unsigned int __mxcsr;\n-}\n-my_fenv_t;\n+};\n \n /* Check we can actually store the FPU state in the allocated size.  */\n-_Static_assert (sizeof(my_fenv_t) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE,\n+_Static_assert (sizeof(struct fenv) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE,\n \t\t\"GFC_FPE_STATE_BUFFER_SIZE is too small\");\n \n #ifdef __SSE_MATH__\n-# define __math_force_eval(x) __asm__ __volatile__ (\"\" : : \"x\" (x));\n+# define __math_force_eval_div(x, y)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    __asm__ (\"\" : \"+x\" (x)); __asm__ __volatile__ (\"\" : : \"x\" (x / y));\t\\\n+  } while (0)\n #else\n-# define __math_force_eval(x) __asm__ __volatile__ (\"\" : : \"f\" (x));\n+# define __math_force_eval_div(x, y)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    __asm__ (\"\" : \"+t\" (x)); __asm__ __volatile__ (\"\" : : \"f\" (x / y));\t\\\n+  } while (0)\n #endif\n \n /* Raise the supported floating-point exceptions from EXCEPTS.  Other\n@@ -104,14 +110,15 @@ _Static_assert (sizeof(my_fenv_t) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE,\n static void\n local_feraiseexcept (int excepts)\n {\n+  struct fenv temp;\n+\n   if (excepts & _FPU_MASK_IM)\n     {\n       float f = 0.0f;\n-      __math_force_eval (f / f);\n+      __math_force_eval_div (f, f);\n     }\n   if (excepts & _FPU_MASK_DM)\n     {\n-      my_fenv_t temp;\n       __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= _FPU_MASK_DM;\n       __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n@@ -120,19 +127,17 @@ local_feraiseexcept (int excepts)\n   if (excepts & _FPU_MASK_ZM)\n     {\n       float f = 1.0f, g = 0.0f;\n-      __math_force_eval (f / g);\n+      __math_force_eval_div (f, g);\n     }\n   if (excepts & _FPU_MASK_OM)\n     {\n-      my_fenv_t temp;\n       __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= _FPU_MASK_OM;\n       __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n       __asm__ __volatile__ (\"fwait\");\n     }\n   if (excepts & _FPU_MASK_UM)\n     {\n-      my_fenv_t temp;\n       __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (temp));\n       temp.__status_word |= _FPU_MASK_UM;\n       __asm__ __volatile__ (\"fldenv\\t%0\" : : \"m\" (temp));\n@@ -141,12 +146,7 @@ local_feraiseexcept (int excepts)\n   if (excepts & _FPU_MASK_PM)\n     {\n       float f = 1.0f, g = 3.0f;\n-#ifdef __SSE_MATH__\n-      __asm__ __volatile__ (\"%vdivss\\t{%1, %d0|%d0, %1}\" : \"+x\" (f) : \"xm\" (g));\n-#else\n-      __asm__ __volatile__ (\"fdivs\\t%1\" : \"+t\" (f) : \"m\" (g));\n-      /* No need for fwait, exception is triggered by emitted fstp.  */\n-#endif\n+      __math_force_eval_div (f, g);\n     }\n }\n \n@@ -272,7 +272,7 @@ get_fpu_except_flags (void)\n void\n set_fpu_except_flags (int set, int clear)\n {\n-  my_fenv_t temp;\n+  struct fenv temp;\n   int exc_set = 0, exc_clr = 0;\n \n   /* Translate from GFC_PE_* values to _FPU_MASK_* values.  */\n@@ -426,7 +426,7 @@ support_fpu_rounding_mode (int mode __attribute__((unused)))\n void\n get_fpu_state (void *state)\n {\n-  my_fenv_t *envp = state;\n+  struct fenv *envp = state;\n \n   __asm__ __volatile__ (\"fnstenv\\t%0\" : \"=m\" (*envp));\n \n@@ -441,7 +441,7 @@ get_fpu_state (void *state)\n void\n set_fpu_state (void *state)\n {\n-  my_fenv_t *envp = state;\n+  struct fenv *envp = state;\n \n   /* glibc sources (sysdeps/x86_64/fpu/fesetenv.c) do something more\n      complex than this, but I think it suffices in our case.  */"}]}