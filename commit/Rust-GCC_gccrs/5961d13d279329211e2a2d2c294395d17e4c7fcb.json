{"sha": "5961d13d279329211e2a2d2c294395d17e4c7fcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk2MWQxM2QyNzkzMjkyMTFlMmEyZDJjMjk0Mzk1ZDE3ZTRjN2ZjYg==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-09-04T17:39:05Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-09-04T17:39:05Z"}, "message": "ffi.c (ffi_struct_type): Put type declaration on separate line.\n\n\t* src/pa/ffi.c (ffi_struct_type): Put type declaration on separate line.\n\t(ffi_prep_args_pa32): Likewise.\n\t(ffi_size_stack_pa32): Likewise.\n\t(ffi_prep_cif_machdep): Likewise.\n\t(ffi_call): Likewise.  Rename to ffi_call_int.  Add closure argument\n\tand update call to ffi_call_pa32.\n\t(ffi_call, ffi_call_go, ffi_prep_go_closure): New.\n\t(ffi_closure_inner_pa32): Update to handle go closures.\n\t* src/pa/ffitarget.h (FFI_GO_CLOSURES): Define.\n\t* src/pa/hpux32.S (ffi_call_pa32): Pass go closure argument in static\n\tchain register (%ret1).\n\t(ffi_closure_pa32): Set closure type argument to zero.\n\t(ffi_go_closure_pa32): New function.  Add unwind data for it.\n\t* src/pa/linux.S: Likewise.  Use cfi directives for unwind data.\n\t* testsuite/libffi.go/static-chain.h (STATIC_CHAIN_REG): Define for\n\thppa.\n\nFrom-SVN: r239978", "tree": {"sha": "76f94005b2db4feb8e825883b98b4bc9e47b3d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76f94005b2db4feb8e825883b98b4bc9e47b3d69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5961d13d279329211e2a2d2c294395d17e4c7fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5961d13d279329211e2a2d2c294395d17e4c7fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5961d13d279329211e2a2d2c294395d17e4c7fcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5961d13d279329211e2a2d2c294395d17e4c7fcb/comments", "author": null, "committer": null, "parents": [{"sha": "d6598cf719fb63ead5618cf8908218519e82cc3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6598cf719fb63ead5618cf8908218519e82cc3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6598cf719fb63ead5618cf8908218519e82cc3e"}], "stats": {"total": 317, "additions": 224, "deletions": 93}, "files": [{"sha": "4b16fb0b31fdb6d641a02ff86ab6cd638ae4773a", "filename": "libffi/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=5961d13d279329211e2a2d2c294395d17e4c7fcb", "patch": "@@ -1,3 +1,22 @@\n+2016-09-04  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* src/pa/ffi.c (ffi_struct_type): Put type declaration on separate line.\n+\t(ffi_prep_args_pa32): Likewise.\n+\t(ffi_size_stack_pa32): Likewise.\n+\t(ffi_prep_cif_machdep): Likewise.\n+\t(ffi_call): Likewise.  Rename to ffi_call_int.  Add closure argument\n+\tand update call to ffi_call_pa32.\n+\t(ffi_call, ffi_call_go, ffi_prep_go_closure): New.\n+\t(ffi_closure_inner_pa32): Update to handle go closures.\n+\t* src/pa/ffitarget.h (FFI_GO_CLOSURES): Define.\n+\t* src/pa/hpux32.S (ffi_call_pa32): Pass go closure argument in static\n+\tchain register (%ret1).\n+\t(ffi_closure_pa32): Set closure type argument to zero.\n+\t(ffi_go_closure_pa32): New function.  Add unwind data for it.\n+\t* src/pa/linux.S: Likewise.  Use cfi directives for unwind data.\n+\t* testsuite/libffi.go/static-chain.h (STATIC_CHAIN_REG): Define for\n+\thppa.\n+\n 2016-05-23  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR libffi/65567"}, {"sha": "0da81849deefdfa5ab2d579c45df5fdf5b8df409", "filename": "libffi/src/pa/ffi.c", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=5961d13d279329211e2a2d2c294395d17e4c7fcb", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - (c) 2011 Anthony Green\n+   ffi.c - (c) 2016 John David Anglin\n+\t   (c) 2011 Anthony Green\n            (c) 2008 Red Hat, Inc.\n \t   (c) 2006 Free Software Foundation, Inc.\n            (c) 2003-2004 Randolph Chung <tausq@debian.org>\n@@ -51,7 +52,8 @@\n \n #define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)\n \n-static inline int ffi_struct_type(ffi_type *t)\n+static inline int\n+ffi_struct_type (ffi_type *t)\n {\n   size_t sz = t->size;\n \n@@ -139,7 +141,8 @@ static inline int ffi_struct_type(ffi_type *t)\n    NOTE: We load floating point args in this function... that means we\n    assume gcc will not mess with fp regs in here.  */\n \n-void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n+void\n+ffi_prep_args_pa32 (UINT32 *stack, extended_cif *ecif, unsigned bytes)\n {\n   register unsigned int i;\n   register ffi_type **p_arg;\n@@ -275,7 +278,8 @@ void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n   return;\n }\n \n-static void ffi_size_stack_pa32(ffi_cif *cif)\n+static void\n+ffi_size_stack_pa32 (ffi_cif *cif)\n {\n   ffi_type **ptr;\n   int i;\n@@ -316,7 +320,8 @@ static void ffi_size_stack_pa32(ffi_cif *cif)\n }\n \n /* Perform machine dependent cif processing.  */\n-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n {\n   /* Set the return type flag */\n   switch (cif->rtype->type)\n@@ -369,11 +374,13 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-extern void ffi_call_pa32(void (*)(UINT32 *, extended_cif *, unsigned),\n-\t\t\t  extended_cif *, unsigned, unsigned, unsigned *,\n-\t\t\t  void (*fn)(void));\n+extern void ffi_call_pa32 (void (*)(UINT32 *, extended_cif *, unsigned),\n+\t\t\t   extended_cif *, unsigned, unsigned, unsigned *,\n+\t\t\t   void (*fn)(void), void *closure);\n \n-void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+static void\n+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue,\n+\t      void *closure)\n {\n   extended_cif ecif;\n \n@@ -401,8 +408,8 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     {\n     case FFI_PA32:\n       debug(3, \"Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\\n\", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);\n-      ffi_call_pa32(ffi_prep_args_pa32, &ecif, cif->bytes,\n-\t\t     cif->flags, ecif.rvalue, fn);\n+      ffi_call_pa32 (ffi_prep_args_pa32, &ecif, cif->bytes,\n+\t\t     cif->flags, ecif.rvalue, fn, closure);\n       break;\n \n     default:\n@@ -411,14 +418,30 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n }\n \n+void\n+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n+}\n+\n+void\n+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue,\n+\t     void *closure)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, closure);\n+}\n+\n #if FFI_CLOSURES\n /* This is more-or-less an inverse of ffi_call -- we have arguments on\n    the stack, and we need to fill them into a cif structure and invoke\n    the user function. This really ought to be in asm to make sure\n    the compiler doesn't do things we don't expect.  */\n-ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n+ffi_status\n+ffi_closure_inner_pa32 (void *closure, UINT32 *stack, int closure_type)\n {\n   ffi_cif *cif;\n+  void (*fun)(ffi_cif *,void *,void **,void *); \n+  void *user_data;\n   void **avalue;\n   void *rvalue;\n   UINT32 ret[2]; /* function can return up to 64-bits in registers */\n@@ -428,15 +451,27 @@ ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n   unsigned int slot = FIRST_ARG_SLOT;\n   register UINT32 r28 asm(\"r28\");\n \n-  cif = closure->cif;\n+  /* A non-zero closure type indicates a go closure.  */\n+  if (closure_type)\n+    {\n+      cif = ((ffi_go_closure *)closure)->cif;\n+      fun = ((ffi_go_closure *)closure)->fun;\n+      user_data = closure;\n+    }\n+  else\n+    {\n+      cif = ((ffi_closure *)closure)->cif;\n+      fun = ((ffi_closure *)closure)->fun;\n+      user_data = ((ffi_closure *)closure)->user_data;\n+    }\n \n   /* If returning via structure, callee will write to our pointer.  */\n   if (cif->flags == FFI_TYPE_STRUCT)\n     rvalue = (void *)r28;\n   else\n     rvalue = &ret[0];\n \n-  avalue = (void **)alloca(cif->nargs * FFI_SIZEOF_ARG);\n+  avalue = (void **) alloca (cif->nargs * FFI_SIZEOF_ARG);\n   avn = cif->nargs;\n   p_arg = cif->arg_types;\n \n@@ -529,7 +564,7 @@ ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n     }\n \n   /* Invoke the closure.  */\n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+  fun (cif, rvalue, avalue, user_data);\n \n   debug(3, \"after calling function, ret[0] = %08x, ret[1] = %08x\\n\", ret[0],\n \tret[1]);\n@@ -621,6 +656,7 @@ ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n    cif specifies the argument and result types for fun.\n    The cif must already be prep'ed.  */\n \n+extern void ffi_go_closure_pa32(void);\n extern void ffi_closure_pa32(void);\n \n ffi_status\n@@ -716,4 +752,21 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n   return FFI_OK;\n }\n+\n+#ifdef FFI_GO_CLOSURES\n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure *closure,\n+\t\t     ffi_cif *cif,\n+\t\t     void (*fun)(ffi_cif *, void *, void **, void *))\n+{\n+  if (cif->abi != FFI_PA32)\n+    return FFI_BAD_ABI;\n+\n+  closure->tramp = &ffi_go_closure_pa32;\n+  closure->cif = cif;\n+  closure->fun = fun;\n+\n+  return FFI_OK;\n+}\n+#endif /* FFI_GO_CLOSURES */\n #endif"}, {"sha": "024ac81a8073b0c3bfa822f4a5e7998f482f50e7", "filename": "libffi/src/pa/ffitarget.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffitarget.h?ref=5961d13d279329211e2a2d2c294395d17e4c7fcb", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 2012  Anthony Green\n+   ffitarget.h - Copyright (c) 2016  John David Anglin\n+\t\t Copyright (c) 2012  Anthony Green\n                  Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for hppa.\n \n@@ -67,6 +68,7 @@ typedef enum ffi_abi {\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n+#define FFI_GO_CLOSURES 1\n #define FFI_NATIVE_RAW_API 0\n \n #ifdef PA_LINUX"}, {"sha": "4a47da3791a96d486efaa51aab2189adfb09d4f8", "filename": "libffi/src/pa/hpux32.S", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Fhpux32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Fhpux32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fhpux32.S?ref=5961d13d279329211e2a2d2c294395d17e4c7fcb", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n    hpux32.S - Copyright (c) 2006 Free Software Foundation, Inc.\n \t                (c) 2008 Red Hat, Inc.\n+\t\t\t(c) 2016 John David Anglin\n    based on src/pa/linux.S\n \n    HP-UX PA Foreign Function Interface\n@@ -41,7 +42,8 @@\n \t\t\t       unsigned bytes,\n \t\t\t       unsigned flags,\n \t\t\t       unsigned *rvalue,\n-\t\t\t       void (*fn)(void));\n+\t\t\t       void (*fn)(void),\n+\t\t\t       ffi_go_closure *closure);\n \t */\n \n \t.export\tffi_call_pa32,ENTRY,PRIV_LEV=3\n@@ -104,6 +106,7 @@ L$CFI13\n \t   we need to give it a place to put the result.  */\n \tldw\t-52(%r3), %ret0\t\t; %ret0 <- rvalue\n \tldw\t-56(%r3), %r22\t\t; %r22 <- function to call\n+\tldw\t-60(%r3), %ret1\t\t; %ret1 <- closure\n \tbl\t$$dyncall, %r31\t\t; Call the user function\n \tcopy\t%r31, %rp\n \n@@ -285,7 +288,9 @@ L$CFI22\n \tstw\t%arg2, -44(%r3)\n \tstw\t%arg3, -48(%r3)\n \n+\t/* Closure type 0.  */\n \tcopy\t%r21, %arg0\n+\tcopy\t%r0, %arg2\n \tbl\tffi_closure_inner_pa32, %r2\n \tcopy    %r3, %arg1\n \tldwm\t-64(%sp), %r3\n@@ -297,6 +302,47 @@ L$CFI22\n \t.procend\n L$FE2:\n \n+\t/* void ffi_go_closure_pa32(void);\n+\t   Called with closure argument in %ret1 */\n+\n+\t.SPACE $TEXT$\n+\t.SUBSPA $CODE$\n+\t.export ffi_go_closure_pa32,ENTRY,PRIV_LEV=3,RTNVAL=GR\n+\t.import ffi_closure_inner_pa32,CODE\n+\t.align 4\n+L$FB3\n+ffi_go_closure_pa32\n+\t.proc\n+\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n+\t.entry\n+\n+\tstw\t%rp, -20(%sp)\n+\tcopy\t%r3, %r1\n+L$CFI31\n+\tcopy\t%sp, %r3\n+L$CFI32\n+\tstwm\t%r1, 64(%sp)\n+\n+\t/* Put arguments onto the stack and call ffi_closure_inner.  */\n+\tstw\t%arg0, -36(%r3)\n+\tstw\t%arg1, -40(%r3)\n+\tstw\t%arg2, -44(%r3)\n+\tstw\t%arg3, -48(%r3)\n+\n+\t/* Closure type 1.  */\n+\tcopy\t%ret1, %arg0\n+\tldi\t1, %arg2\n+\tbl\tffi_closure_inner_pa32, %r2\n+\tcopy    %r3, %arg1\n+\tldwm\t-64(%sp), %r3\n+\tldw\t-20(%sp), %rp\n+\tldw\t-36(%sp), %ret0\n+\tbv\t%r0(%rp)\n+\tldw\t-40(%sp), %ret1\n+\t.exit\n+\t.procend\n+L$FE3:\n+\n \t.SPACE $PRIVATE$\n \t.SUBSPA $DATA$\n \n@@ -366,3 +412,25 @@ L$ASFDE2:\n \n \t.align 4\n L$EFDE2:\n+\n+L$SFDE3:\n+\t.word   L$EFDE3-L$ASFDE3        ;# FDE Length\n+L$ASFDE3:\n+\t.word   L$ASFDE3-L$frame1       ;# FDE CIE offset\n+\t.word   L$FB3   ;# FDE initial location\n+\t.word   L$FE3-L$FB3     ;# FDE address range\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI31-L$FB3\n+\t.byte   0x83    ;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI32-L$CFI31\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n+\n+\t.align 4\n+L$EFDE3:"}, {"sha": "602690432c046214fa003a40bbc034a20952d8d6", "filename": "libffi/src/pa/linux.S", "status": "modified", "additions": 59, "deletions": 76, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Flinux.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Fsrc%2Fpa%2Flinux.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Flinux.S?ref=5961d13d279329211e2a2d2c294395d17e4c7fcb", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n    linux.S - (c) 2003-2004 Randolph Chung <tausq@debian.org>\n \t     (c) 2008 Red Hat, Inc.\n+\t     (c) 2016 John David Anglin\n \n    HPPA Foreign Function Interface\n \n@@ -37,24 +38,26 @@\n \t\t\t       unsigned bytes,\n \t\t\t       unsigned flags,\n \t\t\t       unsigned *rvalue,\n-\t\t\t       void (*fn)(void));\n+\t\t\t       void (*fn)(void),\n+\t\t\t       ffi_go_closure *closure);\n \t */\n \n \t.export ffi_call_pa32,code\n \t.import ffi_prep_args_pa32,code\n \n \t.type ffi_call_pa32, @function\n-.LFB1:\n+\t.cfi_startproc\n ffi_call_pa32:\n \t.proc\n \t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4\n \t.entry\n \tstw %rp, -20(%sp)\n \tcopy %r3, %r1\n-.LCFI11:\n+        .cfi_offset 2, -20\n+        .cfi_register 3, 1\n \n \tcopy %sp, %r3\n-.LCFI12:\n+\t.cfi_def_cfa_register 3\n \n \t/* Setup the stack for calling prep_args...\n \t   We want the stack to look like this:\n@@ -70,8 +73,8 @@ ffi_call_pa32:\n \t */\n \n \tstwm %r1, 64(%sp)\n+\t.cfi_offset 3, 0\n \tstw %r4, 12(%r3)\n-.LCFI13:\n \tcopy %sp, %r4\n \n \taddl %arg2, %r4, %arg0      /* arg stack */\n@@ -98,6 +101,7 @@ ffi_call_pa32:\n \t   we need to give it a place to put the result.  */\n \tldw -52(%r3), %ret0                     /* %ret0 <- rvalue */\n \tldw -56(%r3), %r22                      /* %r22 <- function to call */\n+\tldw -60(%r3), %ret1                     /* %ret1 <- closure */\n \tbl $$dyncall, %r31                      /* Call the user function */\n \tcopy %r31, %rp\n \n@@ -249,35 +253,37 @@ ffi_call_pa32:\n \tnop\n \t.exit\n \t.procend\n-.LFE1:\n+\t.cfi_endproc\n \n \t/* void ffi_closure_pa32(void);\n-\t   Called with closure argument in %r21 */\n+\t   Called with ffi_closure argument in %r21.  */\n \t.export ffi_closure_pa32,code\n \t.import ffi_closure_inner_pa32,code\n-\n \t.type ffi_closure_pa32, @function\n-.LFB2:\n+\t.cfi_startproc\n ffi_closure_pa32:\n \t.proc\n \t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n \t.entry\n \n \tstw %rp, -20(%sp)\n-.LCFI20:\n \tcopy %r3, %r1\n-.LCFI21:\n+\t.cfi_offset 2, -20\n+\t.cfi_register 3, 1\n \tcopy %sp, %r3\n-.LCFI22:\n+\t.cfi_def_cfa_register 3\n \tstwm %r1, 64(%sp)\n+\t.cfi_offset 3, 0\n \n \t/* Put arguments onto the stack and call ffi_closure_inner.  */\n \tstw %arg0, -36(%r3)\n \tstw %arg1, -40(%r3)\n \tstw %arg2, -44(%r3)\n \tstw %arg3, -48(%r3)\n \n+\t/* Closure type 0.  */\n \tcopy %r21, %arg0\n+\tcopy %r0, %arg2\n \tbl ffi_closure_inner_pa32, %r2\n \tcopy %r3, %arg1\n \n@@ -289,69 +295,46 @@ ffi_closure_pa32:\n \n \t.exit\n \t.procend\n-.LFE2:\n-\n-\t.section        \".eh_frame\",EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.word   .LECIE1-.LSCIE1 ;# Length of Common Information Entry\n-.LSCIE1:\n-\t.word   0x0     ;# CIE Identifier Tag\n-\t.byte   0x1     ;# CIE Version\n-\t.ascii \"\\0\"     ;# CIE Augmentation\n-\t.uleb128 0x1    ;# CIE Code Alignment Factor\n-\t.sleb128 4      ;# CIE Data Alignment Factor\n-\t.byte   0x2     ;# CIE RA Column\n-\t.byte   0xc     ;# DW_CFA_def_cfa\n-\t.uleb128 0x1e\n-\t.uleb128 0x0\n-\t.align 4\n-.LECIE1:\n-.LSFDE1:\n-\t.word   .LEFDE1-.LASFDE1        ;# FDE Length\n-.LASFDE1:\n-\t.word   .LASFDE1-.Lframe1       ;# FDE CIE offset\n-\t.word   .LFB1   ;# FDE initial location\n-\t.word   .LFE1-.LFB1     ;# FDE address range\n-\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   .LCFI11-.LFB1\n-\t.byte\t0x83\t;# DW_CFA_offset, column 0x3\n-\t.uleb128 0x0\n-\t.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]\n-\t.uleb128 0x2\n-\t.sleb128 -5\n-\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   .LCFI12-.LCFI11\n-\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n-\t.uleb128 0x3\n-\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   .LCFI13-.LCFI12\n-\t.byte\t0x84\t;# DW_CFA_offset, column 0x4\n-\t.uleb128 0x3\n+\t.cfi_endproc\n \n-\t.align 4\n-.LEFDE1:\n-\n-.LSFDE2:\n-\t.word   .LEFDE2-.LASFDE2        ;# FDE Length\n-.LASFDE2:\n-\t.word   .LASFDE2-.Lframe1       ;# FDE CIE offset\n-\t.word   .LFB2   ;# FDE initial location\n-\t.word   .LFE2-.LFB2     ;# FDE address range\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   .LCFI21-.LFB2\n-\t.byte   0x83    ;# DW_CFA_offset, column 0x3\n-\t.uleb128 0x0\n-\t.byte   0x11    ;# DW_CFA_offset_extended_sf\n-\t.uleb128 0x2\n-\t.sleb128 -5\n-\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   .LCFI22-.LCFI21\n-\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n-\t.uleb128 0x3\n+\t/* void ffi_go_closure_pa32(void);\n+\t   Called with ffi_go_closure argument in %ret1.  */\n+\t.export ffi_go_closure_pa32,code\n+\t.import ffi_closure_inner_pa32,code\n+\t.type ffi_go_closure_pa32, @function\n+\t.cfi_startproc\n+ffi_go_closure_pa32:\n+\t.proc\n+\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n+\t.entry\n \n-\t.align 4\n-.LEFDE2:\n+\tstw %rp, -20(%sp)\n+\tcopy %r3, %r1\n+\t.cfi_offset 2, -20\n+\t.cfi_register 3, 1\n+\tcopy %sp, %r3\n+\t.cfi_def_cfa_register 3\n+\tstwm %r1, 64(%sp)\n+\t.cfi_offset 3, 0\n+\n+\t/* Put arguments onto the stack and call ffi_closure_inner.  */\n+\tstw %arg0, -36(%r3)\n+\tstw %arg1, -40(%r3)\n+\tstw %arg2, -44(%r3)\n+\tstw %arg3, -48(%r3)\n+\n+\t/* Closure type 1.  */\n+\tcopy %ret1, %arg0\n+\tldi 1, %arg2\n+\tbl ffi_closure_inner_pa32, %r2\n+\tcopy %r3, %arg1\n+\n+\tldwm -64(%sp), %r3\n+\tldw -20(%sp), %rp\n+\tldw -36(%sp), %ret0\n+\tbv %r0(%r2)\n+\tldw -40(%sp), %ret1\n+\n+\t.exit\n+\t.procend\n+\t.cfi_endproc"}, {"sha": "e120eea5e75b4a069d85fab1494c9459ddc0190d", "filename": "libffi/testsuite/libffi.go/static-chain.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5961d13d279329211e2a2d2c294395d17e4c7fcb/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h?ref=5961d13d279329211e2a2d2c294395d17e4c7fcb", "patch": "@@ -4,6 +4,12 @@\n # define STATIC_CHAIN_REG  \"$1\"\n #elif defined(__arm__)\n # define STATIC_CHAIN_REG  \"ip\"\n+#elif defined(__hppa__)\n+# if defined(__LP64)\n+#   define define STATIC_CHAIN_REG  \"%r31\"\n+# else\n+#   define define STATIC_CHAIN_REG  \"%r29\"   /* %ret1 */\n+# endif\n #elif defined(__sparc__)\n # if defined(__arch64__) || defined(__sparcv9)\n #  define STATIC_CHAIN_REG \"g5\""}]}