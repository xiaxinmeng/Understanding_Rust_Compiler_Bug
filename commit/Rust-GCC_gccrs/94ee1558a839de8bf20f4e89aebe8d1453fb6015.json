{"sha": "94ee1558a839de8bf20f4e89aebe8d1453fb6015", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlZTE1NThhODM5ZGU4YmYyMGY0ZTg5YWViZThkMTQ1M2ZiNjAxNQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-07-02T12:18:00Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-07-02T12:18:00Z"}, "message": "Abstract a lot of the {PLUS,MINUS}_EXPR code in\nextract_range_from_binary_expr_1 into separate functions.\n\nFrom-SVN: r262306", "tree": {"sha": "6995ce9b8543c001458fb5d8a304acceb98dfa9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6995ce9b8543c001458fb5d8a304acceb98dfa9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94ee1558a839de8bf20f4e89aebe8d1453fb6015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94ee1558a839de8bf20f4e89aebe8d1453fb6015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94ee1558a839de8bf20f4e89aebe8d1453fb6015", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94ee1558a839de8bf20f4e89aebe8d1453fb6015/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9957cf9a9cae15a9559d1d352b9f87486a04f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9957cf9a9cae15a9559d1d352b9f87486a04f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9957cf9a9cae15a9559d1d352b9f87486a04f24"}], "stats": {"total": 441, "additions": 220, "deletions": 221}, "files": [{"sha": "15f2749d49242716fcddb80aed4de1542cda2bee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94ee1558a839de8bf20f4e89aebe8d1453fb6015/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94ee1558a839de8bf20f4e89aebe8d1453fb6015/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94ee1558a839de8bf20f4e89aebe8d1453fb6015", "patch": "@@ -1,3 +1,11 @@\n+2018-07-02  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (extract_range_from_binary_expr_1): Abstract a lot of the\n+\t{PLUS,MINUS}_EXPR code to...\n+\t(adjust_symbolic_bound): ...here,\n+\t(combine_bound): ...here,\n+\t(set_value_range_with_overflow): ...and here.\n+\n 2018-07-02  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* tree-vrp.c (extract_range_from_unary_expr): Abstract ABS_EXPR"}, {"sha": "c966334acbcfe213dc1eb86007cdb44fcb31a255", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 212, "deletions": 221, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94ee1558a839de8bf20f4e89aebe8d1453fb6015/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94ee1558a839de8bf20f4e89aebe8d1453fb6015/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=94ee1558a839de8bf20f4e89aebe8d1453fb6015", "patch": "@@ -1275,6 +1275,196 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n \t\t   wide_int_to_tree (type, max), NULL);\n }\n \n+/* If BOUND will include a symbolic bound, adjust it accordingly,\n+   otherwise leave it as is.\n+\n+   CODE is the original operation that combined the bounds (PLUS_EXPR\n+   or MINUS_EXPR).\n+\n+   TYPE is the type of the original operation.\n+\n+   SYM_OPn is the symbolic for OPn if it has a symbolic.\n+\n+   NEG_OPn is TRUE if the OPn was negated.  */\n+\n+static void\n+adjust_symbolic_bound (tree &bound, enum tree_code code, tree type,\n+\t\t       tree sym_op0, tree sym_op1,\n+\t\t       bool neg_op0, bool neg_op1)\n+{\n+  bool minus_p = (code == MINUS_EXPR);\n+  /* If the result bound is constant, we're done; otherwise, build the\n+     symbolic lower bound.  */\n+  if (sym_op0 == sym_op1)\n+    ;\n+  else if (sym_op0)\n+    bound = build_symbolic_expr (type, sym_op0,\n+\t\t\t\t neg_op0, bound);\n+  else if (sym_op1)\n+    {\n+      /* We may not negate if that might introduce\n+\t undefined overflow.  */\n+      if (!minus_p\n+\t  || neg_op1\n+\t  || TYPE_OVERFLOW_WRAPS (type))\n+\tbound = build_symbolic_expr (type, sym_op1,\n+\t\t\t\t     neg_op1 ^ minus_p, bound);\n+      else\n+\tbound = NULL_TREE;\n+    }\n+}\n+\n+/* Combine OP1 and OP1, which are two parts of a bound, into one wide\n+   int bound according to CODE.  CODE is the operation combining the\n+   bound (either a PLUS_EXPR or a MINUS_EXPR).\n+\n+   TYPE is the type of the combine operation.\n+\n+   WI is the wide int to store the result.\n+\n+   OVF is -1 if an underflow occurred, +1 if an overflow occurred or 0\n+   if over/underflow occurred.  */\n+\n+static void\n+combine_bound (enum tree_code code, wide_int &wi, int &ovf,\n+\t       tree type, tree op0, tree op1)\n+{\n+  bool minus_p = (code == MINUS_EXPR);\n+  const signop sgn = TYPE_SIGN (type);\n+  const unsigned int prec = TYPE_PRECISION (type);\n+\n+  /* Combine the bounds, if any.  */\n+  if (op0 && op1)\n+    {\n+      if (minus_p)\n+\t{\n+\t  wi = wi::to_wide (op0) - wi::to_wide (op1);\n+\n+\t  /* Check for overflow.  */\n+\t  if (wi::cmp (0, wi::to_wide (op1), sgn)\n+\t      != wi::cmp (wi, wi::to_wide (op0), sgn))\n+\t    ovf = wi::cmp (wi::to_wide (op0),\n+\t\t\t   wi::to_wide (op1), sgn);\n+\t}\n+      else\n+\t{\n+\t  wi = wi::to_wide (op0) + wi::to_wide (op1);\n+\n+\t  /* Check for overflow.  */\n+\t  if (wi::cmp (wi::to_wide (op1), 0, sgn)\n+\t      != wi::cmp (wi, wi::to_wide (op0), sgn))\n+\t    ovf = wi::cmp (wi::to_wide (op0), wi, sgn);\n+\t}\n+    }\n+  else if (op0)\n+    wi = wi::to_wide (op0);\n+  else if (op1)\n+    {\n+      if (minus_p)\n+\t{\n+\t  wi = -wi::to_wide (op1);\n+\n+\t  /* Check for overflow.  */\n+\t  if (sgn == SIGNED\n+\t      && wi::neg_p (wi::to_wide (op1))\n+\t      && wi::neg_p (wi))\n+\t    ovf = 1;\n+\t  else if (sgn == UNSIGNED && wi::to_wide (op1) != 0)\n+\t    ovf = -1;\n+\t}\n+      else\n+\twi = wi::to_wide (op1);\n+    }\n+  else\n+    wi = wi::shwi (0, prec);\n+}\n+\n+/* Given a range in [WMIN, WMAX], adjust it for possible overflow and\n+   put the result in VR.\n+\n+   TYPE is the type of the range.\n+\n+   MIN_OVF and MAX_OVF indicate what type of overflow, if any,\n+   occurred while originally calculating WMIN or WMAX.  -1 indicates\n+   underflow.  +1 indicates overflow.  0 indicates neither.  */\n+\n+static void\n+set_value_range_with_overflow (value_range &vr,\n+\t\t\t       tree type,\n+\t\t\t       const wide_int &wmin, const wide_int &wmax,\n+\t\t\t       int min_ovf, int max_ovf)\n+{\n+  const signop sgn = TYPE_SIGN (type);\n+  const unsigned int prec = TYPE_PRECISION (type);\n+  vr.type = VR_RANGE;\n+  vr.equiv = NULL;\n+  if (TYPE_OVERFLOW_WRAPS (type))\n+    {\n+      /* If overflow wraps, truncate the values and adjust the\n+\t range kind and bounds appropriately.  */\n+      wide_int tmin = wide_int::from (wmin, prec, sgn);\n+      wide_int tmax = wide_int::from (wmax, prec, sgn);\n+      if (min_ovf == max_ovf)\n+\t{\n+\t  /* No overflow or both overflow or underflow.  The\n+\t     range kind stays VR_RANGE.  */\n+\t  vr.min = wide_int_to_tree (type, tmin);\n+\t  vr.max = wide_int_to_tree (type, tmax);\n+\t}\n+      else if ((min_ovf == -1 && max_ovf == 0)\n+\t       || (max_ovf == 1 && min_ovf == 0))\n+\t{\n+\t  /* Min underflow or max overflow.  The range kind\n+\t     changes to VR_ANTI_RANGE.  */\n+\t  bool covers = false;\n+\t  wide_int tem = tmin;\n+\t  vr.type = VR_ANTI_RANGE;\n+\t  tmin = tmax + 1;\n+\t  if (wi::cmp (tmin, tmax, sgn) < 0)\n+\t    covers = true;\n+\t  tmax = tem - 1;\n+\t  if (wi::cmp (tmax, tem, sgn) > 0)\n+\t    covers = true;\n+\t  /* If the anti-range would cover nothing, drop to varying.\n+\t     Likewise if the anti-range bounds are outside of the\n+\t     types values.  */\n+\t  if (covers || wi::cmp (tmin, tmax, sgn) > 0)\n+\t    {\n+\t      set_value_range_to_varying (&vr);\n+\t      return;\n+\t    }\n+\t  vr.min = wide_int_to_tree (type, tmin);\n+\t  vr.max = wide_int_to_tree (type, tmax);\n+\t}\n+      else\n+\t{\n+\t  /* Other underflow and/or overflow, drop to VR_VARYING.  */\n+\t  set_value_range_to_varying (&vr);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      /* If overflow does not wrap, saturate to the types min/max\n+\t value.  */\n+      wide_int type_min = wi::min_value (prec, sgn);\n+      wide_int type_max = wi::max_value (prec, sgn);\n+      if (min_ovf == -1)\n+\tvr.min = wide_int_to_tree (type, type_min);\n+      else if (min_ovf == 1)\n+\tvr.min = wide_int_to_tree (type, type_max);\n+      else\n+\tvr.min = wide_int_to_tree (type, wmin);\n+\n+      if (max_ovf == -1)\n+\tvr.max = wide_int_to_tree (type, type_min);\n+      else if (max_ovf == 1)\n+\tvr.max = wide_int_to_tree (type, type_max);\n+      else\n+\tvr.max = wide_int_to_tree (type, wmax);\n+    }\n+}\n+\n /* Extract range information from a binary operation CODE based on\n    the ranges of each of its operands *VR0 and *VR1 with resulting\n    type EXPR_TYPE.  The resulting range is stored in *VR.  */\n@@ -1495,128 +1685,13 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      || (sym_max_op0 == sym_max_op1\n \t\t  && neg_max_op0 == (minus_p ? neg_max_op1 : !neg_max_op1))))\n \t{\n-\t  const signop sgn = TYPE_SIGN (expr_type);\n-\t  const unsigned int prec = TYPE_PRECISION (expr_type);\n-\t  wide_int type_min, type_max, wmin, wmax;\n+\t  wide_int wmin, wmax;\n \t  int min_ovf = 0;\n \t  int max_ovf = 0;\n \n-\t  /* Get the lower and upper bounds of the type.  */\n-\t  if (TYPE_OVERFLOW_WRAPS (expr_type))\n-\t    {\n-\t      type_min = wi::min_value (prec, sgn);\n-\t      type_max = wi::max_value (prec, sgn);\n-\t    }\n-\t  else\n-\t    {\n-\t      type_min = wi::to_wide (vrp_val_min (expr_type));\n-\t      type_max = wi::to_wide (vrp_val_max (expr_type));\n-\t    }\n-\n-\t  /* Combine the lower bounds, if any.  */\n-\t  if (min_op0 && min_op1)\n-\t    {\n-\t      if (minus_p)\n-\t\t{\n-\t\t  wmin = wi::to_wide (min_op0) - wi::to_wide (min_op1);\n-\n-\t\t  /* Check for overflow.  */\n-\t\t  if (wi::cmp (0, wi::to_wide (min_op1), sgn)\n-\t\t      != wi::cmp (wmin, wi::to_wide (min_op0), sgn))\n-\t\t    min_ovf = wi::cmp (wi::to_wide (min_op0),\n-\t\t\t\t       wi::to_wide (min_op1), sgn);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  wmin = wi::to_wide (min_op0) + wi::to_wide (min_op1);\n-\n-\t\t  /* Check for overflow.  */\n-\t\t  if (wi::cmp (wi::to_wide (min_op1), 0, sgn)\n-\t\t      != wi::cmp (wmin, wi::to_wide (min_op0), sgn))\n-\t\t    min_ovf = wi::cmp (wi::to_wide (min_op0), wmin, sgn);\n-\t\t}\n-\t    }\n-\t  else if (min_op0)\n-\t    wmin = wi::to_wide (min_op0);\n-\t  else if (min_op1)\n-\t    {\n-\t      if (minus_p)\n-\t\t{\n-\t\t  wmin = -wi::to_wide (min_op1);\n-\n-\t\t  /* Check for overflow.  */\n-\t\t  if (sgn == SIGNED\n-\t\t      && wi::neg_p (wi::to_wide (min_op1))\n-\t\t      && wi::neg_p (wmin))\n-\t\t    min_ovf = 1;\n-\t\t  else if (sgn == UNSIGNED && wi::to_wide (min_op1) != 0)\n-\t\t    min_ovf = -1;\n-\t\t}\n-\t      else\n-\t\twmin = wi::to_wide (min_op1);\n-\t    }\n-\t  else\n-\t    wmin = wi::shwi (0, prec);\n-\n-\t  /* Combine the upper bounds, if any.  */\n-\t  if (max_op0 && max_op1)\n-\t    {\n-\t      if (minus_p)\n-\t\t{\n-\t\t  wmax = wi::to_wide (max_op0) - wi::to_wide (max_op1);\n-\n-\t\t  /* Check for overflow.  */\n-\t\t  if (wi::cmp (0, wi::to_wide (max_op1), sgn)\n-\t\t      != wi::cmp (wmax, wi::to_wide (max_op0), sgn))\n-\t\t    max_ovf = wi::cmp (wi::to_wide (max_op0),\n-\t\t\t\t       wi::to_wide (max_op1), sgn);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  wmax = wi::to_wide (max_op0) + wi::to_wide (max_op1);\n-\n-\t\t  if (wi::cmp (wi::to_wide (max_op1), 0, sgn)\n-\t\t      != wi::cmp (wmax, wi::to_wide (max_op0), sgn))\n-\t\t    max_ovf = wi::cmp (wi::to_wide (max_op0), wmax, sgn);\n-\t\t}\n-\t    }\n-\t  else if (max_op0)\n-\t    wmax = wi::to_wide (max_op0);\n-\t  else if (max_op1)\n-\t    {\n-\t      if (minus_p)\n-\t\t{\n-\t\t  wmax = -wi::to_wide (max_op1);\n-\n-\t\t  /* Check for overflow.  */\n-\t\t  if (sgn == SIGNED\n-\t\t      && wi::neg_p (wi::to_wide (max_op1))\n-\t\t      && wi::neg_p (wmax))\n-\t\t    max_ovf = 1;\n-\t\t  else if (sgn == UNSIGNED && wi::to_wide (max_op1) != 0)\n-\t\t    max_ovf = -1;\n-\t\t}\n-\t      else\n-\t\twmax = wi::to_wide (max_op1);\n-\t    }\n-\t  else\n-\t    wmax = wi::shwi (0, prec);\n-\n-\t  /* Check for type overflow.  */\n-\t  if (min_ovf == 0)\n-\t    {\n-\t      if (wi::cmp (wmin, type_min, sgn) == -1)\n-\t\tmin_ovf = -1;\n-\t      else if (wi::cmp (wmin, type_max, sgn) == 1)\n-\t\tmin_ovf = 1;\n-\t    }\n-\t  if (max_ovf == 0)\n-\t    {\n-\t      if (wi::cmp (wmax, type_min, sgn) == -1)\n-\t\tmax_ovf = -1;\n-\t      else if (wi::cmp (wmax, type_max, sgn) == 1)\n-\t\tmax_ovf = 1;\n-\t    }\n+\t  /* Build the bounds.  */\n+\t  combine_bound (code, wmin, min_ovf, expr_type, min_op0, min_op1);\n+\t  combine_bound (code, wmax, max_ovf, expr_type, max_op0, max_op1);\n \n \t  /* If we have overflow for the constant part and the resulting\n \t     range will be symbolic, drop to VR_VARYING.  */\n@@ -1627,108 +1702,24 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      return;\n \t    }\n \n-\t  if (TYPE_OVERFLOW_WRAPS (expr_type))\n-\t    {\n-\t      /* If overflow wraps, truncate the values and adjust the\n-\t\t range kind and bounds appropriately.  */\n-\t      wide_int tmin = wide_int::from (wmin, prec, sgn);\n-\t      wide_int tmax = wide_int::from (wmax, prec, sgn);\n-\t      if (min_ovf == max_ovf)\n-\t\t{\n-\t\t  /* No overflow or both overflow or underflow.  The\n-\t\t     range kind stays VR_RANGE.  */\n-\t\t  min = wide_int_to_tree (expr_type, tmin);\n-\t\t  max = wide_int_to_tree (expr_type, tmax);\n-\t\t}\n-\t      else if ((min_ovf == -1 && max_ovf == 0)\n-\t\t       || (max_ovf == 1 && min_ovf == 0))\n-\t\t{\n-\t\t  /* Min underflow or max overflow.  The range kind\n-\t\t     changes to VR_ANTI_RANGE.  */\n-\t\t  bool covers = false;\n-\t\t  wide_int tem = tmin;\n-\t\t  type = VR_ANTI_RANGE;\n-\t\t  tmin = tmax + 1;\n-\t\t  if (wi::cmp (tmin, tmax, sgn) < 0)\n-\t\t    covers = true;\n-\t\t  tmax = tem - 1;\n-\t\t  if (wi::cmp (tmax, tem, sgn) > 0)\n-\t\t    covers = true;\n-\t\t  /* If the anti-range would cover nothing, drop to varying.\n-\t\t     Likewise if the anti-range bounds are outside of the\n-\t\t     types values.  */\n-\t\t  if (covers || wi::cmp (tmin, tmax, sgn) > 0)\n-\t\t    {\n-\t\t      set_value_range_to_varying (vr);\n-\t\t      return;\n-\t\t    }\n-\t\t  min = wide_int_to_tree (expr_type, tmin);\n-\t\t  max = wide_int_to_tree (expr_type, tmax);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Other underflow and/or overflow, drop to VR_VARYING.  */\n-\t\t  set_value_range_to_varying (vr);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If overflow does not wrap, saturate to the types min/max\n-\t         value.  */\n-\t      if (min_ovf == -1)\n-\t\tmin = wide_int_to_tree (expr_type, type_min);\n-\t      else if (min_ovf == 1)\n-\t\tmin = wide_int_to_tree (expr_type, type_max);\n-\t      else\n-\t\tmin = wide_int_to_tree (expr_type, wmin);\n-\n-\t      if (max_ovf == -1)\n-\t\tmax = wide_int_to_tree (expr_type, type_min);\n-\t      else if (max_ovf == 1)\n-\t\tmax = wide_int_to_tree (expr_type, type_max);\n-\t      else\n-\t\tmax = wide_int_to_tree (expr_type, wmax);\n-\t    }\n-\n-\t  /* If the result lower bound is constant, we're done;\n-\t     otherwise, build the symbolic lower bound.  */\n-\t  if (sym_min_op0 == sym_min_op1)\n-\t    ;\n-\t  else if (sym_min_op0)\n-\t    min = build_symbolic_expr (expr_type, sym_min_op0,\n-\t\t\t\t       neg_min_op0, min);\n-\t  else if (sym_min_op1)\n-\t    {\n-\t      /* We may not negate if that might introduce\n-\t\t undefined overflow.  */\n-\t      if (! minus_p\n-\t\t  || neg_min_op1\n-\t\t  || TYPE_OVERFLOW_WRAPS (expr_type))\n-\t\tmin = build_symbolic_expr (expr_type, sym_min_op1,\n-\t\t\t\t\t   neg_min_op1 ^ minus_p, min);\n-\t      else\n-\t\tmin = NULL_TREE;\n-\t    }\n-\n-\t  /* Likewise for the upper bound.  */\n-\t  if (sym_max_op0 == sym_max_op1)\n-\t    ;\n-\t  else if (sym_max_op0)\n-\t    max = build_symbolic_expr (expr_type, sym_max_op0,\n-\t\t\t\t       neg_max_op0, max);\n-\t  else if (sym_max_op1)\n-\t    {\n-\t      /* We may not negate if that might introduce\n-\t\t undefined overflow.  */\n-\t      if (! minus_p\n-\t\t  || neg_max_op1\n-\t\t  || TYPE_OVERFLOW_WRAPS (expr_type))\n-\t\tmax = build_symbolic_expr (expr_type, sym_max_op1,\n-\t\t\t\t\t   neg_max_op1 ^ minus_p, max);\n-\t      else\n-\t\tmax = NULL_TREE;\n-\t    }\n+\t  /* Adjust the range for possible overflow.  */\n+\t  set_value_range_with_overflow (*vr, expr_type,\n+\t\t\t\t\t wmin, wmax, min_ovf, max_ovf);\n+\t  if (vr->type == VR_VARYING)\n+\t    return;\n+\n+\t  /* Build the symbolic bounds if needed.  */\n+\t  adjust_symbolic_bound (vr->min, code, expr_type,\n+\t\t\t\t sym_min_op0, sym_min_op1,\n+\t\t\t\t neg_min_op0, neg_min_op1);\n+\t  adjust_symbolic_bound (vr->max, code, expr_type,\n+\t\t\t\t sym_max_op0, sym_max_op1,\n+\t\t\t\t neg_max_op0, neg_max_op1);\n+\t  /* ?? It would probably be cleaner to eliminate min/max/type\n+\t     entirely and hold these values in VR directly.  */\n+\t  min = vr->min;\n+\t  max = vr->max;\n+\t  type = vr->type;\n \t}\n       else\n \t{"}]}