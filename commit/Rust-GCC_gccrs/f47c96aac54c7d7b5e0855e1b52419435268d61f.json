{"sha": "f47c96aac54c7d7b5e0855e1b52419435268d61f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ3Yzk2YWFjNTRjN2Q3YjVlMDg1NWUxYjUyNDE5NDM1MjY4ZDYxZg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2005-05-03T12:19:56Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2005-05-03T12:19:56Z"}, "message": "lambda-code.c (gcc_loop_to_lambda_loop, [...]): Use generic operand interface.\n\n\n2005-05-03  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* lambda-code.c (gcc_loop_to_lambda_loop,\n\tlambda_loopnest_to_gcc_loopnest, phi_loop_edge_uses_def,\n\tstmt_is_bumper_for_loop, perfect_nest_p, replace_uses_of_x_with_y): Use\n\tgeneric operand interface.\n\t* tree-data-ref.c (find_data_references_in_loop): Use generic interface.\n\t* tree-dfa.c (collect_dfa_stats_r, mark_new_vars_to_rename): Use\n\tgeneric operand interface.\n\t* tree-flow-inline.h (delink_imm_use, link_imm_use_to_list,\n\tlink_imm_use, link_imm_use_stmt, relink_imm_use, relink_imm_use_stmt,\n\tnext_safe_imm_use, has_zero_uses, has_single_use, single_imm_use,\n\tnum_imm_uses): Use ssa_use_operand_t.\n\t(get_def_ops, get_use_ops, get_v_may_def_ops, get_vuse_ops,\n\tget_v_must_def_ops): Delete.\n\t(get_def_from_ptr, get_phi_result_ptr): Get def directly now.\n\t(get_use_op_ptr, get_def_op_ptr, get_v_may_def_result_ptr,\n\tget_v_may_def_op_ptr, get_vuse_op_ptr, get_v_must_def_result_ptr,\n\tget_v_must_def_kill_ptr): Delete.\n\t(delink_stmt_imm_use): Move and use new operand interface.\n\t(op_iter_next_use, op_iter_next_def, op_iter_next_tree, op_iter_init,\n\top_iter_next_tree): Use new operand implementation.\n\t(clear_and_done_ssa_iter): New.  Initialize a blank operand iterator.\n\t(op_iter_init_use, op_iter_init_def, op_iter_init_tree): Add iterator\n\ttype check.\n\t(op_iter_next_mustdef, op_iter_next_maydef,\n\top_iter_next_must_and_may_def): Delete. Replace with...\n\t(op_iter_next_maymustdef): New.  Combine must and may next operations.\n\t(op_iter_init_maydef, op_iter_init_mustdef,\n\top_iter_init_must_and_may_def): Use new interface.\n\t(single_ssa_tree_operand ): New.  Process single operands only as trees.\n\t(single_ssa_use_operand): New.  Process single operands only as uses.\n\t(single_ssa_def_operand): New.  Process single operands only as defs.\n\t(zero_ssa_operands): New.  Return TRUE if there are zero operands of the\n\tspecified types.\n\t(num_ssa_operands): New.  Count the number of specified operands.\n\t(compare_ssa_operands_equal): New.  Compare two statements' operands.\n\t(single_phi_def): New.  Return true if PHI has one def of the specified\n\toperand type.\n\t(op_iter_init_phiuse): New.  Initialize the iterator for PHI arguments.\n\t(op_iter_init_phidef): New.  Initialize the iterator for the PHI def.\n\t* tree-flow.h (struct immediate_use_iterator_d): Use ssa_use_operand_t.\n\t(struct stmt_ann_d): Operands field no longer require GTY().\n\t(vn_compute, vn_lookup_or_add, vn_add, vn_lookup): Change prototype.\n\t* tree-into-ssa.c (mark_def_sites): Use SSA_OP_VMUSTKILL.\n\t* tree-outof-ssa.c (check_replaceable, find_replaceable_in_bb,\n\tdump_replaceable_exprs, rewrite_trees): Use generic interface.\n\t* tree-phinodes.c (make_phi_node, release_phi_node, resize_phi_node):\n\tUse use_operand_p instead of ssa_imm_use_t *.\n\t* tree-pretty-print.c (dump_vops): check if operands are active before\n\tdumping virtual operands.\n\t* tree-sra.c (sra_walk_function): Use ZERO_SSA_OPERANDS.\n\t* tree-ssa-ccp.c (likely_value): Use ZERO_SSA_OPERANDS.\n\t(ccp_fold): Use new interface.\n\t(ccp_visit_stmt): Remove unused variables and code.\n\t(convert_to_gimple_builtin): Insert statements before calling\n\tmark_new_vars_to_rename.\n\t* tree-ssa-copy.c (stmt_may_generate_copy): Use ZERO_SSA_OPERANDS.\n\t(copy_prop_visit_cond_stmt): Use generic interface.\n\t* tree-ssa-dom.c (struct expr_hash_elt): Use stmt pointer, not the\n\tannotation in table.\n\t(thread_across_edge): Use generic interface.\n\t(initialize_hash_element): Initialzie with stmt, not annotation.\n\t(eliminate_redundant_computations): Use generic interface.\n\t(record_equivalences_from_stmt): Pass stmt, not annotation.\n\t(avail_expr_hash, real_avail_expr_hash, avail_expr_eq): Use generic\n\tinterface.\n\t* tree-ssa-dse.c (dse_optimize_stmt): Use ZERO_SSA_OPERANDS.\n\t* tree-ssa-loop-ivopts.c (find_invariants_stmt,\n\tfind_interesting_uses_stmt, protect_loop_closed_ssa_form_use): Use\n\tgeneric operand interface.\n\t* tree-ssa-loop-niter.c (chain_of_csts_start, get_val_for): Use generic\n\tinterface.\n\t* tree-ssa-loop-unswitch.c (tree_may_unswitch_on): Use Generic operand\n\tInterface.\n\t* tree-ssa-operands.c (struct opbuild_list_d): New.  Operand build type.\n\t(build_defs, build_uses, build_v_may_defs, build_vuses,\n\tbuild_v_must_defs): Change type to struct opbuild_list_d.\n\t(ops_active): New.  Operands active boolean.\n\t(operand_memory, operand_memory_index): New.  Operand memory managers.\n\t(allocate_def_optype, allocate_use_optype, allocate_v_may_def_optype,\n\tallocate_vuse_optype, allocate_v_must_def_optype): Delete.\n\t(free_uses, free_defs, free_vuses, free_v_may_defs, free_v_must_defs):\n\tChange from functions to static variable list heads.\n\t(opbuild_initialize_virtual): New.  Initialize a virtual build list.\n\t(opbuild_initialize_real): New.  Initialize a virtual build list.\n\t(opbuild_free): New.  Free a build list.\n\t(opbuild_num_elems): New.  Number of items in a list.\n\t(opbuild_append_real): New.  Add a real (tree *) operand.\n\t(opbuild_append_virtual): New.  Add and sort a virtual (tree) operand.\n\t(opbuild_first): New.  Return first element index in a list.\n\t(opbuild_next): New.  Return next element in a list.\n\t(opbuild_elem_real): New.  Return real element.\n\t(opbuild_elem_virtual): New.  Return virtual element.\n\t(opbuild_elem_uid): New.  Return UID of virtual element.\n\t(opbuild_clear): New.  Reset an operand list.\n\t(opbuild_remove_elem): New.  Remove an element form a list.\n\t(ssa_operands_active): New.  Return true if operand cache is active.\n\t(init_ssa_operands, fini_ssa_operands): Initialize new implementation.\n\t(ssa_operand_alloc): New.  Allocate memory from an operand chunk.\n\t(correct_use_link): Use use_operand_p.\n\t(finalize_ssa_uses, finalize_ssa_v_may_defs, finalize_ssa_defs,\n\tfinalize_ssa_vuses, finalize_ssa_v_must_defs): New implmentation.\n\t(cleanup_v_may_defs): Use new implmentation.\n\t(finalize_ssa_stmt_operands, start_ssa_stmt_operands): New\n\timplementation.\n\t(append_def, append_use, append_v_may_def, append_vuse,\n\tappend_v_must_def): Call opbuild_append routine instead of using varray.\n\t(build_ssa_operands): Simplify to simply use stmt, don't maintain a\n\tglobal parse_old_ops variable.\n\t(free_ssa_operands): New implementation.\n\t(update_stmt_operands): Move.  Change argument to build_ssa_operands.\n\t(copy_virtual_operands): Move. New generic implementation.\n\t(create_ssa_artficial_load_stmt): Move. New implementation.\n\t(swap_tree_operands): Update for new implementation.\n\t(get_expr_operands): Add stmt parameter to calls to swap_tree_operands.\n\t(add_call_clobber_ops, add_call_read_ops): Initialize opbuild list\n\trather than a varray.\n\t(verify_imm_links): Use use_operand_p.\n\t(dump_immediate_uses_for): If the immediate use variable is a virtual\n\tvariable, show the virtual ops in the stmt.\n\t* tree-ssa-operands.h (def_operand_p): No longer a structure.\n\t(NULL_DEF_OPERAND_P): Now a #define.\n\t(def_optype_d, use_optype_d, v_def_use_operand_type, v_may_def_optype_d,\n\tvuse_operand_type, vuse_optype_d, v_must_def_optype_d): Delete.\n\t(def_optype_d, use_optype_d, maydef_optype_d, vuse_optype_d,\n\tmustdef_optype_d): New.  Use Linked list representation.\n\t(SSA_OPERAND_MEMORY_SIZE): New.  Size of operand memory chunk.\n\t(struct ssa_operand_memory_d): New.  Allocated Chunk node.\n\t(struct stmt_operands_d): Change to new pointers that are not GTY.\n\t(STMT_USE_OPS, NUM_USES, SET_USE_OP, STMT_DEF_OPS, NUM_DEFS, SET_DEF_OP,\n\tSTMT_V_MAY_DEF_OPS, NUM_V_MAY_DEFS, SET_V_MAY_DEF_RESULT,\n\tSET_V_MAY_DEF_OP, STMT_VUSE_OPS, NUM_VUSES, SET_VUSE_OP,\n\tSTMT_V_MUST_DEF_OPS, NUM_V_MUST_DEFS, SET_V_MUST_DEF_RESULT,\n\tSET_V_MUST_DEF_KILL): Delete.\n\t(V_MAY_DEF_OPS, V_MAY_DEF_RESULT_PTR, V_MAY_DEF_RESULT,\n\tV_MAY_DEF_OP_PTR, V_MAY_DEF_OP): Rename to MAYDEF_*.\n\t(V_MUST_DEF_OPS, V_MUST_DEF_RESULT_PTR, V_MUST_DEF_RESULT,\n\tV_MUST_DEF_KILL_PTR, V_MUST_DEF_KILL): Rename to MUSTDEF_*.\n\t(enum ssa_op_iter_type): Operand iterator typechecking values.\n\t(struct ssa_operand_iterator_d): Use linked lists of operands.\n\t(SSA_OP_VMUSTDEFKILL): Rename to SSA_OP_VMUSTKILL.\n\t(FOR_EACH_SSA_MAYDEF_OPERAND, FOR_EACH_SSA_MUSTDEF_OPERAND,\n\tFOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND): Use op_iter_next_maymustdef.\n\t(FOR_EACH_PHI_ARG): New.  Iterate over PHI arguments.\n\t(FOR_EACH_PHI_OR_STMT_USE): New.  Iterate over PHI or stmt uses.\n\t(FOR_EACH_PHI_OR_STMT_DEF): New.  Iterate over PHI or stmt defs.\n\t(SINGLE_SSA_TREE_OPERAND, SINGLE_SSA_USE_OPERAND,\n\tSINGLE_SSA_DEF_OPERAND, ZERO_SSA_OPERANDS, NUM_SSA_OPERANDS): New.\n\t* tree-ssa-opfinalize.h: New.  Function templates for expansion.\n\t(FINALIZE_ALLOC): Expands into alloc_def, alloc_use, alloc_maydef,\n\talloc_vuse, and alloc_mustdef.\n\t(FINALIZE_FUNC): Expands into finalize_ssa_def_ops,\n\tfinalize_ssa_use_ops, finalize_ssa_v_may_def_ops, finalize_ssa_vuse_ops,\n\tand finalize_ssa_v_must_def_ops.\n\t* tree-ssa-pre.c (add_to_sets): Pass tree to vn_add.\n\t(create_value_expr_from): Use stmt not vuse_optype as a parameter. Pass\n\tstmt around.\n\t(compute_avail): Use generic iterator interface.\n\t* tree-ssa-propagate.c (first_vdef): Use generic operand interface.\n\t(stmt_makes_single_load, stmt_makes_single_store): Use\n\tZERO_SSA_OPERANDS.\n\t* tree-ssa-sink.c (is_hidden_global_store): Use ZERO_SSA_OPERANDS.\n\t(statement_sink_location): Use generic interface.\n\t* tree-ssa.c (verify_ssa):  Use %p in fprintf.  Use generic interface.\n\t(delete_tree_ssa): Don't call release_defs.  Call release_ssa_name and\n\treset the immediate use link nodes.\n\t(stmt_references_memory_p): Use ZERO_SSA_OPERANDS.\n\t* tree-ssanames.c (make_ssa_name): Use use_operand_p.\n\t* tree-tailcall.c (find_tail_calls): Use ZERO_SSA_OPERANDS.\n\t(eliminate_tail_call): Use generic operand interface.\n\t* tree-vect-analyze.c (vect_analyze_data_refs): Use ZERO_SSA_OPERANDS.\n\t(vect_mark_relevant, vect_mark_stmts_to_be_vectorized): Use generic\n\tinterface.\n\t* tree-vect-transform.c (update_vuses_to_preheader): Use generic\n\tinterface.\n\t* tree-vectorizer.c (rename_variables_in_bb): Use generic interface.\n\t* tree-vn.c (struct val_expr_pair_d): Cache statment pointer instead of\n\tvuse_optype.\n\t(vn_compute, val_expr_pair_hash, vn_add, vn_lookup, vn_lookup_or_add):\n\tUse statement pointer instead of vuse_optype.  Use generic interface.\n\t* tree-vrp.c (maybe_add_assert_expr): Use generic interface.\n\t(stmt_interesting_for_vrp, vrp_visit_stmt): Use ZERO_SSA_OPERANDS.\n\t* tree.h (struct ssa_imm_use_d): Renamed to ssa_use_operand_d.\n\t(tree_ssa_name, phi_arg_d): Use ssa_use_operand_d.\n\t* doc/tree-ssa.texi: Update documentation for operand interface.\n\nFrom-SVN: r99155", "tree": {"sha": "4bdcc871f23e3607a16ebf6af8f41a8854a30836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bdcc871f23e3607a16ebf6af8f41a8854a30836"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f47c96aac54c7d7b5e0855e1b52419435268d61f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47c96aac54c7d7b5e0855e1b52419435268d61f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f47c96aac54c7d7b5e0855e1b52419435268d61f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47c96aac54c7d7b5e0855e1b52419435268d61f/comments", "author": null, "committer": null, "parents": [{"sha": "992d08b1a18b90775f61b815949cd005545fa844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992d08b1a18b90775f61b815949cd005545fa844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992d08b1a18b90775f61b815949cd005545fa844"}], "stats": {"total": 3822, "additions": 2018, "deletions": 1804}, "files": [{"sha": "7aecc48dc7f91f12df5c31581271483e8a3facee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1,3 +1,190 @@\n+2005-05-03  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* lambda-code.c (gcc_loop_to_lambda_loop, \n+\tlambda_loopnest_to_gcc_loopnest, phi_loop_edge_uses_def,\n+\tstmt_is_bumper_for_loop, perfect_nest_p, replace_uses_of_x_with_y): Use\n+\tgeneric operand interface.\n+\t* tree-data-ref.c (find_data_references_in_loop): Use generic interface.\n+\t* tree-dfa.c (collect_dfa_stats_r, mark_new_vars_to_rename): Use\n+\tgeneric operand interface.\n+\t* tree-flow-inline.h (delink_imm_use, link_imm_use_to_list, \n+\tlink_imm_use, link_imm_use_stmt, relink_imm_use, relink_imm_use_stmt,\n+\tnext_safe_imm_use, has_zero_uses, has_single_use, single_imm_use,\n+\tnum_imm_uses): Use ssa_use_operand_t.\n+\t(get_def_ops, get_use_ops, get_v_may_def_ops, get_vuse_ops,\n+\tget_v_must_def_ops): Delete.\n+\t(get_def_from_ptr, get_phi_result_ptr): Get def directly now.\n+\t(get_use_op_ptr, get_def_op_ptr, get_v_may_def_result_ptr,\n+\tget_v_may_def_op_ptr, get_vuse_op_ptr, get_v_must_def_result_ptr,\n+\tget_v_must_def_kill_ptr): Delete.\n+\t(delink_stmt_imm_use): Move and use new operand interface.\n+\t(op_iter_next_use, op_iter_next_def, op_iter_next_tree, op_iter_init,\n+\top_iter_next_tree): Use new operand implementation.\n+\t(clear_and_done_ssa_iter): New.  Initialize a blank operand iterator.\n+\t(op_iter_init_use, op_iter_init_def, op_iter_init_tree): Add iterator \n+\ttype check.\n+\t(op_iter_next_mustdef, op_iter_next_maydef, \n+\top_iter_next_must_and_may_def): Delete. Replace with...\n+\t(op_iter_next_maymustdef): New.  Combine must and may next operations.\n+\t(op_iter_init_maydef, op_iter_init_mustdef, \n+\top_iter_init_must_and_may_def): Use new interface.\n+\t(single_ssa_tree_operand ): New.  Process single operands only as trees.\n+\t(single_ssa_use_operand): New.  Process single operands only as uses.\n+\t(single_ssa_def_operand): New.  Process single operands only as defs.\n+\t(zero_ssa_operands): New.  Return TRUE if there are zero operands of the\n+\tspecified types.\n+\t(num_ssa_operands): New.  Count the number of specified operands.\n+\t(compare_ssa_operands_equal): New.  Compare two statements' operands.\n+\t(single_phi_def): New.  Return true if PHI has one def of the specified\n+\toperand type.\n+\t(op_iter_init_phiuse): New.  Initialize the iterator for PHI arguments.\n+\t(op_iter_init_phidef): New.  Initialize the iterator for the PHI def.\n+\t* tree-flow.h (struct immediate_use_iterator_d): Use ssa_use_operand_t.\n+\t(struct stmt_ann_d): Operands field no longer require GTY().\n+\t(vn_compute, vn_lookup_or_add, vn_add, vn_lookup): Change prototype.\n+\t* tree-into-ssa.c (mark_def_sites): Use SSA_OP_VMUSTKILL.\n+\t* tree-outof-ssa.c (check_replaceable, find_replaceable_in_bb, \n+\tdump_replaceable_exprs, rewrite_trees): Use generic interface.\n+\t* tree-phinodes.c (make_phi_node, release_phi_node, resize_phi_node): \n+\tUse use_operand_p instead of ssa_imm_use_t *.\n+\t* tree-pretty-print.c (dump_vops): check if operands are active before\n+\tdumping virtual operands.\n+\t* tree-sra.c (sra_walk_function): Use ZERO_SSA_OPERANDS.\n+\t* tree-ssa-ccp.c (likely_value): Use ZERO_SSA_OPERANDS.\n+\t(ccp_fold): Use new interface.\n+\t(ccp_visit_stmt): Remove unused variables and code.\n+\t(convert_to_gimple_builtin): Insert statements before calling \n+\tmark_new_vars_to_rename.\n+\t* tree-ssa-copy.c (stmt_may_generate_copy): Use ZERO_SSA_OPERANDS.\n+\t(copy_prop_visit_cond_stmt): Use generic interface.\n+\t* tree-ssa-dom.c (struct expr_hash_elt): Use stmt pointer, not the \n+\tannotation in table.\n+\t(thread_across_edge): Use generic interface.\n+\t(initialize_hash_element): Initialzie with stmt, not annotation.\n+\t(eliminate_redundant_computations): Use generic interface.\n+\t(record_equivalences_from_stmt): Pass stmt, not annotation.\n+\t(avail_expr_hash, real_avail_expr_hash, avail_expr_eq): Use generic\n+\tinterface.\n+\t* tree-ssa-dse.c (dse_optimize_stmt): Use ZERO_SSA_OPERANDS.\n+\t* tree-ssa-loop-ivopts.c (find_invariants_stmt, \n+\tfind_interesting_uses_stmt, protect_loop_closed_ssa_form_use): Use \n+\tgeneric operand interface.\n+\t* tree-ssa-loop-niter.c (chain_of_csts_start, get_val_for): Use generic\n+\tinterface.\n+\t* tree-ssa-loop-unswitch.c (tree_may_unswitch_on): Use Generic operand\n+\tInterface.\n+\t* tree-ssa-operands.c (struct opbuild_list_d): New.  Operand build type.\n+\t(build_defs, build_uses, build_v_may_defs, build_vuses, \n+\tbuild_v_must_defs): Change type to struct opbuild_list_d.\n+\t(ops_active): New.  Operands active boolean.\n+\t(operand_memory, operand_memory_index): New.  Operand memory managers.\n+\t(allocate_def_optype, allocate_use_optype, allocate_v_may_def_optype,\n+\tallocate_vuse_optype, allocate_v_must_def_optype): Delete.\n+\t(free_uses, free_defs, free_vuses, free_v_may_defs, free_v_must_defs): \n+\tChange from functions to static variable list heads.\n+\t(opbuild_initialize_virtual): New.  Initialize a virtual build list.\n+\t(opbuild_initialize_real): New.  Initialize a virtual build list.\n+\t(opbuild_free): New.  Free a build list.\n+\t(opbuild_num_elems): New.  Number of items in a list.\n+\t(opbuild_append_real): New.  Add a real (tree *) operand.\n+\t(opbuild_append_virtual): New.  Add and sort a virtual (tree) operand.\n+\t(opbuild_first): New.  Return first element index in a list.\n+\t(opbuild_next): New.  Return next element in a list.\n+\t(opbuild_elem_real): New.  Return real element.\n+\t(opbuild_elem_virtual): New.  Return virtual element.\n+\t(opbuild_elem_uid): New.  Return UID of virtual element.\n+\t(opbuild_clear): New.  Reset an operand list.\n+\t(opbuild_remove_elem): New.  Remove an element form a list.\n+\t(ssa_operands_active): New.  Return true if operand cache is active.\n+\t(init_ssa_operands, fini_ssa_operands): Initialize new implementation.\n+\t(ssa_operand_alloc): New.  Allocate memory from an operand chunk.\n+\t(correct_use_link): Use use_operand_p.\n+\t(finalize_ssa_uses, finalize_ssa_v_may_defs, finalize_ssa_defs,\n+\tfinalize_ssa_vuses, finalize_ssa_v_must_defs): New implmentation. \n+\t(cleanup_v_may_defs): Use new implmentation.\n+\t(finalize_ssa_stmt_operands, start_ssa_stmt_operands): New \n+\timplementation.\n+\t(append_def, append_use, append_v_may_def, append_vuse, \n+\tappend_v_must_def): Call opbuild_append routine instead of using varray.\n+\t(build_ssa_operands): Simplify to simply use stmt, don't maintain a \n+\tglobal parse_old_ops variable.\n+\t(free_ssa_operands): New implementation.\n+\t(update_stmt_operands): Move.  Change argument to build_ssa_operands.\n+\t(copy_virtual_operands): Move. New generic implementation.\n+\t(create_ssa_artficial_load_stmt): Move. New implementation.\n+\t(swap_tree_operands): Update for new implementation.\n+\t(get_expr_operands): Add stmt parameter to calls to swap_tree_operands.\n+\t(add_call_clobber_ops, add_call_read_ops): Initialize opbuild list\n+\trather than a varray.\n+\t(verify_imm_links): Use use_operand_p.\n+\t(dump_immediate_uses_for): If the immediate use variable is a virtual \n+\tvariable, show the virtual ops in the stmt.\n+\t* tree-ssa-operands.h (def_operand_p): No longer a structure.\n+\t(NULL_DEF_OPERAND_P): Now a #define.\n+\t(def_optype_d, use_optype_d, v_def_use_operand_type, v_may_def_optype_d,\n+\tvuse_operand_type, vuse_optype_d, v_must_def_optype_d): Delete.\n+\t(def_optype_d, use_optype_d, maydef_optype_d, vuse_optype_d,\n+\tmustdef_optype_d): New.  Use Linked list representation.\n+\t(SSA_OPERAND_MEMORY_SIZE): New.  Size of operand memory chunk.\n+\t(struct ssa_operand_memory_d): New.  Allocated Chunk node.\n+\t(struct stmt_operands_d): Change to new pointers that are not GTY.\n+\t(STMT_USE_OPS, NUM_USES, SET_USE_OP, STMT_DEF_OPS, NUM_DEFS, SET_DEF_OP,\n+\tSTMT_V_MAY_DEF_OPS, NUM_V_MAY_DEFS, SET_V_MAY_DEF_RESULT,\n+\tSET_V_MAY_DEF_OP, STMT_VUSE_OPS, NUM_VUSES, SET_VUSE_OP,\n+\tSTMT_V_MUST_DEF_OPS, NUM_V_MUST_DEFS, SET_V_MUST_DEF_RESULT, \n+\tSET_V_MUST_DEF_KILL): Delete.\n+\t(V_MAY_DEF_OPS, V_MAY_DEF_RESULT_PTR, V_MAY_DEF_RESULT, \n+\tV_MAY_DEF_OP_PTR, V_MAY_DEF_OP): Rename to MAYDEF_*.\n+\t(V_MUST_DEF_OPS, V_MUST_DEF_RESULT_PTR, V_MUST_DEF_RESULT, \n+\tV_MUST_DEF_KILL_PTR, V_MUST_DEF_KILL): Rename to MUSTDEF_*.\n+\t(enum ssa_op_iter_type): Operand iterator typechecking values.\n+\t(struct ssa_operand_iterator_d): Use linked lists of operands.\n+\t(SSA_OP_VMUSTDEFKILL): Rename to SSA_OP_VMUSTKILL.\n+\t(FOR_EACH_SSA_MAYDEF_OPERAND, FOR_EACH_SSA_MUSTDEF_OPERAND,\n+\tFOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND): Use op_iter_next_maymustdef.\n+\t(FOR_EACH_PHI_ARG): New.  Iterate over PHI arguments.\n+\t(FOR_EACH_PHI_OR_STMT_USE): New.  Iterate over PHI or stmt uses.\n+\t(FOR_EACH_PHI_OR_STMT_DEF): New.  Iterate over PHI or stmt defs.\n+\t(SINGLE_SSA_TREE_OPERAND, SINGLE_SSA_USE_OPERAND, \n+\tSINGLE_SSA_DEF_OPERAND, ZERO_SSA_OPERANDS, NUM_SSA_OPERANDS): New.\n+\t* tree-ssa-opfinalize.h: New.  Function templates for expansion.\n+\t(FINALIZE_ALLOC): Expands into alloc_def, alloc_use, alloc_maydef,\n+\talloc_vuse, and alloc_mustdef.\n+\t(FINALIZE_FUNC): Expands into finalize_ssa_def_ops, \n+\tfinalize_ssa_use_ops, finalize_ssa_v_may_def_ops, finalize_ssa_vuse_ops,\n+\tand finalize_ssa_v_must_def_ops.\n+\t* tree-ssa-pre.c (add_to_sets): Pass tree to vn_add.\n+\t(create_value_expr_from): Use stmt not vuse_optype as a parameter. Pass\n+\tstmt around.\n+\t(compute_avail): Use generic iterator interface.\n+\t* tree-ssa-propagate.c (first_vdef): Use generic operand interface.\n+\t(stmt_makes_single_load, stmt_makes_single_store): Use \n+\tZERO_SSA_OPERANDS.\n+\t* tree-ssa-sink.c (is_hidden_global_store): Use ZERO_SSA_OPERANDS.\n+\t(statement_sink_location): Use generic interface.\n+\t* tree-ssa.c (verify_ssa):  Use %p in fprintf.  Use generic interface.\n+\t(delete_tree_ssa): Don't call release_defs.  Call release_ssa_name and\n+\treset the immediate use link nodes.\n+\t(stmt_references_memory_p): Use ZERO_SSA_OPERANDS.\n+\t* tree-ssanames.c (make_ssa_name): Use use_operand_p.\n+\t* tree-tailcall.c (find_tail_calls): Use ZERO_SSA_OPERANDS.\n+\t(eliminate_tail_call): Use generic operand interface.\n+\t* tree-vect-analyze.c (vect_analyze_data_refs): Use ZERO_SSA_OPERANDS.\n+\t(vect_mark_relevant, vect_mark_stmts_to_be_vectorized): Use generic \n+\tinterface.\n+\t* tree-vect-transform.c (update_vuses_to_preheader): Use generic \n+\tinterface.\n+\t* tree-vectorizer.c (rename_variables_in_bb): Use generic interface.\n+\t* tree-vn.c (struct val_expr_pair_d): Cache statment pointer instead of\n+\tvuse_optype.\n+\t(vn_compute, val_expr_pair_hash, vn_add, vn_lookup, vn_lookup_or_add): \n+\tUse statement pointer instead of vuse_optype.  Use generic interface.\n+\t* tree-vrp.c (maybe_add_assert_expr): Use generic interface.\n+\t(stmt_interesting_for_vrp, vrp_visit_stmt): Use ZERO_SSA_OPERANDS.\n+\t* tree.h (struct ssa_imm_use_d): Renamed to ssa_use_operand_d.\n+\t(tree_ssa_name, phi_arg_d): Use ssa_use_operand_d.\n+\t* doc/tree-ssa.texi: Update documentation for operand interface.\n+\n 2005-05-03  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/darwin.c (machopic_define_symbol): Use gcc_assert or"}, {"sha": "88dcacf912d87f33bc047469847772feeea22599", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 87, "deletions": 85, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -705,8 +705,8 @@ Almost every GIMPLE statement will contain a reference to a variable\n or memory location.  Since statements come in different shapes and\n sizes, their operands are going to be located at various spots inside\n the statement's tree.  To facilitate access to the statement's\n-operands, they are organized into arrays associated inside each\n-statement's annotation.  Each element in an operand array is a pointer\n+operands, they are organized into lists associated inside each\n+statement's annotation.  Each element in an operand list is a pointer\n to a @code{VAR_DECL}, @code{PARM_DECL} or @code{SSA_NAME} tree node.\n This provides a very convenient way of examining and replacing\n operands.\n@@ -810,98 +810,58 @@ function is converted into SSA form.  This will be used to link all\n the non-killing definitions to prevent optimizations from making\n incorrect assumptions about them.\n \n-Operands are collected by @file{tree-ssa-operands.c}.  They are stored\n-inside each statement's annotation and can be accessed with\n-@code{DEF_OPS}, @code{USE_OPS}, @code{V_MAY_DEF_OPS},\n-@code{V_MUST_DEF_OPS} and @code{VUSE_OPS}.  The following are all the\n-accessor macros available to access USE operands.  To access all the\n-other operand arrays, just change the name accordingly.  Note that\n-this interface to the operands is deprecated, and is slated for\n-removal in a future version of gcc.  The preferred interface is the\n-operand iterator interface.  Unless you need to discover the number of\n-operands of a given type on a statement, you are strongly urged not to\n-use this interface.\n-\n-@defmac USE_OPS (@var{ann})\n-Returns the array of operands used by the statement with annotation\n-@var{ann}.\n-@end defmac\n-\n-@defmac STMT_USE_OPS (@var{stmt})\n-Alternate version of USE_OPS that takes the statement @var{stmt} as\n-input.\n-@end defmac\n+Operands are updated as soon as the statement is finished via a call\n+to @code{update_stmt}.  If statement elements are changed via\n+@code{SET_USE} or @code{SET_DEF}, then no further action is required\n+(ie, those macros take care of updating the statement).  If changes\n+are made by manipulating the statement's tree directly, then a call\n+must be made to @code{update_stmt} when complete.  Calling one of the\n+@code{bsi_insert} routines or @code{bsi_replace} performs an implicit\n+call to @code{update_stmt}.\n \n-@defmac NUM_USES (@var{ops})\n-Return the number of USE operands in array @var{ops}.\n-@end defmac\n+@subsection Operand Iterators And Access Routines\n+@cindex Operand Iterators \n+@cindex Operand Access Routines\n \n-@defmac USE_OP_PTR (@var{ops}, @var{i})\n-Return a pointer to the @var{i}th operand in array @var{ops}.\n-@end defmac\n+Operands are collected by @file{tree-ssa-operands.c}.  They are stored\n+inside each statement's annotation and can be accessed through either the\n+operand iterators or an access routine.\n \n-@defmac USE_OP (@var{ops}, @var{i})\n-Return the @var{i}th operand in array @var{ops}.\n-@end defmac\n+The following access routines are available for examining operands:\n \n-The following function shows how to print all the operands of a given\n-statement:\n+@enumerate\n+@item @code{SINGLE_SSA_@{USE,DEF,TREE@}_OPERAND}: These accessors will return \n+NULL unless there is exactly one operand mathcing the specified flags.  If \n+there is exactly one operand, the operand is returned as either a @code{tree}, \n+@code{def_operand_p}, or @code{use_operand_p}.\n \n @smallexample\n-void\n-print_ops (tree stmt)\n-@{\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  def_optype defs;\n-  use_optype uses;\n-  stmt_ann_t ann;\n-  size_t i;\n-\n-  ann = stmt_ann (stmt);\n-\n-  defs = DEF_OPS (ann);\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n-    print_generic_expr (stderr, DEF_OP (defs, i), 0);\n-\n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    print_generic_expr (stderr, USE_OP (uses, i), 0);\n-\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    @{\n-      print_generic_expr (stderr, V_MAY_DEF_OP (v_may_defs, i), 0);\n-      print_generic_expr (stderr, V_MAY_DEF_RESULT (v_may_defs, i), 0);\n-    @}\n+tree t = SINGLE_SSA_TREE_OPERAND (stmt, flags);\n+use_operand_p u = SINGLE_SSA_USE_OPERAND (stmt, SSA_ALL_VIRTUAL_USES);\n+def_operand_p d = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_ALL_DEFS);\n+@end smallexample\n \n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-    print_generic_expr (stderr, V_MUST_DEF_OP (v_must_defs, i), 0);\n+@item @code{ZERO_SSA_OPERANDS}: This macro returns true if there are no \n+operands matching the specified flags.\n \n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    print_generic_expr (stderr, VUSE_OP (vuses, i), 0);\n-@}\n+@smallexample\n+if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+  return;\n @end smallexample\n \n-Operands are updated as soon as the statement is finished via a call\n-to @code{update_stmt}.  If statement elements are changed via\n-@code{SET_USE} or @code{SET_DEF}, then no further action is required\n-(ie, those macros take care of updating the statement).  If changes\n-are made by manipulating the statement's tree directly, then a call\n-must be made to @code{update_stmt} when complete.  Calling one of the\n-@code{bsi_insert} routines or @code{bsi_replace} performs an implicit\n-call to @code{update_stmt}.\n+@item @code{NUM_SSA_OPERANDS}: This macro Returns the number of operands \n+matching 'flags'.  This actually executes a loop to perform the count, so \n+only use this if it is really needed.\n+\n+@smallexample\n+int count = NUM_SSA_OPERANDS (stmt, flags)\n+@end smallexample\n+@end enumerate\n \n-@subsection Operand Iterators\n-@cindex Operand Iterators\n \n-There is an alternative to iterating over the operands in a statement.\n-It is especially useful when you wish to perform the same operation on\n-more than one type of operand.  The previous example could be\n-rewritten as follows:\n+If you wish to iterate over some or all operands, use the\n+@code{FOR_EACH_SSA_@{USE,DEF,TREE@}_OPERAND} iterator.  For example, to print\n+all the operands for a statement:\n \n @smallexample\n void\n@@ -911,11 +871,13 @@ print_ops (tree stmt)\n   tree var;\n \n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_OPERANDS)\n-    print_generic_expr (stderr, var, 0);\n+    print_generic_expr (stderr, var, TDF_SLIM);\n @}\n @end smallexample\n \n \n+How to choose the appropriate iterator:\n+\n @enumerate\n @item Determine whether you are need to see the operand pointers, or just the\n     trees, and choose the appropriate macro:\n@@ -966,7 +928,7 @@ So if you want to look at the use pointers for all the @code{USE} and\n     @}\n @end smallexample\n \n-The @code{_TREE_} macro is basically the same as the @code{USE} and\n+The @code{TREE} macro is basically the same as the @code{USE} and\n @code{DEF} macros, only with the use or def dereferenced via\n @code{USE_FROM_PTR (use_p)} and @code{DEF_FROM_PTR (def_p)}.  Since we\n aren't using operand pointers, use and defs flags can be mixed.\n@@ -1002,7 +964,7 @@ this one.\n \n @code{V_MUST_DEF}s are broken into two flags, one for the\n @code{DEF} portion (@code{SSA_OP_VMUSTDEF}) and one for the kill portion\n-(@code{SSA_OP_VMUSTDEFKILL}).  If all you want to look at are the\n+(@code{SSA_OP_VMUSTKILL}).  If all you want to look at are the\n @code{V_MUST_DEF}s together, there is a fourth iterator macro for this,\n which returns both a def_operand_p and a use_operand_p for each\n @code{V_MUST_DEF} in the statement.  Note that you don't need any flags for\n@@ -1023,6 +985,46 @@ this one.\n There are many examples in the code as well, as well as the\n documentation in @file{tree-ssa-operands.h}.\n \n+There are also a couple of variants on the stmt iterators regarding PHI\n+nodes.\n+\n+@code{FOR_EACH_PHI_ARG} Works exactly like \n+@code{FOR_EACH_SSA_USE_OPERAND}, except it works over @code{PHI} arguments \n+instead of statement operands.\n+\n+@smallexample\n+/* Look at every virtual PHI use.  */\n+FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_VIRTUAL_USES)\n+@{\n+   my_code;\n+@}\n+\n+/* Look at every real PHI use.  */\n+FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_USES)\n+  my_code;\n+\n+/* Look at every every PHI use.  */\n+FOR_EACH_PHI_ARG (use_p, phi_stmt, iter, SSA_OP_ALL_USES)\n+  my_code;\n+@end smallexample\n+\n+@code{FOR_EACH_PHI_OR_STMT_@{USE,DEF@}} works exactly like \n+@code{FOR_EACH_SSA_@{USE,DEF@}_OPERAND}, except it will function on\n+either a statement or a @code{PHI} node.  These should be used when it is\n+appropriate but they are not quite as efficient as the individual \n+@code{FOR_EACH_PHI} and @code{FOR_EACH_SSA} routines.\n+\n+@smallexample\n+FOR_EACH_PHI_OR_STMT_USE (use_operand_p, stmt, iter, flags)\n+  @{\n+     my_code;\n+  @}\n+\n+FOR_EACH_PHI_OR_STMT_DEF (def_operand_p, phi, iter, flags)\n+  @{\n+     my_code;\n+  @}\n+@end smallexample\n \n @subsection Immediate Uses\n @cindex Immediate Uses"}, {"sha": "940f7470afe2ddc95c99de10ca717f00faf9dba9", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1266,7 +1266,6 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   int stepint;\n   int extra = 0;\n   tree lboundvar, uboundvar, uboundresult;\n-  use_optype uses;\n \n   /* Find out induction var and exit condition.  */\n   inductionvar = find_induction_var_from_exit_cond (loop);\n@@ -1295,9 +1294,8 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   phi = SSA_NAME_DEF_STMT (inductionvar);\n   if (TREE_CODE (phi) != PHI_NODE)\n     {\n-      uses = STMT_USE_OPS (phi);\n-\n-      if (!uses)\n+      phi = SINGLE_SSA_TREE_OPERAND (phi, SSA_OP_USE);\n+      if (!phi)\n \t{\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1307,7 +1305,6 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t  return NULL;\n \t}\n \n-      phi = USE_OP (uses, 0);\n       phi = SSA_NAME_DEF_STMT (phi);\n       if (TREE_CODE (phi) != PHI_NODE)\n \t{\n@@ -1972,12 +1969,11 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       tree oldiv_def;\n       tree oldiv_stmt = SSA_NAME_DEF_STMT (oldiv);\n \n-      gcc_assert (TREE_CODE (oldiv_stmt) == PHI_NODE\n-\t\t  || NUM_DEFS (STMT_DEF_OPS (oldiv_stmt)) == 1);\n       if (TREE_CODE (oldiv_stmt) == PHI_NODE)\n-\toldiv_def = PHI_RESULT (oldiv_stmt);\n+        oldiv_def = PHI_RESULT (oldiv_stmt);\n       else\n-\toldiv_def = DEF_OP (STMT_DEF_OPS (oldiv_stmt), 0);\n+\toldiv_def = SINGLE_SSA_TREE_OPERAND (oldiv_stmt, SSA_OP_DEF);\n+      gcc_assert (oldiv_def != NULL_TREE);\n \n       FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, oldiv_def)\n \t{\n@@ -2069,16 +2065,11 @@ phi_loop_edge_uses_def (struct loop *loop, tree phi, tree def)\n static bool\n stmt_uses_phi_result (tree stmt, tree phi_result)\n {\n-  use_optype uses = STMT_USE_OPS (stmt);\n+  tree use = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_USE);\n   \n   /* This is conservatively true, because we only want SIMPLE bumpers\n      of the form x +- constant for our pass.  */\n-  if (NUM_USES (uses) != 1)\n-    return false;\n-  if (USE_OP (uses, 0) == phi_result)\n-    return true;\n-  \n-  return false;\n+  return (use == phi_result);\n }\n \n /* STMT is a bumper stmt for LOOP if the version it defines is used in the\n@@ -2092,13 +2083,13 @@ stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n {\n   tree use;\n   tree def;\n-  def_optype defs = STMT_DEF_OPS (stmt);\n   imm_use_iterator iter;\n   use_operand_p use_p;\n   \n-  if (NUM_DEFS (defs) != 1)\n+  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+  if (!def)\n     return false;\n-  def = DEF_OP (defs, 0);\n+\n   FOR_EACH_IMM_USE_FAST (use_p, iter, def)\n     {\n       use = USE_STMT (use_p);\n@@ -2179,12 +2170,13 @@ perfect_nest_p (struct loop *loop)\n static void\n replace_uses_of_x_with_y (tree stmt, tree x, tree y)\n {\n-  use_optype uses = STMT_USE_OPS (stmt);\n-  size_t i;\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n     {\n-      if (USE_OP (uses, i) == x)\n-\tSET_USE_OP (uses, i, y);\n+      if (USE_FROM_PTR (use_p) == x)\n+\tSET_USE (use_p, y);\n     }\n }\n \n@@ -2193,11 +2185,12 @@ replace_uses_of_x_with_y (tree stmt, tree x, tree y)\n static bool\n stmt_uses_op (tree stmt, tree op)\n {\n-  use_optype uses = STMT_USE_OPS (stmt);\n-  size_t i;\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  ssa_op_iter iter;\n+  tree use;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      if (USE_OP (uses, i) == op)\n+      if (use == op)\n \treturn true;\n     }\n   return false;"}, {"sha": "8ef5c51a66060e761a80861ee6e8c5d0af7a0a90", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -2231,14 +2231,11 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n         {\n \t  tree stmt = bsi_stmt (bsi);\n-\t  stmt_ann_t ann = stmt_ann (stmt);\n \n \t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n \t    continue;\n \n-\t  if (!VUSE_OPS (ann)\n-\t      && !V_MUST_DEF_OPS (ann)\n-\t      && !V_MAY_DEF_OPS (ann))\n+\t  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n \t    continue;\n \t  \n \t  /* In the GIMPLE representation, a modify expression\n@@ -2269,8 +2266,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t    }\n \n \t  /* When there are no defs in the loop, the loop is parallel.  */\n-\t  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0\n-\t      || NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) > 0)\n+\t  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n \t    bb->loop_father->parallel_p = false;\n \t}\n "}, {"sha": "fa8ee86083f56c0b71a0a1fc35579e0c46abeaee", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -482,15 +482,13 @@ collect_dfa_stats_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t{\n \tcase STMT_ANN:\n \t  {\n-\t    stmt_ann_t ann = (stmt_ann_t) t->common.ann;\n \t    dfa_stats_p->num_stmt_anns++;\n-\t    dfa_stats_p->num_defs += NUM_DEFS (DEF_OPS (ann));\n-\t    dfa_stats_p->num_uses += NUM_USES (USE_OPS (ann));\n-\t    dfa_stats_p->num_v_may_defs +=\n-\t                 NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann));\n-\t    dfa_stats_p->num_vuses += NUM_VUSES (VUSE_OPS (ann));\n-\t    dfa_stats_p->num_v_must_defs +=\n-\t                 NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann));\n+\t    dfa_stats_p->num_defs += NUM_SSA_OPERANDS (t, SSA_OP_DEF);\n+\t    dfa_stats_p->num_uses += NUM_SSA_OPERANDS (t, SSA_OP_USE);\n+\t    dfa_stats_p->num_v_may_defs += NUM_SSA_OPERANDS (t, SSA_OP_VMAYDEF);\n+\t    dfa_stats_p->num_vuses += NUM_SSA_OPERANDS (t, SSA_OP_VUSE);\n+\t    dfa_stats_p->num_v_must_defs += \n+\t\t\t\t  NUM_SSA_OPERANDS (t, SSA_OP_VMUSTDEF);\n \t    break;\n \t  }\n \n@@ -642,8 +640,8 @@ mark_new_vars_to_rename (tree stmt)\n      We flag them in a separate bitmap because we don't really want to\n      rename them if there are not any newly exposed symbols in the\n      statement operands.  */\n-  v_may_defs_before = NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt));\n-  v_must_defs_before = NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt));\n+  v_may_defs_before = NUM_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF);\n+  v_must_defs_before = NUM_SSA_OPERANDS (stmt, SSA_OP_VMUSTDEF);\n \n   FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, \n \t\t\t     SSA_OP_VMAYDEF | SSA_OP_VUSE | SSA_OP_VMUSTDEF)\n@@ -657,8 +655,8 @@ mark_new_vars_to_rename (tree stmt)\n      exposed variables.  */\n   update_stmt (stmt);\n \n-  v_may_defs_after = NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt));\n-  v_must_defs_after = NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt));\n+  v_may_defs_after = NUM_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF);\n+  v_must_defs_after = NUM_SSA_OPERANDS (stmt, SSA_OP_VMUSTDEF);\n \n   FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_ALL_OPERANDS)\n     if (DECL_P (val))"}, {"sha": "3fa6259aa8ef203cb894c1cd93a09b4c54c61153", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 386, "deletions": 257, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -186,7 +186,7 @@ stmt_modified_p (tree t)\n \n /* Delink an immediate_uses node from its chain.  */\n static inline void\n-delink_imm_use (ssa_imm_use_t *linknode)\n+delink_imm_use (ssa_use_operand_t *linknode)\n {\n   /* Return if this node is not in a list.  */\n   if (linknode->prev == NULL)\n@@ -200,7 +200,7 @@ delink_imm_use (ssa_imm_use_t *linknode)\n \n /* Link ssa_imm_use node LINKNODE into the chain for LIST.  */\n static inline void\n-link_imm_use_to_list (ssa_imm_use_t *linknode, ssa_imm_use_t *list)\n+link_imm_use_to_list (ssa_use_operand_t *linknode, ssa_use_operand_t *list)\n {\n   /* Link the new node at the head of the list.  If we are in the process of \n      traversing the list, we won't visit any new nodes added to it.  */\n@@ -212,9 +212,9 @@ link_imm_use_to_list (ssa_imm_use_t *linknode, ssa_imm_use_t *list)\n \n /* Link ssa_imm_use node LINKNODE into the chain for DEF.  */\n static inline void\n-link_imm_use (ssa_imm_use_t *linknode, tree def)\n+link_imm_use (ssa_use_operand_t *linknode, tree def)\n {\n-  ssa_imm_use_t *root;\n+  ssa_use_operand_t *root;\n \n   if (!def || TREE_CODE (def) != SSA_NAME)\n     linknode->prev = NULL;\n@@ -241,7 +241,7 @@ set_ssa_use_from_ptr (use_operand_p use, tree val)\n /* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occuring \n    in STMT.  */\n static inline void\n-link_imm_use_stmt (ssa_imm_use_t *linknode, tree def, tree stmt)\n+link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, tree stmt)\n {\n   if (stmt)\n     link_imm_use (linknode, def);\n@@ -252,7 +252,7 @@ link_imm_use_stmt (ssa_imm_use_t *linknode, tree def, tree stmt)\n \n /* Relink a new node in place of an old node in the list.  */\n static inline void\n-relink_imm_use (ssa_imm_use_t *node, ssa_imm_use_t *old)\n+relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n {\n   /* The node one had better be in the same list.  */\n   gcc_assert (*(old->use) == *(node->use));\n@@ -270,7 +270,7 @@ relink_imm_use (ssa_imm_use_t *node, ssa_imm_use_t *old)\n /* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occuring \n    in STMT.  */\n static inline void\n-relink_imm_use_stmt (ssa_imm_use_t *linknode, ssa_imm_use_t *old, tree stmt)\n+relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old, tree stmt)\n {\n   if (stmt)\n     relink_imm_use (linknode, old);\n@@ -318,7 +318,7 @@ first_safe_imm_use (imm_use_iterator *imm, tree var)\n static inline use_operand_p\n next_safe_imm_use (imm_use_iterator *imm)\n {\n-  ssa_imm_use_t *ptr;\n+  ssa_use_operand_t *ptr;\n   use_operand_p old;\n \n   old = imm->imm_use;\n@@ -405,7 +405,7 @@ next_readonly_imm_use (imm_use_iterator *imm)\n static inline bool\n has_zero_uses (tree var)\n {\n-  ssa_imm_use_t *ptr;\n+  ssa_use_operand_t *ptr;\n   ptr = &(SSA_NAME_IMM_USE_NODE (var));\n   /* A single use means there is no items in the list.  */\n   return (ptr == ptr->next);\n@@ -415,7 +415,7 @@ has_zero_uses (tree var)\n static inline bool\n has_single_use (tree var)\n {\n-  ssa_imm_use_t *ptr;\n+  ssa_use_operand_t *ptr;\n   ptr = &(SSA_NAME_IMM_USE_NODE (var));\n   /* A single use means there is one item in the list.  */\n   return (ptr != ptr->next && ptr == ptr->next->next);\n@@ -426,7 +426,7 @@ has_single_use (tree var)\n static inline bool\n single_imm_use (tree var, use_operand_p *use_p, tree *stmt)\n {\n-  ssa_imm_use_t *ptr;\n+  ssa_use_operand_t *ptr;\n \n   ptr = &(SSA_NAME_IMM_USE_NODE (var));\n   if (ptr != ptr->next && ptr == ptr->next->next)\n@@ -444,7 +444,7 @@ single_imm_use (tree var, use_operand_p *use_p, tree *stmt)\n static inline unsigned int\n num_imm_uses (tree var)\n {\n-  ssa_imm_use_t *ptr, *start;\n+  ssa_use_operand_t *ptr, *start;\n   unsigned int num;\n \n   start = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -455,46 +455,6 @@ num_imm_uses (tree var)\n   return num;\n }\n \n-/* Return the definitions present in ANN, a statement annotation.\n-   Return NULL if this annotation contains no definitions.  */\n-static inline def_optype\n-get_def_ops (stmt_ann_t ann)\n-{\n-  return ann ? ann->operands.def_ops : NULL;\n-}\n-\n-/* Return the uses present in ANN, a statement annotation.\n-   Return NULL if this annotation contains no uses.  */\n-static inline use_optype\n-get_use_ops (stmt_ann_t ann)\n-{\n-  return ann ? ann->operands.use_ops : NULL;\n-}\n-\n-/* Return the virtual may-defs present in ANN, a statement\n-   annotation.\n-   Return NULL if this annotation contains no virtual may-defs.  */\n-static inline v_may_def_optype\n-get_v_may_def_ops (stmt_ann_t ann)\n-{\n-  return ann ? ann->operands.v_may_def_ops : NULL;\n-}\n-\n-/* Return the virtual uses present in ANN, a statement annotation.\n-   Return NULL if this annotation contains no virtual uses.  */\n-static inline vuse_optype\n-get_vuse_ops (stmt_ann_t ann)\n-{\n-  return ann ? ann->operands.vuse_ops : NULL;\n-}\n-\n-/* Return the virtual must-defs present in ANN, a statement\n-   annotation.  Return NULL if this annotation contains no must-defs.*/\n-static inline v_must_def_optype\n-get_v_must_def_ops (stmt_ann_t ann)\n-{\n-  return ann ? ann->operands.v_must_def_ops : NULL;\n-}\n \n /* Return the tree pointer to by USE.  */ \n static inline tree\n@@ -507,80 +467,14 @@ get_use_from_ptr (use_operand_p use)\n static inline tree\n get_def_from_ptr (def_operand_p def)\n {\n-  return *(def.def);\n-}\n-\n-/* Return a pointer to the tree that is at INDEX in the USES array.  */\n-static inline use_operand_p\n-get_use_op_ptr (use_optype uses, unsigned int index)\n-{\n-  gcc_assert (index < uses->num_uses);\n-  return &(uses->uses[index]);\n-}\n-\n-/* Return a def_operand_p pointer for element INDEX of DEFS.  */\n-static inline def_operand_p\n-get_def_op_ptr (def_optype defs, unsigned int index)\n-{\n-  gcc_assert (index < defs->num_defs);\n-  return defs->defs[index];\n-}\n-\n-/* Return the def_operand_p that is the V_MAY_DEF_RESULT for the V_MAY_DEF\n-   at INDEX in the V_MAY_DEFS array.  */\n-static inline def_operand_p\n-get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n-{\n-  def_operand_p op;\n-  gcc_assert (index < v_may_defs->num_v_may_defs);\n-  op.def = &(v_may_defs->v_may_defs[index].def);\n-  return op;\n-}\n-\n-/* Return a use_operand_p that is the V_MAY_DEF_OP for the V_MAY_DEF at\n-   INDEX in the V_MAY_DEFS array.  */\n-static inline use_operand_p\n-get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n-{\n-  gcc_assert (index < v_may_defs->num_v_may_defs);\n-  return &(v_may_defs->v_may_defs[index].imm_use);\n-}\n-\n-/* Return a use_operand_p that is at INDEX in the VUSES array.  */\n-static inline use_operand_p\n-get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n-{\n-  gcc_assert (index < vuses->num_vuses);\n-  return &(vuses->vuses[index].imm_use);\n-}\n-\n-/* Return a def_operand_p that is the V_MUST_DEF_RESULT for the\n-   V_MUST_DEF at INDEX in the V_MUST_DEFS array.  */\n-static inline def_operand_p\n-get_v_must_def_result_ptr (v_must_def_optype v_must_defs, unsigned int index)\n-{\n-  def_operand_p op;\n-  gcc_assert (index < v_must_defs->num_v_must_defs);\n-  op.def = &(v_must_defs->v_must_defs[index].def);\n-  return op;\n-}\n-\n-/* Return a use_operand_p that is the V_MUST_DEF_KILL for the \n-   V_MUST_DEF at INDEX in the V_MUST_DEFS array.  */\n-static inline use_operand_p\n-get_v_must_def_kill_ptr (v_must_def_optype v_must_defs, unsigned int index)\n-{\n-  gcc_assert (index < v_must_defs->num_v_must_defs);\n-  return &(v_must_defs->v_must_defs[index].imm_use);\n+  return *def;\n }\n \n /* Return a def_operand_p pointer for the result of PHI.  */\n static inline def_operand_p\n get_phi_result_ptr (tree phi)\n {\n-  def_operand_p op;\n-  op.def = &(PHI_RESULT_TREE (phi));\n-  return op;\n+  return &(PHI_RESULT_TREE (phi));\n }\n \n /* Return a use_operand_p pointer for argument I of phinode PHI.  */\n@@ -590,29 +484,6 @@ get_phi_arg_def_ptr (tree phi, int i)\n   return &(PHI_ARG_IMM_USE_NODE (phi,i));\n }\n \n-/* Delink all immediate_use information for STMT.  */\n-static inline void\n-delink_stmt_imm_use (tree stmt)\n-{\n-   unsigned int x;\n-   use_optype uses = STMT_USE_OPS (stmt);\n-   vuse_optype vuses = STMT_VUSE_OPS (stmt);\n-   v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-   v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-\n-   for (x = 0; x < NUM_USES (uses); x++)\n-     delink_imm_use (&(uses->uses[x]));\n-\n-   for (x = 0; x < NUM_VUSES (vuses); x++)\n-     delink_imm_use (&(vuses->vuses[x].imm_use));\n-\n-   for (x = 0; x < NUM_V_MAY_DEFS (v_may_defs); x++)\n-     delink_imm_use (&(v_may_defs->v_may_defs[x].imm_use));\n-\n-   for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n-     delink_imm_use (&(v_must_defs->v_must_defs[x].imm_use));\n-}\n-\n \n /* Return the bitmap of addresses taken by STMT, or NULL if it takes\n    no addresses.  */\n@@ -963,23 +834,37 @@ op_iter_done (ssa_op_iter *ptr)\n static inline use_operand_p\n op_iter_next_use (ssa_op_iter *ptr)\n {\n-  if (ptr->use_i < ptr->num_use)\n+  use_operand_p use_p;\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (ptr->iter_type == ssa_op_iter_use);\n+#endif\n+  if (ptr->uses)\n     {\n-      return USE_OP_PTR (ptr->ops->use_ops, (ptr->use_i)++);\n+      use_p = USE_OP_PTR (ptr->uses);\n+      ptr->uses = ptr->uses->next;\n+      return use_p;\n     }\n-  if (ptr->vuse_i < ptr->num_vuse)\n+  if (ptr->vuses)\n     {\n-      return VUSE_OP_PTR (ptr->ops->vuse_ops, (ptr->vuse_i)++);\n+      use_p = VUSE_OP_PTR (ptr->vuses);\n+      ptr->vuses = ptr->vuses->next;\n+      return use_p;\n     }\n-  if (ptr->v_mayu_i < ptr->num_v_mayu)\n+  if (ptr->mayuses)\n     {\n-      return V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops,\n-\t\t\t       (ptr->v_mayu_i)++);\n+      use_p = MAYDEF_OP_PTR (ptr->mayuses);\n+      ptr->mayuses = ptr->mayuses->next;\n+      return use_p;\n     }\n-  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+  if (ptr->mustkills)\n     {\n-      return V_MUST_DEF_KILL_PTR (ptr->ops->v_must_def_ops,\n-\t\t\t\t  (ptr->v_mustu_i)++);\n+      use_p = MUSTDEF_KILL_PTR (ptr->mustkills);\n+      ptr->mustkills = ptr->mustkills->next;\n+      return use_p;\n+    }\n+  if (ptr->phi_i < ptr->num_phi)\n+    {\n+      return PHI_ARG_DEF_PTR (ptr->phi_stmt, (ptr->phi_i)++);\n     }\n   ptr->done = true;\n   return NULL_USE_OPERAND_P;\n@@ -989,19 +874,27 @@ op_iter_next_use (ssa_op_iter *ptr)\n static inline def_operand_p\n op_iter_next_def (ssa_op_iter *ptr)\n {\n-  if (ptr->def_i < ptr->num_def)\n+  def_operand_p def_p;\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (ptr->iter_type == ssa_op_iter_def);\n+#endif\n+  if (ptr->defs)\n     {\n-      return DEF_OP_PTR (ptr->ops->def_ops, (ptr->def_i)++);\n+      def_p = DEF_OP_PTR (ptr->defs);\n+      ptr->defs = ptr->defs->next;\n+      return def_p;\n     }\n-  if (ptr->v_mustd_i < ptr->num_v_mustd)\n+  if (ptr->mustdefs)\n     {\n-      return V_MUST_DEF_RESULT_PTR (ptr->ops->v_must_def_ops, \n-\t\t\t\t\t(ptr->v_mustd_i)++);\n+      def_p = MUSTDEF_RESULT_PTR (ptr->mustdefs);\n+      ptr->mustdefs = ptr->mustdefs->next;\n+      return def_p;\n     }\n-  if (ptr->v_mayd_i < ptr->num_v_mayd)\n+  if (ptr->maydefs)\n     {\n-      return V_MAY_DEF_RESULT_PTR (ptr->ops->v_may_def_ops,\n-\t\t\t\t\t   (ptr->v_mayd_i)++);\n+      def_p = MAYDEF_RESULT_PTR (ptr->maydefs);\n+      ptr->maydefs = ptr->maydefs->next;\n+      return def_p;\n     }\n   ptr->done = true;\n   return NULL_DEF_OPERAND_P;\n@@ -1011,68 +904,100 @@ op_iter_next_def (ssa_op_iter *ptr)\n static inline tree\n op_iter_next_tree (ssa_op_iter *ptr)\n {\n-  if (ptr->use_i < ptr->num_use)\n+  tree val;\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (ptr->iter_type == ssa_op_iter_tree);\n+#endif\n+  if (ptr->uses)\n     {\n-      return USE_OP (ptr->ops->use_ops, (ptr->use_i)++);\n+      val = USE_OP (ptr->uses);\n+      ptr->uses = ptr->uses->next;\n+      return val;\n     }\n-  if (ptr->vuse_i < ptr->num_vuse)\n+  if (ptr->vuses)\n     {\n-      return VUSE_OP (ptr->ops->vuse_ops, (ptr->vuse_i)++);\n+      val = VUSE_OP (ptr->vuses);\n+      ptr->vuses = ptr->vuses->next;\n+      return val;\n     }\n-  if (ptr->v_mayu_i < ptr->num_v_mayu)\n+  if (ptr->mayuses)\n     {\n-      return V_MAY_DEF_OP (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n+      val = MAYDEF_OP (ptr->mayuses);\n+      ptr->mayuses = ptr->mayuses->next;\n+      return val;\n     }\n-  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+  if (ptr->mustkills)\n     {\n-      return V_MUST_DEF_KILL (ptr->ops->v_must_def_ops, (ptr->v_mustu_i)++);\n+      val = MUSTDEF_KILL (ptr->mustkills);\n+      ptr->mustkills = ptr->mustkills->next;\n+      return val;\n     }\n-  if (ptr->def_i < ptr->num_def)\n+  if (ptr->defs)\n     {\n-      return DEF_OP (ptr->ops->def_ops, (ptr->def_i)++);\n+      val = DEF_OP (ptr->defs);\n+      ptr->defs = ptr->defs->next;\n+      return val;\n     }\n-  if (ptr->v_mustd_i < ptr->num_v_mustd)\n+  if (ptr->mustdefs)\n     {\n-      return V_MUST_DEF_RESULT (ptr->ops->v_must_def_ops, \n-\t\t\t\t\t(ptr->v_mustd_i)++);\n+      val = MUSTDEF_RESULT (ptr->mustdefs);\n+      ptr->mustdefs = ptr->mustdefs->next;\n+      return val;\n     }\n-  if (ptr->v_mayd_i < ptr->num_v_mayd)\n+  if (ptr->maydefs)\n     {\n-      return V_MAY_DEF_RESULT (ptr->ops->v_may_def_ops,\n-\t\t\t\t\t   (ptr->v_mayd_i)++);\n+      val = MAYDEF_RESULT (ptr->maydefs);\n+      ptr->maydefs = ptr->maydefs->next;\n+      return val;\n     }\n+\n+  ptr->done = true;\n+  return NULL_TREE;\n+\n+}\n+\n+\n+/* This functiins clears the iterator PTR, and marks it done.  This is normally\n+   used to prevent warnings in the compile about might be uninitailzied\n+   components.  */\n+\n+static inline void\n+clear_and_done_ssa_iter (ssa_op_iter *ptr)\n+{\n+  ptr->defs = NULL;\n+  ptr->uses = NULL;\n+  ptr->vuses = NULL;\n+  ptr->maydefs = NULL;\n+  ptr->mayuses = NULL;\n+  ptr->mustdefs = NULL;\n+  ptr->mustkills = NULL;\n+  ptr->iter_type = ssa_op_iter_none;\n+  ptr->phi_i = 0;\n+  ptr->num_phi = 0;\n+  ptr->phi_stmt = NULL_TREE;\n   ptr->done = true;\n-  return NULL;\n }\n \n /* Initialize the iterator PTR to the virtual defs in STMT.  */\n static inline void\n op_iter_init (ssa_op_iter *ptr, tree stmt, int flags)\n {\n-  stmt_operands_p ops;\n-  stmt_ann_t ann = get_stmt_ann (stmt);\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (stmt_ann (stmt));\n+#endif\n \n-  ops = &(ann->operands);\n+  ptr->defs = (flags & SSA_OP_DEF) ? DEF_OPS (stmt) : NULL;\n+  ptr->uses = (flags & SSA_OP_USE) ? USE_OPS (stmt) : NULL;\n+  ptr->vuses = (flags & SSA_OP_VUSE) ? VUSE_OPS (stmt) : NULL;\n+  ptr->maydefs = (flags & SSA_OP_VMAYDEF) ? MAYDEF_OPS (stmt) : NULL;\n+  ptr->mayuses = (flags & SSA_OP_VMAYUSE) ? MAYDEF_OPS (stmt) : NULL;\n+  ptr->mustdefs = (flags & SSA_OP_VMUSTDEF) ? MUSTDEF_OPS (stmt) : NULL;\n+  ptr->mustkills = (flags & SSA_OP_VMUSTKILL) ? MUSTDEF_OPS (stmt) : NULL;\n   ptr->done = false;\n-  ptr->ops = ops;\n-  ptr->num_def = (flags & SSA_OP_DEF) ? NUM_DEFS (ops->def_ops) : 0;\n-  ptr->num_use = (flags & SSA_OP_USE) ? NUM_USES (ops->use_ops) : 0;\n-  ptr->num_vuse = (flags & SSA_OP_VUSE) ? NUM_VUSES (ops->vuse_ops) : 0;\n-  ptr->num_v_mayu = (flags & SSA_OP_VMAYUSE)\n-\t\t     ?  NUM_V_MAY_DEFS (ops->v_may_def_ops) : 0;\n-  ptr->num_v_mayd = (flags & SSA_OP_VMAYDEF) \n-\t\t     ?  NUM_V_MAY_DEFS (ops->v_may_def_ops) : 0;\n-  ptr->num_v_mustu = (flags & SSA_OP_VMUSTDEFKILL)\n-                     ? NUM_V_MUST_DEFS (ops->v_must_def_ops) : 0;\n-  ptr->num_v_mustd = (flags & SSA_OP_VMUSTDEF) \n-\t\t     ? NUM_V_MUST_DEFS (ops->v_must_def_ops) : 0;\n-  ptr->def_i = 0;\n-  ptr->use_i = 0;\n-  ptr->vuse_i = 0;\n-  ptr->v_mayu_i = 0;\n-  ptr->v_mayd_i = 0;\n-  ptr->v_mustu_i = 0;\n-  ptr->v_mustd_i = 0;\n+\n+  ptr->phi_i = 0;\n+  ptr->num_phi = 0;\n+  ptr->phi_stmt = NULL_TREE;\n }\n \n /* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n@@ -1081,6 +1006,7 @@ static inline use_operand_p\n op_iter_init_use (ssa_op_iter *ptr, tree stmt, int flags)\n {\n   op_iter_init (ptr, stmt, flags);\n+  ptr->iter_type = ssa_op_iter_use;\n   return op_iter_next_use (ptr);\n }\n \n@@ -1090,6 +1016,7 @@ static inline def_operand_p\n op_iter_init_def (ssa_op_iter *ptr, tree stmt, int flags)\n {\n   op_iter_init (ptr, stmt, flags);\n+  ptr->iter_type = ssa_op_iter_def;\n   return op_iter_next_def (ptr);\n }\n \n@@ -1099,85 +1026,53 @@ static inline tree\n op_iter_init_tree (ssa_op_iter *ptr, tree stmt, int flags)\n {\n   op_iter_init (ptr, stmt, flags);\n+  ptr->iter_type = ssa_op_iter_tree;\n   return op_iter_next_tree (ptr);\n }\n \n /* Get the next iterator mustdef value for PTR, returning the mustdef values in\n    KILL and DEF.  */\n static inline void\n-op_iter_next_mustdef (use_operand_p *kill, def_operand_p *def, ssa_op_iter *ptr)\n+op_iter_next_maymustdef (use_operand_p *use, def_operand_p *def, \n+\t\t\t ssa_op_iter *ptr)\n {\n-  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (ptr->iter_type == ssa_op_iter_maymustdef);\n+#endif\n+  if (ptr->mayuses)\n     {\n-      *def = V_MUST_DEF_RESULT_PTR (ptr->ops->v_must_def_ops, ptr->v_mustu_i);\n-      *kill = V_MUST_DEF_KILL_PTR (ptr->ops->v_must_def_ops, (ptr->v_mustu_i)++);\n+      *def = MAYDEF_RESULT_PTR (ptr->mayuses);\n+      *use = MAYDEF_OP_PTR (ptr->mayuses);\n+      ptr->mayuses = ptr->mayuses->next;\n       return;\n     }\n-  else\n-    {\n-      *def = NULL_DEF_OPERAND_P;\n-      *kill = NULL_USE_OPERAND_P;\n-    }\n-  ptr->done = true;\n-  return;\n-}\n \n-/* Get the next iterator maydef value for PTR, returning the maydef values in\n-   USE and DEF.  */\n-static inline void\n-op_iter_next_maydef (use_operand_p *use, def_operand_p *def, ssa_op_iter *ptr)\n-{\n-  if (ptr->v_mayu_i < ptr->num_v_mayu)\n+  if (ptr->mustkills)\n     {\n-      *def = V_MAY_DEF_RESULT_PTR (ptr->ops->v_may_def_ops, ptr->v_mayu_i);\n-      *use = V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n+      *def = MUSTDEF_RESULT_PTR (ptr->mustkills);\n+      *use = MUSTDEF_KILL_PTR (ptr->mustkills);\n+      ptr->mustkills = ptr->mustkills->next;\n       return;\n     }\n-  else\n-    {\n-      *def = NULL_DEF_OPERAND_P;\n-      *use = NULL_USE_OPERAND_P;\n-    }\n-  ptr->done = true;\n-  return;\n-}\n \n-/* Get the next iterator mustdef or maydef value for PTR, returning the\n-   mustdef or maydef values in KILL and DEF.  */\n-static inline void\n-op_iter_next_must_and_may_def (use_operand_p *kill,\n-\t\t\t       def_operand_p *def,\n-\t\t\t       ssa_op_iter *ptr)\n-{\n-  if (ptr->v_mustu_i < ptr->num_v_mustu)\n-    {\n-      *def = V_MUST_DEF_RESULT_PTR (ptr->ops->v_must_def_ops, ptr->v_mustu_i);\n-      *kill = V_MUST_DEF_KILL_PTR (ptr->ops->v_must_def_ops, (ptr->v_mustu_i)++);\n-      return;\n-    }\n-  else if (ptr->v_mayu_i < ptr->num_v_mayu)\n-    {\n-      *def = V_MAY_DEF_RESULT_PTR (ptr->ops->v_may_def_ops, ptr->v_mayu_i);\n-      *kill = V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n-      return;\n-    }\n-  else\n-    {\n-      *def = NULL_DEF_OPERAND_P;\n-      *kill = NULL_USE_OPERAND_P;\n-    }\n+  *def = NULL_DEF_OPERAND_P;\n+  *use = NULL_USE_OPERAND_P;\n   ptr->done = true;\n   return;\n }\n \n+\n /* Initialize iterator PTR to the operands in STMT.  Return the first operands\n    in USE and DEF.  */\n static inline void\n op_iter_init_maydef (ssa_op_iter *ptr, tree stmt, use_operand_p *use, \n \t\t     def_operand_p *def)\n {\n+  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n+\n   op_iter_init (ptr, stmt, SSA_OP_VMAYUSE);\n-  op_iter_next_maydef (use, def, ptr);\n+  ptr->iter_type = ssa_op_iter_maymustdef;\n+  op_iter_next_maymustdef (use, def, ptr);\n }\n \n \n@@ -1187,8 +1082,11 @@ static inline void\n op_iter_init_mustdef (ssa_op_iter *ptr, tree stmt, use_operand_p *kill, \n \t\t     def_operand_p *def)\n {\n-  op_iter_init (ptr, stmt, SSA_OP_VMUSTDEFKILL);\n-  op_iter_next_mustdef (kill, def, ptr);\n+  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n+\n+  op_iter_init (ptr, stmt, SSA_OP_VMUSTKILL);\n+  ptr->iter_type = ssa_op_iter_maymustdef;\n+  op_iter_next_maymustdef (kill, def, ptr);\n }\n \n /* Initialize iterator PTR to the operands in STMT.  Return the first operands\n@@ -1197,10 +1095,241 @@ static inline void\n op_iter_init_must_and_may_def (ssa_op_iter *ptr, tree stmt,\n \t\t\t       use_operand_p *kill, def_operand_p *def)\n {\n-  op_iter_init (ptr, stmt, SSA_OP_VMUSTDEFKILL | SSA_OP_VMAYUSE);\n-  op_iter_next_must_and_may_def (kill, def, ptr);\n+  gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n+\n+  op_iter_init (ptr, stmt, SSA_OP_VMUSTKILL|SSA_OP_VMAYUSE);\n+  ptr->iter_type = ssa_op_iter_maymustdef;\n+  op_iter_next_maymustdef (kill, def, ptr);\n+}\n+\n+\n+/* If there is a single opernad in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  PTR is the iterator to use.  */\n+static inline tree\n+single_ssa_tree_operand (tree stmt, int flags)\n+{\n+  tree var;\n+  ssa_op_iter iter;\n+\n+  var = op_iter_init_tree (&iter, stmt, flags);\n+  if (op_iter_done (&iter))\n+    return NULL_TREE;\n+  op_iter_next_tree (&iter);\n+  if (op_iter_done (&iter))\n+    return var;\n+  return NULL_TREE;\n+}\n+\n+\n+/* If there is a single opernad in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  PTR is the iterator to use.  */\n+static inline use_operand_p\n+single_ssa_use_operand (tree stmt, int flags)\n+{\n+  use_operand_p var;\n+  ssa_op_iter iter;\n+\n+  var = op_iter_init_use (&iter, stmt, flags);\n+  if (op_iter_done (&iter))\n+    return NULL_USE_OPERAND_P;\n+  op_iter_next_use (&iter);\n+  if (op_iter_done (&iter))\n+    return var;\n+  return NULL_USE_OPERAND_P;\n+}\n+\n+\n+\n+/* If there is a single opernad in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  PTR is the iterator to use.  */\n+static inline def_operand_p\n+single_ssa_def_operand (tree stmt, int flags)\n+{\n+  def_operand_p var;\n+  ssa_op_iter iter;\n+\n+  var = op_iter_init_def (&iter, stmt, flags);\n+  if (op_iter_done (&iter))\n+    return NULL_DEF_OPERAND_P;\n+  op_iter_next_def (&iter);\n+  if (op_iter_done (&iter))\n+    return var;\n+  return NULL_DEF_OPERAND_P;\n+}\n+\n+\n+/* If there is a single opernad in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  PTR is the iterator to use.  */\n+static inline bool\n+zero_ssa_operands (tree stmt, int flags)\n+{\n+  ssa_op_iter iter;\n+\n+  op_iter_init_tree (&iter, stmt, flags);\n+  return op_iter_done (&iter);\n }\n \n+\n+/* Return the  number of opernads mathcing FLAGS in STMT.  */\n+static inline int\n+num_ssa_operands (tree stmt, int flags)\n+{\n+  ssa_op_iter iter;\n+  int num = 0;\n+\n+  op_iter_init (&iter, stmt, flags);\n+  for ( ; iter.defs; iter.defs = iter.defs->next)\n+    num++;\n+  for ( ; iter.uses; iter.uses = iter.uses->next)\n+    num++;\n+  for ( ; iter.vuses; iter.vuses = iter.vuses->next)\n+    num++;\n+  for ( ; iter.maydefs; iter.maydefs = iter.maydefs->next)\n+    num++;\n+  for ( ; iter.mayuses; iter.mayuses = iter.mayuses->next)\n+    num++;\n+  for ( ; iter.mustdefs; iter.mustdefs = iter.mustdefs->next)\n+    num++;\n+  for ( ; iter.mustkills; iter.mustkills = iter.mustkills->next)\n+    num++;\n+\n+  return num;\n+}\n+\n+\n+/* Delink all immediate_use information for STMT.  */\n+static inline void\n+delink_stmt_imm_use (tree stmt)\n+{\n+   ssa_op_iter iter;\n+   use_operand_p use_p;\n+\n+   if (ssa_operands_active ())\n+     FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n+\t\t\t       (SSA_OP_ALL_USES | SSA_OP_ALL_KILLS))\n+       delink_imm_use (use_p);\n+}\n+\n+\n+/* This routine will compare all the operands matching FLAGS in STMT1 to those\n+   in STMT2.  TRUE is returned if they are the same.  STMTs can be NULL.  */\n+static inline bool\n+compare_ssa_operands_equal (tree stmt1, tree stmt2, int flags)\n+{\n+  ssa_op_iter iter1, iter2;\n+  tree op1 = NULL_TREE;\n+  tree op2 = NULL_TREE;\n+  bool look1, look2;\n+\n+  if (stmt1 == stmt2)\n+    return true;\n+\n+  look1 = stmt1 && stmt_ann (stmt1);\n+  look2 = stmt2 && stmt_ann (stmt2);\n+\n+  if (look1)\n+    {\n+      op1 = op_iter_init_tree (&iter1, stmt1, flags);\n+      if (!look2)\n+        return op_iter_done (&iter1);\n+    }\n+  else\n+    clear_and_done_ssa_iter (&iter1);\n+\n+  if (look2)\n+    {\n+      op2 = op_iter_init_tree (&iter2, stmt2, flags);\n+      if (!look1)\n+        return op_iter_done (&iter2);\n+    }\n+  else\n+    clear_and_done_ssa_iter (&iter2);\n+\n+  while (!op_iter_done (&iter1) && !op_iter_done (&iter2))\n+    {\n+      if (op1 != op2)\n+\treturn false;\n+      op1 = op_iter_next_tree (&iter1);\n+      op2 = op_iter_next_tree (&iter2);\n+    }\n+\n+  return (op_iter_done (&iter1) && op_iter_done (&iter2));\n+}\n+\n+\n+/* If there is a single DEF in the PHI node which matches FLAG, return it.\n+   Otherwise return NULL_DEF_OPERAND_P.  */\n+static inline tree\n+single_phi_def (tree stmt, int flags)\n+{\n+  tree def = PHI_RESULT (stmt);\n+  if ((flags & SSA_OP_DEF) && is_gimple_reg (def)) \n+    return def;\n+  if ((flags & SSA_OP_VIRTUAL_DEFS) && !is_gimple_reg (def))\n+    return def;\n+  return NULL_TREE;\n+}\n+\n+/* Initialize the iterator PTR for uses matching FLAGS in PHI.  FLAGS should\n+   be either SSA_OP_USES or SAS_OP_VIRTUAL_USES.  */\n+static inline use_operand_p\n+op_iter_init_phiuse (ssa_op_iter *ptr, tree phi, int flags)\n+{\n+  tree phi_def = PHI_RESULT (phi);\n+  int comp;\n+\n+  clear_and_done_ssa_iter (ptr);\n+  ptr->done = false;\n+\n+  gcc_assert ((flags & (SSA_OP_USE | SSA_OP_VIRTUAL_USES)) != 0);\n+\n+  comp = (is_gimple_reg (phi_def) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n+    \n+  /* if the PHI node deosn't the operand type we care about, we're done.  */\n+  if ((flags & comp) == 0)\n+    {\n+      ptr->done = true;\n+      return NULL_USE_OPERAND_P;\n+    }\n+\n+  ptr->phi_stmt = phi;\n+  ptr->num_phi = PHI_NUM_ARGS (phi);\n+  ptr->iter_type = ssa_op_iter_use;\n+  return op_iter_next_use (ptr);\n+}\n+\n+\n+/* Start an iterator for a PHI defintion.  */\n+\n+static inline def_operand_p\n+op_iter_init_phidef (ssa_op_iter *ptr, tree phi, int flags)\n+{\n+  tree phi_def = PHI_RESULT (phi);\n+  int comp;\n+\n+  clear_and_done_ssa_iter (ptr);\n+  ptr->done = false;\n+\n+  gcc_assert ((flags & (SSA_OP_DEF | SSA_OP_VIRTUAL_DEFS)) != 0);\n+\n+  comp = (is_gimple_reg (phi_def) ? SSA_OP_DEF : SSA_OP_VIRTUAL_DEFS);\n+    \n+  /* if the PHI node deosn't the operand type we care about, we're done.  */\n+  if ((flags & comp) == 0)\n+    {\n+      ptr->done = true;\n+      return NULL_USE_OPERAND_P;\n+    }\n+\n+  ptr->iter_type = ssa_op_iter_def;\n+  /* The first call to op_iter_next_def will terminate the iterator since\n+     all the fields are NULL.  Simply return the result here as the first and\n+     therefore only result.  */\n+  return PHI_RESULT_PTR (phi);\n+}\n+\n+\n+\n /* Return true if VAR cannot be modified by the program.  */\n \n static inline bool"}, {"sha": "3d946a696f9165854eb9d9cb0a52f21982136672", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -264,9 +264,9 @@ struct var_ann_d GTY(())\n \n typedef struct immediate_use_iterator_d\n {\n-  ssa_imm_use_t *imm_use;\n-  ssa_imm_use_t *end_p;\n-  ssa_imm_use_t iter_node;\n+  ssa_use_operand_t *imm_use;\n+  ssa_use_operand_t *end_p;\n+  ssa_use_operand_t iter_node;\n } imm_use_iterator;\n \n \n@@ -315,7 +315,7 @@ struct stmt_ann_d GTY(())\n   basic_block GTY ((skip (\"\"))) bb;\n \n   /* Operand cache for stmt.  */\n-  struct stmt_operands_d operands;\n+  struct stmt_operands_d GTY ((skip (\"\"))) operands;\n \n   /* Set of variables that have had their address taken in the statement.  */\n   bitmap addresses_taken;\n@@ -362,10 +362,6 @@ static inline int get_lineno (tree);\n static inline const char *get_filename (tree);\n static inline bool is_exec_stmt (tree);\n static inline bool is_label_stmt (tree);\n-static inline v_may_def_optype get_v_may_def_ops (stmt_ann_t);\n-static inline vuse_optype get_vuse_ops (stmt_ann_t);\n-static inline use_optype get_use_ops (stmt_ann_t);\n-static inline def_optype get_def_ops (stmt_ann_t);\n static inline bitmap addresses_taken (tree);\n static inline void set_default_def (tree, tree);\n static inline tree default_def (tree);\n@@ -765,10 +761,10 @@ void print_value_expressions (FILE *, tree);\n /* In tree-vn.c  */\n bool expressions_equal_p (tree, tree);\n tree get_value_handle (tree);\n-hashval_t vn_compute (tree, hashval_t, vuse_optype);\n-tree vn_lookup_or_add (tree, vuse_optype);\n-void vn_add (tree, tree, vuse_optype);\n-tree vn_lookup (tree, vuse_optype);\n+hashval_t vn_compute (tree, hashval_t, tree);\n+tree vn_lookup_or_add (tree, tree);\n+void vn_add (tree, tree, tree);\n+tree vn_lookup (tree, tree);\n void vn_init (void);\n void vn_delete (void);\n "}, {"sha": "962e1c1a7f1790232525e5be1923de29a56c4e6a", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -616,7 +616,7 @@ add_new_name_mapping (tree new, tree old)\n    for every variable in the function.  For every statement S in block\n    BB:\n \n-   1- Variables defined by S in DEF_OPS(S) are marked in the bitmap\n+   1- Variables defined by S in the DEFS of S are marked in the bitmap\n       WALK_DATA->GLOBAL_DATA->KILLS.\n \n    2- If S uses a variable VAR and there is no preceding kill of VAR,\n@@ -648,7 +648,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n-\t\t\t    SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n+\t\t\t    SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTKILL)\n     {\n       tree sym = USE_FROM_PTR (use_p);\n       gcc_assert (DECL_P (sym));"}, {"sha": "bff48d621b9f667617210428e4176198bd2e40e6", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 39, "deletions": 67, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1444,35 +1444,25 @@ add_dependance (temp_expr_table_p tab, int version, tree var)\n static bool\n check_replaceable (temp_expr_table_p tab, tree stmt)\n {\n-  stmt_ann_t ann;\n-  vuse_optype vuseops;\n-  def_optype defs;\n-  use_optype uses;\n   tree var, def;\n-  int num_use_ops, version;\n+  int version;\n   var_map map = tab->map;\n   ssa_op_iter iter;\n   tree call_expr;\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n   \n-  ann = stmt_ann (stmt);\n-  defs = DEF_OPS (ann);\n-\n   /* Punt if there is more than 1 def, or more than 1 use.  */\n-  if (NUM_DEFS (defs) != 1)\n-    return false;\n-  def = DEF_OP (defs, 0);\n-  if (version_ref_count (map, def) != 1)\n+  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+  if (!def)\n     return false;\n \n-  /* There must be no V_MAY_DEFS.  */\n-  if (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) != 0)\n+  if (version_ref_count (map, def) != 1)\n     return false;\n \n-  /* There must be no V_MUST_DEFS.  */\n-  if (NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) != 0)\n+  /* There must be no V_MAY_DEFS or V_MUST_DEFS.  */\n+  if (!(ZERO_SSA_OPERANDS (stmt, (SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF))))\n     return false;\n \n   /* Float expressions must go through memory if float-store is on.  */\n@@ -1488,21 +1478,6 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n \treturn false;\n     }\n \n-  uses = USE_OPS (ann);\n-  num_use_ops = NUM_USES (uses);\n-  vuseops = VUSE_OPS (ann);\n-\n-  /* Any expression which has no virtual operands and no real operands\n-     should have been propagated if it's possible to do anything with them. \n-     If this happens here, it probably exists that way for a reason, so we \n-     won't touch it.   An example is:\n-         b_4 = &tab\n-     There are no virtual uses nor any real uses, so we just leave this \n-     alone to be safe.  */\n-\n-  if (num_use_ops == 0 && NUM_VUSES (vuseops) == 0)\n-    return false;\n-\n   version = SSA_NAME_VERSION (def);\n \n   /* Add this expression to the dependency list for each use partition.  */\n@@ -1512,7 +1487,7 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n     }\n \n   /* If there are VUSES, add a dependence on virtual defs.  */\n-  if (NUM_VUSES (vuseops) != 0)\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n     {\n       add_value_to_list (tab, (value_expr_p *)&(tab->version_info[version]), \n \t\t\t VIRTUAL_PARTITION (tab));\n@@ -1687,12 +1662,8 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t  free_value_expr (tab, p);\n \t}\n \n-      /* A V_MAY_DEF kills any expression using a virtual operand.  */\n-      if (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0)\n-        kill_virtual_exprs (tab, true);\n-\t\n-      /* A V_MUST_DEF kills any expression using a virtual operand.  */\n-      if (NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0)\n+      /* A V_{MAY,MUST}_DEF kills any expression using a virtual operand.  */\n+      if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n         kill_virtual_exprs (tab, true);\n     }\n }\n@@ -1743,7 +1714,8 @@ dump_replaceable_exprs (FILE *f, tree *expr)\n     if (expr[x])\n       {\n         stmt = expr[x];\n-\tvar = DEF_OP (STMT_DEF_OPS (stmt), 0);\n+\tvar = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+\tgcc_assert (var != NULL_TREE);\n \tprint_generic_expr (f, var, TDF_SLIM);\n \tfprintf (f, \" replace with --> \");\n \tprint_generic_expr (f, TREE_OPERAND (stmt, 1), TDF_SLIM);\n@@ -1874,13 +1846,11 @@ rewrite_trees (var_map map, tree *values)\n     {\n       for (si = bsi_start (bb); !bsi_end_p (si); )\n \t{\n-\t  size_t num_uses, num_defs;\n-\t  use_optype uses;\n-\t  def_optype defs;\n \t  tree stmt = bsi_stmt (si);\n-\t  use_operand_p use_p;\n+\t  use_operand_p use_p, copy_use_p;\n \t  def_operand_p def_p;\n-\t  int remove = 0, is_copy = 0;\n+\t  bool remove = false, is_copy = false;\n+\t  int num_uses = 0;\n \t  stmt_ann_t ann;\n \t  ssa_op_iter iter;\n \n@@ -1889,44 +1859,46 @@ rewrite_trees (var_map map, tree *values)\n \n \t  if (TREE_CODE (stmt) == MODIFY_EXPR \n \t      && (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME))\n-\t    is_copy = 1;\n+\t    is_copy = true;\n \n-\t  uses = USE_OPS (ann);\n-\t  num_uses = NUM_USES (uses);\n+\t  copy_use_p = NULL_USE_OPERAND_P;\n \t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t    {\n \t      if (replace_use_variable (map, use_p, values))\n-\t        changed = true;\n+\t\tchanged = true;\n+\t      copy_use_p = use_p;\n+\t      num_uses++;\n \t    }\n \n-\t  defs = DEF_OPS (ann);\n-\t  num_defs = NUM_DEFS (defs);\n+\t  if (num_uses != 1)\n+\t    is_copy = false;\n \n-\t  /* Mark this stmt for removal if it is the list of replaceable \n-\t     expressions.  */\n-\t  if (values && num_defs == 1)\n-\t    {\n-\t      tree def = DEF_OP (defs, 0);\n-\t      tree val;\n-\t      val = values[SSA_NAME_VERSION (def)];\n-\t      if (val)\n-\t\tremove = 1;\n-\t    }\n-\t  if (!remove)\n+\t  def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);\n+\n+\t  if (def_p != NULL)\n \t    {\n-\t      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n+\t      /* Mark this stmt for removal if it is the list of replaceable \n+\t\t expressions.  */\n+\t      if (values && values[SSA_NAME_VERSION (DEF_FROM_PTR (def_p))])\n+\t\tremove = true;\n+\t      else\n \t\t{\n \t\t  if (replace_def_variable (map, def_p, NULL))\n \t\t    changed = true;\n-\n \t\t  /* If both SSA_NAMEs coalesce to the same variable,\n \t\t     mark the now redundant copy for removal.  */\n-\t\t  if (is_copy\n-\t\t      && num_uses == 1\n-\t\t      && (DEF_FROM_PTR (def_p) == USE_OP (uses, 0)))\n-\t\t    remove = 1;\n+\t\t  if (is_copy)\n+\t\t    {\n+\t\t      gcc_assert (copy_use_p != NULL_USE_OPERAND_P);\n+\t\t      if (DEF_FROM_PTR (def_p) == USE_FROM_PTR (copy_use_p))\n+\t\t\tremove = true;\n+\t\t    }\n \t\t}\n \t    }\n+\t  else\n+\t    FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n+\t      if (replace_def_variable (map, def_p, NULL))\n+\t\tchanged = true;\n \n \t  /* Remove any stmts marked for removal.  */\n \t  if (remove)"}, {"sha": "ca01c8c52d1b43a3d60a7bc8dc75cb6d19d284b2", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -226,7 +226,7 @@ make_phi_node (tree var, int len)\n \n   for (i = 0; i < capacity; i++)\n     {\n-      ssa_imm_use_t * imm;\n+      use_operand_p  imm;\n       imm = &(PHI_ARG_IMM_USE_NODE (phi, i));\n       imm->use = &(PHI_ARG_DEF_TREE (phi, i));\n       imm->prev = NULL;\n@@ -247,7 +247,7 @@ release_phi_node (tree phi)\n \n   for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n     {\n-      ssa_imm_use_t * imm;\n+      use_operand_p  imm;\n       imm = &(PHI_ARG_IMM_USE_NODE (phi, x));\n       delink_imm_use (imm);\n     }\n@@ -282,7 +282,7 @@ resize_phi_node (tree *phi, int len)\n \n   for (i = 0; i < PHI_NUM_ARGS (new_phi); i++)\n     {\n-      ssa_imm_use_t *imm, *old_imm;\n+      use_operand_p imm, old_imm;\n       imm = &(PHI_ARG_IMM_USE_NODE (new_phi, i));\n       old_imm = &(PHI_ARG_IMM_USE_NODE (*phi, i));\n       imm->use = &(PHI_ARG_DEF_TREE (new_phi, i));\n@@ -293,7 +293,7 @@ resize_phi_node (tree *phi, int len)\n \n   for (i = PHI_NUM_ARGS (new_phi); i < len; i++)\n     {\n-      ssa_imm_use_t * imm;\n+      use_operand_p imm;\n       imm = &(PHI_ARG_IMM_USE_NODE (new_phi, i));\n       imm->use = &(PHI_ARG_DEF_TREE (new_phi, i));\n       imm->prev = NULL;"}, {"sha": "52bf437ff9869c091ff0629dd73f49904b777301", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -2098,6 +2098,9 @@ dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n   use_operand_p kill_p;\n   ssa_op_iter iter;\n \n+  if (!ssa_operands_active ())\n+    return;\n+\n   FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n     {\n       pp_string (buffer, \"#   \");"}, {"sha": "78cd03b7bf5f7aa51569e81fc4024080f261a7fe", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -897,9 +897,7 @@ sra_walk_function (const struct sra_walk_fns *fns)\n \n \t/* If the statement has no virtual operands, then it doesn't\n \t   make any structure references that we care about.  */\n-\tif (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n-\t    && NUM_VUSES (VUSE_OPS (ann)) == 0\n-\t    && NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) == 0)\n+\tif (ZERO_SSA_OPERANDS (stmt, (SSA_OP_VIRTUAL_DEFS | SSA_OP_VUSE)))\n \t  continue;\n \n \tswitch (TREE_CODE (stmt))"}, {"sha": "14b5a3d94647ce581720c581c1ff5dcef6b2ef39", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -457,9 +457,7 @@ likely_value (tree stmt)\n   if (!do_store_ccp\n       && (ann->makes_aliased_stores\n \t  || ann->makes_aliased_loads\n-\t  || NUM_VUSES (VUSE_OPS (ann)) > 0\n-\t  || NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0\n-\t  || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0))\n+\t  || !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS)))\n     return VARYING;\n \n \n@@ -495,8 +493,8 @@ likely_value (tree stmt)\n     }\n \n   if (found_constant\n-      || NUM_USES (USE_OPS (ann)) == 0\n-      || NUM_VUSES (VUSE_OPS (ann)) == 0)\n+      || ZERO_SSA_OPERANDS (stmt, SSA_OP_USE)\n+      || ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n     return CONSTANT;\n \n   return UNDEFINED;\n@@ -934,17 +932,18 @@ ccp_fold (tree stmt)\n \t       == FUNCTION_DECL)\n \t   && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0)))\n     {\n-      use_optype uses = STMT_USE_OPS (stmt);\n-      if (NUM_USES (uses) != 0)\n+      if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_USE))\n \t{\n-\t  tree *orig;\n+\t  tree *orig, var;\n \t  tree fndecl, arglist;\n-\t  size_t i;\n+\t  size_t i = 0;\n+\t  ssa_op_iter iter;\n+\t  use_operand_p var_p;\n \n \t  /* Preserve the original values of every operand.  */\n-\t  orig = xmalloc (sizeof (tree) * NUM_USES (uses));\n-\t  for (i = 0; i < NUM_USES (uses); i++)\n-\t    orig[i] = USE_OP (uses, i);\n+\t  orig = xmalloc (sizeof (tree) *  NUM_SSA_OPERANDS (stmt, SSA_OP_USE));\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n+\t    orig[i++] = var;\n \n \t  /* Substitute operands with their values and try to fold.  */\n \t  replace_uses_in (stmt, NULL, const_val);\n@@ -953,8 +952,9 @@ ccp_fold (tree stmt)\n \t  retval = fold_builtin (fndecl, arglist, false);\n \n \t  /* Restore operands to their original form.  */\n-\t  for (i = 0; i < NUM_USES (uses); i++)\n-\t    SET_USE_OP (uses, i, orig[i]);\n+\t  i = 0;\n+\t  FOR_EACH_SSA_USE_OPERAND (var_p, stmt, iter, SSA_OP_USE)\n+\t    SET_USE (var_p, orig[i++]);\n \t  free (orig);\n \t}\n     }\n@@ -1188,9 +1188,6 @@ visit_cond_stmt (tree stmt, edge *taken_edge_p)\n static enum ssa_prop_result\n ccp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n {\n-  stmt_ann_t ann;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n   tree def;\n   ssa_op_iter iter;\n \n@@ -1201,10 +1198,6 @@ ccp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  ann = stmt_ann (stmt);\n-\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n       /* If the statement is an assignment that produces a single\n@@ -2206,18 +2199,19 @@ convert_to_gimple_builtin (block_stmt_iterator *si_p, tree expr)\n   tmp = get_initialized_tmp_var (expr, &stmts, NULL);\n   pop_gimplify_context (NULL);\n \n+  if (EXPR_HAS_LOCATION (stmt))\n+    annotate_all_with_locus (&stmts, EXPR_LOCATION (stmt));\n+\n   /* The replacement can expose previously unreferenced variables.  */\n   for (ti = tsi_start (stmts); !tsi_end_p (ti); tsi_next (&ti))\n     {\n+      tree new_stmt = tsi_stmt (ti);\n       find_new_referenced_vars (tsi_stmt_ptr (ti));\n-      mark_new_vars_to_rename (tsi_stmt (ti));\n+      bsi_insert_before (si_p, new_stmt, BSI_NEW_STMT);\n+      mark_new_vars_to_rename (bsi_stmt (*si_p));\n+      bsi_next (si_p);\n     }\n \n-  if (EXPR_HAS_LOCATION (stmt))\n-    annotate_all_with_locus (&stmts, EXPR_LOCATION (stmt));\n-\n-  bsi_insert_before (si_p, stmts, BSI_SAME_STMT);\n-\n   return tmp;\n }\n "}, {"sha": "dd4c5debc5ce4e3157791891a62ec34e12a580a3", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -360,9 +360,7 @@ stmt_may_generate_copy (tree stmt)\n   /* If we are not doing store copy-prop, statements with loads and/or\n      stores will never generate a useful copy.  */\n   if (!do_store_copy_prop\n-      && (NUM_VUSES (VUSE_OPS (ann)) > 0\n-\t  || NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0\n-\t  || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0))\n+      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return false;\n \n   /* Otherwise, the only statements that generate useful copies are\n@@ -596,26 +594,31 @@ copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n {\n   enum ssa_prop_result retval;\n   tree cond;\n-  use_optype uses;\n+  use_operand_p use_p;\n+  ssa_op_iter iter;\n+  unsigned num;\n+\n \n   cond = COND_EXPR_COND (stmt);\n-  uses = STMT_USE_OPS (stmt);\n   retval = SSA_PROP_VARYING;\n+  num = NUM_SSA_OPERANDS (stmt, SSA_OP_USE);\n \n   /* The only conditionals that we may be able to compute statically\n      are predicates involving at least one SSA_NAME.  */\n   if (COMPARISON_CLASS_P (cond)\n-      && NUM_USES (uses) >= 1)\n+      && num >= 1)\n     {\n       unsigned i;\n       tree *orig;\n \n       /* Save the original operands.  */\n-      orig = xmalloc (sizeof (tree) * NUM_USES (uses));\n-      for (i = 0; i < NUM_USES (uses); i++)\n+      orig = xmalloc (sizeof (tree) * num);\n+      i = 0;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t{\n-\t  orig[i] = USE_OP (uses, i);\n-\t  SET_USE_OP (uses, i, get_last_copy_of (USE_OP (uses, i)));\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  orig[i++] = use;\n+\t  SET_USE (use_p, get_last_copy_of (use));\n \t}\n \n       /* See if we can determine the predicate's value.  */\n@@ -638,8 +641,9 @@ copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n \t}\n \n       /* Restore the original operands.  */\n-      for (i = 0; i < NUM_USES (uses); i++)\n-\tSET_USE_OP (uses, i, orig[i]);\n+      i = 0;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\tSET_USE (use_p, orig[i++]);\n       free (orig);\n     }\n "}, {"sha": "fa8e7d6f42249f87c5f83a8c8b6a25e7026fa739", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 41, "deletions": 81, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -124,8 +124,8 @@ struct expr_hash_elt\n   /* The expression (rhs) we want to record.  */\n   tree rhs;\n \n-  /* The annotation if this element corresponds to a statement.  */\n-  stmt_ann_t ann;\n+  /* The stmt pointer if this element corresponds to a statement.  */\n+  tree stmt;\n \n   /* The hash value for RHS/ann.  */\n   hashval_t hash;\n@@ -675,36 +675,26 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       else\n \t{\n \t  /* Copy the operands.  */\n-\t  stmt_ann_t ann = stmt_ann (stmt);\n-\t  use_optype uses = USE_OPS (ann);\n-\t  vuse_optype vuses = VUSE_OPS (ann);\n-\t  tree *uses_copy = xmalloc (NUM_USES (uses) * sizeof (tree));\n-\t  tree *vuses_copy = xmalloc (NUM_VUSES (vuses) * sizeof (tree));\n-\t  unsigned int i;\n+\t  tree *copy;\n+\t  ssa_op_iter iter;\n+\t  use_operand_p use_p;\n+\t  unsigned int num, i = 0;\n \n-\t  /* Make a copy of the uses into USES_COPY, then cprop into\n-\t     the use operands.  */\n-\t  for (i = 0; i < NUM_USES (uses); i++)\n-\t    {\n-\t      tree tmp = NULL;\n+\t  num = NUM_SSA_OPERANDS (stmt, (SSA_OP_USE | SSA_OP_VUSE));\n+\t  copy = xcalloc (num, sizeof (tree));\n \n-\t      uses_copy[i] = USE_OP (uses, i);\n-\t      if (TREE_CODE (USE_OP (uses, i)) == SSA_NAME)\n-\t\ttmp = SSA_NAME_VALUE (USE_OP (uses, i));\n-\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n-\t\tSET_USE_OP (uses, i, tmp);\n-\t    }\n-\n-\t  /* Similarly for virtual uses.  */\n-\t  for (i = 0; i < NUM_VUSES (vuses); i++)\n+\t  /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n+\t     the operands.  */\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n \t    {\n \t      tree tmp = NULL;\n+\t      tree use = USE_FROM_PTR (use_p);\n \n-\t      vuses_copy[i] = VUSE_OP (vuses, i);\n-\t      if (TREE_CODE (VUSE_OP (vuses, i)) == SSA_NAME)\n-\t\ttmp = SSA_NAME_VALUE (VUSE_OP (vuses, i));\n+\t      copy[i++] = use;\n+\t      if (TREE_CODE (use) == SSA_NAME)\n+\t\ttmp = SSA_NAME_VALUE (use);\n \t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n-\t\tSET_VUSE_OP (vuses, i, tmp);\n+\t\tSET_USE (use_p, tmp);\n \t    }\n \n \t  /* Try to fold/lookup the new expression.  Inserting the\n@@ -715,15 +705,13 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t      && !is_gimple_min_invariant (cached_lhs))\n \t    cached_lhs = lookup_avail_expr (stmt, false);\n \n-\t  /* Restore the statement's original uses/defs.  */\n-\t  for (i = 0; i < NUM_USES (uses); i++)\n-\t    SET_USE_OP (uses, i, uses_copy[i]);\n \n-\t  for (i = 0; i < NUM_VUSES (vuses); i++)\n-\t    SET_VUSE_OP (vuses, i, vuses_copy[i]);\n+\t  /* Restore the statement's original uses/defs.  */\n+\t  i = 0;\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n+\t    SET_USE (use_p, copy[i++]);\n \n-\t  free (uses_copy);\n-\t  free (vuses_copy);\n+\t  free (copy);\n \t}\n \n       /* Record the context sensitive equivalence if we were able\n@@ -885,32 +873,32 @@ initialize_hash_element (tree expr, tree lhs, struct expr_hash_elt *element)\n      we want to record the expression the statement evaluates.  */\n   if (COMPARISON_CLASS_P (expr) || TREE_CODE (expr) == TRUTH_NOT_EXPR)\n     {\n-      element->ann = NULL;\n+      element->stmt = NULL;\n       element->rhs = expr;\n     }\n   else if (TREE_CODE (expr) == COND_EXPR)\n     {\n-      element->ann = stmt_ann (expr);\n+      element->stmt = expr;\n       element->rhs = COND_EXPR_COND (expr);\n     }\n   else if (TREE_CODE (expr) == SWITCH_EXPR)\n     {\n-      element->ann = stmt_ann (expr);\n+      element->stmt = expr;\n       element->rhs = SWITCH_COND (expr);\n     }\n   else if (TREE_CODE (expr) == RETURN_EXPR && TREE_OPERAND (expr, 0))\n     {\n-      element->ann = stmt_ann (expr);\n+      element->stmt = expr;\n       element->rhs = TREE_OPERAND (TREE_OPERAND (expr, 0), 1);\n     }\n   else if (TREE_CODE (expr) == GOTO_EXPR)\n     {\n-      element->ann = stmt_ann (expr);\n+      element->stmt = expr;\n       element->rhs = GOTO_DESTINATION (expr);\n     }\n   else\n     {\n-      element->ann = stmt_ann (expr);\n+      element->stmt = expr;\n       element->rhs = TREE_OPERAND (expr, 1);\n     }\n \n@@ -2608,7 +2596,6 @@ static bool\n eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \t\t\t\t  tree stmt, stmt_ann_t ann)\n {\n-  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n   tree *expr_p, def = NULL_TREE;\n   bool insert = true;\n   tree cached_lhs;\n@@ -2623,7 +2610,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n       || ! def\n       || TREE_CODE (def) != SSA_NAME\n       || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def)\n-      || NUM_V_MAY_DEFS (v_may_defs) != 0\n+      || !ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF)\n       /* Do not record equivalences for increments of ivs.  This would create\n \t overlapping live ranges for a very questionable gain.  */\n       || simple_iv_increment_p (stmt))\n@@ -2804,7 +2791,7 @@ record_equivalences_from_stmt (tree stmt,\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n \t  new = build (MODIFY_EXPR, TREE_TYPE (stmt), rhs, lhs);\n \n-\t  create_ssa_artficial_load_stmt (&(ann->operands), new);\n+\t  create_ssa_artficial_load_stmt (new, stmt);\n \n \t  /* Finally enter the statement into the available expression\n \t     table.  */\n@@ -3391,11 +3378,11 @@ vrp_eq (const void *p1, const void *p2)\n static hashval_t\n avail_expr_hash (const void *p)\n {\n-  stmt_ann_t ann = ((struct expr_hash_elt *)p)->ann;\n+  tree stmt = ((struct expr_hash_elt *)p)->stmt;\n   tree rhs = ((struct expr_hash_elt *)p)->rhs;\n+  tree vuse;\n+  ssa_op_iter iter;\n   hashval_t val = 0;\n-  size_t i;\n-  vuse_optype vuses;\n \n   /* iterative_hash_expr knows how to deal with any expression and\n      deals with commutative operators as well, so just use it instead\n@@ -3405,16 +3392,15 @@ avail_expr_hash (const void *p)\n   /* If the hash table entry is not associated with a statement, then we\n      can just hash the expression and not worry about virtual operands\n      and such.  */\n-  if (!ann)\n+  if (!stmt || !stmt_ann (stmt))\n     return val;\n \n   /* Add the SSA version numbers of every vuse operand.  This is important\n      because compound variables like arrays are not renamed in the\n      operands.  Rather, the rename is done on the virtual variable\n      representing all the elements of the array.  */\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    val = iterative_hash_expr (VUSE_OP (vuses, i), val);\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n+    val = iterative_hash_expr (vuse, val);\n \n   return val;\n }\n@@ -3428,13 +3414,13 @@ real_avail_expr_hash (const void *p)\n static int\n avail_expr_eq (const void *p1, const void *p2)\n {\n-  stmt_ann_t ann1 = ((struct expr_hash_elt *)p1)->ann;\n+  tree stmt1 = ((struct expr_hash_elt *)p1)->stmt;\n   tree rhs1 = ((struct expr_hash_elt *)p1)->rhs;\n-  stmt_ann_t ann2 = ((struct expr_hash_elt *)p2)->ann;\n+  tree stmt2 = ((struct expr_hash_elt *)p2)->stmt;\n   tree rhs2 = ((struct expr_hash_elt *)p2)->rhs;\n \n   /* If they are the same physical expression, return true.  */\n-  if (rhs1 == rhs2 && ann1 == ann2)\n+  if (rhs1 == rhs2 && stmt1 == stmt2)\n     return true;\n \n   /* If their codes are not equal, then quit now.  */\n@@ -3447,36 +3433,10 @@ avail_expr_eq (const void *p1, const void *p2)\n        || lang_hooks.types_compatible_p (TREE_TYPE (rhs1), TREE_TYPE (rhs2)))\n       && operand_equal_p (rhs1, rhs2, OEP_PURE_SAME))\n     {\n-      vuse_optype ops1 = NULL;\n-      vuse_optype ops2 = NULL;\n-      size_t num_ops1 = 0;\n-      size_t num_ops2 = 0;\n-      size_t i;\n-\n-      if (ann1)\n-\t{\n-\t  ops1 = VUSE_OPS (ann1);\n-\t  num_ops1 = NUM_VUSES (ops1);\n-\t}\n-\n-      if (ann2)\n-\t{\n-\t  ops2 = VUSE_OPS (ann2);\n-\t  num_ops2 = NUM_VUSES (ops2);\n-\t}\n-\n-      /* If the number of virtual uses is different, then we consider\n-\t them not equal.  */\n-      if (num_ops1 != num_ops2)\n-\treturn false;\n-\n-      for (i = 0; i < num_ops1; i++)\n-\tif (VUSE_OP (ops1, i) != VUSE_OP (ops2, i))\n-\t  return false;\n-\n-      gcc_assert (((struct expr_hash_elt *)p1)->hash\n+      bool ret = compare_ssa_operands_equal (stmt1, stmt2, SSA_OP_VUSE);\n+      gcc_assert (!ret || ((struct expr_hash_elt *)p1)->hash\n \t\t  == ((struct expr_hash_elt *)p2)->hash);\n-      return true;\n+      return ret;\n     }\n \n   return false;"}, {"sha": "23b9d4ac9c2b7bfc2ec6583de6e23b07a0d82c48", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -167,16 +167,10 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n   struct dse_global_data *dse_gd = walk_data->global_data;\n   tree stmt = bsi_stmt (bsi);\n   stmt_ann_t ann = stmt_ann (stmt);\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n \n   /* If this statement has no virtual defs, then there is nothing\n      to do.  */\n-  if (NUM_V_MAY_DEFS (v_may_defs) == 0\n-      && NUM_V_MUST_DEFS (v_must_defs) == 0)\n+  if (ZERO_SSA_OPERANDS (stmt, (SSA_OP_VMAYDEF|SSA_OP_VMUSTDEF)))\n     return;\n \n   /* We know we have virtual definitions.  If this is a MODIFY_EXPR that's"}, {"sha": "5e3f3619d141d54164619ed9664a62749ce873bb", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 12, "deletions": 46, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1578,25 +1578,13 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n static void\n find_invariants_stmt (struct ivopts_data *data, tree stmt)\n {\n-  use_optype uses = NULL;\n-  unsigned i, n;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n   tree op;\n \n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    n = PHI_NUM_ARGS (stmt);\n-  else\n-    {\n-      uses = STMT_USE_OPS (stmt);\n-      n = NUM_USES (uses);\n-    }\n-\n-  for (i = 0; i < n; i++)\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n     {\n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\top = PHI_ARG_DEF (stmt, i);\n-      else\n-\top = USE_OP (uses, i);\n-\n+      op = USE_FROM_PTR (use_p);\n       record_invariant (data, op, false);\n     }\n }\n@@ -1608,8 +1596,8 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n {\n   struct iv *iv;\n   tree op, lhs, rhs;\n-  use_optype uses = NULL;\n-  unsigned i, n;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n \n   find_invariants_stmt (data, stmt);\n \n@@ -1677,20 +1665,9 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n \treturn;\n     }\n \n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    n = PHI_NUM_ARGS (stmt);\n-  else\n-    {\n-      uses = STMT_USE_OPS (stmt);\n-      n = NUM_USES (uses);\n-    }\n-\n-  for (i = 0; i < n; i++)\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n     {\n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\top = PHI_ARG_DEF (stmt, i);\n-      else\n-\top = USE_OP (uses, i);\n+      op = USE_FROM_PTR (use_p);\n \n       if (TREE_CODE (op) != SSA_NAME)\n \tcontinue;\n@@ -5577,22 +5554,11 @@ protect_loop_closed_ssa_form_use (edge exit, use_operand_p op_p)\n static void\n protect_loop_closed_ssa_form (edge exit, tree stmt)\n {\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  unsigned i;\n-\n-  uses = STMT_USE_OPS (stmt);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    protect_loop_closed_ssa_form_use (exit, USE_OP_PTR (uses, i));\n-\n-  vuses = STMT_VUSE_OPS (stmt);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    protect_loop_closed_ssa_form_use (exit, VUSE_OP_PTR (vuses, i));\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n \n-  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    protect_loop_closed_ssa_form_use (exit, V_MAY_DEF_OP_PTR (v_may_defs, i));\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+    protect_loop_closed_ssa_form_use (exit, use_p);\n }\n \n /* STMTS compute a value of a phi argument OP on EXIT of a loop.  Arrange things"}, {"sha": "b3bde288a4857d7b81c771acec3020f81b479d6a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1081,8 +1081,8 @@ static tree\n chain_of_csts_start (struct loop *loop, tree x)\n {\n   tree stmt = SSA_NAME_DEF_STMT (x);\n+  tree use;\n   basic_block bb = bb_for_stmt (stmt);\n-  use_optype uses;\n \n   if (!bb\n       || !flow_bb_inside_loop_p (loop, bb))\n@@ -1099,19 +1099,16 @@ chain_of_csts_start (struct loop *loop, tree x)\n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return NULL_TREE;\n \n-  if (NUM_VUSES (STMT_VUSE_OPS (stmt)) > 0)\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return NULL_TREE;\n-  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0)\n+  if (SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF) == NULL_DEF_OPERAND_P)\n     return NULL_TREE;\n-  if (NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) > 0)\n-    return NULL_TREE;\n-  if (NUM_DEFS (STMT_DEF_OPS (stmt)) > 1)\n-    return NULL_TREE;\n-  uses = STMT_USE_OPS (stmt);\n-  if (NUM_USES (uses) != 1)\n+\n+  use = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_USE);\n+  if (use == NULL_USE_OPERAND_P)\n     return NULL_TREE;\n \n-  return chain_of_csts_start (loop, USE_OP (uses, 0));\n+  return chain_of_csts_start (loop, use);\n }\n \n /* Determines whether the expression X is derived from a result of a phi node\n@@ -1164,8 +1161,8 @@ static tree\n get_val_for (tree x, tree base)\n {\n   tree stmt, nx, val;\n-  use_optype uses;\n   use_operand_p op;\n+  ssa_op_iter iter;\n \n   if (!x)\n     return base;\n@@ -1174,16 +1171,19 @@ get_val_for (tree x, tree base)\n   if (TREE_CODE (stmt) == PHI_NODE)\n     return base;\n \n-  uses = STMT_USE_OPS (stmt);\n-  op = USE_OP_PTR (uses, 0);\n-\n-  nx = USE_FROM_PTR (op);\n-  val = get_val_for (nx, base);\n-  SET_USE (op, val);\n-  val = fold (TREE_OPERAND (stmt, 1));\n-  SET_USE (op, nx);\n+  FOR_EACH_SSA_USE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+    {\n+      nx = USE_FROM_PTR (op);\n+      val = get_val_for (nx, base);\n+      SET_USE (op, val);\n+      val = fold (TREE_OPERAND (stmt, 1));\n+      SET_USE (op, nx);\n+      /* only iterate loop once.  */\n+      return val;\n+    }\n \n-  return val;\n+  /* Should never reach here.  */\n+  gcc_unreachable();\n }\n \n /* Tries to count the number of iterations of LOOP till it exits by EXIT"}, {"sha": "cb235f0a4e596826a3ffbcbe9f9ca7b959b63c21", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -113,21 +113,19 @@ tree_ssa_unswitch_loops (struct loops *loops)\n static tree\n tree_may_unswitch_on (basic_block bb, struct loop *loop)\n {\n-  tree stmt, def, cond;\n+  tree stmt, def, cond, use;\n   basic_block def_bb;\n-  use_optype uses;\n-  unsigned i;\n+  ssa_op_iter iter;\n \n   /* BB must end in a simple conditional jump.  */\n   stmt = last_stmt (bb);\n   if (!stmt || TREE_CODE (stmt) != COND_EXPR)\n     return NULL_TREE;\n \n   /* Condition must be invariant.  */\n-  uses = STMT_USE_OPS (stmt);\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      def = SSA_NAME_DEF_STMT (USE_OP (uses, i));\n+      def = SSA_NAME_DEF_STMT (use);\n       def_bb = bb_for_stmt (def);\n       if (def_bb\n \t  && flow_bb_inside_loop_p (loop, def_bb))"}, {"sha": "d46bf8478385093cd8f671920e78624f795c7094", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 679, "deletions": 772, "changes": 1451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -99,20 +99,34 @@ Boston, MA 02111-1307, USA.  */\n    VUSE for 'b'.  */\n #define opf_no_vops \t(1 << 2)\n \n+/* This structure maintain a sorted list of operands which is created by\n+   parse_ssa_operand.  */\n+struct opbuild_list_d GTY (())\n+{\n+  varray_type vars;     /* The VAR_DECLS tree.  */\n+  varray_type uid;      /* The sort value for virtaul symbols.  */\n+  varray_type next;     /* The next index in the sorted list.  */\n+  int first;            /* First element in list.  */\n+  unsigned num;\t\t/* Number of elements.  */\n+};\n+                                                                                \n+#define OPBUILD_LAST     -1\n+                                                                                \n+\n /* Array for building all the def operands.  */\n-static GTY (()) varray_type build_defs;\n+static GTY (()) struct opbuild_list_d build_defs;\n \n /* Array for building all the use operands.  */\n-static GTY (()) varray_type build_uses;\n+static GTY (()) struct opbuild_list_d build_uses;\n \n /* Array for building all the v_may_def operands.  */\n-static GTY (()) varray_type build_v_may_defs;\n+static GTY (()) struct opbuild_list_d build_v_may_defs;\n \n /* Array for building all the vuse operands.  */\n-static GTY (()) varray_type build_vuses;\n+static GTY (()) struct opbuild_list_d build_vuses;\n \n /* Array for building all the v_must_def operands.  */\n-static GTY (()) varray_type build_v_must_defs;\n+static GTY (()) struct opbuild_list_d build_v_must_defs;\n \n /* True if the operands for call clobbered vars are cached and valid.  */\n bool ssa_call_clobbered_cache_valid;\n@@ -125,9 +139,10 @@ static GTY (()) varray_type ro_call_vuses;\n static bool clobbered_aliased_loads;\n static bool clobbered_aliased_stores;\n static bool ro_call_aliased_loads;\n-static stmt_operands_p parse_old_ops = NULL;\n+static bool ops_active = false;\n \n-def_operand_p NULL_DEF_OPERAND_P = { NULL };\n+static GTY (()) struct ssa_operand_memory_d *operand_memory = NULL;\n+static unsigned operand_memory_index;\n \n static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int);\n@@ -141,311 +156,311 @@ static void append_v_must_def (tree);\n static void add_call_clobber_ops (tree);\n static void add_call_read_ops (tree);\n static void add_stmt_operand (tree *, stmt_ann_t, int);\n+static void build_ssa_operands (tree stmt);\n+                                                                                \n+static def_optype_p free_defs = NULL;\n+static use_optype_p free_uses = NULL;\n+static vuse_optype_p free_vuses = NULL;\n+static maydef_optype_p free_maydefs = NULL;\n+static mustdef_optype_p free_mustdefs = NULL;\n \n-/* Return a vector of contiguous memory for NUM def operands.  */\n+/* Initialize a virtual operand build LIST called NAME with NUM elements.  */\n \n-static inline def_optype\n-allocate_def_optype (unsigned num)\n+static inline void\n+opbuild_initialize_virtual (struct  opbuild_list_d *list, int num, \n+\t\t\t   const char *name)\n {\n-  def_optype def_ops;\n-  unsigned size;\n-  size = sizeof (struct def_optype_d) + sizeof (tree *) * (num - 1);\n-  def_ops =  ggc_alloc (size);\n-  def_ops->num_defs = num;\n-  return def_ops;\n+  list->first = OPBUILD_LAST;\n+  list->num = 0;\n+  VARRAY_TREE_INIT (list->vars, num, name);\n+  VARRAY_UINT_INIT (list->uid, num, \"List UID\");\n+  VARRAY_INT_INIT (list->next, num, \"List NEXT\");\n }\n \n \n-/* Return a vector of contiguous memory for NUM use operands.  */\n+/* Initialize a real operand build LIST called NAME with NUM elements.  */\n \n-static inline use_optype\n-allocate_use_optype (unsigned num)\n+static inline void\n+opbuild_initialize_real (struct opbuild_list_d *list, int num, const char *name)\n {\n-  use_optype use_ops;\n-  unsigned size;\n-  size = sizeof (struct use_optype_d) + sizeof (use_operand_type_t) * (num - 1);\n-  use_ops =  ggc_alloc (size);\n-  use_ops->num_uses = num;\n-  return use_ops;\n+  list->first = OPBUILD_LAST;\n+  list->num = 0;\n+  VARRAY_TREE_PTR_INIT (list->vars, num, name);\n+  VARRAY_INT_INIT (list->next, num, \"List NEXT\");\n+  /* The UID field is not needed since we sort based on the pointer value.  */\n+  list->uid = NULL;\n }\n \n \n-/* Return a vector of contiguous memory for NUM v_may_def operands.  */\n+/* Free memory used in virtual operand build object LIST.  */\n \n-static inline v_may_def_optype\n-allocate_v_may_def_optype (unsigned num)\n+static inline void\n+opbuild_free (struct opbuild_list_d *list)\n {\n-  v_may_def_optype v_may_def_ops;\n-  unsigned size;\n-  size = sizeof (struct v_may_def_optype_d) \n-\t   + sizeof (v_def_use_operand_type_t) * (num - 1);\n-  v_may_def_ops =  ggc_alloc (size);\n-  v_may_def_ops->num_v_may_defs = num;\n-  return v_may_def_ops;\n+  list->vars = NULL;\n+  list->uid = NULL;\n+  list->next = NULL;\n }\n \n \n-/* Return a vector of contiguous memory for NUM v_use operands.  */\n+/* Number of elements in an opbuild list.  */\n \n-static inline vuse_optype\n-allocate_vuse_optype (unsigned num)\n+static inline unsigned\n+opbuild_num_elems (struct opbuild_list_d *list)\n {\n-  vuse_optype vuse_ops;\n-  unsigned size;\n-  size = sizeof (struct vuse_optype_d) \n-       + sizeof (vuse_operand_type_t) * (num - 1);\n-  vuse_ops =  ggc_alloc (size);\n-  vuse_ops->num_vuses = num;\n-  return vuse_ops;\n+  return list->num;\n }\n \n \n-/* Return a vector of contiguous memory for NUM v_must_def operands.  */\n+/* Add VAR to the real operand list LIST, keeping it sorted and avoiding\n+   duplicates.  The actual sort value is the tree pointer value.  */\n \n-static inline v_must_def_optype\n-allocate_v_must_def_optype (unsigned num)\n+static inline void\n+opbuild_append_real (struct opbuild_list_d *list, tree *var)\n {\n-  v_must_def_optype v_must_def_ops;\n-  unsigned size;\n-  size = sizeof (struct v_must_def_optype_d) + sizeof (v_def_use_operand_type_t) * (num - 1);\n-  v_must_def_ops =  ggc_alloc (size);\n-  v_must_def_ops->num_v_must_defs = num;\n-  return v_must_def_ops;\n+  int index;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Ensure the real operand doesn't exist already.  */\n+  for (index = list->first; \n+       index != OPBUILD_LAST; \n+       index = VARRAY_INT (list->next, index))\n+    gcc_assert (VARRAY_TREE_PTR (list->vars, index) != var);\n+#endif\n+\n+  /* First item in the list.  */\n+  index = VARRAY_ACTIVE_SIZE (list->vars);\n+  if (index == 0)\n+    list->first = index;\n+  else\n+    VARRAY_INT (list->next, index - 1) = index;\n+  VARRAY_PUSH_INT (list->next, OPBUILD_LAST);\n+  VARRAY_PUSH_TREE_PTR (list->vars, var);\n+  list->num++;\n }\n \n \n-/* Free memory for USES.  */\n+/* Add VAR to the virtual operand list LIST, keeping it sorted and avoiding\n+   duplicates.  The actual sort value is the DECL UID of the base variable.  */\n \n static inline void\n-free_uses (use_optype *uses)\n+opbuild_append_virtual (struct opbuild_list_d *list, tree var)\n {\n-  if (*uses)\n-    {\n-      unsigned int x;\n-      use_optype use = *uses;\n-      for (x = 0; x < use->num_uses; x++)\n-        delink_imm_use (&(use->uses[x]));\n-      ggc_free (*uses);\n-      *uses = NULL;\n-    }\n-}\n+  int index, curr, last;\n+  unsigned int var_uid;\n \n+  if (TREE_CODE (var) != SSA_NAME)\n+    var_uid = DECL_UID (var);\n+  else\n+    var_uid = DECL_UID (SSA_NAME_VAR (var));\n \n-/* Free memory for DEFS.  */\n+  index = VARRAY_ACTIVE_SIZE (list->vars);\n \n-static inline void\n-free_defs (def_optype *defs)\n-{\n-  if (*defs)\n+  if (index == 0)\n     {\n-      ggc_free (*defs);\n-      *defs = NULL;\n+      VARRAY_PUSH_TREE (list->vars, var);\n+      VARRAY_PUSH_UINT (list->uid, var_uid);\n+      VARRAY_PUSH_INT (list->next, OPBUILD_LAST);\n+      list->first = 0;\n+      list->num = 1;\n+      return;\n     }\n-}\n-\n \n-/* Free memory for VUSES.  */\n+  last = OPBUILD_LAST;\n+  /* Find the correct spot in the sorted list.  */\n+  for (curr = list->first; \n+       curr != OPBUILD_LAST; \n+       last = curr, curr = VARRAY_INT (list->next, curr))\n+    {\n+      if (VARRAY_UINT (list->uid, curr) > var_uid)\n+        break;\n+    }\n \n-static inline void\n-free_vuses (vuse_optype *vuses)\n-{\n-  if (*vuses)\n+  if (last == OPBUILD_LAST)\n     {\n-      unsigned int x;\n-      vuse_optype vuse = *vuses;\n-      for (x = 0; x < vuse->num_vuses; x++)\n-        delink_imm_use (&(vuse->vuses[x].imm_use));\n-      ggc_free (*vuses);\n-      *vuses = NULL;\n+      /* First item in the list.  */\n+      VARRAY_PUSH_INT (list->next, list->first);\n+      list->first = index;\n     }\n+  else\n+    {\n+      /* Dont enter duplicates at all.  */\n+      if (VARRAY_UINT (list->uid, last) == var_uid)\n+        return;\n+      \n+      VARRAY_PUSH_INT (list->next, VARRAY_INT (list->next, last));\n+      VARRAY_INT (list->next, last) = index;\n+    }\n+  VARRAY_PUSH_TREE (list->vars, var);\n+  VARRAY_PUSH_UINT (list->uid, var_uid);\n+  list->num++;\n }\n \n \n-/* Free memory for V_MAY_DEFS.  */\n+/*  Return the first element index in LIST.  OPBUILD_LAST means there are no \n+    more elements.  */\n \n-static inline void\n-free_v_may_defs (v_may_def_optype *v_may_defs)\n+static inline int\n+opbuild_first (struct opbuild_list_d *list)\n {\n-  if (*v_may_defs)\n-    {\n-      unsigned int x;\n-      v_may_def_optype v_may_def = *v_may_defs;\n-      for (x = 0; x < v_may_def->num_v_may_defs; x++)\n-        delink_imm_use (&(v_may_def->v_may_defs[x].imm_use));\n-      ggc_free (*v_may_defs);\n-      *v_may_defs = NULL;\n-    }\n+  if (list->num > 0)\n+    return list->first;\n+  else\n+    return OPBUILD_LAST;\n }\n \n \n-/* Free memory for V_MUST_DEFS.  */\n+/* Return the next element after PREV in LIST.  */\n \n-static inline void\n-free_v_must_defs (v_must_def_optype *v_must_defs)\n+static inline int\n+opbuild_next (struct opbuild_list_d *list, int prev)\n {\n-  if (*v_must_defs)\n-    {\n-      unsigned int x;\n-      v_must_def_optype v_must_def = *v_must_defs;\n-      for (x = 0; x < v_must_def->num_v_must_defs; x++)\n-        delink_imm_use (&(v_must_def->v_must_defs[x].imm_use));\n-      ggc_free (*v_must_defs);\n-      *v_must_defs = NULL;\n-    }\n+  return VARRAY_INT (list->next, prev);\n }\n \n \n-/* Initialize the operand cache routines.  */\n+/* Return the real element at index ELEM in LIST.  */\n \n-void\n-init_ssa_operands (void)\n+static inline tree *\n+opbuild_elem_real (struct opbuild_list_d *list, int elem)\n {\n-  VARRAY_TREE_PTR_INIT (build_defs, 5, \"build defs\");\n-  VARRAY_TREE_PTR_INIT (build_uses, 10, \"build uses\");\n-  VARRAY_TREE_INIT (build_v_may_defs, 10, \"build v_may_defs\");\n-  VARRAY_TREE_INIT (build_vuses, 10, \"build vuses\");\n-  VARRAY_TREE_INIT (build_v_must_defs, 10, \"build v_must_defs\");\n+  return VARRAY_TREE_PTR (list->vars, elem);\n }\n \n \n-/* Dispose of anything required by the operand routines.  */\n+/* Return the virtual element at index ELEM in LIST.  */\n \n-void\n-fini_ssa_operands (void)\n+static inline tree\n+opbuild_elem_virtual (struct opbuild_list_d *list, int elem)\n {\n-  ggc_free (build_defs);\n-  ggc_free (build_uses);\n-  ggc_free (build_v_may_defs);\n-  ggc_free (build_vuses);\n-  ggc_free (build_v_must_defs);\n-  build_defs = NULL;\n-  build_uses = NULL;\n-  build_v_may_defs = NULL;\n-  build_vuses = NULL;\n-  build_v_must_defs = NULL;\n-  if (clobbered_v_may_defs)\n-    {\n-      ggc_free (clobbered_v_may_defs);\n-      ggc_free (clobbered_vuses);\n-      clobbered_v_may_defs = NULL;\n-      clobbered_vuses = NULL;\n-    }\n-  if (ro_call_vuses)\n-    {\n-      ggc_free (ro_call_vuses);\n-      ro_call_vuses = NULL;\n-    }\n+  return VARRAY_TREE (list->vars, elem);\n }\n \n-/* Initialize V_USES index INDEX to VAL for STMT.  If OLD is present, preserve\n-   the position of the may-def in the immediate_use list.  */\n \n-static inline void\n-initialize_vuse_operand (vuse_optype vuses, unsigned int index, tree val, \n-\t\t\t tree stmt, ssa_imm_use_t *old)\n+/* Return the virtual element uid at index ELEM in LIST.  */\n+static inline unsigned int\n+opbuild_elem_uid (struct opbuild_list_d *list, int elem)\n {\n-  vuse_operand_type_t *ptr;\n-  ptr = &(vuses->vuses[index]);\n-  ptr->use = val;\n-  ptr->imm_use.use = &(ptr->use);\n-  if (old)\n-    relink_imm_use_stmt (&(ptr->imm_use), old, stmt);\n-  else\n-    link_imm_use_stmt (&(ptr->imm_use), ptr->use, stmt);\n+  return VARRAY_UINT (list->uid, elem);\n }\n \n \n-/* Initialize V_MAY_DEF_OPS index X to be DEF = MAY_DEF <USE> for STMT.  If\n-   OLD is present, preserve the position of the may-def in the immediate_use\n-   list.  */\n+/* Reset an operand build list.  */\n \n static inline void\n-initialize_v_may_def_operand (v_may_def_optype v_may_def_ops, unsigned int x, \n-\t\t\t      tree def, tree use, tree stmt, ssa_imm_use_t *old)\n+opbuild_clear (struct opbuild_list_d *list)\n {\n-  v_def_use_operand_type_t *ptr;\n-  ptr = &(v_may_def_ops->v_may_defs[x]);\n-  ptr->def = def;\n-  ptr->use = use;\n-  ptr->imm_use.use = &(ptr->use);\n-  if (old)\n-    relink_imm_use_stmt (&(ptr->imm_use), old, stmt);\n-  else\n-    link_imm_use_stmt (&(ptr->imm_use), ptr->use, stmt);\n+  list->first = OPBUILD_LAST;\n+  VARRAY_POP_ALL (list->vars);\n+  VARRAY_POP_ALL (list->next);\n+  if (list->uid)\n+    VARRAY_POP_ALL (list->uid);\n+  list->num = 0;\n }\n \n \n-/* Initialize V_MUST_DEF_OPS index X to be DEF = MUST_DEF <USE> for STMT.  If\n-   OLD is present, preserve the position of the may-def in the immediate_use\n-   list.  */\n+/* Remove ELEM from LIST where PREV is the rpevious element.  Return the next \n+   element.  */\n \n-static inline void\n-initialize_v_must_def_operand (v_must_def_optype v_must_def_ops, unsigned int x,\n-\t\t\t      tree def, tree use, tree stmt, ssa_imm_use_t *old)\n+static inline int \n+opbuild_remove_elem (struct opbuild_list_d *list, int elem, int prev)\n {\n-  v_def_use_operand_type_t *ptr;\n-  ptr = &(v_must_def_ops->v_must_defs[x]);\n-  ptr->def = def;\n-  ptr->use = use;\n-  ptr->imm_use.use = &(ptr->use);\n-  if (old)\n-    relink_imm_use_stmt (&(ptr->imm_use), old, stmt);\n+  int ret;\n+  if (prev != OPBUILD_LAST)\n+    {\n+      gcc_assert (VARRAY_INT (list->next, prev) == elem);\n+      ret = VARRAY_INT (list->next, prev) = VARRAY_INT (list->next, elem);\n+    }\n   else\n-    link_imm_use_stmt (&(ptr->imm_use), ptr->use, stmt);\n+    {\n+      gcc_assert (list->first == elem);\n+      ret = list->first = VARRAY_INT (list->next, elem);\n+    }\n+  list->num--;\n+  return ret;\n }\n \n-/* All the finalize_ssa_* routines do the work required to turn the build_\n-   VARRAY into an operand_vector of the appropriate type.  The original vector,\n-   if any, is passed in for comparison and virtual SSA_NAME reuse.  If the\n-   old vector is reused, the pointer passed in is set to NULL so that \n-   the memory is not freed when the old operands are freed.  */\n \n-/* Return a new def operand vector for STMT, comparing to OLD_OPS_P.  */\n+/*  Return true if the ssa operands cache is active.  */\n \n-static def_optype\n-finalize_ssa_defs (def_optype *old_ops_p, tree stmt)\n+bool\n+ssa_operands_active (void)\n {\n-  unsigned num, x;\n-  def_optype def_ops, old_ops;\n-  bool build_diff;\n+  return ops_active;\n+}\n \n-  num = VARRAY_ACTIVE_SIZE (build_defs);\n-  if (num == 0)\n-    return NULL;\n \n-  /* There should only be a single real definition per assignment.  */\n-  gcc_assert ((stmt && TREE_CODE (stmt) != MODIFY_EXPR) || num <= 1);\n+/* Initialize the operand cache routines.  */\n+\n+void\n+init_ssa_operands (void)\n+{\n+  opbuild_initialize_real (&build_defs, 5, \"build defs\");\n+  opbuild_initialize_real (&build_uses, 10, \"build uses\");\n+  opbuild_initialize_virtual (&build_vuses, 25, \"build_vuses\");\n+  opbuild_initialize_virtual (&build_v_may_defs, 25, \"build_v_may_defs\");\n+  opbuild_initialize_virtual (&build_v_must_defs, 25, \"build_v_must_defs\");\n+  gcc_assert (operand_memory == NULL);\n+  operand_memory_index = SSA_OPERAND_MEMORY_SIZE;\n+  ops_active = true;\n+}\n \n-  old_ops = *old_ops_p;\n \n-  /* Compare old vector and new array.  */\n-  build_diff = true;\n-  if (stmt && old_ops && old_ops->num_defs == num)\n-    {\n-      build_diff = false;\n-      for (x = 0; x < num; x++)\n-        if (old_ops->defs[x].def != VARRAY_TREE_PTR (build_defs, x))\n-\t  {\n-\t    build_diff = true;\n-\t    break;\n-\t  }\n+/* Dispose of anything required by the operand routines.  */\n+\n+void\n+fini_ssa_operands (void)\n+{\n+  struct ssa_operand_memory_d *ptr;\n+  opbuild_free (&build_defs);\n+  opbuild_free (&build_uses);\n+  opbuild_free (&build_v_must_defs);\n+  opbuild_free (&build_v_may_defs);\n+  opbuild_free (&build_vuses);\n+  free_defs = NULL;\n+  free_uses = NULL;\n+  free_vuses = NULL;\n+  free_maydefs = NULL;\n+  free_mustdefs = NULL;\n+  while ((ptr = operand_memory) != NULL)\n+    {\n+      operand_memory = operand_memory->next;\n+      ggc_free (ptr);\n     }\n \n-  if (!build_diff)\n+  if (clobbered_v_may_defs)\n     {\n-      def_ops = old_ops;\n-      *old_ops_p = NULL;\n+      ggc_free (clobbered_v_may_defs);\n+      ggc_free (clobbered_vuses);\n+      clobbered_v_may_defs = NULL;\n+      clobbered_vuses = NULL;\n     }\n-  else\n+  if (ro_call_vuses)\n     {\n-      def_ops = allocate_def_optype (num);\n-      for (x = 0; x < num ; x++)\n-\tdef_ops->defs[x].def = VARRAY_TREE_PTR (build_defs, x);\n+      ggc_free (ro_call_vuses);\n+      ro_call_vuses = NULL;\n     }\n+  ops_active = false;\n+}\n \n-  VARRAY_POP_ALL (build_defs);\n \n-  return def_ops;\n+/* Return memory for operands of SIZE chunks.  */\n+                                                                              \n+static inline void *\n+ssa_operand_alloc (unsigned size)\n+{\n+  char *ptr;\n+  if (operand_memory_index + size >= SSA_OPERAND_MEMORY_SIZE)\n+    {\n+      struct ssa_operand_memory_d *ptr;\n+      ptr = ggc_alloc (sizeof (struct ssa_operand_memory_d));\n+      ptr->next = operand_memory;\n+      operand_memory = ptr;\n+      operand_memory_index = 0;\n+    }\n+  ptr = &(operand_memory->mem[operand_memory_index]);\n+  operand_memory_index += size;\n+  return ptr;\n }\n \n \n@@ -458,9 +473,9 @@ finalize_ssa_defs (def_optype *old_ops_p, tree stmt)\n    because all nodes in the same stmt might have be changed.  */\n \n static inline void\n-correct_use_link (ssa_imm_use_t *ptr, tree stmt)\n+correct_use_link (use_operand_p ptr, tree stmt)\n {\n-  ssa_imm_use_t *prev;\n+  use_operand_p prev;\n   tree root;\n \n   /*  Fold_stmt () may have changed the stmt pointers.  */\n@@ -501,195 +516,161 @@ correct_use_link (ssa_imm_use_t *ptr, tree stmt)\n }\n \n \n-/* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */\n+#define FINALIZE_OPBUILD\t\tbuild_defs\n+#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_real (&build_defs, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_real (&build_defs, (I))\n+#define FINALIZE_FUNC\t\t\tfinalize_ssa_def_ops\n+#define FINALIZE_ALLOC\t\t\talloc_def\n+#define FINALIZE_FREE\t\t\tfree_defs\n+#define FINALIZE_TYPE\t\t\tstruct def_optype_d\n+#define FINALIZE_ELEM(PTR)\t\t((PTR)->def_ptr)\n+#define FINALIZE_OPS\t\t\tDEF_OPS\n+#define FINALIZE_BASE(VAR)\t\tVAR\n+#define FINALIZE_BASE_TYPE\t\ttree *\n+#define FINALIZE_BASE_ZERO\t\tNULL\n+#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\tFINALIZE_ELEM (PTR) = (VAL)\n+#include \"tree-ssa-opfinalize.h\"\n \n-static use_optype\n-finalize_ssa_uses (use_optype *old_ops_p, tree stmt)\n+\n+/* This routine will create stmt operands for STMT from the def build list.  */\n+\n+static void\n+finalize_ssa_defs (tree stmt)\n {\n-  unsigned num, x, num_old, i;\n-  use_optype use_ops, old_ops;\n-  bool build_diff;\n+  unsigned int num = opbuild_num_elems (&build_defs);\n+  /* There should only be a single real definition per assignment.  */\n+  gcc_assert ((stmt && TREE_CODE (stmt) != MODIFY_EXPR) || num <= 1);\n \n-  num = VARRAY_ACTIVE_SIZE (build_uses);\n-  if (num == 0)\n-    return NULL;\n+  /* If there is an old list, often the new list is identical, or close, so\n+     find the elements at the beginning that are the same as the vector.  */\n+\n+  finalize_ssa_def_ops (stmt);\n+  opbuild_clear (&build_defs);\n+}\n \n+#define FINALIZE_OPBUILD\tbuild_uses\n+#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_real (&build_uses, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_real (&build_uses, (I))\n+#define FINALIZE_FUNC\t\tfinalize_ssa_use_ops\n+#define FINALIZE_ALLOC\t\talloc_use\n+#define FINALIZE_FREE\t\tfree_uses\n+#define FINALIZE_TYPE\t\tstruct use_optype_d\n+#define FINALIZE_ELEM(PTR)\t((PTR)->use_ptr.use)\n+#define FINALIZE_OPS\t\tUSE_OPS\n+#define FINALIZE_USE_PTR(PTR)\tUSE_OP_PTR (PTR)\n+#define FINALIZE_BASE(VAR)\tVAR\n+#define FINALIZE_BASE_TYPE\ttree *\n+#define FINALIZE_BASE_ZERO\tNULL\n+#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n+\t\t\t\t(PTR)->use_ptr.use = (VAL);             \\\n+\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),   \\\n+\t\t\t\t\t\t   *(VAL), (STMT))\n+#include \"tree-ssa-opfinalize.h\"\n+\n+/* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */\n+                                                                              \n+static void\n+finalize_ssa_uses (tree stmt)\n+{\n #ifdef ENABLE_CHECKING\n   {\n     unsigned x;\n+    unsigned num = opbuild_num_elems (&build_uses);\n+\n     /* If the pointer to the operand is the statement itself, something is\n-       wrong.  It means that we are pointing to a local variable.  */\n+       wrong.  It means that we are pointing to a local variable (the \n+       initial call to get_stmt_operands does not pass a pointer to a \n+       statement).  */\n     for (x = 0; x < num; x++)\n-      gcc_assert (*(VARRAY_TREE_PTR (build_uses, x)) != stmt);\n+      gcc_assert (*(opbuild_elem_real (&build_uses, x)) != stmt);\n   }\n #endif\n-  old_ops = *old_ops_p;\n-  num_old = ((stmt && old_ops) ? old_ops->num_uses : 0);\n-\n-  /* Check if the old vector and the new array are the same.  */\n-  build_diff = true;\n-  if (stmt && old_ops && num_old == num)\n-    {\n-      build_diff = false;\n-      for (x = 0; x < num; x++)\n-        {\n-\t  tree *var_p = VARRAY_TREE_PTR (build_uses, x);\n-\t  tree *node = old_ops->uses[x].use;\n-\t  /* Check the pointer values to see if they are the same. */\n-\t  if (node != var_p)\n-\t    {\n-\t      build_diff = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (!build_diff)\n-    {\n-      use_ops = old_ops;\n-      *old_ops_p = NULL;\n-      for (i = 0; i < num_old; i++)\n-        correct_use_link (&(use_ops->uses[i]), stmt);\n-    }\n-  else\n-    {\n-      use_ops = allocate_use_optype (num);\n-      for (x = 0; x < num ; x++)\n-        {\n-\t  tree *var = VARRAY_TREE_PTR (build_uses, x);\n-\t  use_ops->uses[x].use = var;\n-\t  for (i = 0; i < num_old; i++)\n-\t    {\n-\t      ssa_imm_use_t *ptr = &(old_ops->uses[i]);\n-\t      if (ptr->use == var)\n-\t\t{\n-\t\t  relink_imm_use_stmt (&(use_ops->uses[x]), ptr, stmt);\n-\t\t  correct_use_link (&(use_ops->uses[x]), stmt);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (i == num_old)\n-\t    link_imm_use_stmt (&(use_ops->uses[x]), *var, stmt);\n-\t}\n-    }\n-  VARRAY_POP_ALL (build_uses);\n-\n-  return use_ops;\n+  finalize_ssa_use_ops (stmt);\n+  opbuild_clear (&build_uses);\n }\n-\n-\n-/* Return a new v_may_def operand vector for STMT, comparing to OLD_OPS_P.  */\n-\n-static v_may_def_optype\n-finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p, tree stmt)\n+                                                                              \n+                                                                              \n+/* Return a new v_may_def operand vector for STMT, comparing to OLD_OPS_P.  */                                                                                \n+#define FINALIZE_OPBUILD\tbuild_v_may_defs\n+#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_virtual (&build_v_may_defs, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_uid (&build_v_may_defs, (I))\n+#define FINALIZE_FUNC\t\tfinalize_ssa_v_may_def_ops\n+#define FINALIZE_ALLOC\t\talloc_maydef\n+#define FINALIZE_FREE\t\tfree_maydefs\n+#define FINALIZE_TYPE\t\tstruct maydef_optype_d\n+#define FINALIZE_ELEM(PTR)\tMAYDEF_RESULT (PTR)\n+#define FINALIZE_OPS\t\tMAYDEF_OPS\n+#define FINALIZE_USE_PTR(PTR)\tMAYDEF_OP_PTR (PTR)\n+#define FINALIZE_BASE_ZERO\t0\n+#define FINALIZE_BASE(VAR)\t((TREE_CODE (VAR) == SSA_NAME)\t\t\\\n+\t\t\t\t? DECL_UID (SSA_NAME_VAR (VAR)) : DECL_UID ((VAR)))\n+#define FINALIZE_BASE_TYPE\tunsigned\n+#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n+\t\t\t\t(PTR)->def_var = (VAL);\t\t\t\\\n+\t\t\t\t(PTR)->use_var = (VAL);\t\t\t\\\n+\t\t\t\t(PTR)->use_ptr.use = &((PTR)->use_var);\t\\\n+\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),\t\\\n+\t\t\t\t\t\t   (VAL), (STMT))\n+#include \"tree-ssa-opfinalize.h\"\n+                                                                              \n+                                                                              \n+static void\n+finalize_ssa_v_may_defs (tree stmt)\n {\n-  unsigned num, x, i, old_num;\n-  v_may_def_optype v_may_def_ops, old_ops;\n-  tree result, var;\n-  bool build_diff;\n-\n-  num = VARRAY_ACTIVE_SIZE (build_v_may_defs);\n-  if (num == 0)\n-    return NULL;\n-\n-  old_ops = *old_ops_p;\n-\n-  /* Check if the old vector and the new array are the same.  */\n-  build_diff = true;\n-  if (stmt && old_ops && old_ops->num_v_may_defs == num)\n-    {\n-      old_num = num;\n-      build_diff = false;\n-      for (x = 0; x < num; x++)\n-        {\n-\t  var = old_ops->v_may_defs[x].def;\n-\t  if (TREE_CODE (var) == SSA_NAME)\n-\t    var = SSA_NAME_VAR (var);\n-\t  if (var != VARRAY_TREE (build_v_may_defs, x))\n-\t    {\n-\t      build_diff = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  else\n-    old_num = (old_ops ? old_ops->num_v_may_defs : 0);\n-\n-  if (!build_diff)\n-    {\n-      v_may_def_ops = old_ops;\n-      *old_ops_p = NULL;\n-      for (x = 0; x < num; x++)\n-        correct_use_link (&(v_may_def_ops->v_may_defs[x].imm_use), stmt);\n-    }\n-  else\n-    {\n-      v_may_def_ops = allocate_v_may_def_optype (num);\n-      for (x = 0; x < num; x++)\n-        {\n-\t  var = VARRAY_TREE (build_v_may_defs, x);\n-\t  /* Look for VAR in the old operands vector.  */\n-\t  for (i = 0; i < old_num; i++)\n-\t    {\n-\t      result = old_ops->v_may_defs[i].def;\n-\t      if (TREE_CODE (result) == SSA_NAME)\n-\t\tresult = SSA_NAME_VAR (result);\n-\t      if (result == var)\n-\t        {\n-\t\t  initialize_v_may_def_operand (v_may_def_ops, x, \n-\t\t\t\t\t\told_ops->v_may_defs[i].def,\n-\t\t\t\t\t\told_ops->v_may_defs[i].use,\n-\t\t\t\t\t\tstmt, \n-\t\t\t\t\t\t&(old_ops->v_may_defs[i].imm_use));\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (i == old_num)\n-\t    {\n-\t      initialize_v_may_def_operand (v_may_def_ops, x, var, var, stmt, \n-\t\t\t\t\t    NULL);\n-\t    }\n-\t}\n-    }\n-\n-  /* Empty the V_MAY_DEF build vector after VUSES have been processed.  */\n-\n-  return v_may_def_ops;\n+  finalize_ssa_v_may_def_ops (stmt);\n }\n-\n+                                                                               \n \n /* Clear the in_list bits and empty the build array for v_may_defs.  */\n \n static inline void\n cleanup_v_may_defs (void)\n {\n   unsigned x, num;\n-  num = VARRAY_ACTIVE_SIZE (build_v_may_defs);\n+  num = opbuild_num_elems (&build_v_may_defs);\n \n   for (x = 0; x < num; x++)\n     {\n-      tree t = VARRAY_TREE (build_v_may_defs, x);\n-      var_ann_t ann = var_ann (t);\n-      ann->in_v_may_def_list = 0;\n+      tree t = opbuild_elem_virtual (&build_v_may_defs, x);\n+      if (TREE_CODE (t) != SSA_NAME)\n+\t{\n+\t  var_ann_t ann = var_ann (t);\n+\t  ann->in_v_may_def_list = 0;\n+\t}\n     }\n-  VARRAY_POP_ALL (build_v_may_defs);\n-}\n+  opbuild_clear (&build_v_may_defs);\n+}                                                                             \n+\n+                                                                              \n+#define FINALIZE_OPBUILD\tbuild_vuses\n+#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_virtual (&build_vuses, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_uid (&build_vuses, (I))\n+#define FINALIZE_FUNC\t\tfinalize_ssa_vuse_ops\n+#define FINALIZE_ALLOC\t\talloc_vuse\n+#define FINALIZE_FREE\t\tfree_vuses\n+#define FINALIZE_TYPE\t\tstruct vuse_optype_d\n+#define FINALIZE_ELEM(PTR)\tVUSE_OP (PTR)\n+#define FINALIZE_OPS\t\tVUSE_OPS\n+#define FINALIZE_USE_PTR(PTR)\tVUSE_OP_PTR (PTR)\n+#define FINALIZE_BASE_ZERO\t0\n+#define FINALIZE_BASE(VAR)\t((TREE_CODE (VAR) == SSA_NAME)\t\t\\\n+\t\t\t\t? DECL_UID (SSA_NAME_VAR (VAR)) : DECL_UID ((VAR)))\n+#define FINALIZE_BASE_TYPE\tunsigned\n+#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n+\t\t\t\t(PTR)->use_var = (VAL);\t\t\t\\\n+\t\t\t\t(PTR)->use_ptr.use = &((PTR)->use_var);\t\\\n+\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),\t\\\n+\t\t\t\t\t\t   (VAL), (STMT))\n+#include \"tree-ssa-opfinalize.h\"\n \n-/* Return a new vuse operand vector, comparing to OLD_OPS_P.  */\n \n-static vuse_optype\n-finalize_ssa_vuses (vuse_optype *old_ops_p, tree stmt)\n+/* Return a new vuse operand vector, comparing to OLD_OPS_P.  */\n+                                                                              \n+static void\n+finalize_ssa_vuses (tree stmt)\n {\n-  unsigned num, x, i, num_v_may_defs, old_num;\n-  vuse_optype vuse_ops, old_ops;\n-  bool build_diff;\n-\n-  num = VARRAY_ACTIVE_SIZE (build_vuses);\n-  if (num == 0)\n-    {\n-      cleanup_v_may_defs ();\n-      return NULL;\n-    }\n+  unsigned num, num_v_may_defs;\n+  int vuse_index;\n \n   /* Remove superfluous VUSE operands.  If the statement already has a\n    V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is not\n@@ -703,224 +684,104 @@ finalize_ssa_vuses (vuse_optype *old_ops_p, tree stmt)\n   The VUSE <a_2> is superfluous because it is implied by the V_MAY_DEF\n   operation.  */\n \n-  num_v_may_defs = VARRAY_ACTIVE_SIZE (build_v_may_defs);\n+  num = opbuild_num_elems (&build_vuses);\n+  num_v_may_defs = opbuild_num_elems (&build_v_may_defs);\n \n-  if (num_v_may_defs > 0)\n+  if (num > 0 && num_v_may_defs > 0)\n     {\n-      size_t i;\n-      tree vuse;\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vuses); i++)\n-\t{\n-\t  vuse = VARRAY_TREE (build_vuses, i);\n+      int last = OPBUILD_LAST;\n+      vuse_index = opbuild_first (&build_vuses);\n+      for ( ; vuse_index != OPBUILD_LAST; )\n+        {\n+\t  tree vuse;\n+\t  vuse = opbuild_elem_virtual (&build_vuses, vuse_index);\n \t  if (TREE_CODE (vuse) != SSA_NAME)\n \t    {\n \t      var_ann_t ann = var_ann (vuse);\n \t      ann->in_vuse_list = 0;\n \t      if (ann->in_v_may_def_list)\n \t        {\n-\t\t  /* If we found a useless VUSE operand, remove it from the\n-\t\t     operand array by replacing it with the last active element\n-\t\t     in the operand array (unless the useless VUSE was the\n-\t\t     last operand, in which case we simply remove it.  */\n-\t\t  if (i != VARRAY_ACTIVE_SIZE (build_vuses) - 1)\n-\t\t    {\n-\t\t      VARRAY_TREE (build_vuses, i)\n-\t\t\t= VARRAY_TREE (build_vuses,\n-\t\t\t\t       VARRAY_ACTIVE_SIZE (build_vuses) - 1);\n-\t\t    }\n-\t\t  VARRAY_POP (build_vuses);\n-\n-\t\t  /* We want to rescan the element at this index, unless\n-\t\t     this was the last element, in which case the loop\n-\t\t     terminates.  */\n-\t\t  i--;\n+\t\t  vuse_index = opbuild_remove_elem (&build_vuses, vuse_index, \n+\t\t\t\t\t\t    last);\n+\t\t  continue;\n \t\t}\n \t    }\n+\t  last = vuse_index;\n+\t  vuse_index = opbuild_next (&build_vuses, vuse_index);\n \t}\n     }\n   else\n     /* Clear out the in_list bits.  */\n-    for (x = 0; x < num; x++)\n+    for (vuse_index = opbuild_first (&build_vuses);\n+\t vuse_index != OPBUILD_LAST;\n+\t vuse_index = opbuild_next (&build_vuses, vuse_index))\n       {\n-\ttree t = VARRAY_TREE (build_vuses, x);\n+\ttree t = opbuild_elem_virtual (&build_vuses, vuse_index);\n \tif (TREE_CODE (t) != SSA_NAME)\n \t  {\n \t    var_ann_t ann = var_ann (t);\n \t    ann->in_vuse_list = 0;\n \t  }\n       }\n \n-\n-  num = VARRAY_ACTIVE_SIZE (build_vuses);\n-  /* We could have reduced the size to zero now, however.  */\n-  if (num == 0)\n-    {\n-      cleanup_v_may_defs ();\n-      return NULL;\n-    }\n-\n-  old_ops = *old_ops_p;\n-\n-  /* Determine whether vuses is the same as the old vector.  */\n-  build_diff = true;\n-  if (stmt && old_ops && old_ops->num_vuses == num)\n-    {\n-      old_num = num;\n-      build_diff = false;\n-      for (x = 0; x < num ; x++)\n-        {\n-\t  tree v;\n-\t  v = old_ops->vuses[x].use;\n-\t  if (TREE_CODE (v) == SSA_NAME)\n-\t    v = SSA_NAME_VAR (v);\n-\t  if (v != VARRAY_TREE (build_vuses, x))\n-\t    {\n-\t      build_diff = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  else\n-    old_num = (old_ops ? old_ops->num_vuses : 0);\n-\n-  if (!build_diff)\n-    {\n-      vuse_ops = old_ops;\n-      *old_ops_p = NULL;\n-      for (x = 0; x < num; x++)\n-        correct_use_link (&(vuse_ops->vuses[x].imm_use), stmt);\n-    }\n-  else\n-    {\n-      vuse_ops = allocate_vuse_optype (num);\n-      for (x = 0; x < num; x++)\n-        {\n-\t  tree result, var = VARRAY_TREE (build_vuses, x);\n-\t  /* Look for VAR in the old vector, and use that SSA_NAME.  */\n-\t  for (i = 0; i < old_num; i++)\n-\t    {\n-\t      result = old_ops->vuses[i].use;\n-\t      if (TREE_CODE (result) == SSA_NAME)\n-\t\tresult = SSA_NAME_VAR (result);\n-\t      if (result == var)\n-\t        {\n-\t\t  initialize_vuse_operand (vuse_ops, x, old_ops->vuses[i].use, \n-\t\t\t\t\t   stmt, &(old_ops->vuses[i].imm_use));\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (i == old_num)\n-\t    initialize_vuse_operand (vuse_ops, x, var, stmt, NULL);\n-\t}\n-    }\n-\n-  /* The v_may_def build vector wasn't freed because we needed it here.\n-     Free it now with the vuses build vector.  */\n-  VARRAY_POP_ALL (build_vuses);\n+  finalize_ssa_vuse_ops (stmt);\n+  /* The v_may_def build vector wasn't cleaned up because we needed it.  */\n   cleanup_v_may_defs ();\n+                                                                              \n+  /* Free the vuses build vector.  */\n+  opbuild_clear (&build_vuses);\n \n-  return vuse_ops;\n }\n-\n+                                                                              \n /* Return a new v_must_def operand vector for STMT, comparing to OLD_OPS_P.  */\n+                                                                              \n+#define FINALIZE_OPBUILD\tbuild_v_must_defs\n+#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_virtual (&build_v_must_defs, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_uid (&build_v_must_defs, (I))\n+#define FINALIZE_FUNC\t\tfinalize_ssa_v_must_def_ops\n+#define FINALIZE_ALLOC\t\talloc_mustdef\n+#define FINALIZE_FREE\t\tfree_mustdefs\n+#define FINALIZE_TYPE\t\tstruct mustdef_optype_d\n+#define FINALIZE_ELEM(PTR)\tMUSTDEF_RESULT (PTR)\n+#define FINALIZE_OPS\t\tMUSTDEF_OPS\n+#define FINALIZE_USE_PTR(PTR)\tMUSTDEF_KILL_PTR (PTR)\n+#define FINALIZE_BASE_ZERO\t0\n+#define FINALIZE_BASE(VAR)\t((TREE_CODE (VAR) == SSA_NAME)\t\t\\\n+\t\t\t\t? DECL_UID (SSA_NAME_VAR (VAR)) : DECL_UID ((VAR)))\n+#define FINALIZE_BASE_TYPE\tunsigned\n+#define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n+\t\t\t\t(PTR)->def_var = (VAL);\t\t\t\\\n+\t\t\t\t(PTR)->kill_var = (VAL);\t\t\\\n+\t\t\t\t(PTR)->use_ptr.use = &((PTR)->kill_var);\\\n+\t\t\t\tlink_imm_use_stmt (&((PTR)->use_ptr),\t\\\n+\t\t\t\t\t\t   (VAL), (STMT))\n+#include \"tree-ssa-opfinalize.h\"\n \n-static v_must_def_optype\n-finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p, tree stmt)\n-{\n-  unsigned num, x, i, old_num = 0;\n-  v_must_def_optype v_must_def_ops, old_ops;\n-  tree result, var;\n-  bool build_diff;\n-\n-  num = VARRAY_ACTIVE_SIZE (build_v_must_defs);\n-  if (num == 0)\n-    return NULL;\n \n+static void\n+finalize_ssa_v_must_defs (tree stmt)\n+{\n   /* In the presence of subvars, there may be more than one V_MUST_DEF per\n      statement (one for each subvar).  It is a bit expensive to verify that\n      all must-defs in a statement belong to subvars if there is more than one\n      MUST-def, so we don't do it.  Suffice to say, if you reach here without\n      having subvars, and have num >1, you have hit a bug. */\n-     \n-\n-  old_ops = *old_ops_p;\n-\n-  /* Check if the old vector and the new array are the same.  */\n-  build_diff = true;\n-  if (stmt && old_ops && old_ops->num_v_must_defs == num)\n-    {\n-      old_num = num;\n-      build_diff = false;\n-      for (x = 0; x < num; x++)\n-        {\n-\t  tree var = old_ops->v_must_defs[x].def;\n-\t  if (TREE_CODE (var) == SSA_NAME)\n-\t    var = SSA_NAME_VAR (var);\n-\t  if (var != VARRAY_TREE (build_v_must_defs, x))\n-\t    {\n-\t      build_diff = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  else\n-    old_num = (old_ops ? old_ops->num_v_must_defs : 0);\n-\n-  if (!build_diff)\n-    {\n-      v_must_def_ops = old_ops;\n-      *old_ops_p = NULL;\n-      for (x = 0; x < num; x++)\n-        correct_use_link (&(v_must_def_ops->v_must_defs[x].imm_use), stmt);\n-    }\n-  else\n-    {\n-      v_must_def_ops = allocate_v_must_def_optype (num);\n-      for (x = 0; x < num ; x++)\n-\t{\n-\t  var = VARRAY_TREE (build_v_must_defs, x);\n-\t  /* Look for VAR in the original vector.  */\n-\t  for (i = 0; i < old_num; i++)\n-\t    {\n-\t      result = old_ops->v_must_defs[i].def;\n-\t      if (TREE_CODE (result) == SSA_NAME)\n-\t\tresult = SSA_NAME_VAR (result);\n-\t      if (result == var)\n-\t        {\n-\t\t  initialize_v_must_def_operand (v_must_def_ops, x,\n-\t\t\t\t\t\t old_ops->v_must_defs[i].def,\n-\t\t\t\t\t\t old_ops->v_must_defs[i].use,\n-\t\t\t\t\t\t stmt,\n-\t\t\t\t\t\t &(old_ops->v_must_defs[i].imm_use));\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (i == old_num)\n-\t    {\n-\t      initialize_v_must_def_operand (v_must_def_ops, x, var, var, stmt,\n-\t      \t\t\t\t     NULL);\n-\t    }\n-\t}\n-    }\n-  VARRAY_POP_ALL (build_v_must_defs);\n \n-  return v_must_def_ops;\n+  finalize_ssa_v_must_def_ops (stmt);\n+  opbuild_clear (&build_v_must_defs);\n }\n \n \n /* Finalize all the build vectors, fill the new ones into INFO.  */\n-\n+                                                                              \n static inline void\n-finalize_ssa_stmt_operands (tree stmt, stmt_operands_p old_ops, \n-\t\t\t    stmt_operands_p new_ops)\n+finalize_ssa_stmt_operands (tree stmt)\n {\n-  new_ops->def_ops = finalize_ssa_defs (&(old_ops->def_ops), stmt);\n-  new_ops->use_ops = finalize_ssa_uses (&(old_ops->use_ops), stmt);\n-  new_ops->v_must_def_ops \n-    = finalize_ssa_v_must_defs (&(old_ops->v_must_def_ops), stmt);\n-  new_ops->v_may_def_ops \n-    = finalize_ssa_v_may_defs (&(old_ops->v_may_def_ops), stmt);\n-  new_ops->vuse_ops = finalize_ssa_vuses (&(old_ops->vuse_ops), stmt);\n+  finalize_ssa_defs (stmt);\n+  finalize_ssa_uses (stmt);\n+  finalize_ssa_v_must_defs (stmt);\n+  finalize_ssa_v_may_defs (stmt);\n+  finalize_ssa_vuses (stmt);\n }\n \n \n@@ -929,11 +790,11 @@ finalize_ssa_stmt_operands (tree stmt, stmt_operands_p old_ops,\n static inline void\n start_ssa_stmt_operands (void)\n {\n-  gcc_assert (VARRAY_ACTIVE_SIZE (build_defs) == 0);\n-  gcc_assert (VARRAY_ACTIVE_SIZE (build_uses) == 0);\n-  gcc_assert (VARRAY_ACTIVE_SIZE (build_vuses) == 0);\n-  gcc_assert (VARRAY_ACTIVE_SIZE (build_v_may_defs) == 0);\n-  gcc_assert (VARRAY_ACTIVE_SIZE (build_v_must_defs) == 0);\n+  gcc_assert (opbuild_num_elems (&build_defs) == 0);\n+  gcc_assert (opbuild_num_elems (&build_uses) == 0);\n+  gcc_assert (opbuild_num_elems (&build_vuses) == 0);\n+  gcc_assert (opbuild_num_elems (&build_v_may_defs) == 0);\n+  gcc_assert (opbuild_num_elems (&build_v_must_defs) == 0);\n }\n \n \n@@ -942,7 +803,7 @@ start_ssa_stmt_operands (void)\n static inline void\n append_def (tree *def_p)\n {\n-  VARRAY_PUSH_TREE_PTR (build_defs, def_p);\n+  opbuild_append_real (&build_defs, def_p);\n }\n \n \n@@ -951,7 +812,7 @@ append_def (tree *def_p)\n static inline void\n append_use (tree *use_p)\n {\n-  VARRAY_PUSH_TREE_PTR (build_uses, use_p);\n+  opbuild_append_real (&build_uses, use_p);\n }\n \n \n@@ -960,14 +821,17 @@ append_use (tree *use_p)\n static inline void\n append_v_may_def (tree var)\n {\n-  var_ann_t ann = get_var_ann (var);\n+  if (TREE_CODE (var) != SSA_NAME)\n+    {\n+      var_ann_t ann = get_var_ann (var);\n \n-  /* Don't allow duplicate entries.  */\n-  if (ann->in_v_may_def_list)\n-    return;\n-  ann->in_v_may_def_list = 1;\n+      /* Don't allow duplicate entries.  */\n+      if (ann->in_v_may_def_list)\n+\treturn;\n+      ann->in_v_may_def_list = 1;\n+    }\n \n-  VARRAY_PUSH_TREE (build_v_may_defs, var);\n+  opbuild_append_virtual (&build_v_may_defs, var);\n }\n \n \n@@ -987,7 +851,7 @@ append_vuse (tree var)\n       ann->in_vuse_list = 1;\n     }\n \n-  VARRAY_PUSH_TREE (build_vuses, var);\n+  opbuild_append_virtual (&build_vuses, var);\n }\n \n \n@@ -999,11 +863,11 @@ append_v_must_def (tree var)\n   unsigned i;\n \n   /* Don't allow duplicate entries.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_must_defs); i++)\n-    if (var == VARRAY_TREE (build_v_must_defs, i))\n+  for (i = 0; i < opbuild_num_elems (&build_v_must_defs); i++)\n+    if (var == opbuild_elem_virtual (&build_v_must_defs, i))\n       return;\n \n-  VARRAY_PUSH_TREE (build_v_must_defs, var);\n+  opbuild_append_virtual (&build_v_must_defs, var);\n }\n \n \n@@ -1116,17 +980,9 @@ parse_ssa_operands (tree stmt)\n        free_ssa_operands (old_ops);\t\t\t\t\t*/\n \n static void\n-build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops, \n-\t\t    stmt_operands_p new_ops)\n+build_ssa_operands (tree stmt)\n {\n-  tree_ann_t saved_ann = stmt->common.ann;\n-  \n-  /* Replace stmt's annotation with the one passed in for the duration\n-     of the operand building process.  This allows \"fake\" stmts to be built\n-     and not be included in other data structures which can be built here.  */\n-  stmt->common.ann = (tree_ann_t) ann;\n-\n-  parse_old_ops = old_ops;\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n   \n   /* Initially assume that the statement has no volatile operands, nor\n      makes aliased loads or stores.  */\n@@ -1141,72 +997,219 @@ build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops,\n \n   parse_ssa_operands (stmt);\n \n-  parse_old_ops = NULL;\n-\n-  if (ann)\n-    finalize_ssa_stmt_operands (stmt, old_ops, new_ops);\n-  else\n-    finalize_ssa_stmt_operands (NULL, old_ops, new_ops);\n-  stmt->common.ann = saved_ann;\n+  finalize_ssa_stmt_operands (stmt);\n }\n \n \n /* Free any operands vectors in OPS.  */\n-\n+#if 0\n static void \n free_ssa_operands (stmt_operands_p ops)\n {\n-  if (ops->def_ops)\n-    free_defs (&(ops->def_ops));\n-  if (ops->use_ops)\n-    free_uses (&(ops->use_ops));\n-  if (ops->vuse_ops)\n-    free_vuses (&(ops->vuse_ops));\n-  if (ops->v_may_def_ops)\n-    free_v_may_defs (&(ops->v_may_def_ops));\n-  if (ops->v_must_def_ops)\n-    free_v_must_defs (&(ops->v_must_def_ops));\n+  ops->def_ops = NULL;\n+  ops->use_ops = NULL;\n+  ops->maydef_ops = NULL;\n+  ops->mustdef_ops = NULL;\n+  ops->vuse_ops = NULL;\n+  while (ops->memory.next != NULL)\n+    {\n+      operand_memory_p tmp = ops->memory.next;\n+      ops->memory.next = tmp->next;\n+      ggc_free (tmp);\n+    }\n+}\n+#endif\n+\n+\n+/* Get the operands of statement STMT.  Note that repeated calls to\n+   get_stmt_operands for the same statement will do nothing until the\n+   statement is marked modified by a call to mark_stmt_modified().  */\n+\n+void\n+update_stmt_operands (tree stmt)\n+{\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n+  /* If get_stmt_operands is called before SSA is initialized, dont\n+  do anything.  */\n+  if (!ssa_operands_active ())\n+    return;\n+  /* The optimizers cannot handle statements that are nothing but a\n+     _DECL.  This indicates a bug in the gimplifier.  */\n+  gcc_assert (!SSA_VAR_P (stmt));\n+\n+  gcc_assert (ann->modified);\n+\n+  timevar_push (TV_TREE_OPS);\n+\n+  build_ssa_operands (stmt);\n+\n+  /* Clear the modified bit for STMT.  Subsequent calls to\n+     get_stmt_operands for this statement will do nothing until the\n+     statement is marked modified by a call to mark_stmt_modified().  */\n+  ann->modified = 0;\n+\n+  timevar_pop (TV_TREE_OPS);\n+}\n+\n+  \n+/* Copies virtual operands from SRC to DST.  */\n+\n+void\n+copy_virtual_operands (tree dest, tree src)\n+{\n+  tree t;\n+  ssa_op_iter iter, old_iter;\n+  use_operand_p use_p, u2;\n+  def_operand_p def_p, d2;\n+\n+  build_ssa_operands (dest);\n+\n+  /* Copy all the virtuial fields.  */\n+  FOR_EACH_SSA_TREE_OPERAND (t, src, iter, SSA_OP_VUSE)\n+    append_vuse (t);\n+  FOR_EACH_SSA_TREE_OPERAND (t, src, iter, SSA_OP_VMAYDEF)\n+    append_v_may_def (t);\n+  FOR_EACH_SSA_TREE_OPERAND (t, src, iter, SSA_OP_VMUSTDEF)\n+    append_v_must_def (t);\n+\n+  if (opbuild_num_elems (&build_vuses) == 0\n+      && opbuild_num_elems (&build_v_may_defs) == 0\n+      && opbuild_num_elems (&build_v_must_defs) == 0)\n+    return;\n+\n+  /* Now commit the virtual operands to this stmt.  */\n+  finalize_ssa_v_must_defs (dest);\n+  finalize_ssa_v_may_defs (dest);\n+  finalize_ssa_vuses (dest);\n+\n+  /* Finally, set the field to the same values as then originals.  */\n+\n+  \n+  t = op_iter_init_tree (&old_iter, src, SSA_OP_VUSE);\n+  FOR_EACH_SSA_USE_OPERAND (use_p, dest, iter, SSA_OP_VUSE)\n+    {\n+      gcc_assert (!op_iter_done (&old_iter));\n+      SET_USE (use_p, t);\n+      t = op_iter_next_tree (&old_iter);\n+    }\n+  gcc_assert (op_iter_done (&old_iter));\n+\n+  op_iter_init_maydef (&old_iter, src, &u2, &d2);\n+  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, dest, iter)\n+    {\n+      gcc_assert (!op_iter_done (&old_iter));\n+      SET_USE (use_p, USE_FROM_PTR (u2));\n+      SET_DEF (def_p, DEF_FROM_PTR (d2));\n+      op_iter_next_maymustdef (&u2, &d2, &old_iter);\n+    }\n+  gcc_assert (op_iter_done (&old_iter));\n+\n+  op_iter_init_mustdef (&old_iter, src, &u2, &d2);\n+  FOR_EACH_SSA_MUSTDEF_OPERAND (def_p, use_p, dest, iter)\n+    {\n+      gcc_assert (!op_iter_done (&old_iter));\n+      SET_USE (use_p, USE_FROM_PTR (u2));\n+      SET_DEF (def_p, DEF_FROM_PTR (d2));\n+      op_iter_next_maymustdef (&u2, &d2, &old_iter);\n+    }\n+  gcc_assert (op_iter_done (&old_iter));\n+\n }\n \n \n-/* Swap operands EXP0 and EXP1 in STMT.  */\n+/* Specifically for use in DOM's expression analysis.  Given a store, we\n+   create an artificial stmt which looks like a load from the store, this can\n+   be used to eliminate redundant loads.  OLD_OPS are the operands from the \n+   store stmt, and NEW_STMT is the new load which represents a load of the\n+   values stored.  */\n+\n+void\n+create_ssa_artficial_load_stmt (tree new_stmt, tree old_stmt)\n+{\n+  stmt_ann_t ann;\n+  tree op;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  unsigned x;\n+\n+  ann = get_stmt_ann (new_stmt);\n+\n+  /* process the stmt looking for operands.  */\n+  start_ssa_stmt_operands ();\n+  parse_ssa_operands (new_stmt);\n+\n+  for (x = 0; x < opbuild_num_elems (&build_vuses); x++)\n+    {\n+      tree t = opbuild_elem_virtual (&build_vuses, x);\n+      if (TREE_CODE (t) != SSA_NAME)\n+\t{\n+\t  var_ann_t ann = var_ann (t);\n+\t  ann->in_vuse_list = 0;\n+\t}\n+    }\n+   \n+  for (x = 0; x < opbuild_num_elems (&build_v_may_defs); x++)\n+    {\n+      tree t = opbuild_elem_virtual (&build_v_may_defs, x);\n+      if (TREE_CODE (t) != SSA_NAME)\n+\t{\n+\t  var_ann_t ann = var_ann (t);\n+\t  ann->in_v_may_def_list = 0;\n+\t}\n+    }\n+  /* Remove any virtual operands that were found.  */\n+  opbuild_clear (&build_v_may_defs);\n+  opbuild_clear (&build_v_must_defs);\n+  opbuild_clear (&build_vuses);\n+\n+  /* For each VDEF on the original statement, we want to create a\n+     VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n+     statement.  */\n+  FOR_EACH_SSA_TREE_OPERAND (op, old_stmt, iter, \n+\t\t\t     (SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF))\n+    append_vuse (op);\n+    \n+  /* Now build the operands for this new stmt.  */\n+  finalize_ssa_stmt_operands (new_stmt);\n+\n+  /* All uses in this fake stmt must not be in the immediate use lists.  */\n+  FOR_EACH_SSA_USE_OPERAND (use_p, new_stmt, iter, SSA_OP_ALL_USES)\n+    delink_imm_use (use_p);\n+}\n \n static void\n-swap_tree_operands (tree *exp0, tree *exp1)\n+swap_tree_operands (tree stmt, tree *exp0, tree *exp1)\n {\n   tree op0, op1;\n   op0 = *exp0;\n   op1 = *exp1;\n \n   /* If the operand cache is active, attempt to preserve the relative positions\n      of these two operands in their respective immediate use lists.  */\n-  if (build_defs != NULL && op0 != op1 && parse_old_ops != NULL)\n+  if (ssa_operands_active () && op0 != op1)\n     {\n-      unsigned x, use0, use1;\n-      use_optype uses = parse_old_ops->use_ops;\n-      use0 = use1 = NUM_USES (uses);\n+      use_optype_p use0, use1, ptr;\n+      use0 = use1 = NULL;\n       /* Find the 2 operands in the cache, if they are there.  */\n-      for (x = 0; x < NUM_USES (uses); x++)\n-\tif (USE_OP_PTR (uses, x)->use == exp0)\n+      for (ptr = USE_OPS (stmt); ptr; ptr = ptr->next)\n+\tif (USE_OP_PTR (ptr)->use == exp0)\n \t  {\n-\t    use0 = x;\n+\t    use0 = ptr;\n \t    break;\n \t  }\n-      for (x = 0; x < NUM_USES (uses); x++)\n-\tif (USE_OP_PTR (uses, x)->use == exp1)\n+      for (ptr = USE_OPS (stmt); ptr; ptr = ptr->next)\n+\tif (USE_OP_PTR (ptr)->use == exp1)\n \t  {\n-\t    use1 = x;\n+\t    use1 = ptr;\n \t    break;\n \t  }\n       /* If both uses don't have operand entries, there isn't much we can do\n          at this point.  Presumably we dont need to worry about it.  */\n-      if (use0 != NUM_USES (uses) && use1 != NUM_USES (uses))\n+      if (use0 && use1)\n         {\n-\t  tree *tmp = USE_OP_PTR (uses, use1)->use;\n-\t  gcc_assert (use0 != use1);\n-\n-\t  USE_OP_PTR (uses, use1)->use = USE_OP_PTR (uses, use0)->use;\n-\t  USE_OP_PTR (uses, use0)->use = tmp;\n+\t  tree *tmp = USE_OP_PTR (use1)->use;\n+\t  USE_OP_PTR (use1)->use = USE_OP_PTR (use0)->use;\n+\t  USE_OP_PTR (use0)->use = tmp;\n \t}\n     }\n \n@@ -1215,39 +1218,6 @@ swap_tree_operands (tree *exp0, tree *exp1)\n   *exp1 = op0;\n }\n \n-/* Get the operands of statement STMT.  */\n-\n-void\n-update_stmt_operands (tree stmt)\n-{\n-  stmt_ann_t ann;\n-  stmt_operands_t old_operands;\n-\n-  /* Don't do anything if we are called before SSA is initialized.  */\n-  if (build_defs == NULL)\n-    return;\n-  /* The optimizers cannot handle statements that are nothing but a\n-     _DECL.  This indicates a bug in the gimplifier.  */\n-  gcc_assert (!SSA_VAR_P (stmt));\n-\n-  ann = get_stmt_ann (stmt);\n-\n-  gcc_assert (ann->modified);\n-\n-  timevar_push (TV_TREE_OPS);\n-\n-  old_operands = ann->operands;\n-  memset (&(ann->operands), 0, sizeof (stmt_operands_t));\n-\n-  build_ssa_operands (stmt, ann, &old_operands, &(ann->operands));\n-  free_ssa_operands (&old_operands);\n-\n-  /* Clear the modified bit for STMT.  */\n-  ann->modified = 0;\n-\n-  timevar_pop (TV_TREE_OPS);\n-}\n-\n \n /* Recursively scan the expression pointed by EXPR_P in statement referred to\n    by INFO.  FLAGS is one of the OPF_* constants modifying how to interpret the\n@@ -1465,14 +1435,16 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t\t|| code == GE_EXPR)\n \t      {\n \t\tTREE_SET_CODE (expr, swap_tree_comparison (code));\n-\t\tswap_tree_operands (&TREE_OPERAND (expr, 0),\t\t\t\n+\t\tswap_tree_operands (stmt,\n+\t\t\t\t    &TREE_OPERAND (expr, 0),\t\t\t\n \t\t\t\t    &TREE_OPERAND (expr, 1));\n \t      }\n \t  \n \t    /* For a commutative operator we can just swap the operands.  */\n \t    else if (commutative_tree_code (code))\n \t      {\n-\t\tswap_tree_operands (&TREE_OPERAND (expr, 0),\t\t\t\n+\t\tswap_tree_operands (stmt,\n+\t\t\t\t    &TREE_OPERAND (expr, 0),\t\t\t\n \t\t\t\t    &TREE_OPERAND (expr, 1));\n \t      }\n \t  }\n@@ -1978,7 +1950,8 @@ note_addressable (tree var, stmt_ann_t s_ann)\n static void\n add_call_clobber_ops (tree stmt)\n {\n-  unsigned i;\n+  int i;\n+  unsigned u;\n   tree t;\n   bitmap_iterator bi;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n@@ -2000,19 +1973,21 @@ add_call_clobber_ops (tree stmt)\n   /* If cache is valid, copy the elements into the build vectors.  */\n   if (ssa_call_clobbered_cache_valid)\n     {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (clobbered_vuses); i++)\n+      /* Process the caches in reverse order so we are always inserting at\n+         the head of the list.  */\n+      for (i = VARRAY_ACTIVE_SIZE (clobbered_vuses) - 1; i >=0; i--)\n \t{\n \t  t = VARRAY_TREE (clobbered_vuses, i);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_vuse_list = 1;\n-\t  VARRAY_PUSH_TREE (build_vuses, t);\n+\t  opbuild_append_virtual (&build_vuses, t);\n \t}\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (clobbered_v_may_defs); i++)\n+      for (i = VARRAY_ACTIVE_SIZE (clobbered_v_may_defs) - 1; i >= 0; i--)\n \t{\n \t  t = VARRAY_TREE (clobbered_v_may_defs, i);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_v_may_def_list = 1;\n-\t  VARRAY_PUSH_TREE (build_v_may_defs, t);\n+\t  opbuild_append_virtual (&build_v_may_defs, t);\n \t}\n       if (s_ann)\n \t{\n@@ -2025,9 +2000,9 @@ add_call_clobber_ops (tree stmt)\n   memset (&empty_ann, 0, sizeof (struct stmt_ann_d));\n \n   /* Add a V_MAY_DEF operand for every call clobbered variable.  */\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, u, bi)\n     {\n-      tree var = referenced_var (i);\n+      tree var = referenced_var (u);\n       if (unmodifiable_var_p (var))\n \tadd_stmt_operand (&var, &empty_ann, opf_none);\n       else\n@@ -2057,10 +2032,22 @@ add_call_clobber_ops (tree stmt)\n     }\n \n   /* Now fill the clobbered cache with the values that have been found.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vuses); i++)\n-    VARRAY_PUSH_TREE (clobbered_vuses, VARRAY_TREE (build_vuses, i));\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_may_defs); i++)\n-    VARRAY_PUSH_TREE (clobbered_v_may_defs, VARRAY_TREE (build_v_may_defs, i));\n+  for (i = opbuild_first (&build_vuses);\n+       i != OPBUILD_LAST;\n+       i = opbuild_next (&build_vuses, i))\n+    VARRAY_PUSH_TREE (clobbered_vuses, opbuild_elem_virtual (&build_vuses, i));\n+\n+  gcc_assert (opbuild_num_elems (&build_vuses) \n+\t      == VARRAY_ACTIVE_SIZE (clobbered_vuses));\n+\n+  for (i = opbuild_first (&build_v_may_defs);\n+       i != OPBUILD_LAST;\n+       i = opbuild_next (&build_v_may_defs, i))\n+    VARRAY_PUSH_TREE (clobbered_v_may_defs, \n+\t\t      opbuild_elem_virtual (&build_v_may_defs, i));\n+\n+  gcc_assert (opbuild_num_elems (&build_v_may_defs) \n+\t      == VARRAY_ACTIVE_SIZE (clobbered_v_may_defs));\n \n   ssa_call_clobbered_cache_valid = true;\n }\n@@ -2072,7 +2059,8 @@ add_call_clobber_ops (tree stmt)\n static void\n add_call_read_ops (tree stmt)\n {\n-  unsigned i;\n+  int i;\n+  unsigned u;\n   tree t;\n   bitmap_iterator bi;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n@@ -2090,12 +2078,14 @@ add_call_read_ops (tree stmt)\n   /* If cache is valid, copy the elements into the build vector.  */\n   if (ssa_ro_call_cache_valid)\n     {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (ro_call_vuses); i++)\n+      for (i = VARRAY_ACTIVE_SIZE (ro_call_vuses) - 1; i >=0 ; i--)\n \t{\n+\t  /* Process the caches in reverse order so we are always inserting at\n+\t     the head of the list.  */\n \t  t = VARRAY_TREE (ro_call_vuses, i);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_vuse_list = 1;\n-\t  VARRAY_PUSH_TREE (build_vuses, t);\n+\t  opbuild_append_virtual (&build_vuses, t);\n \t}\n       if (s_ann)\n \ts_ann->makes_aliased_loads = ro_call_aliased_loads;\n@@ -2105,9 +2095,9 @@ add_call_read_ops (tree stmt)\n   memset (&empty_ann, 0, sizeof (struct stmt_ann_d));\n \n   /* Add a VUSE for each call-clobbered variable.  */\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, u, bi)\n     {\n-      tree var = referenced_var (i);\n+      tree var = referenced_var (u);\n       add_stmt_operand (&var, &empty_ann, opf_none);\n     }\n \n@@ -2121,112 +2111,27 @@ add_call_read_ops (tree stmt)\n   else\n     VARRAY_TREE_INIT (ro_call_vuses, 10, \"ro_call_vuses\");\n \n+\n   /* Now fill the clobbered cache with the values that have been found.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vuses); i++)\n-    VARRAY_PUSH_TREE (ro_call_vuses, VARRAY_TREE (build_vuses, i));\n+  for (i = opbuild_first (&build_vuses);\n+       i != OPBUILD_LAST;\n+       i = opbuild_next (&build_vuses, i))\n+    VARRAY_PUSH_TREE (ro_call_vuses, opbuild_elem_virtual (&build_vuses, i));\n \n-  ssa_ro_call_cache_valid = true;\n-}\n+  gcc_assert (opbuild_num_elems (&build_vuses) \n+\t      == VARRAY_ACTIVE_SIZE (ro_call_vuses));\n \n-/* Copies virtual operands from SRC to DST.  */\n-\n-void\n-copy_virtual_operands (tree dst, tree src)\n-{\n-  unsigned i;\n-  vuse_optype vuses = STMT_VUSE_OPS (src);\n-  v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (src);\n-  v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (src);\n-  vuse_optype *vuses_new = &stmt_ann (dst)->operands.vuse_ops;\n-  v_may_def_optype *v_may_defs_new = &stmt_ann (dst)->operands.v_may_def_ops;\n-  v_must_def_optype *v_must_defs_new = &stmt_ann (dst)->operands.v_must_def_ops;\n-\n-  if (vuses)\n-    {\n-      *vuses_new = allocate_vuse_optype (NUM_VUSES (vuses));\n-      for (i = 0; i < NUM_VUSES (vuses); i++)\n-\tinitialize_vuse_operand (*vuses_new, i, VUSE_OP (vuses, i), dst, NULL);\n-    }\n-\n-  if (v_may_defs)\n-    {\n-      *v_may_defs_new = allocate_v_may_def_optype (NUM_V_MAY_DEFS (v_may_defs));\n-      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t{\n-\t  initialize_v_may_def_operand (*v_may_defs_new, i, \n-\t\t\t\t\tV_MAY_DEF_RESULT (v_may_defs, i),\n-\t\t\t\t\tV_MAY_DEF_OP (v_may_defs, i), dst,\n-\t\t\t\t\tNULL);\n-\t}\n-    }\n-\n-  if (v_must_defs)\n-    {\n-      *v_must_defs_new \n-\t = allocate_v_must_def_optype (NUM_V_MUST_DEFS (v_must_defs));\n-      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\t{\n-\t  initialize_v_must_def_operand (*v_must_defs_new, i, \n-\t\t\t\t\t V_MUST_DEF_RESULT (v_must_defs, i),\n-\t\t\t\t\t V_MUST_DEF_KILL (v_must_defs, i), dst,\n-\t\t\t\t\t NULL);\n-\t}\n-    }\n+  ssa_ro_call_cache_valid = true;\n }\n \n \n-/* Specifically for use in DOM's expression analysis.  Given a store, we\n-   create an artificial stmt which looks like a load from the store, this can\n-   be used to eliminate redundant loads.  OLD_OPS are the operands from the \n-   store stmt, and NEW_STMT is the new load which represents a load of the\n-   values stored.  */\n-\n-void\n-create_ssa_artficial_load_stmt (stmt_operands_p old_ops, tree new_stmt)\n-{\n-  stmt_ann_t ann;\n-  tree op;\n-  stmt_operands_t tmp;\n-  unsigned j;\n-\n-  memset (&tmp, 0, sizeof (stmt_operands_t));\n-  ann = get_stmt_ann (new_stmt);\n-\n-  /* Free operands just in case is was an existing stmt.  */\n-  free_ssa_operands (&(ann->operands));\n-\n-  build_ssa_operands (new_stmt, NULL, &tmp, &(ann->operands));\n-  free_vuses (&(ann->operands.vuse_ops));\n-  free_v_may_defs (&(ann->operands.v_may_def_ops));\n-  free_v_must_defs (&(ann->operands.v_must_def_ops));\n-  \n-  /* For each VDEF on the original statement, we want to create a\n-     VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n-     statement.  */\n-  for (j = 0; j < NUM_V_MAY_DEFS (old_ops->v_may_def_ops); j++)\n-    {\n-      op = V_MAY_DEF_RESULT (old_ops->v_may_def_ops, j);\n-      append_vuse (op);\n-    }\n-    \n-  for (j = 0; j < NUM_V_MUST_DEFS (old_ops->v_must_def_ops); j++)\n-    {\n-      op = V_MUST_DEF_RESULT (old_ops->v_must_def_ops, j);\n-      append_vuse (op);\n-    }\n-\n-  /* Now set the vuses for this new stmt.  */\n-  ann->operands.vuse_ops = finalize_ssa_vuses (&(tmp.vuse_ops), NULL);\n-}\n-\n /* Scan the immediate_use list for VAR making sure its linked properly.\n    return RTUE iof there is a problem.  */\n \n bool\n verify_imm_links (FILE *f, tree var)\n {\n-  ssa_imm_use_t *ptr, *prev;\n-  ssa_imm_use_t *list;\n+  use_operand_p ptr, prev, list;\n   int count;\n \n   gcc_assert (TREE_CODE (var) == SSA_NAME);\n@@ -2312,7 +2217,10 @@ dump_immediate_uses_for (FILE *file, tree var)\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n     {\n-      print_generic_stmt (file, USE_STMT (use_p), TDF_SLIM);\n+      if (!is_gimple_reg (USE_FROM_PTR (use_p)))\n+\tprint_generic_stmt (file, USE_STMT (use_p), TDF_VOPS);\n+      else\n+\tprint_generic_stmt (file, USE_STMT (use_p), TDF_SLIM);\n     }\n   fprintf(file, \"\\n\");\n }\n@@ -2351,5 +2259,4 @@ debug_immediate_uses_for (tree var)\n {\n   dump_immediate_uses_for (stderr, var);\n }\n-\n #include \"gt-tree-ssa-operands.h\""}, {"sha": "2fb8d97f08428fa5dc1dae4dcda183311c1f2d4a", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 166, "deletions": 147, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -25,155 +25,116 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n \n /* This represents a pointer to a DEF operand.  */\n-typedef struct def_operand_ptr GTY(())\n-{\n-  tree * GTY((skip(\"\"))) def;\n-} def_operand_p;\n+typedef tree *def_operand_p;\n \n /* This represents a pointer to a USE operand.  */\n-typedef ssa_imm_use_t *use_operand_p;\n+typedef ssa_use_operand_t *use_operand_p;\n \n+/* NULL operand types.  */\n #define NULL_USE_OPERAND_P \t\tNULL\n-extern def_operand_p NULL_DEF_OPERAND_P;\n+#define NULL_DEF_OPERAND_P \t\tNULL\n \n /* This represents the DEF operands of a stmt.  */\n-typedef struct def_optype_d GTY(())\n+struct def_optype_d\n {\n-  unsigned num_defs; \n-  struct def_operand_ptr GTY((length(\"%h.num_defs\"))) defs[1];\n-} def_optype_t;\n-\n-typedef def_optype_t *def_optype;\n-\n-/* Operand type which uses a pointer to a tree ihn an immediate use.  */\n-typedef ssa_imm_use_t use_operand_type_t;\n+  struct def_optype_d *next;\n+  tree *def_ptr;\n+};\n+typedef struct def_optype_d *def_optype_p;\n \n /* This represents the USE operands of a stmt.  */\n-typedef struct use_optype_d GTY(())\n-{\n-  unsigned num_uses; \n-  struct ssa_imm_use_d GTY((length(\"%h.num_uses\"))) uses[1];\n-} use_optype_t;\n-\n-typedef use_optype_t *use_optype;\n-\n-/* Operand type which stores a def a use, and an immediate use.  */\n-typedef struct v_def_use_operand_type GTY(())\n+struct use_optype_d \n {\n-  tree def;\n-  tree use;\n-  ssa_imm_use_t imm_use;\n-} v_def_use_operand_type_t;\n+  struct use_optype_d *next;\n+  struct ssa_use_operand_d use_ptr;\n+};\n+typedef struct use_optype_d *use_optype_p;\n \n /* This represents the MAY_DEFS for a stmt.  */\n-typedef struct v_may_def_optype_d GTY(())\n+struct maydef_optype_d\n {\n-  unsigned num_v_may_defs; \n-  struct v_def_use_operand_type GTY((length (\"%h.num_v_may_defs\")))\n-\t\t\t\t\t\t\t      v_may_defs[1];\n-} v_may_def_optype_t;\n-\n-typedef v_may_def_optype_t *v_may_def_optype;\n-\n-/* Operand type which stores a tree and an immeidate_use.  */\n-typedef struct vuse_operand_type GTY(())\n-{\n-  tree use;\n-  ssa_imm_use_t imm_use;\n-} vuse_operand_type_t;\n+  struct maydef_optype_d *next;\n+  tree def_var;\n+  tree use_var;\n+  struct ssa_use_operand_d use_ptr;\n+};\n+typedef struct maydef_optype_d *maydef_optype_p;\n \n /* This represents the VUSEs for a stmt.  */\n-typedef struct vuse_optype_d GTY(()) \n+struct vuse_optype_d\n+{\n+  struct vuse_optype_d *next;\n+  tree use_var;\n+  struct ssa_use_operand_d use_ptr;\n+};\n+typedef struct vuse_optype_d *vuse_optype_p;\n+                                                                              \n+/* This represents the V_MUST_DEFS for a stmt.  */\n+struct mustdef_optype_d\n {\n-  unsigned num_vuses; \n-  struct vuse_operand_type GTY((length (\"%h.num_vuses\"))) vuses[1];\n-} vuse_optype_t;\n+  struct mustdef_optype_d *next;\n+  tree def_var;\n+  tree kill_var;\n+  struct ssa_use_operand_d use_ptr;\n+};\n+typedef struct mustdef_optype_d *mustdef_optype_p;\n \n-typedef vuse_optype_t *vuse_optype;\n \n-/* This represents the V_MUST_DEFS for a stmt.  */\n-typedef struct v_must_def_optype_d GTY(())\n+#define SSA_OPERAND_MEMORY_SIZE\t\t(2048 - sizeof (void *))\n+                                                                              \n+struct ssa_operand_memory_d GTY((chain_next(\"%h.next\")))\n {\n-  unsigned num_v_must_defs; \n-  v_def_use_operand_type_t GTY((length(\"%h.num_v_must_defs\"))) v_must_defs[1];\n-} v_must_def_optype_t;\n+  struct ssa_operand_memory_d *next;\n+  char mem[SSA_OPERAND_MEMORY_SIZE];\n+};\n \n-typedef v_must_def_optype_t *v_must_def_optype;\n \n /* This represents the operand cache for a stmt.  */\n-typedef struct stmt_operands_d GTY(())\n+struct stmt_operands_d\n {\n   /* Statement operands.  */\n-  struct def_optype_d * GTY (()) def_ops;\n-  struct use_optype_d * GTY (()) use_ops;\n-\n+  struct def_optype_d * def_ops;\n+  struct use_optype_d * use_ops;\n+                                                                              \n   /* Virtual operands (V_MAY_DEF, VUSE, and V_MUST_DEF).  */\n-  struct v_may_def_optype_d * GTY (()) v_may_def_ops;\n-  struct vuse_optype_d * GTY (()) vuse_ops;\n-  struct v_must_def_optype_d * GTY (()) v_must_def_ops;\n-} stmt_operands_t;\n-\n-typedef stmt_operands_t *stmt_operands_p;\n-\n-#define USE_FROM_PTR(OP)\tget_use_from_ptr (OP)\n-#define DEF_FROM_PTR(OP)\tget_def_from_ptr (OP)\n-#define SET_USE(OP, V)\t\tset_ssa_use_from_ptr (OP, V)\n-#define SET_DEF(OP, V)\t\t((*((OP).def)) = (V))\n-\n-#define USE_STMT(OP)\t\t(OP)->stmt\n-\n-#define USE_OPS(ANN)\t\tget_use_ops (ANN)\n-#define STMT_USE_OPS(STMT)\tget_use_ops (stmt_ann (STMT))\n-#define NUM_USES(OPS)\t\t((OPS) ? (OPS)->num_uses : 0)\n-#define USE_OP_PTR(OPS, I)\tget_use_op_ptr ((OPS), (I))\n-#define USE_OP(OPS, I)\t\t(USE_FROM_PTR (USE_OP_PTR ((OPS), (I))))\n-#define SET_USE_OP(OPS, I, V)\t(SET_USE (USE_OP_PTR ((OPS), (I)), (V)))\n-\n-\n-\n-#define DEF_OPS(ANN)\t\tget_def_ops (ANN)\n-#define STMT_DEF_OPS(STMT)\tget_def_ops (stmt_ann (STMT))\n-#define NUM_DEFS(OPS)\t\t((OPS) ? (OPS)->num_defs : 0)\n-#define DEF_OP_PTR(OPS, I)\tget_def_op_ptr ((OPS), (I))\n-#define DEF_OP(OPS, I)\t\t(DEF_FROM_PTR (DEF_OP_PTR ((OPS), (I))))\n-#define SET_DEF_OP(OPS, I, V)\t(SET_DEF (DEF_OP_PTR ((OPS), (I)), (V)))\n-\n-\n-\n-#define V_MAY_DEF_OPS(ANN)\t\tget_v_may_def_ops (ANN)\n-#define STMT_V_MAY_DEF_OPS(STMT)\tget_v_may_def_ops (stmt_ann(STMT))\n-#define NUM_V_MAY_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_may_defs : 0)\n-#define V_MAY_DEF_RESULT_PTR(OPS, I)\tget_v_may_def_result_ptr ((OPS), (I))\n-#define V_MAY_DEF_RESULT(OPS, I)\t\t\t\t\t\\\n-\t\t\t    (DEF_FROM_PTR (V_MAY_DEF_RESULT_PTR ((OPS), (I))))\n-#define SET_V_MAY_DEF_RESULT(OPS, I, V)\t\t\t\t\t\\\n-\t\t\t    (SET_DEF (V_MAY_DEF_RESULT_PTR ((OPS), (I)), (V)))\n-#define V_MAY_DEF_OP_PTR(OPS, I)\tget_v_may_def_op_ptr ((OPS), (I))\n-#define V_MAY_DEF_OP(OPS, I)\t\t\t\t\t\t\\\n-\t\t\t    (USE_FROM_PTR (V_MAY_DEF_OP_PTR ((OPS), (I))))\n-#define SET_V_MAY_DEF_OP(OPS, I, V)\t\t\t\t\t\\\n-\t\t\t    (SET_USE (V_MAY_DEF_OP_PTR ((OPS), (I)), (V)))\n-\n-\n-#define VUSE_OPS(ANN)\t\tget_vuse_ops (ANN)\n-#define STMT_VUSE_OPS(STMT)\tget_vuse_ops (stmt_ann(STMT))\n-#define NUM_VUSES(OPS)\t\t((OPS) ? (OPS)->num_vuses : 0)\n-#define VUSE_OP_PTR(OPS, I)  \tget_vuse_op_ptr ((OPS), (I))\n-#define VUSE_OP(OPS, I)  \t(USE_FROM_PTR (VUSE_OP_PTR ((OPS), (I))))\n-#define SET_VUSE_OP(OPS, I, V)\t(SET_USE (VUSE_OP_PTR ((OPS), (I)), (V)))\n-\n-\n-#define V_MUST_DEF_OPS(ANN)\t\tget_v_must_def_ops (ANN)\n-#define STMT_V_MUST_DEF_OPS(STMT)\tget_v_must_def_ops (stmt_ann (STMT))\n-#define NUM_V_MUST_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_must_defs : 0)\n-#define V_MUST_DEF_RESULT_PTR(OPS, I)\tget_v_must_def_result_ptr ((OPS), (I))\n-#define V_MUST_DEF_RESULT(OPS, I) \\\n-\t\t\t\t(DEF_FROM_PTR (V_MUST_DEF_RESULT_PTR ((OPS), (I))))\n-#define SET_V_MUST_DEF_RESULT(OPS, I, V) \\\n-\t\t\t\t(SET_DEF (V_MUST_DEF_RESULT_PTR ((OPS), (I)), (V)))\n-#define V_MUST_DEF_KILL_PTR(OPS, I)  get_v_must_def_kill_ptr ((OPS), (I))\n-#define V_MUST_DEF_KILL(OPS, I) (USE_FROM_PTR (V_MUST_DEF_KILL_PTR ((OPS), (I))))\n-#define SET_V_MUST_DEF_KILL(OPS, I, V) (SET_USE (V_MUST_DEF_KILL_PTR ((OPS), (I)), (V)))\n+  struct maydef_optype_d * maydef_ops;\n+  struct vuse_optype_d * vuse_ops;\n+  struct mustdef_optype_d * mustdef_ops;\n+};\n+                                                                              \n+typedef struct stmt_operands_d *stmt_operands_p;\n+                                                                              \n+#define USE_FROM_PTR(PTR)\tget_use_from_ptr (PTR)\n+#define DEF_FROM_PTR(PTR)\tget_def_from_ptr (PTR)\n+#define SET_USE(USE, V)\t\tset_ssa_use_from_ptr (USE, V)\n+#define SET_DEF(DEF, V)\t\t((*(DEF)) = (V))\n+\n+#define USE_STMT(USE)\t\t(USE)->stmt\n+\n+#define DEF_OPS(STMT)\t\t(stmt_ann (STMT)->operands.def_ops)\n+#define USE_OPS(STMT)\t\t(stmt_ann (STMT)->operands.use_ops)\n+#define VUSE_OPS(STMT)\t\t(stmt_ann (STMT)->operands.vuse_ops)\n+#define MAYDEF_OPS(STMT)\t(stmt_ann (STMT)->operands.maydef_ops)\n+#define MUSTDEF_OPS(STMT)\t(stmt_ann (STMT)->operands.mustdef_ops)\n+\n+#define USE_OP_PTR(OP)\t\t(&((OP)->use_ptr))\n+#define USE_OP(OP)\t\t(USE_FROM_PTR (USE_OP_PTR (OP)))\n+\n+#define DEF_OP_PTR(OP)\t\t((OP)->def_ptr)\n+#define DEF_OP(OP)\t\t(DEF_FROM_PTR (DEF_OP_PTR (OP)))\n+\n+#define VUSE_OP_PTR(OP)\t\tUSE_OP_PTR(OP)\n+#define VUSE_OP(OP)\t\t((OP)->use_var)\n+\n+#define MAYDEF_RESULT_PTR(OP)\t(&((OP)->def_var))\n+#define MAYDEF_RESULT(OP)\t((OP)->def_var)\n+#define MAYDEF_OP_PTR(OP)\tUSE_OP_PTR (OP)\n+#define MAYDEF_OP(OP)\t\t((OP)->use_var)\n+\n+#define MUSTDEF_RESULT_PTR(OP)\t(&((OP)->def_var))\n+#define MUSTDEF_RESULT(OP)\t((OP)->def_var)\n+#define MUSTDEF_KILL_PTR(OP)\tUSE_OP_PTR (OP)\n+#define MUSTDEF_KILL(OP)\t((OP)->kill_var)\n \n #define PHI_RESULT_PTR(PHI)\tget_phi_result_ptr (PHI)\n #define PHI_RESULT(PHI)\t\tDEF_FROM_PTR (PHI_RESULT_PTR (PHI))\n@@ -196,7 +157,7 @@ extern void update_stmt_operands (tree);\n extern bool verify_imm_links (FILE *f, tree var);\n \n extern void copy_virtual_operands (tree, tree);\n-extern void create_ssa_artficial_load_stmt (stmt_operands_p, tree);\n+extern void create_ssa_artficial_load_stmt (tree, tree);\n \n extern void dump_immediate_uses (FILE *file);\n extern void dump_immediate_uses_for (FILE *file, tree var);\n@@ -206,28 +167,33 @@ extern void debug_immediate_uses_for (tree var);\n extern bool ssa_call_clobbered_cache_valid;\n extern bool ssa_ro_call_cache_valid;\n \n+extern bool ssa_operands_active (void);\n+\n+enum ssa_op_iter_type {\n+  ssa_op_iter_none = 0,\n+  ssa_op_iter_tree,\n+  ssa_op_iter_use,\n+  ssa_op_iter_def,\n+  ssa_op_iter_maymustdef\n+};\n /* This structure is used in the operand iterator loops.  It contains the \n    items required to determine which operand is retrieved next.  During\n    optimization, this structure is scalarized, and any unused fields are \n    optimized away, resulting in little overhead.  */\n \n typedef struct ssa_operand_iterator_d\n {\n-  int num_use;\n-  int num_def;\n-  int num_vuse;\n-  int num_v_mayu;\n-  int num_v_mayd;\n-  int num_v_mustu;\n-  int num_v_mustd;\n-  int use_i;\n-  int def_i;\n-  int vuse_i;\n-  int v_mayu_i;\n-  int v_mayd_i;\n-  int v_mustu_i;\n-  int v_mustd_i;\n-  stmt_operands_p ops;\n+  def_optype_p defs;\n+  use_optype_p uses;\n+  vuse_optype_p vuses;\n+  maydef_optype_p maydefs;\n+  maydef_optype_p mayuses;\n+  mustdef_optype_p mustdefs;\n+  mustdef_optype_p mustkills;\n+  enum ssa_op_iter_type iter_type;\n+  int phi_i;\n+  int num_phi;\n+  tree phi_stmt;\n   bool done;\n } ssa_op_iter;\n \n@@ -239,17 +205,19 @@ typedef struct ssa_operand_iterator_d\n #define SSA_OP_VMAYUSE\t\t0x08\t/* USE portion of V_MAY_DEFS.  */\n #define SSA_OP_VMAYDEF\t\t0x10\t/* DEF portion of V_MAY_DEFS.  */\n #define SSA_OP_VMUSTDEF\t\t0x20\t/* V_MUST_DEF definitions.  */\n-#define SSA_OP_VMUSTDEFKILL     0x40    /* V_MUST_DEF kills.  */\n+#define SSA_OP_VMUSTKILL     \t0x40    /* V_MUST_DEF kills.  */\n \n /* These are commonly grouped operand flags.  */\n #define SSA_OP_VIRTUAL_USES\t(SSA_OP_VUSE | SSA_OP_VMAYUSE)\n #define SSA_OP_VIRTUAL_DEFS\t(SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF)\n-#define SSA_OP_VIRTUAL_KILLS    (SSA_OP_VMUSTDEFKILL)\n-#define SSA_OP_ALL_VIRTUALS     (SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS | SSA_OP_VIRTUAL_DEFS)\n+#define SSA_OP_VIRTUAL_KILLS    (SSA_OP_VMUSTKILL)\n+#define SSA_OP_ALL_VIRTUALS     (SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS \\\n+\t\t\t\t | SSA_OP_VIRTUAL_DEFS)\n #define SSA_OP_ALL_USES\t\t(SSA_OP_VIRTUAL_USES | SSA_OP_USE)\n #define SSA_OP_ALL_DEFS\t\t(SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)\n #define SSA_OP_ALL_KILLS        (SSA_OP_VIRTUAL_KILLS)\n-#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS | SSA_OP_ALL_KILLS)\n+#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS\t\\\n+\t\t\t\t | SSA_OP_ALL_KILLS)\n \n /* This macro executes a loop over the operands of STMT specified in FLAG, \n    returning each operand as a 'tree' in the variable TREEVAR.  ITER is an\n@@ -281,21 +249,72 @@ typedef struct ssa_operand_iterator_d\n #define FOR_EACH_SSA_MAYDEF_OPERAND(DEFVAR, USEVAR, STMT, ITER)\t\\\n   for (op_iter_init_maydef (&(ITER), STMT, &(USEVAR), &(DEFVAR));\t\\\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       op_iter_next_maydef (&(USEVAR), &(DEFVAR), &(ITER)))\n+       op_iter_next_maymustdef (&(USEVAR), &(DEFVAR), &(ITER)))\n \n /* This macro executes a loop over the V_MUST_DEF operands of STMT.  The def\n    and kill for each V_MUST_DEF is returned in DEFVAR and KILLVAR. \n    ITER is an ssa_op_iter structure used to control the loop.  */\n #define FOR_EACH_SSA_MUSTDEF_OPERAND(DEFVAR, KILLVAR, STMT, ITER)\t\\\n   for (op_iter_init_mustdef (&(ITER), STMT, &(KILLVAR), &(DEFVAR));\t\\\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       op_iter_next_mustdef (&(KILLVAR), &(DEFVAR), &(ITER)))\n+       op_iter_next_maymustdef (&(KILLVAR), &(DEFVAR), &(ITER)))\n \n /* This macro executes a loop over the V_{MUST,MAY}_DEF of STMT.  The def\n    and kill for each V_{MUST,MAY}_DEF is returned in DEFVAR and KILLVAR. \n    ITER is an ssa_op_iter structure used to control the loop.  */\n #define FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND(DEFVAR, KILLVAR, STMT, ITER)\\\n   for (op_iter_init_must_and_may_def (&(ITER), STMT, &(KILLVAR), &(DEFVAR));\\\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       op_iter_next_must_and_may_def (&(KILLVAR), &(DEFVAR), &(ITER)))\n+       op_iter_next_maymustdef (&(KILLVAR), &(DEFVAR), &(ITER)))\n+\n+/* This macro will execute a loop over all the arguemnts of a PHI which\n+   match FLAGS.   A use_operand_p is alwasy returned via USEVAR.  FLAGS\n+   can be eiother SSA_OP_USE or SSA_OP_VIRTUAL_USES or SSA_OP_ALL_USES.  */\n+#define FOR_EACH_PHI_ARG (USEVAR, STMT, ITER, FLAGS)\t\t\\\n+  for ((USEVAR) = op_iter_init_phiuse (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (USEVAR) = op_iter_next_use (&(ITER)))\n+\n+\n+/* This macro will execute a loop over a stmt, regardless of whether it is\n+   a real stmt or a PHI node, looking at the USE nodes matching FLAGS.  */\n+#define FOR_EACH_PHI_OR_STMT_USE(USEVAR, STMT, ITER, FLAGS)\t\\\n+  for ((USEVAR) = (TREE_CODE (STMT) == PHI_NODE \t\t\\\n+\t\t   ? op_iter_init_phiuse (&(ITER), STMT, FLAGS)\t\\\n+\t\t   : op_iter_init_use (&(ITER), STMT, FLAGS));\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (USEVAR) = op_iter_next_use (&(ITER)))\n+\n+/* This macro will execute a loop over a stmt, regardless of whether it is\n+   a real stmt or a PHI node, looking at the DEF nodes matching FLAGS.  */\n+#define FOR_EACH_PHI_OR_STMT_DEF(DEFVAR, STMT, ITER, FLAGS)\t\\\n+  for ((DEFVAR) = (TREE_CODE (STMT) == PHI_NODE \t\t\\\n+\t\t   ? op_iter_init_phidef (&(ITER), STMT, FLAGS)\t\\\n+\t\t   : op_iter_init_def (&(ITER), STMT, FLAGS));\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (DEFVAR) = op_iter_next_def (&(ITER)))\n+  \n+/* This macro returns an operand in STMT as a tree if it is the ONLY\n+   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n+   FLAGS, then NULL_TREE is returned.  */\n+#define SINGLE_SSA_TREE_OPERAND(STMT, FLAGS)\t\t\t\\\n+  single_ssa_tree_operand (STMT, FLAGS)\n+                                                                                \n+/* This macro returns an operand in STMT as a use_operand_p if it is the ONLY\n+   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n+   FLAGS, then NULL_USE_OPERAND_P is returned.  */\n+#define SINGLE_SSA_USE_OPERAND(STMT, FLAGS)\t\t\t\\\n+  single_ssa_use_operand (STMT, FLAGS)\n+                                                                                \n+/* This macro returns an operand in STMT as a def_operand_p if it is the ONLY\n+   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n+   FLAGS, then NULL_DEF_OPERAND_P is returned.  */\n+#define SINGLE_SSA_DEF_OPERAND(STMT, FLAGS)\t\t\t\\\n+  single_ssa_def_operand (STMT, FLAGS)\n+\t\t\t\t\t\t\t\t\t\t/* This macro returns TRUE if there are no operands matching FLAGS in STMT.  */\n+#define ZERO_SSA_OPERANDS(STMT, FLAGS) \tzero_ssa_operands (STMT, FLAGS)\n+\n+/* THis macro counts the number of operands in STMT matching FLAGS.  */\n+#define NUM_SSA_OPERANDS(STMT, FLAGS)\tnum_ssa_operands (STMT, FLAGS)\n+\n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "16850c06d49e34e4a5933d92476313d990e151d8", "filename": "gcc/tree-ssa-opfinalize.h", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-opfinalize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-opfinalize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-opfinalize.h?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -0,0 +1,175 @@\n+/* SSA operand allocation and finalizing.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+\n+/* This file contains common code which is used by each of the 5 operand \n+   types.  Macros are defined to specify the varying componenets.\n+\n+   FINALIZE_FUNC - name of finalize function.\n+   FINALIZE_ALLOC - name of allocation routine.\n+   FINALIZE_FREE - name of free list.\n+   FINALIZE_TYPE - type of node.\n+   FINALIZE_OPS - Lead element in list.\n+   FINALIZE_USE_PTR - How to get the use_operand_p, if this is a use operand.\n+   FINALIZE_INITIALIZE - How to initialize an element.\n+   FINALIZE_ELEM - How to retreive an element.\n+   FINALIZE_BASE - How to retreive the base variable of an element.\n+   FINALIZE_BASE_TYPE - Type of the base variable.\n+   FINALIZE_OPBUILD - Opbuild array for these nodes.\n+   FINALIZE_OPBUILD_ELEM - How to get an element from the opbuild list.\n+   FINALIZE_OPBUILD_BASE - How to get an element base from the opbuild list.\n+   FINALIZE_BASE_ZERO - How to zero an element.  */\n+\n+\n+/* This routine will either pick up a node from the free list, or allocate a\n+   new one if need be.  */\n+\n+static inline FINALIZE_TYPE *\n+FINALIZE_ALLOC (void)\n+{\n+  FINALIZE_TYPE *ret;\n+  if (FINALIZE_FREE)\n+    {\n+      ret = FINALIZE_FREE;\n+      FINALIZE_FREE = FINALIZE_FREE->next;\n+    }\n+  else\n+    ret = (FINALIZE_TYPE *)ssa_operand_alloc (sizeof (FINALIZE_TYPE));\n+  return ret;\n+}\n+\n+\n+\n+/* This routine will take the new operands from FINALIZE_OPBUILD and turn them\n+   into the new operands for STMT.  All required linking and deleting is u\n+   performed here.  */\n+static inline void\n+FINALIZE_FUNC (tree stmt)\n+{\n+  int new_i;\n+  FINALIZE_TYPE *old_ops, *ptr, *last;\n+  FINALIZE_BASE_TYPE old_base;\n+  FINALIZE_TYPE new_list;\n+\n+  new_list.next = NULL;\n+  last = &new_list;\n+\n+  old_ops = FINALIZE_OPS (stmt);\n+  if (old_ops)\n+    old_base = FINALIZE_BASE (FINALIZE_ELEM (old_ops));\n+  else\n+    old_base = FINALIZE_BASE_ZERO;\n+\n+  new_i = opbuild_first (&FINALIZE_OPBUILD);\n+  while (old_ops && new_i != OPBUILD_LAST)\n+    {\n+      FINALIZE_BASE_TYPE new_base = FINALIZE_OPBUILD_BASE (new_i);\n+      if (old_base == new_base)\n+        {\n+\t  /* if variables are the same, reuse this node.  */\n+\t  last->next = old_ops;\n+\t  last = old_ops;\n+#ifdef FINALIZE_USE_PTR\n+\t  correct_use_link (FINALIZE_USE_PTR (last), stmt);\n+#endif\n+\t  old_ops = old_ops->next;\n+\t  new_i = opbuild_next (&FINALIZE_OPBUILD, new_i);\n+\t}\n+      else\n+        if (old_base < new_base)\n+\t  {\n+\t    /* if old is less than new, old goes to the free list.  */\n+#ifdef FINALIZE_USE_PTR\n+\t    use_operand_p use_p = FINALIZE_USE_PTR (old_ops);\n+\t    delink_imm_use (use_p);\n+#endif\n+\t    ptr = old_ops;\n+\t    old_ops = old_ops->next;\n+\t    ptr->next = FINALIZE_FREE;\n+\t    FINALIZE_FREE = ptr;\n+\t  }\n+\telse\n+\t  {\n+\t    /* This is a new operand.  */\n+\t    ptr = FINALIZE_ALLOC ();\n+\t    FINALIZE_INITIALIZE (ptr, FINALIZE_OPBUILD_ELEM (new_i), stmt);\n+\t    last->next = ptr;\n+\t    last = ptr;\n+\t    new_i = opbuild_next (&FINALIZE_OPBUILD, new_i);\n+\t  }\n+      if (old_ops)\n+        old_base = FINALIZE_BASE (FINALIZE_ELEM (old_ops));\n+    }\n+\n+  /* If there is anything remaining in the opbuild list, simply emit them.  */\n+  for ( ; \n+\tnew_i != OPBUILD_LAST; \n+\tnew_i = opbuild_next (&FINALIZE_OPBUILD, new_i))\n+    {\n+      ptr = FINALIZE_ALLOC ();\n+      FINALIZE_INITIALIZE (ptr, FINALIZE_OPBUILD_ELEM (new_i), stmt);\n+      last->next = ptr;\n+      last = ptr;\n+    }\n+\n+  last->next = NULL;\n+\n+  /* If there is anything in the old list, free them.  */\n+  if (old_ops)\n+    {\n+#ifdef FINALIZE_USE_PTR\n+      for (ptr = old_ops; ptr; ptr = ptr->next)\n+\t{\n+\t  use_operand_p use_p = FINALIZE_USE_PTR (ptr);\n+\t  delink_imm_use (use_p);\n+\t}\n+#endif\n+      old_ops->next = FINALIZE_FREE;\n+      FINALIZE_FREE = old_ops;\n+    }\n+\n+  /* NOw set the stmt's operands.  */\n+  FINALIZE_OPS (stmt) = new_list.next;\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    unsigned x = 0;\n+    for (ptr = FINALIZE_OPS (stmt); ptr; ptr = ptr->next)\n+      x++;\n+\n+    gcc_assert (x == opbuild_num_elems (&FINALIZE_OPBUILD));\n+  }\n+#endif\n+}\n+\n+#undef FINALIZE_FUNC\n+#undef FINALIZE_ALLOC\n+#undef FINALIZE_FREE\n+#undef FINALIZE_TYPE\n+#undef FINALIZE_OPS\n+#undef FINALIZE_USE_PTR\n+#undef FINALIZE_INITIALIZE\n+#undef FINALIZE_ELEM\n+#undef FINALIZE_BASE\n+#undef FINALIZE_BASE_TYPE\n+#undef FINALIZE_OPBUILD\n+#undef FINALIZE_OPBUILD_ELEM\n+#undef FINALIZE_OPBUILD_BASE\n+#undef FINALIZE_BASE_ZERO"}, {"sha": "abc2a7e760e941398034841b053c48d25b0e5a13", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1758,17 +1758,17 @@ is_undefined_value (tree expr)\n    any). They are used when computing the hash value for EXPR.  */\n \n static inline void\n-add_to_sets (tree var, tree expr, vuse_optype vuses, bitmap_set_t s1,\n+add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n \t     bitmap_set_t s2)\n {\n-  tree val = vn_lookup_or_add (expr, vuses);\n+  tree val = vn_lookup_or_add (expr, stmt);\n \n   /* VAR and EXPR may be the same when processing statements for which\n      we are not computing value numbers (e.g., non-assignments, or\n      statements that make aliased stores).  In those cases, we are\n      only interested in making VAR available as its own value.  */\n   if (var != expr)\n-    vn_add (var, val, NULL);\n+    vn_add (var, val, NULL_TREE);\n \n   if (s1)\n     bitmap_insert_into_set (s1, var);\n@@ -1785,9 +1785,7 @@ add_to_sets (tree var, tree expr, vuse_optype vuses, bitmap_set_t s1,\n    Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n \n static inline tree\n-create_value_expr_from (tree expr, basic_block block,\n-\t\t\tvuse_optype vuses)\n-\n+create_value_expr_from (tree expr, basic_block block, tree stmt)\n {\n   int i;\n   enum tree_code code = TREE_CODE (expr);\n@@ -1829,9 +1827,9 @@ create_value_expr_from (tree expr, basic_block block,\n       /* Recursively value-numberize reference ops */\n       if (REFERENCE_CLASS_P (op))\n \t{\n-\t  tree tempop = create_value_expr_from (op, block, vuses);\n+\t  tree tempop = create_value_expr_from (op, block, stmt);\n \t  op = tempop ? tempop : op;\n-\t  val = vn_lookup_or_add (op, vuses);\n+\t  val = vn_lookup_or_add (op, stmt);\n \t}\n       else       \n \t/* Create a value handle for OP and add it to VEXPR.  */\n@@ -1922,7 +1920,8 @@ compute_avail (void)\n       for (bsi = bsi_start (block); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  stmt_ann_t ann;\n-\t  size_t j;\n+\t  ssa_op_iter iter;\n+\t  tree op;\n \n \t  stmt = bsi_stmt (bsi);\n \t  ann = stmt_ann (stmt);\n@@ -1938,7 +1937,6 @@ compute_avail (void)\n \t    {\n \t      tree lhs = TREE_OPERAND (stmt, 0);\n \t      tree rhs = TREE_OPERAND (stmt, 1);\n-\t      vuse_optype vuses = STMT_VUSE_OPS (stmt);\n \n \t      STRIP_USELESS_TYPE_CONVERSION (rhs);\n \t      if (UNARY_CLASS_P (rhs)\n@@ -1950,10 +1948,10 @@ compute_avail (void)\n \t\t     create a duplicate expression with the operands\n \t\t     replaced with the value handles of the original\n \t\t     RHS.  */\n-\t\t  tree newt = create_value_expr_from (rhs, block, vuses);\n+\t\t  tree newt = create_value_expr_from (rhs, block, stmt);\n \t\t  if (newt)\n \t\t    {\n-\t\t      add_to_sets (lhs, newt, vuses, TMP_GEN (block),\n+\t\t      add_to_sets (lhs, newt, stmt, TMP_GEN (block),\n \t\t\t\t   AVAIL_OUT (block));\n \t\t      value_insert_into_set (EXP_GEN (block), newt);\n \t\t      continue;\n@@ -1968,7 +1966,7 @@ compute_avail (void)\n \t\t  /* Compute a value number for the RHS of the statement\n \t\t     and add its value to the AVAIL_OUT set for the block.\n \t\t     Add the LHS to TMP_GEN.  */\n-\t\t  add_to_sets (lhs, rhs, vuses, TMP_GEN (block), \n+\t\t  add_to_sets (lhs, rhs, stmt, TMP_GEN (block), \n \t\t\t       AVAIL_OUT (block));\n \t\t  \n \t\t  if (TREE_CODE (rhs) == SSA_NAME\n@@ -1981,18 +1979,11 @@ compute_avail (void)\n \t  /* For any other statement that we don't recognize, simply\n \t     make the names generated by the statement available in\n \t     AVAIL_OUT and TMP_GEN.  */\n-\t  for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n-\t    {\n-\t      tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t      add_to_sets (def, def, NULL, TMP_GEN (block),\n-\t\t\t    AVAIL_OUT (block));\n-\t    }\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n+\t    add_to_sets (op, op, NULL, TMP_GEN (block), AVAIL_OUT (block));\n \n-\t  for (j = 0; j < NUM_USES (STMT_USE_OPS (stmt)); j++)\n-\t    {\n-\t      tree use = USE_OP (STMT_USE_OPS (stmt), j);\n-\t      add_to_sets (use, use, NULL, NULL, AVAIL_OUT (block));\n-\t    }\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\t    add_to_sets (op, op, NULL, NULL , AVAIL_OUT (block));\n \t}\n \n       /* Put the dominator children of BLOCK on the worklist of blocks"}, {"sha": "9f9fef100fad1526e732c27c73137f18fcb88414", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -678,12 +678,14 @@ ssa_propagate (ssa_prop_visit_stmt_fn visit_stmt,\n tree\n first_vdef (tree stmt)\n {\n-  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0)\n-    return V_MAY_DEF_RESULT (STMT_V_MAY_DEF_OPS (stmt), 0);\n-  else if (NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) > 0)\n-    return V_MUST_DEF_RESULT (STMT_V_MUST_DEF_OPS (stmt), 0);\n-  else\n-    gcc_unreachable ();\n+  ssa_op_iter iter;\n+  tree op;\n+\n+  /* Simply return the first operand we arrive at.  */\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+    return (op);\n+\n+  gcc_unreachable ();\n }\n \n \n@@ -700,8 +702,7 @@ stmt_makes_single_load (tree stmt)\n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n \n-  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0\n-      && NUM_VUSES (STMT_VUSE_OPS (stmt)) == 0)\n+  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF|SSA_OP_VUSE))\n     return false;\n \n   rhs = TREE_OPERAND (stmt, 1);\n@@ -726,8 +727,7 @@ stmt_makes_single_store (tree stmt)\n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n \n-  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0\n-      && NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) == 0)\n+  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF|SSA_OP_VMUSTDEF))\n     return false;\n \n   lhs = TREE_OPERAND (stmt, 0);"}, {"sha": "a234be8347c2fade2849863f057363fa980deb75", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -138,16 +138,10 @@ all_immediate_uses_same_place (tree stmt)\n bool\n is_hidden_global_store (tree stmt)\n {\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-    \n   /* Check virtual definitions.  If we get here, the only virtual\n      definitions we should see are those generated by assignment\n      statements.  */\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  if (NUM_V_MAY_DEFS (v_may_defs) > 0 || NUM_V_MUST_DEFS (v_must_defs) > 0)\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n     {\n       tree lhs;\n \n@@ -324,13 +318,13 @@ statement_sink_location (tree stmt, basic_block frombb)\n \n   */\n   ann = stmt_ann (stmt);\n-  if (NUM_VUSES (STMT_VUSE_OPS (stmt)) != 0\n-      || stmt_ends_bb_p (stmt)\n+  if (stmt_ends_bb_p (stmt)\n       || TREE_SIDE_EFFECTS (rhs)\n       || TREE_CODE (rhs) == EXC_PTR_EXPR\n       || TREE_CODE (rhs) == FILTER_EXPR\n       || is_hidden_global_store (stmt)\n-      || ann->has_volatile_ops)\n+      || ann->has_volatile_ops\n+      || !ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n     return NULL;\n   \n   FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n@@ -397,18 +391,10 @@ statement_sink_location (tree stmt, basic_block frombb)\n     }\n \n   /* Note that at this point, all uses must be in the same statement, so it\n-     doesn't matter which def op we choose.  */\n-  if (STMT_DEF_OPS (stmt) == NULL)\n-    {\n-      if (STMT_V_MAY_DEF_OPS (stmt) != NULL)\n-\tdef = V_MAY_DEF_RESULT (STMT_V_MAY_DEF_OPS (stmt), 0);\n-      else if (STMT_V_MUST_DEF_OPS (stmt) != NULL)\n-\tdef = V_MUST_DEF_RESULT (STMT_V_MUST_DEF_OPS (stmt), 0);\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else\n-    def = DEF_OP (STMT_DEF_OPS (stmt), 0);\n+     doesn't matter which def op we choose, pick the first one.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+    break;\n+\n   \n   sinkbb = find_bb_for_arg (use, def);\n   if (!sinkbb)"}, {"sha": "ac4e23353595b685ac002c0e84e99bfeb744b62c", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -709,8 +709,8 @@ verify_ssa (bool check_modified_stmt)\n \n \t  if (check_modified_stmt && stmt_modified_p (stmt))\n \t    {\n-\t      error (\"Stmt (0x%x) marked modified after optimization pass : \",\n-\t\t     (unsigned long)stmt);\n+\t      error (\"Stmt (%p) marked modified after optimization pass : \",\n+\t\t     (void *)stmt);\n \t      print_generic_stmt (stderr, stmt, TDF_VOPS);\n \t      goto err;\n \t    }\n@@ -725,8 +725,7 @@ verify_ssa (bool check_modified_stmt)\n \n \t      if (base_address\n \t\t  && SSA_VAR_P (base_address)\n-\t\t  && NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0\n-\t\t  && NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) == 0)\n+\t\t  && ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF|SSA_OP_VMUSTDEF))\n \t\t{\n \t\t  error (\"Statement makes a memory store, but has no \"\n \t\t\t \"V_MAY_DEFS nor V_MUST_DEFS\");\n@@ -737,7 +736,7 @@ verify_ssa (bool check_modified_stmt)\n \n \n \t  if (stmt_ann (stmt)->makes_aliased_stores \n-\t      && NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0)\n+\t      && ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF))\n \t    {\n \t      error (\"Statement makes aliased stores, but has no V_MAY_DEFS\");\n \t      print_generic_stmt (stderr, stmt, TDF_VOPS);\n@@ -806,12 +805,23 @@ delete_tree_ssa (void)\n   basic_block bb;\n   block_stmt_iterator bsi;\n \n+  /* Release any ssa_names still in use.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree var = ssa_name (i);\n+      if (var && TREE_CODE (var) == SSA_NAME)\n+        {\n+\t  SSA_NAME_IMM_USE_NODE (var).prev = &(SSA_NAME_IMM_USE_NODE (var));\n+\t  SSA_NAME_IMM_USE_NODE (var).next = &(SSA_NAME_IMM_USE_NODE (var));\n+\t}\n+      release_ssa_name (var);\n+    }\n+\n   /* Remove annotations from every tree in the function.  */\n   FOR_EACH_BB (bb)\n     for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n       {\n \ttree stmt = bsi_stmt (bsi);\n-        release_defs (stmt);\n \tggc_free (stmt->common.ann);\n \tstmt->common.ann = NULL;\n       }\n@@ -943,9 +953,7 @@ stmt_references_memory_p (tree stmt)\n   if (ann->has_volatile_ops)\n     return true;\n \n-  return (NUM_VUSES (VUSE_OPS (ann)) > 0\n-\t  || NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0\n-\t  || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0);\n+  return (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS));\n }\n \n /* Internal helper for walk_use_def_chains.  VAR, FN and DATA are as"}, {"sha": "2c4b0b7e2bfcc9e787d6481ec3ef23561884fb45", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -121,7 +121,7 @@ tree\n make_ssa_name (tree var, tree stmt)\n {\n   tree t;\n-  ssa_imm_use_t *imm;\n+  use_operand_p imm;\n \n   gcc_assert (DECL_P (var)\n \t      || TREE_CODE (var) == INDIRECT_REF);\n@@ -205,7 +205,7 @@ release_ssa_name (tree var)\n     {\n       tree saved_ssa_name_var = SSA_NAME_VAR (var);\n       int saved_ssa_name_version = SSA_NAME_VERSION (var);\n-      ssa_imm_use_t *imm = &(SSA_NAME_IMM_USE_NODE (var));\n+      use_operand_p imm = &(SSA_NAME_IMM_USE_NODE (var));\n \n #ifdef ENABLE_CHECKING\n       verify_imm_links (stderr, var);"}, {"sha": "bdeaf9cfaf99cca626d940e274a79b3d527d7cb8", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -413,9 +413,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n       /* If the statement has virtual or volatile operands, fail.  */\n       ann = stmt_ann (stmt);\n-      if (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann))\n-          || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann))\n-\t  || NUM_VUSES (VUSE_OPS (ann))\n+      if (!ZERO_SSA_OPERANDS (stmt, (SSA_OP_VUSE | SSA_OP_VIRTUAL_DEFS))\n \t  || ann->has_volatile_ops)\n \treturn;\n     }\n@@ -679,13 +677,13 @@ eliminate_tail_call (struct tailcall *t)\n   basic_block bb, first;\n   edge e;\n   tree phi;\n-  stmt_ann_t ann;\n-  v_may_def_optype v_may_defs;\n-  unsigned i;\n   block_stmt_iterator bsi;\n+  use_operand_p mayuse;\n+  def_operand_p maydef;\n+  ssa_op_iter iter;\n+  tree orig_stmt;\n \n-  stmt = bsi_stmt (t->call_bsi);\n-  ann = stmt_ann (stmt);\n+  stmt = orig_stmt = bsi_stmt (t->call_bsi);\n   bb = t->call_block;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -748,10 +746,9 @@ eliminate_tail_call (struct tailcall *t)\n     }\n \n   /* Add phi nodes for the call clobbered variables.  */\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+  FOR_EACH_SSA_MAYDEF_OPERAND (maydef, mayuse, orig_stmt, iter)\n     {\n-      param = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, i));\n+      param = SSA_NAME_VAR (DEF_FROM_PTR (maydef));\n       for (phi = phi_nodes (first); phi; phi = PHI_CHAIN (phi))\n \tif (param == SSA_NAME_VAR (PHI_RESULT (phi)))\n \t  break;\n@@ -782,7 +779,7 @@ eliminate_tail_call (struct tailcall *t)\n \t  gcc_assert (EDGE_COUNT (first->preds) <= 2);\n \t}\n \n-      add_phi_arg (phi, V_MAY_DEF_OP (v_may_defs, i), e);\n+      add_phi_arg (phi, USE_FROM_PTR (mayuse), e);\n     }\n \n   /* Update the values of accumulators.  */"}, {"sha": "7529effb076b81365fec823da441d7df6239f8d0", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1943,29 +1943,25 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  bool is_read = false;\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t  v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-\t  v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-\t  vuse_optype vuses = STMT_VUSE_OPS (stmt);\n \t  varray_type *datarefs = NULL;\n-\t  int nvuses, nv_may_defs, nv_must_defs;\n \t  tree memref = NULL;\n \t  tree scalar_type, vectype;\t  \n \t  tree base, offset, misalign, step, tag;\n \t  struct ptr_info_def *ptr_info;\n \t  bool base_aligned;\n \t  subvar_t subvars = NULL;\n+\t  bool no_vuse, no_vmaymust;\n \n \t  /* Assumption: there exists a data-ref in stmt, if and only if \n              it has vuses/vdefs.  */\n \n-\t  if (!vuses && !v_may_defs && !v_must_defs)\n+\t  no_vuse = ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE);\n+\t  no_vmaymust = ZERO_SSA_OPERANDS (stmt,\n+\t\t\t\t\t   SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF);\n+\t  if (no_vuse && no_vmaymust)\n \t    continue;\n \n-\t  nvuses = NUM_VUSES (vuses);\n-\t  nv_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n-\t  nv_must_defs = NUM_V_MUST_DEFS (v_must_defs);\n-\n-\t  if (nvuses && (nv_may_defs || nv_must_defs))\n+\t  if (!no_vuse && !no_vmaymust)\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t\t{\n@@ -1985,7 +1981,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      return false;\n \t    }\n \n-\t  if (vuses)\n+\t  if (!no_vuse)\n \t    {\n \t      memref = TREE_OPERAND (stmt, 1);\n \t      datarefs = &(LOOP_VINFO_DATAREF_READS (loop_vinfo));\n@@ -2106,49 +2102,29 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt)\n static bool\n vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n {\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   ssa_op_iter op_iter;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-  tree var;\n+  def_operand_p def_p;\n \n   /* cond stmt other than loop exit cond.  */\n   if (is_ctrl_stmt (stmt) && (stmt != LOOP_VINFO_EXIT_COND (loop_vinfo)))\n     return true;\n \n   /* changing memory.  */\n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    {\n-      if (!is_gimple_reg (PHI_RESULT (stmt)))\n-        return false;\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, PHI_RESULT (stmt))\n-\t{\n-\t  basic_block bb = bb_for_stmt (USE_STMT (use_p));\n-\t  if (!flow_bb_inside_loop_p (loop, bb))\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\t\tfprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n-\t      return true;\n-\t    }\n-\t}\n-      return false;\n-    }\n-\n-  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-  if (v_may_defs || v_must_defs)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\tfprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n-      return true;\n-    }\n+  if (TREE_CODE (stmt) != PHI_NODE)\n+    if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n+      {\n+\tif (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n+\treturn true;\n+      }\n \n   /* uses outside the loop.  */\n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, op_iter, SSA_OP_DEF)\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, op_iter, SSA_OP_DEF)\n     {\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, DEF_FROM_PTR (def_p))\n \t{\n \t  basic_block bb = bb_for_stmt (USE_STMT (use_p));\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n@@ -2188,11 +2164,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   unsigned int nbbs = loop->num_nodes;\n   block_stmt_iterator si;\n-  tree stmt;\n-  stmt_ann_t ann;\n+  tree stmt, use;\n+  ssa_op_iter iter;\n   unsigned int i;\n   int j;\n-  use_optype use_ops;\n   stmt_vec_info stmt_info;\n   basic_block bb;\n   tree phi;\n@@ -2291,12 +2266,8 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    }\n \t} \n \n-      ann = stmt_ann (stmt);\n-      use_ops = USE_OPS (ann);\n-\n-      for (i = 0; i < NUM_USES (use_ops); i++)\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t{\n-\t  tree use = USE_OP (use_ops, i);\n \n \t  /* We are only interested in uses that need to be vectorized. Uses \n \t     that are used for address computation are not considered relevant."}, {"sha": "17d65897cdb90a2b9cdac6cf12c286bf4829133e", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1499,13 +1499,12 @@ update_vuses_to_preheader (tree stmt, struct loop *loop)\n {\n   basic_block header_bb = loop->header;\n   edge preheader_e = loop_preheader_edge (loop);\n-  vuse_optype vuses = STMT_VUSE_OPS (stmt);\n-  int nvuses = NUM_VUSES (vuses);\n-  int i;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n \n-  for (i = 0; i < nvuses; i++)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_VUSE)\n     {\n-      tree ssa_name = VUSE_OP (vuses, i);\n+      tree ssa_name = USE_FROM_PTR (use_p);\n       tree def_stmt = SSA_NAME_DEF_STMT (ssa_name);\n       tree name_var = SSA_NAME_VAR (ssa_name);\n       basic_block bb = bb_for_stmt (def_stmt);\n@@ -1524,8 +1523,7 @@ update_vuses_to_preheader (tree stmt, struct loop *loop)\n \t    {\n \t      if (SSA_NAME_VAR (PHI_RESULT (phi)) == name_var)\n \t\t{\n-\t\t  SET_VUSE_OP (vuses, i, \n-\t\t\t       PHI_ARG_DEF (phi, preheader_e->dest_idx));\n+\t\t  SET_USE (use_p, PHI_ARG_DEF (phi, preheader_e->dest_idx));\n \t\t  updated = true;\n \t\t  break;\n \t\t}"}, {"sha": "95ecdd9fa9777c42e13f29ce017b84774f082cf8", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -215,36 +215,18 @@ rename_variables_in_bb (basic_block bb)\n   tree phi;\n   block_stmt_iterator bsi;\n   tree stmt;\n-  stmt_ann_t ann;\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  unsigned i;\n+  use_operand_p use_p;\n+  ssa_op_iter iter;\n   edge e;\n   edge_iterator ei;\n   struct loop *loop = bb->loop_father;\n \n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       stmt = bsi_stmt (bsi);\n-      ann = stmt_ann (stmt);\n-\n-      uses = USE_OPS (ann);\n-      for (i = 0; i < NUM_USES (uses); i++)\n-\trename_use_op (USE_OP_PTR (uses, i));\n-\n-      vuses = VUSE_OPS (ann);\n-      for (i = 0; i < NUM_VUSES (vuses); i++)\n-\trename_use_op (VUSE_OP_PTR (vuses, i));\n-\n-      v_may_defs = V_MAY_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\trename_use_op (V_MAY_DEF_OP_PTR (v_may_defs, i));\n-\n-      v_must_defs = V_MUST_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\trename_use_op (V_MUST_DEF_KILL_PTR (v_must_defs, i));\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, \n+\t\t\t\t (SSA_OP_ALL_USES | SSA_OP_ALL_KILLS))\n+\trename_use_op (use_p);\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "c1178e382b133fb433bd4b16671e8ea5f869d4aa", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -48,8 +48,8 @@ typedef struct val_expr_pair_d\n   /* Associated expression.  */\n   tree e;\n \n-  /* Virtual uses in E.  */\n-  vuse_optype vuses;\n+  /* for comparing Virtual uses in E.  */\n+  tree stmt;\n \n   /* E's hash value.  */\n   hashval_t hashcode;\n@@ -79,13 +79,13 @@ make_value_handle (tree type)\n    VAL can be used to iterate by passing previous value numbers (it is\n    used by iterative_hash_expr).\n \n-   VUSES is the set of virtual use operands associated with EXPR.  It\n-   may be NULL if EXPR has no virtual operands.  */\n+   STMT is the stmt associated with EXPR for comparing virtual operands.  */\n \n hashval_t\n-vn_compute (tree expr, hashval_t val, vuse_optype vuses)\n+vn_compute (tree expr, hashval_t val, tree stmt)\n {\n-  size_t i;\n+  ssa_op_iter iter;\n+  tree vuse;\n \n   /* EXPR must not be a statement.  We are only interested in value\n      numbering expressions on the RHS of assignments.  */\n@@ -97,8 +97,9 @@ vn_compute (tree expr, hashval_t val, vuse_optype vuses)\n \n   /* If the expression has virtual uses, incorporate them into the\n      hash value computed for EXPR.  */\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    val = iterative_hash_expr (VUSE_OP (vuses, i), val);\n+  if (stmt)\n+    FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n+      val = iterative_hash_expr (vuse,  val);\n \n   return val;\n }\n@@ -146,22 +147,15 @@ val_expr_pair_hash (const void *p)\n static int\n val_expr_pair_expr_eq (const void *p1, const void *p2)\n {\n+  bool ret;\n   const val_expr_pair_t ve1 = (val_expr_pair_t) p1;\n   const val_expr_pair_t ve2 = (val_expr_pair_t) p2;\n-  size_t i;\n \n   if (! expressions_equal_p (ve1->e, ve2->e))\n     return false;\n \n-  if (NUM_VUSES (ve1->vuses) != NUM_VUSES (ve2->vuses))\n-    return false;\n-  \n-  for (i = 0; i < NUM_VUSES (ve1->vuses); i++)\n-    if (! expressions_equal_p (VUSE_OP (ve1->vuses, i),\n-\t\t\t       VUSE_OP (ve2->vuses, i)))\n-      return false;\n-  \n-  return true;\n+  ret = compare_ssa_operands_equal (ve1->stmt, ve2->stmt, SSA_OP_VUSE);\n+  return ret;\n }\n \n \n@@ -181,21 +175,20 @@ set_value_handle (tree e, tree v)\n \n \n /* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n-   EXPR to the value set for value VAL.  VUSES represent the virtual\n-   use operands associated with EXPR (if any).  They are used when\n-   computing the hash value for EXPR.  */\n+   EXPR to the value set for value VAL.  STMT represent the stmt\n+   associated with EXPR.  It is used when computing a hash value for EXPR.  */\n \n void\n-vn_add (tree expr, tree val, vuse_optype vuses)\n+vn_add (tree expr, tree val, tree stmt)\n {\n   void **slot;\n   val_expr_pair_t new_pair;\n   \n   new_pair = xmalloc (sizeof (struct val_expr_pair_d));\n   new_pair->e = expr;\n   new_pair->v = val;\n-  new_pair->vuses = vuses;\n-  new_pair->hashcode = vn_compute (expr, 0, vuses);\n+  new_pair->stmt = stmt;\n+  new_pair->hashcode = vn_compute (expr, 0, stmt);\n   slot = htab_find_slot_with_hash (value_table, new_pair, new_pair->hashcode,\n \t\t\t\t   INSERT);\n   if (*slot)\n@@ -208,12 +201,12 @@ vn_add (tree expr, tree val, vuse_optype vuses)\n \n \n /* Search in VALUE_TABLE for an existing instance of expression EXPR,\n-   and return its value, or NULL if none has been set.  VUSES\n-   represent the virtual use operands associated with EXPR (if any).\n-   They are used when computing the hash value for EXPR.  */\n+   and return its value, or NULL if none has been set.  STMT\n+   represent the stmt associated with EXPR.   It is arused when computing the \n+   hash value for EXPR.  */\n \n tree\n-vn_lookup (tree expr, vuse_optype vuses)\n+vn_lookup (tree expr, tree stmt)\n {\n   void **slot;\n   struct val_expr_pair_d vep = {NULL, NULL, NULL, 0};\n@@ -223,8 +216,8 @@ vn_lookup (tree expr, vuse_optype vuses)\n     return expr;\n \n   vep.e = expr;\n-  vep.vuses = vuses;\n-  vep.hashcode = vn_compute (expr, 0, vuses); \n+  vep.stmt = stmt;\n+  vep.hashcode = vn_compute (expr, 0, stmt); \n   slot = htab_find_slot_with_hash (value_table, &vep, vep.hashcode, NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -235,14 +228,13 @@ vn_lookup (tree expr, vuse_optype vuses)\n \n /* Like vn_lookup, but creates a new value for expression EXPR, if\n    EXPR doesn't already have a value.  Return the existing/created\n-   value for EXPR.  VUSES represent the virtual use operands\n-   associated with EXPR (if any).  They are used when computing the\n-   hash value for EXPR.  */\n+   value for EXPR.  STMT represent the stmt associated with EXPR.  It is used\n+   when computing the hash value for EXPR.  */\n \n tree\n-vn_lookup_or_add (tree expr, vuse_optype vuses)\n+vn_lookup_or_add (tree expr, tree stmt)\n {\n-  tree v = vn_lookup (expr, vuses);\n+  tree v = vn_lookup (expr, stmt);\n   if (v == NULL_TREE)\n     {\n       v = make_value_handle (TREE_TYPE (expr));\n@@ -256,7 +248,7 @@ vn_lookup_or_add (tree expr, vuse_optype vuses)\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      vn_add (expr, v, vuses);\n+      vn_add (expr, v, stmt);\n     }\n \n   set_value_handle (expr, v);"}, {"sha": "8be79b5919c3280611a0ebba2ceed929b748a863", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1544,7 +1544,6 @@ maybe_add_assert_expr (basic_block bb)\n   block_stmt_iterator si;\n   tree last;\n   bool added;\n-  use_optype uses;\n \n   /* Step 1.  Mark all the SSA names used in BB in bitmap FOUND.  */\n   added = false;\n@@ -1628,16 +1627,20 @@ maybe_add_assert_expr (basic_block bb)\n   if (last\n       && TREE_CODE (last) == COND_EXPR\n       && !fp_predicate (COND_EXPR_COND (last))\n-      && NUM_USES (uses = STMT_USE_OPS (last)) > 0)\n+      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n     {\n       edge e;\n       edge_iterator ei;\n       tree op, cond;\n       basic_block son;\n+      ssa_op_iter iter;\n       \n       cond = COND_EXPR_COND (last);\n \n-      op = USE_OP (uses, 0);\n+      /* Get just the first use operand.  */\n+      FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n+\tbreak;\n+      gcc_assert (op != NULL);\n \n       /* Do not attempt to infer anything in names that flow through\n \t abnormal edges.  */\n@@ -1819,14 +1822,11 @@ stmt_interesting_for_vrp (tree stmt)\n   else if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n       tree lhs = TREE_OPERAND (stmt, 0);\n-      stmt_ann_t ann = stmt_ann (stmt);\n \n       if (TREE_CODE (lhs) == SSA_NAME\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n-\t  && NUM_VUSES (VUSE_OPS (ann)) == 0\n-\t  && NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) == 0)\n+\t  && ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n \treturn true;\n     }\n   else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n@@ -2080,9 +2080,7 @@ vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n \n   ann = stmt_ann (stmt);\n   if (TREE_CODE (stmt) == MODIFY_EXPR\n-      && NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n-      && NUM_VUSES (VUSE_OPS (ann)) == 0\n-      && NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) == 0)\n+      && ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return vrp_visit_assignment (stmt, output_p);\n   else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n     return vrp_visit_cond_stmt (stmt, taken_edge_p);"}, {"sha": "4600d51fdfc8435a6dfb13a24df38316c682c47b", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f47c96aac54c7d7b5e0855e1b52419435268d61f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f47c96aac54c7d7b5e0855e1b52419435268d61f", "patch": "@@ -1355,13 +1355,13 @@ struct value_range_def;\n \n /* Immediate use linking structure.  This structure is used for maintaining\n    a doubly linked list of uses of an SSA_NAME.  */\n-typedef struct ssa_imm_use_d GTY(())\n+typedef struct ssa_use_operand_d GTY(())\n {\n-  struct ssa_imm_use_d* GTY((skip(\"\"))) prev;\n-  struct ssa_imm_use_d* GTY((skip(\"\"))) next;\n+  struct ssa_use_operand_d* GTY((skip(\"\"))) prev;\n+  struct ssa_use_operand_d* GTY((skip(\"\"))) next;\n   tree GTY((skip(\"\"))) stmt;\n   tree *GTY((skip(\"\"))) use;\n-} ssa_imm_use_t;\n+} ssa_use_operand_t;\n \n /* Return the immediate_use information for an SSA_NAME. */\n #define SSA_NAME_IMM_USE_NODE(NODE) SSA_NAME_CHECK (NODE)->ssa_name.imm_uses\n@@ -1393,7 +1393,7 @@ struct tree_ssa_name GTY(())\n   PTR GTY((skip)) aux;\n \n   /* Immediate uses list for this SSA_NAME.  */\n-  struct ssa_imm_use_d imm_uses;\n+  struct ssa_use_operand_d imm_uses;\n };\n \f\n /* In a PHI_NODE node.  */\n@@ -1424,7 +1424,7 @@ struct phi_arg_d GTY(())\n {\n   /* imm_use MUST be the first element in struct because we do some\n      pointer arithmetic with it.  See phi_arg_index_from_use.  */\n-  struct ssa_imm_use_d imm_use;\n+  struct ssa_use_operand_d imm_use;\n   tree def;\n   bool nonzero;\n };"}]}