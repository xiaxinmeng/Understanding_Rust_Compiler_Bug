{"sha": "a7bba6ca0e41334dfc3768af39b48a142c5ed34e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdiYmE2Y2EwZTQxMzM0ZGZjMzc2OGFmMzliNDhhMTQyYzVlZDM0ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-01-26T11:11:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-01-26T11:11:11Z"}, "message": "re PR target/13666 (deviation from the psABI for small unions)\n\n\tPR target/13666\n\t* config/sparc/sparc.c (function_arg_union_value): New function.\n\t(function_arg): Use it to deal with unions.\n\t(function_value): Likewise.  Define 'regbase' only for ARCH64.\n\tReplace a conditional statement by a simpler one.\n\nFrom-SVN: r76628", "tree": {"sha": "394359c2d0d2c999ab3115d7051f0ff25fbdba04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/394359c2d0d2c999ab3115d7051f0ff25fbdba04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7bba6ca0e41334dfc3768af39b48a142c5ed34e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7bba6ca0e41334dfc3768af39b48a142c5ed34e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7bba6ca0e41334dfc3768af39b48a142c5ed34e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7bba6ca0e41334dfc3768af39b48a142c5ed34e/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2cb612d1b0459fdb72a0af8928741869f2fdaaed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cb612d1b0459fdb72a0af8928741869f2fdaaed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cb612d1b0459fdb72a0af8928741869f2fdaaed"}], "stats": {"total": 74, "additions": 58, "deletions": 16}, "files": [{"sha": "af75fc13ef374c8a5e2463eedb8d4facb5fb9a17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7bba6ca0e41334dfc3768af39b48a142c5ed34e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7bba6ca0e41334dfc3768af39b48a142c5ed34e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7bba6ca0e41334dfc3768af39b48a142c5ed34e", "patch": "@@ -1,3 +1,11 @@\n+2004-01-26  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/13666\n+\t* config/sparc/sparc.c (function_arg_union_value): New function.\n+\t(function_arg): Use it to deal with unions.\n+\t(function_value): Likewise.  Define 'regbase' only for ARCH64.\n+\tReplace a conditional statement by a simpler one.\n+\n 2004-01-26  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips16_optimize_gp): Delete."}, {"sha": "b732e7ae7069935f4c60504aa5b1a012fb064775", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7bba6ca0e41334dfc3768af39b48a142c5ed34e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7bba6ca0e41334dfc3768af39b48a142c5ed34e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a7bba6ca0e41334dfc3768af39b48a142c5ed34e", "patch": "@@ -4827,7 +4827,7 @@ init_cumulative_args (struct sparc_args *cum, tree fntype,\n    Sub-fields are not taken into account for the PACKED_P predicate.  */\n \n static void\n-scan_record_type(tree type, int *intregs_p, int *fpregs_p, int *packed_p)\n+scan_record_type (tree type, int *intregs_p, int *fpregs_p, int *packed_p)\n {\n   tree field;\n \n@@ -5002,6 +5002,7 @@ static void function_arg_record_value_2\n static void function_arg_record_value_1\n  (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *, bool);\n static rtx function_arg_record_value (tree, enum machine_mode, int, int, int);\n+static rtx function_arg_union_value (int, int);\n \n /* A subroutine of function_arg_record_value.  Traverse the structure\n    recursively and determine how many registers will be required.  */\n@@ -5335,6 +5336,34 @@ function_arg_record_value (tree type, enum machine_mode mode,\n   return parms.ret;\n }\n \n+/* Used by function_arg and function_value to implement the conventions\n+   of the 64-bit ABI for passing and returning unions.\n+   Return an expression valid as a return value for the two macros\n+   FUNCTION_ARG and FUNCTION_VALUE.\n+\n+   SIZE is the size in bytes of the union.\n+   REGNO is the hard register the union will be passed in.  */\n+\n+static rtx\n+function_arg_union_value (int size, int regno)\n+{\n+  enum machine_mode mode;\n+  rtx reg;\n+\n+  if (size <= UNITS_PER_WORD)\n+    mode = word_mode;\n+  else\n+    mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\n+  reg = gen_rtx_REG (mode, regno);\n+\n+  /* Unions are passed left-justified.  */\n+  return gen_rtx_PARALLEL (mode,\n+\t\t\t   gen_rtvec (1, gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t\t    reg,\n+\t\t\t\t\t\t\t    const0_rtx)));\n+}\n+\n /* Handle the FUNCTION_ARG macro.\n    Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -5384,14 +5413,12 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n     }\n   else if (type && TREE_CODE (type) == UNION_TYPE)\n     {\n-      enum machine_mode mode;\n-      int bytes = int_size_in_bytes (type);\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n \n-      if (bytes > 16)\n-\tabort ();\n+      if (size > 16)\n+\tabort (); /* shouldn't get here */\n \n-      mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n-      reg = gen_rtx_REG (mode, regno);\n+      return function_arg_union_value (size, regno);\n     }\n   /* v9 fp args in reg slots beyond the int reg slots get passed in regs\n      but also have the slot allocated for them.\n@@ -5646,12 +5673,13 @@ rtx\n function_value (tree type, enum machine_mode mode, int incoming_p)\n {\n   int regno;\n-  int regbase = (incoming_p\n-\t\t ? SPARC_OUTGOING_INT_ARG_FIRST\n-\t\t : SPARC_INCOMING_INT_ARG_FIRST);\n \n   if (TARGET_ARCH64 && type)\n     {\n+      int regbase = (incoming_p\n+\t\t     ? SPARC_OUTGOING_INT_ARG_FIRST\n+\t\t     : SPARC_INCOMING_INT_ARG_FIRST);\n+\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n \t  /* Structures up to 32 bytes in size are passed in registers,\n@@ -5662,6 +5690,15 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \n \t  return function_arg_record_value (type, mode, 0, 1, regbase);\n \t}\n+      else if (TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\n+\t  if (size > 32)\n+\t    abort (); /* shouldn't get here */\n+\n+\t  return function_arg_union_value (size, regbase);\n+\t}\n       else if (AGGREGATE_TYPE_P (type))\n \t{\n \t  /* All other aggregate types are passed in an integer register\n@@ -5673,13 +5710,10 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \n \t  mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n \t}\n+      else if (GET_MODE_CLASS (mode) == MODE_INT\n+\t       && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\tmode = word_mode;\n     }\n-    \n-  if (TARGET_ARCH64\n-      && GET_MODE_CLASS (mode) == MODE_INT \n-      && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n-      && type && ! AGGREGATE_TYPE_P (type))\n-    mode = DImode;\n \n   if (incoming_p)\n     regno = BASE_RETURN_VALUE_REG (mode);"}]}