{"sha": "9e6280242225587be256fdb80c41327736238e77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2MjgwMjQyMjI1NTg3YmUyNTZmZGI4MGM0MTMyNzczNjIzOGU3Nw==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2020-11-10T11:36:58Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2020-11-10T11:36:58Z"}, "message": "openmp: Implement OpenMP 5.0 base-pointer attachement and clause ordering\n\nThis patch implements some parts of the target variable mapping changes\nspecified in OpenMP 5.0, including base-pointer attachment/detachment\nbehavior for array section list-items in map clauses, and ordering of\nmap clauses according to map kind.\n\n2020-11-10  Chung-Lin Tang  <cltang@codesourcery.com>\n\ngcc/c-family/ChangeLog:\n\n\t* c-common.h (c_omp_adjust_map_clauses): New declaration.\n\t* c-omp.c (struct map_clause): Helper type for c_omp_adjust_map_clauses.\n\t(c_omp_adjust_map_clauses): New function.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_omp_target_data): Add use of\n\tnew c_omp_adjust_map_clauses function. Add GOMP_MAP_ATTACH_DETACH as\n\thandled map clause kind.\n\t(c_parser_omp_target_enter_data): Likewise.\n\t(c_parser_omp_target_exit_data): Likewise.\n\t(c_parser_omp_target): Likewise.\n\t* c-typeck.c (handle_omp_array_sections): Adjust COMPONENT_REF case to\n\tuse GOMP_MAP_ATTACH_DETACH map kind for C_ORT_OMP region type.\n\t(c_finish_omp_clauses): Adjust bitmap checks to allow struct decl and\n\tsame struct field access to co-exist on OpenMP construct.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_omp_target_data): Add use of\n\tnew c_omp_adjust_map_clauses function. Add GOMP_MAP_ATTACH_DETACH as\n\thandled map clause kind.\n\t(cp_parser_omp_target_enter_data): Likewise.\n\t(cp_parser_omp_target_exit_data): Likewise.\n\t(cp_parser_omp_target): Likewise.\n\t* semantics.c (handle_omp_array_sections): Adjust COMPONENT_REF case to\n\tuse GOMP_MAP_ATTACH_DETACH map kind for C_ORT_OMP region type. Fix\n\tinteraction between reference case and attach/detach.\n\t(finish_omp_clauses): Adjust bitmap checks to allow struct decl and\n\tsame struct field access to co-exist on OpenMP construct.\n\ngcc/ChangeLog:\n\n\t* gimplify.c (is_or_contains_p): New static helper function.\n\t(omp_target_reorder_clauses): New function.\n\t(gimplify_scan_omp_clauses): Add use of omp_target_reorder_clauses to\n\treorder clause list according to OpenMP 5.0 rules. Add handling of\n\tGOMP_MAP_ATTACH_DETACH for OpenMP cases.\n\t* omp-low.c (is_omp_target): New static helper function.\n\t(scan_sharing_clauses): Add scan phase handling of GOMP_MAP_ATTACH/DETACH\n\tfor OpenMP cases.\n\t(lower_omp_target): Add lowering handling of GOMP_MAP_ATTACH/DETACH for\n\tOpenMP cases.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/clauses-2.c: Remove dg-error cases now valid.\n\t* gfortran.dg/gomp/map-2.f90: Likewise.\n\t* c-c++-common/gomp/map-5.c: New testcase.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.h (enum gomp_map_vars_kind): Adjust enum values to be bit-flag\n\tusable.\n\t* oacc-mem.c (acc_map_data): Adjust gomp_map_vars argument flags to\n\t'GOMP_MAP_VARS_OPENACC | GOMP_MAP_VARS_ENTER_DATA'.\n\t(goacc_enter_datum): Likewise for call to gomp_map_vars_async.\n\t(goacc_enter_data_internal): Likewise.\n\t* target.c (gomp_map_vars_internal):\n\tChange checks of GOMP_MAP_VARS_ENTER_DATA to use bit-and (&). Adjust use\n\tof gomp_attach_pointer for OpenMP cases.\n\t(gomp_exit_data): Add handling of GOMP_MAP_DETACH.\n\t(GOMP_target_enter_exit_data): Add handling of GOMP_MAP_ATTACH.\n\t* testsuite/libgomp.c-c++-common/ptr-attach-1.c: New testcase.", "tree": {"sha": "b5e88c67ec188b75283218d9c5a1d856b0a54490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5e88c67ec188b75283218d9c5a1d856b0a54490"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e6280242225587be256fdb80c41327736238e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6280242225587be256fdb80c41327736238e77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e6280242225587be256fdb80c41327736238e77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6280242225587be256fdb80c41327736238e77/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba3d03da6f44d7dac2dc58c7663567ec345d5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba3d03da6f44d7dac2dc58c7663567ec345d5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba3d03da6f44d7dac2dc58c7663567ec345d5f4"}], "stats": {"total": 717, "additions": 615, "deletions": 102}, "files": [{"sha": "b80db230a6df4519213df60f41a42873c6d1aca4", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -1224,6 +1224,7 @@ extern enum omp_clause_defaultmap_kind c_omp_predetermined_mapping (tree);\n extern tree c_omp_check_context_selector (location_t, tree);\n extern void c_omp_mark_declare_variant (location_t, tree, tree);\n extern const char *c_omp_map_clause_name (tree, bool);\n+extern void c_omp_adjust_map_clauses (tree, bool);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n static inline tree"}, {"sha": "84572116c76faab0877e8a736c511ee0fbec6cb1", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -2771,3 +2771,93 @@ c_omp_map_clause_name (tree clause, bool oacc)\n     }\n   return omp_clause_code_name[OMP_CLAUSE_CODE (clause)];\n }\n+\n+/* Used to merge map clause information in c_omp_adjust_map_clauses.  */\n+struct map_clause\n+{\n+  tree clause;\n+  bool firstprivate_ptr_p;\n+  bool decl_mapped;\n+  bool omp_declare_target;\n+  map_clause (void) : clause (NULL_TREE), firstprivate_ptr_p (false),\n+    decl_mapped (false), omp_declare_target (false) { }\n+};\n+\n+/* Adjust map clauses after normal clause parsing, mainly to turn specific\n+   base-pointer map cases into attach/detach and mark them addressable.  */\n+void\n+c_omp_adjust_map_clauses (tree clauses, bool is_target)\n+{\n+  if (!is_target)\n+    {\n+      /* If this is not a target construct, just turn firstprivate pointers\n+\t into attach/detach, the runtime will check and do the rest.  */\n+\n+      for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t    && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t    && DECL_P (OMP_CLAUSE_DECL (c))\n+\t    && POINTER_TYPE_P (TREE_TYPE (OMP_CLAUSE_DECL (c))))\n+\t  {\n+\t    tree ptr = OMP_CLAUSE_DECL (c);\n+\t    OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ATTACH_DETACH);\n+\t    c_common_mark_addressable_vec (ptr);\n+\t  }\n+      return;\n+    }\n+\n+  hash_map<tree, map_clause> maps;\n+\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t&& DECL_P (OMP_CLAUSE_DECL (c)))\n+      {\n+\t/* If this is for a target construct, the firstprivate pointer\n+\t   is changed to attach/detach if either is true:\n+\t   (1) the base-pointer is mapped in this same construct, or\n+\t   (2) the base-pointer is a variable place on the device by\n+\t       \"declare target\" directives.\n+\n+\t   Here we iterate through all map clauses collecting these cases,\n+\t   and merge them with a hash_map to process below.  */\n+\n+\tif (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t    && POINTER_TYPE_P (TREE_TYPE (OMP_CLAUSE_DECL (c))))\n+\t  {\n+\t    tree ptr = OMP_CLAUSE_DECL (c);\n+\t    map_clause &mc = maps.get_or_insert (ptr);\n+\t    if (mc.clause == NULL_TREE)\n+\t      mc.clause = c;\n+\t    mc.firstprivate_ptr_p = true;\n+\n+\t    if (is_global_var (ptr)\n+\t\t&& lookup_attribute (\"omp declare target\",\n+\t\t\t\t     DECL_ATTRIBUTES (ptr)))\n+\t      mc.omp_declare_target = true;\n+\t  }\n+\telse if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALLOC\n+\t\t || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_TO\n+\t\t || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FROM\n+\t\t || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_TOFROM\n+\t\t || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TO\n+\t\t || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_FROM\n+\t\t || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TOFROM)\n+\t  {\n+\t    map_clause &mc = maps.get_or_insert (OMP_CLAUSE_DECL (c));\n+\t    mc.decl_mapped = true;\n+\t  }\n+      }\n+\n+  for (hash_map<tree, map_clause>::iterator i = maps.begin ();\n+       i != maps.end (); ++i)\n+    {\n+      map_clause &mc = (*i).second;\n+\n+      if (mc.firstprivate_ptr_p\n+\t  && (mc.decl_mapped || mc.omp_declare_target))\n+\t{\n+\t  OMP_CLAUSE_SET_MAP_KIND (mc.clause, GOMP_MAP_ATTACH_DETACH);\n+\t  c_common_mark_addressable_vec (OMP_CLAUSE_DECL (mc.clause));\n+\t}\n+    }\n+}"}, {"sha": "377914cad165f5bb43cdf6a37b922301fc7d7e3f", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -19511,6 +19511,7 @@ c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target data\");\n+  c_omp_adjust_map_clauses (clauses, false);\n   int map_seen = 0;\n   for (tree *pc = &clauses; *pc;)\n     {\n@@ -19528,6 +19529,7 @@ c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -19651,6 +19653,7 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target enter data\");\n+  c_omp_adjust_map_clauses (clauses, false);\n   int map_seen = 0;\n   for (tree *pc = &clauses; *pc;)\n     {\n@@ -19664,6 +19667,7 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -19735,7 +19739,7 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target exit data\");\n-\n+  c_omp_adjust_map_clauses (clauses, false);\n   int map_seen = 0;\n   for (tree *pc = &clauses; *pc;)\n     {\n@@ -19750,6 +19754,7 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \t    break;\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -19960,6 +19965,8 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n   OMP_TARGET_CLAUSES (stmt)\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target\");\n+  c_omp_adjust_map_clauses (OMP_TARGET_CLAUSES (stmt), true);\n+\n   pc = &OMP_TARGET_CLAUSES (stmt);\n   keep_next_level ();\n   block = c_begin_compound_stmt (true);\n@@ -19984,6 +19991,7 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n \t  case GOMP_MAP_ALLOC:\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    error_at (OMP_CLAUSE_LOCATION (*pc),"}, {"sha": "df1dad468df162c282d2306430cd98a537972dae", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -13584,11 +13584,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n       if (ort != C_ORT_OMP && ort != C_ORT_ACC)\n \tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n       else if (TREE_CODE (t) == COMPONENT_REF)\n-\t{\n-\t  gomp_map_kind k = (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n-\t\t\t\t\t       : GOMP_MAP_ALWAYS_POINTER;\n-\t  OMP_CLAUSE_SET_MAP_KIND (c2, k);\n-\t}\n+\tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n       else\n \tOMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n       if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n@@ -14711,7 +14707,9 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tbreak;\n \t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t\t{\n-\t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t))\n+\t\t      || (ort == C_ORT_OMP\n+\t\t\t  && bitmap_bit_p (&map_head, DECL_UID (t))))\n \t\t    break;\n \t\t}\n \t    }\n@@ -14780,7 +14778,9 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      else\n \t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n \t    }\n-\t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t  else if (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t   && (ort != C_ORT_OMP\n+\t\t       || !bitmap_bit_p (&map_field_head, DECL_UID (t))))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -14794,7 +14794,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n-\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t\t   && ort == C_ORT_ACC)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),"}, {"sha": "9c08c0e46a2ef65162394e5893148dae68fd25e4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -40785,6 +40785,7 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target data\", pragma_tok);\n+  c_omp_adjust_map_clauses (clauses, false);\n   int map_seen = 0;\n   for (tree *pc = &clauses; *pc;)\n     {\n@@ -40803,6 +40804,7 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -40886,6 +40888,7 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target enter data\", pragma_tok);\n+  c_omp_adjust_map_clauses (clauses, false);\n   int map_seen = 0;\n   for (tree *pc = &clauses; *pc;)\n     {\n@@ -40900,6 +40903,7 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -40974,6 +40978,7 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target exit data\", pragma_tok);\n+  c_omp_adjust_map_clauses (clauses, false);\n   int map_seen = 0;\n   for (tree *pc = &clauses; *pc;)\n     {\n@@ -40989,6 +40994,7 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    map_seen |= 1;\n@@ -41238,6 +41244,8 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n   OMP_TARGET_CLAUSES (stmt)\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target\", pragma_tok);\n+  c_omp_adjust_map_clauses (OMP_TARGET_CLAUSES (stmt), true);\n+\n   pc = &OMP_TARGET_CLAUSES (stmt);\n   keep_next_level (true);\n   OMP_TARGET_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n@@ -41261,6 +41269,7 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n \t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n \t    break;\n \t  default:\n \t    error_at (OMP_CLAUSE_LOCATION (*pc),"}, {"sha": "33d715edaec19e0fd239a4f5be87183dc87fedd6", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -5382,11 +5382,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t  if ((ort & C_ORT_OMP_DECLARE_SIMD) != C_ORT_OMP && ort != C_ORT_ACC)\n \t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n \t  else if (TREE_CODE (t) == COMPONENT_REF)\n-\t    {\n-\t      gomp_map_kind k = (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n-\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER;\n-\t      OMP_CLAUSE_SET_MAP_KIND (c2, k);\n-\t    }\n+\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n \t  else if (REFERENCE_REF_P (t)\n \t\t   && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n \t    {\n@@ -5424,8 +5420,12 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t\t\t\t\t  OMP_CLAUSE_MAP);\n \t      OMP_CLAUSE_SET_MAP_KIND (c3, OMP_CLAUSE_MAP_KIND (c2));\n \t      OMP_CLAUSE_DECL (c3) = ptr;\n-\t      if (OMP_CLAUSE_MAP_KIND (c2) == GOMP_MAP_ALWAYS_POINTER)\n-\t\tOMP_CLAUSE_DECL (c2) = build_simple_mem_ref (ptr);\n+\t      if (OMP_CLAUSE_MAP_KIND (c2) == GOMP_MAP_ALWAYS_POINTER\n+\t\t  || OMP_CLAUSE_MAP_KIND (c2) == GOMP_MAP_ATTACH_DETACH)\n+\t\t{\n+\t\t  OMP_CLAUSE_DECL (c2) = build_simple_mem_ref (ptr);\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t\t}\n \t      else\n \t\tOMP_CLAUSE_DECL (c2) = convert_from_reference (ptr);\n \t      OMP_CLAUSE_SIZE (c3) = size_zero_node;\n@@ -7486,7 +7486,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      t = TREE_OPERAND (t, 0);\n \t      OMP_CLAUSE_DECL (c) = t;\n \t    }\n-\t  if (ort == C_ORT_ACC\n+\t  if ((ort == C_ORT_ACC || ort == C_ORT_OMP)\n \t      && TREE_CODE (t) == COMPONENT_REF\n \t      && TREE_CODE (TREE_OPERAND (t, 0)) == INDIRECT_REF)\n \t    t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n@@ -7532,7 +7532,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tt = TREE_OPERAND (t, 0);\n \t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t\t{\n-\t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t)))\n+\t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t))\n+\t\t      || (ort == C_ORT_OMP\n+\t\t\t  && bitmap_bit_p (&map_head, DECL_UID (t))))\n \t\t    goto handle_map_references;\n \t\t}\n \t    }\n@@ -7626,13 +7628,12 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tbitmap_set_bit (&generic_head, DECL_UID (t));\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t))\n-\t\t   && (ort != C_ORT_ACC\n-\t\t       || !bitmap_bit_p (&map_field_head, DECL_UID (t))))\n+\t\t   && !bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t  \"%qD appears more than once in motion clauses\", t);\n-\t      if (ort == C_ORT_ACC)\n+\t      else if (ort == C_ORT_ACC)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n@@ -7641,7 +7642,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n-\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t\t   && ort == C_ORT_ACC)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -7677,17 +7684,14 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t       && (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t   != GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n \t\t       && (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t   != GOMP_MAP_ALWAYS_POINTER))\n+\t\t\t   != GOMP_MAP_ALWAYS_POINTER)\n+\t\t       && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t   != GOMP_MAP_ATTACH_DETACH))\n \t\t{\n \t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t      OMP_CLAUSE_MAP);\n \t\t  if (TREE_CODE (t) == COMPONENT_REF)\n-\t\t    {\n-\t\t      gomp_map_kind k\n-\t\t\t= (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n-\t\t\t\t\t     : GOMP_MAP_ALWAYS_POINTER;\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (c2, k);\n-\t\t    }\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n \t\t  else\n \t\t    OMP_CLAUSE_SET_MAP_KIND (c2,\n \t\t\t\t\t     GOMP_MAP_FIRSTPRIVATE_REFERENCE);"}, {"sha": "b2c623be456e74ec968794fda348be2e5df13f6a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 226, "deletions": 44, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -8364,6 +8364,113 @@ extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n   return base;\n }\n \n+/* Returns true if EXPR is or contains (as a sub-component) BASE_PTR.  */\n+\n+static bool\n+is_or_contains_p (tree expr, tree base_ptr)\n+{\n+  while (expr != base_ptr)\n+    if (TREE_CODE (base_ptr) == COMPONENT_REF)\n+      base_ptr = TREE_OPERAND (base_ptr, 0);\n+    else\n+      break;\n+  return expr == base_ptr;\n+}\n+\n+/* Implement OpenMP 5.x map ordering rules for target directives. There are\n+   several rules, and with some level of ambiguity, hopefully we can at least\n+   collect the complexity here in one place.  */\n+\n+static void\n+omp_target_reorder_clauses (tree *list_p)\n+{\n+  /* Collect refs to alloc/release/delete maps.  */\n+  auto_vec<tree, 32> ard;\n+  tree *cp = list_p;\n+  while (*cp != NULL_TREE)\n+    if (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP\n+\t&& (OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ALLOC\n+\t    || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_RELEASE\n+\t    || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_DELETE))\n+      {\n+\t/* Unlink cp and push to ard.  */\n+\ttree c = *cp;\n+\ttree nc = OMP_CLAUSE_CHAIN (c);\n+\t*cp = nc;\n+\tard.safe_push (c);\n+\n+\t/* Any associated pointer type maps should also move along.  */\n+\twhile (*cp != NULL_TREE\n+\t       && OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP\n+\t       && (OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_FIRSTPRIVATE_REFERENCE\n+\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ATTACH_DETACH\n+\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_POINTER\n+\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ALWAYS_POINTER\n+\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_TO_PSET))\n+\t  {\n+\t    c = *cp;\n+\t    nc = OMP_CLAUSE_CHAIN (c);\n+\t    *cp = nc;\n+\t    ard.safe_push (c);\n+\t  }\n+      }\n+    else\n+      cp = &OMP_CLAUSE_CHAIN (*cp);\n+\n+  /* Link alloc/release/delete maps to the end of list.  */\n+  for (unsigned int i = 0; i < ard.length (); i++)\n+    {\n+      *cp = ard[i];\n+      cp = &OMP_CLAUSE_CHAIN (ard[i]);\n+    }\n+  *cp = NULL_TREE;\n+\n+  /* OpenMP 5.0 requires that pointer variables are mapped before\n+     its use as a base-pointer.  */\n+  auto_vec<tree *, 32> atf;\n+  for (tree *cp = list_p; *cp; cp = &OMP_CLAUSE_CHAIN (*cp))\n+    if (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP)\n+      {\n+\t/* Collect alloc, to, from, to/from clause tree pointers.  */\n+\tgomp_map_kind k = OMP_CLAUSE_MAP_KIND (*cp);\n+\tif (k == GOMP_MAP_ALLOC\n+\t    || k == GOMP_MAP_TO\n+\t    || k == GOMP_MAP_FROM\n+\t    || k == GOMP_MAP_TOFROM\n+\t    || k == GOMP_MAP_ALWAYS_TO\n+\t    || k == GOMP_MAP_ALWAYS_FROM\n+\t    || k == GOMP_MAP_ALWAYS_TOFROM)\n+\t  atf.safe_push (cp);\n+      }\n+\n+  for (unsigned int i = 0; i < atf.length (); i++)\n+    if (atf[i])\n+      {\n+\ttree *cp = atf[i];\n+\ttree decl = OMP_CLAUSE_DECL (*cp);\n+\tif (TREE_CODE (decl) == INDIRECT_REF || TREE_CODE (decl) == MEM_REF)\n+\t  {\n+\t    tree base_ptr = TREE_OPERAND (decl, 0);\n+\t    STRIP_TYPE_NOPS (base_ptr);\n+\t    for (unsigned int j = i + 1; j < atf.length (); j++)\n+\t      {\n+\t\ttree *cp2 = atf[j];\n+\t\ttree decl2 = OMP_CLAUSE_DECL (*cp2);\n+\t\tif (is_or_contains_p (decl2, base_ptr))\n+\t\t  {\n+\t\t    /* Move *cp2 to before *cp.  */\n+\t\t    tree c = *cp2;\n+\t\t    *cp2 = OMP_CLAUSE_CHAIN (c);\n+\t\t    OMP_CLAUSE_CHAIN (c) = *cp;\n+\t\t    *cp = c;\n+\t\t    atf[j] = NULL;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+}\n+\n /* Scan the OMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n@@ -8405,6 +8512,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tbreak;\n       }\n \n+  if (code == OMP_TARGET\n+      || code == OMP_TARGET_DATA\n+      || code == OMP_TARGET_ENTER_DATA\n+      || code == OMP_TARGET_EXIT_DATA)\n+    omp_target_reorder_clauses (list_p);\n+\n   while ((c = *list_p) != NULL)\n     {\n       bool remove = false;\n@@ -8845,15 +8958,18 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  else if ((OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n \t\t    || (OMP_CLAUSE_MAP_KIND (c)\n-\t\t\t== GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n+\t\t\t== GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t\t    || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n \t\t   && TREE_CODE (OMP_CLAUSE_SIZE (c)) != INTEGER_CST)\n \t    {\n \t      OMP_CLAUSE_SIZE (c)\n \t\t= get_initialized_tmp_var (OMP_CLAUSE_SIZE (c), pre_p, NULL,\n \t\t\t\t\t   false);\n-\t      omp_add_variable (ctx, OMP_CLAUSE_SIZE (c),\n-\t\t\t\tGOVD_FIRSTPRIVATE | GOVD_SEEN);\n+\t      if ((region_type & ORT_TARGET) != 0)\n+\t\tomp_add_variable (ctx, OMP_CLAUSE_SIZE (c),\n+\t\t\t\t  GOVD_FIRSTPRIVATE | GOVD_SEEN);\n \t    }\n+\n \t  if (!DECL_P (decl))\n \t    {\n \t      tree d = decl, *pd;\n@@ -8878,17 +8994,19 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      bool indir_p = false;\n \t      tree orig_decl = decl;\n \t      tree decl_ref = NULL_TREE;\n-\t      if ((region_type & ORT_ACC) != 0\n+\t      if ((region_type & (ORT_ACC | ORT_TARGET | ORT_TARGET_DATA)) != 0\n \t\t  && TREE_CODE (*pd) == COMPONENT_REF\n \t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH\n \t\t  && code != OACC_UPDATE)\n \t\t{\n \t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n \t\t    {\n \t\t      decl = TREE_OPERAND (decl, 0);\n-\t\t      if ((TREE_CODE (decl) == MEM_REF\n-\t\t\t   && integer_zerop (TREE_OPERAND (decl, 1)))\n-\t\t\t  || INDIRECT_REF_P (decl))\n+\t\t      if (((TREE_CODE (decl) == MEM_REF\n+\t\t\t    && integer_zerop (TREE_OPERAND (decl, 1)))\n+\t\t\t   || INDIRECT_REF_P (decl))\n+\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t\t      == POINTER_TYPE))\n \t\t\t{\n \t\t\t  indir_p = true;\n \t\t\t  decl = TREE_OPERAND (decl, 0);\n@@ -8915,8 +9033,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t}\n \t      if (decl != orig_decl && DECL_P (decl) && indir_p)\n \t\t{\n-\t\t  gomp_map_kind k = (code == OACC_EXIT_DATA) ? GOMP_MAP_DETACH\n-\t\t\t\t\t\t\t     : GOMP_MAP_ATTACH;\n+\t\t  gomp_map_kind k\n+\t\t    = ((code == OACC_EXIT_DATA || code == OMP_TARGET_EXIT_DATA)\n+\t\t       ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n \t\t  /* We have a dereference of a struct member.  Make this an\n \t\t     attach/detach operation, and ensure the base pointer is\n \t\t     mapped as a FIRSTPRIVATE_POINTER.  */\n@@ -8925,6 +9044,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  tree next_clause = OMP_CLAUSE_CHAIN (c);\n \t\t  if (k == GOMP_MAP_ATTACH\n \t\t      && code != OACC_ENTER_DATA\n+\t\t      && code != OMP_TARGET_ENTER_DATA\n \t\t      && (!next_clause\n \t\t\t   || (OMP_CLAUSE_CODE (next_clause) != OMP_CLAUSE_MAP)\n \t\t\t   || (OMP_CLAUSE_MAP_KIND (next_clause)\n@@ -8972,17 +9092,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      if (code == OACC_UPDATE\n \t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n \t\tOMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALWAYS_POINTER);\n-\t      if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue, fb_lvalue)\n-\t\t  == GS_ERROR)\n-\t\t{\n-\t\t  remove = true;\n-\t\t  break;\n-\t\t}\n \t      if (DECL_P (decl)\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH\n-\t\t  && code != OACC_UPDATE)\n+\t\t  && code != OACC_UPDATE\n+\t\t  && code != OMP_TARGET_UPDATE)\n \t\t{\n \t\t  if (error_operand_p (decl))\n \t\t    {\n@@ -9044,15 +9159,19 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  bool has_attachments = false;\n \t\t  /* For OpenACC, pointers in structs should trigger an\n \t\t     attach action.  */\n-\t\t  if (attach_detach && (region_type & ORT_ACC) != 0)\n+\t\t  if (attach_detach\n+\t\t      && ((region_type & (ORT_ACC | ORT_TARGET | ORT_TARGET_DATA))\n+\t\t\t  || code == OMP_TARGET_ENTER_DATA\n+\t\t\t  || code == OMP_TARGET_EXIT_DATA))\n+\n \t\t    {\n \t\t      /* Turn a GOMP_MAP_ATTACH_DETACH clause into a\n \t\t\t GOMP_MAP_ATTACH or GOMP_MAP_DETACH clause after we\n \t\t\t have detected a case that needs a GOMP_MAP_STRUCT\n \t\t\t mapping added.  */\n \t\t      gomp_map_kind k\n-\t\t\t= (code == OACC_EXIT_DATA) ? GOMP_MAP_DETACH\n-\t\t\t\t\t\t   : GOMP_MAP_ATTACH;\n+\t\t\t= ((code == OACC_EXIT_DATA || code == OMP_TARGET_EXIT_DATA)\n+\t\t\t   ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n \t\t      OMP_CLAUSE_SET_MAP_KIND (c, k);\n \t\t      has_attachments = true;\n \t\t    }\n@@ -9148,33 +9267,38 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t      break;\n \t\t\t    if (scp)\n \t\t\t      continue;\n-\t\t\t    tree d1 = OMP_CLAUSE_DECL (*sc);\n-\t\t\t    tree d2 = OMP_CLAUSE_DECL (c);\n-\t\t\t    while (TREE_CODE (d1) == ARRAY_REF)\n-\t\t\t      d1 = TREE_OPERAND (d1, 0);\n-\t\t\t    while (TREE_CODE (d2) == ARRAY_REF)\n-\t\t\t      d2 = TREE_OPERAND (d2, 0);\n-\t\t\t    if (TREE_CODE (d1) == INDIRECT_REF)\n-\t\t\t      d1 = TREE_OPERAND (d1, 0);\n-\t\t\t    if (TREE_CODE (d2) == INDIRECT_REF)\n-\t\t\t      d2 = TREE_OPERAND (d2, 0);\n-\t\t\t    while (TREE_CODE (d1) == COMPONENT_REF)\n-\t\t\t      if (TREE_CODE (d2) == COMPONENT_REF\n-\t\t\t\t  && TREE_OPERAND (d1, 1)\n-\t\t\t\t     == TREE_OPERAND (d2, 1))\n-\t\t\t\t{\n+\t\t\t    if ((region_type & ORT_ACC) != 0)\n+\t\t\t      {\n+\t\t\t\t/* This duplicate checking code is currently only\n+\t\t\t\t   enabled for OpenACC.  */\n+\t\t\t\ttree d1 = OMP_CLAUSE_DECL (*sc);\n+\t\t\t\ttree d2 = OMP_CLAUSE_DECL (c);\n+\t\t\t\twhile (TREE_CODE (d1) == ARRAY_REF)\n \t\t\t\t  d1 = TREE_OPERAND (d1, 0);\n+\t\t\t\twhile (TREE_CODE (d2) == ARRAY_REF)\n \t\t\t\t  d2 = TREE_OPERAND (d2, 0);\n-\t\t\t\t}\n-\t\t\t      else\n-\t\t\t\tbreak;\n-\t\t\t    if (d1 == d2)\n-\t\t\t      {\n-\t\t\t\terror_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t  \"%qE appears more than once in map \"\n-\t\t\t\t\t  \"clauses\", OMP_CLAUSE_DECL (c));\n-\t\t\t\tremove = true;\n-\t\t\t\tbreak;\n+\t\t\t\tif (TREE_CODE (d1) == INDIRECT_REF)\n+\t\t\t\t  d1 = TREE_OPERAND (d1, 0);\n+\t\t\t\tif (TREE_CODE (d2) == INDIRECT_REF)\n+\t\t\t\t  d2 = TREE_OPERAND (d2, 0);\n+\t\t\t\twhile (TREE_CODE (d1) == COMPONENT_REF)\n+\t\t\t\t  if (TREE_CODE (d2) == COMPONENT_REF\n+\t\t\t\t      && TREE_OPERAND (d1, 1)\n+\t\t\t\t      == TREE_OPERAND (d2, 1))\n+\t\t\t\t    {\n+\t\t\t\t      d1 = TREE_OPERAND (d1, 0);\n+\t\t\t\t      d2 = TREE_OPERAND (d2, 0);\n+\t\t\t\t    }\n+\t\t\t\t  else\n+\t\t\t\t    break;\n+\t\t\t\tif (d1 == d2)\n+\t\t\t\t  {\n+\t\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t      \"%qE appears more than once in map \"\n+\t\t\t\t\t      \"clauses\", OMP_CLAUSE_DECL (c));\n+\t\t\t\t    remove = true;\n+\t\t\t\t    break;\n+\t\t\t\t  }\n \t\t\t      }\n \t\t\t    if (maybe_lt (offset1, offsetn)\n \t\t\t\t|| (known_eq (offset1, offsetn)\n@@ -9220,6 +9344,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t}\n \t\t    }\n \t\t}\n+\n+\t      if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue, fb_lvalue)\n+\t\t  == GS_ERROR)\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\n \t      if (!remove\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_POINTER\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH_DETACH\n@@ -9236,10 +9368,60 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \t      break;\n \t    }\n+\t  else\n+\t    {\n+\t      /* DECL_P (decl) == true  */\n+\t      tree *sc;\n+\t      if (struct_map_to_clause\n+\t\t  && (sc = struct_map_to_clause->get (decl)) != NULL\n+\t\t  && OMP_CLAUSE_MAP_KIND (*sc) == GOMP_MAP_STRUCT\n+\t\t  && decl == OMP_CLAUSE_DECL (*sc))\n+\t\t{\n+\t\t  /* We have found a map of the whole structure after a\n+\t\t     leading GOMP_MAP_STRUCT has been created, so refill the\n+\t\t     leading clause into a map of the whole structure\n+\t\t     variable, and remove the current one.\n+\t\t     TODO: we should be able to remove some maps of the\n+\t\t     following structure element maps if they are of\n+\t\t     compatible TO/FROM/ALLOC type.  */\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (*sc, OMP_CLAUSE_MAP_KIND (c));\n+\t\t  OMP_CLAUSE_SIZE (*sc) = unshare_expr (OMP_CLAUSE_SIZE (c));\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  flags = GOVD_MAP | GOVD_EXPLICIT;\n \t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TO\n \t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_TOFROM)\n \t    flags |= GOVD_MAP_ALWAYS_TO;\n+\n+\t  if ((code == OMP_TARGET\n+\t       || code == OMP_TARGET_DATA\n+\t       || code == OMP_TARGET_ENTER_DATA\n+\t       || code == OMP_TARGET_EXIT_DATA)\n+\t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n+\t    {\n+\t      for (struct gimplify_omp_ctx *octx = outer_ctx; octx;\n+\t\t   octx = octx->outer_context)\n+\t\t{\n+\t\t  splay_tree_node n\n+\t\t    = splay_tree_lookup (octx->variables,\n+\t\t\t\t\t (splay_tree_key) OMP_CLAUSE_DECL (c));\n+\t\t  /* If this is contained in an outer OpenMP region as a\n+\t\t     firstprivate value, remove the attach/detach.  */\n+\t\t  if (n && (n->value & GOVD_FIRSTPRIVATE))\n+\t\t    {\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+\t\t      goto do_add;\n+\t\t    }\n+\t\t}\n+\n+\t      enum gomp_map_kind map_kind = (code == OMP_TARGET_EXIT_DATA\n+\t\t\t\t\t     ? GOMP_MAP_DETACH\n+\t\t\t\t\t     : GOMP_MAP_ATTACH);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, map_kind);\n+\t    }\n+\n \t  goto do_add;\n \n \tcase OMP_CLAUSE_DEPEND:"}, {"sha": "447d7dbc92a5e15545c87710c9bbed71289a948d", "filename": "gcc/omp-low.c", "status": "modified", "additions": 85, "deletions": 5, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -214,6 +214,21 @@ is_oacc_kernels (omp_context *ctx)\n \t      == GF_OMP_TARGET_KIND_OACC_KERNELS));\n }\n \n+/* Return true if STMT corresponds to an OpenMP target region.  */\n+static bool\n+is_omp_target (gimple *stmt)\n+{\n+  if (gimple_code (stmt) == GIMPLE_OMP_TARGET)\n+    {\n+      int kind = gimple_omp_target_kind (stmt);\n+      return (kind == GF_OMP_TARGET_KIND_REGION\n+\t      || kind == GF_OMP_TARGET_KIND_DATA\n+\t      || kind == GF_OMP_TARGET_KIND_ENTER_DATA\n+\t      || kind == GF_OMP_TARGET_KIND_EXIT_DATA);\n+    }\n+  return false;\n+}\n+\n /* If DECL is the artificial dummy VAR_DECL created for non-static\n    data member privatization, return the underlying \"this\" parameter,\n    otherwise return NULL.  */\n@@ -1346,7 +1361,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      && DECL_P (decl)\n \t      && ((OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t\t   && (OMP_CLAUSE_MAP_KIND (c)\n-\t\t       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n+\t\t       != GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH)\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TO\n \t      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_FROM\n@@ -1367,6 +1384,40 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\t  && !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c))\n \t\tbreak;\n \t    }\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t      && DECL_P (decl)\n+\t      && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)\n+\t      && is_omp_target (ctx->stmt))\n+\t    {\n+\t      /* If this is an offloaded region, an attach operation should\n+\t\t only exist when the pointer variable is mapped in a prior\n+\t\t clause.  */\n+\t      if (is_gimple_omp_offloaded (ctx->stmt))\n+\t\tgcc_assert\n+\t\t  (maybe_lookup_decl (decl, ctx)\n+\t\t   || (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n+\t\t       && lookup_attribute (\"omp declare target\",\n+\t\t\t\t\t    DECL_ATTRIBUTES (decl))));\n+\n+\t      /* By itself, attach/detach is generated as part of pointer\n+\t\t variable mapping and should not create new variables in the\n+\t\t offloaded region, however sender refs for it must be created\n+\t\t for its address to be passed to the runtime.  */\n+\t      tree field\n+\t\t= build_decl (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      FIELD_DECL, NULL_TREE, ptr_type_node);\n+\t      SET_DECL_ALIGN (field, TYPE_ALIGN (ptr_type_node));\n+\t      insert_field_into_struct (ctx->record_type, field);\n+\t      /* To not clash with a map of the pointer variable itself,\n+\t\t attach/detach maps have their field looked up by the *clause*\n+\t\t tree expression, not the decl.  */\n+\t      gcc_assert (!splay_tree_lookup (ctx->field_map,\n+\t\t\t\t\t      (splay_tree_key) c));\n+\t      splay_tree_insert (ctx->field_map, (splay_tree_key) c,\n+\t\t\t\t (splay_tree_value) field);\n+\t      break;\n+\t    }\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n \t\t  || (OMP_CLAUSE_MAP_KIND (c)\n@@ -1607,6 +1658,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n \t      && varpool_node::get_create (decl)->offloadable)\n \t    break;\n+\t  if ((OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t       || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)\n+\t      && is_omp_target (ctx->stmt)\n+\t      && !is_gimple_omp_offloaded (ctx->stmt))\n+\t    break;\n \t  if (DECL_P (decl))\n \t    {\n \t      if ((OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n@@ -11471,6 +11527,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n \t  case GOMP_MAP_STRUCT:\n \t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH:\n+\t  case GOMP_MAP_DETACH:\n \t    break;\n \t  case GOMP_MAP_IF_PRESENT:\n \t  case GOMP_MAP_FORCE_ALLOC:\n@@ -11481,8 +11539,6 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case GOMP_MAP_FORCE_DEVICEPTR:\n \t  case GOMP_MAP_DEVICE_RESIDENT:\n \t  case GOMP_MAP_LINK:\n-\t  case GOMP_MAP_ATTACH:\n-\t  case GOMP_MAP_DETACH:\n \t  case GOMP_MAP_FORCE_DETACH:\n \t    gcc_assert (is_gimple_omp_oacc (stmt));\n \t    break;\n@@ -11537,6 +11593,16 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    continue;\n \t  }\n \n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t    && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t\t|| OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)\n+\t    && is_omp_target (stmt))\n+\t  {\n+\t    gcc_assert (maybe_lookup_field (c, ctx));\n+\t    map_cnt++;\n+\t    continue;\n+\t  }\n+\n \tif (!maybe_lookup_field (var, ctx))\n \t  continue;\n \n@@ -11769,14 +11835,28 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    gcc_assert (DECL_P (ovar2));\n \t\t    ovar = ovar2;\n \t\t  }\n-\t\tif (!maybe_lookup_field (ovar, ctx))\n+\t\tif (!maybe_lookup_field (ovar, ctx)\n+\t\t    && !(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t\t && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t\t\t     || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)))\n \t\t  continue;\n \t      }\n \n \t    talign = TYPE_ALIGN_UNIT (TREE_TYPE (ovar));\n \t    if (DECL_P (ovar) && DECL_ALIGN_UNIT (ovar) > talign)\n \t      talign = DECL_ALIGN_UNIT (ovar);\n-\t    if (nc)\n+\n+\t    if (nc\n+\t\t&& OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t&& (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t\t    || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_DETACH)\n+\t\t&& is_omp_target (stmt))\n+\t      {\n+\t\tvar = lookup_decl_in_outer_ctx (ovar, ctx);\n+\t\tx = build_sender_ref (c, ctx);\n+\t\tgimplify_assign (x, build_fold_addr_expr (var), &ilist);\n+\t      }\n+\t    else if (nc)\n \t      {\n \t\tvar = lookup_decl_in_outer_ctx (ovar, ctx);\n \t\tx = build_sender_ref (ovar, ctx);"}, {"sha": "bbc8fb4e32bf81267293de248057c42558f88312", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-2.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -13,35 +13,35 @@ foo (int *p, int q, struct S t, int i, int j, int k, int l)\n     bar (p);\n   #pragma omp target map (p[0]) map (p) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (p);\n-  #pragma omp target map (p) , map (p[0]) /* { dg-error \"appears both in data and map clauses\" } */\n+  #pragma omp target map (p) , map (p[0])\n     bar (p);\n   #pragma omp target map (q) map (q) /* { dg-error \"appears more than once in map clauses\" } */\n     bar (&q);\n   #pragma omp target map (p[0]) map (p[0]) /* { dg-error \"appears more than once in data clauses\" } */\n     bar (p);\n-  #pragma omp target map (t) map (t.r) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t) map (t.r)\n     bar (&t.r);\n-  #pragma omp target map (t.r) map (t) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t.r) map (t)\n     bar (&t.r);\n-  #pragma omp target map (t.r) map (t.r) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t.r) map (t.r)\n     bar (&t.r);\n   #pragma omp target firstprivate (t), map (t.r) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (&t.r);\n   #pragma omp target map (t.r) firstprivate (t) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (&t.r);\n-  #pragma omp target map (t.s[0]) map (t) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t.s[0]) map (t)\n     bar (t.s);\n-  #pragma omp target map (t) map(t.s[0]) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t) map(t.s[0])\n     bar (t.s);\n   #pragma omp target firstprivate (t) map (t.s[0]) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (t.s);\n   #pragma omp target map (t.s[0]) firstprivate (t) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (t.s);\n-  #pragma omp target map (t.s[0]) map (t.s[2]) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t.s[0]) map (t.s[2])\n     bar (t.s);\n-  #pragma omp target map (t.t[0:2]) map (t.t[4:6]) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t.t[0:2]) map (t.t[4:6])\n     bar (t.t);\n-  #pragma omp target map (t.t[i:j]) map (t.t[k:l]) /* { dg-error \"appears more than once in map clauses\" } */\n+  #pragma omp target map (t.t[i:j]) map (t.t[k:l])\n     bar (t.t);\n   #pragma omp target map (t.s[0]) map (t.r)\n     bar (t.s);\n@@ -50,5 +50,5 @@ foo (int *p, int q, struct S t, int i, int j, int k, int l)\n   #pragma omp target map (t.r) map (t) map (t.s[0]) firstprivate (t) /* { dg-error \"appears both in data and map clauses\" } */\n     bar (t.s);\n   #pragma omp target map (t) map (t.r) firstprivate (t) map (t.s[0]) /* { dg-error \"appears both in data and map clauses\" } */\n-    bar (t.s); /* { dg-error \"appears more than once in map clauses\" \"\" { target *-*-* } .-1 } */\n+    bar (t.s);\n }"}, {"sha": "1d9d9252864cf8d37c6f2ffb7539df7354c902cb", "filename": "gcc/testsuite/c-c++-common/gomp/map-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-5.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+void foo (void)\n+{\n+  /* Basic test to ensure to,from,tofrom is ordered before alloc,release,delete clauses.  */\n+  int a, b, c;\n+  #pragma omp target enter data map(alloc:a) map(to:b) map(alloc:c)\n+  #pragma omp target exit data map(from:a) map(release:b) map(from:c)\n+\n+  #pragma omp target map(alloc:a) map(tofrom:b) map(alloc:c)\n+  a = b = c = 1;\n+\n+  #pragma omp target enter data map(to:a) map(alloc:b) map(to:c)\n+  #pragma omp target exit data map(from:a) map(delete:b) map(from:c)\n+}\n+\n+/* { dg-final { scan-tree-dump \"pragma omp target enter data map\\\\(to:.* map\\\\(alloc:.* map\\\\(alloc:.*\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target exit data map\\\\(from:.* map\\\\(from:.* map\\\\(release:.*\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"pragma omp target num_teams.* map\\\\(tofrom:.* map\\\\(alloc:.* map\\\\(alloc:.*\" \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump \"pragma omp target enter data map\\\\(to:.* map\\\\(to:.* map\\\\(alloc:.*\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target exit data map\\\\(from:.* map\\\\(from:.* map\\\\(delete:.*\" \"gimple\" } } */"}, {"sha": "79bab726deab07941f3e9f70944bcdf77085ce5d", "filename": "gcc/testsuite/gfortran.dg/gomp/map-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-2.f90?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -2,5 +2,5 @@\n   integer :: i\n end type t\n type(t) v\n-!$omp target enter data map(to:v%i, v%i)  ! { dg-error \"appears more than once in map clauses\" }\n+!$omp target enter data map(to:v%i, v%i)\n end"}, {"sha": "0cc3f4d406b6fbe589a8c62019520af767edbf55", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -1162,10 +1162,10 @@ struct gomp_device_descr\n /* Kind of the pragma, for which gomp_map_vars () is called.  */\n enum gomp_map_vars_kind\n {\n-  GOMP_MAP_VARS_OPENACC,\n-  GOMP_MAP_VARS_TARGET,\n-  GOMP_MAP_VARS_DATA,\n-  GOMP_MAP_VARS_ENTER_DATA\n+  GOMP_MAP_VARS_OPENACC    = 1,\n+  GOMP_MAP_VARS_TARGET     = 2,\n+  GOMP_MAP_VARS_DATA       = 4,\n+  GOMP_MAP_VARS_ENTER_DATA = 8\n };\n \n extern void gomp_acc_declare_allocate (bool, size_t, void **, size_t *,"}, {"sha": "4c8f0e0828ec1ff3f84cced7e5b4daeccf7aabf5", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -403,7 +403,8 @@ acc_map_data (void *h, void *d, size_t s)\n \n       struct target_mem_desc *tgt\n \t= gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,\n-\t\t\t &kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n+\t\t\t &kinds, true,\n+\t\t\t GOMP_MAP_VARS_OPENACC | GOMP_MAP_VARS_ENTER_DATA);\n       assert (tgt);\n       assert (tgt->list_count == 1);\n       splay_tree_key n = tgt->list[0].key;\n@@ -572,7 +573,8 @@ goacc_enter_datum (void **hostaddrs, size_t *sizes, void *kinds, int async)\n \n       struct target_mem_desc *tgt\n \t= gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes,\n-\t\t\t       kinds, true, GOMP_MAP_VARS_ENTER_DATA);\n+\t\t\t       kinds, true, (GOMP_MAP_VARS_OPENACC\n+\t\t\t\t\t     | GOMP_MAP_VARS_ENTER_DATA));\n       assert (tgt);\n       assert (tgt->list_count == 1);\n       n = tgt->list[0].key;\n@@ -1202,7 +1204,8 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t  struct target_mem_desc *tgt\n \t    = gomp_map_vars_async (acc_dev, aq, groupnum, &hostaddrs[i], NULL,\n \t\t\t\t   &sizes[i], &kinds[i], true,\n-\t\t\t\t   GOMP_MAP_VARS_ENTER_DATA);\n+\t\t\t\t   (GOMP_MAP_VARS_OPENACC\n+\t\t\t\t    | GOMP_MAP_VARS_ENTER_DATA));\n \t  assert (tgt);\n \n \t  gomp_mutex_lock (&acc_dev->lock);"}, {"sha": "6152f58e13d4ac1ea9e70124c0522a180504a781", "filename": "libgomp/target.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -683,7 +683,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   struct target_mem_desc *tgt\n     = gomp_malloc (sizeof (*tgt) + sizeof (tgt->list[0]) * mapnum);\n   tgt->list_count = mapnum;\n-  tgt->refcount = pragma_kind == GOMP_MAP_VARS_ENTER_DATA ? 0 : 1;\n+  tgt->refcount = (pragma_kind & GOMP_MAP_VARS_ENTER_DATA) ? 0 : 1;\n   tgt->device_descr = devicep;\n   tgt->prev = NULL;\n   struct gomp_coalesce_buf cbuf, *cbufp = NULL;\n@@ -1212,15 +1212,16 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t      /* OpenACC 'attach'/'detach' doesn't affect\n \t\t\t structured/dynamic reference counts ('n->refcount',\n \t\t\t 'n->dynamic_refcount').  */\n+\n+\t\t      gomp_attach_pointer (devicep, aq, mem_map, n,\n+\t\t\t\t\t   (uintptr_t) hostaddrs[i], sizes[i],\n+\t\t\t\t\t   cbufp);\n \t\t    }\n-\t\t  else\n+\t\t  else if ((pragma_kind & GOMP_MAP_VARS_OPENACC) != 0)\n \t\t    {\n \t\t      gomp_mutex_unlock (&devicep->lock);\n \t\t      gomp_fatal (\"outer struct not mapped for attach\");\n \t\t    }\n-\t\t  gomp_attach_pointer (devicep, aq, mem_map, n,\n-\t\t\t\t       (uintptr_t) hostaddrs[i], sizes[i],\n-\t\t\t\t       cbufp);\n \t\t  continue;\n \t\t}\n \t      default:\n@@ -1415,7 +1416,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   /* If the variable from \"omp target enter data\" map-list was already mapped,\n      tgt is not needed.  Otherwise tgt will be freed by gomp_unmap_vars or\n      gomp_exit_data.  */\n-  if (pragma_kind == GOMP_MAP_VARS_ENTER_DATA && tgt->refcount == 0)\n+  if ((pragma_kind & GOMP_MAP_VARS_ENTER_DATA) && tgt->refcount == 0)\n     {\n       free (tgt);\n       tgt = NULL;\n@@ -2475,6 +2476,19 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n       return;\n     }\n \n+  for (i = 0; i < mapnum; i++)\n+    if ((kinds[i] & typemask) == GOMP_MAP_DETACH)\n+      {\n+\tstruct splay_tree_key_s cur_node;\n+\tcur_node.host_start = (uintptr_t) hostaddrs[i];\n+\tcur_node.host_end = cur_node.host_start + sizeof (void *);\n+\tsplay_tree_key n = splay_tree_lookup (&devicep->mem_map, &cur_node);\n+\n+\tif (n)\n+\t  gomp_detach_pointer (devicep, NULL, n, (uintptr_t) hostaddrs[i],\n+\t\t\t       false, NULL);\n+      }\n+\n   for (i = 0; i < mapnum; i++)\n     {\n       struct splay_tree_key_s cur_node;\n@@ -2512,7 +2526,9 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t\tcur_node.host_end - cur_node.host_start);\n \t  if (k->refcount == 0)\n \t    gomp_remove_var (devicep, k);\n+\t  break;\n \n+\tcase GOMP_MAP_DETACH:\n \t  break;\n \tdefault:\n \t  gomp_mutex_unlock (&devicep->lock);\n@@ -2621,6 +2637,14 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n \t\t\t &kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n \t  i += j - i - 1;\n \t}\n+      else if (i + 1 < mapnum && (kinds[i + 1] & 0xff) == GOMP_MAP_ATTACH)\n+\t{\n+\t  /* An attach operation must be processed together with the mapped\n+\t     base-pointer list item.  */\n+\t  gomp_map_vars (devicep, 2, &hostaddrs[i], NULL, &sizes[i], &kinds[i],\n+\t\t\t true, GOMP_MAP_VARS_ENTER_DATA);\n+\t  i += 1;\n+\t}\n       else\n \tgomp_map_vars (devicep, 1, &hostaddrs[i], NULL, &sizes[i], &kinds[i],\n \t\t       true, GOMP_MAP_VARS_ENTER_DATA);"}, {"sha": "e7deec6e006bc97fd36699524c39df239ed51d81", "filename": "libgomp/testsuite/libgomp.c-c++-common/ptr-attach-1.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6280242225587be256fdb80c41327736238e77/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fptr-attach-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6280242225587be256fdb80c41327736238e77/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fptr-attach-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fptr-attach-1.c?ref=9e6280242225587be256fdb80c41327736238e77", "patch": "@@ -0,0 +1,82 @@\n+#include <stdlib.h>\n+\n+struct S\n+{\n+  int a, b;\n+  int *ptr;\n+  int c, d;\n+};\n+typedef struct S S;\n+\n+#pragma omp declare target\n+int *gp;\n+#pragma omp end declare target\n+\n+#define N 10\n+int main (void)\n+{\n+  /* Test to see if pointer attachment works, for scalar pointers,\n+     and pointer fields in structures.  */\n+\n+  int *ptr = (int *) malloc (sizeof (int) * N);\n+  int *orig_ptr = ptr;\n+\n+  #pragma omp target map (ptr, ptr[:N])\n+  {\n+    for (int i = 0; i < N; i++)\n+      ptr[i] = N - i;\n+  }\n+\n+  if (ptr != orig_ptr)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr[i] != N - i)\n+      abort ();\n+\n+  S s = { 0 };\n+  s.ptr = ptr;\n+  #pragma omp target map (s, s.ptr[:N])\n+  {\n+    for (int i = 0; i < N; i++)\n+      s.ptr[i] = i;\n+\n+    s.a = 1;\n+    s.b = 2;\n+  }\n+\n+  if (s.ptr != ptr)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (s.ptr[i] != i)\n+      abort ();\n+\n+  if (s.a != 1 || s.b != 2 || s.c != 0 || s.d != 0)\n+    abort ();\n+\n+  gp = (int *) malloc (sizeof (int) * N);\n+  orig_ptr = gp;\n+\n+  for (int i = 0; i < N; i++)\n+    gp[i] = i - 1;\n+\n+  #pragma omp target map (gp[:N])\n+  {\n+    for (int i = 0; i < N; i++)\n+      gp[i] += 1;\n+  }\n+\n+  if (gp != orig_ptr)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (gp[i] != i)\n+      abort ();\n+\n+  free (ptr);\n+  free (gp);\n+\n+  return 0;\n+}\n+"}]}