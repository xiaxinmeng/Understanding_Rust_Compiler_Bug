{"sha": "be8ac49a3e4f2f84f04c45ceb4d914e070cb6099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU4YWM0OWEzZTRmMmY4NGYwNGM0NWNlYjRkOTE0ZTA3MGNiNjA5OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-07-01T15:52:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-01T15:52:26Z"}, "message": "cse.c (new_label_ref): Variable deleted.\n\n\t* cse.c (new_label_ref): Variable deleted.\n\t(insert): Remove set of new_label_ref.\n\t(check_for_label_ref): New function.\n\t(cse_basic_block): Don't check new_label_ref; call check_for_label_ref.\n\nFrom-SVN: r43672", "tree": {"sha": "c0a95cb3b84bd366d98f478e689d193df2762f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0a95cb3b84bd366d98f478e689d193df2762f37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099/comments", "author": null, "committer": null, "parents": [{"sha": "b987f23731a41836b6859b85c540e25cc318e2ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b987f23731a41836b6859b85c540e25cc318e2ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b987f23731a41836b6859b85c540e25cc318e2ce"}], "stats": {"total": 52, "additions": 34, "deletions": 18}, "files": [{"sha": "45be5e87fa7180e3bcee4c51b002012e8b0056ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be8ac49a3e4f2f84f04c45ceb4d914e070cb6099", "patch": "@@ -1,3 +1,10 @@\n+Sun Jul  1 11:53:52 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cse.c (new_label_ref): Variable deleted.\n+\t(insert): Remove set of new_label_ref.\n+\t(check_for_label_ref): New function.\n+\t(cse_basic_block): Don't check new_label_ref; call check_for_label_ref.\n+\n 2001-06-30  Zack Weinberg  <zackw@stanford.edu>\n \n \t* rtl.def (DEFINE_INSN, DEFINE_INSN_AND_SPLIT, DEFINE_PEEPHOLE):"}, {"sha": "bc4a05aad763118d16d6b457228cda27e93ed719", "filename": "gcc/cse.c", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8ac49a3e4f2f84f04c45ceb4d914e070cb6099/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=be8ac49a3e4f2f84f04c45ceb4d914e070cb6099", "patch": "@@ -386,10 +386,6 @@ static int cse_jumps_altered;\n    REG_LABEL, we have to rerun jump after CSE to put in the note.  */\n static int recorded_label_ref;\n \n-/* Says which LABEL_REF was put in the hash table.  Used to see if we need\n-   to set the above flag.  */\n-static rtx new_label_ref;\n-\n /* canon_hash stores 1 in do_not_record\n    if it notices a reference to CC0, PC, or some other volatile\n    subexpression.  */\n@@ -692,6 +688,7 @@ static void cse_check_loop_start PARAMS ((rtx, rtx, void *));\n static void cse_set_around_loop\tPARAMS ((rtx, rtx, rtx));\n static rtx cse_basic_block\tPARAMS ((rtx, rtx, struct branch_path *, int));\n static void count_reg_usage\tPARAMS ((rtx, int *, rtx, int));\n+static int check_for_label_ref\tPARAMS ((rtx *, void *));\n extern void dump_class          PARAMS ((struct table_elt*));\n static struct cse_reg_info * get_cse_reg_info PARAMS ((unsigned int));\n static int check_dependence\tPARAMS ((rtx *, void *));\n@@ -718,6 +715,7 @@ dump_class (classp)\n }\n \n /* Subroutine of approx_reg_cost; called through for_each_rtx.  */\n+\n static int\n approx_reg_cost_1 (xp, data)\n      rtx *xp;\n@@ -1580,12 +1578,6 @@ insert (x, classp, hash, mode)\n \tSET_HARD_REG_BIT (hard_regs_in_table, i);\n     }\n \n-  /* If X is a label, show we recorded it.  */\n-  if (GET_CODE (x) == LABEL_REF\n-      || (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF))\n-    new_label_ref = x;\n-\n   /* Put an element for X into the right hash bucket.  */\n \n   elt = free_element_chain;\n@@ -1823,6 +1815,7 @@ struct check_dependence_data\n   enum machine_mode mode;\n   rtx exp;\n };\n+\n static int\n check_dependence (x, data)\n      rtx *x;\n@@ -7290,16 +7283,13 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t\tlibcall_insn = 0;\n \t    }\n \n-\t  new_label_ref = 0;\n \t  cse_insn (insn, libcall_insn);\n \n-\t  /* If this insn uses a LABEL_REF and there isn't a REG_LABEL\n-\t     note for it, we must rerun jump since it needs to place the\n-\t     note.  If this is a LABEL_REF for a CODE_LABEL that isn't in\n-\t     the insn chain, don't do this since no REG_LABEL will be added. */\n-\t  if (new_label_ref != 0 && INSN_UID (XEXP (new_label_ref, 0)) != 0\n-\t      && reg_mentioned_p (new_label_ref, PATTERN (insn))\n-\t      && ! find_reg_note (insn, REG_LABEL, XEXP (new_label_ref, 0)))\n+\t  /* If we haven't already found an insn where we added a LABEL_REF,\n+\t     check this one.  */\n+\t  if (GET_CODE (insn) == INSN && ! recorded_label_ref\n+\t      && for_each_rtx (&PATTERN (insn), check_for_label_ref,\n+\t\t\t       (void *) insn))\n \t    recorded_label_ref = 1;\n \t}\n \n@@ -7408,6 +7398,25 @@ cse_basic_block (from, to, next_branch, around_loop)\n   return to ? NEXT_INSN (to) : 0;\n }\n \f\n+/* Called via for_each_rtx to see if an insn is using a LABEL_REF for which\n+   there isn't a REG_DEAD note.  Return one if so.  DATA is the insn.  */\n+\n+static int\n+check_for_label_ref (rtl, data)\n+     rtx *rtl;\n+     void *data;\n+{\n+  rtx insn = (rtx) data;\n+\n+  /* If this insn uses a LABEL_REF and there isn't a REG_LABEL note for it,\n+     we must rerun jump since it needs to place the note.  If this is a\n+     LABEL_REF for a CODE_LABEL that isn't in the insn chain, don't do this\n+     since no REG_LABEL will be added. */\n+  return (GET_CODE (*rtl) == LABEL_REF\n+\t  && INSN_UID (XEXP (*rtl, 0)) != 0\n+\t  && ! find_reg_note (insn, REG_LABEL, XEXP (*rtl, 0)));\n+}\n+\f\n /* Count the number of times registers are used (not set) in X.\n    COUNTS is an array in which we accumulate the count, INCR is how much\n    we count each register usage."}]}