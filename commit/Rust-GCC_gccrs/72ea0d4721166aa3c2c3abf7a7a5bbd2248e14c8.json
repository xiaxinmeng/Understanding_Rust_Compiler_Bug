{"sha": "72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlYTBkNDcyMTE2NmFhM2MyYzNhYmY3YTdhNWJiZDIyNDhlMTRjOA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-04-19T03:57:22Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-04-19T03:57:22Z"}, "message": "[multiple changes]\n\n2013-04-18  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/56992\n\t* lra-coalesce.c (coalescable_pseudo_p): Remove 2nd parameter and\n\trelated code.\n\t(lra_coalesce): Remove split_origin_bitmap and related code.\n\t* lra.c (lra): Coalesce after undoing inheritance.  Recreate live\n\tranges if necessary.\n\n2013-04-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/56992\n\t* g++.dg/opt/pr56999.C: New test.\n\nFrom-SVN: r198082", "tree": {"sha": "5b0327b9fb3d3fdd57343fdfd1bcc9b35af18699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b0327b9fb3d3fdd57343fdfd1bcc9b35af18699"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/comments", "author": null, "committer": null, "parents": [{"sha": "ebad3a4f1bb5222eedd29994c5060aeb180a55cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebad3a4f1bb5222eedd29994c5060aeb180a55cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebad3a4f1bb5222eedd29994c5060aeb180a55cb"}], "stats": {"total": 250, "additions": 221, "deletions": 29}, "files": [{"sha": "880fef9662298cd6decc0a129c09c4163fb4367e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "patch": "@@ -1,3 +1,12 @@\n+2013-04-18  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/56992\n+\t* lra-coalesce.c (coalescable_pseudo_p): Remove 2nd parameter and\n+\trelated code.\n+\t(lra_coalesce): Remove split_origin_bitmap and related code.\n+\t* lra.c (lra): Coalesce after undoing inheritance.  Recreate live\n+\tranges if necessary.\n+\n 2013-04-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (x86_64_ms_sysv_extra_clobbered_registers):"}, {"sha": "859e02f0dba22667df302ae45664b8aba399fdd9", "filename": "gcc/lra-coalesce.c", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Flra-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Flra-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-coalesce.c?ref=72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "patch": "@@ -201,24 +201,14 @@ update_live_info (bitmap lr_bitmap)\n     }\n }\n \n-/* Return true if pseudo REGNO can be potentially coalesced.  Use\n-   SPLIT_PSEUDO_BITMAP to find pseudos whose live ranges were\n-   split.  */\n+/* Return true if pseudo REGNO can be potentially coalesced.  */\n static bool\n-coalescable_pseudo_p (int regno, bitmap split_origin_bitmap)\n+coalescable_pseudo_p (int regno)\n {\n   lra_assert (regno >= FIRST_PSEUDO_REGISTER);\n-  /* Don't coalesce inheritance pseudos because spilled inheritance\n-     pseudos will be removed in subsequent 'undo inheritance'\n-     pass.  */\n-  return (lra_reg_info[regno].restore_regno < 0\n-\t  /* We undo splits for spilled pseudos whose live ranges were\n-\t     split.  So don't coalesce them, it is not necessary and\n-\t     the undo transformations would be wrong.  */\n-\t  && ! bitmap_bit_p (split_origin_bitmap, regno)\n-\t  /* We don't want to coalesce regnos with equivalences, at\n+  return (/* We don't want to coalesce regnos with equivalences, at\n \t     least without updating this info.  */\n-\t  && ira_reg_equiv[regno].constant == NULL_RTX\n+\t  ira_reg_equiv[regno].constant == NULL_RTX\n \t  && ira_reg_equiv[regno].memory == NULL_RTX\n \t  && ira_reg_equiv[regno].invariant == NULL_RTX);\n }\n@@ -230,12 +220,10 @@ lra_coalesce (void)\n {\n   basic_block bb;\n   rtx mv, set, insn, next, *sorted_moves;\n-  int i, mv_num, sregno, dregno, restore_regno;\n-  unsigned int regno;\n+  int i, mv_num, sregno, dregno;\n   int coalesced_moves;\n   int max_regno = max_reg_num ();\n-  bitmap_head involved_insns_bitmap, split_origin_bitmap;\n-  bitmap_iterator bi;\n+  bitmap_head involved_insns_bitmap;\n \n   timevar_push (TV_LRA_COALESCE);\n \n@@ -249,11 +237,6 @@ lra_coalesce (void)\n     first_coalesced_pseudo[i] = next_coalesced_pseudo[i] = i;\n   sorted_moves = XNEWVEC (rtx, get_max_uid ());\n   mv_num = 0;\n-  /* Collect pseudos whose live ranges were split.  */\n-  bitmap_initialize (&split_origin_bitmap, &reg_obstack);\n-  EXECUTE_IF_SET_IN_BITMAP (&lra_split_regs, 0, regno, bi)\n-    if ((restore_regno = lra_reg_info[regno].restore_regno) >= 0)\n-      bitmap_set_bit (&split_origin_bitmap, restore_regno);\n   /* Collect moves.  */\n   coalesced_moves = 0;\n   FOR_EACH_BB (bb)\n@@ -265,15 +248,13 @@ lra_coalesce (void)\n \t    && (sregno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n \t    && (dregno = REGNO (SET_DEST (set))) >= FIRST_PSEUDO_REGISTER\n \t    && mem_move_p (sregno, dregno)\n-\t    && coalescable_pseudo_p (sregno, &split_origin_bitmap)\n-\t    && coalescable_pseudo_p (dregno, &split_origin_bitmap)\n+\t    && coalescable_pseudo_p (sregno) && coalescable_pseudo_p (dregno)\n \t    && ! side_effects_p (set)\n \t    && !(lra_intersected_live_ranges_p\n \t\t (lra_reg_info[sregno].live_ranges,\n \t\t  lra_reg_info[dregno].live_ranges)))\n \t  sorted_moves[mv_num++] = insn;\n     }\n-  bitmap_clear (&split_origin_bitmap);\n   qsort (sorted_moves, mv_num, sizeof (rtx), move_freq_compare_func);\n   /* Coalesced copies, most frequently executed first.\t*/\n   bitmap_initialize (&coalesced_pseudos_bitmap, &reg_obstack);"}, {"sha": "3ea4a6507d2c7fe222e1a4e0e6dcf6809e35c873", "filename": "gcc/lra.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "patch": "@@ -2295,11 +2295,20 @@ lra (FILE *f)\n \t    lra_assign ();\n \t  else\n \t    {\n-\t      /* Do coalescing only for regular algorithms.  */\n-\t      if (! lra_assign () && lra_coalesce ())\n-\t\tlive_p = false;\n+\t      bool spill_p = !lra_assign ();\n+\n \t      if (lra_undo_inheritance ())\n \t\tlive_p = false;\n+\t      if (spill_p)\n+\t\t{\n+\t\t  if (! live_p)\n+\t\t    {\n+\t\t      lra_create_live_ranges (true);\n+\t\t      live_p = true;\n+\t\t    }\n+\t\t  if (lra_coalesce ())\n+\t\t    live_p = false;\n+\t\t}\n \t      if (! live_p)\n \t\tlra_clear_live_ranges ();\n \t    }"}, {"sha": "f2bcfcf2395267f76a53e0cfc9d87bf59ae32a8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "patch": "@@ -1,3 +1,8 @@\n+2013-04-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/56992\n+\t* g++.dg/opt/pr56999.C: New test.\n+\n 2013-04-18   Cary Coutant  <ccoutant@google.com>\n \n \t* g++.dg/debug/dwarf2/pubnames-2.C: Add -fno-debug-types-section."}, {"sha": "6db2f270ecfd57c104dae546cabcf6698aefac4d", "filename": "gcc/testsuite/g++.dg/opt/pr56999.C", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr56999.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr56999.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr56999.C?ref=72ea0d4721166aa3c2c3abf7a7a5bbd2248e14c8", "patch": "@@ -0,0 +1,188 @@\n+// PR rtl-optimization/56999\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-fpic\" { target fpic } }\n+// { dg-additional-options \"-march=i686 -mtune=atom\" { target ia32 } }\n+// { dg-require-visibility \"\" }\n+\n+extern \"C\" void abort (void);\n+extern \"C\" void exit (int);\n+volatile bool do_exit = true;\n+struct JSScript;\n+struct JITScript { int i; };\n+#pragma GCC visibility push(hidden)\n+typedef struct JSCompartment JSCompartment;\n+typedef struct JSContext JSContext;\n+namespace js\n+{\n+  struct ContextFriendFields\n+  {\n+    JSCompartment *compartment;\n+  };\n+  struct TempAllocPolicy\n+  {\n+  };\n+  template <class T>\n+  struct Vector\n+  {\n+    T *mBegin;\n+    T *begin () { return mBegin; }\n+    T & operator[] (unsigned i) { return begin ()[i]; }\n+    template <class U>\n+    __attribute__((noinline, noclone))\n+    bool append (U) { asm volatile (\"\" : : : \"memory\"); if (do_exit) abort (); return false; }\n+  };\n+  namespace types\n+  {\n+    struct TypeCompartment;\n+  }\n+  namespace mjit\n+  {\n+  }\n+  namespace ion\n+  {\n+    struct IonScript;\n+  }\n+  namespace types\n+  {\n+    struct CompilerOutput\n+    {\n+      enum Kind { MethodJIT, ParallelIon };\n+      JSScript *script;\n+      unsigned kindInt : 2;\n+      bool constructing : 1;\n+      bool barriers : 1;\n+      bool pendingRecompilation : 1;\n+      Kind kind () const { return static_cast <Kind> (kindInt); }\n+      bool isValid () const;\n+    };\n+    struct RecompileInfo\n+    {\n+      unsigned outputIndex;\n+      CompilerOutput *compilerOutput (TypeCompartment & types) const;\n+      CompilerOutput *compilerOutput (JSContext *cx) const;\n+    };\n+    struct TypeCompartment\n+    {\n+      Vector <CompilerOutput> *constrainedOutputs;\n+      Vector <RecompileInfo> *pendingRecompiles;\n+      void addPendingRecompile (JSContext *cx, const RecompileInfo & info);\n+    };\n+  }\n+}\n+struct JSScript\n+{\n+  struct JITScriptHandle\n+  {\n+    static volatile JITScript *UNJITTABLE __attribute__((visibility (\"default\")));\n+    JITScript *value;\n+    bool isValid () { return value != UNJITTABLE; }\n+    JITScript *getValid () { return value; }\n+  };\n+  struct JITScriptSet\n+  {\n+    JITScriptHandle jitHandleNormal, jitHandleNormalBarriered;\n+    JITScriptHandle jitHandleCtor, jitHandleCtorBarriered;\n+    JITScriptHandle jitNull1, jitNull2;\n+  };\n+  JITScriptSet *mJITInfo;\n+  void *ion;\n+  JITScriptHandle *jitHandle (bool constructing, bool barriers)\n+  {\n+    return constructing ? (barriers ? &mJITInfo->jitHandleCtorBarriered\n+\t\t\t\t    : &mJITInfo->jitHandleCtor)\n+\t\t\t: (barriers ? &mJITInfo->jitHandleNormalBarriered\n+\t\t\t\t    : &mJITInfo->jitHandleNormal);\n+  }\n+  JITScript *getJIT (bool constructing, bool barriers)\n+  {\n+    JITScriptHandle *jith = jitHandle (constructing, barriers);\n+    return jith->isValid () ? jith->getValid () : __null;\n+  }\n+};\n+struct JSContext : js::ContextFriendFields\n+{\n+};\n+namespace js\n+{\n+  __attribute__((noinline, noclone))\n+  void CancelOffThreadIonCompile (JSCompartment *, JSScript *)\n+  {\n+    if (do_exit)\n+      exit (0);\n+  }\n+}\n+struct JSCompartment\n+{\n+  js::types::TypeCompartment types;\n+};\n+namespace js\n+{\n+  namespace types\n+  {\n+    inline bool CompilerOutput::isValid () const\n+    {\n+      if (!script)\n+\treturn false;\n+      switch (kind ())\n+\t{\n+\tcase MethodJIT:\n+\t  {\n+\t    JITScript *jit = script->getJIT (constructing, barriers);\n+\t    if (!jit)\n+\t      return false;\n+\t  }\n+\tcase ParallelIon:\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+    inline CompilerOutput *RecompileInfo::compilerOutput (TypeCompartment & types) const\n+    {\n+      return &(*types.constrainedOutputs)[outputIndex];\n+    }\n+    inline CompilerOutput *RecompileInfo::compilerOutput (JSContext *cx) const\n+    {\n+      return compilerOutput (cx->compartment->types);\n+    }\n+  }\n+}\n+using namespace js::types;\n+__attribute__((noinline, noclone)) void\n+TypeCompartment::addPendingRecompile (JSContext *cx, const RecompileInfo & info)\n+{\n+  CompilerOutput *co = info.compilerOutput (cx);\n+  if (co->pendingRecompilation)\n+    if (co->isValid ())\n+      CancelOffThreadIonCompile (cx->compartment, co->script);\n+  if (co->isValid ())\n+    pendingRecompiles->append (info);\n+}\n+volatile JITScript *JSScript::JITScriptHandle::UNJITTABLE;\n+int\n+main ()\n+{\n+  JSContext cx;\n+  JSCompartment com;\n+  RecompileInfo info;\n+  cx.compartment = &com;\n+  info.outputIndex = 0;\n+  js::Vector<CompilerOutput> v;\n+  JITScript js;\n+  JSScript::JITScriptSet set;\n+  __builtin_memset (&set, 0, sizeof set);\n+  set.jitHandleCtor.value = &js;\n+  JSScript s;\n+  s.mJITInfo = &set;\n+  CompilerOutput co;\n+  co.kindInt = 0;\n+  co.constructing = true;\n+  co.barriers = false;\n+  co.pendingRecompilation = true;\n+  co.script = &s;\n+  v.mBegin = &co;\n+  com.types.constrainedOutputs = &v;\n+  com.types.pendingRecompiles = __null;\n+  com.types.addPendingRecompile (&cx, info);\n+  abort ();\n+}"}]}