{"sha": "94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwODNlNWRkYjhjODdmNGIxMTIxNWFiMjAwYTRjY2FjYWM3OWQ1ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-02-16T01:26:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-16T01:26:14Z"}, "message": "Remove old ABI support from libsupc++.\n\n\t* libsupc++/cxxabi.h: Remove conditionally compiled code.\n\t* libsupc++/exception_support.cc: Likewise.\n\t* libsupc++/pure.cc: Likewise.\n\t* libsupc++/tinfo.cc: Likewise.\n\t* libsupc++/tinfo.h: Likewise.\n\t* libsupc++/tinfo2.cc: Likewise.\n\t* libsupc++/typeinfo: Likewise.\n\t* libsupc++/vec.cc: Likewise.\n\nFrom-SVN: r39732", "tree": {"sha": "ec8d0c6d236b322cc3e5a37ee0220bf1759a3149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec8d0c6d236b322cc3e5a37ee0220bf1759a3149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/comments", "author": null, "committer": null, "parents": [{"sha": "f1a3f197e1f19c0b439d84d2e3ce11ab21c507a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a3f197e1f19c0b439d84d2e3ce11ab21c507a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1a3f197e1f19c0b439d84d2e3ce11ab21c507a0"}], "stats": {"total": 1048, "additions": 23, "deletions": 1025}, "files": [{"sha": "0b4ea09ce42e53c518fec1dc426eebcfa81c2d34", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -1,3 +1,15 @@\n+2001-02-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove old ABI support from libsupc++.\n+\t* libsupc++/cxxabi.h: Remove conditionally compiled code.\n+\t* libsupc++/exception_support.cc: Likewise.\n+\t* libsupc++/pure.cc: Likewise.\n+\t* libsupc++/tinfo.cc: Likewise.\n+\t* libsupc++/tinfo.h: Likewise.\n+\t* libsupc++/tinfo2.cc: Likewise.\n+\t* libsupc++/typeinfo: Likewise.\n+\t* libsupc++/vec.cc: Likewise.\n+\n 2001-02-15  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tAdd support for -fno-exceptions."}, {"sha": "e533f4de7718199fd2db9491a0d5f7f791e25c1e", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -42,12 +42,6 @@\n #ifndef __CXXABI_H\n #define __CXXABI_H 1\n \n-#if defined(__cplusplus) && (!defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-/* These structures only make sense when targeting the new abi, catch a\n-   bonehead error early rather than let the user get very confused.  */\n-#error \"Not targetting the new abi, supply -fnew-abi\"\n-#endif\n-\n #ifdef __cplusplus\n \n // We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of"}, {"sha": "ae62e5321da9bcaf28d00eddab4b33c50df0ba1e", "filename": "libstdc++-v3/libsupc++/exception_support.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -151,10 +151,6 @@ __cplus_type_matcher (__eh_info *info_, void *match_info,\n   \n   void *match_type = match_info;\n   \n-#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-  match_type  = ((void *(*)())match_type) ();\n-#endif\n-\n   if (__throw_type_match_rtti_2 (match_type, info->type,\n \t\t\t\t info->original_value, &info->value))\n     // Arbitrary non-null pointer.\n@@ -352,7 +348,7 @@ __check_null_eh_spec (void)\n // Helpers for rtti. Although these don't return, we give them return types so\n // that the type system is not broken.\n extern \"C\" void *\n-__cxa_bad_cast()\n+__cxa_bad_cast ()\n {\n #ifdef __EXCEPTIONS  \n   throw std::bad_cast();\n@@ -363,7 +359,7 @@ __cxa_bad_cast()\n }\n \n extern \"C\" std::type_info const &\n-__cxa_bad_typeid()\n+__cxa_bad_typeid ()\n {\n #ifdef __EXCEPTIONS  \n   throw std::bad_typeid();"}, {"sha": "7373cd1739f641a87ee148ab8df63a03dea5f2e8", "filename": "libstdc++-v3/libsupc++/pure.cc", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpure.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpure.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpure.cc?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -1,6 +1,5 @@\n // -*- C++ -*- \n-\n-// Copyright (C) 2000 Free Software Foundation\n+// Copyright (C) 2000, 2001 Free Software Foundation\n //\n // This file is part of GNU CC.\n //\n@@ -47,16 +46,8 @@ extern \"C\" {\n \n extern void __terminate(void) __attribute__ ((__noreturn__));\n \n-// The name of the function to be placed in vtables in place of a pure\n-// virtual function is different in the two ABIs.\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-#define PURE_VIRTUAL_NAME __pure_virtual\n-#else\n-#define PURE_VIRTUAL_NAME __cxa_pure_virtual\n-#endif\n-\n void\n-PURE_VIRTUAL_NAME (void)\n+__cxa_pure_virtual (void)\n {\n   writestr (\"pure virtual method called\\n\");\n   __terminate ();"}, {"sha": "1d0c505893994af20b196ed9cb848325840f666d", "filename": "libstdc++-v3/libsupc++/tinfo.cc", "status": "modified", "additions": 1, "deletions": 497, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -1,6 +1,5 @@\n // Methods for type_info for -*- C++ -*- Run Time Type Identification.\n-\n-// Copyright (C) 1994, 1996, 1998, 1999, 2000 Free Software Foundation\n+// Copyright (C) 1994, 1996, 1998, 1999, 2000, 2001 Free Software Foundation\n //\n // This file is part of GNU CC.\n //\n@@ -53,500 +52,6 @@ operator== (const std::type_info& arg) const\n \n #endif\n \n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// original (old) abi\n-\n-namespace\n-{\n-// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n-// using OFFSET.\n-inline void*\n-convert_to_base (void *addr, bool is_virtual, myint32 offset)\n-{\n-  if (!addr)\n-    return NULL;\n-\n-  if (!is_virtual)\n-    return (char *) addr + offset;\n-\n-  // Under the old ABI, the offset gives us the address of a pointer\n-  // to the virtual base.\n-  return *((void **) ((char *) addr + offset));\n-}\n-\n-}\n-\n-extern \"C\" void\n-__rtti_class (void *addr, const char *name,\n-\t      const __class_type_info::base_info *bl, std::size_t bn)\n-{ new (addr) __class_type_info (name, bl, bn); }\n-\n-extern \"C\" void\n-__rtti_si (void *addr, const char *n, const std::type_info *ti)\n-{\n-  new (addr) __si_type_info\n-    (n, static_cast <const __user_type_info &> (*ti));\n-}\n-\n-extern \"C\" void\n-__rtti_user (void *addr, const char *name)\n-{ new (addr) __user_type_info (name); }\n-\n-// Upcast for catch checking. OBJPTR points to the thrown object and might be\n-// NULL. Return 0 on failure, non-zero on success. Set *ADJPTR to adjusted\n-// object pointer.\n-int __user_type_info::\n-upcast (const type_info &target, void *objptr,\n-        void **adjptr) const\n-{\n-  upcast_result result;\n-  \n-  if (do_upcast (contained_public, target, objptr, result))\n-    return 0;\n-  *adjptr = result.target_obj;\n-  return contained_public_p (result.whole2target);\n-}\n-\n-// Down or cross cast for dynamic_cast. OBJPTR points to the most derrived\n-// object, SUBPTR points to the static base object. Both must not be NULL.\n-// TARGET specifies the desired target type, SUBTYPE specifies the static\n-// type. Both must be defined. Returns adjusted object pointer on success,\n-// NULL on failure. [expr.dynamic.cast]/8 says 'unambiguous public base'. This\n-// itself is an ambiguous statement. We choose it to mean the base must be\n-// separately unambiguous and public, rather than unambiguous considering only\n-// public bases.\n-void *__user_type_info::\n-dyncast (int boff,\n-         const type_info &target, void *objptr,\n-         const type_info &subtype, void *subptr) const\n-{\n-  dyncast_result result;\n-  \n-  do_dyncast (boff, contained_public,\n-              target, objptr, subtype, subptr, result);\n-  if (!result.target_obj)\n-    return NULL;\n-  if (contained_public_p (result.target2sub))\n-    return result.target_obj;\n-  if (contained_public_p (sub_kind (result.whole2sub & result.whole2target)))\n-    // Found a valid cross cast\n-    return result.target_obj;\n-  if (contained_nonvirtual_p (result.whole2sub))\n-    // Found an invalid cross cast, which cannot also be a down cast\n-    return NULL;\n-  if (result.target2sub == unknown)\n-    result.target2sub = static_cast <const __user_type_info &> (target)\n-                        .find_public_subobj (boff, subtype,\n-                                             result.target_obj, subptr);\n-  if (contained_public_p (result.target2sub))\n-    // Found a valid down cast\n-    return result.target_obj;\n-  // Must be an invalid down cast, or the cross cast wasn't bettered\n-  return NULL;\n-}\n-\n-// Catch cast helper. ACCESS_PATH is the access from the complete thrown\n-// object to this base. TARGET is the desired type we want to catch. OBJPTR\n-// points to this base within the throw object, it might be NULL. Fill in\n-// RESULT with what we find. Return true, should we determine catch must fail.\n-bool __user_type_info::\n-do_upcast (sub_kind access_path,\n-           const type_info &target, void *objptr,\n-           upcast_result &__restrict result) const\n-{\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2target = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  return false;\n-}\n-\n-// dynamic cast helper. ACCESS_PATH gives the access from the most derived\n-// object to this base. TARGET indicates the desired type we want. OBJPTR\n-// points to this base within the object. SUBTYPE indicates the static type\n-// started from and SUBPTR points to that base within the most derived object.\n-// Fill in RESULT with what we find. Return true if we have located an\n-// ambiguous match.\n-bool __user_type_info::\n-do_dyncast (int, sub_kind access_path,\n-            const type_info &target, void *objptr,\n-            const type_info &subtype, void *subptr,\n-            dyncast_result &__restrict result) const\n-{\n-  if (objptr == subptr && *this == subtype)\n-    {\n-      // The subobject we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2sub = access_path;\n-      return false;\n-    }\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.whole2target = access_path;\n-      result.target2sub = not_contained;\n-      return false;\n-    }\n-  return false;\n-}\n-\n-// find_public_subobj helper. Return contained_public if we are the desired\n-// subtype. OBJPTR points to this base type, SUBPTR points to the desired base\n-// object.\n-__user_type_info::sub_kind __user_type_info::\n-do_find_public_subobj (int, const type_info &, void *objptr, void *subptr) const\n-{\n-  if (subptr == objptr)\n-    // Must be our type, as the pointers match.\n-    return contained_public;\n-  return not_contained;\n-}\n-\n-// catch helper for single public inheritance types. See\n-// __user_type_info::do_upcast for semantics.\n-bool __si_type_info::\n-do_upcast (sub_kind access_path,\n-           const type_info &target, void *objptr,\n-           upcast_result &__restrict result) const\n-{\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2target = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  return base.do_upcast (access_path, target, objptr, result);\n-}\n-\n-// dynamic cast helper for single public inheritance types. See\n-// __user_type_info::do_dyncast for semantics. BOFF indicates how SUBTYPE\n-// types are inherited by TARGET types.\n-bool __si_type_info::\n-do_dyncast (int boff, sub_kind access_path,\n-            const type_info &target, void *objptr,\n-            const type_info &subtype, void *subptr,\n-            dyncast_result &__restrict result) const\n-{\n-  if (objptr == subptr && *this == subtype)\n-    {\n-      // The subobject we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2sub = access_path;\n-      return false;\n-    }\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.whole2target = access_path;\n-      if (boff >= 0)\n-        result.target2sub = ((char *)subptr - (char *)objptr) == boff\n-              ? contained_public : not_contained;\n-      else if (boff == -2)\n-        result.target2sub = not_contained;\n-      return false;\n-    }\n-  return base.do_dyncast (boff, access_path,\n-                          target, objptr, subtype, subptr, result);\n-}\n-\n-// find_public_subobj helper. See __user_type_info::do_find_public_subobj or\n-// semantics. BOFF indicates how SUBTYPE types are inherited by the original\n-// target object.\n-__user_type_info::sub_kind __si_type_info::\n-do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const\n-{\n-  if (subptr == objptr && subtype == *this)\n-    return contained_public;\n-  return base.do_find_public_subobj (boff, subtype, objptr, subptr);\n-}\n-\n-// catch helper for multiple or non-public inheritance types. See\n-// __user_type_info::do_upcast for semantics.\n-bool __class_type_info::\n-do_upcast (sub_kind access_path,\n-           const type_info &target, void *objptr,\n-           upcast_result &__restrict result) const\n-{\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2target = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  \n-  for (std::size_t i = n_bases; i--;)\n-    {\n-      upcast_result result2;\n-      void *p = objptr;\n-      sub_kind sub_access = access_path;\n-      p = convert_to_base (p, \n-\t\t\t   base_list[i].is_virtual,\n-\t\t\t   base_list[i].offset);\n-      if (base_list[i].is_virtual)\n-\tsub_access = sub_kind (sub_access | contained_virtual_mask);\n-      if (base_list[i].access != PUBLIC)\n-        sub_access = sub_kind (sub_access & ~contained_public_mask);\n-      if (base_list[i].base->do_upcast (sub_access, target, p, result2)\n-          && !contained_virtual_p (result2.whole2target))\n-        return true; // must fail\n-      if (result2.base_type)\n-        {\n-          if (result2.base_type == nonvirtual_base_type\n-              && base_list[i].is_virtual)\n-            result2.base_type = base_list[i].base;\n-          if (!result.base_type)\n-            result = result2;\n-          else if (result.target_obj != result2.target_obj)\n-            {\n-              // Found an ambiguity.\n-\t      result.target_obj = NULL;\n-\t      result.whole2target = contained_ambig;\n-\t      return true;\n-            }\n-          else if (result.target_obj)\n-            {\n-              // Ok, found real object via a virtual path.\n-              result.whole2target\n-                  = sub_kind (result.whole2target | result2.whole2target);\n-            }\n-          else\n-            {\n-              // Dealing with a null pointer, need to check vbase\n-              // containing each of the two choices.\n-              if (result2.base_type == nonvirtual_base_type\n-                  || result.base_type == nonvirtual_base_type\n-                  || !(*result2.base_type == *result.base_type))\n-                {\n-                  // Already ambiguous, not virtual or via different virtuals.\n-                  // Cannot match.\n-                  result.whole2target = contained_ambig;\n-                  return true;\n-                }\n-              result.whole2target\n-                  = sub_kind (result.whole2target | result2.whole2target);\n-            }\n-        }\n-    }\n-  return false;\n-}\n-\n-// dynamic cast helper for non-public or multiple inheritance types. See\n-// __user_type_info::do_dyncast for overall semantics.\n-// This is a big hairy function. Although the run-time behaviour of\n-// dynamic_cast is simple to describe, it gives rise to some non-obvious\n-// behaviour. We also desire to determine as early as possible any definite\n-// answer we can get. Because it is unknown what the run-time ratio of\n-// succeeding to failing dynamic casts is, we do not know in which direction\n-// to bias any optimizations. To that end we make no particular effort towards\n-// early fail answers or early success answers. Instead we try to minimize\n-// work by filling in things lazily (when we know we need the information),\n-// and opportunisticly take early success or failure results.\n-bool __class_type_info::\n-do_dyncast (int boff, sub_kind access_path,\n-            const type_info &target, void *objptr,\n-            const type_info &subtype, void *subptr,\n-            dyncast_result &__restrict result) const\n-{\n-  if (objptr == subptr && *this == subtype)\n-    {\n-      // The subobject we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2sub = access_path;\n-      return false;\n-    }\n-  if (*this == target)\n-    {\n-      result.target_obj = objptr;\n-      result.whole2target = access_path;\n-      if (boff >= 0)\n-        result.target2sub = ((char *)subptr - (char *)objptr) == boff\n-              ? contained_public : not_contained;\n-      else if (boff == -2)\n-        result.target2sub = not_contained;\n-      return false;\n-    }\n-  bool result_ambig = false;\n-  for (std::size_t i = n_bases; i--;)\n-    {\n-      dyncast_result result2;\n-      void *p;\n-      sub_kind sub_access = access_path;\n-      p = convert_to_base (objptr, \n-\t\t\t   base_list[i].is_virtual,\n-\t\t\t   base_list[i].offset);\n-      if (base_list[i].is_virtual)\n-\tsub_access = sub_kind (sub_access | contained_virtual_mask);\n-      if (base_list[i].access != PUBLIC)\n-        sub_access = sub_kind (sub_access & ~contained_public_mask);\n-      \n-      bool result2_ambig\n-          = base_list[i].base->do_dyncast (boff, sub_access,\n-                                           target, p, subtype, subptr, result2);\n-      result.whole2sub = sub_kind (result.whole2sub | result2.whole2sub);\n-      if (result2.target2sub == contained_public\n-          || result2.target2sub == contained_ambig)\n-        {\n-          result.target_obj = result2.target_obj;\n-          result.whole2target = result2.whole2target;\n-          result.target2sub = result2.target2sub;\n-          // Found a downcast which can't be bettered or an ambiguous downcast\n-          // which can't be disambiguated\n-          return result2_ambig;\n-        }\n-      \n-      if (!result_ambig && !result.target_obj)\n-        {\n-          // Not found anything yet.\n-          result.target_obj = result2.target_obj;\n-          result.whole2target = result2.whole2target;\n-          result_ambig = result2_ambig;\n-        }\n-      else if (result.target_obj && result.target_obj == result2.target_obj)\n-        {\n-          // Found at same address, must be via virtual.  Pick the most\n-          // accessible path.\n-          result.whole2target =\n-              sub_kind (result.whole2target | result2.whole2target);\n-        }\n-      else if ((result.target_obj && result2.target_obj)\n-               || (result_ambig && result2.target_obj)\n-               || (result2_ambig && result.target_obj))\n-        {\n-          // Found two different TARGET bases, or a valid one and a set of\n-          // ambiguous ones, must disambiguate. See whether SUBOBJ is\n-          // contained publicly within one of the non-ambiguous choices.\n-          // If it is in only one, then that's the choice. If it is in\n-          // both, then we're ambiguous and fail. If it is in neither,\n-          // we're ambiguous, but don't yet fail as we might later find a\n-          // third base which does contain SUBPTR.\n-        \n-          sub_kind new_sub_kind = result2.target2sub;\n-          sub_kind old_sub_kind = result.target2sub;\n-          \n-          if (contained_nonvirtual_p (result.whole2sub))\n-            {\n-              // We already found SUBOBJ as a non-virtual base of most\n-              // derived. Therefore if it is in either choice, it can only be\n-              // in one of them, and we will already know.\n-              if (old_sub_kind == unknown)\n-                old_sub_kind = not_contained;\n-              if (new_sub_kind == unknown)\n-                new_sub_kind = not_contained;\n-            }\n-          else\n-            {\n-              const __user_type_info &t =\n-                  static_cast <const __user_type_info &> (target);\n-              \n-              if (old_sub_kind >= not_contained)\n-                ;// already calculated\n-              else if (contained_nonvirtual_p (new_sub_kind))\n-                // Already found non-virtually inside the other choice,\n-                // cannot be in this.\n-                old_sub_kind = not_contained;\n-              else\n-                old_sub_kind = t.find_public_subobj (boff, subtype,\n-                                                     result.target_obj, subptr);\n-          \n-              if (new_sub_kind >= not_contained)\n-                ;// already calculated\n-              else if (contained_nonvirtual_p (old_sub_kind))\n-                // Already found non-virtually inside the other choice,\n-                // cannot be in this.\n-                new_sub_kind = not_contained;\n-              else\n-                new_sub_kind = t.find_public_subobj (boff, subtype,\n-                                                     result2.target_obj, subptr);\n-            }\n-          \n-          // Neither sub_kind can be contained_ambig -- we bail out early\n-          // when we find those.\n-          if (contained_p (sub_kind (new_sub_kind ^ old_sub_kind)))\n-            {\n-              // Only on one choice, not ambiguous.\n-              if (contained_p (new_sub_kind))\n-                {\n-                  // Only in new.\n-                  result.target_obj = result2.target_obj;\n-                  result.whole2target = result2.whole2target;\n-                  result_ambig = false;\n-                  old_sub_kind = new_sub_kind;\n-                }\n-              result.target2sub = old_sub_kind;\n-              if (result.target2sub == contained_public)\n-                return false; // Can't be an ambiguating downcast for later discovery.\n-            }\n-          else if (contained_p (sub_kind (new_sub_kind & old_sub_kind)))\n-            {\n-              // In both.\n-              result.target_obj = NULL;\n-              result.target2sub = contained_ambig;\n-              return true;  // Fail.\n-            }\n-          else\n-            {\n-              // In neither publicly, ambiguous for the moment, but keep\n-              // looking. It is possible that it was private in one or\n-              // both and therefore we should fail, but that's just tough.\n-              result.target_obj = NULL;\n-              result.target2sub = not_contained;\n-              result_ambig = true;\n-            }\n-        }\n-      \n-      if (result.whole2sub == contained_private)\n-        // We found SUBOBJ as a private non-virtual base, therefore all\n-        // cross casts will fail. We have already found a down cast, if\n-        // there is one.\n-        return result_ambig;\n-    }\n-\n-  return result_ambig;\n-}\n-\n-// find_public_subobj helper for non-public or multiple inheritance types. See\n-// __user_type_info::do_find_public_subobj for semantics. We make use of BOFF\n-// to prune the base class walk.\n-__user_type_info::sub_kind __class_type_info::\n-do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const\n-{\n-  if (objptr == subptr && subtype == *this)\n-    return contained_public;\n-  \n-  for (std::size_t i = n_bases; i--;)\n-    {\n-      if (base_list[i].access != PUBLIC)\n-        continue; // Not public, can't be here.\n-      void *p;\n-\n-      if (base_list[i].is_virtual && boff == -3)\n-\t// Not a virtual base, so can't be here.\n-\tcontinue;\n-      \n-      p = convert_to_base (objptr, \n-\t\t\t   base_list[i].is_virtual,\n-\t\t\t   base_list[i].offset);\n-\n-      sub_kind base_kind = base_list[i].base->do_find_public_subobj\n-                              (boff, subtype, p, subptr);\n-      if (contained_p (base_kind))\n-        {\n-          if (base_list[i].is_virtual)\n-            base_kind = sub_kind (base_kind | contained_virtual_mask);\n-          return base_kind;\n-        }\n-    }\n-  \n-  return not_contained;\n-}\n-#else\n-// new abi\n-\n namespace std {\n \n // return true if this is a type_info for a pointer type\n@@ -1212,4 +717,3 @@ __dynamic_cast (const void *src_ptr,    // object started from\n }\n \n }; // namespace __cxxabiv1\n-#endif"}, {"sha": "e5cb63aa8d365883e4e357a71fc2303f4177b6f0", "filename": "libstdc++-v3/libsupc++/tinfo.h", "status": "modified", "additions": 1, "deletions": 217, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.h?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -1,225 +1,9 @@\n // RTTI support internals for -*- C++ -*-\n-\n-// Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000 Free Software Foundation\n-\n+// Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000, 2001 Free Software Foundation\n #include \"typeinfo\"\n #include <cstddef>\n \n // Class declarations shared between the typeinfo implementation files.\n \n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// original (old) abi\n-\n-// type_info for a class with no base classes (or an enum).\n-\n-struct __user_type_info : public std::type_info {\n-  __user_type_info (const char *n) : type_info (n) {}\n-\n-  // If our type can be upcast to a public and unambiguous base, then return\n-  // non-zero and set RES to point to the base object. OBJ points to the throw\n-  // object and can be NULL, if there is no object to adjust.\n-  int upcast (const type_info &target, void *obj, void **res) const;\n-  \n-  // If our type can be dynamicly cast to the target type, then return\n-  // pointer to the target object. OBJ is the pointer to the most derived\n-  // type and cannot be NULL. SUBTYPE and SUBOBJ indicate the static type\n-  // base object from whence we came, it cannot be NULL. SUBTYPE cannot be\n-  // the same as TARGET. TARGET cannot be a base of SUBTYPE.\n-  // BOFF indicates how SUBTYPE is related to TARGET.\n-  // BOFF >= 0, there is only one public non-virtual SUBTYPE base at offset\n-  //    BOFF, and there are no public virtual SUBTYPE bases.\n-  //    Therefore check if SUBOBJ is at offset BOFF when we find a target\n-  // BOFF == -1, SUBTYPE occurs as multiple public virtual or non-virtual bases.\n-  //    Lazily search all the bases of TARGET.\n-  // BOFF == -2, SUBTYPE is not a public base.\n-  // BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.\n-  //    Lazily search the non-virtual bases of TARGET.\n-  // For backwards compatibility set BOFF to -1, that is the safe \"unknown\"\n-  // value. We do not care about SUBTYPES as private bases of TARGET, as they\n-  // can never succeed as downcasts, only as crosscasts -- and then only if\n-  // they are virtual. This is more complicated that it might seem.\n-  void *dyncast (int boff,\n-                 const type_info &target, void *obj,\n-                 const type_info &subtype, void *subobj) const;\n-  \n-  // non_virtual_base_type is used to indicate that a base class is via a\n-  // non-virtual access path.\n-  static const type_info *const nonvirtual_base_type\n-      = static_cast <const type_info *> (0) + 1;\n-  \n-  // sub_kind tells us about how a base object is contained within a derived\n-  // object. We often do this lazily, hence the UNKNOWN value. At other times\n-  // we may use NOT_CONTAINED to mean not publicly contained.\n-  enum sub_kind\n-  {\n-    unknown = 0,              // we have no idea\n-    not_contained,            // not contained within us (in some\n-                              // circumstances this might mean not contained\n-                              // publicly)\n-    contained_ambig,          // contained ambiguously\n-    contained_mask = 4,       // contained within us\n-    contained_virtual_mask = 1, // via a virtual path\n-    contained_public_mask = 2,  // via a public path\n-    contained_private = contained_mask,\n-    contained_public = contained_mask | contained_public_mask\n-  };\n-  // some predicate functions for sub_kind\n-  static inline bool contained_p (sub_kind access_path)\n-  {\n-    return access_path >= contained_mask;\n-  }\n-  static inline bool contained_public_p (sub_kind access_path)\n-  {\n-    return access_path >= contained_public;\n-  }\n-  static inline bool contained_nonpublic_p (sub_kind access_path)\n-  {\n-    return (access_path & contained_public) == contained_mask;\n-  }\n-  static inline bool contained_nonvirtual_p (sub_kind access_path)\n-  {\n-    return (access_path & (contained_mask | contained_virtual_mask))\n-           == contained_mask;\n-  }\n-  static inline bool contained_virtual_p (sub_kind access_path)\n-  {\n-    return (access_path & (contained_mask | contained_virtual_mask))\n-           == (contained_mask | contained_virtual_mask);\n-  }\n-  \n-  struct upcast_result\n-  {\n-    void *target_obj;   // pointer to target object or NULL (init NULL)\n-    sub_kind whole2target;      // path from most derived object to target\n-    const type_info *base_type; // where we found the target, (init NULL)\n-                                // if in vbase the __user_type_info of vbase)\n-                                // if a non-virtual base then 1\n-                                // else NULL\n-    public:\n-    upcast_result ()\n-      :target_obj (NULL), whole2target (unknown), base_type (NULL)\n-      {}\n-  };\n-  struct dyncast_result\n-  {\n-    void *target_obj;   // pointer to target object or NULL (init NULL)\n-    sub_kind whole2target;      // path from most derived object to target\n-    sub_kind whole2sub;         // path from most derived object to sub object\n-    sub_kind target2sub;        // path from target to sub object\n-    \n-    public:\n-    dyncast_result ()\n-      :target_obj (NULL), whole2target (unknown),\n-       whole2sub (unknown), target2sub (unknown)\n-      {}\n-  };\n-  \n-  public:\n-  // Helper for upcast. See if TARGET is us, or one of our bases. ACCESS_PATH\n-  // gives the access from the start object. Return TRUE if we know the catch\n-  // fails.\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const type_info &target, void *obj,\n-                          upcast_result &__restrict result) const;\n-  // Helper for dyncast. BOFF indicates how the SUBTYPE is related to TARGET.\n-  // ACCESS_PATH indicates the access from the most derived object.  It is\n-  // used to prune the DAG walk. All information about what we find is put\n-  // into RESULT. Return true, if the match we have found is ambiguous.\n-  virtual bool do_dyncast (int boff, sub_kind access_path,\n-                           const type_info &target, void *obj,\n-                           const type_info &subtype, void *subptr,\n-                           dyncast_result &__restrict result) const;\n-  public:\n-  // Indicate whether SUBPTR of type SUBTYPE is contained publicly within\n-  // OBJPTR. OBJPTR points to this base object. BOFF indicates how SUBTYPE\n-  // objects might be contained within this type.  If SUBPTR is one of our\n-  // SUBTYPE bases, indicate virtuality. Returns not_contained for non\n-  // containment or private containment.\n-  sub_kind find_public_subobj (int boff, const type_info &subtype,\n-                               void *objptr, void *subptr) const\n-  {\n-    if (boff >= 0)\n-      return ((char *)subptr - (char *)objptr) == boff\n-              ? contained_public : not_contained;\n-    if (boff == -2)\n-      return not_contained;\n-    return do_find_public_subobj (boff, subtype, objptr, subptr);\n-  }\n-  \n-  public:\n-  // Helper for find_subobj. BOFF indicates how SUBTYPE bases are inherited by\n-  // the type started from -- which is not necessarily the current type.\n-  // OBJPTR points to the current base.\n-  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n-                                          void *objptr, void *subptr) const;\n-};\n-\n-// type_info for a class with one public, nonvirtual base class.\n-\n-class __si_type_info : public __user_type_info {\n-  const __user_type_info &base;\n-\n-public:\n-  __si_type_info (const char *n, const __user_type_info &b)\n-    : __user_type_info (n), base (b) { }\n-\n-  private:\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const type_info &target, void *obj,\n-                          upcast_result &__restrict result) const;\n-  virtual bool do_dyncast (int boff, sub_kind access_path,\n-                           const type_info &target, void *obj,\n-                           const type_info &subtype, void *subptr,\n-                           dyncast_result &__restrict result) const;\n-  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n-                                          void *objptr, void *subptr) const;\n-};\n-\n-// type_info for a general class.\n-\n-#include <climits>\n-\n-#if INT_MAX == 2147483647\n-typedef int myint32;\n-#elif SHRT_MAX == 2147483647\n-typedef short myint32;\n-#elif SCHAR_MAX == 2147483647\n-typedef signed char myint32;\n-#elif LONG_MAX == 2147483647\n-typedef long myint32;\n-#else\n-# error \"No 32-bit data type?\"\n-#endif\n-\n-struct __class_type_info : public __user_type_info {\n-  enum access { PUBLIC = 1, PROTECTED = 2, PRIVATE = 3 };\n-\n-  struct base_info {\n-    const __user_type_info *base;\n-    myint32 offset: 29;\n-    bool is_virtual: 1;\n-    enum access access: 2;\n-  };\n-\n-  const base_info *base_list;\n-  std::size_t n_bases;\n-\n-  __class_type_info (const char *name, const base_info *bl, std::size_t bn)\n-    : __user_type_info (name), base_list (bl), n_bases (bn) {}\n-\n-  public:\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const type_info &target, void *obj,\n-                          upcast_result &__restrict result) const;\n-  virtual bool do_dyncast (int boff, sub_kind access_path,\n-                           const type_info &target, void *obj,\n-                           const type_info &subtype, void *subptr,\n-                           dyncast_result &__restrict result) const;\n-  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n-                                          void *objptr, void *subptr) const;\n-};\n-#else\n-// new abi\n #include <cxxabi.h>\n \n-#endif"}, {"sha": "a29d1d30f0238123151ebb3df09fd7a146e796ca", "filename": "libstdc++-v3/libsupc++/tinfo2.cc", "status": "modified", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -48,65 +48,8 @@ type_info::before (const type_info &arg) const\n \n #endif\n \n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-\n-// type info for pointer type.\n-\n-struct __pointer_type_info : public type_info {\n-  const type_info& type;\n-\n-  __pointer_type_info (const char *n, const type_info& ti)\n-    : type_info (n), type (ti) {}\n-};\n-\n-// type info for attributes\n-\n-struct __attr_type_info : public type_info {\n-  enum cv { NONE = 0, CONST = 1, VOLATILE = 2, CONSTVOL = 1 | 2 };\n-\n-  const type_info& type;\n-  cv attr;\n-\n-  __attr_type_info (const char *n, cv a, const type_info& t)\n-    : type_info (n), type (t), attr (a) {}\n-};\n-\n-// type_info for builtin type\n-\n-struct __builtin_type_info : public type_info {\n-  __builtin_type_info (const char *n): type_info (n) {}\n-};\n-\n-// type info for function.\n-\n-struct __func_type_info : public type_info {\n-  __func_type_info (const char *n) : type_info (n) {}\n-};\n-\n-// type info for pointer to member function.\n-\n-struct __ptmf_type_info : public type_info {\n-  __ptmf_type_info (const char *n) : type_info (n) {}\n-};\n-\n-// type info for pointer to data member.\n-\n-struct __ptmd_type_info : public type_info {\n-  __ptmd_type_info (const char *n): type_info (n) {}\n-};\n-\n-// type info for array.\n-\n-struct __array_type_info : public type_info {\n-  __array_type_info (const char *n): type_info (n) {}\n-};\n-\n-#else\n-\n #include <cxxabi.h>\n-#endif\n \n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n namespace __cxxabiv1 {\n \n using namespace std;\n@@ -222,7 +165,6 @@ __pointer_catch (const __pbase_type_info *thr_type,\n }\n \n } // namespace std\n-#endif\n \n // Entry points for the compiler.\n \n@@ -238,222 +180,16 @@ __throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n \n   *valp = objptr;\n \n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// old abi\n-  if (catch_type == throw_type)\n-    return 1;\n-  \n-  if (const __user_type_info *p\n-      = dynamic_cast <const __user_type_info *> (&throw_type))\n-    {\n-      return p->upcast (catch_type, objptr, valp);\n-    }\n-  else if (const __pointer_type_info *fr =\n-\t   dynamic_cast <const __pointer_type_info *> (&throw_type))\n-    {\n-      const __pointer_type_info *to =\n-\t   dynamic_cast <const __pointer_type_info *> (&catch_type);\n-\n-      if (! to)\n-\treturn 0;\n-\n-      const type_info *subfr = &fr->type, *subto = &to->type;\n-      __attr_type_info::cv cvfrom, cvto;\n-\n-      if (const __attr_type_info *at\n-\t  = dynamic_cast <const __attr_type_info *> (subfr))\n-\t{\n-\t  cvfrom = at->attr;\n-\t  subfr = &at->type;\n-\t}\n-      else\n-\tcvfrom = __attr_type_info::NONE;\n-      \n-      if (const __attr_type_info *at\n-\t  = dynamic_cast <const __attr_type_info *> (subto))\n-\t{\n-\t  cvto = at->attr;\n-\t  subto = &at->type;\n-\t}\n-      else\n-\tcvto = __attr_type_info::NONE;\n-\n-      if (((cvfrom & __attr_type_info::CONST)\n-\t   > (cvto & __attr_type_info::CONST))\n-\t  || ((cvfrom & __attr_type_info::VOLATILE)\n-\t      > (cvto & __attr_type_info::VOLATILE)))\n-\treturn 0;\n-\n-      if (*subto == *subfr)\n-\treturn 1;\n-      else if (*subto == typeid (void)\n-\t       && dynamic_cast <const __func_type_info *> (subfr) == 0)\n-\treturn 1;\n-      else if (const __user_type_info *p\n-\t       = dynamic_cast <const __user_type_info *> (subfr))\n-\treturn p->upcast (*subto, objptr, valp);\n-      else if (const __pointer_type_info *pfr\n-\t       = dynamic_cast <const __pointer_type_info *> (subfr))\n-\t{\n-\t  // Multi-level pointer conversion.\n-\n-\t  const __pointer_type_info *pto\n-\t    = dynamic_cast <const __pointer_type_info *> (subto);\n-\n-\t  if (! pto)\n-\t    return 0;\n-\t    \n-\t  bool constp = (cvto & __attr_type_info::CONST);\n-\t  for (subto = &pto->type, subfr = &pfr->type; ;\n-\t       subto = &pto->type, subfr = &pfr->type)\n-\t    {\n-\t      if (const __attr_type_info *at\n-\t\t  = dynamic_cast <const __attr_type_info *> (subfr))\n-\t\t{\n-\t\t  cvfrom = at->attr;\n-\t\t  subfr = &at->type;\n-\t\t}\n-\t      else\n-\t\tcvfrom = __attr_type_info::NONE;\n-      \n-\t      if (const __attr_type_info *at\n-\t\t  = dynamic_cast <const __attr_type_info *> (subto))\n-\t\t{\n-\t\t  cvto = at->attr;\n-\t\t  subto = &at->type;\n-\t\t}\n-\t      else\n-\t\tcvto = __attr_type_info::NONE;\n-\n-\t      if (((cvfrom & __attr_type_info::CONST)\n-\t\t   > (cvto & __attr_type_info::CONST))\n-\t\t  || ((cvfrom & __attr_type_info::VOLATILE)\n-\t\t      > (cvto & __attr_type_info::VOLATILE)))\n-\t\treturn 0;\n-\n-\t      if (! constp\n-\t\t  && (((cvfrom & __attr_type_info::CONST)\n-\t\t       < (cvto & __attr_type_info::CONST))\n-\t\t      || ((cvfrom & __attr_type_info::VOLATILE)\n-\t\t\t  < (cvto & __attr_type_info::VOLATILE))))\n-\t\treturn 0;\n-\n-\t      if (*subto == *subfr)\n-\t\treturn 1;\n-\n-\t      pto = dynamic_cast <const __pointer_type_info *> (subto);\n-\t      pfr = dynamic_cast <const __pointer_type_info *> (subfr);\n-\t      if (! pto || ! pfr)\n-\t\treturn 0;\t\t\n-\n-\t      if (! (cvto & __attr_type_info::CONST))\n-\t\tconstp = false;\n-\t    }\n-\t}\n-    }\n-#else\n-// new abi\n-  \n   return catch_type.__do_catch (&throw_type, valp, 1);\n-#endif\n-  return 0;\n }\n \n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-/* Backward compatibility wrapper.  */\n-\n-extern \"C\" void*\n-__throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n-\t\t\t void *objptr)\n-{\n-  void *ret;\n-  if (__throw_type_match_rtti_2 (catch_type_r, throw_type_r, objptr, &ret))\n-    return ret;\n-  return NULL;\n-}\n-#endif\n-\n /* Called from __cp_pop_exception.  Is P the type_info node for a pointer\n    of some kind?  */\n \n bool\n __is_pointer (void *p)\n {\n   const type_info *t = reinterpret_cast <const type_info *>(p);\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// old abi\n-  const __pointer_type_info *pt =\n-    dynamic_cast <const __pointer_type_info *> (t);\n-  return pt != 0;\n-#else\n-// new abi\n   return t->__is_pointer_p ();\n-#endif\n }\n \n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-// old abi\n-\n-extern \"C\" void\n-__rtti_ptr (void *addr, const char *n, const type_info *ti)\n-{ new (addr) __pointer_type_info (n, *ti); }\n-\n-extern \"C\" void\n-__rtti_attr (void *addr, const char *n, int attrval, const type_info *ti)\n-{\n-  new (addr) __attr_type_info\n-    (n, static_cast <__attr_type_info::cv> (attrval), *ti);\n-}\n-\n-extern \"C\" void\n-__rtti_func (void *addr, const char *name)\n-{ new (addr) __func_type_info (name); }\n-\n-extern \"C\" void\n-__rtti_ptmf (void *addr, const char *name)\n-{ new (addr) __ptmf_type_info (name); }\n-\n-extern \"C\" void\n-__rtti_ptmd (void *addr, const char *name)\n-{ new (addr) __ptmd_type_info (name); }\n-\n-extern \"C\" void\n-__rtti_array (void *addr, const char *name)\n-{ new (addr) __array_type_info (name); }\n-\n-extern \"C\" void *\n-__dynamic_cast (const type_info& (*from)(void), const type_info& (*to)(void),\n-\t\tint require_public, void *address, const type_info & (*sub)(void), void *subptr)\n-{\n-  if (!require_public) abort();\n-  return static_cast <__user_type_info const &> (from ()).dyncast\n-      (/*boff=*/-1, to (), address, sub (), subptr);\n-}\n-\n-extern \"C\" void *\n-__dynamic_cast_2 (const type_info& (*from)(void), const type_info& (*to)(void),\n-                  int boff,\n-\t\t  void *address, const type_info & (*sub)(void), void *subptr)\n-{\n-  return static_cast <__user_type_info const &> (from ()).dyncast\n-      (boff, to (), address, sub (), subptr);\n-}\n-\n-// type_info nodes and functions for the builtin types.  The mangling here\n-// must match the mangling in gcc/cp/rtti.c.\n-\n-#define BUILTIN(mangled)\t\t\t\t\t\\\n-unsigned char __ti##mangled [sizeof (__builtin_type_info)]\t\\\n-  __attribute__ ((aligned (__alignof__ (void *))));\t\t\\\n-extern \"C\" const type_info &__tf##mangled (void) {\t\t\\\n-  if ((*(void **) __ti##mangled) == 0)\t\t\t\t\\\n-    new (__ti##mangled) __builtin_type_info (#mangled);\t\t\\\n-  return *(type_info *)__ti##mangled;\t\t\t\t\\\n-}\n-\n-BUILTIN (v); BUILTIN (x); BUILTIN (l); BUILTIN (i); BUILTIN (s); BUILTIN (b);\n-BUILTIN (c); BUILTIN (w); BUILTIN (r); BUILTIN (d); BUILTIN (f);\n-BUILTIN (Ui); BUILTIN (Ul); BUILTIN (Ux); BUILTIN (Us); BUILTIN (Uc);\n-BUILTIN (Sc);\n-\n-#endif"}, {"sha": "bffe042a73a45f89c724009d76eb07e583dab4c5", "filename": "libstdc++-v3/libsupc++/typeinfo", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -1,6 +1,5 @@\n // RTTI support for -*- C++ -*-\n-\n-// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000 Free Software Foundation\n+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001 Free Software Foundation\n //\n // This file is part of GNU CC.\n //\n@@ -28,11 +27,6 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-// __GXX_ABI_VERSION distinguishes the ABI that is being used. Values <100\n-// indicate the `old' abi, which grew as C++ was defined. Values >=100\n-// indicate the `new' abi, which is a cross vendor C++ abi, documented at\n-// `http://reality.sgi.com/dehnert_engr/cxx/'.\n-\n #ifndef __TYPEINFO__\n #define __TYPEINFO__\n \n@@ -42,23 +36,16 @@\n \n extern \"C++\" {\n \n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n namespace __cxxabiv1\n {\n   class __class_type_info;\n } // namespace __cxxabiv1\n-#endif\n \n-\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-  // In the old ABI, typeinfo name strings were not merged.\n-  #define __GXX_MERGED_TYPEINFO_NAMES 0\n-#elif !__GXX_WEAK__\n-  // If weak symbols are not supported, they are still not merged.\n+#if !__GXX_WEAK__\n+  // If weak symbols are not supported, typeinfo names are not merged.\n   #define __GXX_MERGED_TYPEINFO_NAMES 0\n #else\n-  // In the new ABI, on platforms that support weak symbols, they are\n-  // merged.\n+  // On platforms that support weak symbols, typeinfo names are merged.\n   #define __GXX_MERGED_TYPEINFO_NAMES 1\n #endif\n \n@@ -86,13 +73,8 @@ namespace std\n     \n   public:\n     // the public interface\n-#if !defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n     const char* name() const\n     { return __name; }\n-#else\n-    const char* name() const\n-    { return __name; }\n-#endif\n \n #if !__GXX_MERGED_TYPEINFO_NAMES\n     bool before(const type_info& arg) const;\n@@ -112,7 +94,6 @@ namespace std\n     { return !operator==(__arg); }\n     \n     // the internal interface\n-#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n   public:\n     // return true if this is a pointer type of some kind\n     virtual bool __is_pointer_p() const;\n@@ -131,7 +112,6 @@ namespace std\n     // internally used during catch matching\n     virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,\n \t\t\t     void **__obj_ptr) const;\n-#endif\n   };\n \n   class bad_cast : public exception "}, {"sha": "c07e5ddfa6bdde011e3c9c822b5c1b240df0bdd9", "filename": "libstdc++-v3/libsupc++/vec.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94083e5ddb8c87f4b11215ab200a4ccacac79d5d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc?ref=94083e5ddb8c87f4b11215ab200a4ccacac79d5d", "patch": "@@ -298,3 +298,4 @@ namespace __cxxabiv1\n     dealloc(base, size);\n   }\n } // namespace __cxxabiv1\n+"}]}