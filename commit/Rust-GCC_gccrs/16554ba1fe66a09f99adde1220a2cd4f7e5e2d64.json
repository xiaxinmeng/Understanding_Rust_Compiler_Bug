{"sha": "16554ba1fe66a09f99adde1220a2cd4f7e5e2d64", "node_id": "C_kwDOANBUbNoAKDE2NTU0YmExZmU2NmEwOWY5OWFkZGUxMjIwYTJjZDRmN2U1ZTJkNjQ", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-05-05T02:41:38Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2023-03-03T20:00:53Z"}, "message": "libstdc++: testsuite: async.cc early timeout\n\nThe async call and future variable initialization may take a while to\ncomplete on uniprocessors, especially if the async call and other\nunrelated processes run before context switches back to the main\nthread.\n\nTaking steady_begin only then sometimes causes the 11*100ms in the\nslow clock, counted from before the async call, to not be enough for\nthe measured wait to last 1s in the steady clock.  I've seen it fall\nshort of 1s by as little as a third of a tenth of a second in some\ncases, but in one surprisingly extreme case the elapsed wait time got\nonly up to 216.7ms.\n\nInitializing both timestamps next to each other, before the async\ncall, appears to avoid the problem entirely.  I've renamed the\nvariable moved out of the block so as to avoid name hiding in the\nsubsequent block, that has another steady_begin variable.\n\nThe second wait fails a lot less frequently, but the 2s limit has been\nexceeded, so I'm bumping up the max sleep to ~4s, and the tolerance to\n3s.\n\n\nfor  libstdc++-v3/ChangeLog\n\n\t* testsuite/30_threads/async/async.cc (test04): Initialize\n\tsteady_start, renamed from steady_begin, next to slow_start.\n\tIncrease tolerance for final wait.", "tree": {"sha": "b181d3eef1625dd23c387565483b20559fc0c31d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b181d3eef1625dd23c387565483b20559fc0c31d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16554ba1fe66a09f99adde1220a2cd4f7e5e2d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16554ba1fe66a09f99adde1220a2cd4f7e5e2d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16554ba1fe66a09f99adde1220a2cd4f7e5e2d64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16554ba1fe66a09f99adde1220a2cd4f7e5e2d64/comments", "author": null, "committer": null, "parents": [{"sha": "1f83aee5864129c4147a95c1a4e35d37c7eb7e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f83aee5864129c4147a95c1a4e35d37c7eb7e59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f83aee5864129c4147a95c1a4e35d37c7eb7e59"}], "stats": {"total": 17, "additions": 12, "deletions": 5}, "files": [{"sha": "4e290e581c2f1e646df068fe35c368d70ea7219e", "filename": "libstdc++-v3/testsuite/30_threads/async/async.cc", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16554ba1fe66a09f99adde1220a2cd4f7e5e2d64/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16554ba1fe66a09f99adde1220a2cd4f7e5e2d64/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc?ref=16554ba1fe66a09f99adde1220a2cd4f7e5e2d64", "patch": "@@ -20,6 +20,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#include <iostream>\n \n #include <future>\n #include <thread>\n@@ -133,28 +134,34 @@ void test04()\n {\n   using namespace std::chrono;\n \n+  auto const steady_start = steady_clock::now();\n   auto const slow_start = slow_clock::now();\n   future<void> f1 = async(launch::async, []() {\n       std::this_thread::sleep_for(std::chrono::seconds(2));\n     });\n \n   // Wait for ~1s\n   {\n-    auto const steady_begin = steady_clock::now();\n     auto const status = f1.wait_until(slow_start + milliseconds(100));\n     VERIFY(status == std::future_status::timeout);\n-    auto const elapsed = steady_clock::now() - steady_begin;\n+    auto const elapsed = steady_clock::now() - steady_start;\n+    if (elapsed < seconds(1))\n+      std::cout << elapsed.count () << \"ns < 1s\" << std::endl;\n     VERIFY(elapsed >= seconds(1));\n     VERIFY(elapsed < seconds(2));\n   }\n \n-  // Wait for up to ~2s more\n+  // Wait for up to ~4s more, but since the async sleep completes, the\n+  // actual wait may be shorter than 1s.  Tolerate 3s because 2s\n+  // hasn't been enough in some extreme cases.\n   {\n     auto const steady_begin = steady_clock::now();\n-    auto const status = f1.wait_until(slow_start + milliseconds(300));\n+    auto const status = f1.wait_until(slow_start + milliseconds(500));\n     VERIFY(status == std::future_status::ready);\n     auto const elapsed = steady_clock::now() - steady_begin;\n-    VERIFY(elapsed < seconds(2));\n+    if (elapsed >= seconds(3))\n+      std::cout << elapsed.count () << \"ns > 2s\" << std::endl;\n+    VERIFY(elapsed < seconds(3));\n   }\n }\n "}]}