{"sha": "4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "node_id": "C_kwDOANBUbNoAKDRjOWE4MTgzYjM0NjlmNTBjOTQxOGEyMzA5ZTU2YjM3Y2JhYzlmOWY", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-02-24T16:30:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-13T08:04:41Z"}, "message": "[Ada] Simplify helper units for formal hashed sets/maps\n\nAs tampering checks do not exist in formal hashed sets and maps, remove\nthe machinery for such checks in the version of generic key and node\noperations for formal sets/maps. Update comments as well.\n\ngcc/ada/\n\n\t* libgnat/a-chtgfk.adb (Checked_Equivalent_Keys, Checked_Index):\n\tRemove useless functions.\n\t(Delete_Key_Sans_Free, Find, Generic_Conditional_Insert): Adapt\n\tto removal of wrapper functions.\n\t* libgnat/a-chtgfk.ads (Checked_Equivalent_Keys, Checked_Index):\n\tRemove useless functions.\n\t* libgnat/a-chtgfo.adb (Checked_Index): Remove useless function.\n\t(Clear): Delete code commented out regarding Busy and Lock\n\tmanagement.\n\t(Delete_Node_At_Index): Delete unused procedure.\n\t(Delete_Node_Sans_Free, Free, Generic_Read, Next): Adapt to\n\tremoval of wrapper functions.\n\t* libgnat/a-chtgfo.ads (Checked_Index): Remove useless function.\n\t(Delete_Node_At_Index): Delete unused procedure.", "tree": {"sha": "28c7c3b4bf906b1f675a91b4c935127ff6c0d99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28c7c3b4bf906b1f675a91b4c935127ff6c0d99a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e12e78628238a9e3cf68ce9376aa2e28e0506f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e12e78628238a9e3cf68ce9376aa2e28e0506f"}], "stats": {"total": 180, "additions": 24, "deletions": 156}, "files": [{"sha": "7d355e04c4917302458de4357fc2fd7e1043a169", "filename": "gcc/ada/libgnat/a-chtgfk.adb", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb?ref=4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "patch": "@@ -31,31 +31,6 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n \n    Checks : constant Boolean := Container_Checks'Enabled;\n \n-   -----------------------------\n-   -- Checked_Equivalent_Keys --\n-   -----------------------------\n-\n-   function Checked_Equivalent_Keys\n-     (HT   : Hash_Table_Type;\n-      Key  : Key_Type;\n-      Node : Count_Type) return Boolean\n-   is\n-   begin\n-      return Equivalent_Keys (Key, HT.Nodes (Node));\n-   end Checked_Equivalent_Keys;\n-\n-   -------------------\n-   -- Checked_Index --\n-   -------------------\n-\n-   function Checked_Index\n-     (HT  : Hash_Table_Type;\n-      Key : Key_Type) return Hash_Type\n-   is\n-   begin\n-      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n-   end Checked_Index;\n-\n    --------------------------\n    -- Delete_Key_Sans_Free --\n    --------------------------\n@@ -74,14 +49,14 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n          return;\n       end if;\n \n-      Indx := Checked_Index (HT, Key);\n+      Indx := Index (HT, Key);\n       X := HT.Buckets (Indx);\n \n       if X = 0 then\n          return;\n       end if;\n \n-      if Checked_Equivalent_Keys (HT, Key, X) then\n+      if Equivalent_Keys (Key, HT.Nodes (X)) then\n          HT.Buckets (Indx) := Next (HT.Nodes (X));\n          HT.Length := HT.Length - 1;\n          return;\n@@ -95,7 +70,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n             return;\n          end if;\n \n-         if Checked_Equivalent_Keys (HT, Key, X) then\n+         if Equivalent_Keys (Key, HT.Nodes (X)) then\n             Set_Next (HT.Nodes (Prev), Next => Next (HT.Nodes (X)));\n             HT.Length := HT.Length - 1;\n             return;\n@@ -119,11 +94,11 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n          return 0;\n       end if;\n \n-      Indx := Checked_Index (HT, Key);\n+      Indx := Index (HT, Key);\n \n       Node := HT.Buckets (Indx);\n       while Node /= 0 loop\n-         if Checked_Equivalent_Keys (HT, Key, Node) then\n+         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n             return Node;\n          end if;\n          Node := Next (HT.Nodes (Node));\n@@ -145,7 +120,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n       Indx : Hash_Type;\n \n    begin\n-      Indx := Checked_Index (HT, Key);\n+      Indx := Index (HT, Key);\n       Node := HT.Buckets (Indx);\n \n       if Node = 0 then\n@@ -165,7 +140,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n       end if;\n \n       loop\n-         if Checked_Equivalent_Keys (HT, Key, Node) then\n+         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n             Inserted := False;\n             return;\n          end if;\n@@ -204,27 +179,20 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n       NN : Nodes_Type renames HT.Nodes;\n \n       Old_Indx : Hash_Type;\n-      New_Indx : constant Hash_Type := Checked_Index (HT, Key);\n+      New_Indx : constant Hash_Type := Index (HT, Key);\n \n       New_Bucket : Count_Type renames BB (New_Indx);\n       N, M       : Count_Type;\n \n    begin\n-      --  The following block appears to be vestigial -- this should be done\n-      --  using Checked_Index instead. Also, we might have to move the actual\n-      --  tampering checks to the top of the subprogram, in order to prevent\n-      --  infinite recursion when calling Hash. (This is similar to how Insert\n-      --  and Delete are implemented.) This implies that we will have to defer\n-      --  the computation of New_Index until after the tampering check. ???\n-\n       Old_Indx := HT.Buckets'First + Hash (NN (Node)) mod HT.Buckets'Length;\n \n       --  Replace_Element is allowed to change a node's key to Key\n       --  (generic formal operation Assign provides the mechanism), but\n       --  only if Key is not already in the hash table. (In a unique-key\n       --  hash table as this one, a key is mapped to exactly one node.)\n \n-      if Checked_Equivalent_Keys (HT, Key, Node) then\n+      if Equivalent_Keys (Key, NN (Node)) then\n          --  The new Key value is mapped to this same Node, so Node\n          --  stays in the same bucket.\n \n@@ -239,7 +207,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n \n       N := New_Bucket;\n       while N /= 0 loop\n-         if Checks and then Checked_Equivalent_Keys (HT, Key, N) then\n+         if Checks and then Equivalent_Keys (Key, NN (N)) then\n             pragma Assert (N /= Node);\n             raise Program_Error with\n               \"attempt to replace existing element\";\n@@ -249,11 +217,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n       end loop;\n \n       --  We have determined that Key is not already in the hash table, so\n-      --  the change is tentatively allowed. We now perform the standard\n-      --  checks to determine whether the hash table is locked (because you\n-      --  cannot change an element while it's in use by Query_Element or\n-      --  Update_Element), or if the container is busy (because moving a\n-      --  node to a different bucket would interfere with iteration).\n+      --  the change is allowed.\n \n       if Old_Indx = New_Indx then\n          --  The node is already in the bucket implied by Key. In this case"}, {"sha": "363eaf05680a40b8780cae55d1ef2fbccc143ea8", "filename": "gcc/ada/libgnat/a-chtgfk.ads", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads?ref=4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "patch": "@@ -59,27 +59,11 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    pragma Inline (Index);\n    --  Returns the bucket number (array index value) for the given key\n \n-   function Checked_Index\n-     (HT  : Hash_Table_Type;\n-      Key : Key_Type) return Hash_Type;\n-   pragma Inline (Checked_Index);\n-   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n-   --  order to detect element tampering by the generic actual Hash function.\n-\n-   function Checked_Equivalent_Keys\n-     (HT   : Hash_Table_Type;\n-      Key  : Key_Type;\n-      Node : Count_Type) return Boolean;\n-   --  Calls Equivalent_Keys, but locks and unlocks the container, per\n-   --  AI05-0022, in order to detect element tampering by that generic actual.\n-\n    procedure Delete_Key_Sans_Free\n      (HT  : in out Hash_Table_Type;\n       Key : Key_Type;\n       X   : out Count_Type);\n-   --  Removes the node (if any) with the given key from the hash table,\n-   --  without deallocating it. Program_Error is raised if the hash\n-   --  table is busy.\n+   --  Removes the node (if any) with the given key from the hash table\n \n    function Find\n      (HT  : Hash_Table_Type;\n@@ -98,8 +82,7 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n    --  Attempts to insert a new node with the given key into the hash table.\n    --  If a node with that key already exists in the table, then that node\n    --  is returned and Inserted returns False. Otherwise New_Node is called\n-   --  to allocate a new node, and Inserted returns True. Program_Error is\n-   --  raised if the hash table is busy.\n+   --  to allocate a new node, and Inserted returns True.\n \n    generic\n       with function Hash (Node : Node_Type) return Hash_Type;\n@@ -108,15 +91,11 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n      (HT   : in out Hash_Table_Type;\n       Node : Count_Type;\n       Key  : Key_Type);\n-   --  Assigns Key to Node, possibly changing its equivalence class. If Node\n-   --  is in the same equivalence class as Key (that is, it's already in the\n-   --  bucket implied by Key), then if the hash table is locked then\n-   --  Program_Error is raised; otherwise Assign is called to assign Key to\n-   --  Node. If Node is in a different bucket from Key, then Program_Error is\n-   --  raised if the hash table is busy. Otherwise it Assigns Key to Node and\n-   --  moves the Node from its current bucket to the bucket implied by Key.\n-   --  Note that it is never proper to assign to Node a key value already\n-   --  in the map, and so if Key is equivalent to some other node then\n-   --  Program_Error is raised.\n+   --  Assigns Key to Node, possibly changing its equivalence class. Procedure\n+   --  Assign is called to assign Key to Node. If Node is not in the same\n+   --  bucket as Key before the assignment, it is moved from its current bucket\n+   --  to the bucket implied by Key. Note that it is never proper to assign to\n+   --  Node a key value already in the hash table, and so if Key is equivalent\n+   --  to some other node then Program_Error is raised.\n \n end Ada.Containers.Hash_Tables.Generic_Formal_Keys;"}, {"sha": "d688863d3fb7827a3ea14f2ae165d39cc4f1aaaa", "filename": "gcc/ada/libgnat/a-chtgfo.adb", "status": "modified", "additions": 4, "deletions": 61, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb?ref=4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "patch": "@@ -33,74 +33,17 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n \n    Checks : constant Boolean := Container_Checks'Enabled;\n \n-   -------------------\n-   -- Checked_Index --\n-   -------------------\n-\n-   function Checked_Index\n-     (Hash_Table : Hash_Table_Type;\n-      Node       : Count_Type) return Hash_Type\n-   is\n-   begin\n-      return Index (Hash_Table, Hash_Table.Nodes (Node));\n-   end Checked_Index;\n-\n    -----------\n    -- Clear --\n    -----------\n \n    procedure Clear (HT : in out Hash_Table_Type) is\n    begin\n       HT.Length := 0;\n-      --  HT.Busy := 0;\n-      --  HT.Lock := 0;\n       HT.Free := -1;\n       HT.Buckets := [others => 0];  -- optimize this somehow ???\n    end Clear;\n \n-   --------------------------\n-   -- Delete_Node_At_Index --\n-   --------------------------\n-\n-   procedure Delete_Node_At_Index\n-     (HT   : in out Hash_Table_Type;\n-      Indx : Hash_Type;\n-      X    : Count_Type)\n-   is\n-      Prev : Count_Type;\n-      Curr : Count_Type;\n-\n-   begin\n-      Prev := HT.Buckets (Indx);\n-\n-      if Checks and then Prev = 0 then\n-         raise Program_Error with\n-           \"attempt to delete node from empty hash bucket\";\n-      end if;\n-\n-      if Prev = X then\n-         HT.Buckets (Indx) := Next (HT.Nodes (Prev));\n-         HT.Length := HT.Length - 1;\n-         return;\n-      end if;\n-\n-      if Checks and then HT.Length = 1 then\n-         raise Program_Error with\n-           \"attempt to delete node not in its proper hash bucket\";\n-      end if;\n-\n-      loop\n-         Curr := Next (HT.Nodes (Prev));\n-\n-         if Checks and then Curr = 0 then\n-            raise Program_Error with\n-              \"attempt to delete node not in its proper hash bucket\";\n-         end if;\n-\n-         Prev := Curr;\n-      end loop;\n-   end Delete_Node_At_Index;\n-\n    ---------------------------\n    -- Delete_Node_Sans_Free --\n    ---------------------------\n@@ -121,7 +64,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n            \"attempt to delete node from empty hashed container\";\n       end if;\n \n-      Indx := Checked_Index (HT, X);\n+      Indx := Index (HT, HT.Nodes (X));\n       Prev := HT.Buckets (Indx);\n \n       if Checks and then Prev = 0 then\n@@ -223,7 +166,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n       --  in the \"normal\" way: Container.Free points to the head of the list\n       --  of free (inactive) nodes, and the value 0 means the free list is\n       --  empty. Each node on the free list has been initialized to point\n-      --  to the next free node (via its Parent component), and the value 0\n+      --  to the next free node (via its Next component), and the value 0\n       --  means that this is the last free node.\n       --\n       --  If Container.Free is negative, then the links on the free store\n@@ -446,7 +389,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n       for J in 1 .. N loop\n          declare\n             Node : constant Count_Type := New_Node (Stream);\n-            Indx : constant Hash_Type := Checked_Index (HT, Node);\n+            Indx : constant Hash_Type := Index (HT, HT.Nodes (Node));\n             B    : Count_Type renames HT.Buckets (Indx);\n          begin\n             Set_Next (HT.Nodes (Node), Next => B);\n@@ -523,7 +466,7 @@ package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n       --  This was the last node in the bucket, so move to the next\n       --  bucket, and start searching for next node from there.\n \n-      First := Checked_Index (HT, Node) + 1;\n+      First := Index (HT, HT.Nodes (Node)) + 1;\n       for Indx in First .. HT.Buckets'Last loop\n          Result := HT.Buckets (Indx);\n "}, {"sha": "043b73232fa9eaac23e9ab0e577c13a0e8a61cd7", "filename": "gcc/ada/libgnat/a-chtgfo.ads", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9a8183b3469f50c9418a2309e56b37cbac9f9f/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads?ref=4c9a8183b3469f50c9418a2309e56b37cbac9f9f", "patch": "@@ -62,12 +62,6 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    --  Uses the hash value of Node to compute its Hash_Table buckets array\n    --  index.\n \n-   function Checked_Index\n-     (Hash_Table : Hash_Table_Type;\n-      Node       : Count_Type) return Hash_Type;\n-   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n-   --  order to detect element tampering by the generic actual Hash function.\n-\n    generic\n       with function Find\n         (HT  : Hash_Table_Type;\n@@ -80,19 +74,7 @@ package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n    --  node then Generic_Equal returns True.\n \n    procedure Clear (HT : in out Hash_Table_Type);\n-   --  Deallocates each node in hash table HT. (Note that it only deallocates\n-   --  the nodes, not the buckets array.) Program_Error is raised if the hash\n-   --  table is busy.\n-\n-   procedure Delete_Node_At_Index\n-     (HT   : in out Hash_Table_Type;\n-      Indx : Hash_Type;\n-      X    : Count_Type);\n-   --  Delete a node whose bucket position is known. extracted from following\n-   --  subprogram, but also used directly to remove a node whose element has\n-   --  been modified through a key_preserving reference: in that case we cannot\n-   --  use the value of the element precisely because the current value does\n-   --  not correspond to the hash code that determines its bucket.\n+   --  Empties the hash table HT\n \n    procedure Delete_Node_Sans_Free\n      (HT : in out Hash_Table_Type;"}]}