{"sha": "3cf63c94df4712569e0ab996155013a3a043bed3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmNjNjOTRkZjQ3MTI1NjllMGFiOTk2MTU1MDEzYTNhMDQzYmVkMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-09-02T20:47:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-10T20:36:15Z"}, "message": "c++: Add make_temp_override generator functions\n\nA common pattern before C++17 is the generator function, used to avoid\nhaving to specify the type of a container element by using a function call\nto get type deduction; for example, std::make_pair.  C++17 added class type\nargument deduction, making generator functions unnecessary for many uses,\nbut GCC won't be written in C++17 for years yet.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (struct type_identity): New.\n\t(make_temp_override): New.\n\t* decl.c (grokdeclarator): Use it.\n\t* except.c (maybe_noexcept_warning): Use it.\n\t* parser.c (cp_parser_enum_specifier): Use it.\n\t(cp_parser_parameter_declaration_clause): Use it.\n\t(cp_parser_gnu_attributes_opt): Use it.\n\t(cp_parser_std_attribute): Use it.", "tree": {"sha": "ace8cabaa9a8553b576a222edb7e245246d67623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ace8cabaa9a8553b576a222edb7e245246d67623"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf63c94df4712569e0ab996155013a3a043bed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf63c94df4712569e0ab996155013a3a043bed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf63c94df4712569e0ab996155013a3a043bed3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf63c94df4712569e0ab996155013a3a043bed3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "445430e16bd08ade34637d2346ded40dd49de508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445430e16bd08ade34637d2346ded40dd49de508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445430e16bd08ade34637d2346ded40dd49de508"}], "stats": {"total": 44, "additions": 38, "deletions": 6}, "files": [{"sha": "5cd2999ca85bd347b9e5d7e28cf9ca8abc08573a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3cf63c94df4712569e0ab996155013a3a043bed3", "patch": "@@ -1932,6 +1932,38 @@ class temp_override\n   ~temp_override() { overridden_variable = saved_value; }\n };\n \n+/* Wrapping a template parameter in type_identity_t hides it from template\n+   argument deduction.  */\n+#if __cpp_lib_type_identity\n+using std::type_identity_t;\n+#else\n+template <typename T>\n+struct type_identity { typedef T type; };\n+template <typename T>\n+using type_identity_t = typename type_identity<T>::type;\n+#endif\n+\n+/* Object generator function for temp_override, so you don't need to write the\n+   type of the object as a template argument.\n+\n+   Use as auto x = make_temp_override (flag); */\n+\n+template <typename T>\n+inline temp_override<T>\n+make_temp_override (T& var)\n+{\n+  return { var };\n+}\n+\n+/* Likewise, but use as auto x = make_temp_override (flag, value); */\n+\n+template <typename T>\n+inline temp_override<T>\n+make_temp_override (T& var, type_identity_t<T> overrider)\n+{\n+  return { var, overrider };\n+}\n+\n /* The cached class binding level, from the most recently exited\n    class, or NULL if none.  */\n "}, {"sha": "b56eb113fd65cc9b2330d6e3b155cb96c137df66", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3cf63c94df4712569e0ab996155013a3a043bed3", "patch": "@@ -11513,7 +11513,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n   /* An object declared as __attribute__((deprecated)) suppresses\n      warnings of uses of other deprecated items.  */\n-  temp_override<deprecated_states> ds (deprecated_state);\n+  auto ds = make_temp_override (deprecated_state);\n   if (attrlist && lookup_attribute (\"deprecated\", *attrlist))\n     deprecated_state = DEPRECATED_SUPPRESS;\n "}, {"sha": "e76ade2f9256e92b39a242ab01ea702bf7a7ebfa", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=3cf63c94df4712569e0ab996155013a3a043bed3", "patch": "@@ -1101,7 +1101,7 @@ maybe_noexcept_warning (tree fn)\n       && (!DECL_IN_SYSTEM_HEADER (fn)\n \t  || global_dc->dc_warn_system_headers))\n     {\n-      temp_override<bool> s (global_dc->dc_warn_system_headers, true);\n+      auto s = make_temp_override (global_dc->dc_warn_system_headers, true);\n       auto_diagnostic_group d;\n       if (warning (OPT_Wnoexcept, \"noexcept-expression evaluates to %<false%> \"\n \t\t   \"because of a call to %qD\", fn))"}, {"sha": "7ea8c28830ea11f3fdcfb6f5cc64213e296a77e7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf63c94df4712569e0ab996155013a3a043bed3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3cf63c94df4712569e0ab996155013a3a043bed3", "patch": "@@ -19732,7 +19732,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n   bool is_unnamed = false;\n   tree underlying_type = NULL_TREE;\n   cp_token *type_start_token = NULL;\n-  temp_override<bool> cleanup (parser->colon_corrects_to_scope_p, false);\n+  auto cleanup = make_temp_override (parser->colon_corrects_to_scope_p, false);\n \n   /* Parse tentatively so that we can back up if we don't find a\n      enum-specifier.  */\n@@ -23381,7 +23381,7 @@ cp_parser_parameter_declaration_clause (cp_parser* parser,\n   cp_token *token;\n   bool ellipsis_p;\n \n-  temp_override<bool> cleanup\n+  auto cleanup = make_temp_override\n     (parser->auto_is_implicit_function_template_parm_p);\n \n   if (!processing_specialization\n@@ -27488,7 +27488,7 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)\n {\n   tree attributes = NULL_TREE;\n \n-  temp_override<bool> cleanup\n+  auto cleanup = make_temp_override\n     (parser->auto_is_implicit_function_template_parm_p, false);\n \n   while (true)\n@@ -27688,7 +27688,7 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n   tree attribute, attr_id = NULL_TREE, arguments;\n   cp_token *token;\n \n-  temp_override<bool> cleanup\n+  auto cleanup = make_temp_override\n     (parser->auto_is_implicit_function_template_parm_p, false);\n \n   /* First, parse name of the attribute, a.k.a attribute-token.  */"}]}