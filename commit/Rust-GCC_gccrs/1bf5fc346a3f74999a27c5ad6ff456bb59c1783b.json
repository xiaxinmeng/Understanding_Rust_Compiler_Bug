{"sha": "1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJmNWZjMzQ2YTNmNzQ5OTlhMjdjNWFkNmZmNDU2YmI1OWMxNzgzYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-06-15T08:18:01Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-06-15T08:18:01Z"}, "message": "Make-lang.in: Reformat some long lines.\n\n\t* Make-lang.in: Reformat some long lines.\n\t(gt-cp-rtti.h): New target.\n\t(cp/rtti.o): Add dependency.\n\t* config-lang.in (gtfiles): Add cp/rtti.c.\n\t* cp-tree.h (CPTI_TI_DESC_TYPE, CPTI_BLTN_DESC_TYPE,\n\tCPTI_PTR_DESC_TYPE, CPTI_ARY_DESC_TYPE, CPTI_FUNC_DESC_TYPE,\n\tCPTI_ENUM_DESC_TYPE, CPTI_CLASS_DESC_TYPE,\n\tCPTI_SI_CLASS_DESC_TYPE, CPTI_VMI_CLASS_DESC_TYPE,\n\tCPTI_PTM_DESC_TYPE, CPTI_BASE_DESC_TYPE): Remove.\n\t(ti_desc_type_node, bltn_desc_type_node, ptr_desc_type_node,\n\tary_desc_type_node, func_desc_type_node, enum_desc_type_node,\n\tclass_desc_type_node, si_class_desc_type_node,\n\tvmi_class_desc_type_node, ptm_desc_type_node,\n\tbase_desc_type_node): Remove.\n\t* decl.c: Adjust documentation of global trees.\n\t* rtti.c (TINFO_PSEUDO_TYPE, TINFO_VTABLE_DECL,\n\tTINFO_REAL_NAME): Remove.\n\t(struct tinfo_s): New.\n\t(enum tinfo_kind): New.\n\t(tinfo_descs): New.\n\t(get_tinfo_decl): Adjust use of tinfo descriptor.\n\t(tinfo_base_init, generic_initializer, ptr_initializer,\n\tptm_initializer, class_initializer): Likewise.\n\t(get_pseudo_ti_init): Take descriptor index. Adjust.\n\t(create_pseudo_type_info): Likewise.\n\t(get_pseudo_ti_desc): Return descriptor index. Adjust.\n\t(create_tinfo_types): Adjust use of create_pseudo_type_info.\n\t(emit_tinfo_decl): Adjust use of tinfo descriptor.\n\nFrom-SVN: r100971", "tree": {"sha": "880eab48ebbaf66667a728e5b54574150141c300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/880eab48ebbaf66667a728e5b54574150141c300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/comments", "author": null, "committer": null, "parents": [{"sha": "8813ac2634a24b3c3a144b2f925033faf3c8e359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8813ac2634a24b3c3a144b2f925033faf3c8e359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8813ac2634a24b3c3a144b2f925033faf3c8e359"}], "stats": {"total": 599, "additions": 325, "deletions": 274}, "files": [{"sha": "44281fbf502d530c6797505a1eaabdc5e812a682", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "patch": "@@ -1,3 +1,34 @@\n+2005-06-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* Make-lang.in: Reformat some long lines.\n+\t(gt-cp-rtti.h): New target.\n+\t(cp/rtti.o): Add dependency.\n+\t* config-lang.in (gtfiles): Add cp/rtti.c.\n+\t* cp-tree.h (CPTI_TI_DESC_TYPE, CPTI_BLTN_DESC_TYPE,\n+\tCPTI_PTR_DESC_TYPE, CPTI_ARY_DESC_TYPE, CPTI_FUNC_DESC_TYPE,\n+\tCPTI_ENUM_DESC_TYPE, CPTI_CLASS_DESC_TYPE,\n+\tCPTI_SI_CLASS_DESC_TYPE, CPTI_VMI_CLASS_DESC_TYPE,\n+\tCPTI_PTM_DESC_TYPE, CPTI_BASE_DESC_TYPE): Remove.\n+\t(ti_desc_type_node, bltn_desc_type_node, ptr_desc_type_node,\n+\tary_desc_type_node, func_desc_type_node, enum_desc_type_node,\n+\tclass_desc_type_node, si_class_desc_type_node,\n+\tvmi_class_desc_type_node, ptm_desc_type_node,\n+\tbase_desc_type_node): Remove.\n+\t* decl.c: Adjust documentation of global trees.\n+\t* rtti.c (TINFO_PSEUDO_TYPE, TINFO_VTABLE_DECL,\n+\tTINFO_REAL_NAME): Remove.\n+\t(struct tinfo_s): New.\n+\t(enum tinfo_kind): New.\n+\t(tinfo_descs): New.\n+\t(get_tinfo_decl): Adjust use of tinfo descriptor.\n+\t(tinfo_base_init, generic_initializer, ptr_initializer,\n+\tptm_initializer, class_initializer): Likewise.\n+\t(get_pseudo_ti_init): Take descriptor index. Adjust.\n+\t(create_pseudo_type_info): Likewise.\n+\t(get_pseudo_ti_desc): Return descriptor index. Adjust.\n+\t(create_tinfo_types): Adjust use of create_pseudo_type_info.\n+\t(emit_tinfo_decl): Adjust use of tinfo descriptor.\n+\n 2005-06-14  Roger Sayle  <roger@eyesopen.com>\n \n \t* decl.c (grokdeclarator): Only check TREE_OVERFLOW on INTEGER_CST."}, {"sha": "e1664dcc28105093a76362a15d871dd182919b3d", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "patch": "@@ -112,6 +112,7 @@ $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf\n gtype-cp.h gt-cp-call.h gt-cp-decl.h gt-cp-decl2.h : s-gtype; @true\n gt-cp-pt.h gt-cp-repo.h gt-cp-parser.h gt-cp-method.h : s-gtype; @true\n gt-cp-tree.h gt-cp-mangle.h gt-cp-name-lookup.h gt-cp-typeck2.h: s-gtype; @true\n+gt-cp-rtti.h: s-gtype ; @true\n \n #\f\n # Build hooks:\n@@ -235,42 +236,45 @@ CXX_PRETTY_PRINT_H = cp/cxx-pretty-print.h $(C_PRETTY_PRINT_H)\n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h \\\n   c-pragma.h toplev.h output.h input.h cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h \\\n-  $(LANGHOOKS_DEF_H) c-common.h gtype-cp.h $(CXX_PRETTY_PRINT_H) $(DIAGNOSTIC_H) \\\n-  cp/cp-objcp-common.h\n+  $(LANGHOOKS_DEF_H) c-common.h gtype-cp.h $(CXX_PRETTY_PRINT_H) \\\n+  $(DIAGNOSTIC_H) cp/cp-objcp-common.h\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n   debug.h gt-cp-decl.h timevar.h $(TREE_FLOW_H)\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h cgraph.h \\\n   c-pragma.h\n-cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) $(TREE_H) $(CXX_TREE_H) c-common.h toplev.h langhooks.h \\\n+cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) c-common.h toplev.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h $(CXX_PRETTY_PRINT_H) \\\n   cp/cp-objcp-common.h\n-cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n-   diagnostic.h gt-cp-typeck2.h\n-cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n-   diagnostic.h convert.h c-common.h\n-cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(TARGET_H) \\\n-   convert.h $(CGRAPH_H)\n-cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(EXPR_H) \\\n-     diagnostic.h intl.h gt-cp-call.h convert.h target.h\n-cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) toplev.h $(EXPR_H)\n-cp/init.o: cp/init.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n-  except.h $(TARGET_H)\n+cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h \\\n+  $(TM_P_H) diagnostic.h gt-cp-typeck2.h\n+cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) \\\n+  toplev.h diagnostic.h convert.h c-common.h\n+cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n+  $(TARGET_H) convert.h $(CGRAPH_H)\n+cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n+  $(EXPR_H) diagnostic.h intl.h gt-cp-call.h convert.h target.h\n+cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) toplev.h \\\n+  $(EXPR_H)\n+cp/init.o: cp/init.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) \\\n+  toplev.h except.h $(TARGET_H)\n cp/method.o: cp/method.c $(CXX_TREE_H) $(TM_H) toplev.h $(RTL_H) $(EXPR_H) \\\n   $(TM_P_H) $(TARGET_H) diagnostic.h gt-cp-method.h\n cp/cvt.o: cp/cvt.c $(CXX_TREE_H) $(TM_H) cp/decl.h flags.h toplev.h convert.h\n cp/search.o: cp/search.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H)\n cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n-  insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h $(TARGET_H) debug.h\n+  insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h $(TARGET_H) \\\n+  debug.h\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n-cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h convert.h\n-cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h toplev.h \\\n-  cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n-cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n-  except.h $(TM_P_H)\n+cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h convert.h \\\n+  gt-cp-rtti.h\n+cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h \\\n+  toplev.h cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n+cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) \\\n+  toplev.h except.h $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\\n   toplev.h $(RTL_H) except.h tree-inline.h pointer-set.h gt-cp-pt.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h $(DIAGNOSTIC_H) \\\n@@ -281,11 +285,11 @@ cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) except.h toplev.h \\\n   flags.h debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n   tree-inline.h cgraph.h $(TARGET_H) c-common.h\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) tree-dump.h\n-cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h integrate.h insn-config.h \\\n-  input.h $(PARAMS_H) debug.h tree-inline.h tree-gimple.h $(TARGET_H)\n+cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h integrate.h \\\n+  insn-config.h input.h $(PARAMS_H) debug.h tree-inline.h tree-gimple.h \\\n+  $(TARGET_H)\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h real.h gt-cp-mangle.h \\\n   $(TARGET_H) $(TM_P_H)\n-\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) diagnostic.h gt-cp-parser.h \\\n   output.h\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) toplev.h c-common.h \\"}, {"sha": "5614ca4b7bb254134dd349a317a8159d2cd50323", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3\"\n \n-gtfiles=\"\\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c \\$(srcdir)/cp/class.c\"\n+gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c \\$(srcdir)/cp/class.c\""}, {"sha": "ef67f6b61b2b7f2c5d6398d5c5bbe128a06efa9c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "patch": "@@ -483,18 +483,6 @@ enum cp_tree_index\n     CPTI_CLEANUP_TYPE,\n     CPTI_VTT_PARM_TYPE,\n \n-    CPTI_TI_DESC_TYPE,\n-    CPTI_BLTN_DESC_TYPE,\n-    CPTI_PTR_DESC_TYPE,\n-    CPTI_ARY_DESC_TYPE,\n-    CPTI_FUNC_DESC_TYPE,\n-    CPTI_ENUM_DESC_TYPE,\n-    CPTI_CLASS_DESC_TYPE,\n-    CPTI_SI_CLASS_DESC_TYPE,\n-    CPTI_VMI_CLASS_DESC_TYPE,\n-    CPTI_PTM_DESC_TYPE,\n-    CPTI_BASE_DESC_TYPE,\n-\n     CPTI_CLASS_TYPE,\n     CPTI_UNKNOWN_TYPE,\n     CPTI_VTBL_TYPE,\n@@ -559,18 +547,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* The type used to represent an index into the vtable.  */\n #define vtable_index_type\t\tcp_global_trees[CPTI_VTABLE_INDEX_TYPE]\n \n-#define ti_desc_type_node\t\tcp_global_trees[CPTI_TI_DESC_TYPE]\n-#define bltn_desc_type_node\t\tcp_global_trees[CPTI_BLTN_DESC_TYPE]\n-#define ptr_desc_type_node\t\tcp_global_trees[CPTI_PTR_DESC_TYPE]\n-#define ary_desc_type_node\t\tcp_global_trees[CPTI_ARY_DESC_TYPE]\n-#define func_desc_type_node\t\tcp_global_trees[CPTI_FUNC_DESC_TYPE]\n-#define enum_desc_type_node\t\tcp_global_trees[CPTI_ENUM_DESC_TYPE]\n-#define class_desc_type_node\t\tcp_global_trees[CPTI_CLASS_DESC_TYPE]\n-#define si_class_desc_type_node\t\tcp_global_trees[CPTI_SI_CLASS_DESC_TYPE]\n-#define vmi_class_desc_type_node\tcp_global_trees[CPTI_VMI_CLASS_DESC_TYPE]\n-#define ptm_desc_type_node\t\tcp_global_trees[CPTI_PTM_DESC_TYPE]\n-#define base_desc_type_node\t\tcp_global_trees[CPTI_BASE_DESC_TYPE]\n-\n #define class_type_node\t\t\tcp_global_trees[CPTI_CLASS_TYPE]\n #define unknown_type_node\t\tcp_global_trees[CPTI_UNKNOWN_TYPE]\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]"}, {"sha": "3edb40a301eeabd5f4224d39d2cd71ef6d8edb45", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "patch": "@@ -128,12 +128,6 @@ tree error_mark_list;\n \ttree vtable_entry_type;\n \ttree delta_type_node;\n \ttree __t_desc_type_node;\n-\ttree ti_desc_type_node;\n-\ttree bltn_desc_type_node, ptr_desc_type_node;\n-\ttree ary_desc_type_node, func_desc_type_node, enum_desc_type_node;\n-\ttree class_desc_type_node, si_class_desc_type_node, vmi_class_desc_type_node;\n-\ttree ptm_desc_type_node;\n-\ttree base_desc_type_node;\n \n \ttree class_type_node;\n \ttree unknown_type_node;"}, {"sha": "317068e5c6e78785cc00d649b3f797ea6fddb031", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 265, "deletions": 219, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf5fc346a3f74999a27c5ad6ff456bb59c1783b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=1bf5fc346a3f74999a27c5ad6ff456bb59c1783b", "patch": "@@ -62,21 +62,45 @@ Boston, MA 02111-1307, USA.  */\n    corresponding to type_info.  That will only happen at the end of\n    translation, when we are emitting the type info objects.  */\n \n-/* Accessors for the type_info objects. We need to remember several things\n-   about each of the type_info types. The global tree nodes such as\n-   bltn_desc_type_node are TREE_LISTs, and these macros are used to access\n-   the required information.  */\n-/* The RECORD_TYPE of a type_info derived class.  */\n-#define TINFO_PSEUDO_TYPE(NODE) TREE_TYPE (NODE)\n-/* The VAR_DECL of the vtable for the type_info derived class.\n-   This is only filled in at the end of the translation.  */\n-#define TINFO_VTABLE_DECL(NODE) TREE_VALUE (NODE)\n-/* The IDENTIFIER_NODE naming the real class.  */\n-#define TINFO_REAL_NAME(NODE) TREE_PURPOSE (NODE)\n+/* Auxiliary data we hold for each type_info derived object we need.  */\n+typedef struct tinfo_s GTY (())\n+{\n+  tree type;  /* The RECORD_TYPE for this type_info object */\n+\n+  tree vtable; /* The VAR_DECL of the vtable.  Only filled at end of\n+\t\t  translation.  */\n+\n+  tree name;  /* IDENTIFIER_NODE for the ABI specified name of\n+\t\t the type_info derived type.  */\n+} tinfo_s;\n+\n+DEF_VEC_O(tinfo_s);\n+DEF_VEC_ALLOC_O(tinfo_s,gc);\n+\n+typedef enum tinfo_kind\n+{\n+  TK_TYPE_INFO_TYPE,    /* std::type_info */\n+  TK_BASE_TYPE,\t\t/* abi::__base_class_type_info */\n+  TK_BUILTIN_TYPE,\t/* abi::__fundamental_type_info */\n+  TK_ARRAY_TYPE,\t/* abi::__array_type_info */\n+  TK_FUNCTION_TYPE,\t/* abi::__function_type_info */\n+  TK_ENUMERAL_TYPE,\t/* abi::__enum_type_info */\n+  TK_POINTER_TYPE,\t/* abi::__pointer_type_info */\n+  TK_POINTER_MEMBER_TYPE, /* abi::__pointer_to_member_type_info */\n+  TK_CLASS_TYPE,\t/* abi::__class_type_info */\n+  TK_SI_CLASS_TYPE,\t/* abi::__si_class_type_info */\n+  TK_FIXED   \t\t/* end of fixed descriptors. */\n+  /* ... \t\t   abi::__vmi_type_info<I> */\n+} tinfo_kind;\n \n /* A vector of all tinfo decls that haven't yet been emitted.  */\n VEC(tree,gc) *unemitted_tinfo_decls;\n \n+/* A vector of all type_info derived types we need.  The first few are\n+   fixed and created early. The remainder are for multiple inheritance\n+   and are generated as needed. */\n+static GTY (()) VEC(tinfo_s,gc) *tinfo_descs;\n+\n static tree build_headof (tree);\n static tree ifnonnull (tree, tree);\n static tree tinfo_name (tree);\n@@ -88,12 +112,14 @@ static tree get_tinfo_ptr (tree);\n static bool typeid_ok_p (void);\n static int qualifier_flags (tree);\n static bool target_incomplete_p (tree);\n-static tree tinfo_base_init (tree, tree);\n-static tree generic_initializer (tree, tree);\n-static tree class_initializer (tree, tree, tree);\n-static tree create_pseudo_type_info (const char *, int, ...);\n-static tree get_pseudo_ti_init (tree, tree);\n-static tree get_pseudo_ti_desc (tree);\n+static tree tinfo_base_init (tinfo_s *, tree);\n+static tree generic_initializer (tinfo_s *, tree);\n+static tree ptr_initializer (tinfo_s *, tree);\n+static tree ptm_initializer (tinfo_s *, tree);\n+static tree class_initializer (tinfo_s *, tree, tree);\n+static void create_pseudo_type_info (tinfo_kind, const char *, ...);\n+static tree get_pseudo_ti_init (tree, unsigned);\n+static unsigned get_pseudo_ti_index (tree);\n static void create_tinfo_types (void);\n static bool typeinfo_in_lib_p (tree);\n \n@@ -343,9 +369,10 @@ get_tinfo_decl (tree type)\n   d = IDENTIFIER_GLOBAL_VALUE (name);\n   if (!d)\n     {\n-      tree var_desc = get_pseudo_ti_desc (type);\n+      tinfo_s *ti = VEC_index (tinfo_s, tinfo_descs,\n+\t\t\t       get_pseudo_ti_index (type));\n \n-      d = build_lang_decl (VAR_DECL, name, TINFO_PSEUDO_TYPE (var_desc));\n+      d = build_lang_decl (VAR_DECL, name, ti->type);\n       SET_DECL_ASSEMBLER_NAME (d, name);\n       /* Remember the type it is for.  */\n       TREE_TYPE (name) = type;\n@@ -758,7 +785,7 @@ involves_incomplete_p (tree type)\n    as comdat, because of pointers to incomplete.) */\n \n static tree\n-tinfo_base_init (tree desc, tree target)\n+tinfo_base_init (tinfo_s *ti, tree target)\n {\n   tree init = NULL_TREE;\n   tree name_decl;\n@@ -799,13 +826,12 @@ tinfo_base_init (tree desc, tree target)\n     pushdecl_top_level_and_finish (name_decl, name_string);\n   }\n \n-  vtable_ptr = TINFO_VTABLE_DECL (desc);\n+  vtable_ptr = ti->vtable;\n   if (!vtable_ptr)\n     {\n       tree real_type;\n-\n       push_nested_namespace (abi_node);\n-      real_type = xref_tag (class_type, TINFO_REAL_NAME (desc),\n+      real_type = xref_tag (class_type, ti->name,\n \t\t\t    /*tag_scope=*/ts_current, false);\n       pop_nested_namespace (abi_node);\n \n@@ -827,8 +853,8 @@ tinfo_base_init (tree desc, tree target)\n \t size_binop (MULT_EXPR,\n \t\t     size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),\n \t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n-\n-      TINFO_VTABLE_DECL (desc) = vtable_ptr;\n+      \n+      ti->vtable = vtable_ptr;\n     }\n \n   init = tree_cons (NULL_TREE, vtable_ptr, init);\n@@ -844,15 +870,15 @@ tinfo_base_init (tree desc, tree target)\n   return init;\n }\n \n-/* Return the CONSTRUCTOR expr for a type_info of TYPE. DESC provides the\n+/* Return the CONSTRUCTOR expr for a type_info of TYPE. TI provides the\n    information about the particular type_info derivation, which adds no\n    additional fields to the type_info base.  */\n \n static tree\n-generic_initializer (tree desc, tree target)\n+generic_initializer (tinfo_s *ti, tree target)\n {\n-  tree init = tinfo_base_init (desc, target);\n-\n+  tree init = tinfo_base_init (ti, target);\n+  \n   init = build_constructor (NULL_TREE, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n@@ -861,13 +887,13 @@ generic_initializer (tree desc, tree target)\n }\n \n /* Return the CONSTRUCTOR expr for a type_info of pointer TYPE.\n-   DESC provides information about the particular type_info derivation,\n+   TI provides information about the particular type_info derivation,\n    which adds target type and qualifier flags members to the type_info base.  */\n \n static tree\n-ptr_initializer (tree desc, tree target)\n+ptr_initializer (tinfo_s *ti, tree target)\n {\n-  tree init = tinfo_base_init (desc, target);\n+  tree init = tinfo_base_init (ti, target);\n   tree to = TREE_TYPE (target);\n   int flags = qualifier_flags (to);\n   bool incomplete = target_incomplete_p (to);\n@@ -887,14 +913,14 @@ ptr_initializer (tree desc, tree target)\n }\n \n /* Return the CONSTRUCTOR expr for a type_info of pointer to member data TYPE.\n-   DESC provides information about the particular type_info derivation,\n+   TI provides information about the particular type_info derivation,\n    which adds class, target type and qualifier flags members to the type_info\n    base.  */\n \n static tree\n-ptm_initializer (tree desc, tree target)\n+ptm_initializer (tinfo_s *ti, tree target)\n {\n-  tree init = tinfo_base_init (desc, target);\n+  tree init = tinfo_base_init (ti, target);\n   tree to = TYPE_PTRMEM_POINTED_TO_TYPE (target);\n   tree klass = TYPE_PTRMEM_CLASS_TYPE (target);\n   int flags = qualifier_flags (to);\n@@ -920,13 +946,13 @@ ptm_initializer (tree desc, tree target)\n }\n \n /* Return the CONSTRUCTOR expr for a type_info of class TYPE.\n-   DESC provides information about the particular __class_type_info derivation,\n+   TI provides information about the particular __class_type_info derivation,\n    which adds hint flags and TRAIL initializers to the type_info base.  */\n \n static tree\n-class_initializer (tree desc, tree target, tree trail)\n+class_initializer (tinfo_s *ti, tree target, tree trail)\n {\n-  tree init = tinfo_base_init (desc, target);\n+  tree init = tinfo_base_init (ti, target);\n \n   TREE_CHAIN (init) = trail;\n   init = build_constructor (NULL_TREE, init);\n@@ -963,101 +989,98 @@ typeinfo_in_lib_p (tree type)\n     }\n }\n \n-/* Generate the initializer for the type info describing TYPE.  */\n+/* Generate the initializer for the type info describing TYPE.  TK_INDEX is\n+   the index of the descriptor in the tinfo_desc vector. */\n \n static tree\n-get_pseudo_ti_init (tree type, tree var_desc)\n+get_pseudo_ti_init (tree type, unsigned tk_index)\n {\n+  tinfo_s *ti = VEC_index (tinfo_s, tinfo_descs, tk_index);\n+  \n   gcc_assert (at_eof);\n-  switch (TREE_CODE (type))\n+  switch (tk_index)\n     {\n-    case OFFSET_TYPE:\n-      return ptm_initializer (var_desc, type);\n-    case POINTER_TYPE:\n-      return ptr_initializer (var_desc, type);\n-    case ENUMERAL_TYPE:\n-      return generic_initializer (var_desc, type);\n-      break;\n-    case FUNCTION_TYPE:\n-      return generic_initializer (var_desc, type);\n-      break;\n-    case ARRAY_TYPE:\n-      return generic_initializer (var_desc, type);\n-      break;\n-    case UNION_TYPE:\n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (type))\n-\treturn ptm_initializer (var_desc, type);\n-      else if (var_desc == class_desc_type_node)\n-\treturn class_initializer (var_desc, type, NULL_TREE);\n-      else if (var_desc == si_class_desc_type_node)\n-\t{\n-\t  tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n-\t  tree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n-\t  tree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n-\n-\t  return class_initializer (var_desc, type, base_inits);\n-\t}\n-      else\n-\t{\n-\t  int hint = ((CLASSTYPE_REPEATED_BASE_P (type) << 0)\n-\t\t      | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n-\t  tree binfo = TYPE_BINFO (type);\n-\t  int nbases = BINFO_N_BASE_BINFOS (binfo);\n-\t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n-\t  tree base_inits = NULL_TREE;\n-\t  int ix;\n-\n-\t  /* Generate the base information initializer.  */\n-\t  for (ix = nbases; ix--;)\n-\t    {\n-\t      tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n-\t      tree base_init = NULL_TREE;\n-\t      int flags = 0;\n-\t      tree tinfo;\n-\t      tree offset;\n-\n-\t      if (VEC_index (tree, base_accesses, ix) == access_public_node)\n-\t\tflags |= 2;\n-\t      tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n-\t      if (BINFO_VIRTUAL_P (base_binfo))\n-\t\t{\n-\t\t   /* We store the vtable offset at which the virtual\n-\t\t      base offset can be found.  */\n-\t\t  offset = BINFO_VPTR_FIELD (base_binfo);\n-\t\t  offset = convert (sizetype, offset);\n-\t\t  flags |= 1;\n-\t\t}\n-\t      else\n-\t\toffset = BINFO_OFFSET (base_binfo);\n-\n-\t      /* Combine offset and flags into one field.  */\n-\t      offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n-\t\t\t\t\t   build_int_cst (NULL_TREE, 8));\n-\t      offset = cp_build_binary_op (BIT_IOR_EXPR, offset,\n-\t\t\t\t\t   build_int_cst (NULL_TREE, flags));\n-\t      base_init = tree_cons (NULL_TREE, offset, base_init);\n-\t      base_init = tree_cons (NULL_TREE, tinfo, base_init);\n-\t      base_init = build_constructor (NULL_TREE, base_init);\n-\t      base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n-\t    }\n-\t  base_inits = build_constructor (NULL_TREE, base_inits);\n-\t  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n-\t  /* Prepend the number of bases.  */\n-\t  base_inits = tree_cons (NULL_TREE,\n-\t\t\t\t  build_int_cst (NULL_TREE, nbases),\n-\t\t\t\t  base_inits);\n-\t  /* Prepend the hint flags.  */\n-\t  base_inits = tree_cons (NULL_TREE,\n-\t\t\t\t  build_int_cst (NULL_TREE, hint),\n-\t\t\t\t  base_inits);\n-\n-\t  return class_initializer (var_desc, type, base_inits);\n-\t}\n-      break;\n+    case TK_POINTER_MEMBER_TYPE:\n+      return ptm_initializer (ti, type);\n+      \n+    case TK_POINTER_TYPE:\n+      return ptr_initializer (ti, type);\n+      \n+    case TK_BUILTIN_TYPE:\n+    case TK_ENUMERAL_TYPE:\n+    case TK_FUNCTION_TYPE:\n+    case TK_ARRAY_TYPE:\n+      return generic_initializer (ti, type);\n+\n+    case TK_CLASS_TYPE:\n+      return class_initializer (ti, type, NULL_TREE);\n+\n+    case TK_SI_CLASS_TYPE:\n+      {\n+\ttree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n+\ttree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n+\ttree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n+\t\n+\treturn class_initializer (ti, type, base_inits);\n+      }\n \n     default:\n-      return generic_initializer (var_desc, type);\n+      {\n+\tint hint = ((CLASSTYPE_REPEATED_BASE_P (type) << 0)\n+\t\t    | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n+\ttree binfo = TYPE_BINFO (type);\n+\tint nbases = BINFO_N_BASE_BINFOS (binfo);\n+\tVEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n+\ttree base_inits = NULL_TREE;\n+\tint ix;\n+          \n+\tgcc_assert (tk_index >= TK_FIXED);\n+      \n+\t/* Generate the base information initializer.  */\n+\tfor (ix = nbases; ix--;)\n+\t  {\n+\t    tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n+\t    tree base_init = NULL_TREE;\n+\t    int flags = 0;\n+\t    tree tinfo;\n+\t    tree offset;\n+\t    \n+\t    if (VEC_index (tree, base_accesses, ix) == access_public_node)\n+\t      flags |= 2;\n+\t    tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n+\t    if (BINFO_VIRTUAL_P (base_binfo))\n+\t      {\n+\t\t/* We store the vtable offset at which the virtual\n+       \t\t   base offset can be found.  */\n+\t\toffset = BINFO_VPTR_FIELD (base_binfo);\n+\t\toffset = convert (sizetype, offset);\n+\t\tflags |= 1;\n+\t      }\n+\t    else\n+\t      offset = BINFO_OFFSET (base_binfo);\n+\t    \n+\t    /* Combine offset and flags into one field.  */\n+\t    offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n+\t\t\t\t\t build_int_cst (NULL_TREE, 8));\n+\t    offset = cp_build_binary_op (BIT_IOR_EXPR, offset,\n+\t\t\t\t\t build_int_cst (NULL_TREE, flags));\n+\t    base_init = tree_cons (NULL_TREE, offset, base_init);\n+\t    base_init = tree_cons (NULL_TREE, tinfo, base_init);\n+\t    base_init = build_constructor (NULL_TREE, base_init);\n+\t    base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n+\t  }\n+\tbase_inits = build_constructor (NULL_TREE, base_inits);\n+\tbase_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n+\t/* Prepend the number of bases.  */\n+\tbase_inits = tree_cons (NULL_TREE,\n+\t\t\t\tbuild_int_cst (NULL_TREE, nbases),\n+\t\t\t\tbase_inits);\n+\t/* Prepend the hint flags.  */\n+\tbase_inits = tree_cons (NULL_TREE,\n+\t\t\t\tbuild_int_cst (NULL_TREE, hint),\n+\t\t\t\tbase_inits);\n+\treturn class_initializer (ti, type, base_inits);\n+      }\n     }\n }\n \n@@ -1076,27 +1099,29 @@ get_pseudo_ti_init (tree type, tree var_desc)\n    additional FIELD_DECL's for the structure. The final argument must be\n    NULL.  */\n \n-static tree\n-create_pseudo_type_info (const char *real_name, int ident, ...)\n+static void\n+create_pseudo_type_info (tinfo_kind tk, const char *real_name, ...)\n {\n+  tinfo_s *ti;\n   tree pseudo_type;\n   char *pseudo_name;\n   tree fields;\n   tree field_decl;\n-  tree result;\n   va_list ap;\n \n-  va_start (ap, ident);\n+  va_start (ap, real_name);\n \n   /* Generate the pseudo type name.  */\n   pseudo_name = alloca (strlen (real_name) + 30);\n   strcpy (pseudo_name, real_name);\n   strcat (pseudo_name, \"_pseudo\");\n-  if (ident)\n-    sprintf (pseudo_name + strlen (pseudo_name), \"%d\", ident);\n+  if (tk >= TK_FIXED)\n+    sprintf (pseudo_name + strlen (pseudo_name), \"%d\", tk - TK_FIXED);\n \n   /* First field is the pseudo type_info base class.  */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n+  fields = build_decl (FIELD_DECL, NULL_TREE,\n+\t\t       VEC_index (tinfo_s, tinfo_descs,\n+\t\t\t\t  TK_TYPE_INFO_TYPE)->type);\n \n   /* Now add the derived fields.  */\n   while ((field_decl = va_arg (ap, tree)))\n@@ -1110,46 +1135,64 @@ create_pseudo_type_info (const char *real_name, int ident, ...)\n   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n   CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n \n-  result = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n-  TINFO_REAL_NAME (result) = get_identifier (real_name);\n-  TINFO_PSEUDO_TYPE (result) =\n-    cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n+  ti = VEC_index (tinfo_s, tinfo_descs, tk);\n+  ti->type = cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n+  ti->name = get_identifier (real_name);\n+  ti->vtable = NULL_TREE;\n \n   va_end (ap);\n-  return result;\n }\n \n-/* Return a pseudo type info type node used to describe TYPE.  TYPE\n-   must be a complete type (or cv void), except at the end of the\n-   translation unit.  */\n+/* Return the index of a pseudo type info type node used to describe\n+   TYPE.  TYPE must be a complete type (or cv void), except at the end\n+   of the translation unit.  */\n \n-static tree\n-get_pseudo_ti_desc (tree type)\n+static unsigned\n+get_pseudo_ti_index (tree type)\n {\n+  unsigned ix;\n+  \n   switch (TREE_CODE (type))\n     {\n     case OFFSET_TYPE:\n-      return ptm_desc_type_node;\n+      ix = TK_POINTER_MEMBER_TYPE;\n+      break;\n+      \n     case POINTER_TYPE:\n-      return ptr_desc_type_node;\n+      ix = TK_POINTER_TYPE;\n+      break;\n+      \n     case ENUMERAL_TYPE:\n-      return enum_desc_type_node;\n+      ix = TK_ENUMERAL_TYPE;\n+      break;\n+      \n     case FUNCTION_TYPE:\n-      return func_desc_type_node;\n+      ix = TK_FUNCTION_TYPE;\n+      break;\n+      \n     case ARRAY_TYPE:\n-      return ary_desc_type_node;\n+      ix = TK_ARRAY_TYPE;\n+      break;\n+      \n     case UNION_TYPE:\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n-\treturn ptm_desc_type_node;\n+\t{\n+\t  ix = TK_POINTER_MEMBER_TYPE;\n+\t  break;\n+\t}\n       else if (!COMPLETE_TYPE_P (type))\n \t{\n \t  if (!at_eof)\n \t    cxx_incomplete_type_error (NULL_TREE, type);\n-\t  return class_desc_type_node;\n+\t  ix = TK_CLASS_TYPE;\n+\t  break;\n \t}\n       else if (!BINFO_N_BASE_BINFOS (TYPE_BINFO (type)))\n-\treturn class_desc_type_node;\n+\t{\n+\t  ix = TK_CLASS_TYPE;\n+\t  break;\n+\t}\n       else\n \t{\n \t  tree binfo = TYPE_BINFO (type);\n@@ -1161,26 +1204,29 @@ get_pseudo_ti_desc (tree type)\n \t      && VEC_index (tree, base_accesses, 0) == access_public_node\n \t      && !BINFO_VIRTUAL_P (base_binfo)\n \t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n-\t    /* single non-virtual public.  */\n-\t    return si_class_desc_type_node;\n+\t    {\n+\t      /* single non-virtual public.  */\n+\t      ix = TK_SI_CLASS_TYPE;\n+\t      break;\n+\t    }\n \t  else\n \t    {\n-\t      tree var_desc;\n+\t      tinfo_s *ti;\n \t      tree array_domain, base_array;\n \n-\t      if (TREE_VEC_LENGTH (vmi_class_desc_type_node) <= num_bases)\n+\t      ix = TK_FIXED + num_bases;\n+\t      if (VEC_length (tinfo_s, tinfo_descs) <= ix)\n \t\t{\n-\t\t  int ix;\n-\t\t  tree extend = make_tree_vec (num_bases + 5);\n-\n-\t\t  for (ix = TREE_VEC_LENGTH (vmi_class_desc_type_node); ix--;)\n-\t\t    TREE_VEC_ELT (extend, ix)\n-\t\t      = TREE_VEC_ELT (vmi_class_desc_type_node, ix);\n-\t\t  vmi_class_desc_type_node = extend;\n+\t\t  /* too short, extend.  */\n+\t\t  unsigned len = VEC_length (tinfo_s, tinfo_descs);\n+\t\t  \n+\t\t  VEC_safe_grow (tinfo_s, gc, tinfo_descs, ix + 1);\n+\t\t  while (VEC_iterate (tinfo_s, tinfo_descs, len++, ti))\n+\t\t    ti->type = ti->vtable = ti->name = NULL_TREE;\n \t\t}\n-\t      var_desc = TREE_VEC_ELT (vmi_class_desc_type_node, num_bases);\n-\t      if (var_desc)\n-\t\treturn var_desc;\n+\t      else if (VEC_index (tinfo_s, tinfo_descs, ix)->type)\n+\t\t/* already created.  */\n+\t\tbreak;\n \n \t      /* Create the array of __base_class_type_info entries.\n \t\t G++ 3.2 allocated an array that had one too many\n@@ -1191,24 +1237,26 @@ get_pseudo_ti_desc (tree type)\n \t      else\n \t\tarray_domain = build_index_type (size_int (num_bases));\n \t      base_array =\n-\t\tbuild_array_type (base_desc_type_node, array_domain);\n+\t\tbuild_array_type (VEC_index (tinfo_s, tinfo_descs,\n+\t\t\t\t\t     TK_BASE_TYPE)->type,\n+\t\t\t\t  array_domain);\n \n \t      push_nested_namespace (abi_node);\n-\t      var_desc = create_pseudo_type_info\n-\t\t(\"__vmi_class_type_info\", num_bases,\n+\t      create_pseudo_type_info\n+\t\t(ix, \"__vmi_class_type_info\",\n \t\t build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n \t\t build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n \t\t build_decl (FIELD_DECL, NULL_TREE, base_array),\n \t\t NULL);\n \t      pop_nested_namespace (abi_node);\n-\n-\t      TREE_VEC_ELT (vmi_class_desc_type_node, num_bases) = var_desc;\n-\t      return var_desc;\n+\t      break;\n \t    }\n \t}\n     default:\n-      return bltn_desc_type_node;\n+      ix = TK_BUILTIN_TYPE;\n+      break;\n     }\n+  return ix;\n }\n \n /* Make sure the required builtin types exist for generating the type_info\n@@ -1217,55 +1265,51 @@ get_pseudo_ti_desc (tree type)\n static void\n create_tinfo_types (void)\n {\n-  gcc_assert (!ti_desc_type_node);\n+  tinfo_s *ti;\n+  \n+  gcc_assert (!tinfo_descs);\n \n+  VEC_safe_grow (tinfo_s, gc, tinfo_descs, TK_FIXED);\n+  \n   push_nested_namespace (abi_node);\n \n   /* Create the internal type_info structure. This is used as a base for\n      the other structures.  */\n   {\n     tree field, fields;\n \n-    ti_desc_type_node = make_aggr_type (RECORD_TYPE);\n     field = build_decl (FIELD_DECL, NULL_TREE, const_ptr_type_node);\n     fields = field;\n \n     field = build_decl (FIELD_DECL, NULL_TREE, const_string_type_node);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n \n-    finish_builtin_struct (ti_desc_type_node, \"__type_info_pseudo\",\n+    ti = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE);\n+    ti->type = make_aggr_type (RECORD_TYPE);\n+    ti->vtable = NULL_TREE;\n+    ti->name = NULL_TREE;\n+    finish_builtin_struct (ti->type, \"__type_info_pseudo\",\n \t\t\t   fields, NULL_TREE);\n-    TYPE_HAS_CONSTRUCTOR (ti_desc_type_node) = 1;\n+    TYPE_HAS_CONSTRUCTOR (ti->type) = 1;\n   }\n \n   /* Fundamental type_info */\n-  bltn_desc_type_node = create_pseudo_type_info\n-      (\"__fundamental_type_info\", 0,\n-       NULL);\n+  create_pseudo_type_info (TK_BUILTIN_TYPE, \"__fundamental_type_info\", NULL);\n \n   /* Array, function and enum type_info. No additional fields.  */\n-  ary_desc_type_node = create_pseudo_type_info\n-      (\"__array_type_info\", 0,\n-       NULL);\n-  func_desc_type_node = create_pseudo_type_info\n-       (\"__function_type_info\", 0,\n-\tNULL);\n-  enum_desc_type_node = create_pseudo_type_info\n-       (\"__enum_type_info\", 0,\n-\tNULL);\n-\n-  /* Class type_info. Add a flags field.  */\n-  class_desc_type_node = create_pseudo_type_info\n-\t(\"__class_type_info\", 0,\n-\t NULL);\n-\n-  /* Single public non-virtual base class. Add pointer to base class.\n+  create_pseudo_type_info (TK_ARRAY_TYPE, \"__array_type_info\", NULL);\n+  create_pseudo_type_info (TK_FUNCTION_TYPE, \"__function_type_info\", NULL);\n+  create_pseudo_type_info (TK_ENUMERAL_TYPE, \"__enum_type_info\", NULL);\n+  \n+  /* Class type_info.  No additional fields.  */\n+  create_pseudo_type_info (TK_CLASS_TYPE, \"__class_type_info\", NULL);\n+  \n+  /* Single public non-virtual base class. Add pointer to base class. \n      This is really a descendant of __class_type_info.  */\n-  si_class_desc_type_node = create_pseudo_type_info\n-\t   (\"__si_class_type_info\", 0,\n-\t    build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\t    NULL);\n+  create_pseudo_type_info (TK_SI_CLASS_TYPE, \"__si_class_type_info\",\n+            build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+            NULL);\n \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags.  */\n@@ -1278,34 +1322,34 @@ create_tinfo_types (void)\n     field = build_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n-\n-    base_desc_type_node = make_aggr_type (RECORD_TYPE);\n-    finish_builtin_struct (base_desc_type_node, \"__base_class_type_info_pseudo\",\n+  \n+    ti = VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);\n+    \n+    ti->type = make_aggr_type (RECORD_TYPE);\n+    ti->vtable = NULL_TREE;\n+    ti->name = NULL_TREE;\n+    finish_builtin_struct (ti->type, \"__base_class_type_info_pseudo\",\n \t\t\t   fields, NULL_TREE);\n-    TYPE_HAS_CONSTRUCTOR (base_desc_type_node) = 1;\n+    TYPE_HAS_CONSTRUCTOR (ti->type) = 1;\n   }\n \n-  /* General hierarchy is created as necessary in this vector.  */\n-  vmi_class_desc_type_node = make_tree_vec (10);\n-\n   /* Pointer type_info. Adds two fields, qualification mask\n      and pointer to the pointed to type.  This is really a descendant of\n      __pbase_type_info.  */\n-  ptr_desc_type_node = create_pseudo_type_info\n-      (\"__pointer_type_info\", 0,\n+  create_pseudo_type_info (TK_POINTER_TYPE, \"__pointer_type_info\",\n        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n        NULL);\n \n   /* Pointer to member data type_info.  Add qualifications flags,\n      pointer to the member's type info and pointer to the class.\n      This is really a descendant of __pbase_type_info.  */\n-  ptm_desc_type_node = create_pseudo_type_info\n-       (\"__pointer_to_member_type_info\", 0,\n-\tbuild_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\tNULL);\n+  create_pseudo_type_info (TK_POINTER_MEMBER_TYPE,\n+       \"__pointer_to_member_type_info\",\n+        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+        NULL);\n \n   pop_nested_namespace (abi_node);\n }\n@@ -1389,7 +1433,6 @@ emit_tinfo_decl (tree decl)\n {\n   tree type = TREE_TYPE (DECL_NAME (decl));\n   int in_library = typeinfo_in_lib_p (type);\n-  tree var_desc, var_init;\n \n   gcc_assert (DECL_TINFO_P (decl));\n \n@@ -1422,14 +1465,17 @@ emit_tinfo_decl (tree decl)\n   import_export_decl (decl);\n   if (DECL_NOT_REALLY_EXTERN (decl) && decl_needed_p (decl))\n     {\n+      tree init;\n+      \n       DECL_EXTERNAL (decl) = 0;\n-      var_desc = get_pseudo_ti_desc (type);\n-      var_init = get_pseudo_ti_init (type, var_desc);\n-      DECL_INITIAL (decl) = var_init;\n+      init = get_pseudo_ti_init (type, get_pseudo_ti_index (type));\n+      DECL_INITIAL (decl) = init;\n       mark_used (decl);\n-      cp_finish_decl (decl, var_init, NULL_TREE, 0);\n+      cp_finish_decl (decl, init, NULL_TREE, 0);\n       return true;\n     }\n   else\n     return false;\n }\n+\n+#include \"gt-cp-rtti.h\""}]}