{"sha": "e7ab55938c4d392306c0a19cba3bda764b17cdd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhYjU1OTM4YzRkMzkyMzA2YzBhMTljYmEzYmRhNzY0YjE3Y2RkNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2010-10-21T13:46:52Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-10-21T13:46:52Z"}, "message": "mn10300.c: Fold code to 80-character width.\n\n        * config/mn10300/mn10300.c: Fold code to 80-character width.\n        Replace GET_CODE (foo) == REG with REG_P (foo).  Likewise for\n        MEM, CONST_INT and CONST_DOUBLE.\n        (targetm): Move initialization to end of file.\n        (print_operand): Rename to mn10300_print_operand.\n        (print_operand_address): Rename to mn10300_print_operand_address.\n        (can_use_return_insn): Rename to mn10300_can_use_return_insn.\n        (expand_prologue): Rename to mn10300_expand_prologue.\n        (expand_epilogue): Rename to mn10300_expand_epilogue.\n        (initial_offset): Rename to mn10300_initial_offset.\n        (function_arg): Rename to mn10300_function_arg.\n        (mask_ok_for_mem_btst): Rename to mn10300_mask_ok_for_mem_btst.\n        (symbolic_operand): Rename to mn10300_symbolic_operand.\n        (legitimize_pic_address): Rename to mn10300_legitimize_pic_address.\n        (legitimate_pic_operand_p): Rename to mn10300_legitimate_pic_operand_p.\n        * config/mn10300/mn10300-protos.h: Update prototypes.\n        * config/mn10300/mn10300.h: Fold code to 80-character width.\n        Replace GET_CODE (foo) == REG with REG_P (foo).  Likewise for\n        MEM, CONST_INT and CONST_DOUBLE.\n        (CPP_SPEC): Move to...\n        (TARGET_CPU_CPP_BUILTINS): ... here.\n        * config/mn10300/mn10300.md: Fold code to 80-character width.\n        Replace GET_CODE (foo) == REG with REG_P (foo).  Likewise for\n        MEM, CONST_INT and CONST_DOUBLE.\n\nFrom-SVN: r165778", "tree": {"sha": "9983734464fc15bdf487ed13014b32f90acee9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9983734464fc15bdf487ed13014b32f90acee9c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7ab55938c4d392306c0a19cba3bda764b17cdd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ab55938c4d392306c0a19cba3bda764b17cdd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ab55938c4d392306c0a19cba3bda764b17cdd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ab55938c4d392306c0a19cba3bda764b17cdd7/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b"}], "stats": {"total": 797, "additions": 422, "deletions": 375}, "files": [{"sha": "fb21da0c18cbf6c4a634fcde1aa685fc322db2aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7ab55938c4d392306c0a19cba3bda764b17cdd7", "patch": "@@ -1,3 +1,30 @@\n+2010-10-21  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mn10300/mn10300.c: Fold code to 80-character width.\n+        Replace GET_CODE (foo) == REG with REG_P (foo).  Likewise for\n+        MEM, CONST_INT and CONST_DOUBLE.\n+\t(targetm): Move initialization to end of file.\n+\t(print_operand): Rename to mn10300_print_operand.\n+\t(print_operand_address): Rename to mn10300_print_operand_address.\n+\t(can_use_return_insn): Rename to mn10300_can_use_return_insn.\n+\t(expand_prologue): Rename to mn10300_expand_prologue.\n+\t(expand_epilogue): Rename to mn10300_expand_epilogue.\n+\t(initial_offset): Rename to mn10300_initial_offset.\n+\t(function_arg): Rename to mn10300_function_arg.\n+\t(mask_ok_for_mem_btst): Rename to mn10300_mask_ok_for_mem_btst.\n+\t(symbolic_operand): Rename to mn10300_symbolic_operand.\n+\t(legitimize_pic_address): Rename to mn10300_legitimize_pic_address.\n+\t(legitimate_pic_operand_p): Rename to mn10300_legitimate_pic_operand_p.\n+\t* config/mn10300/mn10300-protos.h: Update prototypes.\n+\t* config/mn10300/mn10300.h: Fold code to 80-character width.\n+        Replace GET_CODE (foo) == REG with REG_P (foo).  Likewise for\n+        MEM, CONST_INT and CONST_DOUBLE.\n+        (CPP_SPEC): Move to...\n+        (TARGET_CPU_CPP_BUILTINS): ... here.\n+\t* config/mn10300/mn10300.md: Fold code to 80-character width.\n+        Replace GET_CODE (foo) == REG with REG_P (foo).  Likewise for\n+        MEM, CONST_INT and CONST_DOUBLE.\n+\n 2010-10-21  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/46049"}, {"sha": "23d428cec224ac7b8a01ef6836c11688c16031f6", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=e7ab55938c4d392306c0a19cba3bda764b17cdd7", "patch": "@@ -3,55 +3,55 @@\n    Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #define Mmode enum machine_mode\n #define Cstar const char *\n #define Rclas enum reg_class\n \n #ifdef RTX_CODE\n-extern rtx   legitimize_pic_address (rtx, rtx);\n-extern int   legitimate_pic_operand_p (rtx);\n+extern rtx   mn10300_legitimize_pic_address (rtx, rtx);\n+extern int   mn10300_legitimate_pic_operand_p (rtx);\n extern bool  mn10300_function_value_regno_p (const unsigned int);\n extern void  mn10300_gen_multiple_store (int);\n extern int   mn10300_get_live_callee_saved_regs (void);\n extern bool  mn10300_hard_regno_mode_ok (unsigned int, Mmode);\n extern bool  mn10300_legitimate_constant_p (rtx);\n extern bool  mn10300_modes_tieable (Mmode, Mmode);\n extern Cstar mn10300_output_cmp (rtx, rtx);\n+extern void  mn10300_print_operand (FILE *, rtx, int);\n+extern void  mn10300_print_operand_address (FILE *, rtx);\n extern void  mn10300_print_reg_list (FILE *, int);\n extern Rclas mn10300_secondary_reload_class (Rclas, Mmode, rtx);\n extern Mmode mn10300_select_cc_mode (rtx);\n+extern int   mn10300_store_multiple_operation (rtx, Mmode);\n+extern int   mn10300_symbolic_operand (rtx, Mmode);\n extern bool  mn10300_wide_const_load_uses_clr (rtx operands[2]);\n-extern void  print_operand (FILE *, rtx, int);\n-extern void  print_operand_address (FILE *, rtx);\n-extern int   store_multiple_operation (rtx, Mmode);\n-extern int   symbolic_operand (rtx, Mmode);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern struct rtx_def *function_arg (CUMULATIVE_ARGS *, Mmode, tree, int);\n+extern struct rtx_def * mn10300_function_arg (CUMULATIVE_ARGS *, Mmode, tree, int);\n #endif /* TREE_CODE */\n \n-extern int   can_use_return_insn (void);\n-extern void  expand_prologue (void);\n-extern void  expand_epilogue (void);\n-extern int   initial_offset (int, int);\n-extern int   mask_ok_for_mem_btst (int, int);\n+extern int   mn10300_can_use_return_insn (void);\n+extern void  mn10300_expand_prologue (void);\n+extern void  mn10300_expand_epilogue (void);\n+extern int   mn10300_initial_offset (int, int);\n+extern int   mn10300_mask_ok_for_mem_btst (int, int);\n \n #undef Mmode\n #undef Cstar"}, {"sha": "a947366b0c908390faaf954d8bdee0d1353739c0", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 166, "deletions": 175, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=e7ab55938c4d392306c0a19cba3bda764b17cdd7", "patch": "@@ -3,21 +3,21 @@\n    2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -61,106 +61,16 @@ enum processor_type mn10300_processor = PROCESSOR_DEFAULT;\n /* The size of the callee register save area.  Right now we save everything\n    on entry since it costs us nothing in code size.  It does cost us from a\n    speed standpoint, so we want to optimize this sooner or later.  */\n-#define REG_SAVE_BYTES (4 * df_regs_ever_live_p (2)\t\\\n-\t\t\t+ 4 * df_regs_ever_live_p (3)\t\\\n-\t\t        + 4 * df_regs_ever_live_p (6)\t\\\n-\t\t\t+ 4 * df_regs_ever_live_p (7)\t\t\t\\\n-\t\t\t+ 16 * (df_regs_ever_live_p (14) || df_regs_ever_live_p (15) \\\n-\t\t\t\t|| df_regs_ever_live_p (16) || df_regs_ever_live_p (17)))\n-\n-\n-static bool mn10300_handle_option (size_t, const char *, int);\n-static void mn10300_option_override (void);\n-static bool mn10300_legitimate_address_p (enum machine_mode, rtx, bool);\n-static int mn10300_address_cost_1 (rtx, int *);\n-static int mn10300_address_cost (rtx, bool);\n-static bool mn10300_rtx_costs (rtx, int, int, int *, bool);\n-static void mn10300_file_start (void);\n-static bool mn10300_return_in_memory (const_tree, const_tree);\n-static rtx mn10300_builtin_saveregs (void);\n-static void mn10300_va_start (tree, rtx);\n-static rtx mn10300_legitimize_address (rtx, rtx, enum machine_mode);\n-static bool mn10300_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t       const_tree, bool);\n-static int mn10300_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t      tree, bool);\n-static unsigned int mn10300_case_values_threshold (void);\n-static void mn10300_encode_section_info (tree, rtx, int);\n-static void mn10300_asm_trampoline_template (FILE *);\n-static void mn10300_trampoline_init (rtx, tree, rtx);\n-static rtx mn10300_function_value (const_tree, const_tree, bool);\n-static rtx mn10300_libcall_value (enum machine_mode, const_rtx);\n-static void mn10300_asm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n-static bool mn10300_can_output_mi_thunk (const_tree, HOST_WIDE_INT, HOST_WIDE_INT, const_tree);\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef  TARGET_EXCEPT_UNWIND_INFO\n-#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n-\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-\n-#undef TARGET_LEGITIMIZE_ADDRESS\n-#define TARGET_LEGITIMIZE_ADDRESS mn10300_legitimize_address\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS mn10300_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST mn10300_address_cost\n-\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START mn10300_file_start\n-#undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-\n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS MASK_MULT_BUG | MASK_PTR_A0D0\n-#undef TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION mn10300_handle_option\n-#undef TARGET_OPTION_OVERRIDE\n-#define TARGET_OPTION_OVERRIDE mn10300_option_override\n-\n-#undef  TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO mn10300_encode_section_info\n-\n-#undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY mn10300_return_in_memory\n-#undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE mn10300_pass_by_reference\n-#undef TARGET_CALLEE_COPIES\n-#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n-#undef TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES mn10300_arg_partial_bytes\n-\n-#undef TARGET_EXPAND_BUILTIN_SAVEREGS\n-#define TARGET_EXPAND_BUILTIN_SAVEREGS mn10300_builtin_saveregs\n-#undef TARGET_EXPAND_BUILTIN_VA_START\n-#define TARGET_EXPAND_BUILTIN_VA_START mn10300_va_start\n-\n-#undef TARGET_CASE_VALUES_THRESHOLD\n-#define TARGET_CASE_VALUES_THRESHOLD mn10300_case_values_threshold\n-\n-#undef TARGET_LEGITIMATE_ADDRESS_P\n-#define TARGET_LEGITIMATE_ADDRESS_P\tmn10300_legitimate_address_p\n-\n-#undef TARGET_ASM_TRAMPOLINE_TEMPLATE\n-#define TARGET_ASM_TRAMPOLINE_TEMPLATE mn10300_asm_trampoline_template\n-#undef TARGET_TRAMPOLINE_INIT\n-#define TARGET_TRAMPOLINE_INIT mn10300_trampoline_init\n-\n-#undef TARGET_FUNCTION_VALUE\n-#define TARGET_FUNCTION_VALUE mn10300_function_value\n-#undef TARGET_LIBCALL_VALUE\n-#define TARGET_LIBCALL_VALUE mn10300_libcall_value\n-\n-#undef  TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK      mn10300_asm_output_mi_thunk\n-#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK  mn10300_can_output_mi_thunk\n+#define REG_SAVE_BYTES (4 * df_regs_ever_live_p (2)\t\t\\\n+\t\t\t+ 4 * df_regs_ever_live_p (3)\t\t\\\n+\t\t        + 4 * df_regs_ever_live_p (6)\t\t\\\n+\t\t\t+ 4 * df_regs_ever_live_p (7)\t\t\\\n+\t\t\t+ 16 * (df_regs_ever_live_p (14)\t\\\n+\t\t\t\t|| df_regs_ever_live_p (15)\t\\\n+\t\t\t\t|| df_regs_ever_live_p (16)\t\\\n+\t\t\t\t|| df_regs_ever_live_p (17)))\n \n-struct gcc_target targetm = TARGET_INITIALIZER;\n+static int mn10300_address_cost (rtx, bool);\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n \n@@ -204,12 +114,11 @@ mn10300_file_start (void)\n     fprintf (asm_out_file, \"\\t.am33\\n\");\n }\n \f\n-\n /* Print operand X using operand code CODE to assembly language output file\n    FILE.  */\n \n void\n-print_operand (FILE *file, rtx x, int code)\n+mn10300_print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -308,14 +217,14 @@ print_operand (FILE *file, rtx x, int code)\n \t/* This is used for the operand to a call instruction;\n \t   if it's a REG, enclose it in parens, else output\n \t   the operand normally.  */\n-\tif (GET_CODE (x) == REG)\n+\tif (REG_P (x))\n \t  {\n \t    fputc ('(', file);\n-\t    print_operand (file, x, 0);\n+\t    mn10300_print_operand (file, x, 0);\n \t    fputc (')', file);\n \t  }\n \telse\n-\t  print_operand (file, x, 0);\n+\t  mn10300_print_operand (file, x, 0);\n \tbreak;\n \n       case 'D':\n@@ -373,8 +282,8 @@ print_operand (FILE *file, rtx x, int code)\n \t\t      break;;\n \t\t    case VOIDmode:\n \t\t    case DImode:\n-\t\t      print_operand_address (file,\n-\t\t\t\t\t     GEN_INT (CONST_DOUBLE_LOW (x)));\n+\t\t      mn10300_print_operand_address (file,\n+\t\t\t\t\t\t     GEN_INT (CONST_DOUBLE_LOW (x)));\n \t\t      break;\n \t\t    default:\n \t\t      break;\n@@ -430,8 +339,8 @@ print_operand (FILE *file, rtx x, int code)\n \t\t      gcc_unreachable ();\n \t\t    case VOIDmode:\n \t\t    case DImode:\n-\t\t      print_operand_address (file,\n-\t\t\t\t\t     GEN_INT (CONST_DOUBLE_HIGH (x)));\n+\t\t      mn10300_print_operand_address (file,\n+\t\t\t\t\t\t     GEN_INT (CONST_DOUBLE_HIGH (x)));\n \t\t      break;\n \t\t    default:\n \t\t      break;\n@@ -454,7 +363,7 @@ print_operand (FILE *file, rtx x, int code)\n \n       case 'A':\n \tfputc ('(', file);\n-\tif (GET_CODE (XEXP (x, 0)) == REG)\n+\tif (REG_P ((XEXP (x, 0))))\n \t  output_address (gen_rtx_PLUS (SImode, XEXP (x, 0), const0_rtx));\n \telse\n \t  output_address (XEXP (x, 0));\n@@ -476,7 +385,7 @@ print_operand (FILE *file, rtx x, int code)\n \t shift count as an error.  So we mask off the high bits\n \t of the immediate here.  */\n       case 'S':\n-\tif (GET_CODE (x) == CONST_INT)\n+\tif (CONST_INT_P ((x)))\n \t  {\n \t    fprintf (file, \"%d\", (int)(INTVAL (x) & 0x1f));\n \t    break;\n@@ -522,7 +431,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  case LABEL_REF:\n \t  case CODE_LABEL:\n \t  case UNSPEC:\n-\t    print_operand_address (file, x);\n+\t    mn10300_print_operand_address (file, x);\n \t    break;\n \t  default:\n \t    gcc_unreachable ();\n@@ -534,16 +443,16 @@ print_operand (FILE *file, rtx x, int code)\n /* Output assembly language output for the address ADDR to FILE.  */\n \n void\n-print_operand_address (FILE *file, rtx addr)\n+mn10300_print_operand_address (FILE *file, rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n     case POST_INC:\n-      print_operand_address (file, XEXP (addr, 0));\n+      mn10300_print_operand_address (file, XEXP (addr, 0));\n       fputc ('+', file);\n       break;\n     case REG:\n-      print_operand (file, addr, 0);\n+      mn10300_print_operand (file, addr, 0);\n       break;\n     case PLUS:\n       {\n@@ -556,9 +465,9 @@ print_operand_address (FILE *file, rtx addr)\n \t  base = XEXP (addr, 1), index = XEXP (addr, 0);\n       \telse\n \t  gcc_unreachable ();\n-\tprint_operand (file, index, 0);\n+\tmn10300_print_operand (file, index, 0);\n \tfputc (',', file);\n-\tprint_operand (file, base, 0);;\n+\tmn10300_print_operand (file, base, 0);;\n \tbreak;\n       }\n     case SYMBOL_REF:\n@@ -623,7 +532,7 @@ mn10300_print_reg_list (FILE *file, int mask)\n }\n \n int\n-can_use_return_insn (void)\n+mn10300_can_use_return_insn (void)\n {\n   /* size includes the fixed stack space needed for function calls.  */\n   int size = get_frame_size () + crtl->outgoing_args_size;\n@@ -739,7 +648,7 @@ mn10300_gen_multiple_store (int mask)\n }\n \n void\n-expand_prologue (void)\n+mn10300_expand_prologue (void)\n {\n   HOST_WIDE_INT size;\n \n@@ -754,11 +663,14 @@ expand_prologue (void)\n     {\n       int num_regs_to_save = fp_regs_to_save (), i;\n       HOST_WIDE_INT xsize;\n-      enum { save_sp_merge,\n-\t     save_sp_no_merge,\n-\t     save_sp_partial_merge,\n-\t     save_a0_merge,\n-\t     save_a0_no_merge } strategy;\n+      enum\n+      {\n+\tsave_sp_merge,\n+\tsave_sp_no_merge,\n+\tsave_sp_partial_merge,\n+\tsave_a0_merge,\n+\tsave_a0_no_merge\n+      } strategy;\n       unsigned int strategy_size = (unsigned)-1, this_strategy_size;\n       rtx reg;\n \n@@ -996,7 +908,7 @@ expand_prologue (void)\n }\n \n void\n-expand_epilogue (void)\n+mn10300_expand_epilogue (void)\n {\n   HOST_WIDE_INT size;\n \n@@ -1237,7 +1149,8 @@ expand_epilogue (void)\n    registers it saves.  Return 0 otherwise.  */\n \n int\n-store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+mn10300_store_multiple_operation (rtx op,\n+\t\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count;\n   int mask;\n@@ -1252,7 +1165,7 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   /* Check that first instruction has the form (set (sp) (plus A B)) */\n   elt = XVECEXP (op, 0, 0);\n   if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_DEST (elt)) != REG\n+      || (! REG_P (SET_DEST (elt)))\n       || REGNO (SET_DEST (elt)) != STACK_POINTER_REGNUM\n       || GET_CODE (SET_SRC (elt)) != PLUS)\n     return 0;\n@@ -1262,9 +1175,9 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n      the stack.  We therefore expect the first instruction to create\n      COUNT-1 stack slots.  */\n   elt = SET_SRC (elt);\n-  if (GET_CODE (XEXP (elt, 0)) != REG\n+  if ((! REG_P (XEXP (elt, 0)))\n       || REGNO (XEXP (elt, 0)) != STACK_POINTER_REGNUM\n-      || GET_CODE (XEXP (elt, 1)) != CONST_INT\n+      || (! CONST_INT_P (XEXP (elt, 1)))\n       || INTVAL (XEXP (elt, 1)) != -(count - 1) * 4)\n     return 0;\n \n@@ -1282,8 +1195,8 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       /* Check that element i is a (set (mem M) R) and that R is valid.  */\n       elt = XVECEXP (op, 0, i);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || (! MEM_P (SET_DEST (elt)))\n+\t  || (! REG_P (SET_SRC (elt)))\n \t  || REGNO (SET_SRC (elt)) >= last)\n \treturn 0;\n \n@@ -1295,9 +1208,9 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       /* Check that M has the form (plus (sp) (const_int -I*4)) */\n       elt = XEXP (SET_DEST (elt), 0);\n       if (GET_CODE (elt) != PLUS\n-\t  || GET_CODE (XEXP (elt, 0)) != REG\n+\t  || (! REG_P (XEXP (elt, 0)))\n \t  || REGNO (XEXP (elt, 0)) != STACK_POINTER_REGNUM\n-\t  || GET_CODE (XEXP (elt, 1)) != CONST_INT\n+\t  || (! CONST_INT_P (XEXP (elt, 1)))\n \t  || INTVAL (XEXP (elt, 1)) != -i * 4)\n \treturn 0;\n     }\n@@ -1314,6 +1227,7 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    MODE into a register in register class RCLASS.\n \n    We might be able to simplify this.  */\n+\n enum reg_class\n mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n \t\t\t\trtx in)\n@@ -1329,8 +1243,8 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n   /* Memory loads less than a full word wide can't have an\n      address or stack pointer destination.  They must use\n      a data register as an intermediate register.  */\n-  if ((GET_CODE (in) == MEM\n-       || (GET_CODE (inner) == REG\n+  if ((MEM_P ((in))\n+       || (REG_P ((inner))\n \t   && REGNO (inner) >= FIRST_PSEUDO_REGISTER))\n       && (mode == QImode || mode == HImode)\n       && (rclass == ADDRESS_REGS || rclass == SP_REGS\n@@ -1360,13 +1274,13 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n     {\n       /* We can't load directly into an FP register from a\t\n \t constant address.  */\n-      if (GET_CODE (in) == MEM\n+      if (MEM_P ((in))\n \t  && CONSTANT_ADDRESS_P (XEXP (in, 0)))\n \treturn DATA_OR_EXTENDED_REGS;\n \n       /* Handle case were a pseudo may not get a hard register\n \t but has an equivalent memory location defined.  */\n-      if (GET_CODE (inner) == REG\n+      if (REG_P ((inner))\n \t  && REGNO (inner) >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem [REGNO (inner)]\n \t  && CONSTANT_ADDRESS_P (XEXP (reg_equiv_mem [REGNO (inner)], 0)))\n@@ -1378,7 +1292,7 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n }\n \n int\n-initial_offset (int from, int to)\n+mn10300_initial_offset (int from, int to)\n {\n   /* The difference between the argument pointer and the frame pointer\n      is the size of the callee register save area.  */\n@@ -1497,8 +1411,8 @@ mn10300_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    from a function.  If the result is NULL_RTX, the argument is pushed.  */\n \n rtx\n-function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t      tree type, int named ATTRIBUTE_UNUSED)\n+mn10300_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t      tree type, int named ATTRIBUTE_UNUSED)\n {\n   rtx result = NULL_RTX;\n   int size, align;\n@@ -1651,12 +1565,12 @@ mn10300_output_cmp (rtx operand, rtx insn)\n       /* We allow the search to go through call insns.  We record\n \t the fact that we've past a CALL_INSN and reject matches which\n \t use call clobbered registers.  */\n-      if (GET_CODE (temp) == CODE_LABEL\n-\t  || GET_CODE (temp) == JUMP_INSN\n+      if (LABEL_P (temp)\n+\t  || JUMP_P (temp)\n \t  || GET_CODE (temp) == BARRIER)\n \tbreak;\n \n-      if (GET_CODE (temp) == CALL_INSN)\n+      if (CALL_P (temp))\n \tpast_call = 1;\n \n       if (GET_CODE (temp) == NOTE)\n@@ -1727,7 +1641,7 @@ mn10300_output_cmp (rtx operand, rtx insn)\n /* Similarly, but when using a zero_extract pattern for a btst where\n    the source operand might end up in memory.  */\n int\n-mask_ok_for_mem_btst (int len, int bit)\n+mn10300_mask_ok_for_mem_btst (int len, int bit)\n {\n   unsigned int mask = 0;\n \n@@ -1748,8 +1662,10 @@ mask_ok_for_mem_btst (int len, int bit)\n /* Return 1 if X contains a symbolic expression.  We know these\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */\n+\n int\n-symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+mn10300_symbolic_operand (rtx op,\n+\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -1760,7 +1676,7 @@ symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       op = XEXP (op, 0);\n       return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n                || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-              && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+              && CONST_INT_P ((XEXP (op, 1))));\n     default:\n       return 0;\n     }\n@@ -1778,18 +1694,19 @@ symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n    But on a few ports with segmented architectures and indexed addressing\n    (mn10300, hppa) it is used to rewrite certain problematical addresses.  */\n+\n static rtx\n mn10300_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  if (flag_pic && ! legitimate_pic_operand_p (x))\n-    x = legitimize_pic_address (oldx, NULL_RTX);\n+  if (flag_pic && ! mn10300_legitimate_pic_operand_p (x))\n+    x = mn10300_legitimize_pic_address (oldx, NULL_RTX);\n \n   /* Uh-oh.  We might have an address for x[n-100000].  This needs\n      special handling to avoid creating an indexed memory address\n      with x-100000 as the base.  */\n   if (GET_CODE (x) == PLUS\n-      && symbolic_operand (XEXP (x, 1), VOIDmode))\n+      && mn10300_symbolic_operand (XEXP (x, 1), VOIDmode))\n     {\n       /* Ugly.  We modify things here so that the address offset specified\n          by the index expression is computed first, then added to x to form\n@@ -1808,7 +1725,8 @@ mn10300_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t  regy1 = force_reg (Pmode, force_operand (XEXP (y, 0), 0));\n \t  regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n \t  regx1 = force_reg (Pmode,\n-\t\t\t     gen_rtx_fmt_ee (GET_CODE (y), Pmode, regx1, regy2));\n+\t\t\t     gen_rtx_fmt_ee (GET_CODE (y), Pmode, regx1,\n+\t\t\t\t\t     regy2));\n \t  return force_reg (Pmode, gen_rtx_PLUS (Pmode, regx1, regy1));\n \t}\n     }\n@@ -1817,8 +1735,9 @@ mn10300_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n /* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n    @GOTOFF in `reg'.  */\n+\n rtx\n-legitimize_pic_address (rtx orig, rtx reg)\n+mn10300_legitimize_pic_address (rtx orig, rtx reg)\n {\n   if (GET_CODE (orig) == LABEL_REF\n       || (GET_CODE (orig) == SYMBOL_REF\n@@ -1844,11 +1763,12 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n /* Return zero if X references a SYMBOL_REF or LABEL_REF whose symbol\n    isn't protected by a PIC unspec; nonzero otherwise.  */\n+\n int\n-legitimate_pic_operand_p (rtx x)\n+mn10300_legitimate_pic_operand_p (rtx x)\n {\n-  register const char *fmt;\n-  register int i;\n+  const char *fmt;\n+  int i;\n \n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n     return 0;\n@@ -1869,10 +1789,11 @@ legitimate_pic_operand_p (rtx x)\n \t  int j;\n \n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (! legitimate_pic_operand_p (XVECEXP (x, i, j)))\n+\t    if (! mn10300_legitimate_pic_operand_p (XVECEXP (x, i, j)))\n \t      return 0;\n \t}\n-      else if (fmt[i] == 'e' && ! legitimate_pic_operand_p (XEXP (x, i)))\n+      else if (fmt[i] == 'e'\n+\t       && ! mn10300_legitimate_pic_operand_p (XEXP (x, i)))\n \treturn 0;\n     }\n \n@@ -1897,7 +1818,7 @@ static bool\n mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   if (CONSTANT_ADDRESS_P (x)\n-      && (! flag_pic || legitimate_pic_operand_p (x)))\n+      && (! flag_pic || mn10300_legitimate_pic_operand_p (x)))\n     return TRUE;\n \n   if (RTX_OK_FOR_BASE_P (x, strict))\n@@ -1929,12 +1850,12 @@ mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \n       if (base != 0 && index != 0)\n \t{\n-\t  if (GET_CODE (index) == CONST_INT)\n+\t  if (CONST_INT_P ((index)))\n \t    return TRUE;\n \t  if (GET_CODE (index) == CONST\n \t      && GET_CODE (XEXP (index, 0)) != PLUS\n \t      && (! flag_pic\n- \t\t  || (legitimate_pic_operand_p (index)\n+ \t\t  || (mn10300_legitimate_pic_operand_p (index)\n \t\t      && GET_MODE_SIZE (mode) == 4)))\n \t    return TRUE;\n \t}\n@@ -1958,7 +1879,7 @@ mn10300_legitimate_constant_p (rtx x)\n \n       if (GET_CODE (x) == PLUS)\n \t{\n-\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  if (! CONST_INT_P (XEXP (x, 1)))\n \t    return false;\n \t  x = XEXP (x, 0);\n \t}\n@@ -1981,7 +1902,7 @@ mn10300_legitimate_constant_p (rtx x)\n \t}\n \n       /* We must have drilled down to a symbol.  */\n-      if (!symbolic_operand (x, Pmode))\n+      if (! mn10300_symbolic_operand (x, Pmode))\n \treturn false;\n       break;\n \n@@ -2066,7 +1987,8 @@ mn10300_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n }\n \n static bool\n-mn10300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed ATTRIBUTE_UNUSED)\n+mn10300_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t   bool speed ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -2128,7 +2050,7 @@ mn10300_wide_const_load_uses_clr (rtx operands[2])\n {\n   long val[2] = {0, 0};\n \n-  if (GET_CODE (operands[0]) != REG\n+  if (! REG_P (operands[0])\n       || REGNO_REG_CLASS (REGNO (operands[0])) != DATA_REGS)\n     return false;\n \n@@ -2173,7 +2095,7 @@ mn10300_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n {\n   rtx symbol;\n \n-  if (GET_CODE (rtl) != MEM)\n+  if (! MEM_P (rtl))\n     return;\n   symbol = XEXP (rtl, 0);\n   if (GET_CODE (symbol) != SYMBOL_REF)\n@@ -2331,3 +2253,72 @@ mn10300_select_cc_mode (rtx x)\n   return (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT) ? CC_FLOATmode : CCmode;\n }\n \f\n+/* Initialize the GCC target structure.  */\n+\n+#undef  TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n+\n+#undef  TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+\n+#undef  TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS mn10300_legitimize_address\n+\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS mn10300_rtx_costs\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST mn10300_address_cost\n+\n+#undef  TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START mn10300_file_start\n+#undef  TARGET_ASM_FILE_START_FILE_DIRECTIVE\n+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n+\n+#undef  TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS MASK_MULT_BUG | MASK_PTR_A0D0\n+#undef  TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION mn10300_handle_option\n+#undef  TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE mn10300_option_override\n+\n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO mn10300_encode_section_info\n+\n+#undef  TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY mn10300_return_in_memory\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE mn10300_pass_by_reference\n+#undef  TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES mn10300_arg_partial_bytes\n+\n+#undef  TARGET_EXPAND_BUILTIN_SAVEREGS\n+#define TARGET_EXPAND_BUILTIN_SAVEREGS mn10300_builtin_saveregs\n+#undef  TARGET_EXPAND_BUILTIN_VA_START\n+#define TARGET_EXPAND_BUILTIN_VA_START mn10300_va_start\n+\n+#undef  TARGET_CASE_VALUES_THRESHOLD\n+#define TARGET_CASE_VALUES_THRESHOLD mn10300_case_values_threshold\n+\n+#undef  TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tmn10300_legitimate_address_p\n+\n+#undef  TARGET_ASM_TRAMPOLINE_TEMPLATE\n+#define TARGET_ASM_TRAMPOLINE_TEMPLATE mn10300_asm_trampoline_template\n+#undef  TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT mn10300_trampoline_init\n+\n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE mn10300_function_value\n+#undef  TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE mn10300_libcall_value\n+\n+#undef  TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK      mn10300_asm_output_mi_thunk\n+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK  mn10300_can_output_mi_thunk\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "cf52f5b3d9b513c046537fe85d54a73a5904bb33", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 69, "deletions": 50, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=e7ab55938c4d392306c0a19cba3bda764b17cdd7", "patch": "@@ -4,29 +4,28 @@\n    2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #undef ASM_SPEC\n #undef LIB_SPEC\n #undef ENDFILE_SPEC\n-#undef LINK_SPEC\n+#undef  LINK_SPEC\n #define LINK_SPEC \"%{mrelax:--relax}\"\n-#undef STARTFILE_SPEC\n+#undef  STARTFILE_SPEC\n #define STARTFILE_SPEC \"%{!mno-crt0:%{!shared:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}}\"\n \n /* Names to predefine in the preprocessor for this target machine.  */\n@@ -38,14 +37,21 @@ along with GCC; see the file COPYING3.  If not see\n       builtin_define (\"__MN10300__\");\t\t\\\n       builtin_assert (\"cpu=mn10300\");\t\t\\\n       builtin_assert (\"machine=mn10300\");\t\\\n+\t\t\t\t\t\t\\\n+      if (TARGET_AM33_2)\t\t\t\\\n+        { \t\t\t\t\t\\\n+          builtin_define (\"__AM33__=2\");\t\\\n+          builtin_define (\"__AM33_2__\");\t\\\n+        }\t\t\t\t\t\\\n+      else if (TARGET_AM33)\t\t\t\\\n+        builtin_define (\"__AM33__=1\");\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-#define CPP_SPEC \"%{mam33:-D__AM33__} %{mam33-2:-D__AM33__=2 -D__AM33_2__}\"\n-\n extern GTY(()) int mn10300_unspec_int_label_counter;\n \n-enum processor_type {\n+enum processor_type\n+{\n   PROCESSOR_MN10300,\n   PROCESSOR_AM33,\n   PROCESSOR_AM33_2\n@@ -99,7 +105,7 @@ extern enum processor_type mn10300_processor;\n #define BIGGEST_ALIGNMENT\t32\n \n /* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n+#define EMPTY_FIELD_BOUNDARY    32\n \n /* Define this if move instructions will actually fail to work\n    when given unaligned data.  */\n@@ -254,7 +260,8 @@ extern enum processor_type mn10300_processor;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-enum reg_class {\n+enum reg_class\n+{\n   NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS,\n   DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS,\n   EXTENDED_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n@@ -274,7 +281,8 @@ enum reg_class {\n   \"DATA_OR_EXTENDED_REGS\", \"ADDRESS_OR_EXTENDED_REGS\",\t\t\\\n   \"SP_OR_EXTENDED_REGS\", \"SP_OR_ADDRESS_OR_EXTENDED_REGS\",\t\\\n   \"FP_REGS\", \"FP_ACC_REGS\", \"CC_REGS\",\t\t\t\t\\\n-  \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+  \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\"\t\t\t\\\n+}\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -307,23 +315,23 @@ enum reg_class {\n    array of register classes with LIM_REG_CLASSES used as the end\n    marker.  */\n \n-#define IRA_COVER_CLASSES                                                    \\\n-{                                                                            \\\n-  GENERAL_REGS, FP_REGS, LIM_REG_CLASSES \\\n+#define IRA_COVER_CLASSES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  GENERAL_REGS, FP_REGS, LIM_REG_CLASSES\t\t\t\\\n }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((REGNO) <= LAST_DATA_REGNUM ? DATA_REGS : \\\n-   (REGNO) <= LAST_ADDRESS_REGNUM ? ADDRESS_REGS : \\\n-   (REGNO) == STACK_POINTER_REGNUM ? SP_REGS : \\\n+#define REGNO_REG_CLASS(REGNO)\t\t\t     \\\n+  ((REGNO) <= LAST_DATA_REGNUM ? DATA_REGS :\t     \\\n+   (REGNO) <= LAST_ADDRESS_REGNUM ? ADDRESS_REGS :   \\\n+   (REGNO) == STACK_POINTER_REGNUM ? SP_REGS :\t     \\\n    (REGNO) <= LAST_EXTENDED_REGNUM ? EXTENDED_REGS : \\\n-   (REGNO) <= LAST_FP_REGNUM ? FP_REGS : \\\n-   (REGNO) == CC_REG ? CC_REGS : \\\n+   (REGNO) <= LAST_FP_REGNUM ? FP_REGS :\t     \\\n+   (REGNO) == CC_REG ? CC_REGS :\t\t     \\\n    NO_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -414,11 +422,11 @@ enum reg_class {\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\\\n   ((X) == stack_pointer_rtx && (CLASS) != SP_REGS\t\t\\\n    ? ADDRESS_OR_EXTENDED_REGS\t\t\t\t\t\\\n-   : (GET_CODE (X) == MEM\t\t\t\t\t\\\n-      || (GET_CODE (X) == REG\t\t\t\t\t\\\n+   : (MEM_P (X)\t\t\t\t\t\t\t\\\n+      || (REG_P (X)\t\t\t\t\t\t\\\n \t  && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n       || (GET_CODE (X) == SUBREG\t\t\t\t\\\n-\t  && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\\\n+\t  && REG_P (SUBREG_REG (X))\t\t\t\t\\\n \t  && REGNO (SUBREG_REG (X)) >= FIRST_PSEUDO_REGISTER)\t\\\n       ? LIMIT_RELOAD_CLASS (GET_MODE (X), CLASS)\t\t\\\n       : (CLASS)))\n@@ -483,7 +491,7 @@ enum reg_class {\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  OFFSET = initial_offset (FROM, TO)\n+  OFFSET = mn10300_initial_offset (FROM, TO)\n \n /* We can debug without frame pointers on the mn10300, so eliminate\n    them whenever possible.  */\n@@ -494,11 +502,10 @@ enum reg_class {\n #define REG_PARM_STACK_SPACE(DECL) 8\n #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n #define ACCUMULATE_OUTGOING_ARGS 1\n-#if 1\n+\n /* So we can allocate space for return pointers once for the function\n    instead of around every call.  */\n #define STACK_POINTER_OFFSET 4\n-#endif\n \n /* 1 if N is a possible register number for function argument passing.\n    On the MN10300, d0 and d1 are used in this way.  */\n@@ -516,7 +523,11 @@ enum reg_class {\n    of arguments scanned so far.  */\n \n #define CUMULATIVE_ARGS struct cum_arg\n-struct cum_arg {int nbytes; };\n+\n+struct cum_arg\n+{\n+  int nbytes;\n+};\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -550,7 +561,7 @@ struct cum_arg {int nbytes; };\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  function_arg (&CUM, MODE, TYPE, NAMED)\n+  mn10300_function_arg (&(CUM), MODE, TYPE, NAMED)\n \n #define FUNCTION_VALUE_REGNO_P(N)  mn10300_function_value_regno_p (N)\n \n@@ -614,7 +625,8 @@ struct cum_arg {int nbytes; };\n \n /* Zero if this needs fixing up to become PIC.  */\n \n-#define LEGITIMATE_PIC_OPERAND_P(X) (legitimate_pic_operand_p (X))\n+#define LEGITIMATE_PIC_OPERAND_P(X) \\\n+  mn10300_legitimate_pic_operand_p (X)\n \n /* Register to hold the addressing base for\n    position independent code access to data items.  */\n@@ -701,7 +713,7 @@ struct cum_arg {int nbytes; };\n \n #define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n #define DATA_SECTION_ASM_OP \"\\t.section .data\"\n-#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n+#define BSS_SECTION_ASM_OP  \"\\t.section .bss\"\n \n #define ASM_COMMENT_START \"#\"\n \n@@ -731,7 +743,7 @@ struct cum_arg {int nbytes; };\n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.  */\n \n-#undef ASM_OUTPUT_LABELREF\n+#undef  ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n   asm_fprintf (FILE, \"%U%s\", (*targetm.strip_name_encoding) (NAME))\n \n@@ -740,11 +752,14 @@ struct cum_arg {int nbytes; };\n /* This is how we tell the assembler that two symbols have the same value.  */\n \n #define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \\\n-  do { assemble_name(FILE, NAME1); \t \\\n-       fputs(\" = \", FILE);\t\t \\\n-       assemble_name(FILE, NAME2);\t \\\n-       fputc('\\n', FILE); } while (0)\n-\n+  do\t\t\t\t\t \\\n+    {\t\t\t\t\t \\\n+      assemble_name (FILE, NAME1);\t \\\n+      fputs (\" = \", FILE);\t\t \\\n+      assemble_name (FILE, NAME2);\t \\\n+      fputc ('\\n', FILE);\t\t \\\n+    }\t\t\t\t\t \\\n+  while (0)\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n@@ -774,12 +789,14 @@ struct cum_arg {int nbytes; };\n /* Print an instruction operand X on file FILE.\n    look in mn10300.c for details */\n \n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+#define PRINT_OPERAND(FILE, X, CODE) \\\n+  mn10300_print_operand (FILE, X, CODE)\n \n /* Print a memory operand whose address is X, on file FILE.\n    This uses a function in output-vax.c.  */\n \n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n+  mn10300_print_operand_address (FILE, ADDR)\n \n /* This is how to output an element of a case-vector that is absolute.  */\n \n@@ -821,12 +838,14 @@ struct cum_arg {int nbytes; };\n #define DEBUGGER_AUTO_OFFSET(X) \\\n   ((GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0) \\\n     + (frame_pointer_needed \\\n-       ? 0 : -initial_offset (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM)))\n+       ? 0 : - mn10300_initial_offset (FRAME_POINTER_REGNUM, \\\n+\t\t\t\t       STACK_POINTER_REGNUM)))\n \n #define DEBUGGER_ARG_OFFSET(OFFSET, X) \\\n   ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n     + (frame_pointer_needed \\\n-       ? 0 : -initial_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM)))\n+       ? 0 : - mn10300_initial_offset (ARG_POINTER_REGNUM, \\\n+\t\t\t\t       STACK_POINTER_REGNUM)))\n \n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}, {"sha": "d90f0f25836fd3f4081221e236a52b57074bab18", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 136, "deletions": 126, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ab55938c4d392306c0a19cba3bda764b17cdd7/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=e7ab55938c4d392306c0a19cba3bda764b17cdd7", "patch": "@@ -72,7 +72,7 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+      if (CONST_DOUBLE_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n \t  xoperands[0] = operands[0];\n@@ -82,7 +82,7 @@\n \t}\n \n       if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t  && CONST_INT_P (operands[1]))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (operands[1]);\n \n@@ -118,7 +118,7 @@\n     case 2:\n     case 3:\n     case 4:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+      if (CONST_DOUBLE_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n \t  xoperands[0] = operands[0];\n@@ -164,7 +164,7 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+      if (CONST_DOUBLE_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n \t  xoperands[0] = operands[0];\n@@ -174,7 +174,7 @@\n \t}\n \n       if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t  && CONST_INT_P (operands[1]))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (operands[1]);\n \n@@ -210,7 +210,7 @@\n     case 2:\n     case 3:\n     case 4:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+      if (CONST_DOUBLE_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n \t  xoperands[0] = operands[0];\n@@ -293,23 +293,23 @@\n       rtx temp;\n       if (SYMBOLIC_CONST_P (operands[1]))\n \t{\n-\t  if (GET_CODE (operands[0]) == MEM)\n+\t  if (MEM_P (operands[0]))\n \t    operands[1] = force_reg (Pmode, operands[1]);\n \t  else\n \t    {\n \t      temp = (!can_create_pseudo_p ()\n \t\t      ? operands[0]\n \t\t      : gen_reg_rtx (Pmode));\n-\t      operands[1] = legitimize_pic_address (operands[1], temp);\n+\t      operands[1] = mn10300_legitimize_pic_address (operands[1], temp);\n \t    }\n \t}\n       else if (GET_CODE (operands[1]) == CONST\n \t       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n \t       && SYMBOLIC_CONST_P (XEXP (XEXP (operands[1], 0), 0)))\n \t{\n \t  temp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n-\t  temp = legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n-\t\t\t\t\t temp);\n+\t  temp = mn10300_legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n+\t\t\t\t\t\t temp);\n \t  operands[1] = expand_binop (SImode, add_optab, temp,\n \t\t\t\t      XEXP (XEXP (operands[1], 0), 1),\n \t\t\t\t      (!can_create_pseudo_p ()\n@@ -346,7 +346,7 @@\n     case 11:\n     case 12:\n     case 13:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+      if (CONST_DOUBLE_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n \t  xoperands[0] = operands[0];\n@@ -356,7 +356,7 @@\n \t}\n \n       if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t  && CONST_INT_P (operands[1]))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (operands[1]);\n \n@@ -410,7 +410,7 @@\n     case 7:\n     case 8:\n       if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n-\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t  && CONST_INT_P (operands[1]))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (operands[1]);\n \n@@ -471,14 +471,14 @@\n       case 9:\n       case 10:\n       case 11:\n-\tif (GET_CODE (operands[1]) == CONST_INT)\n+\tif (CONST_INT_P (operands[1]))\n \t  {\n \t    rtx low, high;\n \t    split_double (operands[1], &low, &high);\n \t    val[0] = INTVAL (low);\n \t    val[1] = INTVAL (high);\n \t  }\n-\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tif (CONST_DOUBLE_P (operands[1]))\n \t  {\n \t    if (GET_MODE (operands[1]) == DFmode)\n \t      {\n@@ -493,15 +493,15 @@\n \t      }\n \t  }\n \n-\tif (GET_CODE (operands[1]) == MEM\n+\tif (MEM_P (operands[1])\n \t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n \t  {\n \t    rtx temp = operands[0];\n \n \t    while (GET_CODE (temp) == SUBREG)\n \t      temp = SUBREG_REG (temp);\n \n-\t    gcc_assert (GET_CODE (temp) == REG);\n+\t    gcc_assert (REG_P (temp));\n \n \t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n@@ -510,7 +510,7 @@\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n \n \t  }\n-\telse if (GET_CODE (operands[1]) == MEM\n+\telse if (MEM_P (operands[1])\n \t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n \t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n \t  {\n@@ -525,17 +525,17 @@\n \t  }\n \telse\n \t  {\n-\t    if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    if ((CONST_INT_P (operands[1])\n+\t\t || CONST_DOUBLE_P (operands[1]))\n \t\t&& val[0] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n@@ -544,21 +544,21 @@\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n-\t    if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    if ((CONST_INT_P (operands[1])\n+\t\t || CONST_DOUBLE_P (operands[1]))\n \t\t&& val[1] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && val[0] == val[1])\n \t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n@@ -575,15 +575,15 @@\n       case 15:\n         return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n       case 16:\n-\tif (GET_CODE (operands[1]) == MEM\n-\t    && GET_CODE (XEXP (operands[1], 0)) == CONST_INT\n+\tif (MEM_P (operands[1])\n+\t    && CONST_INT_P (XEXP (operands[1], 0))\n \t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n \t  return \\\"fmov %D1, %D0\\\";\n \telse\n           return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n       case 17:\n-\tif (GET_CODE (operands[0]) == MEM\n-\t    && GET_CODE (XEXP (operands[0], 0)) == CONST_INT\n+\tif (MEM_P (operands[0])\n+\t    && CONST_INT_P (XEXP (operands[0], 0))\n \t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n \t  return \\\"fmov %D1, %D0\\\";\n \telse\n@@ -637,16 +637,16 @@\n         return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n \n       case 7:\n-\tif (GET_CODE (operands[1]) == MEM\n-\t    && GET_CODE (XEXP (operands[1], 0)) == CONST_INT\n+\tif (MEM_P (operands[1])\n+\t    && CONST_INT_P (XEXP (operands[1], 0))\n \t    && (INTVAL (XEXP (operands[1], 0)) & 7) == 0)\n \t  return \\\"fmov %D1, %D0\\\";\n \telse\n           return \\\"fmov %L1, %L0\\;fmov %H1, %H0\\\";\n \n       case 8:\n-\tif (GET_CODE (operands[0]) == MEM\n-\t    && GET_CODE (XEXP (operands[0], 0)) == CONST_INT\n+\tif (MEM_P (operands[0])\n+\t    && CONST_INT_P (XEXP (operands[0], 0))\n \t    && (INTVAL (XEXP (operands[0], 0)) & 7) == 0)\n \t  return \\\"fmov %D1, %D0\\\";\n \telse\n@@ -665,14 +665,14 @@\n       case 15:\n       case 16:\n       case 17:\n-\tif (GET_CODE (operands[1]) == CONST_INT)\n+\tif (CONST_INT_P (operands[1]))\n \t  {\n \t    rtx low, high;\n \t    split_double (operands[1], &low, &high);\n \t    val[0] = INTVAL (low);\n \t    val[1] = INTVAL (high);\n \t  }\n-\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tif (CONST_DOUBLE_P (operands[1]))\n \t  {\n \t    if (GET_MODE (operands[1]) == DFmode)\n \t      {\n@@ -687,15 +687,15 @@\n \t      }\n \t  }\n \n-\tif (GET_CODE (operands[1]) == MEM\n+\tif (MEM_P (operands[1])\n \t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n \t  {\n \t    rtx temp = operands[0];\n \n \t    while (GET_CODE (temp) == SUBREG)\n \t      temp = SUBREG_REG (temp);\n \n-\t    gcc_assert (GET_CODE (temp) == REG);\n+\t    gcc_assert (REG_P (temp));\n \n \t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n@@ -704,7 +704,7 @@\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n \n \t  }\n-\telse if (GET_CODE (operands[1]) == MEM\n+\telse if (MEM_P (operands[1])\n \t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n \t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n \t  {\n@@ -719,17 +719,17 @@\n \t  }\n \telse\n \t  {\n-\t    if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    if ((CONST_INT_P (operands[1])\n+\t\t || CONST_DOUBLE_P (operands[1]))\n \t\t&& val[0] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n@@ -738,21 +738,21 @@\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n-\t    if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    if ((CONST_INT_P (operands[1])\n+\t\t || CONST_DOUBLE_P (operands[1]))\n \t\t&& val[1] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && val[0] == val[1])\n \t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n@@ -803,14 +803,14 @@\n       case 8:\n       case 9:\n       case 10:\n-\tif (GET_CODE (operands[1]) == CONST_INT)\n+\tif (CONST_INT_P (operands[1]))\n \t  {\n \t    rtx low, high;\n \t    split_double (operands[1], &low, &high);\n \t    val[0] = INTVAL (low);\n \t    val[1] = INTVAL (high);\n \t  }\n-\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tif (CONST_DOUBLE_P (operands[1]))\n \t  {\n \t    if (GET_MODE (operands[1]) == DFmode)\n \t      {\n@@ -825,15 +825,15 @@\n \t      }\n \t  }\n \n-\tif (GET_CODE (operands[1]) == MEM\n+\tif (MEM_P (operands[1])\n \t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n \t  {\n \t    rtx temp = operands[0];\n \n \t    while (GET_CODE (temp) == SUBREG)\n \t      temp = SUBREG_REG (temp);\n \n-\t    gcc_assert (GET_CODE (temp) == REG);\n+\t    gcc_assert (REG_P (temp));\n \n \t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n@@ -842,7 +842,7 @@\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n \n \t  }\n-\telse if (GET_CODE (operands[1]) == MEM\n+\telse if (MEM_P (operands[1])\n \t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n \t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n \t  {\n@@ -857,17 +857,17 @@\n \t  }\n \telse\n \t  {\n-\t    if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    if ((CONST_INT_P (operands[1])\n+\t\t || CONST_DOUBLE_P (operands[1]))\n \t\t&& val[0] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n@@ -876,21 +876,21 @@\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n-\t    if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    if ((CONST_INT_P (operands[1])\n+\t\t || CONST_DOUBLE_P (operands[1]))\n \t\t&& val[1] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n \t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && val[0] == val[1])\n \t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n-\t    else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    else if ((CONST_INT_P (operands[1])\n+\t\t      || CONST_DOUBLE_P (operands[1]))\n \t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n \t\t\t == EXTENDED_REGS)\n \t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n@@ -965,10 +965,11 @@\n \t    /* We have to copy one of the sources into the destination, then\n \t       add the other source to the destination.\n \n-\t       Carefully select which source to copy to the destination; a naive\n-\t       implementation will waste a byte when the source classes are\n-\t       different and the destination is an address register.  Selecting\n-\t       the lowest cost register copy will optimize this sequence.  */\n+\t       Carefully select which source to copy to the destination; a\n+\t       naive implementation will waste a byte when the source classes\n+\t       are different and the destination is an address register.\n+\t       Selecting the lowest cost register copy will optimize this\n+\t       sequence.  */\n \t    if (REGNO_REG_CLASS (true_regnum (operands[1]))\n \t\t== REGNO_REG_CLASS (true_regnum (operands[0])))\n \t      return \\\"mov %1,%0\\;add %2,%0\\\";\n@@ -1260,25 +1261,25 @@\n   \"TARGET_AM33\"\n   \"*\n {\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xff)\n     return \\\"extbu %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xffff)\n     return \\\"exthu %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x7fffffff)\n     return \\\"add %0,%0\\;lsr 1,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x3fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x3fffffff)\n     return \\\"asl2 %0\\;lsr 2,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x1fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x1fffffff)\n     return \\\"add %0,%0\\;asl2 %0\\;lsr 3,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x0fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x0fffffff)\n     return \\\"asl2 %0\\;asl2 %0\\;lsr 4,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffe)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffe)\n     return \\\"lsr 1,%0\\;add %0,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffc)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffc)\n     return \\\"lsr 2,%0\\;asl2 %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff8)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff8)\n     return \\\"lsr 3,%0\\;add %0,%0\\;asl2 %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff0)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff0)\n     return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n   if (REG_P (operands[2]) && REG_P (operands[1])\n       && true_regnum (operands[0]) != true_regnum (operands[1])\n@@ -1299,33 +1300,33 @@\n )\n \n (define_insn \"*mn10300_andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx,dx\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi\")))\n    (clobber (reg:CC CC_REG))\n   ]\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xff)\n     return \\\"extbu %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xffff)\n     return \\\"exthu %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x7fffffff)\n     return \\\"add %0,%0\\;lsr 1,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x3fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x3fffffff)\n     return \\\"asl2 %0\\;lsr 2,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x1fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x1fffffff)\n     return \\\"add %0,%0\\;asl2 %0\\;lsr 3,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x0fffffff)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0x0fffffff)\n     return \\\"asl2 %0\\;asl2 %0\\;lsr 4,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffe)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffe)\n     return \\\"lsr 1,%0\\;add %0,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffc)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffffc)\n     return \\\"lsr 2,%0\\;asl2 %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff8)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff8)\n     return \\\"lsr 3,%0\\;add %0,%0\\;asl2 %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff0)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 0xfffffff0)\n     return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n   return \\\"and %2,%0\\\";\n }\"\n@@ -1478,7 +1479,8 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int 0))\n    (clobber (reg:CC CC_REG))\n    ]\n-  \"GET_CODE (operands[0]) != MEM || (! MEM_VOLATILE_P (operands[0]) && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n+  \"(! MEM_P (operands[0])) || (! MEM_VOLATILE_P (operands[0])\n+                               && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n   \"@\n   bclr 255,%A0\n   clr %0\"\n@@ -1488,7 +1490,8 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int -1))\n    (clobber (reg:CC CC_REG))\n   ]\n-  \"GET_CODE (operands[0]) != MEM || (! MEM_VOLATILE_P (operands[0]) && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n+  \"( ! MEM_P (operands[0])) || (! MEM_VOLATILE_P (operands[0])\n+                                && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n   \"@\n   bset 255,%A0\n   mov -1,%0\"\n@@ -1553,8 +1556,8 @@\n \t\t(match_operand:QI 2 \"general_operand\" \"i,d,ir\")))\n    (clobber (reg:CC CC_REG))\n   ]\n-  \"TARGET_AM33 &&\n-   (GET_CODE (operands[2]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+  \"TARGET_AM33 && \n+   ((! MEM_P (operands[2])) || (! MEM_P (operands[1])))\"\n   \"@\n   bset %U2,%A0\n   bset %2,%0\n@@ -1571,7 +1574,7 @@\n \t\t(match_operand:QI 2 \"general_operand\" \"i,d,id\")))\n    (clobber (reg:CC CC_REG))\n   ]\n-  \"GET_CODE (operands[2]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"(! MEM_P (operands[2])) || (! MEM_P (operands[1]))\"\n   \"@\n   bset %U2,%A0\n   bset %2,%0\n@@ -1612,7 +1615,7 @@\n \t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n \t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n \t      (const_int 0)))]\n-  \"mask_ok_for_mem_btst (INTVAL (operands[1]), INTVAL (operands[2]))\"\n+  \"mn10300_mask_ok_for_mem_btst (INTVAL (operands[1]), INTVAL (operands[2]))\"\n   \"*\n {\n   int len = INTVAL (operands[1]);\n@@ -1644,7 +1647,7 @@\n \n   xoperands[0] = operands[0];\n   xoperands[1] = GEN_INT (trunc_int_for_mode (mask, SImode));\n-  if (GET_CODE (operands[0]) == REG)\n+  if (REG_P (operands[0]))\n     output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n   else\n     output_asm_insn (\\\"btst %U1,%A0\\\", xoperands);\n@@ -1710,11 +1713,12 @@\n      attribute is not set correctly on the jump insn.  */\n   emit_insn (gen_cmpsi (operands[0], operands[1]));\n   \n-  emit_jump_insn (gen_integer_conditional_branch (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n-\t\t\t\t\t\t \t\t CCmode,\n-\t\t\t\t \t\t \t\t gen_rtx_REG (CCmode, CC_REG),\n-\t\t\t\t\t\t\t\t const0_rtx),\n-\t\t\t\t\t          operands[2]));\n+  emit_jump_insn (gen_integer_conditional_branch\n+                      (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n+\t\t\t\t       CCmode,\n+\t\t \t\t       gen_rtx_REG (CCmode, CC_REG),\n+\t\t\t\t  \t            const0_rtx),\n+\t\t\t\t       operands[2]));\n   \"\n )\n \n@@ -1786,11 +1790,12 @@\n      attribute is not set correctly on the jump insn.  */\n   emit_insn (gen_am33_cmpsf (operands[0], operands[1]));\n   \n-  emit_jump_insn (gen_float_conditional_branch (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n-  \t\t \t\t\t       \t\t       CC_FLOATmode,\n- \t\t \t\t \t       \t\t       gen_rtx_REG (CC_FLOATmode, CC_REG),\n-\t\t\t\t\t\t\t       const0_rtx),\n-\t\t\t\t\t\toperands[2]));\n+  emit_jump_insn (gen_float_conditional_branch\n+                     (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n+\t\t\t\t      CC_FLOATmode,\n+ \t\t \t       \t      gen_rtx_REG (CC_FLOATmode, CC_REG),\n+\t\t\t\t      const0_rtx),\n+\t\t\t\t      operands[2]));\n   \"\n )\n \n@@ -1804,7 +1809,8 @@\n \n (define_insn \"float_conditional_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\" [(reg:CC_FLOAT CC_REG) (const_int 0)])\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(reg:CC_FLOAT CC_REG) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_AM33_2\"\n@@ -1950,9 +1956,9 @@\n ;; NB: Mode on match_operands 0 and 1 deliberately omitted\n ;;     in order to be able to match UNSPECs in PIC mode.\n (define_insn \"call_value_internal\"\n-  [(set (match_operand               0 \"register_operand\" \"=dax\")\n+  [(set (match_operand               0 \"register_operand\"    \"=dax\")\n \t(call (mem:QI (match_operand 1 \"call_address_operand\" \"aS\"))\n-\t      (match_operand:SI      2 \"general_operand\" \"g\")))]\n+\t      (match_operand:SI      2 \"general_operand\"      \"g\")))]\n   \"\"\n   \"*\n {\n@@ -2142,17 +2148,17 @@\n   \"TARGET_AM33\"\n   \"*\n {\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 1)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n     return \\\"add %0,%0\\\";\n \n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 2)\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 2)\n     return \\\"asl2 %0\\\";\n \n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 3\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 3\n       && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n     return \\\"asl2 %0\\;add %0,%0\\\";\n \n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 4\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 4\n       && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n     return \\\"asl2 %0\\;asl2 %0\\\";\n \n@@ -2418,8 +2424,11 @@\n )\n \n (define_expand \"sqrtsf2\"\n-  [(set (match_operand:SF          0 \"register_operand\")\n-\t(sqrt:SF (match_operand:SF 1 \"register_operand\")))]\n+  [(parallel [(set (match_operand:SF          0 \"register_operand\" \"\")\n+\t\t   (sqrt:SF (match_operand:SF 1 \"register_operand\" \"\")))\n+\t      (clobber (reg:CC_FLOAT CC_REG))\n+\t     ])\n+  ]\n   \"TARGET_AM33_2 && flag_unsafe_math_optimizations\"\n   \"\n {\n@@ -2455,7 +2464,7 @@\n (define_insn \"*addsf3_internal\"\n   [(set (match_operand:SF          0 \"register_operand\" \"=f,f\")\n \t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0,f\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"f,?fF\")))\n    (clobber (reg:CC_FLOAT CC_REG))\n   ]\n   \"TARGET_AM33_2\"\n@@ -2477,7 +2486,7 @@\n (define_insn \"*subsf3_internal\"\n   [(set (match_operand:SF           0 \"register_operand\" \"=f,f\")\n \t(minus:SF (match_operand:SF 1 \"register_operand\" \"0,f\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"f,?fF\")))\n+\t\t  (match_operand:SF 2 \"nonmemory_operand\" \"f,?fF\")))\n    (clobber (reg:CC_FLOAT CC_REG))\n   ]\n   \"TARGET_AM33_2\"\n@@ -2499,7 +2508,7 @@\n (define_insn \"*mulsf3_internal\"\n   [(set (match_operand:SF          0 \"register_operand\" \"=f,f\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0,f\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"f,?fF\")))\n   (clobber (reg:CC_FLOAT CC_REG))\n   ]\n   \"TARGET_AM33_2\"\n@@ -2570,14 +2579,14 @@\n (define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n-  \"expand_prologue (); DONE;\")\n+  \"mn10300_expand_prologue (); DONE;\")\n \n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n   \"\n {\n-  expand_epilogue ();\n+  mn10300_expand_epilogue ();\n   DONE;\n }\")\n \n@@ -2606,28 +2615,29 @@\n \n ;; This instruction matches one generated by mn10300_gen_multiple_store()\n (define_insn \"store_movm\"\n-  [(match_parallel 0 \"store_multiple_operation\"\n+  [(match_parallel 0 \"mn10300_store_multiple_operation\"\n     [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_operand 1 \"\" \"\")))])]\n   \"\"\n   \"*\n {\n   fputs (\\\"\\\\tmovm \\\", asm_out_file);\n   mn10300_print_reg_list (asm_out_file,\n-                          store_multiple_operation (operands[0], VOIDmode));\n+                          mn10300_store_multiple_operation (operands[0],\n+\t\t\t\t\t\t            VOIDmode));\n   fprintf (asm_out_file, \\\",(sp)\\\\n\\\");\n   return \\\"\\\";\n }\"\n )\n \n (define_insn \"return\"\n   [(return)]\n-  \"can_use_return_insn ()\"\n+  \"mn10300_can_use_return_insn ()\"\n   \"*\n {\n   rtx next = next_active_insn (insn);\n \n   if (next\n-      && GET_CODE (next) == JUMP_INSN\n+      && JUMP_P (next)\n       && GET_CODE (PATTERN (next)) == RETURN)\n     return \\\"\\\";\n   else"}]}