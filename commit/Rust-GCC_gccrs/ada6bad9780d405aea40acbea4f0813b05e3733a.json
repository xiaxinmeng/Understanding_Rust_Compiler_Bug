{"sha": "ada6bad9780d405aea40acbea4f0813b05e3733a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRhNmJhZDk3ODBkNDA1YWVhNDBhY2JlYTRmMDgxM2IwNWUzNzMzYQ==", "commit": {"author": {"name": "David Pagan", "email": "dave.pagan@oracle.com", "date": "2018-03-13T18:10:09Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2018-03-13T18:10:09Z"}, "message": "PR c/46921 Lost side effect when struct initializer expression uses comma operator\n\nThis patch fixes improper handling of comma operator expression in a\nstruct field initializer as described in:\n\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=46921\n\nCurrently, function output_init_element () does not evaluate the left\nhand expression in a comma operator that's used for a struct\ninitializer field if the right hand side is zero-sized. However, the\nleft hand expression must be evaluated if it's found to have side\neffects (for example, a function call).\n\nPatch was successfully bootstrapped and tested on x86_64-linux.\n\ngcc/c:\n2018-03-13  David Pagan  <dave.pagan@oracle.com>\n\n\tPR c/46921\n\t* c-typeck.c (output_init_element): Ensure field initializer\n\texpression is always evaluated if there are side effects.\n\ngcc/testsuite:\n2018-03-13  David Pagan  <dave.pagan@oracle.com>\n\n\tPR c/46921\n\t* gcc.dg/pr46921.c: New test.\n\nFrom-SVN: r258497", "tree": {"sha": "fb467b2bf55a3765f69f31dbf4f572aef4e42353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb467b2bf55a3765f69f31dbf4f572aef4e42353"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ada6bad9780d405aea40acbea4f0813b05e3733a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada6bad9780d405aea40acbea4f0813b05e3733a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada6bad9780d405aea40acbea4f0813b05e3733a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada6bad9780d405aea40acbea4f0813b05e3733a/comments", "author": null, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b34f5c5e69bb024f41b4e15869f7ff18c3f8dd6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34f5c5e69bb024f41b4e15869f7ff18c3f8dd6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b34f5c5e69bb024f41b4e15869f7ff18c3f8dd6f"}], "stats": {"total": 57, "additions": 55, "deletions": 2}, "files": [{"sha": "8147835935ceef5843f555570ff56cca39f195b2", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ada6bad9780d405aea40acbea4f0813b05e3733a", "patch": "@@ -1,3 +1,9 @@\n+2018-03-13  David Pagan  <dave.pagan@oracle.com>\n+\n+\tPR c/46921\n+\t* c-typeck.c (output_init_element): Ensure field initializer\n+\texpression is always evaluated if there are side effects.\n+\n 2018-03-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/84721"}, {"sha": "2ac85003ebb2059eff9ff0d207758227ad4e751f", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=ada6bad9780d405aea40acbea4f0813b05e3733a", "patch": "@@ -9208,12 +9208,14 @@ output_init_element (location_t loc, tree value, tree origtype,\n \t\t      \"enum conversion in initialization is invalid in C++\");\n     }\n \n-  /* If this field is empty (and not at the end of structure),\n-     don't do anything other than checking the initializer.  */\n+  /* If this field is empty and does not have side effects (and is not at\n+     the end of structure), don't do anything other than checking the\n+     initializer.  */\n   if (field\n       && (TREE_TYPE (field) == error_mark_node\n \t  || (COMPLETE_TYPE_P (TREE_TYPE (field))\n \t      && integer_zerop (TYPE_SIZE (TREE_TYPE (field)))\n+\t      && !TREE_SIDE_EFFECTS (new_value)\n \t      && (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t\t  || DECL_CHAIN (field)))))\n     return;"}, {"sha": "c518ebeff22b4e2d761fd0152dc2af64cf554f6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ada6bad9780d405aea40acbea4f0813b05e3733a", "patch": "@@ -1,3 +1,8 @@\n+2018-03-13  David Pagan  <dave.pagan@oracle.com>\n+\n+\tPR c/46921\n+\t* gcc.dg/pr46921.c: New test.\n+\n 2018-03-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/84725"}, {"sha": "17dfedd7e0a272dcc81666986310efdb0b9bde79", "filename": "gcc/testsuite/gcc.dg/pr46921.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46921.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada6bad9780d405aea40acbea4f0813b05e3733a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46921.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46921.c?ref=ada6bad9780d405aea40acbea4f0813b05e3733a", "patch": "@@ -0,0 +1,40 @@\n+/* PR c/46921  lost side effect when struct initializer expr uses comma\n+      operator  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+\n+extern int printf(const char *, ...);\n+extern void abort (void);\n+\n+typedef struct __uws_0 { } uw_unit;\n+uw_unit uw_unit_v = {};\n+\n+struct __uws_1 \n+{\n+  struct __uws_0 __uwf_1;\n+  struct __uws_1* __uwf_2;\n+};\n+\n+static int left_hand_eval = 0;\n+\n+static void\n+foo (const char *s)\n+{\n+  ++left_hand_eval;\n+  printf(\"%s\", s);\n+}\n+\n+int\n+main ()\n+{\n+  struct __uws_1 tmp = {(foo(\"Inner\\n\"), uw_unit_v)};\n+  \n+  printf(\"Outer\\n\");\n+  /* left hand expression in comma operator initializer must always be\n+     evaluated if there are side effects.  */\n+  if (!left_hand_eval)\n+    abort ();\n+  \n+  return 0;\n+}"}]}