{"sha": "dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQxOGFlNTYwNjU1MGYzYWJjYzY5NGU5Y2Y0ODJlZDU5NDFkZDhkNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-07-26T10:59:55Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-07-26T10:59:55Z"}, "message": "Replace %R%s with %r\n\nFrom-SVN: r28264", "tree": {"sha": "b553cdfae2be8ceb7caaaa186577f5f46aa2a787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b553cdfae2be8ceb7caaaa186577f5f46aa2a787"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/comments", "author": null, "committer": null, "parents": [{"sha": "fe0503eabfee54a8bf163c7d732519d8a27dcfc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0503eabfee54a8bf163c7d732519d8a27dcfc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe0503eabfee54a8bf163c7d732519d8a27dcfc4"}], "stats": {"total": 189, "additions": 95, "deletions": 94}, "files": [{"sha": "2b5ce97a7645f1abcfa57566caae19427f10b54f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "patch": "@@ -1,3 +1,8 @@\n+Mon Jul 26 11:58:46 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c: Replace %R%s in asm_fprintf strings with %r.\n+\t* config/arm/arm.h: Replace %R%s in asm_fprintf strings with %r.\n+\n Mon Jul 26 10:23:36 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* final.c (asm_fprintf): Accept ASM_FPRINTF_EXTENSIONS, if"}, {"sha": "2a15262f0989e79b37bbbf4f5040ce040b2a0bba", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 51, "deletions": 54, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "patch": "@@ -4409,16 +4409,18 @@ fp_const_from_val (r)\n    must follow the register list.  */\n \n void\n-print_multi_reg (stream, instr, mask, hat)\n+print_multi_reg (stream, instr, reg, mask, hat)\n      FILE * stream;\n      char * instr;\n-     int mask, hat;\n+     int reg;\n+     int mask;\n+     int hat;\n {\n   int i;\n   int not_first = FALSE;\n \n   fputc ('\\t', stream);\n-  fprintf (stream, instr, REGISTER_PREFIX);\n+  asm_fprintf (stream, instr, reg);\n   fputs (\", {\", stream);\n   \n   for (i = 0; i < 16; i++)\n@@ -4427,7 +4429,7 @@ print_multi_reg (stream, instr, mask, hat)\n \tif (not_first)\n \t  fprintf (stream, \", \");\n \t\n-\tasm_fprintf (stream, \"%R%s\", reg_names[i]);\n+\tasm_fprintf (stream, \"%r\", i);\n \tnot_first = TRUE;\n       }\n \n@@ -5557,15 +5559,15 @@ output_func_prologue (f, frame_size)\n   return_used_this_function = 0;\n   lr_save_eliminated = 0;\n   \n-  fprintf (f, \"\\t%s args = %d, pretend = %d, frame = %d\\n\",\n-\t   ASM_COMMENT_START, current_function_args_size,\n-\t   current_function_pretend_args_size, frame_size);\n-  fprintf (f, \"\\t%s frame_needed = %d, current_function_anonymous_args = %d\\n\",\n-\t   ASM_COMMENT_START, frame_pointer_needed,\n-\t   current_function_anonymous_args);\n+  asm_fprintf (f, \"\\t%@ args = %d, pretend = %d, frame = %d\\n\",\n+\t       current_function_args_size,\n+\t       current_function_pretend_args_size, frame_size);\n+  asm_fprintf (f, \"\\t%@ frame_needed = %d, current_function_anonymous_args = %d\\n\",\n+\t       frame_pointer_needed,\n+\t       current_function_anonymous_args);\n \n   if (volatile_func)\n-    fprintf (f, \"\\t%s Volatile function.\\n\", ASM_COMMENT_START);\n+    asm_fprintf (f, \"\\t%@ Volatile function.\\n\");\n \n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n@@ -5574,7 +5576,7 @@ output_func_prologue (f, frame_size)\n     if (regs_ever_live[reg] && ! call_used_regs[reg])\n       live_regs_mask |= (1 << reg);\n \n-  if (flag_pic && ! TARGET_SINGLE_PIC_BASE \n+  if (flag_pic && ! TARGET_SINGLE_PIC_BASE\n       && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n \n@@ -5602,13 +5604,11 @@ output_func_prologue (f, frame_size)\n     }\n \n   if (lr_save_eliminated)\n-    fprintf (f,\"\\t%s I don't think this function clobbers lr\\n\",\n-\t     ASM_COMMENT_START);\n+    asm_fprintf (f,\"\\t%@ I don't think this function clobbers lr\\n\");\n \n #ifdef AOF_ASSEMBLER\n   if (flag_pic)\n-    asm_fprintf (f, \"\\tmov\\t%R%s, %R%s\\n\", reg_names [IP_REGNUM],\n-\t\t reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", IP_REGNUM, PIC_OFFSET_TABLE_REGNUM);\n #endif\n }\n \n@@ -5671,8 +5671,8 @@ output_func_epilogue (f, frame_size)\n \t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n \t      {\n \t\tfloats_offset += 12;\n-\t\tasm_fprintf (f, \"\\tldfe\\t%R%s, [%R%s, #-%d]\\n\", \n-\t\t\t reg_names[reg], reg_names [FP_REGNUM], floats_offset);\n+\t\tasm_fprintf (f, \"\\tldfe\\t%r, [%r, #-%d]\\n\", \n+\t\t\t     reg, FP_REGNUM, floats_offset);\n \t      }\n \t}\n       else\n@@ -5688,39 +5688,38 @@ output_func_epilogue (f, frame_size)\n \t\t  /* We can't unstack more than four registers at once */\n \t\t  if (start_reg - reg == 3)\n \t\t    {\n-\t\t      asm_fprintf (f, \"\\tlfm\\t%R%s, 4, [%R%s, #-%d]\\n\",\n-\t\t\t           reg_names[reg], reg_names [FP_REGNUM],\n-\t\t\t\t   floats_offset);\n+\t\t      asm_fprintf (f, \"\\tlfm\\t%r, 4, [%r, #-%d]\\n\",\n+\t\t\t           reg, FP_REGNUM, floats_offset);\n \t\t      start_reg = reg - 1;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (reg != start_reg)\n-\t\t    asm_fprintf (f, \"\\tlfm\\t%R%s, %d, [%R%s, #-%d]\\n\",\n-\t\t\t\t reg_names [reg + 1], start_reg - reg,\n-\t\t\t\t reg_names [FP_REGNUM], floats_offset);\n+\t\t    asm_fprintf (f, \"\\tlfm\\t%r, %d, [%r, #-%d]\\n\",\n+\t\t\t\t reg + 1, start_reg - reg,\n+\t\t\t\t FP_REGNUM, floats_offset);\n \t\t  start_reg = reg - 1;\n \t\t}\n \t    }\n \n \t  /* Just in case the last register checked also needs unstacking.  */\n \t  if (reg != start_reg)\n-\t    asm_fprintf (f, \"\\tlfm\\t%R%s, %d, [%R%s, #-%d]\\n\",\n-\t\t\t reg_names [reg + 1], start_reg - reg,\n-\t\t\t reg_names [FP_REGNUM], floats_offset);\n+\t    asm_fprintf (f, \"\\tlfm\\t%r, %d, [%r, #-%d]\\n\",\n+\t\t\t reg + 1, start_reg - reg,\n+\t\t\t FP_REGNUM, floats_offset);\n \t}\n       \n       if (TARGET_INTERWORK)\n \t{\n \t  live_regs_mask |= 0x6800;\n-\t  print_multi_reg (f, \"ldmea\\t%sfp\", live_regs_mask, FALSE);\n-\t  asm_fprintf (f, \"\\tbx\\t%R%s\\n\", reg_names [LR_REGNUM]);\n+\t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask, FALSE);\n+\t  asm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n \t}\n       else\n \t{\n \t  live_regs_mask |= 0xA800;\n-\t  print_multi_reg (f, \"ldmea\\t%sfp\", live_regs_mask,\n+\t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask,\n \t\t\t   TARGET_APCS_32 ? FALSE : TRUE);\n \t}\n     }\n@@ -5739,8 +5738,8 @@ output_func_epilogue (f, frame_size)\n \t{\n \t  for (reg = 16; reg < 24; reg++)\n \t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t      asm_fprintf (f, \"\\tldfe\\t%R%s, [%R%s], #12\\n\",\n-\t\t\t   reg_names[reg], reg_names [SP_REGNUM]);\n+\t      asm_fprintf (f, \"\\tldfe\\t%r, [%r], #12\\n\",\n+\t\t\t   reg, SP_REGNUM);\n \t}\n       else\n \t{\n@@ -5752,27 +5751,26 @@ output_func_epilogue (f, frame_size)\n \t\t{\n \t\t  if (reg - start_reg == 3)\n \t\t    {\n-\t\t      asm_fprintf (f, \"\\tlfmfd\\t%R%s, 4, [%R%s]!\\n\",\n-\t\t\t\t   reg_names[start_reg], reg_names [SP_REGNUM]);\n+\t\t      asm_fprintf (f, \"\\tlfmfd\\t%r, 4, [%r]!\\n\",\n+\t\t\t\t   start_reg, SP_REGNUM);\n \t\t      start_reg = reg + 1;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (reg != start_reg)\n-\t\t    asm_fprintf (f, \"\\tlfmfd\\t%R%s, %d, [%R%s]!\\n\",\n-\t\t\t\t reg_names [start_reg], reg - start_reg,\n-\t\t\t\t reg_names [SP_REGNUM]);\n+\t\t    asm_fprintf (f, \"\\tlfmfd\\t%r, %d, [%r]!\\n\",\n+\t\t\t\t start_reg, reg - start_reg,\n+\t\t\t\t SP_REGNUM);\n \t\t  \n \t\t  start_reg = reg + 1;\n \t\t}\n \t    }\n \n \t  /* Just in case the last register checked also needs unstacking.  */\n \t  if (reg != start_reg)\n-\t    asm_fprintf (f, \"\\tlfmfd\\t%R%s, %d, [%R%s]!\\n\",\n-\t\t\t reg_names [start_reg], reg - start_reg,\n-\t\t\t reg_names [SP_REGNUM]);\n+\t    asm_fprintf (f, \"\\tlfmfd\\t%r, %d, [%r]!\\n\",\n+\t\t\t start_reg, reg - start_reg, SP_REGNUM);\n \t}\n \n       if (current_function_pretend_args_size == 0 && regs_ever_live[LR_REGNUM])\n@@ -5783,16 +5781,16 @@ output_func_epilogue (f, frame_size)\n \t\tlive_regs_mask |= 1 << LR_REGNUM;\n \n \t      if (live_regs_mask != 0)\n-\t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n+\t\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask, FALSE);\n \t      \n-\t      asm_fprintf (f, \"\\tbx\\t%R%s\\n\", reg_names [LR_REGNUM]);\n+\t      asm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n \t    }\n \t  else if (lr_save_eliminated)\n \t    asm_fprintf (f, \"\\tmov%c\\t%r, %r\\n\",\n \t\t\t TARGET_APCS_32 ? ' ' : 's',\n-\t\t\t reg_names [PC_REGNUM], reg_names [LR_REGNUM]);\n+\t\t\t PC_REGNUM, LR_REGNUM);\n \t  else\n-\t    print_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x8000,\n+\t    print_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask | 0x8000,\n \t\t\t     TARGET_APCS_32 ? FALSE : TRUE);\n \t}\n       else\n@@ -5804,7 +5802,7 @@ output_func_epilogue (f, frame_size)\n \t\tlive_regs_mask |= 1 << LR_REGNUM;\n \n \t      if (live_regs_mask != 0)\n-\t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n+\t\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask, FALSE);\n \t    }\n \n \t  if (current_function_pretend_args_size)\n@@ -5816,11 +5814,11 @@ output_func_epilogue (f, frame_size)\n \t    }\n \t  /* And finally, go home */\n \t  if (TARGET_INTERWORK)\n-\t    asm_fprintf (f, \"\\tbx\\t%R%s\\n\", reg_names [LR_REGNUM]);\n+\t    asm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n \t  else if (TARGET_APCS_32)\n-\t    asm_fprintf (f, \"\\tmov\\t%R%s, %R%s\\n\",  reg_names [PC_REGNUM], reg_names [LR_REGNUM]);\n+\t    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n \t  else\n-\t    asm_fprintf (f, \"\\tmovs\\t%R%s, %R%s\\n\", reg_names [PC_REGNUM], reg_names [LR_REGNUM]);\n+\t    asm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n \t}\n     }\n \n@@ -6129,9 +6127,8 @@ arm_print_operand (stream, x, code)\n       return;\n \n     case 'M':\n-      asm_fprintf (stream, \"{%R%s-%R%s}\",\n-\t\t   reg_names[REGNO (x)],\n-\t\t   reg_names[REGNO (x) + NUM_REGS (GET_MODE (x)) - 1]);\n+      asm_fprintf (stream, \"{%r-%r}\",\n+\t\t   REGNO (x), REGNO (x) + NUM_REGS (GET_MODE (x)) - 1);\n       return;\n \n     case 'd':\n@@ -6698,9 +6695,9 @@ aof_dump_pic_table (f)\n   if (aof_pic_chain == NULL)\n     return;\n \n-  asm_fprintf (f, \"\\tAREA |%R%s$$adcons|, BASED %R%s\\n\",\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n-\t       reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+  asm_fprintf (f, \"\\tAREA |%r$$adcons|, BASED %r\\n\",\n+\t       PIC_OFFSET_TABLE_REGNUM,\n+\t       PIC_OFFSET_TABLE_REGNUM);\n   fputs (\"|x$adcons|\\n\", f);\n   \n   for (chain = aof_pic_chain; chain; chain = chain->next)"}, {"sha": "43646ea7fa12102cca730ad102f5d2e0c30d77bb", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd18ae5606550f3abcc694e9cf482ed5941dd8d7/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=dd18ae5606550f3abcc694e9cf482ed5941dd8d7", "patch": "@@ -22,15 +22,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Configuration triples for ARM ports work as follows:\n-   (This is a bit of a mess and needs some thought)\n-   arm-*-*: little endian\n-   armel-*-*: little endian\n-   armeb-*-*: big endian\n-   If a non-embedded environment (ie: \"real\" OS) is specified, `arm'\n-   should default to that used by the OS.\n-*/\n-\n #ifndef __ARM_H__\n #define __ARM_H__\n \n@@ -316,11 +307,11 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define ARM_FLAG_NO_SCHED_PRO\t(1 << 12)\n \n /* Nonzero if a call to abort should be generated if a noreturn \n-function tries to return. */\n+   function tries to return.  */\n #define ARM_FLAG_ABORT_NORETURN\t(1 << 13)\n \n /* Nonzero if function prologues should not load the PIC register. */\n-#define ARM_FLAG_SINGLE_PIC_BASE\t(1 << 14)\n+#define ARM_FLAG_SINGLE_PIC_BASE (1 << 14)\n \n #define TARGET_APCS\t\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n #define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n@@ -343,7 +334,7 @@ function tries to return. */\n #define TARGET_INTERWORK\t\t(target_flags & ARM_FLAG_INTERWORK)\n #define TARGET_LITTLE_WORDS\t\t(target_flags & ARM_FLAG_LITTLE_WORDS)\n #define TARGET_NO_SCHED_PRO\t\t(target_flags & ARM_FLAG_NO_SCHED_PRO)\n-#define TARGET_ABORT_NORETURN           (target_flags & ARM_FLAG_ABORT_NORETURN)\n+#define TARGET_ABORT_NORETURN\t\t(target_flags & ARM_FLAG_ABORT_NORETURN)\n #define TARGET_SINGLE_PIC_BASE\t\t(target_flags & ARM_FLAG_SINGLE_PIC_BASE)\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.\n@@ -378,7 +369,7 @@ function tries to return. */\n      \"Load shorts a byte at a time\" },\t\t\t\t\\\n   {\"no-short-load-bytes\",      -ARM_FLAG_SHORT_BYTE, \"\" },\t\\\n   {\"short-load-words\",\t       -ARM_FLAG_SHORT_BYTE,\t\t\\\n-     \"Load shorts a word at a time\" },\t\t\t\t\\\n+     \"Load words a byte at a time\" },\t\t\t\t\\\n   {\"no-short-load-words\",\tARM_FLAG_SHORT_BYTE, \"\" },\t\\\n   {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT,\t\t\\\n      \"Use library calls to perform FP operations\" },\t\t\\\n@@ -395,13 +386,13 @@ function tries to return. */\n   {\"no-thumb-interwork\",       -ARM_FLAG_INTERWORK, \"\" },\t\\\n   {\"abort-on-noreturn\",         ARM_FLAG_ABORT_NORETURN,\t\\\n    \"Generate a call to abort if a noreturn function returns\"},\t\\\n-  {\"no-abort-on-noreturn\",      -ARM_FLAG_ABORT_NORETURN, \"\"},\t\\\n+  {\"no-abort-on-noreturn\",     -ARM_FLAG_ABORT_NORETURN, \"\"},\t\\\n   {\"sched-prolog\",             -ARM_FLAG_NO_SCHED_PRO,\t\t\\\n      \"Do not move instructions into a function's prologue\" },\t\\\n   {\"no-sched-prolog\",           ARM_FLAG_NO_SCHED_PRO, \"\" },\t\\\n   {\"single-pic-base\",\t\tARM_FLAG_SINGLE_PIC_BASE,\t\\\n      \"Do not load the PIC register in function prologues\" },\t\\\n-  {\"no-single-pic-base\",\t-ARM_FLAG_SINGLE_PIC_BASE, \"\" },\\\n+  {\"no-single-pic-base\",       -ARM_FLAG_SINGLE_PIC_BASE, \"\" },\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   {\"\",\t\t\t\tTARGET_DEFAULT }\t\t\\\n }\n@@ -760,6 +751,20 @@ extern const char * structure_size_string;\n   SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\t        \\\n }\n \n+/* These are a couple of extensions to the formats accecpted\n+   by asm_fprintf:\n+     %@ prints out ASM_COMMENT_START\n+     %r prints out REGISTER_PREFIX reg_names[arg]  */\n+#define ASM_FPRINTF_EXTENSIONS(FILE, ARGS, P)\t\t\\\n+  case '@':\t\t\t\t\t\t\\\n+    fputs (ASM_COMMENT_START, FILE);\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case 'r':\t\t\t\t\t\t\\\n+    fputs (REGISTER_PREFIX, FILE);\t\t\t\\\n+    fputs (reg_names [va_arg (ARGS, int)], FILE);\t\\\n+    break;\n+\n /* Convert fron bytes to ints.  */\n #define NUM_INTS(X) (((X) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n@@ -1234,9 +1239,8 @@ enum reg_class\n   char temp[20];\t\t\t\t\t\\\n   rtx sym;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n-  asm_fprintf (STREAM, \"\\tmov\\t%R%s, %R%s\\n\\tbl\\t\",\t\\\n-\t       reg_names[IP_REGNUM] /* ip */,\t\t\\\n-\t       reg_names[LR_REGNUM] /* lr */);\t\t\\\n+  asm_fprintf (STREAM, \"\\tmov\\t%r, %r\\n\\tbl\\t\",\t\t\\\n+\t       IP_REGNUM, LR_REGNUM);\t\t\t\\\n   assemble_name (STREAM, ARM_MCOUNT_NAME);\t\t\\\n   fputc ('\\n', STREAM);\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", LABELNO);\t\\\n@@ -1982,12 +1986,10 @@ extern struct rtx_def * arm_compare_op1;\n \n /* Output a push or a pop instruction (only used when profiling).  */\n #define ASM_OUTPUT_REG_PUSH(STREAM, REGNO) \\\n-  asm_fprintf (STREAM,\"\\tstmfd\\t%Rsp!,{%R%s}\\n\", \\\n-\t       reg_names [REGNO])\n+  asm_fprintf (STREAM,\"\\tstmfd\\t%r!,{%r}\\n\", SP_REGNUM, REGNO)\n \n #define ASM_OUTPUT_REG_POP(STREAM, REGNO) \\\n-  asm_fprintf (STREAM,\"\\tldmfd\\t%Rsp!,{%R%s}\\n\", \\\n-\t       reg_names [REGNO])\n+  asm_fprintf (STREAM,\"\\tldmfd\\t%r!,{%r}\\n\", SP_REGNUM, REGNO)\n \n #define ARM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) \t\\\n   do\t\t\t\t\t\t\t\\\n@@ -2033,12 +2035,12 @@ extern struct rtx_def * arm_compare_op1;\n     int is_minus = GET_CODE (X) == MINUS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-      asm_fprintf (STREAM, \"[%R%s, #0]\", reg_names[REGNO (X)]);\t\t\\\n+      asm_fprintf (STREAM, \"[%r, #0]\", REGNO (X));\t\t\t\\\n     else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \trtx base = XEXP (X, 0);\t\t\t\t\t\t\\\n \trtx index = XEXP (X, 1);\t\t\t\t\t\\\n-\tchar * base_reg_name;\t\t\t\t\t\t\\\n+\tint base_reg;\t\t\t\t\t\t\t\\\n \tHOST_WIDE_INT offset = 0;\t\t\t\t\t\\\n \tif (GET_CODE (base) != REG)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n@@ -2047,20 +2049,19 @@ extern struct rtx_def * arm_compare_op1;\n \t    base = index;\t\t\t\t\t\t\\\n \t    index = temp;\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n-\tbase_reg_name = reg_names[REGNO (base)];\t\t\t\\\n+\tbase_reg = REGNO (base);\t\t\t\t\t\\\n \tswitch (GET_CODE (index))\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t  case CONST_INT:\t\t\t\t\t\t\\\n \t    offset = INTVAL (index);\t\t\t\t\t\\\n \t    if (is_minus)\t\t\t\t\t\t\\\n \t      offset = -offset;\t\t\t\t\t\t\\\n-\t    asm_fprintf (STREAM, \"[%R%s, #%d]\", base_reg_name, offset);\t\\\n+\t    asm_fprintf (STREAM, \"[%r, #%d]\", base_reg, offset);\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case REG:\t\t\t\t\t\t\t\\\n-\t    asm_fprintf (STREAM, \"[%R%s, %s%R%s]\", \t\t\t\\\n-\t\t         base_reg_name, is_minus ? \"-\" : \"\",\t\t\\\n-\t\t         reg_names[REGNO (index)] );\t\t\t\\\n+\t    asm_fprintf (STREAM, \"[%r, %s%r]\", base_reg,\t\t\\\n+\t\t         is_minus ? \"-\" : \"\", REGNO (index));\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case MULT:\t\t\t\t\t\t\t\\\n@@ -2069,9 +2070,8 @@ extern struct rtx_def * arm_compare_op1;\n \t  case ASHIFT:\t\t\t\t\t\t\t\\\n \t  case ROTATERT:\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    asm_fprintf (STREAM, \"[%R%s, %s%R%s\", \t\t\t\\\n-\t\t         base_reg_name, is_minus ? \"-\" : \"\", \t\t\\\n-\t\t         reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n+\t    asm_fprintf (STREAM, \"[%r, %s%r\", base_reg,\t\t\t\\\n+\t\t         is_minus ? \"-\" : \"\", REGNO (XEXP (index, 0)));\t\\\n \t    arm_print_operand (STREAM, index, 'S');\t\t\t\\\n \t    fputs (\"]\", STREAM);\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n@@ -2090,13 +2090,13 @@ extern struct rtx_def * arm_compare_op1;\n \tabort ();\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n-\tasm_fprintf (STREAM, \"[%R%s, #%s%d]!\", \t\t\t\t\\\n-\t\t     reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n+\tasm_fprintf (STREAM, \"[%r, #%s%d]!\", \t\t\t\t\\\n+\t\t     REGNO (XEXP (X, 0)),\t\t\t\t\\\n \t\t     GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\\\n \t\t     GET_MODE_SIZE (output_memory_reference_mode));\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tasm_fprintf (STREAM, \"[%R%s], #%s%d\", \t\t\t\t\\\n-\t\t     reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n+\tasm_fprintf (STREAM, \"[%r], #%s%d\", \t\t\t\t\\\n+\t\t     REGNO (XEXP (X, 0)),\t\t\t\t\\\n \t\t     GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\\\n \t\t     GET_MODE_SIZE (output_memory_reference_mode));\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2146,17 +2146,16 @@ extern struct rtx_def * arm_compare_op1;\n \t    shift += 2;\t\t\t\t\t\t\t\t\\\n           else\t\t\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\t\\\n-\t      asm_fprintf (FILE, \"\\t%s\\t%R%s, %R%s, #%d\\n\",\t\t\t\\\n-\t\t           mi_op, reg_names[this_regno],\t\t\t\\\n-\t\t           reg_names[this_regno],\t\t\t\t\\\n+\t      asm_fprintf (FILE, \"\\t%s\\t%r, %r, #%d\\n\",\t\t\t\t\\\n+\t\t           mi_op, this_regno, this_regno,\t\t\t\\\n \t\t           mi_delta & (0xff << shift));\t\t\t\t\\\n \t      mi_delta &= ~(0xff << shift);\t\t\t\t\t\\\n \t      shift += 8;\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\t\\\n       fputs (\"\\tb\\t\", FILE);\t\t\t\t\t\t\t\\\n       assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t\t\\\n-      if (NEED_PLT_RELOC)\t\t\t\t\t\t\t\t\\\n+      if (NEED_PLT_RELOC)\t\t\t\t\t\t\t\\\n         fputs (\"(PLT)\", FILE);\t\t\t\t\t\t\t\\\n       fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\t\\"}]}