{"sha": "95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTViOWEzYTU1YzE1OGZjODdhYzQxNjRkODdmZGNjYWEzM2JmYThkZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-11-05T00:55:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-11-05T00:55:23Z"}, "message": "re PR rtl-optimization/23490 (Long compile time for array initializer with inlined constructor)\n\n\tPR rtl-optimization/23490\n\t* doc/invoke.texi (max-predicted-iterations, max-cse-insns,\n\tmax-flow-memory-location): Document.\n\t* flow.c: Include params.h\n\t(MAX_MEM_SET_LIST_LEN): Kill.\n\t(add_to_mem_set_list): Use new param.\n\t* cse.c (cse_basic_block): Replace 1000 by new param.\n\t* params.def (PARAM_MAX_PREDICTED_ITERATIONS, PARAM_MAX_CSE_INSNS,\n\tPARAM_MAX_FLOW_MEMORY_LOCATIONS): New.\n\t* predict.c (predict_loops): Use new param.\n\t* predict.def (MAX_PRED_LOOP_ITERATIONS): Remove.\n\nFrom-SVN: r106520", "tree": {"sha": "2528946d7ea31c1a4553fc28e301db2d6bfac0d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2528946d7ea31c1a4553fc28e301db2d6bfac0d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/comments", "author": null, "committer": null, "parents": [{"sha": "50fe876da0e0792b5cf55d7eba7dd30f0efbf1de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50fe876da0e0792b5cf55d7eba7dd30f0efbf1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50fe876da0e0792b5cf55d7eba7dd30f0efbf1de"}], "stats": {"total": 86, "additions": 60, "deletions": 26}, "files": [{"sha": "7f8e742789c1ae18c8db443fe63e82f6fc264417", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -1,5 +1,17 @@\n 2005-11-05  Jan Hubicka  <jh@suse.cz>\n \n+\tPR rtl-optimization/23490\n+\t* doc/invoke.texi (max-predicted-iterations, max-cse-insns,\n+\tmax-flow-memory-location): Document.\n+\t* flow.c: Include params.h\n+\t(MAX_MEM_SET_LIST_LEN): Kill.\n+\t(add_to_mem_set_list): Use new param.\n+\t* cse.c (cse_basic_block): Replace 1000 by new param.\n+\t* params.def (PARAM_MAX_PREDICTED_ITERATIONS, PARAM_MAX_CSE_INSNS,\n+\tPARAM_MAX_FLOW_MEMORY_LOCATIONS): New.\n+\t* predict.c (predict_loops): Use new param.\n+\t* predict.def (MAX_PRED_LOOP_ITERATIONS): Remove.\n+\n \t* ipa-inline.c (cgraph_decide_inlining_of_small_function, \n \tcgraph_decide_inlining, cgraph_decide_inlining_incrementally):\n \tDo not hold memory returned by cgraph_node_name across other call."}, {"sha": "ca9087b0c2f465bcc7a631d4f298a77ab16dfa2d", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -6890,7 +6890,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \n \t ??? This is a real kludge and needs to be done some other way.\n \t Perhaps for 2.9.  */\n-      if (code != NOTE && num_insns++ > 1000)\n+      if (code != NOTE && num_insns++ > PARAM_VALUE (PARAM_MAX_CSE_INSNS))\n \t{\n \t  flush_hash_table ();\n \t  num_insns = 0;"}, {"sha": "3e2189625a9336286e2a4ee799b8bc2cb083150e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -5935,6 +5935,13 @@ given basic block needs to have to be considered hot.\n Select fraction of the maximal frequency of executions of basic block in\n function given basic block needs to have to be considered hot\n \n+@item max-predicted-iterations\n+The maximum number of loop iterations we predict statically.  This is useful\n+in cases where function contain single loop with known bound and other loop\n+with unknown.  We predict the known number of iterations correctly, while\n+the unknown nummber of iterations average to roughly 10.  This means that the\n+loop without bounds would appear artifically cold relative to the other one.\n+\n @item tracer-dynamic-coverage\n @itemx tracer-dynamic-coverage-feedback\n \n@@ -5972,6 +5979,9 @@ order to make tracer effective.\n \n Maximum number of basic blocks on path that cse considers.  The default is 10.\n \n+@item max-cse-insns\n+The maximum instructions CSE process before flushing. The default is 1000.\n+\n @item global-var-threshold\n \n Counts the number of function calls (@var{n}) and the number of\n@@ -6033,6 +6043,10 @@ The maximum number of memory locations cselib should take into acount.\n Increasing values mean more aggressive optimization, making the compile time\n increase with probably slightly better performance.  The default value is 500.\n \n+@item max-flow-memory-location\n+Similar as @option{max-cselib-memory-location} but for dataflow liveness.\n+The default value is 100.\n+\n @item reorder-blocks-duplicate\n @itemx reorder-blocks-duplicate-feedback\n "}, {"sha": "1fc88b64f1f483a5e44e31d9e962460d458db47e", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -141,6 +141,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"obstack.h\"\n #include \"splay-tree.h\"\n #include \"tree-pass.h\"\n+#include \"params.h\"\n \n #ifndef HAVE_epilogue\n #define HAVE_epilogue 0\n@@ -283,10 +284,6 @@ static int ndead;\n \n static int *reg_deaths;\n \n-/* Maximum length of pbi->mem_set_list before we start dropping\n-   new elements on the floor.  */\n-#define MAX_MEM_SET_LIST_LEN\t100\n-\n /* Forward declarations */\n static int verify_wide_reg_1 (rtx *, void *);\n static void verify_wide_reg (int, basic_block);\n@@ -630,7 +627,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \n \t  /* We repeat regardless of what cleanup_cfg says.  If there were\n \t     instructions deleted above, that might have been only a\n-\t     partial improvement (see MAX_MEM_SET_LIST_LEN usage).\n+\t     partial improvement (see PARAM_MAX_FLOW_MEMORY_LOCATIONS  usage).\n \t     Further improvement may be possible.  */\n \t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \n@@ -2515,7 +2512,7 @@ add_to_mem_set_list (struct propagate_block_info *pbi, rtx mem)\n \t}\n     }\n \n-  if (pbi->mem_set_list_len < MAX_MEM_SET_LIST_LEN)\n+  if (pbi->mem_set_list_len < PARAM_VALUE (PARAM_MAX_FLOW_MEMORY_LOCATIONS))\n     {\n #ifdef AUTO_INC_DEC\n       /* Store a copy of mem, otherwise the address may be"}, {"sha": "a68557bce0917ed812c5eb349ee95b116f124e2d", "filename": "gcc/params.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -309,6 +309,22 @@ DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n \t \"hot-bb-frequency-fraction\",\n \t \"Select fraction of the maximal frequency of executions of basic block in function given basic block needs to have to be considered hot\",\n \t 1000, 0, 0)\n+\n+/* For guessed profiles, the loops having unknown number of iterations\n+   are predicted to iterate relatively few (10) times at average.\n+   For functions containing one loop with large known number of iterations\n+   and other loops having unbounded loops we would end up predicting all\n+   the other loops cold that is not usually the case.  So we need to artifically\n+   flatten the profile.  \n+\n+   We need to cut the maximal predicted iterations to large enought iterations\n+   so the loop appears important, but safely within HOT_BB_COUNT_FRACTION\n+   range.  */\n+\n+DEFPARAM(PARAM_MAX_PREDICTED_ITERATIONS,\n+\t \"max-predicted-iterations\",\n+\t \"The maximum number of loop iterations we predict statically\",\n+\t 100, 0, 0)\n DEFPARAM(TRACER_DYNAMIC_COVERAGE_FEEDBACK,\n \t \"tracer-dynamic-coverage-feedback\",\n \t \"The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available\",\n@@ -363,6 +379,10 @@ DEFPARAM(PARAM_MAX_CSE_PATH_LENGTH,\n \t \"max-cse-path-length\",\n \t \"The maximum length of path considered in cse\",\n \t 10, 0, 0)\n+DEFPARAM(PARAM_MAX_CSE_INSNS,\n+\t \"max-flow-memory-locations\",\n+\t \"The maximum instructions CSE process before flushing\",\n+\t 1000, 0, 0)\n \n /* The cost of expression in loop invariant motion that is considered\n    expensive.  */\n@@ -417,6 +437,10 @@ DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,\n \t \"max-cselib-memory-locations\",\n \t \"The maximum memory locations recorded by cselib\",\n \t 500, 0, 0)\n+DEFPARAM(PARAM_MAX_FLOW_MEMORY_LOCATIONS,\n+\t \"max-flow-memory-locations\",\n+\t \"The maximum memory locations recorded by flow\",\n+\t 100, 0, 0)\n \n #ifdef ENABLE_GC_ALWAYS_COLLECT\n # define GGC_MIN_EXPAND_DEFAULT 0"}, {"sha": "8f50ba0287b0ef733ce22bc9a71c562d9c1dd504", "filename": "gcc/predict.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -624,8 +624,9 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t      niter = desc.niter + 1;\n \t      if (niter == 0)        /* We might overflow here.  */\n \t\tniter = desc.niter;\n-\t      if (niter > MAX_PRED_LOOP_ITERATIONS)\n-\t\tniter = MAX_PRED_LOOP_ITERATIONS;\n+\t      if (niter\n+\t\t  > (unsigned int) PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS))\n+\t\tniter = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n \n \t      prob = (REG_BR_PROB_BASE\n \t\t      - (REG_BR_PROB_BASE + niter /2) / niter);\n@@ -653,19 +654,17 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t      if (TREE_CODE (niter) == INTEGER_CST)\n \t\t{\n \t\t  int probability;\n+\t\t  int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n \t\t  if (host_integerp (niter, 1)\n \t\t      && tree_int_cst_lt (niter,\n-\t\t\t\t          build_int_cstu (NULL_TREE,\n-\t\t\t\t\t\t MAX_PRED_LOOP_ITERATIONS - 1)))\n+\t\t\t\t          build_int_cstu (NULL_TREE, max - 1)))\n \t\t    {\n \t\t      HOST_WIDE_INT nitercst = tree_low_cst (niter, 1) + 1;\n \t\t      probability = ((REG_BR_PROB_BASE + nitercst / 2)\n \t\t\t\t     / nitercst);\n \t\t    }\n \t\t  else\n-\t\t    probability = ((REG_BR_PROB_BASE\n-\t\t\t\t    + MAX_PRED_LOOP_ITERATIONS / 2)\n-\t\t\t\t   / MAX_PRED_LOOP_ITERATIONS);\n+\t\t    probability = ((REG_BR_PROB_BASE + max / 2) / max);\n \n \t\t  predict_edge (exits[j], PRED_LOOP_ITERATIONS, probability);\n \t\t}"}, {"sha": "997f4d2cc987a765c665f4d8839fe86edaeb761c", "filename": "gcc/predict.def", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b9a3a55c158fc87ac4164d87fdccaa33bfa8df/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=95b9a3a55c158fc87ac4164d87fdccaa33bfa8df", "patch": "@@ -58,18 +58,6 @@ DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS,\n DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n \t       PRED_FLAG_FIRST_MATCH)\n \n-/* For guessed profiles, the loops having unknown number of iterations\n-   are predicted to iterate relatively few (10) times at average.\n-   For functions containing one loop with large known number of iterations\n-   and other loops having unbounded loops we would end up predicting all\n-   the other loops cold that is not usually the case.  So we need to artifically\n-   flatten the profile.  \n-\n-   We need to cut the maximal predicted iterations to large enought iterations\n-   so the loop appears important, but safely within HOT_BB_COUNT_FRACTION\n-   range.  */\n-#define MAX_PRED_LOOP_ITERATIONS 100\n-\n /* Hints dropped by user via __builtin_expect feature.  */\n DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n \t       PRED_FLAG_FIRST_MATCH)"}]}