{"sha": "993ef28f827140e0df07c81ff2b03e14059b052d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkzZWYyOGY4MjcxNDBlMGRmMDdjODFmZjJiMDNlMTQwNTliMDUyZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-09T21:13:29Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-09T21:13:29Z"}, "message": "re PR other/29975 ([meta-bugs] ICEs with CP2K)\n\n2006-12-09  Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29975\n\tPR fortran/30068\n\tPR fortran/30096\n\t* interface.c (compare_type_rank_if): Reject invalid generic\n\tinterfaces.\n\t(check_interface1): Give a warning for nonreferred to ambiguous\n\tinterfaces.\n\t(check_sym_interfaces): Check whether an ambiguous interface is\n\treferred to.  Do not check host associated interfaces since these\n\tcannot be ambiguous with the local versions.\n\t(check_uop_interface, gfc_check_interfaces): Update call to\n\tcheck_interface1.\n\t* symbol.c (gfc_get_sym_tree, gfc_get_sym_tree): Allow adding\n\tunambiguous procedures to generic interfaces.\n\t* gfortran.h (symbol_attribute): Added use_only and\n\tambiguous_interfaces.\n\t* module.c (load_need): Set the use_only flag, if needed.\n\t* resolve.c (resolve_fl_procedure): Warn for nonreferred\n\tinterfaces.\n\t* expr.c (find_array_section): Fix initializer array contructor.\n\n\n2006-12-09  Paul Thomas <pault@gcc.gnu.org>\n\t    Tobias Burnus <burnus@gcc.gnu.org>\n\n\tPR fortran/29975\n\tPR fortran/30068\n\t* gfortran.dg/interface_4.f90: Test adding procedure to generic\n\tinterface.\n\t* gfortran.dg/interface_5.f90: Test warning for not-referenced-to\n\tambiguous interfaces.\n\t* gfortran.dg/interface_6.f90: Test invalid, ambiguous interface.\n\t* gfortran.dg/interface_7.f90: Test invalid, ambiguous interface.\n\t* gfortran.dg/interface_8.f90: Test warning for not-referenced-to\n\tambiguous interfaces.\n\t* gfortran.dg/interface_1.f90: Change dg-error into a dg-warning.\n\t* gfortran.dg/array_initializer_2.f90: Add initializer array\n\tconstructor test.\n\n\tPR fortran/30096\n\t* gfortran.dg/interface_9.f90: Test that host interfaces are\n\tnot checked for ambiguity with the local version.\n\nCo-Authored-By: Tobias Burnus <burnus@gcc.gnu.org>\n\nFrom-SVN: r119697", "tree": {"sha": "c8776eb41194bb8dda5bb0ceb9bff152156493b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8776eb41194bb8dda5bb0ceb9bff152156493b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/993ef28f827140e0df07c81ff2b03e14059b052d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/993ef28f827140e0df07c81ff2b03e14059b052d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/993ef28f827140e0df07c81ff2b03e14059b052d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/993ef28f827140e0df07c81ff2b03e14059b052d/comments", "author": null, "committer": null, "parents": [{"sha": "1027275d2e6e9c34d1703406111ca2d7cab150dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1027275d2e6e9c34d1703406111ca2d7cab150dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1027275d2e6e9c34d1703406111ca2d7cab150dc"}], "stats": {"total": 367, "additions": 342, "deletions": 25}, "files": [{"sha": "c2a3464d54c1b1b037e9d494a2388449e21b023e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -1,3 +1,26 @@\n+2006-12-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29975\n+\tPR fortran/30068\n+\tPR fortran/30096\n+\t* interface.c (compare_type_rank_if): Reject invalid generic\n+\tinterfaces.\n+\t(check_interface1): Give a warning for nonreferred to ambiguous\n+\tinterfaces.\n+\t(check_sym_interfaces): Check whether an ambiguous interface is\n+\treferred to.  Do not check host associated interfaces since these\n+\tcannot be ambiguous with the local versions.\n+\t(check_uop_interface, gfc_check_interfaces): Update call to\n+\tcheck_interface1.\n+\t* symbol.c (gfc_get_sym_tree, gfc_get_sym_tree): Allow adding\n+\tunambiguous procedures to generic interfaces.\n+\t* gfortran.h (symbol_attribute): Added use_only and\n+\tambiguous_interfaces.\n+\t* module.c (load_need): Set the use_only flag, if needed.\n+\t* resolve.c (resolve_fl_procedure): Warn for nonreferred\n+\tinterfaces.\n+\t* expr.c (find_array_section): Fix initializer array contructor.\n+\n 2006-12-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29464"}, {"sha": "78cb9f07443d41ab109835e38e6de747a6294923", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -1189,7 +1189,8 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       for (d = 0; d < rank; d++)\n \t{\n \t  mpz_set (tmp_mpz, ctr[d]);\n-\t  mpz_sub_ui (tmp_mpz, tmp_mpz, one);\n+\t  mpz_sub (tmp_mpz, tmp_mpz,\n+\t\t   ref->u.ar.as->lower[d]->value.integer);\n \t  mpz_mul (tmp_mpz, tmp_mpz, delta[d]);\n \t  mpz_add (ptr, ptr, tmp_mpz);\n "}, {"sha": "8665ec9bb6a138e30e68d4817e25fae96eeabd97", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -483,7 +483,8 @@ typedef struct\n     dummy:1, result:1, assign:1, threadprivate:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n-    use_assoc:1;\t\t/* Symbol has been use-associated.  */\n+    use_assoc:1,\t\t/* Symbol has been use-associated.  */\n+    use_only:1;\t\t\t/* Symbol has been use-associated, with ONLY.  */\n \n   unsigned in_namelist:1, in_common:1, in_equivalence:1;\n   unsigned function:1, subroutine:1, generic:1, generic_copy:1;\n@@ -518,6 +519,9 @@ typedef struct\n      modification of type or type parameters is permitted.  */\n   unsigned referenced:1;\n \n+  /* Set if the symbol has ambiguous interfaces.  */\n+  unsigned ambiguous_interfaces:1;\n+\n   /* Set if the is the symbol for the main program.  This is the least\n      cumbersome way to communicate this function property without\n      strcmp'ing with __MAIN everywhere.  */"}, {"sha": "bcf95f51ee0f1ca4becd083f370a15cbdf2db75f", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -462,7 +462,9 @@ compare_type_rank_if (gfc_symbol * s1, gfc_symbol * s2)\n   if (s1->attr.function && compare_type_rank (s1, s2) == 0)\n     return 0;\n \n-  return compare_interfaces (s1, s2, 0);\t/* Recurse! */\n+  /* Originally, gfortran recursed here to check the interfaces of passed\n+     procedures.  This is explicitly not required by the standard.  */\n+  return 1;\n }\n \n \n@@ -965,7 +967,8 @@ check_interface0 (gfc_interface * p, const char *interface_name)\n \n static int\n check_interface1 (gfc_interface * p, gfc_interface * q0,\n-\t\t  int generic_flag, const char *interface_name)\n+\t\t  int generic_flag, const char *interface_name,\n+\t\t  int referenced)\n {\n   gfc_interface * q;\n   for (; p; p = p->next)\n@@ -979,12 +982,20 @@ check_interface1 (gfc_interface * p, gfc_interface * q0,\n \n \tif (compare_interfaces (p->sym, q->sym, generic_flag))\n \t  {\n-\t    gfc_error (\"Ambiguous interfaces '%s' and '%s' in %s at %L\",\n-\t\t       p->sym->name, q->sym->name, interface_name, &p->where);\n+\t    if (referenced)\n+\t      {\n+\t\tgfc_error (\"Ambiguous interfaces '%s' and '%s' in %s at %L\",\n+\t\t\t   p->sym->name, q->sym->name, interface_name,\n+\t\t\t   &p->where);\n+\t      }\n+\n+\t    if (!p->sym->attr.use_assoc && q->sym->attr.use_assoc)\n+\t      gfc_warning (\"Ambiguous interfaces '%s' and '%s' in %s at %L\",\n+\t\t\t   p->sym->name, q->sym->name, interface_name,\n+\t\t\t   &p->where);\n \t    return 1;\n \t  }\n       }\n-\n   return 0;\n }\n \n@@ -997,7 +1008,7 @@ static void\n check_sym_interfaces (gfc_symbol * sym)\n {\n   char interface_name[100];\n-  gfc_symbol *s2;\n+  int k;\n \n   if (sym->ns != gfc_current_ns)\n     return;\n@@ -1008,17 +1019,13 @@ check_sym_interfaces (gfc_symbol * sym)\n       if (check_interface0 (sym->generic, interface_name))\n \treturn;\n \n-      s2 = sym;\n-      while (s2 != NULL)\n-\t{\n-\t  if (check_interface1 (sym->generic, s2->generic, 1, interface_name))\n-\t    return;\n-\n-\t  if (s2->ns->parent == NULL)\n-\t    break;\n-\t  if (gfc_find_symbol (sym->name, s2->ns->parent, 1, &s2))\n-\t    break;\n-\t}\n+      /* Originally, this test was aplied to host interfaces too;\n+\t this is incorrect since host associated symbols, from any\n+\t source, cannot be ambiguous with local symbols.  */\n+      k = sym->attr.referenced || !sym->attr.use_assoc;\n+      if (check_interface1 (sym->generic, sym->generic, 1,\n+\t\t\t    interface_name, k))\n+\tsym->attr.ambiguous_interfaces = 1;\n     }\n }\n \n@@ -1040,7 +1047,8 @@ check_uop_interfaces (gfc_user_op * uop)\n       if (uop2 == NULL)\n \tcontinue;\n \n-      check_interface1 (uop->operator, uop2->operator, 0, interface_name);\n+      check_interface1 (uop->operator, uop2->operator, 0,\n+\t\t\tinterface_name, 1);\n     }\n }\n \n@@ -1082,7 +1090,7 @@ gfc_check_interfaces (gfc_namespace * ns)\n \n       for (ns2 = ns->parent; ns2; ns2 = ns2->parent)\n \tif (check_interface1 (ns->operator[i], ns2->operator[i], 0,\n-\t\t\t      interface_name))\n+\t\t\t      interface_name, 1))\n \t  break;\n     }\n "}, {"sha": "ca4e0913b18306e3e1665dc184af88ace08880d3", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -3228,6 +3228,8 @@ load_needed (pointer_info * p)\n \n   mio_symbol (sym);\n   sym->attr.use_assoc = 1;\n+  if (only_flag)\n+    sym->attr.use_only = 1;\n \n   return 1;\n }"}, {"sha": "0690dca46e501936999eed3d4e85501e425689d1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -5528,6 +5528,10 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n   gfc_formal_arglist *arg;\n   gfc_symtree *st;\n \n+  if (sym->attr.ambiguous_interfaces && !sym->attr.referenced)\n+    gfc_warning (\"Although not referenced, '%s' at %L has ambiguous \"\n+\t\t \"interfaces\", sym->name, &sym->declared_at);\n+\n   if (sym->attr.function\n \t&& resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;"}, {"sha": "a8090824718890a016030a9d963ac40eed5933ae", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -2037,7 +2037,9 @@ gfc_find_sym_tree (const char *name, gfc_namespace * ns, int parent_flag,\n       if (st != NULL)\n \t{\n \t  *result = st;\n-\t  if (st->ambiguous)\n+\t  /* Ambiguous generic interfaces are permitted, as long\n+\t     as the specific interfaces are different.  */\n+\t  if (st->ambiguous && !st->n.sym->attr.generic)\n \t    {\n \t      ambiguous_symbol (name, st);\n \t      return 1;\n@@ -2138,8 +2140,10 @@ gfc_get_sym_tree (const char *name, gfc_namespace * ns, gfc_symtree ** result)\n     }\n   else\n     {\n-      /* Make sure the existing symbol is OK.  */\n-      if (st->ambiguous)\n+      /* Make sure the existing symbol is OK.  Ambiguous\n+\t generic interfaces are permitted, as long as the\n+\t specific interfaces are different.  */\n+      if (st->ambiguous && !st->n.sym->attr.generic)\n \t{\n \t  ambiguous_symbol (name, st);\n \t  return 1;"}, {"sha": "2402aa803c04df405c22103a8fe1b0b09a659e40", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -1,3 +1,24 @@\n+2006-12-09  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@gcc.gnu.org>\n+\n+\tPR fortran/29975\n+\tPR fortran/30068\n+\t* gfortran.dg/interface_4.f90: Test adding procedure to generic\n+\tinterface.\n+\t* gfortran.dg/interface_5.f90: Test warning for not-referenced-to\n+\tambiguous interfaces.\n+\t* gfortran.dg/interface_6.f90: Test invalid, ambiguous interface.\n+\t* gfortran.dg/interface_7.f90: Test invalid, ambiguous interface.\n+\t* gfortran.dg/interface_8.f90: Test warning for not-referenced-to\n+\tambiguous interfaces.\n+\t* gfortran.dg/interface_1.f90: Change dg-error into a dg-warning.\n+\t* gfortran.dg/array_initializer_2.f90: Add initializer array\n+\tconstructor test.\n+\n+\tPR fortran/30096\n+\t* gfortran.dg/interface_9.f90: Test that host interfaces are\n+\tnot checked for ambiguity with the local version.\n+\n 2006-12-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29464"}, {"sha": "ef30b84d409176bb80d31b299eedf33ef5dfbff1", "filename": "gcc/testsuite/gfortran.dg/array_initializer_2.f90", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_2.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -2,6 +2,10 @@\n ! Tests the fix for PR28496 in which initializer array constructors with\n ! a missing initial array index would cause an ICE.\n !\n+! Test for the fix of the initializer array constructor part of PR29975\n+! was added later.  Here, the indexing would get in a mess if the array\n+! specification had a lower bound other than unity.\n+!\n ! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n ! Based on original test case from Samir Nordin  <snordin_ng@yahoo.fr> \n !\n@@ -11,7 +15,17 @@\n   integer, dimension(2,3), parameter :: d=reshape ((/c(3:2:-1,:)/),(/2,3/))\n   integer, dimension(3,3), parameter :: e=reshape ((/a(:),a(:)+3,a(:)+6/),(/3,3/))\n   integer, dimension(2,3), parameter :: f=reshape ((/c(2:1:-1,:)/),(/2,3/))\n+  CHARACTER (LEN=1), DIMENSION(3:7),  PARAMETER :: g =  &\n+    (/ '+', '-', '*', '/', '^' /)\n+  CHARACTER (LEN=3) :: h = \"A+C\"\n+!\n+! PR28496\n+!\n   if (any (b .ne. (/1,2,3/))) call abort ()\n   if (any (reshape(d,(/6/)) .ne. (/3, 2, 6, 5, 9, 8/))) call abort () \n   if (any (reshape(f,(/6/)) .ne. (/2, 1, 5, 4, 8, 7/))) call abort () \n+!\n+! PR29975\n+!\n+  IF (all(h(2:2) /= g(3:4))) call abort ()\n end"}, {"sha": "e520c0973aebfafafa4ec14d173098d43fcc6946", "filename": "gcc/testsuite/gfortran.dg/generic_7.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_7.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -24,4 +24,5 @@ SUBROUTINE sub_c(x, y)\n     WRITE(*,*) x, y\n   END SUBROUTINE\n END MODULE\n+\n ! { dg-final { cleanup-modules \"global\" } }"}, {"sha": "e170f870e1a4a39a31e3bc62b7b9b260b5430cf8", "filename": "gcc/testsuite/gfortran.dg/interface_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_1.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -27,7 +27,7 @@ module z\n   use y\n \n   interface ambiguous\n-    module procedure f    ! { dg-error \"in generic interface\" \"\" }\n+    module procedure f    ! { dg-warning \"in generic interface\" \"\" }\n   end interface\n \n   contains"}, {"sha": "8f6c3317eefaf4dd193ca3fb1a934424f0db84e3", "filename": "gcc/testsuite/gfortran.dg/interface_4.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_4.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! Tests the fix for the interface bit of PR29975, in which the\n+! interfaces bl_copy were rejected as ambiguous, even though\n+! they import different specific interfaces.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk> and\n+! simplified by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+SUBROUTINE RECOPY(N, c)\n+  real, INTENT(IN) :: N\n+  character(6) :: c\n+  c = \"recopy\"\n+END SUBROUTINE RECOPY\n+\n+MODULE f77_blas_extra\n+PUBLIC :: BL_COPY\n+INTERFACE BL_COPY\n+  MODULE PROCEDURE SDCOPY\n+END INTERFACE BL_COPY\n+CONTAINS\n+   SUBROUTINE SDCOPY(N, c)\n+    INTEGER, INTENT(IN) :: N\n+    character(6) :: c\n+    c = \"sdcopy\"\n+   END SUBROUTINE SDCOPY\n+END MODULE f77_blas_extra\n+\n+MODULE f77_blas_generic\n+INTERFACE BL_COPY\n+   SUBROUTINE RECOPY(N, c)\n+    real, INTENT(IN) :: N\n+    character(6) :: c\n+   END SUBROUTINE RECOPY\n+END INTERFACE BL_COPY\n+END MODULE f77_blas_generic\n+\n+program main\n+  USE f77_blas_extra\n+  USE f77_blas_generic\n+  character(6) :: chr\n+  call bl_copy(1, chr)\n+  if (chr /= \"sdcopy\") call abort ()\n+  call bl_copy(1.0, chr)\n+  if (chr /= \"recopy\") call abort ()  \n+end program main\n+! { dg-final { cleanup-modules \"f77_blas_generic f77_blas_extra\" } }"}, {"sha": "cc5a7129d4eca3ab7273b5c73b0c7574120c619b", "filename": "gcc/testsuite/gfortran.dg/interface_5.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_5.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile }\n+! Tests the fix for the interface bit of PR29975, in which the\n+! interfaces bl_copy were rejected as ambiguous, even though\n+! they import different specific interfaces.  In this testcase,\n+! it is verified that ambiguous specific interfaces are caught.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk> and\n+! simplified by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+SUBROUTINE RECOPY(N, c)\n+  real, INTENT(IN) :: N\n+  character(6) :: c\n+  print *, n\n+  c = \"recopy\"\n+END SUBROUTINE RECOPY\n+\n+MODULE f77_blas_extra\n+PUBLIC :: BL_COPY\n+INTERFACE BL_COPY\n+  MODULE PROCEDURE SDCOPY\n+END INTERFACE BL_COPY\n+CONTAINS\n+   SUBROUTINE SDCOPY(N, c)\n+    REAL, INTENT(IN) :: N\n+    character(6) :: c\n+    print *, n\n+    c = \"sdcopy\"\n+   END SUBROUTINE SDCOPY\n+END MODULE f77_blas_extra\n+\n+MODULE f77_blas_generic\n+INTERFACE BL_COPY\n+   SUBROUTINE RECOPY(N, c)\n+    real, INTENT(IN) :: N\n+    character(6) :: c\n+   END SUBROUTINE RECOPY\n+END INTERFACE BL_COPY\n+END MODULE f77_blas_generic\n+\n+subroutine i_am_ok\n+  USE f77_blas_extra ! { dg-warning \"ambiguous interfaces\" }\n+  USE f77_blas_generic\n+  character(6) :: chr\n+  chr = \"\"\n+  if (chr /= \"recopy\") call abort ()  \n+end subroutine i_am_ok\n+\n+program main\n+  USE f77_blas_extra ! { dg-error \"Ambiguous interfaces\" }\n+  USE f77_blas_generic\n+  character(6) :: chr\n+  chr = \"\"\n+  call bl_copy(1.0, chr)\n+  if (chr /= \"recopy\") call abort ()  \n+end program main\n+! { dg-final { cleanup-modules \"f77_blas_generic f77_blas_extra\" } }"}, {"sha": "2e7f85afa477de36299987ce97bec550c4e23e03", "filename": "gcc/testsuite/gfortran.dg/interface_6.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_6.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! One of the tests of the patch for PR30068.\n+! Taken from the fortran 2003 standard C11.2.\n+!\n+! The standard specifies that the optional arguments should be\n+! ignored in the counting of like type/kind, so the specific\n+! procedures below are invalid, even though actually unambiguous.\n+!\n+INTERFACE BAD8\n+  SUBROUTINE S8A(X,Y,Z)\n+    REAL,OPTIONAL :: X\n+    INTEGER :: Y\n+    REAL :: Z\n+  END SUBROUTINE S8A\n+  SUBROUTINE S8B(X,Z,Y)\n+    INTEGER,OPTIONAL :: X\n+    INTEGER :: Z\n+    REAL :: Y\n+  END SUBROUTINE S8B ! { dg-error \"Ambiguous interfaces\" }\n+END INTERFACE BAD8\n+real :: a, b\n+integer :: i, j\n+call bad8(x,i,b)\n+end"}, {"sha": "545211aec367a49e7dbe907c5ba7ad4d1ad0409c", "filename": "gcc/testsuite/gfortran.dg/interface_7.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_7.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+! One of the tests of the patch for PR30068.\n+!  Taken from the fortran 2003 standard C11.2.\n+!\n+! The interface is invalid although it is unambiguous because the\n+! standard explicitly does not require recursion into the formal\n+! arguments of procedures that themselves are interface arguments.\n+!\n+module x\n+  INTERFACE BAD9\n+    SUBROUTINE S9A(X)\n+      REAL :: X\n+    END SUBROUTINE S9A\n+    SUBROUTINE S9B(X)\n+      INTERFACE\n+        FUNCTION X(A)\n+          REAL :: X,A\n+        END FUNCTION X\n+      END INTERFACE\n+    END SUBROUTINE S9B\n+    SUBROUTINE S9C(X)\n+      INTERFACE\n+        FUNCTION X(A)\n+          REAL :: X\n+          INTEGER :: A\n+        END FUNCTION X\n+      END INTERFACE\n+    END SUBROUTINE S9C  ! { dg-error \"Ambiguous interfaces\" }\n+  END INTERFACE BAD9\n+end module x\n+\n+! { dg-final { cleanup-modules \"x\" } }"}, {"sha": "7feccb38b40765b30db7f4e20d08c16cd437f22d", "filename": "gcc/testsuite/gfortran.dg/interface_8.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_8.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+! One of the tests of the patch for PR30068.\n+! Taken from comp.lang.fortran 3rd December 2006.\n+!\n+! Although the generic procedure is not referenced and it would\n+! normally be permissible for it to be ambiguous, the USE, ONLY\n+! statement is effectively a reference and is invalid.\n+!\n+module mod1\n+   interface generic\n+      subroutine foo(a)\n+         real :: a\n+      end subroutine\n+   end interface generic\n+end module  mod1\n+\n+module mod2\n+   interface generic\n+      subroutine bar(a)\n+         real :: a\n+      end subroutine\n+   end interface generic\n+end module  mod2\n+\n+program main\n+  use mod1, only: generic   ! { dg-warning \"has ambiguous interfaces\" }\n+  use mod2\n+end program main\n+\n+! { dg-final { cleanup-modules \"mod1 mod2\" } }"}, {"sha": "b407ab0652404aaa7351dfecdcb1f8dc5dd4bd67", "filename": "gcc/testsuite/gfortran.dg/interface_9.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993ef28f827140e0df07c81ff2b03e14059b052d/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_9.f90?ref=993ef28f827140e0df07c81ff2b03e14059b052d", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do compile }\n+! Test of the patch for PR30096, in which gfortran incorrectly.\n+! compared local with host associated interfaces.\n+! \n+! Based on contribution by Harald Anlauf <anlauf@gmx.de>\n+!\n+module module1\n+  interface inverse\n+     module procedure A, B\n+  end interface\n+contains\n+  function A (X) result (Y)\n+    real                        :: X, Y\n+    Y = 1.0\n+  end function A\n+  function B (X) result (Y)\n+    integer                     :: X, Y\n+    Y = 3\n+  end function B\n+end module module1\n+\n+module module2\n+  interface inverse\n+     module procedure C\n+  end interface\n+contains\n+  function C (X) result (Y)\n+    real                        :: X, Y\n+    Y = 2.0\n+  end function C\n+end module module2\n+\n+program gfcbug48\n+  use module1, only : inverse\n+  call sub ()\n+  if (inverse(1.0_4) /= 1.0_4) call abort ()\n+  if (inverse(1_4) /= 3_4) call abort ()\n+contains\n+  subroutine sub ()\n+    use module2, only : inverse\n+    if (inverse(1.0_4) /= 2.0_4) call abort ()\n+    if (inverse(1_4) /= 3_4) call abort ()\n+  end subroutine sub\n+end program gfcbug48\n+\n+! { dg-final { cleanup-modules \"module1 module2\" } }\n+"}]}