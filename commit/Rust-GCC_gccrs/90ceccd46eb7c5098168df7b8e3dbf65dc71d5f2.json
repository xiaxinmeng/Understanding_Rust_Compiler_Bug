{"sha": "90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjZWNjZDQ2ZWI3YzUwOTgxNjhkZjdiOGUzZGJmNjVkYzcxZDVmMg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-03-25T18:23:40Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-03-25T18:23:40Z"}, "message": "mt_allocator.h (__mt_alloc<>::tune): Add _M_min_bin, the size in bytes of the smallest bin.\n\n2004-03-25  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/mt_allocator.h (__mt_alloc<>::tune):\n\tAdd _M_min_bin, the size in bytes of the smallest bin.\n\t(__mt_alloc<>::tune()): Tweak accordingly.\n\t(__mt_alloc<>::tune(size_t, ...)): Likewise.\n\t(__mt_alloc<>::block_record): Change to a union: members next\n\tand thread_id are never used at the same time.\n\t(__mt_alloc<>::allocate): Update consistently.\n\t(__mt_alloc<>::deallocate): Likewise.\n\t(__mt_alloc<>::_S_initialize): Update setups of _S_binmap and\n\t_S_bin_size for the configurable _M_min_size.\n\nFrom-SVN: r79962", "tree": {"sha": "038d9914d1aae06a5d0987462f8f103612eb5288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/038d9914d1aae06a5d0987462f8f103612eb5288"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2/comments", "author": null, "committer": null, "parents": [{"sha": "0d63bf21fc0d8c64807e65eea053af204742649c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d63bf21fc0d8c64807e65eea053af204742649c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d63bf21fc0d8c64807e65eea053af204742649c"}], "stats": {"total": 58, "additions": 38, "deletions": 20}, "files": [{"sha": "c5c7fd91fda7cb6f86acab31452cf6ada5931120", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2", "patch": "@@ -1,3 +1,16 @@\n+2004-03-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/mt_allocator.h (__mt_alloc<>::tune):\n+\tAdd _M_min_bin, the size in bytes of the smallest bin.\n+\t(__mt_alloc<>::tune()): Tweak accordingly.\n+\t(__mt_alloc<>::tune(size_t, ...)): Likewise.\n+\t(__mt_alloc<>::block_record): Change to a union: members next\n+\tand thread_id are never used at the same time.\n+\t(__mt_alloc<>::allocate): Update consistently.\n+\t(__mt_alloc<>::deallocate): Likewise.\n+\t(__mt_alloc<>::_S_initialize): Update setups of _S_binmap and\n+\t_S_bin_size for the configurable _M_min_size.\n+\n 2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n \n \t* include/bits/stl_list.h: Created a _List_impl class and made it"}, {"sha": "943cff7d439a4ffec40bef8114dcc45b423fe116", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=90ceccd46eb7c5098168df7b8e3dbf65dc71d5f2", "patch": "@@ -121,6 +121,9 @@ namespace __gnu_cxx\n \t// call will be used for requests larger than this value.\n \tsize_t\t_M_max_bytes; \n \n+\t// Size in bytes of the smallest bin (must be a power of 2).\n+\tsize_t  _M_min_bin;\n+\n \t// In order to avoid fragmenting and minimize the number of\n \t// new() calls we always request new memory using this\n \t// value. Based on previous discussions on the libstdc++\n@@ -144,7 +147,8 @@ namespace __gnu_cxx\n \tbool \t_M_force_new; \n      \n \texplicit tune() \n-\t: _M_max_bytes(128), _M_chunk_size(4096 - 4 * sizeof(void*)), \n+\t: _M_max_bytes(128), _M_min_bin(8),\n+\t  _M_chunk_size(4096 - 4 * sizeof(void*)), \n #ifdef __GTHREADS\n \t  _M_max_threads(4096), \n #else\n@@ -154,9 +158,9 @@ namespace __gnu_cxx\n \t  _M_force_new(getenv(\"GLIBCXX_FORCE_NEW\") ? true : false) \n \t{ }      \n \n-\texplicit tune(size_t __maxb, size_t __chunk, size_t __maxthreads, \n-\t\t\t size_t __headroom, bool __force) \n-\t: _M_max_bytes(__maxb), _M_chunk_size(__chunk), \n+\texplicit tune(size_t __maxb, size_t __minbin, size_t __chunk,\n+\t\t      size_t __maxthreads, size_t __headroom, bool __force) \n+\t: _M_max_bytes(__maxb), _M_min_bin(__minbin), _M_chunk_size(__chunk), \n \t  _M_max_threads(__maxthreads), _M_freelist_headroom(__headroom), \n \t  _M_force_new(__force)\n \t{ }      \n@@ -221,7 +225,7 @@ namespace __gnu_cxx\n       static size_t \n       _S_get_thread_id();\n \n-      struct block_record\n+      union block_record\n       {\n \t// Points to the next block_record for its thread_id.\n         block_record* volatile next;\n@@ -315,7 +319,8 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n \t  if (__gthread_active_p())\n \t    {\n-\t      const size_t bin_size = (1 << __which) + sizeof(block_record);\n+\t      const size_t bin_size = ((_S_options._M_min_bin << __which)\n+\t\t\t\t       + sizeof(block_record));\n \t      size_t block_count = _S_options._M_chunk_size / bin_size;\n \t      \n \t      __gthread_mutex_lock(__bin.mutex);\t      \n@@ -336,13 +341,10 @@ namespace __gnu_cxx\n \t\t    {\n \t\t      char* c = reinterpret_cast<char*>(block) + bin_size;\n \t\t      block->next = reinterpret_cast<block_record*>(c);\n-\t\t      block->thread_id = __thread_id;\n \t\t      block = block->next;\n \t\t      block_count--;\n \t\t    }\n-\t\t  \n \t\t  block->next = NULL;\n-\t\t  block->thread_id = __thread_id;\n \t\t}\n \t      else\n \t\t{\n@@ -356,7 +358,6 @@ namespace __gnu_cxx\n \t\t      block->next = __bin.first[__thread_id];\n \t\t      __bin.first[__thread_id] = block;\t\t      \n \t\t      \n-\t\t      block->thread_id = __thread_id;\n \t\t      __bin.free[__thread_id]++;\n \t\t      __bin.first[0] = tmp;\n \t\t      global_count++;\n@@ -368,6 +369,7 @@ namespace __gnu_cxx\n \t      // update the counters\n \t      block = __bin.first[__thread_id];\n \t      __bin.first[__thread_id] = __bin.first[__thread_id]->next; \n+\t      block->thread_id = __thread_id;\n \t      __bin.free[__thread_id]--;\n \t      __bin.used[__thread_id]++;\n \t    }\n@@ -377,7 +379,8 @@ namespace __gnu_cxx\n \t      void* __v = ::operator new(_S_options._M_chunk_size);\n \t      __bin.first[0] = static_cast<block_record*>(__v);\n \t      \n-\t      const size_t bin_size = (1 << __which) + sizeof(block_record);\n+\t      const size_t bin_size = ((_S_options._M_min_bin << __which)\n+\t\t\t\t       + sizeof(block_record));\n \t      size_t block_count = _S_options._M_chunk_size / bin_size;\n \t      \n \t      block_count--;\n@@ -400,8 +403,9 @@ namespace __gnu_cxx\n \t{\n \t  // \"Default\" operation - we have blocks on our own freelist\n \t  // grab the first record and update the counters.\n-\t  block = __bin.first[__thread_id];\t  \n+\t  block = __bin.first[__thread_id];\n \t  __bin.first[__thread_id] = __bin.first[__thread_id]->next;\n+\t  block->thread_id = __thread_id;\n \n #ifdef __GTHREADS\n \t  if (__gthread_active_p())\n@@ -450,7 +454,8 @@ namespace __gnu_cxx\n \t  // much contention when locking and therefore we wait until\n \t  // the number of records is \"high enough\".\n \t  int __cond1 = static_cast<int>(100 * (_S_bin_size - __which));\n-\t  int __cond2 = static_cast<int>(__bin.free[thread_id] / _S_options._M_freelist_headroom);\n+\t  int __cond2 = static_cast<int>(__bin.free[thread_id]\n+\t\t\t\t\t / _S_options._M_freelist_headroom);\n \t  if (remove > __cond1 && remove > __cond2)\n \t    {\n \t      __gthread_mutex_lock(__bin.mutex);\n@@ -470,13 +475,12 @@ namespace __gnu_cxx\n \t  \n \t  // Return this block to our list and update counters and\n \t  // owner id as needed.\n+\t  __bin.used[block->thread_id]--;\n+\n \t  block->next = __bin.first[thread_id];\n \t  __bin.first[thread_id] = block;\n \t  \n \t  __bin.free[thread_id]++;\n-\t  \n-\t  __bin.used[block->thread_id]--;\n-\t  block->thread_id = thread_id;\n \t}\n       else\n #endif\n@@ -497,10 +501,10 @@ namespace __gnu_cxx\n \n       // Calculate the number of bins required based on _M_max_bytes.\n       // _S_bin_size is statically-initialized to one.\n-      size_t __bin_size = 1;\n+      size_t __bin_size = _S_options._M_min_bin;\n       while (_S_options._M_max_bytes > __bin_size)\n \t{\n-\t  __bin_size = __bin_size << 1;\n+\t  __bin_size <<= 1;\n \t  _S_bin_size++;\n \t}\n \n@@ -509,7 +513,7 @@ namespace __gnu_cxx\n       _S_binmap = static_cast<binmap_type*>(::operator new(__j));\n \n       binmap_type* __bp = _S_binmap;\n-      binmap_type __bin_max = 1;\n+      binmap_type __bin_max = _S_options._M_min_bin;\n       binmap_type __bint = 0;\n       for (binmap_type __ct = 0; __ct <= _S_options._M_max_bytes; __ct++)\n         {\n@@ -625,7 +629,8 @@ namespace __gnu_cxx\n       // returns it's id.\n       if (__gthread_active_p())\n         {\n-          thread_record* __freelist_pos = static_cast<thread_record*>(__gthread_getspecific(_S_thread_key)); \n+          thread_record* __freelist_pos =\n+\t    static_cast<thread_record*>(__gthread_getspecific(_S_thread_key)); \n \t  if (__freelist_pos == NULL)\n             {\n \t      // Since _S_options._M_max_threads must be larger than"}]}