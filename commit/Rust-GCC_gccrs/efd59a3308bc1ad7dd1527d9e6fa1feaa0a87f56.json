{"sha": "efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZkNTlhMzMwOGJjMWFkN2RkMTUyN2Q5ZTZmYTFmZWFhMGE4N2Y1Ng==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-01-13T10:46:45Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-01-13T10:46:45Z"}, "message": "cccp.c (xstrdup): Renamed from `savestring'.\n\n        * cccp.c (xstrdup): Renamed from `savestring'.  All callers changed.\n        Remove prototype which we get from libiberty.h.\n        * collect2.c (xstrdup): Likewise.\n        * genextract.c (xstrdup): Likewise for `copystr'.\n        (mybzero): Remove it and use `memset' instead.\n        * genoutput.c (mybcopy, mybzero): Remove these.  All callers changed\n        to use `memcpy' and `memset' instead.\n        * genrecog.c (xstrdup): Renamed from `copystr'.  All callers\n        changed.  Remove prototype.\n        (mybcopy, mybzero): Remove these and use memcpy/memset.\n\nFrom-SVN: r24650", "tree": {"sha": "bf643739547223da4478feeee08ef27e41880c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf643739547223da4478feeee08ef27e41880c22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/comments", "author": null, "committer": null, "parents": [{"sha": "9684789222a5e8e34eac4565cd42f4e848a942fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9684789222a5e8e34eac4565cd42f4e848a942fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9684789222a5e8e34eac4565cd42f4e848a942fc"}], "stats": {"total": 282, "additions": 116, "deletions": 166}, "files": [{"sha": "8342b555aa19805ba5601e55570d077de794a5ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "patch": "@@ -1,3 +1,20 @@\n+Wed Jan 13 13:30:08 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cccp.c (xstrdup): Renamed from `savestring'.  All callers changed.\n+\tRemove prototype which we get from libiberty.h.\n+\n+\t* collect2.c (xstrdup): Likewise.\n+\n+\t* genextract.c (xstrdup): Likewise for `copystr'.\n+\t(mybzero): Remove it and use `memset' instead.\n+\n+\t* genoutput.c (mybcopy, mybzero): Remove these.  All callers changed\n+\tto use `memcpy' and `memset' instead.\n+\n+\t* genrecog.c (xstrdup): Renamed from `copystr'.  All callers\n+ \tchanged.  Remove prototype.\n+\t(mybcopy, mybzero): Remove these and use memcpy/memset.\n+\n Wed Jan 13 00:59:04 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* mips.h (LOAD_EXTEND_OP): Correct for SImode and CCmode moves when"}, {"sha": "44c7e5d9b2c610a670d1d24372bdf584efcade11", "filename": "gcc/cccp.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "patch": "@@ -1042,7 +1042,6 @@ static void pfatal_with_name PROTO((char *)) __attribute__ ((noreturn));\n static void pipe_closed PROTO((int)) __attribute__ ((noreturn));\n \n static void memory_full PROTO((void)) __attribute__ ((noreturn));\n-static char *savestring PROTO((char *));\n static void print_help PROTO((void));\n \f\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n@@ -1276,7 +1275,7 @@ main (argc, argv)\n   {\n     /* Remove extension from PROGNAME.  */\n     char *p;\n-    char *s = progname = savestring (progname);\n+    char *s = progname = xstrdup (progname);\n \n     if ((p = rindex (s, ';')) != 0) *p = '\\0';\t/* strip version number */\n     if ((p = rindex (s, '.')) != 0\t\t/* strip type iff \".exe\" */\n@@ -1378,7 +1377,7 @@ main (argc, argv)\n \t  if (include_prefix != 0)\n \t    prefix = include_prefix;\n \t  else {\n-\t    prefix = savestring (GCC_INCLUDE_DIR);\n+\t    prefix = xstrdup (GCC_INCLUDE_DIR);\n \t    /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n \t    if (!strcmp (prefix + strlen (prefix) - 8, \"/include\"))\n \t      prefix[strlen (prefix) - 7] = 0;\n@@ -1403,7 +1402,7 @@ main (argc, argv)\n \t  if (include_prefix != 0)\n \t    prefix = include_prefix;\n \t  else {\n-\t    prefix = savestring (GCC_INCLUDE_DIR);\n+\t    prefix = xstrdup (GCC_INCLUDE_DIR);\n \t    /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n \t    if (!strcmp (prefix + strlen (prefix) - 8, \"/include\"))\n \t      prefix[strlen (prefix) - 7] = 0;\n@@ -1977,7 +1976,7 @@ main (argc, argv)\n \tif (c == PATH_SEPARATOR || !c) {\n \t  endp[-1] = 0;\n \t  include_defaults[num_dirs].fname\n-\t    = startp == endp ? \".\" : savestring (startp);\n+\t    = startp == endp ? \".\" : xstrdup (startp);\n \t  endp[-1] = c;\n \t  include_defaults[num_dirs].component = 0;\n \t  include_defaults[num_dirs].cplusplus = cplusplus;\n@@ -2003,7 +2002,7 @@ main (argc, argv)\n   if (!no_standard_includes) {\n     struct default_include *p = include_defaults;\n     char *specd_prefix = include_prefix;\n-    char *default_prefix = savestring (GCC_INCLUDE_DIR);\n+    char *default_prefix = xstrdup (GCC_INCLUDE_DIR);\n     int default_len = 0;\n     /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n     if (!strcmp (default_prefix + strlen (default_prefix) - 8, \"/include\")) {\n@@ -5067,7 +5066,7 @@ read_name_map (dirname)\n \n   map_list_ptr = ((struct file_name_map_list *)\n \t\t  xmalloc (sizeof (struct file_name_map_list)));\n-  map_list_ptr->map_list_name = savestring (dirname);\n+  map_list_ptr->map_list_name = xstrdup (dirname);\n   map_list_ptr->map_list_map = NULL;\n \n   dirlen = strlen (dirname);\n@@ -10762,13 +10761,13 @@ xcalloc (number, size)\n   return ptr;\n }\n \n-static char *\n-savestring (input)\n-     char *input;\n+char *\n+xstrdup (input)\n+  const char *input;\n {\n-  size_t size = strlen (input);\n-  char *output = xmalloc (size + 1);\n-  strcpy (output, input);\n+  register size_t len = strlen (input) + 1;\n+  register char *output = xmalloc (len);\n+  memcpy (output, input, len);\n   return output;\n }\n \f"}, {"sha": "2184e0e23983093d2e43f8c06a4bf8da9788c742", "filename": "gcc/collect2.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "patch": "@@ -1,6 +1,6 @@\n /* Collect static initialization info into data structures that can be\n    traversed by C++ initialization and finalization routines.\n-   Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.\n    Contributed by Chris Smith (csmith@convex.com).\n    Heavily modified by Michael Meissner (meissner@cygnus.com),\n    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).\n@@ -551,13 +551,12 @@ file_exists (name)\n /* Make a copy of a string INPUT with size SIZE.  */\n \n char *\n-savestring (input, size)\n-     char *input;\n-     int size;\n+xstrdup (input)\n+  const char *input;\n {\n-  char *output = (char *) xmalloc (size + 1);\n-  bcopy (input, output, size);\n-  output[size] = 0;\n+  register size_t len = strlen (input) + 1;\n+  register char *output = xmalloc (len);\n+  memcpy (output, input, len);\n   return output;\n }\n \n@@ -874,7 +873,7 @@ add_prefix (pprefix, prefix)\n     pprefix->max_len = len;\n \n   pl = (struct prefix_list *) xmalloc (sizeof (struct prefix_list));\n-  pl->prefix = savestring (prefix, len);\n+  pl->prefix = xstrdup (prefix);\n \n   if (*prev)\n     pl->next = *prev;"}, {"sha": "6340490f27f0d16e3a09b37509458834311b5b71", "filename": "gcc/genextract.c", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "patch": "@@ -1,5 +1,5 @@\n /* Generate code from machine description to extract operands from insn as rtl.\n-   Copyright (C) 1987, 91, 92, 93, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-93, 97-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -100,8 +100,6 @@ static void walk_rtx PROTO ((rtx, const char *));\n static void print_path PROTO ((char *));\n static void fatal PVPROTO ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-static char *copystr PROTO ((const char *));\n-static void mybzero ();\n void fancy_abort PROTO ((void)) ATTRIBUTE_NORETURN;\n \f\n static void\n@@ -116,7 +114,7 @@ gen_insn (insn)\n   dup_count = 0;\n \n   /* No operands seen so far in this pattern.  */\n-  mybzero (oplocs, sizeof oplocs);\n+  memset (oplocs, 0, sizeof oplocs);\n \n   /* Walk the insn's pattern, remembering at all times the path\n      down to the walking point.  */\n@@ -211,19 +209,19 @@ walk_rtx (x, path)\n \n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n-      oplocs[XINT (x, 0)] = copystr (path);\n+      oplocs[XINT (x, 0)] = xstrdup (path);\n       op_count = MAX (op_count, XINT (x, 0) + 1);\n       break;\n \n     case MATCH_DUP:\n     case MATCH_PAR_DUP:\n-      duplocs[dup_count] = copystr (path);\n+      duplocs[dup_count] = xstrdup (path);\n       dupnums[dup_count] = XINT (x, 0);\n       dup_count++;\n       break;\n \n     case MATCH_OP_DUP:\n-      duplocs[dup_count] = copystr (path);\n+      duplocs[dup_count] = xstrdup (path);\n       dupnums[dup_count] = XINT (x, 0);\n       dup_count++;\n       \n@@ -239,7 +237,7 @@ walk_rtx (x, path)\n       return;\n       \n     case MATCH_OPERATOR:\n-      oplocs[XINT (x, 0)] = copystr (path);\n+      oplocs[XINT (x, 0)] = xstrdup (path);\n       op_count = MAX (op_count, XINT (x, 0) + 1);\n \n       newpath = (char *) alloca (depth + 2);\n@@ -254,7 +252,7 @@ walk_rtx (x, path)\n       return;\n \n     case MATCH_PARALLEL:\n-      oplocs[XINT (x, 0)] = copystr (path);\n+      oplocs[XINT (x, 0)] = xstrdup (path);\n       op_count = MAX (op_count, XINT (x, 0) + 1);\n \n       newpath = (char *) alloca (depth + 2);\n@@ -398,28 +396,14 @@ fancy_abort ()\n   fatal (\"Internal gcc abort.\");\n }\n \n-static char *\n-copystr (s1)\n-  const char *s1;\n+char *\n+xstrdup (s1)\n+  const char *input;\n {\n-  register char *tem;\n-\n-  if (s1 == 0)\n-    return 0;\n-\n-  tem = (char *) xmalloc (strlen (s1) + 1);\n-  strcpy (tem, s1);\n-\n-  return tem;\n-}\n-\n-static void\n-mybzero (b, length)\n-     register char *b;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *b++ = 0;\n+  register size_t len = strlen (input) + 1;\n+  register char *output = xmalloc (len);\n+  memcpy (output, input, len);\n+  return output;\n }\n \f\n int"}, {"sha": "eaa4461c3041147fdfbd492ef23d3bba29c79819", "filename": "gcc/genoutput.c", "status": "modified", "additions": 53, "deletions": 74, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "patch": "@@ -1,5 +1,5 @@\n /* Generate code from to output assembler insns as recognized from rtl.\n-   Copyright (C) 1987, 88, 92, 94, 95, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92, 94-95, 97-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -111,8 +111,6 @@ static void fatal PVPROTO ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n void fancy_abort PROTO((void)) ATTRIBUTE_NORETURN;\n static void error PVPROTO ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-static void mybcopy ();\n-static void mybzero ();\n static int n_occurrences PROTO((int, char *));\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n@@ -684,26 +682,26 @@ gen_insn (insn)\n   max_opno = -1;\n   num_dups = 0;\n \n-  mybzero (constraints, sizeof constraints);\n-  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n-  mybzero (predicates, sizeof predicates);\n-  mybzero (address_p, sizeof address_p);\n-  mybzero (modes, sizeof modes);\n-  mybzero (strict_low, sizeof strict_low);\n-  mybzero (seen, sizeof seen);\n+  memset (constraints, 0, sizeof constraints);\n+  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n+  memset (predicates, 0, sizeof predicates);\n+  memset (address_p, 0, sizeof address_p);\n+  memset (modes, 0, sizeof modes);\n+  memset (strict_low, 0, sizeof strict_low);\n+  memset (seen, 0, sizeof seen);\n \n   for (i = 0; i < XVECLEN (insn, 1); i++)\n     scan_operands (XVECEXP (insn, 1, i), 0, 0);\n \n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n \n-  mybcopy (constraints, d->constraints, sizeof constraints);\n-  mybcopy (op_n_alternatives, d->op_n_alternatives, sizeof op_n_alternatives);\n-  mybcopy (predicates, d->predicates, sizeof predicates);\n-  mybcopy (address_p, d->address_p, sizeof address_p);\n-  mybcopy (modes, d->modes, sizeof modes);\n-  mybcopy (strict_low, d->strict_low, sizeof strict_low);\n+  memcpy (d->constraints, constraints, sizeof constraints);\n+  memcpy (d->op_n_alternatives, op_n_alternatives, sizeof op_n_alternatives);\n+  memcpy (d->predicates, predicates, sizeof predicates);\n+  memcpy (d->address_p, address_p, sizeof address_p);\n+  memcpy (d->modes, modes, sizeof modes);\n+  memcpy (d->strict_low, strict_low, sizeof strict_low);\n \n   validate_insn_alternatives (d);\n   process_template (d, XSTR (insn, 3));\n@@ -735,13 +733,13 @@ gen_peephole (peep)\n   end_of_insn_data = d;\n \n   max_opno = -1;\n-  mybzero (constraints, sizeof constraints);\n-  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n-  mybzero (predicates, sizeof predicates);\n-  mybzero (address_p, sizeof address_p);\n-  mybzero (modes, sizeof modes);\n-  mybzero (strict_low, sizeof strict_low);\n-  mybzero (seen, sizeof seen);\n+  memset (constraints, 0, sizeof constraints);\n+  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n+  memset (predicates, 0, sizeof predicates);\n+  memset (address_p, 0, sizeof address_p);\n+  memset (modes, 0, sizeof modes);\n+  memset (strict_low, 0, sizeof strict_low);\n+  memset (seen, 0, sizeof seen);\n \n   /* Get the number of operands by scanning all the\n      patterns of the peephole optimizer.\n@@ -752,12 +750,12 @@ gen_peephole (peep)\n   d->n_operands = max_opno + 1;\n   d->n_dups = 0;\n \n-  mybcopy (constraints, d->constraints, sizeof constraints);\n-  mybcopy (op_n_alternatives, d->op_n_alternatives, sizeof op_n_alternatives);\n-  mybzero (d->predicates, sizeof predicates);\n-  mybzero (d->address_p, sizeof address_p);\n-  mybzero (d->modes, sizeof modes);\n-  mybzero (d->strict_low, sizeof strict_low);\n+  memcpy (d->constraints, constraints, sizeof constraints);\n+  memcpy (d->op_n_alternatives, op_n_alternatives, sizeof op_n_alternatives);\n+  memset (d->predicates, 0, sizeof predicates);\n+  memset (d->address_p, 0, sizeof address_p);\n+  memset (d->modes, 0, sizeof modes);\n+  memset (d->strict_low, 0, sizeof strict_low);\n \n   validate_insn_alternatives (d);\n   process_template (d, XSTR (peep, 2));\n@@ -796,13 +794,13 @@ gen_expand (insn)\n   /* Scan the operands to get the specified predicates and modes,\n      since expand_binop needs to know them.  */\n \n-  mybzero (constraints, sizeof constraints);\n-  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n-  mybzero (predicates, sizeof predicates);\n-  mybzero (address_p, sizeof address_p);\n-  mybzero (modes, sizeof modes);\n-  mybzero (strict_low, sizeof strict_low);\n-  mybzero (seen, sizeof seen);\n+  memset (constraints, 0, sizeof constraints);\n+  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n+  memset (predicates, 0, sizeof predicates);\n+  memset (address_p, 0, sizeof address_p);\n+  memset (modes, 0, sizeof modes);\n+  memset (strict_low, 0, sizeof strict_low);\n+  memset (seen, 0, sizeof seen);\n \n   if (XVEC (insn, 1))\n     for (i = 0; i < XVECLEN (insn, 1); i++)\n@@ -811,12 +809,12 @@ gen_expand (insn)\n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n \n-  mybcopy (constraints, d->constraints, sizeof constraints);\n-  mybcopy (op_n_alternatives, d->op_n_alternatives, sizeof op_n_alternatives);\n-  mybcopy (predicates, d->predicates, sizeof predicates);\n-  mybcopy (address_p, d->address_p, sizeof address_p);\n-  mybcopy (modes, d->modes, sizeof modes);\n-  mybcopy (strict_low, d->strict_low, sizeof strict_low);\n+  memcpy (d->constraints, constraints, sizeof constraints);\n+  memcpy (d->op_n_alternatives, op_n_alternatives, sizeof op_n_alternatives);\n+  memcpy (d->predicates, predicates, sizeof predicates);\n+  memcpy (d->address_p, address_p, sizeof address_p);\n+  memcpy (d->modes, modes, sizeof modes);\n+  memcpy (d->strict_low, strict_low, sizeof strict_low);\n \n   d->template = 0;\n   d->outfun = 0;\n@@ -851,13 +849,13 @@ gen_split (split)\n   max_opno = -1;\n   num_dups = 0;\n \n-  mybzero (constraints, sizeof constraints);\n-  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n-  mybzero (predicates, sizeof predicates);\n-  mybzero (address_p, sizeof address_p);\n-  mybzero (modes, sizeof modes);\n-  mybzero (strict_low, sizeof strict_low);\n-  mybzero (seen, sizeof seen);\n+  memset (constraints, 0, sizeof constraints);\n+  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n+  memset (predicates, 0, sizeof predicates);\n+  memset (address_p, 0, sizeof address_p);\n+  memset (modes, 0, sizeof modes);\n+  memset (strict_low, 0, sizeof strict_low);\n+  memset (seen, 0, sizeof seen);\n \n   /* Get the number of operands by scanning all the\n      patterns of the split patterns.\n@@ -867,12 +865,12 @@ gen_split (split)\n \n   d->n_operands = max_opno + 1;\n \n-  mybzero (d->constraints, sizeof constraints);\n-  mybzero (d->op_n_alternatives, sizeof op_n_alternatives);\n-  mybzero (d->predicates, sizeof predicates);\n-  mybzero (d->address_p, sizeof address_p);\n-  mybzero (d->modes, sizeof modes);\n-  mybzero (d->strict_low, sizeof strict_low);\n+  memset (d->constraints, 0, sizeof constraints);\n+  memset (d->op_n_alternatives, 0, sizeof op_n_alternatives);\n+  memset (d->predicates, 0, sizeof predicates);\n+  memset (d->address_p, 0, sizeof address_p);\n+  memset (d->modes, 0, sizeof modes);\n+  memset (d->strict_low, 0, sizeof strict_low);\n \n   d->n_dups = 0;\n   d->n_alternatives = 0;\n@@ -902,25 +900,6 @@ xrealloc (ptr, size)\n   return result;\n }\n \n-static void\n-mybzero (b, length)\n-     register char *b;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *b++ = 0;\n-}\n-\n-static void\n-mybcopy (b1, b2, length)\n-     register char *b1;\n-     register char *b2;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *b2++ = *b1++;\n-}\n-\n static void\n fatal VPROTO ((const char *format, ...))\n {"}, {"sha": "bf0c0dad50c28fb22962bcf960b70ae33bcf75a1", "filename": "gcc/genrecog.c", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=efd59a3308bc1ad7dd1527d9e6fa1feaa0a87f56", "patch": "@@ -1,5 +1,5 @@\n /* Generate code from machine description to recognize rtl as insns.\n-   Copyright (C) 1987, 88, 92, 93, 94, 95, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-95, 97-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -191,9 +191,6 @@ static void write_tree\t\tPROTO((struct decision *, const char *,\n \t\t\t\t       struct decision *, int,\n \t\t\t\t       enum routine_type));\n static void change_state\tPROTO((const char *, const char *, int));\n-static char *copystr\t\tPROTO((const char *));\n-static void mybzero\t\tPROTO((char *, unsigned));\n-static void mybcopy\t\tPROTO((char *, char *, unsigned));\n static void fatal\t\tPVPROTO((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n void fancy_abort\t\tPROTO((void)) ATTRIBUTE_NORETURN;\n@@ -310,7 +307,7 @@ add_to_sequence (pattern, last, position)\n     max_depth = depth;\n \n   new->number = next_number++;\n-  new->position = copystr (position);\n+  new->position = xstrdup (position);\n   new->ignore_code = 0;\n   new->ignore_mode = 0;\n   new->enforce_mode = 1;\n@@ -833,8 +830,7 @@ merge_trees (oldh, addh)\n \t\t      struct decision *split\n \t\t\t= (struct decision *) xmalloc (sizeof (struct decision));\n \n-\t\t      mybcopy ((char *) old, (char *) split,\n-\t\t\t       sizeof (struct decision));\n+\t\t      memcpy (split, old, sizeof (struct decision));\n \n \t\t      old->success.first = old->success.last = split;\n \t\t      old->c_test = 0;\n@@ -860,8 +856,7 @@ merge_trees (oldh, addh)\n \t\t      struct decision *split\n \t\t\t= (struct decision *) xmalloc (sizeof (struct decision));\n \n-\t\t      mybcopy ((char *) add, (char *) split,\n-\t\t\t       sizeof (struct decision));\n+\t\t      memcpy (split, add, sizeof (struct decision));\n \n \t\t      add->success.first = add->success.last = split;\n \t\t      add->c_test = 0;\n@@ -1300,7 +1295,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n       if (switch_mode == VOIDmode && mode != VOIDmode && p->next != 0\n \t  && p->next->enforce_mode && p->next->mode != VOIDmode)\n \t{\n-\t  mybzero (modemap, sizeof modemap);\n+\t  memset (modemap, 0, sizeof modemap);\n \t  printf (\"%sswitch (GET_MODE (x%d))\\n\", indents[indent], depth);\n \t  printf (\"%s{\\n\", indents[indent + 2]);\n \t  indent += 4;\n@@ -1317,7 +1312,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n       if (switch_code == UNKNOWN && p->code != UNKNOWN && ! p->ignore_code\n \t  && p->next != 0 && p->next->code != UNKNOWN)\n \t{\n-\t  mybzero (codemap, sizeof codemap);\n+\t  memset (codemap, 0, sizeof codemap);\n \t  printf (\"%sswitch (GET_CODE (x%d))\\n\", indents[indent], depth);\n \t  printf (\"%s{\\n\", indents[indent + 2]);\n \t  indent += 4;\n@@ -1628,37 +1623,14 @@ change_state (oldpos, newpos, indent)\n     }\n }\n \f\n-static char *\n-copystr (s1)\n-  const char *s1;\n+char *\n+xstrdup (s1)\n+  const char *input;\n {\n-  register char *tem;\n-\n-  if (s1 == 0)\n-    return 0;\n-\n-  tem = (char *) xmalloc (strlen (s1) + 1);\n-  strcpy (tem, s1);\n-\n-  return tem;\n-}\n-\n-static void\n-mybzero (b, length)\n-     register char *b;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *b++ = 0;\n-}\n-\n-static void\n-mybcopy (in, out, length)\n-     register char *in, *out;\n-     register unsigned length;\n-{\n-  while (length-- > 0)\n-    *out++ = *in++;\n+  register size_t len = strlen (input) + 1;\n+  register char *output = xmalloc (len);\n+  memcpy (output, input, len);\n+  return output;\n }\n \n PTR"}]}