{"sha": "970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcwZGFiYmQxZTc5NmNmZTFhZTFhOWQxMmMwNjU4M2Y5YTAzZTFlMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-28T13:29:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-28T13:29:54Z"}, "message": "ipa-inline-analysis.c (will_be_nonconstant_predicate): Take nonconstant_names array.\n\n\n\t* ipa-inline-analysis.c (will_be_nonconstant_predicate): Take nonconstant_names\n\tarray.\n\t(estimate_function_body_sizes): Build nonconstant_names array; handle\n\tBUILT_IN_CONSTANT_P.\n\nFrom-SVN: r173070", "tree": {"sha": "681164be0a06f67435bf67aa3ae84d4723fbadea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/681164be0a06f67435bf67aa3ae84d4723fbadea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1/comments", "author": null, "committer": null, "parents": [{"sha": "80f81134d72f538c54e223e0dd1d607deda797c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f81134d72f538c54e223e0dd1d607deda797c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f81134d72f538c54e223e0dd1d607deda797c5"}], "stats": {"total": 84, "additions": 70, "deletions": 14}, "files": [{"sha": "a6b0f0384caceed020d98c5b05f4e86f5b8f45e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1", "patch": "@@ -1,3 +1,10 @@\n+2011-04-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c (will_be_nonconstant_predicate): Take nonconstant_names\n+\tarray.\n+\t(estimate_function_body_sizes): Build nonconstant_names array; handle\n+\tBUILT_IN_CONSTANT_P.\n+\n 2011-04-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR bootstrap/48804"}, {"sha": "8a4c883b1a399cb35d53db37118ddea9358e8a57", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=970dabbd1e796cfe1ae1a9d12c06583f9a03e1e1", "patch": "@@ -931,10 +931,23 @@ edge_execution_predicate (struct ipa_node_params *info,\n \t\t\tgimple_cond_rhs (last));\n }\n \n+\n+/* We keep info about constantness of SSA names.  */\n+\n+typedef struct predicate predicate_t;\n+DEF_VEC_O (predicate_t);\n+DEF_VEC_ALLOC_O (predicate_t, heap);\n+\n+\n+/* Return predicate specifying when the STMT might have result that is not a compile\n+   time constant.  */\n+\n static struct predicate\n will_be_nonconstant_predicate (struct ipa_node_params *info,\n \t\t\t       struct inline_summary *summary,\n-\t\t\t       gimple stmt)\n+\t\t\t       gimple stmt,\n+\t\t\t       VEC (predicate_t, heap) *nonconstant_names)\n+\t\t\t      \n {\n   struct predicate p = true_predicate ();\n   ssa_op_iter iter;\n@@ -949,29 +962,45 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n       && gimple_code (stmt) != GIMPLE_SWITCH)\n     return p;\n \n-  /* Stores and loads will stay anyway.  */\n+  /* Stores and loads will stay anyway.\n+     TODO: Constant memory accesses could be handled here, too.  */\n   if (gimple_vuse (stmt))\n     return p;\n \n   /* See if we understand all operands before we start\n      adding conditionals.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      /* TODO: handle nested expressions and constant\n-\t array accesses.  */\n-      if (TREE_CODE (use) != SSA_NAME\n-\t  || !SSA_NAME_IS_DEFAULT_DEF (use)\n-\t  || ipa_get_param_decl_index (info, SSA_NAME_VAR (use)) < 0)\n+      if (TREE_CODE (use) != SSA_NAME)\n \treturn p;\n+      /* For arguments we can build a condition.  */\n+      if (SSA_NAME_IS_DEFAULT_DEF (use)\n+\t  && ipa_get_param_decl_index (info, SSA_NAME_VAR (use)) >= 0)\n+\tcontinue;\n+      /* If we know when operand is constant,\n+\t we still can say something useful.  */\n+      if (!true_predicate_p (VEC_index (predicate_t, nonconstant_names,\n+\t\t\t\t\tSSA_NAME_VERSION (use))))\n+\tcontinue;\n+      return p;\n     }\n   op_non_const = false_predicate ();\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      p = add_condition (summary,\n-\t\t\t ipa_get_param_decl_index (info, SSA_NAME_VAR (use)),\n-\t\t\t IS_NOT_CONSTANT, NULL);\n+      if (SSA_NAME_IS_DEFAULT_DEF (use)\n+\t  && ipa_get_param_decl_index (info, SSA_NAME_VAR (use)) >= 0)\n+\tp = add_condition (summary,\n+\t\t\t   ipa_get_param_decl_index (info, SSA_NAME_VAR (use)),\n+\t\t\t   IS_NOT_CONSTANT, NULL);\n+      else\n+\tp = *VEC_index (predicate_t, nonconstant_names,\n+\t\t\tSSA_NAME_VERSION (use));\n       op_non_const = or_predicates (&p, &op_non_const);\n     }\n+  if (gimple_code (stmt) == GIMPLE_ASSIGN\n+      && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n+    VEC_replace (predicate_t, nonconstant_names,\n+\t\t SSA_NAME_VERSION (gimple_assign_lhs (stmt)), &op_non_const);\n   return op_non_const;\n }\n \n@@ -994,9 +1023,15 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   int freq;\n   struct inline_summary *info = inline_summary (node);\n   struct predicate bb_predicate;\n-  struct ipa_node_params *parms_info;\n+  struct ipa_node_params *parms_info = NULL;\n+  VEC (predicate_t, heap) *nonconstant_names = NULL;\n \n-  parms_info = ipa_node_params_vector && !early ? IPA_NODE_REF (node) : NULL;\n+  if (ipa_node_params_vector && !early && optimize)\n+    {\n+      parms_info = IPA_NODE_REF (node);\n+      VEC_safe_grow_cleared (predicate_t, heap, nonconstant_names,\n+\t\t\t     VEC_length (tree, SSANAMES (my_function)));\n+    }\n \n   info->conds = 0;\n   info->entry = 0;\n@@ -1014,7 +1049,6 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   bb_predicate = not_inlined_predicate ();\n   account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);\n \n-\n   gcc_assert (my_function && my_function->cfg);\n   FOR_EACH_BB_FN (bb, my_function)\n     {\n@@ -1063,6 +1097,19 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      struct cgraph_edge *edge = cgraph_edge (node, stmt);\n \t      struct inline_edge_summary *es = inline_edge_summary (edge);\n \n+\t      /* Special case: results of BUILT_IN_CONSTANT_P will be always\n+\t\t resolved as constant.  We however don't want to optimize\n+\t\t out the cgraph edges.  */\n+\t      if (nonconstant_names\n+\t\t  && gimple_call_builtin_p (stmt, BUILT_IN_CONSTANT_P)\n+\t\t  && gimple_call_lhs (stmt)\n+\t\t  && TREE_CODE (gimple_call_lhs (stmt)) == SSA_NAME)\n+\t\t{\n+\t\t  struct predicate false_p = false_predicate ();\n+\t\t  VEC_replace (predicate_t, nonconstant_names,\n+\t\t\t       SSA_NAME_VERSION (gimple_call_lhs (stmt)), &false_p);\n+\t\t}\n+\n \t      es->call_stmt_size = this_size;\n \t      es->call_stmt_time = this_time;\n \t      es->loop_depth = bb->loop_depth;\n@@ -1098,7 +1145,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      if (parms_info)\n \t\t{\n \t\t  will_be_nonconstant\n-\t\t     = will_be_nonconstant_predicate (parms_info, info, stmt);\n+\t\t     = will_be_nonconstant_predicate (parms_info, info,\n+\t\t\t\t\t\t      stmt, nonconstant_names);\n \t\t  p = and_predicates (&bb_predicate, &will_be_nonconstant);\n \t\t}\n \t      else\n@@ -1131,6 +1179,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n     time = MAX_TIME;\n   inline_summary (node)->self_time = time;\n   inline_summary (node)->self_size = size;\n+  VEC_free (predicate_t, heap, nonconstant_names);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n\");"}]}