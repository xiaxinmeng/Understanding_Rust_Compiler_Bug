{"sha": "deb8dacccffd4eda62517772bef5fd90e03776d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGViOGRhY2NjZmZkNGVkYTYyNTE3NzcyYmVmNWZkOTBlMDM3NzZkNw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2011-08-03T14:42:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T14:42:53Z"}, "message": "exp_ch13.adb: Add with and use clause for Targparm;\n\n2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch13.adb: Add with and use clause for Targparm;\n\t(Expand_N_Free_Statement): Prevent the generation of a custom\n\tDeallocate on .NET/JVM targets since this requires pools and address\n\tarithmetic.\n\t* exp_ch4.adb (Expand_Allocator_Expression): When compiling for\n\t.NET/JVM targets, attach the newly allocated object to the access\n\ttype's finalization collection. Do not generate a call to\n\tSet_Finalize_Address_Ptr on .NET/JVM because this routine does not\n\texist in the runtime.\n\t(Expand_N_Allocator): When compiling for .NET/JVM targets, do not\n\tcreate a custom Allocate for object that do not require initialization.\n\tAttach a newly allocated object to the access type's finalization\n\tcollection on .NET/JVM.\n\t* exp_ch5.adb (Make_Tag_Ctrl_Assignment): Add special processing for\n\tassignment of controlled types on .NET/JVM. The two hidden pointers\n\tPrev and Next and stored and later restored after the assignment takes\n\tplace.\n\t* exp_ch6.adb (Expand_Call): Add local constant Curr_S. Add specialized\n\tkludge for .NET/JVM to recognize a particular piece of code coming from\n\tHeap_Management and change the call to Finalize into Deep_Finalize.\n\t* exp_ch7.adb (Build_Finalization_Collection): Allow the creation of\n\tfinalization collections on .NET/JVM only for types derived from\n\tControlled. Separate the association of storage pools with a collection\n\tand only allow it on non-.NET/JVM targets.\n\t(Make_Attach_Call): New routine.\n\t(Make_Detach_Call): New routine.\n\t(Process_Object_Declarations): Suppress the generation of\n\tbuild-in-place return object clean up code on .NET/JVM since it uses\n\tpools.\n\t* exp_ch7.ads (Make_Attach_Call): New routine.\n\t(Make_Detach_Call): New routine.\n\t* exp_intr.adb Add with and use clause for Targparm.\n\t(Expand_Unc_Deallocation): Detach a controlled object from a collection\n\ton .NET/JVM targets.\n\t* rtsfind.ads: Add entries RE_Attach, RE_Detach and\n\tRE_Root_Controlled_Ptr to tables RE_Id and RE_Unit_Table.\n\t* snames.ads-tmpl: Add name Name_Prev. Move Name_Prev to the special\n\tnames used in finalization.\n\n2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-fihema.adb: Add with and use clauses for System.Soft_Links.\n\t(Attach, Detach): Lock the current task when chaining an object onto a\n\tcollection.\n\nFrom-SVN: r177276", "tree": {"sha": "4c63cfa6c69adcb44e1f7e6a42494f3a20e9edcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c63cfa6c69adcb44e1f7e6a42494f3a20e9edcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deb8dacccffd4eda62517772bef5fd90e03776d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb8dacccffd4eda62517772bef5fd90e03776d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deb8dacccffd4eda62517772bef5fd90e03776d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb8dacccffd4eda62517772bef5fd90e03776d7/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df3e68b121249fad724c7c3f2b71e430dfb91008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e68b121249fad724c7c3f2b71e430dfb91008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3e68b121249fad724c7c3f2b71e430dfb91008"}], "stats": {"total": 487, "additions": 423, "deletions": 64}, "files": [{"sha": "0a1c510bc0b09898d7654872ac691c553f23ff7a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -1,3 +1,50 @@\n+2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch13.adb: Add with and use clause for Targparm;\n+\t(Expand_N_Free_Statement): Prevent the generation of a custom\n+\tDeallocate on .NET/JVM targets since this requires pools and address\n+\tarithmetic.\n+\t* exp_ch4.adb (Expand_Allocator_Expression): When compiling for\n+\t.NET/JVM targets, attach the newly allocated object to the access\n+\ttype's finalization collection. Do not generate a call to\n+\tSet_Finalize_Address_Ptr on .NET/JVM because this routine does not\n+\texist in the runtime.\n+\t(Expand_N_Allocator): When compiling for .NET/JVM targets, do not\n+\tcreate a custom Allocate for object that do not require initialization.\n+\tAttach a newly allocated object to the access type's finalization\n+\tcollection on .NET/JVM.\n+\t* exp_ch5.adb (Make_Tag_Ctrl_Assignment): Add special processing for\n+\tassignment of controlled types on .NET/JVM. The two hidden pointers\n+\tPrev and Next and stored and later restored after the assignment takes\n+\tplace.\n+\t* exp_ch6.adb (Expand_Call): Add local constant Curr_S. Add specialized\n+\tkludge for .NET/JVM to recognize a particular piece of code coming from\n+\tHeap_Management and change the call to Finalize into Deep_Finalize.\n+\t* exp_ch7.adb (Build_Finalization_Collection): Allow the creation of\n+\tfinalization collections on .NET/JVM only for types derived from\n+\tControlled. Separate the association of storage pools with a collection\n+\tand only allow it on non-.NET/JVM targets.\n+\t(Make_Attach_Call): New routine.\n+\t(Make_Detach_Call): New routine.\n+\t(Process_Object_Declarations): Suppress the generation of\n+\tbuild-in-place return object clean up code on .NET/JVM since it uses\n+\tpools.\n+\t* exp_ch7.ads (Make_Attach_Call): New routine.\n+\t(Make_Detach_Call): New routine.\n+\t* exp_intr.adb Add with and use clause for Targparm.\n+\t(Expand_Unc_Deallocation): Detach a controlled object from a collection\n+\ton .NET/JVM targets.\n+\t* rtsfind.ads: Add entries RE_Attach, RE_Detach and\n+\tRE_Root_Controlled_Ptr to tables RE_Id and RE_Unit_Table.\n+\t* snames.ads-tmpl: Add name Name_Prev. Move Name_Prev to the special\n+\tnames used in finalization.\n+\n+2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-fihema.adb: Add with and use clauses for System.Soft_Links.\n+\t(Attach, Detach): Lock the current task when chaining an object onto a\n+\tcollection.\n+\n 2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* a-except.adb, a-except-2005.adb (Raise_From_Controlled_Operation):"}, {"sha": "ab0e273cba135af18178d2c20ec31c0733fce569", "filename": "gcc/ada/a-fihema.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -37,6 +37,7 @@ with GNAT.IO;                 use GNAT.IO;\n \n with System;                  use System;\n with System.Address_Image;\n+with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n with System.Storage_Pools;    use System.Storage_Pools;\n \n@@ -135,10 +136,18 @@ package body Ada.Finalization.Heap_Management is\n \n    procedure Attach (N : Node_Ptr; L : Node_Ptr) is\n    begin\n+      Lock_Task.all;\n+\n       L.Next.Prev := N;\n       N.Next := L.Next;\n       L.Next := N;\n       N.Prev := L;\n+\n+      Unlock_Task.all;\n+   exception\n+      when others =>\n+         Unlock_Task.all;\n+         raise;\n    end Attach;\n \n    ---------------\n@@ -209,6 +218,8 @@ package body Ada.Finalization.Heap_Management is\n \n    procedure Detach (N : Node_Ptr) is\n    begin\n+      Lock_Task.all;\n+\n       if N.Prev /= null\n         and then N.Next /= null\n       then\n@@ -217,6 +228,12 @@ package body Ada.Finalization.Heap_Management is\n          N.Prev := null;\n          N.Next := null;\n       end if;\n+\n+      Unlock_Task.all;\n+   exception\n+      when others =>\n+         Unlock_Task.all;\n+         raise;\n    end Detach;\n \n    --------------"}, {"sha": "0af6519a46d55461d6a830ec2c8b8de6c34538ba", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -43,6 +43,7 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n@@ -214,6 +215,13 @@ package body Exp_Ch13 is\n       Typ  : Entity_Id := Etype (Expr);\n \n    begin\n+      --  Do not create a specialized Deallocate since .NET/JVM compilers do\n+      --  not support pools and address arithmetic.\n+\n+      if VM_Target /= No_VM then\n+         return;\n+      end if;\n+\n       --  Use the base type to perform the collection check\n \n       if Ekind (Typ) = E_Access_Subtype then"}, {"sha": "fb7f3b04e9cc16178f39cc1ce109f65ac992a365", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 90, "deletions": 13, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -840,6 +840,22 @@ package body Exp_Ch4 is\n                Complete_Controlled_Allocation (Temp_Decl);\n                Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n+               --  Attach the object to the associated finalization collection.\n+               --  This is done manually on .NET/JVM since those compilers do\n+               --  no support pools and can't benefit from internally generated\n+               --  Allocate / Deallocate procedures.\n+\n+               if VM_Target /= No_VM\n+                 and then Is_Controlled (DesigT)\n+                 and then Present (Associated_Collection (PtrT))\n+               then\n+                  Insert_Action (N,\n+                    Make_Attach_Call (\n+                      Obj_Ref =>\n+                        New_Reference_To (Temp, Loc),\n+                      Ptr_Typ => PtrT));\n+               end if;\n+\n             else\n                Node := Relocate_Node (N);\n                Set_Analyzed (Node);\n@@ -853,6 +869,22 @@ package body Exp_Ch4 is\n \n                Insert_Action (N, Temp_Decl);\n                Complete_Controlled_Allocation (Temp_Decl);\n+\n+               --  Attach the object to the associated finalization collection.\n+               --  This is done manually on .NET/JVM since those compilers do\n+               --  no support pools and can't benefit from internally generated\n+               --  Allocate / Deallocate procedures.\n+\n+               if VM_Target /= No_VM\n+                 and then Is_Controlled (DesigT)\n+                 and then Present (Associated_Collection (PtrT))\n+               then\n+                  Insert_Action (N,\n+                    Make_Attach_Call (\n+                      Obj_Ref =>\n+                        New_Reference_To (Temp, Loc),\n+                      Ptr_Typ => PtrT));\n+               end if;\n             end if;\n \n          --  Ada 2005 (AI-251): Handle allocators whose designated type is an\n@@ -1040,7 +1072,12 @@ package body Exp_Ch4 is\n             --    Set_Finalize_Address_Ptr\n             --      (Collection, <Finalize_Address>'Unrestricted_Access)\n \n-            if Present (Associated_Collection (PtrT)) then\n+            --  Since .NET/JVM compilers do not support address arithmetic,\n+            --  this call is skipped.\n+\n+            if VM_Target = No_VM\n+              and then Present (Associated_Collection (PtrT))\n+            then\n                Insert_Action (N,\n                  Make_Set_Finalize_Address_Ptr_Call (\n                    Loc     => Loc,\n@@ -1085,6 +1122,22 @@ package body Exp_Ch4 is\n          Complete_Controlled_Allocation (Temp_Decl);\n          Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n+         --  Attach the object to the associated finalization collection. This\n+         --  is done manually on .NET/JVM since those compilers do no support\n+         --  pools and cannot benefit from internally generated Allocate and\n+         --  Deallocate procedures.\n+\n+         if VM_Target /= No_VM\n+           and then Is_Controlled (DesigT)\n+           and then Present (Associated_Collection (PtrT))\n+         then\n+            Insert_Action (N,\n+              Make_Attach_Call (\n+                Obj_Ref =>\n+                  New_Reference_To (Temp, Loc),\n+                Ptr_Typ => PtrT));\n+         end if;\n+\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n@@ -3477,9 +3530,12 @@ package body Exp_Ch4 is\n          if No_Initialization (N) then\n \n             --  Even though this might be a simple allocation, create a custom\n-            --  Allocate if the context requires it.\n+            --  Allocate if the context requires it. Since .NET/JVM compilers\n+            --  do not support pools, this step is skipped.\n \n-            if Present (Associated_Collection (PtrT)) then\n+            if VM_Target = No_VM\n+              and then Present (Associated_Collection (PtrT))\n+            then\n                Build_Allocate_Deallocate_Proc\n                  (N           => Parent (N),\n                   Is_Allocate => True);\n@@ -3759,7 +3815,8 @@ package body Exp_Ch4 is\n                else\n                   Insert_Action (N,\n                     Make_Procedure_Call_Statement (Loc,\n-                      Name                   => New_Reference_To (Init, Loc),\n+                      Name =>\n+                        New_Reference_To (Init, Loc),\n                       Parameter_Associations => Args));\n                end if;\n \n@@ -3773,16 +3830,36 @@ package body Exp_Ch4 is\n                       Obj_Ref => New_Copy_Tree (Init_Arg1),\n                       Typ     => T));\n \n-                  --  Generate:\n-                  --    Set_Finalize_Address_Ptr\n-                  --      (Pool, <Finalize_Address>'Unrestricted_Access)\n-\n                   if Present (Associated_Collection (PtrT)) then\n-                     Insert_Action (N,\n-                       Make_Set_Finalize_Address_Ptr_Call (\n-                         Loc     => Loc,\n-                         Typ     => T,\n-                         Ptr_Typ => PtrT));\n+\n+                     --  Special processing for .NET/JVM, the allocated object\n+                     --  is attached to the finalization collection. Generate:\n+\n+                     --    Attach (<PtrT>FC, Root_Controlled_Ptr (Init_Arg1));\n+\n+                     --  Types derived from [Limited_]Controlled are the only\n+                     --  ones considered since they have fields Prev and Next.\n+\n+                     if VM_Target /= No_VM then\n+                        if Is_Controlled (T) then\n+                           Insert_Action (N,\n+                             Make_Attach_Call (\n+                               Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                               Ptr_Typ => PtrT));\n+                        end if;\n+\n+                     --  Default case, generate:\n+\n+                     --    Set_Finalize_Address_Ptr\n+                     --      (Pool, <Finalize_Address>'Unrestricted_Access)\n+\n+                     else\n+                        Insert_Action (N,\n+                          Make_Set_Finalize_Address_Ptr_Call (\n+                            Loc     => Loc,\n+                            Typ     => T,\n+                            Ptr_Typ => PtrT));\n+                     end if;\n                   end if;\n                end if;\n "}, {"sha": "cba68fbf4d444f1534fce2ac2a6f335f9c505569", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 92, "deletions": 10, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -3496,7 +3496,9 @@ package body Exp_Ch5 is\n       --  Tags are not saved and restored when VM_Target because VM tags are\n       --  represented implicitly in objects.\n \n-      Tag_Tmp : Entity_Id;\n+      Next_Id : Entity_Id;\n+      Prev_Id : Entity_Id;\n+      Tag_Id  : Entity_Id;\n \n    begin\n       --  Finalize the target of the assignment when controlled\n@@ -3535,14 +3537,14 @@ package body Exp_Ch5 is\n              Typ     => Etype (L)));\n       end if;\n \n-      --  Save the Tag in a local variable Tag_Tmp\n+      --  Save the Tag in a local variable Tag_Id\n \n       if Save_Tag then\n-         Tag_Tmp := Make_Temporary (Loc, 'A');\n+         Tag_Id := Make_Temporary (Loc, 'A');\n \n          Append_To (Res,\n            Make_Object_Declaration (Loc,\n-             Defining_Identifier => Tag_Tmp,\n+             Defining_Identifier => Tag_Id,\n              Object_Definition =>\n                New_Reference_To (RTE (RE_Tag), Loc),\n              Expression =>\n@@ -3552,10 +3554,52 @@ package body Exp_Ch5 is\n                  Selector_Name =>\n                    New_Reference_To (First_Tag_Component (T), Loc))));\n \n-      --  Otherwise Tag_Tmp not used\n+      --  Otherwise Tag_Id is not used\n \n       else\n-         Tag_Tmp := Empty;\n+         Tag_Id := Empty;\n+      end if;\n+\n+      --  Save the Prev and Next fields on .NET/JVM. This is not needed on non\n+      --  VM targets since the fields are not part of the object.\n+\n+      if VM_Target /= No_VM\n+        and then Is_Controlled (T)\n+      then\n+         Prev_Id := Make_Temporary (Loc, 'P');\n+         Next_Id := Make_Temporary (Loc, 'N');\n+\n+         --  Generate:\n+         --    Pnn : Root_Controlled_Ptr := Root_Controlled (L).Prev;\n+\n+         Append_To (Res,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Prev_Id,\n+             Object_Definition =>\n+               New_Reference_To (RTE (RE_Root_Controlled_Ptr), Loc),\n+             Expression =>\n+               Make_Selected_Component (Loc,\n+                 Prefix =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Name_Prev))));\n+\n+         --  Generate:\n+         --    Nnn : Root_Controlled_Ptr := Root_Controlled (L).Next;\n+\n+         Append_To (Res,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Next_Id,\n+             Object_Definition =>\n+               New_Reference_To (RTE (RE_Root_Controlled_Ptr), Loc),\n+             Expression =>\n+               Make_Selected_Component (Loc,\n+                 Prefix =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Name_Next))));\n       end if;\n \n       --  If the tagged type has a full rep clause, expand the assignment into\n@@ -3577,10 +3621,48 @@ package body Exp_Ch5 is\n            Make_Assignment_Statement (Loc,\n              Name =>\n                Make_Selected_Component (Loc,\n-                 Prefix        => Duplicate_Subexpr_No_Checks (L),\n-                 Selector_Name => New_Reference_To (First_Tag_Component (T),\n-                                                    Loc)),\n-             Expression => New_Reference_To (Tag_Tmp, Loc)));\n+                 Prefix =>\n+                   Duplicate_Subexpr_No_Checks (L),\n+                 Selector_Name =>\n+                   New_Reference_To (First_Tag_Component (T), Loc)),\n+             Expression =>\n+               New_Reference_To (Tag_Id, Loc)));\n+      end if;\n+\n+      --  Restore the Prev and Next fields on .NET/JVM\n+\n+      if VM_Target /= No_VM\n+        and then Is_Controlled (T)\n+      then\n+         --  Generate:\n+         --    Root_Controlled (L).Prev := Prev_Id;\n+\n+         Append_To (Res,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Selected_Component (Loc,\n+                 Prefix =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Name_Prev)),\n+             Expression =>\n+               New_Reference_To (Prev_Id, Loc)));\n+\n+         --  Generate:\n+         --    Root_Controlled (L).Next := Next_Id;\n+\n+         Append_To (Res,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Selected_Component (Loc,\n+                 Prefix =>\n+                   Unchecked_Convert_To\n+                     (RTE (RE_Root_Controlled), New_Copy_Tree (L)),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Name_Next)),\n+             Expression =>\n+               New_Reference_To (Next_Id, Loc)));\n       end if;\n \n       --  Adjust the target after the assignment when controlled (not in the"}, {"sha": "98b6ad07fa563a7cd47219c1db917118b2072274", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -2015,7 +2015,8 @@ package body Exp_Ch6 is\n \n       --  Local variables\n \n-      Remote        : constant Boolean := Is_Remote_Call (Call_Node);\n+      Curr_S        : constant Entity_Id := Current_Scope;\n+      Remote        : constant Boolean   := Is_Remote_Call (Call_Node);\n       Actual        : Node_Id;\n       Formal        : Entity_Id;\n       Orig_Subp     : Entity_Id := Empty;\n@@ -2105,6 +2106,52 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n+      --  Detect the following code in Ada.Finalization.Heap_Management only\n+      --  on .NET/JVM targets:\n+      --\n+      --    procedure Finalize (Collection : in out Finalization_Collection) is\n+      --    begin\n+      --       . . .\n+      --       begin\n+      --          Finalize (Curr_Ptr.all);\n+      --\n+      --  Since .NET/JVM compilers lack address arithmetic and Deep_Finalize\n+      --  cannot be named in library or user code, the compiler has to install\n+      --  a kludge and transform the call to Finalize into Deep_Finalize.\n+\n+      if VM_Target /= No_VM\n+        and then Chars (Subp) = Name_Finalize\n+        and then Ekind (Curr_S) = E_Block\n+        and then Ekind (Scope (Curr_S)) = E_Procedure\n+        and then Chars (Scope (Curr_S)) = Name_Finalize\n+        and then Etype (First_Formal (Scope (Curr_S))) =\n+                   RTE (RE_Finalization_Collection)\n+      then\n+         declare\n+            Deep_Fin : constant Entity_Id :=\n+                         Find_Prim_Op (RTE (RE_Root_Controlled),\n+                                       TSS_Deep_Finalize);\n+         begin\n+            --  Since Root_Controlled is a tagged type, the compiler should\n+            --  always generate Deep_Finalize for it.\n+\n+            pragma Assert (Present (Deep_Fin));\n+\n+            --  Generate:\n+            --    Deep_Finalize (Curr_Ptr.all);\n+\n+            Rewrite (N,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (Deep_Fin, Loc),\n+                Parameter_Associations =>\n+                  New_Copy_List_Tree (Parameter_Associations (N))));\n+\n+            Analyze (N);\n+            return;\n+         end;\n+      end if;\n+\n       --  Ada 2005 (AI-345): We have a procedure call as a triggering\n       --  alternative in an asynchronous select or as an entry call in\n       --  a conditional or timed select. Check whether the procedure call"}, {"sha": "ad48e5a9233eb42b9941f0824462818e60750416", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 84, "deletions": 35, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -896,9 +896,13 @@ package body Exp_Ch7 is\n       then\n          return;\n \n-      --  Do not process access-to-controlled types on .NET/JVM targets\n+      --  For .NET/JVM targets, allow the processing of access-to-controlled\n+      --  types where the designated type is explicitly derived from [Limited_]\n+      --  Controlled.\n \n-      elsif VM_Target /= No_VM then\n+      elsif VM_Target /= No_VM\n+        and then not Is_Controlled (Desig_Typ)\n+      then\n          return;\n       end if;\n \n@@ -933,47 +937,54 @@ package body Exp_Ch7 is\n              Object_Definition =>\n                New_Reference_To (RTE (RE_Finalization_Collection), Loc)));\n \n-         --  If the access type has a user-defined pool, use it as the base\n-         --  storage medium for the finalization pool.\n+         --  Storage pool selection and attribute decoration of the generated\n+         --  collection. Since .NET/JVM compilers do not support pools, this\n+         --  step is skipped.\n \n-         if Present (Associated_Storage_Pool (Typ)) then\n-            Pool_Id := Associated_Storage_Pool (Typ);\n+         if VM_Target = No_VM then\n \n-         --  Access subtypes must use the storage pool of their base type\n+            --  If the access type has a user-defined pool, use it as the base\n+            --  storage medium for the finalization pool.\n \n-         elsif Ekind (Typ) = E_Access_Subtype then\n-            declare\n-               Base_Typ : constant Entity_Id := Base_Type (Typ);\n+            if Present (Associated_Storage_Pool (Typ)) then\n+               Pool_Id := Associated_Storage_Pool (Typ);\n \n-            begin\n-               if No (Associated_Storage_Pool (Base_Typ)) then\n-                  Pool_Id := RTE (RE_Global_Pool_Object);\n-                  Set_Associated_Storage_Pool (Base_Typ, Pool_Id);\n-               else\n-                  Pool_Id := Associated_Storage_Pool (Base_Typ);\n-               end if;\n-            end;\n+            --  Access subtypes must use the storage pool of their base type\n \n-         --  The default choice is the global pool\n+            elsif Ekind (Typ) = E_Access_Subtype then\n+               declare\n+                  Base_Typ : constant Entity_Id := Base_Type (Typ);\n \n-         else\n-            Pool_Id := RTE (RE_Global_Pool_Object);\n-            Set_Associated_Storage_Pool (Typ, Pool_Id);\n-         end if;\n+               begin\n+                  if No (Associated_Storage_Pool (Base_Typ)) then\n+                     Pool_Id := RTE (RE_Global_Pool_Object);\n+                     Set_Associated_Storage_Pool (Base_Typ, Pool_Id);\n+                  else\n+                     Pool_Id := Associated_Storage_Pool (Base_Typ);\n+                  end if;\n+               end;\n \n-         --  Generate:\n-         --    Set_Storage_Pool_Ptr (Fnn, Pool_Id'Unchecked_Access);\n+            --  The default choice is the global pool\n \n-         Append_To (Actions,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Reference_To (RTE (RE_Set_Storage_Pool_Ptr), Loc),\n-             Parameter_Associations => New_List (\n-               New_Reference_To (Coll_Id, Loc),\n-               Make_Attribute_Reference (Loc,\n-                 Prefix =>\n-                   New_Reference_To (Pool_Id, Loc),\n-                 Attribute_Name => Name_Unrestricted_Access))));\n+            else\n+               Pool_Id := RTE (RE_Global_Pool_Object);\n+               Set_Associated_Storage_Pool (Typ, Pool_Id);\n+            end if;\n+\n+            --  Generate:\n+            --    Set_Storage_Pool_Ptr (Fnn, Pool_Id'Unchecked_Access);\n+\n+            Append_To (Actions,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Set_Storage_Pool_Ptr), Loc),\n+                Parameter_Associations => New_List (\n+                  New_Reference_To (Coll_Id, Loc),\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      New_Reference_To (Pool_Id, Loc),\n+                    Attribute_Name => Name_Unrestricted_Access))));\n+         end if;\n \n          Set_Associated_Collection (Typ, Coll_Id);\n \n@@ -2586,6 +2597,8 @@ package body Exp_Ch7 is\n             --  caller finalization chain and deallocates the object. This is\n             --  disabled on .NET/JVM because pools are not supported.\n \n+            --  H505-021 This needs to be revisited on .NET/JVM\n+\n             if VM_Target = No_VM\n               and then Is_Return_Object (Obj_Id)\n             then\n@@ -4429,6 +4442,42 @@ package body Exp_Ch7 is\n       end if;\n    end Make_Adjust_Call;\n \n+   ----------------------\n+   -- Make_Attach_Call --\n+   ----------------------\n+\n+   function Make_Attach_Call\n+     (Obj_Ref : Node_Id;\n+      Ptr_Typ : Entity_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Obj_Ref);\n+\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name =>\n+            New_Reference_To (RTE (RE_Attach), Loc),\n+          Parameter_Associations => New_List (\n+            New_Reference_To (Associated_Collection (Ptr_Typ), Loc),\n+            Unchecked_Convert_To (RTE (RE_Root_Controlled_Ptr), Obj_Ref)));\n+   end Make_Attach_Call;\n+\n+   ----------------------\n+   -- Make_Detach_Call --\n+   ----------------------\n+\n+   function Make_Detach_Call (Obj_Ref : Node_Id) return Node_Id is\n+      Loc : constant Source_Ptr := Sloc (Obj_Ref);\n+\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name =>\n+            New_Reference_To (RTE (RE_Detach), Loc),\n+          Parameter_Associations => New_List (\n+            Unchecked_Convert_To (RTE (RE_Root_Controlled_Ptr), Obj_Ref)));\n+   end Make_Detach_Call;\n+\n    ---------------\n    -- Make_Call --\n    ---------------"}, {"sha": "5ed2a73eae317ec83d3aad786ba07d05cb35e511", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -93,6 +93,24 @@ package Exp_Ch7 is\n    --  adjusted. Typ is the expected type of Obj_Ref. Flag For_Parent must be\n    --  set when an adjustment call is being created for field _parent.\n \n+   function Make_Attach_Call\n+     (Obj_Ref : Node_Id;\n+      Ptr_Typ : Entity_Id) return Node_Id;\n+   --  Create a call to prepend an object to a finalization collection. Obj_Ref\n+   --  is the object, Ptr_Typ is the access type that owns the collection.\n+   --  Generate the following:\n+\n+   --    Ada.Finalization.Heap_Managment.Attach\n+   --      (<Ptr_Typ>FC,\n+   --       System.Finalization_Root.Root_Controlled_Ptr (Obj_Ref));\n+\n+   function Make_Detach_Call (Obj_Ref : Node_Id) return Node_Id;\n+   --  Create a call to unhook an object from an arbitrary list. Obj_Ref is the\n+   --  object. Generate the following:\n+\n+   --    Ada.Finalization.Heap_Management.Detach\n+   --      (System.Finalization_Root.Root_Controlled_Ptr (Obj_Ref));\n+\n    function Make_Final_Call\n      (Obj_Ref    : Node_Id;\n       Typ        : Entity_Id;"}, {"sha": "21585ad0840110bfd089277df7a1a538711b9564", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -53,6 +53,7 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -1009,6 +1010,16 @@ package body Exp_Intr is\n                                          (RTE (RE_Get_Current_Excep),\n                                           Loc))))))))))));\n \n+         --  For .NET/JVM, detach the object from the containing finalization\n+         --  collection before finalizing it.\n+\n+         if VM_Target /= No_VM\n+           and then Is_Controlled (Desig_T)\n+         then\n+            Prepend_To (Final_Code,\n+              Make_Detach_Call (New_Copy_Tree (Arg)));\n+         end if;\n+\n          --  If aborts are allowed, then the finalization code must be\n          --  protected by an abort defer/undefer pair.\n "}, {"sha": "f34c569656e26b84a13e4c3bbea44f1db182bf7a", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -517,8 +517,10 @@ package Rtsfind is\n \n      RE_Add_Offset_To_Address,           -- Ada.Finalization.Heap_Management\n      RE_Allocate,                        -- Ada.Finalization.Heap_Management\n+     RE_Attach,                          -- Ada.Finalization.Heap_Management\n      RE_Base_Pool,                       -- Ada.Finalization.Heap_Management\n      RE_Deallocate,                      -- Ada.Finalization.Heap_Management\n+     RE_Detach,                          -- Ada.Finalization.Heap_Management\n      RE_Finalization_Collection,         -- Ada.Finalization.Heap_Management\n      RE_Finalization_Collection_Ptr,     -- Ada.Finalization.Heap_Management\n      RE_Set_Finalize_Address_Ptr,        -- Ada.Finalization.Heap_Management\n@@ -796,8 +798,7 @@ package Rtsfind is\n      RE_Fat_VAX_G,                       -- System.Fat_VAX_G_Float\n \n      RE_Root_Controlled,                 -- System.Finalization_Root\n-     RE_Finalizable,                     -- System.Finalization_Root\n-     RE_Finalizable_Ptr,                 -- System.Finalization_Root\n+     RE_Root_Controlled_Ptr,             -- System.Finalization_Root\n \n      RE_Fore,                            -- System.Fore\n \n@@ -1694,8 +1695,10 @@ package Rtsfind is\n \n      RE_Add_Offset_To_Address            => Ada_Finalization_Heap_Management,\n      RE_Allocate                         => Ada_Finalization_Heap_Management,\n+     RE_Attach                           => Ada_Finalization_Heap_Management,\n      RE_Base_Pool                        => Ada_Finalization_Heap_Management,\n      RE_Deallocate                       => Ada_Finalization_Heap_Management,\n+     RE_Detach                           => Ada_Finalization_Heap_Management,\n      RE_Finalization_Collection          => Ada_Finalization_Heap_Management,\n      RE_Finalization_Collection_Ptr      => Ada_Finalization_Heap_Management,\n      RE_Set_Finalize_Address_Ptr         => Ada_Finalization_Heap_Management,\n@@ -1973,8 +1976,7 @@ package Rtsfind is\n      RE_Fat_VAX_G                        => System_Fat_VAX_G_Float,\n \n      RE_Root_Controlled                  => System_Finalization_Root,\n-     RE_Finalizable                      => System_Finalization_Root,\n-     RE_Finalizable_Ptr                  => System_Finalization_Root,\n+     RE_Root_Controlled_Ptr              => System_Finalization_Root,\n \n      RE_Fore                             => System_Fore,\n "}, {"sha": "818cc8b6708cf5d61ee9feb8a0976315ae93b6db", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb8dacccffd4eda62517772bef5fd90e03776d7/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=deb8dacccffd4eda62517772bef5fd90e03776d7", "patch": "@@ -195,6 +195,8 @@ package Snames is\n    Name_Adjust                         : constant Name_Id := N + $;\n    Name_Finalize                       : constant Name_Id := N + $;\n    Name_Finalize_Address               : constant Name_Id := N + $;\n+   Name_Next                           : constant Name_Id := N + $;\n+   Name_Prev                           : constant Name_Id := N + $;\n \n    --  Names of allocation routines, also needed by expander\n \n@@ -1202,7 +1204,6 @@ package Snames is\n    Name_Cursor                           : constant Name_Id := N + $;\n    Name_Element                          : constant Name_Id := N + $;\n    Name_Element_Type                     : constant Name_Id := N + $;\n-   Name_Next                             : constant Name_Id := N + $;\n    Name_No_Element                       : constant Name_Id := N + $;\n    Name_Previous                         : constant Name_Id := N + $;\n "}]}