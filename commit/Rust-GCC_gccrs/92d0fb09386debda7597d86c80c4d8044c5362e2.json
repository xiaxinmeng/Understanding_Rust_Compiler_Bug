{"sha": "92d0fb09386debda7597d86c80c4d8044c5362e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJkMGZiMDkzODZkZWJkYTc1OTdkODZjODBjNGQ4MDQ0YzUzNjJlMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-04-09T14:22:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-04-09T14:22:37Z"}, "message": "i386.c (expand_fp_movcc): Fix condition reversal code.\n\n\n\t* i386.c (expand_fp_movcc): Fix condition reversal code.\n\n\t* i386.c (ix86_register_move_cost): Fix handling of reformating penalty\n\t* i386.h (INTEGER_CLASS_P, MAYBE_INTEGER_CLASS_P): New.\n\t(CLASS_MAX_NREGS): Use it.\n\n\t* i386.h (HARD_REGNO_NREGS): Handle properly TF and TCmodes on 64bit;\n\thandle properly complex values.\n\t(CLASS_MAX_NREGS): Likewise; update comment.\n\nFrom-SVN: r41206", "tree": {"sha": "5517fcd5a534b468b61facf3919d33de2993bb51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5517fcd5a534b468b61facf3919d33de2993bb51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92d0fb09386debda7597d86c80c4d8044c5362e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d0fb09386debda7597d86c80c4d8044c5362e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d0fb09386debda7597d86c80c4d8044c5362e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d0fb09386debda7597d86c80c4d8044c5362e2/comments", "author": null, "committer": null, "parents": [{"sha": "600254fc5e694cbf1335be14071d15ce7cd5d57a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600254fc5e694cbf1335be14071d15ce7cd5d57a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600254fc5e694cbf1335be14071d15ce7cd5d57a"}], "stats": {"total": 46, "additions": 34, "deletions": 12}, "files": [{"sha": "286a585c2b079257ea6cfc5d16cf5be6a5b72e3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d0fb09386debda7597d86c80c4d8044c5362e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d0fb09386debda7597d86c80c4d8044c5362e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92d0fb09386debda7597d86c80c4d8044c5362e2", "patch": "@@ -1,3 +1,15 @@\n+Mon Apr  9 16:18:03 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (expand_fp_movcc): Fix condition reversal code.\n+\n+\t* i386.c (ix86_register_move_cost): Fix handling of reformating penalty\n+\t* i386.h (INTEGER_CLASS_P, MAYBE_INTEGER_CLASS_P): New.\n+\t(CLASS_MAX_NREGS): Use it.\n+\n+\t* i386.h (HARD_REGNO_NREGS): Handle properly TF and TCmodes on 64bit;\n+\thandle properly complex values.\n+\t(CLASS_MAX_NREGS): Likewise; update comment.\n+\n 2001-04-05  Bernd Schmidt  <bernds@redhat.com>\n \n \t* ia64.c (ia64_flag_schedule_insns2): New variable."}, {"sha": "a108a97571b5c13ae8846f1bb81ec65132a00367", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d0fb09386debda7597d86c80c4d8044c5362e2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d0fb09386debda7597d86c80c4d8044c5362e2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=92d0fb09386debda7597d86c80c4d8044c5362e2", "patch": "@@ -6605,7 +6605,8 @@ ix86_expand_fp_movcc (operands)\n       /* We may be called from the post-reload splitter.  */\n       && (!REG_P (operands[0])\n \t  || SSE_REG_P (operands[0])\n-\t  || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n+\t  || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+      && 0)\n     {\n       rtx op0 = ix86_compare_op0, op1 = ix86_compare_op1;\n       code = GET_CODE (operands[1]);\n@@ -6668,7 +6669,7 @@ ix86_expand_fp_movcc (operands)\n \t{\n \t  rtx tmp = operands[2];\n \t  operands[2] = operands[3];\n-\t  operands[2] = tmp;\n+\t  operands[3] = tmp;\n \t  operands[1] = gen_rtx_fmt_ee (reverse_condition_maybe_unordered\n \t\t\t\t\t  (GET_CODE (operands[1])),\n \t\t\t\t\tVOIDmode, ix86_compare_op0,\n@@ -10400,13 +10401,13 @@ ix86_register_move_cost (mode, class1, class2)\n      stall.  Count this as arbitarily high cost of 20.  */\n   if (ix86_secondary_memory_needed (class1, class2, mode, 0))\n     {\n+      int add_cost = 0;\n       if (CLASS_MAX_NREGS (class1, mode) > CLASS_MAX_NREGS (class2, mode))\n-\treturn 10;\n+\t  add_cost = 20;\n       return (MEMORY_MOVE_COST (mode, class1, 0)\n-\t      + MEMORY_MOVE_COST (mode, class2, 1));\n+\t      + MEMORY_MOVE_COST (mode, class2, 1) + add_cost);\n     }\n-  /* Moves between SSE/MMX and integer unit are expensive.\n-     ??? We should make this cost CPU specific.  */\n+  /* Moves between SSE/MMX and integer unit are expensive.  */\n   if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)\n       || SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n     return ix86_cost->mmxsse_to_integer;"}, {"sha": "92a347d0b76a37607dd4e2786ede7fe5b9090a5e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d0fb09386debda7597d86c80c4d8044c5362e2/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d0fb09386debda7597d86c80c4d8044c5362e2/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=92d0fb09386debda7597d86c80c4d8044c5362e2", "patch": "@@ -851,9 +851,12 @@ extern int ix86_arch;\n    */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO) ? 1 \\\n+  (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n+   ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n    : (MODE == TFmode\t\t\t\t\t\t\t\\\n-      ? 3\t\t\t\t\t\t\t\t\\\n+      ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n+      : MODE == TCmode\t\t\t\t\t\t\t\\\n+      ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\t\\\n       : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n #define VALID_SSE_REG_MODE(MODE) \\\n@@ -1067,9 +1070,11 @@ enum reg_class\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n+#define INTEGER_CLASS_P(CLASS) (reg_class_subset_p (CLASS, GENERAL_REGS))\n #define FLOAT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, FLOAT_REGS))\n #define SSE_CLASS_P(CLASS) (reg_class_subset_p (CLASS, SSE_REGS))\n #define MMX_CLASS_P(CLASS) (reg_class_subset_p (CLASS, MMX_REGS))\n+#define MAYBE_INTEGER_CLASS_P(CLASS) (reg_classes_intersect_p (CLASS, GENERAL_REGS))\n #define MAYBE_FLOAT_CLASS_P(CLASS) (reg_classes_intersect_p (CLASS, FLOAT_REGS))\n #define MAYBE_SSE_CLASS_P(CLASS) (reg_classes_intersect_p (SSE_REGS, CLASS))\n #define MAYBE_MMX_CLASS_P(CLASS) (reg_classes_intersect_p (MMX_REGS, CLASS))\n@@ -1314,11 +1319,15 @@ enum reg_class\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On the 80386, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n+   except in the FP regs, where a single reg is always enough.\n+   The TFmodes are really just 80bit values, so we use only 3 registers\n+   to hold them, instead of 4, as the size would suggest.\n+ */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n- (FLOAT_CLASS_P (CLASS) || SSE_CLASS_P (CLASS) || MMX_CLASS_P (CLASS)\t\\\n-  ? 1\t\t\t\t\t\t\t\t\t\\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+ (!MAYBE_INTEGER_CLASS_P (CLASS)\t\t\t\t\t\\\n+  ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n+  : ((GET_MODE_SIZE ((MODE) == TFmode ? XFmode : (MODE))\t\t\\\n+     + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* A C expression whose value is nonzero if pseudos that have been\n    assigned to registers of class CLASS would likely be spilled"}]}