{"sha": "b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2NGQ0ZjlkNmNiMTYzZGEzMmQxOWNiMTcyY2JjNGE1ZmZmYjM5YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:16:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:16:47Z"}, "message": "poly_int: vect_no_alias_p\n\nThis patch replaces the two-state vect_no_alias_p with a three-state\nvect_compile_time_alias that handles polynomial segment lengths.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-data-refs.c (vect_no_alias_p): Replace with...\n\t(vect_compile_time_alias): ...this new function.  Do the calculation\n\ton poly_ints rather than trees.\n\t(vect_prune_runtime_alias_test_list): Update call accordingly.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256142", "tree": {"sha": "0e5cc0305a12b6479ab3575e35e4626e455b3389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e5cc0305a12b6479ab3575e35e4626e455b3389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a/comments", "author": null, "committer": null, "parents": [{"sha": "dad55d7014374121fd75112014ccadcfb9653182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad55d7014374121fd75112014ccadcfb9653182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad55d7014374121fd75112014ccadcfb9653182"}], "stats": {"total": 89, "additions": 50, "deletions": 39}, "files": [{"sha": "1f70fcd9cc1c421ec64972bfffd434027b92d4ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "patch": "@@ -1,3 +1,12 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_no_alias_p): Replace with...\n+\t(vect_compile_time_alias): ...this new function.  Do the calculation\n+\ton poly_ints rather than trees.\n+\t(vect_prune_runtime_alias_test_list): Update call accordingly.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0aa0bfd9da47e83588f556dbc54981c423deeed7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "patch": "@@ -3001,52 +3001,49 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n \n /* Function vect_no_alias_p.\n \n-   Given data references A and B with equal base and offset, the alias\n-   relation can be decided at compilation time, return TRUE if they do\n-   not alias to each other; return FALSE otherwise.  SEGMENT_LENGTH_A\n+   Given data references A and B with equal base and offset, see whether\n+   the alias relation can be decided at compilation time.  Return 1 if\n+   it can and the references alias, 0 if it can and the references do\n+   not alias, and -1 if we cannot decide at compile time.  SEGMENT_LENGTH_A\n    and SEGMENT_LENGTH_B are the memory lengths accessed by A and B\n    respectively.  */\n \n-static bool\n-vect_no_alias_p (struct data_reference *a, struct data_reference *b,\n-                 tree segment_length_a, tree segment_length_b)\n+static int\n+vect_compile_time_alias (struct data_reference *a, struct data_reference *b,\n+\t\t\t tree segment_length_a, tree segment_length_b)\n {\n-  gcc_assert (TREE_CODE (DR_INIT (a)) == INTEGER_CST\n-\t      && TREE_CODE (DR_INIT (b)) == INTEGER_CST);\n-  if (tree_int_cst_equal (DR_INIT (a), DR_INIT (b)))\n-    return false;\n+  poly_offset_int offset_a = wi::to_poly_offset (DR_INIT (a));\n+  poly_offset_int offset_b = wi::to_poly_offset (DR_INIT (b));\n+  poly_uint64 const_length_a;\n+  poly_uint64 const_length_b;\n \n-  tree seg_a_min = DR_INIT (a);\n-  tree seg_a_max = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_a_min),\n-\t\t\t\tseg_a_min, segment_length_a);\n   /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n      bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n      [a, a+12) */\n   if (tree_int_cst_compare (DR_STEP (a), size_zero_node) < 0)\n     {\n-      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (a)));\n-      seg_a_min = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_a_max),\n-\t\t\t       seg_a_max, unit_size);\n-      seg_a_max = fold_build2 (PLUS_EXPR, TREE_TYPE (DR_INIT (a)),\n-\t\t\t       DR_INIT (a), unit_size);\n+      const_length_a = (-wi::to_poly_wide (segment_length_a)).force_uhwi ();\n+      offset_a = (offset_a + vect_get_scalar_dr_size (a)) - const_length_a;\n     }\n-  tree seg_b_min = DR_INIT (b);\n-  tree seg_b_max = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_b_min),\n-\t\t\t\tseg_b_min, segment_length_b);\n+  else\n+    const_length_a = tree_to_poly_uint64 (segment_length_a);\n   if (tree_int_cst_compare (DR_STEP (b), size_zero_node) < 0)\n     {\n-      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (b)));\n-      seg_b_min = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_b_max),\n-\t\t\t       seg_b_max, unit_size);\n-      seg_b_max = fold_build2 (PLUS_EXPR, TREE_TYPE (DR_INIT (b)),\n-\t\t\t       DR_INIT (b), unit_size);\n+      const_length_b = (-wi::to_poly_wide (segment_length_b)).force_uhwi ();\n+      offset_b = (offset_b + vect_get_scalar_dr_size (b)) - const_length_b;\n     }\n+  else\n+    const_length_b = tree_to_poly_uint64 (segment_length_b);\n \n-  if (tree_int_cst_le (seg_a_max, seg_b_min)\n-      || tree_int_cst_le (seg_b_max, seg_a_min))\n-    return true;\n+  if (ranges_known_overlap_p (offset_a, const_length_a,\n+\t\t\t      offset_b, const_length_b))\n+    return 1;\n \n-  return false;\n+  if (!ranges_maybe_overlap_p (offset_a, const_length_a,\n+\t\t\t       offset_b, const_length_b))\n+    return 0;\n+\n+  return -1;\n }\n \n /* Return true if the minimum nonzero dependence distance for loop LOOP_DEPTH\n@@ -3188,21 +3185,26 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \tcomp_res = data_ref_compare_tree (DR_OFFSET (dr_a),\n \t\t\t\t\t  DR_OFFSET (dr_b));\n \n-      /* Alias is known at compilation time.  */\n+      /* See whether the alias is known at compilation time.  */\n       if (comp_res == 0\n \t  && TREE_CODE (DR_STEP (dr_a)) == INTEGER_CST\n \t  && TREE_CODE (DR_STEP (dr_b)) == INTEGER_CST\n-\t  && TREE_CODE (segment_length_a) == INTEGER_CST\n-\t  && TREE_CODE (segment_length_b) == INTEGER_CST)\n+\t  && poly_int_tree_p (segment_length_a)\n+\t  && poly_int_tree_p (segment_length_b))\n \t{\n-\t  if (vect_no_alias_p (dr_a, dr_b, segment_length_a, segment_length_b))\n+\t  int res = vect_compile_time_alias (dr_a, dr_b,\n+\t\t\t\t\t     segment_length_a,\n+\t\t\t\t\t     segment_length_b);\n+\t  if (res == 0)\n \t    continue;\n \n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"not vectorized: compilation time alias.\\n\");\n-\n-\t  return false;\n+\t  if (res == 1)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"not vectorized: compilation time alias.\\n\");\n+\t      return false;\n+\t    }\n \t}\n \n       dr_with_seg_len_pair_t dr_with_seg_len_pair"}]}