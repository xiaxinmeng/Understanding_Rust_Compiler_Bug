{"sha": "41195c94583a5f2da9178234bbcdacee27db69ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDExOTVjOTQ1ODNhNWYyZGE5MTc4MjM0YmJjZGFjZWUyN2RiNjlmZg==", "commit": {"author": {"name": "Paul Hilfinger", "email": "hilfinger@adacore.com", "date": "2010-06-22T15:24:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T15:24:10Z"}, "message": "2010-06-22  Paul Hilfinger  <hilfinger@adacore.com>\n\n\t* a-nudira.adb, a-nudira.ads, a-nuflra.adb, a-nuflra.ads,\n\tgnat_rm.texi, impunit.adb, Makefile.rtl, s-rannum.adb\n\t(Random_Float_Template, Random): New method of creating\n\tuniform floating-point variables that allow the creation of all machine\n\tvalues in [0 .. 1).  \n\n\t* g-mbdira.adb, g-mbflra.adb, g-mbdira.ads, g-mbflra.ads: New file.\n\nFrom-SVN: r161191", "tree": {"sha": "7ad4f5d9484bab54aefb464310bc5032a6f6961c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ad4f5d9484bab54aefb464310bc5032a6f6961c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41195c94583a5f2da9178234bbcdacee27db69ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41195c94583a5f2da9178234bbcdacee27db69ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41195c94583a5f2da9178234bbcdacee27db69ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41195c94583a5f2da9178234bbcdacee27db69ff/comments", "author": null, "committer": null, "parents": [{"sha": "07309d58d08122d67d722bc297eb371d9788488c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07309d58d08122d67d722bc297eb371d9788488c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07309d58d08122d67d722bc297eb371d9788488c"}], "stats": {"total": 1588, "additions": 1029, "deletions": 559}, "files": [{"sha": "700fa324ac2858da98c70cfba08b77eef5cfaf4c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -1,3 +1,13 @@\n+2010-06-22  Paul Hilfinger  <hilfinger@adacore.com>\n+\n+\t* a-nudira.adb, a-nudira.ads, a-nuflra.adb, a-nuflra.ads,\n+\tgnat_rm.texi, impunit.adb, Makefile.rtl, s-rannum.adb\n+\t(Random_Float_Template, Random): New method of creating\n+\tuniform floating-point variables that allow the creation of all machine\n+\tvalues in [0 .. 1).  \n+\n+\t* g-mbdira.adb, g-mbflra.adb, g-mbdira.ads, g-mbflra.ads: New file.\n+\n 2010-06-22  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch5.adb (Analyze_Assignment): Revise test for illegal assignment"}, {"sha": "c130ad31a8385c250ed4f37502472ba5e16e0630", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -1,5 +1,5 @@\n # Makefile.rtl for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 2003-2008, Free Software Foundation, Inc.\n+#   Copyright (C) 2003-2010, Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -359,6 +359,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-io$(objext) \\\n   g-io_aux$(objext) \\\n   g-locfil$(objext) \\\n+  g-mbdira$(objext) \\\n+  g-mbflra$(objext) \\\n   g-md5$(objext) \\\n   g-memdum$(objext) \\\n   g-moreex$(objext) \\"}, {"sha": "e17945c07a2bece07c1bc9fcc1b60512d969d9de", "filename": "gcc/ada/a-nudira.adb", "status": "modified", "additions": 32, "deletions": 228, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,9 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Calendar;\n-\n-with Interfaces; use Interfaces;\n+with System.Random_Numbers; use System.Random_Numbers;\n \n package body Ada.Numerics.Discrete_Random is\n \n@@ -49,249 +47,55 @@ package body Ada.Numerics.Discrete_Random is\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n \n-   type Pointer is access all State;\n-\n-   Fits_In_32_Bits : constant Boolean :=\n-                       Rst'Size < 31\n-                         or else (Rst'Size = 31\n-                                  and then Rst'Pos (Rst'First) < 0);\n-   --  This is set True if we do not need more than 32 bits in the result. If\n-   --  we need 64-bits, we will only use the meaningful 48 bits of any 64-bit\n-   --  number generated, since if more than 48 bits are required, we split the\n-   --  computation into two separate parts, since the algorithm does not behave\n-   --  above 48 bits.\n-\n-   --  The way this expression works is that obviously if the size is 31 bits,\n-   --  it fits in 32 bits. In the 32-bit case, it fits in 32-bit signed if the\n-   --  range has negative values. It is too conservative in the case that the\n-   --  programmer has set a size greater than the default, e.g. a size of 33\n-   --  for an integer type with a range of 1..10, but an over-conservative\n-   --  result is OK. The important thing is that the value is only True if\n-   --  we know the result will fit in 32-bits signed. If the value is False\n-   --  when it could be True, the behavior will be correct, just a bit less\n-   --  efficient than it could have been in some unusual cases.\n-   --\n-   --  One might assume that we could get a more accurate result by testing\n-   --  the lower and upper bounds of the type Rst against the bounds of 32-bit\n-   --  Integer. However, there is no easy way to do that. Why? Because in the\n-   --  relatively rare case where this expresion has to be evaluated at run\n-   --  time rather than compile time (when the bounds are dynamic), we need a\n-   --  type to use for the computation. But the possible range of upper bound\n-   --  values for Rst (remembering the possibility of 64-bit modular types) is\n-   --  from -2**63 to 2**64-1, and no run-time type has a big enough range.\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n+   subtype Rep_Generator is System.Random_Numbers.Generator;\n+   subtype Rep_State is System.Random_Numbers.State;\n \n-   function Square_Mod_N (X, N : Int) return Int;\n-   pragma Inline (Square_Mod_N);\n-   --  Computes X**2 mod N avoiding intermediate overflow\n+   function Rep_Random is\n+      new Random_Discrete (Result_Subtype, Result_Subtype'First);\n \n-   -----------\n-   -- Image --\n-   -----------\n-\n-   function Image (Of_State : State) return String is\n+   function Random (Gen : Generator) return Result_Subtype is\n    begin\n-      return Int'Image (Of_State.X1) &\n-             ','                     &\n-             Int'Image (Of_State.X2) &\n-             ','                     &\n-             Int'Image (Of_State.Q);\n-   end Image;\n-\n-   ------------\n-   -- Random --\n-   ------------\n-\n-   function Random (Gen : Generator) return Rst is\n-      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n-      Temp : Int;\n-      TF   : Flt;\n-\n-   begin\n-      --  Check for flat range here, since we are typically run with checks\n-      --  off, note that in practice, this condition will usually be static\n-      --  so we will not actually generate any code for the normal case.\n-\n-      if Rst'Last < Rst'First then\n-         raise Constraint_Error;\n-      end if;\n-\n-      --  Continue with computation if non-flat range\n-\n-      Genp.X1 := Square_Mod_N (Genp.X1, Genp.P);\n-      Genp.X2 := Square_Mod_N (Genp.X2, Genp.Q);\n-      Temp := Genp.X2 - Genp.X1;\n-\n-      --  Following duplication is not an error, it is a loop unwinding!\n-\n-      if Temp < 0 then\n-         Temp := Temp + Genp.Q;\n-      end if;\n-\n-      if Temp < 0 then\n-         Temp := Temp + Genp.Q;\n-      end if;\n-\n-      TF := Offs + (Flt (Temp) * Flt (Genp.P) + Flt (Genp.X1)) * Genp.Scl;\n-\n-      --  Pathological, but there do exist cases where the rounding implicit\n-      --  in calculating the scale factor will cause rounding to 'Last + 1.\n-      --  In those cases, returning 'First results in the least bias.\n-\n-      if TF >= Flt (Rst'Pos (Rst'Last)) + 0.5 then\n-         return Rst'First;\n-\n-      elsif not Fits_In_32_Bits then\n-         return Rst'Val (Interfaces.Integer_64 (TF));\n-\n-      else\n-         return Rst'Val (Int (TF));\n-      end if;\n+      return Rep_Random (Gen.Rep);\n    end Random;\n \n-   -----------\n-   -- Reset --\n-   -----------\n-\n-   procedure Reset (Gen : Generator; Initiator : Integer) is\n-      Genp   : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n-      X1, X2 : Int;\n-\n-   begin\n-      X1 := 2 + Int (Initiator) mod (K1 - 3);\n-      X2 := 2 + Int (Initiator) mod (K2 - 3);\n-\n-      for J in 1 .. 5 loop\n-         X1 := Square_Mod_N (X1, K1);\n-         X2 := Square_Mod_N (X2, K2);\n-      end loop;\n-\n-      --  Eliminate effects of small Initiators\n-\n-      Genp.all :=\n-        (X1  => X1,\n-         X2  => X2,\n-         P   => K1,\n-         Q   => K2,\n-         FP  => K1F,\n-         Scl => Scal);\n-   end Reset;\n-\n-   -----------\n-   -- Reset --\n-   -----------\n-\n-   procedure Reset (Gen : Generator) is\n-      Genp : constant Pointer       := Gen.Gen_State'Unrestricted_Access;\n-      Now  : constant Calendar.Time := Calendar.Clock;\n-      X1   : Int;\n-      X2   : Int;\n-\n+   procedure Reset (Gen       : Generator;\n+                    Initiator : Integer) is\n+      G : Rep_Generator renames Gen.Rep'Unrestricted_Access.all;\n    begin\n-      X1 := Int (Calendar.Year    (Now)) * 12 * 31 +\n-            Int (Calendar.Month   (Now) * 31)     +\n-            Int (Calendar.Day     (Now));\n-\n-      X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));\n-\n-      X1 := 2 + X1 mod (K1 - 3);\n-      X2 := 2 + X2 mod (K2 - 3);\n-\n-      --  Eliminate visible effects of same day starts\n-\n-      for J in 1 .. 5 loop\n-         X1 := Square_Mod_N (X1, K1);\n-         X2 := Square_Mod_N (X2, K2);\n-      end loop;\n-\n-      Genp.all :=\n-        (X1  => X1,\n-         X2  => X2,\n-         P   => K1,\n-         Q   => K2,\n-         FP  => K1F,\n-         Scl => Scal);\n-\n+      Reset (G, Initiator);\n    end Reset;\n \n-   -----------\n-   -- Reset --\n-   -----------\n-\n-   procedure Reset (Gen : Generator; From_State : State) is\n-      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+   procedure Reset (Gen       : Generator) is\n+      G : Rep_Generator renames Gen.Rep'Unrestricted_Access.all;\n    begin\n-      Genp.all := From_State;\n+      Reset (G);\n    end Reset;\n \n-   ----------\n-   -- Save --\n-   ----------\n-\n-   procedure Save (Gen : Generator; To_State : out State) is\n+   procedure Save  (Gen        : Generator;\n+                    To_State   : out State) is\n    begin\n-      To_State := Gen.Gen_State;\n+      Save (Gen.Rep, State (To_State));\n    end Save;\n \n-   ------------------\n-   -- Square_Mod_N --\n-   ------------------\n-\n-   function Square_Mod_N (X, N : Int) return Int is\n+   procedure Reset (Gen        : Generator;\n+                    From_State : State) is\n+      G : Rep_Generator renames Gen.Rep'Unrestricted_Access.all;\n    begin\n-      return Int ((Integer_64 (X) ** 2) mod (Integer_64 (N)));\n-   end Square_Mod_N;\n+      Reset (G, From_State);\n+   end Reset;\n \n-   -----------\n-   -- Value --\n-   -----------\n+   function Image (Of_State    : State)  return String is\n+   begin\n+      return Image (Rep_State (Of_State));\n+   end Image;\n \n    function Value (Coded_State : String) return State is\n-      Last  : constant Natural := Coded_State'Last;\n-      Start : Positive := Coded_State'First;\n-      Stop  : Positive := Coded_State'First;\n-      Outs  : State;\n-\n+      G : Generator;\n+      S : Rep_State;\n    begin\n-      while Stop <= Last and then Coded_State (Stop) /= ',' loop\n-         Stop := Stop + 1;\n-      end loop;\n-\n-      if Stop > Last then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Outs.X1 := Int'Value (Coded_State (Start .. Stop - 1));\n-      Start := Stop + 1;\n-\n-      loop\n-         Stop := Stop + 1;\n-         exit when Stop > Last or else Coded_State (Stop) = ',';\n-      end loop;\n-\n-      if Stop > Last then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Outs.X2  := Int'Value (Coded_State (Start .. Stop - 1));\n-      Outs.Q   := Int'Value (Coded_State (Stop + 1 .. Last));\n-      Outs.P   := Outs.Q * 2 + 1;\n-      Outs.FP  := Flt (Outs.P);\n-      Outs.Scl := (RstL - RstF + 1.0) / (Flt (Outs.P) * Flt (Outs.Q));\n-\n-      --  Now do *some* sanity checks\n-\n-      if Outs.Q < 31\n-        or else Outs.X1 not in 2 .. Outs.P - 1\n-        or else Outs.X2 not in 2 .. Outs.Q - 1\n-      then\n-         raise Constraint_Error;\n-      end if;\n-\n-      return Outs;\n+      Reset (G.Rep, Coded_State);\n+      System.Random_Numbers.Save (G.Rep, S);\n+      return State (S);\n    end Value;\n \n end Ada.Numerics.Discrete_Random;"}, {"sha": "03ce48b38b4225ca4f63d02bec0bd1465f7e345a", "filename": "gcc/ada/a-nudira.ads", "status": "modified", "additions": 9, "deletions": 48, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nudira.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nudira.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.ads?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,39 +33,24 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Note: the implementation used in this package was contributed by Robert\n---  Eachus. It is based on the work of L. Blum, M. Blum, and M. Shub, SIAM\n---  Journal of Computing, Vol 15. No 2, May 1986. The particular choices for P\n---  and Q chosen here guarantee a period of 562,085,314,430,582 (about 2**49),\n---  and the generated sequence has excellent randomness properties. For further\n---  details, see the paper \"Fast Generation of Trustworthy Random Numbers\", by\n---  Robert Eachus, which describes both the algorithm and the efficient\n---  implementation approach used here.\n+--  Note: the implementation used in this package is a version of the\n+--  Mersenne Twister. See s-rannum.adb for details and references.\n \n-with Interfaces;\n+with System.Random_Numbers;\n \n generic\n    type Result_Subtype is (<>);\n \n package Ada.Numerics.Discrete_Random is\n \n-   --  The algorithm used here is reliable from a required statistical point of\n-   --  view only up to 48 bits. We try to behave reasonably in the case of\n-   --  larger types, but we can't guarantee the required properties. So\n-   --  generate a warning for these (slightly) dubious cases.\n-\n-   pragma Compile_Time_Warning\n-     (Result_Subtype'Size > 48,\n-      \"statistical properties not guaranteed for size > 48\");\n-\n    --  Basic facilities\n \n    type Generator is limited private;\n \n    function Random (Gen : Generator) return Result_Subtype;\n \n-   procedure Reset (Gen : Generator);\n    procedure Reset (Gen : Generator; Initiator : Integer);\n+   procedure Reset (Gen : Generator);\n \n    --  Advanced facilities\n \n@@ -74,41 +59,17 @@ package Ada.Numerics.Discrete_Random is\n    procedure Save  (Gen : Generator; To_State   : out State);\n    procedure Reset (Gen : Generator; From_State : State);\n \n-   Max_Image_Width : constant := 80;\n+   Max_Image_Width : constant := System.Random_Numbers.Max_Image_Width;\n \n    function Image (Of_State    : State)  return String;\n    function Value (Coded_State : String) return State;\n \n private\n-   subtype Int is Interfaces.Integer_32;\n-   subtype Rst is Result_Subtype;\n-\n-   --  We prefer to use 14 digits for Flt, but some targets are more limited\n-\n-   type Flt is digits Positive'Min (14, Long_Long_Float'Digits);\n-\n-   RstF : constant Flt := Flt (Rst'Pos (Rst'First));\n-   RstL : constant Flt := Flt (Rst'Pos (Rst'Last));\n-\n-   Offs : constant Flt := RstF - 0.5;\n-\n-   K1   : constant := 94_833_359;\n-   K1F  : constant := 94_833_359.0;\n-   K2   : constant := 47_416_679;\n-   K2F  : constant := 47_416_679.0;\n-   Scal : constant Flt := (RstL - RstF + 1.0) / (K1F * K2F);\n-\n-   type State is record\n-      X1  : Int := Int (2999 ** 2);\n-      X2  : Int := Int (1439 ** 2);\n-      P   : Int := K1;\n-      Q   : Int := K2;\n-      FP  : Flt := K1F;\n-      Scl : Flt := Scal;\n-   end record;\n \n    type Generator is limited record\n-      Gen_State : State;\n+      Rep : System.Random_Numbers.Generator;\n    end record;\n \n+   type State is new System.Random_Numbers.State;\n+\n end Ada.Numerics.Discrete_Random;"}, {"sha": "e58ff9247c23326fbe4cb01ee5069b0dbdbb5bff", "filename": "gcc/ada/a-nuflra.adb", "status": "modified", "additions": 32, "deletions": 220, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nuflra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nuflra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nuflra.adb?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Calendar;\n+with Interfaces; use Interfaces;\n+\n+with System.Random_Numbers; use System.Random_Numbers;\n \n package body Ada.Numerics.Float_Random is\n \n@@ -47,105 +49,16 @@ package body Ada.Numerics.Float_Random is\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n \n-   type Pointer is access all State;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Euclid (P, Q : Int; X, Y : out Int; GCD : out Int);\n-\n-   function  Euclid (P, Q : Int) return Int;\n-\n-   function Square_Mod_N (X, N : Int) return Int;\n-\n-   ------------\n-   -- Euclid --\n-   ------------\n-\n-   procedure Euclid (P, Q : Int; X, Y : out Int; GCD : out Int) is\n-\n-      XT : Int := 1;\n-      YT : Int := 0;\n-\n-      procedure Recur\n-        (P,  Q  : Int;                    --  a (i-1), a (i)\n-         X,  Y  : Int;                    --  x (i),   y (i)\n-         XP, YP : in out Int;             --  x (i-1), y (i-1)\n-         GCD    : out Int);\n-\n-      procedure Recur\n-        (P,  Q  : Int;\n-         X,  Y  : Int;\n-         XP, YP : in out Int;\n-         GCD    : out Int)\n-      is\n-         Quo : Int := P / Q;              --  q <-- |_ a (i-1) / a (i) _|\n-         XT  : Int := X;                  --  x (i)\n-         YT  : Int := Y;                  --  y (i)\n-\n-      begin\n-         if P rem Q = 0 then                 --  while does not divide\n-            GCD := Q;\n-            XP  := X;\n-            YP  := Y;\n-         else\n-            Recur (Q, P - Q * Quo, XP - Quo * X, YP - Quo * Y, XT, YT, Quo);\n-\n-            --  a (i) <== a (i)\n-            --  a (i+1) <-- a (i-1) - q*a (i)\n-            --  x (i+1) <-- x (i-1) - q*x (i)\n-            --  y (i+1) <-- y (i-1) - q*y (i)\n-            --  x (i) <== x (i)\n-            --  y (i) <== y (i)\n-\n-            XP  := XT;\n-            YP  := YT;\n-            GCD := Quo;\n-         end if;\n-      end Recur;\n-\n-   --  Start of processing for Euclid\n-\n-   begin\n-      Recur (P, Q, 0, 1, XT, YT, GCD);\n-      X := XT;\n-      Y := YT;\n-   end Euclid;\n-\n-   function Euclid (P, Q : Int) return Int is\n-      X, Y, GCD : Int;\n-      pragma Unreferenced (Y, GCD);\n-   begin\n-      Euclid (P, Q, X, Y, GCD);\n-      return X;\n-   end Euclid;\n-\n-   -----------\n-   -- Image --\n-   -----------\n-\n-   function Image (Of_State : State) return String is\n-   begin\n-      return Int'Image (Of_State.X1) & ',' & Int'Image (Of_State.X2)\n-             & ',' &\n-             Int'Image (Of_State.P)  & ',' & Int'Image (Of_State.Q);\n-   end Image;\n+   subtype Rep_Generator is System.Random_Numbers.Generator;\n+   subtype Rep_State is System.Random_Numbers.State;\n \n    ------------\n    -- Random --\n    ------------\n \n-   function Random  (Gen : Generator) return Uniformly_Distributed is\n-      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n-\n+   function Random (Gen : Generator) return Uniformly_Distributed is\n    begin\n-      Genp.X1 := Square_Mod_N (Genp.X1,  Genp.P);\n-      Genp.X2 := Square_Mod_N (Genp.X2,  Genp.Q);\n-      return\n-        Float ((Flt (((Genp.X2 - Genp.X1) * Genp.X)\n-                  mod Genp.Q) * Flt (Genp.P)\n-          + Flt (Genp.X1)) * Genp.Scl);\n+      return Random (Gen.Rep);\n    end Random;\n \n    -----------\n@@ -155,157 +68,56 @@ package body Ada.Numerics.Float_Random is\n    --  Version that works from given initiator value\n \n    procedure Reset (Gen : Generator; Initiator : Integer) is\n-      Genp   : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n-      X1, X2 : Int;\n-\n+      G : Rep_Generator renames Gen.Rep'Unrestricted_Access.all;\n    begin\n-      X1 := 2 + Int (Initiator) mod (K1 - 3);\n-      X2 := 2 + Int (Initiator) mod (K2 - 3);\n-\n-      --  Eliminate effects of small initiators\n-\n-      for J in 1 .. 5 loop\n-         X1 := Square_Mod_N (X1, K1);\n-         X2 := Square_Mod_N (X2, K2);\n-      end loop;\n-\n-      Genp.all :=\n-        (X1  => X1,\n-         X2  => X2,\n-         P   => K1,\n-         Q   => K2,\n-         X   => 1,\n-         Scl => Scal);\n-   end Reset;\n-\n-   --  Version that works from specific saved state\n-\n-   procedure Reset (Gen : Generator; From_State : State) is\n-      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n-\n-   begin\n-      Genp.all := From_State;\n+      Reset (G, Integer_32 (Initiator));\n    end Reset;\n \n    --  Version that works from calendar\n \n    procedure Reset (Gen : Generator) is\n-      Genp   : constant Pointer       := Gen.Gen_State'Unrestricted_Access;\n-      Now    : constant Calendar.Time := Calendar.Clock;\n-      X1, X2 : Int;\n-\n+      G : Rep_Generator renames Gen.Rep'Unrestricted_Access.all;\n    begin\n-      X1 := Int (Calendar.Year  (Now)) * 12 * 31 +\n-            Int (Calendar.Month (Now)) * 31 +\n-            Int (Calendar.Day   (Now));\n-\n-      X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));\n-\n-      X1 := 2 + X1 mod (K1 - 3);\n-      X2 := 2 + X2 mod (K2 - 3);\n-\n-      --  Eliminate visible effects of same day starts\n-\n-      for J in 1 .. 5 loop\n-         X1 := Square_Mod_N (X1, K1);\n-         X2 := Square_Mod_N (X2, K2);\n-      end loop;\n+      Reset (G);\n+   end Reset;\n \n-      Genp.all :=\n-        (X1  => X1,\n-         X2  => X2,\n-         P   => K1,\n-         Q   => K2,\n-         X   => 1,\n-         Scl => Scal);\n+   --  Version that works from specific saved state\n \n+   procedure Reset (Gen : Generator; From_State : State) is\n+      G : Rep_Generator renames Gen.Rep'Unrestricted_Access.all;\n+   begin\n+      Reset (G, From_State);\n    end Reset;\n \n    ----------\n    -- Save --\n    ----------\n \n-   procedure Save (Gen : Generator; To_State : out State) is\n+   procedure Save  (Gen : Generator; To_State : out State) is\n    begin\n-      To_State := Gen.Gen_State;\n+      Save (Gen.Rep, State (To_State));\n    end Save;\n \n-   ------------------\n-   -- Square_Mod_N --\n-   ------------------\n-\n-   function Square_Mod_N (X, N : Int) return Int is\n-      Temp : constant Flt := Flt (X) * Flt (X);\n-      Div  : Int;\n+   -----------\n+   -- Image --\n+   -----------\n \n+   function Image (Of_State : State) return String is\n    begin\n-      Div := Int (Temp / Flt (N));\n-      Div := Int (Temp - Flt (Div) * Flt (N));\n-\n-      if Div < 0 then\n-         return Div + N;\n-      else\n-         return Div;\n-      end if;\n-   end Square_Mod_N;\n+      return Image (Rep_State (Of_State));\n+   end Image;\n \n    -----------\n    -- Value --\n    -----------\n \n    function Value (Coded_State : String) return State is\n-      Last  : constant Natural := Coded_State'Last;\n-      Start : Positive := Coded_State'First;\n-      Stop  : Positive := Coded_State'First;\n-      Outs  : State;\n-\n+      G : Generator;\n+      S : Rep_State;\n    begin\n-      while Stop <= Last and then Coded_State (Stop) /= ',' loop\n-         Stop := Stop + 1;\n-      end loop;\n-\n-      if Stop > Last then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Outs.X1 := Int'Value (Coded_State (Start .. Stop - 1));\n-      Start := Stop + 1;\n-\n-      loop\n-         Stop := Stop + 1;\n-         exit when Stop > Last or else Coded_State (Stop) = ',';\n-      end loop;\n-\n-      if Stop > Last then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Outs.X2 := Int'Value (Coded_State (Start .. Stop - 1));\n-      Start := Stop + 1;\n-\n-      loop\n-         Stop := Stop + 1;\n-         exit when Stop > Last or else Coded_State (Stop) = ',';\n-      end loop;\n-\n-      if Stop > Last then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Outs.P   := Int'Value (Coded_State (Start .. Stop - 1));\n-      Outs.Q   := Int'Value (Coded_State (Stop + 1 .. Last));\n-      Outs.X   := Euclid (Outs.P, Outs.Q);\n-      Outs.Scl := 1.0 / (Flt (Outs.P) * Flt (Outs.Q));\n-\n-      --  Now do *some* sanity checks\n-\n-      if Outs.Q < 31 or else Outs.P < 31\n-        or else Outs.X1 not in 2 .. Outs.P - 1\n-        or else Outs.X2 not in 2 .. Outs.Q - 1\n-      then\n-         raise Constraint_Error;\n-      end if;\n-\n-      return Outs;\n+      Reset (G.Rep, Coded_State);\n+      System.Random_Numbers.Save (G.Rep, S);\n+      return State (S);\n    end Value;\n+\n end Ada.Numerics.Float_Random;"}, {"sha": "9f8308121bba8eebe3fd19443f6847ac7d2da68f", "filename": "gcc/ada/a-nuflra.ads", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nuflra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fa-nuflra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nuflra.ads?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,17 +33,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Note: the implementation used in this package was contributed by\n---  Robert Eachus. It is based on the work of L. Blum, M. Blum, and\n---  M. Shub, SIAM Journal of Computing, Vol 15. No 2, May 1986. The\n---  particular choices for P and Q chosen here guarantee a period of\n---  562,085,314,430,582 (about 2**49), and the generated sequence has\n---  excellent randomness properties. For further details, see the\n---  paper \"Fast Generation of Trustworthy Random Numbers\", by Robert\n---  Eachus, which describes both the algorithm and the efficient\n---  implementation approach used here.\n+--  Note: the implementation used in this package is a version of the\n+--  Mersenne Twister. See s-rannum.adb for details and references.\n \n-with Interfaces;\n+with System.Random_Numbers;\n \n package Ada.Numerics.Float_Random is\n \n@@ -65,35 +58,17 @@ package Ada.Numerics.Float_Random is\n    procedure Save  (Gen : Generator; To_State   : out State);\n    procedure Reset (Gen : Generator; From_State : State);\n \n-   Max_Image_Width : constant := 80;\n+   Max_Image_Width : constant := System.Random_Numbers.Max_Image_Width;\n \n    function Image (Of_State    : State)  return String;\n    function Value (Coded_State : String) return State;\n \n private\n-   type Int is new Interfaces.Integer_32;\n-\n-   --  We prefer to use 14 digits for Flt, but some targets are more limited\n-\n-   type Flt is digits Positive'Min (14, Long_Long_Float'Digits);\n-\n-   K1   : constant := 94_833_359;\n-   K1F  : constant := 94_833_359.0;\n-   K2   : constant := 47_416_679;\n-   K2F  : constant := 47_416_679.0;\n-   Scal : constant := 1.0 / (K1F * K2F);\n-\n-   type State is record\n-      X1  : Int := 2999 ** 2;      --  Square mod p\n-      X2  : Int := 1439 ** 2;      --  Square mod q\n-      P   : Int := K1;\n-      Q   : Int := K2;\n-      X   : Int := 1;\n-      Scl : Flt := Scal;\n-   end record;\n \n    type Generator is limited record\n-      Gen_State : State;\n+      Rep : System.Random_Numbers.Generator;\n    end record;\n \n+   type State is new System.Random_Numbers.State;\n+\n end Ada.Numerics.Float_Random;"}, {"sha": "20cb746d3399bdc231563ea8468284d95495fa6e", "filename": "gcc/ada/g-mbdira.adb", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbdira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbdira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbdira.adb?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -0,0 +1,299 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . M B S S _ D I S C R E T E _ R A N D O M             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;\n+\n+with Interfaces; use Interfaces;\n+\n+package body GNAT.MBBS_Discrete_Random is\n+\n+   -------------------------\n+   -- Implementation Note --\n+   -------------------------\n+\n+   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  permitting in-out parameters for function formals (most naturally\n+   --  Generator values would be passed this way). In pure Ada 95, the only\n+   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n+   --  controlled types.\n+\n+   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  get a pointer to the state in the passed Generator. This works because\n+   --  Generator is a limited type and will thus always be passed by reference.\n+\n+   package Calendar renames Ada.Calendar;\n+\n+   type Pointer is access all State;\n+\n+   Fits_In_32_Bits : constant Boolean :=\n+                       Rst'Size < 31\n+                         or else (Rst'Size = 31\n+                                  and then Rst'Pos (Rst'First) < 0);\n+   --  This is set True if we do not need more than 32 bits in the result. If\n+   --  we need 64-bits, we will only use the meaningful 48 bits of any 64-bit\n+   --  number generated, since if more than 48 bits are required, we split the\n+   --  computation into two separate parts, since the algorithm does not behave\n+   --  above 48 bits.\n+\n+   --  The way this expression works is that obviously if the size is 31 bits,\n+   --  it fits in 32 bits. In the 32-bit case, it fits in 32-bit signed if the\n+   --  range has negative values. It is too conservative in the case that the\n+   --  programmer has set a size greater than the default, e.g. a size of 33\n+   --  for an integer type with a range of 1..10, but an over-conservative\n+   --  result is OK. The important thing is that the value is only True if\n+   --  we know the result will fit in 32-bits signed. If the value is False\n+   --  when it could be True, the behavior will be correct, just a bit less\n+   --  efficient than it could have been in some unusual cases.\n+   --\n+   --  One might assume that we could get a more accurate result by testing\n+   --  the lower and upper bounds of the type Rst against the bounds of 32-bit\n+   --  Integer. However, there is no easy way to do that. Why? Because in the\n+   --  relatively rare case where this expresion has to be evaluated at run\n+   --  time rather than compile time (when the bounds are dynamic), we need a\n+   --  type to use for the computation. But the possible range of upper bound\n+   --  values for Rst (remembering the possibility of 64-bit modular types) is\n+   --  from -2**63 to 2**64-1, and no run-time type has a big enough range.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Square_Mod_N (X, N : Int) return Int;\n+   pragma Inline (Square_Mod_N);\n+   --  Computes X**2 mod N avoiding intermediate overflow\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Of_State : State) return String is\n+   begin\n+      return Int'Image (Of_State.X1) &\n+             ','                     &\n+             Int'Image (Of_State.X2) &\n+             ','                     &\n+             Int'Image (Of_State.Q);\n+   end Image;\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   function Random (Gen : Generator) return Rst is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+      Temp : Int;\n+      TF   : Flt;\n+\n+   begin\n+      --  Check for flat range here, since we are typically run with checks\n+      --  off, note that in practice, this condition will usually be static\n+      --  so we will not actually generate any code for the normal case.\n+\n+      if Rst'Last < Rst'First then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Continue with computation if non-flat range\n+\n+      Genp.X1 := Square_Mod_N (Genp.X1, Genp.P);\n+      Genp.X2 := Square_Mod_N (Genp.X2, Genp.Q);\n+      Temp := Genp.X2 - Genp.X1;\n+\n+      --  Following duplication is not an error, it is a loop unwinding!\n+\n+      if Temp < 0 then\n+         Temp := Temp + Genp.Q;\n+      end if;\n+\n+      if Temp < 0 then\n+         Temp := Temp + Genp.Q;\n+      end if;\n+\n+      TF := Offs + (Flt (Temp) * Flt (Genp.P) + Flt (Genp.X1)) * Genp.Scl;\n+\n+      --  Pathological, but there do exist cases where the rounding implicit\n+      --  in calculating the scale factor will cause rounding to 'Last + 1.\n+      --  In those cases, returning 'First results in the least bias.\n+\n+      if TF >= Flt (Rst'Pos (Rst'Last)) + 0.5 then\n+         return Rst'First;\n+\n+      elsif not Fits_In_32_Bits then\n+         return Rst'Val (Interfaces.Integer_64 (TF));\n+\n+      else\n+         return Rst'Val (Int (TF));\n+      end if;\n+   end Random;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : Generator; Initiator : Integer) is\n+      Genp   : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+      X1, X2 : Int;\n+\n+   begin\n+      X1 := 2 + Int (Initiator) mod (K1 - 3);\n+      X2 := 2 + Int (Initiator) mod (K2 - 3);\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      --  Eliminate effects of small Initiators\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         FP  => K1F,\n+         Scl => Scal);\n+   end Reset;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : Generator) is\n+      Genp : constant Pointer       := Gen.Gen_State'Unrestricted_Access;\n+      Now  : constant Calendar.Time := Calendar.Clock;\n+      X1   : Int;\n+      X2   : Int;\n+\n+   begin\n+      X1 := Int (Calendar.Year    (Now)) * 12 * 31 +\n+            Int (Calendar.Month   (Now) * 31)     +\n+            Int (Calendar.Day     (Now));\n+\n+      X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));\n+\n+      X1 := 2 + X1 mod (K1 - 3);\n+      X2 := 2 + X2 mod (K2 - 3);\n+\n+      --  Eliminate visible effects of same day starts\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         FP  => K1F,\n+         Scl => Scal);\n+\n+   end Reset;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : Generator; From_State : State) is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+   begin\n+      Genp.all := From_State;\n+   end Reset;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   procedure Save (Gen : Generator; To_State : out State) is\n+   begin\n+      To_State := Gen.Gen_State;\n+   end Save;\n+\n+   ------------------\n+   -- Square_Mod_N --\n+   ------------------\n+\n+   function Square_Mod_N (X, N : Int) return Int is\n+   begin\n+      return Int ((Integer_64 (X) ** 2) mod (Integer_64 (N)));\n+   end Square_Mod_N;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Coded_State : String) return State is\n+      Last  : constant Natural := Coded_State'Last;\n+      Start : Positive := Coded_State'First;\n+      Stop  : Positive := Coded_State'First;\n+      Outs  : State;\n+\n+   begin\n+      while Stop <= Last and then Coded_State (Stop) /= ',' loop\n+         Stop := Stop + 1;\n+      end loop;\n+\n+      if Stop > Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Outs.X1 := Int'Value (Coded_State (Start .. Stop - 1));\n+      Start := Stop + 1;\n+\n+      loop\n+         Stop := Stop + 1;\n+         exit when Stop > Last or else Coded_State (Stop) = ',';\n+      end loop;\n+\n+      if Stop > Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Outs.X2  := Int'Value (Coded_State (Start .. Stop - 1));\n+      Outs.Q   := Int'Value (Coded_State (Stop + 1 .. Last));\n+      Outs.P   := Outs.Q * 2 + 1;\n+      Outs.FP  := Flt (Outs.P);\n+      Outs.Scl := (RstL - RstF + 1.0) / (Flt (Outs.P) * Flt (Outs.Q));\n+\n+      --  Now do *some* sanity checks\n+\n+      if Outs.Q < 31\n+        or else Outs.X1 not in 2 .. Outs.P - 1\n+        or else Outs.X2 not in 2 .. Outs.Q - 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Outs;\n+   end Value;\n+\n+end GNAT.MBBS_Discrete_Random;"}, {"sha": "5c614e4ec425b6032fdce475799dc6de57cb91d2", "filename": "gcc/ada/g-mbdira.ads", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbdira.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbdira.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbdira.ads?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -0,0 +1,118 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . M B S S _ D I S C R E T E _ R A N D O M             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The implementation used in this package was contributed by Robert\n+--  Eachus. It is based on the work of L. Blum, M. Blum, and M. Shub, SIAM\n+--  Journal of Computing, Vol 15. No 2, May 1986. The particular choices for P\n+--  and Q chosen here guarantee a period of 562,085,314,430,582 (about 2**49),\n+--  and the generated sequence has excellent randomness properties. For further\n+--  details, see the paper \"Fast Generation of Trustworthy Random Numbers\", by\n+--  Robert Eachus, which describes both the algorithm and the efficient\n+--  implementation approach used here.\n+\n+--  Formerly, this package was Ada.Numerics.Discrete_Random. It is retained\n+--  here in part to allow users to reconstruct number sequences generated\n+--  by previous versions.\n+\n+with Interfaces;\n+\n+generic\n+   type Result_Subtype is (<>);\n+\n+package GNAT.MBBS_Discrete_Random is\n+\n+   --  The algorithm used here is reliable from a required statistical point of\n+   --  view only up to 48 bits. We try to behave reasonably in the case of\n+   --  larger types, but we can't guarantee the required properties. So\n+   --  generate a warning for these (slightly) dubious cases.\n+\n+   pragma Compile_Time_Warning\n+     (Result_Subtype'Size > 48,\n+      \"statistical properties not guaranteed for size > 48\");\n+\n+   --  Basic facilities\n+\n+   type Generator is limited private;\n+\n+   function Random (Gen : Generator) return Result_Subtype;\n+\n+   procedure Reset (Gen : Generator);\n+   procedure Reset (Gen : Generator; Initiator : Integer);\n+\n+   --  Advanced facilities\n+\n+   type State is private;\n+\n+   procedure Save  (Gen : Generator; To_State   : out State);\n+   procedure Reset (Gen : Generator; From_State : State);\n+\n+   Max_Image_Width : constant := 80;\n+\n+   function Image (Of_State    : State)  return String;\n+   function Value (Coded_State : String) return State;\n+\n+private\n+   subtype Int is Interfaces.Integer_32;\n+   subtype Rst is Result_Subtype;\n+\n+   --  We prefer to use 14 digits for Flt, but some targets are more limited\n+\n+   type Flt is digits Positive'Min (14, Long_Long_Float'Digits);\n+\n+   RstF : constant Flt := Flt (Rst'Pos (Rst'First));\n+   RstL : constant Flt := Flt (Rst'Pos (Rst'Last));\n+\n+   Offs : constant Flt := RstF - 0.5;\n+\n+   K1   : constant := 94_833_359;\n+   K1F  : constant := 94_833_359.0;\n+   K2   : constant := 47_416_679;\n+   K2F  : constant := 47_416_679.0;\n+   Scal : constant Flt := (RstL - RstF + 1.0) / (K1F * K2F);\n+\n+   type State is record\n+      X1  : Int := Int (2999 ** 2);\n+      X2  : Int := Int (1439 ** 2);\n+      P   : Int := K1;\n+      Q   : Int := K2;\n+      FP  : Flt := K1F;\n+      Scl : Flt := Scal;\n+   end record;\n+\n+   type Generator is limited record\n+      Gen_State : State;\n+   end record;\n+\n+end GNAT.MBBS_Discrete_Random;"}, {"sha": "cf455707f64e8c3722160ac226ac448dadecc447", "filename": "gcc/ada/g-mbflra.adb", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbflra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbflra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbflra.adb?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -0,0 +1,313 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               G N A T . M B S S _ F L O A T _ R A N D O M                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;\n+\n+package body GNAT.MBBS_Float_Random is\n+\n+   -------------------------\n+   -- Implementation Note --\n+   -------------------------\n+\n+   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  permitting in-out parameters for function formals (most naturally\n+   --  Generator values would be passed this way). In pure Ada 95, the only\n+   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n+   --  controlled types.\n+\n+   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  get a pointer to the state in the passed Generator. This works because\n+   --  Generator is a limited type and will thus always be passed by reference.\n+\n+   package Calendar renames Ada.Calendar;\n+\n+   type Pointer is access all State;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Euclid (P, Q : Int; X, Y : out Int; GCD : out Int);\n+\n+   function  Euclid (P, Q : Int) return Int;\n+\n+   function Square_Mod_N (X, N : Int) return Int;\n+\n+   ------------\n+   -- Euclid --\n+   ------------\n+\n+   procedure Euclid (P, Q : Int; X, Y : out Int; GCD : out Int) is\n+\n+      XT : Int := 1;\n+      YT : Int := 0;\n+\n+      procedure Recur\n+        (P,  Q  : Int;                    --  a (i-1), a (i)\n+         X,  Y  : Int;                    --  x (i),   y (i)\n+         XP, YP : in out Int;             --  x (i-1), y (i-1)\n+         GCD    : out Int);\n+\n+      procedure Recur\n+        (P,  Q  : Int;\n+         X,  Y  : Int;\n+         XP, YP : in out Int;\n+         GCD    : out Int)\n+      is\n+         Quo : Int := P / Q;              --  q <-- |_ a (i-1) / a (i) _|\n+         XT  : Int := X;                  --  x (i)\n+         YT  : Int := Y;                  --  y (i)\n+\n+      begin\n+         if P rem Q = 0 then                 --  while does not divide\n+            GCD := Q;\n+            XP  := X;\n+            YP  := Y;\n+         else\n+            Recur (Q, P - Q * Quo, XP - Quo * X, YP - Quo * Y, XT, YT, Quo);\n+\n+            --  a (i) <== a (i)\n+            --  a (i+1) <-- a (i-1) - q*a (i)\n+            --  x (i+1) <-- x (i-1) - q*x (i)\n+            --  y (i+1) <-- y (i-1) - q*y (i)\n+            --  x (i) <== x (i)\n+            --  y (i) <== y (i)\n+\n+            XP  := XT;\n+            YP  := YT;\n+            GCD := Quo;\n+         end if;\n+      end Recur;\n+\n+   --  Start of processing for Euclid\n+\n+   begin\n+      Recur (P, Q, 0, 1, XT, YT, GCD);\n+      X := XT;\n+      Y := YT;\n+   end Euclid;\n+\n+   function Euclid (P, Q : Int) return Int is\n+      X, Y, GCD : Int;\n+      pragma Unreferenced (Y, GCD);\n+   begin\n+      Euclid (P, Q, X, Y, GCD);\n+      return X;\n+   end Euclid;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Of_State : State) return String is\n+   begin\n+      return Int'Image (Of_State.X1) & ',' & Int'Image (Of_State.X2)\n+             & ',' &\n+             Int'Image (Of_State.P)  & ',' & Int'Image (Of_State.Q);\n+   end Image;\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   function Random  (Gen : Generator) return Uniformly_Distributed is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+\n+   begin\n+      Genp.X1 := Square_Mod_N (Genp.X1,  Genp.P);\n+      Genp.X2 := Square_Mod_N (Genp.X2,  Genp.Q);\n+      return\n+        Float ((Flt (((Genp.X2 - Genp.X1) * Genp.X)\n+                  mod Genp.Q) * Flt (Genp.P)\n+          + Flt (Genp.X1)) * Genp.Scl);\n+   end Random;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   --  Version that works from given initiator value\n+\n+   procedure Reset (Gen : Generator; Initiator : Integer) is\n+      Genp   : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+      X1, X2 : Int;\n+\n+   begin\n+      X1 := 2 + Int (Initiator) mod (K1 - 3);\n+      X2 := 2 + Int (Initiator) mod (K2 - 3);\n+\n+      --  Eliminate effects of small initiators\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         X   => 1,\n+         Scl => Scal);\n+   end Reset;\n+\n+   --  Version that works from specific saved state\n+\n+   procedure Reset (Gen : Generator; From_State : State) is\n+      Genp : constant Pointer := Gen.Gen_State'Unrestricted_Access;\n+\n+   begin\n+      Genp.all := From_State;\n+   end Reset;\n+\n+   --  Version that works from calendar\n+\n+   procedure Reset (Gen : Generator) is\n+      Genp   : constant Pointer       := Gen.Gen_State'Unrestricted_Access;\n+      Now    : constant Calendar.Time := Calendar.Clock;\n+      X1, X2 : Int;\n+\n+   begin\n+      X1 := Int (Calendar.Year  (Now)) * 12 * 31 +\n+            Int (Calendar.Month (Now)) * 31 +\n+            Int (Calendar.Day   (Now));\n+\n+      X2 := Int (Calendar.Seconds (Now) * Duration (1000.0));\n+\n+      X1 := 2 + X1 mod (K1 - 3);\n+      X2 := 2 + X2 mod (K2 - 3);\n+\n+      --  Eliminate visible effects of same day starts\n+\n+      for J in 1 .. 5 loop\n+         X1 := Square_Mod_N (X1, K1);\n+         X2 := Square_Mod_N (X2, K2);\n+      end loop;\n+\n+      Genp.all :=\n+        (X1  => X1,\n+         X2  => X2,\n+         P   => K1,\n+         Q   => K2,\n+         X   => 1,\n+         Scl => Scal);\n+\n+   end Reset;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   procedure Save (Gen : Generator; To_State : out State) is\n+   begin\n+      To_State := Gen.Gen_State;\n+   end Save;\n+\n+   ------------------\n+   -- Square_Mod_N --\n+   ------------------\n+\n+   function Square_Mod_N (X, N : Int) return Int is\n+      Temp : constant Flt := Flt (X) * Flt (X);\n+      Div  : Int;\n+\n+   begin\n+      Div := Int (Temp / Flt (N));\n+      Div := Int (Temp - Flt (Div) * Flt (N));\n+\n+      if Div < 0 then\n+         return Div + N;\n+      else\n+         return Div;\n+      end if;\n+   end Square_Mod_N;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Coded_State : String) return State is\n+      Last  : constant Natural := Coded_State'Last;\n+      Start : Positive := Coded_State'First;\n+      Stop  : Positive := Coded_State'First;\n+      Outs  : State;\n+\n+   begin\n+      while Stop <= Last and then Coded_State (Stop) /= ',' loop\n+         Stop := Stop + 1;\n+      end loop;\n+\n+      if Stop > Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Outs.X1 := Int'Value (Coded_State (Start .. Stop - 1));\n+      Start := Stop + 1;\n+\n+      loop\n+         Stop := Stop + 1;\n+         exit when Stop > Last or else Coded_State (Stop) = ',';\n+      end loop;\n+\n+      if Stop > Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Outs.X2 := Int'Value (Coded_State (Start .. Stop - 1));\n+      Start := Stop + 1;\n+\n+      loop\n+         Stop := Stop + 1;\n+         exit when Stop > Last or else Coded_State (Stop) = ',';\n+      end loop;\n+\n+      if Stop > Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Outs.P   := Int'Value (Coded_State (Start .. Stop - 1));\n+      Outs.Q   := Int'Value (Coded_State (Stop + 1 .. Last));\n+      Outs.X   := Euclid (Outs.P, Outs.Q);\n+      Outs.Scl := 1.0 / (Flt (Outs.P) * Flt (Outs.Q));\n+\n+      --  Now do *some* sanity checks\n+\n+      if Outs.Q < 31 or else Outs.P < 31\n+        or else Outs.X1 not in 2 .. Outs.P - 1\n+        or else Outs.X2 not in 2 .. Outs.Q - 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Outs;\n+   end Value;\n+end GNAT.MBBS_Float_Random;"}, {"sha": "f9ad5af42385aea6cf4763c003f4dbbfcbdbd998", "filename": "gcc/ada/g-mbflra.ads", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbflra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fg-mbflra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbflra.ads?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -0,0 +1,103 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               G N A T . M B S S _ F L O A T _ R A N D O M                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  The implementation used in this package was contributed by\n+--  Robert Eachus. It is based on the work of L. Blum, M. Blum, and\n+--  M. Shub, SIAM Journal of Computing, Vol 15. No 2, May 1986. The\n+--  particular choices for P and Q chosen here guarantee a period of\n+--  562,085,314,430,582 (about 2**49), and the generated sequence has\n+--  excellent randomness properties. For further details, see the\n+--  paper \"Fast Generation of Trustworthy Random Numbers\", by Robert\n+--  Eachus, which describes both the algorithm and the efficient\n+--  implementation approach used here.\n+\n+--  Formerly, this package was Ada.Numerics.Float_Random. It is retained\n+--  here in part to allow users to reconstruct number sequences generated\n+--  by previous versions.\n+\n+with Interfaces;\n+\n+package GNAT.MBBS_Float_Random is\n+\n+   --  Basic facilities\n+\n+   type Generator is limited private;\n+\n+   subtype Uniformly_Distributed is Float range 0.0 .. 1.0;\n+\n+   function Random (Gen : Generator) return Uniformly_Distributed;\n+\n+   procedure Reset (Gen : Generator);\n+   procedure Reset (Gen : Generator; Initiator : Integer);\n+\n+   --  Advanced facilities\n+\n+   type State is private;\n+\n+   procedure Save  (Gen : Generator; To_State   : out State);\n+   procedure Reset (Gen : Generator; From_State : State);\n+\n+   Max_Image_Width : constant := 80;\n+\n+   function Image (Of_State    : State)  return String;\n+   function Value (Coded_State : String) return State;\n+\n+private\n+   type Int is new Interfaces.Integer_32;\n+\n+   --  We prefer to use 14 digits for Flt, but some targets are more limited\n+\n+   type Flt is digits Positive'Min (14, Long_Long_Float'Digits);\n+\n+   K1   : constant := 94_833_359;\n+   K1F  : constant := 94_833_359.0;\n+   K2   : constant := 47_416_679;\n+   K2F  : constant := 47_416_679.0;\n+   Scal : constant := 1.0 / (K1F * K2F);\n+\n+   type State is record\n+      X1  : Int := 2999 ** 2;      --  Square mod p\n+      X2  : Int := 1439 ** 2;      --  Square mod q\n+      P   : Int := K1;\n+      Q   : Int := K2;\n+      X   : Int := 1;\n+      Scl : Flt := Scal;\n+   end record;\n+\n+   type Generator is limited record\n+      Gen_State : State;\n+   end record;\n+\n+end GNAT.MBBS_Float_Random;"}, {"sha": "f3089d44f6ae3ceb0849cd2d9b1e8b24ed350597", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -8848,7 +8848,7 @@ floating-point.\n @code{Numerics.Float_Random.Max_Image_Width}.  See A.5.2(27).\n @end cartouche\n @noindent\n-Maximum image width is 649, see library file @file{a-numran.ads}.\n+Maximum image width is 6864, see library file @file{s-rannum.ads}.\n \n @sp 1\n @cartouche\n@@ -8857,7 +8857,7 @@ Maximum image width is 649, see library file @file{a-numran.ads}.\n @code{Numerics.Discrete_Random.Max_Image_Width}.  See A.5.2(27).\n @end cartouche\n @noindent\n-Maximum image width is 80, see library file @file{a-nudira.ads}.\n+Maximum image width is 6864, see library file @file{s-rannum.ads}.\n \n @sp 1\n @cartouche\n@@ -8866,8 +8866,8 @@ Maximum image width is 80, see library file @file{a-nudira.ads}.\n A.5.2(32).\n @end cartouche\n @noindent\n-The algorithm is documented in the source files @file{a-numran.ads} and\n-@file{a-numran.adb}.\n+The algorithm is the Mersenne Twister, as documented in the source file\n+@file{s-rannum.adb}.\n \n @sp 1\n @cartouche\n@@ -8876,7 +8876,9 @@ The algorithm is documented in the source files @file{a-numran.ads} and\n state.  See A.5.2(38).\n @end cartouche\n @noindent\n-See the documentation contained in the file @file{a-numran.adb}.\n+The value returned by the Image function is the concatenation of \n+the fixed-width decimal representations of the 624 32-bit integers \n+of the state vector.\n \n @sp 1\n @cartouche\n@@ -11839,12 +11841,12 @@ This is a predefined instantiation of\n build the type @code{Complex} and @code{Imaginary}.\n \n @item Ada.Numerics.Discrete_Random\n-This package provides a random number generator suitable for generating\n-random integer values from a specified range.\n+This generic package provides a random number generator suitable for generating\n+uniformly distributed values of a specified discrete subtype.\n \n @item Ada.Numerics.Float_Random\n This package provides a random number generator suitable for generating\n-uniformly distributed floating point values.\n+uniformly distributed floating point values in the unit interval.\n \n @item Ada.Numerics.Generic_Complex_Elementary_Functions\n This is a generic version of the package that provides the"}, {"sha": "47e5b16311e89eeccf4a3fd6109e09a52216130d", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -250,6 +250,8 @@ package body Impunit is\n      \"g-io    \",    -- GNAT.IO\n      \"g-io_aux\",    -- GNAT.IO_Aux\n      \"g-locfil\",    -- GNAT.Lock_Files\n+     \"g-mbdira\",    -- GNAT.MBBS_Discrete_Random\n+     \"g-mbflra\",    -- GNAT.MBBS_Float_Random\n      \"g-md5   \",    -- GNAT.MD5\n      \"g-memdum\",    -- GNAT.Memory_Dump\n      \"g-moreex\",    -- GNAT.Most_Recent_Exception"}, {"sha": "c161b6ebbe04f93510c93d60b390b35ed4e4665c", "filename": "gcc/ada/s-rannum.adb", "status": "modified", "additions": 90, "deletions": 21, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fs-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41195c94583a5f2da9178234bbcdacee27db69ff/gcc%2Fada%2Fs-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.adb?ref=41195c94583a5f2da9178234bbcdacee27db69ff", "patch": "@@ -188,35 +188,104 @@ package body System.Random_Numbers is\n       return Y;\n    end Random;\n \n-   function Random (Gen : Generator) return Float is\n-\n-      --  Note: The application of Float'Machine (...) is necessary to avoid\n-      --  returning extra significand bits. Without it, the function's value\n-      --  will change if it is spilled, for example, causing\n-      --  gratuitous nondeterminism.\n+   generic\n+      type Unsigned is mod <>;\n+      type Real is digits <>;\n+      with function Shift_Right (Value : Unsigned; Amount : Natural)\n+        return Unsigned is <>;\n+      with function Random (G : Generator) return Unsigned is <>;\n+   function Random_Float_Template (Gen : Generator) return Real;\n+   pragma Inline (Random_Float_Template);\n+   --  Template for a random-number generator implementation that delivers\n+   --  values of type Real in the half-open range [0 .. 1), using values from\n+   --  Gen, assuming that Unsigned is large enough to hold the bits of\n+   --  a mantissa for type Real.\n+\n+   function Random_Float_Template (Gen : Generator) return Real is\n+      --  This code generates random floating-point numbers from unsigned\n+      --  integers. Assuming that Real'Machine_Radix = 2, it can deliver\n+      --  all machine values of type Real (at least as implied by\n+      --  Real'Machine_Mantissa and Real'Machine_Emin), which is not true\n+      --  of the standard method (to which we fall back for non-binary\n+      --  radix): computing Real(<random integer>) / (<max random integer>+1).\n+      --  To do so, we first extract an (M-1)-bit significand (where M\n+      --  is Real'Machine_Mantissa), and then decide on a normalized\n+      --  exponent by repeated coin flips, decrementing from 0 as long as\n+      --  we flip heads (1 bits). This yields the proper geometric\n+      --  distribution for the exponent: in a uniformly distributed set of\n+      --  floating-point numbers, 1/2 of them will be in [0.5, 1), 1/4 will\n+      --  be in [0.25, 0.5), and so forth. If the process reaches\n+      --  Machine_Emin (an extremely rare event), it uses the selected\n+      --  mantissa bits as an unnormalized fraction with Machine_Emin as\n+      --  exponent. Otherwise, it adds a leading bit to the selected\n+      --  mantissa bits (thus giving a normalized fraction) and adjusts by\n+      --  the chosen exponent. The algorithm attempts to be stingy with\n+      --  random integers. In the worst case, it can consume roughly\n+      --  -Real'Machine_Emin/32 32-bit integers, but this case occurs with\n+      --  probability 2**Machine_Emin, and the expected number of calls to\n+      --  integer-valued Random is 1.\n \n-      Result : constant Float :=\n-                 Float'Machine\n-                   (Float (Unsigned_32'(Random (Gen))) * 2.0 ** (-32));\n    begin\n-      if Result < 1.0 then\n-         return Result;\n+      if Real'Machine_Radix /= 2 then\n+         declare\n+            Val : constant Real := Real'Machine\n+              (Real (Unsigned'(Random (Gen))) * 2.0**(-Unsigned'Size));\n+         begin\n+            if Val < 1.0 then\n+               return Real'Base (Val);\n+            else\n+               return Real'Pred (1.0);\n+            end if;\n+         end;\n       else\n-         return Float'Adjacent (1.0, 0.0);\n+         declare\n+            Mant_Bits : constant Integer := Real'Machine_Mantissa - 1;\n+            Mant_Mask : constant Unsigned := 2**Mant_Bits - 1;\n+            Adjust32  : constant Integer := Real'Size - Unsigned_32'Size;\n+            Leftover  : constant Integer :=\n+              Unsigned'Size - Real'Machine_Mantissa + 1;\n+\n+            V         : constant Unsigned := Random (Gen);\n+            Mant      : constant Unsigned := V and Mant_Mask;\n+            Rand_Bits : Unsigned_32;\n+            Exp       : Integer;\n+            Bits_Left : Integer;\n+            Result    : Real;\n+         begin\n+            Rand_Bits := Unsigned_32 (Shift_Right (V, Adjust32));\n+            Exp := 0;\n+            Bits_Left := Leftover;\n+            Result := Real (Mant + 2**Mant_Bits) * 2.0**(-Mant_Bits - 1);\n+            while Rand_Bits >= 2**31 loop\n+               if Exp = Real'Machine_Emin then\n+                  return Real (Mant) * 2.0**Real'Machine_Emin;\n+               end if;\n+\n+               Result := Result * 0.5;\n+               Exp := Exp - 1;\n+               Rand_Bits := 2 * Rand_Bits;\n+               Bits_Left := Bits_Left - 1;\n+\n+               if Bits_Left = 0 then\n+                  Bits_Left := 32;\n+                  Rand_Bits := Random (Gen);\n+               end if;\n+            end loop;\n+            return Result;\n+         end;\n       end if;\n+   end Random_Float_Template;\n+\n+   function Random (Gen : Generator) return Float is\n+      function F is new Random_Float_Template (Unsigned_32, Float);\n+   begin\n+      return F (Gen);\n    end Random;\n \n    function Random (Gen : Generator) return Long_Float is\n-      Result : constant Long_Float :=\n-                 Long_Float'Machine ((Long_Float (Unsigned_32'(Random (Gen)))\n-                   * 2.0 ** (-32))\n-                   + (Long_Float (Unsigned_32'(Random (Gen))) * 2.0 ** (-64)));\n+      function F is new Random_Float_Template (Unsigned_64, Long_Float);\n    begin\n-      if Result < 1.0 then\n-         return Result;\n-      else\n-         return Long_Float'Adjacent (1.0, 0.0);\n-      end if;\n+      return F (Gen);\n    end Random;\n \n    function Random (Gen : Generator) return Unsigned_64 is"}]}