{"sha": "354ae44943ca7642d2f3a48ca428bfb5df2e0049", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU0YWU0NDk0M2NhNzY0MmQyZjNhNDhjYTQyOGJmYjVkZjJlMDA0OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:54:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:54:43Z"}, "message": "[multiple changes]\n\n2017-01-13  Javier Miranda  <miranda@adacore.com>\n\n\t* einfo.ads (Component_Bit_Offset): Fix documentation.\n\t* sem_ch13.adb (Check_Record_Representation_Clause): Skip check\n\ton record holes for components with unknown compile-time offsets.\n\n2017-01-13  Bob Duff  <duff@adacore.com>\n\n\t* ali.ads, ali.adb (Static_Elaboration_Model_Used): Remove unused flag.\n\t* g-locfil.ads: Minor comment fix.\n\n2017-01-13  Bob Duff  <duff@adacore.com>\n\n\t* binde.adb (Elab_New): New elaboration order algorithm\n\tthat is expected to cause fewer ABE issues. This is a work in\n\tprogress. The new algorithm is currently disabled, and can be\n\tenable by the -dp switch, or by modifying the Do_Old and Do_New\n\tetc. flags and rebuilding. Experimental code is included to\n\tcompare the results of the old and new algorithms.\n\t* binde.ads: Use GNAT.Dynamic_Tables instead of Table, so we\n\tcan have multiple of these tables, so the old and new algorithms\n\tcan coexist.\n\t* bindgen.ads (Gen_Output_File): Pass Elab_Order as an 'in'\n\tparameter of type array. This avoids the global variable, and\n\tallows bounds checking (which is normally defeated by the tables\n\tpackages). It also ensures that the Elab_Order is read-only\n\tto Bindgen.\n\t* bindgen.adb: Pass Elab_Order as an 'in' parameter to all\n\tsubprograms that need it, as above.\n\t* debug.adb: Document new -dp switch. Modify doc of old -do\n\tswitch.\n\t* gnatbind.adb (Gnatbind): Make use of new interfaces to Binde\n\tand Bindgen.  Move writing of closure (-R and -Ra switches)\n\tto Binde; that's more convenient.\n\n2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): If the expression\n\tfunction is a completion, all entities referenced in the\n\texpression are frozen. As a consequence, a reference to an\n\tuncompleted private type from an enclosing scope is illegal.\n\nFrom-SVN: r244419", "tree": {"sha": "f029b95ac27175fee7062ad81282fdb79d0f388a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f029b95ac27175fee7062ad81282fdb79d0f388a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/354ae44943ca7642d2f3a48ca428bfb5df2e0049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354ae44943ca7642d2f3a48ca428bfb5df2e0049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354ae44943ca7642d2f3a48ca428bfb5df2e0049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354ae44943ca7642d2f3a48ca428bfb5df2e0049/comments", "author": null, "committer": null, "parents": [{"sha": "448a1eb3eb4357dcdd1e2271e267bedb0c4b7d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448a1eb3eb4357dcdd1e2271e267bedb0c4b7d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448a1eb3eb4357dcdd1e2271e267bedb0c4b7d6c"}], "stats": {"total": 2808, "additions": 2019, "deletions": 789}, "files": [{"sha": "fba33935f1663b37eaaf90f3a192d415315e3ed1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -1,3 +1,45 @@\n+2017-01-13  Javier Miranda  <miranda@adacore.com>\n+\n+\t* einfo.ads (Component_Bit_Offset): Fix documentation.\n+\t* sem_ch13.adb (Check_Record_Representation_Clause): Skip check\n+\ton record holes for components with unknown compile-time offsets.\n+\n+2017-01-13  Bob Duff  <duff@adacore.com>\n+\n+\t* ali.ads, ali.adb (Static_Elaboration_Model_Used): Remove unused flag.\n+\t* g-locfil.ads: Minor comment fix.\n+\n+2017-01-13  Bob Duff  <duff@adacore.com>\n+\n+\t* binde.adb (Elab_New): New elaboration order algorithm\n+\tthat is expected to cause fewer ABE issues. This is a work in\n+\tprogress. The new algorithm is currently disabled, and can be\n+\tenable by the -dp switch, or by modifying the Do_Old and Do_New\n+\tetc. flags and rebuilding. Experimental code is included to\n+\tcompare the results of the old and new algorithms.\n+\t* binde.ads: Use GNAT.Dynamic_Tables instead of Table, so we\n+\tcan have multiple of these tables, so the old and new algorithms\n+\tcan coexist.\n+\t* bindgen.ads (Gen_Output_File): Pass Elab_Order as an 'in'\n+\tparameter of type array. This avoids the global variable, and\n+\tallows bounds checking (which is normally defeated by the tables\n+\tpackages). It also ensures that the Elab_Order is read-only\n+\tto Bindgen.\n+\t* bindgen.adb: Pass Elab_Order as an 'in' parameter to all\n+\tsubprograms that need it, as above.\n+\t* debug.adb: Document new -dp switch. Modify doc of old -do\n+\tswitch.\n+\t* gnatbind.adb (Gnatbind): Make use of new interfaces to Binde\n+\tand Bindgen.  Move writing of closure (-R and -Ra switches)\n+\tto Binde; that's more convenient.\n+\n+2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): If the expression\n+\tfunction is a completion, all entities referenced in the\n+\texpression are frozen. As a consequence, a reference to an\n+\tuncompleted private type from an enclosing scope is illegal.\n+\n 2017-01-13  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch6.adb (Freeze_Expr_Types): New subprogram."}, {"sha": "d42cb34431a52e29cc49fbdf43354da9db5f5ffe", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -116,7 +116,6 @@ package body ALI is\n       Partition_Elaboration_Policy_Specified := ' ';\n       Queuing_Policy_Specified               := ' ';\n       SSO_Default_Specified                  := False;\n-      Static_Elaboration_Model_Used          := False;\n       Task_Dispatching_Policy_Specified      := ' ';\n       Unreserve_All_Interrupts_Specified     := False;\n       Frontend_Exceptions_Specified          := False;\n@@ -1996,14 +1995,6 @@ package body ALI is\n \n          Skip_Eol;\n \n-         --  Check if static elaboration model used\n-\n-         if not Units.Table (Units.Last).Dynamic_Elab\n-           and then not Units.Table (Units.Last).Internal\n-         then\n-            Static_Elaboration_Model_Used := True;\n-         end if;\n-\n          C := Getc;\n \n          --  Scan out With lines for this unit"}, {"sha": "c51129df0dbdc03b701a1cf119eb1767cd1041ec", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -523,11 +523,6 @@ package ALI is\n    --  Set to True if at least one ALI file contains '-fstack-check' in its\n    --  argument list.\n \n-   Static_Elaboration_Model_Used : Boolean := False;\n-   --  Set to False by Initialize_ALI. Set to True if any ALI file for a\n-   --  non-internal unit compiled with the static elaboration model is\n-   --  encountered.\n-\n    Task_Dispatching_Policy_Specified : Character := ' ';\n    --  Set to blank by Initialize_ALI. Set to the appropriate task dispatching\n    --  policy character if an ali file contains a P line setting the"}, {"sha": "ea341272b56dc350711a4380e19d7fca1826089a", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 1705, "deletions": 450, "changes": 2155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049"}, {"sha": "79d9cdf0c909ae4109932c3ebaf29064d29bda54", "filename": "gcc/ada/binde.ads", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbinde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbinde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.ads?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -23,30 +23,38 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines to determine elaboration order\n+--  This package contains the routine that determines library-level elaboration\n+--  order.\n \n with ALI;   use ALI;\n-with Table;\n+with Namet; use Namet;\n with Types; use Types;\n \n+with GNAT.Dynamic_Tables;\n+\n package Binde is\n \n-   --  The following table records the chosen elaboration order. It is used\n-   --  by Gen_Elab_Calls to generate the sequence of elaboration calls. Note\n-   --  that units are included in this table even if they have no elaboration\n+   package Unit_Id_Tables is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Unit_Id,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 500,\n+      Table_Increment      => 200);\n+   use Unit_Id_Tables;\n+\n+   subtype Unit_Id_Table is Unit_Id_Tables.Instance;\n+   subtype Unit_Id_Array is Unit_Id_Tables.Table_Type;\n+\n+   procedure Find_Elab_Order\n+     (Elab_Order          : out Unit_Id_Table;\n+      First_Main_Lib_File : File_Name_Type);\n+   --  Determine elaboration order.\n+   --\n+   --  The Elab_Order table records the chosen elaboration order. It is used by\n+   --  Gen_Elab_Calls to generate the sequence of elaboration calls. Note that\n+   --  units are included in this table even if they have no elaboration\n    --  routine, since the table is also used to drive the generation of object\n    --  files in the binder output. Gen_Elab_Calls skips any units that have no\n    --  elaboration routine.\n \n-   package Elab_Order is new Table.Table (\n-     Table_Component_Type => Unit_Id,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 500,\n-     Table_Increment      => 200,\n-     Table_Name           => \"Elab_Order\");\n-\n-   procedure Find_Elab_Order;\n-   --  Determine elaboration order\n-\n end Binde;"}, {"sha": "d6c9a83d7dcd987fddbefda6d3fc9c42996dd3a0", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 145, "deletions": 128, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -24,7 +24,6 @@\n ------------------------------------------------------------------------------\n \n with ALI;      use ALI;\n-with Binde;    use Binde;\n with Casing;   use Casing;\n with Fname;    use Fname;\n with Gnatvsn;  use Gnatvsn;\n@@ -47,12 +46,13 @@ with GNAT.Heap_Sort_A; use GNAT.Heap_Sort_A;\n with GNAT.HTable;\n \n package body Bindgen is\n+   use Binde.Unit_Id_Tables;\n \n    Statement_Buffer : String (1 .. 1000);\n    --  Buffer used for constructing output statements\n \n-   Last : Natural := 0;\n-   --  Last location in Statement_Buffer currently set\n+   Stm_Last : Natural := 0;\n+   --  Stm_Last location in Statement_Buffer currently set\n \n    With_GNARL : Boolean := False;\n    --  Flag which indicates whether the program uses the GNARL library\n@@ -113,27 +113,27 @@ package body Bindgen is\n    --  that the information is consistent across units. The entries\n    --  in this table are n/u/r/s for not set/user/runtime/system.\n \n-   package IS_Pragma_Settings is new Table.Table (\n-     Table_Component_Type => Character,\n-     Table_Index_Type     => Int,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => 100,\n-     Table_Increment      => 200,\n-     Table_Name           => \"IS_Pragma_Settings\");\n+   package IS_Pragma_Settings is new Table.Table\n+     (Table_Component_Type => Character,\n+      Table_Index_Type     => Int,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => 100,\n+      Table_Increment      => 200,\n+      Table_Name           => \"IS_Pragma_Settings\");\n \n    --  This table assembles the Priority_Specific_Dispatching pragma\n    --  information from all the units in the partition. Note that Bcheck has\n    --  already checked that the information is consistent across units.\n    --  The entries in this table are the upper case first character of the\n    --  policy name, e.g. 'F' for FIFO_Within_Priorities.\n \n-   package PSD_Pragma_Settings is new Table.Table (\n-     Table_Component_Type => Character,\n-     Table_Index_Type     => Int,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => 100,\n-     Table_Increment      => 200,\n-     Table_Name           => \"PSD_Pragma_Settings\");\n+   package PSD_Pragma_Settings is new Table.Table\n+     (Table_Component_Type => Character,\n+      Table_Index_Type     => Int,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => 100,\n+      Table_Increment      => 200,\n+      Table_Name           => \"PSD_Pragma_Settings\");\n \n    ----------------------------\n    -- Bind_Environment Table --\n@@ -271,7 +271,7 @@ package body Bindgen is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Gen_Adainit;\n+   procedure Gen_Adainit (Elab_Order : Unit_Id_Array);\n    --  Generates the Adainit procedure\n \n    procedure Gen_Adafinal;\n@@ -283,27 +283,29 @@ package body Bindgen is\n    procedure Gen_CodePeer_Wrapper;\n    --  For CodePeer, generate wrapper which calls user-defined main subprogram\n \n-   procedure Gen_Elab_Calls;\n+   procedure Gen_Elab_Calls (Elab_Order : Unit_Id_Array);\n    --  Generate sequence of elaboration calls\n \n-   procedure Gen_Elab_Externals;\n+   procedure Gen_Elab_Externals (Elab_Order : Unit_Id_Array);\n    --  Generate sequence of external declarations for elaboration\n \n-   procedure Gen_Elab_Order;\n+   procedure Gen_Elab_Order (Elab_Order : Unit_Id_Array);\n    --  Generate comments showing elaboration order chosen\n \n-   procedure Gen_Finalize_Library;\n+   procedure Gen_Finalize_Library (Elab_Order : Unit_Id_Array);\n    --  Generate a sequence of finalization calls to elaborated packages\n \n    procedure Gen_Main;\n    --  Generate procedure main\n \n-   procedure Gen_Object_Files_Options;\n+   procedure Gen_Object_Files_Options (Elab_Order : Unit_Id_Array);\n    --  Output comments containing a list of the full names of the object\n    --  files to be linked and the list of linker options supplied by\n    --  Linker_Options pragmas in the source.\n \n-   procedure Gen_Output_File_Ada (Filename : String);\n+   procedure Gen_Output_File_Ada\n+     (Filename   : String;\n+      Elab_Order : Unit_Id_Array);\n    --  Generate Ada output file\n \n    procedure Gen_Restrictions;\n@@ -335,41 +337,41 @@ package body Bindgen is\n    --  the encoding method used for the main program source. If there is no\n    --  main program source (-z switch used), returns brackets ('b').\n \n-   function Has_Finalizer return Boolean;\n+   function Has_Finalizer (Elab_Order : Unit_Id_Array) return Boolean;\n    --  Determine whether the current unit has at least one library-level\n    --  finalizer.\n \n-   function Lt_Linker_Option (Op1, Op2 : Natural) return Boolean;\n+   function Lt_Linker_Option (Op1 : Natural; Op2 : Natural) return Boolean;\n    --  Compare linker options, when sorting, first according to\n    --  Is_Internal_File (internal files come later) and then by\n    --  elaboration order position (latest to earliest).\n \n    procedure Move_Linker_Option (From : Natural; To : Natural);\n    --  Move routine for sorting linker options\n \n-   procedure Resolve_Binder_Options;\n+   procedure Resolve_Binder_Options (Elab_Order : Unit_Id_Array);\n    --  Set the value of With_GNARL\n \n    procedure Set_Char (C : Character);\n-   --  Set given character in Statement_Buffer at the Last + 1 position\n-   --  and increment Last by one to reflect the stored character.\n+   --  Set given character in Statement_Buffer at the Stm_Last + 1 position\n+   --  and increment Stm_Last by one to reflect the stored character.\n \n    procedure Set_Int (N : Int);\n    --  Set given value in decimal in Statement_Buffer with no spaces starting\n-   --  at the Last + 1 position, and updating Last past the value. A minus sign\n-   --  is output for a negative value.\n+   --  at the Stm_Last + 1 position, and updating Stm_Last past the value. A\n+   --  minus sign is output for a negative value.\n \n    procedure Set_Boolean (B : Boolean);\n-   --  Set given boolean value in Statement_Buffer at the Last + 1 position\n-   --  and update Last past the value.\n+   --  Set given boolean value in Statement_Buffer at the Stm_Last + 1 position\n+   --  and update Stm_Last past the value.\n \n    procedure Set_IS_Pragma_Table;\n    --  Initializes contents of IS_Pragma_Settings table from ALI table\n \n    procedure Set_Main_Program_Name;\n    --  Given the main program name in Name_Buffer (length in Name_Len) generate\n    --  the name of the routine to be used in the call. The name is generated\n-   --  starting at Last + 1, and Last is updated past it.\n+   --  starting at Stm_Last + 1, and Stm_Last is updated past it.\n \n    procedure Set_Name_Buffer;\n    --  Set the value stored in positions 1 .. Name_Len of the Name_Buffer\n@@ -379,7 +381,7 @@ package body Bindgen is\n \n    procedure Set_String (S : String);\n    --  Sets characters of given string in Statement_Buffer, starting at the\n-   --  Last + 1 position, and updating last past the string value.\n+   --  Stm_Last + 1 position, and updating last past the string value.\n \n    procedure Set_String_Replace (S : String);\n    --  Replaces the last S'Length characters in the Statement_Buffer with the\n@@ -388,20 +390,21 @@ package body Bindgen is\n \n    procedure Set_Unit_Name;\n    --  Given a unit name in the Name_Buffer, copy it into Statement_Buffer,\n-   --  starting at the Last + 1 position and update Last past the value.\n-   --  Each dot (.) will be qualified into double underscores (__).\n+   --  starting at the Stm_Last + 1 position and update Stm_Last past the\n+   --  value. Each dot (.) will be qualified into double underscores (__).\n \n    procedure Set_Unit_Number (U : Unit_Id);\n    --  Sets unit number (first unit is 1, leading zeroes output to line up all\n    --  output unit numbers nicely as required by the value, and by the total\n    --  number of units.\n \n    procedure Write_Statement_Buffer;\n-   --  Write out contents of statement buffer up to Last, and reset Last to 0\n+   --  Write out contents of statement buffer up to Stm_Last, and reset\n+   --  Stm_Last to 0.\n \n    procedure Write_Statement_Buffer (S : String);\n    --  First writes its argument (using Set_String (S)), then writes out the\n-   --  contents of statement buffer up to Last, and reset Last to 0\n+   --  contents of statement buffer up to Stm_Last, and reset Stm_Last to 0\n \n    procedure Write_Bind_Line (S : String);\n    --  Write S (an LF-terminated string) to the binder file (for use with\n@@ -472,7 +475,7 @@ package body Bindgen is\n    -- Gen_Adainit --\n    -----------------\n \n-   procedure Gen_Adainit is\n+   procedure Gen_Adainit (Elab_Order : Unit_Id_Array) is\n       Main_Priority : Int renames ALIs.Table (ALIs.First).Main_Priority;\n       Main_CPU      : Int renames ALIs.Table (ALIs.First).Main_CPU;\n \n@@ -892,8 +895,8 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n-      --  Initialize stack limit variable of the environment task if the\n-      --  stack check method is stack limit and stack check is enabled.\n+      --  Initialize stack limit variable of the environment task if the stack\n+      --  check method is stack limit and stack check is enabled.\n \n       if Stack_Check_Limits_On_Target\n         and then (Stack_Check_Default_On_Target or Stack_Check_Switch_Set)\n@@ -934,7 +937,7 @@ package body Bindgen is\n          WBI (\"\");\n       end if;\n \n-      Gen_Elab_Calls;\n+      Gen_Elab_Calls (Elab_Order);\n \n       if not CodePeer_Mode then\n \n@@ -980,9 +983,6 @@ package body Bindgen is\n    -------------------------\n \n    procedure Gen_Bind_Env_String is\n-      KN, VN : Name_Id := No_Name;\n-      Amp    : Character;\n-\n       procedure Write_Name_With_Len (Nam : Name_Id);\n       --  Write Nam as a string literal, prefixed with one\n       --  character encoding Nam's length.\n@@ -1002,10 +1002,17 @@ package body Bindgen is\n          Write_String_Table_Entry (End_String);\n       end Write_Name_With_Len;\n \n+      --  Local variables\n+\n+      Amp : Character;\n+      KN  : Name_Id := No_Name;\n+      VN  : Name_Id := No_Name;\n+\n    --  Start of processing for Gen_Bind_Env_String\n \n    begin\n       Bind_Environment.Get_First (KN, VN);\n+\n       if VN = No_Name then\n          return;\n       end if;\n@@ -1058,15 +1065,15 @@ package body Bindgen is\n    -- Gen_Elab_Calls --\n    --------------------\n \n-   procedure Gen_Elab_Calls is\n+   procedure Gen_Elab_Calls (Elab_Order : Unit_Id_Array) is\n       Check_Elab_Flag : Boolean;\n \n    begin\n       --  Loop through elaboration order entries\n \n-      for E in Elab_Order.First .. Elab_Order.Last loop\n+      for E in Elab_Order'Range loop\n          declare\n-            Unum : constant Unit_Id := Elab_Order.Table (E);\n+            Unum : constant Unit_Id := Elab_Order (E);\n             U    : Unit_Record renames Units.Table (Unum);\n \n             Unum_Spec : Unit_Id;\n@@ -1241,15 +1248,15 @@ package body Bindgen is\n    -- Gen_Elab_Externals --\n    ------------------------\n \n-   procedure Gen_Elab_Externals is\n+   procedure Gen_Elab_Externals (Elab_Order : Unit_Id_Array) is\n    begin\n       if CodePeer_Mode then\n          return;\n       end if;\n \n-      for E in Elab_Order.First .. Elab_Order.Last loop\n+      for E in Elab_Order'Range loop\n          declare\n-            Unum : constant Unit_Id := Elab_Order.Table (E);\n+            Unum : constant Unit_Id := Elab_Order (E);\n             U    : Unit_Record renames Units.Table (Unum);\n \n          begin\n@@ -1289,13 +1296,13 @@ package body Bindgen is\n    -- Gen_Elab_Order --\n    --------------------\n \n-   procedure Gen_Elab_Order is\n+   procedure Gen_Elab_Order (Elab_Order : Unit_Id_Array) is\n    begin\n       WBI (\"   --  BEGIN ELABORATION ORDER\");\n \n-      for J in Elab_Order.First .. Elab_Order.Last loop\n+      for J in Elab_Order'Range loop\n          Set_String (\"   --  \");\n-         Get_Name_String (Units.Table (Elab_Order.Table (J)).Uname);\n+         Get_Name_String (Units.Table (Elab_Order (J)).Uname);\n          Set_Name_Buffer;\n          Write_Statement_Buffer;\n       end loop;\n@@ -1308,12 +1315,7 @@ package body Bindgen is\n    -- Gen_Finalize_Library --\n    --------------------------\n \n-   procedure Gen_Finalize_Library is\n-      Count : Int := 1;\n-      U     : Unit_Record;\n-      Uspec : Unit_Record;\n-      Unum  : Unit_Id;\n-\n+   procedure Gen_Finalize_Library (Elab_Order : Unit_Id_Array) is\n       procedure Gen_Header;\n       --  Generate the header of the finalization routine\n \n@@ -1327,15 +1329,22 @@ package body Bindgen is\n          WBI (\"   begin\");\n       end Gen_Header;\n \n+      --  Local variables\n+\n+      Count : Int := 1;\n+      U     : Unit_Record;\n+      Uspec : Unit_Record;\n+      Unum  : Unit_Id;\n+\n    --  Start of processing for Gen_Finalize_Library\n \n    begin\n       if CodePeer_Mode then\n          return;\n       end if;\n \n-      for E in reverse Elab_Order.First .. Elab_Order.Last loop\n-         Unum := Elab_Order.Table (E);\n+      for E in reverse Elab_Order'Range loop\n+         Unum := Elab_Order (E);\n          U    := Units.Table (Unum);\n \n          --  Dealing with package bodies is a little complicated. In such\n@@ -1634,11 +1643,11 @@ package body Bindgen is\n          end if;\n       end if;\n \n-      --  Generate a reference to Ada_Main_Program_Name. This symbol is\n-      --  not referenced elsewhere in the generated program, but is needed\n-      --  by the debugger (that's why it is generated in the first place).\n-      --  The reference stops Ada_Main_Program_Name from being optimized\n-      --  away by smart linkers, such as the AiX linker.\n+      --  Generate a reference to Ada_Main_Program_Name. This symbol is not\n+      --  referenced elsewhere in the generated program, but is needed by\n+      --  the debugger (that's why it is generated in the first place). The\n+      --  reference stops Ada_Main_Program_Name from being optimized away by\n+      --  smart linkers, such as the AiX linker.\n \n       --  Because this variable is unused, we make this variable \"aliased\"\n       --  with a pragma Volatile in order to tell the compiler to preserve\n@@ -1664,9 +1673,9 @@ package body Bindgen is\n          WBI (\"      gnat_envp := envp;\");\n          WBI (\"\");\n \n-      --  If configurable run time and no command line args, then nothing\n-      --  needs to be done since the gnat_argc/argv/envp variables are\n-      --  suppressed in this case.\n+      --  If configurable run time and no command line args, then nothing needs\n+      --  to be done since the gnat_argc/argv/envp variables are suppressed in\n+      --  this case.\n \n       elsif Configurable_Run_Time_On_Target then\n          null;\n@@ -1767,11 +1776,11 @@ package body Bindgen is\n    -- Gen_Object_Files_Options --\n    ------------------------------\n \n-   procedure Gen_Object_Files_Options is\n+   procedure Gen_Object_Files_Options (Elab_Order : Unit_Id_Array) is\n       Lgnat : Natural;\n-      --  This keeps track of the position in the sorted set of entries\n-      --  in the Linker_Options table of where the first entry from an\n-      --  internal file appears.\n+      --  This keeps track of the position in the sorted set of entries in the\n+      --  Linker_Options table of where the first entry from an internal file\n+      --  appears.\n \n       Linker_Option_List_Started : Boolean := False;\n       --  Set to True when \"LINKER OPTION LIST\" is displayed\n@@ -1836,17 +1845,17 @@ package body Bindgen is\n          Set_List_File (Object_List_Filename.all);\n       end if;\n \n-      for E in Elab_Order.First .. Elab_Order.Last loop\n+      for E in Elab_Order'Range loop\n \n          --  If not spec that has an associated body, then generate a comment\n          --  giving the name of the corresponding object file.\n \n-         if not Units.Table (Elab_Order.Table (E)).SAL_Interface\n-           and then Units.Table (Elab_Order.Table (E)).Utype /= Is_Spec\n+         if not Units.Table (Elab_Order (E)).SAL_Interface\n+           and then Units.Table (Elab_Order (E)).Utype /= Is_Spec\n          then\n             Get_Name_String\n               (ALIs.Table\n-                (Units.Table (Elab_Order.Table (E)).My_ALI).Ofile_Full_Name);\n+                (Units.Table (Elab_Order (E)).My_ALI).Ofile_Full_Name);\n \n             --  If the presence of an object file is necessary or if it exists,\n             --  then use it.\n@@ -1874,6 +1883,7 @@ package body Bindgen is\n       for J in 1 .. Nb_Dir_In_Obj_Search_Path loop\n          declare\n             Dir : constant String_Ptr := Dir_In_Obj_Search_Path (J);\n+\n          begin\n             Name_Len := 0;\n             Add_Str_To_Name_Buffer (\"-L\");\n@@ -1996,7 +2006,10 @@ package body Bindgen is\n    -- Gen_Output_File --\n    ---------------------\n \n-   procedure Gen_Output_File (Filename : String) is\n+   procedure Gen_Output_File\n+     (Filename   : String;\n+      Elab_Order : Unit_Id_Array)\n+   is\n    begin\n       --  Acquire settings for Interrupt_State pragmas\n \n@@ -2014,8 +2027,8 @@ package body Bindgen is\n \n       --  Count number of elaboration calls\n \n-      for E in Elab_Order.First .. Elab_Order.Last loop\n-         if Units.Table (Elab_Order.Table (E)).No_Elab then\n+      for E in Elab_Order'Range loop\n+         if Units.Table (Elab_Order (E)).No_Elab then\n             null;\n          else\n             Num_Elab_Calls := Num_Elab_Calls + 1;\n@@ -2024,21 +2037,23 @@ package body Bindgen is\n \n       --  Generate output file in appropriate language\n \n-      Gen_Output_File_Ada (Filename);\n+      Gen_Output_File_Ada (Filename, Elab_Order);\n    end Gen_Output_File;\n \n    -------------------------\n    -- Gen_Output_File_Ada --\n    -------------------------\n \n-   procedure Gen_Output_File_Ada (Filename : String) is\n-\n+   procedure Gen_Output_File_Ada\n+     (Filename : String; Elab_Order : Unit_Id_Array)\n+   is\n       Ada_Main : constant String := Get_Ada_Main_Name;\n       --  Name to be used for generated Ada main program. See the body of\n       --  function Get_Ada_Main_Name for details on the form of the name.\n \n       Needs_Library_Finalization : constant Boolean :=\n-        not Configurable_Run_Time_On_Target and then Has_Finalizer;\n+        not Configurable_Run_Time_On_Target\n+        and then Has_Finalizer (Elab_Order);\n       --  For restricted run-time libraries (ZFP and Ravenscar) tasks are\n       --  non-terminating, so we do not want finalization.\n \n@@ -2096,7 +2111,7 @@ package body Bindgen is\n          WBI (\"with System.Secondary_Stack;\");\n       end if;\n \n-      Resolve_Binder_Options;\n+      Resolve_Binder_Options (Elab_Order);\n \n       --  Generate standard with's\n \n@@ -2240,7 +2255,7 @@ package body Bindgen is\n       end if;\n \n       Gen_Versions;\n-      Gen_Elab_Order;\n+      Gen_Elab_Order (Elab_Order);\n \n       --  Spec is complete\n \n@@ -2323,7 +2338,7 @@ package body Bindgen is\n \n       --  Generate externals for elaboration entities\n \n-      Gen_Elab_Externals;\n+      Gen_Elab_Externals (Elab_Order);\n \n       if not CodePeer_Mode then\n          if not Suppress_Standard_Library_On_Target then\n@@ -2375,21 +2390,21 @@ package body Bindgen is\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n          if Needs_Library_Finalization then\n-            Gen_Finalize_Library;\n+            Gen_Finalize_Library (Elab_Order);\n          end if;\n \n          Gen_Adafinal;\n       end if;\n \n-      Gen_Adainit;\n+      Gen_Adainit (Elab_Order);\n \n       if Bind_Main_Program then\n          Gen_Main;\n       end if;\n \n       --  Output object file list and the Ada body is complete\n \n-      Gen_Object_Files_Options;\n+      Gen_Object_Files_Options (Elab_Order);\n \n       WBI (\"\");\n       WBI (\"end \" & Ada_Main & \";\");\n@@ -2519,8 +2534,8 @@ package body Bindgen is\n       WBI (\"   type Version_32 is mod 2 ** 32;\");\n       for U in Units.First .. Units.Last loop\n          if not Units.Table (U).SAL_Interface\n-           and then\n-             (not Bind_For_Library or else Units.Table (U).Directly_Scanned)\n+           and then (not Bind_For_Library\n+                      or else Units.Table (U).Directly_Scanned)\n          then\n             Increment_Ubuf;\n             WBI (\"   \" & Ubuf & \" : constant Version_32 := 16#\" &\n@@ -2580,19 +2595,20 @@ package body Bindgen is\n    function Get_Ada_Main_Name return String is\n       Suffix : constant String := \"_00\";\n       Name   : String (1 .. Opt.Ada_Main_Name.all'Length + Suffix'Length) :=\n-        Opt.Ada_Main_Name.all & Suffix;\n+                 Opt.Ada_Main_Name.all & Suffix;\n       Nlen   : Natural;\n \n    begin\n-      --  For CodePeer, we want reproducible names (independent of other\n-      --  mains that may or may not be present) that don't collide\n-      --  when analyzing multiple mains and which are easily recognizable\n-      --  as \"ada_main\" names.\n+      --  For CodePeer, we want reproducible names (independent of other mains\n+      --  that may or may not be present) that don't collide when analyzing\n+      --  multiple mains and which are easily recognizable as \"ada_main\" names.\n \n       if CodePeer_Mode then\n          Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-         return \"ada_main_for_\" &\n-           Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len - 2));\n+\n+         return\n+           \"ada_main_for_\" &\n+             Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len - 2));\n       end if;\n \n       --  This loop tries the following possibilities in order\n@@ -2713,13 +2729,13 @@ package body Bindgen is\n    -- Has_Finalizer --\n    -------------------\n \n-   function Has_Finalizer return Boolean is\n+   function Has_Finalizer (Elab_Order : Unit_Id_Array) return Boolean is\n       U     : Unit_Record;\n       Unum  : Unit_Id;\n \n    begin\n-      for E in reverse Elab_Order.First .. Elab_Order.Last loop\n-         Unum := Elab_Order.Table (E);\n+      for E in reverse Elab_Order'Range loop\n+         Unum := Elab_Order (E);\n          U    := Units.Table (Unum);\n \n          --  We are only interested in non-generic packages\n@@ -2749,7 +2765,7 @@ package body Bindgen is\n    -- Lt_Linker_Option --\n    ----------------------\n \n-   function Lt_Linker_Option (Op1, Op2 : Natural) return Boolean is\n+   function Lt_Linker_Option (Op1 : Natural; Op2 : Natural) return Boolean is\n    begin\n       --  Sort internal files last\n \n@@ -2771,7 +2787,6 @@ package body Bindgen is\n          return Units.Table (Linker_Options.Table (Op1).Unit).Elab_Position\n                   >\n                 Units.Table (Linker_Options.Table (Op2).Unit).Elab_Position;\n-\n       end if;\n    end Lt_Linker_Option;\n \n@@ -2788,8 +2803,7 @@ package body Bindgen is\n    -- Resolve_Binder_Options --\n    ----------------------------\n \n-   procedure Resolve_Binder_Options is\n-\n+   procedure Resolve_Binder_Options (Elab_Order : Unit_Id_Array) is\n       procedure Check_Package (Var : in out Boolean; Name : String);\n       --  Set Var to true iff the current identifier in Namet is Name. Do\n       --  nothing if it doesn't match. This procedure is just a helper to\n@@ -2811,8 +2825,8 @@ package body Bindgen is\n    --  Start of processing for Resolve_Binder_Options\n \n    begin\n-      for E in Elab_Order.First .. Elab_Order.Last loop\n-         Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n+      for E in Elab_Order'Range loop\n+         Get_Name_String (Units.Table (Elab_Order (E)).Uname);\n \n          --  This is not a perfect approach, but is the current protocol\n          --  between the run-time and the binder to indicate that tasking is\n@@ -2873,15 +2887,18 @@ package body Bindgen is\n    -----------------\n \n    procedure Set_Boolean (B : Boolean) is\n-      True_Str  : constant String := \"True\";\n       False_Str : constant String := \"False\";\n+      True_Str  : constant String := \"True\";\n+\n    begin\n       if B then\n-         Statement_Buffer (Last + 1 .. Last + True_Str'Length) := True_Str;\n-         Last := Last + True_Str'Length;\n+         Statement_Buffer (Stm_Last + 1 .. Stm_Last + True_Str'Length) :=\n+           True_Str;\n+         Stm_Last := Stm_Last + True_Str'Length;\n       else\n-         Statement_Buffer (Last + 1 .. Last + False_Str'Length) := False_Str;\n-         Last := Last + False_Str'Length;\n+         Statement_Buffer (Stm_Last + 1 .. Stm_Last + False_Str'Length) :=\n+           False_Str;\n+         Stm_Last := Stm_Last + False_Str'Length;\n       end if;\n    end Set_Boolean;\n \n@@ -2891,8 +2908,8 @@ package body Bindgen is\n \n    procedure Set_Char (C : Character) is\n    begin\n-      Last := Last + 1;\n-      Statement_Buffer (Last) := C;\n+      Stm_Last := Stm_Last + 1;\n+      Statement_Buffer (Stm_Last) := C;\n    end Set_Char;\n \n    -------------\n@@ -2910,8 +2927,8 @@ package body Bindgen is\n             Set_Int (N / 10);\n          end if;\n \n-         Last := Last + 1;\n-         Statement_Buffer (Last) :=\n+         Stm_Last := Stm_Last + 1;\n+         Statement_Buffer (Stm_Last) :=\n            Character'Val (N mod 10 + Character'Pos ('0'));\n       end if;\n    end Set_Int;\n@@ -2928,9 +2945,9 @@ package body Bindgen is\n          loop\n             declare\n                Inum : constant Int :=\n-                 Interrupt_States.Table (K).Interrupt_Id;\n+                        Interrupt_States.Table (K).Interrupt_Id;\n                Stat : constant Character :=\n-                 Interrupt_States.Table (K).Interrupt_State;\n+                        Interrupt_States.Table (K).Interrupt_State;\n \n             begin\n                while IS_Pragma_Settings.Last < Inum loop\n@@ -2951,8 +2968,8 @@ package body Bindgen is\n    begin\n       --  Note that name has %b on the end which we ignore\n \n-      --  First we output the initial _ada_ since we know that the main\n-      --  program is a library level subprogram.\n+      --  First we output the initial _ada_ since we know that the main program\n+      --  is a library level subprogram.\n \n       Set_String (\"_ada_\");\n \n@@ -3011,8 +3028,8 @@ package body Bindgen is\n \n    procedure Set_String (S : String) is\n    begin\n-      Statement_Buffer (Last + 1 .. Last + S'Length) := S;\n-      Last := Last + S'Length;\n+      Statement_Buffer (Stm_Last + 1 .. Stm_Last + S'Length) := S;\n+      Stm_Last := Stm_Last + S'Length;\n    end Set_String;\n \n    ------------------------\n@@ -3021,7 +3038,7 @@ package body Bindgen is\n \n    procedure Set_String_Replace (S : String) is\n    begin\n-      Statement_Buffer (Last - S'Length + 1 .. Last) := S;\n+      Statement_Buffer (Stm_Last - S'Length + 1 .. Stm_Last) := S;\n    end Set_String_Replace;\n \n    -------------------\n@@ -3076,8 +3093,8 @@ package body Bindgen is\n \n    procedure Write_Statement_Buffer is\n    begin\n-      WBI (Statement_Buffer (1 .. Last));\n-      Last := 0;\n+      WBI (Statement_Buffer (1 .. Stm_Last));\n+      Stm_Last := 0;\n    end Write_Statement_Buffer;\n \n    procedure Write_Statement_Buffer (S : String) is"}, {"sha": "070c7fc4f1cca735e3d41405540cc8ba5d1173a4", "filename": "gcc/ada/bindgen.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbindgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fbindgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.ads?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,9 +32,13 @@\n \n --  See the body for exact details of the file that is generated\n \n+with Binde; use Binde;\n+\n package Bindgen is\n \n-   procedure Gen_Output_File (Filename : String);\n+   procedure Gen_Output_File\n+     (Filename   : String;\n+      Elab_Order : Unit_Id_Array);\n    --  Filename is the full path name of the binder output file\n \n    procedure Set_Bind_Env (Key, Value : String);"}, {"sha": "4e1f0fc9810020cc19345505258e586515216f52", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -181,14 +181,14 @@ package body Debug is\n    --  dl\n    --  dm\n    --  dn  List details of manipulation of Num_Pred values\n-   --  do  Use old preference for elaboration order\n-   --  dp\n+   --  do  Use older preference for elaboration order\n+   --  dp  Use new preference for elaboration order\n    --  dq\n    --  dr\n    --  ds\n    --  dt\n    --  du  List units as they are acquired\n-   --  dv\n+   --  dv  Verbose debugging printouts\n    --  dw\n    --  dx  Force binder to read xref information from ali files\n    --  dy\n@@ -809,14 +809,25 @@ package body Debug is\n    --      the algorithm used to determine a correct order of elaboration. This\n    --      is useful in diagnosing any problems in its behavior.\n \n-   --  do  Use old elaboration order preference. The new preference rules\n+   --  do  Use older elaboration order preference. The new preference rules\n    --      prefer specs with no bodies to specs with bodies, and between two\n    --      specs with bodies, prefers the one whose body is closer to being\n    --      able to be elaborated. This is a clear improvement, but we provide\n    --      this debug flag in case of regressions.\n \n+   --  dp  Use new elaboration order preference. The new preference rules\n+   --      elaborate all units within a strongly connected component together,\n+   --      with no other units in between. In particular, if a spec/body pair\n+   --      can be elaborated together, it will be. In the new order, the binder\n+   --      behaves as if every pragma Elaborate_All that would be legal is\n+   --      present, even if it does not appear in the source code. NOTE: We\n+   --      intend to reverse the sense of this switch at some point, so the new\n+   --      preference is the default.\n+\n    --  du  List unit name and file name for each unit as it is read in\n \n+   --  dv  Verbose debugging printouts\n+\n    --  dx  Force the binder to read (and then ignore) the xref information\n    --      in ali files (used to check that read circuit is working OK).\n "}, {"sha": "c0ff37122ee0a073a8fecf10981a12b1341a5660", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -670,14 +670,13 @@ package Einfo is\n --       stored in a non-standard way, see body for details.\n \n --    Component_Bit_Offset (Uint11)\n---       Defined in record components (E_Component, E_Discriminant) if a\n---       component clause applies to the component. First bit position of\n---       given component, computed from the first bit and position values\n---       given in the component clause. A value of No_Uint means that the\n---       value is not yet known. The value can be set by the appearance of\n---       an explicit component clause in a record representation clause,\n---       or it can be set by the front-end in package Layout, or it can be\n---       set by the backend. By the time backend processing is completed,\n+--       Defined in record components (E_Component, E_Discriminant). First\n+--       bit position of given component, computed from the first bit and\n+--       position values given in the component clause. A value of No_Uint\n+--       means that the value is not yet known. The value can be set by the\n+--       appearance of an explicit component clause in a record representation\n+--       clause, or it can be set by the front-end in package Layout, or it can\n+--       be set by the backend. By the time backend processing is completed,\n --       this field is always set. A negative value is used to represent\n --       a value which is not known at compile time, and must be computed\n --       at run-time (this happens if fields of a record have variable"}, {"sha": "3e52cc0625f990151a44069ce14c7dbfe00f9732", "filename": "gcc/ada/g-locfil.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fg-locfil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fg-locfil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-locfil.ads?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2010, AdaCore                     --\n+--                     Copyright (C) 1995-2016, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,7 @@ package GNAT.Lock_Files is\n    --  Exception raised if file cannot be locked\n \n    subtype Path_Name is String;\n-   --  Pathname is used by all services provided in this unit to specified\n+   --  Pathname is used by all services provided in this unit to specify\n    --  directory name and file name. On DOS based systems both directory\n    --  separators are handled (i.e. slash and backslash).\n "}, {"sha": "ebe87c11f0eec87d5254f1914223faeb77121ee8", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 32, "deletions": 154, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -30,12 +30,10 @@ with Binde;    use Binde;\n with Binderr;  use Binderr;\n with Bindgen;  use Bindgen;\n with Bindusg;\n-with Butil;    use Butil;\n with Casing;   use Casing;\n with Csets;\n with Debug;    use Debug;\n with Fmap;\n-with Fname;    use Fname;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -45,7 +43,6 @@ with Rident;   use Rident;\n with Snames;\n with Switch;   use Switch;\n with Switch.B; use Switch.B;\n-with Table;\n with Targparm; use Targparm;\n with Types;    use Types;\n \n@@ -76,22 +73,15 @@ procedure Gnatbind is\n \n    Mapping_File : String_Ptr := null;\n \n-   package Closure_Sources is new Table.Table\n-     (Table_Component_Type => File_Name_Type,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Gnatbind.Closure_Sources\");\n-   --  Table to record the sources in the closure, to avoid duplications. Used\n-   --  only with switch -R.\n-\n    procedure Add_Artificial_ALI_File (Name : String);\n    --  Artificially add ALI file Name in the closure\n \n    function Gnatbind_Supports_Auto_Init return Boolean;\n-   --  Indicates if automatic initialization of elaboration procedure\n-   --  through the constructor mechanism is possible on the platform.\n+   --  Indicates if automatic initialization of elaboration procedure through\n+   --  the constructor mechanism is possible on the platform.\n+\n+   function Is_Cross_Compiler return Boolean;\n+   --  Returns True iff this is a cross-compiler\n \n    procedure List_Applicable_Restrictions;\n    --  List restrictions that apply to this partition if option taken\n@@ -110,9 +100,6 @@ procedure Gnatbind is\n    procedure Write_Arg (S : String);\n    --  Passed to Generic_Scan_Bind_Args to print args\n \n-   function Is_Cross_Compiler return Boolean;\n-   --  Returns True iff this is a cross-compiler\n-\n    -----------------------------\n    -- Add_Artificial_ALI_File --\n    -----------------------------\n@@ -149,6 +136,7 @@ procedure Gnatbind is\n       function gnat_binder_supports_auto_init return Integer;\n       pragma Import (C, gnat_binder_supports_auto_init,\n                      \"__gnat_binder_supports_auto_init\");\n+\n    begin\n       return gnat_binder_supports_auto_init /= 0;\n    end Gnatbind_Supports_Auto_Init;\n@@ -160,6 +148,7 @@ procedure Gnatbind is\n    function Is_Cross_Compiler return Boolean is\n       Cross_Compiler : Integer;\n       pragma Import (C, Cross_Compiler, \"__gnat_is_cross_compiler\");\n+\n    begin\n       return Cross_Compiler = 1;\n    end Is_Cross_Compiler;\n@@ -287,20 +276,21 @@ procedure Gnatbind is\n \n       for R in All_Restrictions loop\n          if not No_Restriction_List (R)\n-            and then Restriction_Could_Be_Set (R)\n+           and then Restriction_Could_Be_Set (R)\n          then\n             if not Additional_Restrictions_Listed then\n                Write_Eol;\n                Write_Line\n-                 (\"The following additional restrictions may be\" &\n-                  \" applied to this partition:\");\n+                 (\"The following additional restrictions may be applied to \"\n+                  & \"this partition:\");\n                Additional_Restrictions_Listed := True;\n             end if;\n \n             Write_Str (\"pragma Restrictions (\");\n \n             declare\n                S : constant String := Restriction_Id'Image (R);\n+\n             begin\n                Name_Len := S'Length;\n                Name_Buffer (1 .. Name_Len) := S;\n@@ -377,8 +367,8 @@ procedure Gnatbind is\n \n             else\n                Fail\n-                 (\"Prefix of initialization and finalization \" &\n-                  \"procedure names missing in -L\");\n+                 (\"Prefix of initialization and finalization procedure names \"\n+                  & \"missing in -L\");\n             end if;\n \n          --  -Sin -Slo -Shi -Sxx -Sev\n@@ -560,12 +550,12 @@ procedure Gnatbind is\n       Write_Str (\" \" & S);\n    end Write_Arg;\n \n-   procedure Scan_Bind_Args is new Generic_Scan_Bind_Args (Scan_Bind_Arg);\n-   procedure Put_Bind_Args is new Generic_Scan_Bind_Args (Write_Arg);\n-\n    procedure Check_Version_And_Help is\n      new Check_Version_And_Help_G (Bindusg.Display);\n \n+   procedure Put_Bind_Args  is new Generic_Scan_Bind_Args (Write_Arg);\n+   procedure Scan_Bind_Args is new Generic_Scan_Bind_Args (Scan_Bind_Arg);\n+\n --  Start of processing for Gnatbind\n \n begin\n@@ -582,8 +572,8 @@ begin\n    begin\n       pragma Assert\n         (Shared_Libgnat_Default = SHARED\n-         or else\n-        Shared_Libgnat_Default = STATIC);\n+          or else\n+         Shared_Libgnat_Default = STATIC);\n       Shared_Libgnat := (Shared_Libgnat_Default = SHARED);\n    end;\n \n@@ -618,8 +608,8 @@ begin\n          Fail (\"switch -a must be used in conjunction with -n or -Lxxx\");\n \n       elsif not Gnatbind_Supports_Auto_Init then\n-         Fail (\"automatic initialisation of elaboration \" &\n-               \"not supported on this platform\");\n+         Fail (\"automatic initialisation of elaboration not supported on this \"\n+               & \"platform\");\n       end if;\n    end if;\n \n@@ -641,6 +631,7 @@ begin\n       Check_Extensions : declare\n          Length : constant Natural := Output_File_Name'Length;\n          Last   : constant Natural := Output_File_Name'Last;\n+\n       begin\n          if Length <= 4\n            or else Output_File_Name (Last - 3 .. Last) /= \".adb\"\n@@ -873,132 +864,19 @@ begin\n       --  Complete bind if no errors\n \n       if Errors_Detected = 0 then\n-         Find_Elab_Order;\n-\n-         if Errors_Detected = 0 then\n-            --  Display elaboration order if -l was specified\n-\n-            if Elab_Order_Output then\n-               if not Zero_Formatting then\n-                  Write_Eol;\n-                  Write_Str (\"ELABORATION ORDER\");\n-                  Write_Eol;\n-               end if;\n-\n-               for J in Elab_Order.First .. Elab_Order.Last loop\n-                  if not Units.Table (Elab_Order.Table (J)).SAL_Interface then\n-                     if not Zero_Formatting then\n-                        Write_Str (\"   \");\n-                     end if;\n-\n-                     Write_Unit_Name\n-                       (Units.Table (Elab_Order.Table (J)).Uname);\n-                     Write_Eol;\n-                  end if;\n-               end loop;\n-\n-               if not Zero_Formatting then\n-                  Write_Eol;\n-               end if;\n-            end if;\n-\n-            if not Check_Only then\n-               Gen_Output_File (Output_File_Name.all);\n-            end if;\n+         declare\n+            Elab_Order : Unit_Id_Table;\n+            use Unit_Id_Tables;\n \n-            --  Display list of sources in the closure (except predefined\n-            --  sources) if -R was used.\n-\n-            if List_Closure then\n-               List_Closure_Display : declare\n-                  Source : File_Name_Type;\n-\n-                  function Put_In_Sources (S : File_Name_Type) return Boolean;\n-                  --  Check if S is already in table Sources and put in Sources\n-                  --  if it is not. Return False if the source is already in\n-                  --  Sources, and True if it is added.\n-\n-                  --------------------\n-                  -- Put_In_Sources --\n-                  --------------------\n-\n-                  function Put_In_Sources\n-                    (S : File_Name_Type) return Boolean\n-                  is\n-                  begin\n-                     for J in 1 .. Closure_Sources.Last loop\n-                        if Closure_Sources.Table (J) = S then\n-                           return False;\n-                        end if;\n-                     end loop;\n-\n-                     Closure_Sources.Append (S);\n-                     return True;\n-                  end Put_In_Sources;\n-\n-               --  Start of processing for List_Closure_Display\n-\n-               begin\n-                  Closure_Sources.Init;\n-\n-                  if not Zero_Formatting then\n-                     Write_Eol;\n-                     Write_Str (\"REFERENCED SOURCES\");\n-                     Write_Eol;\n-                  end if;\n+         begin\n+            Find_Elab_Order (Elab_Order, First_Main_Lib_File);\n \n-                  for J in reverse Elab_Order.First .. Elab_Order.Last loop\n-                     Source := Units.Table (Elab_Order.Table (J)).Sfile;\n-\n-                     --  Do not include same source more than once\n-\n-                     if Put_In_Sources (Source)\n-\n-                       --  Do not include run-time units unless -Ra switch set\n-\n-                       and then (List_Closure_All\n-                                  or else not Is_Internal_File_Name (Source))\n-                     then\n-                        if not Zero_Formatting then\n-                           Write_Str (\"   \");\n-                        end if;\n-\n-                        Write_Str (Get_Name_String (Source));\n-                        Write_Eol;\n-                     end if;\n-                  end loop;\n-\n-                  --  Subunits do not appear in the elaboration table because\n-                  --  they are subsumed by their parent units, but we need to\n-                  --  list them for other tools. For now they are listed after\n-                  --  other files, rather than right after their parent, since\n-                  --  there is no easy link between the elaboration table and\n-                  --  the ALIs table ??? As subunits may appear repeatedly in\n-                  --  the list, if the parent unit appears in the context of\n-                  --  several units in the closure, duplicates are suppressed.\n-\n-                  for J in Sdep.First .. Sdep.Last loop\n-                     Source := Sdep.Table (J).Sfile;\n-\n-                     if Sdep.Table (J).Subunit_Name /= No_Name\n-                       and then Put_In_Sources (Source)\n-                       and then not Is_Internal_File_Name (Source)\n-                     then\n-                        if not Zero_Formatting then\n-                           Write_Str (\"   \");\n-                        end if;\n-\n-                        Write_Str (Get_Name_String (Source));\n-                        Write_Eol;\n-                     end if;\n-                  end loop;\n-\n-                  if not Zero_Formatting then\n-                     Write_Eol;\n-                  end if;\n-               end List_Closure_Display;\n+            if Errors_Detected = 0 and then not Check_Only then\n+               Gen_Output_File\n+                 (Output_File_Name.all,\n+                  Elab_Order => Elab_Order.Table (First .. Last (Elab_Order)));\n             end if;\n-         end if;\n+         end;\n       end if;\n \n       Total_Errors := Total_Errors + Errors_Detected;\n@@ -1010,7 +888,7 @@ begin\n          Total_Warnings := Total_Warnings + Warnings_Detected;\n    end;\n \n-   --  All done. Set proper exit status\n+   --  All done. Set the proper exit status.\n \n    Finalize_Binderr;\n    Namet.Finalize;"}, {"sha": "55aea49bf2fc82d6ce6b14eec1c3667897923a0e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -10374,15 +10374,26 @@ package body Sem_Ch13 is\n                   Nbit := Sbit;\n                   for J in 1 .. Ncomps loop\n                      CEnt := Comps (J);\n-                     Error_Msg_Uint_1 := Component_Bit_Offset (CEnt) - Nbit;\n \n-                     if Error_Msg_Uint_1 > 0 then\n-                        Error_Msg_NE\n-                          (\"?H?^-bit gap before component&\",\n-                           Component_Name (Component_Clause (CEnt)), CEnt);\n-                     end if;\n+                     declare\n+                        CBO : constant Uint := Component_Bit_Offset (CEnt);\n+\n+                     begin\n+                        --  Skip components with unknown offsets\n+\n+                        if CBO /= No_Uint and then CBO >= 0 then\n+                           Error_Msg_Uint_1 := CBO - Nbit;\n \n-                     Nbit := Component_Bit_Offset (CEnt) + Esize (CEnt);\n+                           if Error_Msg_Uint_1 > 0 then\n+                              Error_Msg_NE\n+                                (\"?H?^-bit gap before component&\",\n+                                 Component_Name (Component_Clause (CEnt)),\n+                                 CEnt);\n+                           end if;\n+\n+                           Nbit := CBO + Esize (CEnt);\n+                        end if;\n+                     end;\n                   end loop;\n \n                   --  Process variant parts recursively if present"}, {"sha": "7cb90bfc6da08940fee4eaa7d5eb1c53c3bd9671", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354ae44943ca7642d2f3a48ca428bfb5df2e0049/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=354ae44943ca7642d2f3a48ca428bfb5df2e0049", "patch": "@@ -274,6 +274,7 @@ package body Sem_Ch6 is\n       New_Spec : Node_Id;\n       Orig_N   : Node_Id;\n       Ret      : Node_Id;\n+      Ret_Type : Entity_Id;\n \n       Prev : Entity_Id;\n       --  If the expression is a completion, Prev is the entity whose\n@@ -366,16 +367,34 @@ package body Sem_Ch6 is\n       then\n          Set_Has_Completion (Prev, False);\n          Set_Is_Inlined (Prev);\n+         Ret_Type := Etype (Prev);\n \n          --  An expression function that is a completion freezes the\n-         --  expression. This means freezing the return type, and if it is\n-         --  an access type, freezing its designated type as well.\n+         --  expression. This means freezing the return type, and if it is an\n+         --  access type, freezing its designated type as well.\n \n          --  Note that we cannot defer this freezing to the analysis of the\n          --  expression itself, because a freeze node might appear in a nested\n          --  scope, leading to an elaboration order issue in gigi.\n \n-         Freeze_Before (N, Etype (Prev));\n+         --  An entity can only be frozen if it has a completion, so we must\n+         --  check this explicitly. If it is declared elsewhere it will have\n+         --  been frozen already, so only types declared in currently opend\n+         --  scopes need to be tested.\n+\n+         if Ekind (Ret_Type) = E_Private_Type\n+           and then In_Open_Scopes (Scope (Ret_Type))\n+           and then not Is_Generic_Type (Ret_Type)\n+           and then not Is_Frozen (Ret_Type)\n+           and then No (Full_View (Ret_Type))\n+         then\n+            Error_Msg_NE\n+              (\"premature use of private type&\",\n+               Result_Definition (Specification (N)), Ret_Type);\n+\n+         else\n+            Freeze_Before (N, Ret_Type);\n+         end if;\n \n          if Is_Access_Type (Etype (Prev)) then\n             Freeze_Before (N, Designated_Type (Etype (Prev)));"}]}