{"sha": "ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiZDU0MzkyNGQ1YjcxYzJiOWQ2NTUzZGFmZjZjNmYwMjlhMTljMA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2006-03-16T05:17:41Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2006-03-16T05:17:41Z"}, "message": "ddg.c (build_intra_loop_deps): Adjust add_forward_dependence call.\n\n2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n            Andrey Belevantsev <abel@ispras.ru>\n\n\t* ddg.c (build_intra_loop_deps): Adjust add_forward_dependence call.\n        * lists.c (unused_deps_list): New variable.\n\t(free_list): Add assertions to verify the proper distinguishing \n        between INSN_LISTs and DEPS_LISTs.\n        (find_list_elem, remove_list_elem, remove_list_node): New static\n\tfunctions.\n        (alloc_DEPS_LIST, free_DEPS_LIST, free_DEPS_LIST_node,\n        remove_free_INSN_LIST_elem, remove_free_DEPS_LIST_elem,\n        remove_free_INSN_LIST_node, remove_free_DEPS_LIST_node): New functions.\n        (alloc_INSN_LIST): Assert that the list we're working on is indeed\n\tan INSN_LIST.\n        (free_INSN_LIST_node): Likewise.\n\t* modulo-sched.c (current_sched_info): Initialize flags field.\n\t* reg-notes.def: Exchange DEP_ANTI and DEP_OUTPUT.\n\t* rtl.def (DEPS_LIST): Define.\n        * rtl.h: Declare new functions from lists.c.\n        * sched-deps.c (spec_dependency_cache): New static variable.\n        (maybe_add_or_update_back_dep_1, add_back_dep): New static functions.\n        (add_dependence): Change return type to void.  Move the logic to ...\n        (add_or_update_back_dep_1): ... here.  Handle speculative dependencies.\n        (delete_all_dependences): Add comment about forward_dependency_cache.\n\tHandle spec_dependency_cache.  Handle DEPS_LISTs.\n        (fixup_sched_groups): Clarify the change of priority of output\n        and anti dependencies.\n        (sched_analyze_2): Adjust add_dependence calls to create data\n\tspeculative dependence.\n        (add_forward_dependence): Renamed to add_forw_dep, change prototype.\n\tAdjust all callers.  Handle DEPS_LISTS.\n        (compute_forward_dependences): Use add_forw_dep.  Sort LOG_LINKs in\n\tpresence of speculation.\n        (init_dependency_caches, free_dependency_caches):\n\tHandle spec_dependency_cache.\n        (adjust_add_sorted_back_dep, adjust_back_add_forw_dep, delete_forw_dep,\n\testimate_dep_weak, get_dep_weak, ds_merge, check_dep_status):\n\tNew static functions.\n        (add_or_update_back_dep, add_or_update_back_forw_dep,\n\tadd_back_forw_dep, delete_back_forw_dep): New functions.\n\t* sched-int.h (ds_t, dw_t): New typedefs.\n\t(struct sched_info): Add new field flags.\n\t(struct haifa_insn_data): Add new bitfield has_internal_dep.\n\tPrototype new sched-deps.c functions.\n        (HAS_INTERNAL_DEP, DEP_STATUS): New access macros.\n\t(BITS_PER_DEP_STATUS, BITS_PER_DEP_WEAK, DEP_WEAK_MASK, MAX_DEP_WEAK,\n\tMIN_DEP_WEAK, NO_DEP_WEAK, UNCERTAIN_DEP_WEAK, BEGIN_DATA, BE_IN_DATA,\n\tBEGIN_CONTROL, BE_IN_CONTROL, BEGIN_SPEC, DATA_SPEC, CONTROL_SPEC,\n\tSPECULATIVE, BE_IN_SPEC, FIRST_SPEC_TYPE, LAST_SPEC_TYPE,\n\tSPEC_TYPE_SHIFT, DEP_TRUE, DEP_OUTPUT, DEP_ANTI, DEP_TYPES, HARD_DEP):\n\tNew constants.\n        (enum SPEC_TYPES_OFFSETS, enum DEPS_ADJUST_RESULT, enum SCHED_FLAGS):\n\tNew enums.\n\t* sched-rgn.c (current_sched_info): Initialize flags field.\n\t(schedule_insns): Initialize current_sched_info before the sched_init\n\tcall.\n\t* sched-ebb.c (current_sched_info): Initialize flags field.\n\t(add_deps_for_risky_insns): Use control_flow_insn_p instead of JUMP_P.\n\tCall add_or_update_back_dep instead of add_dependence.\n\tCreate control speculative dependencies.\n\t(schedule_insns): Initialize current_sched_info before the sched_init\n\tcall.\n\nCo-Authored-By: Andrey Belevantsev <abel@ispras.ru>\n\nFrom-SVN: r112125", "tree": {"sha": "9ddbe18a95fcd89be1c80f461b8e96c3764df6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ddbe18a95fcd89be1c80f461b8e96c3764df6ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/comments", "author": null, "committer": null, "parents": [{"sha": "3062335c076f3700185f1f217fe0516d0549f67d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3062335c076f3700185f1f217fe0516d0549f67d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3062335c076f3700185f1f217fe0516d0549f67d"}], "stats": {"total": 1226, "additions": 1087, "deletions": 139}, "files": [{"sha": "d6af3cbbb27c2d679bef5576af35a89ad3536888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -1,3 +1,66 @@\n+2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n+            Andrey Belevantsev <abel@ispras.ru>\n+\n+\t* ddg.c (build_intra_loop_deps): Adjust add_forward_dependence call.\n+        * lists.c (unused_deps_list): New variable.\n+\t(free_list): Add assertions to verify the proper distinguishing \n+        between INSN_LISTs and DEPS_LISTs.\n+        (find_list_elem, remove_list_elem, remove_list_node): New static\n+\tfunctions.\n+        (alloc_DEPS_LIST, free_DEPS_LIST, free_DEPS_LIST_node,\n+        remove_free_INSN_LIST_elem, remove_free_DEPS_LIST_elem,\n+        remove_free_INSN_LIST_node, remove_free_DEPS_LIST_node): New functions.\n+        (alloc_INSN_LIST): Assert that the list we're working on is indeed\n+\tan INSN_LIST.\n+        (free_INSN_LIST_node): Likewise.\n+\t* modulo-sched.c (current_sched_info): Initialize flags field.\n+\t* reg-notes.def: Exchange DEP_ANTI and DEP_OUTPUT.\n+\t* rtl.def (DEPS_LIST): Define.\n+        * rtl.h: Declare new functions from lists.c.\n+        * sched-deps.c (spec_dependency_cache): New static variable.\n+        (maybe_add_or_update_back_dep_1, add_back_dep): New static functions.\n+        (add_dependence): Change return type to void.  Move the logic to ...\n+        (add_or_update_back_dep_1): ... here.  Handle speculative dependencies.\n+        (delete_all_dependences): Add comment about forward_dependency_cache.\n+\tHandle spec_dependency_cache.  Handle DEPS_LISTs.\n+        (fixup_sched_groups): Clarify the change of priority of output\n+        and anti dependencies.\n+        (sched_analyze_2): Adjust add_dependence calls to create data\n+\tspeculative dependence.\n+        (add_forward_dependence): Renamed to add_forw_dep, change prototype.\n+\tAdjust all callers.  Handle DEPS_LISTS.\n+        (compute_forward_dependences): Use add_forw_dep.  Sort LOG_LINKs in\n+\tpresence of speculation.\n+        (init_dependency_caches, free_dependency_caches):\n+\tHandle spec_dependency_cache.\n+        (adjust_add_sorted_back_dep, adjust_back_add_forw_dep, delete_forw_dep,\n+\testimate_dep_weak, get_dep_weak, ds_merge, check_dep_status):\n+\tNew static functions.\n+        (add_or_update_back_dep, add_or_update_back_forw_dep,\n+\tadd_back_forw_dep, delete_back_forw_dep): New functions.\n+\t* sched-int.h (ds_t, dw_t): New typedefs.\n+\t(struct sched_info): Add new field flags.\n+\t(struct haifa_insn_data): Add new bitfield has_internal_dep.\n+\tPrototype new sched-deps.c functions.\n+        (HAS_INTERNAL_DEP, DEP_STATUS): New access macros.\n+\t(BITS_PER_DEP_STATUS, BITS_PER_DEP_WEAK, DEP_WEAK_MASK, MAX_DEP_WEAK,\n+\tMIN_DEP_WEAK, NO_DEP_WEAK, UNCERTAIN_DEP_WEAK, BEGIN_DATA, BE_IN_DATA,\n+\tBEGIN_CONTROL, BE_IN_CONTROL, BEGIN_SPEC, DATA_SPEC, CONTROL_SPEC,\n+\tSPECULATIVE, BE_IN_SPEC, FIRST_SPEC_TYPE, LAST_SPEC_TYPE,\n+\tSPEC_TYPE_SHIFT, DEP_TRUE, DEP_OUTPUT, DEP_ANTI, DEP_TYPES, HARD_DEP):\n+\tNew constants.\n+        (enum SPEC_TYPES_OFFSETS, enum DEPS_ADJUST_RESULT, enum SCHED_FLAGS):\n+\tNew enums.\n+\t* sched-rgn.c (current_sched_info): Initialize flags field.\n+\t(schedule_insns): Initialize current_sched_info before the sched_init\n+\tcall.\n+\t* sched-ebb.c (current_sched_info): Initialize flags field.\n+\t(add_deps_for_risky_insns): Use control_flow_insn_p instead of JUMP_P.\n+\tCall add_or_update_back_dep instead of add_dependence.\n+\tCreate control speculative dependencies.\n+\t(schedule_insns): Initialize current_sched_info before the sched_init\n+\tcall.\n+\n 2006-03-16  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/linux-unwind.h (shmedia_fallback_frame_state): Set"}, {"sha": "53cf6859c8af8ea1948dedca082172827152f7fb", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -401,8 +401,7 @@ build_intra_loop_deps (ddg_ptr g)\n \t  if (!src_node)\n \t    continue;\n \n-      \t  add_forward_dependence (XEXP (link, 0), dest_node->insn,\n-\t\t\t\t  REG_NOTE_KIND (link));\n+      \t  add_forw_dep (dest_node->insn, link);\n \t  create_ddg_dependence (g, src_node, dest_node,\n \t\t\t\t INSN_DEPEND (src_node->insn));\n \t}"}, {"sha": "70f2ee89e01c0d5f5abe7ccfc3375b477e43a04a", "filename": "gcc/lists.c", "status": "modified", "additions": 106, "deletions": 4, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n \n static void free_list (rtx *, rtx *);\n+static void free_DEPS_LIST_node (rtx);\n \n /* Functions for maintaining cache-able lists of EXPR_LIST and INSN_LISTs.  */\n \n@@ -37,11 +38,14 @@ static GTY ((deletable)) rtx unused_insn_list;\n /* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n static GTY ((deletable)) rtx unused_expr_list;\n \n+/* An DEPS_LIST containing all DEPS_LISTs allocated but currently unused.  */\n+static GTY ((deletable)) rtx unused_deps_list;\n \n-/* This function will free an entire list of either EXPR_LIST or INSN_LIST\n-   nodes. This is to be used only on lists that consist exclusively of\n-   nodes of one type only.  This is only called by free_EXPR_LIST_list\n-   and free_INSN_LIST_list.  */\n+\n+/* This function will free an entire list of either EXPR_LIST, INSN_LIST\n+   or DEPS_LIST nodes.  This is to be used only on lists that consist\n+   exclusively of nodes of one type only.  This is only called by\n+   free_EXPR_LIST_list, free_INSN_LIST_list and free_DEPS_LIST_list.  */\n static void\n free_list (rtx *listp, rtx *unused_listp)\n {\n@@ -50,8 +54,18 @@ free_list (rtx *listp, rtx *unused_listp)\n   prev_link = *listp;\n   link = XEXP (prev_link, 1);\n \n+  gcc_assert ((unused_listp != &unused_insn_list\n+\t       || GET_CODE (prev_link) == INSN_LIST)\n+\t      && (unused_listp != &unused_deps_list\n+\t\t  || GET_CODE (prev_link) == DEPS_LIST));\n+  \n   while (link)\n     {\n+      gcc_assert ((unused_listp != &unused_insn_list\n+\t\t   || GET_CODE (prev_link) == INSN_LIST)\n+\t\t  && (unused_listp != &unused_deps_list\n+\t\t      || GET_CODE (prev_link) == DEPS_LIST));\n+  \n       prev_link = link;\n       link = XEXP (link, 1);\n     }\n@@ -61,6 +75,40 @@ free_list (rtx *listp, rtx *unused_listp)\n   *listp = 0;\n }\n \n+/* Find corresponding to ELEM node in the list pointed to by LISTP.\n+   This node must exist in the list.  Returns pointer to that node.  */\n+static rtx *\n+find_list_elem (rtx elem, rtx *listp)\n+{\n+  while (XEXP (*listp, 0) != elem)\n+    listp = &XEXP (*listp, 1);\n+  return listp;\n+}\n+\n+/* Remove the node pointed to by LISTP from the list.  */\n+static void\n+remove_list_node (rtx *listp)\n+{\n+  rtx node;\n+\n+  node = *listp;\n+  *listp = XEXP (node, 1);\n+  XEXP (node, 1) = 0;\n+}\n+\n+/* Removes corresponding to ELEM node from the list pointed to by LISTP.\n+   Returns that node.  */\n+static rtx\n+remove_list_elem (rtx elem, rtx *listp)\n+{\n+  rtx node;\n+\n+  listp = find_list_elem (elem, listp);\n+  node = *listp;\n+  remove_list_node (listp);\n+  return node;\n+}\n+\n /* This call is used in place of a gen_rtx_INSN_LIST. If there is a cached\n    node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST\n    is made.  */\n@@ -76,6 +124,8 @@ alloc_INSN_LIST (rtx val, rtx next)\n       XEXP (r, 0) = val;\n       XEXP (r, 1) = next;\n       PUT_REG_NOTE_KIND (r, VOIDmode);\n+\n+      gcc_assert (GET_CODE (r) == INSN_LIST);\n     }\n   else\n     r = gen_rtx_INSN_LIST (VOIDmode, val, next);\n@@ -105,6 +155,31 @@ alloc_EXPR_LIST (int kind, rtx val, rtx next)\n   return r;\n }\n \n+/* This call is used in place of a gen_rtx_DEPS_LIST.  If there is a cached\n+   node available, we'll use it, otherwise a call to gen_rtx_DEPS_LIST\n+   is made.  */\n+rtx\n+alloc_DEPS_LIST (rtx val, rtx next, HOST_WIDE_INT ds)\n+{\n+  rtx r;\n+\n+  if (unused_deps_list)\n+    {\n+      r = unused_deps_list;\n+      unused_deps_list = XEXP (r, 1);\n+      XEXP (r, 0) = val;\n+      XEXP (r, 1) = next;\n+      XWINT (r, 2) = ds;\n+      PUT_REG_NOTE_KIND (r, VOIDmode);\n+\n+      gcc_assert (GET_CODE (r) == DEPS_LIST);\n+    }\n+  else\n+    r = gen_rtx_DEPS_LIST (VOIDmode, val, next, ds);\n+\n+  return r;\n+}\n+\n /* This function will free up an entire list of EXPR_LIST nodes.  */\n void\n free_EXPR_LIST_list (rtx *listp)\n@@ -123,6 +198,15 @@ free_INSN_LIST_list (rtx *listp)\n   free_list (listp, &unused_insn_list);\n }\n \n+/* This function will free up an entire list of DEPS_LIST nodes.  */\n+void\n+free_DEPS_LIST_list (rtx *listp)\n+{\n+  if (*listp == 0)\n+    return;\n+  free_list (listp, &unused_deps_list);\n+}\n+\n /* This function will free up an individual EXPR_LIST node.  */\n void\n free_EXPR_LIST_node (rtx ptr)\n@@ -135,8 +219,26 @@ free_EXPR_LIST_node (rtx ptr)\n void\n free_INSN_LIST_node (rtx ptr)\n {\n+  gcc_assert (GET_CODE (ptr) == INSN_LIST);\n   XEXP (ptr, 1) = unused_insn_list;\n   unused_insn_list = ptr;\n }\n \n+/* This function will free up an individual DEPS_LIST node.  */\n+static void\n+free_DEPS_LIST_node (rtx ptr)\n+{\n+  gcc_assert (GET_CODE (ptr) == DEPS_LIST);\n+  XEXP (ptr, 1) = unused_deps_list;\n+  unused_deps_list = ptr;\n+}\n+\n+/* Remove and free corresponding to ELEM node in the DEPS_LIST pointed to\n+   by LISTP.  */\n+void\n+remove_free_DEPS_LIST_elem (rtx elem, rtx *listp)\n+{\n+  free_DEPS_LIST_node (remove_list_elem (elem, listp));\n+}\n+\n #include \"gt-lists.h\""}, {"sha": "3d8ee8d57b8b37ca15efc0aa3906e857e74d01df", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -263,7 +263,9 @@ static struct sched_info sms_sched_info =\n   compute_jump_reg_dependencies,\n   NULL, NULL,\n   NULL, NULL,\n-  0, 0, 0\n+  0, 0, 0,\n+\n+  0\n };\n \n "}, {"sha": "10d558401bb8b4086d6149fbaee0f47eceacc0c2", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -99,8 +99,8 @@ REG_NOTE (LABEL)\n \n /* REG_DEP_ANTI and REG_DEP_OUTPUT are used in LOG_LINKS to represent\n    write-after-read and write-after-write dependencies respectively.  */\n-REG_NOTE (DEP_ANTI)\n REG_NOTE (DEP_OUTPUT)\n+REG_NOTE (DEP_ANTI)\n \n /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs.  It has an\n    integer value.  For jumps, it is the probability that this is a"}, {"sha": "078f4af67ac262fbf2a83f50950c0d35ac5ef0bb", "filename": "gcc/rtl.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -93,6 +93,12 @@ DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", RTX_EXTRA)\n    The insns are represented in print by their uids.  */\n DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", RTX_EXTRA)\n \n+/* a linked list of dependencies. \n+   The insns are represented in print by their uids. \n+   Operand 2 is a degree of speculativeness of the dependence.\n+   Operand 3 is a degree of weakness of the dependence.  */\n+DEF_RTL_EXPR(DEPS_LIST, \"deps_list\", \"uew\", RTX_EXTRA)\n+\n /* SEQUENCE appears in the result of a `gen_...' function\n    for a DEFINE_EXPAND that wants to make several insns.\n    Its elements are the bodies of the insns that should be made."}, {"sha": "aa90617fa7afa1a673380a5889b5349890a5f48f", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -1753,6 +1753,9 @@ void free_EXPR_LIST_node\t\t(rtx);\n void free_INSN_LIST_node\t\t(rtx);\n rtx alloc_INSN_LIST\t\t\t(rtx, rtx);\n rtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n+void free_DEPS_LIST_list (rtx *);\n+rtx alloc_DEPS_LIST (rtx, rtx, HOST_WIDE_INT);\n+void remove_free_DEPS_LIST_elem (rtx, rtx *);\n \n /* regclass.c */\n "}, {"sha": "0597d304bbc559e82fc7a7c3e65a1e6aade42022", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 714, "deletions": 120, "changes": 834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -75,8 +75,9 @@ static enum reg_pending_barrier_mode reg_pending_barrier;\n    the insn chain.  All bitmap for true dependencies cache is\n    allocated then the rest two ones are also allocated.  */\n static bitmap_head *true_dependency_cache;\n-static bitmap_head *anti_dependency_cache;\n static bitmap_head *output_dependency_cache;\n+static bitmap_head *anti_dependency_cache;\n+static bitmap_head *spec_dependency_cache;\n static int cache_size;\n \n /* To speed up checking consistency of formed forward insn\n@@ -100,6 +101,24 @@ static void sched_analyze_insn (struct deps *, rtx, rtx);\n \n static rtx sched_get_condition (rtx);\n static int conditions_mutex_p (rtx, rtx);\n+\n+static enum DEPS_ADJUST_RESULT maybe_add_or_update_back_dep_1 (rtx, rtx, \n+\t\t\t       enum reg_note, ds_t, rtx, rtx, rtx **);\n+static enum DEPS_ADJUST_RESULT add_or_update_back_dep_1 (rtx, rtx, \n+                               enum reg_note, ds_t, rtx, rtx, rtx **);\n+static void add_back_dep (rtx, rtx, enum reg_note, ds_t);\n+\n+static void adjust_add_sorted_back_dep (rtx, rtx, rtx *);\n+static void adjust_back_add_forw_dep (rtx, rtx *);\n+static void delete_forw_dep (rtx, rtx);\n+static dw_t estimate_dep_weak (rtx, rtx);\n+static dw_t get_dep_weak (ds_t, ds_t);\n+static ds_t ds_merge (ds_t, ds_t);\n+#ifdef INSN_SCHEDULING\n+#ifdef ENABLE_CHECKING\n+static void check_dep_status (enum reg_note, ds_t, bool);\n+#endif\n+#endif\n \f\n /* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n \n@@ -209,139 +228,342 @@ sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n }\n \f\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n-   LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the\n-   type of dependence that this link represents.  The function returns\n-   nonzero if a new entry has been added to insn's LOG_LINK.  */\n-\n-int\n-add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n+   LOG_LINKS of INSN, if it is not already there.  DEP_TYPE indicates the\n+   type of dependence that this link represents.  DS, if non-zero,\n+   indicates speculations, through which this dependence can be overcome.\n+   MEM1 and MEM2, if non-null, corresponds to memory locations in case of\n+   data speculation.  The function returns a value indicating if an old entry\n+   has been changed or a new entry has been added to insn's LOG_LINK.\n+   In case of changed entry CHANGED_LINKPP sets to its address.\n+   See also the definition of enum DEPS_ADJUST_RESULT in sched-int.h.  \n+   Actual manipulation of dependence data structures is performed in \n+   add_or_update_back_dep_1.  */\n+\n+static enum DEPS_ADJUST_RESULT\n+maybe_add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n+\t\t\t\tds_t ds, rtx mem1, rtx mem2,\n+\t\t\t\trtx **changed_linkpp)\n {\n-  rtx link;\n-  int present_p;\n+  gcc_assert (INSN_P (insn) && INSN_P (elem));\n \n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n-    return 0;\n+    {\n+#ifdef INSN_SCHEDULING\n+      if (current_sched_info->flags & DO_SPECULATION)\n+        /* INSN has an internal dependence, which we can't overcome.  */\n+        HAS_INTERNAL_DEP (insn) = 1;\n+#endif\n+      return 0;\n+    }\n \n-  /* We can get a dependency on deleted insns due to optimizations in\n-     the register allocation and reloading or due to splitting.  Any\n-     such dependency is useless and can be ignored.  */\n-  if (NOTE_P (elem))\n-    return 0;\n+  return add_or_update_back_dep_1 (insn, elem, dep_type,\n+\t\t\t\t   ds, mem1, mem2, changed_linkpp);\n+}\n \n-  present_p = 1;\n+/* This function has the same meaning of parameters and return values\n+   as maybe_add_or_update_back_dep_1.  The only difference between these\n+   two functions is that INSN and ELEM are guaranteed not to be the same\n+   in this one.  */\n+static enum DEPS_ADJUST_RESULT\n+add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type, \n+\t\t\t  ds_t ds ATTRIBUTE_UNUSED,\n+\t\t\t  rtx mem1 ATTRIBUTE_UNUSED, rtx mem2 ATTRIBUTE_UNUSED,\n+\t\t\t  rtx **changed_linkpp ATTRIBUTE_UNUSED)\n+{\n+  bool maybe_present_p = true, present_p = false;\n+\n+  gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);\n+  \n #ifdef INSN_SCHEDULING\n-  /* ??? No good way to tell from here whether we're doing interblock\n-     scheduling.  Possibly add another callback.  */\n-#if 0\n-  /* (This code is guarded by INSN_SCHEDULING, otherwise INSN_BB is undefined.)\n-     No need for interblock dependences with calls, since\n-     calls are not moved between blocks.   Note: the edge where\n-     elem is a CALL is still required.  */\n-  if (CALL_P (insn)\n-      && (INSN_BB (elem) != INSN_BB (insn)))\n-    return 0;\n+\n+#ifdef ENABLE_CHECKING\n+  check_dep_status (dep_type, ds, mem1 != NULL);\n #endif\n \n   /* If we already have a dependency for ELEM, then we do not need to\n      do anything.  Avoiding the list walk below can cut compile times\n      dramatically for some code.  */\n   if (true_dependency_cache != NULL)\n     {\n-      enum reg_note present_dep_type = 0;\n-\n-      gcc_assert (anti_dependency_cache);\n+      enum reg_note present_dep_type;\n+      \n       gcc_assert (output_dependency_cache);\n-      if (bitmap_bit_p (&true_dependency_cache[INSN_LUID (insn)],\n-\t\t\tINSN_LUID (elem)))\n-\t/* Do nothing (present_set_type is already 0).  */\n-\t;\n-      else if (bitmap_bit_p (&anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t INSN_LUID (elem)))\n-\tpresent_dep_type = REG_DEP_ANTI;\n-      else if (bitmap_bit_p (&output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t INSN_LUID (elem)))\n-\tpresent_dep_type = REG_DEP_OUTPUT;\n+      gcc_assert (anti_dependency_cache);\n+      if (!(current_sched_info->flags & USE_DEPS_LIST))\n+        {          \n+          if (bitmap_bit_p (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem)))\n+            present_dep_type = REG_DEP_TRUE;\n+          else if (bitmap_bit_p (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t INSN_LUID (elem)))\n+            present_dep_type = REG_DEP_OUTPUT;\n+          else if (bitmap_bit_p (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t INSN_LUID (elem)))\n+            present_dep_type = REG_DEP_ANTI;\n+          else\n+            maybe_present_p = false;\n+\n+\t  if (maybe_present_p)\n+\t    {\n+\t      if ((int) dep_type >= (int) present_dep_type)\n+\t\treturn DEP_PRESENT;\n+\t      \n+\t      present_p = true;\n+\t    }\n+        }\n       else\n-\tpresent_p = 0;\n-      if (present_p && (int) dep_type >= (int) present_dep_type)\n-\treturn 0;\n+        {      \n+          ds_t present_dep_types = 0;\n+          \n+          if (bitmap_bit_p (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem)))\n+            present_dep_types |= DEP_TRUE;\n+          if (bitmap_bit_p (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem)))\n+            present_dep_types |= DEP_OUTPUT;\n+          if (bitmap_bit_p (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem)))\n+            present_dep_types |= DEP_ANTI;\n+\n+          if (present_dep_types)\n+\t    {\n+\t      if (!(current_sched_info->flags & DO_SPECULATION)\n+\t\t  || !bitmap_bit_p (&spec_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t    INSN_LUID (elem)))\n+\t\t{\n+\t\t  if ((present_dep_types | (ds & DEP_TYPES))\n+\t\t      == present_dep_types)\n+\t\t    /* We already have all these bits.  */\n+\t\t    return DEP_PRESENT;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Only true dependencies can be data speculative and\n+\t\t     only anti dependencies can be control speculative.  */\n+\t\t  gcc_assert ((present_dep_types & (DEP_TRUE | DEP_ANTI))\n+\t\t\t      == present_dep_types);\n+\t\t  \n+\t\t  /* if (additional dep is SPECULATIVE) then\n+ \t\t       we should update DEP_STATUS\n+\t\t     else\n+\t\t       we should reset existing dep to non-speculative.  */\n+\t\t}\n+\t  \t\n+\t      present_p = true;\n+\t    }\n+\t  else\n+\t    maybe_present_p = false;\n+        }\n     }\n #endif\n \n   /* Check that we don't already have this dependence.  */\n-  if (present_p)\n-    for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-      if (XEXP (link, 0) == elem)\n-\t{\n+  if (maybe_present_p)\n+    {\n+      rtx *linkp;\n+\n+      for (linkp = &LOG_LINKS (insn); *linkp; linkp = &XEXP (*linkp, 1))\n+        {\n+          rtx link = *linkp;\n+\n+\t  gcc_assert (true_dependency_cache == 0 || present_p);\n+\t  \n+          if (XEXP (link, 0) == elem)\n+            {\n+              enum DEPS_ADJUST_RESULT changed_p = DEP_PRESENT;\n+\n #ifdef INSN_SCHEDULING\n-\t  /* Clear corresponding cache entry because type of the link\n-             may be changed.  */\n-\t  if (true_dependency_cache != NULL)\n-\t    {\n-\t      enum reg_note kind = REG_NOTE_KIND (link);\n-\t      switch (kind)\n+              if (current_sched_info->flags & USE_DEPS_LIST)\n+                {\n+                  ds_t new_status = ds | DEP_STATUS (link);\n+\n+\t\t  if (new_status & SPECULATIVE)\n+\t\t    {\n+\t\t      if (!(ds & SPECULATIVE)\n+\t\t\t  || !(DEP_STATUS (link) & SPECULATIVE))\n+\t\t\t/* Then this dep can't be speculative.  */\n+\t\t\t{\n+\t\t\t  new_status &= ~SPECULATIVE;\n+\t\t\t  if (true_dependency_cache\n+\t\t\t      && (DEP_STATUS (link) & SPECULATIVE))\n+\t\t\t    bitmap_clear_bit (&spec_dependency_cache\n+\t\t\t\t\t      [INSN_LUID (insn)],\n+\t\t\t\t\t      INSN_LUID (elem));\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* Both are speculative.  Merging probabilities.  */\n+\t\t\t  if (mem1)\n+\t\t\t    {\n+\t\t\t      dw_t dw;\n+\n+\t\t\t      dw = estimate_dep_weak (mem1, mem2);\n+\t\t\t      ds = set_dep_weak (ds, BEGIN_DATA, dw);\n+\t\t\t    }\n+\t\t\t\t\t\t\t \n+\t\t\t  new_status = ds_merge (DEP_STATUS (link), ds);\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  ds = new_status;\n+                }\n+\n+              /* Clear corresponding cache entry because type of the link\n+                 may have changed.  Keep them if we use_deps_list.  */\n+              if (true_dependency_cache != NULL\n+\t\t  && !(current_sched_info->flags & USE_DEPS_LIST))\n+\t\t{\n+\t\t  enum reg_note kind = REG_NOTE_KIND (link);\n+\n+\t\t  switch (kind)\n+\t\t    {\n+\t\t    case REG_DEP_OUTPUT:\n+\t\t      bitmap_clear_bit (&output_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+\t\t      break;\n+\t\t    case REG_DEP_ANTI:\n+\t\t      bitmap_clear_bit (&anti_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+\t\t      break;\n+\t\t    default:\n+\t\t      gcc_unreachable ();                        \n+                    }\n+                }\n+\n+              if ((current_sched_info->flags & USE_DEPS_LIST)\n+\t\t  && DEP_STATUS (link) != ds)\n \t\t{\n-\t\tcase REG_DEP_ANTI:\n-\t\t  bitmap_clear_bit (&anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\t    INSN_LUID (elem));\n-\t\t  break;\n-\t\tcase REG_DEP_OUTPUT:\n-\t\t  gcc_assert (output_dependency_cache);\n-\t\t  bitmap_clear_bit (&output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\t    INSN_LUID (elem));\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n+\t\t  DEP_STATUS (link) = ds;\n+\t\t  changed_p = DEP_CHANGED;\n \t\t}\n-\t    }\n #endif\n \n-\t  /* If this is a more restrictive type of dependence than the existing\n-\t     one, then change the existing dependence to this type.  */\n-\t  if ((int) dep_type < (int) REG_NOTE_KIND (link))\n-\t    PUT_REG_NOTE_KIND (link, dep_type);\n+              /* If this is a more restrictive type of dependence than the\n+\t\t existing one, then change the existing dependence to this\n+\t\t type.  */\n+              if ((int) dep_type < (int) REG_NOTE_KIND (link))\n+                {\n+                  PUT_REG_NOTE_KIND (link, dep_type);\n+                  changed_p = DEP_CHANGED;\n+                }\n \n #ifdef INSN_SCHEDULING\n-\t  /* If we are adding a dependency to INSN's LOG_LINKs, then\n-\t     note that in the bitmap caches of dependency information.  */\n-\t  if (true_dependency_cache != NULL)\n-\t    {\n-\t      if ((int) REG_NOTE_KIND (link) == 0)\n-\t\tbitmap_set_bit (&true_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\tINSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tbitmap_set_bit (&anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\tINSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-\t\tbitmap_set_bit (&output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t\tINSN_LUID (elem));\n-\t    }\n+              /* If we are adding a dependency to INSN's LOG_LINKs, then\n+                 note that in the bitmap caches of dependency information.  */\n+              if (true_dependency_cache != NULL)\n+                {\n+                  if (!(current_sched_info->flags & USE_DEPS_LIST))\n+                    {\n+                      if (REG_NOTE_KIND (link) == REG_DEP_TRUE)\n+                        bitmap_set_bit (&true_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+                      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+                        bitmap_set_bit (&output_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+                      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+                        bitmap_set_bit (&anti_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+                    }\n+                  else\n+                    {\n+                      if (ds & DEP_TRUE)\n+                        bitmap_set_bit (&true_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+                      if (ds & DEP_OUTPUT)\n+                        bitmap_set_bit (&output_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+                      if (ds & DEP_ANTI)\n+                        bitmap_set_bit (&anti_dependency_cache\n+\t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n+                      /* Note, that dep can become speculative only \n+                         at the moment of creation. Thus, we don't need to \n+\t\t         check for it here.  */\n+                    }\n+                }\n+              \n+              if (changed_linkpp && changed_p == DEP_CHANGED)\n+                *changed_linkpp = linkp;\n #endif\n-\t  return 0;\n-\t}\n-  /* Might want to check one level of transitivity to save conses.  */\n+              return changed_p;\n+            }\t  \n+        }\n+      /* We didn't find a dep. It shouldn't be present in the cache.  */\n+      gcc_assert (!present_p);\n+    }\n \n-  link = alloc_INSN_LIST (elem, LOG_LINKS (insn));\n-  LOG_LINKS (insn) = link;\n+  /* Might want to check one level of transitivity to save conses.\n+     This check should be done in maybe_add_or_update_back_dep_1.\n+     Since we made it to add_or_update_back_dep_1, we must create\n+     (or update) a link.  */\n \n-  /* Insn dependency, not data dependency.  */\n-  PUT_REG_NOTE_KIND (link, dep_type);\n+  if (mem1)\n+    {\n+      gcc_assert (current_sched_info->flags & DO_SPECULATION);\n+      ds = set_dep_weak (ds, BEGIN_DATA, estimate_dep_weak (mem1, mem2));\n+    }\n+  \n+  add_back_dep (insn, elem, dep_type, ds);\n+  \n+  return DEP_CREATED;\n+}\n \n+/* This function creates a link between INSN and ELEM under any\n+   conditions.  DS describes speculative status of the link.  */\n+static void\n+add_back_dep (rtx insn, rtx elem, enum reg_note dep_type, ds_t ds)\n+{\n+  gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);\n+\n+  if (current_sched_info->flags & USE_DEPS_LIST)\n+    LOG_LINKS (insn) = alloc_DEPS_LIST (elem, LOG_LINKS (insn), ds);\n+  else\n+    LOG_LINKS (insn) = alloc_INSN_LIST (elem, LOG_LINKS (insn));\n+  \n+  /* Insn dependency, not data dependency.  */\n+  PUT_REG_NOTE_KIND (LOG_LINKS (insn), dep_type);\n+    \n #ifdef INSN_SCHEDULING\n+#ifdef ENABLE_CHECKING\n+  check_dep_status (dep_type, ds, false);\n+#endif\n+\n   /* If we are adding a dependency to INSN's LOG_LINKs, then note that\n      in the bitmap caches of dependency information.  */\n   if (true_dependency_cache != NULL)\n     {\n-      if ((int) dep_type == 0)\n-\tbitmap_set_bit (&true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n-      else if (dep_type == REG_DEP_ANTI)\n-\tbitmap_set_bit (&anti_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n-      else if (dep_type == REG_DEP_OUTPUT)\n-\tbitmap_set_bit (&output_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+      if (!(current_sched_info->flags & USE_DEPS_LIST))\n+        {\n+          if (dep_type == REG_DEP_TRUE)\n+            bitmap_set_bit (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem));\n+          else if (dep_type == REG_DEP_OUTPUT)\n+            bitmap_set_bit (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem));\n+          else if (dep_type == REG_DEP_ANTI)\n+                bitmap_set_bit (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\tINSN_LUID (elem));\n+        }\n+      else\n+        {\n+          if (ds & DEP_TRUE)\n+            bitmap_set_bit (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem));\n+          if (ds & DEP_OUTPUT)\n+            bitmap_set_bit (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem));\n+          if (ds & DEP_ANTI)\n+            bitmap_set_bit (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t    INSN_LUID (elem));\n+          if (ds & SPECULATIVE)\n+\t    {\n+\t      gcc_assert (current_sched_info->flags & DO_SPECULATION);\n+\t      bitmap_set_bit (&spec_dependency_cache[INSN_LUID (insn)],\n+\t\t\t      INSN_LUID (elem));\n+\t    }\n+        }\n     }\n #endif\n-  return 1;\n }\n \n /* A convenience wrapper to operate on an entire list.  */\n@@ -383,12 +605,21 @@ delete_all_dependences (rtx insn)\n   if (true_dependency_cache != NULL)\n     {\n       bitmap_clear (&true_dependency_cache[INSN_LUID (insn)]);\n-      bitmap_clear (&anti_dependency_cache[INSN_LUID (insn)]);\n       bitmap_clear (&output_dependency_cache[INSN_LUID (insn)]);\n+      bitmap_clear (&anti_dependency_cache[INSN_LUID (insn)]);\n+      /* We don't have to clear forward_dependency_cache here,\n+\t because it is formed later.  */\n+      if (current_sched_info->flags & DO_SPECULATION)\n+        bitmap_clear (&spec_dependency_cache[INSN_LUID (insn)]);\n     }\n #endif\n \n-  free_INSN_LIST_list (&LOG_LINKS (insn));\n+  if (!(current_sched_info->flags & USE_DEPS_LIST))\n+    /* In this case LOG_LINKS are formed from the DEPS_LISTs,\n+       not the INSN_LISTs.  */\n+    free_INSN_LIST_list (&LOG_LINKS (insn));  \n+  else\n+    free_DEPS_LIST_list (&LOG_LINKS (insn));\n }\n \n /* All insns in a scheduling group except the first should only have\n@@ -430,8 +661,8 @@ fixup_sched_groups (rtx insn)\n \n    (0) read dependence: read follows read\n    (1) true dependence: read follows write\n-   (2) anti dependence: write follows read\n-   (3) output dependence: write follows write\n+   (2) output dependence: write follows write\n+   (3) anti dependence: write follows read\n \n    We are careful to build only dependencies which actually exist, and\n    use transitivity to avoid building too many links.  */\n@@ -787,7 +1018,15 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t    if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n \t\t\t\t t, rtx_varies_p)\n \t\t&& ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t      add_dependence (insn, XEXP (pending, 0), REG_DEP_TRUE);\n+              {\n+                if (current_sched_info->flags & DO_SPECULATION)\n+                  maybe_add_or_update_back_dep_1 (insn, XEXP (pending, 0),\n+\t\t\t\t\t\t  REG_DEP_TRUE,\n+\t\t\t\t\t\t  BEGIN_DATA | DEP_TRUE,\n+\t\t\t\t\t\t  XEXP (pending_mem, 0), t, 0);\n+                else\n+                  add_dependence (insn, XEXP (pending, 0), REG_DEP_TRUE);\n+              }\n \n \t    pending = XEXP (pending, 1);\n \t    pending_mem = XEXP (pending_mem, 1);\n@@ -1391,9 +1630,11 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n    given DEP_TYPE.  The forward dependence should be not exist before.  */\n \n void\n-add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n+add_forw_dep (rtx to, rtx link)\n {\n-  rtx new_link;\n+  rtx new_link, from;\n+\n+  from = XEXP (link, 0);\n \n #ifdef ENABLE_CHECKING\n   /* If add_dependence is working properly there should never\n@@ -1402,23 +1643,25 @@ add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n \n      However, if we have enabled checking we might as well go\n      ahead and verify that add_dependence worked properly.  */\n-  gcc_assert (!NOTE_P (from));\n+  gcc_assert (INSN_P (from));\n   gcc_assert (!INSN_DELETED_P (from));\n-  if (forward_dependency_cache)\n-    gcc_assert (!bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n-\t\t\t       INSN_LUID (to)));\n+  if (true_dependency_cache)\n+    {\n+      gcc_assert (!bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n+\t\t\t\t INSN_LUID (to)));\n+      bitmap_set_bit (&forward_dependency_cache[INSN_LUID (from)],\n+\t\t      INSN_LUID (to));\n+    }\n   else\n     gcc_assert (!find_insn_list (to, INSN_DEPEND (from)));\n-\n-  /* ??? If bitmap_bit_p is a predicate, what is this supposed to do? */\n-  if (forward_dependency_cache != NULL)\n-    bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n-\t\t  INSN_LUID (to));\n #endif\n \n-  new_link = alloc_INSN_LIST (to, INSN_DEPEND (from));\n+  if (!(current_sched_info->flags & USE_DEPS_LIST))\n+    new_link = alloc_INSN_LIST (to, INSN_DEPEND (from));\n+  else\n+    new_link = alloc_DEPS_LIST (to, INSN_DEPEND (from), DEP_STATUS (link));\n \n-  PUT_REG_NOTE_KIND (new_link, dep_type);\n+  PUT_REG_NOTE_KIND (new_link, REG_NOTE_KIND (link));\n \n   INSN_DEPEND (from) = new_link;\n   INSN_DEP_COUNT (to) += 1;\n@@ -1431,17 +1674,32 @@ add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n void\n compute_forward_dependences (rtx head, rtx tail)\n {\n-  rtx insn, link;\n+  rtx insn;\n   rtx next_tail;\n \n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n+      rtx link;\n+      \n       if (! INSN_P (insn))\n \tcontinue;\n+      \n+      if (current_sched_info->flags & DO_SPECULATION)\n+        {\n+          rtx new = 0, link, next;\n+\n+          for (link = LOG_LINKS (insn); link; link = next)\n+            {\n+              next = XEXP (link, 1);\n+              adjust_add_sorted_back_dep (insn, link, &new);\n+            }\n+\n+          LOG_LINKS (insn) = new;\n+        }\n \n       for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\tadd_forward_dependence (XEXP (link, 0), insn, REG_NOTE_KIND (link));\n+        add_forw_dep (insn, link);\n     }\n }\n \f\n@@ -1520,20 +1778,27 @@ init_dependency_caches (int luid)\n   if (luid / n_basic_blocks > 100 * 5)\n     {\n       int i;\n+\n       true_dependency_cache = XNEWVEC (bitmap_head, luid);\n       anti_dependency_cache = XNEWVEC (bitmap_head, luid);\n       output_dependency_cache = XNEWVEC (bitmap_head, luid);\n #ifdef ENABLE_CHECKING\n       forward_dependency_cache = XNEWVEC (bitmap_head, luid);\n #endif\n+      if (current_sched_info->flags & DO_SPECULATION)\n+        spec_dependency_cache = XRESIZEVEC (bitmap_head, spec_dependency_cache,\n+\t\t\t\t\t    luid);\n+\n       for (i = 0; i < luid; i++)\n \t{\n \t  bitmap_initialize (&true_dependency_cache[i], 0);\n-\t  bitmap_initialize (&anti_dependency_cache[i], 0);\n \t  bitmap_initialize (&output_dependency_cache[i], 0);\n+\t  bitmap_initialize (&anti_dependency_cache[i], 0);\n #ifdef ENABLE_CHECKING\n \t  bitmap_initialize (&forward_dependency_cache[i], 0);\n #endif\n+          if (current_sched_info->flags & DO_SPECULATION)\n+            bitmap_initialize (&spec_dependency_cache[i], 0);\n \t}\n       cache_size = luid;\n     }\n@@ -1551,22 +1816,29 @@ free_dependency_caches (void)\n       for (i = 0; i < cache_size; i++)\n \t{\n \t  bitmap_clear (&true_dependency_cache[i]);\n-\t  bitmap_clear (&anti_dependency_cache[i]);\n \t  bitmap_clear (&output_dependency_cache[i]);\n+\t  bitmap_clear (&anti_dependency_cache[i]);\n #ifdef ENABLE_CHECKING\n \t  bitmap_clear (&forward_dependency_cache[i]);\n #endif\n+          if (current_sched_info->flags & DO_SPECULATION)\n+            bitmap_clear (&spec_dependency_cache[i]);\n \t}\n       free (true_dependency_cache);\n       true_dependency_cache = NULL;\n-      free (anti_dependency_cache);\n-      anti_dependency_cache = NULL;\n       free (output_dependency_cache);\n       output_dependency_cache = NULL;\n+      free (anti_dependency_cache);\n+      anti_dependency_cache = NULL;\n #ifdef ENABLE_CHECKING\n       free (forward_dependency_cache);\n       forward_dependency_cache = NULL;\n #endif\n+      if (current_sched_info->flags & DO_SPECULATION)\n+        {\n+          free (spec_dependency_cache);\n+          spec_dependency_cache = NULL;\n+        }\n     }\n }\n \n@@ -1591,3 +1863,325 @@ finish_deps_global (void)\n   FREE_REG_SET (reg_pending_clobbers);\n   FREE_REG_SET (reg_pending_uses);\n }\n+\n+/* Insert LINK into the dependence chain pointed to by LINKP and \n+   maintain the sort order.  */\n+static void\n+adjust_add_sorted_back_dep (rtx insn, rtx link, rtx *linkp)\n+{\n+  gcc_assert (current_sched_info->flags & DO_SPECULATION);\n+  \n+  /* If the insn cannot move speculatively, but the link is speculative,   \n+     make it hard dependence.  */\n+  if (HAS_INTERNAL_DEP (insn)\n+      && (DEP_STATUS (link) & SPECULATIVE))\n+    {      \n+      DEP_STATUS (link) &= ~SPECULATIVE;\n+      \n+      if (true_dependency_cache)\n+        bitmap_clear_bit (&spec_dependency_cache[INSN_LUID (insn)],\n+\t\t\t  INSN_LUID (XEXP (link, 0)));\n+    }\n+\n+  /* Non-speculative links go at the head of LOG_LINKS, followed by\n+     speculative links.  */\n+  if (DEP_STATUS (link) & SPECULATIVE)\n+    while (*linkp && !(DEP_STATUS (*linkp) & SPECULATIVE))\n+      linkp = &XEXP (*linkp, 1);\n+\n+  XEXP (link, 1) = *linkp;\n+  *linkp = link;\n+}\n+\n+/* Move the dependence pointed to by LINKP to the back dependencies  \n+   of INSN, and also add this dependence to the forward ones.  All LOG_LINKS,\n+   except one pointed to by LINKP, must be sorted.  */\n+static void\n+adjust_back_add_forw_dep (rtx insn, rtx *linkp)\n+{\n+  rtx link;\n+\n+  gcc_assert (current_sched_info->flags & DO_SPECULATION);\n+\n+  link = *linkp;\n+  *linkp = XEXP (*linkp, 1);  \n+\n+  adjust_add_sorted_back_dep (insn, link, &LOG_LINKS (insn));\n+  add_forw_dep (insn, link);\n+}\n+\n+/* Remove forward dependence ELEM from the DEPS_LIST of INSN.  */\n+static void\n+delete_forw_dep (rtx insn, rtx elem)\n+{\n+  gcc_assert (current_sched_info->flags & DO_SPECULATION);\n+\n+#ifdef ENABLE_CHECKING\n+  if (true_dependency_cache)\n+    bitmap_clear_bit (&forward_dependency_cache[INSN_LUID (elem)],\n+\t\t      INSN_LUID (insn));\n+#endif\n+\n+  remove_free_DEPS_LIST_elem (insn, &INSN_DEPEND (elem));    \n+  INSN_DEP_COUNT (insn)--;\n+}\n+\n+/* Estimate the weakness of dependence between MEM1 and MEM2.  */\n+static dw_t\n+estimate_dep_weak (rtx mem1, rtx mem2)\n+{\n+  rtx r1, r2;\n+\n+  if (mem1 == mem2)\n+    /* MEMs are the same - don't speculate.  */\n+    return MIN_DEP_WEAK;\n+\n+  r1 = XEXP (mem1, 0);\n+  r2 = XEXP (mem2, 0);\n+\n+  if (r1 == r2\n+      || (REG_P (r1) && REG_P (r2)\n+\t  && REGNO (r1) == REGNO (r2)))\n+    /* Again, MEMs are the same.  */\n+    return MIN_DEP_WEAK;\n+  else if ((REG_P (r1) && !REG_P (r2))\n+\t   || (!REG_P (r1) && REG_P (r2)))\n+    /* Different addressing modes - reason to be more speculative,\n+       than usual.  */\n+    return NO_DEP_WEAK - (NO_DEP_WEAK - UNCERTAIN_DEP_WEAK) / 2;\n+  else\n+    /* We can't say anything about the dependence.  */\n+    return UNCERTAIN_DEP_WEAK;\n+}\n+\n+/* Add or update backward dependence between INSN and ELEM with type DEP_TYPE.\n+   This function can handle same INSN and ELEM (INSN == ELEM).\n+   It is a convenience wrapper.  */\n+void\n+add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n+{\n+  ds_t ds;\n+  \n+  if (dep_type == REG_DEP_TRUE)\n+    ds = DEP_TRUE;\n+  else if (dep_type == REG_DEP_OUTPUT)\n+    ds = DEP_OUTPUT;\n+  else if (dep_type == REG_DEP_ANTI)\n+    ds = DEP_ANTI;\n+  else\n+    gcc_unreachable ();\n+\n+  maybe_add_or_update_back_dep_1 (insn, elem, dep_type, ds, 0, 0, 0);\n+}\n+\n+/* Add or update backward dependence between INSN and ELEM\n+   with given type DEP_TYPE and dep_status DS.\n+   This function is a convenience wrapper.  */\n+enum DEPS_ADJUST_RESULT\n+add_or_update_back_dep (rtx insn, rtx elem, enum reg_note dep_type, ds_t ds)\n+{\n+  return add_or_update_back_dep_1 (insn, elem, dep_type, ds, 0, 0, 0);\n+}\n+\n+/* Add or update both backward and forward dependencies between INSN and ELEM\n+   with given type DEP_TYPE and dep_status DS.  */\n+void\n+add_or_update_back_forw_dep (rtx insn, rtx elem, enum reg_note dep_type,\n+\t\t\t     ds_t ds)\n+{\n+  enum DEPS_ADJUST_RESULT res;\n+  rtx *linkp;\n+\n+  res = add_or_update_back_dep_1 (insn, elem, dep_type, ds, 0, 0, &linkp);\n+\n+  if (res == DEP_CHANGED || res == DEP_CREATED)\n+    {\n+      if (res == DEP_CHANGED)\n+\tdelete_forw_dep (insn, elem);\n+      else if (res == DEP_CREATED)\n+\tlinkp = &LOG_LINKS (insn);\n+\n+      adjust_back_add_forw_dep (insn, linkp);\n+    }\n+}\n+\n+/* Add both backward and forward dependencies between INSN and ELEM\n+   with given type DEP_TYPE and dep_status DS.  */\n+void\n+add_back_forw_dep (rtx insn, rtx elem, enum reg_note dep_type, ds_t ds)\n+{\n+  add_back_dep (insn, elem, dep_type, ds);  \n+  adjust_back_add_forw_dep (insn, &LOG_LINKS (insn));    \n+}\n+\n+/* Remove both backward and forward dependencies between INSN and ELEM.  */\n+void\n+delete_back_forw_dep (rtx insn, rtx elem)\n+{\n+  gcc_assert (current_sched_info->flags & DO_SPECULATION);\n+\n+  if (true_dependency_cache != NULL)\n+    {\n+      bitmap_clear_bit (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\tINSN_LUID (elem));\n+      bitmap_clear_bit (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\tINSN_LUID (elem));\n+      bitmap_clear_bit (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\tINSN_LUID (elem));\n+      bitmap_clear_bit (&spec_dependency_cache[INSN_LUID (insn)],\n+\t\t\tINSN_LUID (elem));\n+    }\n+\n+  remove_free_DEPS_LIST_elem (elem, &LOG_LINKS (insn));\n+  delete_forw_dep (insn, elem);\n+}\n+\n+/* Return weakness of speculative type TYPE in the dep_status DS.  */\n+static dw_t\n+get_dep_weak (ds_t ds, ds_t type)\n+{\n+  ds = ds & type;\n+  switch (type)\n+    {\n+    case BEGIN_DATA: ds >>= BEGIN_DATA_BITS_OFFSET; break;\n+    case BE_IN_DATA: ds >>= BE_IN_DATA_BITS_OFFSET; break;\n+    case BEGIN_CONTROL: ds >>= BEGIN_CONTROL_BITS_OFFSET; break;\n+    case BE_IN_CONTROL: ds >>= BE_IN_CONTROL_BITS_OFFSET; break;\n+    default: gcc_unreachable ();\n+    }\n+\n+  gcc_assert (MIN_DEP_WEAK <= ds && ds <= MAX_DEP_WEAK);\n+  return (dw_t) ds;\n+}\n+\n+/* Return the dep_status, which has the same parameters as DS, except for\n+   speculative type TYPE, that will have weakness DW.  */\n+ds_t\n+set_dep_weak (ds_t ds, ds_t type, dw_t dw)\n+{\n+  gcc_assert (MIN_DEP_WEAK <= dw && dw <= MAX_DEP_WEAK);\n+\n+  ds &= ~type;\n+  switch (type)\n+    {\n+    case BEGIN_DATA: ds |= ((ds_t) dw) << BEGIN_DATA_BITS_OFFSET; break;\n+    case BE_IN_DATA: ds |= ((ds_t) dw) << BE_IN_DATA_BITS_OFFSET; break;\n+    case BEGIN_CONTROL: ds |= ((ds_t) dw) << BEGIN_CONTROL_BITS_OFFSET; break;\n+    case BE_IN_CONTROL: ds |= ((ds_t) dw) << BE_IN_CONTROL_BITS_OFFSET; break;\n+    default: gcc_unreachable ();\n+    }\n+  return ds;\n+}\n+\n+/* Return the join of two dep_statuses DS1 and DS2.  */\n+static ds_t\n+ds_merge (ds_t ds1, ds_t ds2)\n+{\n+  ds_t ds, t;\n+\n+  gcc_assert ((ds1 & SPECULATIVE) && (ds2 & SPECULATIVE));\n+\n+  ds = (ds1 & DEP_TYPES) | (ds2 & DEP_TYPES);\n+\n+  t = FIRST_SPEC_TYPE;\n+  do\n+    {\n+      if ((ds1 & t) && !(ds2 & t))\n+\tds |= ds1 & t;\n+      else if (!(ds1 & t) && (ds2 & t))\n+\tds |= ds2 & t;\n+      else if ((ds1 & t) && (ds2 & t))\n+\t{\n+\t  ds_t dw;\n+\n+\t  dw = ((ds_t) get_dep_weak (ds1, t)) * ((ds_t) get_dep_weak (ds2, t));\n+\t  dw /= MAX_DEP_WEAK;\n+\t  if (dw < MIN_DEP_WEAK)\n+\t    dw = MIN_DEP_WEAK;\n+\n+\t  ds = set_dep_weak (ds, t, (dw_t) dw);\n+\t}\n+\n+      if (t == LAST_SPEC_TYPE)\n+\tbreak;\n+      t <<= SPEC_TYPE_SHIFT;\n+    }\n+  while (1);\n+\n+  return ds;\n+}\n+\n+#ifdef INSN_SCHEDULING\n+#ifdef ENABLE_CHECKING\n+/* Verify that dependence type and status are consistent.\n+   If RELAXED_P is true, then skip dep_weakness checks.  */\n+static void\n+check_dep_status (enum reg_note dt, ds_t ds, bool relaxed_p)\n+{\n+  /* Check that dependence type contains the same bits as the status.  */\n+  if (dt == REG_DEP_TRUE)\n+    gcc_assert (ds & DEP_TRUE);\n+  else if (dt == REG_DEP_OUTPUT)\n+    gcc_assert ((ds & DEP_OUTPUT)\n+\t\t&& !(ds & DEP_TRUE));    \n+  else \n+    gcc_assert ((dt == REG_DEP_ANTI)\n+\t\t&& (ds & DEP_ANTI)\n+\t\t&& !(ds & (DEP_OUTPUT | DEP_TRUE)));\n+\n+  /* HARD_DEP can not appear in dep_status of a link.  */\n+  gcc_assert (!(ds & HARD_DEP));\t  \n+\n+  /* Check that dependence status is set correctly when speculation is not\n+     supported.  */\n+  if (!(current_sched_info->flags & DO_SPECULATION))\n+    gcc_assert (!(ds & SPECULATIVE));\n+  else if (ds & SPECULATIVE)\n+    {\n+      if (!relaxed_p)\n+\t{\n+\t  ds_t type = FIRST_SPEC_TYPE;\n+\n+\t  /* Check that dependence weakness is in proper range.  */\n+\t  do\n+\t    {\n+\t      if (ds & type)\n+\t\tget_dep_weak (ds, type);\n+\n+\t      if (type == LAST_SPEC_TYPE)\n+\t\tbreak;\n+\t      type <<= SPEC_TYPE_SHIFT;\n+\t    }\n+\t  while (1);\n+\t}\n+\n+      if (ds & BEGIN_SPEC)\n+\t{\n+\t  /* Only true dependence can be data speculative.  */\n+\t  if (ds & BEGIN_DATA)\n+\t    gcc_assert (ds & DEP_TRUE);\n+\n+\t  /* Control dependencies in the insn scheduler are represented by\n+\t     anti-dependencies, therefore only anti dependence can be\n+\t     control speculative.  */\n+\t  if (ds & BEGIN_CONTROL)\n+\t    gcc_assert (ds & DEP_ANTI);\n+\t}\n+      else\n+\t{\n+\t  /* Subsequent speculations should resolve true dependencies.  */\n+\t  gcc_assert ((ds & DEP_TYPES) == DEP_TRUE);\n+\t}\n+          \n+      /* Check that true and anti depencies can't have other speculative \n+\t statuses.  */\n+      if (ds & DEP_TRUE)\n+\tgcc_assert (ds & (BEGIN_DATA | BE_IN_SPEC));\n+      /* An output dependence can't be speculative at all.  */\n+      gcc_assert (!(ds & DEP_OUTPUT));\n+      if (ds & DEP_ANTI)\n+\tgcc_assert (ds & BEGIN_CONTROL);\n+    }\n+}\n+#endif\n+#endif  "}, {"sha": "2fa454df238f1b73bde34fe61be92e6fc4fd9651", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -205,7 +205,9 @@ static struct sched_info ebb_sched_info =\n \n   NULL, NULL,\n   NULL, NULL,\n-  0, 1, 0\n+  0, 1, 0,\n+\n+  0\n };\n \f\n /* It is possible that ebb scheduling eliminated some blocks.\n@@ -421,7 +423,7 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n   basic_block last_block = NULL, bb;\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (JUMP_P (insn))\n+    if (control_flow_insn_p (insn))\n       {\n \tbb = BLOCK_FOR_INSN (insn);\n \tbb->aux = last_block;\n@@ -455,9 +457,27 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n \t    /* We can not change the mode of the backward\n \t       dependency because REG_DEP_ANTI has the lowest\n \t       rank.  */\n-\t    if (! sched_insns_conditions_mutex_p (insn, prev)\n-\t\t&& add_dependence (insn, prev, REG_DEP_ANTI))\n-\t      add_forward_dependence (prev, insn, REG_DEP_ANTI);\n+\t    if (! sched_insns_conditions_mutex_p (insn, prev))\n+\t      {\n+\t\tif (!(current_sched_info->flags & DO_SPECULATION))\n+\t\t  {\n+\t\t    enum DEPS_ADJUST_RESULT res;\n+\t\t    \n+\t\t    res = add_or_update_back_dep (insn, prev,\n+\t\t\t\t\t\t  REG_DEP_ANTI, DEP_ANTI);\n+\n+\t\t    if (res == DEP_CREATED)\n+\t\t      add_forw_dep (insn, LOG_LINKS (insn));\n+\t\t    else\n+\t\t      gcc_assert (res != DEP_CHANGED);\n+\t\t  }\n+\t\telse\n+\t\t  add_or_update_back_forw_dep (insn, prev, REG_DEP_ANTI,\n+\t\t\t\t\t       set_dep_weak (DEP_ANTI,\n+\t\t\t\t\t\t\t     BEGIN_CONTROL,\n+\t\t\t\t\t\t\t     MAX_DEP_WEAK));\n+\t      }\n+\n             break;\n \n           default:\n@@ -571,10 +591,12 @@ schedule_ebbs (void)\n   if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return;\n \n-  sched_init ();\n-\n+  /* We need current_sched_info in init_dependency_caches, which is\n+     invoked via sched_init.  */\n   current_sched_info = &ebb_sched_info;\n \n+  sched_init ();\n+\n   compute_bb_for_insn ();\n \n   /* Schedule every region in the subroutine.  */"}, {"sha": "15f1a3d71d71a75f487a7d4698630e2a20d7e536", "filename": "gcc/sched-int.h", "status": "modified", "additions": 153, "deletions": 2, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -36,6 +36,12 @@ extern state_t curr_state;\n /* Forward declaration.  */\n struct ready_list;\n \n+/* Type to represent status of a dependence.  A convinient short alias.  */\n+typedef HOST_WIDE_INT ds_t;\n+\n+/* Type to represent weakness of speculative dependence.  */\n+typedef int dw_t;\n+\n /* Describe state of dependencies used during sched_analyze phase.  */\n struct deps\n {\n@@ -180,6 +186,10 @@ struct sched_info\n \n   /* Maximum priority that has been assigned to an insn.  */\n   int sched_max_insns_priority;\n+\n+  /* ??? FIXME: should use straight bitfields inside sched_info instead of\n+     this flag field.  */\n+  unsigned int flags;\n };\n \n extern struct sched_info *current_sched_info;\n@@ -231,6 +241,10 @@ struct haifa_insn_data\n \n   /* Nonzero if priority has been computed already.  */\n   unsigned int priority_known : 1;\n+\n+  /* Nonzero if instruction has internal dependence\n+     (e.g. add_dependence was invoked with (insn == elem)).  */\n+  unsigned int has_internal_dep : 1;\n };\n \n extern struct haifa_insn_data *h_i_d;\n@@ -245,6 +259,137 @@ extern struct haifa_insn_data *h_i_d;\n #define INSN_PRIORITY_KNOWN(INSN) (h_i_d[INSN_UID (INSN)].priority_known)\n #define INSN_COST(INSN)\t\t(h_i_d[INSN_UID (INSN)].cost)\n #define INSN_REG_WEIGHT(INSN)\t(h_i_d[INSN_UID (INSN)].reg_weight)\n+#define HAS_INTERNAL_DEP(INSN)  (h_i_d[INSN_UID (INSN)].has_internal_dep)\n+\n+/* DEP_STATUS of the link incapsulates information, that is needed for\n+   speculative scheduling.  Namely, it is 4 integers in the range\n+   [0, MAX_DEP_WEAK] and 3 bits.\n+   The integers correspond to the probability of the dependence to *not*\n+   exist, it is the probability, that overcoming of this dependence will\n+   not be followed by execution of the recovery code.  Nevertheless,\n+   whatever high the probability of success is, recovery code should still\n+   be generated to preserve semantics of the program.  To find a way to\n+   get/set these integers, please refer to the {get, set}_dep_weak ()\n+   functions in sched-deps.c .\n+   The 3 bits in the DEP_STATUS correspond to 3 dependence types: true-,\n+   output- and anti- dependence.  It is not enough for speculative scheduling\n+   to know just the major type of all the dependence between two instructions,\n+   as only true dependence can be overcome.\n+   There also is the 4-th bit in the DEP_STATUS (HARD_DEP), that is reserved\n+   for using to describe instruction's status.  It is set whenever instuction\n+   has at least one dependence, that cannot be overcome.\n+   See also: check_dep_status () in sched-deps.c .  */\n+#define DEP_STATUS(LINK) XWINT (LINK, 2)\n+\n+/* We exclude sign bit.  */\n+#define BITS_PER_DEP_STATUS (HOST_BITS_PER_WIDE_INT - 1)\n+\n+/* First '4' stands for 3 dep type bits and HARD_DEP bit.\n+   Second '4' stands for BEGIN_{DATA, CONTROL}, BE_IN_{DATA, CONTROL}\n+   dep weakness.  */\n+#define BITS_PER_DEP_WEAK ((BITS_PER_DEP_STATUS - 4) / 4)\n+\n+/* Mask of speculative weakness in dep_status.  */\n+#define DEP_WEAK_MASK ((1 << BITS_PER_DEP_WEAK) - 1)\n+\n+/* This constant means that dependence is fake with 99.999...% probability.\n+   This is the maximum value, that can appear in dep_status.\n+   Note, that we don't want MAX_DEP_WEAK to be the same as DEP_WEAK_MASK for\n+   debugging reasons.  Though, it can be set to DEP_WEAK_MASK, and, when\n+   done so, we'll get fast (mul for)/(div by) NO_DEP_WEAK.  */\n+#define MAX_DEP_WEAK (DEP_WEAK_MASK - 1)\n+\n+/* This constant means that dependence is 99.999...% real and it is a really\n+   bad idea to overcome it (though this can be done, preserving program\n+   semantics).  */\n+#define MIN_DEP_WEAK 1\n+\n+/* This constant represents 100% probability.\n+   E.g. it is used to represent weakness of dependence, that doesn't exist.  */\n+#define NO_DEP_WEAK (MAX_DEP_WEAK + MIN_DEP_WEAK)\n+\n+/* Default weakness of speculative dependence.  Used when we can't say\n+   neither bad nor good about the dependence.  */\n+#define UNCERTAIN_DEP_WEAK (MAX_DEP_WEAK - MAX_DEP_WEAK / 4)\n+\n+/* Offset for speculative weaknesses in dep_status.  */\n+enum SPEC_TYPES_OFFSETS {\n+  BEGIN_DATA_BITS_OFFSET = 0,\n+  BE_IN_DATA_BITS_OFFSET = BEGIN_DATA_BITS_OFFSET + BITS_PER_DEP_WEAK,\n+  BEGIN_CONTROL_BITS_OFFSET = BE_IN_DATA_BITS_OFFSET + BITS_PER_DEP_WEAK,\n+  BE_IN_CONTROL_BITS_OFFSET = BEGIN_CONTROL_BITS_OFFSET + BITS_PER_DEP_WEAK\n+};\n+\n+/* The following defines provide numerous constants used to distinguish between\n+   different types of speculative dependencies.  */\n+\n+/* Dependence can be overcomed with generation of new data speculative\n+   instruction.  */\n+#define BEGIN_DATA (((ds_t) DEP_WEAK_MASK) << BEGIN_DATA_BITS_OFFSET)\n+\n+/* This dependence is to the instruction in the recovery block, that was\n+   formed to recover after data-speculation failure.\n+   Thus, this dependence can overcomed with generating of the copy of\n+   this instruction in the recovery block.  */\n+#define BE_IN_DATA (((ds_t) DEP_WEAK_MASK) << BE_IN_DATA_BITS_OFFSET)\n+\n+/* Dependence can be overcomed with generation of new control speculative\n+   instruction.  */\n+#define BEGIN_CONTROL (((ds_t) DEP_WEAK_MASK) << BEGIN_CONTROL_BITS_OFFSET)\n+\n+/* This dependence is to the instruction in the recovery block, that was\n+   formed to recover after control-speculation failure.\n+   Thus, this dependence can overcomed with generating of the copy of\n+   this instruction in the recovery block.  */\n+#define BE_IN_CONTROL (((ds_t) DEP_WEAK_MASK) << BE_IN_CONTROL_BITS_OFFSET)\n+\n+/* Few convinient combinations.  */\n+#define BEGIN_SPEC (BEGIN_DATA | BEGIN_CONTROL)\n+#define DATA_SPEC (BEGIN_DATA | BE_IN_DATA)\n+#define CONTROL_SPEC (BEGIN_CONTROL | BE_IN_CONTROL)\n+#define SPECULATIVE (DATA_SPEC | CONTROL_SPEC)\n+#define BE_IN_SPEC (BE_IN_DATA | BE_IN_CONTROL)\n+\n+/* Constants, that are helpful in iterating through dep_status.  */\n+#define FIRST_SPEC_TYPE BEGIN_DATA\n+#define LAST_SPEC_TYPE BE_IN_CONTROL\n+#define SPEC_TYPE_SHIFT BITS_PER_DEP_WEAK\n+\n+/* Dependence on instruction can be of multiple types\n+   (e.g. true and output). This fields enhance REG_NOTE_KIND information\n+   of the dependence.  */\n+#define DEP_TRUE (((ds_t) 1) << (BE_IN_CONTROL_BITS_OFFSET + BITS_PER_DEP_WEAK))\n+#define DEP_OUTPUT (DEP_TRUE << 1)\n+#define DEP_ANTI (DEP_OUTPUT << 1)\n+\n+#define DEP_TYPES (DEP_TRUE | DEP_OUTPUT | DEP_ANTI)\n+\n+/* Instruction has non-speculative dependence.  This bit represents the\n+   property of an instruction - not the one of a dependence.\n+   Therefore, it can appear only in TODO_SPEC field of an instruction.  */\n+#define HARD_DEP (DEP_ANTI << 1)\n+\n+/* This represents the results of calling sched-deps.c functions, \n+   which modify dependencies.  Possible choices are: a dependence\n+   is already present and nothing has been changed; a dependence type\n+   has been changed; brand new dependence has been created.  */\n+enum DEPS_ADJUST_RESULT {\n+  DEP_PRESENT = 1,\n+  DEP_CHANGED = 2,\n+  DEP_CREATED = 3\n+};\n+\n+/* Represents the bits that can be set in the flags field of the \n+   sched_info structure.  */\n+enum SCHED_FLAGS {\n+  /* If set, generate links between instruction as DEPS_LIST.\n+     Otherwise, generate usual INSN_LIST links.  */\n+  USE_DEPS_LIST = 1,\n+  /* Perform data or control (or both) speculation.\n+     Results in generation of data and control speculative dependencies.\n+     Requires USE_DEPS_LIST set.  */\n+  DO_SPECULATION = USE_DEPS_LIST << 1\n+};\n \n extern FILE *sched_dump;\n extern int sched_verbose;\n@@ -332,17 +477,23 @@ extern void print_insn (char *, rtx, int);\n \n /* Functions in sched-deps.c.  */\n extern bool sched_insns_conditions_mutex_p (rtx, rtx);\n-extern int add_dependence (rtx, rtx, enum reg_note);\n+extern void add_dependence (rtx, rtx, enum reg_note);\n extern void sched_analyze (struct deps *, rtx, rtx);\n extern void init_deps (struct deps *);\n extern void free_deps (struct deps *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);\n-extern void add_forward_dependence (rtx, rtx, enum reg_note);\n+extern void add_forw_dep (rtx, rtx);\n extern void compute_forward_dependences (rtx, rtx);\n extern rtx find_insn_list (rtx, rtx);\n extern void init_dependency_caches (int);\n extern void free_dependency_caches (void);\n+extern enum DEPS_ADJUST_RESULT add_or_update_back_dep (rtx, rtx, \n+\t\t\t\t\t\t       enum reg_note, ds_t);\n+extern void add_or_update_back_forw_dep (rtx, rtx, enum reg_note, ds_t);\n+extern void add_back_forw_dep (rtx, rtx, enum reg_note, ds_t);\n+extern void delete_back_forw_dep (rtx, rtx);\n+extern ds_t set_dep_weak (ds_t, ds_t, dw_t);\n \n /* Functions in haifa-sched.c.  */\n extern int haifa_classify_insn (rtx);"}, {"sha": "521d104e70517aa3943365b7173bdd5858506eed", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddbd543924d5b71c2b9d6553daff6c6f029a19c0/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "patch": "@@ -1816,7 +1816,9 @@ static struct sched_info region_sched_info =\n \n   NULL, NULL,\n   NULL, NULL,\n-  0, 0, 0\n+  0, 0, 0,\n+\n+  0\n };\n \n /* Determine if PAT sets a CLASS_LIKELY_SPILLED_P register.  */\n@@ -2512,14 +2514,18 @@ schedule_insns (void)\n \n   nr_inter = 0;\n   nr_spec = 0;\n+\n+  /* We need current_sched_info in init_dependency_caches, which is\n+     invoked via sched_init.  */\n+  current_sched_info = &region_sched_info;\n+\n   sched_init ();\n \n   min_spec_prob = ((PARAM_VALUE (PARAM_MIN_SPEC_PROB) * REG_BR_PROB_BASE)\n \t\t    / 100);\n \n   init_regions ();\n \n-  current_sched_info = &region_sched_info;\n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     schedule_region (rgn);"}]}