{"sha": "40e1ed26774b7b6c24d166489a715aa75843ab36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBlMWVkMjY3NzRiN2I2YzI0ZDE2NjQ4OWE3MTVhYTc1ODQzYWIzNg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-07-25T16:24:00Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-07-25T16:24:00Z"}, "message": "re PR fortran/65819 (overzealous checking in gfc_check_dependency for identical=true)\n\n2019-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/65819\n\t* dependency.h (gfc_dep_resovler): Add optional argument identical.\n\t* dependency.c (gfc_check_dependency): Do not alway return 1 if\n\tthe symbol is the same. Pass on identical to gfc_dep_resolver.\n\t(gfc_check_element_vs_element): Whitespace fix.\n\t(gfc_dep_resolver): Adjust comment for function.  If identical is\n\ttrue, return 1 if any overlap has been found.\n\n2019-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/65819\n\t* gfortran.dg/dependency_54.f90: New test.\n\nFrom-SVN: r273807", "tree": {"sha": "4ba8ee2131458a74b1d6ebb6bbb2493f7bceabd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ba8ee2131458a74b1d6ebb6bbb2493f7bceabd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40e1ed26774b7b6c24d166489a715aa75843ab36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e1ed26774b7b6c24d166489a715aa75843ab36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40e1ed26774b7b6c24d166489a715aa75843ab36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e1ed26774b7b6c24d166489a715aa75843ab36/comments", "author": null, "committer": null, "parents": [{"sha": "0dfa7ba12c7cbdfc177b07f990a859761dc36e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dfa7ba12c7cbdfc177b07f990a859761dc36e25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dfa7ba12c7cbdfc177b07f990a859761dc36e25"}], "stats": {"total": 90, "additions": 71, "deletions": 19}, "files": [{"sha": "faca1a0657cd19e31ddb93b485a23479e0ce24dc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=40e1ed26774b7b6c24d166489a715aa75843ab36", "patch": "@@ -1,3 +1,13 @@\n+2019-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/65819\n+\t* dependency.h (gfc_dep_resovler): Add optional argument identical.\n+\t* dependency.c (gfc_check_dependency): Do not alway return 1 if\n+\tthe symbol is the same. Pass on identical to gfc_dep_resolver.\n+\t(gfc_check_element_vs_element): Whitespace fix.\n+\t(gfc_dep_resolver): Adjust comment for function.  If identical is\n+\ttrue, return 1 if any overlap has been found.\n+\n 2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/54072\n@@ -6,7 +16,7 @@\n \t(gfc_check_transfer): Use to arguments.\n \t(gfc_check_storage_size): Ditto.\n \t(gfc_check_complex): Remove leftover comment from BOZ patch.\n-\t* primary.c (match_boz_constant): Remove leftover comment. \n+\t* primary.c (match_boz_constant): Remove leftover comment.\n \n 2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n@@ -19,7 +29,7 @@\n \t(match_complex_constant: Use convert_complex.\n \t* arith.h (gfc_convert_integer, gfc_convert_real, gfc_convert_complex):\n \tRemove prototypes.\n-\t* array.c (match_array_cons_element): A BOZ cannot be a data \n+\t* array.c (match_array_cons_element): A BOZ cannot be a data\n \tstatement value.  Jump to a common exit point.\n \t* check.c (gfc_invalid_boz): New function.  Emit error or warning\n \tfor a BOZ in an invalid context.\n@@ -32,7 +42,7 @@\n \tconstant to INTEGER in accordance to F2018.\n \t(gfc_check_achar, gfc_check_char, gfc_check_float): Use gfc_invalid_boz.  Convert BOZ\n \tas needed.\n-\t(gfc_check_bge_bgt_ble_blt): Enforce F2018 requirements on BGE, \n+\t(gfc_check_bge_bgt_ble_blt): Enforce F2018 requirements on BGE,\n \tBGT, BLE, and BLT intrinsic functions.\n \t(gfc_check_cmplx): Re-organize to check kind, if present, first.\n \tConvert BOZ real and/or imaginary parts as needed in accordance to\n@@ -41,7 +51,7 @@\n \t(gfc_check_dcmplx, gfc_check_dble ): Convert BOZ as needed.\n \t(gfc_check_dshift):  Make dshift[lr] conform to F2018 standard.\n  \tgfc_check_float (gfc_expr *a)\n-\t(gfc_check_iand_ieor_ior):  Make IAND, IEOR, and IOR conform to \n+\t(gfc_check_iand_ieor_ior):  Make IAND, IEOR, and IOR conform to\n \tF2018 standard.\n \t(gfc_check_int): Conform to F2018 standard.\n \t(gfc_check_intconv): Deprecate SHORT and LONG aliases for INT2 and\n@@ -62,7 +72,7 @@\n \tINTEGER or REAL.\n \t* gfortran.h (gfc_expr): Add a boz component.  Remove is_boz component.\n \t(gfc_boz2int, gfc_boz2real, gfc_invalid_boz): New prototypes.\n-\t* interface.c (gfc_extend_assign): Guard against replacing an \n+\t* interface.c (gfc_extend_assign): Guard against replacing an\n \tintrinsic involving a BOZ literal constant on RHS.\n \t* invoke.texi: Doument -fallow-invalid-boz.\n \t* lang.opt: New option. -fallow-invalid-boz."}, {"sha": "da4a37c9e953ccba1e4d8d8fcc8be9da37f93270", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=40e1ed26774b7b6c24d166489a715aa75843ab36", "patch": "@@ -1351,13 +1351,10 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n \t  return 0;\n \t}\n \n-      if (identical)\n-\treturn 1;\n-\n       /* Identical and disjoint ranges return 0,\n \t overlapping ranges return 1.  */\n       if (expr1->ref && expr2->ref)\n-\treturn gfc_dep_resolver (expr1->ref, expr2->ref, NULL);\n+\treturn gfc_dep_resolver (expr1->ref, expr2->ref, NULL, identical);\n \n       return 1;\n \n@@ -1884,6 +1881,7 @@ gfc_check_element_vs_element (gfc_ref *lref, gfc_ref *rref, int n)\n \n   if (i > -2)\n     return GFC_DEP_NODEP;\n+\n   return GFC_DEP_EQUAL;\n }\n \n@@ -2084,13 +2082,15 @@ ref_same_as_full_array (gfc_ref *full_ref, gfc_ref *ref)\n \n /* Finds if two array references are overlapping or not.\n    Return value\n-   \t2 : array references are overlapping but reversal of one or\n+\t2 : array references are overlapping but reversal of one or\n \t    more dimensions will clear the dependency.\n-   \t1 : array references are overlapping.\n-   \t0 : array references are identical or not overlapping.  */\n+\t1 : array references are overlapping, or identical is true and\n+\t    there is some kind of overlap.\n+\t0 : array references are identical or not overlapping.  */\n \n int\n-gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n+gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse,\n+\t\t  bool identical)\n {\n   int n;\n   int m;\n@@ -2124,11 +2124,15 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \tcase REF_ARRAY:\n \n+\t  /* For now, treat all coarrays as dangerous.  */\n+\t  if (lref->u.ar.codimen || rref->u.ar.codimen)\n+\t    return 1;\n+\n \t  if (ref_same_as_full_array (lref, rref))\n-\t    return 0;\n+\t    return identical;\n \n \t  if (ref_same_as_full_array (rref, lref))\n-\t    return 0;\n+\t    return identical;\n \n \t  if (lref->u.ar.dimen != rref->u.ar.dimen)\n \t    {\n@@ -2180,6 +2184,8 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t\t  gcc_assert (rref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n \t\t\t      && lref->u.ar.dimen_type[n] == DIMEN_ELEMENT);\n \t\t  this_dep = gfc_check_element_vs_element (rref, lref, n);\n+\t\t  if (identical && this_dep == GFC_DEP_EQUAL)\n+\t\t    this_dep = GFC_DEP_OVERLAP;\n \t\t}\n \n \t      /* If any dimension doesn't overlap, we have no dependency.  */\n@@ -2240,6 +2246,9 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t\t know the worst one.*/\n \n \t    update_fin_dep:\n+\t      if (identical && this_dep == GFC_DEP_EQUAL)\n+\t\tthis_dep = GFC_DEP_OVERLAP;\n+\n \t      if (this_dep > fin_dep)\n \t\tfin_dep = this_dep;\n \t    }\n@@ -2253,7 +2262,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \t  /* Exactly matching and forward overlapping ranges don't cause a\n \t     dependency.  */\n-\t  if (fin_dep < GFC_DEP_BACKWARD)\n+\t  if (fin_dep < GFC_DEP_BACKWARD && !identical)\n \t    return 0;\n \n \t  /* Keep checking.  We only have a dependency if\n@@ -2267,11 +2276,14 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n       rref = rref->next;\n     }\n \n+  /* Assume the worst if we nest to different depths.  */\n+  if (lref || rref)\n+    return 1;\n+\n   /* If we haven't seen any array refs then something went wrong.  */\n   gcc_assert (fin_dep != GFC_DEP_ERROR);\n \n-  /* Assume the worst if we nest to different depths.  */\n-  if (lref || rref)\n+  if (identical && fin_dep != GFC_DEP_NODEP)\n     return 1;\n \n   return fin_dep == GFC_DEP_OVERLAP;"}, {"sha": "eca60f7d8e51e7daf108a1928722f66099cf0a44", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=40e1ed26774b7b6c24d166489a715aa75843ab36", "patch": "@@ -37,7 +37,8 @@ int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n int gfc_check_dependency (gfc_expr *, gfc_expr *, bool);\n int gfc_expr_is_one (gfc_expr *, int);\n \n-int gfc_dep_resolver(gfc_ref *, gfc_ref *, gfc_reverse *);\n+int gfc_dep_resolver (gfc_ref *, gfc_ref *, gfc_reverse *,\n+\t\t      bool identical = false);\n int gfc_are_equivalenced_arrays (gfc_expr *, gfc_expr *);\n \n gfc_expr * gfc_discard_nops (gfc_expr *);"}, {"sha": "ea5d239661a824bb36cea08dd49016111bb4785a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40e1ed26774b7b6c24d166489a715aa75843ab36", "patch": "@@ -1,3 +1,8 @@\n+2019-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/65819\n+\t* gfortran.dg/dependency_54.f90: New test.\n+\n 2019-07-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/case_optimization3.ad[sb]: New test."}, {"sha": "f738ed81d6ca282ef54ac17d45c185510d991ea9", "filename": "gcc/testsuite/gfortran.dg/dependency_54.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_54.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e1ed26774b7b6c24d166489a715aa75843ab36/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_54.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_54.f90?ref=40e1ed26774b7b6c24d166489a715aa75843ab36", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do  run }\n+! { dg-additional-options \"-fdump-tree-original -ffrontend-optimize\" }\n+! PR 65819 - this used to cause a temporary in matmul inlining.\n+! Check that these are absent by looking for the names of the\n+! temporary variables.\n+program main\n+  implicit none\n+  real, dimension(3,3,3) :: f\n+  real, dimension(3,3) :: res\n+  real, dimension(2,3,3) :: backup\n+  integer :: three\n+  integer :: i\n+\n+  data f(1,:,:) /9*-42./\n+  data f(2:3,:,:) /2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61/\n+  data res /652, 772, 984, 2010, 2406, 3082, 3402, 4086, 5242/ \n+  three = 3\n+  backup = f(2:3,:,:)\n+  f(1, 1:three, :) = matmul(f(2,1:3,2:3), f(3,2:3,:))\n+  if (any (res /= f(1,:,:))) stop 1\n+  if (any (f(2:3,:,:) /= backup)) stop 2\n+end program main\n+! { dg-final { scan-tree-dump-not \"mma\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"mmb\" \"original\" } }"}]}