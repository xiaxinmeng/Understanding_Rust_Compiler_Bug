{"sha": "de6320a81695800de0f0f5fc3e4c6487a52cd430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU2MzIwYTgxNjk1ODAwZGUwZjBmNWZjM2U0YzY0ODdhNTJjZDQzMA==", "commit": {"author": {"name": "Craig Blackmore", "email": "craig.blackmore@embecosm.com", "date": "2020-05-12T21:41:08Z"}, "committer": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2020-05-12T21:43:48Z"}, "message": "RISC-V: Add shorten_memrefs pass.\n\n\tgcc/\n\t* config.gcc:  Add riscv-shorten-memrefs.o to extra_objs for riscv.\n\t* config/riscv/riscv-passes.def: New file.\n\t* config/riscv/riscv-protos.h (make_pass_shorten_memrefs): Declare.\n\t* config/riscv/riscv-shorten-memrefs.c: New file.\n\t* config/riscv/riscv.c (tree-pass.h): New include.\n\t(riscv_compressed_reg_p): New Function\n\t(riscv_compressed_lw_offset_p): Likewise.\n\t(riscv_compressed_lw_address_p): Likewise.\n\t(riscv_shorten_lw_offset): Likewise.\n\t(riscv_legitimize_address): Attempt to convert base + large_offset\n\tto compressible new_base + small_offset.\n\t(riscv_address_cost): Make anticipated compressed load/stores\n\tcheaper for code size than uncompressed load/stores.\n\t(riscv_register_priority): Move compressed register check to\n\triscv_compressed_reg_p.\n\t* config/riscv/riscv.h (C_S_BITS): Define.\n\t(CSW_MAX_OFFSET): Define.\n\t* config/riscv/riscv.opt (mshorten-memefs): New option.\n\t* config/riscv/t-riscv (riscv-shorten-memrefs.o): New rule.\n\t(PASSES_EXTRA): Add riscv-passes.def.\n\t* doc/invoke.texi: Document -mshorten-memrefs.\n\n\t* config/riscv/riscv.c (riscv_new_address_profitable_p): New function.\n\t(TARGET_NEW_ADDRESS_PROFITABLE_P): Define.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_NEW_ADDRESS_PROFITABLE_P):  New hook.\n\t* sched-deps.c (attempt_change): Use old address if it is cheaper than\n\tnew address.\n\t* target.def (new_address_profitable_p): New hook.\n\t* targhooks.c (default_new_address_profitable_p): New function.\n\t* targhooks.h (default_new_address_profitable_p): Declare.\n\n\tgcc/testsuite/\n\t* gcc.target/riscv/shorten-memrefs-1.c: New test.\n\t* gcc.target/riscv/shorten-memrefs-2.c: New test.\n\t* gcc.target/riscv/shorten-memrefs-3.c: New test.\n\t* gcc.target/riscv/shorten-memrefs-4.c: New test.\n\t* gcc.target/riscv/shorten-memrefs-5.c: New test.\n\t* gcc.target/riscv/shorten-memrefs-6.c: New test.\n\t* gcc.target/riscv/shorten-memrefs-7.c: New test.", "tree": {"sha": "f6767022ffcd8a6baaca7656b0bccbf8fc6f5735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6767022ffcd8a6baaca7656b0bccbf8fc6f5735"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de6320a81695800de0f0f5fc3e4c6487a52cd430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6320a81695800de0f0f5fc3e4c6487a52cd430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6320a81695800de0f0f5fc3e4c6487a52cd430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6320a81695800de0f0f5fc3e4c6487a52cd430/comments", "author": {"login": "craigblackmore", "id": 13001403, "node_id": "MDQ6VXNlcjEzMDAxNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/13001403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/craigblackmore", "html_url": "https://github.com/craigblackmore", "followers_url": "https://api.github.com/users/craigblackmore/followers", "following_url": "https://api.github.com/users/craigblackmore/following{/other_user}", "gists_url": "https://api.github.com/users/craigblackmore/gists{/gist_id}", "starred_url": "https://api.github.com/users/craigblackmore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/craigblackmore/subscriptions", "organizations_url": "https://api.github.com/users/craigblackmore/orgs", "repos_url": "https://api.github.com/users/craigblackmore/repos", "events_url": "https://api.github.com/users/craigblackmore/events{/privacy}", "received_events_url": "https://api.github.com/users/craigblackmore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11dd3be56b83d11465ae5d6ecd0d8096531678e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11dd3be56b83d11465ae5d6ecd0d8096531678e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11dd3be56b83d11465ae5d6ecd0d8096531678e5"}], "stats": {"total": 715, "additions": 709, "deletions": 6}, "files": [{"sha": "a360b5a975760f79d582269651c6564f85efcb90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -1,3 +1,37 @@\n+2020-05-12  Craig Blackmore  <craig.blackmore@embecosm.com>\n+\n+\t* config.gcc:  Add riscv-shorten-memrefs.o to extra_objs for riscv.\n+\t* config/riscv/riscv-passes.def: New file.\n+\t* config/riscv/riscv-protos.h (make_pass_shorten_memrefs): Declare.\n+\t* config/riscv/riscv-shorten-memrefs.c: New file.\n+\t* config/riscv/riscv.c (tree-pass.h): New include.\n+\t(riscv_compressed_reg_p): New Function\n+\t(riscv_compressed_lw_offset_p): Likewise.\n+\t(riscv_compressed_lw_address_p): Likewise.\n+\t(riscv_shorten_lw_offset): Likewise.\n+\t(riscv_legitimize_address): Attempt to convert base + large_offset\n+\tto compressible new_base + small_offset.\n+\t(riscv_address_cost): Make anticipated compressed load/stores\n+\tcheaper for code size than uncompressed load/stores.\n+\t(riscv_register_priority): Move compressed register check to\n+\triscv_compressed_reg_p.\n+\t* config/riscv/riscv.h (C_S_BITS): Define.\n+\t(CSW_MAX_OFFSET): Define.\n+\t* config/riscv/riscv.opt (mshorten-memefs): New option.\n+\t* config/riscv/t-riscv (riscv-shorten-memrefs.o): New rule.\n+\t(PASSES_EXTRA): Add riscv-passes.def.\n+\t* doc/invoke.texi: Document -mshorten-memrefs.\n+\n+\t* config/riscv/riscv.c (riscv_new_address_profitable_p): New function.\n+\t(TARGET_NEW_ADDRESS_PROFITABLE_P): Define.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (TARGET_NEW_ADDRESS_PROFITABLE_P):  New hook.\n+\t* sched-deps.c (attempt_change): Use old address if it is cheaper than\n+\tnew address.\n+\t* target.def (new_address_profitable_p): New hook.\n+\t* targhooks.c (default_new_address_profitable_p): New function.\n+\t* targhooks.h (default_new_address_profitable_p): Declare.\n+\n 2020-05-12  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/95046"}, {"sha": "f544932fc3963bfd9e527ff808b1708cb035f54f", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -526,7 +526,7 @@ pru-*-*)\n \t;;\n riscv*)\n \tcpu_type=riscv\n-\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o\"\n+\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o\"\n \td_target_objs=\"riscv-d.o\"\n \t;;\n rs6000*-*-*)"}, {"sha": "8a4ea0918db9472b4379a1fc7cf9058cf60ba26d", "filename": "gcc/config/riscv/riscv-passes.def", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-passes.def?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,20 @@\n+/* Declaration of target-specific passes for RISC-V.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+INSERT_PASS_AFTER (pass_rtl_store_motion, 1, pass_shorten_memrefs);"}, {"sha": "72280ec1c76e872a30ce1e895ac021221ed077fd", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -91,4 +91,6 @@ extern std::string riscv_arch_str ();\n \n extern bool riscv_hard_regno_rename_ok (unsigned, unsigned);\n \n+rtl_opt_pass * make_pass_shorten_memrefs (gcc::context *ctxt);\n+\n #endif /* ! GCC_RISCV_PROTOS_H */"}, {"sha": "3686005fe2eb87b7bd26dfc4ee3d64db59b6df60", "filename": "gcc/config/riscv/riscv-shorten-memrefs.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv-shorten-memrefs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv-shorten-memrefs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-shorten-memrefs.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,200 @@\n+/* Shorten memrefs pass for RISC-V.\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"backend.h\"\n+#include \"regs.h\"\n+#include \"target.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"df.h\"\n+#include \"predict.h\"\n+#include \"tree-pass.h\"\n+\n+/* Try to make more use of compressed load and store instructions by replacing\n+   a load/store at address BASE + LARGE_OFFSET with a new load/store at address\n+   NEW BASE + SMALL OFFSET.  If NEW BASE is stored in a compressed register, the\n+   load/store can be compressed.  Since creating NEW BASE incurs an overhead,\n+   the change is only attempted when BASE is referenced by at least four\n+   load/stores in the same basic block.  */\n+\n+namespace {\n+\n+const pass_data pass_data_shorten_memrefs =\n+{\n+  RTL_PASS, /* type */\n+  \"shorten_memrefs\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_shorten_memrefs : public rtl_opt_pass\n+{\n+public:\n+  pass_shorten_memrefs (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_shorten_memrefs, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return TARGET_RVC && riscv_mshorten_memrefs && optimize > 0;\n+    }\n+  virtual unsigned int execute (function *);\n+\n+private:\n+  typedef int_hash <HOST_WIDE_INT, 0> regno_hash;\n+  typedef hash_map <regno_hash, int> regno_map;\n+\n+  regno_map * analyze (basic_block bb);\n+  void transform (regno_map *m, basic_block bb);\n+  bool get_si_mem_base_reg (rtx mem, rtx *addr);\n+}; // class pass_shorten_memrefs\n+\n+bool\n+pass_shorten_memrefs::get_si_mem_base_reg (rtx mem, rtx *addr)\n+{\n+  if (!MEM_P (mem) || GET_MODE (mem) != SImode)\n+    return false;\n+  *addr = XEXP (mem, 0);\n+  return GET_CODE (*addr) == PLUS && REG_P (XEXP (*addr, 0));\n+}\n+\n+/* Count how many times each regno is referenced as base address for a memory\n+   access.  */\n+\n+pass_shorten_memrefs::regno_map *\n+pass_shorten_memrefs::analyze (basic_block bb)\n+{\n+  regno_map *m = hash_map<regno_hash, int>::create_ggc (10);\n+  rtx_insn *insn;\n+\n+  regstat_init_n_sets_and_refs ();\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (!NONJUMP_INSN_P (insn))\n+\tcontinue;\n+      rtx pat = PATTERN (insn);\n+      if (GET_CODE (pat) != SET)\n+\tcontinue;\n+      /* Analyze stores first then loads.  */\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  rtx mem = XEXP (pat, i);\n+\t  rtx addr;\n+\t  if (get_si_mem_base_reg (mem, &addr))\n+\t    {\n+\t      HOST_WIDE_INT regno = REGNO (XEXP (addr, 0));\n+\t      /* Do not count store zero as these cannot be compressed.  */\n+\t      if (i == 0)\n+\t\t{\n+\t\t  if (XEXP (pat, 1) == CONST0_RTX (GET_MODE (XEXP (pat, 1))))\n+\t\t    continue;\n+\t\t}\n+\t      if (REG_N_REFS (regno) < 4)\n+\t\tcontinue;\n+\t      m->get_or_insert (regno)++;\n+\t    }\n+\t  }\n+    }\n+  regstat_free_n_sets_and_refs ();\n+\n+  return m;\n+}\n+\n+/* Convert BASE + LARGE_OFFSET to NEW_BASE + SMALL_OFFSET for each load/store\n+   with a base reg referenced at least 4 times.  */\n+\n+void\n+pass_shorten_memrefs::transform (regno_map *m, basic_block bb)\n+{\n+  rtx_insn *insn;\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (!NONJUMP_INSN_P (insn))\n+\tcontinue;\n+      rtx pat = PATTERN (insn);\n+      if (GET_CODE (pat) != SET)\n+\tcontinue;\n+      start_sequence ();\n+      /* Transform stores first then loads.  */\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  rtx mem = XEXP (pat, i);\n+\t  rtx addr;\n+\t  if (get_si_mem_base_reg (mem, &addr))\n+\t    {\n+\t      HOST_WIDE_INT regno = REGNO (XEXP (addr, 0));\n+\t      /* Do not transform store zero as these cannot be compressed.  */\n+\t      if (i == 0)\n+\t\t{\n+\t\t  if (XEXP (pat, 1) == CONST0_RTX (GET_MODE (XEXP (pat, 1))))\n+\t\t    continue;\n+\t\t}\n+\t      if (m->get_or_insert (regno) > 3)\n+\t\t{\n+\t\t  addr\n+\t\t    = targetm.legitimize_address (addr, addr, GET_MODE (mem));\n+\t\t  XEXP (pat, i) = replace_equiv_address (mem, addr);\n+\t\t  df_insn_rescan (insn);\n+\t\t}\n+\t    }\n+\t}\n+      rtx_insn *seq = get_insns ();\n+      end_sequence ();\n+      emit_insn_before (seq, insn);\n+    }\n+}\n+\n+unsigned int\n+pass_shorten_memrefs::execute (function *fn)\n+{\n+  basic_block bb;\n+\n+  FOR_ALL_BB_FN (bb, fn)\n+  {\n+    regno_map *m;\n+    if (optimize_bb_for_speed_p (bb))\n+      continue;\n+    m = analyze (bb);\n+    transform (m, bb);\n+  }\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_shorten_memrefs (gcc::context *ctxt)\n+{\n+  return new pass_shorten_memrefs (ctxt);\n+}"}, {"sha": "e4c08d780db531c6a59e5252ec40524d3a8050d2", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 99, "deletions": 5, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"builtins.h\"\n #include \"predict.h\"\n+#include \"tree-pass.h\"\n \n /* True if X is an UNSPEC wrapper around a SYMBOL_REF or LABEL_REF.  */\n #define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n@@ -848,6 +849,52 @@ riscv_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n   return riscv_classify_address (&addr, x, mode, strict_p);\n }\n \n+/* Return true if hard reg REGNO can be used in compressed instructions.  */\n+\n+static bool\n+riscv_compressed_reg_p (int regno)\n+{\n+  /* x8-x15/f8-f15 are compressible registers.  */\n+  return (TARGET_RVC && (IN_RANGE (regno, GP_REG_FIRST + 8, GP_REG_FIRST + 15)\n+\t  || IN_RANGE (regno, FP_REG_FIRST + 8, FP_REG_FIRST + 15)));\n+}\n+\n+/* Return true if x is an unsigned 5-bit immediate scaled by 4.  */\n+\n+static bool\n+riscv_compressed_lw_offset_p (rtx x)\n+{\n+  return (CONST_INT_P (x)\n+\t  && (INTVAL (x) & 3) == 0\n+\t  && IN_RANGE (INTVAL (x), 0, CSW_MAX_OFFSET));\n+}\n+\n+/* Return true if load/store from/to address x can be compressed.  */\n+\n+static bool\n+riscv_compressed_lw_address_p (rtx x)\n+{\n+  struct riscv_address_info addr;\n+  bool result = riscv_classify_address (&addr, x, GET_MODE (x),\n+\t\t\t\t\treload_completed);\n+\n+  /* Before reload, assuming all load/stores of valid addresses get compressed\n+     gives better code size than checking if the address is reg + small_offset\n+     early on.  */\n+  if (result && !reload_completed)\n+    return true;\n+\n+  /* Return false if address is not compressed_reg + small_offset.  */\n+  if (!result\n+      || addr.type != ADDRESS_REG\n+      || (!riscv_compressed_reg_p (REGNO (addr.reg))\n+\t    && addr.reg != stack_pointer_rtx)\n+      || !riscv_compressed_lw_offset_p (addr.offset))\n+    return false;\n+\n+  return result;\n+}\n+\n /* Return the number of instructions needed to load or store a value\n    of mode MODE at address X.  Return 0 if X isn't valid for MODE.\n    Assume that multiword moves may need to be split into word moves\n@@ -1308,6 +1355,24 @@ riscv_force_address (rtx x, machine_mode mode)\n   return x;\n }\n \n+/* Modify base + offset so that offset fits within a compressed load/store insn\n+   and the excess is added to base.  */\n+\n+static rtx\n+riscv_shorten_lw_offset (rtx base, HOST_WIDE_INT offset)\n+{\n+  rtx addr, high;\n+  /* Leave OFFSET as an unsigned 5-bit offset scaled by 4 and put the excess\n+     into HIGH.  */\n+  high = GEN_INT (offset & ~CSW_MAX_OFFSET);\n+  offset &= CSW_MAX_OFFSET;\n+  if (!SMALL_OPERAND (INTVAL (high)))\n+    high = force_reg (Pmode, high);\n+  base = force_reg (Pmode, gen_rtx_PLUS (Pmode, high, base));\n+  addr = plus_constant (Pmode, base, offset);\n+  return addr;\n+}\n+\n /* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n    be legitimized in a way that the generic machinery might not expect,\n    return a new address, otherwise return NULL.  MODE is the mode of\n@@ -1326,7 +1391,7 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   if (riscv_split_symbol (NULL, x, mode, &addr, FALSE))\n     return riscv_force_address (addr, mode);\n \n-  /* Handle BASE + OFFSET using riscv_add_offset.  */\n+  /* Handle BASE + OFFSET.  */\n   if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1))\n       && INTVAL (XEXP (x, 1)) != 0)\n     {\n@@ -1335,7 +1400,14 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n       if (!riscv_valid_base_register_p (base, mode, false))\n \tbase = copy_to_mode_reg (Pmode, base);\n-      addr = riscv_add_offset (NULL, base, offset);\n+      if (optimize_function_for_size_p (cfun)\n+\t  && (strcmp (current_pass->name, \"shorten_memrefs\") == 0)\n+\t  && mode == SImode)\n+\t/* Convert BASE + LARGE_OFFSET into NEW_BASE + SMALL_OFFSET to allow\n+\t   possible compressed load/store.  */\n+\taddr = riscv_shorten_lw_offset (base, offset);\n+      else\n+\taddr = riscv_add_offset (NULL, base, offset);\n       return riscv_force_address (addr, mode);\n     }\n \n@@ -1833,6 +1905,11 @@ riscv_address_cost (rtx addr, machine_mode mode,\n \t\t    addr_space_t as ATTRIBUTE_UNUSED,\n \t\t    bool speed ATTRIBUTE_UNUSED)\n {\n+  /* When optimizing for size, make uncompressible 32-bit addresses more\n+   * expensive so that compressible 32-bit addresses are preferred.  */\n+  if (TARGET_RVC && !speed && riscv_mshorten_memrefs && mode == SImode\n+      && !riscv_compressed_lw_address_p (addr))\n+    return riscv_address_insns (addr, mode, false) + 1;\n   return riscv_address_insns (addr, mode, false);\n }\n \n@@ -4666,6 +4743,7 @@ riscv_option_override (void)\n     error (\"%<-mriscv-attribute%> RISC-V ELF attribute requires GNU as 2.32\"\n \t   \" [%<-mriscv-attribute%>]\");\n #endif\n+\n }\n \n /* Implement TARGET_CONDITIONAL_REGISTER_USAGE.  */\n@@ -4705,9 +4783,9 @@ riscv_conditional_register_usage (void)\n static int\n riscv_register_priority (int regno)\n {\n-  /* Favor x8-x15/f8-f15 to improve the odds of RVC instruction selection.  */\n-  if (TARGET_RVC && (IN_RANGE (regno, GP_REG_FIRST + 8, GP_REG_FIRST + 15)\n-\t\t     || IN_RANGE (regno, FP_REG_FIRST + 8, FP_REG_FIRST + 15)))\n+  /* Favor compressed registers to improve the odds of RVC instruction\n+     selection.  */\n+  if (riscv_compressed_reg_p (regno))\n     return 1;\n \n   return 0;\n@@ -5049,6 +5127,19 @@ riscv_hard_regno_rename_ok (unsigned from_regno ATTRIBUTE_UNUSED,\n   return !cfun->machine->interrupt_handler_p || df_regs_ever_live_p (to_regno);\n }\n \n+/* Implement TARGET_NEW_ADDRESS_PROFITABLE_P.  */\n+\n+bool\n+riscv_new_address_profitable_p (rtx memref, rtx_insn *insn, rtx new_addr)\n+{\n+  /* Prefer old address if it is less expensive.  */\n+  addr_space_t as = MEM_ADDR_SPACE (memref);\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+  int old_cost = address_cost (XEXP (memref, 0), GET_MODE (memref), as, speed);\n+  int new_cost = address_cost (new_addr, GET_MODE (memref), as, speed);\n+  return new_cost <= old_cost;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n@@ -5226,6 +5317,9 @@ riscv_hard_regno_rename_ok (unsigned from_regno ATTRIBUTE_UNUSED,\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG riscv_reorg\n \n+#undef TARGET_NEW_ADDRESS_PROFITABLE_P\n+#define TARGET_NEW_ADDRESS_PROFITABLE_P riscv_new_address_profitable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "e6209ede9d664dd92e4cdc8bc0ec42114cf06c11", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -920,6 +920,7 @@ extern unsigned riscv_stack_boundary;\n #define SHIFT_RS1 15\n #define SHIFT_IMM 20\n #define IMM_BITS 12\n+#define C_S_BITS 5\n #define C_SxSP_BITS 6\n \n #define IMM_REACH (1LL << IMM_BITS)\n@@ -929,6 +930,10 @@ extern unsigned riscv_stack_boundary;\n #define SWSP_REACH (4LL << C_SxSP_BITS)\n #define SDSP_REACH (8LL << C_SxSP_BITS)\n \n+/* This is the maximum value that can be represented in a compressed load/store\n+   offset (an unsigned 5-bit value scaled by 4).  */\n+#define CSW_MAX_OFFSET ((4LL << C_S_BITS) - 1) & ~3\n+\n /* Called from RISCV_REORG, this is defined in riscv-sr.c.  */\n \n extern void riscv_remove_unneeded_save_restore_calls (void);"}, {"sha": "e4bfcb86f51385d153c5e8d539eeaa636a7fe6a1", "filename": "gcc/config/riscv/riscv.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Friscv.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.opt?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -87,6 +87,12 @@ msave-restore\n Target Report Mask(SAVE_RESTORE)\n Use smaller but slower prologue and epilogue code.\n \n+mshorten-memrefs\n+Target Bool Var(riscv_mshorten_memrefs) Init(1)\n+Convert BASE + LARGE_OFFSET addresses to NEW_BASE + SMALL_OFFSET to allow more\n+memory accesses to be generated as compressed instructions.  Currently targets\n+32-bit integer load/stores.\n+\n mcmodel=\n Target Report RejectNegative Joined Enum(code_model) Var(riscv_cmodel) Init(TARGET_DEFAULT_CMODEL)\n Specify the code model."}, {"sha": "4820fb35d317d463bd389a218350bd54e50a0ed5", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -19,3 +19,8 @@ riscv-d.o: $(srcdir)/config/riscv/riscv-d.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+riscv-shorten-memrefs.o: $(srcdir)/config/riscv/riscv-shorten-memrefs.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n+PASSES_EXTRA += $(srcdir)/config/riscv/riscv-passes.def"}, {"sha": "850aeac033d88b473cd3a2ff794b24774f20683c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -1129,6 +1129,7 @@ See RS/6000 and PowerPC Options.\n -mpreferred-stack-boundary=@var{num} @gol\n -msmall-data-limit=@var{N-bytes} @gol\n -msave-restore  -mno-save-restore @gol\n+-mshorten-memrefs  -mno-shorten-memrefs @gol\n -mstrict-align  -mno-strict-align @gol\n -mcmodel=medlow  -mcmodel=medany @gol\n -mexplicit-relocs  -mno-explicit-relocs @gol\n@@ -25329,6 +25330,15 @@ Do or don't use smaller but slower prologue and epilogue code that uses\n library function calls.  The default is to use fast inline prologues and\n epilogues.\n \n+@item -mshorten-memrefs\n+@itemx -mno-shorten-memrefs\n+@opindex mshorten-memrefs\n+Do or do not attempt to make more use of compressed load/store instructions by\n+replacing a load/store of 'base register + large offset' with a new load/store\n+of 'new base + small offset'.  If the new base gets stored in a compressed\n+register, then the new load/store can be compressed.  Currently targets 32-bit\n+integer load/stores only.\n+\n @item -mstrict-align\n @itemx -mno-strict-align\n @opindex mstrict-align"}, {"sha": "b8d64d136e0389a38a4a2fd2f7757f0486c791ca", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -6967,6 +6967,13 @@ candidate as a replacement for the if-convertible sequence described in\n @code{if_info}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_NEW_ADDRESS_PROFITABLE_P (rtx @var{memref}, rtx_insn * @var{insn}, rtx @var{new_addr})\n+Return @code{true} if it is profitable to replace the address in\n+@var{memref} with @var{new_addr}.  This allows targets to prevent the\n+scheduler from undoing address optimizations.  The instruction containing the\n+memref is @var{insn}.  The default implementation returns @code{true}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P (void)\n This predicate controls the use of the eager delay slot filler to disallow\n speculatively executed instructions being placed in delay slots.  Targets"}, {"sha": "3be984bbd5cdacb19bcf40588ea370a7a7ccf377", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -4697,6 +4697,8 @@ Define this macro if a non-short-circuit operation produced by\n \n @hook TARGET_NOCE_CONVERSION_PROFITABLE_P\n \n+@hook TARGET_NEW_ADDRESS_PROFITABLE_P\n+\n @hook TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P\n \n @hook TARGET_ESTIMATED_POLY_VALUE"}, {"sha": "1bc75074e5d8c83c3b695f568df10d9cf6d07704", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -4694,6 +4694,9 @@ attempt_change (struct mem_inc_info *mii, rtx new_addr)\n   rtx mem = *mii->mem_loc;\n   rtx new_mem;\n \n+  if (!targetm.new_address_profitable_p (mem, mii->mem_insn, new_addr))\n+    return NULL_RTX;\n+\n   /* Jump through a lot of hoops to keep the attributes up to date.  We\n      do not want to call one of the change address variants that take\n      an offset even though we know the offset in many cases.  These"}, {"sha": "f36aebb535c63105d904b25ce7b48a2c1dc0b7b8", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -3847,6 +3847,17 @@ candidate as a replacement for the if-convertible sequence described in\\n\\\n bool, (rtx_insn *seq, struct noce_if_info *if_info),\n default_noce_conversion_profitable_p)\n \n+/* Return true if new_addr should be preferred over the existing address used by\n+   memref in insn.  */\n+DEFHOOK\n+(new_address_profitable_p,\n+ \"Return @code{true} if it is profitable to replace the address in\\n\\\n+@var{memref} with @var{new_addr}.  This allows targets to prevent the\\n\\\n+scheduler from undoing address optimizations.  The instruction containing the\\n\\\n+memref is @var{insn}.  The default implementation returns @code{true}.\",\n+bool, (rtx memref, rtx_insn * insn, rtx new_addr),\n+default_new_address_profitable_p)\n+\n DEFHOOK\n (estimated_poly_value,\n  \"Return an estimate of the runtime value of @var{val}, for use in\\n\\"}, {"sha": "e0982328d8ecfb346a8ffbb4eec012c85c74afb3", "filename": "gcc/targhooks.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -1566,6 +1566,19 @@ default_mode_dependent_address_p (const_rtx addr ATTRIBUTE_UNUSED,\n   return false;\n }\n \n+extern bool default_new_address_profitable_p (rtx, rtx);\n+\n+\n+/* The default implementation of TARGET_NEW_ADDRESS_PROFITABLE_P.  */\n+\n+bool\n+default_new_address_profitable_p (rtx memref ATTRIBUTE_UNUSED,\n+\t\t\t\t  rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t\t  rtx new_addr ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n bool\n default_target_option_valid_attribute_p (tree ARG_UNUSED (fndecl),\n \t\t\t\t\t tree ARG_UNUSED (name),"}, {"sha": "9bab77bc638d3335b5ff7f007763adc1ed23c3b7", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -186,6 +186,7 @@ extern tree default_emutls_var_init (tree, tree, tree);\n extern unsigned int default_hard_regno_nregs (unsigned int, machine_mode);\n extern bool default_hard_regno_scratch_ok (unsigned int);\n extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);\n+extern bool default_new_address_profitable_p (rtx, rtx_insn *, rtx);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);"}, {"sha": "9ad48bad03178787e3d98a77aac26fc774d73d4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -1,3 +1,13 @@\n+2020-05-12  Craig Blackmore  <craig.blackmore@embecosm.com>\n+\n+\t* gcc.target/riscv/shorten-memrefs-1.c: New test.\n+\t* gcc.target/riscv/shorten-memrefs-2.c: New test.\n+\t* gcc.target/riscv/shorten-memrefs-3.c: New test.\n+\t* gcc.target/riscv/shorten-memrefs-4.c: New test.\n+\t* gcc.target/riscv/shorten-memrefs-5.c: New test.\n+\t* gcc.target/riscv/shorten-memrefs-6.c: New test.\n+\t* gcc.target/riscv/shorten-memrefs-7.c: New test.\n+\n 2020-05-12  Nathan Sidwell  <nathan@acm.org>\n \n \tPR preprocessor/95013"}, {"sha": "958942a6f7f02178a8a24387a44bb3527a963490", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-1.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-Os -march=rv32imc -mabi=ilp32\" } */\n+\n+/* These stores cannot be compressed because x0 is not a compressed reg.\n+   Therefore the shorten_memrefs pass should not attempt to rewrite them into a\n+   compressible format.  */\n+\n+void\n+store1z (int *array)\n+{\n+  array[200] = 0;\n+  array[201] = 0;\n+  array[202] = 0;\n+  array[203] = 0;\n+}\n+\n+void\n+store2z (long long *array)\n+{\n+  array[200] = 0;\n+  array[201] = 0;\n+  array[202] = 0;\n+  array[203] = 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"store1z:\\n\\taddi\" } } */\n+/* { dg-final { scan-assembler-not \"store2z:\\n\\taddi\" } } */"}, {"sha": "2c2f41548c6188c649198814bf0f5d725df3d8d9", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-2.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-options \"-Os -march=rv32imc -mabi=ilp32\" } */\n+\n+/* shorten_memrefs should rewrite these load/stores into a compressible\n+   format.  */\n+\n+void\n+store1a (int *array, int a)\n+{\n+  array[200] = a;\n+  array[201] = a;\n+  array[202] = a;\n+  array[203] = a;\n+}\n+\n+void\n+store2a (long long *array, long long a)\n+{\n+  array[200] = a;\n+  array[201] = a;\n+  array[202] = a;\n+  array[203] = a;\n+}\n+\n+int\n+load1r (int *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return a;\n+}\n+\n+long long\n+load2r (long long *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"store1a:\\n\\taddi\" } } */\n+/* The sd insns in store2a are not rewritten because shorten_memrefs currently\n+   only optimizes lw and sw.\n+/* { dg-final { scan-assembler \"store2a:\\n\\taddi\" { xfail riscv*-*-*  } } } */\n+/* { dg-final { scan-assembler \"load1r:\\n\\taddi\" } } */\n+/* { dg-final { scan-assembler \"load2r:\\n\\taddi\" } } */"}, {"sha": "2001fe871ee1d519d924804c62377ec5f76c058d", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-3.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-options \"-Os -march=rv32imc -mabi=ilp32\" } */\n+\n+/* These loads cannot be compressed because only one compressed reg is\n+   available (since args are passed in a0-a4, that leaves a5-a7 available, of\n+   which only a5 is a compressed reg). Therefore the shorten_memrefs pass should\n+   not attempt to rewrite these loads into a compressible format. It may not\n+   be possible to avoid this because shorten_memrefs happens before reg alloc.\n+*/\n+\n+extern int sub1 (int, int, int, int, int, int, int);\n+\n+int\n+load1a (int a0, int a1, int a2, int a3, int a4, int *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return sub1 (a0, a1, a2, a3, a4, 0, a);\n+}\n+\n+extern long long sub2 (long long, long long, long long, long long, long long,\n+           long long, long long);\n+\n+long long\n+load2a (long long a0, long long a1, long long a2, long long a3, long long a4,\n+  long long *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return sub2 (a0, a1, a2, a3, a4, 0, a);\n+}\n+\n+/* { dg-final { scan-assembler-not \"load1a:\\n\\taddi\" { xfail riscv*-*-* } } } */\n+/* { dg-final { scan-assembler-not \"load2a:\\n.*addi\\[ \\t\\]*\\[at\\]\\[0-9\\],\\[at\\]\\[0-9\\],\\[0-9\\]*\" { xfail riscv*-*-*  } } } */"}, {"sha": "cd4784913e473f8613fb4dee3d758814695800bb", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-4.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-Os -march=rv64imc -mabi=lp64\" } */\n+\n+/* These stores cannot be compressed because x0 is not a compressed reg.\n+   Therefore the shorten_memrefs pass should not attempt to rewrite them into a\n+   compressible format.  */\n+\n+void\n+store1z (int *array)\n+{\n+  array[200] = 0;\n+  array[201] = 0;\n+  array[202] = 0;\n+  array[203] = 0;\n+}\n+\n+void\n+store2z (long long *array)\n+{\n+  array[200] = 0;\n+  array[201] = 0;\n+  array[202] = 0;\n+  array[203] = 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"store1z:\\n\\taddi\" } } */\n+/* { dg-final { scan-assembler-not \"store2z:\\n\\taddi\" } } */"}, {"sha": "80b3897e4da17981d5f2985fb2bd025602aa43eb", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-5.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-options \"-Os -march=rv64imc -mabi=lp64\" } */\n+\n+/* shorten_memrefs should rewrite these load/stores into a compressible\n+   format.  */\n+\n+void\n+store1a (int *array, int a)\n+{\n+  array[200] = a;\n+  array[201] = a;\n+  array[202] = a;\n+  array[203] = a;\n+}\n+\n+void\n+store2a (long long *array, long long a)\n+{\n+  array[200] = a;\n+  array[201] = a;\n+  array[202] = a;\n+  array[203] = a;\n+}\n+\n+int\n+load1r (int *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return a;\n+}\n+\n+long long\n+load2r (long long *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler \"store1a:\\n\\taddi\" } } */\n+/* The sd insns in store2a are not rewritten because shorten_memrefs currently\n+   only optimizes lw and sw.\n+/* { dg-final { scan-assembler \"store2a:\\n\\taddi\" { xfail riscv*-*-* } } } */\n+/* { dg-final { scan-assembler \"load1r:\\n\\taddi\" } } */\n+/* The ld insns in load2r are not rewritten because shorten_memrefs currently\n+   only optimizes lw and sw.\n+/* { dg-final { scan-assembler \"load2r:\\n\\taddi\" { xfail riscv*-*-* } } } */"}, {"sha": "3403c7044df059b8637f9f6a3b92c493a374b057", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-6.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-6.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-options \"-Os -march=rv64imc -mabi=lp64\" } */\n+\n+/* These loads cannot be compressed because only one compressed reg is\n+   available (since args are passed in a0-a4, that leaves a5-a7 available, of\n+   which only a5 is a compressed reg). Therefore the shorten_memrefs pass should\n+   not attempt to rewrite these loads into a compressible format. It may not\n+   be possible to avoid this because shorten_memrefs happens before reg alloc.\n+*/\n+\n+extern int sub1 (int, int, int, int, int, int, int);\n+\n+int\n+load1a (int a0, int a1, int a2, int a3, int a4, int *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return sub1 (a0, a1, a2, a3, a4, 0, a);\n+}\n+\n+extern long long sub2 (long long, long long, long long, long long, long long,\n+           long long, long long);\n+\n+long long\n+load2a (long long a0, long long a1, long long a2, long long a3, long long a4,\n+  long long *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return sub2 (a0, a1, a2, a3, a4, 0, a);\n+}\n+\n+/* { dg-final { scan-assembler-not \"load1a:\\n\\taddi\" { xfail riscv*-*-* } } } */\n+/* { dg-final { scan-assembler-not \"load2a:\\n.*addi\\[ \\t\\]*\\[at\\]\\[0-9\\],\\[at\\]\\[0-9\\],\\[0-9\\]*\" } } */"}, {"sha": "a5833fd356d8ab841ee8933a48025e53c412c961", "filename": "gcc/testsuite/gcc.target/riscv/shorten-memrefs-7.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6320a81695800de0f0f5fc3e4c6487a52cd430/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshorten-memrefs-7.c?ref=de6320a81695800de0f0f5fc3e4c6487a52cd430", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-options \"-Os -march=rv32imc -mabi=ilp32 -mno-shorten-memrefs\" } */\n+\n+/* Check that these load/stores do not get rewritten into a compressible format\n+   when shorten_memrefs is disabled.  */\n+\n+void\n+store1a (int *array, int a)\n+{\n+  array[200] = a;\n+  array[201] = a;\n+  array[202] = a;\n+  array[203] = a;\n+}\n+\n+void\n+store2a (long long *array, long long a)\n+{\n+  array[200] = a;\n+  array[201] = a;\n+  array[202] = a;\n+  array[203] = a;\n+}\n+\n+int\n+load1r (int *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return a;\n+}\n+\n+long long\n+load2r (long long *array)\n+{\n+  int a = 0;\n+  a += array[200];\n+  a += array[201];\n+  a += array[202];\n+  a += array[203];\n+  return a;\n+}\n+\n+/* { dg-final { scan-assembler-not \"addi\" } } */"}]}