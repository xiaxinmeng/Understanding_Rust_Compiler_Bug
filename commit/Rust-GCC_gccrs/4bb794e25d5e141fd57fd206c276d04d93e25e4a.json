{"sha": "4bb794e25d5e141fd57fd206c276d04d93e25e4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiNzk0ZTI1ZDVlMTQxZmQ1N2ZkMjA2YzI3NmQwNGQ5M2UyNWU0YQ==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2015-06-04T21:14:10Z"}, "committer": {"name": "Sriraman Tallam", "email": "tmsriram@gcc.gnu.org", "date": "2015-06-04T21:14:10Z"}, "message": "c-common.c (noplt): New attribute.\n\n2015-06-04  Sriraman Tallam  <tmsriram@google.com>\n\n\t* c-family/c-common.c (noplt): New attribute.\n\t(handle_noplt_attribute): New handler.\n\t* calls.c (prepare_call_address): Check for noplt\n\tattribute.\n\t* config/i386/i386.c (ix86_expand_call): Check\n\tfor noplt attribute.\n\t(ix86_nopic_noplt_attribute_p): New function.\n\t(ix86_output_call_insn): Output indirect call for non-pic\n\tno plt calls.\n\t* doc/extend.texi (noplt): Document new attribute.\n\t* doc/invoke.texi: Document new attribute.\n\t* testsuite/gcc.target/i386/noplt-1.c: New test.\n\t* testsuite/gcc.target/i386/noplt-2.c: New test.\n\t* testsuite/gcc.target/i386/noplt-3.c: New test.\n\t* testsuite/gcc.target/i386/noplt-4.c: New test.\n\nThis patch does two things:\n\n* Adds new generic function attribute \"noplt\" that is similar in functionality\n  to -fno-plt except that it applies only to calls to functions that are marked\n  with this attribute.\n* For x86_64, it makes -fno-plt(and the attribute) also work for non-PIC code by\n  directly generating an indirect call via a GOT entry.\n\nFrom-SVN: r224138", "tree": {"sha": "6b25a7412ce088321aa5a46c7d80ebb9b7e8b619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b25a7412ce088321aa5a46c7d80ebb9b7e8b619"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bb794e25d5e141fd57fd206c276d04d93e25e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb794e25d5e141fd57fd206c276d04d93e25e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb794e25d5e141fd57fd206c276d04d93e25e4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb794e25d5e141fd57fd206c276d04d93e25e4a/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "172f0ce5ab5fa74a5695cf855c9ba7c4e98c754a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/172f0ce5ab5fa74a5695cf855c9ba7c4e98c754a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/172f0ce5ab5fa74a5695cf855c9ba7c4e98c754a"}], "stats": {"total": 180, "additions": 175, "deletions": 5}, "files": [{"sha": "2ad6068e15fc1b3845b8439b8c5fdcfcdcc13381", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -1,3 +1,17 @@\n+2015-06-04  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* c-family/c-common.c (noplt): New attribute.\n+\t(handle_noplt_attribute): New handler.\n+\t* calls.c (prepare_call_address): Check for noplt\n+\tattribute.\n+\t* config/i386/i386.c (ix86_expand_call): Check\n+\tfor noplt attribute.\n+\t(ix86_nopic_noplt_attribute_p): New function.\n+\t(ix86_output_call_insn): Output indirect call for non-pic\n+\tno plt calls.\n+\t* doc/extend.texi (noplt): Document new attribute.\n+\t* doc/invoke.texi: Document new attribute.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* coretypes.h: Include machmode.h, signop.h, wide-int.h, double-int.h,"}, {"sha": "6f4393b7748a3c0cea00ec8473e4c95a01f42382", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -356,6 +356,7 @@ static tree handle_mode_attribute (tree *, tree, tree, int, bool *);\n static tree handle_section_attribute (tree *, tree, tree, int, bool *);\n static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n+static tree handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_alias_ifunc_attribute (bool, tree *, tree, tree, bool *);\n static tree handle_ifunc_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alias_attribute (tree *, tree, tree, int, bool *);\n@@ -705,6 +706,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_aligned_attribute, false },\n   { \"weak\",                   0, 0, true,  false, false,\n \t\t\t      handle_weak_attribute, false },\n+  { \"noplt\",                   0, 0, true,  false, false,\n+\t\t\t      handle_noplt_attribute, false },\n   { \"ifunc\",                  1, 1, true,  false, false,\n \t\t\t      handle_ifunc_attribute, false },\n   { \"alias\",                  1, 1, true,  false, false,\n@@ -8184,6 +8187,25 @@ handle_weak_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"noplt\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noplt_attribute (tree *node, tree name,\n+\t\t       tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags),\n+\t\t       bool * ARG_UNUSED (no_add_attrs))\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute is only applicable on functions\", name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Handle an \"alias\" or \"ifunc\" attribute; arguments as in\n    struct attribute_spec.handler, except that IS_ALIAS tells us\n    whether this is an alias as opposed to ifunc attribute.  */"}, {"sha": "330f65a38277eb266796b2fbdb2eefa676ea599d", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -221,10 +221,16 @@ prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n \t       && targetm.small_register_classes_for_mode_p (FUNCTION_MODE))\n \t      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n \t      : memory_address (FUNCTION_MODE, funexp));\n-  else if (flag_pic && !flag_plt && fndecl_or_type\n+  else if (flag_pic\n+\t   && fndecl_or_type\n \t   && TREE_CODE (fndecl_or_type) == FUNCTION_DECL\n+\t   && (!flag_plt\n+\t       || lookup_attribute (\"noplt\", DECL_ATTRIBUTES (fndecl_or_type)))\n \t   && !targetm.binds_local_p (fndecl_or_type))\n     {\n+      /* This is done only for PIC code.  There is no easy interface to force the\n+\t function address into GOT for non-PIC case.  non-PIC case needs to be\n+\t handled specially by the backend.  */\n       funexp = force_reg (Pmode, funexp);\n     }\n   else if (! sibcallp)"}, {"sha": "153dd85babf1122b0f86685ed406cb77f511e0a0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -25495,13 +25495,19 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n     }\n   else\n     {\n-      /* Static functions and indirect calls don't need the pic register.  */\n+      /* Static functions and indirect calls don't need the pic register.  Also,\n+\t check if PLT was explicitly avoided via no-plt or \"noplt\" attribute, making\n+\t it an indirect call.  */\n       if (flag_pic\n \t  && (!TARGET_64BIT\n \t      || (ix86_cmodel == CM_LARGE_PIC\n \t\t  && DEFAULT_ABI != MS_ABI))\n \t  && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n-\t  && ! SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n+\t  && !SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0))\n+\t  && flag_plt\n+\t  && (SYMBOL_REF_DECL ((XEXP (fnaddr, 0))) == NULL_TREE\n+\t      || !lookup_attribute (\"noplt\",\n+\t\t     DECL_ATTRIBUTES (SYMBOL_REF_DECL (XEXP (fnaddr, 0))))))\n \t{\n \t  use_reg (&use, gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM));\n \t  if (ix86_use_pseudo_pic_reg ())\n@@ -25597,6 +25603,31 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   return call;\n }\n \n+/* Return true if the function being called was marked with attribute \"noplt\"\n+   or using -fno-plt and we are compiling for non-PIC and x86_64.  We need to\n+   handle the non-PIC case in the backend because there is no easy interface\n+   for the front-end to force non-PLT calls to use the GOT.  This is currently\n+   used only with 64-bit ELF targets to call the function marked \"noplt\"\n+   indirectly.  */\n+\n+static bool\n+ix86_nopic_noplt_attribute_p (rtx call_op)\n+{\n+  if (flag_pic || ix86_cmodel == CM_LARGE\n+      || !TARGET_64BIT || TARGET_MACHO || TARGET_SEH || TARGET_PECOFF\n+      || SYMBOL_REF_LOCAL_P (call_op))\n+    return false;\n+\n+  tree symbol_decl = SYMBOL_REF_DECL (call_op);\n+\n+  if (!flag_plt\n+      || (symbol_decl != NULL_TREE\n+          && lookup_attribute (\"noplt\", DECL_ATTRIBUTES (symbol_decl))))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Output the assembly for a call instruction.  */\n \n const char *\n@@ -25608,7 +25639,9 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)\n \n   if (SIBLING_CALL_P (insn))\n     {\n-      if (direct_p)\n+      if (direct_p && ix86_nopic_noplt_attribute_p (call_op))\n+\txasm = \"%!jmp\\t*%p0@GOTPCREL(%%rip)\";\n+      else if (direct_p)\n \txasm = \"%!jmp\\t%P0\";\n       /* SEH epilogue detection requires the indirect branch case\n \t to include REX.W.  */\n@@ -25651,7 +25684,9 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)\n \tseh_nop_p = true;\n     }\n \n-  if (direct_p)\n+  if (direct_p && ix86_nopic_noplt_attribute_p (call_op))\n+    xasm = \"%!call\\t*%p0@GOTPCREL(%%rip)\";\n+  else if (direct_p)\n     xasm = \"%!call\\t%P0\";\n   else\n     xasm = \"%!call\\t%A0\";"}, {"sha": "ecdd3c8023f3fd1c35754f82d9696733bbd9f100", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -2916,6 +2916,35 @@ the standard C library can be guaranteed not to throw an exception\n with the notable exceptions of @code{qsort} and @code{bsearch} that\n take function pointer arguments.\n \n+@item noplt\n+@cindex @code{noplt} function attribute\n+The @code{noplt} attribute is the counterpart to option @option{-fno-plt} and\n+does not use PLT for calls to functions marked with this attribute in position\n+independent code. \n+\n+@smallexample\n+@group\n+/* Externally defined function foo.  */\n+int foo () __attribute__ ((noplt));\n+\n+int\n+main (/* @r{@dots{}} */)\n+@{\n+  /* @r{@dots{}} */\n+  foo ();\n+  /* @r{@dots{}} */\n+@}\n+@end group\n+@end smallexample\n+\n+The @code{noplt} attribute on function foo tells the compiler to assume that\n+the function foo is externally defined and the call to foo must avoid the PLT\n+in position independent code.\n+\n+Additionally, a few targets also convert calls to those functions that are\n+marked to not use the PLT to use the GOT instead for non-position independent\n+code.\n+\n @item optimize\n @cindex @code{optimize} function attribute\n The @code{optimize} attribute is used to specify that a function is to"}, {"sha": "a954d49cf97e582a172d3f2912692242d3c87b80", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -23872,6 +23872,14 @@ PLT stubs expect GOT pointer in a specific register, this gives more\n register allocation freedom to the compiler.  Lazy binding requires PLT:\n with @option{-fno-plt} all external symbols are resolved at load time.\n \n+Alternatively, function attribute @code{noplt} can be used to avoid PLT\n+for calls to specific external functions by marking those functions with\n+this attribute.\n+\n+Additionally, a few targets also convert calls to those functions that are\n+marked to not use the PLT to use the GOT instead for non-position independent\n+code.\n+\n @item -fno-jump-tables\n @opindex fno-jump-tables\n Do not use jump tables for switch statements even where it would be"}, {"sha": "5bd68ee33d09c6ea7c678dbdbb0253fb38a086f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -1,3 +1,10 @@\n+2015-06-04  Sriraman Tallam  <tmsriram@google.com>\n+\t\n+\t* testsuite/gcc.target/i386/noplt-1.c: New test.\n+\t* testsuite/gcc.target/i386/noplt-2.c: New test.\n+\t* testsuite/gcc.target/i386/noplt-3.c: New test.\n+\t* testsuite/gcc.target/i386/noplt-4.c: New test.\n+\n 2015-06-04  Thomas Koenig  <tkoenig@netcologne.de>\n \n \tPR fortran/58749"}, {"sha": "d9e5d6ea7cac812f072d5bde8bf34e748b2b907f", "filename": "gcc/testsuite/gcc.target/i386/noplt-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-1.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target x86_64-*-linux* } } */\n+/* { dg-options \"-fno-pic\" } */\n+\n+__attribute__ ((noplt))\n+void foo();\n+\n+int main()\n+{\n+  foo();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]\\\\*.*foo.*@GOTPCREL\\\\(%rip\\\\)\" } } */ "}, {"sha": "4df0618b6799dc6be9aab8c00c087a5eeb988689", "filename": "gcc/testsuite/gcc.target/i386/noplt-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-2.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target x86_64-*-linux* } } */\n+/* { dg-options \"-O2 -fno-pic\" } */\n+\n+\n+__attribute__ ((noplt))\n+int foo();\n+\n+int main()\n+{\n+  return foo();\n+}\n+\n+/* { dg-final { scan-assembler \"jmp\\[ \\t\\]\\\\*.*foo.*@GOTPCREL\\\\(%rip\\\\)\" } } */ "}, {"sha": "e2a6f9386499975cb54c726b3f8244324816c744", "filename": "gcc/testsuite/gcc.target/i386/noplt-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-3.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target x86_64-*-linux* } } */\n+/* { dg-options \"-fno-pic -fno-plt\" } */\n+\n+void foo();\n+\n+int main()\n+{\n+  foo();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]\\\\*.*foo.*@GOTPCREL\\\\(%rip\\\\)\" } } */ "}, {"sha": "d9039dd77c1f287fd0be3d3d9b94519805a7c537", "filename": "gcc/testsuite/gcc.target/i386/noplt-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb794e25d5e141fd57fd206c276d04d93e25e4a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fnoplt-4.c?ref=4bb794e25d5e141fd57fd206c276d04d93e25e4a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target x86_64-*-linux* } } */\n+/* { dg-options \"-O2 -fno-pic -fno-plt\" } */\n+\n+int foo();\n+\n+int main()\n+{\n+  return foo();\n+}\n+\n+/* { dg-final { scan-assembler \"jmp\\[ \\t\\]\\\\*.*foo.*@GOTPCREL\\\\(%rip\\\\)\" } } */"}]}