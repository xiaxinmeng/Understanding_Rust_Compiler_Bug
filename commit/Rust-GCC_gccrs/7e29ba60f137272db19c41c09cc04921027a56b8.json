{"sha": "7e29ba60f137272db19c41c09cc04921027a56b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyOWJhNjBmMTM3MjcyZGIxOWM0MWMwOWNjMDQ5MjEwMjdhNTZiOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-04T14:11:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-04T14:11:30Z"}, "message": "re PR middle-end/49806 (FAIL: gcc.dg/tree-ssa/vrp47.c)\n\n2011-08-04  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/49806\n\t* tree-vrp.c (op_with_boolean_value_range_p): New function.\n\t(simplify_truth_ops_using_ranges): Simplify.  Allow inserting\n\ta new statement for a final conversion to bool.\n\nFrom-SVN: r177392", "tree": {"sha": "fe11f322a9e6a69500c3e06d19b3c7e750d95de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe11f322a9e6a69500c3e06d19b3c7e750d95de4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e29ba60f137272db19c41c09cc04921027a56b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e29ba60f137272db19c41c09cc04921027a56b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e29ba60f137272db19c41c09cc04921027a56b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e29ba60f137272db19c41c09cc04921027a56b8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24558db881d2789475da76d93a4e1369502ab867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24558db881d2789475da76d93a4e1369502ab867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24558db881d2789475da76d93a4e1369502ab867"}], "stats": {"total": 158, "additions": 68, "deletions": 90}, "files": [{"sha": "773df850ca1c82b2e9e26cafd5525bdd1635120b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e29ba60f137272db19c41c09cc04921027a56b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e29ba60f137272db19c41c09cc04921027a56b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e29ba60f137272db19c41c09cc04921027a56b8", "patch": "@@ -1,3 +1,10 @@\n+2011-08-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/49806\n+\t* tree-vrp.c (op_with_boolean_value_range_p): New function.\n+\t(simplify_truth_ops_using_ranges): Simplify.  Allow inserting\n+\ta new statement for a final conversion to bool.\n+\n 2011-08-04  Romain Geissler  <romain.geissler@gmail.com>\n \n \t* gengtype-state.c: Include \"bconfig.h\" if"}, {"sha": "5aa942be611b2c57d2f6e04608825394b3a10400", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 61, "deletions": 90, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e29ba60f137272db19c41c09cc04921027a56b8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e29ba60f137272db19c41c09cc04921027a56b8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7e29ba60f137272db19c41c09cc04921027a56b8", "patch": "@@ -1454,6 +1454,28 @@ op_with_constant_singleton_value_range (tree op)\n   return NULL_TREE;\n }\n \n+/* Return true if op is in a boolean [0, 1] value-range.  */\n+\n+static bool\n+op_with_boolean_value_range_p (tree op)\n+{\n+  value_range_t *vr;\n+\n+  if (TYPE_PRECISION (TREE_TYPE (op)) == 1)\n+    return true;\n+\n+  if (integer_zerop (op)\n+      || integer_onep (op))\n+    return true;\n+\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return false;\n+\n+  vr = get_value_range (op);\n+  return (vr->type == VR_RANGE\n+\t  && integer_zerop (vr->min)\n+\t  && integer_onep (vr->max));\n+}\n \n /* Extract value range information from an ASSERT_EXPR EXPR and store\n    it in *VR_P.  */\n@@ -6753,115 +6775,64 @@ static bool\n simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n-  tree val = NULL;\n-  tree op0, op1;\n-  value_range_t *vr;\n-  bool sop = false;\n+  tree lhs, op0, op1;\n   bool need_conversion;\n \n   /* We handle only !=/== case here.  */\n   gcc_assert (rhs_code == EQ_EXPR || rhs_code == NE_EXPR);\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (TYPE_PRECISION (TREE_TYPE (op0)) != 1)\n-    {\n-      if (TREE_CODE (op0) != SSA_NAME)\n-\treturn false;\n-      vr = get_value_range (op0);\n-\n-      val = compare_range_with_value (GE_EXPR, vr, integer_zero_node, &sop);\n-      if (!val || !integer_onep (val))\n-        return false;\n-\n-      val = compare_range_with_value (LE_EXPR, vr, integer_one_node, &sop);\n-      if (!val || !integer_onep (val))\n-        return false;\n-    }\n+  if (!op_with_boolean_value_range_p (op0))\n+    return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n+  if (!op_with_boolean_value_range_p (op1))\n+    return false;\n \n-  /* Reduce number of cases to handle.  */\n-  if (is_gimple_min_invariant (op1))\n-    {\n-      if (!integer_zerop (op1)\n-\t  && !integer_onep (op1)\n-\t  && !integer_all_onesp (op1))\n-\treturn false;\n-\n-      /* Limit the number of cases we have to consider.  */\n-      if (rhs_code == EQ_EXPR)\n-\t{\n-\t  rhs_code = NE_EXPR;\n-\t  /* OP1 is a constant.  */\n-\t  op1 = fold_unary (TRUTH_NOT_EXPR, TREE_TYPE (op1), op1);\n-\t}\n-    }\n-  else\n-    {\n-      /* Punt on A == B as there is no BIT_XNOR_EXPR.  */\n-      if (rhs_code == EQ_EXPR)\n-\treturn false;\n-\n-      if (TYPE_PRECISION (TREE_TYPE (op1)) != 1)\n-\t{\n-\t  vr = get_value_range (op1);\n-\t  val = compare_range_with_value (GE_EXPR, vr, integer_zero_node, &sop);\n-\t  if (!val || !integer_onep (val))\n-\t    return false;\n-\n-\t  val = compare_range_with_value (LE_EXPR, vr, integer_one_node, &sop);\n-\t  if (!val || !integer_onep (val))\n-\t    return false;\n-\t}\n-    }\n-\n-  if (sop && issue_strict_overflow_warning (WARN_STRICT_OVERFLOW_MISC))\n+  /* Reduce number of cases to handle to NE_EXPR.  As there is no\n+     BIT_XNOR_EXPR we cannot replace A == B with a single statement.  */\n+  if (rhs_code == EQ_EXPR)\n     {\n-      location_t location;\n-\n-      if (!gimple_has_location (stmt))\n-\tlocation = input_location;\n+      if (TREE_CODE (op1) == INTEGER_CST)\n+\top1 = int_const_binop (BIT_XOR_EXPR, op1, integer_one_node);\n       else\n-\tlocation = gimple_location (stmt);\n-\n-      warning_at (location, OPT_Wstrict_overflow,\n-\t\t  _(\"assuming signed overflow does not occur when \"\n-\t\t    \"simplifying ==, != or ! to identity or ^\"));\n+\treturn false;\n     }\n \n-  need_conversion =\n-    !useless_type_conversion_p (TREE_TYPE (gimple_assign_lhs (stmt)),\n-\t\t\t        TREE_TYPE (op0));\n+  lhs = gimple_assign_lhs (stmt);\n+  need_conversion\n+    = !useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (op0));\n \n-  /* Make sure to not sign-extend -1 as a boolean value.  */\n+  /* Make sure to not sign-extend a 1-bit 1 when converting the result.  */\n   if (need_conversion\n       && !TYPE_UNSIGNED (TREE_TYPE (op0))\n-      && TYPE_PRECISION (TREE_TYPE (op0)) == 1)\n+      && TYPE_PRECISION (TREE_TYPE (op0)) == 1\n+      && TYPE_PRECISION (TREE_TYPE (lhs)) > 1)\n     return false;\n \n-  switch (rhs_code)\n-    {\n-    case NE_EXPR:\n-      if (integer_zerop (op1))\n-\t{\n-\t  gimple_assign_set_rhs_with_ops (gsi,\n-\t\t\t\t\t  need_conversion ? NOP_EXPR : SSA_NAME,\n-\t\t\t\t\t  op0, NULL);\n-\t  update_stmt (gsi_stmt (*gsi));\n-\t  return true;\n-\t}\n-\n-      rhs_code = BIT_XOR_EXPR;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (need_conversion)\n-    return false;\n-\n-  gimple_assign_set_rhs_with_ops (gsi, rhs_code, op0, op1);\n+  /* For A != 0 we can substitute A itself.  */\n+  if (integer_zerop (op1))\n+    gimple_assign_set_rhs_with_ops (gsi,\n+\t\t\t\t    need_conversion\n+\t\t\t\t    ? NOP_EXPR : TREE_CODE (op0),\n+\t\t\t\t    op0, NULL_TREE);\n+  /* For A != B we substitute A ^ B.  Either with conversion.  */\n+  else if (need_conversion)\n+    {\n+      gimple newop;\n+      tree tem = create_tmp_reg (TREE_TYPE (op0), NULL);\n+      newop = gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n+      tem = make_ssa_name (tem, newop);\n+      gimple_assign_set_lhs (newop, tem);\n+      gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n+      update_stmt (newop);\n+      gimple_assign_set_rhs_with_ops (gsi, NOP_EXPR, tem, NULL_TREE);\n+    }\n+  /* Or without.  */\n+  else\n+    gimple_assign_set_rhs_with_ops (gsi, BIT_XOR_EXPR, op0, op1);\n   update_stmt (gsi_stmt (*gsi));\n+\n   return true;\n }\n "}]}