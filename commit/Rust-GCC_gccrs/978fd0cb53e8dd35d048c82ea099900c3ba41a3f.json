{"sha": "978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4ZmQwY2I1M2U4ZGQzNWQwNDhjODJlYTA5OTkwMGMzYmE0MWEzZg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-02-03T10:30:26Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-02-03T10:30:26Z"}, "message": "Fix blkarg.c test to fail even on alpha.\n\nMake blkarg.c an expected failure.\nFix driver.c to use exit()/abort().\n\nFrom-SVN: r25002", "tree": {"sha": "1fc95e26a5c16266cc7d0965ffc104c232793b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fc95e26a5c16266cc7d0965ffc104c232793b7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/comments", "author": null, "committer": null, "parents": [{"sha": "545954c9d3339ad0c85a92a4a7b201b109f28b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545954c9d3339ad0c85a92a4a7b201b109f28b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/545954c9d3339ad0c85a92a4a7b201b109f28b2f"}], "stats": {"total": 115, "additions": 83, "deletions": 32}, "files": [{"sha": "736b565c1e1e0ac44c723b07183c8ae491e054af", "filename": "gcc/testsuite/gcc.c-torture/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog?ref=978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "patch": "@@ -1,3 +1,16 @@\n+1999-02-03  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* execute/memcheck/blkarg.c (foo): Use 10 leading arguments in\n+\torder to force structure S onto the stack even on the alpha.\n+\t(test): Pass 10 leading arguments to function foo as well as the\n+\tstructure S.\n+\n+\t* execute/memcheck/blkarg.x: New file: Expected failure for all\n+\ttargets. \n+\n+\t* execute/memcheck/driver.c (main): Use exit or abort to terminate\n+\tprogram execution.\n+\n 1999-01-28  Michael Meissner  <meissner@cygnus.com>\n \n \t* execute/990128-1.c: New test."}, {"sha": "4f448d661d6709feecca9927a6fc4ae82fb476b3", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.c?ref=978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "patch": "@@ -23,41 +23,52 @@\n int expect_error = 0;\n \n /* Must be BLKmode.  Using only two fields gets TImode on Alpha.  */\n-struct S {\n+struct S\n+{\n   unsigned long long ll;\n-  long xx, yy;\n+  long               xx;\n+  long               yy;\n };\n \n-unsigned long long x = 0x12345689ULL;\n-#define I2\t42\n-\n-/* Leading six arguments force X into stack on both Alpha and MIPS.  */\n+unsigned long long   x = 0x12345689ULL;\n+#define I2\t     42\n \n static int first_time = 1;\n-int foo (int a1, int a2, int a3, int a4, int a5, int a6, struct S s) {\n-  if (a1 != 1 || a2 != 2 || a3 != 3 || a4 != 4 || a5 != 5 || a6 != 6)\n+\n+/* Leading ten arguments force struct S onto the stack on both Alpha and MIPS.  */\n+int\n+foo (int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10,\n+     struct S s)\n+{\n+  if (a1 != 1 || a2 != 2 || a3 != 3 || a4 != 4 || a5 != 5 || a6 != 6 || a7 != 7\n+      || a8 != 8 || a9 !=9 || a10 != 10)\n     abort ();\n+  \n   if (first_time)\n     {\n       if (s.ll != x || s.xx != I2 || s.yy != 0)\n \tabort ();\n+      \n       first_time = 0;\n     }\n   else\n     {\n       if (s.ll != 0 || s.xx != 0 || s.yy != 0)\n \tabort ();\n     }\n+  \n   return 0;\n }\n \n-void test ()\n+void\n+test ()\n {\n-  foo (1, 2, 3, 4, 5, 6, (struct S) { x, I2 });\n-  foo (1, 2, 3, 4, 5, 6, (struct S) { 0 });\n+  foo (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, (struct S) { x, I2 });\n+  foo (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, (struct S) { 0 });\n }\n \n-void setup () /* NOCHECK */\n+void\n+setup () /* NOCHECK */\n {\n   mark_region (&x, sizeof (x), ACCESS_RO);\n   mark_region (&first_time, sizeof (first_time), ACCESS_RW);"}, {"sha": "52b53fe2163851d519e6686258aaa7e5899f1846", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.x", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.x?ref=978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "patch": "@@ -0,0 +1,9 @@\n+# The memeory checking code does not mark the stack as readable or writable\n+# so this test fails.  Ideally the memory checking library ought to \n+# cooperate with the host OS to mark the stack as it is used or individual\n+# function prologues and epilogues ought to mark their pieces of stack as \n+# writable and readable-after-written.\n+\n+set torture_execute_xfail \"*-*-*\"\n+\n+return 0"}, {"sha": "1da22e7a22228e72e34e9c779a2db557e99f9bca", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/driver.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/978fd0cb53e8dd35d048c82ea099900c3ba41a3f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.c?ref=978fd0cb53e8dd35d048c82ea099900c3ba41a3f", "patch": "@@ -9,7 +9,8 @@ int verbose = 0;\n int debug = 0;\n int bad_accesses = 0;\n \n-const char *const memory_use_strings[] = {\n+const char *const memory_use_strings[] =\n+{\n #define INIT(x)\t\t[x] = #x\n   INIT (MEMORY_USE_BAD),\n   INIT (MEMORY_USE_DONT),\n@@ -23,10 +24,12 @@ const char *const memory_use_strings[] = {\n /* This won't be used for any really huge test cases, so a simple\n    linked list is adequate.  We won't even worry about overlapping\n    regions; the matching entry that comes up first wins.  */\n-const char *const access_mode_strings[] = {\n+const char *const access_mode_strings[] =\n+{\n   \"none\", \"ro\", \"wo\", \"rw\",\n };\n-struct access_node {\n+struct access_node\n+{\n   struct access_node *next;\n   const void *addr;\n   size_t sz;\n@@ -35,7 +38,8 @@ struct access_node {\n \n static struct access_node *access_list;\n \n-void mark_region (const void *addr, size_t sz, enum access_mode mode)\n+void\n+mark_region (const void *addr, size_t sz, enum access_mode mode)\n {\n   struct access_node *a;\n   if (debug)\n@@ -50,7 +54,8 @@ void mark_region (const void *addr, size_t sz, enum access_mode mode)\n }\n \n void report_bad_access (void *, size_t, enum memory_use_mode) NOCHECK;\n-void report_bad_access (void *addr, size_t sz, enum memory_use_mode mode)\n+void\n+report_bad_access (void *addr, size_t sz, enum memory_use_mode mode)\n {\n   if (++bad_accesses > 100)\n     bad_accesses = 100;\n@@ -72,8 +77,9 @@ void report_bad_access (void *addr, size_t sz, enum memory_use_mode mode)\n }\n \n int verify1 (void *, size_t, enum access_mode, struct access_node *) NOCHECK;\n-int verify1 (void *addr, size_t sz, enum access_mode mode,\n-\t     struct access_node *a)\n+int\n+verify1 (void *addr, size_t sz, enum access_mode mode,\n+\t struct access_node *a)\n {\n   while (a && (addr + sz <= a->addr || addr >= a->addr + a->sz))\n     a = a->next;\n@@ -99,8 +105,8 @@ int verify1 (void *addr, size_t sz, enum access_mode mode,\n }\n \n int verify_range_permission (void *, size_t, enum access_mode) NOCHECK;\n-\n-int verify_range_permission (void *addr, size_t sz, enum access_mode mode)\n+int\n+verify_range_permission (void *addr, size_t sz, enum access_mode mode)\n {\n   if (debug)\n     printf (\"verify_range_permission (%p, %ld, %s)\\n\", addr, (long) sz,\n@@ -109,8 +115,8 @@ int verify_range_permission (void *addr, size_t sz, enum access_mode mode)\n }\n \n void chkr_check_addr (void *, size_t, int) NOCHECK;\n-\n-void chkr_check_addr (void *addr, size_t sz, int mode)\n+void\n+chkr_check_addr (void *addr, size_t sz, int mode)\n {\n   switch (mode)\n     {\n@@ -146,7 +152,8 @@ void chkr_check_addr (void *addr, size_t sz, int mode)\n }\n \n void copy1 (void *, void *, size_t, struct access_node *) NOCHECK;\n-void copy1 (void *dest, void *src, size_t sz, struct access_node *a)\n+void\n+copy1 (void *dest, void *src, size_t sz, struct access_node *a)\n {\n   while (a && (src + sz <= a->addr || src >= a->addr + a->sz))\n     a = a->next;\n@@ -178,38 +185,48 @@ void copy1 (void *dest, void *src, size_t sz, struct access_node *a)\n }\n \n void chkr_copy_bitmap (void *, void *, size_t) NOCHECK;\n-void chkr_copy_bitmap (void *dest, void *src, size_t sz)\n+void\n+chkr_copy_bitmap (void *dest, void *src, size_t sz)\n {\n   if (verify_range_permission (dest, sz, MEMORY_USE_WO) == 0)\n     report_bad_access (dest, sz, MEMORY_USE_WO);\n   copy1 (dest, src, sz, access_list);\n }\n \n void chkr_set_right (void *, size_t, enum access_mode) NOCHECK;\n-void chkr_set_right (void *addr, size_t sz, enum access_mode mode)\n+void\n+chkr_set_right (void *addr, size_t sz, enum access_mode mode)\n {\n   mark_region (addr, sz, mode);\n }\n \n int main () NOCHECK;\n-int main ()\n+int\n+main ()\n {\n   setup ();\n   test ();\n   bad_accesses = !!bad_accesses; /* get 0 or 1 */\n-  /* Return 0 if got expected results, 1 otherwise.  */\n-  return !(bad_accesses == expect_error);\n+  \n+  if (bad_accesses == expect_error)\n+    exit (0);\n+  else\n+    abort ();\n+  \n+  return 0;\n }\n \n-struct malloc_node {\n+struct malloc_node\n+{\n   struct malloc_node *next;\n   void *addr;\n   size_t sz;\n   unsigned is_free : 1;\n };\n static struct malloc_node *malloc_list;\n \n-void *c_malloc (size_t sz)\n+void *\n+c_malloc (size_t sz)\n {\n   void *p;\n   struct malloc_node *m;\n@@ -238,7 +255,8 @@ void *c_malloc (size_t sz)\n   return p;\n }\n \n-void c_free (void *p)\n+void\n+c_free (void *p)\n {\n   struct malloc_node *m;\n   if (p == 0)"}]}