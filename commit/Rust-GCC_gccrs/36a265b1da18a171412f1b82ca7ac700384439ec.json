{"sha": "36a265b1da18a171412f1b82ca7ac700384439ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhMjY1YjFkYTE4YTE3MTQxMmYxYjgyY2E3YWM3MDAzODQ0MzllYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-07-05T17:50:22Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2016-07-05T17:50:22Z"}, "message": "rs6000-protos.h (rs6000_split_signbit): New prototype.\n\n[gcc]\n\n2016-07-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_split_signbit): New\n\tprototype.\n\t* config/rs6000/rs6000.c (rs6000_split_signbit): New function.\n\t* config/rs6000/rs6000.md (UNSPEC_SIGNBIT): New constant.\n\t(SIGNBIT): New mode iterator.\n\t(Fsignbit): New mode attribute.\n\t(signbit<mode>2): Change operand1 to match FLOAT128 instead of\n\tIBM128; dispatch to gen_signbit{kf,tf}2_dm for __float128\n\twhen direct moves are available.\n\t(signbit<mode>2_dm): New define_insn_and_split).\n\t(signbit<mode>2_dm2): New define_insn.\n\n[gcc/testsuite]\n\n2016-07-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/signbit-1.c: New test.\n\t* gcc.target/powerpc/signbit-2.c: New test.\n\t* gcc.target/powerpc/signbit-3.c: New test.\n\n\nCo-Authored-By: Bill Schmidt <wschmidt@linux.vnet.ibm.com>\n\nFrom-SVN: r238016", "tree": {"sha": "942960fd34750603157286c6093cebe8b0015a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/942960fd34750603157286c6093cebe8b0015a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a265b1da18a171412f1b82ca7ac700384439ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a265b1da18a171412f1b82ca7ac700384439ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a265b1da18a171412f1b82ca7ac700384439ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a265b1da18a171412f1b82ca7ac700384439ec/comments", "author": null, "committer": null, "parents": [{"sha": "7a98fb6ed6f1b1b7d78466dfdb66bb919740098e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a98fb6ed6f1b1b7d78466dfdb66bb919740098e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a98fb6ed6f1b1b7d78466dfdb66bb919740098e"}], "stats": {"total": 326, "additions": 324, "deletions": 2}, "files": [{"sha": "f3099046a832a321cb92ebee7b25017217558cd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -1,3 +1,18 @@\n+2016-07-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_signbit): New\n+\tprototype.\n+\t* config/rs6000/rs6000.c (rs6000_split_signbit): New function.\n+\t* config/rs6000/rs6000.md (UNSPEC_SIGNBIT): New constant.\n+\t(SIGNBIT): New mode iterator.\n+\t(Fsignbit): New mode attribute.\n+\t(signbit<mode>2): Change operand1 to match FLOAT128 instead of\n+\tIBM128; dispatch to gen_signbit{kf,tf}2_dm for __float128\n+\twhen direct moves are available.\n+\t(signbit<mode>2_dm): New define_insn_and_split).\n+\t(signbit<mode>2_dm2): New define_insn.\n+\n 2016-07-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/71594"}, {"sha": "0a47075d6bf3ab87df78b83ff373314220eebf21", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -135,6 +135,7 @@ extern bool rs6000_emit_set_const (rtx, rtx);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n+extern void rs6000_split_signbit (rtx, rtx);\n extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);\n extern void rs6000_expand_atomic_exchange (rtx op[]);\n extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);"}, {"sha": "d2a62bdd72b6a8282591781feab1b6f88912b986", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -23145,6 +23145,48 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     emit_move_insn (dest, target);\n }\n \n+/* Split a signbit operation on 64-bit machines with direct move.  Also allow\n+   for the value to come from memory or if it is already loaded into a GPR.  */\n+\n+void\n+rs6000_split_signbit (rtx dest, rtx src)\n+{\n+  machine_mode d_mode = GET_MODE (dest);\n+  machine_mode s_mode = GET_MODE (src);\n+  rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);\n+  rtx shift_reg = dest_di;\n+\n+  gcc_assert (REG_P (dest));\n+  gcc_assert (REG_P (src) || MEM_P (src));\n+  gcc_assert (s_mode == KFmode || s_mode == TFmode);\n+\n+  if (MEM_P (src))\n+    {\n+      rtx mem = (WORDS_BIG_ENDIAN\n+\t\t ? adjust_address (src, DImode, 0)\n+\t\t : adjust_address (src, DImode, 8));\n+      emit_insn (gen_rtx_SET (dest_di, mem));\n+    }\n+\n+  else\n+    {\n+      unsigned int r = REGNO (src);\n+\n+      /* If this is a VSX register, generate the special mfvsrd instruction\n+\t to get it in a GPR.  Until we support SF and DF modes, that will\n+\t always be true.  */\n+      gcc_assert (VSX_REGNO_P (r));\n+\n+      if (s_mode == KFmode)\n+\temit_insn (gen_signbitkf2_dm2 (dest_di, src));\n+      else\n+\temit_insn (gen_signbittf2_dm2 (dest_di, src));\n+    }\n+\n+  emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));\n+  return;\n+}\n+\n /* A subroutine of the atomic operation splitters.  Jump to LABEL if\n    COND is true.  Mark the jump as unlikely to be taken.  */\n "}, {"sha": "46f73823392d8d1e8b1f58d4edcf460c0c1e640f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -147,6 +147,7 @@\n    UNSPEC_ROUND_TO_ODD\n    UNSPEC_IEEE128_MOVE\n    UNSPEC_IEEE128_CONVERT\n+   UNSPEC_SIGNBIT\n   ])\n \n ;;\n@@ -508,6 +509,13 @@\n \t\t\t\t(IF \"TARGET_FLOAT128\")\n \t\t\t\t(TF \"TARGET_LONG_DOUBLE_128\")])\n \n+; Iterator for signbit on 64-bit machines with direct move\n+(define_mode_iterator SIGNBIT [(KF \"FLOAT128_VECTOR_P (KFmode)\")\n+\t\t\t       (TF \"FLOAT128_VECTOR_P (TFmode)\")])\n+\n+(define_mode_attr Fsignbit\t[(KF \"wa\")\n+\t\t\t\t (TF \"wa\")])\n+\n ; Iterator for ISA 3.0 supported floating point types\n (define_mode_iterator FP_ISA3 [SF\n \t\t\t       DF\n@@ -4567,16 +4575,28 @@\n ;; when little-endian.\n (define_expand \"signbit<mode>2\"\n   [(set (match_dup 2)\n-\t(float_truncate:DF (match_operand:IBM128 1 \"gpc_reg_operand\" \"\")))\n+\t(float_truncate:DF (match_operand:FLOAT128 1 \"gpc_reg_operand\" \"\")))\n    (set (match_dup 3)\n    \t(subreg:DI (match_dup 2) 0))\n    (set (match_dup 4)\n    \t(match_dup 5))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n   \t(match_dup 6))]\n   \"TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && (!FLOAT128_IEEE_P (<MODE>mode)\n+       || (TARGET_POWERPC64 && TARGET_DIRECT_MOVE))\"\n {\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n+    {\n+      if (<MODE>mode == KFmode)\n+\temit_insn (gen_signbitkf2_dm (operands[0], operands[1]));\n+      else if (<MODE>mode == TFmode)\n+\temit_insn (gen_signbittf2_dm (operands[0], operands[1]));\n+      else\n+\tgcc_unreachable ();\n+      DONE;\n+    }\n   operands[2] = gen_reg_rtx (DFmode);\n   operands[3] = gen_reg_rtx (DImode);\n   if (TARGET_POWERPC64)\n@@ -4624,6 +4644,37 @@\n    operands[5] = CONST0_RTX (<MODE>mode);\n   })\n \n+;; Optimize signbit on 64-bit systems with direct move to avoid doing the store\n+;; and load.\n+(define_insn_and_split \"signbit<mode>2_dm\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(unspec:SI\n+\t [(match_operand:SIGNBIT 1 \"input_operand\" \"<Fsignbit>,m,r\")]\n+\t UNSPEC_SIGNBIT))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_signbit (operands[0], operands[1]);\n+  DONE;\n+}\n+ [(set_attr \"length\" \"8,8,12\")\n+  (set_attr \"type\" \"mftgpr,load,integer\")])\n+\n+;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating\n+;; point types, which makes normal SUBREG's problematical. Instead use a\n+;; special pattern to avoid using a normal movdi.\n+(define_insn \"signbit<mode>2_dm2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"<Fsignbit>\")\n+\t\t    (const_int 0)]\n+\t\t   UNSPEC_SIGNBIT))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mfvsrd %0,%x1\"\n+ [(set_attr \"type\" \"mftgpr\")])\n+\n+\n ;; Use an unspec rather providing an if-then-else in RTL, to prevent the\n ;; compiler from optimizing -0.0\n (define_insn \"copysign<mode>3_fcpsgn\""}, {"sha": "f6fb6cd7e9fd34b51a2d43706987f3bfdfba9396", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -1,3 +1,10 @@\n+2016-07-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/signbit-1.c: New test.\n+\t* gcc.target/powerpc/signbit-2.c: New test.\n+\t* gcc.target/powerpc/signbit-3.c: New test.\n+\n 2016-07-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/71594"}, {"sha": "bdfeb702663b9b51c376b9c455e4b256ece5250d", "filename": "gcc/testsuite/gcc.target/powerpc/signbit-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-1.c?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2 -mfloat128\" } */\n+\n+int do_signbit_kf (__float128 a) { return __builtin_signbit (a); }\n+int do_signbit_if (__ibm128 a) { return __builtin_signbit (a); }\n+int do_signbit_tf (long double a) { return __builtin_signbit (a); }\n+\n+/* { dg-final { scan-assembler-not   \"stxvd2x\"  } } */\n+/* { dg-final { scan-assembler-not   \"stxvw4x\"  } } */\n+/* { dg-final { scan-assembler-not   \"stxsd\"    } } */\n+/* { dg-final { scan-assembler-not   \"stxsdx\"   } } */\n+/* { dg-final { scan-assembler-times \"mfvsrd\" 3 } } */\n+/* { dg-final { scan-assembler-times \"srdi\"   3 } } */"}, {"sha": "b5bd856d9091af87f2426dbc7a3fac613fa34356", "filename": "gcc/testsuite/gcc.target/powerpc/signbit-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-2.c?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 -mfloat128\" } */\n+\n+int do_signbit_kf (__float128 *a) { return __builtin_signbit (*a); }\n+\n+/* { dg-final { scan-assembler-not   \"stxvd2x\"  } } */\n+/* { dg-final { scan-assembler-not   \"stxvw4x\"  } } */\n+/* { dg-final { scan-assembler-not   \"stxsd\"    } } */\n+/* { dg-final { scan-assembler-not   \"stxsdx\"   } } */\n+/* { dg-final { scan-assembler-not   \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not   \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not   \"lxsd\"     } } */\n+/* { dg-final { scan-assembler-not   \"lxsdx\"    } } */\n+/* { dg-final { scan-assembler-times \"ld\"     1 } } */\n+/* { dg-final { scan-assembler-times \"srdi\"   1 } } */"}, {"sha": "cd64143fc2f16f8d451787269d7876090cd99844", "filename": "gcc/testsuite/gcc.target/powerpc/signbit-3.c", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a265b1da18a171412f1b82ca7ac700384439ec/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsignbit-3.c?ref=36a265b1da18a171412f1b82ca7ac700384439ec", "patch": "@@ -0,0 +1,172 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-mcpu=power7 -O2 -mfloat128 -lm\" } */\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <inttypes.h>\n+#include <stdlib.h>\n+#include <math.h>\n+\n+#if defined(__BIG_ENDIAN__)\n+struct ieee128 {\n+  uint64_t upper;\n+  uint64_t lower;\n+};\n+\n+#elif defined(__LITTLE_ENDIAN__)\n+struct ieee128 {\n+  uint64_t lower;\n+  uint64_t upper;\n+};\n+\n+#else\n+#error \"Unknown system\"\n+#endif\n+\n+union ieee_union {\n+  __float128 f128;\n+  struct ieee128 st128;\n+};\n+\n+#ifdef DEBUG\n+static int num_errors = 0;\n+\n+__attribute__((__noinline__))\n+static void\n+failure (int expected, int got, __float128 x)\n+{\n+  unsigned sign;\n+  unsigned exponent;\n+  uint64_t mantissa1;\n+  uint64_t mantissa2;\n+  uint64_t upper;\n+  uint64_t lower;\n+\n+  union ieee_union u;\n+\n+  u.f128 = x;\n+  upper  = u.st128.upper;\n+  lower  = u.st128.lower;\n+\n+  sign      = (unsigned)((upper >> 63) & 1);\n+  exponent  = (unsigned)((upper >> 48) & ((((uint64_t)1) << 16) - 1));\n+  mantissa1 = (upper & ((((uint64_t)1) << 48) - 1));\n+  mantissa2 = lower;\n+\n+  printf (\"Expected %d, got %d, %c 0x%.4x 0x%.12\" PRIx64 \" 0x%.16\" PRIx64,\n+\t  expected, got,\n+\t  sign ? '-' : '+',\n+\t  exponent,\n+\t  mantissa1,\n+\t  mantissa2);\n+\n+  num_errors++;\n+}\n+\n+#else\n+\n+#define failure(E, G, F) abort ()\n+#endif\n+\n+__attribute__((__noinline__))\n+static void\n+test_signbit_arg (__float128 f128, int expected)\n+{\n+  int sign = __builtin_signbit (f128);\n+\n+  if ((expected != 0 && sign == 0)\n+      || (expected == 0 && sign != 0))\n+    failure (f128, expected, sign);\n+}\n+\n+__attribute__((__noinline__))\n+static void\n+test_signbit_mem (__float128 *ptr, int expected)\n+{\n+  int sign = __builtin_signbit (*ptr);\n+\n+  if ((expected != 0 && sign == 0)\n+      || (expected == 0 && sign != 0))\n+    failure (*ptr, expected, sign);\n+}\n+\n+__attribute__((__noinline__))\n+static void\n+test_signbit_gpr (__float128 *ptr, int expected)\n+{\n+  __float128 f128 = *ptr;\n+  int sign;\n+\n+  __asm__ (\" # %0\" : \"+r\" (f128));\n+\n+  sign = __builtin_signbit (f128);\n+  if ((expected != 0 && sign == 0)\n+      || (expected == 0 && sign != 0))\n+    failure (f128, expected, sign);\n+}\n+\n+__attribute__((__noinline__))\n+static void\n+test_signbit (__float128 f128, int expected)\n+{\n+#ifdef DEBUG\n+  union ieee_union u;\n+  u.f128 = f128;\n+  printf (\"Expecting %d, trying %-5g \"\n+\t  \"(0x%.16\" PRIx64 \" 0x%.16\" PRIx64 \")\\n\",\n+\t  expected, (double)f128,\n+\t  u.st128.upper, u.st128.lower);\n+#endif\n+\n+  test_signbit_arg (f128,  expected);\n+  test_signbit_mem (&f128, expected);\n+  test_signbit_gpr (&f128, expected);\n+}\n+\n+int\n+main (void)\n+{\n+  union ieee_union u;\n+\n+  test_signbit (+0.0q, 0);\n+  test_signbit (+1.0q, 0);\n+\n+  test_signbit (-0.0q, 1);\n+  test_signbit (-1.0q, 1);\n+\n+  test_signbit (__builtin_copysign (__builtin_infq (), +1.0q), 0);\n+  test_signbit (__builtin_copysign (__builtin_infq (), -1.0q), 1);\n+\n+  test_signbit (__builtin_copysign (__builtin_nanq (\"\"), +1.0q), 0);\n+  test_signbit (__builtin_copysign (__builtin_nanq (\"\"), -1.0q), 1);\n+\n+  /* force the bottom double word to have specific bits in the 'sign' bit to\n+     make sure we are picking the right word.  */\n+  u.f128 = 1.0q;\n+  u.st128.lower = 0ULL;\n+  test_signbit (u.f128, 0);\n+\n+  u.st128.lower = ~0ULL;\n+  test_signbit (u.f128, 0);\n+\n+  u.f128 = -1.0q;\n+  u.st128.lower = 0ULL;\n+  test_signbit (u.f128, 1);\n+\n+  u.st128.lower = ~0ULL;\n+  test_signbit (u.f128, 1);\n+\n+#ifdef DEBUG\n+  printf (\"%d error(s) were found\\n\", num_errors);\n+  if (num_errors)\n+    return num_errors;\n+#endif\n+\n+  return 0;\n+}\n+"}]}