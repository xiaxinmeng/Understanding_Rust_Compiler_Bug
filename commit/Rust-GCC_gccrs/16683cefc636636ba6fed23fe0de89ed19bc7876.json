{"sha": "16683cefc636636ba6fed23fe0de89ed19bc7876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY2ODNjZWZjNjM2NjM2YmE2ZmVkMjNmZTBkZTg5ZWQxOWJjNzg3Ng==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-04-28T17:07:41Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-04-28T17:07:41Z"}, "message": "fix asm-not pattern in dwarf2/inline5.c\n\nThe test is supposed to check that the abstract lexical block of a\nfunction that was inlined doesn't have attributes, and that the\nconcrete inlined lexical block does.\n\nThere are two patterns to verify the absence of attributes in the\nabstract lexical block, one for the case in which the concrete block\nappears after the abstract one, and another for the case in which it's\nbefore.\n\nThe former has a problem that is not visible when asm comments start\nwith a single character, but that becomes apparent when they start\nwith \"/ \".\n\nThe pattern starts by matching the abstract DW_TAG_lexical_block DIE\nheader, and checking that the next line has, after any of the\ncomment-starter characters (e.g. '/'), there are one or more blanks '\n+', and then a character other than the '(' that would start another\nDIE.\n\nThe problem is that '[.../...]+ +[^(].*' matches '/  (DIE...', because\n'[^(]' may match the second blank, and after that anything goes.  So\nwe end up recognizing the pattern, as if it was an abstract lexical\nblock with an attribute.\n\nThis could be minimally fixed by changing '[^(]' to '[^ (]', but the\npattern that matches concrete before abstract checks for an explicit\nDW_AT after the abstract DIE, so I'm using that in the other pattern\nas well.\n\nFor reference, the lines that start the unwanted match are:\n\t.uleb128 0xc\t/  (DIE (0xa4) DW_TAG_lexical_block)\n\t.uleb128 0xd\t/  (DIE (0xa5) DW_TAG_variable)\n\n\nfor  gcc/testsuite/ChangeLog\n\n\t* gcc.dg/debug/dwarf2/inline5.c: Adjust pattern to avoid\n\tmismatch when asm comments start with \"/ \".", "tree": {"sha": "c0a4f1a055819609ae7aa0c3001f9d1e9ac07496", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0a4f1a055819609ae7aa0c3001f9d1e9ac07496"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16683cefc636636ba6fed23fe0de89ed19bc7876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16683cefc636636ba6fed23fe0de89ed19bc7876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16683cefc636636ba6fed23fe0de89ed19bc7876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16683cefc636636ba6fed23fe0de89ed19bc7876/comments", "author": null, "committer": null, "parents": [{"sha": "59f5d16f2c5db4d9592c8ce6453afe81334bb012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f5d16f2c5db4d9592c8ce6453afe81334bb012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f5d16f2c5db4d9592c8ce6453afe81334bb012"}], "stats": {"total": 2, "additions": 1, "deletions": 1}, "files": [{"sha": "3b50e9f2617355ccf805805e1d3c6e939a8e11d9", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/inline5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16683cefc636636ba6fed23fe0de89ed19bc7876/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Finline5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16683cefc636636ba6fed23fe0de89ed19bc7876/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Finline5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Finline5.c?ref=16683cefc636636ba6fed23fe0de89ed19bc7876", "patch": "@@ -9,7 +9,7 @@\n /* We do not know which is output first so look for both invalid abstract\n    origins on the lexical blocks (knowing that the abstract instance has\n    no attribute following the DW_TAG_lexical_block.  */\n-/* { dg-final { scan-assembler-not \"\\\\(DIE \\\\(0x(\\[0-9a-f\\]*)\\\\) DW_TAG_lexical_block\\\\)\\[^#/!@;\\\\|\\]*\\[#/!@;\\\\|\\]+ +\\[^(\\].*DW_TAG_lexical_block\\\\)\\[^#/!@;\\\\|x\\]*x\\\\1\\[^#/!@;\\\\|\\]*\\[#/!@;\\\\|\\] +DW_AT_abstract_origin\" { xfail { { *-*-aix* || *-*-solaris2.* } && { ! gas } } } } } */\n+/* { dg-final { scan-assembler-not \"\\\\(DIE \\\\(0x(\\[0-9a-f\\]*)\\\\) DW_TAG_lexical_block\\\\)\\[^#/!@;\\\\|\\]*\\[#/!@;\\\\|\\]+ +DW_AT.*DW_TAG_lexical_block\\\\)\\[^#/!@;\\\\|x\\]*x\\\\1\\[^#/!@;\\\\|\\]*\\[#/!@;\\\\|\\] +DW_AT_abstract_origin\" { xfail { { *-*-aix* || *-*-solaris2.* } && { ! gas } } } } } */\n /* { dg-final { scan-assembler-not \"DW_TAG_lexical_block\\\\)\\[^#/!@;\\\\|x\\]*x(\\[0-9a-f\\]*)\\[^#/!@;\\\\|\\]*\\[#/!@;\\\\|\\]+ +DW_AT_abstract_origin.*\\\\(DIE \\\\(0x\\\\1\\\\) DW_TAG_lexical_block\\\\)\\[^#/!@;\\\\|\\]*\\[#/!@;\\\\|\\]+ +DW_AT\" } } */\n \n int foo (int i)"}]}