{"sha": "5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNiZjhjOGQwYjE1ZTk5NzFlNmEwNTRiZDRlOWJhMzllMzdmNjYzNg==", "commit": {"author": {"name": "David Daney", "email": "ddaney@caviumnetworks.com", "date": "2009-09-15T17:15:33Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2009-09-15T17:15:33Z"}, "message": "java_raw_api.c (ffi_java_raw_to_rvalue): Remove special handling for FFI_TYPE_POINTER.\n\n2009-09-15  David Daney  <ddaney@caviumnetworks.com>\n\n\t* src/java_raw_api.c (ffi_java_raw_to_rvalue): Remove special\n\thandling for FFI_TYPE_POINTER.\n\t* src/mips/ffitarget.h (FFI_TYPE_STRUCT_D_SOFT,\n\tFFI_TYPE_STRUCT_F_SOFT, FFI_TYPE_STRUCT_DD_SOFT,\n\tFFI_TYPE_STRUCT_FF_SOFT, FFI_TYPE_STRUCT_FD_SOFT,\n\tFFI_TYPE_STRUCT_DF_SOFT, FFI_TYPE_STRUCT_SOFT): New defines.\n\t(FFI_N32_SOFT_FLOAT, FFI_N64_SOFT_FLOAT): New ffi_abi enumerations.\n\t(enum ffi_abi): Set FFI_DEFAULT_ABI for soft-float.\n\t* src/mips/n32.S (ffi_call_N32): Add handling for soft-float\n\tstructure and pointer returns.\n\t(ffi_closure_N32): Add handling for pointer returns.\n\t* src/mips/ffi.c (ffi_prep_args, calc_n32_struct_flags,\n\tcalc_n32_return_struct_flags): Handle soft-float.\n\t(ffi_prep_cif_machdep):  Handle soft-float, fix pointer handling.\n\t(ffi_call_N32): Declare proper argument types.\n\t(ffi_call, copy_struct_N32, ffi_closure_mips_inner_N32): Handle\n\tsoft-float.\n\nFrom-SVN: r151726", "tree": {"sha": "bcf96a2bec0678e59202d229d2cf488b66017407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf96a2bec0678e59202d229d2cf488b66017407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/comments", "author": null, "committer": null, "parents": [{"sha": "1c3c9f1247b44f08530c7c9b5288aabc2bbc6895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c3c9f1247b44f08530c7c9b5288aabc2bbc6895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c3c9f1247b44f08530c7c9b5288aabc2bbc6895"}], "stats": {"total": 253, "additions": 219, "deletions": 34}, "files": [{"sha": "684a0e88fcea72e99174d30c981357918cbfdde5", "filename": "libffi/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "patch": "@@ -1,3 +1,23 @@\n+2009-09-15  David Daney  <ddaney@caviumnetworks.com>\n+\n+\t* src/java_raw_api.c (ffi_java_raw_to_rvalue): Remove special\n+\thandling for FFI_TYPE_POINTER.\n+\t* src/mips/ffitarget.h (FFI_TYPE_STRUCT_D_SOFT,\n+\tFFI_TYPE_STRUCT_F_SOFT, FFI_TYPE_STRUCT_DD_SOFT,\n+\tFFI_TYPE_STRUCT_FF_SOFT, FFI_TYPE_STRUCT_FD_SOFT,\n+\tFFI_TYPE_STRUCT_DF_SOFT, FFI_TYPE_STRUCT_SOFT): New defines.\n+\t(FFI_N32_SOFT_FLOAT, FFI_N64_SOFT_FLOAT): New ffi_abi enumerations.\n+\t(enum ffi_abi): Set FFI_DEFAULT_ABI for soft-float.\n+\t* src/mips/n32.S (ffi_call_N32): Add handling for soft-float\n+\tstructure and pointer returns.\n+\t(ffi_closure_N32): Add handling for pointer returns.\n+\t* src/mips/ffi.c (ffi_prep_args, calc_n32_struct_flags,\n+\tcalc_n32_return_struct_flags): Handle soft-float.\n+\t(ffi_prep_cif_machdep):  Handle soft-float, fix pointer handling.\n+\t(ffi_call_N32): Declare proper argument types.\n+\t(ffi_call, copy_struct_N32, ffi_closure_mips_inner_N32): Handle\n+\tsoft-float.\n+\n 2009-08-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure.ac (AC_PREREQ): Bump to 2.64."}, {"sha": "9c5383e6d5a6055228e2e06f11a87499342ad9f9", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "patch": "@@ -276,9 +276,6 @@ ffi_java_raw_to_rvalue (ffi_cif *cif, void *rvalue)\n     case FFI_TYPE_SINT16:\n     case FFI_TYPE_SINT32:\n     case FFI_TYPE_INT:\n-#if FFI_SIZEOF_JAVA_RAW == 4\n-    case FFI_TYPE_POINTER:\n-#endif\n       *(SINT64 *)rvalue >>= 32;\n       break;\n "}, {"sha": "3143dcfc6539305c14093dc2b50e133d834a4ffb", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 125, "deletions": 29, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "patch": "@@ -99,7 +99,7 @@ static void ffi_prep_args(char *stack,\n \n   p_argv = ecif->avalue;\n \n-  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n+  for (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs; i++, p_arg++)\n     {\n       size_t z;\n       unsigned int a;\n@@ -123,9 +123,25 @@ static void ffi_prep_args(char *stack,\n \n           /* The size of a pointer depends on the ABI */\n           if (type == FFI_TYPE_POINTER)\n-            type =\n-              (ecif->cif->abi == FFI_N64) ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;\n+            type = (ecif->cif->abi == FFI_N64\n+\t\t    || ecif->cif->abi == FFI_N64_SOFT_FLOAT)\n+\t      ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;\n \n+\tif (i < 8 && (ecif->cif->abi == FFI_N32_SOFT_FLOAT\n+\t\t      || ecif->cif->abi == FFI_N64_SOFT_FLOAT))\n+\t  {\n+\t    switch (type)\n+\t      {\n+\t      case FFI_TYPE_FLOAT:\n+\t\ttype = FFI_TYPE_UINT32;\n+\t\tbreak;\n+\t      case FFI_TYPE_DOUBLE:\n+\t\ttype = FFI_TYPE_UINT64;\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n \t  switch (type)\n \t    {\n \t      case FFI_TYPE_SINT8:\n@@ -205,13 +221,17 @@ static void ffi_prep_args(char *stack,\n    definitions and generates the appropriate flags. */\n \n static unsigned\n-calc_n32_struct_flags(ffi_type *arg, unsigned *loc, unsigned *arg_reg)\n+calc_n32_struct_flags(int soft_float, ffi_type *arg,\n+\t\t      unsigned *loc, unsigned *arg_reg)\n {\n   unsigned flags = 0;\n   unsigned index = 0;\n \n   ffi_type *e;\n \n+  if (soft_float)\n+    return 0;\n+\n   while ((e = arg->elements[index]))\n     {\n       /* Align this object.  */\n@@ -236,7 +256,7 @@ calc_n32_struct_flags(ffi_type *arg, unsigned *loc, unsigned *arg_reg)\n }\n \n static unsigned\n-calc_n32_return_struct_flags(ffi_type *arg)\n+calc_n32_return_struct_flags(int soft_float, ffi_type *arg)\n {\n   unsigned flags = 0;\n   unsigned small = FFI_TYPE_SMALLSTRUCT;\n@@ -256,6 +276,7 @@ calc_n32_return_struct_flags(ffi_type *arg)\n     small = FFI_TYPE_SMALLSTRUCT2;\n \n   e = arg->elements[0];\n+\n   if (e->type == FFI_TYPE_DOUBLE)\n     flags = FFI_TYPE_DOUBLE;\n   else if (e->type == FFI_TYPE_FLOAT)\n@@ -276,6 +297,8 @@ calc_n32_return_struct_flags(ffi_type *arg)\n \t     floats! This must be passed the old way. */\n \t  return small;\n \t}\n+      if (soft_float)\n+\tflags += FFI_TYPE_STRUCT_SOFT;\n     }\n   else\n     if (!flags)\n@@ -382,16 +405,19 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n #ifdef FFI_MIPS_N32\n   /* Set the flags necessary for N32 processing */\n   {\n+    int type;\n     unsigned arg_reg = 0;\n     unsigned loc = 0;\n     unsigned count = (cif->nargs < 8) ? cif->nargs : 8;\n     unsigned index = 0;\n \n     unsigned struct_flags = 0;\n+    int soft_float = (cif->abi == FFI_N32_SOFT_FLOAT\n+\t\t      || cif->abi == FFI_N64_SOFT_FLOAT);\n \n     if (cif->rtype->type == FFI_TYPE_STRUCT)\n       {\n-\tstruct_flags = calc_n32_return_struct_flags(cif->rtype);\n+\tstruct_flags = calc_n32_return_struct_flags(soft_float, cif->rtype);\n \n \tif (struct_flags == 0)\n \t  {\n@@ -411,7 +437,22 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n     while (count-- > 0 && arg_reg < 8)\n       {\n-\tswitch ((cif->arg_types)[index]->type)\n+\ttype = (cif->arg_types)[index]->type;\n+\tif (soft_float)\n+\t  {\n+\t    switch (type)\n+\t      {\n+\t      case FFI_TYPE_FLOAT:\n+\t\ttype = FFI_TYPE_UINT32;\n+\t\tbreak;\n+\t      case FFI_TYPE_DOUBLE:\n+\t\ttype = FFI_TYPE_UINT64;\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tswitch (type)\n \t  {\n \t  case FFI_TYPE_FLOAT:\n \t  case FFI_TYPE_DOUBLE:\n@@ -423,17 +464,25 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n             /* Align it.  */\n             arg_reg = ALIGN(arg_reg, 2);\n             /* Treat it as two adjacent doubles.  */\n-\t    cif->flags +=\n-              (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));\n-            arg_reg++;\n-\t    cif->flags +=\n-              (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));\n-            arg_reg++;\n+\t    if (soft_float) \n+\t      {\n+\t\targ_reg += 2;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcif->flags +=\n+\t\t  (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));\n+\t\targ_reg++;\n+\t\tcif->flags +=\n+\t\t  (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));\n+\t\targ_reg++;\n+\t      }\n             break;\n \n \t  case FFI_TYPE_STRUCT:\n             loc = arg_reg * FFI_SIZEOF_ARG;\n-\t    cif->flags += calc_n32_struct_flags((cif->arg_types)[index],\n+\t    cif->flags += calc_n32_struct_flags(soft_float,\n+\t\t\t\t\t\t(cif->arg_types)[index],\n \t\t\t\t\t\t&loc, &arg_reg);\n \t    break;\n \n@@ -469,17 +518,43 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       case FFI_TYPE_VOID:\n \t/* Do nothing, 'cause FFI_TYPE_VOID is 0 */\n \tbreak;\n-\t\n+\n+      case FFI_TYPE_POINTER:\n+\tif (cif->abi == FFI_N32_SOFT_FLOAT || cif->abi == FFI_N32)\n+\t  cif->flags += FFI_TYPE_SINT32 << (FFI_FLAG_BITS * 8);\n+\telse\n+\t  cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);\n+\tbreak;\n+\n       case FFI_TYPE_FLOAT:\n+\tif (soft_float)\n+\t  {\n+\t    cif->flags += FFI_TYPE_SINT32 << (FFI_FLAG_BITS * 8);\n+\t    break;\n+\t  }\n+\t/* else fall through */\n       case FFI_TYPE_DOUBLE:\n-\tcif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);\n+\tif (soft_float)\n+\t  cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);\n+\telse\n+\t  cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);\n \tbreak;\n+\n       case FFI_TYPE_LONGDOUBLE:\n \t/* Long double is returned as if it were a struct containing\n \t   two doubles.  */\n-\tcif->flags += FFI_TYPE_STRUCT << (FFI_FLAG_BITS * 8);\n-\tcif->flags += (FFI_TYPE_DOUBLE + (FFI_TYPE_DOUBLE << FFI_FLAG_BITS))\n-\t\t      << (4 + (FFI_FLAG_BITS * 8));\n+\tif (soft_float)\n+\t  {\n+\t    cif->flags += FFI_TYPE_STRUCT << (FFI_FLAG_BITS * 8);\n+\t    cif->flags += FFI_TYPE_SMALLSTRUCT2 << (4 + (FFI_FLAG_BITS * 8));\n+ \t  }\n+\telse\n+\t  {\n+\t    cif->flags += FFI_TYPE_STRUCT << (FFI_FLAG_BITS * 8);\n+\t    cif->flags += (FFI_TYPE_DOUBLE\n+\t\t\t   + (FFI_TYPE_DOUBLE << FFI_FLAG_BITS))\n+\t\t\t\t\t      << (4 + (FFI_FLAG_BITS * 8));\n+\t  }\n \tbreak;\n       default:\n \tcif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);\n@@ -499,7 +574,7 @@ extern int ffi_call_O32(void (*)(char *, extended_cif *, int, int),\n /* Low level routine for calling N32 functions */\n extern int ffi_call_N32(void (*)(char *, extended_cif *, int, int), \n \t\t\textended_cif *, unsigned, \n-\t\t\tunsigned, unsigned *, void (*)(void));\n+\t\t\tunsigned, void *, void (*)(void));\n \n void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n@@ -529,10 +604,13 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n \n #ifdef FFI_MIPS_N32\n     case FFI_N32:\n+    case FFI_N32_SOFT_FLOAT:\n     case FFI_N64:\n+    case FFI_N64_SOFT_FLOAT:\n       {\n         int copy_rvalue = 0;\n-        void *rvalue_copy = ecif.rvalue;\n+\tint copy_offset = 0;\n+        char *rvalue_copy = ecif.rvalue;\n         if (cif->rtype->type == FFI_TYPE_STRUCT && cif->rtype->size < 16)\n           {\n             /* For structures smaller than 16 bytes we clobber memory\n@@ -541,10 +619,20 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n             rvalue_copy = alloca(16);\n             copy_rvalue = 1;\n           }\n+\telse if (cif->rtype->type == FFI_TYPE_FLOAT\n+\t\t && (cif->abi == FFI_N64_SOFT_FLOAT\n+\t\t     || cif->abi == FFI_N32_SOFT_FLOAT))\n+\t  {\n+\t    rvalue_copy = alloca (8);\n+\t    copy_rvalue = 1;\n+#ifdef __MIPSEB__\n+\t    copy_offset = 4;\n+#endif\n+\t  }\n         ffi_call_N32(ffi_prep_args, &ecif, cif->bytes,\n                      cif->flags, rvalue_copy, fn);\n         if (copy_rvalue)\n-          memcpy(ecif.rvalue, rvalue_copy, cif->rtype->size);\n+          memcpy(ecif.rvalue, rvalue_copy + copy_offset, cif->rtype->size);\n       }\n       break;\n #endif\n@@ -755,7 +843,7 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n static void\n copy_struct_N32(char *target, unsigned offset, ffi_abi abi, ffi_type *type,\n                 int argn, unsigned arg_offset, ffi_arg *ar,\n-                ffi_arg *fpr)\n+                ffi_arg *fpr, int soft_float)\n {\n   ffi_type **elt_typep = type->elements;\n   while(*elt_typep)\n@@ -777,7 +865,7 @@ copy_struct_N32(char *target, unsigned offset, ffi_abi abi, ffi_type *type,\n \n       tp = target + offset;\n \n-      if (elt_type->type == FFI_TYPE_DOUBLE)\n+      if (elt_type->type == FFI_TYPE_DOUBLE && !soft_float)\n         *(double *)tp = *(double *)fpp;\n       else\n         memcpy(tp, argp + arg_offset, elt_type->size);\n@@ -815,8 +903,12 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n   ffi_arg *avalue;\n   ffi_type **arg_types;\n   int i, avn, argn;\n+  int soft_float;\n+  ffi_arg *argp;\n \n   cif = closure->cif;\n+  soft_float = cif->abi == FFI_N64_SOFT_FLOAT\n+    || cif->abi == FFI_N32_SOFT_FLOAT;\n   avalue = alloca (cif->nargs * sizeof (ffi_arg));\n   avaluep = alloca (cif->nargs * sizeof (ffi_arg));\n \n@@ -839,9 +931,9 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n   while (i < avn)\n     {\n       if (arg_types[i]->type == FFI_TYPE_FLOAT\n-          || arg_types[i]->type == FFI_TYPE_DOUBLE)\n+\t  || arg_types[i]->type == FFI_TYPE_DOUBLE)\n         {\n-          ffi_arg *argp = argn >= 8 ? ar + argn : fpr + argn;\n+          argp = (argn >= 8 || soft_float) ? ar + argn : fpr + argn;\n #ifdef __MIPSEB__\n           if (arg_types[i]->type == FFI_TYPE_FLOAT && argn < 8)\n             avaluep[i] = ((char *) argp) + sizeof (float);\n@@ -856,11 +948,15 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n           if (arg_types[i]->alignment > sizeof(ffi_arg))\n             argn = ALIGN(argn, arg_types[i]->alignment / sizeof(ffi_arg));\n \n-          ffi_arg *argp = ar + argn;\n+          argp = ar + argn;\n \n           /* The size of a pointer depends on the ABI */\n           if (type == FFI_TYPE_POINTER)\n-            type = (cif->abi == FFI_N64) ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;\n+            type = (cif->abi == FFI_N64 || cif->abi == FFI_N64_SOFT_FLOAT)\n+\t      ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;\n+\n+\t  if (soft_float && type ==  FFI_TYPE_FLOAT)\n+\t    type = FFI_TYPE_UINT32;\n \n           switch (type)\n             {\n@@ -901,7 +997,7 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n                      it was passed in registers.  */\n                   avaluep[i] = alloca(arg_types[i]->size);\n                   copy_struct_N32(avaluep[i], 0, cif->abi, arg_types[i],\n-                                  argn, 0, ar, fpr);\n+                                  argn, 0, ar, fpr, soft_float);\n \n                   break;\n                 }"}, {"sha": "dd3fe739c224229b0f0d193592df34d841876773", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "patch": "@@ -95,6 +95,15 @@\n #define FFI_TYPE_STRUCT_DF     189\n #define FFI_TYPE_STRUCT_SMALL  93\n #define FFI_TYPE_STRUCT_SMALL2 109\n+\n+/* and for n32 soft float, add 16 * 2^4 */\n+#define FFI_TYPE_STRUCT_D_SOFT      317\n+#define FFI_TYPE_STRUCT_F_SOFT      301\n+#define FFI_TYPE_STRUCT_DD_SOFT     509\n+#define FFI_TYPE_STRUCT_FF_SOFT     429\n+#define FFI_TYPE_STRUCT_FD_SOFT     493\n+#define FFI_TYPE_STRUCT_DF_SOFT     445\n+#define FFI_TYPE_STRUCT_SOFT        16\n #endif\n \n #ifdef LIBFFI_ASM\n@@ -161,6 +170,8 @@ typedef enum ffi_abi {\n   FFI_N32,\n   FFI_N64,\n   FFI_O32_SOFT_FLOAT,\n+  FFI_N32_SOFT_FLOAT,\n+  FFI_N64_SOFT_FLOAT,\n \n #ifdef FFI_MIPS_O32\n #ifdef __mips_soft_float\n@@ -170,9 +181,17 @@ typedef enum ffi_abi {\n #endif\n #else\n # if _MIPS_SIM==_ABI64\n+#  ifdef __mips_soft_float\n+  FFI_DEFAULT_ABI = FFI_N64_SOFT_FLOAT,\n+#  else\n   FFI_DEFAULT_ABI = FFI_N64,\n+#  endif\n # else\n+#  ifdef __mips_soft_float\n+  FFI_DEFAULT_ABI = FFI_N32_SOFT_FLOAT,\n+#  else\n   FFI_DEFAULT_ABI = FFI_N32,\n+#  endif\n # endif\n #endif\n "}, {"sha": "6f0f4c6d530a4e121557b978266f9b8468f06718", "filename": "libffi/src/mips/n32.S", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fmips%2Fn32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636/libffi%2Fsrc%2Fmips%2Fn32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fn32.S?ref=5cbf8c8d0b15e9971e6a054bd4e9ba39e37f6636", "patch": "@@ -217,8 +217,10 @@ callit:\n \n \t# Shift the return type flag over\n \tSRL\tt6, 8*FFI_FLAG_BITS\n-\t\n+\n+\tbeq\tt6, FFI_TYPE_SINT32, retint\t\n \tbne     t6, FFI_TYPE_INT, retfloat\n+retint:\n \tjal\tt9\n \tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n \tREG_S\tv0, 0(t4)\n@@ -277,12 +279,58 @@ retstruct_d_f:\n \tb\tepilogue\n \t\n retstruct_f_d:\t\n-\tbne\tt6, FFI_TYPE_STRUCT_FD, retstruct_small\n+\tbne\tt6, FFI_TYPE_STRUCT_FD, retstruct_d_soft\n \tjal\tt9\n \tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n \ts.s\t$f0, 0(t4)\n \ts.d\t$f2, 8(t4)\n \tb\tepilogue\n+\n+retstruct_d_soft:\n+\tbne\tt6, FFI_TYPE_STRUCT_D_SOFT, retstruct_f_soft\n+\tjal\tt9\n+\tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n+\tsd\tv0, 0(t4)\n+\tb\tepilogue\n+\t\n+retstruct_f_soft:\t\n+\tbne\tt6, FFI_TYPE_STRUCT_F_SOFT, retstruct_d_d_soft\n+\tjal\tt9\n+\tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n+\tsw\tv0, 0(t4)\n+\tb\tepilogue\n+\t\n+retstruct_d_d_soft:\t\n+\tbne\tt6, FFI_TYPE_STRUCT_DD_SOFT, retstruct_f_f_soft\n+\tjal\tt9\n+\tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n+\tsd\tv0, 0(t4)\n+\tsd\tv1, 8(t4)\n+\tb\tepilogue\n+\t\n+retstruct_f_f_soft:\t\n+\tbne\tt6, FFI_TYPE_STRUCT_FF_SOFT, retstruct_d_f_soft\n+\tjal\tt9\n+\tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n+\tsw\tv0, 0(t4)\n+\tsw\tv1, 4(t4)\n+\tb\tepilogue\n+\t\n+retstruct_d_f_soft:\t\n+\tbne\tt6, FFI_TYPE_STRUCT_DF_SOFT, retstruct_f_d_soft\n+\tjal\tt9\n+\tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n+\tsd\tv0, 0(t4)\n+\tsw\tv1, 8(t4)\n+\tb\tepilogue\n+\t\n+retstruct_f_d_soft:\t\n+\tbne\tt6, FFI_TYPE_STRUCT_FD_SOFT, retstruct_small\n+\tjal\tt9\n+\tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n+\tsw\tv0, 0(t4)\n+\tsd\tv1, 8(t4)\n+\tb\tepilogue\n \t\n retstruct_small:\t\n \tbne\tt6, FFI_TYPE_STRUCT_SMALL, retstruct_small2\n@@ -413,6 +461,11 @@ ffi_closure_N32:\n \tjalr\tt9\n \n \t# Return flags are in v0\n+\tbne     v0, FFI_TYPE_SINT32, cls_retint\n+\tlw\tv0, V0_OFF2($sp)\n+\tb\tcls_epilogue\n+\n+cls_retint:\n \tbne     v0, FFI_TYPE_INT, cls_retfloat\n \tREG_L\tv0, V0_OFF2($sp)\n \tb\tcls_epilogue"}]}