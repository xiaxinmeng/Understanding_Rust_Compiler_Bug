{"sha": "67470f5d6697337808fd23061cc765173ed0825d", "node_id": "C_kwDOANBUbNoAKDY3NDcwZjVkNjY5NzMzNzgwOGZkMjMwNjFjYzc2NTE3M2VkMDgyNWQ", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-06-21T16:05:28Z"}, "committer": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-06-21T16:54:06Z"}, "message": "gccrs const folding port: start porting potential_constant_expression_1()\n\nSince this is a huge function, we will start by porting chunks on which it depends.\nThis changeset ports over the below typedefs, structs and functions in addition to the macros:\n\nTypedefs:\n - tsubst_flags_t\n\nStructs:\n - lang_type\n - tree_pair_s\n\nFunctions:\n - cp_expr_loc_or_loc\n - cp_expr_loc_or_input_loc\n - cp_expr_location\n - is_really_empty_class\n - is_empty_class\n - array_type_nelts_top", "tree": {"sha": "95958f702b4ebf47eb7be5d0535b4770a51b8054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95958f702b4ebf47eb7be5d0535b4770a51b8054"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67470f5d6697337808fd23061cc765173ed0825d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67470f5d6697337808fd23061cc765173ed0825d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67470f5d6697337808fd23061cc765173ed0825d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67470f5d6697337808fd23061cc765173ed0825d/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0f11672d760513256997f325da678016d13f677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f11672d760513256997f325da678016d13f677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0f11672d760513256997f325da678016d13f677"}], "stats": {"total": 299, "additions": 299, "deletions": 0}, "files": [{"sha": "a71b584618c9b3e427391eaa38821bd39f79ea76", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67470f5d6697337808fd23061cc765173ed0825d/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67470f5d6697337808fd23061cc765173ed0825d/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=67470f5d6697337808fd23061cc765173ed0825d", "patch": "@@ -760,4 +760,92 @@ rs_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func, void *data,\n #undef WALK_SUBTREE\n }\n \n+// forked from gcc/cp/tree.cc cp_expr_location\n+\n+/* Like EXPR_LOCATION, but also handle some tcc_exceptional that have\n+   locations.  */\n+\n+location_t\n+cp_expr_location (const_tree t_)\n+{\n+  tree t = CONST_CAST_TREE (t_);\n+  if (t == NULL_TREE)\n+    return UNKNOWN_LOCATION;\n+\n+  return EXPR_LOCATION (t);\n+}\n+\n+// forked from gcc/cp/class.cc\n+\n+/* Returns true if TYPE contains no actual data, just various\n+   possible combinations of empty classes.  If IGNORE_VPTR is true,\n+   a vptr doesn't prevent the class from being considered empty.  Typically\n+   we want to ignore the vptr on assignment, and not on initialization.  */\n+\n+bool\n+is_really_empty_class (tree type, bool ignore_vptr)\n+{\n+  if (CLASS_TYPE_P (type))\n+    {\n+      tree field;\n+      tree binfo;\n+      tree base_binfo;\n+      int i;\n+\n+      /* CLASSTYPE_EMPTY_P isn't set properly until the class is actually laid\n+\t out, but we'd like to be able to check this before then.  */\n+      if (COMPLETE_TYPE_P (type) && is_empty_class (type))\n+\treturn true;\n+\n+      if (!ignore_vptr && TYPE_CONTAINS_VPTR_P (type))\n+\treturn false;\n+\n+      for (binfo = TYPE_BINFO (type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+\tif (!is_really_empty_class (BINFO_TYPE (base_binfo), ignore_vptr))\n+\t  return false;\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && !DECL_ARTIFICIAL (field)\n+\t    /* An unnamed bit-field is not a data member.  */\n+\t    && !DECL_UNNAMED_BIT_FIELD (field)\n+\t    && !is_really_empty_class (TREE_TYPE (field), ignore_vptr))\n+\t  return false;\n+      return true;\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    return (integer_zerop (array_type_nelts_top (type))\n+\t    || is_really_empty_class (TREE_TYPE (type), ignore_vptr));\n+  return false;\n+}\n+\n+// forked from gcc/cp/class.cc is_empty_class\n+\n+/* Returns 1 if TYPE contains only padding bytes.  */\n+\n+int\n+is_empty_class (tree type)\n+{\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (!CLASS_TYPE_P (type))\n+    return 0;\n+\n+  return CLASSTYPE_EMPTY_P (type);\n+}\n+\n+// forked from gcc/cp/tree.cc array_type_nelts_top\n+\n+/* Return, as an INTEGER_CST node, the number of elements for TYPE\n+   (which is an ARRAY_TYPE).  This counts only elements of the top\n+   array.  */\n+\n+tree\n+array_type_nelts_top (tree type)\n+{\n+  return fold_build2_loc (input_location, PLUS_EXPR, sizetype,\n+\t\t\t  array_type_nelts (type), size_one_node);\n+}\n+\n } // namespace Rust"}, {"sha": "b5640907e353961d5300b7023ab95a9aa8cc6206", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67470f5d6697337808fd23061cc765173ed0825d/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67470f5d6697337808fd23061cc765173ed0825d/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=67470f5d6697337808fd23061cc765173ed0825d", "patch": "@@ -111,8 +111,186 @@\n    has been duly initialized in its constructor.  */\n #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))\n \n+/* Nonzero if T is a class type.  Zero for template type parameters,\n+   typename types, and so forth.  */\n+#define CLASS_TYPE_P(T)                                                        \\\n+  (RECORD_OR_UNION_CODE_P (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n+\n+/* [class.virtual]\n+\n+   A class that declares or inherits a virtual function is called a\n+   polymorphic class.  */\n+#define TYPE_POLYMORPHIC_P(NODE) (TREE_LANG_FLAG_2 (NODE))\n+\n+/* Nonzero if this class has a virtual function table pointer.  */\n+#define TYPE_CONTAINS_VPTR_P(NODE)                                             \\\n+  (TYPE_POLYMORPHIC_P (NODE) || CLASSTYPE_VBASECLASSES (NODE))\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* We used to have a variant type for lang_type.  Keep the name of the\n+   checking accessor for the sole survivor.  */\n+#define LANG_TYPE_CLASS_CHECK(NODE) (TYPE_LANG_SPECIFIC (NODE))\n+\n+/* Keep these checks in ascending code order.  */\n+#define RECORD_OR_UNION_CODE_P(T) ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n+#define OVERLOAD_TYPE_P(T) (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n+\n+/* Nonzero if this class is \"empty\" in the sense of the C++ ABI.  */\n+#define CLASSTYPE_EMPTY_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->empty_p)\n+\n+// Below macros are copied from gcc/c-family/c-common.h\n+\n+/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n+#define DECL_C_BIT_FIELD(NODE) (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n+#define SET_DECL_C_BIT_FIELD(NODE)                                             \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n+#define CLEAR_DECL_C_BIT_FIELD(NODE)                                           \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n+\n+/* True if the decl was an unnamed bitfield.  */\n+#define DECL_UNNAMED_BIT_FIELD(NODE)                                           \\\n+  (DECL_C_BIT_FIELD (NODE) && !DECL_NAME (NODE))\n+\n+// Above macros are copied from gcc/c-family/c-common.h\n+\n+// forked from gcc/cp/cp-tree.h treee_pair_s\n+\n+struct GTY (()) tree_pair_s\n+{\n+  tree purpose;\n+  tree value;\n+};\n+\n+// forked from gcc/cp/cp-tree.h tree_pair_p\n+\n+typedef tree_pair_s *tree_pair_p;\n+\n+// forked from gcc/cp/cp-tree.h lang_type\n+\n+/* This structure provides additional information above and beyond\n+   what is provide in the ordinary tree_type.  In the past, we used it\n+   for the types of class types, template parameters types, typename\n+   types, and so forth.  However, there can be many (tens to hundreds\n+   of thousands) of template parameter types in a compilation, and\n+   there's no need for this additional information in that case.\n+   Therefore, we now use this data structure only for class types.\n+\n+   In the past, it was thought that there would be relatively few\n+   class types.  However, in the presence of heavy use of templates,\n+   many (i.e., thousands) of classes can easily be generated.\n+   Therefore, we should endeavor to keep the size of this structure to\n+   a minimum.  */\n+struct GTY (()) lang_type\n+{\n+  unsigned char align;\n+\n+  unsigned has_type_conversion : 1;\n+  unsigned has_copy_ctor : 1;\n+  unsigned has_default_ctor : 1;\n+  unsigned const_needs_init : 1;\n+  unsigned ref_needs_init : 1;\n+  unsigned has_const_copy_assign : 1;\n+  unsigned use_template : 2;\n+\n+  unsigned has_mutable : 1;\n+  unsigned com_interface : 1;\n+  unsigned non_pod_class : 1;\n+  unsigned nearly_empty_p : 1;\n+  unsigned user_align : 1;\n+  unsigned has_copy_assign : 1;\n+  unsigned has_new : 1;\n+  unsigned has_array_new : 1;\n+\n+  unsigned gets_delete : 2;\n+  unsigned interface_only : 1;\n+  unsigned interface_unknown : 1;\n+  unsigned contains_empty_class_p : 1;\n+  unsigned anon_aggr : 1;\n+  unsigned non_zero_init : 1;\n+  unsigned empty_p : 1;\n+  /* 32 bits allocated.  */\n+\n+  unsigned vec_new_uses_cookie : 1;\n+  unsigned declared_class : 1;\n+  unsigned diamond_shaped : 1;\n+  unsigned repeated_base : 1;\n+  unsigned being_defined : 1;\n+  unsigned debug_requested : 1;\n+  unsigned fields_readonly : 1;\n+  unsigned ptrmemfunc_flag : 1;\n+\n+  unsigned lazy_default_ctor : 1;\n+  unsigned lazy_copy_ctor : 1;\n+  unsigned lazy_copy_assign : 1;\n+  unsigned lazy_destructor : 1;\n+  unsigned has_const_copy_ctor : 1;\n+  unsigned has_complex_copy_ctor : 1;\n+  unsigned has_complex_copy_assign : 1;\n+  unsigned non_aggregate : 1;\n+\n+  unsigned has_complex_dflt : 1;\n+  unsigned has_list_ctor : 1;\n+  unsigned non_std_layout : 1;\n+  unsigned is_literal : 1;\n+  unsigned lazy_move_ctor : 1;\n+  unsigned lazy_move_assign : 1;\n+  unsigned has_complex_move_ctor : 1;\n+  unsigned has_complex_move_assign : 1;\n+\n+  unsigned has_constexpr_ctor : 1;\n+  unsigned unique_obj_representations : 1;\n+  unsigned unique_obj_representations_set : 1;\n+  bool erroneous : 1;\n+  bool non_pod_aggregate : 1;\n+\n+  /* When adding a flag here, consider whether or not it ought to\n+     apply to a template instance if it applies to the template.  If\n+     so, make sure to copy it in instantiate_class_template!  */\n+\n+  /* There are some bits left to fill out a 32-bit word.  Keep track\n+     of this by updating the size of this bitfield whenever you add or\n+     remove a flag.  */\n+  unsigned dummy : 3;\n+\n+  tree primary_base;\n+  vec<tree_pair_s, va_gc> *vcall_indices;\n+  tree vtables;\n+  tree typeinfo_var;\n+  vec<tree, va_gc> *vbases;\n+  tree as_base;\n+  vec<tree, va_gc> *pure_virtuals;\n+  tree friend_classes;\n+  vec<tree, va_gc> *GTY ((reorder (\"resort_type_member_vec\"))) members;\n+  tree key_method;\n+  tree decl_list;\n+  tree befriending_classes;\n+  /* In a RECORD_TYPE, information specific to Objective-C++, such\n+     as a list of adopted protocols or a pointer to a corresponding\n+     @interface.  See objc/objc-act.h for details.  */\n+  tree objc_info;\n+  /* FIXME reuse another field?  */\n+  tree lambda_expr;\n+};\n+\n namespace Rust {\n \n+// forked from gcc/cp/cp-tree.h tsubst_flags_t\n+\n+/* This type is used for parameters and variables which hold\n+   combinations of the flags in enum tsubst_flags.  */\n+typedef int tsubst_flags_t;\n+\n // forked from gcc/cp/cvt.cc convert_to_void\n //\n // When an expression is used in a void context, its value is discarded and\n@@ -220,13 +398,46 @@ get_fndecl_from_callee (tree fn);\n extern tree\n pointer_offset_expression (tree base_tree, tree index_tree, location_t locus);\n \n+/* A tree node, together with a location, so that we can track locations\n+   (and ranges) during parsing.\n+\n+   The location is redundant for node kinds that have locations,\n+   but not all node kinds do (e.g. constants, and references to\n+   params, locals, etc), so we stash a copy here.  */\n+\n+extern location_t cp_expr_location (const_tree);\n+\n+extern int\n+is_empty_class (tree type);\n+\n+extern tree array_type_nelts_top (tree);\n+\n extern tree\n rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n #define rs_walk_tree(tp, func, data, pset)                                     \\\n   walk_tree_1 (tp, func, data, pset, rs_walk_subtrees)\n #define rs_walk_tree_without_duplicates(tp, func, data)                        \\\n   walk_tree_without_duplicates_1 (tp, func, data, rs_walk_subtrees)\n \n+// forked from gcc/cp/cp-tree.h cp_expr_loc_or_loc\n+\n+inline location_t\n+cp_expr_loc_or_loc (const_tree t, location_t or_loc)\n+{\n+  location_t loc = cp_expr_location (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n+// forked from gcc/cp/cp-tree.h cp_expr_loc_or_input_loc\n+\n+inline location_t\n+cp_expr_loc_or_input_loc (const_tree t)\n+{\n+  return cp_expr_loc_or_loc (t, input_location);\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}