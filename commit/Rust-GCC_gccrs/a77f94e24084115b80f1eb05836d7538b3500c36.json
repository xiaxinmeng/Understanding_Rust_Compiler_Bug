{"sha": "a77f94e24084115b80f1eb05836d7538b3500c36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3Zjk0ZTI0MDg0MTE1YjgwZjFlYjA1ODM2ZDc1MzhiMzUwMGMzNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-12-17T19:08:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-12-17T19:08:14Z"}, "message": "semantics.c (describable_type): New function.\n\ngcc/cp:\n        * semantics.c (describable_type): New function.\n        (finish_decltype_type): Use it for dependent exprs.\n        * cp-tree.h: Declare it.\n        * mangle.c (write_type) [DECLTYPE_TYPE]: Set skip_evaluation.\n        (write_expression): If skip_evaluation, use type stubs.\n        * tree.c (cp_tree_equal): Handle PARM_DECLs from different\n        declarations of a function.\n        * init.c (build_new): Do auto deduction if type is describable.\n        * decl.c (cp_finish_decl): Likewise.\n        * parser.c (cp_parser_omp_for_loop): Likewise.\ngcc/testsuite:\n        * g++.dg/cpp0x/auto6.C: Test more stuff.\n        * g++.dg/cpp0x/auto12.C: New test.\nlibiberty:\n        * cp-demangle.c (d_expression): Handle rvalue stubs too.\n        [DEMANGLE_COMPONENT_CAST]: Update mangling.\n        (d_print_comp): Avoid extra \", \" with empty template argument packs.\n        Remove handling for obsolete T() mangling.\n\nFrom-SVN: r142799", "tree": {"sha": "2fc764010bfc532f00bb2946a496b9d1884f5ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fc764010bfc532f00bb2946a496b9d1884f5ed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a77f94e24084115b80f1eb05836d7538b3500c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77f94e24084115b80f1eb05836d7538b3500c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a77f94e24084115b80f1eb05836d7538b3500c36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77f94e24084115b80f1eb05836d7538b3500c36/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3aea2d1ce29ba8a41d54857de2c5bcf1a4dce254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aea2d1ce29ba8a41d54857de2c5bcf1a4dce254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aea2d1ce29ba8a41d54857de2c5bcf1a4dce254"}], "stats": {"total": 273, "additions": 250, "deletions": 23}, "files": [{"sha": "2c681c0edbc4bdf04c7d2187b9af7a04fce0c4a8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -1,3 +1,16 @@\n+2008-12-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* semantics.c (describable_type): New function.\n+\t(finish_decltype_type): Use it for dependent exprs.\n+\t* cp-tree.h: Declare it.\n+\t* mangle.c (write_type) [DECLTYPE_TYPE]: Set skip_evaluation.\n+\t(write_expression): If skip_evaluation, use type stubs.\n+\t* tree.c (cp_tree_equal): Handle PARM_DECLs from different\n+\tdeclarations of a function.\n+\t* init.c (build_new): Do auto deduction if type is describable.\n+\t* decl.c (cp_finish_decl): Likewise.\n+\t* parser.c (cp_parser_omp_for_loop): Likewise.\n+\n 2008-12-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/35319"}, {"sha": "ff43bc70d74eafdbcc66b0955407d2fbb486cd17", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -4814,6 +4814,7 @@ extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool, bool);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n                                                  bool);\n+extern tree describable_type\t\t\t(tree);\n extern tree finish_decltype_type                (tree, bool);\n extern tree finish_trait_expr\t\t\t(enum cp_trait_kind, tree, tree);\n "}, {"sha": "efc7e2eb8a3835c884d34d9db4c791e36de900f9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -5496,7 +5496,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  TREE_TYPE (decl) = error_mark_node;\n \t  return;\n \t}\n-      else if (!type_dependent_expression_p (init))\n+      else if (describable_type (init))\n \t{\n \t  type = TREE_TYPE (decl) = do_auto_deduction (type, init, auto_node);\n \t  if (type == error_mark_node)"}, {"sha": "abcf858647346b22132bfc0c2548a58fad670154", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -2329,7 +2329,7 @@ build_new (tree placement, tree type, tree nelts, tree init,\n   orig_init = init;\n \n   if (nelts == NULL_TREE && init != void_zero_node && list_length (init) == 1\n-      && !any_type_dependent_arguments_p (init))\n+      && describable_type (TREE_VALUE (init)))\n     {\n       tree auto_node = type_uses_auto (type);\n       if (auto_node)"}, {"sha": "1ec27c1ffcd722ea1e322caa05dd1beeefa14db6", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -1680,7 +1680,9 @@ write_type (tree type)\n                 write_char ('t');\n               else\n                 write_char ('T');\n+\t      ++skip_evaluation;\n               write_expression (DECLTYPE_TYPE_EXPR (type));\n+\t      --skip_evaluation;\n               write_char ('E');\n               break;\n \n@@ -2139,9 +2141,28 @@ write_member_name (tree member)\n static void\n write_expression (tree expr)\n {\n-  enum tree_code code;\n+  enum tree_code code = TREE_CODE (expr);\n \n-  code = TREE_CODE (expr);\n+  /* Inside decltype we can simplify some expressions, since we're only\n+     interested in the type.  */\n+  if (skip_evaluation)\n+    {\n+      tree type = describable_type (expr);\n+      if (type == NULL_TREE)\n+\t;\n+      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t{\n+\t  write_string (\"sT\");\n+\t  write_type (TREE_TYPE (type));\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  write_string (\"sR\");\n+\t  write_type (type);\n+\t  return;\n+\t}\n+    }\n \n   /* Skip NOP_EXPRs.  They can occur when (say) a pointer argument\n      is converted (via qualification conversions) to another"}, {"sha": "79be488028f2a8b1dfe4f80bad1ac31889407c39", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -21159,7 +21159,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t\t\t\t\t    &is_direct_init,\n \t\t\t\t\t\t    &is_non_constant_init);\n \n-\t\t      if (auto_node && !type_dependent_expression_p (init))\n+\t\t      if (auto_node && describable_type (init))\n \t\t\t{\n \t\t\t  TREE_TYPE (decl)\n \t\t\t    = do_auto_deduction (TREE_TYPE (decl), init,"}, {"sha": "d5efb834810734ba5f19b85274cc863f4d22d605", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -4438,12 +4438,79 @@ finish_static_assert (tree condition, tree message, location_t location,\n     }\n }\n \f\n+/* Returns decltype((EXPR)) for cases where we can drop the decltype and\n+   just return the type even though EXPR is a type-dependent expression.\n+   The ABI specifies which cases this applies to, which is a subset of the\n+   possible cases.  */\n+\n+tree\n+describable_type (tree expr)\n+{\n+  tree type = NULL_TREE;\n+\n+  /* processing_template_decl isn't set when we're called from the mangling\n+     code, so bump it now.  */\n+  ++processing_template_decl;\n+  if (! type_dependent_expression_p (expr)\n+      && ! type_unknown_p (expr))\n+    {\n+      type = TREE_TYPE (expr);\n+      if (real_lvalue_p (expr))\n+\ttype = build_reference_type (type);\n+    }\n+  --processing_template_decl;\n+\n+  if (type)\n+    return type;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case FUNCTION_DECL:\n+      /* Named rvalue reference becomes lvalue.  */\n+      type = build_reference_type (non_reference (TREE_TYPE (expr)));\n+      break;\n+\n+    case NEW_EXPR:\n+    case CONST_DECL:\n+    case TEMPLATE_PARM_INDEX:\n+    case CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+      type = TREE_TYPE (expr);\n+      break;\n+\n+    case INDIRECT_REF:\n+      {\n+\ttree ptrtype = describable_type (TREE_OPERAND (expr, 0));\n+\tif (ptrtype && POINTER_TYPE_P (ptrtype))\n+\t  type = build_reference_type (TREE_TYPE (ptrtype));\n+      }\n+      break;\n+\n+    default:\n+      if (TREE_CODE_CLASS (TREE_CODE (expr)) == tcc_constant)\n+\ttype = TREE_TYPE (expr);\n+      break;\n+    }\n+\n+  if (type && type_uses_auto (type))\n+    return NULL_TREE;\n+  else\n+    return type;\n+}\n+\n /* Implements the C++0x decltype keyword. Returns the type of EXPR,\n    suitable for use as a type-specifier.\n \n    ID_EXPRESSION_OR_MEMBER_ACCESS_P is true when EXPR was parsed as an\n    id-expression or a class member access, FALSE when it was parsed as\n    a full expression.  */\n+\n tree\n finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n {\n@@ -4464,6 +4531,29 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n \n   if (type_dependent_expression_p (expr))\n     {\n+      if (id_expression_or_member_access_p)\n+\t{\n+\t  switch (TREE_CODE (expr))\n+\t    {\n+\t    case VAR_DECL:\n+\t    case PARM_DECL:\n+\t    case RESULT_DECL:\n+\t    case FUNCTION_DECL:\n+\t    case CONST_DECL:\n+\t    case TEMPLATE_PARM_INDEX:\n+\t      type = TREE_TYPE (expr);\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\ttype = describable_type (expr);\n+\n+      if (type && !type_uses_auto (type))\n+\treturn type;\n+\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;\n       DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type)"}, {"sha": "1f2c6319ece66c219d820c781178620b4873cdbf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -1857,8 +1857,17 @@ cp_tree_equal (tree t1, tree t2)\n \treturn false;\n       return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n \n-    case VAR_DECL:\n     case PARM_DECL:\n+      /* For comparing uses of parameters in late-specified return types\n+\t with an out-of-class definition of the function.  */\n+      if ((!DECL_CONTEXT (t1) || !DECL_CONTEXT (t2))\n+\t  && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  && DECL_NAME (t1) == DECL_NAME (t2))\n+\treturn true;\n+      else\n+\treturn false;\n+\n+    case VAR_DECL:\n     case CONST_DECL:\n     case FUNCTION_DECL:\n     case TEMPLATE_DECL:"}, {"sha": "11a6a70953142a0ed52c9652c40c85946512d6d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -1,3 +1,8 @@\n+2008-12-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/auto6.C: Test more stuff.\n+\t* g++.dg/cpp0x/auto12.C: New test.\n+\n 2008-12-17  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/38137"}, {"sha": "94652cb5ca88dd51f5a579be11267f59f294f586", "filename": "gcc/testsuite/g++.dg/cpp0x/auto12.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto12.C?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -0,0 +1,52 @@\n+// More auto/decltype mangling tests.\n+// { dg-options \"-std=c++0x\" }\n+\n+template <class T>\n+struct B\n+{\n+  static int i;\n+};\n+\n+int&& x();\n+\n+template <class T>\n+struct A\n+{\n+  static int i;\n+  static int &ir;\n+  static int &&irr;\n+  template <class U>\n+  auto f(U u) -> decltype (u + i);\n+  template <class U>\n+  auto fr(U u) -> decltype (u + ir);\n+  template <class U>\n+  auto frr(U u) -> decltype (u + irr);\n+  template <class U>\n+  auto g(U u) -> decltype (u + sizeof (i));\n+  template <class U>\n+  auto h(U u) -> decltype (u + B<U>::i);\n+  template <class U>\n+  auto j(U u) -> decltype (u + x());\n+};\n+\n+template<class T> template<class U>\n+auto A<T>::f(U u) -> decltype (u + i)\n+{\n+  return u + i;\n+}\n+\n+int main()\n+{\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1fIiEEDTplsTT_sTiES2_\" } }\n+  A<int>().f(1);\n+  // { dg-final { scan-assembler  \"_ZN1AIiE2frIiEEDTplsTT_sTiES2_\" } }\n+  A<int>().fr(1);\n+  // { dg-final { scan-assembler  \"_ZN1AIiE3frrIiEEDTplsTT_sTiES2_\" } }\n+  A<int>().frr(1);\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1gIiEEDTplsTT_sRjES2_\" } }\n+  A<int>().g(1);\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1hIiEEDTplsTT_sr1BIS2_E1iES2_\" } }\n+  A<int>().h(1);\n+  // { dg-final { scan-assembler  \"_ZN1AIiE1jIiEEDTplsTT_sRiES2_\" } }\n+  A<int>().j(1);\n+}"}, {"sha": "7d659c7236a09c541a6910b17462d80507f79ca9", "filename": "gcc/testsuite/g++.dg/cpp0x/auto6.C", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -30,6 +30,12 @@ auto add3(T t, U u) -> decltype (ag(t,u))\n   return ag(t,u);\n }\n \n+template<class T, class U>\n+decltype(*(T*)0+*(U*)0) add4(T t, U u)\n+{\n+  return t+u;\n+}\n+\n template <class T>\n struct A\n {\n@@ -72,13 +78,28 @@ auto k(T t, U u, V v) -> decltype (t.U::template B<V>::MEM)\n   return t.U::template B<V>::MEM;\n }\n \n+// For these two examples we can elide the 'decltype' and just mangle the type.\n+template <class T>\n+auto l(T t) -> decltype (t)\n+{\n+  return t;\n+}\n+\n+template <class T, T u>\n+auto m(T t) -> decltype (u)\n+{\n+  return t;\n+}\n+\n A<int> a, *p;\n \n int main()\n {\n-  // { dg-final { scan-assembler \"_Z3addIidEDTplsTT_sTT0_ES0_S1_\" } }\n+  // { dg-final { scan-assembler  \"_Z3addIidEDTplsTT_sTT0_ES0_S1_\" } }\n   auto i = add(1, 2.0);\n-  // { dg-final { scan-assembler \"_Z4add2IidEDTplcvT_vcvT0_vES0_S1_\" } }\n+  // { dg-final { scan-assembler \"_Z4add4IidEDTplsTT_sTT0_ES0_S1_\" } }\n+  auto i4 = add4(1, 2.0);\n+  // { dg-final { scan-assembler \"_Z4add2IidEDTplsRT_sRT0_ES0_S1_\" } }\n   auto i2 = add2(1, 2.0);\n   // { dg-final { scan-assembler \"_Z4add3IidEDTclL_Z2agEsTT_sTT0_EES0_S1_\" } }\n   auto i3 = add3(1, 2.0);\n@@ -90,4 +111,8 @@ int main()\n   h(a,1.0);\n   // { dg-final { scan-assembler \"_Z1kI1C1AIiE1DEDtdtsTT_srNT0_1BIT1_EE3MEMES4_S5_S7_\" } }\n   k( C(), A<int>(), D() );\n+  // { dg-final { scan-assembler \"_Z1lIiET_S0_\" } }\n+  l(1);\n+  // { dg-final { scan-assembler \"_Z1mIiLi1EET_S0_\" } }\n+  m<int,1>(1);\n }"}, {"sha": "4eaee542b3beacbaead67b4c208a6f76daf74713", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -1,3 +1,10 @@\n+2008-12-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_expression): Handle rvalue stubs too.\n+\t[DEMANGLE_COMPONENT_CAST]: Update mangling.\n+\t(d_print_comp): Avoid extra \", \" with empty template argument packs.\n+\tRemove handling for obsolete T() mangling.\n+\n 2008-12-10  Jason Merrill  <jason@redhat.com>\n \n \t* cp-demangle.c (cplus_demangle_type): Support fixed-point types."}, {"sha": "8ab5729dbb7642d569e164ce04b70a791e2778a6", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a77f94e24084115b80f1eb05836d7538b3500c36/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a77f94e24084115b80f1eb05836d7538b3500c36/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=a77f94e24084115b80f1eb05836d7538b3500c36", "patch": "@@ -2561,7 +2561,8 @@ d_expression (struct d_info *di)\n \t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n \t\t\t\t\t d_template_args (di)));\n     }\n-  else if (peek == 's' && d_peek_next_char (di) == 'T')\n+  else if (peek == 's'\n+\t   && (d_peek_next_char (di) == 'T' || d_peek_next_char (di) == 'R'))\n     {\n       /* Just demangle a parameter placeholder as its type.  */\n       d_advance (di, 2);\n@@ -2608,20 +2609,22 @@ d_expression (struct d_info *di)\n \t  args = op->u.s_extended_operator.args;\n \t  break;\n \tcase DEMANGLE_COMPONENT_CAST:\n-\t  if (d_peek_char (di) == 'v')\n-\t    /* T() encoded as an operand of void.  */\n-\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n-\t\t\t\tcplus_demangle_type (di));\n-\t  else\n-\t    args = 1;\n+\t  args = 1;\n \t  break;\n \t}\n \n       switch (args)\n \t{\n \tcase 1:\n-\t  return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n-\t\t\t      d_expression (di));\n+\t  {\n+\t    struct demangle_component *operand;\n+\t    if (op->type == DEMANGLE_COMPONENT_CAST)\n+\t      operand = d_exprlist (di);\n+\t    else\n+\t      operand = d_expression (di);\n+\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n+\t\t\t\toperand);\n+\t  }\n \tcase 2:\n \t  {\n \t    struct demangle_component *left;\n@@ -3763,8 +3766,14 @@ d_print_comp (struct d_print_info *dpi,\n \td_print_comp (dpi, d_left (dc));\n       if (d_right (dc) != NULL)\n \t{\n+\t  size_t len;\n \t  d_append_string (dpi, \", \");\n+\t  len = dpi->len;\n \t  d_print_comp (dpi, d_right (dc));\n+\t  /* If that didn't print anything (which can happen with empty\n+\t     template argument packs), remove the comma and space.  */\n+\t  if (dpi->len == len)\n+\t    dpi->len -= 2;\n \t}\n       return;\n \n@@ -3800,12 +3809,7 @@ d_print_comp (struct d_print_info *dpi,\n \t  d_print_cast (dpi, d_left (dc));\n \t  d_append_char (dpi, ')');\n \t}\n-      if (d_left (dc)->type == DEMANGLE_COMPONENT_CAST\n-\t  && d_right (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)\n-\t/* type() -- FIXME what about type(multiple,args) */\n-\td_append_string (dpi, \"()\");\n-      else\n-\td_print_subexpr (dpi, d_right (dc));\n+      d_print_subexpr (dpi, d_right (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_BINARY:"}]}