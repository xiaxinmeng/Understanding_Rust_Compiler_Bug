{"sha": "8b496ceb134e0ba2ca5dc0e5287d5811f5937c38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI0OTZjZWIxMzRlMGJhMmNhNWRjMGU1Mjg3ZDU4MTFmNTkzN2MzOA==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2002-05-31T19:41:45Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2002-05-31T19:41:45Z"}, "message": "c-decl.c (struct binding_level): Change int field n_incomplete to tree list incomplete_list.\n\n2002-05-31  Stan Shebs  <shebs@apple.com>\n            Turly O'Connor  <turly@apple.com>\n\n        * c-decl.c (struct binding_level): Change int field n_incomplete\n        to tree list incomplete_list.\n        (clear_binding_level): Init field with NULL.\n        (pushdecl): Add incomplete type to list.\n        (mark_binding_level): Mark the incomplete list.\n        (finish_struct): Scan the incomplete list for types instead\n        of all decls in the current binding level.\n\nCo-Authored-By: Turly O'Connor <turly@apple.com>\n\nFrom-SVN: r54116", "tree": {"sha": "7a1277e5673ba04fd10eba7bcf6240f12c283de7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a1277e5673ba04fd10eba7bcf6240f12c283de7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38/comments", "author": null, "committer": null, "parents": [{"sha": "fe2fe4972bf560dcea866fb29133d6126672594e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2fe4972bf560dcea866fb29133d6126672594e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe2fe4972bf560dcea866fb29133d6126672594e"}], "stats": {"total": 49, "additions": 35, "deletions": 14}, "files": [{"sha": "508cb9a58f93feac41087bb848b646bbbbdde5af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b496ceb134e0ba2ca5dc0e5287d5811f5937c38", "patch": "@@ -1,3 +1,14 @@\n+2002-05-31  Stan Shebs  <shebs@apple.com>\n+\t    Turly O'Connor  <turly@apple.com>\n+\n+\t* c-decl.c (struct binding_level): Change int field n_incomplete\n+\tto tree list incomplete_list.\n+\t(clear_binding_level): Init field with NULL.\n+\t(pushdecl): Add incomplete type to list.\n+\t(mark_binding_level): Mark the incomplete list.\n+\t(finish_struct): Scan the incomplete list for types instead\n+\tof all decls in the current binding level.\n+\n 2002-05-31  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* pa.c (output_millicode_call): Add missing '%' characters."}, {"sha": "7e3309edf8b6680eafc852aea147d670c193bfea", "filename": "gcc/c-decl.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b496ceb134e0ba2ca5dc0e5287d5811f5937c38/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8b496ceb134e0ba2ca5dc0e5287d5811f5937c38", "patch": "@@ -215,9 +215,9 @@ struct binding_level\n     /* Nonzero means make a BLOCK if this level has any subblocks.  */\n     char keep_if_subblocks;\n \n-    /* Number of decls in `names' that have incomplete\n-       structure or union types.  */\n-    int n_incomplete;\n+    /* List of decls in `names' that have incomplete structure or\n+       union types.  */\n+    tree incomplete_list;\n \n     /* A list of decls giving the (reversed) specified order of parms,\n        not including any forward-decls in the parmlist.\n@@ -244,7 +244,7 @@ static struct binding_level *global_binding_level;\n /* Binding level structures are initialized by copying this one.  */\n \n static struct binding_level clear_binding_level\n-  = {NULL, NULL, NULL, NULL, NULL, NULL_BINDING_LEVEL, 0, 0, 0, 0, 0, 0,\n+  = {NULL, NULL, NULL, NULL, NULL, NULL_BINDING_LEVEL, 0, 0, 0, 0, 0, NULL,\n      NULL};\n \n /* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n@@ -2392,7 +2392,7 @@ pushdecl (x)\n \t    b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n \t}\n \n-      /* Keep count of variables in this level with incomplete type.\n+      /* Keep list of variables in this level with incomplete type.\n \t If the input is erroneous, we can have error_mark in the type\n \t slot (e.g. \"f(void a, ...)\") - that doesn't count as an\n \t incomplete type.  */\n@@ -2405,7 +2405,7 @@ pushdecl (x)\n \t    element = TREE_TYPE (element);\n \t  if (TREE_CODE (element) == RECORD_TYPE\n \t      || TREE_CODE (element) == UNION_TYPE)\n-\t    ++b->n_incomplete;\n+\t    b->incomplete_list = tree_cons (NULL_TREE, x, b->incomplete_list);\n \t}\n     }\n \n@@ -2880,6 +2880,7 @@ mark_binding_level (arg)\n       ggc_mark_tree (level->blocks);\n       ggc_mark_tree (level->this_block);\n       ggc_mark_tree (level->parm_order);\n+      ggc_mark_tree (level->incomplete_list);\n     }\n }\n \n@@ -5691,11 +5692,14 @@ finish_struct (t, fieldlist, attributes)\n   /* If this structure or union completes the type of any previous\n      variable declaration, lay it out and output its rtl.  */\n \n-  if (current_binding_level->n_incomplete != 0)\n+  if (current_binding_level->incomplete_list != NULL_TREE)\n     {\n-      tree decl;\n-      for (decl = current_binding_level->names; decl; decl = TREE_CHAIN (decl))\n-\t{\n+      tree prev = NULL_TREE;\n+\n+      for (x = current_binding_level->incomplete_list; x; x = TREE_CHAIN (x))\n+        {\n+\t  tree decl = TREE_VALUE (x);\n+\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TYPE_MAIN_VARIANT (t)\n \t      && TREE_CODE (decl) != TYPE_DECL)\n \t    {\n@@ -5705,8 +5709,11 @@ finish_struct (t, fieldlist, attributes)\n \t      rest_of_decl_compilation (decl, NULL, toplevel, 0);\n \t      if (! toplevel)\n \t\texpand_decl (decl);\n-\t      if (--current_binding_level->n_incomplete == 0)\n-\t\tbreak;\n+\t      /* Unlink X from the incomplete list.  */\n+\t      if (prev)\n+\t\tTREE_CHAIN (prev) = TREE_CHAIN (x);\n+\t      else\n+\t        current_binding_level->incomplete_list = TREE_CHAIN (x);\n \t    }\n \t  else if (!COMPLETE_TYPE_P (TREE_TYPE (decl))\n \t\t   && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n@@ -5725,8 +5732,11 @@ finish_struct (t, fieldlist, attributes)\n \t\t      if (! toplevel)\n \t\t\texpand_decl (decl);\n \t\t    }\n-\t\t  if (--current_binding_level->n_incomplete == 0)\n-\t\t    break;\n+\t\t  /* Unlink X from the incomplete list.  */\n+\t\t  if (prev)\n+\t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n+\t\t  else\n+\t\t    current_binding_level->incomplete_list = TREE_CHAIN (x);\n \t\t}\n \t    }\n \t}"}]}