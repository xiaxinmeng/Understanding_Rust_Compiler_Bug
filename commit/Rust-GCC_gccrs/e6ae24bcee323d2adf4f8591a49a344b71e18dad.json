{"sha": "e6ae24bcee323d2adf4f8591a49a344b71e18dad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZhZTI0YmNlZTMyM2QyYWRmNGY4NTkxYTQ5YTM0NGI3MWUxOGRhZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T17:08:24Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T17:08:24Z"}, "message": "ifcvt.c: Use rtx_insn\n\ngcc/\n\t* ifcvt.c (count_bb_insns): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(cheap_bb_rtx_cost_p): Likewise.\n\t(first_active_insn): Likewise for return type and local \"insn\".\n\t(last_active_insn):  Likewise for return type and locals \"insn\",\n\t\"head\".\n\t(struct noce_if_info): Likewise for fields \"jump\", \"insn_a\",\n\t\"insn_b\".\n\t(end_ifcvt_sequence): Likewise for return type and locals \"insn\",\n\t\"seq\".\n\t(noce_try_move): Likewise for local \"seq\".\n\t(noce_try_store_flag): Likewise.\n\t(noce_try_store_flag_constants): Likewise.\n\t(noce_try_addcc): Likewise.\n\t(noce_try_store_flag_mask): Likewise.\n\t(noce_try_cmove): Likewise.\n\t(noce_try_minmax): Likewise.\n\t(noce_try_abs): Likewise.\n\t(noce_try_sign_mask): Likewise.\n\t(noce_try_bitop): Likewise.\n\t(noce_can_store_speculate_p): Likewise for local \"insn\".\n\t(noce_process_if_block): Likewise for locals \"insn_a\", \"insn_b\",\n\tseq\".\n\t(check_cond_move_block): Likewise for local \"insn\".\n\t(cond_move_convert_if_block): Likewise.\n\t(cond_move_process_if_block): Likewise for locals \"seq\",\n\t\"loc_insn\".\n\t(noce_find_if_block): Likewise for local \"jump\".\n\t(merge_if_block): Likewise for local \"last\".\n\t(block_jumps_and_fallthru_p): Likewise for locals \"insn\", \"end\".\n\t(find_cond_trap): Likewise for locals \"trap\", \"jump\", \"newjump\".\n\t(block_has_only_trap): Likewise for return type and local \"trap\".\n\t(find_if_case_1): Likewise for local \"jump\".\n\t(dead_or_predicable): Likewise for locals \"head\", \"end\", \"jump\",\n\t\"insn\".\n\nFrom-SVN: r214335", "tree": {"sha": "19860f9d0a83d43b95605eaf297098b71da98e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19860f9d0a83d43b95605eaf297098b71da98e91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6ae24bcee323d2adf4f8591a49a344b71e18dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ae24bcee323d2adf4f8591a49a344b71e18dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ae24bcee323d2adf4f8591a49a344b71e18dad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ae24bcee323d2adf4f8591a49a344b71e18dad/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da76d746a2652ecac3576986c206d2809333f1b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da76d746a2652ecac3576986c206d2809333f1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da76d746a2652ecac3576986c206d2809333f1b4"}], "stats": {"total": 174, "additions": 116, "deletions": 58}, "files": [{"sha": "c2870853f00e77f03f38902d68b49f5612d682ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ae24bcee323d2adf4f8591a49a344b71e18dad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ae24bcee323d2adf4f8591a49a344b71e18dad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6ae24bcee323d2adf4f8591a49a344b71e18dad", "patch": "@@ -1,3 +1,41 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ifcvt.c (count_bb_insns): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(cheap_bb_rtx_cost_p): Likewise.\n+\t(first_active_insn): Likewise for return type and local \"insn\".\n+\t(last_active_insn):  Likewise for return type and locals \"insn\",\n+\t\"head\".\n+\t(struct noce_if_info): Likewise for fields \"jump\", \"insn_a\",\n+\t\"insn_b\".\n+\t(end_ifcvt_sequence): Likewise for return type and locals \"insn\",\n+\t\"seq\".\n+\t(noce_try_move): Likewise for local \"seq\".\n+\t(noce_try_store_flag): Likewise.\n+\t(noce_try_store_flag_constants): Likewise.\n+\t(noce_try_addcc): Likewise.\n+\t(noce_try_store_flag_mask): Likewise.\n+\t(noce_try_cmove): Likewise.\n+\t(noce_try_minmax): Likewise.\n+\t(noce_try_abs): Likewise.\n+\t(noce_try_sign_mask): Likewise.\n+\t(noce_try_bitop): Likewise.\n+\t(noce_can_store_speculate_p): Likewise for local \"insn\".\n+\t(noce_process_if_block): Likewise for locals \"insn_a\", \"insn_b\",\n+\tseq\".\n+\t(check_cond_move_block): Likewise for local \"insn\".\n+\t(cond_move_convert_if_block): Likewise.\n+\t(cond_move_process_if_block): Likewise for locals \"seq\",\n+\t\"loc_insn\".\n+\t(noce_find_if_block): Likewise for local \"jump\".\n+\t(merge_if_block): Likewise for local \"last\".\n+\t(block_jumps_and_fallthru_p): Likewise for locals \"insn\", \"end\".\n+\t(find_cond_trap): Likewise for locals \"trap\", \"jump\", \"newjump\".\n+\t(block_has_only_trap): Likewise for return type and local \"trap\".\n+\t(find_if_case_1): Likewise for local \"jump\".\n+\t(dead_or_predicable): Likewise for locals \"head\", \"end\", \"jump\",\n+\t\"insn\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* hw-doloop.h (struct hwloop_info_d): Strengthen fields"}, {"sha": "4034b78682a06aab0f2c94d4b446cd8facf6c147", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 78, "deletions": 58, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ae24bcee323d2adf4f8591a49a344b71e18dad/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ae24bcee323d2adf4f8591a49a344b71e18dad/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e6ae24bcee323d2adf4f8591a49a344b71e18dad", "patch": "@@ -85,8 +85,8 @@ static int cond_exec_changed_p;\n /* Forward references.  */\n static int count_bb_insns (const_basic_block);\n static bool cheap_bb_rtx_cost_p (const_basic_block, int, int);\n-static rtx first_active_insn (basic_block);\n-static rtx last_active_insn (basic_block, int);\n+static rtx_insn *first_active_insn (basic_block);\n+static rtx_insn *last_active_insn (basic_block, int);\n static rtx find_active_insn_before (basic_block, rtx);\n static rtx find_active_insn_after (basic_block, rtx);\n static basic_block block_fallthru (basic_block);\n@@ -105,15 +105,15 @@ static int find_if_case_2 (basic_block, edge, edge);\n static int dead_or_predicable (basic_block, basic_block, basic_block,\n \t\t\t       edge, int);\n static void noce_emit_move_insn (rtx, rtx);\n-static rtx block_has_only_trap (basic_block);\n+static rtx_insn *block_has_only_trap (basic_block);\n \f\n /* Count the number of non-jump active insns in BB.  */\n \n static int\n count_bb_insns (const_basic_block bb)\n {\n   int count = 0;\n-  rtx insn = BB_HEAD (bb);\n+  rtx_insn *insn = BB_HEAD (bb);\n \n   while (1)\n     {\n@@ -140,7 +140,7 @@ static bool\n cheap_bb_rtx_cost_p (const_basic_block bb, int scale, int max_cost)\n {\n   int count = 0;\n-  rtx insn = BB_HEAD (bb);\n+  rtx_insn *insn = BB_HEAD (bb);\n   bool speed = optimize_bb_for_speed_p (bb);\n \n   /* Set scale to REG_BR_PROB_BASE to void the identical scaling\n@@ -203,38 +203,38 @@ cheap_bb_rtx_cost_p (const_basic_block bb, int scale, int max_cost)\n \n /* Return the first non-jump active insn in the basic block.  */\n \n-static rtx\n+static rtx_insn *\n first_active_insn (basic_block bb)\n {\n-  rtx insn = BB_HEAD (bb);\n+  rtx_insn *insn = BB_HEAD (bb);\n \n   if (LABEL_P (insn))\n     {\n       if (insn == BB_END (bb))\n-\treturn NULL_RTX;\n+\treturn NULL;\n       insn = NEXT_INSN (insn);\n     }\n \n   while (NOTE_P (insn) || DEBUG_INSN_P (insn))\n     {\n       if (insn == BB_END (bb))\n-\treturn NULL_RTX;\n+\treturn NULL;\n       insn = NEXT_INSN (insn);\n     }\n \n   if (JUMP_P (insn))\n-    return NULL_RTX;\n+    return NULL;\n \n   return insn;\n }\n \n /* Return the last non-jump active (non-jump) insn in the basic block.  */\n \n-static rtx\n+static rtx_insn *\n last_active_insn (basic_block bb, int skip_use_p)\n {\n-  rtx insn = BB_END (bb);\n-  rtx head = BB_HEAD (bb);\n+  rtx_insn *insn = BB_END (bb);\n+  rtx_insn *head = BB_HEAD (bb);\n \n   while (NOTE_P (insn)\n \t || JUMP_P (insn)\n@@ -244,12 +244,12 @@ last_active_insn (basic_block bb, int skip_use_p)\n \t     && GET_CODE (PATTERN (insn)) == USE))\n     {\n       if (insn == head)\n-\treturn NULL_RTX;\n+\treturn NULL;\n       insn = PREV_INSN (insn);\n     }\n \n   if (LABEL_P (insn))\n-    return NULL_RTX;\n+    return NULL;\n \n   return insn;\n }\n@@ -777,7 +777,7 @@ struct noce_if_info\n   basic_block test_bb, then_bb, else_bb, join_bb;\n \n   /* The jump that ends TEST_BB.  */\n-  rtx jump;\n+  rtx_insn *jump;\n \n   /* The jump condition.  */\n   rtx cond;\n@@ -791,7 +791,7 @@ struct noce_if_info\n      COND_EARLIEST, or NULL_RTX.  In the former case, the insn\n      operands are still valid, as if INSN_B was moved down below\n      the jump.  */\n-  rtx insn_a, insn_b;\n+  rtx_insn *insn_a, *insn_b;\n \n   /* The SET_SRC of INSN_A and INSN_B.  */\n   rtx a, b;\n@@ -1004,11 +1004,11 @@ noce_emit_move_insn (rtx x, rtx y)\n    that are instructions are unshared, recognizable non-jump insns.\n    On failure, this function returns a NULL_RTX.  */\n \n-static rtx\n+static rtx_insn *\n end_ifcvt_sequence (struct noce_if_info *if_info)\n {\n-  rtx insn;\n-  rtx seq = get_insns ();\n+  rtx_insn *insn;\n+  rtx_insn *seq = get_insns ();\n \n   set_used_flags (if_info->x);\n   set_used_flags (if_info->cond);\n@@ -1024,7 +1024,7 @@ end_ifcvt_sequence (struct noce_if_info *if_info)\n   for (insn = seq; insn; insn = NEXT_INSN (insn))\n     if (JUMP_P (insn)\n \t|| recog_memoized (insn) == -1)\n-      return NULL_RTX;\n+      return NULL;\n \n   return seq;\n }\n@@ -1037,7 +1037,8 @@ noce_try_move (struct noce_if_info *if_info)\n {\n   rtx cond = if_info->cond;\n   enum rtx_code code = GET_CODE (cond);\n-  rtx y, seq;\n+  rtx y;\n+  rtx_insn *seq;\n \n   if (code != NE && code != EQ)\n     return FALSE;\n@@ -1087,7 +1088,8 @@ static int\n noce_try_store_flag (struct noce_if_info *if_info)\n {\n   int reversep;\n-  rtx target, seq;\n+  rtx target;\n+  rtx_insn *seq;\n \n   if (CONST_INT_P (if_info->b)\n       && INTVAL (if_info->b) == STORE_FLAG_VALUE\n@@ -1130,7 +1132,8 @@ noce_try_store_flag (struct noce_if_info *if_info)\n static int\n noce_try_store_flag_constants (struct noce_if_info *if_info)\n {\n-  rtx target, seq;\n+  rtx target;\n+  rtx_insn *seq;\n   int reversep;\n   HOST_WIDE_INT itrue, ifalse, diff, tmp;\n   int normalize, can_reverse;\n@@ -1260,7 +1263,8 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n static int\n noce_try_addcc (struct noce_if_info *if_info)\n {\n-  rtx target, seq;\n+  rtx target;\n+  rtx_insn *seq;\n   int subtract, normalize;\n \n   if (GET_CODE (if_info->a) == PLUS\n@@ -1350,7 +1354,8 @@ noce_try_addcc (struct noce_if_info *if_info)\n static int\n noce_try_store_flag_mask (struct noce_if_info *if_info)\n {\n-  rtx target, seq;\n+  rtx target;\n+  rtx_insn *seq;\n   int reversep;\n \n   reversep = 0;\n@@ -1510,7 +1515,8 @@ static int\n noce_try_cmove (struct noce_if_info *if_info)\n {\n   enum rtx_code code;\n-  rtx target, seq;\n+  rtx target;\n+  rtx_insn *seq;\n \n   if ((CONSTANT_P (if_info->a) || register_operand (if_info->a, VOIDmode))\n       && (CONSTANT_P (if_info->b) || register_operand (if_info->b, VOIDmode)))\n@@ -1900,7 +1906,8 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n static int\n noce_try_minmax (struct noce_if_info *if_info)\n {\n-  rtx cond, earliest, target, seq;\n+  rtx cond, earliest, target;\n+  rtx_insn *seq;\n   enum rtx_code code, op;\n   int unsignedp;\n \n@@ -1995,7 +2002,8 @@ noce_try_minmax (struct noce_if_info *if_info)\n static int\n noce_try_abs (struct noce_if_info *if_info)\n {\n-  rtx cond, earliest, target, seq, a, b, c;\n+  rtx cond, earliest, target, a, b, c;\n+  rtx_insn *seq;\n   int negate;\n   bool one_cmpl = false;\n \n@@ -2140,7 +2148,8 @@ noce_try_abs (struct noce_if_info *if_info)\n static int\n noce_try_sign_mask (struct noce_if_info *if_info)\n {\n-  rtx cond, t, m, c, seq;\n+  rtx cond, t, m, c;\n+  rtx_insn *seq;\n   enum machine_mode mode;\n   enum rtx_code code;\n   bool t_unconditional;\n@@ -2218,7 +2227,8 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n static int\n noce_try_bitop (struct noce_if_info *if_info)\n {\n-  rtx cond, x, a, result, seq;\n+  rtx cond, x, a, result;\n+  rtx_insn *seq;\n   enum machine_mode mode;\n   enum rtx_code code;\n   int bitnum;\n@@ -2453,7 +2463,7 @@ noce_can_store_speculate_p (basic_block top_bb, const_rtx mem)\n        dominator != NULL;\n        dominator = get_immediate_dominator (CDI_POST_DOMINATORS, dominator))\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       FOR_BB_INSNS (dominator, insn)\n \t{\n@@ -2490,7 +2500,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n   basic_block join_bb = if_info->join_bb;\t/* JOIN */\n   rtx jump = if_info->jump;\n   rtx cond = if_info->cond;\n-  rtx insn_a, insn_b;\n+  rtx_insn *insn_a, *insn_b;\n   rtx set_a, set_b;\n   rtx orig_x, x, a, b;\n \n@@ -2557,7 +2567,10 @@ noce_process_if_block (struct noce_if_info *if_info)\n \t  || reg_overlap_mentioned_p (x, cond)\n \t  || reg_overlap_mentioned_p (x, a)\n \t  || modified_between_p (x, insn_b, jump))\n-\tinsn_b = set_b = NULL_RTX;\n+\t{\n+\t  insn_b = NULL;\n+\t  set_b = NULL_RTX;\n+\t}\n     }\n \n   /* If x has side effects then only the if-then-else form is safe to\n@@ -2626,7 +2639,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n \t  if ((note = find_reg_note (insn_b, REG_EQUAL, NULL_RTX)) != 0)\n \t    remove_note (insn_b, note);\n \n-\t  insn_b = NULL_RTX;\n+\t  insn_b = NULL;\n \t}\n       /* If we have \"x = b; if (...) x = a;\", and x has side-effects, then\n \t x must be executed twice.  */\n@@ -2693,7 +2706,8 @@ noce_process_if_block (struct noce_if_info *if_info)\n \n   if (!else_bb && set_b)\n     {\n-      insn_b = set_b = NULL_RTX;\n+      insn_b = NULL;\n+      set_b = NULL_RTX;\n       b = orig_x;\n       goto retry;\n     }\n@@ -2705,7 +2719,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n   /* If we used a temporary, fix it up now.  */\n   if (orig_x != x)\n     {\n-      rtx seq;\n+      rtx_insn *seq;\n \n       start_sequence ();\n       noce_emit_move_insn (orig_x, x);\n@@ -2755,7 +2769,7 @@ check_cond_move_block (basic_block bb,\n \t\t       vec<rtx> *regs,\n \t\t       rtx cond)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n    /* We can only handle simple jumps at the end of the basic block.\n       It is almost impossible to update the CFG otherwise.  */\n@@ -2836,7 +2850,8 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n \t\t\t    bool else_block_p)\n {\n   enum rtx_code code;\n-  rtx insn, cond_arg0, cond_arg1;\n+  rtx_insn *insn;\n+  rtx cond_arg0, cond_arg1;\n \n   code = GET_CODE (cond);\n   cond_arg0 = XEXP (cond, 0);\n@@ -2900,7 +2915,7 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   basic_block join_bb = if_info->join_bb;\n   rtx jump = if_info->jump;\n   rtx cond = if_info->cond;\n-  rtx seq, loc_insn;\n+  rtx_insn *seq, *loc_insn;\n   rtx reg;\n   int c;\n   vec<rtx> then_regs = vNULL;\n@@ -3027,7 +3042,8 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n {\n   basic_block then_bb, else_bb, join_bb;\n   bool then_else_reversed = false;\n-  rtx jump, cond;\n+  rtx_insn *jump;\n+  rtx cond;\n   rtx cond_earliest;\n   struct noce_if_info if_info;\n \n@@ -3223,7 +3239,7 @@ merge_if_block (struct ce_if_block * ce_info)\n \n   if (! join_bb)\n     {\n-      rtx last = BB_END (combo_bb);\n+      rtx_insn *last = BB_END (combo_bb);\n \n       /* The outgoing edge for the current COMBO block should already\n \t be correct.  Verify this.  */\n@@ -3378,8 +3394,8 @@ block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n   edge cur_edge;\n   int fallthru_p = FALSE;\n   int jump_p = FALSE;\n-  rtx insn;\n-  rtx end;\n+  rtx_insn *insn;\n+  rtx_insn *end;\n   int n_insns = 0;\n   edge_iterator ei;\n \n@@ -3681,7 +3697,8 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   basic_block other_bb, trap_bb;\n-  rtx trap, jump, cond, cond_earliest, seq;\n+  rtx_insn *trap, *jump;\n+  rtx cond, cond_earliest, seq;\n   enum rtx_code code;\n \n   /* Locate the block with the trap instruction.  */\n@@ -3751,7 +3768,8 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n     single_succ_edge (test_bb)->flags |= EDGE_FALLTHRU;\n   else if (trap_bb == then_bb)\n     {\n-      rtx lab, newjump;\n+      rtx lab;\n+      rtx_insn *newjump;\n \n       lab = JUMP_LABEL (jump);\n       newjump = emit_jump_insn_after (gen_jump (lab), jump);\n@@ -3774,25 +3792,25 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n /* Subroutine of find_cond_trap: if BB contains only a trap insn,\n    return it.  */\n \n-static rtx\n+static rtx_insn *\n block_has_only_trap (basic_block bb)\n {\n-  rtx trap;\n+  rtx_insn *trap;\n \n   /* We're not the exit block.  */\n   if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-    return NULL_RTX;\n+    return NULL;\n \n   /* The block must have no successors.  */\n   if (EDGE_COUNT (bb->succs) > 0)\n-    return NULL_RTX;\n+    return NULL;\n \n   /* The only instruction in the THEN block must be the trap.  */\n   trap = first_active_insn (bb);\n   if (! (trap == BB_END (bb)\n \t && GET_CODE (PATTERN (trap)) == TRAP_IF\n          && TRAP_CONDITION (PATTERN (trap)) == const_true_rtx))\n-    return NULL_RTX;\n+    return NULL;\n \n   return trap;\n }\n@@ -3940,7 +3958,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   if (else_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n-      rtx jump = BB_END (else_edge->src);\n+      rtx_insn *jump = BB_END (else_edge->src);\n       gcc_assert (JUMP_P (jump));\n       else_target = JUMP_LABEL (jump);\n     }\n@@ -4115,7 +4133,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t\t    basic_block other_bb, edge dest_edge, int reversep)\n {\n   basic_block new_dest = dest_edge->dest;\n-  rtx head, end, jump, earliest = NULL_RTX, old_dest;\n+  rtx_insn *head, *end, *jump;\n+  rtx earliest = NULL_RTX, old_dest;\n   bitmap merge_set = NULL;\n   /* Number of pending changes.  */\n   int n_validated_changes = 0;\n@@ -4145,7 +4164,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n     {\n       if (head == end)\n \t{\n-\t  head = end = NULL_RTX;\n+\t  head = end = NULL;\n \t  goto no_body;\n \t}\n       head = NEXT_INSN (head);\n@@ -4159,7 +4178,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \treturn FALSE;\n       if (head == end)\n \t{\n-\t  head = end = NULL_RTX;\n+\t  head = end = NULL;\n \t  goto no_body;\n \t}\n       end = PREV_INSN (end);\n@@ -4171,7 +4190,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n      can lead to one of the paths of the branch having wrong unwind info.  */\n   if (epilogue_completed)\n     {\n-      rtx insn = head;\n+      rtx_insn *insn = head;\n       while (1)\n \t{\n \t  if (INSN_P (insn) && RTX_FRAME_RELATED_P (insn))\n@@ -4232,7 +4251,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   /* Try the NCE path if the CE path did not result in any changes.  */\n   if (n_validated_changes == 0)\n     {\n-      rtx cond, insn;\n+      rtx cond;\n+      rtx_insn *insn;\n       regset live;\n       bool success;\n \n@@ -4369,7 +4389,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   /* Move the insns out of MERGE_BB to before the branch.  */\n   if (head != NULL)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       if (end == BB_END (merge_bb))\n \tSET_BB_END (merge_bb) = PREV_INSN (head);"}]}