{"sha": "6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZiNWZhM2NiYzBkNzhjZjlmNGZmN2NhYzVlMWQ4YWYxZTY1YzViYg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-06-11T18:02:15Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-06-11T18:02:15Z"}, "message": "Merge dataflow branch into mainline\n\nFrom-SVN: r125624", "tree": {"sha": "fdb9e9f8a0700a2713dc690fed1a2cf20dae8392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb9e9f8a0700a2713dc690fed1a2cf20dae8392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/comments", "author": null, "committer": null, "parents": [{"sha": "a91d32a4a65d54cccf639a1541417e39cb7b7deb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a91d32a4a65d54cccf639a1541417e39cb7b7deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a91d32a4a65d54cccf639a1541417e39cb7b7deb"}], "stats": {"total": 37277, "additions": 24135, "deletions": 13142}, "files": [{"sha": "873677ddd6011f38e38556d465c766329adbe899", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -195,6 +195,7 @@ build machinery (*.in)\tDJ Delorie\t\tdj@redhat.com\n build machinery (*.in)\tNathanael Nerode\tneroden@gcc.gnu.org\n build machinery (*.in)\tAlexandre Oliva\t\taoliva@redhat.com\n dataflow\t\tPaolo Bonzini\t\tbonzini@gnu.org\n+dataflow\t\tDaniel Berlin\t\tdberlin@dberlin.org\n docs co-maintainer\tGerald Pfeifer\t\tgerald@pfeifer.com\n docs co-maintainer\tJoseph Myers\t\tjsm@polyomino.org.uk\n predict.def\t\tJan Hubicka\t\tjh@suse.cz"}, {"sha": "2b2134c34b9092056cde93c745872527c8dba17f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,3 +1,7 @@\n+2007-06-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Merge dataflow-branch into mainline (see ChangeLog.dataflow)\n+\n 2007-06-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (\"*movtf_internal): Penalize moves to and"}, {"sha": "936caa09193bde27454512029670af6163511507", "filename": "gcc/ChangeLog.dataflow", "status": "added", "additions": 4481, "deletions": 0, "changes": 4481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2FChangeLog.dataflow", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2FChangeLog.dataflow", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.dataflow?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "2c87de75185b303dc45cd7ac7e3de986755b1b40", "filename": "gcc/Makefile.in", "status": "modified", "additions": 89, "deletions": 57, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -749,7 +749,7 @@ EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACH\n OPTABS_H = optabs.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)\n RESOURCE_H = resource.h hard-reg-set.h\n-SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H)\n+SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H)\n INTEGRATE_H = integrate.h $(VARRAY_H)\n CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)\n CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H) vecprim.h double-int.h\n@@ -758,6 +758,7 @@ IPA_REFERENCE_H = ipa-reference.h bitmap.h $(TREE_H)\n IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)\n CGRAPH_H = cgraph.h $(TREE_H)\n DF_H = df.h bitmap.h $(BASIC_BLOCK_H) alloc-pool.h\n+RESOURCE_H = resource.h hard-reg-set.h $(DF_H)\n DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h\n GGC_H = ggc.h gtype-desc.h\n@@ -790,6 +791,7 @@ TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n TREE_INLINE_H = tree-inline.h $(VARRAY_H) pointer-set.h\n REAL_H = real.h $(MACHMODE_H)\n+DBGCNT_H = dbgcnt.h dbgcnt.def\n EBIMAP_H = ebitmap.h sbitmap.h\n \n #\f\n@@ -953,6 +955,7 @@ OBJS-common = \\\n \t$(GGC) \\\n \talias.o \\\n \talloc-pool.o \\\n+\tauto-inc-dec.o \\\n \tbb-reorder.o \\\n \tbitmap.o \\\n \tbt-load.o \\\n@@ -977,6 +980,8 @@ OBJS-common = \\\n \tcse.o \\\n \tcselib.o \\\n \tdbxout.o \\\n+\tdbgcnt.o \\\n+\tdce.o \\\n \tddg.o \\\n \tdebug.o \\\n \tdf-core.o \\\n@@ -988,6 +993,7 @@ OBJS-common = \\\n \tdominance.o \\\n \tdomwalk.o \\\n \tdouble-int.o \\\n+\tdse.o \\\n \tdwarf2asm.o \\\n \tdwarf2out.o \\\n \tebitmap.o \\\n@@ -998,7 +1004,6 @@ OBJS-common = \\\n \texpmed.o \\\n \texpr.o \\\n \tfinal.o \\\n-\tflow.o \\\n \tfold-const.o \\\n \tfunction.o \\\n \tfwprop.o \\\n@@ -1014,6 +1019,7 @@ OBJS-common = \\\n \thaifa-sched.o \\\n \thooks.o \\\n \tifcvt.o \\\n+\tinit-regs.o \\\n \tintegrate.o \\\n \tintl.o \\\n \tjump.o \\\n@@ -1055,6 +1061,7 @@ OBJS-common = \\\n \tregclass.o \\\n \tregmove.o \\\n \tregrename.o \\\n+\tregstat.o \\\n \treload.o \\\n \treload1.o \\\n \treorg.o \\\n@@ -1073,6 +1080,7 @@ OBJS-common = \\\n \tsee.o \\\n \tsimplify-rtx.o \\\n \tsreal.o \\\n+\tstack-ptr-mod.o \\\n \tstmt.o \\\n \tstor-layout.o \\\n \tstringpool.o \\\n@@ -2016,7 +2024,8 @@ tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    tree-ssa-propagate.h\n rtl-factoring.o : rtl-factoring.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    coretypes.h $(TM_H) $(BASIC_BLOCK_H) $(GGC_H) $(REGS_H) $(PARAMS_H) $(EXPR_H) \\\n-   addresses.h $(TM_P_H) tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) output.h\n+   addresses.h $(TM_P_H) tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) output.h \\\n+   $(DF_H)\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H) except.h tree-pass.h $(FLAGS_H) langhooks.h \\\n@@ -2227,7 +2236,7 @@ diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(RTL_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n-   $(FLAGS_H) $(PARAMS_H) tree-pass.h\n+   $(FLAGS_H) $(PARAMS_H) tree-pass.h $(DBGCNT_H)\n opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h intl.h\n targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n@@ -2257,7 +2266,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \\\n    $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n-   gt-passes.h $(PREDICT_H)\n+   gt-passes.h $(DF_H) $(PREDICT_H)\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n \n@@ -2276,7 +2285,8 @@ print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(BCONFIG_H) $(REAL_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \\\n-   $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H)\n+   $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H) \\\n+   $(DF_H)\n \n varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n@@ -2288,7 +2298,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n    gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \\\n-   tree-pass.h vecprim.h\n+   tree-pass.h $(DF_H) timevar.h vecprim.h\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) insn-config.h hard-reg-set.h $(EXPR_H) \\\n    libfuncs.h except.h $(RECOG_H) toplev.h output.h $(GGC_H) $(TM_P_H) \\\n@@ -2306,7 +2316,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h reload.h \\\n    $(GGC_H) langhooks.h intl.h $(TM_P_H) $(REAL_H) $(TARGET_H) \\\n    tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \\\n-   tree-pass.h\n+   tree-pass.h $(DF_H)\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n    langhooks.h $(GGC_H) gt-dojump.h\n@@ -2319,10 +2329,10 @@ builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \\\n    libfuncs.h $(REGS_H) toplev.h output.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_P_H) \\\n-   $(CGRAPH_H) except.h sbitmap.h\n+   $(CGRAPH_H) except.h sbitmap.h $(DBGCNT_H)\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(REAL_H) \\\n-   toplev.h $(TM_P_H) langhooks.h $(TARGET_H)\n+   toplev.h $(TM_P_H) langhooks.h $(DF_H) $(TARGET_H)\n explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n    toplev.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h \\\n@@ -2358,7 +2368,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \\\n    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h tree-pass.h gt-emit-rtl.h \\\n-   $(REAL_H)\n+   $(REAL_H) $(DF_H)\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    toplev.h $(TM_P_H) $(REAL_H)\n dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(TREE_H) \\\n@@ -2367,7 +2377,7 @@ integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \\\n    $(EXPR_H) $(REAL_H) $(REGS_H) intl.h $(FUNCTION_H) output.h $(RECOG_H) \\\n    except.h toplev.h $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h \\\n-   gt-integrate.h $(GGC_H) tree-pass.h\n+   gt-integrate.h $(GGC_H) tree-pass.h $(DF_H)\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) \\\n    $(REAL_H) except.h $(FUNCTION_H) tree-pass.h $(DIAGNOSTIC_H) \\\n@@ -2441,7 +2451,15 @@ cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h $(FUNCTION_H) $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\\n-   except.h $(TARGET_H) $(PARAMS_H) rtlhooks-def.h tree-pass.h $(REAL_H)\n+   except.h $(TARGET_H) $(PARAMS_H) rtlhooks-def.h tree-pass.h $(REAL_H) \\\n+    $(DF_H) $(DBGCNT_H)\n+dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(DF_H) cselib.h \\\n+   $(DBGCNT_H) dce.h timevar.h tree-pass.h $(DBGCNT_H)\n+dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) \\\n+   $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) timevar.h tree-pass.h \\\n+   alloc-pool.h $(ALIAS_H) dse.h\n fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    toplev.h insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \\\n    output.h $(DF_H) alloc-pool.h $(TIMEVAR_H) tree-pass.h\n@@ -2455,17 +2473,17 @@ gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h \\\n    $(TM_P_H) $(PARAMS_H) except.h gt-gcse.h $(TREE_H) cselib.h $(TIMEVAR_H) \\\n-   intl.h $(OBSTACK_H) tree-pass.h\n+   intl.h $(OBSTACK_H) tree-pass.h $(DF_H) $(DBGCNT_H)\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(REGS_H) $(FLAGS_H) output.h $(RESOURCE_H) \\\n+   coretypes.h $(TM_H) $(REGS_H) $(FLAGS_H) output.h $(RESOURCE_H) $(DF_H) \\\n    $(FUNCTION_H) toplev.h $(INSN_ATTR_H) except.h $(PARAMS_H) $(TM_P_H)\n lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(RECOG_H) \\\n    $(BASIC_BLOCK_H) $(TM_P_H) $(FUNCTION_H) output.h $(REAL_H)\n mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(INSN_ATTR_H) $(RECOG_H) $(BASIC_BLOCK_H) $(TM_P_H) $(FUNCTION_H) \\\n-   output.h tree-pass.h $(TIMEVAR_H) $(REAL_H)\n+   output.h tree-pass.h $(TIMEVAR_H) $(REAL_H) $(DF_H)\n tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n     coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \\\n@@ -2496,11 +2514,14 @@ df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) \\\n-   $(FLAGS_H) output.h vecprim.h\n+   $(FLAGS_H) output.h except.h dce.h vecprim.h\n df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) \\\n    $(FLAGS_H) $(TARGET_H) $(TARGET_DEF_H) $(TREE_H) output.h tree-pass.h\n+regstat.o : regstat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(TM_P_H) $(FLAGS_H) $(REGS_H) output.h except.h hard-reg-set.h \\\n+   $(BASIC_BLOCK_H) $(TIMEVAR_H) $(DF_H)\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n@@ -2522,14 +2543,14 @@ loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n    toplev.h $(CFGLOOP_H) output.h $(PARAMS_H) $(TARGET_H)\n alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)\n-flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \\\n-   hard-reg-set.h output.h toplev.h $(RECOG_H) $(FUNCTION_H) except.h \\\n-   $(EXPR_H) $(TM_P_H) $(OBSTACK_H) $(SPLAY_TREE_H) $(TIMEVAR_H) tree-pass.h\n+auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) insn-config.h \\\n+   $(REGS_H) $(FLAGS_H) output.h $(FUNCTION_H) except.h toplev.h $(RECOG_H) \\\n+   $(EXPR_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    $(REGS_H) hard-reg-set.h output.h toplev.h $(FUNCTION_H) except.h $(GGC_H) \\\n-   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H) \\\n-   $(CFGLOOP_H)\n+   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h \\\n+   $(HASHTAB_H) $(DF_H) $(CFGLOOP_H)\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(CFGLOOP_H)\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2541,7 +2562,7 @@ cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h toplev.h $(FUNCTION_H) except.h $(TM_P_H) insn-config.h $(EXPR_H) \\\n    $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n-   tree-pass.h\n+   tree-pass.h $(DF_H)\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(TM_P_H) \\\n    $(TIMEVAR_H) $(OBSTACK_H) toplev.h\n@@ -2551,7 +2572,8 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TIMEVAR_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n    toplev.h insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n-   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) tree-pass.h $(CFGLOOP_H) $(EXPR_H)\n+   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) tree-pass.h $(CFGLOOP_H) $(EXPR_H) \\\n+   $(DF_H) dce.h\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) $(FUNCTION_H) \\\n    $(OBSTACK_H) toplev.h $(TREE_FLOW_H) $(TREE_H) pointer-set.h output.h \\\n@@ -2564,7 +2586,7 @@ graphds.o : graphds.c graphds.h $(CONFIG_H) $(SYSTEM_H) bitmap.h $(OBSTACK_H) \\\n struct-equiv.o : struct-equiv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n    insn-config.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n-   $(REGS_H) $(EMIT_RTL_H)\n+   $(REGS_H) $(EMIT_RTL_H) $(DF_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    output.h intl.h $(DF_H) $(HASHTAB_H)\n@@ -2577,7 +2599,7 @@ cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H)\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n-   coretypes.h $(TM_H) $(OBSTACK_H) tree-pass.h $(TIMEVAR_H) $(FLAGS_H)\n+   coretypes.h $(TM_H) $(OBSTACK_H) tree-pass.h $(TIMEVAR_H) $(FLAGS_H) $(DF_H)\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n    output.h $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)\n@@ -2594,53 +2616,53 @@ combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(FUNCTION_H) insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) $(REAL_H) hard-reg-set.h \\\n    toplev.h $(TM_P_H) $(TREE_H) $(TARGET_H) output.h $(PARAMS_H) $(OPTABS_H) \\\n-   insn-codes.h $(TIMEVAR_H) tree-pass.h\n+   insn-codes.h $(TIMEVAR_H) tree-pass.h $(DF_H)\n regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \\\n    $(RECOG_H) reload.h $(REAL_H) toplev.h $(FUNCTION_H) output.h $(GGC_H) \\\n    $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-regclass.h $(HASHTAB_H) \\\n-   $(TARGET_H)\n+   $(TARGET_H) tree-pass.h $(DF_H)\n local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h $(FUNCTION_H) $(INSN_ATTR_H) toplev.h  except.h reload.h $(TM_P_H) \\\n-   $(GGC_H) $(INTEGRATE_H) $(TIMEVAR_H) tree-pass.h\n+   $(GGC_H) $(INTEGRATE_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H)\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(GGC_H) gt-bitmap.h bitmap.h $(OBSTACK_H)\n global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n-   $(TIMEVAR_H) vecprim.h\n+   $(TIMEVAR_H) vecprim.h $(DF_H)\n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) toplev.h\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \\\n    toplev.h\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) output.h $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) \\\n-   hard-reg-set.h insn-config.h $(REGS_H) $(FUNCTION_H) toplev.h \\\n-   addresses.h $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H)\n+   hard-reg-set.h insn-config.h $(REGS_H) $(FUNCTION_H) real.h toplev.h \\\n+   addresses.h $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H) $(DF_H)\n reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) output.h $(FUNCTION_H) toplev.h $(TM_P_H) \\\n    addresses.h except.h $(TREE_H) $(REAL_H) $(FLAGS_H) $(MACHMODE_H) \\\n-   $(OBSTACK_H) $(TARGET_H)\n+   $(OBSTACK_H) $(DF_H) $(TARGET_H) dse.h\n rtlhooks.o :  rtlhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    rtlhooks-def.h $(EXPR_H) $(RECOG_H)\n postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(REAL_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \\\n    hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \\\n    $(FUNCTION_H) toplev.h cselib.h $(TM_P_H) except.h $(TREE_H) $(MACHMODE_H) \\\n-   $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h\n+   $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h $(DF_H)\n postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h \\\n    $(TM_P_H) except.h $(TREE_H) $(TARGET_H) $(HASHTAB_H) intl.h $(OBSTACK_H) \\\n-   $(PARAMS_H) $(TIMEVAR_H) tree-pass.h $(REAL_H)\n+   $(PARAMS_H) $(TIMEVAR_H) tree-pass.h $(REAL_H) $(DBGCNT_H)\n caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n-   addresses.h $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)\n+   addresses.h $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H) $(DF_H)\n bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) except.h \\\n    $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) output.h $(EXPR_H) \\\n-   $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) $(FUNCTION_H) tree-pass.h toplev.h\n+   $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) $(FUNCTION_H) tree-pass.h toplev.h $(DF_H)\n reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    conditions.h hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \\\n    $(INSN_ATTR_H) except.h $(RECOG_H) $(FUNCTION_H) $(FLAGS_H) output.h \\\n@@ -2650,9 +2672,15 @@ alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h \\\n    $(ALIAS_H) $(EMIT_RTL_H) $(GGC_H) $(FUNCTION_H) cselib.h $(TREE_H) $(TM_P_H) \\\n    langhooks.h $(TARGET_H) gt-alias.h $(TIMEVAR_H) $(CGRAPH_H) \\\n-   $(SPLAY_TREE_H) $(VARRAY_H) $(IPA_TYPE_ESCAPE_H) tree-pass.h\n+   $(SPLAY_TREE_H) $(VARRAY_H) $(IPA_TYPE_ESCAPE_H) $(DF_H) tree-pass.h\n+stack-ptr-mod.o : stack-ptr-mod.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TREE_H) $(RTL_H) $(REGS_H) $(EXPR_H) tree-pass.h \\\n+   $(BASIC_BLOCK_H) $(FLAGS_H) output.h $(DF_H)\n+init-regs.o : init-regs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TREE_H) $(RTL_H) $(REGS_H) $(EXPR_H) tree-pass.h \\\n+   $(BASIC_BLOCK_H) $(FLAGS_H) $(DF_H)\n regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   insn-config.h $(TIMEVAR_H) tree-pass.h \\\n+   insn-config.h $(TIMEVAR_H) tree-pass.h $(DF_H)\\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\\n    $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n combine-stack-adj.o : combine-stack-adj.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -2662,30 +2690,30 @@ combine-stack-adj.o : combine-stack-adj.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \\\n    toplev.h $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) except.h $(RECOG_H) \\\n-   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) bitmap.h $(DF_H) \\\n+   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) bitmap.h \\\n    hard-reg-set.h sbitmap.h $(TM_H)\n modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TARGET_H) toplev.h $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) except.h $(RECOG_H) \\\n    $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \\\n-   cfghooks.h $(DF_H) $(GCOV_IO_H) hard-reg-set.h $(TM_H) $(TIMEVAR_H) \\\n-   tree-pass.h\n-haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n-   $(FUNCTION_H) $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) \\\n-   $(TARGET_H) output.h $(PARAMS_H)\n+   cfghooks.h $(GCOV_IO_H) hard-reg-set.h $(TM_H) timevar.h tree-pass.h \\\n+   $(DF_H)\n+haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \\\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H) output.h \\\n+   $(PARAMS_H) $(DBGCNT_H)\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h \\\n-   $(PARAMS_H) $(TM_P_H) $(DF_H)\n+   $(PARAMS_H) $(TM_P_H) \n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(PARAMS_H) \\\n-   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H) $(TIMEVAR_H) tree-pass.h\n+   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H) $(TIMEVAR_H) tree-pass.h $(DBGCNT_H)\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) \\\n-   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H) output.h\n+   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H) output.h \n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H) \\\n    $(TM_P_H) $(REAL_H) toplev.h tree-pass.h\n@@ -2694,16 +2722,17 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(INSN_ATTR_H) $(FUNCTION_H) output.h hard-reg-set.h \\\n    except.h debug.h xcoffout.h toplev.h reload.h dwarf2out.h tree-pass.h \\\n    $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) $(CFGLAYOUT_H) dbxout.h \\\n-   $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) $(REAL_H) vecprim.h\n+   $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) $(REAL_H) $(DF_H) vecprim.h\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) toplev.h output.h reload.h \\\n-   addresses.h $(TM_P_H) $(TIMEVAR_H) tree-pass.h hard-reg-set.h $(REAL_H)\n+   addresses.h $(TM_P_H) $(TIMEVAR_H) tree-pass.h hard-reg-set.h $(REAL_H) \\\n+   $(DF_H) $(DBGCNT_H)\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    insn-config.h toplev.h reload.h $(FUNCTION_H) $(TM_P_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) output.h $(VARRAY_H) $(TIMEVAR_H) tree-pass.h \\\n-   $(TARGET_H) vecprim.h\n+   $(TARGET_H) vecprim.h $(DF_H)\n sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \\\n@@ -2724,17 +2753,19 @@ tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \\\n    $(FUNCTION_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(TARGET_H) gt-cfglayout.h \\\n-   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H) tree-pass.h vecprim.h\n+   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H) tree-pass.h vecprim.h \\\n+   $(DF_H)\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TIMEVAR_H) $(FLAGS_H) intl.h toplev.h $(RTL_H) timevar.def\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\\n-   addresses.h reload.h toplev.h $(TIMEVAR_H) tree-pass.h\n+   addresses.h reload.h toplev.h $(TIMEVAR_H) tree-pass.h $(DF_H)\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) toplev.h $(FLAGS_H) insn-config.h $(FUNCTION_H) $(RECOG_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) \\\n-   $(REAL_H) $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h $(TIMEVAR_H) tree-pass.h\n+   $(REAL_H) $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h $(TIMEVAR_H) tree-pass.h \\\n+   $(DF_H)\n lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n    $(TM_H) coretypes.h $(TREE_H)\n lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n@@ -2750,10 +2781,11 @@ hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)\n pretty-print.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h $(PRETTY_PRINT_H) \\\n    $(TREE_H)\n errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h $(BCONFIG_H)\n+dbgcnt.o: dbgcnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DBGCNT_H)\n lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(MACHMODE_H) $(TM_H) $(RTL_H) $(TM_P_H) $(TIMEVAR_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) $(OBSTACK_H) bitmap.h \\\n-   $(EXPR_H) $(REGS_H) tree-pass.h\n+   $(EXPR_H) $(REGS_H) tree-pass.h $(DF_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\"}, {"sha": "c03ff03ce6207dfc8ecd8f872501bec94a389c59", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -46,6 +46,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"varray.h\"\n #include \"tree-pass.h\"\n #include \"ipa-type-escape.h\"\n+#include \"df.h\"\n \n /* The aliasing API provided here solves related but different problems:\n \n@@ -839,7 +840,7 @@ find_base_value (rtx src)\n \t  /* If we're inside init_alias_analysis, use new_reg_base_value\n \t     to reduce the number of relaxation iterations.  */\n \t  if (new_reg_base_value && new_reg_base_value[regno]\n-\t      && REG_N_SETS (regno) == 1)\n+\t      && DF_REG_DEF_COUNT (regno) == 1)\n \t    return new_reg_base_value[regno];\n \n \t  if (VEC_index (rtx, reg_base_value, regno))\n@@ -1087,27 +1088,6 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n   reg_seen[regno] = 1;\n }\n \n-/* Clear alias info for a register.  This is used if an RTL transformation\n-   changes the value of a register.  This is used in flow by AUTO_INC_DEC\n-   optimizations.  We don't need to clear reg_base_value, since flow only\n-   changes the offset.  */\n-\n-void\n-clear_reg_alias_info (rtx reg)\n-{\n-  unsigned int regno = REGNO (reg);\n-\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < reg_known_value_size)\n-\t{\n-\t  reg_known_value[regno] = reg;\n-\t  reg_known_equiv_p[regno] = false;\n-\t}\n-    }\n-}\n-\n /* If a value is known for REGNO, return it.  */\n \n rtx\n@@ -2433,7 +2413,7 @@ init_alias_analysis (void)\n      the optimization level or flag_expensive_optimizations.\n \n      We could propagate more information in the first pass by making use\n-     of REG_N_SETS to determine immediately that the alias information\n+     of DF_REG_DEF_COUNT to determine immediately that the alias information\n      for a pseudo is \"constant\".\n \n      A program with an uninitialized variable can cause an infinite loop\n@@ -2514,7 +2494,7 @@ init_alias_analysis (void)\n \n \t\t  note = find_reg_equal_equiv_note (insn);\n \t\t  if (note && REG_NOTE_KIND (note) == REG_EQUAL\n-\t\t      && REG_N_SETS (regno) != 1)\n+\t\t      && DF_REG_DEF_COUNT (regno) != 1)\n \t\t    note = NULL_RTX;\n \n \t\t  if (note != NULL_RTX\n@@ -2527,7 +2507,7 @@ init_alias_analysis (void)\n \t\t      set_reg_known_equiv_p (regno,\n \t\t\tREG_NOTE_KIND (note) == REG_EQUIV);\n \t\t    }\n-\t\t  else if (REG_N_SETS (regno) == 1\n+\t\t  else if (DF_REG_DEF_COUNT (regno) == 1\n \t\t\t   && GET_CODE (src) == PLUS\n \t\t\t   && REG_P (XEXP (src, 0))\n \t\t\t   && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n@@ -2537,7 +2517,7 @@ init_alias_analysis (void)\n \t\t      set_reg_known_value (regno, t);\n \t\t      set_reg_known_equiv_p (regno, 0);\n \t\t    }\n-\t\t  else if (REG_N_SETS (regno) == 1\n+\t\t  else if (DF_REG_DEF_COUNT (regno) == 1\n \t\t\t   && ! rtx_varies_p (src, 1))\n \t\t    {\n \t\t      set_reg_known_value (regno, src);"}, {"sha": "52d5cffdaaa7472619ec130925792c632e9b5559", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Functions to support a pool of allocatable objects.\n-   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@cgsoftware.com>\n \n@@ -161,7 +161,9 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n   header_size = align_eight (sizeof (struct alloc_pool_list_def));\n \n   pool->block_size = (size * num) + header_size;\n-  pool->free_list = NULL;\n+  pool->returned_free_list = NULL;\n+  pool->virgin_free_list = NULL;\n+  pool->virgin_elts_remaining = 0;\n   pool->elts_allocated = 0;\n   pool->elts_free = 0;\n   pool->blocks_allocated = 0;\n@@ -223,7 +225,6 @@ void *\n pool_alloc (alloc_pool pool)\n {\n   alloc_pool_list header;\n-  char *block;\n #ifdef GATHER_STATISTICS\n   struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n \n@@ -233,46 +234,57 @@ pool_alloc (alloc_pool pool)\n   gcc_assert (pool);\n \n   /* If there are no more free elements, make some more!.  */\n-  if (!pool->free_list)\n+  if (!pool->returned_free_list)\n     {\n-      size_t i;\n-      alloc_pool_list block_header;\n-\n-      /* Make the block.  */\n-      block = XNEWVEC (char, pool->block_size);\n-      block_header = (alloc_pool_list) block;\n-      block += align_eight (sizeof (struct alloc_pool_list_def));\n+      char *block;\n+      if (!pool->virgin_elts_remaining)\n+\t{\n+\t  alloc_pool_list block_header;\n+\n+\t  /* Make the block.  */\n+\t  block = XNEWVEC (char, pool->block_size);\n+\t  block_header = (alloc_pool_list) block;\n+\t  block += align_eight (sizeof (struct alloc_pool_list_def));\n #ifdef GATHER_STATISTICS\n-      desc->current += pool->block_size;\n-      if (desc->peak < desc->current)\n-\tdesc->peak = desc->current;\n+\t  desc->current += pool->block_size;\n+\t  if (desc->peak < desc->current)\n+\t    desc->peak = desc->current;\n #endif\n-\n-      /* Throw it on the block list.  */\n-      block_header->next = pool->block_list;\n-      pool->block_list = block_header;\n-\n-      /* Now put the actual block pieces onto the free list.  */\n-      for (i = 0; i < pool->elts_per_block; i++, block += pool->elt_size)\n-      {\n+\t  \n+\t  /* Throw it on the block list.  */\n+\t  block_header->next = pool->block_list;\n+\t  pool->block_list = block_header;\n+\n+\t  /* Make the block available for allocation.  */\n+\t  pool->virgin_free_list = block;\n+\t  pool->virgin_elts_remaining = pool->elts_per_block;\n+\n+\t  /* Also update the number of elements we have free/allocated, and\n+\t     increment the allocated block count.  */\n+\t  pool->elts_allocated += pool->elts_per_block;\n+\t  pool->elts_free += pool->elts_per_block;\n+\t  pool->blocks_allocated += 1;\n+\t}\n+\n+      \n+      /* We now know that we can take the first elt off the virgin list and\n+\t put it on the returned list. */\n+      block = pool->virgin_free_list;\n+      header = (alloc_pool_list) USER_PTR_FROM_ALLOCATION_OBJECT_PTR (block);\n+      header->next = NULL;\n #ifdef ENABLE_CHECKING\n-\t/* Mark the element to be free.  */\n-\t((allocation_object *) block)->id = 0;\n+      /* Mark the element to be free.  */\n+      ((allocation_object *) block)->id = 0;\n #endif\n-\theader = (alloc_pool_list) USER_PTR_FROM_ALLOCATION_OBJECT_PTR (block);\n-\theader->next = pool->free_list;\n-\tpool->free_list = header;\n-      }\n-      /* Also update the number of elements we have free/allocated, and\n-\t increment the allocated block count.  */\n-      pool->elts_allocated += pool->elts_per_block;\n-      pool->elts_free += pool->elts_per_block;\n-      pool->blocks_allocated += 1;\n+      pool->returned_free_list = header;\n+      pool->virgin_free_list += pool->elt_size;\n+      pool->virgin_elts_remaining--;\n+\n     }\n \n   /* Pull the first free element from the free list, and return it.  */\n-  header = pool->free_list;\n-  pool->free_list = header->next;\n+  header = pool->returned_free_list;\n+  pool->returned_free_list = header->next;\n   pool->elts_free--;\n \n #ifdef ENABLE_CHECKING\n@@ -305,8 +317,8 @@ pool_free (alloc_pool pool, void *ptr)\n #endif\n \n   header = (alloc_pool_list) ptr;\n-  header->next = pool->free_list;\n-  pool->free_list = header;\n+  header->next = pool->returned_free_list;\n+  pool->returned_free_list = header;\n   pool->elts_free++;\n }\n /* Output per-alloc_pool statistics.  */"}, {"sha": "faf13e8e1a03cf950609cbc416fed14ed74e8fbd", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Functions to support a pool of allocatable objects\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2007\n    Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@cgsoftware.com>\n \n@@ -37,7 +37,18 @@ typedef struct alloc_pool_def\n   ALLOC_POOL_ID_TYPE id;\n #endif\n   size_t elts_per_block;\n-  alloc_pool_list free_list;\n+\n+  /* These are the elements that have been allocated at least once and freed.  */\n+  alloc_pool_list returned_free_list;\n+\n+  /* These are the elements that have not yet been allocated out of\n+     the last block obtained from XNEWVEC.  */\n+  char* virgin_free_list;\n+\n+  /* The number of elements in the virgin_free_list that can be\n+     allocated before needing another block.  */ \n+  size_t virgin_elts_remaining;\n+\n   size_t elts_allocated;\n   size_t elts_free;\n   size_t blocks_allocated;"}, {"sha": "24156624eac660bbf74f364cb24ad3c326e71a22", "filename": "gcc/auto-inc-dec.c", "status": "added", "additions": 1558, "deletions": 0, "changes": 1558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -0,0 +1,1558 @@\n+/* Discovery of auto-inc and auto-dec instructions.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+   \n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"except.h\"\n+#include \"toplev.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+#include \"df.h\"\n+#include \"dbgcnt.h\"\n+\n+/* This pass was originally removed from flow.c. However there is\n+   almost nothing that remains of that code.\n+\n+   There are (4) basic forms that are matched:\n+\n+           a <- b + c\n+           ...\n+           *a\n+\n+        becomes\n+\n+           a <- b\n+           ...\n+           *(a += c) pre\n+           a += c\n+           ...\n+           *a\n+\n+        becomes\n+\n+           *(a += c) pre\n+           *a\n+           ...\n+           b <- a + c\n+\n+\t   for this case to be true, b must not be assigned or used between \n+\t   the *a and the assignment to b.  B must also be a Pmode reg.\n+\n+        becomes\n+\n+           b <- a\n+           ...\n+           *(b += c) post\n+           *a\n+           ...\n+           a <- a + c\n+\n+        becomes\n+\n+           *(a += c) post\n+\n+  There are three types of values of c.\n+\n+    1) c is a constant equal to the width of the value being accessed by\n+       the pointer.  This is useful for machines that have\n+       HAVE_PRE_INCREMENT, HAVE_POST_INCREMENT, HAVE_PRE_DECREMENT or\n+       HAVE_POST_DECREMENT defined.\n+\n+    2) c is a contant not equal to the width of the value being accessed\n+       by the pointer.  This is useful for machines that have\n+       HAVE_PRE_MODIFY_DISP, HAVE_POST_MODIFY_DISP defined.\n+\n+    3) c is a register.  This is useful for machines that have \n+       HAVE_PRE_MODIFY_REG,  HAVE_POST_MODIFY_REG  \n+  \n+  The is one special case: if a already had an offset equal to it +-\n+  its width and that offset is equal to -c when the increment was\n+  before the ref or +c if the increment was after the ref, then if we\n+  can do the combination but switch the pre/post bit.\n+\n+        (1) FORM_PRE_ADD\n+\n+           a <- b + c\n+           ...\n+           *(a - c)\n+\n+        becomes\n+\n+           a <- b\n+           ...\n+           *(a += c) post\n+\n+        (2) FORM_PRE_INC\n+\n+           a += c\n+           ...\n+           *(a - c)\n+\n+        becomes\n+\n+           *(a += c) post\n+\n+        (3) FORM_POST_ADD\n+\n+           *(a + c)\n+           ...\n+           b <- a + c\n+\n+\t   for this case to be true, b must not be assigned or used between \n+\t   the *a and the assignment to b. B must also be a Pmode reg.\n+\n+        becomes\n+\n+           b <- a\n+           ...\n+           *(b += c) pre\n+\n+\n+        (4) FORM_POST_INC\n+\n+           *(a + c)\n+           ...\n+           a <- a + c \n+\n+        becomes\n+\n+           *(a += c) pre\n+*/\n+#ifdef AUTO_INC_DEC\n+\n+enum form\n+{\n+  FORM_PRE_ADD,\n+  FORM_PRE_INC,\n+  FORM_POST_ADD,\n+  FORM_POST_INC,\n+  FORM_last\n+};\n+\n+/* The states of the second operands of mem refs and inc insns.  If no\n+   second operand of the mem_ref was found, it is assumed to just be\n+   ZERO.  SIZE is the size of the mode accessed in the memref.  The\n+   ANY is used for constants that are not +-size or 0.  REG is used if\n+   the forms are reg1 + reg2.  */\n+\n+enum inc_state \n+{\n+  INC_ZERO,           /* == 0  */\n+  INC_NEG_SIZE,       /* == +size  */\n+  INC_POS_SIZE,       /* == -size */\n+  INC_NEG_ANY,        /* == some -constant  */\n+  INC_POS_ANY,        /* == some +constant  */\n+  INC_REG,            /* == some register  */\n+  INC_last\n+};\n+\n+/* The eight forms that pre/post inc/dec can take.  */\n+enum gen_form\n+{\n+  NOTHING,\n+  SIMPLE_PRE_INC,     /* ++size  */\n+  SIMPLE_POST_INC,    /* size++  */\n+  SIMPLE_PRE_DEC,     /* --size  */\n+  SIMPLE_POST_DEC,    /* size--  */\n+  DISP_PRE,           /* ++con   */\n+  DISP_POST,          /* con++   */\n+  REG_PRE,            /* ++reg   */\n+  REG_POST            /* reg++   */\n+};\n+\n+/* Tmp mem rtx for use in cost modeling.  */\n+static rtx mem_tmp;\n+\n+static enum inc_state\n+set_inc_state (HOST_WIDE_INT val, int size)\n+{\n+  if (val == 0)\n+    return INC_ZERO;\n+  if (val < 0)\n+    return (val == -size) ? INC_NEG_SIZE : INC_NEG_ANY;\n+  else\n+    return (val == size) ? INC_POS_SIZE : INC_POS_ANY;\n+}\n+\n+/* The DECISION_TABLE that describes what form, if any, the increment\n+   or decrement will take. It is a three dimensional table.  The first\n+   index is the type of constant or register found as the second\n+   operand of the inc insn.  The second index is the type of constant\n+   or register found as the second operand of the memory reference (if\n+   no second operand exists, 0 is used).  The third index is the form\n+   and location (relative to the mem reference) of inc insn.  */\n+\n+static bool initialized = false;\n+static enum gen_form decision_table[INC_last][INC_last][FORM_last];\n+\n+static void\n+init_decision_table (void)\n+{\n+  enum gen_form value;\n+\n+  if (HAVE_PRE_INCREMENT || HAVE_PRE_MODIFY_DISP)\n+    {\n+      /* Prefer the simple form if both are available.  */\n+      value = (HAVE_PRE_INCREMENT) ? SIMPLE_PRE_INC : DISP_PRE;\n+\n+      decision_table[INC_POS_SIZE][INC_ZERO][FORM_PRE_ADD] = value;\n+      decision_table[INC_POS_SIZE][INC_ZERO][FORM_PRE_INC] = value;\n+\n+      decision_table[INC_POS_SIZE][INC_POS_SIZE][FORM_POST_ADD] = value;\n+      decision_table[INC_POS_SIZE][INC_POS_SIZE][FORM_POST_INC] = value;\n+    }\n+\n+  if (HAVE_POST_INCREMENT || HAVE_POST_MODIFY_DISP)\n+    {\n+      /* Prefer the simple form if both are available.  */\n+      value = (HAVE_POST_INCREMENT) ? SIMPLE_POST_INC : DISP_POST;\n+\n+      decision_table[INC_POS_SIZE][INC_ZERO][FORM_POST_ADD] = value;\n+      decision_table[INC_POS_SIZE][INC_ZERO][FORM_POST_INC] = value;\n+\n+      decision_table[INC_POS_SIZE][INC_NEG_SIZE][FORM_PRE_ADD] = value;\n+      decision_table[INC_POS_SIZE][INC_NEG_SIZE][FORM_PRE_INC] = value;\n+    }\n+\n+  if (HAVE_PRE_DECREMENT || HAVE_PRE_MODIFY_DISP)\n+    {\n+      /* Prefer the simple form if both are available.  */\n+      value = (HAVE_PRE_DECREMENT) ? SIMPLE_PRE_DEC : DISP_PRE;\n+\n+      decision_table[INC_NEG_SIZE][INC_ZERO][FORM_PRE_ADD] = value;\n+      decision_table[INC_NEG_SIZE][INC_ZERO][FORM_PRE_INC] = value;\n+\n+      decision_table[INC_NEG_SIZE][INC_NEG_SIZE][FORM_POST_ADD] = value;\n+      decision_table[INC_NEG_SIZE][INC_NEG_SIZE][FORM_POST_INC] = value;\n+    }\n+\n+  if (HAVE_POST_DECREMENT || HAVE_POST_MODIFY_DISP)\n+    {\n+      /* Prefer the simple form if both are available.  */\n+      value = (HAVE_POST_DECREMENT) ? SIMPLE_POST_DEC : DISP_POST;\n+\n+      decision_table[INC_NEG_SIZE][INC_ZERO][FORM_POST_ADD] = value;\n+      decision_table[INC_NEG_SIZE][INC_ZERO][FORM_POST_INC] = value;\n+\n+      decision_table[INC_NEG_SIZE][INC_POS_SIZE][FORM_PRE_ADD] = value;\n+      decision_table[INC_NEG_SIZE][INC_POS_SIZE][FORM_PRE_INC] = value;\n+    }\n+\n+  if (HAVE_PRE_MODIFY_DISP)\n+    {\n+      decision_table[INC_POS_ANY][INC_ZERO][FORM_PRE_ADD] = DISP_PRE;\n+      decision_table[INC_POS_ANY][INC_ZERO][FORM_PRE_INC] = DISP_PRE;\n+\n+      decision_table[INC_POS_ANY][INC_POS_ANY][FORM_POST_ADD] = DISP_PRE;\n+      decision_table[INC_POS_ANY][INC_POS_ANY][FORM_POST_INC] = DISP_PRE;\n+\n+      decision_table[INC_NEG_ANY][INC_ZERO][FORM_PRE_ADD] = DISP_PRE;\n+      decision_table[INC_NEG_ANY][INC_ZERO][FORM_PRE_INC] = DISP_PRE;\n+\n+      decision_table[INC_NEG_ANY][INC_NEG_ANY][FORM_POST_ADD] = DISP_PRE;\n+      decision_table[INC_NEG_ANY][INC_NEG_ANY][FORM_POST_INC] = DISP_PRE;\n+    }\n+\n+  if (HAVE_POST_MODIFY_DISP)\n+    {\n+      decision_table[INC_POS_ANY][INC_ZERO][FORM_POST_ADD] = DISP_POST;\n+      decision_table[INC_POS_ANY][INC_ZERO][FORM_POST_INC] = DISP_POST;\n+\n+      decision_table[INC_POS_ANY][INC_NEG_ANY][FORM_PRE_ADD] = DISP_POST;\n+      decision_table[INC_POS_ANY][INC_NEG_ANY][FORM_PRE_INC] = DISP_POST;\n+\n+      decision_table[INC_NEG_ANY][INC_ZERO][FORM_POST_ADD] = DISP_POST;\n+      decision_table[INC_NEG_ANY][INC_ZERO][FORM_POST_INC] = DISP_POST;\n+\n+      decision_table[INC_NEG_ANY][INC_POS_ANY][FORM_PRE_ADD] = DISP_POST;\n+      decision_table[INC_NEG_ANY][INC_POS_ANY][FORM_PRE_INC] = DISP_POST;\n+    }\n+\n+  /* This is much simpler than the other cases because we do not look\n+     for the reg1-reg2 case.  Note that we do not have a INC_POS_REG\n+     and INC_NEG_REG states.  Most of the use of such states would be\n+     on a target that had an R1 - R2 update address form.\n+\n+     There is the remote possibility that you could also catch a = a +\n+     b; *(a - b) as a postdecrement of (a + b).  However, it is\n+     unclear if *(a - b) would ever be generated on a machine that did\n+     not have that kind of addressing mode.  The IA-64 and RS6000 will\n+     not do this, and I cannot speak for any other.  If any\n+     architecture does have an a-b update for, these cases should be\n+     added.  */\n+  if (HAVE_PRE_MODIFY_REG)\n+    {\n+      decision_table[INC_REG][INC_ZERO][FORM_PRE_ADD] = REG_PRE;\n+      decision_table[INC_REG][INC_ZERO][FORM_PRE_INC] = REG_PRE;\n+\n+      decision_table[INC_REG][INC_REG][FORM_POST_ADD] = REG_PRE;\n+      decision_table[INC_REG][INC_REG][FORM_POST_INC] = REG_PRE;\n+    }\n+\n+  if (HAVE_POST_MODIFY_REG)\n+    {\n+      decision_table[INC_REG][INC_ZERO][FORM_POST_ADD] = REG_POST;\n+      decision_table[INC_REG][INC_ZERO][FORM_POST_INC] = REG_POST;\n+    }\n+\n+  initialized = true;\n+}\n+\n+/* Parsed fields of an inc insn of the form \"reg_res = reg0+reg1\" or\n+   \"reg_res = reg0+c\".  */\n+\n+static struct inc_insn \n+{\n+  rtx insn;           /* The insn being parsed.  */\n+  rtx pat;            /* The pattern of the insn.  */\n+  bool reg1_is_const; /* True if reg1 is const, false if reg1 is a reg.  */\n+  enum form form;\n+  rtx reg_res;\n+  rtx reg0;\n+  rtx reg1;\n+  enum inc_state reg1_state;/* The form of the const if reg1 is a const.  */\n+  HOST_WIDE_INT reg1_val;/* Value if reg1 is const.  */\n+} inc_insn;\n+\n+\n+/* Dump the parsed inc insn to FILE.  */\n+\n+static void \n+dump_inc_insn (FILE *file)\n+{\n+  const char *f = ((inc_insn.form == FORM_PRE_ADD) \n+\t      || (inc_insn.form == FORM_PRE_INC)) ? \"pre\" : \"post\";\n+\n+  dump_insn_slim (file, inc_insn.insn);\n+\n+  switch (inc_insn.form)\n+    {\n+    case FORM_PRE_ADD:\n+    case FORM_POST_ADD:\n+      if (inc_insn.reg1_is_const)\n+\tfprintf (file, \"found %s add(%d) r[%d]=r[%d]+%d\\n\", \n+\t\t f, INSN_UID (inc_insn.insn), \n+\t\t REGNO (inc_insn.reg_res), \n+\t\t REGNO (inc_insn.reg0), (int) inc_insn.reg1_val);\n+      else\n+\tfprintf (file, \"found %s add(%d) r[%d]=r[%d]+r[%d]\\n\", \n+\t\t f, INSN_UID (inc_insn.insn), \n+\t\t REGNO (inc_insn.reg_res), \n+\t\t REGNO (inc_insn.reg0), REGNO (inc_insn.reg1));\n+      break;\n+      \n+    case FORM_PRE_INC:\n+    case FORM_POST_INC:\n+      if (inc_insn.reg1_is_const)\n+\tfprintf (file, \"found %s inc(%d) r[%d]+=%d\\n\", \n+\t\t f, INSN_UID (inc_insn.insn), \n+\t\t REGNO (inc_insn.reg_res), (int) inc_insn.reg1_val);\n+      else\n+\tfprintf (file, \"found %s inc(%d) r[%d]+=r[%d]\\n\", \n+\t\t f, INSN_UID (inc_insn.insn), \n+\t\t REGNO (inc_insn.reg_res), REGNO (inc_insn.reg1));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+\n+/* Parsed fields of a mem ref of the form \"*(reg0+reg1)\" or \"*(reg0+c)\".  */\n+\n+static struct mem_insn\n+{\n+  rtx insn;           /* The insn being parsed.  */\n+  rtx pat;            /* The pattern of the insn.  */\n+  rtx *mem_loc;       /* The address of the field that holds the mem */\n+                      /* that is to be replaced.  */\n+  bool reg1_is_const; /* True if reg1 is const, false if reg1 is a reg.  */\n+  rtx reg0;\n+  rtx reg1;           /* This is either a reg or a const depending on\n+\t\t\t reg1_is_const.  */\n+  enum inc_state reg1_state;/* The form of the const if reg1 is a const.  */\n+  HOST_WIDE_INT reg1_val;/* Value if reg1 is const.  */\n+} mem_insn;\n+\n+\n+/* Dump the parsed mem insn to FILE.  */\n+\n+static void \n+dump_mem_insn (FILE *file)\n+{\n+  dump_insn_slim (file, mem_insn.insn);\n+\n+  if (mem_insn.reg1_is_const)\n+    fprintf (file, \"found mem(%d) *(r[%d]+%d)\\n\", \n+\t     INSN_UID (mem_insn.insn), \n+\t     REGNO (mem_insn.reg0), (int) mem_insn.reg1_val);\n+  else\n+    fprintf (file, \"found mem(%d) *(r[%d]+r[%d])\\n\", \n+\t     INSN_UID (mem_insn.insn), \n+\t     REGNO (mem_insn.reg0), REGNO (mem_insn.reg1));\n+}\n+\n+\n+/* The following three arrays contain pointers to instructions. They\n+   are indexed by REGNO.  At any point in the basic block where we are\n+   looking these three arrays contain, respectively, the next insn\n+   that uses REGNO, the next inc or add insn that uses REGNO and the\n+   next insn that sets REGNO.\n+\n+   The arrays are not cleared when we move from block to block so\n+   whenever an insn is retrieved from these arrays, it's block number\n+   must be compared with the current block.\n+*/\n+\n+static rtx *reg_next_use = NULL;\n+static rtx *reg_next_inc_use = NULL;\n+static rtx *reg_next_def = NULL;\n+\n+\n+/* Move dead note that match PATTERN to TO_INSN from FROM_INSN.  We do\n+   not really care about moving any other notes from the inc or add\n+   insn.  Moving the REG_EQUAL and REG_EQUIV is clearly wrong and it\n+   does not appear that there are any other kinds of relavant notes.  */\n+\n+static void \n+move_dead_notes (rtx to_insn, rtx from_insn, rtx pattern)\n+{\n+  rtx note; \n+  rtx next_note;\n+  rtx prev_note = NULL;\n+\n+  for (note = REG_NOTES (from_insn); note; note = next_note)\n+    {\n+      next_note = XEXP (note, 1);\n+      \n+      if ((REG_NOTE_KIND (note) == REG_DEAD)\n+\t  && pattern == XEXP (note, 0))\n+\t{\n+\t  XEXP (note, 1) = REG_NOTES (to_insn);\n+\t  REG_NOTES (to_insn) = note;\n+\t  if (prev_note)\n+\t    XEXP (prev_note, 1) = next_note;\n+\t  else\n+\t    REG_NOTES (from_insn) = next_note;\n+\t}\n+      else prev_note = note;\n+    }\n+}\n+\n+\n+/* Create a mov insn DEST_REG <- SRC_REG and insert it before\n+   NEXT_INSN.  */\n+\n+static rtx\n+insert_move_insn_before (rtx next_insn, rtx dest_reg, rtx src_reg)\n+{\n+  rtx insns;\n+\n+  start_sequence ();\n+  emit_move_insn (dest_reg, src_reg);\n+  insns = get_insns ();\n+  end_sequence ();\n+  emit_insn_before (insns, next_insn);\n+  return insns;\n+}\n+\n+  \n+/* Change mem_insn.mem_loc so that uses NEW_ADDR which has an\n+   increment of INC_REG.  To have reached this point, the change is a\n+   legitimate one from a dataflow point of view.  The only questions\n+   are is this a valid change to the instruction and is this a\n+   profitable change to the instruction.  */\n+\n+static bool\n+attempt_change (rtx new_addr, rtx inc_reg)\n+{\n+  /* There are four cases: For the two cases that involve an add\n+     instruction, we are going to have to delete the add and insert a\n+     mov.  We are going to assume that the mov is free.  This is\n+     fairly early in the backend and there are a lot of opportunities\n+     for removing that move later.  In particular, there is the case\n+     where the move may be dead, this is what dead code elimination\n+     passes are for.  The two cases where we have an inc insn will be\n+     handled mov free.  */\n+\n+  basic_block bb = BASIC_BLOCK (BLOCK_NUM (mem_insn.insn));\n+  rtx mov_insn = NULL;\n+  int regno;\n+  rtx mem = *mem_insn.mem_loc;\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx new_mem;\n+  int old_cost = 0;\n+  int new_cost = 0;\n+\n+  PUT_MODE (mem_tmp, mode);\n+  XEXP (mem_tmp, 0) = new_addr;\n+\n+  old_cost = rtx_cost (mem, 0) \n+    + rtx_cost (PATTERN (inc_insn.insn), 0);\n+  new_cost = rtx_cost (mem_tmp, 0);\n+  \n+  /* The first item of business is to see if this is profitable.  */\n+  if (old_cost < new_cost)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"cost failure old=%d new=%d\\n\", old_cost, new_cost);\n+      return false;\n+    }\n+\n+  /* Jump thru a lot of hoops to keep the attributes up to date.  We\n+     do not want to call one of the change address variants that take\n+     an offset even though we know the offset in many cases.  These\n+     assume you are changing where the address is pointing by the\n+     offset.  */\n+  new_mem = replace_equiv_address_nv (mem, new_addr);\n+  if (! validate_change (mem_insn.insn, mem_insn.mem_loc, new_mem, 0))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"validation failure\\n\"); \n+      return false;\n+    }\n+\n+  /* From here to the end of the function we are committed to the\n+     change, i.e. nothing fails.  Generate any necessary movs, move\n+     any regnotes, and fix up the reg_next_{use,inc_use,def}.  */\n+  switch (inc_insn.form)\n+    {\n+    case FORM_PRE_ADD:\n+      mov_insn = insert_move_insn_before (mem_insn.insn, \n+\t\t\t\t\t  inc_insn.reg_res, inc_insn.reg0);\n+      move_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n+\n+      regno = REGNO (inc_insn.reg_res);\n+      reg_next_def[regno] = mov_insn;\n+      reg_next_use[regno] = NULL;\n+      regno = REGNO (inc_insn.reg0);\n+      reg_next_use[regno] = mov_insn;\n+      df_recompute_luids (bb);\n+      break;\n+\n+    case FORM_POST_INC:\n+      regno = REGNO (inc_insn.reg_res);\n+      if (reg_next_use[regno] == reg_next_inc_use[regno])\n+\treg_next_inc_use[regno] = NULL;\n+\n+      /* Fallthru.  */\n+    case FORM_PRE_INC:\n+      regno = REGNO (inc_insn.reg_res);\n+      reg_next_def[regno] = mem_insn.insn;\n+      reg_next_use[regno] = NULL;\n+\n+      break;\n+\n+    case FORM_POST_ADD:\n+      mov_insn = insert_move_insn_before (mem_insn.insn, \n+\t\t\t\t\t  inc_insn.reg_res, inc_insn.reg0);\n+      move_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n+\n+      /* Do not move anything to the mov insn because the instruction\n+\t pointer for the main iteration has not yet hit that.  It is\n+\t still pointing to the mem insn. */\n+      regno = REGNO (inc_insn.reg_res);\n+      reg_next_def[regno] = mem_insn.insn;\n+      reg_next_use[regno] = NULL;\n+\n+      regno = REGNO (inc_insn.reg0);\n+      reg_next_use[regno] = mem_insn.insn;\n+      if ((reg_next_use[regno] == reg_next_inc_use[regno])\n+\t  || (reg_next_inc_use[regno] == inc_insn.insn))\n+\treg_next_inc_use[regno] = NULL;\n+      df_recompute_luids (bb);\n+      break;\n+\n+    case FORM_last:\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!inc_insn.reg1_is_const)\n+    {\n+      regno = REGNO (inc_insn.reg1);\n+      reg_next_use[regno] = mem_insn.insn;\n+      if ((reg_next_use[regno] == reg_next_inc_use[regno])\n+\t  || (reg_next_inc_use[regno] == inc_insn.insn))\n+\treg_next_inc_use[regno] = NULL;\n+    }\n+\n+  delete_insn (inc_insn.insn);\n+\n+  if (dump_file && mov_insn)\n+    {\n+      fprintf (dump_file, \"inserting mov \");\n+      dump_insn_slim (dump_file, mov_insn);\n+    }\n+\n+  /* Record that this insn has an implicit side effect.  */\n+  REG_NOTES (mem_insn.insn) \n+    = alloc_EXPR_LIST (REG_INC, inc_reg, REG_NOTES (mem_insn.insn));\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"****success \");\n+      dump_insn_slim (dump_file, mem_insn.insn);\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Try to combine the instruction in INC_INSN with the instruction in\n+   MEM_INSN.  First the form is determined using the DECISION_TABLE\n+   and and the results of parsing the INC_INSN and the MEM_INSN.\n+   Assuming the form is ok, a prototype new address is built which is\n+   passed to ATTEMPT_CHANGE for final processing.  */\n+\n+static bool \n+try_merge (void)\n+{\n+  enum gen_form gen_form;\n+  rtx mem = *mem_insn.mem_loc;\n+  rtx inc_reg = inc_insn.form == FORM_POST_ADD ?\n+    inc_insn.reg_res : mem_insn.reg0;\n+\n+  /* The width of the mem being accessed.  */\n+  int size = GET_MODE_SIZE (GET_MODE (mem));\n+  rtx last_insn = NULL;\n+\n+  switch (inc_insn.form)\n+    {\n+    case FORM_PRE_ADD:\n+    case FORM_PRE_INC:\n+      last_insn = mem_insn.insn;\n+      break;\n+    case FORM_POST_INC:\n+    case FORM_POST_ADD:\n+      last_insn = inc_insn.insn;\n+      break;\n+    case FORM_last:\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Cannot handle auto inc of the stack.  */\n+  if (inc_reg == stack_pointer_rtx)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"cannot inc stack %d failure\\n\", REGNO (inc_reg));\n+      return false;\n+    }\n+\n+  /* Look to see if the inc register is dead after the memory\n+     reference.  If it is do not do the combination.  */\n+  if (find_regno_note (last_insn, REG_DEAD, REGNO (inc_reg)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"dead failure %d\\n\", REGNO (inc_reg));\n+      return false;\n+    }\n+\n+  mem_insn.reg1_state = (mem_insn.reg1_is_const) \n+    ? set_inc_state (mem_insn.reg1_val, size) : INC_REG;\n+  inc_insn.reg1_state = (inc_insn.reg1_is_const)\n+    ? set_inc_state (inc_insn.reg1_val, size) : INC_REG;\n+\n+  /* Now get the form that we are generating.  */\n+  gen_form = decision_table \n+    [inc_insn.reg1_state][mem_insn.reg1_state][inc_insn.form];\n+\n+  if (dbg_cnt (auto_inc_dec) == false)\n+    return false;\n+\n+  switch (gen_form)\n+    {\n+    default:\n+    case NOTHING:\n+      return false;\n+\n+    case SIMPLE_PRE_INC:     /* ++size  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying SIMPLE_PRE_INC\\n\");\n+      return attempt_change (gen_rtx_PRE_INC (Pmode, inc_reg), inc_reg);\n+      break;\n+      \n+    case SIMPLE_POST_INC:    /* size++  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying SIMPLE_POST_INC\\n\");\n+      return attempt_change (gen_rtx_POST_INC (Pmode, inc_reg), inc_reg);\n+      break;\n+      \n+    case SIMPLE_PRE_DEC:     /* --size  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying SIMPLE_PRE_DEC\\n\");\n+      return attempt_change (gen_rtx_PRE_DEC (Pmode, inc_reg), inc_reg);\n+      break;\n+      \n+    case SIMPLE_POST_DEC:    /* size--  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying SIMPLE_POST_DEC\\n\");\n+      return attempt_change (gen_rtx_POST_DEC (Pmode, inc_reg), inc_reg);\n+      break;\n+      \n+    case DISP_PRE:           /* ++con   */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying DISP_PRE\\n\");\n+      return attempt_change (gen_rtx_PRE_MODIFY (Pmode, \n+\t\t\t\t\t\t inc_reg,\n+\t\t\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t       inc_reg,\n+\t\t\t\t\t\t\t       inc_insn.reg1)),\n+\t\t\t     inc_reg);\n+      break;\n+      \n+    case DISP_POST:          /* con++   */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying POST_DISP\\n\");\n+      return attempt_change (gen_rtx_POST_MODIFY (Pmode,\n+\t\t\t\t\t\t  inc_reg,\n+\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t\tinc_reg,\n+\t\t\t\t\t\t\t\tinc_insn.reg1)),\n+\t\t\t     inc_reg);\n+      break;\n+      \n+    case REG_PRE:            /* ++reg   */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying PRE_REG\\n\");\n+      return attempt_change (gen_rtx_PRE_MODIFY (Pmode, \n+\t\t\t\t\t\t inc_reg,\n+\t\t\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t       inc_reg,\n+\t\t\t\t\t\t\t       inc_insn.reg1)),\n+\t\t\t     inc_reg);\n+      break;\n+      \n+    case REG_POST:            /* reg++   */\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying POST_REG\\n\");\n+      return attempt_change (gen_rtx_POST_MODIFY (Pmode, \n+\t\t\t\t\t\t  inc_reg,\n+\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t\tinc_reg,\n+\t\t\t\t\t\t\t\tinc_insn.reg1)),\n+\t\t\t     inc_reg);\n+      break;\n+    }\n+}\n+\n+/* Return the next insn that uses (if reg_next_use is passed in\n+   NEXT_ARRAY) or defines (if reg_next_def is passed in NEXT_ARRAY)\n+   REGNO in BB.  */\n+\n+static rtx\n+get_next_ref (int regno, basic_block bb, rtx *next_array)\n+{\n+  rtx insn = next_array[regno];\n+\n+  /* Lazy about cleaning out the next_arrays.  */\n+  if (insn && BASIC_BLOCK (BLOCK_NUM (insn)) != bb)\n+    {\n+      next_array[regno] = NULL;\n+      insn = NULL;\n+    }\n+\n+  return insn;\n+}\n+\n+\n+/* Reverse the operands in a mem insn.  */\n+\n+static void \n+reverse_mem (void)\n+{\n+  rtx tmp = mem_insn.reg1; \n+  mem_insn.reg1 = mem_insn.reg0;\n+  mem_insn.reg0 = tmp;\n+}\n+\n+\n+/* Reverse the operands in a inc insn.  */\n+\n+static void \n+reverse_inc (void)\n+{\n+  rtx tmp = inc_insn.reg1; \n+  inc_insn.reg1 = inc_insn.reg0;\n+  inc_insn.reg0 = tmp;\n+}\n+\n+\n+/* Return true if INSN is of a form \"a = b op c\" where a and b are\n+   regs.  op is + if c is a reg and +|- if c is a const.  Fill in\n+   INC_INSN with what is found.  \n+   \n+   This function is called in two contexts, if BEFORE_MEM is true,\n+   this is called for each insn in the basic block.  If BEFORE_MEM is\n+   false, it is called for the instruction in the block that uses the\n+   index register for some memory reference that is currently being\n+   processed.  */\n+\n+static bool\n+parse_add_or_inc (rtx insn, bool before_mem)\n+{\n+  rtx pat = single_set (insn);\n+  if (!pat)\n+    return false;\n+\n+  /* Result must be single reg.  */\n+  if (!REG_P (SET_DEST (pat)))\n+    return false;\n+\n+  if ((GET_CODE (SET_SRC (pat)) != PLUS)\n+      && (GET_CODE (SET_SRC (pat)) != MINUS))\n+    return false;\n+\n+  if (!REG_P (XEXP (SET_SRC (pat), 0)))\n+    return false;\n+\n+  inc_insn.insn = insn;\n+  inc_insn.pat = pat;\n+  inc_insn.reg_res = SET_DEST (pat);\n+  inc_insn.reg0 = XEXP (SET_SRC (pat), 0);\n+  if (rtx_equal_p (inc_insn.reg_res, inc_insn.reg0))\n+    inc_insn.form = before_mem ? FORM_PRE_INC : FORM_POST_INC;\n+  else \n+    inc_insn.form = before_mem ? FORM_PRE_ADD : FORM_POST_ADD;\n+\n+  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == CONST_INT)\n+    {\n+      /* Process a = b + c where c is a const.  */\n+      inc_insn.reg1_is_const = true;\n+      if (GET_CODE (SET_SRC (pat)) == PLUS)\n+\t{\n+\t  inc_insn.reg1 = XEXP (SET_SRC (pat), 1);\n+\t  inc_insn.reg1_val = INTVAL (inc_insn.reg1);\n+\t}\n+      else\n+\t{\n+\t  inc_insn.reg1_val = -INTVAL (XEXP (SET_SRC (pat), 1));\n+\t  inc_insn.reg1 = GEN_INT (inc_insn.reg1_val);\n+\t}\n+      return true;\n+    }\n+  else if ((HAVE_PRE_MODIFY_REG || HAVE_POST_MODIFY_REG)\n+\t   && (REG_P (XEXP (SET_SRC (pat), 1)))\n+\t   && GET_CODE (SET_SRC (pat)) == PLUS)\n+    {\n+      /* Process a = b + c where c is a reg.  */\n+      inc_insn.reg1 = XEXP (SET_SRC (pat), 1);\n+      inc_insn.reg1_is_const = false;\n+      \n+      if (inc_insn.form == FORM_PRE_INC \n+\t  || inc_insn.form == FORM_POST_INC)\n+\treturn true;\n+      else if (rtx_equal_p (inc_insn.reg_res, inc_insn.reg1))\n+\t{\n+\t  /* Reverse the two operands and turn *_ADD into *_INC since\n+\t     a = c + a.  */\n+\t  reverse_inc ();\n+\t  inc_insn.form = before_mem ? FORM_PRE_INC : FORM_POST_INC;\n+\t  return true;\n+\t}\n+      else \n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* A recursive function that checks all of the mem uses in\n+   ADDRESS_OF_X to see if any single one of them is compatible with\n+   what has been found in inc_insn.\n+\n+   -1 is returned for success.  0 is returned if nothing was found and \n+   1 is returned for failure. */\n+\n+static int\n+find_address (rtx *address_of_x)\n+{\n+  rtx x = *address_of_x;\n+  enum rtx_code code = GET_CODE (x);\n+  const char *const fmt = GET_RTX_FORMAT (code);\n+  int i;\n+  int value = 0;\n+  int tem;\n+\n+  if (code == MEM && rtx_equal_p (XEXP (x, 0), inc_insn.reg_res))\n+    {\n+      /* Match with *reg0.  */\n+      mem_insn.mem_loc = address_of_x;\n+      mem_insn.reg0 = inc_insn.reg_res;\n+      mem_insn.reg1_is_const = true;\n+      mem_insn.reg1_val = 0;\n+      mem_insn.reg1 = GEN_INT (0);\n+      return -1;\n+    }\n+  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n+      && rtx_equal_p (XEXP (XEXP (x, 0), 0), inc_insn.reg_res))\n+    {\n+      rtx b = XEXP (XEXP (x, 0), 1);\n+      mem_insn.mem_loc = address_of_x;\n+      mem_insn.reg0 = inc_insn.reg_res;\n+      mem_insn.reg1 = b;\n+      mem_insn.reg1_is_const = inc_insn.reg1_is_const;\n+      if (GET_CODE (b) == CONST_INT)\n+\t{\n+\t  /* Match with *(reg0 + reg1) where reg1 is a const. */\n+\t  HOST_WIDE_INT val = INTVAL (b);\n+\t  if (inc_insn.reg1_is_const \n+\t      && (inc_insn.reg1_val == val || inc_insn.reg1_val == -val))\n+\t    {\n+\t      mem_insn.reg1_val = val;\n+\t      return -1;\n+\t    }\n+\t}\n+      else if (!inc_insn.reg1_is_const \n+\t       && rtx_equal_p (inc_insn.reg1, b)) \n+\t/* Match with *(reg0 + reg1). */\n+\treturn -1;\n+    }\n+\n+  if (code == SIGN_EXTRACT || code == ZERO_EXTRACT)\n+    {\n+      /* If REG occurs inside a MEM used in a bit-field reference,\n+\t that is unacceptable.  */\n+      if (find_address (&XEXP (x, 0)))\n+\treturn 1;\n+    }\n+\n+  if (x == inc_insn.reg_res)\n+    return 1;\n+\n+  /* Time for some deep diving.  */\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  tem = find_address (&XEXP (x, i));\n+\t  /* If this is the first use, let it go so the rest of the\n+\t     insn can be checked.  */\n+\t  if (value == 0)\n+\t    value = tem;\n+\t  else if (tem != 0)\n+\t    /* More than one match was found.  */\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      tem = find_address (&XVECEXP (x, i, j));\n+\t      /* If this is the first use, let it go so the rest of\n+\t\t the insn can be checked.  */\n+\t      if (value == 0)\n+\t\tvalue = tem;\n+\t      else if (tem != 0)\n+\t\t/* More than one match was found.  */\n+\t\treturn 1;\n+\t    }\n+\t}\n+    }\n+  return value;\n+}\n+\n+/* Once a suitable mem reference has been found and the MEM_INSN\n+   structure has been filled in, FIND_INC is called to see if there is\n+   a suitable add or inc insn that follows the mem reference and\n+   determine if it is suitable to merge.\n+\n+   In the case where the MEM_INSN has two registers in the reference,\n+   this function may be called recursively.  The first time looking\n+   for an add of the first register, and if that fails, looking for an\n+   add of the second register.  The FIRST_TRY parameter is used to\n+   only allow the parameters to be reversed once.  */\n+\n+static bool \n+find_inc (bool first_try)\n+{\n+  rtx insn;\n+  basic_block bb = BASIC_BLOCK (BLOCK_NUM (mem_insn.insn));\n+  rtx other_insn;\n+  struct df_ref **def_rec;\n+\n+  /* Make sure this reg appears only once in this insn.  */\n+  if (count_occurrences (PATTERN (mem_insn.insn), mem_insn.reg0, 1) != 1)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"mem count failure\\n\"); \n+      return false;\n+    }\n+\n+  if (dump_file)\n+    dump_mem_insn (dump_file);\n+\n+  /* Find the next use that is an inc.  */\n+  insn = get_next_ref (REGNO (mem_insn.reg0), \n+\t\t       BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)), \n+\t\t       reg_next_inc_use);\n+  if (!insn)\n+    return false;\n+\n+  /* Even though we know the next use is an add or inc because it came\n+     from the reg_next_inc_use, we must still reparse.  */\n+  if (!parse_add_or_inc (insn, false))\n+    {\n+      /* Next use was not an add.  Look for one extra case. It could be\n+\t that we have:\n+\t \n+\t *(a + b)\n+\t ...= a;\n+\t ...= b + a\n+\t \n+\t if we reverse the operands in the mem ref we would\n+\t find this.  Only try it once though.  */\n+      if (first_try && !mem_insn.reg1_is_const)\n+\t{\n+\t  reverse_mem ();\n+\t  return find_inc (false);\n+\t}\n+      else\n+\treturn false;\n+    }\n+\n+  /* Need to assure that none of the operands of the inc instruction are \n+     assigned to by the mem insn.  */\n+  for (def_rec = DF_INSN_DEFS (mem_insn.insn); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      unsigned int regno = DF_REF_REGNO (def);\n+      if ((regno == REGNO (inc_insn.reg0)) \n+\t  || (regno == REGNO (inc_insn.reg_res)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"inc conflicts with store failure.\\n\");\n+\t  return false;\n+\t}\n+      if (!inc_insn.reg1_is_const && (regno == REGNO (inc_insn.reg1)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"inc conflicts with store failure.\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (dump_file)\n+    dump_inc_insn (dump_file);\n+\n+  if (inc_insn.form == FORM_POST_ADD)\n+    {\n+      /* Make sure that there is no insn that assigns to inc_insn.res\n+\t between the mem_insn and the inc_insn.  */\n+      rtx other_insn = get_next_ref (REGNO (inc_insn.reg_res), \n+\t\t\t\t     BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)), \n+\t\t\t\t     reg_next_def);\n+      if (other_insn != inc_insn.insn)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \n+\t\t     \"result of add is assigned to between mem and inc insns.\\n\");\n+\t  return false;\n+\t}\n+\n+      other_insn = get_next_ref (REGNO (inc_insn.reg_res), \n+\t\t\t\t BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)), \n+\t\t\t\t reg_next_use);\n+      if (other_insn \n+\t  && (other_insn != inc_insn.insn)\n+\t  && (DF_INSN_LUID (inc_insn.insn) > DF_INSN_LUID (other_insn)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \n+\t\t     \"result of add is used between mem and inc insns.\\n\");\n+\t  return false;\n+\t}\n+\n+      /* For the post_add to work, the result_reg of the inc must not be\n+\t used in the mem insn since this will become the new index\n+\t register.  */\n+      if (count_occurrences (PATTERN (mem_insn.insn), inc_insn.reg_res, 1) != 0)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"base reg replacement failure.\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (mem_insn.reg1_is_const)\n+    {\n+      if (mem_insn.reg1_val == 0)\n+\t{\n+\t  if (!inc_insn.reg1_is_const)\n+\t    {\n+\t      /* The mem looks like *r0 and the rhs of the add has two\n+\t\t registers.  */\n+\t      int luid = DF_INSN_LUID (inc_insn.insn);\n+\t      if (inc_insn.form == FORM_POST_ADD)\n+\t\t{\n+\t\t  /* The trick is that we are not going to increment r0, \n+\t\t     we are going to increment the result of the add insn.\n+\t\t     For this trick to be correct, the result reg of\n+\t\t     the inc must be a valid addressing reg.  */\n+\t\t  if (GET_MODE (inc_insn.reg_res) != Pmode)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"base reg mode failure.\\n\");\n+\t\t      return false;\n+\t\t    }\n+\n+\t\t  /* We also need to make sure that the next use of\n+\t\t     inc result is after the inc.  */\n+\t\t  other_insn \n+\t\t    = get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_use);\n+\t\t  if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\t    return false;\n+\n+\t\t  if (!rtx_equal_p (mem_insn.reg0, inc_insn.reg0))\n+\t\t    reverse_inc (); \n+\t\t}\n+\n+\t      other_insn \n+\t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n+\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\treturn false;\n+\t    }\n+\t}\n+      /* Both the inc/add and the mem have a constant.  Need to check\n+\t that the constants are ok. */\n+      else if ((mem_insn.reg1_val != inc_insn.reg1_val)\n+\t       && (mem_insn.reg1_val != -inc_insn.reg1_val))\n+\treturn false;\n+    }\n+  else\n+    {\n+      /* The mem insn is of the form *(a + b) where a and b are both\n+\t regs.  It may be that in order to match the add or inc we\n+\t need to treat it as if it was *(b + a).  It may also be that\n+\t the add is of the form a + c where c does not match b and\n+\t then we just abandon this.  */\n+      \n+      int luid = DF_INSN_LUID (inc_insn.insn);\n+      rtx other_insn;\n+      \n+      /* Make sure this reg appears only once in this insn.  */\n+      if (count_occurrences (PATTERN (mem_insn.insn), mem_insn.reg1, 1) != 1)\n+\treturn false;\n+      \n+      if (inc_insn.form == FORM_POST_ADD)\n+\t{\n+\t  /* For this trick to be correct, the result reg of the inc\n+\t     must be a valid addressing reg.  */\n+\t  if (GET_MODE (inc_insn.reg_res) != Pmode)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"base reg mode failure.\\n\");\n+\t      return false;\n+\t    }\n+\n+\t  if (rtx_equal_p (mem_insn.reg0, inc_insn.reg0))\n+\t    {\n+\t      if (!rtx_equal_p (mem_insn.reg1, inc_insn.reg1))\n+\t\t{\n+\t\t  /* See comment above on find_inc (false) call.  */\n+\t\t  if (first_try)\n+\t\t    {\n+\t\t      reverse_mem ();\n+\t\t      return find_inc (false);\n+\t\t    }\n+\t\t  else\n+\t\t    return false;\n+\t\t}\n+\n+\t      /* Need to check that there are no assignemnts to b\n+\t\t before the add insn.  */\n+\t      other_insn \n+\t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n+\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\treturn false;\n+\t      /* All ok for the next step.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We know that mem_insn.reg0 must equal inc_insn.reg1\n+\t\t or else we would not have found the inc insn.  */\n+\t      reverse_mem ();\n+\t      if (!rtx_equal_p (mem_insn.reg0, inc_insn.reg0))\n+\t\t{\n+\t\t  /* See comment above on find_inc (false) call.  */\n+\t\t  if (first_try)\n+\t\t    return find_inc (false);\n+\t\t  else\n+\t\t    return false;\n+\t\t}\n+\t      /* To have gotten here know that.\n+\t       *(b + a)\n+\t       \n+\t       ... = (b + a)\n+\t       \n+\t       We also know that the lhs of the inc is not b or a.  We\n+\t       need to make sure that there are no assignments to b\n+\t       between the mem ref and the inc.  */\t \n+\t      \n+\t      other_insn \n+\t\t= get_next_ref (REGNO (inc_insn.reg0), bb, reg_next_def);\n+\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\treturn false;\n+\t    }\n+\n+\t  /* Need to check that the next use of the add result is later than\n+\t     add insn since this will be the reg incremented.  */\n+\t  other_insn \n+\t    = get_next_ref (REGNO (inc_insn.reg_res), bb, reg_next_use);\n+\t  if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t    return false;\n+\t}\n+      else /* FORM_POST_INC.  There is less to check here because we\n+\t      know that operands must line up.  */ \n+\t{\n+\t  if (!rtx_equal_p (mem_insn.reg1, inc_insn.reg1))\n+\t    /* See comment above on find_inc (false) call.  */\n+\t    {\n+\t      if (first_try)\n+\t\t{\n+\t\t  reverse_mem ();\n+\t\t  return find_inc (false);\n+\t\t}\n+\t      else \n+\t\treturn false;\n+\t    }\n+      \n+\t  /* To have gotten here know that.\n+\t   *(a + b)\n+\t   \n+\t   ... = (a + b)\n+\t   \n+\t   We also know that the lhs of the inc is not b.  We need to make\n+\t   sure that there are no assignments to b between the mem ref and\n+\t   the inc.  */\n+\t  other_insn \n+\t    = get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n+\t  if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t    return false;\n+\t}\n+    }\n+\n+  if (inc_insn.form == FORM_POST_INC)\n+    {\n+      other_insn \n+\t= get_next_ref (REGNO (inc_insn.reg0), bb, reg_next_use);\n+      /* When we found inc_insn, we were looking for the\n+\t next add or inc, not the next insn that used the\n+\t reg.  Because we are going to increment the reg\n+\t in this form, we need to make sure that there\n+\t were no interveining uses of reg.  */\n+      if (inc_insn.insn != other_insn)\n+\treturn false;\n+    }\n+\n+  return try_merge ();\n+}\n+\n+\n+/* A recursive function that walks ADDRESS_OF_X to find all of the mem\n+   uses in pat that could be used as an auto inc or dec.  It then\n+   calls FIND_INC for each one.  */\n+\n+static bool\n+find_mem (rtx *address_of_x)\n+{\n+  rtx x = *address_of_x;\n+  enum rtx_code code = GET_CODE (x);\n+  const char *const fmt = GET_RTX_FORMAT (code);\n+  int i;\n+\n+  if (code == MEM && REG_P (XEXP (x, 0)))\n+    {\n+      /* Match with *reg0.  */\n+      mem_insn.mem_loc = address_of_x;\n+      mem_insn.reg0 = XEXP (x, 0);\n+      mem_insn.reg1_is_const = true;\n+      mem_insn.reg1_val = 0;\n+      mem_insn.reg1 = GEN_INT (0);\n+      if (find_inc (true))\n+\treturn true;\n+    }\n+  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (x, 0), 0)))\n+    {\n+      rtx reg1 = XEXP (XEXP (x, 0), 1);\n+      mem_insn.mem_loc = address_of_x;\n+      mem_insn.reg0 = XEXP (XEXP (x, 0), 0);\n+      mem_insn.reg1 = reg1;\n+      if (GET_CODE (reg1) == CONST_INT)\n+\t{\n+\t  mem_insn.reg1_is_const = true;\n+\t  /* Match with *(reg0 + c) where c is a const. */\n+\t  mem_insn.reg1_val = INTVAL (reg1);\n+\t  if (find_inc (true))\n+\t    return true;\n+\t}\n+      else if (REG_P (reg1))\n+\t{\n+\t  /* Match with *(reg0 + reg1).  */\n+\t  mem_insn.reg1_is_const = false;\n+\t  if (find_inc (true))\n+\t    return true;\n+\t}\n+    }\n+\n+  if (code == SIGN_EXTRACT || code == ZERO_EXTRACT)\n+    {\n+      /* If REG occurs inside a MEM used in a bit-field reference,\n+\t that is unacceptable.  */\n+      return false;\n+    }\n+\n+  /* Time for some deep diving.  */\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (find_mem (&XEXP (x, i)))\n+\t    return true;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (find_mem (&XVECEXP (x, i, j)))\n+\t      return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+\n+/* Try to combine all incs and decs by constant values with memory\n+   references in BB.  */\n+\n+static void\n+merge_in_block (int max_reg, basic_block bb)\n+{\n+  rtx insn;\n+  rtx curr;\n+  int success_in_block = 0;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\\nstarting bb %d\\n\", bb->index);\n+\n+  FOR_BB_INSNS_REVERSE_SAFE (bb, insn, curr)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      bool insn_is_add_or_inc = true;\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\t\n+\n+      /* This continue is deliberate.  We do not want the uses of the\n+\t jump put into reg_next_use because it is not considered safe to \n+\t combine a preincrement with a jump.  */\n+      if (JUMP_P (insn))\n+\tcontinue;\n+\n+      if (dump_file)\n+\tdump_insn_slim (dump_file, insn);\n+\n+      /* Does this instruction increment or decrement a register?  */\n+      if (parse_add_or_inc (insn, true))\n+\t{\n+\t  int regno = REGNO (inc_insn.reg_res);\n+\t  /* Cannot handle case where there are three separate regs\n+\t     before a mem ref.  Too many moves would be needed to be\n+\t     profitable.  */\n+\t  if ((inc_insn.form == FORM_PRE_INC) || inc_insn.reg1_is_const)\n+\t    {\n+\t      mem_insn.insn = get_next_ref (regno, bb, reg_next_use);\n+\t      if (mem_insn.insn)\n+\t\t{\n+\t\t  bool ok = true;\n+\t\t  if (!inc_insn.reg1_is_const)\n+\t\t    {\n+\t\t      /* We are only here if we are going to try a\n+\t\t\t HAVE_*_MODIFY_REG type transformation.  c is a\n+\t\t\t reg and we must sure that the path from the\n+\t\t\t inc_insn to the mem_insn.insn is both def and use\n+\t\t\t clear of c because the inc insn is going to move\n+\t\t\t into the mem_insn.insn.  */\n+\t\t      int luid = DF_INSN_LUID (mem_insn.insn);\n+\t\t      rtx other_insn \n+\t\t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_use);\n+\t\t      \n+\t\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\t\tok = false;\n+\t\t      \n+\t\t      other_insn \n+\t\t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n+\t\t      \n+\t\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\t\tok = false;\n+\t\t    }\n+\t\t  \n+\t\t  if (dump_file)\n+\t\t    dump_inc_insn (dump_file);\n+\t\t  \n+\t\t  if (ok && find_address (&PATTERN (mem_insn.insn)) == -1)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tdump_mem_insn (dump_file);\n+\t\t      if (try_merge ())\n+\t\t\t{\n+\t\t\t  success_in_block++;\n+\t\t\t  insn_is_add_or_inc = false;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  insn_is_add_or_inc = false;\n+\t  mem_insn.insn = insn;\n+\t  if (find_mem (&PATTERN (insn)))\n+\t    success_in_block++;\n+\t}\n+      \n+      /* If the inc insn was merged with a mem, the inc insn is gone\n+\t and there is noting to update.  */\n+      if (DF_INSN_UID_GET(uid))\n+\t{\n+\t  struct df_ref **def_rec;\n+\t  struct df_ref **use_rec;\n+\t  /* Need to update next use.  */\n+\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t    {\n+\t      struct df_ref *def = *def_rec;\n+\t      reg_next_use[DF_REF_REGNO (def)] = NULL;\n+\t      reg_next_inc_use[DF_REF_REGNO (def)] = NULL;\n+\t      reg_next_def[DF_REF_REGNO (def)] = insn;\n+\t    }\n+\t  \n+\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t    {\n+\t      struct df_ref *use = *use_rec;\n+\t      reg_next_use[DF_REF_REGNO (use)] = insn;\n+\t      if (insn_is_add_or_inc)\n+\t\treg_next_inc_use[DF_REF_REGNO (use)] = insn;\n+\t      else\n+\t\treg_next_inc_use[DF_REF_REGNO (use)] = NULL;\n+\t    }  \n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"skipping update of deleted insn %d\\n\", uid);\n+    }\n+\n+  /* If we were successful, try again.  There may have been several\n+     opportunities that were interleaved.  This is rare but\n+     gcc.c-torture/compile/pr17273.c actually exhibits this.  */\n+  if (success_in_block)\n+    {\n+      /* In this case, we must clear these vectors since the trick of\n+\t testing if the stale insn in the block will not work.  */\n+      memset (reg_next_use, 0, max_reg * sizeof(rtx));\n+      memset (reg_next_inc_use, 0, max_reg * sizeof(rtx));\n+      memset (reg_next_def, 0, max_reg * sizeof(rtx));\n+      df_recompute_luids (bb);\n+      merge_in_block (max_reg, bb);\n+    }\n+}\n+\n+#endif\n+\n+static unsigned int \n+rest_of_handle_auto_inc_dec (void)\n+{\n+#ifdef AUTO_INC_DEC\n+  basic_block bb;\n+  int max_reg = max_reg_num ();\n+\n+  if (!initialized)\n+    init_decision_table ();\n+\n+  mem_tmp = gen_rtx_MEM (Pmode, NULL_RTX);\n+\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n+  reg_next_use = XCNEWVEC (rtx, max_reg);\n+  reg_next_inc_use = XCNEWVEC (rtx, max_reg);\n+  reg_next_def = XCNEWVEC (rtx, max_reg);\n+  FOR_EACH_BB (bb)\n+    merge_in_block (max_reg, bb);\n+\n+  free (reg_next_use);\n+  free (reg_next_inc_use);\n+  free (reg_next_def);\n+\n+  mem_tmp = NULL;\n+#endif\n+  return 0;\n+}\n+\n+\n+/* Discover auto-inc auto-dec instructions.  */\n+\n+static bool\n+gate_auto_inc_dec (void)\n+{\n+#ifdef AUTO_INC_DEC\n+  return (optimize > 0 && flag_auto_inc_dec);\n+#else\n+  return false;\n+#endif\n+}\n+\n+\n+struct tree_opt_pass pass_inc_dec =\n+{\n+  \"auto-inc-dec\",                       /* name */\n+  gate_auto_inc_dec,                    /* gate */\n+  rest_of_handle_auto_inc_dec,          /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_AUTO_INC_DEC,                      /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func | \n+  TODO_df_finish,                       /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+"}, {"sha": "75bba8121e09f5ced5789cca91fabfba368d57ea", "filename": "gcc/basic-block.h", "status": "modified", "additions": 61, "deletions": 110, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Define control and data flow tables, and regsets.\n-   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -257,12 +257,6 @@ struct rtl_bb_info GTY(())\n   rtx head_;\n   rtx end_;\n \n-  /* The registers that are live on entry to this block.  */\n-  bitmap GTY ((skip (\"\"))) global_live_at_start;\n-\n-  /* The registers that are live on exit from this block.  */\n-  bitmap GTY ((skip (\"\"))) global_live_at_end;\n-\n   /* In CFGlayout mode points to insn notes/jumptables to be placed just before\n      and after the block.   */\n   rtx header;\n@@ -299,46 +293,45 @@ DEF_VEC_ALLOC_P(basic_block,heap);\n \n enum bb_flags\n {\n-\n-  /* Set if insns in BB have are modified.  Used for updating liveness info.  */\n-  BB_DIRTY = 1,\n-\n   /* Only set on blocks that have just been created by create_bb.  */\n-  BB_NEW = 2,\n+  BB_NEW = 1 << 0,\n \n   /* Set by find_unreachable_blocks.  Do not rely on this being set in any\n      pass.  */\n-  BB_REACHABLE = 4,\n+  BB_REACHABLE = 1 << 1,\n \n   /* Set for blocks in an irreducible loop by loop analysis.  */\n-  BB_IRREDUCIBLE_LOOP = 8,\n+  BB_IRREDUCIBLE_LOOP = 1 << 2,\n \n   /* Set on blocks that may actually not be single-entry single-exit block.  */\n-  BB_SUPERBLOCK = 16,\n+  BB_SUPERBLOCK = 1 << 3,\n \n   /* Set on basic blocks that the scheduler should not touch.  This is used\n      by SMS to prevent other schedulers from messing with the loop schedule.  */\n-  BB_DISABLE_SCHEDULE = 32,\n+  BB_DISABLE_SCHEDULE = 1 << 4,\n \n   /* Set on blocks that should be put in a hot section.  */\n-  BB_HOT_PARTITION = 64,\n+  BB_HOT_PARTITION = 1 << 5,\n \n   /* Set on blocks that should be put in a cold section.  */\n-  BB_COLD_PARTITION = 128,\n+  BB_COLD_PARTITION = 1 << 6,\n \n   /* Set on block that was duplicated.  */\n-  BB_DUPLICATED = 256,\n+  BB_DUPLICATED = 1 << 7,\n+\n+  /* Set if the label at the top of this block is the target of a non-local goto.  */\n+  BB_NON_LOCAL_GOTO_TARGET = 1 << 8,\n \n   /* Set on blocks that are in RTL format.  */\n-  BB_RTL = 1024,\n+  BB_RTL = 1 << 9 ,\n \n   /* Set on blocks that are forwarder blocks.\n      Only used in cfgcleanup.c.  */\n-  BB_FORWARDER_BLOCK = 2048,\n+  BB_FORWARDER_BLOCK = 1 << 10,\n \n   /* Set on blocks that cannot be threaded through.\n      Only used in cfgcleanup.c.  */\n-  BB_NONTHREADABLE_BLOCK = 4096\n+  BB_NONTHREADABLE_BLOCK = 1 << 11\n };\n \n /* Dummy flag for convenience in the hot/cold partitioning code.  */\n@@ -435,11 +428,23 @@ struct control_flow_graph GTY(())\n        (INSN) && (INSN) != NEXT_INSN (BB_END (BB));\t\\\n        (INSN) = NEXT_INSN (INSN))\n \n+/* For iterating over insns in basic block when we might remove the\n+   current insn.  */\n+#define FOR_BB_INSNS_SAFE(BB, INSN, CURR)\t\t\t\\\n+  for ((INSN) = BB_HEAD (BB), (CURR) = (INSN) ? NEXT_INSN ((INSN)): NULL;\t\\\n+       (INSN) && (INSN) != NEXT_INSN (BB_END (BB));\t\\\n+       (INSN) = (CURR), (CURR) = (INSN) ? NEXT_INSN ((INSN)) : NULL)\n+       \n #define FOR_BB_INSNS_REVERSE(BB, INSN)\t\t\\\n   for ((INSN) = BB_END (BB);\t\t\t\\\n        (INSN) && (INSN) != PREV_INSN (BB_HEAD (BB));\t\\\n        (INSN) = PREV_INSN (INSN))\n \n+#define FOR_BB_INSNS_REVERSE_SAFE(BB, INSN, CURR)\t\\\n+  for ((INSN) = BB_END (BB),(CURR) = (INSN) ? PREV_INSN ((INSN)) : NULL;\t\\\n+       (INSN) && (INSN) != PREV_INSN (BB_HEAD (BB));\t\\\n+       (INSN) = (CURR), (CURR) = (INSN) ? PREV_INSN ((INSN)) : NULL)\n+\n /* Cycles through _all_ basic blocks, even the fake ones (entry and\n    exit block).  */\n \n@@ -451,18 +456,6 @@ struct control_flow_graph GTY(())\n \n extern bitmap_obstack reg_obstack;\n \n-/* Indexed by n, gives number of basic block that  (REG n) is used in.\n-   If the value is REG_BLOCK_GLOBAL (-2),\n-   it means (REG n) is used in more than one basic block.\n-   REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.  */\n-\n-#define REG_BLOCK_UNKNOWN -1\n-#define REG_BLOCK_GLOBAL -2\n-\n-#define REG_BASIC_BLOCK(N)\t\t\t\t\\\n-  (VEC_index (reg_info_p, reg_n_info, N)->basic_block)\n \f\n /* Stuff for recording basic block info.  */\n \n@@ -505,7 +498,8 @@ extern edge redirect_edge_succ_nodup (edge, basic_block);\n extern void redirect_edge_pred (edge, basic_block);\n extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n extern void clear_bb_flags (void);\n-extern int post_order_compute (int *, bool);\n+extern int post_order_compute (int *, bool, bool);\n+extern int inverted_post_order_compute (int *);\n extern int pre_and_rev_post_order_compute (int *, int *, bool);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(basic_block, void *),\n@@ -515,7 +509,6 @@ extern void dump_bb_info (basic_block, bool, bool, int, const char *, FILE *);\n extern void dump_edge_info (FILE *, edge, int);\n extern void brief_dump_cfg (FILE *);\n extern void clear_edges (void);\n-extern rtx first_insn_after_basic_block_note (basic_block);\n extern void scale_bbs_frequencies_int (basic_block *, int, int, int);\n extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n \t\t\t\t\t     gcov_type);\n@@ -788,76 +781,26 @@ void verify_edge_list (FILE *, struct edge_list *);\n int find_edge_index (struct edge_list *, basic_block, basic_block);\n edge find_edge (basic_block, basic_block);\n \n-\n-enum update_life_extent\n-{\n-  UPDATE_LIFE_LOCAL = 0,\n-  UPDATE_LIFE_GLOBAL = 1,\n-  UPDATE_LIFE_GLOBAL_RM_NOTES = 2\n-};\n-\n-/* Flags for life_analysis and update_life_info.  */\n-\n-#define PROP_DEATH_NOTES\t1\t/* Create DEAD and UNUSED notes.  */\n-#define PROP_LOG_LINKS\t\t2\t/* Create LOG_LINKS.  */\n-#define PROP_REG_INFO\t\t4\t/* Update regs_ever_live et al.  */\n-#define PROP_KILL_DEAD_CODE\t8\t/* Remove dead code.  */\n-#define PROP_SCAN_DEAD_CODE\t16\t/* Scan for dead code.  */\n-#define PROP_ALLOW_CFG_CHANGES\t32\t/* Allow the CFG to be changed\n-\t\t\t\t\t   by dead code removal.  */\n-#define PROP_AUTOINC\t\t64\t/* Create autoinc mem references.  */\n-#define PROP_SCAN_DEAD_STORES\t128\t/* Scan for dead code.  */\n-#define PROP_ASM_SCAN\t\t256\t/* Internal flag used within flow.c\n-\t\t\t\t\t   to flag analysis of asms.  */\n-#define PROP_DEAD_INSN\t\t1024\t/* Internal flag used within flow.c\n-\t\t\t\t\t   to flag analysis of dead insn.  */\n-#define PROP_POST_REGSTACK\t2048\t/* We run after reg-stack and need\n-\t\t\t\t\t   to preserve REG_DEAD notes for\n-\t\t\t\t\t   stack regs.  */\n-#define PROP_FINAL\t\t(PROP_DEATH_NOTES | PROP_LOG_LINKS  \\\n-\t\t\t\t | PROP_REG_INFO | PROP_KILL_DEAD_CODE  \\\n-\t\t\t\t | PROP_SCAN_DEAD_CODE | PROP_AUTOINC \\\n-\t\t\t\t | PROP_ALLOW_CFG_CHANGES \\\n-\t\t\t\t | PROP_SCAN_DEAD_STORES)\n-#define PROP_POSTRELOAD\t\t(PROP_DEATH_NOTES  \\\n-\t\t\t\t | PROP_KILL_DEAD_CODE  \\\n-\t\t\t\t | PROP_SCAN_DEAD_CODE \\\n-\t\t\t\t | PROP_SCAN_DEAD_STORES)\n-\n #define CLEANUP_EXPENSIVE\t1\t/* Do relatively expensive optimizations\n \t\t\t\t\t   except for edge forwarding */\n #define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n #define CLEANUP_POST_REGSTACK\t4\t/* We run after reg-stack and need\n \t\t\t\t\t   to care REG_DEAD notes.  */\n-#define CLEANUP_UPDATE_LIFE\t8\t/* Keep life information up to date.  */\n-#define CLEANUP_THREADING\t16\t/* Do jump threading.  */\n-#define CLEANUP_NO_INSN_DEL\t32\t/* Do not try to delete trivially dead\n+#define CLEANUP_THREADING\t8\t/* Do jump threading.  */\n+#define CLEANUP_NO_INSN_DEL\t16\t/* Do not try to delete trivially dead\n \t\t\t\t\t   insns.  */\n-#define CLEANUP_CFGLAYOUT\t64\t/* Do cleanup in cfglayout mode.  */\n-#define CLEANUP_LOG_LINKS\t128\t/* Update log links.  */\n+#define CLEANUP_CFGLAYOUT\t32\t/* Do cleanup in cfglayout mode.  */\n \n /* The following are ORed in on top of the CLEANUP* flags in calls to\n    struct_equiv_block_eq.  */\n-#define STRUCT_EQUIV_START\t256\t /* Initializes the search range.  */\n-#define STRUCT_EQUIV_RERUN\t512\t/* Rerun to find register use in\n+#define STRUCT_EQUIV_START\t64\t /* Initializes the search range.  */\n+#define STRUCT_EQUIV_RERUN\t128\t/* Rerun to find register use in\n \t\t\t\t\t   found equivalence.  */\n-#define STRUCT_EQUIV_FINAL\t1024\t/* Make any changes necessary to get\n+#define STRUCT_EQUIV_FINAL\t256\t/* Make any changes necessary to get\n \t\t\t\t\t   actual equivalence.  */\n-#define STRUCT_EQUIV_NEED_FULL_BLOCK 2048 /* struct_equiv_block_eq is required\n+#define STRUCT_EQUIV_NEED_FULL_BLOCK 512 /* struct_equiv_block_eq is required\n \t\t\t\t\t     to match only full blocks  */\n-#define STRUCT_EQUIV_MATCH_JUMPS 4096\t/* Also include the jumps at the end of the block in the comparison.  */\n-\n-extern void life_analysis (int);\n-extern int update_life_info (sbitmap, enum update_life_extent, int);\n-extern int update_life_info_in_dirty_blocks (enum update_life_extent, int);\n-extern int count_or_remove_death_notes (sbitmap, int);\n-extern int propagate_block (basic_block, regset, regset, regset, int);\n-\n-struct propagate_block_info;\n-extern rtx propagate_one_insn (struct propagate_block_info *, rtx);\n-extern struct propagate_block_info *init_propagate_block_info\n- (basic_block, regset, regset, regset, int);\n-extern void free_propagate_block_info (struct propagate_block_info *);\n+#define STRUCT_EQUIV_MATCH_JUMPS 1024\t/* Also include the jumps at the end of the block in the comparison.  */\n \n /* In lcm.c */\n extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n@@ -883,31 +826,19 @@ extern void remove_predictions_associated_with_edge (edge);\n extern bool edge_probability_reliable_p (edge);\n extern bool br_prob_note_reliable_p (rtx);\n \n-/* In flow.c */\n+/* In cfg.c  */\n+extern void dump_regset (regset, FILE *);\n+extern void debug_regset (regset);\n extern void init_flow (void);\n extern void debug_bb (basic_block);\n extern basic_block debug_bb_n (int);\n extern void dump_regset (regset, FILE *);\n extern void debug_regset (regset);\n-extern void allocate_reg_life_data (void);\n extern void expunge_block (basic_block);\n extern void link_block (basic_block, basic_block);\n extern void unlink_block (basic_block);\n extern void compact_blocks (void);\n extern basic_block alloc_block (void);\n-extern void find_unreachable_blocks (void);\n-extern int delete_noop_moves (void);\n-extern basic_block force_nonfallthru (edge);\n-extern rtx block_label (basic_block);\n-extern bool forwarder_block_p (basic_block);\n-extern bool purge_all_dead_edges (void);\n-extern bool purge_dead_edges (basic_block);\n-extern void find_many_sub_basic_blocks (sbitmap);\n-extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n-extern bool can_fallthru (basic_block, basic_block);\n-extern bool could_fall_through (basic_block, basic_block);\n-extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n-extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n extern void alloc_aux_for_block (basic_block, int);\n extern void alloc_aux_for_blocks (int);\n extern void clear_aux_for_blocks (void);\n@@ -916,7 +847,27 @@ extern void alloc_aux_for_edge (edge, int);\n extern void alloc_aux_for_edges (int);\n extern void clear_aux_for_edges (void);\n extern void free_aux_for_edges (void);\n+\n+/* In cfganal.c  */\n+extern void find_unreachable_blocks (void);\n+extern bool forwarder_block_p (basic_block);\n+extern bool can_fallthru (basic_block, basic_block);\n+extern bool could_fall_through (basic_block, basic_block);\n+extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n+extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n+\n+/* In cfgrtl.c  */\n+extern basic_block force_nonfallthru (edge);\n+extern rtx block_label (basic_block);\n+extern bool purge_all_dead_edges (void);\n+extern bool purge_dead_edges (basic_block);\n+\n+/* In cfgbuild.c.  */\n+extern void find_many_sub_basic_blocks (sbitmap);\n+extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n extern void find_basic_blocks (rtx);\n+\n+/* In cfgcleanup.c.  */\n extern bool cleanup_cfg (int);\n extern bool delete_unreachable_blocks (void);\n "}, {"sha": "79e9dbf0d7eaf9136d735f88e156d3ba6151855c", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -85,6 +85,7 @@\n #include \"params.h\"\n #include \"toplev.h\"\n #include \"tree-pass.h\"\n+#include \"df.h\"\n \n #ifndef HAVE_conditional_execution\n #define HAVE_conditional_execution 0\n@@ -1607,16 +1608,6 @@ fix_crossing_conditional_branches (void)\n \t\t  last_bb->aux = new_bb;\n \t\t  prev_bb = last_bb;\n \t\t  last_bb = new_bb;\n-\n-\t\t  /* Update register liveness information.  */\n-\n-\t\t  new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-\t\t  new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-\t\t  COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n-\t\t\t\tprev_bb->il.rtl->global_live_at_end);\n-\t\t  COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n-\t\t\t\tprev_bb->il.rtl->global_live_at_end);\n-\n \t\t  /* Put appropriate instructions in new bb.  */\n \n \t\t  new_label = gen_label_rtx ();\n@@ -1840,10 +1831,7 @@ fix_edges_for_rarely_executed_code (edge *crossing_edges,\n      well.  */\n \n   if (!HAS_LONG_UNCOND_BRANCH)\n-    {\n-      fix_crossing_unconditional_branches ();\n-      reg_scan (get_insns (), max_reg_num ());\n-    }\n+    fix_crossing_unconditional_branches ();\n \n   add_reg_crossing_jump_notes ();\n }\n@@ -2205,13 +2193,11 @@ gate_handle_reorder_blocks (void)\n static unsigned int\n rest_of_handle_reorder_blocks (void)\n {\n-  unsigned int liveness_flags;\n   basic_block bb;\n \n   /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n      splitting possibly introduced more crossjumping opportunities.  */\n-  liveness_flags = (!HAVE_conditional_execution ? CLEANUP_UPDATE_LIFE : 0);\n-  cfg_layout_initialize (CLEANUP_EXPENSIVE | liveness_flags);\n+  cfg_layout_initialize (CLEANUP_EXPENSIVE);\n \n   if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n     {\n@@ -2224,14 +2210,7 @@ rest_of_handle_reorder_blocks (void)\n     reorder_basic_blocks ();\n   if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n       || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n-    cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n-\n-  /* On conditional execution targets we can not update the life cheaply, so\n-     we deffer the updating to after both cleanups.  This may lose some cases\n-     but should not be terribly bad.  */\n-  if (HAVE_conditional_execution)\n-    update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t      PROP_DEATH_NOTES);\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n \n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)\n@@ -2279,9 +2258,6 @@ rest_of_handle_partition_blocks (void)\n {\n   no_new_pseudos = 0;\n   partition_hot_cold_basic_blocks ();\n-  allocate_reg_life_data ();\n-  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n   no_new_pseudos = 1;\n   return 0;\n }"}, {"sha": "740a883b203ab13f7335e90801abe9187cdf0e74", "filename": "gcc/bitmap.c", "status": "modified", "additions": 395, "deletions": 143, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Functions to support general ended bitmaps.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -852,72 +852,151 @@ bitmap_and_into (bitmap a, bitmap b)\n   gcc_assert (!a->current || a->indx == a->current->indx);\n }\n \n+\n+/* Insert an element equal to SRC_ELT after DST_PREV, overwriting DST_ELT\n+   if non-NULL.  CHANGED is true if the destination bitmap had already been\n+   changed; the new value of CHANGED is returned.  */\n+\n+static inline bool\n+bitmap_elt_copy (bitmap dst, bitmap_element *dst_elt, bitmap_element *dst_prev,\n+\t\t bitmap_element *src_elt, bool changed)\n+{\n+  if (!changed && dst_elt && dst_elt->indx == src_elt->indx)\n+    {\n+      unsigned ix;\n+\n+      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\tif (src_elt->bits[ix] != dst_elt->bits[ix])\n+\t  {\n+\t    dst_elt->bits[ix] = src_elt->bits[ix];\n+\t    changed = true;\n+\t  }\n+    }\n+  else\n+    {\n+      changed = true;\n+      if (!dst_elt)\n+\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, src_elt->indx);\n+      else\n+\tdst_elt->indx = src_elt->indx;\n+      memcpy (dst_elt->bits, src_elt->bits, sizeof (dst_elt->bits));\n+    }\n+  return changed;\n+}\n+\n+\n+\n /* DST = A & ~B  */\n \n-void\n+bool\n bitmap_and_compl (bitmap dst, bitmap a, bitmap b)\n {\n   bitmap_element *dst_elt = dst->first;\n   bitmap_element *a_elt = a->first;\n   bitmap_element *b_elt = b->first;\n   bitmap_element *dst_prev = NULL;\n+  bitmap_element **dst_prev_pnext = &dst->first;\n+  bool changed = false;\n \n   gcc_assert (dst != a && dst != b);\n \n   if (a == b)\n     {\n+      changed = !bitmap_empty_p (dst);\n       bitmap_clear (dst);\n-      return;\n+      return changed;\n     }\n \n   while (a_elt)\n     {\n-      if (!b_elt || a_elt->indx < b_elt->indx)\n+      while (b_elt && b_elt->indx < a_elt->indx)\n+\tb_elt = b_elt->next;\n+\n+      if (!b_elt || b_elt->indx > a_elt->indx)\n \t{\n-\t  /* Copy a_elt.  */\n-\t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n-\t  else\n-\t    dst_elt->indx = a_elt->indx;\n-\t  memcpy (dst_elt->bits, a_elt->bits, sizeof (dst_elt->bits));\n-\t  dst_prev = dst_elt;\n-\t  dst_elt = dst_elt->next;\n+\t  changed = bitmap_elt_copy (dst, dst_elt, dst_prev, a_elt, changed);\n+\t  dst_prev = *dst_prev_pnext;\n+\t  dst_prev_pnext = &dst_prev->next;\n+\t  dst_elt = *dst_prev_pnext;\n \t  a_elt = a_elt->next;\n \t}\n-      else if (b_elt->indx < a_elt->indx)\n-\tb_elt = b_elt->next;\n+\n       else\n \t{\n \t  /* Matching elts, generate A & ~B.  */\n \t  unsigned ix;\n \t  BITMAP_WORD ior = 0;\n \n-\t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t  if (!changed && dst_elt && dst_elt->indx == a_elt->indx)\n+\t    {\n+\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t\t{\n+\t\t  BITMAP_WORD r = a_elt->bits[ix] & ~b_elt->bits[ix];\n+\n+\t\t  if (dst_elt->bits[ix] != r)\n+\t\t    {\n+\t\t      changed = true;\n+\t\t      dst_elt->bits[ix] = r;\n+\t\t    }\n+\t\t  ior |= r;\n+\t\t}\n+\t    }\n \t  else\n-\t    dst_elt->indx = a_elt->indx;\n-\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t    {\n-\t      BITMAP_WORD r = a_elt->bits[ix] & ~b_elt->bits[ix];\n+\t      bool new_element;\n+\t      if (!dst_elt || dst_elt->indx > a_elt->indx)\n+\t\t{\n+\t\t  dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t\t  new_element = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dst_elt->indx = a_elt->indx;\n+\t\t  new_element = false;\n+\t\t}\n \n-\t      dst_elt->bits[ix] = r;\n-\t      ior |= r;\n+\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t\t{\n+\t\t  BITMAP_WORD r = a_elt->bits[ix] & ~b_elt->bits[ix];\n+\n+\t\t  dst_elt->bits[ix] = r;\n+\t\t  ior |= r;\n+\t\t}\n+\n+\t      if (ior)\n+\t        changed = true;\n+\t      else\n+\t        {\n+\t          changed |= !new_element;\n+\t\t  bitmap_element_free (dst, dst_elt);\n+\t\t  dst_elt = *dst_prev_pnext;\n+\t\t}\n \t    }\n+\n \t  if (ior)\n \t    {\n-\t      dst_prev = dst_elt;\n-\t      dst_elt = dst_elt->next;\n+\t      dst_prev = *dst_prev_pnext;\n+\t      dst_prev_pnext = &dst_prev->next;\n+\t      dst_elt = *dst_prev_pnext;\n \t    }\n \t  a_elt = a_elt->next;\n \t  b_elt = b_elt->next;\n \t}\n     }\n+\n   /* Ensure that dst->current is valid.  */\n   dst->current = dst->first;\n-  bitmap_elt_clear_from (dst, dst_elt);\n+\n+  if (dst_elt)\n+    {\n+      changed = true;\n+      bitmap_elt_clear_from (dst, dst_elt);\n+    }\n   gcc_assert (!dst->current == !dst->first);\n   if (dst->current)\n     dst->indx = dst->current->indx;\n+\n+  return changed;\n }\n \n /* A &= ~B. Returns true if A changes */\n@@ -974,15 +1053,120 @@ bitmap_and_compl_into (bitmap a, bitmap b)\n   return changed != 0;\n }\n \n+/* Set COUNT bits from START in HEAD.  */\n+void\n+bitmap_set_range (bitmap head, unsigned int start, unsigned int count)\n+{\n+  unsigned int first_index, end_bit_plus1, last_index;\n+  bitmap_element *elt, *elt_prev;\n+  unsigned int i;\n+\n+  if (!count)\n+    return;\n+\n+  first_index = start / BITMAP_ELEMENT_ALL_BITS;\n+  end_bit_plus1 = start + count;\n+  last_index = (end_bit_plus1 - 1) / BITMAP_ELEMENT_ALL_BITS;\n+  elt = bitmap_find_bit (head, start);\n+\n+  /* If bitmap_find_bit returns zero, the current is the closest block\n+     to the result.  Otherwise, just use bitmap_element_allocate to\n+     ensure ELT is set; in the loop below, ELT == NULL means \"insert\n+     at the end of the bitmap\".  */\n+  if (!elt)\n+    {\n+      elt = bitmap_element_allocate (head);\n+      elt->indx = first_index;\n+      bitmap_element_link (head, elt);\n+    }\n+\n+  gcc_assert (elt->indx == first_index);\n+  elt_prev = elt->prev;\n+  for (i = first_index; i <= last_index; i++)\n+    {\n+      unsigned elt_start_bit = i * BITMAP_ELEMENT_ALL_BITS;\n+      unsigned elt_end_bit_plus1 = elt_start_bit + BITMAP_ELEMENT_ALL_BITS;\n+\n+      unsigned int first_word_to_mod;\n+      BITMAP_WORD first_mask;\n+      unsigned int last_word_to_mod;\n+      BITMAP_WORD last_mask;\n+      unsigned int ix;\n+\n+      if (!elt || elt->indx != i)\n+\telt = bitmap_elt_insert_after (head, elt_prev, i);\n+\n+      if (elt_start_bit <= start)\n+\t{\n+\t  /* The first bit to turn on is somewhere inside this\n+\t     elt.  */\n+\t  first_word_to_mod = (start - elt_start_bit) / BITMAP_WORD_BITS;\n+\n+\t  /* This mask should have 1s in all bits >= start position. */\n+\t  first_mask =\n+\t    (((BITMAP_WORD) 1) << ((start % BITMAP_WORD_BITS))) - 1;\n+\t  first_mask = ~first_mask;\n+\t}\n+      else\n+\t{\n+\t  /* The first bit to turn on is below this start of this elt.  */\n+\t  first_word_to_mod = 0;\n+\t  first_mask = ~(BITMAP_WORD) 0;\n+\t}\n+\n+      if (elt_end_bit_plus1 <= end_bit_plus1)\n+\t{\n+\t  /* The last bit to turn on is beyond this elt.  */\n+\t  last_word_to_mod = BITMAP_ELEMENT_WORDS - 1;\n+\t  last_mask = ~(BITMAP_WORD) 0;\n+\t}\n+      else\n+\t{\n+\t  /* The last bit to turn on is inside to this elt.  */\n+\t  last_word_to_mod =\n+\t    (end_bit_plus1 - elt_start_bit) / BITMAP_WORD_BITS;\n+\n+\t  /* The last mask should have 1s below the end bit.  */\n+\t  last_mask =\n+\t    (((BITMAP_WORD) 1) << ((end_bit_plus1 % BITMAP_WORD_BITS))) - 1;\n+\t}\n+\n+      if (first_word_to_mod == last_word_to_mod)\n+\t{\n+\t  BITMAP_WORD mask = first_mask & last_mask;\n+\t  elt->bits[first_word_to_mod] |= mask;\n+\t}\n+      else\n+\t{\n+\t  elt->bits[first_word_to_mod] |= first_mask;\n+\t  if (BITMAP_ELEMENT_WORDS > 2)\n+\t    for (ix = first_word_to_mod + 1; ix < last_word_to_mod; ix++)\n+\t      elt->bits[ix] = ~(BITMAP_WORD) 0;\n+\t  elt->bits[last_word_to_mod] |= last_mask;\n+\t}\n+\n+      elt_prev = elt;\n+      elt = elt->next;\n+    }\n+\n+  head->current = elt ? elt : elt_prev;\n+  head->indx = head->current->indx;\n+}\n+\n /* Clear COUNT bits from START in HEAD.  */\n void\n bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n {\n-  unsigned int first_index = start / BITMAP_ELEMENT_ALL_BITS;\n-  unsigned int end_bit_plus1 = start + count;\n-  unsigned int end_bit = end_bit_plus1 - 1;\n-  unsigned int last_index = (end_bit) / BITMAP_ELEMENT_ALL_BITS;\n-  bitmap_element *elt = bitmap_find_bit (head, start);\n+  unsigned int first_index, end_bit_plus1, last_index;\n+  bitmap_element *elt;\n+\n+  if (!count)\n+    return;\n+\n+  first_index = start / BITMAP_ELEMENT_ALL_BITS;\n+  end_bit_plus1 = start + count;\n+  last_index = (end_bit_plus1 - 1) / BITMAP_ELEMENT_ALL_BITS;\n+  elt = bitmap_find_bit (head, start);\n \n   /* If bitmap_find_bit returns zero, the current is the closest block\n      to the result.  If the current is less than first index, find the\n@@ -1070,8 +1254,9 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t  else\n \t    {\n \t      elt->bits[first_word_to_mod] &= ~first_mask;\n-\t      for (i = first_word_to_mod + 1; i < last_word_to_mod; i++)\n-\t\telt->bits[i] = 0;\n+\t      if (BITMAP_ELEMENT_WORDS > 2)\n+\t        for (i = first_word_to_mod + 1; i < last_word_to_mod; i++)\n+\t\t  elt->bits[i] = 0;\n \t      elt->bits[last_word_to_mod] &= ~last_mask;\n \t    }\n \t  for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n@@ -1163,6 +1348,66 @@ bitmap_compl_and_into (bitmap a, bitmap b)\n   return;\n }\n \n+\n+/* Insert an element corresponding to A_ELT | B_ELT after DST_PREV,\n+   overwriting DST_ELT if non-NULL.  CHANGED is true if the destination bitmap\n+   had already been changed; the new value of CHANGED is returned.  */\n+\n+static inline bool\n+bitmap_elt_ior (bitmap dst, bitmap_element *dst_elt, bitmap_element *dst_prev,\n+\t\tbitmap_element *a_elt, bitmap_element *b_elt,\n+\t\tbool changed)\n+{\n+  gcc_assert (a_elt || b_elt);\n+\n+  if (a_elt && b_elt && a_elt->indx == b_elt->indx)\n+    {\n+      /* Matching elts, generate A | B.  */\n+      unsigned ix;\n+\n+      if (!changed && dst_elt && dst_elt->indx == a_elt->indx)\n+\t{\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n+\t      if (r != dst_elt->bits[ix])\n+\t\t{\n+\t\t  dst_elt->bits[ix] = r;\n+\t\t  changed = true;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  changed = true;\n+\t  if (!dst_elt)\n+\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t  else\n+\t    dst_elt->indx = a_elt->indx;\n+\t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+\t    {\n+\t      BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n+\t      dst_elt->bits[ix] = r;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Copy a single element.  */\n+      bitmap_element *src;\n+\n+      if (!b_elt || (a_elt && a_elt->indx < b_elt->indx))\n+\tsrc = a_elt;\n+      else\n+\tsrc = b_elt;\n+\n+      gcc_assert (src);\n+      changed = bitmap_elt_copy (dst, dst_elt, dst_prev, src, changed);\n+    }\n+  return changed;\n+}\n+\n+\n /* DST = A | B.  Return true if DST changes.  */\n \n bool\n@@ -1172,89 +1417,31 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n   bitmap_element *a_elt = a->first;\n   bitmap_element *b_elt = b->first;\n   bitmap_element *dst_prev = NULL;\n+  bitmap_element **dst_prev_pnext = &dst->first;\n   bool changed = false;\n \n   gcc_assert (dst != a && dst != b);\n \n   while (a_elt || b_elt)\n     {\n+      changed = bitmap_elt_ior (dst, dst_elt, dst_prev, a_elt, b_elt, changed);\n+\n       if (a_elt && b_elt && a_elt->indx == b_elt->indx)\n \t{\n-\t  /* Matching elts, generate A | B.  */\n-\t  unsigned ix;\n-\n-\t  if (!changed && dst_elt && dst_elt->indx == a_elt->indx)\n-\t    {\n-\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n-\t\t{\n-\t\t  BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n-\n-\t\t  if (r != dst_elt->bits[ix])\n-\t\t    {\n-\t\t      dst_elt->bits[ix] = r;\n-\t\t      changed = true;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      changed = true;\n-\t      if (!dst_elt)\n-\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n-\t      else\n-\t\tdst_elt->indx = a_elt->indx;\n-\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n-\t\t{\n-\t\t  BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n-\n-\t\t  dst_elt->bits[ix] = r;\n-\t\t}\n-\t    }\n \t  a_elt = a_elt->next;\n \t  b_elt = b_elt->next;\n-\t  dst_prev = dst_elt;\n-\t  dst_elt = dst_elt->next;\n \t}\n       else\n \t{\n-\t  /* Copy a single element.  */\n-\t  bitmap_element *src;\n-\n-\t  if (!b_elt || (a_elt && a_elt->indx < b_elt->indx))\n-\t    {\n-\t      src = a_elt;\n-\t      a_elt = a_elt->next;\n-\t    }\n-\t  else\n-\t    {\n-\t      src = b_elt;\n-\t      b_elt = b_elt->next;\n-\t    }\n-\n-\t  if (!changed && dst_elt && dst_elt->indx == src->indx)\n-\t    {\n-\t      unsigned ix;\n-\n-\t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n-\t\tif (src->bits[ix] != dst_elt->bits[ix])\n-\t\t  {\n-\t\t    dst_elt->bits[ix] = src->bits[ix];\n-\t\t    changed = true;\n-\t\t  }\n-\t    }\n-\t  else\n-\t    {\n-\t      changed = true;\n-\t      if (!dst_elt)\n-\t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, src->indx);\n-\t      else\n-\t\tdst_elt->indx = src->indx;\n-\t      memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n-\t    }\n-\n-\t  dst_prev = dst_elt;\n-\t  dst_elt = dst_elt->next;\n+\t  if (a_elt && (!b_elt || a_elt->indx <= b_elt->indx))\n+            a_elt = a_elt->next;\n+          else if (b_elt && (!a_elt || b_elt->indx <= a_elt->indx))\n+            b_elt = b_elt->next;\n \t}\n+\n+      dst_prev = *dst_prev_pnext;\n+      dst_prev_pnext = &dst_prev->next;\n+      dst_elt = *dst_prev_pnext;\n     }\n \n   if (dst_elt)\n@@ -1276,55 +1463,31 @@ bitmap_ior_into (bitmap a, bitmap b)\n   bitmap_element *a_elt = a->first;\n   bitmap_element *b_elt = b->first;\n   bitmap_element *a_prev = NULL;\n+  bitmap_element **a_prev_pnext = &a->first;\n   bool changed = false;\n \n   if (a == b)\n     return false;\n \n   while (b_elt)\n     {\n-      if (!a_elt || b_elt->indx < a_elt->indx)\n+      /* If A lags behind B, just advance it.  */\n+      if (!a_elt || a_elt->indx == b_elt->indx)\n \t{\n-\t  /* Copy b_elt.  */\n-\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev, b_elt->indx);\n-\t  memcpy (dst->bits, b_elt->bits, sizeof (dst->bits));\n-\t  a_prev = dst;\n+\t  changed = bitmap_elt_ior (a, a_elt, a_prev, a_elt, b_elt, changed);\n \t  b_elt = b_elt->next;\n-\t  changed = true;\n-\t}\n-      else if (a_elt->indx < b_elt->indx)\n-\t{\n-\t  a_prev = a_elt;\n-\t  a_elt = a_elt->next;\n \t}\n-      else\n+      else if (a_elt->indx > b_elt->indx)\n \t{\n-\t  /* Matching elts, generate A |= B.  */\n-\t  unsigned ix;\n-\n-\t  if (changed)\n-\t    for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n-\t      {\n-\t\tBITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n-\n-\t\ta_elt->bits[ix] = r;\n-\t      }\n-\t  else\n-\t    for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n-\t      {\n-\t\tBITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n-\n-\t\tif (a_elt->bits[ix] != r)\n-\t\t  {\n-\t\t    changed = true;\n-\t\t    a_elt->bits[ix] = r;\n-\t\t  }\n-\t      }\n+          changed = bitmap_elt_copy (a, NULL, a_prev, b_elt, changed);\n \t  b_elt = b_elt->next;\n-\t  a_prev = a_elt;\n-\t  a_elt = a_elt->next;\n \t}\n+\n+      a_prev = *a_prev_pnext;\n+      a_prev_pnext = &a_prev->next;\n+      a_elt = *a_prev_pnext;\n     }\n+\n   gcc_assert (!a->current == !a->first);\n   if (a->current)\n     a->indx = a->current->indx;\n@@ -1548,15 +1711,103 @@ bitmap_intersect_compl_p (bitmap a, bitmap b)\n /* DST = A | (FROM1 & ~FROM2).  Return true if DST changes.  */\n \n bool\n-bitmap_ior_and_compl (bitmap dst, bitmap a, bitmap from1, bitmap from2)\n+bitmap_ior_and_compl (bitmap dst, bitmap a, bitmap b, bitmap kill)\n {\n-  bitmap_head tmp;\n-  bool changed;\n+  bool changed = false;\n \n-  bitmap_initialize (&tmp, &bitmap_default_obstack);\n-  bitmap_and_compl (&tmp, from1, from2);\n-  changed = bitmap_ior (dst, a, &tmp);\n-  bitmap_clear (&tmp);\n+  bitmap_element *dst_elt = dst->first;\n+  bitmap_element *a_elt = a->first;\n+  bitmap_element *b_elt = b->first;\n+  bitmap_element *kill_elt = kill->first;\n+  bitmap_element *dst_prev = NULL;\n+  bitmap_element **dst_prev_pnext = &dst->first;\n+\n+  gcc_assert (dst != a && dst != b && dst != kill);\n+\n+  /* Special cases.  We don't bother checking for bitmap_equal_p (b, kill).  */\n+  if (b == kill || bitmap_empty_p (b))\n+    {\n+      changed = !bitmap_equal_p (dst, a);\n+      if (changed)\n+\tbitmap_copy (dst, a);\n+      return changed;\n+    }\n+  if (bitmap_empty_p (kill))\n+    return bitmap_ior (dst, a, b);\n+  if (bitmap_empty_p (a))\n+    return bitmap_and_compl (dst, b, kill);\n+\n+  while (a_elt || b_elt)\n+    {\n+      bool new_element = false;\n+\n+      if (b_elt)\n+\twhile (kill_elt && kill_elt->indx < b_elt->indx)\n+\t  kill_elt = kill_elt->next;\n+\n+      if (b_elt && kill_elt && kill_elt->indx == b_elt->indx\n+\t  && (!a_elt || a_elt->indx >= b_elt->indx))\n+        {\n+\t  bitmap_element tmp_elt;\n+\t  unsigned ix;\n+\n+\t  BITMAP_WORD ior = 0;\n+\t  tmp_elt.indx = b_elt->indx;\n+          for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n+            {\n+              BITMAP_WORD r = b_elt->bits[ix] & ~kill_elt->bits[ix];\n+              ior |= r;\n+              tmp_elt.bits[ix] = r;\n+            }\n+\n+\t  if (ior)\n+\t    {\n+\t      changed = bitmap_elt_ior (dst, dst_elt, dst_prev,\n+\t\t\t\t        a_elt, &tmp_elt, changed);\n+\t      new_element = true;\n+\t      if (a_elt && a_elt->indx == b_elt->indx)\n+                a_elt = a_elt->next;\n+\t    }\n+\n+\t  b_elt = b_elt->next;\n+\t  kill_elt = kill_elt->next;\n+\t}\n+      else\n+\t{\n+\t  changed = bitmap_elt_ior (dst, dst_elt, dst_prev,\n+\t\t\t\t    a_elt, b_elt, changed);\n+\t  new_element = true;\n+\n+          if (a_elt && b_elt && a_elt->indx == b_elt->indx)\n+\t    {\n+\t      a_elt = a_elt->next;\n+\t      b_elt = b_elt->next;\n+\t    }\n+          else\n+\t    {\n+\t      if (a_elt && (!b_elt || a_elt->indx <= b_elt->indx))\n+                a_elt = a_elt->next;\n+              else if (b_elt && (!a_elt || b_elt->indx <= a_elt->indx))\n+                b_elt = b_elt->next;\n+\t    }\n+\t}\n+\n+      if (new_element)\n+\t{\n+\t  dst_prev = *dst_prev_pnext;\n+\t  dst_prev_pnext = &dst_prev->next;\n+\t  dst_elt = *dst_prev_pnext;\n+\t}\n+    }\n+\n+  if (dst_elt)\n+    {\n+      changed = true;\n+      bitmap_elt_clear_from (dst, dst_elt);\n+    }\n+  gcc_assert (!dst->current == !dst->first);\n+  if (dst->current)\n+    dst->indx = dst->current->indx;\n \n   return changed;\n }\n@@ -1576,6 +1827,7 @@ bitmap_ior_and_compl_into (bitmap a, bitmap from1, bitmap from2)\n \n   return changed;\n }\n+\n \f\n /* Debugging function to print out the contents of a bitmap.  */\n "}, {"sha": "2959603a89fbb94c644ff2ef97bcb8255fef22b3", "filename": "gcc/bitmap.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Functions to support general ended bitmaps.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -117,11 +117,12 @@ extern unsigned long bitmap_count_bits (bitmap);\n    The operations supported are &, & ~, |, ^.  */\n extern void bitmap_and (bitmap, bitmap, bitmap);\n extern void bitmap_and_into (bitmap, bitmap);\n-extern void bitmap_and_compl (bitmap, bitmap, bitmap);\n+extern bool bitmap_and_compl (bitmap, bitmap, bitmap);\n extern bool bitmap_and_compl_into (bitmap, bitmap);\n #define bitmap_compl_and(DST, A, B) bitmap_and_compl (DST, B, A)\n extern void bitmap_compl_and_into (bitmap, bitmap);\n extern void bitmap_clear_range (bitmap, unsigned int, unsigned int);\n+extern void bitmap_set_range (bitmap, unsigned int, unsigned int);\n extern bool bitmap_ior (bitmap, bitmap, bitmap);\n extern bool bitmap_ior_into (bitmap, bitmap);\n extern void bitmap_xor (bitmap, bitmap, bitmap);"}, {"sha": "710c788c73db5804a5dc887169e109c8a41861a5", "filename": "gcc/bt-load.c", "status": "modified", "additions": 57, "deletions": 22, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Perform branch target register load optimizations.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -37,6 +37,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm_p.h\"\n #include \"toplev.h\"\n #include \"tree-pass.h\"\n+#include \"recog.h\"\n+#include \"df.h\"\n \n /* Target register optimizations - these are performed after reload.  */\n \n@@ -476,7 +478,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n       CLEAR_HARD_REG_SET (info.btrs_written_in_block);\n       for (reg = first_btr; reg <= last_btr; reg++)\n \tif (TEST_HARD_REG_BIT (all_btrs, reg)\n-\t    && REGNO_REG_SET_P (bb->il.rtl->global_live_at_start, reg))\n+\t    && REGNO_REG_SET_P (DF_LIVE_IN (bb), reg))\n \t  SET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n \n       for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n@@ -508,7 +510,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t}\n \t      /* Check for the blockage emitted by expand_nl_goto_receiver.  */\n \t      else if (current_function_has_nonlocal_label\n-\t\t       && GET_CODE (PATTERN (insn)) == ASM_INPUT)\n+\t\t       && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE)\n \t\t{\n \t\t  btr_user user;\n \n@@ -577,7 +579,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n       COPY_HARD_REG_SET (btrs_live[i], info.btrs_live_in_block);\n       COPY_HARD_REG_SET (btrs_written[i], info.btrs_written_in_block);\n \n-      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], bb->il.rtl->global_live_at_end);\n+      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], DF_LIVE_OUT (bb));\n       /* If this block ends in a jump insn, add any uses or even clobbers\n \t of branch target registers that it might have.  */\n       for (insn = BB_END (bb); insn != BB_HEAD (bb) && ! INSN_P (insn); )\n@@ -1203,7 +1205,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n   /* Insert target register initialization at head of basic block.  */\n   def->insn = emit_insn_after (new_insn, insp);\n \n-  regs_ever_live[btr] = 1;\n+  df_set_regs_ever_live (btr, true);\n \n   if (dump_file)\n     fprintf (dump_file, \"New pt is insn %d, inserted after insn %d\\n\",\n@@ -1226,7 +1228,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n \treplacement_rtx = btr_rtx;\n       else\n \treplacement_rtx = gen_rtx_REG (GET_MODE (user->use), btr);\n-      replace_rtx (user->insn, user->use, replacement_rtx);\n+      validate_replace_rtx (user->insn, user->use, replacement_rtx);\n       user->use = replacement_rtx;\n     }\n }\n@@ -1418,7 +1420,8 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n   CLEAR_HARD_REG_SET (all_btrs);\n   for (first_btr = -1, reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n     if (TEST_HARD_REG_BIT (reg_class_contents[(int) btr_class], reg)\n-\t&& (allow_callee_save || call_used_regs[reg] || regs_ever_live[reg]))\n+\t&& (allow_callee_save || call_used_regs[reg] \n+\t    || df_regs_ever_live_p (reg)))\n       {\n \tSET_HARD_REG_BIT (all_btrs, reg);\n \tlast_btr = reg;\n@@ -1455,7 +1458,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n   fibheap_delete (all_btr_defs);\n }\n \n-void\n+static void\n branch_target_load_optimize (bool after_prologue_epilogue_gen)\n {\n   enum reg_class class = targetm.branch_target_register_class ();\n@@ -1467,14 +1470,17 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n       else\n \tissue_rate = 1;\n \n-      /* Build the CFG for migrate_btr_defs.  */\n+      if (!after_prologue_epilogue_gen)\n+\t{\n+\t  /* Build the CFG for migrate_btr_defs.  */\n #if 1\n-      /* This may or may not be needed, depending on where we\n-\t run this phase.  */\n-      cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n+\t  /* This may or may not be needed, depending on where we\n+\t     run this phase.  */\n+\t  cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n #endif\n+\t}\n+      df_analyze ();\n \n-      life_analysis (0);\n \n       /* Dominator info is also needed for migrate_btr_def.  */\n       calculate_dominance_info (CDI_DOMINATORS);\n@@ -1483,21 +1489,50 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n \t\t\t(after_prologue_epilogue_gen)));\n \n       free_dominance_info (CDI_DOMINATORS);\n-\n-      update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\tPROP_DEATH_NOTES | PROP_REG_INFO);\n     }\n }\n \f\n static bool\n-gate_handle_branch_target_load_optimize (void)\n+gate_handle_branch_target_load_optimize1 (void)\n+{\n+  return flag_branch_target_load_optimize;\n+}\n+\n+\n+static unsigned int\n+rest_of_handle_branch_target_load_optimize1 (void)\n+{\n+  branch_target_load_optimize (epilogue_completed);\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_branch_target_load_optimize1 =\n+{\n+  \"btl1\",                               /* name */\n+  gate_handle_branch_target_load_optimize1,      /* gate */\n+  rest_of_handle_branch_target_load_optimize1,   /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,\t\t                        /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'd'                                   /* letter */\n+};\n+\n+static bool\n+gate_handle_branch_target_load_optimize2 (void)\n {\n   return (optimize > 0 && flag_branch_target_load_optimize2);\n }\n \n \n static unsigned int\n-rest_of_handle_branch_target_load_optimize (void)\n+rest_of_handle_branch_target_load_optimize2 (void)\n {\n   static int warned = 0;\n \n@@ -1518,11 +1553,11 @@ rest_of_handle_branch_target_load_optimize (void)\n   return 0;\n }\n \n-struct tree_opt_pass pass_branch_target_load_optimize =\n+struct tree_opt_pass pass_branch_target_load_optimize2 =\n {\n-  \"btl\",                               /* name */\n-  gate_handle_branch_target_load_optimize,      /* gate */\n-  rest_of_handle_branch_target_load_optimize,   /* execute */\n+  \"btl2\",                               /* name */\n+  gate_handle_branch_target_load_optimize2,      /* gate */\n+  rest_of_handle_branch_target_load_optimize2,   /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}, {"sha": "2f3f1a9a43519ea4386b6bea0f10595d538e2bf4", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -761,12 +761,10 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #endif\n       { /* Nothing */ }\n \n-  /* @@@ This is a kludge.  Not all machine descriptions define a blockage\n-     insn, but we must not allow the code we just generated to be reordered\n-     by scheduling.  Specifically, the update of the frame pointer must\n-     happen immediately, not later.  So emit an ASM_INPUT to act as blockage\n-     insn.  */\n-  emit_insn (gen_rtx_ASM_INPUT (VOIDmode, \"\"));\n+  /* We must not allow the code we just generated to be reordered by\n+     scheduling.  Specifically, the update of the frame pointer must\n+     happen immediately, not later.  */\n+  emit_insn (gen_blockage ());\n }\n \n /* __builtin_longjmp is passed a pointer to an array of five words (not"}, {"sha": "a5cd2e3395389442dcd68eeac05806572b7ca0be", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"toplev.h\"\n #include \"tm_p.h\"\n #include \"addresses.h\"\n+#include \"df.h\"\n \n #ifndef MAX_MOVE_MAX\n #define MAX_MOVE_MAX MOVE_MAX\n@@ -189,8 +190,8 @@ init_caller_save (void)\n   savepat = gen_rtx_SET (VOIDmode, test_mem, test_reg);\n   restpat = gen_rtx_SET (VOIDmode, test_reg, test_mem);\n \n-  saveinsn = gen_rtx_INSN (VOIDmode, 0, 0, 0, 0, 0, savepat, -1, 0, 0);\n-  restinsn = gen_rtx_INSN (VOIDmode, 0, 0, 0, 0, 0, restpat, -1, 0, 0);\n+  saveinsn = gen_rtx_INSN (VOIDmode, 0, 0, 0, 0, 0, savepat, -1, 0);\n+  restinsn = gen_rtx_INSN (VOIDmode, 0, 0, 0, 0, 0, restpat, -1, 0);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (mode = 0 ; mode < MAX_MACHINE_MODE; mode++)\n@@ -200,7 +201,7 @@ init_caller_save (void)\n \n \t  /* Update the register number and modes of the register\n \t     and memory operand.  */\n-\t  REGNO (test_reg) = i;\n+\t  SET_REGNO (test_reg, i);\n \t  PUT_MODE (test_reg, mode);\n \t  PUT_MODE (test_mem, mode);\n "}, {"sha": "b339c04d902ad0b76a209b521946d2596e2ffcf5", "filename": "gcc/calls.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -41,6 +41,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"except.h\"\n+#include \"dbgcnt.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -2222,7 +2223,8 @@ expand_call (tree exp, rtx target, int ignore)\n   if (currently_expanding_call++ != 0\n       || !flag_optimize_sibling_calls\n       || args_size.var\n-      || lookup_stmt_eh_region (exp) >= 0)\n+      || lookup_stmt_eh_region (exp) >= 0\n+      || dbg_cnt (tail_call) == false)\n     try_tail_call = 0;\n \n   /*  Rest of purposes for tail call optimizations to fail.  */\n@@ -2855,9 +2857,10 @@ expand_call (tree exp, rtx target, int ignore)\n \t  valreg = temp;\n \t}\n \n-      /* For calls to `setjmp', etc., inform flow.c it should complain\n-\t if nonvolatile values are live.  For functions that cannot return,\n-\t inform flow that control does not fall through.  */\n+      /* For calls to `setjmp', etc., inform\n+\t function.c:setjmp_warnings that it should complain if\n+\t nonvolatile values are live.  For functions that cannot\n+\t return, inform flow that control does not fall through.  */\n \n       if ((flags & ECF_NORETURN) || pass == 0)\n \t{\n@@ -3816,9 +3819,10 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t       valreg,\n \t       old_inhibit_defer_pop + 1, call_fusage, flags, & args_so_far);\n \n-  /* For calls to `setjmp', etc., inform flow.c it should complain\n-     if nonvolatile values are live.  For functions that cannot return,\n-     inform flow that control does not fall through.  */\n+  /* For calls to `setjmp', etc., inform function.c:setjmp_warnings\n+     that it should complain if nonvolatile values are live.  For\n+     functions that cannot return, inform flow that control does not\n+     fall through.  */\n \n   if (flags & ECF_NORETURN)\n     {"}, {"sha": "cf3b4403ef9b853a5bf01ea7c3f1046bdb55ae65", "filename": "gcc/cfg.c", "status": "modified", "additions": 142, "deletions": 79, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Control flow graph manipulation code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -66,6 +66,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"hashtab.h\"\n #include \"alloc-pool.h\"\n+#include \"df.h\"\n #include \"cfgloop.h\"\n \n /* The obstack on which the flow graph components are allocated.  */\n@@ -163,24 +164,28 @@ void\n compact_blocks (void)\n {\n   int i;\n-  basic_block bb;\n \n   SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n   SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n-\n-  i = NUM_FIXED_BLOCKS;\n-  FOR_EACH_BB (bb) \n+  \n+  if (df)\n+    df_compact_blocks ();\n+  else \n     {\n-      SET_BASIC_BLOCK (i, bb);\n-      bb->index = i;\n-      i++;\n-    }\n-\n-  gcc_assert (i == n_basic_blocks);\n-\n-  for (; i < last_basic_block; i++)\n-    SET_BASIC_BLOCK (i, NULL);\n+      basic_block bb;\n+      \n+      i = NUM_FIXED_BLOCKS;\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  SET_BASIC_BLOCK (i, bb);\n+\t  bb->index = i;\n+\t  i++;\n+\t}\n+      gcc_assert (i == n_basic_blocks);\n \n+      for (; i < last_basic_block; i++)\n+\tSET_BASIC_BLOCK (i, NULL);\n+    }\n   last_basic_block = n_basic_blocks;\n }\n \n@@ -205,6 +210,7 @@ static inline void\n connect_src (edge e)\n {\n   VEC_safe_push (edge, gc, e->src->succs, e);\n+  df_mark_solutions_dirty ();\n }\n \n /* Connect E to E->dest.  */\n@@ -215,6 +221,7 @@ connect_dest (edge e)\n   basic_block dest = e->dest;\n   VEC_safe_push (edge, gc, dest->preds, e);\n   e->dest_idx = EDGE_COUNT (dest->preds) - 1;\n+  df_mark_solutions_dirty ();\n }\n \n /* Disconnect edge E from E->src.  */\n@@ -237,6 +244,7 @@ disconnect_src (edge e)\n \tei_next (&ei);\n     }\n \n+  df_mark_solutions_dirty ();\n   gcc_unreachable ();\n }\n \n@@ -254,6 +262,7 @@ disconnect_dest (edge e)\n      to update dest_idx of the edge that moved into the \"hole\".  */\n   if (dest_idx < EDGE_COUNT (dest->preds))\n     EDGE_PRED (dest, dest_idx)->dest_idx = dest_idx;\n+  df_mark_solutions_dirty ();\n }\n \n /* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly\n@@ -275,7 +284,6 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n   connect_dest (e);\n \n   execute_on_growing_pred (e);\n-\n   return e;\n }\n \n@@ -409,15 +417,16 @@ redirect_edge_pred (edge e, basic_block new_pred)\n   connect_src (e);\n }\n \n-/* Clear all basic block flags, with the exception of partitioning.  */\n+/* Clear all basic block flags, with the exception of partitioning and\n+   setjmp_target.  */\n void\n clear_bb_flags (void)\n {\n   basic_block bb;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    bb->flags = (BB_PARTITION (bb)  | (bb->flags & BB_DISABLE_SCHEDULE)\n-\t\t | (bb->flags & BB_RTL));\n+    bb->flags = (BB_PARTITION (bb)  \n+\t\t | (bb->flags & (BB_DISABLE_SCHEDULE + BB_RTL + BB_NON_LOCAL_GOTO_TARGET)));\n }\n \f\n /* Check the consistency of profile information.  We can't do that\n@@ -469,6 +478,41 @@ check_bb_profile (basic_block bb, FILE * file)\n     }\n }\n \f\n+/* Write information about registers and basic blocks into FILE.\n+   This is part of making a debugging dump.  */\n+\n+void\n+dump_regset (regset r, FILE *outf)\n+{\n+  unsigned i;\n+  reg_set_iterator rsi;\n+\n+  if (r == NULL)\n+    {\n+      fputs (\" (nil)\", outf);\n+      return;\n+    }\n+\n+  EXECUTE_IF_SET_IN_REG_SET (r, 0, i, rsi)\n+    {\n+      fprintf (outf, \" %d\", i);\n+      if (i < FIRST_PSEUDO_REGISTER)\n+\tfprintf (outf, \" [%s]\",\n+\t\t reg_names[i]);\n+    }\n+}\n+\n+/* Print a human-readable representation of R on the standard error\n+   stream.  This function is designed to be used from within the\n+   debugger.  */\n+\n+void\n+debug_regset (regset r)\n+{\n+  dump_regset (r, stderr);\n+  putc ('\\n', stderr);\n+}\n+\n /* Emit basic block information for BB.  HEADER is true if the user wants\n    the generic information and the predecessors, FOOTER is true if they want\n    the successors.  FLAGS is the dump flags of interest; TDF_DETAILS emit\n@@ -500,88 +544,107 @@ dump_bb_info (basic_block bb, bool header, bool footer, int flags,\n       fprintf (file, \"%sPredecessors: \", prefix);\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tdump_edge_info (file, e, 0);\n+\n+      if ((flags & TDF_DETAILS)\n+\t  && (bb->flags & BB_RTL)\n+\t  && df)\n+\t{\n+\t  fprintf (file, \"\\n\");\n+\t  df_dump_top (bb, file);\n+\t}\n    }\n \n   if (footer)\n     {\n       fprintf (file, \"\\n%sSuccessors: \", prefix);\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tdump_edge_info (file, e, 1);\n-   }\n \n-  if ((flags & TDF_DETAILS)\n-      && (bb->flags & BB_RTL))\n-    {\n-      if (bb->il.rtl->global_live_at_start && header)\n+      if ((flags & TDF_DETAILS)\n+\t  && (bb->flags & BB_RTL)\n+\t  && df)\n \t{\n-\t  fprintf (file, \"\\n%sRegisters live at start:\", prefix);\n-\t  dump_regset (bb->il.rtl->global_live_at_start, file);\n-\t}\n-\n-      if (bb->il.rtl->global_live_at_end && footer)\n-\t{\n-\t  fprintf (file, \"\\n%sRegisters live at end:\", prefix);\n-\t  dump_regset (bb->il.rtl->global_live_at_end, file);\n+\t  fprintf (file, \"\\n\");\n+\t  df_dump_bottom (bb, file);\n \t}\n    }\n \n   putc ('\\n', file);\n }\n \n+/* Dump the register info to FILE.  */\n+\n+void \n+dump_reg_info (FILE *file)\n+{\n+  unsigned int i, max = max_reg_num ();\n+  if (reload_completed)\n+    return;\n+\n+  if (reg_info_p_size < max)\n+    max = reg_info_p_size;\n+\n+  fprintf (file, \"%d registers.\\n\", max);\n+  for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n+    {\n+      enum reg_class class, altclass;\n+      \n+      if (regstat_n_sets_and_refs)\n+\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n+      else if (df)\n+\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t i, DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i), REG_LIVE_LENGTH (i));\n+      \n+      if (REG_BASIC_BLOCK (i) >= NUM_FIXED_BLOCKS)\n+\tfprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n+      if (regstat_n_sets_and_refs)\n+\tfprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n+\t\t (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n+      else if (df)\n+\tfprintf (file, \"; set %d time%s\", DF_REG_DEF_COUNT (i),\n+\t\t (DF_REG_DEF_COUNT (i) == 1) ? \"\" : \"s\");\n+      if (regno_reg_rtx[i] != NULL && REG_USERVAR_P (regno_reg_rtx[i]))\n+\tfprintf (file, \"; user var\");\n+      if (REG_N_DEATHS (i) != 1)\n+\tfprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n+      if (REG_N_CALLS_CROSSED (i) == 1)\n+\tfprintf (file, \"; crosses 1 call\");\n+      else if (REG_N_CALLS_CROSSED (i))\n+\tfprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n+      if (regno_reg_rtx[i] != NULL\n+\t  && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n+\tfprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+      \n+      class = reg_preferred_class (i);\n+      altclass = reg_alternate_class (i);\n+      if (class != GENERAL_REGS || altclass != ALL_REGS)\n+\t{\n+\t  if (altclass == ALL_REGS || class == ALL_REGS)\n+\t    fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t  else if (altclass == NO_REGS)\n+\t    fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n+\t  else\n+\t    fprintf (file, \"; pref %s, else %s\",\n+\t\t     reg_class_names[(int) class],\n+\t\t     reg_class_names[(int) altclass]);\n+\t}\n+      \n+      if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n+\tfprintf (file, \"; pointer\");\n+      fprintf (file, \".\\n\");\n+    }\n+}\n+\n+\n void\n dump_flow_info (FILE *file, int flags)\n {\n   basic_block bb;\n \n   /* There are no pseudo registers after reload.  Don't dump them.  */\n-  if (reg_n_info && !reload_completed\n-      && (flags & TDF_DETAILS) != 0)\n-    {\n-      unsigned int i, max = max_reg_num ();\n-      fprintf (file, \"%d registers.\\n\", max);\n-      for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n-\tif (REG_N_REFS (i))\n-\t  {\n-\t    enum reg_class prefclass, altclass;\n-\n-\t    fprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t     i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n-\t    if (REG_BASIC_BLOCK (i) >= 0)\n-\t      fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n-\t    if (REG_N_SETS (i))\n-\t      fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n-\t\t       (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n-\t    if (regno_reg_rtx[i] != NULL && REG_USERVAR_P (regno_reg_rtx[i]))\n-\t      fprintf (file, \"; user var\");\n-\t    if (REG_N_DEATHS (i) != 1)\n-\t      fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n-\t    if (REG_N_CALLS_CROSSED (i) == 1)\n-\t      fprintf (file, \"; crosses 1 call\");\n-\t    else if (REG_N_CALLS_CROSSED (i))\n-\t      fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n-\t    if (regno_reg_rtx[i] != NULL\n-\t\t&& PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n-\t      fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n-\n-\t    prefclass = reg_preferred_class (i);\n-\t    altclass = reg_alternate_class (i);\n-\t    if (prefclass != GENERAL_REGS || altclass != ALL_REGS)\n-\t      {\n-\t\tif (altclass == ALL_REGS || prefclass == ALL_REGS)\n-\t\t  fprintf (file, \"; pref %s\", reg_class_names[(int) prefclass]);\n-\t\telse if (altclass == NO_REGS)\n-\t\t  fprintf (file, \"; %s or none\", reg_class_names[(int) prefclass]);\n-\t\telse\n-\t\t  fprintf (file, \"; pref %s, else %s\",\n-\t\t\t   reg_class_names[(int) prefclass],\n-\t\t\t   reg_class_names[(int) altclass]);\n-\t      }\n-\n-\t    if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n-\t      fprintf (file, \"; pointer\");\n-\t    fprintf (file, \".\\n\");\n-\t  }\n-    }\n+  if (reg_info_p_size && (flags & TDF_DETAILS) != 0)\n+    dump_reg_info (file);\n \n   fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n   FOR_EACH_BB (bb)"}, {"sha": "18cef5e98f23ca88cba55b9b9d0f61c2ec63eebf", "filename": "gcc/cfganal.c", "status": "modified", "additions": 223, "deletions": 7, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Control flow graph analysis code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -645,16 +645,20 @@ connect_infinite_loops_to_exit (void)\n   return;\n }\n \f\n-/* Compute reverse top sort order.  \n-   This is computing a post order numbering of the graph.  */\n+/* Compute reverse top sort order.  This is computing a post order\n+   numbering of the graph.  If INCLUDE_ENTRY_EXIT is true, then then\n+   ENTRY_BLOCK and EXIT_BLOCK are included.  If DELETE_UNREACHABLE is\n+   true, unreachable blocks are deleted.  */\n \n int\n-post_order_compute (int *post_order, bool include_entry_exit)\n+post_order_compute (int *post_order, bool include_entry_exit, \n+\t\t    bool delete_unreachable)\n {\n   edge_iterator *stack;\n   int sp;\n   int post_order_num = 0;\n   sbitmap visited;\n+  int count;\n \n   if (include_entry_exit)\n     post_order[post_order_num++] = EXIT_BLOCK;\n@@ -699,7 +703,7 @@ post_order_compute (int *post_order, bool include_entry_exit)\n       else\n \t{\n \t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR)\n-\t   post_order[post_order_num++] = src->index;\n+\t    post_order[post_order_num++] = src->index;\n \n \t  if (!ei_one_before_end_p (ei))\n \t    ei_next (&stack[sp - 1]);\n@@ -709,7 +713,220 @@ post_order_compute (int *post_order, bool include_entry_exit)\n     }\n \n   if (include_entry_exit)\n-    post_order[post_order_num++] = ENTRY_BLOCK;\n+    {\n+      post_order[post_order_num++] = ENTRY_BLOCK;\n+      count = post_order_num;\n+    }\n+  else \n+    count = post_order_num + 2;\n+  \n+  /* Delete the unreachable blocks if some were found and we are\n+     supposed to do it.  */\n+  if (delete_unreachable && (count != n_basic_blocks))\n+    {\n+      basic_block b;\n+      basic_block next_bb;\n+      for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n+\t{\n+\t  next_bb = b->next_bb;\n+\t  \n+\t  if (!(TEST_BIT (visited, b->index)))\n+\t    delete_basic_block (b);\n+\t}\n+      \n+      tidy_fallthru_edges ();\n+    }\n+\n+  free (stack);\n+  sbitmap_free (visited);\n+  return post_order_num;\n+}\n+\n+\n+/* Helper routine for inverted_post_order_compute. \n+   BB has to belong to a region of CFG\n+   unreachable by inverted traversal from the exit.\n+   i.e. there's no control flow path from ENTRY to EXIT\n+   that contains this BB.\n+   This can happen in two cases - if there's an infinite loop\n+   or if there's a block that has no successor\n+   (call to a function with no return).\n+   Some RTL passes deal with this condition by \n+   calling connect_infinite_loops_to_exit () and/or \n+   add_noreturn_fake_exit_edges ().\n+   However, those methods involve modifying the CFG itself\n+   which may not be desirable.\n+   Hence, we deal with the infinite loop/no return cases\n+   by identifying a unique basic block that can reach all blocks\n+   in such a region by inverted traversal.\n+   This function returns a basic block that guarantees\n+   that all blocks in the region are reachable\n+   by starting an inverted traversal from the returned block.  */\n+\n+static basic_block\n+dfs_find_deadend (basic_block bb)\n+{\n+  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (visited);\n+\n+  for (;;)\n+    {\n+      SET_BIT (visited, bb->index);\n+      if (EDGE_COUNT (bb->succs) == 0\n+          || TEST_BIT (visited, EDGE_SUCC (bb, 0)->dest->index))\n+        {\n+          sbitmap_free (visited);\n+          return bb;\n+        }\n+\n+      bb = EDGE_SUCC (bb, 0)->dest;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+\n+/* Compute the reverse top sort order of the inverted CFG\n+   i.e. starting from the exit block and following the edges backward\n+   (from successors to predecessors).\n+   This ordering can be used for forward dataflow problems among others.\n+\n+   This function assumes that all blocks in the CFG are reachable\n+   from the ENTRY (but not necessarily from EXIT).\n+\n+   If there's an infinite loop,\n+   a simple inverted traversal starting from the blocks\n+   with no successors can't visit all blocks.\n+   To solve this problem, we first do inverted traversal\n+   starting from the blocks with no successor.\n+   And if there's any block left that's not visited by the regular \n+   inverted traversal from EXIT,\n+   those blocks are in such problematic region.\n+   Among those, we find one block that has \n+   any visited predecessor (which is an entry into such a region),\n+   and start looking for a \"dead end\" from that block \n+   and do another inverted traversal from that block.  */\n+\n+int\n+inverted_post_order_compute (int *post_order)\n+{\n+  basic_block bb;\n+  edge_iterator *stack;\n+  int sp;\n+  int post_order_num = 0;\n+  sbitmap visited;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = sbitmap_alloc (last_basic_block);\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (visited);\n+\n+  /* Put all blocks that have no successor into the initial work list.  */\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    if (EDGE_COUNT (bb->succs) == 0)\n+      {\n+        /* Push the initial edge on to the stack.  */\n+        if (EDGE_COUNT (bb->preds) > 0) \n+          {\n+            stack[sp++] = ei_start (bb->preds);\n+            SET_BIT (visited, bb->index);\n+          }\n+      }\n+\n+  do \n+    {\n+      bool has_unvisited_bb = false;\n+\n+      /* The inverted traversal loop. */\n+      while (sp)\n+        {\n+          edge_iterator ei;\n+          basic_block pred;\n+\n+          /* Look at the edge on the top of the stack.  */\n+          ei = stack[sp - 1];\n+          bb = ei_edge (ei)->dest;\n+          pred = ei_edge (ei)->src;\n+\n+          /* Check if the predecessor has been visited yet.  */\n+          if (! TEST_BIT (visited, pred->index))\n+            {\n+              /* Mark that we have visited the destination.  */\n+              SET_BIT (visited, pred->index);\n+\n+              if (EDGE_COUNT (pred->preds) > 0)\n+                /* Since the predecessor node has been visited for the first\n+                   time, check its predecessors.  */\n+                stack[sp++] = ei_start (pred->preds);\n+              else\n+                post_order[post_order_num++] = pred->index;\n+            }\n+          else\n+            {\n+              if (bb != EXIT_BLOCK_PTR && ei_one_before_end_p (ei))\n+                post_order[post_order_num++] = bb->index;\n+\n+              if (!ei_one_before_end_p (ei))\n+                ei_next (&stack[sp - 1]);\n+              else\n+                sp--;\n+            }\n+        }\n+\n+      /* Detect any infinite loop and activate the kludge. \n+         Note that this doesn't check EXIT_BLOCK itself\n+         since EXIT_BLOCK is always added after the outer do-while loop.  */\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+        if (!TEST_BIT (visited, bb->index))\n+          {\n+            has_unvisited_bb = true;\n+\n+            if (EDGE_COUNT (bb->preds) > 0)\n+              {\n+                edge_iterator ei;\n+                edge e;\n+                basic_block visited_pred = NULL;\n+\n+                /* Find an already visited predecessor.  */\n+                FOR_EACH_EDGE (e, ei, bb->preds)\n+                  {\n+                    if (TEST_BIT (visited, e->src->index))\n+                      visited_pred = e->src;\n+                  }\n+\n+                if (visited_pred)\n+                  {\n+                    basic_block be = dfs_find_deadend (bb);\n+                    gcc_assert (be != NULL);\n+                    SET_BIT (visited, be->index);\n+                    stack[sp++] = ei_start (be->preds);\n+                    break;\n+                  }\n+              }\n+          }\n+\n+      if (has_unvisited_bb && sp == 0)\n+        {\n+          /* No blocks are reachable from EXIT at all. \n+             Find a dead-end from the ENTRY, and restart the iteration. */\n+          basic_block be = dfs_find_deadend (ENTRY_BLOCK_PTR);\n+          gcc_assert (be != NULL);\n+          SET_BIT (visited, be->index);\n+          stack[sp++] = ei_start (be->preds);\n+        }\n+\n+      /* The only case the below while fires is \n+         when there's an infinite loop.  */\n+    }\n+  while (sp);\n+\n+  /* EXIT_BLOCK is always included.  */\n+  post_order[post_order_num++] = EXIT_BLOCK;\n \n   free (stack);\n   sbitmap_free (visited);\n@@ -1076,4 +1293,3 @@ compute_dominance_frontiers (bitmap *frontiers)\n \n   timevar_pop (TV_DOM_FRONTIERS);\n }\n-"}, {"sha": "b34a2dbe6ab30029c91bad9b04984ae4be0e3770", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 69, "deletions": 45, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -54,6 +54,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-pass.h\"\n #include \"cfgloop.h\"\n #include \"expr.h\"\n+#include \"df.h\"\n+#include \"dce.h\"\n \n #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)\n \n@@ -70,7 +72,7 @@ static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n static bool try_optimize_cfg (int);\n static bool try_simplify_condjump (basic_block);\n static bool try_forward_edges (int, basic_block);\n-static edge thread_jump (int, edge, basic_block);\n+static edge thread_jump (edge, basic_block);\n static bool mark_effect (rtx, bitmap);\n static void notice_new_block (basic_block);\n static void update_forwarder_flag (basic_block);\n@@ -260,7 +262,7 @@ mentions_nonequal_regs (rtx *x, void *data)\n    if exist, NULL otherwise.  */\n \n static edge\n-thread_jump (int mode, edge e, basic_block b)\n+thread_jump (edge e, basic_block b)\n {\n   rtx set1, set2, cond1, cond2, insn;\n   enum rtx_code code1, code2, reversed_code2;\n@@ -380,11 +382,6 @@ thread_jump (int mode, edge e, basic_block b)\n   if (for_each_rtx (&cond2, mentions_nonequal_regs, nonequal))\n     goto failed_exit;\n \n-  /* In case liveness information is available, we need to prove equivalence\n-     only of the live values.  */\n-  if (mode & CLEANUP_UPDATE_LIFE)\n-    AND_REG_SET (nonequal, b->il.rtl->global_live_at_end);\n-\n   EXECUTE_IF_SET_IN_REG_SET (nonequal, 0, i, rsi)\n     goto failed_exit;\n \n@@ -431,7 +428,7 @@ try_forward_edges (int mode, basic_block b)\n       int counter;\n       bool threaded = false;\n       int nthreaded_edges = 0;\n-      bool may_thread = first_pass | (b->flags & BB_DIRTY);\n+      bool may_thread = first_pass | df_get_bb_dirty (b);\n \n       /* Skip complex edges because we don't know how to update them.\n \n@@ -465,7 +462,7 @@ try_forward_edges (int mode, basic_block b)\n \t{\n \t  basic_block new_target = NULL;\n \t  bool new_target_threaded = false;\n-\t  may_thread |= target->flags & BB_DIRTY;\n+\t  may_thread |= df_get_bb_dirty (target);\n \n \t  if (FORWARDER_BLOCK_P (target)\n \t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n@@ -481,7 +478,7 @@ try_forward_edges (int mode, basic_block b)\n \t     of probabilities.  */\n \t  else if ((mode & CLEANUP_THREADING) && may_thread)\n \t    {\n-\t      edge t = thread_jump (mode, e, target);\n+\t      edge t = thread_jump (e, target);\n \t      if (t)\n \t\t{\n \t\t  if (!threaded_edges)\n@@ -644,7 +641,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n   /* Scramble the insn chain.  */\n   if (BB_END (a) != PREV_INSN (BB_HEAD (b)))\n     reorder_insns_nobb (BB_HEAD (a), BB_END (a), PREV_INSN (BB_HEAD (b)));\n-  a->flags |= BB_DIRTY;\n+  df_set_bb_dirty (a);\n \n   if (dump_file)\n     fprintf (dump_file, \"Moved block %d before %d and merged.\\n\",\n@@ -1707,7 +1704,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   redirect_to->count += src1->count;\n   redirect_to->frequency += src1->frequency;\n   /* We may have some registers visible through the block.  */\n-  redirect_to->flags |= BB_DIRTY;\n+  df_set_bb_dirty (redirect_to);\n \n   /* Recompute the frequencies and counts of outgoing edges.  */\n   FOR_EACH_EDGE (s, ei, redirect_to->succs)\n@@ -1856,8 +1853,8 @@ try_crossjump_bb (int mode, basic_block bb)\n \t  /* If nothing changed since the last attempt, there is nothing\n \t     we can do.  */\n \t  if (!first_pass\n-\t      && (!(e->src->flags & BB_DIRTY)\n-\t\t  && !(fallthru->src->flags & BB_DIRTY)))\n+\t      && (!(df_get_bb_dirty (e->src))\n+\t\t  && !(df_get_bb_dirty (fallthru->src))))\n \t    continue;\n \n \t  if (try_crossjump_to_edge (mode, e, fallthru))\n@@ -1906,8 +1903,8 @@ try_crossjump_bb (int mode, basic_block bb)\n \t  /* If nothing changed since the last attempt, there is nothing\n \t     we can do.  */\n \t  if (!first_pass\n-\t      && (!(e->src->flags & BB_DIRTY)\n-\t\t  && !(e2->src->flags & BB_DIRTY)))\n+\t      && (!(df_get_bb_dirty (e->src))\n+\t\t  && !(df_get_bb_dirty (e2->src))))\n \t    continue;\n \n \t  if (try_crossjump_to_edge (mode, e, e2))\n@@ -1937,7 +1934,7 @@ try_optimize_cfg (int mode)\n   if (mode & CLEANUP_CROSSJUMP)\n     add_noreturn_fake_exit_edges ();\n \n-  if (mode & (CLEANUP_UPDATE_LIFE | CLEANUP_CROSSJUMP | CLEANUP_THREADING))\n+  if (mode & (CLEANUP_CROSSJUMP | CLEANUP_THREADING))\n     clear_bb_flags ();\n \n   FOR_EACH_BB (bb)\n@@ -2000,7 +1997,7 @@ try_optimize_cfg (int mode)\n \t\t  rtx label = BB_HEAD (b);\n \n \t\t  delete_insn_chain (label, label, false);\n-\t\t  /* In the case label is undeletable, move it after the\n+\t\t  /* If the case label is undeletable, move it after the\n \t\t     BASIC_BLOCK note.  */\n \t\t  if (NOTE_KIND (BB_HEAD (b)) == NOTE_INSN_DELETED_LABEL)\n \t\t    {\n@@ -2166,6 +2163,47 @@ delete_unreachable_blocks (void)\n     tidy_fallthru_edges ();\n   return changed;\n }\n+\n+/* Delete any jump tables never referenced.  We can't delete them at the\n+   time of removing tablejump insn as they are referenced by the preceding\n+   insns computing the destination, so we delay deleting and garbagecollect\n+   them once life information is computed.  */\n+void\n+delete_dead_jumptables (void)\n+{\n+  basic_block bb;\n+\n+  /* A dead jump table does not belong to any basic block.  Scan insns\n+     between two adjacent basic blocks.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn, next;\n+\n+      for (insn = NEXT_INSN (BB_END (bb));\n+\t   insn && !NOTE_INSN_BASIC_BLOCK_P (insn);\n+\t   insn = next)\n+\t{\n+\t  next = NEXT_INSN (insn);\n+\t  if (LABEL_P (insn)\n+\t      && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n+\t      && JUMP_P (next)\n+\t      && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t    {\n+\t      rtx label = insn, jump = next;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Dead jumptable %i removed\\n\",\n+\t\t\t INSN_UID (insn));\n+\n+\t      next = NEXT_INSN (next);\n+\t      delete_insn (jump);\n+\t      delete_insn (label);\n+\t    }\n+\t}\n+    }\n+}\n+\n \f\n /* Tidy the CFG by deleting unreachable code and whatnot.  */\n \n@@ -2186,7 +2224,7 @@ cleanup_cfg (int mode)\n       changed = true;\n       /* We've possibly created trivially dead code.  Cleanup it right\n \t now to introduce more opportunities for try_optimize_cfg.  */\n-      if (!(mode & (CLEANUP_NO_INSN_DEL | CLEANUP_UPDATE_LIFE))\n+      if (!(mode & (CLEANUP_NO_INSN_DEL))\n \t  && !reload_completed)\n \tdelete_trivially_dead_insns (get_insns (), max_reg_num ());\n     }\n@@ -2196,39 +2234,26 @@ cleanup_cfg (int mode)\n   while (try_optimize_cfg (mode))\n     {\n       delete_unreachable_blocks (), changed = true;\n-      if (mode & CLEANUP_UPDATE_LIFE)\n-\t{\n-\t  /* Cleaning up CFG introduces more opportunities for dead code\n-\t     removal that in turn may introduce more opportunities for\n-\t     cleaning up the CFG.  */\n-\t  if (!update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t\t\t\t PROP_DEATH_NOTES\n-\t\t\t\t\t\t | PROP_SCAN_DEAD_CODE\n-\t\t\t\t\t\t | PROP_KILL_DEAD_CODE\n-\t\t\t\t\t\t | ((mode & CLEANUP_LOG_LINKS)\n-\t\t\t\t\t\t    ? PROP_LOG_LINKS : 0)))\n-\t    break;\n-\t}\n-      else if (!(mode & CLEANUP_NO_INSN_DEL)\n-\t       && (mode & CLEANUP_EXPENSIVE)\n-\t       && !reload_completed)\n+      if (!(mode & CLEANUP_NO_INSN_DEL)\n+\t  && (mode & CLEANUP_EXPENSIVE)\n+\t  && !reload_completed)\n \t{\n \t  if (!delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n \t    break;\n \t}\n       else\n \tbreak;\n-\n-      /* Don't call delete_dead_jumptables in cfglayout mode, because\n-\t that function assumes that jump tables are in the insns stream.\n-\t But we also don't _have_ to delete dead jumptables in cfglayout\n-\t mode because we shouldn't even be looking at things that are\n-\t not in a basic block.  Dead jumptables are cleaned up when\n-\t going out of cfglayout mode.  */\n-      if (!(mode & CLEANUP_CFGLAYOUT))\n-\tdelete_dead_jumptables ();\n     }\n \n+  /* Don't call delete_dead_jumptables in cfglayout mode, because\n+     that function assumes that jump tables are in the insns stream.\n+     But we also don't _have_ to delete dead jumptables in cfglayout\n+     mode because we shouldn't even be looking at things that are\n+     not in a basic block.  Dead jumptables are cleaned up when\n+     going out of cfglayout mode.  */\n+  if (!(mode & CLEANUP_CFGLAYOUT))\n+    delete_dead_jumptables ();\n+\n   timevar_pop (TV_CLEANUP_CFG);\n \n   return changed;\n@@ -2267,7 +2292,6 @@ static unsigned int\n rest_of_handle_jump2 (void)\n {\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  reg_scan (get_insns (), max_reg_num ());\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)"}, {"sha": "46a57fd9ea6ade0de8d6e4e582c8a2b14838d656", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Hooks for cfg representation specific functions.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <s.pop@laposte.net>\n \n This file is part of GCC.\n@@ -57,7 +57,7 @@ struct cfg_hooks\n   /* Creates a new basic block just after basic block B by splitting\n      everything after specified instruction I.  */\n   basic_block (*split_block) (basic_block b, void * i);\n-\n+  \n   /* Move block B immediately after block A.  */\n   bool (*move_block_after) (basic_block b, basic_block a);\n "}, {"sha": "be4b08767b9fa625a3a03919d01f4e62ff86011a", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,6 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -37,6 +38,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"alloc-pool.h\"\n #include \"flags.h\"\n #include \"tree-pass.h\"\n+#include \"df.h\"\n #include \"vecprim.h\"\n \n /* Holds the interesting trailing notes for the function.  */\n@@ -883,7 +885,7 @@ fixup_reorder_chain (void)\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n-\n+      \n       if (e && !can_fallthru (e->src, e->dest))\n \tforce_nonfallthru (e);\n     }\n@@ -1108,35 +1110,34 @@ cfg_layout_duplicate_bb (basic_block bb)\n \tnew_bb->il.rtl->footer = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n-  if (bb->il.rtl->global_live_at_start)\n-    {\n-      new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n-\t\t    bb->il.rtl->global_live_at_start);\n-      COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n-\t\t    bb->il.rtl->global_live_at_end);\n-    }\n-\n   return new_bb;\n }\n+\n \f\n /* Main entry point to this module - initialize the datastructures for\n    CFG layout changes.  It keeps LOOPS up-to-date if not null.\n \n-   FLAGS is a set of additional flags to pass to cleanup_cfg().  It should\n-   include CLEANUP_UPDATE_LIFE if liveness information must be kept up\n-   to date.  */\n+   FLAGS is a set of additional flags to pass to cleanup_cfg().  */\n \n void\n cfg_layout_initialize (unsigned int flags)\n {\n+  rtx x;\n+  basic_block bb;\n+\n   initialize_original_copy_tables ();\n \n   cfg_layout_rtl_register_cfg_hooks ();\n \n   record_effective_endpoints ();\n \n+  /* Make sure that the targets of non local gotos are marked.  */\n+  for (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n+    {\n+      bb = BLOCK_FOR_INSN (XEXP (x, 0));\n+      bb->flags |= BB_NON_LOCAL_GOTO_TARGET;\n+    }\n+\n   cleanup_cfg (CLEANUP_CFGLAYOUT | flags);\n }\n "}, {"sha": "63637980c443600bfce1c523f096f3f92d64eaad", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,6 @@\n /* Natural loop discovery code for GNU compiler.\n-   Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -284,9 +285,6 @@ establish_preds (struct loop *loop, struct loop *father)\n   unsigned depth = loop_depth (father) + 1;\n   unsigned i;\n \n-  /* Remember the current loop depth if it is the largest seen so far.  */\n-  cfun->max_loop_depth = MAX (cfun->max_loop_depth, (int) depth);\n-\n   VEC_truncate (loop_p, loop->superloops, 0);\n   VEC_reserve (loop_p, gc, loop->superloops, depth);\n   for (i = 0; VEC_iterate (loop_p, father->superloops, i, ploop); i++)\n@@ -364,10 +362,6 @@ flow_loops_find (struct loops *loops)\n \n   memset (loops, 0, sizeof *loops);\n \n-  /* We are going to recount the maximum loop depth,\n-     so throw away the last count.  */\n-  cfun->max_loop_depth = 0;\n-\n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n   if (n_basic_blocks == NUM_FIXED_BLOCKS)"}, {"sha": "60b82f0d05f944ca0fbba4be01e5d0762fc8c317", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Natural loop functions\n-   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2005, 2006, 2007Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -386,7 +386,6 @@ extern rtx get_iv_value (struct rtx_iv *, rtx);\n extern bool biv_p (rtx, rtx);\n extern void find_simple_exit (struct loop *, struct niter_desc *);\n extern void iv_analysis_done (void);\n-extern struct df *iv_current_loop_df (void);\n \n extern struct niter_desc *get_simple_loop_desc (struct loop *loop);\n extern void free_simple_loop_desc (struct loop *loop);"}, {"sha": "d7921e3df44a89f108b2ed8a810b7514df52d1c4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 120, "deletions": 112, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,7 @@\n /* Control flow graph manipulation code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -60,6 +61,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cfgloop.h\"\n #include \"ggc.h\"\n #include \"tree-pass.h\"\n+#include \"df.h\"\n \n static int can_delete_note_p (rtx);\n static int can_delete_label_p (rtx);\n@@ -307,6 +309,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   bb->flags = BB_NEW | BB_RTL;\n   link_block (bb, after);\n   SET_BASIC_BLOCK (bb->index, bb);\n+  df_bb_refs_record (bb->index, false);\n   update_bb_for_insn (bb);\n   BB_SET_PARTITION (bb, BB_UNPARTITIONED);\n \n@@ -376,13 +379,10 @@ rtl_delete_block (basic_block b)\n   BB_HEAD (b) = NULL;\n   delete_insn_chain (insn, end, true);\n \n-  if (b->il.rtl->global_live_at_start)\n-    {\n-      FREE_REG_SET (b->il.rtl->global_live_at_start);\n-      FREE_REG_SET (b->il.rtl->global_live_at_end);\n-      b->il.rtl->global_live_at_start = NULL;\n-      b->il.rtl->global_live_at_end = NULL;\n-    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"deleting block %d\\n\", b->index);\n+  df_bb_delete (b->index);\n }\n \f\n /* Records the basic block struct in BLOCK_FOR_INSN for every insn.  */\n@@ -466,12 +466,35 @@ update_bb_for_insn (basic_block bb)\n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (!BARRIER_P (insn))\n-\tset_block_for_insn (insn, bb);\n+\t{\n+\t  set_block_for_insn (insn, bb);\n+\t  df_insn_change_bb (insn);\n+\t}\n       if (insn == BB_END (bb))\n \tbreak;\n     }\n }\n \f\n+/* Return the INSN immediately following the NOTE_INSN_BASIC_BLOCK\n+   note associated with the BLOCK.  */\n+\n+static rtx\n+first_insn_after_basic_block_note (basic_block block)\n+{\n+  rtx insn;\n+\n+  /* Get the first instruction in the block.  */\n+  insn = BB_HEAD (block);\n+\n+  if (insn == NULL_RTX)\n+    return NULL_RTX;\n+  if (LABEL_P (insn))\n+    insn = NEXT_INSN (insn);\n+  gcc_assert (NOTE_INSN_BASIC_BLOCK_P (insn));\n+\n+  return NEXT_INSN (insn);\n+}\n+\n /* Creates a new basic block just after basic block B by splitting\n    everything after specified instruction I.  */\n \n@@ -510,32 +533,8 @@ rtl_split_block (basic_block bb, void *insnp)\n   FOR_EACH_EDGE (e, ei, new_bb->succs)\n     e->src = new_bb;\n \n-  if (bb->il.rtl->global_live_at_start)\n-    {\n-      new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (new_bb->il.rtl->global_live_at_end, bb->il.rtl->global_live_at_end);\n-\n-      /* We now have to calculate which registers are live at the end\n-\t of the split basic block and at the start of the new basic\n-\t block.  Start with those registers that are known to be live\n-\t at the end of the original basic block and get\n-\t propagate_block to determine which registers are live.  */\n-      COPY_REG_SET (new_bb->il.rtl->global_live_at_start, bb->il.rtl->global_live_at_end);\n-      propagate_block (new_bb, new_bb->il.rtl->global_live_at_start, NULL, NULL, 0);\n-      COPY_REG_SET (bb->il.rtl->global_live_at_end,\n-\t\t    new_bb->il.rtl->global_live_at_start);\n-#ifdef HAVE_conditional_execution\n-      /* In the presence of conditional execution we are not able to update\n-\t liveness precisely.  */\n-      if (reload_completed)\n-\t{\n-\t  bb->flags |= BB_DIRTY;\n-\t  new_bb->flags |= BB_DIRTY;\n-\t}\n-#endif\n-    }\n-\n+  /* The new block starts off being dirty.  */\n+  df_set_bb_dirty (bb);\n   return new_bb;\n }\n \n@@ -549,6 +548,9 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   rtx del_first = NULL_RTX, del_last = NULL_RTX;\n   int b_empty = 0;\n \n+  if (dump_file)\n+    fprintf (dump_file, \"merging block %d into block %d\\n\", b->index, a->index);\n+\n   /* If there was a CODE_LABEL beginning B, delete it.  */\n   if (LABEL_P (b_head))\n     {\n@@ -621,17 +623,22 @@ rtl_merge_blocks (basic_block a, basic_block b)\n       rtx x;\n \n       for (x = a_end; x != b_end; x = NEXT_INSN (x))\n-\tset_block_for_insn (x, a);\n+\t{\n+\t  set_block_for_insn (x, a);\n+\t  df_insn_change_bb (x);\n+\t}\n \n       set_block_for_insn (b_end, a);\n+      df_insn_change_bb (b_end);\n \n       a_end = b_end;\n     }\n \n+  df_bb_delete (b->index);\n   BB_END (a) = a_end;\n-  a->il.rtl->global_live_at_end = b->il.rtl->global_live_at_end;\n }\n \n+\n /* Return true when block A and B can be merged.  */\n static bool\n rtl_can_merge_blocks (basic_block a,basic_block b)\n@@ -830,7 +837,10 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \n \t      for (tmp = NEXT_INSN (BB_END (src)); tmp != barrier;\n \t\t   tmp = NEXT_INSN (tmp))\n-\t\tset_block_for_insn (tmp, src);\n+\t\t{\n+\t\t  set_block_for_insn (tmp, src);\n+\t      \t  df_insn_change_bb (tmp);\n+\t\t}\n \n \t      NEXT_INSN (PREV_INSN (new_insn)) = NEXT_INSN (new_insn);\n \t      PREV_INSN (NEXT_INSN (new_insn)) = PREV_INSN (new_insn);\n@@ -860,7 +870,6 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n-\n   return e;\n }\n \n@@ -944,6 +953,7 @@ redirect_branch_edge (edge e, basic_block target)\n \n   if (e->dest != target)\n     e = redirect_edge_succ_nodup (e, target);\n+\n   return e;\n }\n \n@@ -972,15 +982,15 @@ rtl_redirect_edge_and_branch (edge e, basic_block target)\n \n   if ((ret = try_redirect_by_replacing_jump (e, target, false)) != NULL)\n     {\n-      src->flags |= BB_DIRTY;\n+      df_set_bb_dirty (src);\n       return ret;\n     }\n \n   ret = redirect_branch_edge (e, target);\n   if (!ret)\n     return NULL;\n \n-  src->flags |= BB_DIRTY;\n+  df_set_bb_dirty (src);\n   return ret;\n }\n \n@@ -1088,16 +1098,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n       jump_block->frequency = EDGE_FREQUENCY (e);\n       jump_block->loop_depth = target->loop_depth;\n \n-      if (target->il.rtl->global_live_at_start)\n-\t{\n-\t  jump_block->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-\t  jump_block->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-\t  COPY_REG_SET (jump_block->il.rtl->global_live_at_start,\n-\t\t\ttarget->il.rtl->global_live_at_start);\n-\t  COPY_REG_SET (jump_block->il.rtl->global_live_at_end,\n-\t\t\ttarget->il.rtl->global_live_at_start);\n-\t}\n-\n       /* Make sure new block ends up in correct hot/cold section.  */\n \n       BB_COPY_PARTITION (jump_block, e->src);\n@@ -1149,6 +1149,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   if (abnormal_edge_flags)\n     make_edge (src, target, abnormal_edge_flags);\n \n+  df_mark_solutions_dirty (); \n   return new_bb;\n }\n \n@@ -1175,7 +1176,7 @@ rtl_redirect_edge_and_branch_force (edge e, basic_block target)\n \n   /* In case the edge redirection failed, try to force it to be non-fallthru\n      and redirect newly created simplejump.  */\n-  e->src->flags |= BB_DIRTY;\n+  df_set_bb_dirty (e->src);\n   return force_nonfallthru_and_redirect (e, target);\n }\n \n@@ -1289,17 +1290,6 @@ rtl_split_edge (edge edge_in)\n       BB_COPY_PARTITION (bb, edge_in->dest);\n     }\n \n-  /* ??? This info is likely going to be out of date very soon.  */\n-  if (edge_in->dest->il.rtl->global_live_at_start)\n-    {\n-      bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (bb->il.rtl->global_live_at_start,\n-\t\t    edge_in->dest->il.rtl->global_live_at_start);\n-      COPY_REG_SET (bb->il.rtl->global_live_at_end,\n-\t\t    edge_in->dest->il.rtl->global_live_at_start);\n-    }\n-\n   make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n \n   /* For non-fallthru edges, we must adjust the predecessor's\n@@ -1433,11 +1423,11 @@ commit_one_edge_insertion (edge e)\n \n   if (before)\n     {\n-      emit_insn_before_noloc (insns, before);\n+      emit_insn_before_noloc (insns, before, bb);\n       last = prev_nonnote_insn (before);\n     }\n   else\n-    last = emit_insn_after_noloc (insns, after);\n+    last = emit_insn_after_noloc (insns, after, bb);\n \n   if (returnjump_p (last))\n     {\n@@ -1515,6 +1505,7 @@ commit_edge_insertions (void)\n   sbitmap_free (blocks);\n }\n \f\n+\n /* Print out RTL-specific basic block information (live information\n    at start and end).  */\n \n@@ -1528,18 +1519,23 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent)\n   s_indent = (char *) alloca ((size_t) indent + 1);\n   memset (s_indent, ' ', (size_t) indent);\n   s_indent[indent] = '\\0';\n-\n-  fprintf (outf, \";;%s Registers live at start: \", s_indent);\n-  dump_regset (bb->il.rtl->global_live_at_start, outf);\n-  putc ('\\n', outf);\n+  \n+  if (df)\n+    {\n+      df_dump_top (bb, outf);\n+      putc ('\\n', outf);\n+    }\n \n   for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;\n        insn = NEXT_INSN (insn))\n     print_rtl_single (outf, insn);\n \n-  fprintf (outf, \";;%s Registers live at end: \", s_indent);\n-  dump_regset (bb->il.rtl->global_live_at_end, outf);\n-  putc ('\\n', outf);\n+  if (df)\n+    {\n+      df_dump_bottom (bb, outf);\n+      putc ('\\n', outf);\n+    }\n+\n }\n \f\n /* Like print_rtl, but also print out live information for the start of each\n@@ -1549,7 +1545,6 @@ void\n print_rtl_with_bb (FILE *outf, rtx rtx_first)\n {\n   rtx tmp_rtx;\n-\n   if (rtx_first == 0)\n     fprintf (outf, \"(nil)\\n\");\n   else\n@@ -1562,6 +1557,9 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \n       basic_block bb;\n \n+      if (df)\n+\tdf_dump_start (outf);\n+\n       FOR_EACH_BB_REVERSE (bb)\n \t{\n \t  rtx x;\n@@ -1584,15 +1582,21 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n       for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n \t{\n \t  int did_output;\n-\t  edge_iterator ei;\n-\t  edge e;\n-\n \t  if ((bb = start[INSN_UID (tmp_rtx)]) != NULL)\n \t    {\n-\t      fprintf (outf, \";; Start of basic block %d, registers live:\",\n-\t\t       bb->index);\n-\t      dump_regset (bb->il.rtl->global_live_at_start, outf);\n-\t      putc ('\\n', outf);\n+\t      edge e;\n+\t      edge_iterator ei;\n+\t      \n+\t      fprintf (outf, \";; Start of basic block (\");\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\tfprintf (outf, \" %d\", e->src->index);\n+\t      fprintf (outf, \") -> %d\\n\", bb->index);\n+\n+\t      if (df)\n+\t\t{\n+\t\t  df_dump_top (bb, outf);\n+\t\t  putc ('\\n', outf);\n+\t\t}\n \t      FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t{\n \t\t  fputs (\";; Pred edge \", outf);\n@@ -1612,9 +1616,19 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \n \t  if ((bb = end[INSN_UID (tmp_rtx)]) != NULL)\n \t    {\n-\t      fprintf (outf, \";; End of basic block %d, registers live:\",\n-\t\t       bb->index);\n-\t      dump_regset (bb->il.rtl->global_live_at_end, outf);\n+\t      edge e;\n+\t      edge_iterator ei;\n+\n+\t      fprintf (outf, \";; End of basic block %d -> (\", bb->index);\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tfprintf (outf, \" %d\", e->dest->index);\n+\t      fprintf (outf, \")\\n\");\n+\n+\t      if (df)\n+\t\t{\n+\t\t  df_dump_bottom (bb, outf);\n+\t\t  putc ('\\n', outf);\n+\t\t}\n \t      putc ('\\n', outf);\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t{\n@@ -1623,7 +1637,6 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \t\t  fputc ('\\n', outf);\n \t\t}\n \t    }\n-\n \t  if (did_output)\n \t    putc ('\\n', outf);\n \t}\n@@ -2163,7 +2176,7 @@ purge_dead_edges (basic_block bb)\n \t}\n \n       remove_edge (e);\n-      bb->flags |= BB_DIRTY;\n+      df_set_bb_dirty (bb);\n       purged = true;\n     }\n \n@@ -2231,7 +2244,7 @@ purge_dead_edges (basic_block bb)\n \t    }\n \n \t  /* We do not need this edge.  */\n-\t  bb->flags |= BB_DIRTY;\n+\t  df_set_bb_dirty (bb);\n \t  purged = true;\n \t  remove_edge (e);\n \t}\n@@ -2303,7 +2316,7 @@ purge_dead_edges (basic_block bb)\n     {\n       if (!(e->flags & (EDGE_FALLTHRU | EDGE_FAKE)))\n \t{\n-\t  bb->flags |= BB_DIRTY;\n+\t  df_set_bb_dirty (bb);\n \t  remove_edge (e);\n \t  purged = true;\n \t}\n@@ -2355,7 +2368,6 @@ cfg_layout_split_block (basic_block bb, void *insnp)\n   return new_bb;\n }\n \n-\n /* Redirect Edge to DEST.  */\n static edge\n cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n@@ -2372,7 +2384,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->src != ENTRY_BLOCK_PTR\n       && (ret = try_redirect_by_replacing_jump (e, dest, true)))\n     {\n-      src->flags |= BB_DIRTY;\n+      df_set_bb_dirty (src);\n       return ret;\n     }\n \n@@ -2383,7 +2395,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \tfprintf (dump_file, \"Redirecting entry edge from bb %i to %i\\n\",\n \t\t e->src->index, dest->index);\n \n-      e->src->flags |= BB_DIRTY;\n+      df_set_bb_dirty (e->src);\n       redirect_edge_succ (e, dest);\n       return e;\n     }\n@@ -2409,7 +2421,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t  redirected = redirect_branch_edge (e, dest);\n \t  gcc_assert (redirected);\n \t  e->flags |= EDGE_FALLTHRU;\n-\t  e->src->flags |= BB_DIRTY;\n+\t  df_set_bb_dirty (e->src);\n \t  return e;\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n@@ -2435,7 +2447,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   /* We don't want simplejumps in the insn stream during cfglayout.  */\n   gcc_assert (!simplejump_p (BB_END (src)));\n \n-  src->flags |= BB_DIRTY;\n+  df_set_bb_dirty (src);\n   return ret;\n }\n \n@@ -2574,6 +2586,9 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n   gcc_assert (cfg_layout_can_merge_blocks_p (a, b));\n #endif\n \n+  if (dump_file)\n+    fprintf (dump_file, \"merging block %d into block %d\\n\", b->index, a->index);\n+\n   /* If there was a CODE_LABEL beginning B, delete it.  */\n   if (LABEL_P (BB_HEAD (b)))\n     {\n@@ -2595,7 +2610,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     {\n       rtx first = BB_END (a), last;\n \n-      last = emit_insn_after_noloc (b->il.rtl->header, BB_END (a));\n+      last = emit_insn_after_noloc (b->il.rtl->header, BB_END (a), a);\n       delete_insn_chain (NEXT_INSN (first), last, false);\n       b->il.rtl->header = NULL;\n     }\n@@ -2605,7 +2620,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     {\n       rtx first = unlink_insn_chain (BB_HEAD (b), BB_END (b));\n \n-      emit_insn_after_noloc (first, BB_END (a));\n+      emit_insn_after_noloc (first, BB_END (a), a);\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (first))\n \tfirst = NEXT_INSN (first);\n@@ -2621,7 +2636,11 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       for (insn = BB_HEAD (b);\n \t   insn != NEXT_INSN (BB_END (b));\n \t   insn = NEXT_INSN (insn))\n-\tset_block_for_insn (insn, a);\n+\t{\n+\t  set_block_for_insn (insn, a);\n+\t  df_insn_change_bb (insn);\n+\t}\n+\n       insn = BB_HEAD (b);\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n@@ -2632,6 +2651,8 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       delete_insn (insn);\n     }\n \n+  df_bb_delete (b->index);\n+\n   /* Possible tablejumps and barriers should appear after the block.  */\n   if (b->il.rtl->footer)\n     {\n@@ -2648,7 +2669,6 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n \t}\n       b->il.rtl->footer = NULL;\n     }\n-  a->il.rtl->global_live_at_end = b->il.rtl->global_live_at_end;\n \n   if (dump_file)\n     fprintf (dump_file, \"Merged blocks %d and %d.\\n\",\n@@ -2665,18 +2685,6 @@ cfg_layout_split_edge (edge e)\n \t\t\t? NEXT_INSN (BB_END (e->src)) : get_insns (),\n \t\t\tNULL_RTX, e->src);\n \n-  /* ??? This info is likely going to be out of date very soon, but we must\n-     create it to avoid getting an ICE later.  */\n-  if (e->dest->il.rtl->global_live_at_start)\n-    {\n-      new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n-      new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-      COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n-\t\t    e->dest->il.rtl->global_live_at_start);\n-      COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n-\t\t    e->dest->il.rtl->global_live_at_start);\n-    }\n-\n   make_edge (new_bb, e->dest, EDGE_FALLTHRU);\n   redirect_edge_and_branch_force (e, new_bb);\n \n@@ -2977,7 +2985,7 @@ insert_insn_end_bb_new (rtx pat, basic_block bb)\n #endif\n       /* FIXME: What if something in cc0/jump uses value set in new\n          insn?  */\n-      new_insn = emit_insn_before_noloc (pat, insn);\n+      new_insn = emit_insn_before_noloc (pat, insn, bb);\n     }\n \n   /* Likewise if the last insn is a call, as will happen in the presence\n@@ -3008,10 +3016,10 @@ insert_insn_end_bb_new (rtx pat, basic_block bb)\n              || NOTE_INSN_BASIC_BLOCK_P (insn))\n         insn = NEXT_INSN (insn);\n \n-      new_insn = emit_insn_before_noloc (pat, insn);\n+      new_insn = emit_insn_before_noloc (pat, insn, bb);\n     }\n   else\n-    new_insn = emit_insn_after_noloc (pat, insn);\n+    new_insn = emit_insn_after_noloc (pat, insn, bb);\n \n   return new_insn;\n }\n@@ -3089,7 +3097,7 @@ struct cfg_hooks rtl_cfg_hooks = {\n /* We do not want to declare these functions in a header file, since they\n    should only be used through the cfghooks interface, and we do not want to\n    move them here since it would require also moving quite a lot of related\n-   code.  */\n+   code.  They are in cfglayout.c.  */\n extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n extern basic_block cfg_layout_duplicate_bb (basic_block);\n "}, {"sha": "3fc26d0579e0e0f502d22427a75dd05fb779d6cb", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,7 @@\n /* Combine stack adjustments.\n-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 \n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -55,6 +56,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"function.h\"\n #include \"expr.h\"\n #include \"basic-block.h\"\n+#include \"df.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"reload.h\"\n@@ -454,9 +456,7 @@ gate_handle_stack_adjustments (void)\n static unsigned int\n rest_of_handle_stack_adjustments (void)\n {\n-  life_analysis (PROP_POSTRELOAD);\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n-               | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+  cleanup_cfg (flag_crossjumping ? CLEANUP_CROSSJUMP : 0);\n \n   /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n      even for machines with possibly nonzero RETURN_POPS_ARGS\n@@ -465,7 +465,11 @@ rest_of_handle_stack_adjustments (void)\n #ifndef PUSH_ROUNDING\n   if (!ACCUMULATE_OUTGOING_ARGS)\n #endif\n-    combine_stack_adjustments ();\n+    {\n+      df_note_add_problem ();\n+      df_analyze ();\n+      combine_stack_adjustments ();\n+    }\n   return 0;\n }\n \n@@ -482,6 +486,7 @@ struct tree_opt_pass pass_stack_adjustments =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n+  TODO_df_finish |\n   TODO_dump_func |\n   TODO_ggc_collect,                     /* todo_flags_finish */\n   0                                     /* letter */"}, {"sha": "6077e783cf04c606c3cf578c6617d8e5decf72f4", "filename": "gcc/combine.c", "status": "modified", "additions": 594, "deletions": 313, "changes": 907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,7 @@\n /* Optimize by combining instructions for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -49,8 +50,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    we install it, delete the earlier insns, and update the data flow\n    information (LOG_LINKS and REG_NOTES) for what we did.\n \n-   There are a few exceptions where the dataflow information created by\n-   flow.c aren't completely updated:\n+   There are a few exceptions where the dataflow information isn't\n+   completely updated (however this is only a local issue since it is\n+   regenerated before the next pass that uses it):\n \n    - reg_live_length is not updated\n    - reg_n_refs is not adjusted in the rare case when a register is\n@@ -102,6 +104,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"params.h\"\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n+#include \"df.h\"\n \n /* Number of attempts to combine instructions in this function.  */\n \n@@ -140,21 +143,6 @@ static rtx i2mod_old_rhs;\n \n static rtx i2mod_new_rhs;\n \f\n-/* Vector mapping INSN_UIDs to cuids.\n-   The cuids are like uids but increase monotonically always.\n-   Combine always uses cuids so that it can compare them.\n-   But actually renumbering the uids, which we used to do,\n-   proves to be a bad idea because it makes it hard to compare\n-   the dumps produced by earlier passes with those from later passes.  */\n-\n-static int *uid_cuid;\n-static int max_uid_cuid;\n-\n-/* Get the cuid of an insn.  */\n-\n-#define INSN_CUID(INSN) \\\n-(INSN_UID (INSN) > max_uid_cuid ? insn_cuid (INSN) : uid_cuid[INSN_UID (INSN)])\n-\n /* Maximum register number, which is the size of the tables below.  */\n \n static unsigned int combine_max_regno;\n@@ -270,15 +258,15 @@ struct reg_stat {\n \n static struct reg_stat *reg_stat;\n \n-/* Record the cuid of the last insn that invalidated memory\n+/* Record the luid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n \n static int mem_last_set;\n \n-/* Record the cuid of the last CALL_INSN\n+/* Record the luid of the last CALL_INSN\n    so we can tell whether a potential combination crosses any calls.  */\n \n-static int last_call_cuid;\n+static int last_call_luid;\n \n /* When `subst' is called, this is the insn that is being modified\n    (by combining in a previous insn).  The PATTERN of this insn\n@@ -288,14 +276,14 @@ static int last_call_cuid;\n \n static rtx subst_insn;\n \n-/* This is the lowest CUID that `subst' is currently dealing with.\n+/* This is the lowest LUID that `subst' is currently dealing with.\n    get_last_value will not return a value if the register was set at or\n-   after this CUID.  If not for this mechanism, we could get confused if\n+   after this LUID.  If not for this mechanism, we could get confused if\n    I2 or I1 in try_combine were an insn that used the old value of a register\n    to obtain a new value.  In that case, we might erroneously get the\n    new value of the register when we wanted the old one.  */\n \n-static int subst_low_cuid;\n+static int subst_low_luid;\n \n /* This contains any hard registers that are used in newpat; reg_dead_at_p\n    must consider all these registers to be always live.  */\n@@ -311,24 +299,32 @@ static rtx added_links_insn;\n /* Basic block in which we are performing combines.  */\n static basic_block this_basic_block;\n \n-/* A bitmap indicating which blocks had registers go dead at entry.\n-   After combine, we'll need to re-do global life analysis with\n-   those blocks as starting points.  */\n-static sbitmap refresh_blocks;\n \f\n+/* Length of the currently allocated uid_insn_cost array.  */\n+\n+static int max_uid_known;\n+\n /* The following array records the insn_rtx_cost for every insn\n    in the instruction stream.  */\n \n static int *uid_insn_cost;\n \n-/* Length of the currently allocated uid_insn_cost array.  */\n+/* The following array records the LOG_LINKS for every insn in the\n+   instruction stream as an INSN_LIST rtx.  */\n \n-static int last_insn_cost;\n+static rtx *uid_log_links;\n \n-/* Incremented for each label.  */\n+#define INSN_COST(INSN)\t\t(uid_insn_cost[INSN_UID (INSN)])\n+#define LOG_LINKS(INSN)\t\t(uid_log_links[INSN_UID (INSN)])\n+\n+/* Incremented for each basic block.  */\n \n static int label_tick;\n \n+/* Reset to label_tick for each label.  */\n+\n+static int label_tick_ebb_start;\n+\n /* Mode used to compute significance in reg_stat[].nonzero_bits.  It is the\n    largest integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n@@ -384,7 +380,7 @@ static rtx reg_num_sign_bit_copies_for_combine (rtx, enum machine_mode, rtx,\n static void do_SUBST (rtx *, rtx);\n static void do_SUBST_INT (int *, int);\n static void init_reg_last (void);\n-static void setup_incoming_promotions (void);\n+static void setup_incoming_promotions (rtx);\n static void set_nonzero_bits_and_sign_copies (rtx, rtx, void *);\n static int cant_combine_insn_p (rtx);\n static int can_combine_p (rtx, rtx, rtx, rtx, rtx *, rtx *);\n@@ -443,7 +439,6 @@ static int reg_bitfield_target_p (rtx, rtx);\n static void distribute_notes (rtx, rtx, rtx, rtx, rtx, rtx);\n static void distribute_links (rtx);\n static void mark_used_regs_combine (rtx);\n-static int insn_cuid (rtx);\n static void record_promoted_value (rtx, rtx);\n static int unmentioned_reg_p_1 (rtx *, void *);\n static bool unmentioned_reg_p (rtx, rtx);\n@@ -472,6 +467,166 @@ static rtx gen_lowpart_or_truncate (enum machine_mode, rtx);\n \n static const struct rtl_hooks combine_rtl_hooks = RTL_HOOKS_INITIALIZER;\n \n+\f\n+/* This is used by find_single_use to locate an rtx in LOC that\n+   contains exactly one use of DEST, which is typically either a REG\n+   or CC0.  It returns a pointer to the innermost rtx expression\n+   containing DEST.  Appearances of DEST that are being used to\n+   totally replace it are not counted.  */\n+\n+static rtx *\n+find_single_use_1 (rtx dest, rtx *loc)\n+{\n+  rtx x = *loc;\n+  enum rtx_code code = GET_CODE (x);\n+  rtx *result = NULL;\n+  rtx *this_result;\n+  int i;\n+  const char *fmt;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+    case CLOBBER:\n+      return 0;\n+\n+    case SET:\n+      /* If the destination is anything other than CC0, PC, a REG or a SUBREG\n+\t of a REG that occupies all of the REG, the insn uses DEST if\n+\t it is mentioned in the destination or the source.  Otherwise, we\n+\t need just check the source.  */\n+      if (GET_CODE (SET_DEST (x)) != CC0\n+\t  && GET_CODE (SET_DEST (x)) != PC\n+\t  && !REG_P (SET_DEST (x))\n+\t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n+\t\t&& REG_P (SUBREG_REG (SET_DEST (x)))\n+\t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n+\t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n+\t\t\t + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))))\n+\tbreak;\n+\n+      return find_single_use_1 (dest, &SET_SRC (x));\n+\n+    case MEM:\n+    case SUBREG:\n+      return find_single_use_1 (dest, &XEXP (x, 0));\n+\n+    default:\n+      break;\n+    }\n+\n+  /* If it wasn't one of the common cases above, check each expression and\n+     vector of this code.  Look for a unique usage of DEST.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (dest == XEXP (x, i)\n+\t      || (REG_P (dest) && REG_P (XEXP (x, i))\n+\t\t  && REGNO (dest) == REGNO (XEXP (x, i))))\n+\t    this_result = loc;\n+\t  else\n+\t    this_result = find_single_use_1 (dest, &XEXP (x, i));\n+\n+\t  if (result == NULL)\n+\t    result = this_result;\n+\t  else if (this_result)\n+\t    /* Duplicate usage.  */\n+\t    return NULL;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      if (XVECEXP (x, i, j) == dest\n+\t\t  || (REG_P (dest)\n+\t\t      && REG_P (XVECEXP (x, i, j))\n+\t\t      && REGNO (XVECEXP (x, i, j)) == REGNO (dest)))\n+\t\tthis_result = loc;\n+\t      else\n+\t\tthis_result = find_single_use_1 (dest, &XVECEXP (x, i, j));\n+\n+\t      if (result == NULL)\n+\t\tresult = this_result;\n+\t      else if (this_result)\n+\t\treturn NULL;\n+\t    }\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+\n+/* See if DEST, produced in INSN, is used only a single time in the\n+   sequel.  If so, return a pointer to the innermost rtx expression in which\n+   it is used.\n+\n+   If PLOC is nonzero, *PLOC is set to the insn containing the single use.\n+\n+   If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't\n+   care about REG_DEAD notes or LOG_LINKS.\n+\n+   Otherwise, we find the single use by finding an insn that has a\n+   LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is\n+   only referenced once in that insn, we know that it must be the first\n+   and last insn referencing DEST.  */\n+\n+static rtx *\n+find_single_use (rtx dest, rtx insn, rtx *ploc)\n+{\n+  rtx next;\n+  rtx *result;\n+  rtx link;\n+\n+#ifdef HAVE_cc0\n+  if (dest == cc0_rtx)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (next == 0\n+\t  || (!NONJUMP_INSN_P (next) && !JUMP_P (next)))\n+\treturn 0;\n+\n+      result = find_single_use_1 (dest, &PATTERN (next));\n+      if (result && ploc)\n+\t*ploc = next;\n+      return result;\n+    }\n+#endif\n+\n+  if (!REG_P (dest))\n+    return 0;\n+\n+  for (next = next_nonnote_insn (insn);\n+       next != 0 && !LABEL_P (next);\n+       next = next_nonnote_insn (next))\n+    if (INSN_P (next) && dead_or_set_p (next, dest))\n+      {\n+\tfor (link = LOG_LINKS (next); link; link = XEXP (link, 1))\n+\t  if (XEXP (link, 0) == insn)\n+\t    break;\n+\n+\tif (link)\n+\t  {\n+\t    result = find_single_use_1 (dest, &PATTERN (next));\n+\t    if (ploc)\n+\t      *ploc = next;\n+\t    return result;\n+\t  }\n+      }\n+\n+  return 0;\n+}\n \f\n /* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n    insn.  The substitution can be undone by undo_all.  If INTO is already\n@@ -600,15 +755,12 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat)\n   int old_cost, new_cost;\n \n   /* Lookup the original insn_rtx_costs.  */\n-  i2_cost = INSN_UID (i2) <= last_insn_cost\n-\t    ? uid_insn_cost[INSN_UID (i2)] : 0;\n-  i3_cost = INSN_UID (i3) <= last_insn_cost\n-\t    ? uid_insn_cost[INSN_UID (i3)] : 0;\n+  i2_cost = INSN_COST (i2);\n+  i3_cost = INSN_COST (i3);\n \n   if (i1)\n     {\n-      i1_cost = INSN_UID (i1) <= last_insn_cost\n-\t\t? uid_insn_cost[INSN_UID (i1)] : 0;\n+      i1_cost = INSN_COST (i1);\n       old_cost = (i1_cost > 0 && i2_cost > 0 && i3_cost > 0)\n \t\t ? i1_cost + i2_cost + i3_cost : 0;\n     }\n@@ -636,8 +788,7 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat)\n     {\n       int old_other_cost, new_other_cost;\n \n-      old_other_cost = (INSN_UID (undobuf.other_insn) <= last_insn_cost\n-\t\t\t? uid_insn_cost[INSN_UID (undobuf.other_insn)] : 0);\n+      old_other_cost = INSN_COST (undobuf.other_insn);\n       new_other_cost = insn_rtx_cost (PATTERN (undobuf.other_insn));\n       if (old_other_cost > 0 && new_other_cost > 0)\n \t{\n@@ -685,13 +836,163 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat)\n     }\n \n   /* Update the uid_insn_cost array with the replacement costs.  */\n-  uid_insn_cost[INSN_UID (i2)] = new_i2_cost;\n-  uid_insn_cost[INSN_UID (i3)] = new_i3_cost;\n+  INSN_COST (i2) = new_i2_cost;\n+  INSN_COST (i3) = new_i3_cost;\n   if (i1)\n-    uid_insn_cost[INSN_UID (i1)] = 0;\n+    INSN_COST (i1) = 0;\n \n   return true;\n }\n+\n+\n+/* Delete any insns that copy a register to itself.  */\n+\n+static void\n+delete_noop_moves (void)\n+{\n+  rtx insn, next;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); insn = next)\n+\t{\n+\t  next = NEXT_INSN (insn);\n+\t  if (INSN_P (insn) && noop_move_p (insn))\n+\t    {\n+\t      rtx note;\n+\n+\t      /* If we're about to remove the first insn of a libcall\n+\t\t then move the libcall note to the next real insn and\n+\t\t update the retval note.  */\n+\t      if ((note = find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n+\t\t       && XEXP (note, 0) != insn)\n+\t\t{\n+\t\t  rtx new_libcall_insn = next_real_insn (insn);\n+\t\t  rtx retval_note = find_reg_note (XEXP (note, 0),\n+\t\t\t\t\t\t   REG_RETVAL, NULL_RTX);\n+\t\t  REG_NOTES (new_libcall_insn)\n+\t\t    = gen_rtx_INSN_LIST (REG_LIBCALL, XEXP (note, 0),\n+\t\t\t\t\t REG_NOTES (new_libcall_insn));\n+\t\t  XEXP (retval_note, 0) = new_libcall_insn;\n+\t\t}\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"deleting noop move %d\\n\", INSN_UID (insn));\n+\n+\t      delete_insn_and_edges (insn);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\f\n+/* Fill in log links field for all insns.  */\n+\n+static void\n+create_log_links (void)\n+{\n+  basic_block bb;\n+  rtx *next_use, insn;\n+  struct df_ref **def_vec, **use_vec;\n+\n+  next_use = XCNEWVEC (rtx, max_reg_num ());\n+\n+  /* Pass through each block from the end, recording the uses of each\n+     register and establishing log links when def is encountered.\n+     Note that we do not clear next_use array in order to save time,\n+     so we have to test whether the use is in the same basic block as def.\n+              \n+     There are a few cases below when we do not consider the definition or\n+     usage -- these are taken from original flow.c did. Don't ask me why it is\n+     done this way; I don't know and if it works, I don't want to know.  */\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+        {\n+          if (!INSN_P (insn))\n+            continue;\n+\n+\t  /* Log links are created only once.  */\n+\t  gcc_assert (!LOG_LINKS (insn));\n+\n+          for (def_vec = DF_INSN_DEFS (insn); *def_vec; def_vec++)\n+            {\n+\t      struct df_ref *def = *def_vec;\n+              int regno = DF_REF_REGNO (def);\n+              rtx use_insn;\n+\n+              if (!next_use[regno])\n+                continue;\n+\n+              /* Do not consider if it is pre/post modification in MEM.  */\n+              if (DF_REF_FLAGS (def) & DF_REF_PRE_POST_MODIFY)\n+                continue;\n+\n+              /* Do not make the log link for frame pointer.  */\n+              if ((regno == FRAME_POINTER_REGNUM\n+                   && (! reload_completed || frame_pointer_needed))\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+                  || (regno == HARD_FRAME_POINTER_REGNUM\n+                      && (! reload_completed || frame_pointer_needed))\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+                  || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n+                  )\n+                continue;\n+\n+              use_insn = next_use[regno];\n+              if (BLOCK_FOR_INSN (use_insn) == bb)\n+                {\n+                  /* flow.c claimed:\n+\n+                     We don't build a LOG_LINK for hard registers contained\n+                     in ASM_OPERANDs.  If these registers get replaced,\n+                     we might wind up changing the semantics of the insn,\n+                     even if reload can make what appear to be valid\n+                     assignments later.  */\n+                  if (regno >= FIRST_PSEUDO_REGISTER\n+                      || asm_noperands (PATTERN (use_insn)) < 0)\n+                    LOG_LINKS (use_insn) =\n+                      alloc_INSN_LIST (insn, LOG_LINKS (use_insn));\n+                }\n+              next_use[regno] = NULL_RTX;\n+            }\n+\n+          for (use_vec = DF_INSN_USES (insn); *use_vec; use_vec++)\n+            {\n+\t      struct df_ref *use = *use_vec;\n+\t      int regno = DF_REF_REGNO (use);\n+\n+              /* Do not consider the usage of the stack pointer\n+\t\t by function call.  */\n+              if (DF_REF_FLAGS (use) & DF_REF_CALL_STACK_USAGE)\n+                continue;\n+\n+              next_use[regno] = insn;\n+            }\n+        }\n+    }\n+\n+  free (next_use);\n+}\n+\n+/* Clear LOG_LINKS fields of insns.  */\n+\n+static void\n+clear_log_links (void)\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      free_INSN_LIST_list (&LOG_LINKS (insn));\n+}\n+\n+\n+\n \f\n /* Main entry point for combiner.  F is the first insn of the function.\n    NREGS is the first unused pseudo-reg number.\n@@ -705,13 +1006,16 @@ combine_instructions (rtx f, unsigned int nregs)\n #ifdef HAVE_cc0\n   rtx prev;\n #endif\n-  int i;\n-  unsigned int j = 0;\n   rtx links, nextlinks;\n-  sbitmap_iterator sbi;\n+  rtx first;\n \n   int new_direct_jump_p = 0;\n \n+  for (first = f; first && !INSN_P (first); )\n+    first = NEXT_INSN (first);\n+  if (!first)\n+    return 0;\n+\n   combine_attempts = 0;\n   combine_merges = 0;\n   combine_extras = 0;\n@@ -725,14 +1029,10 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   init_recog_no_volatile ();\n \n-  /* Compute maximum uid value so uid_cuid can be allocated.  */\n-\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    if (INSN_UID (insn) > i)\n-      i = INSN_UID (insn);\n-\n-  uid_cuid = XNEWVEC (int, i + 1);\n-  max_uid_cuid = i;\n+  /* Allocate array for insn info.  */\n+  max_uid_known = get_max_uid ();\n+  uid_log_links = XCNEWVEC (rtx, max_uid_known + 1);\n+  uid_insn_cost = XCNEWVEC (int, max_uid_known + 1);\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n@@ -741,81 +1041,70 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   nonzero_sign_valid = 0;\n \n-  /* Compute the mapping from uids to cuids.\n-     Cuids are numbers assigned to insns, like uids,\n-     except that cuids increase monotonically through the code.\n-\n-     Scan all SETs and see if we can deduce anything about what\n+  /* Scan all SETs and see if we can deduce anything about what\n      bits are known to be zero for some registers and how many copies\n      of the sign bit are known to exist for those registers.\n \n      Also set any known values so that we can use it while searching\n      for what bits are known to be set.  */\n \n-  label_tick = 1;\n+  label_tick = label_tick_ebb_start = 1;\n \n-  setup_incoming_promotions ();\n+  setup_incoming_promotions (first);\n \n-  refresh_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (refresh_blocks);\n-\n-  /* Allocate array of current insn_rtx_costs.  */\n-  uid_insn_cost = XCNEWVEC (int, max_uid_cuid + 1);\n-  last_insn_cost = max_uid_cuid;\n-\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n+  create_log_links ();\n+  FOR_EACH_BB (this_basic_block)\n     {\n-      uid_cuid[INSN_UID (insn)] = ++i;\n-      subst_low_cuid = i;\n-      subst_insn = insn;\n+      last_call_luid = 0;\n+      mem_last_set = -1;\n+      label_tick++;\n+      FOR_BB_INSNS (this_basic_block, insn)\n+        if (INSN_P (insn) && BLOCK_FOR_INSN (insn))\n+\t  {\n+            subst_low_luid = DF_INSN_LUID (insn);\n+            subst_insn = insn;\n \n-      if (INSN_P (insn))\n-\t{\n-\t  note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies,\n-\t\t       NULL);\n-\t  record_dead_and_set_regs (insn);\n+\t    note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies,\n+\t\t         insn);\n+\t    record_dead_and_set_regs (insn);\n \n #ifdef AUTO_INC_DEC\n-\t  for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n-\t    if (REG_NOTE_KIND (links) == REG_INC)\n-\t      set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX,\n-\t\t\t\t\t\tNULL);\n+\t    for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n+\t      if (REG_NOTE_KIND (links) == REG_INC)\n+\t        set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX,\n+\t\t\t\t\t\t  insn);\n #endif\n \n-\t  /* Record the current insn_rtx_cost of this instruction.  */\n-\t  if (NONJUMP_INSN_P (insn))\n-\t    uid_insn_cost[INSN_UID (insn)] = insn_rtx_cost (PATTERN (insn));\n-\t  if (dump_file)\n-\t    fprintf(dump_file, \"insn_cost %d: %d\\n\",\n-\t\t    INSN_UID (insn), uid_insn_cost[INSN_UID (insn)]);\n-\t}\n-\n-      if (LABEL_P (insn))\n-\tlabel_tick++;\n+\t    /* Record the current insn_rtx_cost of this instruction.  */\n+\t    if (NONJUMP_INSN_P (insn))\n+\t      INSN_COST (insn) = insn_rtx_cost (PATTERN (insn));\n+\t    if (dump_file)\n+\t      fprintf(dump_file, \"insn_cost %d: %d\\n\",\n+\t\t    INSN_UID (insn), INSN_COST (insn));\n+\t  }\n+\telse if (LABEL_P (insn))\n+\t  label_tick_ebb_start = label_tick;\n     }\n \n   nonzero_sign_valid = 1;\n \n   /* Now scan all the insns in forward order.  */\n \n-  label_tick = 1;\n-  last_call_cuid = 0;\n-  mem_last_set = 0;\n+  label_tick = label_tick_ebb_start = 1;\n   init_reg_last ();\n-  setup_incoming_promotions ();\n+  setup_incoming_promotions (first);\n \n   FOR_EACH_BB (this_basic_block)\n     {\n+      last_call_luid = 0;\n+      mem_last_set = -1;\n+      label_tick++;\n       for (insn = BB_HEAD (this_basic_block);\n \t   insn != NEXT_INSN (BB_END (this_basic_block));\n \t   insn = next ? next : NEXT_INSN (insn))\n \t{\n \t  next = 0;\n-\n-\t  if (LABEL_P (insn))\n-\t    label_tick++;\n-\n-\t  else if (INSN_P (insn))\n+\t  if (INSN_P (insn))\n \t    {\n \t      /* See if we know about function return values before this\n \t\t insn based upon SUBREG flags.  */\n@@ -956,24 +1245,20 @@ combine_instructions (rtx f, unsigned int nregs)\n \t    retry:\n \t      ;\n \t    }\n+\t  else if (LABEL_P (insn))\n+\t    label_tick_ebb_start = label_tick;\n \t}\n     }\n-  clear_bb_flags ();\n \n-  EXECUTE_IF_SET_IN_SBITMAP (refresh_blocks, 0, j, sbi)\n-    BASIC_BLOCK (j)->flags |= BB_DIRTY;\n+  clear_log_links ();\n+  clear_bb_flags ();\n   new_direct_jump_p |= purge_all_dead_edges ();\n   delete_noop_moves ();\n \n-  update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t\t    PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n-\t\t\t\t    | PROP_KILL_DEAD_CODE);\n-\n   /* Clean up.  */\n-  sbitmap_free (refresh_blocks);\n+  free (uid_log_links);\n   free (uid_insn_cost);\n   free (reg_stat);\n-  free (uid_cuid);\n \n   {\n     struct undo *undo, *next;\n@@ -1012,16 +1297,13 @@ init_reg_last (void)\n /* Set up any promoted values for incoming argument registers.  */\n \n static void\n-setup_incoming_promotions (void)\n+setup_incoming_promotions (rtx first)\n {\n-  rtx first;\n   tree arg;\n \n   if (!targetm.calls.promote_function_args (TREE_TYPE (cfun->decl)))\n     return;\n \n-  first = get_insns ();\n-\n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n        arg = TREE_CHAIN (arg))\n     {\n@@ -1059,17 +1341,17 @@ setup_incoming_promotions (void)\n    by any set of X.  */\n \n static void\n-set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n-\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n+set_nonzero_bits_and_sign_copies (rtx x, rtx set, void *data)\n {\n+  rtx insn = (rtx) data;\n   unsigned int num;\n \n   if (REG_P (x)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n       && ! REGNO_REG_SET_P\n-\t (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start, REGNO (x))\n+           (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n@@ -1079,6 +1361,39 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n \t  return;\n \t}\n \n+      /* If this register is being initialized using itself, and the\n+\t register is uninitialized in this basic block, and there are\n+\t no LOG_LINKS which set the register, then part of the\n+\t register is uninitialized.  In that case we can't assume\n+\t anything about the number of nonzero bits.\n+\n+\t ??? We could do better if we checked this in\n+\t reg_{nonzero_bits,num_sign_bit_copies}_for_combine.  Then we\n+\t could avoid making assumptions about the insn which initially\n+\t sets the register, while still using the information in other\n+\t insns.  We would have to be careful to check every insn\n+\t involved in the combination.  */\n+\n+      if (insn\n+\t  && reg_referenced_p (x, PATTERN (insn))\n+\t  && !REGNO_REG_SET_P (DF_LR_IN (BLOCK_FOR_INSN (insn)),\n+\t\t\t       REGNO (x)))\n+\t{\n+\t  rtx link;\n+\n+\t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+\t    {\n+\t      if (dead_or_set_p (XEXP (link, 0), x))\n+\t\tbreak;\n+\t    }\n+\t  if (!link)\n+\t    {\n+\t      reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t      reg_stat[REGNO (x)].sign_bit_copies = 1;\n+\t      return;\n+\t    }\n+\t}\n+\n       /* If this is a complex assignment, see if we can convert it into a\n \t simple assignment.  */\n       set = expand_field_assignment (set);\n@@ -1307,7 +1622,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       || (! all_adjacent\n \t  && (((!MEM_P (src)\n \t\t|| ! find_reg_note (insn, REG_EQUIV, src))\n-\t       && use_crosses_set_p (src, INSN_CUID (insn)))\n+\t       && use_crosses_set_p (src, DF_INSN_LUID (insn)))\n \t      || (GET_CODE (src) == ASM_OPERANDS && MEM_VOLATILE_P (src))\n \t      || GET_CODE (src) == UNSPEC_VOLATILE))\n       /* If there is a REG_NO_CONFLICT note for DEST in I3 or SUCC, we get\n@@ -1319,7 +1634,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t and it is a pain to update that information.\n \t Exception: if source is a constant, moving it later can't hurt.\n \t Accept that special case, because it helps -fforce-addr a lot.  */\n-      || (INSN_CUID (insn) < last_call_cuid && ! CONSTANT_P (src)))\n+      || (DF_INSN_LUID (insn) < last_call_luid && ! CONSTANT_P (src)))\n     return 0;\n \n   /* DEST must either be a REG or CC0.  */\n@@ -1869,7 +2184,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n   /* If I1 and I2 both feed I3, they can be in any order.  To simplify the\n      code below, set I1 to be the earlier of the two insns.  */\n-  if (i1 && INSN_CUID (i1) > INSN_CUID (i2))\n+  if (i1 && DF_INSN_LUID (i1) > DF_INSN_LUID (i2))\n     temp = i1, i1 = i2, i2 = temp;\n \n   added_links_insn = 0;\n@@ -1934,7 +2249,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t      combine_merges++;\n \n \t      subst_insn = i3;\n-\t      subst_low_cuid = INSN_CUID (i2);\n+\t      subst_low_luid = DF_INSN_LUID (i2);\n \n \t      added_sets_2 = added_sets_1 = 0;\n \t      i2dest = SET_SRC (PATTERN (i3));\n@@ -2075,7 +2390,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \t  combine_merges++;\n \t  subst_insn = i3;\n-\t  subst_low_cuid = INSN_CUID (i2);\n+\t  subst_low_luid = DF_INSN_LUID (i2);\n \t  added_sets_2 = added_sets_1 = 0;\n \t  i2dest = SET_DEST (temp);\n \t  i2dest_killed = dead_or_set_p (i2, i2dest);\n@@ -2121,14 +2436,13 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       if (i == 1)\n \t{\n \t  /* We make I1 with the same INSN_UID as I2.  This gives it\n-\t     the same INSN_CUID for value tracking.  Our fake I1 will\n+\t     the same DF_INSN_LUID for value tracking.  Our fake I1 will\n \t     never appear in the insn stream so giving it the same INSN_UID\n \t     as I2 will not cause a problem.  */\n \n \t  i1 = gen_rtx_INSN (VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n \t\t\t     BLOCK_FOR_INSN (i2), INSN_LOCATOR (i2),\n-\t\t\t     XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX,\n-\t\t\t     NULL_RTX);\n+\t\t\t     XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX);\n \n \t  SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 0));\n \t  SUBST (XEXP (SET_SRC (PATTERN (i2)), 0),\n@@ -2342,12 +2656,12 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t     simplifications.  */\n \t  if (i1)\n \t    {\n-\t      subst_low_cuid = INSN_CUID (i1);\n+\t      subst_low_luid = DF_INSN_LUID (i1);\n \t      i1src = subst (i1src, pc_rtx, pc_rtx, 0, 0);\n \t    }\n \t  else\n \t    {\n-\t      subst_low_cuid = INSN_CUID (i2);\n+\t      subst_low_luid = DF_INSN_LUID (i2);\n \t      i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);\n \t    }\n \t}\n@@ -2358,7 +2672,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t need to make a unique copy of I2SRC each time we substitute it\n \t to avoid self-referential rtl.  */\n \n-      subst_low_cuid = INSN_CUID (i2);\n+      subst_low_luid = DF_INSN_LUID (i2);\n       newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n \t\t      ! i1_feeds_i3 && i1dest_in_i1src);\n       substed_i2 = 1;\n@@ -2384,7 +2698,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t}\n \n       n_occurrences = 0;\n-      subst_low_cuid = INSN_CUID (i1);\n+      subst_low_luid = DF_INSN_LUID (i1);\n       newpat = subst (newpat, i1dest, i1src, 0, 0);\n       substed_i1 = 1;\n     }\n@@ -2631,7 +2945,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t}\n       else if (m_split && NEXT_INSN (NEXT_INSN (m_split)) == NULL_RTX\n \t       && (next_real_insn (i2) == i3\n-\t\t   || ! use_crosses_set_p (PATTERN (m_split), INSN_CUID (i2))))\n+\t\t   || ! use_crosses_set_p (PATTERN (m_split), DF_INSN_LUID (i2))))\n \t{\n \t  rtx i2set, i3set;\n \t  rtx newi3pat = PATTERN (NEXT_INSN (m_split));\n@@ -2675,7 +2989,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t      if (REG_P (new_i3_dest)\n \t\t  && REG_P (new_i2_dest)\n \t\t  && REGNO (new_i3_dest) == REGNO (new_i2_dest))\n-\t\tREG_N_SETS (REGNO (new_i2_dest))++;\n+\t\tINC_REG_N_SETS (REGNO (new_i2_dest), 1);\n \t    }\n \t}\n \n@@ -2695,7 +3009,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t      || can_change_dest_mode (i2dest, added_sets_2,\n \t\t\t\t       GET_MODE (*split)))\n \t  && (next_real_insn (i2) == i3\n-\t      || ! use_crosses_set_p (*split, INSN_CUID (i2)))\n+\t      || ! use_crosses_set_p (*split, DF_INSN_LUID (i2)))\n \t  /* We can't overwrite I2DEST if its value is still used by\n \t     NEWPAT.  */\n \t  && ! reg_referenced_p (i2dest, newpat))\n@@ -2865,7 +3179,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && rtx_equal_p (SET_SRC (XVECEXP (newpat, 0, 1)),\n \t\t\t   XEXP (SET_SRC (XVECEXP (newpat, 0, 0)), 0))\n \t   && ! use_crosses_set_p (SET_SRC (XVECEXP (newpat, 0, 1)),\n-\t\t\t\t   INSN_CUID (i2))\n+\t\t\t\t   DF_INSN_LUID (i2))\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != ZERO_EXTRACT\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n@@ -2919,7 +3233,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != ZERO_EXTRACT\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! use_crosses_set_p (SET_SRC (XVECEXP (newpat, 0, 1)),\n-\t\t\t\t   INSN_CUID (i2))\n+\t\t\t\t   DF_INSN_LUID (i2))\n \t   && ! reg_referenced_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t  XVECEXP (newpat, 0, 0))\n \t   && ! reg_referenced_p (SET_DEST (XVECEXP (newpat, 0, 0)),\n@@ -2995,18 +3309,9 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \t  if (REG_NOTE_KIND (note) == REG_UNUSED\n \t      && ! reg_set_p (XEXP (note, 0), PATTERN (undobuf.other_insn)))\n-\t    {\n-\t      if (REG_P (XEXP (note, 0)))\n-\t\tREG_N_DEATHS (REGNO (XEXP (note, 0)))--;\n-\n-\t      remove_note (undobuf.other_insn, note);\n-\t    }\n+\t    remove_note (undobuf.other_insn, note);\n \t}\n \n-      for (note = new_other_notes; note; note = XEXP (note, 1))\n-\tif (REG_P (XEXP (note, 0)))\n-\t  REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n-\n       distribute_notes (new_other_notes, undobuf.other_insn,\n \t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n     }\n@@ -3210,11 +3515,11 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (newi2pat)\n       {\n-\tmove_deaths (newi2pat, NULL_RTX, INSN_CUID (i1), i2, &midnotes);\n-\tmove_deaths (newpat, newi2pat, INSN_CUID (i1), i3, &midnotes);\n+\tmove_deaths (newi2pat, NULL_RTX, DF_INSN_LUID (i1), i2, &midnotes);\n+\tmove_deaths (newpat, newi2pat, DF_INSN_LUID (i1), i3, &midnotes);\n       }\n     else\n-      move_deaths (newpat, NULL_RTX, i1 ? INSN_CUID (i1) : INSN_CUID (i2),\n+      move_deaths (newpat, NULL_RTX, i1 ? DF_INSN_LUID (i1) : DF_INSN_LUID (i2),\n \t\t   i3, &midnotes);\n \n     /* Distribute all the LOG_LINKS and REG_NOTES from I1, I2, and I3.  */\n@@ -3233,26 +3538,13 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n-       so we always pass it as i3.  We have not counted the notes in\n-       reg_n_deaths yet, so we need to do so now.  */\n+       so we always pass it as i3.  */\n \n     if (newi2pat && new_i2_notes)\n-      {\n-\tfor (temp = new_i2_notes; temp; temp = XEXP (temp, 1))\n-\t  if (REG_P (XEXP (temp, 0)))\n-\t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n-\n-\tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n-      }\n-\n+      distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n+    \n     if (new_i3_notes)\n-      {\n-\tfor (temp = new_i3_notes; temp; temp = XEXP (temp, 1))\n-\t  if (REG_P (XEXP (temp, 0)))\n-\t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n-\n-\tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n-      }\n+      distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n        put a REG_DEAD note for it somewhere.  If NEWI2PAT exists and sets\n@@ -3263,9 +3555,6 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (i3dest_killed)\n       {\n-\tif (REG_P (i3dest_killed))\n-\t  REG_N_DEATHS (REGNO (i3dest_killed))++;\n-\n \tif (newi2pat && reg_set_p (i3dest_killed, newi2pat))\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i3dest_killed,\n \t\t\t\t\t       NULL_RTX),\n@@ -3279,9 +3568,6 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (i2dest_in_i2src)\n       {\n-\tif (REG_P (i2dest))\n-\t  REG_N_DEATHS (REGNO (i2dest))++;\n-\n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i2dest, NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n@@ -3293,9 +3579,6 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (i1dest_in_i1src)\n       {\n-\tif (REG_P (i1dest))\n-\t  REG_N_DEATHS (REGNO (i1dest))++;\n-\n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i1dest, NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n@@ -3336,7 +3619,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t    && ! i2dest_in_i2src)\n \t  {\n \t    regno = REGNO (i2dest);\n-\t    REG_N_SETS (regno)--;\n+\t    INC_REG_N_SETS (regno, -1);\n \t  }\n       }\n \n@@ -3354,7 +3637,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \tregno = REGNO (i1dest);\n \tif (! added_sets_1 && ! i1dest_in_i1src)\n-\t  REG_N_SETS (regno)--;\n+\t  INC_REG_N_SETS (regno, -1);\n       }\n \n     /* Update reg_stat[].nonzero_bits et al for any changes that may have\n@@ -3400,13 +3683,53 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t&& SET_DEST (newpat) == pc_rtx)\n       *new_direct_jump_p = 1;\n   }\n+  \n+  if (undobuf.other_insn != NULL_RTX)\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"modifying other_insn \");\n+\t  dump_insn_slim (dump_file, undobuf.other_insn);\n+\t}\n+      df_insn_rescan (undobuf.other_insn);\n+    }\n+\n+  if (i1 && !(NOTE_P(i1) && (NOTE_KIND (i1) == NOTE_INSN_DELETED)))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"modifying insn i1 \");\n+\t  dump_insn_slim (dump_file, i1);\n+\t}\n+      df_insn_rescan (i1);\n+    }\n \n+  if (i2 && !(NOTE_P(i2) && (NOTE_KIND (i2) == NOTE_INSN_DELETED)))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"modifying insn i2 \");\n+\t  dump_insn_slim (dump_file, i2);\n+\t}\n+      df_insn_rescan (i2);\n+    }\n+\n+  if (i3 && !(NOTE_P(i3) && (NOTE_KIND (i3) == NOTE_INSN_DELETED)))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"modifying insn i3 \");\n+\t  dump_insn_slim (dump_file, i3);\n+\t}\n+      df_insn_rescan (i3);\n+    }\n+  \n   combine_successes++;\n   undo_commit ();\n \n   if (added_links_insn\n-      && (newi2pat == 0 || INSN_CUID (added_links_insn) < INSN_CUID (i2))\n-      && INSN_CUID (added_links_insn) < INSN_CUID (i3))\n+      && (newi2pat == 0 || DF_INSN_LUID (added_links_insn) < DF_INSN_LUID (i2))\n+      && DF_INSN_LUID (added_links_insn) < DF_INSN_LUID (i3))\n     return added_links_insn;\n   else\n     return newi2pat ? i2 : i3;\n@@ -3906,11 +4229,11 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n       return (unique_copy && n_occurrences > 1 ? copy_rtx (to) : to);\n     }\n \n-  /* If X and FROM are the same register but different modes, they will\n-     not have been seen as equal above.  However, flow.c will make a\n-     LOG_LINKS entry for that case.  If we do nothing, we will try to\n-     rerecognize our original insn and, when it succeeds, we will\n-     delete the feeding insn, which is incorrect.\n+  /* If X and FROM are the same register but different modes, they\n+     will not have been seen as equal above.  However, the log links code\n+     will make a LOG_LINKS entry for that case.  If we do nothing, we\n+     will try to rerecognize our original insn and, when it succeeds,\n+     we will delete the feeding insn, which is incorrect.\n \n      So force this insn not to match in this (rare) case.  */\n   if (! in_dest && code == REG && REG_P (from)\n@@ -8277,13 +8600,14 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n       && (reg_stat[REGNO (x)].last_set_mode == mode\n \t  || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n \t      && GET_MODE_CLASS (mode) == MODE_INT))\n-      && (reg_stat[REGNO (x)].last_set_label == label_tick\n+      && ((reg_stat[REGNO (x)].last_set_label >= label_tick_ebb_start\n+\t   && reg_stat[REGNO (x)].last_set_label < label_tick)\n+\t  || (reg_stat[REGNO (x)].last_set_label == label_tick\n+              && DF_INSN_LUID (reg_stat[REGNO (x)].last_set) < subst_low_luid)\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n-\t      && ! REGNO_REG_SET_P\n-\t\t (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n-\t\t  REGNO (x))))\n-      && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n+\t      && !REGNO_REG_SET_P\n+\t          (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x)))))\n     {\n       *nonzero &= reg_stat[REGNO (x)].last_set_nonzero_bits;\n       return NULL;\n@@ -8345,13 +8669,14 @@ reg_num_sign_bit_copies_for_combine (rtx x, enum machine_mode mode,\n \n   if (reg_stat[REGNO (x)].last_set_value != 0\n       && reg_stat[REGNO (x)].last_set_mode == mode\n-      && (reg_stat[REGNO (x)].last_set_label == label_tick\n+      && ((reg_stat[REGNO (x)].last_set_label >= label_tick_ebb_start\n+\t   && reg_stat[REGNO (x)].last_set_label < label_tick)\n+\t  || (reg_stat[REGNO (x)].last_set_label == label_tick\n+              && DF_INSN_LUID (reg_stat[REGNO (x)].last_set) < subst_low_luid)\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n-\t      && ! REGNO_REG_SET_P\n-\t\t (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n-\t\t  REGNO (x))))\n-      && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n+\t      && !REGNO_REG_SET_P\n+\t          (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x)))))\n     {\n       *result = reg_stat[REGNO (x)].last_set_sign_bit_copies;\n       return NULL;\n@@ -9382,8 +9707,12 @@ recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n \t  if (REG_P (XEXP (XVECEXP (newpat, 0, i), 0))\n \t      && ! reg_dead_at_p (XEXP (XVECEXP (newpat, 0, i), 0), insn))\n \t    return -1;\n-\t  notes = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t\t     XEXP (XVECEXP (newpat, 0, i), 0), notes);\n+\t  if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) != SCRATCH) \n+\t    {\n+\t      gcc_assert (REG_P (XEXP (XVECEXP (newpat, 0, i), 0)));\n+\t      notes = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t XEXP (XVECEXP (newpat, 0, i), 0), notes);\n+\t    }\n \t}\n       pat = newpat;\n     }\n@@ -9451,11 +9780,6 @@ gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n \n   result = gen_lowpart_common (omode, x);\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  if (result != 0 && GET_CODE (result) == SUBREG)\n-    record_subregs_of_mode (result);\n-#endif\n-\n   if (result)\n     return result;\n \n@@ -10867,7 +11191,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n       /* Set things up so get_last_value is allowed to see anything set up to\n \t our insn.  */\n-      subst_low_cuid = INSN_CUID (insn);\n+      subst_low_luid = DF_INSN_LUID (insn);\n       tem = get_last_value (reg);\n \n       /* If TEM is simply a binary operation with two CLOBBERs as operands,\n@@ -10923,7 +11247,8 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   for (i = regno; i < endregno; i++)\n     {\n       reg_stat[i].last_set_label = label_tick;\n-      if (!insn || (value && reg_stat[i].last_set_table_tick == label_tick))\n+      if (!insn\n+\t  || (value && reg_stat[i].last_set_table_tick >= label_tick_ebb_start))\n \treg_stat[i].last_set_invalid = 1;\n       else\n \treg_stat[i].last_set_invalid = 0;\n@@ -10949,7 +11274,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   if (value)\n     {\n       enum machine_mode mode = GET_MODE (reg);\n-      subst_low_cuid = INSN_CUID (insn);\n+      subst_low_luid = DF_INSN_LUID (insn);\n       reg_stat[regno].last_set_mode = mode;\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n@@ -11000,7 +11325,7 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n   else if (MEM_P (dest)\n \t   /* Ignore pushes, they clobber nothing.  */\n \t   && ! push_operand (dest, GET_MODE (dest)))\n-    mem_last_set = INSN_CUID (record_dead_insn);\n+    mem_last_set = DF_INSN_LUID (record_dead_insn);\n }\n \n /* Update the records of when each REG was most recently set or killed\n@@ -11010,7 +11335,7 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n    We update reg_stat[], in particular fields last_set, last_set_value,\n    last_set_mode, last_set_nonzero_bits, last_set_sign_bit_copies,\n    last_death, and also the similar information mem_last_set (which insn\n-   most recently modified memory) and last_call_cuid (which insn was the\n+   most recently modified memory) and last_call_luid (which insn was the\n    most recent subroutine call).  */\n \n static void\n@@ -11039,6 +11364,8 @@ record_dead_and_set_regs (rtx insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  {\n+\t    reg_stat[i].last_set_invalid = 1;\n+\t    reg_stat[i].last_set = insn;\n \t    reg_stat[i].last_set_value = 0;\n \t    reg_stat[i].last_set_mode = 0;\n \t    reg_stat[i].last_set_nonzero_bits = 0;\n@@ -11047,10 +11374,10 @@ record_dead_and_set_regs (rtx insn)\n \t    reg_stat[i].truncated_to_mode = 0;\n \t  }\n \n-      last_call_cuid = mem_last_set = INSN_CUID (insn);\n+      last_call_luid = mem_last_set = DF_INSN_LUID (insn);\n \n       /* We can't combine into a call pattern.  Remember, though, that\n-\t the return value register is set at this CUID.  We could\n+\t the return value register is set at this LUID.  We could\n \t still replace a register with the return value from the\n \t wrong subroutine call!  */\n       note_stores (PATTERN (insn), record_dead_and_set_regs_1, NULL_RTX);\n@@ -11117,7 +11444,8 @@ reg_truncated_to_mode (enum machine_mode mode, rtx x)\n {\n   enum machine_mode truncated = reg_stat[REGNO (x)].truncated_to_mode;\n \n-  if (truncated == 0 || reg_stat[REGNO (x)].truncation_label != label_tick)\n+  if (truncated == 0\n+      || reg_stat[REGNO (x)].truncation_label < label_tick_ebb_start)\n     return false;\n   if (GET_MODE_SIZE (truncated) <= GET_MODE_SIZE (mode))\n     return true;\n@@ -11158,7 +11486,7 @@ record_truncated_value (rtx x)\n     return;\n \n   if (reg_stat[REGNO (x)].truncated_to_mode == 0\n-      || reg_stat[REGNO (x)].truncation_label < label_tick\n+      || reg_stat[REGNO (x)].truncation_label < label_tick_ebb_start\n       || (GET_MODE_SIZE (truncated_mode)\n \t  < GET_MODE_SIZE (reg_stat[REGNO (x)].truncated_to_mode)))\n     {\n@@ -11233,9 +11561,8 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \t       live at the beginning of the function, it is always valid.  */\n \t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n-\t\t   && (! REGNO_REG_SET_P\n-\t\t       (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n-\t\t\tregno)))\n+\t\t   && !REGNO_REG_SET_P\n+\t\t       (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), regno))\n \t\t&& reg_stat[j].last_set_label > tick))\n \t  {\n \t    if (replace)\n@@ -11249,7 +11576,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n      no stores after it that might have clobbered the value.  We don't\n      have alias info, so we assume any store invalidates it.  */\n   else if (MEM_P (x) && !MEM_READONLY_P (x)\n-\t   && INSN_CUID (insn) <= mem_last_set)\n+\t   && DF_INSN_LUID (insn) <= mem_last_set)\n     {\n       if (replace)\n \t*loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n@@ -11341,17 +11668,17 @@ get_last_value (rtx x)\n      block.  */\n \n   if (value == 0\n-      || (reg_stat[regno].last_set_label != label_tick\n+      || (reg_stat[regno].last_set_label < label_tick_ebb_start\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n-\t      || (REGNO_REG_SET_P\n-\t\t  (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n-\t\t   regno)))))\n+\t      || REGNO_REG_SET_P\n+\t\t (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), regno))))\n     return 0;\n \n   /* If the value was set in a later insn than the ones we are processing,\n      we can't use it even if the register was only set once.  */\n-  if (INSN_CUID (reg_stat[regno].last_set) >= subst_low_cuid)\n+  if (reg_stat[regno].last_set_label == label_tick\n+      && DF_INSN_LUID (reg_stat[regno].last_set) >= subst_low_luid)\n     return 0;\n \n   /* If the value has all its registers valid, return it.  */\n@@ -11371,10 +11698,10 @@ get_last_value (rtx x)\n }\n \f\n /* Return nonzero if expression X refers to a REG or to memory\n-   that is set in an instruction more recent than FROM_CUID.  */\n+   that is set in an instruction more recent than FROM_LUID.  */\n \n static int\n-use_crosses_set_p (rtx x, int from_cuid)\n+use_crosses_set_p (rtx x, int from_luid)\n {\n   const char *fmt;\n   int i;\n@@ -11393,12 +11720,13 @@ use_crosses_set_p (rtx x, int from_cuid)\n #endif\n       for (; regno < endreg; regno++)\n \tif (reg_stat[regno].last_set\n-\t    && INSN_CUID (reg_stat[regno].last_set) > from_cuid)\n+\t    && reg_stat[regno].last_set_label == label_tick\n+\t    && DF_INSN_LUID (reg_stat[regno].last_set) > from_luid)\n \t  return 1;\n       return 0;\n     }\n \n-  if (code == MEM && mem_last_set > from_cuid)\n+  if (code == MEM && mem_last_set > from_luid)\n     return 1;\n \n   fmt = GET_RTX_FORMAT (code);\n@@ -11409,11 +11737,11 @@ use_crosses_set_p (rtx x, int from_cuid)\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (use_crosses_set_p (XVECEXP (x, i, j), from_cuid))\n+\t    if (use_crosses_set_p (XVECEXP (x, i, j), from_luid))\n \t      return 1;\n \t}\n       else if (fmt[i] == 'e'\n-\t       && use_crosses_set_p (XEXP (x, i), from_cuid))\n+\t       && use_crosses_set_p (XEXP (x, i), from_luid))\n \treturn 1;\n     }\n   return 0;\n@@ -11501,14 +11829,13 @@ reg_dead_at_p (rtx reg, rtx insn)\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (REGNO_REG_SET_P (block->il.rtl->global_live_at_start, i))\n+    if (REGNO_REG_SET_P (DF_LIVE_IN (block), i))\n       return 0;\n \n   return 1;\n }\n \f\n-/* Note hard registers in X that are used.  This code is similar to\n-   that in flow.c, but much simpler since we don't care about pseudos.  */\n+/* Note hard registers in X that are used.  */\n \n static void\n mark_used_regs_combine (rtx x)\n@@ -11616,16 +11943,13 @@ remove_death (unsigned int regno, rtx insn)\n   rtx note = find_regno_note (insn, REG_DEAD, regno);\n \n   if (note)\n-    {\n-      REG_N_DEATHS (regno)--;\n-      remove_note (insn, note);\n-    }\n+    remove_note (insn, note);\n \n   return note;\n }\n \n /* For each register (hardware or pseudo) used within expression X, if its\n-   death is in an instruction with cuid between FROM_CUID (inclusive) and\n+   death is in an instruction with luid between FROM_LUID (inclusive) and\n    TO_INSN (exclusive), put a REG_DEAD note for that register in the\n    list headed by PNOTES.\n \n@@ -11635,7 +11959,7 @@ remove_death (unsigned int regno, rtx insn)\n    notes will then be distributed as needed.  */\n \n static void\n-move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n+move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx to_insn,\n \t     rtx *pnotes)\n {\n   const char *fmt;\n@@ -11646,28 +11970,15 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n     {\n       unsigned int regno = REGNO (x);\n       rtx where_dead = reg_stat[regno].last_death;\n-      rtx before_dead, after_dead;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n       if (maybe_kill_insn && reg_set_p (x, maybe_kill_insn)\n \t  && ! reg_referenced_p (x, maybe_kill_insn))\n \treturn;\n \n-      /* WHERE_DEAD could be a USE insn made by combine, so first we\n-\t make sure that we have insns with valid INSN_CUID values.  */\n-      before_dead = where_dead;\n-      while (before_dead && INSN_UID (before_dead) > max_uid_cuid)\n-\tbefore_dead = PREV_INSN (before_dead);\n-\n-      after_dead = where_dead;\n-      while (after_dead && INSN_UID (after_dead) > max_uid_cuid)\n-\tafter_dead = NEXT_INSN (after_dead);\n-\n-      if (before_dead && after_dead\n-\t  && INSN_CUID (before_dead) >= from_cuid\n-\t  && (INSN_CUID (after_dead) < INSN_CUID (to_insn)\n-\t      || (where_dead != after_dead\n-\t\t  && INSN_CUID (after_dead) == INSN_CUID (to_insn))))\n+      if (where_dead\n+\t  && DF_INSN_LUID (where_dead) >= from_luid\n+\t  && DF_INSN_LUID (where_dead) < DF_INSN_LUID (to_insn))\n \t{\n \t  rtx note = remove_death (regno, where_dead);\n \n@@ -11720,7 +12031,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \n \t      for (i = regno + offset; i < ourend; i++)\n \t\tmove_deaths (regno_reg_rtx[i],\n-\t\t\t     maybe_kill_insn, from_cuid, to_insn, &oldnotes);\n+\t\t\t     maybe_kill_insn, from_luid, to_insn, &oldnotes);\n \t    }\n \n \t  if (note != 0 && GET_MODE (XEXP (note, 0)) == GET_MODE (x))\n@@ -11730,8 +12041,6 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t    }\n \t  else\n \t    *pnotes = gen_rtx_EXPR_LIST (REG_DEAD, x, *pnotes);\n-\n-\t  REG_N_DEATHS (regno)++;\n \t}\n \n       return;\n@@ -11741,7 +12050,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n     {\n       rtx dest = SET_DEST (x);\n \n-      move_deaths (SET_SRC (x), maybe_kill_insn, from_cuid, to_insn, pnotes);\n+      move_deaths (SET_SRC (x), maybe_kill_insn, from_luid, to_insn, pnotes);\n \n       /* In the case of a ZERO_EXTRACT, a STRICT_LOW_PART, or a SUBREG\n \t that accesses one word of a multi-word item, some\n@@ -11757,7 +12066,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n \t\t       + UNITS_PER_WORD - 1) / UNITS_PER_WORD))))\n \t{\n-\t  move_deaths (dest, maybe_kill_insn, from_cuid, to_insn, pnotes);\n+\t  move_deaths (dest, maybe_kill_insn, from_luid, to_insn, pnotes);\n \t  return;\n \t}\n \n@@ -11771,7 +12080,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t being replaced so the old value is not used in this insn.  */\n \n       if (MEM_P (dest))\n-\tmove_deaths (XEXP (dest, 0), maybe_kill_insn, from_cuid,\n+\tmove_deaths (XEXP (dest, 0), maybe_kill_insn, from_luid,\n \t\t     to_insn, pnotes);\n       return;\n     }\n@@ -11788,11 +12097,11 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    move_deaths (XVECEXP (x, i, j), maybe_kill_insn, from_cuid,\n+\t    move_deaths (XVECEXP (x, i, j), maybe_kill_insn, from_luid,\n \t\t\t to_insn, pnotes);\n \t}\n       else if (fmt[i] == 'e')\n-\tmove_deaths (XEXP (x, i), maybe_kill_insn, from_cuid, to_insn, pnotes);\n+\tmove_deaths (XEXP (x, i), maybe_kill_insn, from_luid, to_insn, pnotes);\n     }\n }\n \f\n@@ -12059,6 +12368,15 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t     to simply delete it.  */\n \t  break;\n \n+\tcase REG_LIBCALL_ID:\n+\t  /* If the insn previously containing this note still exists,\n+\t     put it back where it was.  Otherwise move it to the previous\n+\t     insn.  */\n+\t  if (!NOTE_P (from_insn))\n+\t    place = from_insn;\n+\t  else\n+\t    place = prev_real_insn (from_insn);\n+\t  break;\n \tcase REG_RETVAL:\n \t  /* If the insn previously containing this note still exists,\n \t     put it back where it was.  Otherwise move it to the previous\n@@ -12260,10 +12578,9 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t i2 but does not die in i2, and place is between i2\n \t\t\t and i3, then we may need to move a link from place to\n \t\t\t i2.  */\n-\t\t      if (i2 && INSN_UID (place) <= max_uid_cuid\n-\t\t\t  && INSN_CUID (place) > INSN_CUID (i2)\n+\t\t      if (i2 && DF_INSN_LUID (place) > DF_INSN_LUID (i2)\n \t\t\t  && from_insn\n-\t\t\t  && INSN_CUID (from_insn) > INSN_CUID (i2)\n+\t\t\t  && DF_INSN_LUID (from_insn) > DF_INSN_LUID (i2)\n \t\t\t  && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n \t\t\t{\n \t\t\t  rtx links = LOG_LINKS (place);\n@@ -12277,15 +12594,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t    break;\n \t\t}\n \n-\t      /* We haven't found an insn for the death note and it\n-\t\t is still a REG_DEAD note, but we have hit the beginning\n-\t\t of the block.  If the existing life info says the reg\n-\t\t was dead, there's nothing left to do.  Otherwise, we'll\n-\t\t need to do a global life update after combine.  */\n-\t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0\n-\t\t  && REGNO_REG_SET_P (bb->il.rtl->global_live_at_start,\n-\t\t\t\t      REGNO (XEXP (note, 0))))\n-\t\tSET_BIT (refresh_blocks, this_basic_block->index);\n \t    }\n \n \t  /* If the register is set or already dead at PLACE, we needn't do\n@@ -12298,11 +12606,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t    {\n \t      unsigned int regno = REGNO (XEXP (note, 0));\n \n-\t      /* Similarly, if the instruction on which we want to place\n-\t\t the note is a noop, we'll need do a global live update\n-\t\t after we remove them in delete_noop_moves.  */\n-\t      if (noop_move_p (place))\n-\t\tSET_BIT (refresh_blocks, this_basic_block->index);\n \n \t      if (dead_or_set_p (place, XEXP (note, 0))\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))\n@@ -12369,11 +12672,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t\tif (! INSN_P (tem))\n \t\t\t\t  {\n \t\t\t\t    if (tem == BB_HEAD (bb))\n-\t\t\t\t      {\n-\t\t\t\t\tSET_BIT (refresh_blocks,\n-\t\t\t\t\t\t this_basic_block->index);\n-\t\t\t\t\tbreak;\n-\t\t\t\t      }\n+\t\t\t \t      break;\n \t\t\t\t    continue;\n \t\t\t\t  }\n \t\t\t\tif (dead_or_set_p (tem, piece)\n@@ -12406,23 +12705,11 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  XEXP (note, 1) = REG_NOTES (place);\n \t  REG_NOTES (place) = note;\n \t}\n-      else if ((REG_NOTE_KIND (note) == REG_DEAD\n-\t\t|| REG_NOTE_KIND (note) == REG_UNUSED)\n-\t       && REG_P (XEXP (note, 0)))\n-\tREG_N_DEATHS (REGNO (XEXP (note, 0)))--;\n \n       if (place2)\n-\t{\n-\t  if ((REG_NOTE_KIND (note) == REG_DEAD\n-\t       || REG_NOTE_KIND (note) == REG_UNUSED)\n-\t      && REG_P (XEXP (note, 0)))\n-\t    REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n-\n-\t  REG_NOTES (place2) = gen_rtx_fmt_ee (GET_CODE (note),\n-\t\t\t\t\t       REG_NOTE_KIND (note),\n-\t\t\t\t\t       XEXP (note, 0),\n-\t\t\t\t\t       REG_NOTES (place2));\n-\t}\n+\tREG_NOTES (place2) \n+\t  = gen_rtx_fmt_ee (GET_CODE (note), REG_NOTE_KIND (note),\n+\t\t\t    XEXP (note, 0), REG_NOTES (place2));\n     }\n }\n \f\n@@ -12510,7 +12797,7 @@ distribute_links (rtx links)\n \t      /* Set added_links_insn to the earliest insn we added a\n \t\t link to.  */\n \t      if (added_links_insn == 0\n-\t\t  || INSN_CUID (added_links_insn) > INSN_CUID (place))\n+\t\t  || DF_INSN_LUID (added_links_insn) > DF_INSN_LUID (place))\n \t\tadded_links_insn = place;\n \t    }\n \t}\n@@ -12544,20 +12831,6 @@ unmentioned_reg_p (rtx equiv, rtx expr)\n   return for_each_rtx (&equiv, unmentioned_reg_p_1, expr);\n }\n \f\n-/* Compute INSN_CUID for INSN, which is an insn made by combine.  */\n-\n-static int\n-insn_cuid (rtx insn)\n-{\n-  while (insn != 0 && INSN_UID (insn) > max_uid_cuid\n-\t && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE)\n-    insn = NEXT_INSN (insn);\n-\n-  gcc_assert (INSN_UID (insn) <= max_uid_cuid);\n-\n-  return INSN_CUID (insn);\n-}\n-\f\n void\n dump_combine_stats (FILE *file)\n {\n@@ -12576,7 +12849,6 @@ dump_combine_total_stats (FILE *file)\n      total_attempts, total_merges, total_extras, total_successes);\n }\n \f\n-\n static bool\n gate_handle_combine (void)\n {\n@@ -12587,7 +12859,15 @@ gate_handle_combine (void)\n static unsigned int\n rest_of_handle_combine (void)\n {\n-  int rebuild_jump_labels_after_combine\n+  int rebuild_jump_labels_after_combine;\n+\n+  df_set_flags (DF_LR_RUN_DCE + DF_DEFER_INSN_RESCAN);\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n+  regstat_init_n_sets_and_refs ();\n+\n+  rebuild_jump_labels_after_combine\n     = combine_instructions (get_insns (), max_reg_num ());\n \n   /* Combining insns may have turned an indirect jump into a\n@@ -12597,11 +12877,11 @@ rest_of_handle_combine (void)\n     {\n       timevar_push (TV_JUMP);\n       rebuild_jump_labels (get_insns ());\n+      cleanup_cfg (0);\n       timevar_pop (TV_JUMP);\n-\n-      delete_dead_jumptables ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n     }\n+\n+  regstat_free_n_sets_and_refs ();\n   return 0;\n }\n \n@@ -12619,6 +12899,7 @@ struct tree_opt_pass pass_combine =\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n   TODO_dump_func |\n+  TODO_df_finish |\n   TODO_ggc_collect,                     /* todo_flags_finish */\n   'c'                                   /* letter */\n };"}, {"sha": "726c35097585899b2170641249adeb9e127c70a3", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -313,6 +313,10 @@ fasynchronous-unwind-tables\n Common Report Var(flag_asynchronous_unwind_tables) Optimization\n Generate unwind tables that are exact at each instruction boundary\n \n+fauto-inc-dec\n+Common Report Var(flag_auto_inc_dec) Init(1)\n+Generate auto-inc/dec instructions\n+\n ; -fcheck-bounds causes gcc to generate array bounds checks.\n ; For C, C++ and ObjC: defaults off.\n ; For Java: defaults to on.\n@@ -388,6 +392,10 @@ fdata-sections\n Common Report Var(flag_data_sections) Optimization\n Place data items into their own section\n \n+fdbg-cnt=\n+Common RejectNegative Joined\n+-fdbg-cnt=<counter>:<limit>             Set the debug counter limit.   \n+\n ; Nonzero for -fdefer-pop: don't pop args after each function call\n ; instead save them up to pop many calls' args with one insns.\n fdefer-pop\n@@ -656,6 +664,14 @@ fmudflapir\n Common RejectNegative Report Var(flag_mudflap_ignore_reads)\n Ignore read operations when inserting mudflap instrumentation\n \n+fdce\n+Common Var(flag_dce) Init(1)\n+Use the RTL dead code elimination pass\n+\n+fdse\n+Common Var(flag_dse) Init(1)\n+Use the RTL dead store elimination pass\n+\n freschedule-modulo-scheduled-loops\n Common Report Var(flag_resched_modulo_sched) Optimization\n Enable/Disable the traditional scheduling in loops that already passed modulo scheduling"}, {"sha": "14d2247ce109c25aae6adbb958256595000eea44", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -56,7 +56,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-flow.h\"\n #include \"tree-stdarg.h\"\n #include \"tm-constrs.h\"\n-\n+#include \"df.h\"\n \n /* Specify which cpu to schedule for.  */\n enum processor_type alpha_tune;\n@@ -4795,7 +4795,7 @@ alpha_ra_ever_killed (void)\n   rtx top;\n \n   if (!has_hard_reg_initial_val (Pmode, REG_RA))\n-    return regs_ever_live[REG_RA];\n+    return (int)df_regs_ever_live_p (REG_RA);\n \n   push_topmost_sequence ();\n   top = get_insns ();\n@@ -7091,7 +7091,7 @@ alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n   /* One for every register we have to save.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& regs_ever_live[i] && i != REG_RA\n+\t&& df_regs_ever_live_p (i) && i != REG_RA\n \t&& (!TARGET_ABI_UNICOSMK || i != HARD_FRAME_POINTER_REGNUM))\n       {\n \tif (i < 32)\n@@ -7199,7 +7199,7 @@ alpha_sa_size (void)\n       vms_save_fp_regno = -1;\n       if (vms_base_regno == HARD_FRAME_POINTER_REGNUM)\n \tfor (i = 0; i < 32; i++)\n-\t  if (! fixed_regs[i] && call_used_regs[i] && ! regs_ever_live[i])\n+\t  if (! fixed_regs[i] && call_used_regs[i] && ! df_regs_ever_live_p (i))\n \t    vms_save_fp_regno = i;\n \n       if (vms_save_fp_regno == -1 && alpha_procedure_type == PT_REGISTER)"}, {"sha": "4924cea0cceee28b8861a5b3916305dbe42ed716", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,7 +1,6 @@\n /* Subroutines used for code generation on the Argonaut ARC cpu.\n-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n+   2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1057,9 +1056,9 @@ arc_compute_function_type (tree decl)\n    Don't consider them here.  */\n #define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n ((regno) != RETURN_ADDR_REGNUM && (regno) != FRAME_POINTER_REGNUM \\\n- && (regs_ever_live[regno] && (!call_used_regs[regno] || interrupt_p)))\n+ && (df_regs_ever_live_p (regno) && (!call_used_regs[regno] || interrupt_p)))\n \n-#define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM])\n+#define MUST_SAVE_RETURN_ADDR (df_regs_ever_live_p (RETURN_ADDR_REGNUM))\n \n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer."}, {"sha": "e316f6a4ede071c77b8fd038d1b47b7c7a782322", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -52,6 +52,7 @@\n #include \"target-def.h\"\n #include \"debug.h\"\n #include \"langhooks.h\"\n+#include \"df.h\"\n \n /* Forward definitions of types.  */\n typedef struct minipool_node    Mnode;\n@@ -1641,7 +1642,7 @@ use_return_insn (int iscond, rtx sibling)\n \n       if (flag_pic \n \t  && arm_pic_register != INVALID_REGNUM\n-\t  && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+\t  && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n \treturn 0;\n     }\n \n@@ -1654,18 +1655,18 @@ use_return_insn (int iscond, rtx sibling)\n      since this also requires an insn.  */\n   if (TARGET_HARD_FLOAT && TARGET_FPA)\n     for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n+      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \treturn 0;\n \n   /* Likewise VFP regs.  */\n   if (TARGET_HARD_FLOAT && TARGET_VFP)\n     for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n+      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \treturn 0;\n \n   if (TARGET_REALLY_IWMMXT)\n     for (regno = FIRST_IWMMXT_REGNUM; regno <= LAST_IWMMXT_REGNUM; regno++)\n-      if (regs_ever_live[regno] && ! call_used_regs [regno])\n+      if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \treturn 0;\n \n   return 1;\n@@ -3460,7 +3461,7 @@ thumb_find_work_register (unsigned long pushed_regs_mask)\n      register allocation order means that sometimes r3 might be used\n      but earlier argument registers might not, so check them all.  */\n   for (reg = LAST_ARG_REGNUM; reg >= 0; reg --)\n-    if (!regs_ever_live[reg])\n+    if (!df_regs_ever_live_p (reg))\n       return reg;\n \n   /* Before going on to check the call-saved registers we can try a couple\n@@ -9770,8 +9771,8 @@ arm_compute_save_reg0_reg12_mask (void)\n \tmax_reg = 12;\n \n       for (reg = 0; reg <= max_reg; reg++)\n-\tif (regs_ever_live[reg]\n-\t    || (! current_function_is_leaf && call_used_regs [reg]))\n+\tif (df_regs_ever_live_p (reg)\n+\t    || (! current_function_is_leaf && call_used_regs[reg]))\n \t  save_reg_mask |= (1 << reg);\n \n       /* Also save the pic base register if necessary.  */\n@@ -9789,15 +9790,18 @@ arm_compute_save_reg0_reg12_mask (void)\n       /* In the normal case we only need to save those registers\n \t which are call saved and which are used by this function.  */\n       for (reg = 0; reg <= last_reg; reg++)\n-\tif (regs_ever_live[reg] && ! call_used_regs [reg])\n+\tif (df_regs_ever_live_p (reg) && ! call_used_regs[reg])\n \t  save_reg_mask |= (1 << reg);\n \n       /* Handle the frame pointer as a special case.  */\n-      if (TARGET_THUMB2 && frame_pointer_needed)\n+      if (! TARGET_APCS_FRAME\n+\t  && ! frame_pointer_needed\n+\t  && df_regs_ever_live_p (HARD_FRAME_POINTER_REGNUM)\n+\t  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n \tsave_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n       else if (! TARGET_APCS_FRAME\n \t       && ! frame_pointer_needed\n-\t       && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n+\t       && df_regs_ever_live_p (HARD_FRAME_POINTER_REGNUM)\n \t       && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n \tsave_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n \n@@ -9806,7 +9810,7 @@ arm_compute_save_reg0_reg12_mask (void)\n       if (flag_pic\n \t  && !TARGET_SINGLE_PIC_BASE\n \t  && arm_pic_register != INVALID_REGNUM\n-\t  && (regs_ever_live[PIC_OFFSET_TABLE_REGNUM]\n+\t  && (df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM)\n \t      || current_function_uses_pic_offset_table))\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n \n@@ -9872,11 +9876,11 @@ arm_compute_save_reg_mask (void)\n      now and then popping it back into the PC.  This incurs extra memory\n      accesses though, so we only do it when optimizing for size, and only\n      if we know that we will not need a fancy return sequence.  */\n-  if (regs_ever_live [LR_REGNUM]\n-\t  || (save_reg_mask\n-\t      && optimize_size\n-\t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n-\t      && !current_function_calls_eh_return))\n+  if (df_regs_ever_live_p (LR_REGNUM)\n+      || (save_reg_mask\n+\t  && optimize_size\n+\t  && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n+\t  && !current_function_calls_eh_return))\n     save_reg_mask |= 1 << LR_REGNUM;\n \n   if (cfun->machine->lr_save_eliminated)\n@@ -9932,7 +9936,7 @@ thumb1_compute_save_reg_mask (void)\n \n   mask = 0;\n   for (reg = 0; reg < 12; reg ++)\n-    if (regs_ever_live[reg] && !call_used_regs[reg])\n+    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n       mask |= 1 << reg;\n \n   if (flag_pic\n@@ -9986,8 +9990,8 @@ arm_get_vfp_saved_size (void)\n \t   regno < LAST_VFP_REGNUM;\n \t   regno += 2)\n \t{\n-\t  if ((!regs_ever_live[regno] || call_used_regs[regno])\n-\t      && (!regs_ever_live[regno + 1] || call_used_regs[regno + 1]))\n+\t  if ((!df_regs_ever_live_p (regno) || call_used_regs[regno])\n+\t      && (!df_regs_ever_live_p (regno + 1) || call_used_regs[regno + 1]))\n \t    {\n \t      if (count > 0)\n \t\t{\n@@ -10389,7 +10393,7 @@ arm_output_epilogue (rtx sibling)\n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n \t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n-\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t      {\n \t\tfloats_offset += 12;\n \t\tasm_fprintf (f, \"\\tldfe\\t%r, [%r, #-%d]\\n\",\n@@ -10402,7 +10406,7 @@ arm_output_epilogue (rtx sibling)\n \n \t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t    {\n-\t      if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t      if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t\t{\n \t\t  floats_offset += 12;\n \n@@ -10448,8 +10452,8 @@ arm_output_epilogue (rtx sibling)\n \t  start_reg = FIRST_VFP_REGNUM;\n \t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n \t    {\n-\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n-\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t      if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])\n+\t\t  && (!df_regs_ever_live_p (reg + 1) || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n \t\t    vfp_output_fldmd (f, IP_REGNUM,\n@@ -10476,7 +10480,7 @@ arm_output_epilogue (rtx sibling)\n \t  lrm_count += (lrm_count % 2 ? 2 : 1);\n \n \t  for (reg = LAST_IWMMXT_REGNUM; reg >= FIRST_IWMMXT_REGNUM; reg--)\n-\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t      {\n \t\tasm_fprintf (f, \"\\twldrd\\t%r, [%r, #-%d]\\n\",\n \t\t\t     reg, FP_REGNUM, lrm_count * 4);\n@@ -10557,7 +10561,7 @@ arm_output_epilogue (rtx sibling)\n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n \t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n-\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t      asm_fprintf (f, \"\\tldfe\\t%r, [%r], #12\\n\",\n \t\t\t   reg, SP_REGNUM);\n \t}\n@@ -10567,7 +10571,7 @@ arm_output_epilogue (rtx sibling)\n \n \t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n \t    {\n-\t      if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t      if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t\t{\n \t\t  if (reg - start_reg == 3)\n \t\t    {\n@@ -10598,8 +10602,8 @@ arm_output_epilogue (rtx sibling)\n \t  start_reg = FIRST_VFP_REGNUM;\n \t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n \t    {\n-\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n-\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t      if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])\n+\t\t  && (!df_regs_ever_live_p (reg + 1) || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n \t\t    vfp_output_fldmd (f, SP_REGNUM,\n@@ -10615,7 +10619,7 @@ arm_output_epilogue (rtx sibling)\n \t}\n       if (TARGET_IWMMXT)\n \tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n-\t  if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t  if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t    asm_fprintf (f, \"\\twldrd\\t%r, [%r], #8\\n\", reg, SP_REGNUM);\n \n       /* If we can, restore the LR into the PC.  */\n@@ -10957,7 +10961,7 @@ thumb_force_lr_save (void)\n   return !cfun->machine->lr_save_eliminated\n \t && (!leaf_function_p ()\n \t     || thumb_far_jump_used_p ()\n-\t     || regs_ever_live [LR_REGNUM]);\n+\t     || df_regs_ever_live_p (LR_REGNUM));\n }\n \n \n@@ -11065,7 +11069,7 @@ arm_get_frame_offsets (void)\n \t  for (regno = FIRST_IWMMXT_REGNUM;\n \t       regno <= LAST_IWMMXT_REGNUM;\n \t       regno++)\n-\t    if (regs_ever_live [regno] && ! call_used_regs [regno])\n+\t    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \t      saved += 8;\n \t}\n \n@@ -11074,7 +11078,7 @@ arm_get_frame_offsets (void)\n \t{\n \t  /* Space for saved FPA registers.  */\n \t  for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n-\t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \t    saved += 12;\n \n \t  /* Space for saved VFP registers.  */\n@@ -11213,7 +11217,7 @@ arm_save_coproc_regs(void)\n   rtx insn;\n \n   for (reg = LAST_IWMMXT_REGNUM; reg >= FIRST_IWMMXT_REGNUM; reg--)\n-    if (regs_ever_live[reg] && ! call_used_regs [reg])\n+    if (df_regs_ever_live_p (reg) && ! call_used_regs[reg])\n       {\n \tinsn = gen_rtx_PRE_DEC (V2SImode, stack_pointer_rtx);\n \tinsn = gen_rtx_MEM (V2SImode, insn);\n@@ -11227,7 +11231,7 @@ arm_save_coproc_regs(void)\n   if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n     {\n       for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n-\tif (regs_ever_live[reg] && !call_used_regs[reg])\n+\tif (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t  {\n \t    insn = gen_rtx_PRE_DEC (XFmode, stack_pointer_rtx);\n \t    insn = gen_rtx_MEM (XFmode, insn);\n@@ -11242,7 +11246,7 @@ arm_save_coproc_regs(void)\n \n       for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n \t{\n-\t  if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t  if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t    {\n \t      if (start_reg - reg == 3)\n \t\t{\n@@ -11277,8 +11281,8 @@ arm_save_coproc_regs(void)\n \n       for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n \t{\n-\t  if ((!regs_ever_live[reg] || call_used_regs[reg])\n-\t      && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n+\t  if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])\n+\t      && (!df_regs_ever_live_p (reg + 1) || call_used_regs[reg + 1]))\n \t    {\n \t      if (start_reg != reg)\n \t\tsaved_size += vfp_emit_fstmd (start_reg,\n@@ -11423,7 +11427,7 @@ arm_expand_prologue (void)\n \t     doesn't need to be unwound, as it doesn't contain a value\n \t     inherited from the caller.  */\n \n-\t  if (regs_ever_live[3] == 0)\n+\t  if (df_regs_ever_live_p (3) == false)\n \t    insn = emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n \t  else if (args_to_push == 0)\n \t    {\n@@ -11517,7 +11521,7 @@ arm_expand_prologue (void)\n \t  if (IS_NESTED (func_type))\n \t    {\n \t      /* Recover the static chain register.  */\n-\t      if (regs_ever_live [3] == 0\n+\t      if (!df_regs_ever_live_p (3)\n \t\t  || saved_pretend_args)\n \t\tinsn = gen_rtx_REG (SImode, 3);\n \t      else /* if (current_function_pretend_args_size == 0) */\n@@ -11586,10 +11590,7 @@ arm_expand_prologue (void)\n   /* If the link register is being kept alive, with the return address in it,\n      then make sure that it does not get reused by the ce2 pass.  */\n   if ((live_regs_mask & (1 << LR_REGNUM)) == 0)\n-    {\n-      emit_insn (gen_prologue_use (gen_rtx_REG (SImode, LR_REGNUM)));\n-      cfun->machine->lr_save_eliminated = 1;\n-    }\n+    cfun->machine->lr_save_eliminated = 1;\n }\n \f\n /* Print condition code to STREAM.  Helper function for arm_print_operand.  */\n@@ -13922,7 +13923,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n     {\n       /* If we can deduce the registers used from the function's\n \t return value.  This is more reliable that examining\n-\t regs_ever_live[] because that will be set if the register is\n+\t df_regs_ever_live_p () because that will be set if the register is\n \t ever used in the function, not just if the register is used\n \t to hold a return value.  */\n \n@@ -14203,7 +14204,7 @@ thumb_far_jump_used_p (void)\n \n \t If we need doubleword stack alignment this could affect the other\n \t elimination offsets so we can't risk getting it wrong.  */\n-      if (regs_ever_live [ARG_POINTER_REGNUM])\n+      if (df_regs_ever_live_p (ARG_POINTER_REGNUM))\n \tcfun->machine->arg_pointer_live = 1;\n       else if (!cfun->machine->arg_pointer_live)\n \treturn 0;\n@@ -14267,7 +14268,7 @@ thumb_unexpanded_epilogue (void)\n   high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n \n   /* If we can deduce the registers used from the function's return value.\n-     This is more reliable that examining regs_ever_live[] because that\n+     This is more reliable that examining df_regs_ever_live_p () because that\n      will be set if the register is ever used in the function, not just if\n      the register is used to hold a return value.  */\n   size = arm_size_return_regs ();\n@@ -14638,11 +14639,6 @@ thumb1_expand_prologue (void)\n   cfun->machine->lr_save_eliminated = !thumb_force_lr_save ();\n   if (live_regs_mask & 0xff)\n     cfun->machine->lr_save_eliminated = 0;\n-\n-  /* If the link register is being kept alive, with the return address in it,\n-     then make sure that it does not get reused by the ce2 pass.  */\n-  if (cfun->machine->lr_save_eliminated)\n-    emit_insn (gen_prologue_use (gen_rtx_REG (SImode, LR_REGNUM)));\n }\n \n \n@@ -14691,10 +14687,10 @@ thumb1_expand_epilogue (void)\n   /* Emit a clobber for each insn that will be restored in the epilogue,\n      so that flow2 will get register lifetimes correct.  */\n   for (regno = 0; regno < 13; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n       emit_insn (gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, regno)));\n \n-  if (! regs_ever_live[LR_REGNUM])\n+  if (! df_regs_ever_live_p (LR_REGNUM))\n     emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, LR_REGNUM)));\n }\n "}, {"sha": "67fa99f22a540f0fb1390facc991b1c5c9f4954c", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -985,7 +985,7 @@ extern int arm_structure_size_boundary;\n    call-clobbered.  */\n #define HARD_REGNO_RENAME_OK(SRC, DST)\t\t\t\t\t\\\n \t(! IS_INTERRUPT (cfun->machine->func_type) ||\t\t\t\\\n-\t\tregs_ever_live[DST])\n+\t df_regs_ever_live_p (DST))\n \f\n /* Register and constant classes.  */\n \n@@ -1600,7 +1600,7 @@ typedef struct\n    frame.  */\n #define EXIT_IGNORE_STACK 1\n \n-#define EPILOGUE_USES(REGNO) (reload_completed && (REGNO) == LR_REGNUM)\n+#define EPILOGUE_USES(REGNO) ((REGNO) == LR_REGNUM)\n \n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */"}, {"sha": "a393cffb59f24e34448b9973c6d3c2704fb33ac9", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -460,7 +460,7 @@ avr_regs_to_save (HARD_REG_SET *set)\n \tcontinue;\n \n       if ((int_or_sig_p && !leaf_func_p && call_used_regs[reg])\n-\t  || (regs_ever_live[reg]\n+\t  || (df_regs_ever_live_p (reg)\n \t      && (int_or_sig_p || !call_used_regs[reg])\n \t      && !(frame_pointer_needed\n \t\t   && (reg == REG_Y || reg == (REG_Y+1)))))\n@@ -517,7 +517,7 @@ sequent_regs_live (void)\n     {\n       if (!call_used_regs[reg])\n \t{\n-\t  if (regs_ever_live[reg])\n+\t  if (df_regs_ever_live_p (reg))\n \t    {\n \t      ++live_seq;\n \t      ++cur_seq;\n@@ -529,15 +529,15 @@ sequent_regs_live (void)\n \n   if (!frame_pointer_needed)\n     {\n-      if (regs_ever_live[REG_Y])\n+      if (df_regs_ever_live_p (REG_Y))\n \t{\n \t  ++live_seq;\n \t  ++cur_seq;\n \t}\n       else\n \tcur_seq = 0;\n \n-      if (regs_ever_live[REG_Y+1])\n+      if (df_regs_ever_live_p (REG_Y+1))\n \t{\n \t  ++live_seq;\n \t  ++cur_seq;\n@@ -5815,7 +5815,7 @@ avr_peep2_scratch_safe (rtx scratch)\n \n       for (reg = first_reg; reg <= last_reg; reg++)\n \t{\n-\t  if (!regs_ever_live[reg])\n+\t  if (!df_regs_ever_live_p (reg))\n \t    return 0;\n \t}\n     }"}, {"sha": "26fbc6cfdde15cf80d142cf5af8c9974502d5b19", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* The Blackfin code generation auxiliary output file.\n-   Copyright (C) 2005, 2006  Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007  Free Software Foundation, Inc.\n    Contributed by Analog Devices.\n \n    This file is part of GCC.\n@@ -250,7 +250,7 @@ n_dregs_to_save (bool is_inthandler)\n \n   for (i = REG_R0; i <= REG_R7; i++)\n     {\n-      if (regs_ever_live[i] && (is_inthandler || ! call_used_regs[i]))\n+      if (df_regs_ever_live_p (i) && (is_inthandler || ! call_used_regs[i]))\n \treturn REG_R7 - i + 1;\n \n       if (current_function_calls_eh_return)\n@@ -278,7 +278,7 @@ n_pregs_to_save (bool is_inthandler)\n   unsigned i;\n \n   for (i = REG_P0; i <= REG_P5; i++)\n-    if ((regs_ever_live[i] && (is_inthandler || ! call_used_regs[i]))\n+    if ((df_regs_ever_live_p (i) && (is_inthandler || ! call_used_regs[i]))\n \t|| (!TARGET_FDPIC\n \t    && i == PIC_OFFSET_TABLE_REGNUM\n \t    && (current_function_uses_pic_offset_table\n@@ -292,7 +292,7 @@ n_pregs_to_save (bool is_inthandler)\n static bool\n must_save_fp_p (void)\n {\n-  return frame_pointer_needed || regs_ever_live[REG_FP];\n+  return frame_pointer_needed || df_regs_ever_live_p (REG_FP);\n }\n \n static bool\n@@ -513,7 +513,7 @@ n_regs_saved_by_prologue (void)\n \n       for (i = REG_P7 + 1; i < REG_CC; i++)\n \tif (all \n-\t    || regs_ever_live[i]\n+\t    || df_regs_ever_live_p (i)\n \t    || (!leaf_function_p () && call_used_regs[i]))\n \t  n += i == REG_A0 || i == REG_A1 ? 2 : 1;\n     }\n@@ -815,7 +815,7 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n \n   for (i = REG_P7 + 1; i < REG_CC; i++)\n     if (all \n-\t|| regs_ever_live[i]\n+\t|| df_regs_ever_live_p (i)\n \t|| (!leaf_function_p () && call_used_regs[i]))\n       {\n \tif (i == REG_A0 || i == REG_A1)\n@@ -845,23 +845,11 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n       rtx insn;\n \n       insn = emit_move_insn (r0reg, gen_rtx_REG (SImode, REG_SEQSTAT));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    NULL_RTX);\n       insn = emit_insn (gen_ashrsi3 (r0reg, r0reg, GEN_INT (26)));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    NULL_RTX);\n       insn = emit_insn (gen_ashlsi3 (r0reg, r0reg, GEN_INT (26)));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    NULL_RTX);\n       insn = emit_move_insn (r1reg, spreg);\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    NULL_RTX);\n       insn = emit_move_insn (r2reg, gen_rtx_REG (Pmode, REG_FP));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    NULL_RTX);\n       insn = emit_insn (gen_addsi3 (r2reg, r2reg, GEN_INT (8)));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    NULL_RTX);\n     }\n }\n \n@@ -899,7 +887,7 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n \n   for (i = REG_CC - 1; i > REG_P7; i--)\n     if (all\n-\t|| regs_ever_live[i]\n+\t|| df_regs_ever_live_p (i)\n \t|| (!leaf_function_p () && call_used_regs[i]))\n       {\n \tif (i == REG_A0 || i == REG_A1)\n@@ -948,7 +936,6 @@ bfin_load_pic_reg (rtx dest)\n \t\t\t gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n \t\t\t\t\t UNSPEC_LIBRARY_OFFSET));\n   insn = emit_insn (gen_movsi (dest, gen_rtx_MEM (Pmode, addr)));\n-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n   return dest;\n }\n \n@@ -1068,7 +1055,7 @@ bfin_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n      call-clobbered.  */\n \n   if (funkind (TREE_TYPE (current_function_decl)) != SUBROUTINE\n-      && !regs_ever_live[new_reg])\n+      && !df_regs_ever_live_p (new_reg))\n     return 0;\n \n   return 1;"}, {"sha": "2365ebca6463f69eabef274ca6c1ccbebd681e18", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for assembler code output on the TMS320C[34]x\n    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003,\n-   2004, 2005\n+   2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n@@ -750,13 +750,13 @@ c4x_isr_reg_used_p (unsigned int regno)\n \n   /* Only save/restore regs in leaf function that are used.  */\n   if (c4x_leaf_function)\n-    return regs_ever_live[regno] && fixed_regs[regno] == 0;\n+    return df_regs_ever_live_p (regno) && fixed_regs[regno] == 0;\n \n   /* Only save/restore regs that are used by the ISR and regs\n      that are likely to be used by functions the ISR calls\n      if they are not fixed.  */\n   return IS_EXT_REGNO (regno)\n-    || ((regs_ever_live[regno] || call_used_regs[regno]) \n+    || ((df_regs_ever_live_p (regno) || call_used_regs[regno]) \n \t&& fixed_regs[regno] == 0);\n }\n \n@@ -890,9 +890,9 @@ c4x_expand_prologue (void)\n       /* We need to clear the repeat mode flag if the ISR is\n          going to use a RPTB instruction or uses the RC, RS, or RE\n          registers.  */\n-      if (regs_ever_live[RC_REGNO] \n-\t  || regs_ever_live[RS_REGNO] \n-\t  || regs_ever_live[RE_REGNO])\n+      if (df_regs_ever_live_p (RC_REGNO) \n+\t  || df_regs_ever_live_p (RS_REGNO) \n+\t  || df_regs_ever_live_p (RE_REGNO))\n \t{\n           insn = emit_insn (gen_andn_st (GEN_INT(~0x100)));\n           RTX_FRAME_RELATED_P (insn) = 1;\n@@ -983,7 +983,7 @@ c4x_expand_prologue (void)\n       \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n-\t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t  if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \t    {\n \t      if (IS_FLOAT_CALL_SAVED_REGNO (regno))\n \t\t{\n@@ -1111,7 +1111,7 @@ c4x_expand_epilogue(void)\n          where required.  */\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n \t{\n-\t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t  if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \t    {\n \t      if (regno == AR3_REGNO && dont_pop_ar3)\n \t\tcontinue;\n@@ -1220,7 +1220,7 @@ c4x_null_epilogue_p (void)\n       && ! get_frame_size ())\n     {\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno]\n+\tif (df_regs_ever_live_p (regno) && ! call_used_regs[regno]\n \t    && (regno != AR3_REGNO))\n \t  return 1;\n       return 0;"}, {"sha": "0a5c71332ea3ccbc47f3fb464c26865e69bd0570", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  TMS320C[34]x\n    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n               and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n@@ -887,7 +887,7 @@ enum reg_class\n  int regno;\t\t\t\t\t\t\t\\\n  int offset = 0;\t\t\t\t\t\t\\\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\\\n       offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n \t\t&& IS_FLOAT_CALL_SAVED_REGNO (regno) ? 2 : 1;\t\\\n   (DEPTH) = -(offset + get_frame_size ());\t\t\t\\\n@@ -906,7 +906,7 @@ enum reg_class\n  int regno;\t\t\t\t\t\t\t\\\n  int offset = 0;\t\t\t\t\t\t\\\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\\\n       offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n \t\t&& IS_FLOAT_CALL_SAVED_REGNO (regno) ? 2 : 1;\t\\\n   (OFFSET) = -(offset + get_frame_size ());\t\t\t\\"}, {"sha": "66b68ef9645a2fbdcdc5fd813422787008126c75", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for GCC.  Part of the machine description for CRIS.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Axis Communications.  Written by Hans-Peter Nilsson.\n \n@@ -578,13 +578,13 @@ static int\n cris_reg_saved_in_regsave_area (unsigned int regno, bool got_really_used)\n {\n   return\n-    (((regs_ever_live[regno]\n+    (((df_regs_ever_live_p (regno)\n        && !call_used_regs[regno])\n       || (regno == PIC_OFFSET_TABLE_REGNUM\n \t  && (got_really_used\n \t      /* It is saved anyway, if there would be a gap.  */\n \t      || (flag_pic\n-\t\t  && regs_ever_live[regno + 1]\n+\t\t  && df_regs_ever_live_p (regno + 1)\n \t\t  && !call_used_regs[regno + 1]))))\n      && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n      && regno != CRIS_SRP_REGNUM)\n@@ -1122,7 +1122,7 @@ cris_return_addr_rtx (int count, rtx frameaddr ATTRIBUTE_UNUSED)\n bool\n cris_return_address_on_stack (void)\n {\n-  return regs_ever_live[CRIS_SRP_REGNUM]\n+  return df_regs_ever_live_p (CRIS_SRP_REGNUM)\n     || cfun->machine->needs_return_address_on_stack;\n }\n "}, {"sha": "f73348e3c88e97dbd44eeac3ba1dbfe71fa206d6", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Output routines for GCC for CRX.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004  Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006, 2007  Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -272,7 +272,7 @@ crx_compute_save_regs (void)\n \t     * for the sake of its sons.  */\n \t    save_regs[regno] = 1;\n \n-\t  else if (regs_ever_live[regno])\n+\t  else if (df_regs_ever_live_p (regno))\n \t    /* This reg is used - save it.  */\n \t    save_regs[regno] = 1;\n \t  else\n@@ -282,7 +282,7 @@ crx_compute_save_regs (void)\n       else\n \t{\n \t  /* If this reg is used and not call-used (except RA), save it. */\n-\t  if (regs_ever_live[regno]\n+\t  if (df_regs_ever_live_p (regno)\n \t      && (!call_used_regs[regno] || regno == RETURN_ADDRESS_REGNUM))\n \t    save_regs[regno] = 1;\n \t  else"}, {"sha": "b1dacaa18c0308cdc32023239a4c267518ae6178", "filename": "gcc/config/crx/crx.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for CRX.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -165,7 +165,7 @@ do {\t\t\t\t\t\t\t\t\\\n /* Interrupt functions can only use registers that have already been saved by\n  * the prologue, even if they would normally be call-clobbered. */\n #define HARD_REGNO_RENAME_OK(SRC, DEST)\t\\\n-\t(!crx_interrupt_function_p () || regs_ever_live[DEST])\n+  (!crx_interrupt_function_p () || df_regs_ever_live_p (DEST))\n \n #define MODES_TIEABLE_P(MODE1, MODE2)  1\n "}, {"sha": "fb5d6f905fbf1e6fabe5e54a02fddd950f9b07db", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Functions for generic Darwin as target machine for GNU C compiler.\n    Copyright (C) 1989, 1990, 1991, 1992, 1993, 2000, 2001, 2002, 2003, 2004,\n-   2005\n+   2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Apple Computer Inc.\n \n@@ -45,6 +45,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tm_p.h\"\n #include \"toplev.h\"\n #include \"hashtab.h\"\n+#include \"df.h\"\n \n /* Darwin supports a feature called fix-and-continue, which is used\n    for rapid turn around debugging.  When code is compiled with the\n@@ -777,7 +778,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n #endif\n \n \t      if (reload_in_progress)\n-\t\tregs_ever_live[REGNO (pic)] = 1;\n+\t\tdf_set_regs_ever_live (REGNO (pic), true);\n \t      pic_ref = gen_rtx_PLUS (Pmode, pic,\n \t\t\t\t      gen_pic_offset (XEXP (orig, 0),\n \t\t\t\t\t\t      pic_base));\n@@ -848,7 +849,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t\t\t\t  pic_offset_table_rtx));\n #endif\n \t\t  if (reload_in_progress)\n-\t\t    regs_ever_live[REGNO (pic)] = 1;\n+\t\t    df_set_regs_ever_live (REGNO (pic), true);\n \t\t  pic_ref = gen_rtx_PLUS (Pmode,\n \t\t\t\t\t  pic,\n \t\t\t\t\t  gen_pic_offset (orig, pic_base));"}, {"sha": "1d8a004a6e516b60d6645ed2045716ce84d57ede", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -137,11 +137,11 @@ static int fr30_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n #define MUST_SAVE_REGISTER(regno)      \\\n   (   (regno) != RETURN_POINTER_REGNUM \\\n    && (regno) != FRAME_POINTER_REGNUM  \\\n-   &&   regs_ever_live [regno]         \\\n+   && df_regs_ever_live_p (regno)      \\\n    && ! call_used_regs [regno]         )\n \n-#define MUST_SAVE_FRAME_POINTER\t (regs_ever_live [FRAME_POINTER_REGNUM]  || frame_pointer_needed)\n-#define MUST_SAVE_RETURN_POINTER (regs_ever_live [RETURN_POINTER_REGNUM] || current_function_profile)\n+#define MUST_SAVE_FRAME_POINTER\t (df_regs_ever_live_p (FRAME_POINTER_REGNUM)  || frame_pointer_needed)\n+#define MUST_SAVE_RETURN_POINTER (df_regs_ever_live_p (RETURN_POINTER_REGNUM) || current_function_profile)\n \n #if UNITS_PER_WORD == 4\n #define WORD_ALIGN(SIZE) (((SIZE) + 3) & ~3)"}, {"sha": "5c2489aa52008f508871d3cf9b43042b2314b535", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005\n+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n@@ -51,6 +51,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"targhooks.h\"\n #include \"integrate.h\"\n #include \"langhooks.h\"\n+#include \"df.h\"\n \n #ifndef FRV_INLINE\n #define FRV_INLINE inline\n@@ -1167,7 +1168,7 @@ frv_stack_info (void)\n \tdefault:\n \t  for (regno = first; regno <= last; regno++)\n \t    {\n-\t      if ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t      if ((df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t\t  || (current_function_calls_eh_return\n \t\t      && (regno >= FIRST_EH_REGNUM && regno <= LAST_EH_REGNUM))\n \t\t  || (!TARGET_FDPIC && flag_pic\n@@ -1185,7 +1186,7 @@ frv_stack_info (void)\n \t  break;\n \n \tcase STACK_REGS_LR:\n-\t  if (regs_ever_live[LR_REGNO]\n+\t  if (df_regs_ever_live_p (LR_REGNO)\n               || profile_flag\n \t      /* This is set for __builtin_return_address, etc.  */\n \t      || cfun->machine->frame_needed\n@@ -1498,7 +1499,7 @@ frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       rtx insn;\n \n       /* Just to check that the above comment is true.  */\n-      gcc_assert (!regs_ever_live[GPR_FIRST + 3]);\n+      gcc_assert (!df_regs_ever_live_p (GPR_FIRST + 3));\n \n       /* Generate the instruction that saves the link register.  */\n       fprintf (file, \"\\tmovsg lr,gr3\\n\");\n@@ -1518,7 +1519,7 @@ frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t      {\n \t\trtx address = XEXP (XVECEXP (pattern, 0, 1), 0);\n \t\tif (GET_CODE (address) == REG && REGNO (address) == LR_REGNO)\n-\t\t  REGNO (address) = GPR_FIRST + 3;\n+\t\t  SET_REGNO (address, GPR_FIRST + 3);\n \t      }\n \t  }\n     }\n@@ -5293,15 +5294,15 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n       for (j = CC_FIRST; j <= CC_LAST; j++)\n \tif (TEST_HARD_REG_BIT (tmp_reg->regs, j))\n \t  {\n-\t    if (REGNO_REG_SET_P (then_bb->il.rtl->global_live_at_start, j))\n+\t    if (REGNO_REG_SET_P (DF_LIVE_IN (rtl_df, then_bb), j))\n \t      continue;\n \n \t    if (else_bb\n-\t\t&& REGNO_REG_SET_P (else_bb->il.rtl->global_live_at_start, j))\n+\t\t&& REGNO_REG_SET_P (DF_LIVE_IN (rtl_df, else_bb), j))\n \t      continue;\n \n \t    if (join_bb\n-\t\t&& REGNO_REG_SET_P (join_bb->il.rtl->global_live_at_start, j))\n+\t\t&& REGNO_REG_SET_P (DF_LIVE_IN (rtl_df, join_bb), j))\n \t      continue;\n \n \t    SET_HARD_REG_BIT (frv_ifcvt.nested_cc_ok_rewrite, j);\n@@ -5323,7 +5324,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n       /* Remove anything live at the beginning of the join block from being\n          available for allocation.  */\n-      EXECUTE_IF_SET_IN_REG_SET (join_bb->il.rtl->global_live_at_start, 0, regno, rsi)\n+      EXECUTE_IF_SET_IN_REG_SET (DF_LIVE_IN (rtl_df, join_bb), 0, regno, rsi)\n \t{\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n@@ -5367,7 +5368,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n       /* Anything live at the beginning of the block is obviously unavailable\n          for allocation.  */\n-      EXECUTE_IF_SET_IN_REG_SET (bb[j]->il.rtl->global_live_at_start, 0, regno, rsi)\n+      EXECUTE_IF_SET_IN_REG_SET (DF_LIVE_IN (rtl_df, bb[j]), 0, regno, rsi)\n \t{\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n@@ -6021,15 +6022,15 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n \t\t  severely.  */\n \t       && ce_info->join_bb\n \t       && ! (REGNO_REG_SET_P\n-\t\t     (ce_info->join_bb->il.rtl->global_live_at_start,\n+\t\t     (DF_LIVE_IN (rtl_df, ce_info->join_bb),\n \t\t      REGNO (SET_DEST (set))))\n \t       /* Similarly, we must not unconditionally set a reg\n \t\t  used as scratch in the THEN branch if the same reg\n \t\t  is live in the ELSE branch.  */\n \t       && (! ce_info->else_bb\n \t\t   || BLOCK_FOR_INSN (insn) == ce_info->else_bb\n \t\t   || ! (REGNO_REG_SET_P\n-\t\t\t (ce_info->else_bb->il.rtl->global_live_at_start,\n+\t\t\t (DF_LIVE_IN (rtl_df, ce_info->else_bb),\n \t\t\t  REGNO (SET_DEST (set))))))\n \tpattern = set;\n \n@@ -7641,7 +7642,7 @@ frv_reorder_packet (void)\n   for (from = 0; from < to - 1; from++)\n     {\n       remove_insn (insns[from]);\n-      add_insn_before (insns[from], insns[to - 1]);\n+      add_insn_before (insns[from], insns[to - 1], NULL);\n       SET_PACKING_FLAG (insns[from]);\n     }\n }\n@@ -8632,7 +8633,7 @@ frv_int_to_acc (enum insn_code icode, int opnum, rtx opval)\n   reg = gen_rtx_REG (insn_data[icode].operand[opnum].mode,\n \t\t     ACC_FIRST + INTVAL (opval));\n   if (! (*insn_data[icode].operand[opnum].predicate) (reg, VOIDmode))\n-    REGNO (reg) = ACCG_FIRST + INTVAL (opval);\n+    SET_REGNO (reg, ACCG_FIRST + INTVAL (opval));\n \n   if (! (*insn_data[icode].operand[opnum].predicate) (reg, VOIDmode))\n     {"}, {"sha": "ab6d89dfb65c731c9e0abbf6c5b862a8fc6a2679", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Renesas H8/300.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com),\n    Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n \n@@ -494,12 +494,12 @@ byte_reg (rtx x, int b)\n    && ! TREE_THIS_VOLATILE (current_function_decl)\t\t\t\\\n    && (h8300_saveall_function_p (current_function_decl)\t\t\t\\\n        /* Save any call saved register that was used.  */\t\t\\\n-       || (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+       || (df_regs_ever_live_p (regno) && !call_used_regs[regno])\t\\\n        /* Save the frame pointer if it was used.  */\t\t\t\\\n-       || (regno == HARD_FRAME_POINTER_REGNUM && regs_ever_live[regno])\t\\\n+       || (regno == HARD_FRAME_POINTER_REGNUM && df_regs_ever_live_p (regno)) \\\n        /* Save any register used in an interrupt handler.  */\t\t\\\n        || (h8300_current_function_interrupt_function_p ()\t\t\\\n-\t   && regs_ever_live[regno])\t\t\t\t\t\\\n+\t   && df_regs_ever_live_p (regno))\t\t\t\t\\\n        /* Save call clobbered registers in non-leaf interrupt\t\t\\\n \t  handlers.  */\t\t\t\t\t\t\t\\\n        || (h8300_current_function_interrupt_function_p ()\t\t\\\n@@ -5607,7 +5607,7 @@ h8300_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n      call-clobbered.  */\n \n   if (h8300_current_function_interrupt_function_p ()\n-      && !regs_ever_live[new_reg])\n+      && !df_regs_ever_live_p (new_reg))\n     return 0;\n \n   return 1;"}, {"sha": "91d698f69407497d9fc0a15474ea481923e1c573", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n ;; GCC machine description for Renesas H8/300\n ;; Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-;; 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+;; 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n ;;   Contributed by Steve Chamberlain (sac@cygnus.com),\n ;;   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n@@ -1210,7 +1210,7 @@\n   [(set (match_operand:HI 0 \"stack_pointer_operand\" \"\")\n \t(plus:HI (match_dup 0)\n \t\t (match_operand 1 \"const_int_gt_2_operand\" \"\")))]\n-  \"TARGET_H8300 && flow2_completed\"\n+  \"TARGET_H8300 && epilogue_completed\"\n   [(const_int 0)]\n   \"split_adds_subs (HImode, operands); DONE;\")\n \n@@ -3017,7 +3017,7 @@\n \t\t\t[(match_dup 0)\n \t\t\t (match_operand:QI 1 \"register_operand\" \"\")]))\n    (clobber (match_operand:QI 3 \"register_operand\" \"\"))]\n-  \"flow2_completed\n+  \"epilogue_completed\n    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\"\n   [(set (cc0)\n \t(match_dup 1))\n@@ -3048,7 +3048,7 @@\n \t\t\t[(match_dup 0)\n \t\t\t (match_operand:QI 1 \"register_operand\" \"\")]))\n    (clobber (match_operand:QI 3 \"register_operand\" \"\"))]\n-  \"flow2_completed\n+  \"epilogue_completed\n    && !find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\"\n   [(set (match_dup 3)\n \t(match_dup 1))\n@@ -4183,7 +4183,7 @@\n \t\t(match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n-   && flow2_completed\n+   && epilogue_completed\n    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n    && REGNO (operands[0]) != REGNO (operands[1])\"\n   [(parallel [(set (match_dup 3)\n@@ -4203,7 +4203,7 @@\n \t\t(match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n-   && flow2_completed\n+   && epilogue_completed\n    && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n         && REGNO (operands[0]) != REGNO (operands[1]))\"\n   [(set (match_dup 2)\n@@ -4286,7 +4286,7 @@\n \t\t (match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n-   && flow2_completed\n+   && epilogue_completed\n    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n    && REGNO (operands[0]) != REGNO (operands[1])\"\n   [(parallel [(set (match_dup 3)\n@@ -4306,7 +4306,7 @@\n \t\t (match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n-   && flow2_completed\n+   && epilogue_completed\n    && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n         && REGNO (operands[0]) != REGNO (operands[1]))\"\n   [(set (match_dup 2)"}, {"sha": "61a24eedadee57fa467a32cd29e1f09932930793", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cgraph.h\"\n #include \"tree-gimple.h\"\n #include \"dwarf2.h\"\n+#include \"df.h\"\n #include \"tm-constrs.h\"\n #include \"params.h\"\n \n@@ -3014,7 +3015,7 @@ ix86_eax_live_at_start_p (void)\n      to correct at this point.  This gives false positives for broken\n      functions that might use uninitialized data that happens to be\n      allocated in eax, but who cares?  */\n-  return REGNO_REG_SET_P (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end, 0);\n+  return REGNO_REG_SET_P (DF_LIVE_OUT (ENTRY_BLOCK_PTR), 0);\n }\n \n /* Return true if TYPE has a variable argument list.  */\n@@ -5580,7 +5581,7 @@ ix86_select_alt_pic_regnum (void)\n     {\n       int i;\n       for (i = 2; i >= 0; --i)\n-        if (!regs_ever_live[i])\n+        if (!df_regs_ever_live_p (i))\n \t  return i;\n     }\n \n@@ -5593,7 +5594,7 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n {\n   if (pic_offset_table_rtx\n       && regno == REAL_PIC_OFFSET_TABLE_REGNUM\n-      && (regs_ever_live[REAL_PIC_OFFSET_TABLE_REGNUM]\n+      && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n \t  || current_function_profile\n \t  || current_function_calls_eh_return\n \t  || current_function_uses_const_pool))\n@@ -5620,7 +5621,7 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n       && regno == REGNO (cfun->machine->force_align_arg_pointer))\n     return 1;\n \n-  return (regs_ever_live[regno]\n+  return (df_regs_ever_live_p (regno)\n \t  && !call_used_regs[regno]\n \t  && !fixed_regs[regno]\n \t  && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed));\n@@ -6106,13 +6107,13 @@ ix86_expand_prologue (void)\n \n   pic_reg_used = false;\n   if (pic_offset_table_rtx\n-      && (regs_ever_live[REAL_PIC_OFFSET_TABLE_REGNUM]\n+      && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n \t  || current_function_profile))\n     {\n       unsigned int alt_pic_reg_used = ix86_select_alt_pic_regnum ();\n \n       if (alt_pic_reg_used != INVALID_REGNUM)\n-\tREGNO (pic_offset_table_rtx) = alt_pic_reg_used;\n+\tSET_REGNO (pic_offset_table_rtx, alt_pic_reg_used);\n \n       pic_reg_used = true;\n     }\n@@ -6130,9 +6131,7 @@ ix86_expand_prologue (void)\n \t      LABEL_PRESERVE_P (label) = 1;\n \t      gcc_assert (REGNO (pic_offset_table_rtx) != REGNO (tmp_reg));\n \t      insn = emit_insn (gen_set_rip_rex64 (pic_offset_table_rtx, label));\n-              REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n \t      insn = emit_insn (gen_set_got_offset_rex64 (tmp_reg, label));\n-              REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n \t      insn = emit_insn (gen_adddi3 (pic_offset_table_rtx,\n \t\t\t\t\t    pic_offset_table_rtx, tmp_reg));\n \t    }\n@@ -6141,20 +6140,16 @@ ix86_expand_prologue (void)\n \t}\n       else\n         insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n-\n-      /* Even with accurate pre-reload life analysis, we can wind up\n-\t deleting all references to the pic register after reload.\n-\t Consider if cross-jumping unifies two sides of a branch\n-\t controlled by a comparison vs the only read from a global.\n-\t In which case, allow the set_got to be deleted, though we're\n-\t too late to do anything about the ebx save in the prologue.  */\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n     }\n \n   /* Prevent function calls from be scheduled before the call to mcount.\n      In the pic_reg_used case, make sure that the got load isn't deleted.  */\n   if (current_function_profile)\n-    emit_insn (gen_blockage (pic_reg_used ? pic_offset_table_rtx : const0_rtx));\n+    {\n+      if (pic_reg_used)\n+\temit_insn (gen_prologue_use (pic_offset_table_rtx));\n+      emit_insn (gen_blockage ());\n+    }\n }\n \n /* Emit code to restore saved registers using MOV insns.  First register\n@@ -6366,7 +6361,7 @@ ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   if (pic_offset_table_rtx)\n-    REGNO (pic_offset_table_rtx) = REAL_PIC_OFFSET_TABLE_REGNUM;\n+    SET_REGNO (pic_offset_table_rtx, REAL_PIC_OFFSET_TABLE_REGNUM);\n #if TARGET_MACHO\n   /* Mach-O doesn't support labels at the end of objects, so if\n      it looks like we might want one, insert a NOP.  */\n@@ -7193,7 +7188,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t base address (@GOTOFF).  */\n \n       if (reload_in_progress)\n-\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n       if (GET_CODE (addr) == CONST)\n \taddr = XEXP (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n@@ -7225,7 +7220,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t base address (@GOTOFF).  */\n \n       if (reload_in_progress)\n-\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n       if (GET_CODE (addr) == CONST)\n \taddr = XEXP (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n@@ -7276,7 +7271,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t     Global Offset Table (@GOT).  */\n \n \t  if (reload_in_progress)\n-\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n \t  new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \t  if (TARGET_64BIT)\n@@ -7329,7 +7324,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t      if (!TARGET_64BIT)\n \t\t{\n \t\t  if (reload_in_progress)\n-\t\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \t\t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0),\n \t\t\t\t\t    UNSPEC_GOTOFF);\n \t\t  new_rtx = gen_rtx_PLUS (Pmode, new_rtx, op1);\n@@ -7489,7 +7484,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n       else if (flag_pic)\n \t{\n \t  if (reload_in_progress)\n-\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \t  pic = pic_offset_table_rtx;\n \t  type = TARGET_ANY_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n \t}"}, {"sha": "5089883dca5bb096c4213a39764a05e7e5cbac5b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -2431,7 +2431,7 @@ struct machine_function GTY(())\n    verify whether there's any such instruction live by testing that\n    REG_SP is live.  */\n #define ix86_current_function_calls_tls_descriptor \\\n-  (ix86_tls_descriptor_calls_expanded_in_cfun && regs_ever_live[SP_REG])\n+  (ix86_tls_descriptor_calls_expanded_in_cfun && df_regs_ever_live_p (SP_REG))\n \n /* Control behavior of x86_file_start.  */\n #define X86_FILE_START_VERSION_DIRECTIVE false"}, {"sha": "0ecb9961d85b32ecc22718c793880c7ac3392d19", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -194,6 +194,7 @@\n    (UNSPECV_CMPXCHG_2\t\t11)\n    (UNSPECV_XCHG\t\t12)\n    (UNSPECV_LOCK\t\t13)\n+   (UNSPECV_PROLOGUE_USE\t14)\n   ])\n \n ;; Registers by name.\n@@ -1917,7 +1918,7 @@\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n         (match_operand:DI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t    ? flow2_completed : reload_completed)\n+\t\t    ? epilogue_completed : reload_completed)\n    && !symbolic_operand (operands[1], DImode)\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 0) (match_dup 1))\n@@ -2153,7 +2154,7 @@\n   [(set (match_operand:DI 0 \"memory_operand\" \"\")\n         (match_operand:DI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t    ? flow2_completed : reload_completed)\n+\t\t    ? epilogue_completed : reload_completed)\n    && !symbolic_operand (operands[1], DImode)\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 2) (match_dup 3))\n@@ -10573,7 +10574,7 @@\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t     ? flow2_completed : reload_completed)\"\n+\t\t     ? epilogue_completed : reload_completed)\"\n   [(const_int 0)]\n   \"ix86_split_ashl (operands, NULL_RTX, DImode); DONE;\")\n \n@@ -11504,7 +11505,7 @@\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t     ? flow2_completed : reload_completed)\"\n+\t\t     ? epilogue_completed : reload_completed)\"\n   [(const_int 0)]\n   \"ix86_split_ashr (operands, NULL_RTX, DImode); DONE;\")\n \n@@ -12182,7 +12183,7 @@\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t     ? flow2_completed : reload_completed)\"\n+\t\t     ? epilogue_completed : reload_completed)\"\n   [(const_int 0)]\n   \"ix86_split_lshr (operands, NULL_RTX, DImode); DONE;\")\n \n@@ -14347,7 +14348,7 @@\n      registers we stored in the result block.  We avoid problems by\n      claiming that all hard registers are used and clobbered at this\n      point.  */\n-  emit_insn (gen_blockage (const0_rtx));\n+  emit_insn (gen_blockage ());\n \n   DONE;\n })\n@@ -14358,7 +14359,15 @@\n ;; all of memory.  This blocks insns from being moved across this point.\n \n (define_insn \"blockage\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPECV_BLOCKAGE)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n+;; As USE insns aren't meaningful after reload, this is used instead\n+;; to prevent deleting instructions setting registers for PIC code\n+(define_insn \"prologue_use\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPECV_PROLOGUE_USE)]\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])"}, {"sha": "2be48783471525c43e4397c3e6d71cf3cb0f2004", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -109,3 +109,4 @@ extern void ia64_output_function_profiler (FILE *, int);\n extern void ia64_profile_hook (int);\n \n extern void ia64_optimization_options (int, int);\n+extern void ia64_init_expanders (void);"}, {"sha": "24af522fac3570e22c0e6c458f6bac2f8918b700", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 261, "deletions": 175, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -53,8 +53,10 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n #include \"intl.h\"\n+#include \"df.h\"\n #include \"debug.h\"\n #include \"params.h\"\n+#include \"dbgcnt.h\"\n #include \"tm-constrs.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n@@ -122,6 +124,18 @@ unsigned int ia64_section_threshold;\n    TRUE if we do insn bundling instead of insn scheduling.  */\n int bundling_p = 0;\n \n+enum ia64_frame_regs\n+{\n+   reg_fp,\n+   reg_save_b0,\n+   reg_save_pr,\n+   reg_save_ar_pfs,\n+   reg_save_ar_unat,\n+   reg_save_ar_lc,\n+   reg_save_gp,\n+   number_of_ia64_frame_regs\n+};\n+\n /* Structure to be filled in by ia64_compute_frame_size with register\n    save masks and offsets for the current function.  */\n \n@@ -136,13 +150,7 @@ struct ia64_frame_info\n   unsigned int gr_used_mask;\t/* mask of registers in use as gr spill\n \t\t\t\t   registers or long-term scratches.  */\n   int n_spilled;\t\t/* number of spilled registers.  */\n-  int reg_fp;\t\t\t/* register for fp.  */\n-  int reg_save_b0;\t\t/* save register for b0.  */\n-  int reg_save_pr;\t\t/* save register for prs.  */\n-  int reg_save_ar_pfs;\t\t/* save register for ar.pfs.  */\n-  int reg_save_ar_unat;\t\t/* save register for ar.unat.  */\n-  int reg_save_ar_lc;\t\t/* save register for ar.lc.  */\n-  int reg_save_gp;\t\t/* save register for gp.  */\n+  int r[number_of_ia64_frame_regs];  /* Frame related registers.  */\n   int n_input_regs;\t\t/* number of input registers used.  */\n   int n_local_regs;\t\t/* number of local registers used.  */\n   int n_output_regs;\t\t/* number of output registers used.  */\n@@ -154,6 +162,8 @@ struct ia64_frame_info\n \n /* Current frame information calculated by ia64_compute_frame_size.  */\n static struct ia64_frame_info current_frame_info;\n+/* The actual registers that are emitted.  */\n+static int emitted_frame_related_regs[number_of_ia64_frame_regs];\n \f\n static int ia64_first_cycle_multipass_dfa_lookahead (void);\n static void ia64_dependencies_evaluation_hook (rtx, rtx);\n@@ -173,7 +183,7 @@ static int ia64_spec_check_p (rtx);\n static int ia64_spec_check_src_p (rtx);\n static rtx gen_tls_get_addr (void);\n static rtx gen_thread_pointer (void);\n-static int find_gr_spill (int);\n+static int find_gr_spill (enum ia64_frame_regs, int);\n static int next_scratch_gr_reg (void);\n static void mark_reg_gr_used_mask (rtx, void *);\n static void ia64_compute_frame_size (HOST_WIDE_INT);\n@@ -1872,13 +1882,42 @@ ia64_expand_call (rtx retval, rtx addr, rtx nextarg ATTRIBUTE_UNUSED,\n     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), b0);\n }\n \n+static void\n+reg_emitted (enum ia64_frame_regs r)\n+{\n+  if (emitted_frame_related_regs[r] == 0)\n+    emitted_frame_related_regs[r] = current_frame_info.r[r];\n+  else\n+    gcc_assert (emitted_frame_related_regs[r] == current_frame_info.r[r]);\n+}\n+\n+static int\n+get_reg (enum ia64_frame_regs r)\n+{\n+  reg_emitted (r);\n+  return current_frame_info.r[r];\n+}\n+\n+static bool\n+is_emitted (int regno)\n+{\n+  enum ia64_frame_regs r;\n+\n+  for (r = reg_fp; r < number_of_ia64_frame_regs; r++)\n+    if (emitted_frame_related_regs[r] == regno)\n+      return true;\n+  return false;\n+}\n+\n void\n ia64_reload_gp (void)\n {\n   rtx tmp;\n \n-  if (current_frame_info.reg_save_gp)\n-    tmp = gen_rtx_REG (DImode, current_frame_info.reg_save_gp);\n+  if (current_frame_info.r[reg_save_gp])\n+    {\n+      tmp = gen_rtx_REG (DImode, get_reg (reg_save_gp));\n+    }\n   else\n     {\n       HOST_WIDE_INT offset;\n@@ -2158,20 +2197,33 @@ ia64_globalize_decl_name (FILE * stream, tree decl)\n    TRY_LOCALS is true if we should attempt to locate a local regnum.  */\n \n static int\n-find_gr_spill (int try_locals)\n+find_gr_spill (enum ia64_frame_regs r, int try_locals)\n {\n   int regno;\n \n+  if (emitted_frame_related_regs[r] != 0)\n+    {\n+      regno = emitted_frame_related_regs[r];\n+      if (regno >= LOC_REG (0) && regno < LOC_REG (80 - frame_pointer_needed))\n+        current_frame_info.n_local_regs = regno - LOC_REG (0) + 1;\n+      else if (current_function_is_leaf \n+               && regno >= GR_REG (1) && regno <= GR_REG (31))\n+        current_frame_info.gr_used_mask |= 1 << regno;\n+\n+      return regno;\n+    }\n+\n   /* If this is a leaf function, first try an otherwise unused\n      call-clobbered register.  */\n   if (current_function_is_leaf)\n     {\n       for (regno = GR_REG (1); regno <= GR_REG (31); regno++)\n-\tif (! regs_ever_live[regno]\n+\tif (! df_regs_ever_live_p (regno)\n \t    && call_used_regs[regno]\n \t    && ! fixed_regs[regno]\n \t    && ! global_regs[regno]\n-\t    && ((current_frame_info.gr_used_mask >> regno) & 1) == 0)\n+\t    && ((current_frame_info.gr_used_mask >> regno) & 1) == 0\n+            && ! is_emitted (regno))\n \t  {\n \t    current_frame_info.gr_used_mask |= 1 << regno;\n \t    return regno;\n@@ -2243,6 +2295,7 @@ mark_reg_gr_used_mask (rtx reg, void *data ATTRIBUTE_UNUSED)\n     }\n }\n \n+\n /* Returns the number of bytes offset between the frame pointer and the stack\n    pointer for the current function.  SIZE is the number of bytes of space\n    needed for local variables.  */\n@@ -2284,7 +2337,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n      since we'll be adjusting that down later.  */\n   regno = LOC_REG (78) + ! frame_pointer_needed;\n   for (; regno >= LOC_REG (0); regno--)\n-    if (regs_ever_live[regno])\n+    if (df_regs_ever_live_p (regno) && !is_emitted (regno))\n       break;\n   current_frame_info.n_local_regs = regno - LOC_REG (0) + 1;\n \n@@ -2299,13 +2352,13 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n   else\n     {\n       for (regno = IN_REG (7); regno >= IN_REG (0); regno--)\n-\tif (regs_ever_live[regno])\n+\tif (df_regs_ever_live_p (regno))\n \t  break;\n       current_frame_info.n_input_regs = regno - IN_REG (0) + 1;\n     }\n \n   for (regno = OUT_REG (7); regno >= OUT_REG (0); regno--)\n-    if (regs_ever_live[regno])\n+    if (df_regs_ever_live_p (regno))\n       break;\n   i = regno - OUT_REG (0) + 1;\n \n@@ -2327,7 +2380,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n      which will always wind up on the stack.  */\n \n   for (regno = FR_REG (2); regno <= FR_REG (127); regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n       {\n \tSET_HARD_REG_BIT (mask, regno);\n \tspill_size += 16;\n@@ -2336,7 +2389,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n       }\n \n   for (regno = GR_REG (1); regno <= GR_REG (31); regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n       {\n \tSET_HARD_REG_BIT (mask, regno);\n \tspill_size += 8;\n@@ -2345,7 +2398,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n       }\n \n   for (regno = BR_REG (1); regno <= BR_REG (7); regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n       {\n \tSET_HARD_REG_BIT (mask, regno);\n \tspill_size += 8;\n@@ -2357,15 +2410,15 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n \n   if (frame_pointer_needed)\n     {\n-      current_frame_info.reg_fp = find_gr_spill (1);\n+      current_frame_info.r[reg_fp] = find_gr_spill (reg_fp, 1);\n       /* If we did not get a register, then we take LOC79.  This is guaranteed\n \t to be free, even if regs_ever_live is already set, because this is\n \t HARD_FRAME_POINTER_REGNUM.  This requires incrementing n_local_regs,\n \t as we don't count loc79 above.  */\n-      if (current_frame_info.reg_fp == 0)\n+      if (current_frame_info.r[reg_fp] == 0)\n \t{\n-\t  current_frame_info.reg_fp = LOC_REG (79);\n-\t  current_frame_info.n_local_regs++;\n+\t  current_frame_info.r[reg_fp] = LOC_REG (79);\n+\t  current_frame_info.n_local_regs = LOC_REG (79) - LOC_REG (0) + 1;\n \t}\n     }\n \n@@ -2376,27 +2429,27 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n \t able to unwind the stack.  */\n       SET_HARD_REG_BIT (mask, BR_REG (0));\n \n-      current_frame_info.reg_save_b0 = find_gr_spill (1);\n-      if (current_frame_info.reg_save_b0 == 0)\n+      current_frame_info.r[reg_save_b0] = find_gr_spill (reg_save_b0, 1);\n+      if (current_frame_info.r[reg_save_b0] == 0)\n \t{\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n \t}\n \n       /* Similarly for ar.pfs.  */\n       SET_HARD_REG_BIT (mask, AR_PFS_REGNUM);\n-      current_frame_info.reg_save_ar_pfs = find_gr_spill (1);\n-      if (current_frame_info.reg_save_ar_pfs == 0)\n+      current_frame_info.r[reg_save_ar_pfs] = find_gr_spill (reg_save_ar_pfs, 1);\n+      if (current_frame_info.r[reg_save_ar_pfs] == 0)\n \t{\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n \t}\n \n       /* Similarly for gp.  Note that if we're calling setjmp, the stacked\n \t registers are clobbered, so we fall back to the stack.  */\n-      current_frame_info.reg_save_gp\n-\t= (current_function_calls_setjmp ? 0 : find_gr_spill (1));\n-      if (current_frame_info.reg_save_gp == 0)\n+      current_frame_info.r[reg_save_gp]\n+\t= (current_function_calls_setjmp ? 0 : find_gr_spill (reg_save_gp, 1));\n+      if (current_frame_info.r[reg_save_gp] == 0)\n \t{\n \t  SET_HARD_REG_BIT (mask, GR_REG (1));\n \t  spill_size += 8;\n@@ -2405,18 +2458,19 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n     }\n   else\n     {\n-      if (regs_ever_live[BR_REG (0)] && ! call_used_regs[BR_REG (0)])\n+      if (df_regs_ever_live_p (BR_REG (0)) && ! call_used_regs[BR_REG (0)])\n \t{\n \t  SET_HARD_REG_BIT (mask, BR_REG (0));\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n \t}\n \n-      if (regs_ever_live[AR_PFS_REGNUM])\n+      if (df_regs_ever_live_p (AR_PFS_REGNUM))\n \t{\n \t  SET_HARD_REG_BIT (mask, AR_PFS_REGNUM);\n-\t  current_frame_info.reg_save_ar_pfs = find_gr_spill (1);\n-\t  if (current_frame_info.reg_save_ar_pfs == 0)\n+ \t  current_frame_info.r[reg_save_ar_pfs] \n+            = find_gr_spill (reg_save_ar_pfs, 1);\n+\t  if (current_frame_info.r[reg_save_ar_pfs] == 0)\n \t    {\n \t      extra_spill_size += 8;\n \t      n_spilled += 1;\n@@ -2429,25 +2483,31 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n      it is absolutely critical that FP get the only hard register that's\n      guaranteed to be free, so we allocated it first.  If all three did\n      happen to be allocated hard regs, and are consecutive, rearrange them\n-     into the preferred order now.  */\n-  if (current_frame_info.reg_fp != 0\n-      && current_frame_info.reg_save_b0 == current_frame_info.reg_fp + 1\n-      && current_frame_info.reg_save_ar_pfs == current_frame_info.reg_fp + 2)\n+     into the preferred order now.  \n+     \n+     If we have already emitted code for any of those registers,\n+     then it's already too late to change.  */\n+  if (current_frame_info.r[reg_fp] != 0\n+      && current_frame_info.r[reg_save_b0] == current_frame_info.r[reg_fp] + 1\n+      && current_frame_info.r[reg_save_ar_pfs] == current_frame_info.r[reg_fp] + 2\n+      && emitted_frame_related_regs[reg_save_b0] == 0\n+      && emitted_frame_related_regs[reg_save_ar_pfs] == 0\n+      && emitted_frame_related_regs[reg_fp] == 0)\n     {\n-      current_frame_info.reg_save_b0 = current_frame_info.reg_fp;\n-      current_frame_info.reg_save_ar_pfs = current_frame_info.reg_fp + 1;\n-      current_frame_info.reg_fp = current_frame_info.reg_fp + 2;\n+      current_frame_info.r[reg_save_b0] = current_frame_info.r[reg_fp];\n+      current_frame_info.r[reg_save_ar_pfs] = current_frame_info.r[reg_fp] + 1;\n+      current_frame_info.r[reg_fp] = current_frame_info.r[reg_fp] + 2;\n     }\n \n   /* See if we need to store the predicate register block.  */\n   for (regno = PR_REG (0); regno <= PR_REG (63); regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n       break;\n   if (regno <= PR_REG (63))\n     {\n       SET_HARD_REG_BIT (mask, PR_REG (0));\n-      current_frame_info.reg_save_pr = find_gr_spill (1);\n-      if (current_frame_info.reg_save_pr == 0)\n+      current_frame_info.r[reg_save_pr] = find_gr_spill (reg_save_pr, 1);\n+      if (current_frame_info.r[reg_save_pr] == 0)\n \t{\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n@@ -2456,30 +2516,32 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n       /* ??? Mark them all as used so that register renaming and such\n \t are free to use them.  */\n       for (regno = PR_REG (0); regno <= PR_REG (63); regno++)\n-\tregs_ever_live[regno] = 1;\n+\tdf_set_regs_ever_live (regno, true);\n     }\n \n   /* If we're forced to use st8.spill, we're forced to save and restore\n      ar.unat as well.  The check for existing liveness allows inline asm\n      to touch ar.unat.  */\n   if (spilled_gr_p || cfun->machine->n_varargs\n-      || regs_ever_live[AR_UNAT_REGNUM])\n+      || df_regs_ever_live_p (AR_UNAT_REGNUM))\n     {\n-      regs_ever_live[AR_UNAT_REGNUM] = 1;\n+      df_set_regs_ever_live (AR_UNAT_REGNUM, true);\n       SET_HARD_REG_BIT (mask, AR_UNAT_REGNUM);\n-      current_frame_info.reg_save_ar_unat = find_gr_spill (spill_size == 0);\n-      if (current_frame_info.reg_save_ar_unat == 0)\n+      current_frame_info.r[reg_save_ar_unat] \n+        = find_gr_spill (reg_save_ar_unat, spill_size == 0);\n+      if (current_frame_info.r[reg_save_ar_unat] == 0)\n \t{\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n \t}\n     }\n \n-  if (regs_ever_live[AR_LC_REGNUM])\n+  if (df_regs_ever_live_p (AR_LC_REGNUM))\n     {\n       SET_HARD_REG_BIT (mask, AR_LC_REGNUM);\n-      current_frame_info.reg_save_ar_lc = find_gr_spill (spill_size == 0);\n-      if (current_frame_info.reg_save_ar_lc == 0)\n+      current_frame_info.r[reg_save_ar_lc] \n+        = find_gr_spill (reg_save_ar_lc, spill_size == 0);\n+      if (current_frame_info.r[reg_save_ar_lc] == 0)\n \t{\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n@@ -2713,16 +2775,6 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n \t    insn = emit_insn (seq);\n \t}\n       spill_fill_data.init_after = insn;\n-\n-      /* If DISP is 0, we may or may not have a further adjustment\n-\t afterward.  If we do, then the load/store insn may be modified\n-\t to be a post-modify.  If we don't, then this copy may be\n-\t eliminated by copyprop_hardreg_forward, which makes this\n-\t insn garbage, which runs afoul of the sanity check in\n-\t propagate_one_insn.  So mark this insn as legal to delete.  */\n-      if (disp == 0)\n-\tREG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t     REG_NOTES (insn));\n     }\n \n   mem = gen_rtx_MEM (GET_MODE (reg), spill_fill_data.iter_reg[iter]);\n@@ -2850,6 +2902,22 @@ ia64_expand_prologue (void)\n   ia64_compute_frame_size (get_frame_size ());\n   last_scratch_gr_reg = 15;\n \n+  if (dump_file) \n+    {\n+      fprintf (dump_file, \"ia64 frame related registers \"\n+               \"recorded in current_frame_info.r[]:\\n\");\n+#define PRINTREG(a) if (current_frame_info.r[a]) \\\n+        fprintf(dump_file, \"%s = %d\\n\", #a, current_frame_info.r[a])\n+      PRINTREG(reg_fp);\n+      PRINTREG(reg_save_b0);\n+      PRINTREG(reg_save_pr);\n+      PRINTREG(reg_save_ar_pfs);\n+      PRINTREG(reg_save_ar_unat);\n+      PRINTREG(reg_save_ar_lc);\n+      PRINTREG(reg_save_gp);\n+#undef PRINTREG\n+    }\n+\n   /* If there is no epilogue, then we don't need some prologue insns.\n      We need to avoid emitting the dead prologue insns, because flow\n      will complain about them.  */\n@@ -2892,12 +2960,12 @@ ia64_expand_prologue (void)\n      there is a frame pointer.  loc79 gets wasted in this case, as it is\n      renamed to a register that will never be used.  See also the try_locals\n      code in find_gr_spill.  */\n-  if (current_frame_info.reg_fp)\n+  if (current_frame_info.r[reg_fp])\n     {\n       const char *tmp = reg_names[HARD_FRAME_POINTER_REGNUM];\n       reg_names[HARD_FRAME_POINTER_REGNUM]\n-\t= reg_names[current_frame_info.reg_fp];\n-      reg_names[current_frame_info.reg_fp] = tmp;\n+\t= reg_names[current_frame_info.r[reg_fp]];\n+      reg_names[current_frame_info.r[reg_fp]] = tmp;\n     }\n \n   /* We don't need an alloc instruction if we've used no outputs or locals.  */\n@@ -2915,8 +2983,11 @@ ia64_expand_prologue (void)\n     {\n       current_frame_info.need_regstk = 0;\n \n-      if (current_frame_info.reg_save_ar_pfs)\n-\tregno = current_frame_info.reg_save_ar_pfs;\n+      if (current_frame_info.r[reg_save_ar_pfs])\n+        {\n+\t  regno = current_frame_info.r[reg_save_ar_pfs];\n+\t  reg_emitted (reg_save_ar_pfs);\n+\t}\n       else\n \tregno = next_scratch_gr_reg ();\n       ar_pfs_save_reg = gen_rtx_REG (DImode, regno);\n@@ -2926,7 +2997,7 @@ ia64_expand_prologue (void)\n \t\t\t\t   GEN_INT (current_frame_info.n_local_regs),\n \t\t\t\t   GEN_INT (current_frame_info.n_output_regs),\n \t\t\t\t   GEN_INT (current_frame_info.n_rotate_regs)));\n-      RTX_FRAME_RELATED_P (insn) = (current_frame_info.reg_save_ar_pfs != 0);\n+      RTX_FRAME_RELATED_P (insn) = (current_frame_info.r[reg_save_ar_pfs] != 0);\n     }\n \n   /* Set up frame pointer, stack pointer, and spill iterators.  */\n@@ -2984,9 +3055,12 @@ ia64_expand_prologue (void)\n   /* Must copy out ar.unat before doing any integer spills.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM))\n     {\n-      if (current_frame_info.reg_save_ar_unat)\n-\tar_unat_save_reg\n-\t  = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_unat);\n+      if (current_frame_info.r[reg_save_ar_unat])\n+        {\n+\t  ar_unat_save_reg\n+\t    = gen_rtx_REG (DImode, current_frame_info.r[reg_save_ar_unat]);\n+\t  reg_emitted (reg_save_ar_unat);\n+\t}\n       else\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n@@ -2996,11 +3070,11 @@ ia64_expand_prologue (void)\n \n       reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\n       insn = emit_move_insn (ar_unat_save_reg, reg);\n-      RTX_FRAME_RELATED_P (insn) = (current_frame_info.reg_save_ar_unat != 0);\n+      RTX_FRAME_RELATED_P (insn) = (current_frame_info.r[reg_save_ar_unat] != 0);\n \n       /* Even if we're not going to generate an epilogue, we still\n \t need to save the register so that EH works.  */\n-      if (! epilogue_p && current_frame_info.reg_save_ar_unat)\n+      if (! epilogue_p && current_frame_info.r[reg_save_ar_unat])\n \temit_insn (gen_prologue_use (ar_unat_save_reg));\n     }\n   else\n@@ -3026,9 +3100,10 @@ ia64_expand_prologue (void)\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, PR_REG (0)))\n     {\n       reg = gen_rtx_REG (DImode, PR_REG (0));\n-      if (current_frame_info.reg_save_pr != 0)\n+      if (current_frame_info.r[reg_save_pr] != 0)\n \t{\n-\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_pr);\n+\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_pr]);\n+\t  reg_emitted (reg_save_pr);\n \t  insn = emit_move_insn (alt_reg, reg);\n \n \t  /* ??? Denote pr spill/fill by a DImode move that modifies all\n@@ -3056,7 +3131,7 @@ ia64_expand_prologue (void)\n \n   /* Handle AR regs in numerical order.  All of them get special handling.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM)\n-      && current_frame_info.reg_save_ar_unat == 0)\n+      && current_frame_info.r[reg_save_ar_unat] == 0)\n     {\n       reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\n       do_spill (gen_movdi_x, ar_unat_save_reg, cfa_off, reg);\n@@ -3067,7 +3142,7 @@ ia64_expand_prologue (void)\n      only thing we have to do now is copy that register to a stack slot\n      if we'd not allocated a local register for the job.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_PFS_REGNUM)\n-      && current_frame_info.reg_save_ar_pfs == 0)\n+      && current_frame_info.r[reg_save_ar_pfs] == 0)\n     {\n       reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);\n       do_spill (gen_movdi_x, ar_pfs_save_reg, cfa_off, reg);\n@@ -3077,9 +3152,10 @@ ia64_expand_prologue (void)\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_LC_REGNUM))\n     {\n       reg = gen_rtx_REG (DImode, AR_LC_REGNUM);\n-      if (current_frame_info.reg_save_ar_lc != 0)\n+      if (current_frame_info.r[reg_save_ar_lc] != 0)\n \t{\n-\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_lc);\n+\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_ar_lc]);\n+\t  reg_emitted (reg_save_ar_lc);\n \t  insn = emit_move_insn (alt_reg, reg);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -3102,9 +3178,10 @@ ia64_expand_prologue (void)\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, BR_REG (0)))\n     {\n       reg = gen_rtx_REG (DImode, BR_REG (0));\n-      if (current_frame_info.reg_save_b0 != 0)\n+      if (current_frame_info.r[reg_save_b0] != 0)\n \t{\n-\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_b0);\n+          alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_b0]);\n+          reg_emitted (reg_save_b0);\n \t  insn = emit_move_insn (alt_reg, reg);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -3123,17 +3200,12 @@ ia64_expand_prologue (void)\n \t}\n     }\n \n-  if (current_frame_info.reg_save_gp)\n+  if (current_frame_info.r[reg_save_gp])\n     {\n+      reg_emitted (reg_save_gp);\n       insn = emit_move_insn (gen_rtx_REG (DImode,\n-\t\t\t\t\t  current_frame_info.reg_save_gp),\n+\t\t\t\t\t  current_frame_info.r[reg_save_gp]),\n \t\t\t     pic_offset_table_rtx);\n-      /* We don't know for sure yet if this is actually needed, since\n-\t we've not split the PIC call patterns.  If all of the calls\n-\t are indirect, and not followed by any uses of the gp, then\n-\t this save is dead.  Allow it to go away.  */\n-      REG_NOTES (insn)\n-\t= gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, REG_NOTES (insn));\n     }\n \n   /* We should now be at the base of the gr/br/fr spill area.  */\n@@ -3217,8 +3289,11 @@ ia64_expand_epilogue (int sibcall_p)\n   /* Restore the predicate registers.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, PR_REG (0)))\n     {\n-      if (current_frame_info.reg_save_pr != 0)\n-\talt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_pr);\n+      if (current_frame_info.r[reg_save_pr] != 0)\n+        {\n+\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_pr]);\n+\t  reg_emitted (reg_save_pr);\n+\t}\n       else\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n@@ -3236,9 +3311,12 @@ ia64_expand_epilogue (int sibcall_p)\n      after the GRs have been restored.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM))\n     {\n-      if (current_frame_info.reg_save_ar_unat != 0)\n-        ar_unat_save_reg\n-\t  = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_unat);\n+      if (current_frame_info.r[reg_save_ar_unat] != 0)\n+        {\n+          ar_unat_save_reg\n+\t    = gen_rtx_REG (DImode, current_frame_info.r[reg_save_ar_unat]);\n+\t  reg_emitted (reg_save_ar_unat);\n+\t}\n       else\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n@@ -3251,9 +3329,10 @@ ia64_expand_epilogue (int sibcall_p)\n   else\n     ar_unat_save_reg = NULL_RTX;\n \n-  if (current_frame_info.reg_save_ar_pfs != 0)\n+  if (current_frame_info.r[reg_save_ar_pfs] != 0)\n     {\n-      alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_pfs);\n+      reg_emitted (reg_save_ar_pfs);\n+      alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_ar_pfs]);\n       reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);\n       emit_move_insn (reg, alt_reg);\n     }\n@@ -3269,8 +3348,11 @@ ia64_expand_epilogue (int sibcall_p)\n \n   if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_LC_REGNUM))\n     {\n-      if (current_frame_info.reg_save_ar_lc != 0)\n-\talt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_lc);\n+      if (current_frame_info.r[reg_save_ar_lc] != 0)\n+        {\n+\t  alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_ar_lc]);\n+          reg_emitted (reg_save_ar_lc);\n+\t}\n       else\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n@@ -3285,8 +3367,11 @@ ia64_expand_epilogue (int sibcall_p)\n   /* Restore the return pointer.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, BR_REG (0)))\n     {\n-      if (current_frame_info.reg_save_b0 != 0)\n-\talt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_b0);\n+      if (current_frame_info.r[reg_save_b0] != 0)\n+        {\n+         alt_reg = gen_rtx_REG (DImode, current_frame_info.r[reg_save_b0]);\n+         reg_emitted (reg_save_b0);\n+        }\n       else\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n@@ -3409,7 +3494,8 @@ ia64_expand_epilogue (int sibcall_p)\n \t register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM,\n \t so we have to make sure we're using the string \"r2\" when emitting\n \t the register name for the assembler.  */\n-      if (current_frame_info.reg_fp && current_frame_info.reg_fp == GR_REG (2))\n+      if (current_frame_info.r[reg_fp] \n+          && current_frame_info.r[reg_fp] == GR_REG (2))\n \tfp = HARD_FRAME_POINTER_REGNUM;\n \n       /* We must emit an alloc to force the input registers to become output\n@@ -3442,11 +3528,11 @@ ia64_direct_return (void)\n \n       return (current_frame_info.total_size == 0\n \t      && current_frame_info.n_spilled == 0\n-\t      && current_frame_info.reg_save_b0 == 0\n-\t      && current_frame_info.reg_save_pr == 0\n-\t      && current_frame_info.reg_save_ar_pfs == 0\n-\t      && current_frame_info.reg_save_ar_unat == 0\n-\t      && current_frame_info.reg_save_ar_lc == 0);\n+\t      && current_frame_info.r[reg_save_b0] == 0\n+\t      && current_frame_info.r[reg_save_pr] == 0\n+\t      && current_frame_info.r[reg_save_ar_pfs] == 0\n+\t      && current_frame_info.r[reg_save_ar_unat] == 0\n+\t      && current_frame_info.r[reg_save_ar_lc] == 0);\n     }\n   return 0;\n }\n@@ -3472,8 +3558,11 @@ ia64_split_return_addr_rtx (rtx dest)\n \n   if (TEST_HARD_REG_BIT (current_frame_info.mask, BR_REG (0)))\n     {\n-      if (current_frame_info.reg_save_b0 != 0)\n-\tsrc = gen_rtx_REG (DImode, current_frame_info.reg_save_b0);\n+      if (current_frame_info.r[reg_save_b0] != 0)\n+        {\n+\t  src = gen_rtx_REG (DImode, current_frame_info.r[reg_save_b0]);\n+\t  reg_emitted (reg_save_b0);\n+\t}\n       else\n \t{\n \t  HOST_WIDE_INT off;\n@@ -3520,21 +3609,14 @@ int\n ia64_hard_regno_rename_ok (int from, int to)\n {\n   /* Don't clobber any of the registers we reserved for the prologue.  */\n-  if (to == current_frame_info.reg_fp\n-      || to == current_frame_info.reg_save_b0\n-      || to == current_frame_info.reg_save_pr\n-      || to == current_frame_info.reg_save_ar_pfs\n-      || to == current_frame_info.reg_save_ar_unat\n-      || to == current_frame_info.reg_save_ar_lc)\n-    return 0;\n+  enum ia64_frame_regs r;\n \n-  if (from == current_frame_info.reg_fp\n-      || from == current_frame_info.reg_save_b0\n-      || from == current_frame_info.reg_save_pr\n-      || from == current_frame_info.reg_save_ar_pfs\n-      || from == current_frame_info.reg_save_ar_unat\n-      || from == current_frame_info.reg_save_ar_lc)\n-    return 0;\n+  for (r = reg_fp; r <= reg_save_ar_lc; r++)\n+    if (to == current_frame_info.r[r] \n+        || from == current_frame_info.r[r]\n+        || to == emitted_frame_related_regs[r]\n+        || from == emitted_frame_related_regs[r])\n+      return 0;\n \n   /* Don't use output registers outside the register frame.  */\n   if (OUT_REGNO_P (to) && to >= OUT_REG (current_frame_info.n_output_regs))\n@@ -3592,36 +3674,36 @@ ia64_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n   mask = 0;\n   grsave = grsave_prev = 0;\n-  if (current_frame_info.reg_save_b0 != 0)\n+  if (current_frame_info.r[reg_save_b0] != 0)\n     {\n       mask |= 8;\n-      grsave = grsave_prev = current_frame_info.reg_save_b0;\n+      grsave = grsave_prev = current_frame_info.r[reg_save_b0];\n     }\n-  if (current_frame_info.reg_save_ar_pfs != 0\n+  if (current_frame_info.r[reg_save_ar_pfs] != 0\n       && (grsave_prev == 0\n-\t  || current_frame_info.reg_save_ar_pfs == grsave_prev + 1))\n+\t  || current_frame_info.r[reg_save_ar_pfs] == grsave_prev + 1))\n     {\n       mask |= 4;\n       if (grsave_prev == 0)\n-\tgrsave = current_frame_info.reg_save_ar_pfs;\n-      grsave_prev = current_frame_info.reg_save_ar_pfs;\n+\tgrsave = current_frame_info.r[reg_save_ar_pfs];\n+      grsave_prev = current_frame_info.r[reg_save_ar_pfs];\n     }\n-  if (current_frame_info.reg_fp != 0\n+  if (current_frame_info.r[reg_fp] != 0\n       && (grsave_prev == 0\n-\t  || current_frame_info.reg_fp == grsave_prev + 1))\n+\t  || current_frame_info.r[reg_fp] == grsave_prev + 1))\n     {\n       mask |= 2;\n       if (grsave_prev == 0)\n \tgrsave = HARD_FRAME_POINTER_REGNUM;\n-      grsave_prev = current_frame_info.reg_fp;\n+      grsave_prev = current_frame_info.r[reg_fp];\n     }\n-  if (current_frame_info.reg_save_pr != 0\n+  if (current_frame_info.r[reg_save_pr] != 0\n       && (grsave_prev == 0\n-\t  || current_frame_info.reg_save_pr == grsave_prev + 1))\n+\t  || current_frame_info.r[reg_save_pr] == grsave_prev + 1))\n     {\n       mask |= 1;\n       if (grsave_prev == 0)\n-\tgrsave = current_frame_info.reg_save_pr;\n+\tgrsave = current_frame_info.r[reg_save_pr];\n     }\n \n   if (mask && TARGET_GNU_AS)\n@@ -3657,12 +3739,13 @@ ia64_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n {\n   int i;\n \n-  if (current_frame_info.reg_fp)\n+  if (current_frame_info.r[reg_fp])\n     {\n       const char *tmp = reg_names[HARD_FRAME_POINTER_REGNUM];\n       reg_names[HARD_FRAME_POINTER_REGNUM]\n-\t= reg_names[current_frame_info.reg_fp];\n-      reg_names[current_frame_info.reg_fp] = tmp;\n+\t= reg_names[current_frame_info.r[reg_fp]];\n+      reg_names[current_frame_info.r[reg_fp]] = tmp;\n+      reg_emitted (reg_fp);\n     }\n   if (! TARGET_REG_NAMES)\n     {\n@@ -3683,11 +3766,11 @@ ia64_dbx_register_number (int regno)\n   /* In ia64_expand_prologue we quite literally renamed the frame pointer\n      from its home at loc79 to something inside the register frame.  We\n      must perform the same renumbering here for the debug info.  */\n-  if (current_frame_info.reg_fp)\n+  if (current_frame_info.r[reg_fp])\n     {\n       if (regno == HARD_FRAME_POINTER_REGNUM)\n-\tregno = current_frame_info.reg_fp;\n-      else if (regno == current_frame_info.reg_fp)\n+\tregno = current_frame_info.r[reg_fp];\n+      else if (regno == current_frame_info.r[reg_fp])\n \tregno = HARD_FRAME_POINTER_REGNUM;\n     }\n \n@@ -5093,6 +5176,13 @@ ia64_override_options (void)\n   init_machine_status = ia64_init_machine_status;\n }\n \n+/* Initialize the record of emitted frame related registers.  */\n+\n+void ia64_init_expanders (void)\n+{\n+  memset (&emitted_frame_related_regs, 0, sizeof (emitted_frame_related_regs));\n+}\n+\n static struct machine_function *\n ia64_init_machine_status (void)\n {\n@@ -6650,11 +6740,12 @@ ia64_set_sched_flags (spec_info_t spec_info)\n \t    mask |= BE_IN_CONTROL;\n \t}\n \n-      gcc_assert (*flags & USE_GLAT);\n-\n       if (mask)\n \t{\n-\t  *flags |= USE_DEPS_LIST | DETACH_LIFE_INFO | DO_SPECULATION;\n+\t  *flags |= USE_DEPS_LIST | DO_SPECULATION;\n+\n+\t  if (mask & BE_IN_SPEC)\n+\t    *flags |= NEW_BBS;\n \t  \n \t  spec_info->mask = mask;\n \t  spec_info->flags = 0;\n@@ -8338,7 +8429,7 @@ emit_predicate_relation_info (void)\n       /* Skip p0, which may be thought to be live due to (reg:DI p0)\n \t grabbing the entire block of predicate registers.  */\n       for (r = PR_REG (2); r < PR_REG (64); r += 2)\n-\tif (REGNO_REG_SET_P (bb->il.rtl->global_live_at_start, r))\n+\tif (REGNO_REG_SET_P (df_get_live_in (bb), r))\n \t  {\n \t    rtx p = gen_rtx_REG (BImode, r);\n \t    rtx n = emit_insn_after (gen_pred_rel_mutex (p), head);\n@@ -8388,13 +8479,9 @@ ia64_reorg (void)\n \n   /* If optimizing, we'll have split before scheduling.  */\n   if (optimize == 0)\n-    split_all_insns (0);\n-\n-  /* ??? update_life_info_in_dirty_blocks fails to terminate during\n-     non-optimizing bootstrap.  */\n-  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES, PROP_DEATH_NOTES);\n+    split_all_insns ();\n \n-  if (optimize && ia64_flag_schedule_insns2)\n+  if (optimize && ia64_flag_schedule_insns2 && dbg_cnt (ia64_sched2))\n     {\n       timevar_push (TV_SCHED2);\n       ia64_final_schedule = 1;\n@@ -8469,6 +8556,8 @@ ia64_reorg (void)\n \t  _1mlx_ = get_cpu_unit_code (\"1b_1mlx.\");\n \t}\n       schedule_ebbs ();\n+      /* We cannot reuse this one because it has been corrupted by the\n+\t evil glat.  */\n       finish_bundle_states ();\n       if (ia64_tune == PROCESSOR_ITANIUM)\n \t{\n@@ -8485,6 +8574,8 @@ ia64_reorg (void)\n   else\n     emit_all_insn_group_barriers (dump_file);\n \n+  df_analyze ();\n+ \n   /* A call must not be the last instruction in a function, so that the\n      return address is still within the function, so that unwinding works\n      properly.  Note that IA-64 differs from dwarf2 on this point.  */\n@@ -8521,6 +8612,7 @@ ia64_reorg (void)\n       variable_tracking_main ();\n       timevar_pop (TV_VAR_TRACKING);\n     }\n+  df_finish_pass ();\n }\n \f\n /* Return true if REGNO is used by the epilogue.  */\n@@ -8567,24 +8659,18 @@ ia64_epilogue_uses (int regno)\n int\n ia64_eh_uses (int regno)\n {\n+  enum ia64_frame_regs r;\n+\n   if (! reload_completed)\n     return 0;\n \n-  if (current_frame_info.reg_save_b0\n-      && regno == current_frame_info.reg_save_b0)\n-    return 1;\n-  if (current_frame_info.reg_save_pr\n-      && regno == current_frame_info.reg_save_pr)\n-    return 1;\n-  if (current_frame_info.reg_save_ar_pfs\n-      && regno == current_frame_info.reg_save_ar_pfs)\n-    return 1;\n-  if (current_frame_info.reg_save_ar_unat\n-      && regno == current_frame_info.reg_save_ar_unat)\n-    return 1;\n-  if (current_frame_info.reg_save_ar_lc\n-      && regno == current_frame_info.reg_save_ar_lc)\n-    return 1;\n+  if (regno == 0)\n+    return 0;\n+\n+  for (r = reg_save_b0; r <= reg_save_ar_lc; r++)\n+    if (regno == current_frame_info.r[r]\n+       || regno == emitted_frame_related_regs[r])\n+      return 1;\n \n   return 0;\n }\n@@ -8737,7 +8823,7 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n \n       /* If this is the final destination for ar.pfs, then this must\n \t be the alloc in the prologue.  */\n-      if (dest_regno == current_frame_info.reg_save_ar_pfs)\n+      if (dest_regno == current_frame_info.r[reg_save_ar_pfs])\n \t{\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n@@ -8802,28 +8888,28 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n \t{\n \tcase BR_REG (0):\n \t  /* Saving return address pointer.  */\n-\t  gcc_assert (dest_regno == current_frame_info.reg_save_b0);\n+\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_b0]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n \t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase PR_REG (0):\n-\t  gcc_assert (dest_regno == current_frame_info.reg_save_pr);\n+\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_pr]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t.save pr, r%d\\n\",\n \t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase AR_UNAT_REGNUM:\n-\t  gcc_assert (dest_regno == current_frame_info.reg_save_ar_unat);\n+\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_unat]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t.save ar.unat, r%d\\n\",\n \t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase AR_LC_REGNUM:\n-\t  gcc_assert (dest_regno == current_frame_info.reg_save_ar_lc);\n+\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_lc]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t.save ar.lc, r%d\\n\",\n \t\t     ia64_dbx_register_number (dest_regno));\n@@ -8880,31 +8966,31 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n       switch (src_regno)\n \t{\n \tcase BR_REG (0):\n-\t  gcc_assert (!current_frame_info.reg_save_b0);\n+\t  gcc_assert (!current_frame_info.r[reg_save_b0]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t%s rp, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase PR_REG (0):\n-\t  gcc_assert (!current_frame_info.reg_save_pr);\n+\t  gcc_assert (!current_frame_info.r[reg_save_pr]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t%s pr, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase AR_LC_REGNUM:\n-\t  gcc_assert (!current_frame_info.reg_save_ar_lc);\n+\t  gcc_assert (!current_frame_info.r[reg_save_ar_lc]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t%s ar.lc, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase AR_PFS_REGNUM:\n-\t  gcc_assert (!current_frame_info.reg_save_ar_pfs);\n+\t  gcc_assert (!current_frame_info.r[reg_save_ar_pfs]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t%s ar.pfs, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase AR_UNAT_REGNUM:\n-\t  gcc_assert (!current_frame_info.reg_save_ar_unat);\n+\t  gcc_assert (!current_frame_info.r[reg_save_ar_unat]);\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t%s ar.unat, %ld\\n\", saveop, off);\n \t  return 1;"}, {"sha": "70120ce787f2bc8141252d328a154e0191348652", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine GNU compiler.  IA-64 version.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by James E. Wilson <wilson@cygnus.com> and\n    \t\t  David Mosberger <davidm@hpl.hp.com>.\n@@ -985,6 +985,7 @@ enum reg_class\n    pointer is not 16-byte aligned like the stack pointer.  */\n #define INIT_EXPANDERS\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n+    ia64_init_expanders ();                             \\\n     if (cfun && cfun->emit->regno_pointer_align)\t\\\n       REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) = 64;\t\\\n   } while (0)"}, {"sha": "527046359e3db7b1e6814516db40e67f75238a16", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on Vitesse IQ2000 processors\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1964,13 +1964,6 @@ iq2000_expand_prologue (void)\n \t  PUT_CODE (SET_SRC (pattern), ASHIFTRT);\n \n \t  insn = emit_insn (pattern);\n-\n-\t  /* Global life information isn't valid at this point, so we\n-\t     can't check whether these shifts are actually used.  Mark\n-\t     them MAYBE_DEAD so that flow2 will remove them, and not\n-\t     complain about dead code in the prologue.  */\n-\t  REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-\t\t\t\t\t       REG_NOTES (insn));\n \t}\n     }\n \n@@ -2119,7 +2112,7 @@ iq2000_can_use_return_insn (void)\n   if (! reload_completed)\n     return 0;\n \n-  if (regs_ever_live[31] || profile_flag)\n+  if (df_regs_ever_live_p (31) || profile_flag)\n     return 0;\n \n   if (cfun->machine->initialized)"}, {"sha": "deb3460de24706310b7fab1c764dc70156fd73a4", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  \n    Vitesse IQ2000 processors\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -974,9 +974,9 @@ enum processor_type\n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n #define MUST_SAVE_REGISTER(regno) \\\n- ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\t\\\n+  ((df_regs_ever_live_p (regno) && !call_used_regs[regno])\t\t\\\n   || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n-  || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n+   || (regno == (GP_REG_FIRST + 31) && df_regs_ever_live_p (GP_REG_FIRST + 31)))\n \n /* ALIGN FRAMES on double word boundaries */\n #ifndef IQ2000_STACK_ALIGN"}, {"sha": "f48b252926e05d7062c28631cca799779e6de62b", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Target Code for R8C/M16C/M32C\n-   Copyright (C) 2005\n+   Copyright (C) 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Red Hat.\n \n@@ -1248,7 +1248,7 @@ need_to_save (int regno)\n   if (cfun->machine->is_interrupt\n       && (!cfun->machine->is_leaf || regno == A0_REGNO))\n     return 1;\n-  if (regs_ever_live[regno]\n+  if (df_regs_ever_live_p (regno)\n       && (!call_used_regs[regno] || cfun->machine->is_interrupt))\n     return 1;\n   return 0;"}, {"sha": "fa0a6ad9eb0d7e28cdffbcce0e6539563aa53029", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1254,10 +1254,10 @@ static struct m32r_frame_info zero_frame_info;\n    Don't consider them here.  */\n #define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n   ((regno) != RETURN_ADDR_REGNUM && (regno) != FRAME_POINTER_REGNUM \\\n-  && (regs_ever_live[regno] && (!call_really_used_regs[regno] || interrupt_p)))\n+   && (df_regs_ever_live_p (regno) && (!call_really_used_regs[regno] || interrupt_p)))\n \n-#define MUST_SAVE_FRAME_POINTER (regs_ever_live[FRAME_POINTER_REGNUM])\n-#define MUST_SAVE_RETURN_ADDR   (regs_ever_live[RETURN_ADDR_REGNUM] || current_function_profile)\n+#define MUST_SAVE_FRAME_POINTER (df_regs_ever_live_p (FRAME_POINTER_REGNUM))\n+#define MUST_SAVE_RETURN_ADDR   (df_regs_ever_live_p (RETURN_ADDR_REGNUM) || current_function_profile)\n \n #define SHORT_INSN_SIZE 2\t/* Size of small instructions.  */\n #define LONG_INSN_SIZE 4\t/* Size of long instructions.  */\n@@ -2449,7 +2449,7 @@ m32r_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n {\n   /* Interrupt routines can't clobber any register that isn't already used.  */\n   if (lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (current_function_decl))\n-      && !regs_ever_live[new_reg])\n+      && !df_regs_ever_live_p (new_reg))\n     return 0;\n \n   return 1;"}, {"sha": "ca7575858a2bb4e0d1882b7469ed93e99bd95f87", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for code generation on Motorola 68HC11 and 68HC12.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Stephane Carrez (stcarrez@nerim.fr)\n \n@@ -1336,7 +1336,7 @@ m68hc11_initial_elimination_offset (int from, int to)\n   /* Push any 2 byte pseudo hard registers that we need to save.  */\n   for (regno = SOFT_REG_FIRST; regno < SOFT_REG_LAST; regno++)\n     {\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n+      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t{\n \t  size += 2;\n \t}\n@@ -1550,7 +1550,7 @@ m68hc11_total_frame_size (void)\n     size += HARD_REG_SIZE;\n \n   for (regno = SOFT_REG_FIRST; regno <= SOFT_REG_LAST; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n       size += HARD_REG_SIZE;\n \n   return size;\n@@ -1662,7 +1662,7 @@ expand_prologue (void)\n   /* Push any 2 byte pseudo hard registers that we need to save.  */\n   for (regno = SOFT_REG_FIRST; regno <= SOFT_REG_LAST; regno++)\n     {\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n+      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t{\n \t  emit_move_after_reload (stack_push_word,\n \t\t\t\t  gen_rtx_REG (HImode, regno), scratch);\n@@ -1700,7 +1700,7 @@ expand_epilogue (void)\n   /* Pop any 2 byte pseudo hard registers that we saved.  */\n   for (regno = SOFT_REG_LAST; regno >= SOFT_REG_FIRST; regno--)\n     {\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n+      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t{\n \t  emit_move_after_reload (gen_rtx_REG (HImode, regno),\n \t\t\t\t  stack_pop_word, scratch);"}, {"sha": "353b84a42f4b0b982d35d1cb19d1a8eb35bb7da2", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"target-def.h\"\n #include \"debug.h\"\n #include \"flags.h\"\n+#include \"df.h\"\n \n enum reg_class regno_reg_class[] =\n {\n@@ -818,15 +819,15 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n      if they are live or when calling nested functions.  */\n   if (interrupt_handler)\n     {\n-      if (regs_ever_live[regno])\n+      if (df_regs_ever_live_p (regno))\n \treturn true;\n \n       if (!current_function_is_leaf && call_used_regs[regno])\n \treturn true;\n     }\n \n   /* Never need to save registers that aren't touched.  */\n-  if (!regs_ever_live[regno])\n+  if (!df_regs_ever_live_p (regno))\n     return false;\n \n   /* Otherwise save everything that isn't call-clobbered.  */\n@@ -1037,12 +1038,7 @@ m68k_expand_prologue (void)\n   if (flag_pic\n       && !TARGET_SEP_DATA\n       && current_function_uses_pic_offset_table)\n-    {\n-      insn = emit_insn (gen_load_got (pic_offset_table_rtx));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\t    const0_rtx,\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n+    insn = emit_insn (gen_load_got (pic_offset_table_rtx));\n }\n \f\n /* Return true if a simple (return) instruction is sufficient for this\n@@ -4143,7 +4139,6 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   /* Pretend to be a post-reload pass while generating rtl.  */\n   no_new_pseudos = 1;\n   reload_completed = 1;\n-  allocate_reg_info (FIRST_PSEUDO_REGISTER, true, true);\n \n   /* The \"this\" pointer is stored at 4(%sp).  */\n   this_slot = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 4));\n@@ -4198,7 +4193,7 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t  /* Use the static chain register as a temporary (call-clobbered)\n \t     GOT pointer for this function.  We can use the static chain\n \t     register because it isn't live on entry to the thunk.  */\n-\t  REGNO (pic_offset_table_rtx) = STATIC_CHAIN_REGNUM;\n+\t  SET_REGNO (pic_offset_table_rtx, STATIC_CHAIN_REGNUM);\n \t  emit_insn (gen_load_got (pic_offset_table_rtx));\n \t}\n       legitimize_pic_address (XEXP (mem, 0), Pmode, static_chain_rtx);\n@@ -4220,7 +4215,7 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n   /* Restore the original PIC register.  */\n   if (flag_pic)\n-    REGNO (pic_offset_table_rtx) = PIC_REG;\n+    SET_REGNO (pic_offset_table_rtx, PIC_REG);\n }\n \n /* Worker function for TARGET_STRUCT_VALUE_RTX.  */\n@@ -4244,7 +4239,7 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n \n   if ((m68k_get_function_kind (current_function_decl)\n        == m68k_fk_interrupt_handler)\n-      && !regs_ever_live[new_reg])\n+      && !df_regs_ever_live_p (new_reg))\n     return 0;\n \n   return 1;"}, {"sha": "e568699eb3a6583a2b487b37ffe51904e1920cb5", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -267,7 +267,7 @@ calc_live_regs (int * count)\n \n   for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n     {\n-      if (regs_ever_live[reg] && !call_used_regs[reg])\n+      if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n \t{\n \t  (*count)++;\n \t  live_regs_mask |= (1 << reg);"}, {"sha": "d84eb9b5595194e9373c89639382425a62033973", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,7 @@\n /* Subroutines used for MIPS code generation.\n    Copyright (C) 1989, 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 \n+   Free Software Foundation, Inc.\n    Contributed by A. Lichnewsky, lich@inria.inria.fr.\n    Changes by Michael Meissner, meissner@osf.org.\n    64-bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n@@ -6337,7 +6338,7 @@ mips_global_pointer (void)\n \n      In cases like these, reload will have added the constant to the pool\n      but no instruction will yet refer to it.  */\n-  if (!regs_ever_live[GLOBAL_POINTER_REGNUM]\n+  if (!df_regs_ever_live_p (GLOBAL_POINTER_REGNUM)\n       && !current_function_uses_const_pool\n       && !mips_function_has_gp_insn ())\n     return 0;\n@@ -6346,7 +6347,7 @@ mips_global_pointer (void)\n      register instead of $gp.  */\n   if (TARGET_CALL_SAVED_GP && current_function_is_leaf)\n     for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-      if (!regs_ever_live[regno]\n+      if (!df_regs_ever_live_p (regno)\n \t  && call_used_regs[regno]\n \t  && !fixed_regs[regno]\n \t  && regno != PIC_FUNCTION_ADDR_REGNUM)\n@@ -6412,15 +6413,15 @@ mips_save_reg_p (unsigned int regno)\n     return TARGET_CALL_SAVED_GP && cfun->machine->global_pointer == regno;\n \n   /* Check call-saved registers.  */\n-  if (regs_ever_live[regno] && !call_used_regs[regno])\n+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n     return true;\n \n  /* Save both registers in an FPR pair if either one is used.  This is\n     needed for the case when MIN_FPRS_PER_FMT == 1, which allows the odd\n     register to be used without the even register.  */\n  if (FP_REG_P (regno)\n-     && MAX_FPRS_PER_FMT == 2 \n-     && regs_ever_live[regno + 1]\n+     && MAX_FPRS_PER_FMT == 2\n+     && df_regs_ever_live_p (regno + 1)\n      && !call_used_regs[regno + 1])\n    return true;\n \n@@ -6430,15 +6431,15 @@ mips_save_reg_p (unsigned int regno)\n \n   /* We need to save the incoming return address if it is ever clobbered\n      within the function.  */\n-  if (regno == GP_REG_FIRST + 31 && regs_ever_live[regno])\n+  if (regno == GP_REG_FIRST + 31 && df_regs_ever_live_p (regno))\n     return true;\n \n   if (TARGET_MIPS16)\n     {\n       /* $18 is a special case in mips16 code.  It may be used to call\n \t a function which returns a floating point value, but it is\n \t marked in call_used_regs.  */\n-      if (regno == GP_REG_FIRST + 18 && regs_ever_live[regno])\n+      if (regno == GP_REG_FIRST + 18 && df_regs_ever_live_p (regno))\n \treturn true;\n \n       /* $31 is also a special case.  It will be used to copy a return\n@@ -6990,7 +6991,7 @@ mips_expand_prologue (void)\n   HOST_WIDE_INT size;\n \n   if (cfun->machine->global_pointer > 0)\n-    REGNO (pic_offset_table_rtx) = cfun->machine->global_pointer;\n+    SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n \n   size = compute_frame_size (get_frame_size ());\n \n@@ -7099,7 +7100,7 @@ mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* Reinstate the normal $gp.  */\n-  REGNO (pic_offset_table_rtx) = GLOBAL_POINTER_REGNUM;\n+  SET_REGNO (pic_offset_table_rtx, GLOBAL_POINTER_REGNUM);\n   mips_output_cplocal ();\n \n   if (cfun->machine->all_noreorder_p)\n@@ -7296,7 +7297,7 @@ mips_can_use_return_insn (void)\n   if (! reload_completed)\n     return 0;\n \n-  if (regs_ever_live[31] || current_function_profile)\n+  if (df_regs_ever_live_p (31) || current_function_profile)\n     return 0;\n \n   /* In mips16 mode, a function that returns a floating point value\n@@ -7331,9 +7332,13 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Pick a global pointer.  Use a call-clobbered register if\n      TARGET_CALL_SAVED_GP, so that we can use a sibcall.  */\n   if (TARGET_USE_GOT)\n-    cfun->machine->global_pointer\n-      = REGNO (pic_offset_table_rtx)\n-      = TARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n+    {\n+      cfun->machine->global_pointer =\n+\tTARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n+\n+      SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n+\n+    }\n \n   /* Set up the global pointer for n32 or n64 abicalls.  If\n      LOADGP_ABSOLUTE then the thunk does not use the gp and there is\n@@ -8387,7 +8392,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \n       /* If we are handling a floating point return value, we need to\n          save $18 in the function prologue.  Putting a note on the\n-         call will mean that regs_ever_live[$18] will be true if the\n+         call will mean that df_regs_ever_live_p ($18) will be true if the\n          call is not eliminated, and we can check that in the prologue\n          code.  */\n       if (fpret)"}, {"sha": "b89f5f9852a65683d0239be6f389434b487a63dd", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,7 @@\n ;;  Mips.md\t     Machine Description for MIPS based processors\n ;;  Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-;;  1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+;;  1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+;;  Free Software Foundation, Inc.\n ;;  Contributed by   A. Lichnewsky, lich@inria.inria.fr\n ;;  Changes by       Michael Meissner, meissner@osf.org\n ;;  64-bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n@@ -3094,7 +3095,7 @@\n \t(high:DI (match_operand:DI 1 \"general_symbolic_operand\" \"\")))]\n   \"TARGET_EXPLICIT_RELOCS && ABI_HAS_64BIT_SYMBOLS\"\n   \"#\"\n-  \"&& flow2_completed\"\n+  \"&& epilogue_completed\"\n   [(set (match_dup 0) (high:DI (match_dup 2)))\n    (set (match_dup 0) (lo_sum:DI (match_dup 0) (match_dup 2)))\n    (set (match_dup 0) (ashift:DI (match_dup 0) (const_int 16)))"}, {"sha": "8a23c02910cc6cc3decdee5ebcbc42a292262b4d", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for MMIX.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n \n@@ -56,7 +56,7 @@ Boston, MA 02110-1301, USA.  */\n /* We have no means to tell DWARF 2 about the register stack, so we need\n    to store the return address on the stack if an exception can get into\n    this function.  FIXME: Narrow condition.  Before any whole-function\n-   analysis, regs_ever_live[] isn't initialized.  We know it's up-to-date\n+   analysis, df_regs_ever_live_p () isn't initialized.  We know it's up-to-date\n    after reload_completed; it may contain incorrect information some time\n    before that.  Within a RTL sequence (after a call to start_sequence,\n    such as in RTL expanders), leaf_function_p doesn't see all insns\n@@ -66,7 +66,7 @@ Boston, MA 02110-1301, USA.  */\n    preferable.  */\n #define MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS\t\t\t\\\n  (flag_exceptions\t\t\t\t\t\t\\\n-  && ((reload_completed && regs_ever_live[MMIX_rJ_REGNUM])\t\\\n+  && ((reload_completed && df_regs_ever_live_p (MMIX_rJ_REGNUM))\t\\\n       || !leaf_function_p ()))\n \n #define IS_MMIX_EH_RETURN_DATA_REG(REGNO)\t\\\n@@ -547,7 +547,7 @@ mmix_initial_elimination_offset (int fromreg, int toreg)\n   for (regno = MMIX_FIRST_GLOBAL_REGNUM;\n        regno <= 255;\n        regno++)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+    if ((df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n       fp_sp_offset += 8;\n \n@@ -765,7 +765,7 @@ mmix_reorg (void)\n   for (regno = MMIX_LAST_STACK_REGISTER_REGNUM;\n        regno >= 0;\n        regno--)\n-    if ((regs_ever_live[regno] && !call_used_regs[regno])\n+    if ((df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t|| (regno == MMIX_FRAME_POINTER_REGNUM && frame_pointer_needed))\n       break;\n \n@@ -774,7 +774,7 @@ mmix_reorg (void)\n      insns to see whether they're actually used (and indeed do other less\n      trivial register usage analysis and transformations), but it seems\n      wasteful to optimize for unused parameter registers.  As of\n-     2002-04-30, regs_ever_live[n] seems to be set for only-reads too, but\n+     2002-04-30, df_regs_ever_live_p (n) seems to be set for only-reads too, but\n      that might change.  */\n   if (!TARGET_ABI_GNU && regno < current_function_args_info.regs - 1)\n     {\n@@ -1836,7 +1836,7 @@ mmix_use_simple_return (void)\n     /* Note that we assume that the frame-pointer-register is one of these\n        registers, in which case we don't count it here.  */\n     if ((((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t  && regs_ever_live[regno] && !call_used_regs[regno]))\n+\t  && df_regs_ever_live_p (regno) && !call_used_regs[regno]))\n \t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n       return 0;\n \n@@ -1872,7 +1872,7 @@ mmix_expand_prologue (void)\n     /* Note that we assume that the frame-pointer-register is one of these\n        registers, in which case we don't count it here.  */\n     if ((((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t  && regs_ever_live[regno] && !call_used_regs[regno]))\n+\t  && df_regs_ever_live_p (regno) && !call_used_regs[regno]))\n \t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n       stack_space_to_allocate += 8;\n \n@@ -2057,7 +2057,7 @@ mmix_expand_prologue (void)\n        regno >= MMIX_FIRST_GLOBAL_REGNUM;\n        regno--)\n     if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regs_ever_live[regno] && ! call_used_regs[regno])\n+\t && df_regs_ever_live_p (regno) && ! call_used_regs[regno])\n \t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n       {\n \trtx insn;\n@@ -2109,7 +2109,7 @@ mmix_expand_epilogue (void)\n        regno >= MMIX_FIRST_GLOBAL_REGNUM;\n        regno--)\n     if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regs_ever_live[regno] && !call_used_regs[regno])\n+\t && df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n       stack_space_to_deallocate += 8;\n \n@@ -2138,7 +2138,7 @@ mmix_expand_epilogue (void)\n        regno <= 255;\n        regno++)\n     if (((regno != MMIX_FRAME_POINTER_REGNUM || !frame_pointer_needed)\n-\t && regs_ever_live[regno] && !call_used_regs[regno])\n+\t && df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t|| IS_MMIX_EH_RETURN_DATA_REG (regno))\n       {\n \tif (offset > 255)"}, {"sha": "8c93f4162c1a1c2da1fc02aef2c1d2b7f9097d09", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Matsushita MN10300 series\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GCC.\n@@ -60,12 +60,12 @@ enum processor_type mn10300_processor = PROCESSOR_DEFAULT;\n /* The size of the callee register save area.  Right now we save everything\n    on entry since it costs us nothing in code size.  It does cost us from a\n    speed standpoint, so we want to optimize this sooner or later.  */\n-#define REG_SAVE_BYTES (4 * regs_ever_live[2] \\\n-\t\t\t+ 4 * regs_ever_live[3] \\\n-\t\t        + 4 * regs_ever_live[6] \\\n-\t\t\t+ 4 * regs_ever_live[7] \\\n-\t\t\t+ 16 * (regs_ever_live[14] || regs_ever_live[15] \\\n-\t\t\t\t|| regs_ever_live[16] || regs_ever_live[17]))\n+#define REG_SAVE_BYTES (4 * df_regs_ever_live_p (2)\t\\\n+\t\t\t+ 4 * df_regs_ever_live_p (3)\t\\\n+\t\t        + 4 * df_regs_ever_live_p (6)\t\\\n+\t\t\t+ 4 * df_regs_ever_live_p (7)\t\t\t\\\n+\t\t\t+ 16 * (df_regs_ever_live_p (14) || df_regs_ever_live_p (15) \\\n+\t\t\t\t|| df_regs_ever_live_p (16) || df_regs_ever_live_p (17)))\n \n \n static bool mn10300_handle_option (size_t, const char *, int);\n@@ -537,7 +537,7 @@ fp_regs_to_save (void)\n     return 0;\n \n   for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n-    if (regs_ever_live[i] && ! call_used_regs[i])\n+    if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n       ++n;\n \n   return n;\n@@ -590,14 +590,14 @@ can_use_return_insn (void)\n \n   return (reload_completed\n \t  && size == 0\n-\t  && !regs_ever_live[2]\n-\t  && !regs_ever_live[3]\n-\t  && !regs_ever_live[6]\n-\t  && !regs_ever_live[7]\n-\t  && !regs_ever_live[14]\n-\t  && !regs_ever_live[15]\n-\t  && !regs_ever_live[16]\n-\t  && !regs_ever_live[17]\n+\t  && !df_regs_ever_live_p (2)\n+\t  && !df_regs_ever_live_p (3)\n+\t  && !df_regs_ever_live_p (6)\n+\t  && !df_regs_ever_live_p (7)\n+\t  && !df_regs_ever_live_p (14)\n+\t  && !df_regs_ever_live_p (15)\n+\t  && !df_regs_ever_live_p (16)\n+\t  && !df_regs_ever_live_p (17)\n \t  && fp_regs_to_save () == 0\n \t  && !frame_pointer_needed);\n }\n@@ -614,7 +614,7 @@ mn10300_get_live_callee_saved_regs (void)\n \n   mask = 0;\n   for (i = 0; i <= LAST_EXTENDED_REGNUM; i++)\n-    if (regs_ever_live[i] && ! call_used_regs[i])\n+    if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n       mask |= (1 << i);\n   if ((mask & 0x3c000) != 0)\n     mask |= 0x3c000;\n@@ -907,7 +907,7 @@ expand_prologue (void)\n \n       /* Now actually save the FP registers.  */\n       for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n \t    rtx addr;\n \n@@ -944,24 +944,8 @@ expand_prologue (void)\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n \t\t\t   GEN_INT (-size)));\n-  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    {\n-      rtx insn = get_last_insn ();\n-      rtx last = emit_insn (gen_GOTaddr2picreg ());\n-\n-      /* Mark these insns as possibly dead.  Sometimes, flow2 may\n-\t delete all uses of the PIC register.  In this case, let it\n-\t delete the initialization too.  */\n-      do\n-\t{\n-\t  insn = NEXT_INSN (insn);\n-\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\t\tconst0_rtx,\n-\t\t\t\t\t\tREG_NOTES (insn));\n-\t}\n-      while (insn != last);\n-    }\n+  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n+    emit_insn (gen_GOTaddr2picreg ());\n }\n \n void\n@@ -1127,7 +1111,7 @@ expand_epilogue (void)\n \treg = gen_rtx_POST_INC (SImode, reg);\n \n       for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n \t    rtx addr;\n \n@@ -1189,10 +1173,10 @@ expand_epilogue (void)\n     }\n \n   /* Adjust the stack and restore callee-saved registers, if any.  */\n-  if (size || regs_ever_live[2] || regs_ever_live[3]\n-      || regs_ever_live[6] || regs_ever_live[7]\n-      || regs_ever_live[14] || regs_ever_live[15]\n-      || regs_ever_live[16] || regs_ever_live[17]\n+  if (size || df_regs_ever_live_p (2) || df_regs_ever_live_p (3)\n+      || df_regs_ever_live_p (6) || df_regs_ever_live_p (7)\n+      || df_regs_ever_live_p (14) || df_regs_ever_live_p (15)\n+      || df_regs_ever_live_p (16) || df_regs_ever_live_p (17)\n       || frame_pointer_needed)\n     emit_jump_insn (gen_return_internal_regs\n \t\t    (GEN_INT (size + REG_SAVE_BYTES)));\n@@ -1401,10 +1385,10 @@ initial_offset (int from, int to)\n      is the size of the callee register save area.  */\n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n     {\n-      if (regs_ever_live[2] || regs_ever_live[3]\n-\t  || regs_ever_live[6] || regs_ever_live[7]\n-\t  || regs_ever_live[14] || regs_ever_live[15]\n-\t  || regs_ever_live[16] || regs_ever_live[17]\n+      if (df_regs_ever_live_p (2) || df_regs_ever_live_p (3)\n+\t  || df_regs_ever_live_p (6) || df_regs_ever_live_p (7)\n+\t  || df_regs_ever_live_p (14) || df_regs_ever_live_p (15)\n+\t  || df_regs_ever_live_p (16) || df_regs_ever_live_p (17)\n \t  || fp_regs_to_save ()\n \t  || frame_pointer_needed)\n \treturn REG_SAVE_BYTES\n@@ -1418,10 +1402,10 @@ initial_offset (int from, int to)\n      area, and the fixed stack space needed for function calls (if any).  */\n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     {\n-      if (regs_ever_live[2] || regs_ever_live[3]\n-\t  || regs_ever_live[6] || regs_ever_live[7]\n-\t  || regs_ever_live[14] || regs_ever_live[15]\n-\t  || regs_ever_live[16] || regs_ever_live[17]\n+      if (df_regs_ever_live_p (2) || df_regs_ever_live_p (3)\n+\t  || df_regs_ever_live_p (6) || df_regs_ever_live_p (7)\n+\t  || df_regs_ever_live_p (14) || df_regs_ever_live_p (15)\n+\t  || df_regs_ever_live_p (16) || df_regs_ever_live_p (17)\n \t  || fp_regs_to_save ()\n \t  || frame_pointer_needed)\n \treturn (get_frame_size () + REG_SAVE_BYTES"}, {"sha": "a0e5567e4bc7e9f42cd5f5583f7cbd9d247b26be", "filename": "gcc/config/mt/mt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmt%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmt%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Target definitions for the MorphoRISC1\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n    This file is part of GCC.\n@@ -353,7 +353,7 @@ mt_print_operand_simple_address (FILE * file, rtx addr)\n     switch (GET_CODE (addr))\n       {\n       case REG:\n-\tfprintf (file, \"%s, #0\", reg_names [REGNO (addr)]);\n+\tfprintf (file, \"%s, #0\", reg_names[REGNO (addr)]);\n \tbreak;\n \t\n       case PLUS:\n@@ -375,11 +375,11 @@ mt_print_operand_simple_address (FILE * file, rtx addr)\n \t      reg = arg1, offset = arg0;\n \t  else if (CONSTANT_P (arg0) && CONSTANT_P (arg1))\n \t    {\n-\t      fprintf (file, \"%s, #\", reg_names [GPR_R0]);\n+\t      fprintf (file, \"%s, #\", reg_names[GPR_R0]);\n \t      output_addr_const (file, addr);\n \t      break;\n \t    }\n-\t  fprintf (file, \"%s, #\", reg_names [REGNO (reg)]);\n+\t  fprintf (file, \"%s, #\", reg_names[REGNO (reg)]);\n \t  output_addr_const (file, offset);\n \t  break;\n \t}\n@@ -457,7 +457,7 @@ mt_print_operand (FILE * file, rtx x, int code)\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      fputs (reg_names [REGNO (x)], file);\n+      fputs (reg_names[REGNO (x)], file);\n       break;\n \n     case CONST:\n@@ -884,10 +884,10 @@ mt_compute_frame_size (int size)\n         }\n     }\n \n-  current_frame_info.save_fp = (regs_ever_live [GPR_FP]\n+  current_frame_info.save_fp = (df_regs_ever_live_p (GPR_FP)\n \t\t\t\t|| frame_pointer_needed\n \t\t\t\t|| interrupt_handler);\n-  current_frame_info.save_lr = (regs_ever_live [GPR_LINK]\n+  current_frame_info.save_lr = (df_regs_ever_live_p (GPR_LINK)\n \t\t\t\t|| profile_flag\n \t\t\t\t|| interrupt_handler);\n  "}, {"sha": "88abec753aeed8cb026c2a21bd9e470858268902", "filename": "gcc/config/mt/mt.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmt%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fmt%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Target Definitions for MorphoRISC1\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n    This file is part of GCC.\n@@ -414,11 +414,11 @@ enum save_direction\n    && (regno) != GPR_FP\t\t  \t\t\t\t\\\n    && (regno) != GPR_SP\t\t  \t\t\t\t\\\n    && (regno) != GPR_R0\t\t  \t\t\t\t\\\n-   &&   (( regs_ever_live [regno] && ! call_used_regs [regno] ) \\\n+      &&   (( df_regs_ever_live_p (regno) && ! call_used_regs[regno] ) \\\n        /* Save ira register in an interrupt handler.  */\t\\\n \t|| (interrupt_handler && (regno) == GPR_INTERRUPT_LINK)\t\\\n        /* Save any register used in an interrupt handler.  */\t\\\n-\t|| (interrupt_handler && regs_ever_live [regno])\t\\\n+\t|| (interrupt_handler && df_regs_ever_live_p (regno))\t\\\n        /* Save call clobbered registers in non-leaf interrupt\t\\\n \t  handlers.  */\t\t\t\t\t\t\\\n \t|| (interrupt_handler && call_used_regs[regno] \t\t\\"}, {"sha": "01eb9c325ee9d71dc302a67c31abb605574f37e4", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for HPPA.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c\n \n This file is part of GCC.\n@@ -3491,13 +3491,13 @@ compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n \n   /* Account for space used by the callee general register saves.  */\n   for (i = 18, j = frame_pointer_needed ? 4 : 3; i >= j; i--)\n-    if (regs_ever_live[i])\n+    if (df_regs_ever_live_p (i))\n       size += UNITS_PER_WORD;\n \n   /* Account for space used by the callee floating point register saves.  */\n   for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n-    if (regs_ever_live[i]\n-\t|| (!TARGET_64BIT && regs_ever_live[i + 1]))\n+    if (df_regs_ever_live_p (i)\n+\t|| (!TARGET_64BIT && df_regs_ever_live_p (i + 1)))\n       {\n \tfreg_saved = 1;\n \n@@ -3562,7 +3562,7 @@ pa_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n      to output the assembler directives which denote the start\n      of a function.  */\n   fprintf (file, \"\\t.CALLINFO FRAME=\" HOST_WIDE_INT_PRINT_DEC, actual_fsize);\n-  if (regs_ever_live[2])\n+  if (df_regs_ever_live_p (2))\n     fputs (\",CALLS,SAVE_RP\", file);\n   else\n     fputs (\",NO_CALLS\", file);\n@@ -3626,7 +3626,7 @@ hppa_expand_prologue (void)\n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp - 20 or sp - 16\n      depending on which ABI is in use.  */\n-  if (regs_ever_live[2] || current_function_calls_eh_return)\n+  if (df_regs_ever_live_p (2) || current_function_calls_eh_return)\n     store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n@@ -3737,7 +3737,7 @@ hppa_expand_prologue (void)\n \t}\n \n       for (i = 18; i >= 4; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n \t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n@@ -3777,7 +3777,7 @@ hppa_expand_prologue (void)\n \t}\n \n       for (i = 18; i >= 3; i--)\n-      \tif (regs_ever_live[i] && ! call_used_regs[i])\n+      \tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n \t    /* If merge_sp_adjust_with_store is nonzero, then we can\n \t       optimize the first GR save.  */\n@@ -3840,8 +3840,8 @@ hppa_expand_prologue (void)\n       /* Now actually save the FP registers.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n-\t  if (regs_ever_live[i]\n-\t      || (! TARGET_64BIT && regs_ever_live[i + 1]))\n+\t  if (df_regs_ever_live_p (i)\n+\t      || (! TARGET_64BIT && df_regs_ever_live_p (i + 1)))\n \t    {\n \t      rtx addr, insn, reg;\n \t      addr = gen_rtx_MEM (DFmode, gen_rtx_POST_INC (DFmode, tmpreg));\n@@ -4029,7 +4029,7 @@ hppa_expand_epilogue (void)\n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n      be necessary even when we schedule the prologue and epilogue.  */\n-  if (regs_ever_live [2] || current_function_calls_eh_return)\n+  if (df_regs_ever_live_p (2) || current_function_calls_eh_return)\n     {\n       ret_off = TARGET_64BIT ? -16 : -20;\n       if (frame_pointer_needed)\n@@ -4071,7 +4071,7 @@ hppa_expand_epilogue (void)\n \t}\n \n       for (i = 18; i >= 4; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n \t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n@@ -4108,7 +4108,7 @@ hppa_expand_epilogue (void)\n \n       for (i = 18; i >= 3; i--)\n \t{\n-\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t    {\n \t      /* Only for the first load.\n \t         merge_sp_adjust_with_load holds the register load\n@@ -4138,8 +4138,8 @@ hppa_expand_epilogue (void)\n \n       /* Actually do the restores now.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n-\tif (regs_ever_live[i]\n-\t    || (! TARGET_64BIT && regs_ever_live[i + 1]))\n+\tif (df_regs_ever_live_p (i)\n+\t    || (! TARGET_64BIT && df_regs_ever_live_p (i + 1)))\n \t  {\n \t    rtx src = gen_rtx_MEM (DFmode, gen_rtx_POST_INC (DFmode, tmpreg));\n \t    rtx dest = gen_rtx_REG (DFmode, i);\n@@ -4414,7 +4414,7 @@ hppa_can_use_return_insn_p (void)\n {\n   return (reload_completed\n \t  && (compute_frame_size (get_frame_size (), 0) ? 0 : 1)\n-\t  && ! regs_ever_live[2]\n+\t  && ! df_regs_ever_live_p (2)\n \t  && ! frame_pointer_needed);\n }\n \n@@ -6256,7 +6256,7 @@ output_lbranch (rtx dest, rtx insn, int xdelay)\n      for other purposes.  */\n   if (TARGET_64BIT)\n     {\n-      if (actual_fsize == 0 && !regs_ever_live[2])\n+      if (actual_fsize == 0 && !df_regs_ever_live_p (2))\n \t/* Use the return pointer slot in the frame marker.  */\n \toutput_asm_insn (\"std %%r1,-16(%%r30)\", xoperands);\n       else\n@@ -6266,7 +6266,7 @@ output_lbranch (rtx dest, rtx insn, int xdelay)\n     }\n   else\n     {\n-      if (actual_fsize == 0 && !regs_ever_live[2])\n+      if (actual_fsize == 0 && !df_regs_ever_live_p (2))\n \t/* Use the return pointer slot in the frame marker.  */\n \toutput_asm_insn (\"stw %%r1,-20(%%r30)\", xoperands);\n       else\n@@ -6310,14 +6310,14 @@ output_lbranch (rtx dest, rtx insn, int xdelay)\n   /* Now restore the value of %r1 in the delay slot.  */\n   if (TARGET_64BIT)\n     {\n-      if (actual_fsize == 0 && !regs_ever_live[2])\n+      if (actual_fsize == 0 && !df_regs_ever_live_p (2))\n \treturn \"ldd -16(%%r30),%%r1\";\n       else\n \treturn \"ldd -40(%%r30),%%r1\";\n     }\n   else\n     {\n-      if (actual_fsize == 0 && !regs_ever_live[2])\n+      if (actual_fsize == 0 && !df_regs_ever_live_p (2))\n \treturn \"ldw -20(%%r30),%%r1\";\n       else\n \treturn \"ldw -12(%%r30),%%r1\";"}, {"sha": "b95dd8a0c375e35a79101276aee5ad859a5b6be1", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for the HP Spectrum.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) of Cygnus Support\n    and Tim Moore (moore@defmacro.cs.utah.edu) of the Center for\n    Software Science at the University of Utah.\n@@ -372,7 +372,7 @@ typedef struct machine_function GTY(())\n    is already live or already being saved (due to eh).  */\n \n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n-  ((NEW_REG) != 2 || regs_ever_live[2] || current_function_calls_eh_return)\n+  ((NEW_REG) != 2 || df_regs_ever_live_p (2) || current_function_calls_eh_return)\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue."}, {"sha": "d61e45e918ae5456dd55cce4952ddffcdcda8fba", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for gcc2 for pdp11.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n    Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n \n This file is part of GCC.\n@@ -291,7 +291,7 @@ pdp11_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \n     /* save CPU registers  */\n     for (regno = 0; regno < 8; regno++)\t\t\t\t\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\n+      if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\n \t    if (! ((regno == FRAME_POINTER_REGNUM)\t\t\t\n \t\t   && frame_pointer_needed))\t\t\t\t\n \t\tfprintf (stream, \"\\tmov %s, -(sp)\\n\", reg_names[regno]);\t\n@@ -304,7 +304,7 @@ pdp11_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n     {\n \t/* ac0 - ac3 */\t\t\t\t\t\t\n \tif (LOAD_FPU_REG_P(regno)\n-\t    && regs_ever_live[regno] \n+\t    && df_regs_ever_live_p (regno) \n \t    && ! call_used_regs[regno])\n \t{\n \t    fprintf (stream, \"\\tstd %s, -(sp)\\n\", reg_names[regno]);\n@@ -314,7 +314,7 @@ pdp11_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n \t/* maybe make ac4, ac5 call used regs?? */\n \t/* ac4 - ac5 */\n \tif (NO_LOAD_FPU_REG_P(regno)\n-\t    && regs_ever_live[regno]\n+\t    && df_regs_ever_live_p (regno)\n \t    && ! call_used_regs[regno])\n \t{\n \t  gcc_assert (via_ac != -1);\n@@ -373,25 +373,25 @@ pdp11_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n     if (frame_pointer_needed)\t\t\t\t\t\n     {\t\t\t\t\t\t\t\t\n \t/* hope this is safe - m68k does it also .... */\t\t\n-\tregs_ever_live[FRAME_POINTER_REGNUM] = 0;\t\t\t\n+      df_regs_ever_live_p (FRAME_POINTER_REGNUM) = 0;\t\t\t\n \t\t\t\t\t\t\t\t\n \tfor (i =7, j = 0 ; i >= 0 ; i--)\t\t\t\t\n-\t    if (regs_ever_live[i] && ! call_used_regs[i])\t\t\n+\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\t\t\n \t\tj++;\n \t\n \t/* remember # of pushed bytes for CPU regs */\n \tk = 2*j;\n \t\n \t/* change fp -> r5 due to the compile error on libgcc2.c */\n \tfor (i =7 ; i >= 0 ; i--)\t\t\t\t\t\n-\t    if (regs_ever_live[i] && ! call_used_regs[i])\t\t\n+\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\t\t\n \t\tfprintf(stream, \"\\tmov %#o(r5), %s\\n\",(-fsize-2*j--)&0xffff, reg_names[i]);\n \n \t/* get ACs */\t\t\t\t\t\t\n \tvia_ac = FIRST_PSEUDO_REGISTER -1;\n \t\n \tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n-\t    if (regs_ever_live[i] && ! call_used_regs[i])\n+\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t    {\n \t\tvia_ac = i;\n \t\tk += 8;\n@@ -400,15 +400,15 @@ pdp11_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n \t{\n \t    if (LOAD_FPU_REG_P(i)\n-\t\t&& regs_ever_live[i]\n+\t\t&& df_regs_ever_live_p (i)\n \t\t&& ! call_used_regs[i])\n \t    {\n \t\tfprintf(stream, \"\\tldd %#o(r5), %s\\n\", (-fsize-k)&0xffff, reg_names[i]);\n \t\tk -= 8;\n \t    }\n \t    \n \t    if (NO_LOAD_FPU_REG_P(i)\n-\t\t&& regs_ever_live[i]\n+\t\t&& df_regs_ever_live_p (i)\n \t\t&& ! call_used_regs[i])\n \t    {\n \t        gcc_assert (LOAD_FPU_REG_P(via_ac));\n@@ -428,18 +428,18 @@ pdp11_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t\n \t/* get ACs */\n \tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n-\t    if (regs_ever_live[i] && call_used_regs[i])\n+\t  if (df_regs_ever_live_p (i) && call_used_regs[i])\n \t\tvia_ac = i;\n \t\n \tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n \t{\n \t    if (LOAD_FPU_REG_P(i)\n-\t\t&& regs_ever_live[i]\n+\t\t&& df_regs_ever_live_p (i)\n \t\t&& ! call_used_regs[i])\n \t      fprintf(stream, \"\\tldd (sp)+, %s\\n\", reg_names[i]);\n \t    \n \t    if (NO_LOAD_FPU_REG_P(i)\n-\t\t&& regs_ever_live[i]\n+\t\t&& df_regs_ever_live_p (i)\n \t\t&& ! call_used_regs[i])\n \t    {\n \t        gcc_assert (LOAD_FPU_REG_P(via_ac));\n@@ -450,7 +450,7 @@ pdp11_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t}\n \n \tfor (i=7; i >= 0; i--)\t\t\t\t\t\n-\t    if (regs_ever_live[i] && !call_used_regs[i])\t\t\n+\t  if (df_regs_ever_live_p (i) && !call_used_regs[i])\t\t\n \t\tfprintf(stream, \"\\tmov (sp)+, %s\\n\", reg_names[i]);\t\n \t\t\t\t\t\t\t\t\n \tif (fsize)\t\t\t\t\t\t"}, {"sha": "4fa2a29b4f0569b45d50a77f4db75e55bd775671", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for the pdp-11\n-   Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n    Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n \n This file is part of GCC.\n@@ -566,10 +566,10 @@ extern int may_call_alloca;\n   int offset, regno;\t\t      \t\t\t\t\\\n   offset = get_frame_size();\t\t\t\t\t\\\n   for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\\\n       offset += 2;\t\t\t\t\t\t\\\n   for (regno = 8; regno < 14; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\\\n       offset += 8;\t\t\t\t\t\t\\\n   /* offset -= 2;   no fp on stack frame */\t\t\t\\\n   (DEPTH_VAR) = offset;\t\t\t\t\t\t\\"}, {"sha": "5f4b233cef9e88c5242f87ed1dbe9514b095a284", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for POWER and PowerPC.\n-;; Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -640,8 +640,8 @@\n        (match_operand 0 \"reg_or_mem_operand\")))\n \n ;; Return 1 if the operand is a general register or memory operand without\n-;; pre_inc or pre_dec, which produces invalid form of PowerPC lwa\n-;; instruction.\n+;; pre_inc or pre_dec or pre_modify, which produces invalid form of PowerPC\n+;; lwa instruction.\n (define_predicate \"lwa_operand\"\n   (match_code \"reg,subreg,mem\")\n {\n@@ -654,6 +654,8 @@\n     || (memory_operand (inner, mode)\n \t&& GET_CODE (XEXP (inner, 0)) != PRE_INC\n \t&& GET_CODE (XEXP (inner, 0)) != PRE_DEC\n+\t&& (GET_CODE (XEXP (inner, 0)) != PRE_MODIFY\n+\t    || legitimate_indexed_address_p (XEXP (XEXP (inner, 0), 1), 0))\n \t&& (GET_CODE (XEXP (inner, 0)) != PLUS\n \t    || GET_CODE (XEXP (XEXP (inner, 0), 1)) != CONST_INT\n \t    || INTVAL (XEXP (XEXP (inner, 0), 1)) % 4 == 0));"}, {"sha": "b821b01145be192e28e6005b7dada75909a13d38", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -42,6 +42,7 @@ extern bool invalid_e500_subreg (rtx, enum machine_mode);\n extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n extern bool legitimate_constant_pool_address_p (rtx);\n extern bool legitimate_indirect_address_p (rtx, int);\n+extern bool legitimate_indexed_address_p (rtx, int);\n \n extern rtx rs6000_got_register (rtx);\n extern rtx find_addr_reg (rtx);"}, {"sha": "910dae7398f5752ce30c6c06b595cc505433f1c8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 79, "deletions": 87, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -616,7 +616,6 @@ struct processor_costs power6_cost = {\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n static const char *rs6000_invalid_within_doloop (rtx);\n static rtx rs6000_generate_compare (enum rtx_code);\n-static void rs6000_maybe_dead (rtx);\n static void rs6000_emit_stack_tie (void);\n static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n static rtx spe_synthesize_frame_save (rtx);\n@@ -631,7 +630,6 @@ static int toc_hash_eq (const void *, const void *);\n static int constant_pool_expr_1 (rtx, int *, int *);\n static bool constant_pool_expr_p (rtx);\n static bool legitimate_small_data_p (enum machine_mode, rtx);\n-static bool legitimate_indexed_address_p (rtx, int);\n static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);\n static struct machine_function * rs6000_init_machine_status (void);\n static bool rs6000_assemble_integer (rtx, unsigned int, int);\n@@ -3098,7 +3096,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n   return (offset < 0x10000) && (offset + extra < 0x10000);\n }\n \n-static bool\n+bool\n legitimate_indexed_address_p (rtx x, int strict)\n {\n   rtx op0, op1;\n@@ -3459,10 +3457,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t\t  emit_insn (gen_addsi3 (tmp3, tmp1, tmp2));\n \t\t  last = emit_move_insn (got, tmp3);\n \t\t  set_unique_reg_note (last, REG_EQUAL, gsym);\n-\t\t  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n-\t\t\t\t\t\t\t REG_NOTES (first));\n-\t\t  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,\n-\t\t\t\t\t\t\tREG_NOTES (last));\n+\t\t  maybe_encapsulate_block (first, last, gsym);\n \t\t}\n \t    }\n \t}\n@@ -3832,6 +3827,24 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && (TARGET_POWERPC64 || mode != DImode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n+  if (GET_CODE (x) == PRE_MODIFY\n+      && mode != TImode\n+      && mode != TFmode\n+      && mode != TDmode\n+      && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t  || TARGET_POWERPC64\n+\t  || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n+      && (TARGET_POWERPC64 || mode != DImode)\n+      && !ALTIVEC_VECTOR_MODE (mode)\n+      && !SPE_VECTOR_MODE (mode)\n+      /* Restrict addressing for DI because of our SUBREG hackery.  */\n+      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == DImode))\n+      && TARGET_UPDATE\n+      && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict)\n+      && (rs6000_legitimate_offset_address_p (mode, XEXP (x, 1), reg_ok_strict)\n+\t  || legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict))\n+      && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n+    return 1;\n   if (legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n     return 1;\n   return 0;\n@@ -3864,7 +3877,10 @@ rs6000_mode_dependent_address (rtx addr)\n     case LO_SUM:\n       return true;\n \n-    /* Auto-increment cases are now treated generically in recog.c.  */\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case PRE_MODIFY:\n+      return TARGET_UPDATE;\n \n     default:\n       break;\n@@ -10465,8 +10481,8 @@ rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n   /* The second flow pass currently (June 1999) can't update\n      regs_ever_live without disturbing other parts of the compiler, so\n      update it here to make the prolog/epilogue code happy.  */\n-  if (no_new_pseudos && ! regs_ever_live[RS6000_PIC_OFFSET_TABLE_REGNUM])\n-    regs_ever_live[RS6000_PIC_OFFSET_TABLE_REGNUM] = 1;\n+  if (no_new_pseudos && ! df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))\n+    df_set_regs_ever_live (RS6000_PIC_OFFSET_TABLE_REGNUM, true);\n \n   current_function_uses_pic_offset_table = 1;\n \n@@ -10833,6 +10849,9 @@ print_operand (FILE *file, rtx x, int code)\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n \t    output_address (plus_constant (XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t   UNITS_PER_WORD));\n+\t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t   UNITS_PER_WORD));\n \t  else\n \t    output_address (XEXP (adjust_address_nv (x, SImode,\n \t\t\t\t\t\t     UNITS_PER_WORD),\n@@ -11033,7 +11052,8 @@ print_operand (FILE *file, rtx x, int code)\n       /* Print `u' if this has an auto-increment or auto-decrement.  */\n       if (GET_CODE (x) == MEM\n \t  && (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC))\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_MODIFY))\n \tputc ('u', file);\n       return;\n \n@@ -11120,7 +11140,9 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'X':\n       if (GET_CODE (x) == MEM\n-\t  && legitimate_indexed_address_p (XEXP (x, 0), 0))\n+\t  && (legitimate_indexed_address_p (XEXP (x, 0), 0)\n+\t      || (GET_CODE (XEXP (x, 0)) == PRE_MODIFY\n+\t\t  && legitimate_indexed_address_p (XEXP (XEXP (x, 0), 1), 0))))\n \tputc ('x', file);\n       return;\n \n@@ -11133,6 +11155,8 @@ print_operand (FILE *file, rtx x, int code)\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n \t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n+\t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n \t  else\n \t    output_address (XEXP (adjust_address_nv (x, SImode, 8), 0));\n \t  if (small_data_operand (x, GET_MODE (x)))\n@@ -11180,6 +11204,8 @@ print_operand (FILE *file, rtx x, int code)\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n \t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n+\t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n \t  else\n \t    output_address (XEXP (adjust_address_nv (x, SImode, 12), 0));\n \t  if (small_data_operand (x, GET_MODE (x)))\n@@ -11260,6 +11286,8 @@ print_operand (FILE *file, rtx x, int code)\n \t  else if (GET_CODE (XEXP (x, 0)) == PRE_DEC)\n \t    fprintf (file, \"%d(%s)\", - GET_MODE_SIZE (GET_MODE (x)),\n \t\t     reg_names[REGNO (XEXP (XEXP (x, 0), 0))]);\n+\t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n+\t    output_address (XEXP (XEXP (x, 0), 1));\n \t  else\n \t    output_address (XEXP (x, 0));\n \t}\n@@ -13120,7 +13148,7 @@ first_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (first_reg = 13; first_reg <= 31; first_reg++)\n-    if (regs_ever_live[first_reg]\n+    if (df_regs_ever_live_p (first_reg)\n \t&& (! call_used_regs[first_reg]\n \t    || (first_reg == RS6000_PIC_OFFSET_TABLE_REGNUM\n \t\t&& ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n@@ -13147,7 +13175,7 @@ first_fp_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (first_reg = 14 + 32; first_reg <= 63; first_reg++)\n-    if (regs_ever_live[first_reg])\n+    if (df_regs_ever_live_p (first_reg))\n       break;\n \n   return first_reg;\n@@ -13173,7 +13201,7 @@ first_altivec_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (i = FIRST_ALTIVEC_REGNO + 20; i <= LAST_ALTIVEC_REGNO; ++i)\n-    if (regs_ever_live[i])\n+    if (df_regs_ever_live_p (i))\n       break;\n \n   return i;\n@@ -13197,7 +13225,7 @@ compute_vrsave_mask (void)\n \n   /* First, find out if we use _any_ altivec registers.  */\n   for (i = FIRST_ALTIVEC_REGNO; i <= LAST_ALTIVEC_REGNO; ++i)\n-    if (regs_ever_live[i])\n+    if (df_regs_ever_live_p (i))\n       mask |= ALTIVEC_REG_BIT (i);\n \n   if (mask == 0)\n@@ -13458,13 +13486,13 @@ rs6000_stack_info (void)\n       || rs6000_ra_ever_killed ())\n     {\n       info_ptr->lr_save_p = 1;\n-      regs_ever_live[LINK_REGISTER_REGNUM] = 1;\n+      df_set_regs_ever_live (LINK_REGISTER_REGNUM, true);\n     }\n \n   /* Determine if we need to save the condition code registers.  */\n-  if (regs_ever_live[CR2_REGNO]\n-      || regs_ever_live[CR3_REGNO]\n-      || regs_ever_live[CR4_REGNO])\n+  if (df_regs_ever_live_p (CR2_REGNO)\n+      || df_regs_ever_live_p (CR3_REGNO)\n+      || df_regs_ever_live_p (CR4_REGNO))\n     {\n       info_ptr->cr_save_p = 1;\n       if (DEFAULT_ABI == ABI_V4)\n@@ -13988,23 +14016,14 @@ rs6000_ra_ever_killed (void)\n   return 0;\n }\n \f\n-/* Add a REG_MAYBE_DEAD note to the insn.  */\n-static void\n-rs6000_maybe_dead (rtx insn)\n-{\n-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\tconst0_rtx,\n-\t\t\t\t\tREG_NOTES (insn));\n-}\n-\n /* Emit instructions needed to load the TOC register.\n    This is only needed when TARGET_TOC, TARGET_MINIMAL_TOC, and there is\n    a constant pool; or for SVR4 -fpic.  */\n \n void\n rs6000_emit_load_toc_table (int fromprolog)\n {\n-  rtx dest, insn;\n+  rtx dest;\n   dest = gen_rtx_REG (Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n \n   if (TARGET_ELF && TARGET_SECURE_PLT && DEFAULT_ABI != ABI_AIX && flag_pic)\n@@ -14024,29 +14043,16 @@ rs6000_emit_load_toc_table (int fromprolog)\n \t  tmp1 = gen_reg_rtx (Pmode);\n \t  tmp2 = gen_reg_rtx (Pmode);\n \t}\n-      insn = emit_insn (gen_load_toc_v4_PIC_1 (lab));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n-      insn = emit_move_insn (tmp1,\n+      emit_insn (gen_load_toc_v4_PIC_1 (lab));\n+      emit_move_insn (tmp1,\n \t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n-      insn = emit_insn (gen_load_toc_v4_PIC_3b (tmp2, tmp1, got, lab));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n-      insn = emit_insn (gen_load_toc_v4_PIC_3c (dest, tmp2, got, lab));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n+      emit_insn (gen_load_toc_v4_PIC_3b (tmp2, tmp1, got, lab));\n+      emit_insn (gen_load_toc_v4_PIC_3c (dest, tmp2, got, lab));\n     }\n   else if (TARGET_ELF && DEFAULT_ABI == ABI_V4 && flag_pic == 1)\n     {\n-      insn = emit_insn (gen_load_toc_v4_pic_si ());\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n-      insn = emit_move_insn (dest,\n-\t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n+      emit_insn (gen_load_toc_v4_pic_si ());\n+      emit_move_insn (dest, gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n     }\n   else if (TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2)\n     {\n@@ -14065,13 +14071,10 @@ rs6000_emit_load_toc_table (int fromprolog)\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n \t  symL = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n \n-\t  rs6000_maybe_dead (emit_insn (gen_load_toc_v4_PIC_1 (symF)));\n-\t  rs6000_maybe_dead (emit_move_insn (dest,\n-\t\t\t\t\t     gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t\t  LINK_REGISTER_REGNUM)));\n-\t  rs6000_maybe_dead (emit_insn (gen_load_toc_v4_PIC_2 (temp0, dest,\n-\t\t\t\t\t\t\t       symL,\n-\t\t\t\t\t\t\t       symF)));\n+\t  emit_insn (gen_load_toc_v4_PIC_1 (symF));\n+\t  emit_move_insn (dest,\n+\t\t\t  gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t  emit_insn (gen_load_toc_v4_PIC_2 (temp0, dest, symL, symF));\n \t}\n       else\n \t{\n@@ -14083,9 +14086,7 @@ rs6000_emit_load_toc_table (int fromprolog)\n \t\t\t  gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n \t  emit_move_insn (temp0, gen_rtx_MEM (Pmode, dest));\n \t}\n-      insn = emit_insn (gen_addsi3 (dest, temp0, dest));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n+      emit_insn (gen_addsi3 (dest, temp0, dest));\n     }\n   else if (TARGET_ELF && !TARGET_AIX && flag_pic == 0 && TARGET_MINIMAL_TOC)\n     {\n@@ -14095,23 +14096,17 @@ rs6000_emit_load_toc_table (int fromprolog)\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n       realsym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n \n-      insn = emit_insn (gen_elf_high (dest, realsym));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n-      insn = emit_insn (gen_elf_low (dest, dest, realsym));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n+      emit_insn (gen_elf_high (dest, realsym));\n+      emit_insn (gen_elf_low (dest, dest, realsym));\n     }\n   else\n     {\n       gcc_assert (DEFAULT_ABI == ABI_AIX);\n \n       if (TARGET_32BIT)\n-\tinsn = emit_insn (gen_load_toc_aix_si (dest));\n+\temit_insn (gen_load_toc_aix_si (dest));\n       else\n-\tinsn = emit_insn (gen_load_toc_aix_di (dest));\n-      if (fromprolog)\n-\trs6000_maybe_dead (insn);\n+\temit_insn (gen_load_toc_aix_di (dest));\n     }\n }\n \n@@ -14198,7 +14193,7 @@ rtx\n create_TOC_reference (rtx symbol)\n {\n   if (no_new_pseudos)\n-    regs_ever_live[TOC_REGISTER] = 1;\n+    df_set_regs_ever_live (TOC_REGISTER, true);\n   return gen_rtx_PLUS (Pmode,\n \t   gen_rtx_REG (Pmode, TOC_REGISTER),\n \t     gen_rtx_CONST (Pmode,\n@@ -14641,7 +14636,7 @@ no_global_regs_above (int first_greg)\n static bool\n rs6000_reg_live_or_pic_offset_p (int reg)\n {\n-  return ((regs_ever_live[reg]\n+  return ((df_regs_ever_live_p (reg)\n            && (!call_used_regs[reg]\n                || (reg == RS6000_PIC_OFFSET_TABLE_REGNUM\n                    && TARGET_TOC && TARGET_MINIMAL_TOC)))\n@@ -14881,7 +14876,7 @@ rs6000_emit_prologue (void)\n     {\n       int i;\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-\tif ((regs_ever_live[info->first_fp_reg_save+i]\n+\tif ((df_regs_ever_live_p (info->first_fp_reg_save+i)\n \t     && ! call_used_regs[info->first_fp_reg_save+i]))\n \t  emit_frame_save (frame_reg_rtx, frame_ptr_rtx, DFmode,\n \t\t\t   info->first_fp_reg_save + i,\n@@ -14952,7 +14947,7 @@ rs6000_emit_prologue (void)\n        int i;\n        rtx spe_save_area_ptr;\n        int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n-                                   && regs_ever_live[STATIC_CHAIN_REGNUM]\n+                                   && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n                                    && !call_used_regs[STATIC_CHAIN_REGNUM]);\n  \n        /* Determine whether we can address all of the registers that need\n@@ -15206,7 +15201,7 @@ rs6000_emit_prologue (void)\n   if ((TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n       || (DEFAULT_ABI == ABI_V4\n \t  && (flag_pic == 1 || (flag_pic && TARGET_SECURE_PLT))\n-\t  && regs_ever_live[RS6000_PIC_OFFSET_TABLE_REGNUM]))\n+\t  && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM)))\n     {\n       /* If emit_load_toc_table will use the link register, we need to save\n \t it.  We use R12 for this purpose because emit_load_toc_table\n@@ -15222,13 +15217,11 @@ rs6000_emit_prologue (void)\n \t  rtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n \n \t  insn = emit_move_insn (frame_ptr_rtx, lr);\n-\t  rs6000_maybe_dead (insn);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n \t  rs6000_emit_load_toc_table (TRUE);\n \n \t  insn = emit_move_insn (lr, frame_ptr_rtx);\n-\t  rs6000_maybe_dead (insn);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else\n@@ -15244,17 +15237,16 @@ rs6000_emit_prologue (void)\n \n       /* Save and restore LR locally around this call (in R0).  */\n       if (!info->lr_save_p)\n-\trs6000_maybe_dead (emit_move_insn (gen_rtx_REG (Pmode, 0), lr));\n+\temit_move_insn (gen_rtx_REG (Pmode, 0), lr);\n \n-      rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (src)));\n+      emit_insn (gen_load_macho_picbase (src));\n \n-      insn = emit_move_insn (gen_rtx_REG (Pmode,\n-\t\t\t\t\t  RS6000_PIC_OFFSET_TABLE_REGNUM),\n-\t\t\t     lr);\n-      rs6000_maybe_dead (insn);\n+      emit_move_insn (gen_rtx_REG (Pmode,\n+\t\t\t\t   RS6000_PIC_OFFSET_TABLE_REGNUM),\n+\t\t      lr);\n \n       if (!info->lr_save_p)\n-\trs6000_maybe_dead (emit_move_insn (lr, gen_rtx_REG (Pmode, 0)));\n+\temit_move_insn (lr, gen_rtx_REG (Pmode, 0));\n     }\n #endif\n }\n@@ -15673,7 +15665,7 @@ rs6000_emit_epilogue (int sibcall)\n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-      if ((regs_ever_live[info->first_fp_reg_save+i]\n+      if ((df_regs_ever_live_p (info->first_fp_reg_save+i)\n \t   && ! call_used_regs[info->first_fp_reg_save+i]))\n \t{\n \t  rtx addr, mem;\n@@ -15697,7 +15689,7 @@ rs6000_emit_epilogue (int sibcall)\n       if (using_mtcr_multiple)\n \t{\n \t  for (i = 0; i < 8; i++)\n-\t    if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n+\t    if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n \t      count++;\n \t  gcc_assert (count);\n \t}\n@@ -15711,7 +15703,7 @@ rs6000_emit_epilogue (int sibcall)\n \n \t  ndx = 0;\n \t  for (i = 0; i < 8; i++)\n-\t    if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n+\t    if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n \t      {\n \t\trtvec r = rtvec_alloc (2);\n \t\tRTVEC_ELT (r, 0) = r12_rtx;\n@@ -15726,7 +15718,7 @@ rs6000_emit_epilogue (int sibcall)\n \t}\n       else\n \tfor (i = 0; i < 8; i++)\n-\t  if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n+\t  if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n \t    {\n \t      emit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode,\n \t\t\t\t\t\t\t   CR0_REGNO+i),"}, {"sha": "5082665af6e0fa5affc8c6d4a1a29b5a6f44a72b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -888,7 +888,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    emitted the vrsave mask.  */\n \n #define HARD_REGNO_RENAME_OK(SRC, DST) \\\n-  (! ALTIVEC_REGNO_P (DST) || regs_ever_live[DST])\n+  (! ALTIVEC_REGNO_P (DST) || df_regs_ever_live_p (DST))\n \n /* A C expression returning the cost of moving data from a register of class\n    CLASS1 to one of CLASS2.  */\n@@ -1598,6 +1598,8 @@ typedef struct rs6000_args\n \n #define HAVE_PRE_DECREMENT 1\n #define HAVE_PRE_INCREMENT 1\n+#define HAVE_PRE_MODIFY_DISP 1\n+#define HAVE_PRE_MODIFY_REG 1\n \n /* Macros to check register numbers against specific register classes.  */\n "}, {"sha": "e44570512af0b9ab62caf10fe8d5694a245dcce1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -8364,7 +8364,8 @@\n \t  || (GET_CODE (operands[1]) == MEM\n \t      && (GET_CODE (XEXP (operands[1], 0)) == LO_SUM\n \t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)))\n+\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC\n+\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_MODIFY)))\n \t{\n \t  /* If the low-address word is used in the address, we must load\n \t     it last.  Otherwise, load it first.  Note that we cannot have\n@@ -8374,7 +8375,7 @@\n \t\t\t\t operands[1], 0))\n \t    return \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n \t  else\n-\t    return \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n+\t    return \\\"{l%U1%X1|lwz%U1%X1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n \t}\n       else\n \t{\n@@ -8404,8 +8405,9 @@\n \t  || (GET_CODE (operands[0]) == MEM\n \t      && (GET_CODE (XEXP (operands[0], 0)) == LO_SUM\n \t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)))\n-\treturn \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)))\n+\treturn \\\"{st%U0%X0|stw%U0%X0} %1,%0\\;{st|stw} %L1,%L0\\\";\n       else\n \t{\n \t  rtx addreg;\n@@ -8461,9 +8463,9 @@\n \t\t\t     operands[1], 0))\n \treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n       else\n-\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n+\treturn \\\"{l%U1%X1|lwz%U1%X1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n     case 2:\n-      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+      return \\\"{st%U0%X0|stw%U0%X0} %1,%0\\;{st|stw} %L1,%L0\\\";\n     case 3:\n     case 4:\n     case 5:"}, {"sha": "a6524fc58b7efbe34ba87ddb5159be6f55d52424", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IBM S/390 and zSeries\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n+   2007 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n                   Ulrich Weigand (uweigand@de.ibm.com).\n \n@@ -51,6 +51,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"langhooks.h\"\n #include \"optabs.h\"\n #include \"tree-gimple.h\"\n+#include \"df.h\"\n \n \n /* Define the specific costs for a given cpu.  */\n@@ -2890,7 +2891,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n           rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n \t  if (reload_in_progress || reload_completed)\n-\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n           addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n           addr = gen_rtx_CONST (Pmode, addr);\n@@ -2916,7 +2917,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n              in both 31- and 64-bit code (@GOT).  */\n \n \t  if (reload_in_progress || reload_completed)\n-\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n           new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n           new = gen_rtx_CONST (Pmode, new);\n@@ -2948,7 +2949,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n           rtx temp = gen_reg_rtx (Pmode);\n \n \t  if (reload_in_progress || reload_completed)\n-\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n           addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n           addr = gen_rtx_CONST (Pmode, addr);\n@@ -2996,7 +2997,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n                         rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n \t\t\tif (reload_in_progress || reload_completed)\n-\t\t\t  regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t\t\t  df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n                         addr = XVECEXP (addr, 0, 0);\n                         addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n@@ -3076,7 +3077,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n                   rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n \t\t  if (reload_in_progress || reload_completed)\n-\t\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n                   addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0),\n \t\t\t\t\t UNSPEC_GOTOFF);\n@@ -3244,7 +3245,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t       in both 31- and 64-bit code.  */\n \n \t    if (reload_in_progress || reload_completed)\n-\t      regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t      df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n \t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n \t    new = gen_rtx_CONST (Pmode, new);\n@@ -3273,7 +3274,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t       from the literal pool.  */\n \n \t    if (reload_in_progress || reload_completed)\n-\t      regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t      df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n \t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n \t    new = gen_rtx_CONST (Pmode, new);\n@@ -6325,7 +6326,7 @@ find_unused_clobbered_reg (void)\n {\n   int i;\n   for (i = 0; i < 6; i++)\n-    if (!regs_ever_live[i])\n+    if (!df_regs_ever_live_p (i))\n       return i;\n   return 0;\n }\n@@ -6391,7 +6392,7 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n     for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM ; i++)\n       if (current_function_calls_eh_return \n \t  || (cfun->machine->has_landing_pad_p \n-\t      && regs_ever_live [EH_RETURN_DATA_REGNO (i)]))\n+\t      && df_regs_ever_live_p (EH_RETURN_DATA_REGNO (i))))\n \tregs_ever_clobbered[EH_RETURN_DATA_REGNO (i)] = 1;\n \n   /* For nonlocal gotos all call-saved registers have to be saved.\n@@ -6470,7 +6471,7 @@ s390_register_info (int clobbered_regs[])\n   cfun_frame_layout.high_fprs = 0;\n   if (TARGET_64BIT)\n     for (i = 24; i < 32; i++)\n-      if (regs_ever_live[i] && !global_regs[i])\n+      if (df_regs_ever_live_p (i) && !global_regs[i])\n \t{\n \t  cfun_set_fpr_bit (i - 16);\n \t  cfun_frame_layout.high_fprs++;\n@@ -6492,7 +6493,7 @@ s390_register_info (int clobbered_regs[])\n \n   if (flag_pic)\n     clobbered_regs[PIC_OFFSET_TABLE_REGNUM] \n-      |= regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n+      |= df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n \n   clobbered_regs[BASE_REGNUM] \n     |= (cfun->machine->base_reg\n@@ -6515,10 +6516,10 @@ s390_register_info (int clobbered_regs[])\n \t|| current_function_stdarg);\n \n   for (i = 6; i < 16; i++)\n-    if (regs_ever_live[i] || clobbered_regs[i])\n+    if (df_regs_ever_live_p (i) || clobbered_regs[i])\n       break;\n   for (j = 15; j > i; j--)\n-    if (regs_ever_live[j] || clobbered_regs[j])\n+    if (df_regs_ever_live_p (j) || clobbered_regs[j])\n       break;\n \n   if (i == 16)\n@@ -6612,7 +6613,7 @@ s390_register_info (int clobbered_regs[])\n \n   if (!TARGET_64BIT)\n     for (i = 2; i < 4; i++)\n-      if (regs_ever_live[i + 16] && !global_regs[i + 16])\n+      if (df_regs_ever_live_p (i + 16) && !global_regs[i + 16])\n \tcfun_set_fpr_bit (i);\n }\n \n@@ -6758,7 +6759,7 @@ s390_init_frame_layout (void)\n \t as base register to avoid save/restore overhead.  */\n       if (!base_used)\n \tcfun->machine->base_reg = NULL_RTX;\n-      else if (current_function_is_leaf && !regs_ever_live[5])\n+      else if (current_function_is_leaf && !df_regs_ever_live_p (5))\n \tcfun->machine->base_reg = gen_rtx_REG (Pmode, 5);\n       else\n \tcfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGNUM);\n@@ -6781,12 +6782,15 @@ s390_update_frame_layout (void)\n \n   s390_register_info (clobbered_regs);\n \n-  regs_ever_live[BASE_REGNUM] = clobbered_regs[BASE_REGNUM];\n-  regs_ever_live[RETURN_REGNUM] = clobbered_regs[RETURN_REGNUM];\n-  regs_ever_live[STACK_POINTER_REGNUM] = clobbered_regs[STACK_POINTER_REGNUM];\n+  df_set_regs_ever_live (BASE_REGNUM, \n+\t\t\t clobbered_regs[BASE_REGNUM] ? true : false);\n+  df_set_regs_ever_live (RETURN_REGNUM, \n+\t\t\t clobbered_regs[RETURN_REGNUM] ? true : false);\n+  df_set_regs_ever_live (STACK_POINTER_REGNUM, \n+\t\t\t clobbered_regs[STACK_POINTER_REGNUM] ? true : false);\n \n   if (cfun->machine->base_reg)\n-    regs_ever_live[REGNO (cfun->machine->base_reg)] = 1;\n+    df_set_regs_ever_live (REGNO (cfun->machine->base_reg), true);\n }\n \n /* Return true if it is legal to put a value with MODE into REGNO.  */\n@@ -7169,7 +7173,10 @@ s390_emit_prologue (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n-      annotate_constant_pool_refs (&PATTERN (insn));\n+      {\n+\tannotate_constant_pool_refs (&PATTERN (insn));\n+\tdf_insn_rescan (insn);\n+      }\n \n   pop_topmost_sequence ();\n \n@@ -7407,17 +7414,12 @@ s390_emit_prologue (void)\n \n   /* Set up got pointer, if needed.  */\n \n-  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n     {\n       rtx insns = s390_load_got ();\n \n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  annotate_constant_pool_refs (&PATTERN (insn));\n-\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-\t\t\t\t\t\tREG_NOTES (insn));\n-\t}\n+\tannotate_constant_pool_refs (&PATTERN (insn));\n \n       emit_insn (insns);\n     }"}, {"sha": "cb77082e0d3088ae1f17f2cabeee8b821dd67cb5", "filename": "gcc/config/score/score-mdaux.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* score-mdaux.c for Sunplus S+CORE processor\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Sunnorth\n \n    This file is part of GCC.\n@@ -126,7 +126,7 @@ static int\n score_save_reg_p (unsigned int regno)\n {\n   /* Check call-saved registers.  */\n-  if (regs_ever_live[regno] && !call_used_regs[regno])\n+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n     return 1;\n \n   /* We need to save the old frame pointer before setting up a new one.  */\n@@ -135,7 +135,7 @@ score_save_reg_p (unsigned int regno)\n \n   /* We need to save the incoming return address if it is ever clobbered\n      within the function.  */\n-  if (regno == RA_REGNUM && regs_ever_live[regno])\n+  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n     return 1;\n \n   return 0;"}, {"sha": "4ca2d5c1a81f933a812ea622aeafe613ac4155e1", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 119, "deletions": 114, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Output routines for GCC for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -47,6 +47,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"real.h\"\n #include \"langhooks.h\"\n #include \"basic-block.h\"\n+#include \"df.h\"\n #include \"cfglayout.h\"\n #include \"intl.h\"\n #include \"sched-int.h\"\n@@ -88,6 +89,9 @@ static short *regmode_weight[2];\n /* Total SFmode and SImode weights of scheduled insns.  */\n static int curr_regmode_pressure[2];\n \n+/* Number of r0 life regions.  */\n+static int r0_life_regions;\n+\n /* If true, skip cycles for Q -> R movement.  */\n static int skip_cycles = 0;\n \n@@ -195,6 +199,7 @@ static int sh_dfa_new_cycle (FILE *, int, rtx, int, int, int *sort_p);\n static short find_set_regmode_weight (rtx, enum machine_mode);\n static short find_insn_regmode_weight (rtx, enum machine_mode);\n static void find_regmode_weight (basic_block, enum machine_mode);\n+static int find_r0_life_regions (basic_block);\n static void  sh_md_init_global (FILE *, int, int);\n static void  sh_md_finish_global (FILE *, int);\n static int rank_for_reorder (const void *, const void *);\n@@ -4757,51 +4762,25 @@ sh_reorg (void)\n \t  if (GET_CODE (reg) != REG)\n \t    continue;\n \n-\t  /* This is a function call via REG.  If the only uses of REG\n-\t     between the time that it is set and the time that it dies\n-\t     are in function calls, then we can associate all the\n-\t     function calls with the setting of REG.  */\n-\n-\t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\t    {\n-\t      rtx linked_insn;\n-\n-\t      if (REG_NOTE_KIND (link) != 0)\n-\t\tcontinue;\n-\t      linked_insn = XEXP (link, 0);\n-\t      set = single_set (linked_insn);\n-\t      if (set\n-\t\t  && rtx_equal_p (reg, SET_DEST (set))\n-\t\t  && ! INSN_DELETED_P (linked_insn))\n-\t\t{\n-\t\t  link = linked_insn;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (! link)\n+\t  /* Try scanning backward to find where the register is set.  */\n+\t  link = NULL;\n+\t  for (scan = PREV_INSN (insn);\n+\t       scan && GET_CODE (scan) != CODE_LABEL;\n+\t       scan = PREV_INSN (scan))\n \t    {\n-\t      /* ??? Sometimes global register allocation will have\n-                 deleted the insn pointed to by LOG_LINKS.  Try\n-                 scanning backward to find where the register is set.  */\n-\t      for (scan = PREV_INSN (insn);\n-\t\t   scan && GET_CODE (scan) != CODE_LABEL;\n-\t\t   scan = PREV_INSN (scan))\n-\t\t{\n-\t\t  if (! INSN_P (scan))\n-\t\t    continue;\n+\t      if (! INSN_P (scan))\n+\t        continue;\n \n-\t\t  if (! reg_mentioned_p (reg, scan))\n-\t\t    continue;\n+\t      if (! reg_mentioned_p (reg, scan))\n+\t        continue;\n \n-\t\t  if (noncall_uses_reg (reg, scan, &set))\n-\t\t    break;\n+\t      if (noncall_uses_reg (reg, scan, &set))\n+\t        break;\n \n-\t\t  if (set)\n-\t\t    {\n-\t\t      link = scan;\n-\t\t      break;\n-\t\t    }\n+\t      if (set)\n+\t\t{\n+\t\t  link = scan;\n+\t\t  break;\n \t\t}\n \t    }\n \n@@ -4833,7 +4812,7 @@ sh_reorg (void)\n \n \t      /* Don't try to trace forward past a CODE_LABEL if we haven't\n \t\t seen INSN yet.  Ordinarily, we will only find the setting insn\n-\t\t in LOG_LINKS if it is in the same basic block.  However,\n+\t\t if it is in the same basic block.  However,\n \t\t cross-jumping can insert code labels in between the load and\n \t\t the call, and can result in situations where a single call\n \t\t insn may have two targets depending on where we came from.  */\n@@ -4880,11 +4859,8 @@ sh_reorg (void)\n \t\t later insn.  */\n \n \t      /* ??? We shouldn't have to use FOUNDINSN here.\n-\t\t However, the LOG_LINKS fields are apparently not\n-\t\t entirely reliable around libcalls;\n-\t\t newlib/libm/math/e_pow.c is a test case.  Sometimes\n-\t\t an insn will appear in LOG_LINKS even though it is\n-\t\t not the most recent insn which sets the register.  */\n+\t\t This dates back to when we used LOG_LINKS to find \n+\t\t the most recent insn which sets the register.  */\n \n \t      if (foundinsn\n \t\t  && (scanset\n@@ -5849,12 +5825,12 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \n   CLEAR_HARD_REG_SET (*live_regs_mask);\n   if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && interrupt_handler\n-      && regs_ever_live[FPSCR_REG])\n+      && df_regs_ever_live_p (FPSCR_REG))\n     target_flags &= ~MASK_FPU_SINGLE;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n   else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n-      if (regs_ever_live[reg] && regs_ever_live[reg+1]\n+      if (df_regs_ever_live_p (reg) && df_regs_ever_live_p (reg+1)\n \t  && (! call_really_used_regs[reg]\n \t      || interrupt_handler)\n \t  && ++count > 2)\n@@ -5876,11 +5852,11 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n       pr_live = (pr_initial\n \t\t ? (GET_CODE (pr_initial) != REG\n \t\t    || REGNO (pr_initial) != (PR_REG))\n-\t\t : regs_ever_live[PR_REG]);\n+\t\t : df_regs_ever_live_p (PR_REG));\n       /* For Shcompact, if not optimizing, we end up with a memory reference\n \t using the return address pointer for __builtin_return_address even\n \t though there is no actual need to put the PR register on the stack.  */\n-      pr_live |= regs_ever_live[RETURN_ADDRESS_POINTER_REGNUM];\n+      pr_live |= df_regs_ever_live_p (RETURN_ADDRESS_POINTER_REGNUM);\n     }\n   /* Force PR to be live if the prologue has to call the SHmedia\n      argument decoder or register saver.  */\n@@ -5896,7 +5872,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t  ? pr_live\n \t  : interrupt_handler\n \t  ? (/* Need to save all the regs ever live.  */\n-\t     (regs_ever_live[reg]\n+\t     (df_regs_ever_live_p (reg)\n \t      || (call_really_used_regs[reg]\n \t\t  && (! fixed_regs[reg] || reg == MACH_REG || reg == MACL_REG\n \t\t      || reg == PIC_OFFSET_TABLE_REGNUM)\n@@ -5914,7 +5890,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t      && flag_pic\n \t      && current_function_args_info.call_cookie\n \t      && reg == PIC_OFFSET_TABLE_REGNUM)\n-\t     || (regs_ever_live[reg]\n+\t     || (df_regs_ever_live_p (reg)\n \t\t && (!call_really_used_regs[reg]\n \t\t     || (trapa_handler && reg == FPSCR_REG && TARGET_FPU_ANY)))\n \t     || (current_function_calls_eh_return\n@@ -5923,7 +5899,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t\t     || reg == EH_RETURN_DATA_REGNO (2)\n \t\t     || reg == EH_RETURN_DATA_REGNO (3)))\n \t     || ((reg == MACL_REG || reg == MACH_REG)\n-\t\t && regs_ever_live[reg]\n+\t\t && df_regs_ever_live_p (reg)\n \t\t && sh_cfun_attr_renesas_p ())\n \t     ))\n \t{\n@@ -5935,7 +5911,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t    {\n \t      if (FP_REGISTER_P (reg))\n \t\t{\n-\t\t  if (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n+\t\t  if (! TARGET_FPU_SINGLE && ! df_regs_ever_live_p (reg ^ 1))\n \t\t    {\n \t\t      SET_HARD_REG_BIT (*live_regs_mask, (reg ^ 1));\n \t\t      count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg ^ 1));\n@@ -6012,10 +5988,10 @@ sh_media_register_for_return (void)\n   if (sh_cfun_interrupt_handler_p ())\n     return -1;\n \n-  tr0_used = flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n+  tr0_used = flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n \n   for (regno = FIRST_TARGET_REG + tr0_used; regno <= LAST_TARGET_REG; regno++)\n-    if (call_really_used_regs[regno] && ! regs_ever_live[regno])\n+    if (call_really_used_regs[regno] && ! df_regs_ever_live_p (regno))\n       return regno;\n \n   return -1;\n@@ -6174,7 +6150,7 @@ sh_expand_prologue (void)\n        incoming-argument decoder and/or of the return trampoline from\n        the GOT, so make sure the PIC register is preserved and\n        initialized.  */\n-    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n   if (TARGET_SHCOMPACT\n       && (current_function_args_info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n@@ -6207,19 +6183,8 @@ sh_expand_prologue (void)\n       int tr = sh_media_register_for_return ();\n \n       if (tr >= 0)\n-\t{\n-\t  rtx insn = emit_move_insn (gen_rtx_REG (DImode, tr),\n-\t\t\t\t     gen_rtx_REG (DImode, PR_MEDIA_REG));\n-\n-\t  /* ??? We should suppress saving pr when we don't need it, but this\n-\t     is tricky because of builtin_return_address.  */\n-\n-\t  /* If this function only exits with sibcalls, this copy\n-\t     will be flagged as dead.  */\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\t\tconst0_rtx,\n-\t\t\t\t\t\tREG_NOTES (insn));\n-\t}\n+\temit_move_insn (gen_rtx_REG (DImode, tr),\n+\t\t\tgen_rtx_REG (DImode, PR_MEDIA_REG));\n     }\n \n   /* Emit the code for SETUP_VARARGS.  */\n@@ -6467,24 +6432,8 @@ sh_expand_prologue (void)\n   else\n     push_regs (&live_regs_mask, current_function_interrupt);\n \n-  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    {\n-      rtx insn = get_last_insn ();\n-      rtx last = emit_insn (gen_GOTaddr2picreg ());\n-\n-      /* Mark these insns as possibly dead.  Sometimes, flow2 may\n-\t delete all uses of the PIC register.  In this case, let it\n-\t delete the initialization too.  */\n-      do\n-\t{\n-\t  insn = NEXT_INSN (insn);\n-\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\t\tconst0_rtx,\n-\t\t\t\t\t\tREG_NOTES (insn));\n-\t}\n-      while (insn != last);\n-    }\n+  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n+    emit_insn (gen_GOTaddr2picreg ());\n \n   if (SHMEDIA_REGS_STACK_ADJUST ())\n     {\n@@ -6499,16 +6448,7 @@ sh_expand_prologue (void)\n     }\n \n   if (target_flags != save_flags && ! current_function_interrupt)\n-    {\n-      rtx insn = emit_insn (gen_toggle_sz ());\n-\n-      /* If we're lucky, a mode switch in the function body will\n-\t overwrite fpscr, turning this insn dead.  Tell flow this\n-\t insn is ok to delete.  */\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\t    const0_rtx,\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n+    emit_insn (gen_toggle_sz ());\n \n   target_flags = save_flags;\n \n@@ -6729,11 +6669,6 @@ sh_expand_epilogue (bool sibcall_p)\n \t    }\n \n \t  insn = emit_move_insn (reg_rtx, mem_rtx);\n-\t  if (reg == PR_MEDIA_REG && sh_media_register_for_return () >= 0)\n-\t    /* This is dead, unless we return with a sibcall.  */\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-\t\t\t\t\t\t  const0_rtx,\n-\t\t\t\t\t\t  REG_NOTES (insn));\n \t}\n \n       gcc_assert (entry->offset + offset_base == d + d_rounding);\n@@ -6742,7 +6677,11 @@ sh_expand_epilogue (bool sibcall_p)\n     {\n       save_size = 0;\n       if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n-\tpop (PR_REG);\n+\t{\n+\t  if (!frame_pointer_needed)\n+\t    emit_insn (gen_blockage ());\n+\t  pop (PR_REG);\n+\t}\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n \t  int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n@@ -8799,7 +8738,7 @@ sh_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n      saved by the prologue, even if they would normally be\n      call-clobbered.  */\n \n-  if (sh_cfun_interrupt_handler_p () && !regs_ever_live[new_reg])\n+  if (sh_cfun_interrupt_handler_p () && !df_regs_ever_live_p (new_reg))\n     return 0;\n \n   return 1;\n@@ -9039,7 +8978,7 @@ flow_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n static int\n sh_pr_n_sets (void)\n {\n-  return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n+  return DF_REG_DEF_COUNT (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n /* Return where to allocate pseudo for a given hard register initial\n@@ -9206,6 +9145,56 @@ ready_reorder (rtx *ready, int nready)\n   SCHED_REORDER (ready, nready);\n }\n \n+/* Count life regions of r0 for a block.  */\n+static int\n+find_r0_life_regions (basic_block b)\n+{\n+  rtx end, insn;\n+  rtx pset;\n+  rtx r0_reg;\n+  int live;\n+  int set;\n+  int death = 0;\n+\n+  if (REGNO_REG_SET_P (DF_LIVE_IN (b), R0_REG))\n+    {\n+      set = 1;\n+      live = 1;\n+    }\n+  else\n+    {\n+      set = 0;\n+      live = 0;\n+    }\n+\n+  insn = BB_HEAD (b);\n+  end = BB_END (b);\n+  r0_reg = gen_rtx_REG (SImode, R0_REG);\n+  while (1)\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  if (find_regno_note (insn, REG_DEAD, R0_REG))\n+\t    {\n+\t      death++;\n+\t      live = 0;\n+\t    }\n+\t  if (!live\n+\t      && (pset = single_set (insn))\n+\t      && reg_overlap_mentioned_p (r0_reg, SET_DEST (pset))\n+\t      && !find_regno_note (insn, REG_UNUSED, R0_REG))\n+\t    {\n+\t      set++;\n+\t      live = 1;\n+\t    }\n+\t}\n+      if (insn == end)\n+\tbreak;\n+      insn = NEXT_INSN (insn);\n+    }\n+  return set - death;\n+}\n+\n /* Calculate regmode weights for all insns of all basic block.  */\n static void\n sh_md_init_global (FILE *dump ATTRIBUTE_UNUSED,\n@@ -9216,11 +9205,14 @@ sh_md_init_global (FILE *dump ATTRIBUTE_UNUSED,\n \n   regmode_weight[0] = (short *) xcalloc (old_max_uid, sizeof (short));\n   regmode_weight[1] = (short *) xcalloc (old_max_uid, sizeof (short));\n+  r0_life_regions = 0;\n \n   FOR_EACH_BB_REVERSE (b)\n   {\n     find_regmode_weight (b, SImode);\n     find_regmode_weight (b, SFmode);\n+    if (!reload_completed)\n+      r0_life_regions += find_r0_life_regions (b);\n   }\n \n   CURR_REGMODE_PRESSURE (SImode) = 0;\n@@ -9281,7 +9273,6 @@ sh_md_init (FILE *dump ATTRIBUTE_UNUSED,\n /* Pressure on register r0 can lead to spill failures. so avoid sched1 for\n    functions that already have high pressure on r0. */\n #define R0_MAX_LIFE_REGIONS 2\n-#define R0_MAX_LIVE_LENGTH 12\n /* Register Pressure thresholds for SImode and SFmode registers.  */\n #define SIMODE_MAX_WEIGHT 5\n #define SFMODE_MAX_WEIGHT 10\n@@ -9292,9 +9283,8 @@ high_pressure (enum machine_mode mode)\n {\n   /* Pressure on register r0 can lead to spill failures. so avoid sched1 for\n      functions that already have high pressure on r0. */\n-  if ((REG_N_SETS (0) - REG_N_DEATHS (0)) >= R0_MAX_LIFE_REGIONS\n-      && REG_LIVE_LENGTH (0) >= R0_MAX_LIVE_LENGTH)\n-    return 1;\n+   if (r0_life_regions >= R0_MAX_LIFE_REGIONS)\n+     return 1;\n \n   if (mode == SFmode)\n     return (CURR_REGMODE_PRESSURE (SFmode) > SFMODE_MAX_WEIGHT);\n@@ -10275,6 +10265,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   insn_locators_alloc ();\n   insns = get_insns ();\n \n+#if 0\n   if (optimize > 0)\n     {\n       /* Initialize the bitmap obstacks.  */\n@@ -10301,6 +10292,14 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       else if (flag_pic)\n \tsplit_all_insns_noflow ();\n     }\n+#else\n+  if (optimize > 0)\n+    {\n+      if (! cfun->cfg)\n+\tinit_flow ();\n+      split_all_insns_noflow ();\n+    }\n+#endif\n \n   sh_reorg ();\n \n@@ -10312,15 +10311,21 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   final (insns, file, 1);\n   final_end_function ();\n \n+#if 0\n   if (optimize > 0)\n     {\n-      /* Release all memory allocated by flow.  */\n-      free_basic_block_vars ();\n+      /* Release all memory allocated by df.  */\n+      if (rtl_df)\n+\t{\n+\t  df_finish (rtl_df);\n+\t  rtl_df = NULL;\n+\t}\n \n       /* Release the bitmap obstacks.  */\n       bitmap_obstack_release (&reg_obstack);\n       bitmap_obstack_release (NULL);\n     }\n+#endif\n \n   reload_completed = 0;\n   epilogue_completed = 0;"}, {"sha": "e85470eae741284c210649da9e4ddd9800fed745", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 198, "deletions": 18, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for Renesas / SuperH SH.\n ;;  Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-;;  2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+;;  2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n ;;  Contributed by Steve Chamberlain (sac@cygnus.com).\n ;;  Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -135,7 +135,6 @@\n   (UNSPEC_FSINA\t\t16)\n   (UNSPEC_NSB\t\t17)\n   (UNSPEC_ALLOCO\t18)\n-  (UNSPEC_EH_RETURN\t19)\n   (UNSPEC_TLSGD\t\t20)\n   (UNSPEC_TLSLDM\t21)\n   (UNSPEC_TLSIE\t\t22)\n@@ -163,6 +162,7 @@\n   (UNSPECV_CONST8\t6)\n   (UNSPECV_WINDOW_END\t10)\n   (UNSPECV_CONST_END\t11)\n+  (UNSPECV_EH_RETURN\t12)\n ])\n \n ;; -------------------------------------------------------------------------\n@@ -8110,15 +8110,197 @@ label:\n   DONE;\n }\")\n \n-(define_expand \"sibcall_value\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand 1 \"\" \"\")\n+(define_insn \"sibcall_valuei\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"k\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:PSI FPSCR_REG))\n+   (return)]\n+  \"TARGET_SH1\"\n+  \"jmp\t@%1%#\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcall_valuei_pcrel\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"k\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (use (reg:PSI FPSCR_REG))\n+   (return)]\n+  \"TARGET_SH2\"\n+  \"braf\t%1\\\\n%O3:%#\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn_and_split \"sibcall_value_pcrel\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"\"))\n \t      (match_operand 2 \"\" \"\")))\n-   (match_operand 3 \"\" \"\")]\n+   (use (reg:PSI FPSCR_REG))\n+   (clobber (match_scratch:SI 3 \"=k\"))\n+   (return)]\n+  \"TARGET_SH2\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx lab = PATTERN (gen_call_site ());\n+  rtx call_insn;\n+\n+  emit_insn (gen_sym_label2reg (operands[3], operands[1], lab));\n+  call_insn = emit_call_insn (gen_sibcall_valuei_pcrel (operands[0],\n+\t\t\t\t\t\t\toperands[3],\n+\t\t\t\t\t\t\toperands[2],\n+\t\t\t\t\t\t\tcopy_rtx (lab)));\n+  SIBLING_CALL_P (call_insn) = 1;\n+  DONE;\n+}\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcall_value_compact\"\n+  [(set (match_operand 0 \"\" \"=rf,rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"k,k\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (return)\n+   (use (match_operand:SI 3 \"register_operand\" \"z,x\"))\n+   (use (reg:SI R1_REG))\n+   (use (reg:PSI FPSCR_REG))\n+   ;; We want to make sure the `x' above will only match MACH_REG\n+   ;; because sibcall_epilogue may clobber MACL_REG.\n+   (clobber (reg:SI MACL_REG))]\n+  \"TARGET_SHCOMPACT\"\n+  \"@\n+\tjmp\t@%1%#\n+\tjmp\t@%1\\\\n\tsts\t%3, r0\"\n+  [(set_attr \"needs_delay_slot\" \"yes,no\")\n+   (set_attr \"length\" \"2,4\")\n+   (set (attr \"fp_mode\") (const_string \"single\"))\n+   (set_attr \"type\" \"jump_ind\")])\n+\n+(define_insn \"sibcall_value_media\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:DI (match_operand 1 \"target_reg_operand\" \"k\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:SI PR_MEDIA_REG))\n+   (return)]\n+  \"TARGET_SHMEDIA\"\n+  \"blink\t%1, r63\"\n+  [(set_attr \"type\" \"jump_media\")])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel\n+    [(set (match_operand 0 \"arith_reg_operand\" \"\")\n+\t  (call (mem:SI (match_operand 1 \"arith_reg_operand\" \"\"))\n+\t  \t(match_operand 2 \"\" \"\")))\n+     (match_operand 3 \"\" \"\")\n+     (use (reg:PSI FPSCR_REG))\n+     (return)])]\n   \"\"\n   \"\n {\n-  emit_call_insn (gen_sibcall (operands[1], operands[2], operands[3]));\n+  if (TARGET_SHMEDIA)\n+    {\n+      operands[1] = shmedia_prepare_call_address (operands[1], 1);\n+      emit_call_insn (gen_sibcall_value_media (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+      DONE;\n+    }\n+  else if (TARGET_SHCOMPACT && operands[3]\n+\t   && (INTVAL (operands[3]) & ~ CALL_COOKIE_RET_TRAMP (1)))\n+    {\n+      rtx cookie_rtx = operands[3];\n+      long cookie = INTVAL (cookie_rtx);\n+      rtx func = XEXP (operands[1], 0);\n+      rtx mach, r1;\n+\n+      if (flag_pic)\n+\t{\n+\t  if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n+\t    {\n+\t      rtx reg = gen_reg_rtx (Pmode);\n+\n+\t      emit_insn (gen_symGOT2reg (reg, func));\n+\t      func = reg;\n+\t    }\n+\t  else\n+\t    func = legitimize_pic_address (func, Pmode, 0);\n+\t}\n+\n+      /* FIXME: if we could tell whether all argument registers are\n+\t already taken, we could decide whether to force the use of\n+\t MACH_REG or to stick to R0_REG.  Unfortunately, there's no\n+\t simple way to tell.  We could use the CALL_COOKIE, but we\n+\t can't currently tell a register used for regular argument\n+\t passing from one that is unused.  If we leave it up to reload\n+\t to decide which register to use, it seems to always choose\n+\t R0_REG, which leaves no available registers in SIBCALL_REGS\n+\t to hold the address of the trampoline.  */\n+      mach = gen_rtx_REG (SImode, MACH_REG);\n+      r1 = gen_rtx_REG (SImode, R1_REG);\n+\n+      /* Since such a call function may use all call-clobbered\n+\t registers, we force a mode switch earlier, so that we don't\n+\t run out of registers when adjusting fpscr for the call.  */\n+      emit_insn (gen_force_mode_for_call ());\n+\n+      operands[1]\n+\t= function_symbol (NULL, \\\"__GCC_shcompact_call_trampoline\\\",\n+\t\t\t   SFUNC_GOT);\n+      operands[1] = force_reg (SImode, operands[1]);\n+\n+      /* We don't need a return trampoline, since the callee will\n+\t return directly to the upper caller.  */\n+      if (cookie & CALL_COOKIE_RET_TRAMP (1))\n+\t{\n+\t  cookie &= ~ CALL_COOKIE_RET_TRAMP (1);\n+\t  cookie_rtx = GEN_INT (cookie);\n+\t}\n+\n+      emit_move_insn (mach, func);\n+      emit_move_insn (r1, cookie_rtx);\n+\n+      emit_call_insn (gen_sibcall_value_compact (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2], mach));\n+      DONE;\n+    }\n+  else if (TARGET_SHCOMPACT && flag_pic\n+\t   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+\t   && ! SYMBOL_REF_LOCAL_P (XEXP (operands[1], 0)))\n+    {\n+      rtx reg = gen_reg_rtx (Pmode);\n+\n+      emit_insn (gen_symGOT2reg (reg, XEXP (operands[1], 0)));\n+      XEXP (operands[1], 0) = reg;\n+    }\n+  if (flag_pic && TARGET_SH2\n+      && GET_CODE (operands[1]) == MEM\n+      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+      /* The PLT needs the PIC register, but the epilogue would have\n+\t to restore it, so we can only use PC-relative PIC calls for\n+\t static functions.  */\n+      && SYMBOL_REF_LOCAL_P (XEXP (operands[1], 0)))\n+    {\n+      emit_call_insn (gen_sibcall_value_pcrel (operands[0],\n+\t\t\t\t\t       XEXP (operands[1], 0),\n+\t\t\t\t\t       operands[2]));\n+      DONE;\n+    }\n+  else\n+    operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n+\n+  emit_call_insn (gen_sibcall_valuei (operands[0], operands[1], operands[2]));\n   DONE;\n }\")\n \n@@ -8239,19 +8421,14 @@ label:\n \t  {\n \t    rtx r0 = gen_rtx_REG (SImode, R0_REG);\n \t    rtx tmp = gen_rtx_REG (SImode, MACL_REG);\n-\t    rtx i;\n \n \t    /* We can't tell at this point whether the sibcall is a\n \t       sibcall_compact and, if it is, whether it uses r0 or\n \t       mach as operand 2, so let the instructions that\n \t       preserve r0 be optimized away if r0 turns out to be\n \t       dead.  */\n-\t    i = emit_insn_before (gen_rtx_SET (SImode, tmp, r0), insn);\n-\t    REG_NOTES (i) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t       REG_NOTES (i));\n-\t    i = emit_move_insn (r0, tmp);\n-\t    REG_NOTES (i) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t       REG_NOTES (i));\n+\t    emit_insn_before (gen_rtx_SET (SImode, tmp, r0), insn);\n+\t    emit_move_insn (r0, tmp);\n \t    break;\n \t  }\n     }\n@@ -9226,19 +9403,22 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; until we know where it will be put in the stack frame.\n \n (define_insn \"eh_set_ra_si\"\n-  [(unspec [(match_operand:SI 0 \"register_operand\" \"r\")] UNSPEC_EH_RETURN)\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")]\n+      UNSPECV_EH_RETURN)\n    (clobber (match_scratch:SI 1 \"=&r\"))]\n   \"! TARGET_SHMEDIA64\"\n   \"#\")\n \n (define_insn \"eh_set_ra_di\"\n-  [(unspec [(match_operand:DI 0 \"register_operand\" \"r\")] UNSPEC_EH_RETURN)\n+  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"r\")]\n+      UNSPECV_EH_RETURN)\n    (clobber (match_scratch:DI 1 \"=&r\"))]\n   \"TARGET_SHMEDIA64\"\n   \"#\")\n \n (define_split\n-  [(unspec [(match_operand 0 \"register_operand\" \"\")] UNSPEC_EH_RETURN)\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"\")]\n+      UNSPECV_EH_RETURN)\n    (clobber (match_scratch 1 \"\"))]\n   \"reload_completed\"\n   [(const_int 0)]\n@@ -10167,7 +10347,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set (reg:PSI FPSCR_REG)\n \t(mem:PSI (match_operand:SI 0 \"register_operand\" \"\")))]\n   \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\n-   && (flag_peephole2 ? flow2_completed : reload_completed)\"\n+   && (flag_peephole2 ? epilogue_completed : reload_completed)\"\n   [(const_int 0)]\n {\n   rtx fpscr, mem, new_insn;"}, {"sha": "afe24246736a4cdb46dfd6db5532bacee94c9767", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for SPARC.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n    64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n@@ -52,6 +52,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-gimple.h\"\n #include \"langhooks.h\"\n #include \"params.h\"\n+#include \"df.h\"\n \n /* Processor costs */\n static const\n@@ -3742,20 +3743,20 @@ sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function_p)\n   if (TARGET_ARCH64)\n     {\n       for (i = 0; i < 8; i++)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  n_regs += 2;\n     }\n   else\n     {\n       for (i = 0; i < 8; i += 2)\n-\tif ((regs_ever_live[i] && ! call_used_regs[i])\n-\t    || (regs_ever_live[i+1] && ! call_used_regs[i+1]))\n+\tif ((df_regs_ever_live_p (i) && ! call_used_regs[i])\n+\t    || (df_regs_ever_live_p (i+1) && ! call_used_regs[i+1]))\n \t  n_regs += 2;\n     }\n \n   for (i = 32; i < (TARGET_V9 ? 96 : 64); i += 2)\n-    if ((regs_ever_live[i] && ! call_used_regs[i])\n-\t|| (regs_ever_live[i+1] && ! call_used_regs[i+1]))\n+    if ((df_regs_ever_live_p (i) && ! call_used_regs[i])\n+\t|| (df_regs_ever_live_p (i+1) && ! call_used_regs[i+1]))\n       n_regs += 2;\n \n   /* Set up values for use in prologue and epilogue.  */\n@@ -3798,7 +3799,7 @@ sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n      .register being printed for them already.  */\n   for (i = 2; i < 8; i++)\n     {\n-      if (regs_ever_live [i]\n+      if (df_regs_ever_live_p (i)\n \t  && ! sparc_hard_reg_printed [i])\n \t{\n \t  sparc_hard_reg_printed [i] = 1;\n@@ -3829,7 +3830,7 @@ save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n     {\n       for (i = low; i < high; i++)\n \t{\n-\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t    {\n \t      mem = gen_rtx_MEM (DImode, plus_constant (base, offset));\n \t      set_mem_alias_set (mem, sparc_sr_alias_set);\n@@ -3848,8 +3849,8 @@ save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n     {\n       for (i = low; i < high; i += 2)\n \t{\n-\t  bool reg0 = regs_ever_live[i] && ! call_used_regs[i];\n-\t  bool reg1 = regs_ever_live[i+1] && ! call_used_regs[i+1];\n+\t  bool reg0 = df_regs_ever_live_p (i) && ! call_used_regs[i];\n+\t  bool reg1 = df_regs_ever_live_p (i+1) && ! call_used_regs[i+1];\n \t  enum machine_mode mode;\n \t  int regno;\n \n@@ -6509,7 +6510,7 @@ order_regs_for_local_alloc (void)\n {\n   static int last_order_nonleaf = 1;\n \n-  if (regs_ever_live[15] != last_order_nonleaf)\n+  if (df_regs_ever_live_p (15) != last_order_nonleaf)\n     {\n       last_order_nonleaf = !last_order_nonleaf;\n       memcpy ((char *) reg_alloc_order,\n@@ -7673,7 +7674,7 @@ sparc_check_64 (rtx x, rtx insn)\n     y = gen_rtx_REG (SImode, REGNO (x) + WORDS_BIG_ENDIAN);\n \n   if (flag_expensive_optimizations\n-      && REG_N_SETS (REGNO (y)) == 1)\n+      && DF_REG_DEF_COUNT (REGNO (y)) == 1)\n     set_once = 1;\n \n   if (insn == 0)"}, {"sha": "fed243f67df1ab37d795d162025cb3f2ecbb1733", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1387,7 +1387,6 @@ print_operand (FILE * file, rtx x, int code)\n }\n \n extern char call_used_regs[];\n-extern char regs_ever_live[];\n \n /* For PIC mode we've reserved PIC_OFFSET_TABLE_REGNUM, which is a\n    caller saved register.  For leaf functions it is more efficient to\n@@ -1517,13 +1516,13 @@ spu_split_immediate (rtx * ops)\n static int\n need_to_save_reg (int regno, int saving)\n {\n-  if (regs_ever_live[regno] && !call_used_regs[regno])\n+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n     return 1;\n   if (flag_pic\n       && regno == PIC_OFFSET_TABLE_REGNUM\n       && (!saving || current_function_uses_pic_offset_table)\n       && (!saving\n-\t  || !current_function_is_leaf || regs_ever_live[LAST_ARG_REGNUM]))\n+\t  || !current_function_is_leaf || df_regs_ever_live_p (LAST_ARG_REGNUM)))\n     return 1;\n   return 0;\n }\n@@ -1571,16 +1570,11 @@ frame_emit_add_imm (rtx dst, rtx src, HOST_WIDE_INT imm, rtx scratch)\n     }\n   else\n     {\n-      insn = emit_insn (gen_movsi (scratch, gen_int_mode (imm, SImode)));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    REG_NOTES (insn));\n+      emit_insn (gen_movsi (scratch, gen_int_mode (imm, SImode)));\n       insn = emit_insn (gen_addsi3 (dst, src, scratch));\n       if (REGNO (src) == REGNO (scratch))\n \tabort ();\n     }\n-  if (REGNO (dst) == REGNO (scratch))\n-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t  REG_NOTES (insn));\n   return insn;\n }\n \n@@ -1688,11 +1682,7 @@ spu_expand_prologue (void)\n     {\n       rtx pic_reg = get_pic_reg ();\n       insn = emit_insn (gen_load_pic_offset (pic_reg, scratch_reg_0));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    REG_NOTES (insn));\n       insn = emit_insn (gen_subsi3 (pic_reg, pic_reg, scratch_reg_0));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n-\t\t\t\t\t    REG_NOTES (insn));\n     }\n \n   if (total_size > 0)\n@@ -2424,7 +2414,7 @@ immediate_load_p (rtx op, enum machine_mode mode)\n     {\n       enum immediate_class c = classify_immediate (op, mode);\n       return c == IC_IL1 || c == IC_IL1s\n-\t     || (!flow2_completed && (c == IC_IL2 || c == IC_IL2s));\n+\t     || (!epilogue_completed && (c == IC_IL2 || c == IC_IL2s));\n     }\n   return 0;\n }\n@@ -3833,7 +3823,7 @@ fsmbi_const_p (rtx x)\n       /* We can always choose TImode for CONST_INT because the high bits\n          of an SImode will always be all 1s, i.e., valid for fsmbi. */\n       enum immediate_class c = classify_immediate (x, TImode);\n-      return c == IC_FSMBI || (!flow2_completed && c == IC_FSMBI2);\n+      return c == IC_FSMBI || (!epilogue_completed && c == IC_FSMBI2);\n     }\n   return 0;\n }"}, {"sha": "8f2dc1e68c9230775b785976ea2eb3bf0d0983f8", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Xstormy16 target functions.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n This file is part of GCC.\n@@ -1000,10 +1000,10 @@ struct xstormy16_stack_layout\n \n /* Does REGNO need to be saved?  */\n #define REG_NEEDS_SAVE(REGNUM, IFUN)\t\t\t\t\t\\\n-  ((regs_ever_live[REGNUM] && ! call_used_regs[REGNUM])\t\t\t\\\n+  ((df_regs_ever_live_p (REGNUM) && ! call_used_regs[REGNUM])\t\t\\\n    || (IFUN && ! fixed_regs[REGNUM] && call_used_regs[REGNUM]\t\t\\\n        && (REGNO_REG_CLASS (REGNUM) != CARRY_REGS)\t\t\t\\\n-       && (regs_ever_live[REGNUM] || ! current_function_is_leaf)))\n+       && (df_regs_ever_live_p (REGNUM) || ! current_function_is_leaf)))\n \n /* Compute the stack layout.  */\n struct xstormy16_stack_layout "}, {"sha": "fbb3ac9986c8fa4c8f8541c33d1df36403cf11e6", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for NEC V850 series\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n    This file is part of GCC.\n@@ -1134,7 +1134,7 @@ substitute_ep_register (rtx first_insn,\n \n   if (!*p_r1)\n     {\n-      regs_ever_live[1] = 1;\n+      df_set_regs_ever_live_p (1, true);\n       *p_r1 = gen_rtx_REG (Pmode, 1);\n       *p_ep = gen_rtx_REG (Pmode, 30);\n     }\n@@ -1460,12 +1460,15 @@ compute_register_save_size (long * p_reg_saved)\n   int size = 0;\n   int i;\n   int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n-  int call_p = regs_ever_live [LINK_POINTER_REGNUM];\n+  int call_p = df_regs_ever_live_p (LINK_POINTER_REGNUM);\n   long reg_saved = 0;\n \n   /* Count the return pointer if we need to save it.  */\n   if (current_function_profile && !call_p)\n-    regs_ever_live [LINK_POINTER_REGNUM] = call_p = 1;\n+    {\n+      df_set_regs_ever_live (LINK_POINTER_REGNUM, true);\n+      call_p = 1;\n+    }\n  \n   /* Count space for the register saves.  */\n   if (interrupt_handler)\n@@ -1474,7 +1477,7 @@ compute_register_save_size (long * p_reg_saved)\n \tswitch (i)\n \t  {\n \t  default:\n-\t    if (regs_ever_live[i] || call_p)\n+\t    if (df_regs_ever_live_p (i) || call_p)\n \t      {\n \t\tsize += 4;\n \t\treg_saved |= 1L << i;\n@@ -1502,7 +1505,7 @@ compute_register_save_size (long * p_reg_saved)\n     {\n       /* Find the first register that needs to be saved.  */\n       for (i = 0; i <= 31; i++)\n-\tif (regs_ever_live[i] && ((! call_used_regs[i])\n+\tif (df_regs_ever_live_p (i) && ((! call_used_regs[i])\n \t\t\t\t  || i == LINK_POINTER_REGNUM))\n \t  break;\n \n@@ -1534,7 +1537,7 @@ compute_register_save_size (long * p_reg_saved)\n \t      reg_saved |= 1L << i;\n \t    }\n \n-\t  if (regs_ever_live [LINK_POINTER_REGNUM])\n+\t  if (df_regs_ever_live_p (LINK_POINTER_REGNUM))\n \t    {\n \t      size += 4;\n \t      reg_saved |= 1L << LINK_POINTER_REGNUM;\n@@ -1543,7 +1546,7 @@ compute_register_save_size (long * p_reg_saved)\n       else\n \t{\n \t  for (; i <= 31; i++)\n-\t    if (regs_ever_live[i] && ((! call_used_regs[i])\n+\t    if (df_regs_ever_live_p (i) && ((! call_used_regs[i])\n \t\t\t\t      || i == LINK_POINTER_REGNUM))\n \t      {\n \t\tsize += 4;"}, {"sha": "dbc239025709173e178a5fe1e624a945cbd185e7", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for VAX.\n    Copyright (C) 1987, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2004, 2005\n+   2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -116,7 +116,7 @@ vax_output_function_prologue (FILE * file, HOST_WIDE_INT size)\n   int mask = 0;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n+    if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n       mask |= 1 << regno;\n \n   fprintf (file, \"\\t.word 0x%x\\n\", mask);\n@@ -127,7 +127,7 @@ vax_output_function_prologue (FILE * file, HOST_WIDE_INT size)\n       int offset = 0;\n \n       for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\n-\tif (regs_ever_live[regno] && !call_used_regs[regno])\n+\tif (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n \t  dwarf2out_reg_save (label, regno, offset -= 4);\n \n       dwarf2out_reg_save (label, PC_REGNUM, offset -= 4);"}, {"sha": "58055ddae061d309d0e8e8dfeee7b2f0c107f311", "filename": "gcc/cse.c", "status": "modified", "additions": 69, "deletions": 99, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -45,6 +45,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"params.h\"\n #include \"rtlhooks-def.h\"\n #include \"tree-pass.h\"\n+#include \"df.h\"\n+#include \"dbgcnt.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -347,27 +349,6 @@ static unsigned int cse_reg_info_timestamp;\n \n static HARD_REG_SET hard_regs_in_table;\n \n-/* CUID of insn that starts the basic block currently being cse-processed.  */\n-\n-static int cse_basic_block_start;\n-\n-/* CUID of insn that ends the basic block currently being cse-processed.  */\n-\n-static int cse_basic_block_end;\n-\n-/* Vector mapping INSN_UIDs to cuids.\n-   The cuids are like uids but increase monotonically always.\n-   We use them to see whether a reg is used outside a given basic block.  */\n-\n-static int *uid_cuid;\n-\n-/* Highest UID in UID_CUID.  */\n-static int max_uid;\n-\n-/* Get the cuid of an insn.  */\n-\n-#define INSN_CUID(INSN) (uid_cuid[INSN_UID (INSN)])\n-\n /* Nonzero if cse has altered conditional jump insns\n    in such a way that jump optimization should be redone.  */\n \n@@ -538,10 +519,6 @@ static int constant_pool_entries_regcost;\n \n struct cse_basic_block_data\n {\n-  /* Lowest CUID value of insns in block.  */\n-  int low_cuid;\n-  /* Highest CUID value of insns in block.  */\n-  int high_cuid;\n   /* Total number of SETs in block.  */\n   int nsets;\n   /* Size of current branch path, if any.  */\n@@ -554,6 +531,11 @@ struct cse_basic_block_data\n     } *path;\n };\n \n+\n+/* Pointers to the live in/live out bitmaps for the boundaries of the\n+   current EBB.  */\n+static bitmap cse_ebb_live_in, cse_ebb_live_out;\n+\n /* A simple bitmap to track which basic blocks have been visited\n    already as part of an already processed extended basic block.  */\n static sbitmap cse_visited_basic_blocks;\n@@ -602,7 +584,7 @@ static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n static void cse_insn (rtx, rtx);\n static void cse_prescan_path (struct cse_basic_block_data *);\n static void invalidate_from_clobbers (rtx);\n-static rtx cse_process_notes (rtx, rtx);\n+static rtx cse_process_notes (rtx, rtx, bool *);\n static void cse_extended_basic_block (struct cse_basic_block_data *);\n static void count_reg_usage (rtx, int *, rtx, int);\n static int check_for_label_ref (rtx *, void *);\n@@ -957,11 +939,10 @@ make_regs_eqv (unsigned int new, unsigned int old)\n       && ((new < FIRST_PSEUDO_REGISTER && FIXED_REGNO_P (new))\n \t  || (new >= FIRST_PSEUDO_REGISTER\n \t      && (firstr < FIRST_PSEUDO_REGISTER\n-\t\t  || ((uid_cuid[REGNO_LAST_UID (new)] > cse_basic_block_end\n-\t\t       || (uid_cuid[REGNO_FIRST_UID (new)]\n-\t\t\t   < cse_basic_block_start))\n-\t\t      && (uid_cuid[REGNO_LAST_UID (new)]\n-\t\t\t  > uid_cuid[REGNO_LAST_UID (firstr)]))))))\n+\t\t  || (bitmap_bit_p (cse_ebb_live_out, new)\n+\t\t      && !bitmap_bit_p (cse_ebb_live_out, firstr))\n+\t\t  || (bitmap_bit_p (cse_ebb_live_in, new)\n+\t\t      && !bitmap_bit_p (cse_ebb_live_in, firstr))))))\n     {\n       reg_eqv_table[firstr].prev = new;\n       reg_eqv_table[new].next = firstr;\n@@ -2648,14 +2629,15 @@ cse_rtx_varies_p (rtx x, int from_alias)\n static void\n validate_canon_reg (rtx *xloc, rtx insn)\n {\n-  rtx new = canon_reg (*xloc, insn);\n+  if (*xloc)\n+    {\n+      rtx new = canon_reg (*xloc, insn);\n \n-  /* If replacing pseudo with hard reg or vice versa, ensure the\n-     insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n-  if (insn != 0 && new != 0)\n-    validate_change (insn, xloc, new, 1);\n-  else\n-    *xloc = new;\n+      /* If replacing pseudo with hard reg or vice versa, ensure the\n+         insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n+      gcc_assert (insn && new);\n+      validate_change (insn, xloc, new, 1);\n+    }\n }\n \n /* Canonicalize an expression:\n@@ -4151,12 +4133,12 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t This does nothing when a register is clobbered\n \t\t because we have already invalidated the reg.  */\n \t      if (MEM_P (XEXP (y, 0)))\n-\t\tcanon_reg (XEXP (y, 0), NULL_RTX);\n+\t\tcanon_reg (XEXP (y, 0), insn);\n \t    }\n \t  else if (GET_CODE (y) == USE\n \t\t   && ! (REG_P (XEXP (y, 0))\n \t\t\t && REGNO (XEXP (y, 0)) < FIRST_PSEUDO_REGISTER))\n-\t    canon_reg (y, NULL_RTX);\n+\t    canon_reg (y, insn);\n \t  else if (GET_CODE (y) == CALL)\n \t    {\n \t      /* The result of apply_change_group can be ignored; see\n@@ -4170,14 +4152,14 @@ cse_insn (rtx insn, rtx libcall_insn)\n   else if (GET_CODE (x) == CLOBBER)\n     {\n       if (MEM_P (XEXP (x, 0)))\n-\tcanon_reg (XEXP (x, 0), NULL_RTX);\n+\tcanon_reg (XEXP (x, 0), insn);\n     }\n \n   /* Canonicalize a USE of a pseudo register or memory location.  */\n   else if (GET_CODE (x) == USE\n \t   && ! (REG_P (XEXP (x, 0))\n \t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER))\n-    canon_reg (XEXP (x, 0), NULL_RTX);\n+    canon_reg (XEXP (x, 0), insn);\n   else if (GET_CODE (x) == CALL)\n     {\n       /* The result of apply_change_group can be ignored; see canon_reg.  */\n@@ -4195,8 +4177,12 @@ cse_insn (rtx insn, rtx libcall_insn)\n       && (! rtx_equal_p (XEXP (tem, 0), SET_SRC (sets[0].rtl))\n \t  || GET_CODE (SET_DEST (sets[0].rtl)) == STRICT_LOW_PART))\n     {\n-      src_eqv = fold_rtx (canon_reg (XEXP (tem, 0), NULL_RTX), insn);\n+      /* The result of apply_change_group can be ignored; see canon_reg.  */\n+      canon_reg (XEXP (tem, 0), insn);\n+      apply_change_group ();\n+      src_eqv = fold_rtx (XEXP (tem, 0), insn);\n       XEXP (tem, 0) = src_eqv;\n+      df_notes_rescan (insn);\n     }\n \n   /* Canonicalize sources and addresses of destinations.\n@@ -4861,6 +4847,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t    XEXP (note, 0) = simplify_replace_rtx (XEXP (note, 0),\n \t\t\t\t\t\t\t   sets[i].orig_src,\n \t\t\t\t\t\t\t   copy_rtx (new));\n+\t\t  df_notes_rescan (libcall_insn);\n \t\t}\n \n \t      /* The result of apply_change_group can be ignored; see\n@@ -4979,6 +4966,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t      /* Record the actual constant value in a REG_EQUAL note,\n \t\t making a new one if one does not already exist.  */\n \t      set_unique_reg_note (insn, REG_EQUAL, src_const);\n+\t      df_notes_rescan (insn);\n \t    }\n \t}\n \n@@ -5056,11 +5044,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n       else if (dest == pc_rtx && GET_CODE (src) == LABEL_REF\n \t       && !LABEL_REF_NONLOCAL_P (src))\n \t{\n-\t  /* Now emit a BARRIER after the unconditional jump.  */\n-\t  if (NEXT_INSN (insn) == 0\n-\t      || !BARRIER_P (NEXT_INSN (insn)))\n-\t    emit_barrier_after (insn);\n-\n \t  /* We reemit the jump in as many cases as possible just in\n \t     case the form of an unconditional jump is significantly\n \t     different than a computed jump or conditional jump.\n@@ -5086,11 +5069,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t      delete_insn_and_edges (insn);\n \t      insn = new;\n-\n-\t      /* Now emit a BARRIER after the unconditional jump.  */\n-\t      if (NEXT_INSN (insn) == 0\n-\t\t  || !BARRIER_P (NEXT_INSN (insn)))\n-\t\temit_barrier_after (insn);\n \t    }\n \t  else\n \t    INSN_CODE (insn) = -1;\n@@ -5716,7 +5694,7 @@ invalidate_from_clobbers (rtx x)\n    Return the replacement for X.  */\n \n static rtx\n-cse_process_notes (rtx x, rtx object)\n+cse_process_notes_1 (rtx x, rtx object, bool *changed)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -5737,22 +5715,22 @@ cse_process_notes (rtx x, rtx object)\n \n     case MEM:\n       validate_change (x, &XEXP (x, 0),\n-\t\t       cse_process_notes (XEXP (x, 0), x), 0);\n+\t\t       cse_process_notes (XEXP (x, 0), x, changed), 0);\n       return x;\n \n     case EXPR_LIST:\n     case INSN_LIST:\n       if (REG_NOTE_KIND (x) == REG_EQUAL)\n-\tXEXP (x, 0) = cse_process_notes (XEXP (x, 0), NULL_RTX);\n+\tXEXP (x, 0) = cse_process_notes (XEXP (x, 0), NULL_RTX, changed);\n       if (XEXP (x, 1))\n-\tXEXP (x, 1) = cse_process_notes (XEXP (x, 1), NULL_RTX);\n+\tXEXP (x, 1) = cse_process_notes (XEXP (x, 1), NULL_RTX, changed);\n       return x;\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n     case SUBREG:\n       {\n-\trtx new = cse_process_notes (XEXP (x, 0), object);\n+\trtx new = cse_process_notes (XEXP (x, 0), object, changed);\n \t/* We don't substitute VOIDmode constants into these rtx,\n \t   since they would impede folding.  */\n \tif (GET_MODE (new) != VOIDmode)\n@@ -5788,10 +5766,20 @@ cse_process_notes (rtx x, rtx object)\n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     if (fmt[i] == 'e')\n       validate_change (object, &XEXP (x, i),\n-\t\t       cse_process_notes (XEXP (x, i), object), 0);\n+\t\t       cse_process_notes (XEXP (x, i), object, changed), 0);\n \n   return x;\n }\n+\n+static rtx\n+cse_process_notes (rtx x, rtx object, bool *changed)\n+{\n+  rtx new = cse_process_notes_1 (x, object, changed);\n+  if (new != x)\n+    *changed = true;\n+  return new;\n+}\n+\n \f\n /* Find a path in the CFG, starting with FIRST_BB to perform CSE on.\n \n@@ -5966,14 +5954,12 @@ have_eh_succ_edges (basic_block bb)\n \n \f\n /* Scan to the end of the path described by DATA.  Return an estimate of\n-   the total number of SETs, and the lowest and highest insn CUID, of all\n-   insns in the path.  */\n+   the total number of SETs of all insns in the path.  */\n \n static void\n cse_prescan_path (struct cse_basic_block_data *data)\n {\n   int nsets = 0;\n-  int low_cuid = -1, high_cuid = -1; /* FIXME low_cuid not computed correctly */\n   int path_size = data->path_size;\n   int path_entry;\n \n@@ -5996,21 +5982,9 @@ cse_prescan_path (struct cse_basic_block_data *data)\n \t    nsets += XVECLEN (PATTERN (insn), 0);\n \t  else\n \t    nsets += 1;\n-\n-\t  /* Ignore insns made by CSE in a previous traversal of this\n-\t     basic block.  They cannot affect the boundaries of the\n-\t     basic block.\n-\t     FIXME: When we only visit each basic block at most once,\n-\t\t    this can go away.  */\n-\t  if (INSN_UID (insn) <= max_uid && INSN_CUID (insn) > high_cuid)\n-\t    high_cuid = INSN_CUID (insn);\n-\t  if (INSN_UID (insn) <= max_uid && INSN_CUID (insn) < low_cuid)\n-\t    low_cuid = INSN_CUID (insn);\n \t}\n     }\n \n-  data->low_cuid = low_cuid;\n-  data->high_cuid = high_cuid;\n   data->nsets = nsets;\n }\n \f\n@@ -6027,6 +6001,8 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n   qty_table = XNEWVEC (struct qty_table_elem, max_qty);\n \n   new_basic_block ();\n+  cse_ebb_live_in = DF_LIVE_IN (ebb_data->path[0].bb);\n+  cse_ebb_live_out = DF_LIVE_OUT (ebb_data->path[path_size - 1].bb);\n   for (path_entry = 0; path_entry < path_size; path_entry++)\n     {\n       basic_block bb;\n@@ -6058,8 +6034,13 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t      /* Process notes first so we have all notes in canonical forms\n \t\t when looking for duplicate operations.  */\n \t      if (REG_NOTES (insn))\n-\t\tREG_NOTES (insn) = cse_process_notes (REG_NOTES (insn),\n-\t\t\t\t\t\t      NULL_RTX);\n+\t\t{\n+\t\t  bool changed = false;\n+\t\t  REG_NOTES (insn) = cse_process_notes (REG_NOTES (insn),\n+\t\t\t\t\t\t        NULL_RTX, &changed);\n+\t\t  if (changed)\n+\t\t    df_notes_rescan (insn);\n+\t\t}\n \n \t      /* Track when we are inside in LIBCALL block.  Inside such\n \t\t a block we do not want to record destinations.  The last\n@@ -6191,6 +6172,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \n   free (qty_table);\n }\n+\n \f\n /* Perform cse on the instructions of a function.\n    F is the first instruction.\n@@ -6207,6 +6189,11 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n   int *rc_order = XNEWVEC (int, last_basic_block);\n   int i, n_blocks;\n \n+  df_set_flags (DF_LR_RUN_DCE);\n+  df_analyze ();\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n+  reg_scan (get_insns (), max_reg_num ());\n   init_cse_reg_info (nregs);\n \n   ebb_data.path = XNEWVEC (struct branch_path,\n@@ -6229,19 +6216,6 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n   cse_visited_basic_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (cse_visited_basic_blocks);\n \n-  /* Compute the mapping from uids to cuids.\n-     CUIDs are numbers assigned to insns, like uids, except that\n-     that cuids increase monotonically through the code.  */\n-  max_uid = get_max_uid ();\n-  uid_cuid = XCNEWVEC (int, max_uid + 1);\n-  i = 0;\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx insn;\n-      FOR_BB_INSNS (bb, insn)\n-\tINSN_CUID (insn) = ++i;\n-    }\n-\n   /* Loop over basic blocks in reverse completion order (RPO),\n      excluding the ENTRY and EXIT blocks.  */\n   n_blocks = pre_and_rev_post_order_compute (NULL, rc_order, false);\n@@ -6271,8 +6245,6 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \t     needed for this path.  For this, we take the number of sets\n \t     and multiply that by MAX_RECOG_OPERANDS.  */\n \t  max_qty = ebb_data.nsets * MAX_RECOG_OPERANDS;\n-\t  cse_basic_block_start = ebb_data.low_cuid;\n-\t  cse_basic_block_end = ebb_data.high_cuid;\n \n \t  /* Dump the path we're about to process.  */\n \t  if (dump_file)\n@@ -6284,7 +6256,6 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \n   /* Clean up.  */\n   end_alias_analysis ();\n-  free (uid_cuid);\n   free (reg_eqv_table);\n   free (ebb_data.path);\n   sbitmap_free (cse_visited_basic_blocks);\n@@ -6605,7 +6576,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n       /* If this is a dead insn, delete it and show registers in it aren't\n \t being used.  */\n \n-      if (! live_insn)\n+      if (! live_insn && dbg_cnt (delete_trivial_dead))\n \t{\n \t  count_reg_usage (insn, counts, NULL_RTX, -1);\n \t  delete_insn_and_edges (insn);\n@@ -7009,11 +6980,10 @@ static unsigned int\n rest_of_handle_cse (void)\n {\n   int tem;\n+\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n \n-  reg_scan (get_insns (), max_reg_num ());\n-\n   tem = cse_main (get_insns (), max_reg_num ());\n \n   /* If we are not running more CSE passes, then we are no longer\n@@ -7024,7 +6994,7 @@ rest_of_handle_cse (void)\n     rebuild_jump_labels (get_insns ());\n \n   if (tem || optimize > 1)\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n+    cleanup_cfg (0);\n \n   return 0;\n }\n@@ -7042,6 +7012,7 @@ struct tree_opt_pass pass_cse =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n+  TODO_df_finish |\n   TODO_dump_func |\n   TODO_ggc_collect |\n   TODO_verify_flow,                     /* todo_flags_finish */\n@@ -7078,11 +7049,9 @@ rest_of_handle_cse2 (void)\n     {\n       timevar_push (TV_JUMP);\n       rebuild_jump_labels (get_insns ());\n-      delete_dead_jumptables ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      cleanup_cfg (0);\n       timevar_pop (TV_JUMP);\n     }\n-  reg_scan (get_insns (), max_reg_num ());\n   cse_not_expected = 1;\n   return 0;\n }\n@@ -7101,6 +7070,7 @@ struct tree_opt_pass pass_cse2 =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n+  TODO_df_finish |\n   TODO_dump_func |\n   TODO_ggc_collect |\n   TODO_verify_flow,                     /* todo_flags_finish */"}, {"sha": "6114091a489a2fbe8efcbb7e54ba2ece5e868691", "filename": "gcc/cselib.c", "status": "modified", "additions": 263, "deletions": 1, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination library for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -131,6 +131,10 @@ static cselib_val dummy_val;\n    each time memory is invalidated.  */\n static cselib_val *first_containing_mem = &dummy_val;\n static alloc_pool elt_loc_list_pool, elt_list_pool, cselib_val_pool, value_pool;\n+\n+/* If nonnull, cselib will call this function before freeing useless\n+   VALUEs.  A VALUE is deemed useless if its \"locs\" field is null.  */\n+void (*cselib_discard_hook) (cselib_val *);\n \f\n \n /* Allocate a struct elt_list and fill in its two elements with the\n@@ -331,6 +335,9 @@ discard_useless_values (void **x, void *info ATTRIBUTE_UNUSED)\n \n   if (v->locs == 0)\n     {\n+      if (cselib_discard_hook)\n+\tcselib_discard_hook (v);\n+\n       CSELIB_VAL_PTR (v->val_rtx) = NULL;\n       htab_clear_slot (cselib_hash_table, x);\n       unchain_one_value (v);\n@@ -823,6 +830,260 @@ cselib_lookup_mem (rtx x, int create)\n   return mem_elt;\n }\n \n+/* Search thru the possible substitutions in P.  We prefer a non reg\n+   substitution because this allows us to expand the tree further.  If\n+   we find, just a reg, take the lowest regno.  There may be several\n+   non-reg results, we just take the first one because they will all\n+   expand to the same place.  */\n+\n+static rtx \n+expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n+{\n+  rtx reg_result = NULL;\n+  unsigned int regno = UINT_MAX;\n+  struct elt_loc_list *p_in = p;\n+\n+  for (; p; p = p -> next)\n+    {\n+      /* Avoid infinite recursion trying to expand a reg into a\n+\t the same reg.  */\n+      if ((REG_P (p->loc)) \n+\t  && (REGNO (p->loc) < regno) \n+\t  && !bitmap_bit_p (regs_active, REGNO (p->loc)))\n+\t{\n+\t  reg_result = p->loc;\n+\t  regno = REGNO (p->loc);\n+\t}\n+      /* Avoid infinite recursion and do not try to expand the\n+\t value.  */\n+      else if (GET_CODE (p->loc) == VALUE \n+\t       && CSELIB_VAL_PTR (p->loc)->locs == p_in)\n+\tcontinue;\n+      else if (!REG_P (p->loc))\n+\t{\n+\t  rtx result;\n+\t  if (dump_file)\n+\t    {\n+\t      print_inline_rtx (dump_file, p->loc, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  result = cselib_expand_value_rtx (p->loc, regs_active, max_depth - 1);\n+\t  if (result)\n+\t    return result;\n+\t}\n+\t\n+    }\n+  \n+  if (regno != UINT_MAX)\n+    {\n+      rtx result;\n+      if (dump_file)\n+\tfprintf (dump_file, \"r%d\\n\", regno);\n+\n+      result = cselib_expand_value_rtx (reg_result, regs_active, max_depth - 1);\n+      if (result)\n+\treturn result;\n+    }\n+\n+  if (dump_file)\n+    {\n+      if (reg_result)\n+\t{\n+\t  print_inline_rtx (dump_file, reg_result, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      else \n+\tfprintf (dump_file, \"NULL\\n\");\n+    }\n+  return reg_result;\n+}\n+\n+\n+/* Forward substitute and expand an expression out to its roots.\n+   This is the opposite of common subexpression.  Because local value\n+   numbering is such a weak optimization, the expanded expression is\n+   pretty much unique (not from a pointer equals point of view but\n+   from a tree shape point of view.  \n+\n+   This function returns NULL if the expansion fails.  The expansion\n+   will fail if there is no value number for one of the operands or if\n+   one of the operands has been overwritten between the current insn\n+   and the beginning of the basic block.  For instance x has no\n+   expansion in:\n+\n+   r1 <- r1 + 3\n+   x <- r1 + 8\n+\n+   REGS_ACTIVE is a scratch bitmap that should be clear when passing in.\n+   It is clear on return.  */\n+\n+rtx\n+cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n+{\n+  rtx copy, scopy;\n+  int i, j;\n+  RTX_CODE code;\n+  const char *format_ptr;\n+\n+  code = GET_CODE (orig);\n+\n+  /* For the context of dse, if we end up expand into a huge tree, we\n+     will not have a useful address, so we might as well just give up\n+     quickly.  */\n+  if (max_depth <= 0)\n+    return NULL;\n+\n+  switch (code)\n+    {\n+    case REG:\n+      {\n+\tstruct elt_list *l = REG_VALUES (REGNO (orig));\n+\n+\tif (l && l->elt == NULL)\n+\t  l = l->next;\n+\tfor (; l; l = l->next)\n+\t  if (GET_MODE (l->elt->val_rtx) == GET_MODE (orig))\n+\t    {\n+\t      rtx result;\n+\t      int regno = REGNO (orig);\n+\t      \n+\t      /* The only thing that we are not willing to do (this\n+\t\t is requirement of dse and if others potiential uses\n+\t\t need this function we should add a parm to control\n+\t\t it) is that we will not substitute the\n+\t\t STACK_POINTER_REGNUM, FRAME_POINTER or the\n+\t\t HARD_FRAME_POINTER.\n+\n+\t\t Thses expansions confuses the code that notices that\n+\t\t stores into the frame go dead at the end of the\n+\t\t function and that the frame is not effected by calls\n+\t\t to subroutines.  If you allow the\n+\t\t STACK_POINTER_REGNUM substitution, then dse will\n+\t\t think that parameter pushing also goes dead which is\n+\t\t wrong.  If you allow the FRAME_POINTER or the\n+\t\t HARD_FRAME_POINTER then you lose the opportunity to\n+\t\t make the frame assumptions.  */\n+\t      if (regno == STACK_POINTER_REGNUM\n+\t\t  || regno == FRAME_POINTER_REGNUM\n+\t\t  || regno == HARD_FRAME_POINTER_REGNUM)\n+\t\treturn orig;\n+\n+\t      bitmap_set_bit (regs_active, regno);\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"expanding: r%d into: \", regno);\n+\n+\t      result = expand_loc (l->elt->locs, regs_active, max_depth);\n+\t      bitmap_clear_bit (regs_active, regno);\n+\n+\t      if (result)\n+\t\treturn result;\n+\t      else \n+\t\treturn orig;\n+\t    }\n+      }\n+      \n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+      /* SCRATCH must be shared because they represent distinct values.  */\n+      return orig;\n+    case CLOBBER:\n+      if (REG_P (XEXP (orig, 0)) && HARD_REGISTER_NUM_P (REGNO (XEXP (orig, 0))))\n+\treturn orig;\n+      break;\n+\n+    case CONST:\n+      if (shared_const_p (orig))\n+\treturn orig;\n+      break;\n+\n+\n+    case VALUE:\n+      {\n+\trtx result;\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"expanding value %s into: \", GET_MODE_NAME (GET_MODE (orig)));\n+\t\n+\tresult = expand_loc (CSELIB_VAL_PTR (orig)->locs, regs_active, max_depth);\n+\tif (result \n+\t    && GET_CODE (result) == CONST_INT\n+\t    && GET_MODE (orig) != VOIDmode)\n+\t  {\n+\t    result = gen_rtx_CONST (GET_MODE (orig), result);\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"  wrapping const_int result in const to preserve mode %s\\n\", \n+\t\t       GET_MODE_NAME (GET_MODE (orig)));\n+\t  }\n+\treturn result;\n+      }\n+    default:\n+      break;\n+    }\n+\n+  /* Copy the various flags, fields, and other information.  We assume\n+     that all fields need copying, and then clear the fields that should\n+     not be copied.  That is the sensible default behavior, and forces\n+     us to explicitly document why we are *not* copying a flag.  */\n+  copy = shallow_copy_rtx (orig);\n+\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+\tif (XEXP (orig, i) != NULL)\n+\t  {\n+\t    rtx result = cselib_expand_value_rtx (XEXP (orig, i), regs_active, max_depth - 1);\n+\t    if (!result)\n+\t      return NULL;\n+\t    XEXP (copy, i) = result;\n+\t  }\n+\tbreak;\n+\n+      case 'E':\n+      case 'V':\n+\tif (XVEC (orig, i) != NULL)\n+\t  {\n+\t    XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t    for (j = 0; j < XVECLEN (copy, i); j++)\n+\t      {\n+\t\trtx result = cselib_expand_value_rtx (XVECEXP (orig, i, j), regs_active, max_depth - 1);\n+\t\tif (!result)\n+\t\t  return NULL;\n+\t\tXVECEXP (copy, i, j) = result;\n+\t      }\n+\t  }\n+\tbreak;\n+\n+      case 't':\n+      case 'w':\n+      case 'i':\n+      case 's':\n+      case 'S':\n+      case 'T':\n+      case 'u':\n+      case 'B':\n+      case '0':\n+\t/* These are left unchanged.  */\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  scopy = simplify_rtx (copy);\n+  if (scopy)\n+    return scopy;\n+  return copy;\n+}\n+\n /* Walk rtx X and replace all occurrences of REG and MEM subexpressions\n    with VALUE expressions.  This way, it becomes independent of changes\n    to registers and memory.\n@@ -1505,6 +1766,7 @@ cselib_init (bool record_memory)\n void\n cselib_finish (void)\n {\n+  cselib_discard_hook = NULL;\n   free_alloc_pool (elt_list_pool);\n   free_alloc_pool (elt_loc_list_pool);\n   free_alloc_pool (cselib_val_pool);"}, {"sha": "427ea1d93823206fecb4b5abc52cbd9101367838", "filename": "gcc/cselib.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -59,6 +59,8 @@ struct elt_list GTY(())\n   cselib_val *elt;\n };\n \n+extern void (*cselib_discard_hook) (cselib_val *);\n+\n extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n extern void cselib_init (bool record_memory);\n extern void cselib_clear_table (void);\n@@ -67,5 +69,6 @@ extern void cselib_process_insn (rtx);\n extern enum machine_mode cselib_reg_set_mode (rtx);\n extern int rtx_equal_for_cselib_p (rtx, rtx);\n extern int references_value_p (rtx, int);\n+extern rtx cselib_expand_value_rtx (rtx, bitmap, int);\n extern rtx cselib_subst_to_values (rtx);\n extern void cselib_invalidate_rtx (rtx);"}, {"sha": "df021112064a03dbf7e4217cf95dd2c2afd38732", "filename": "gcc/dbgcnt.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdbgcnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdbgcnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -0,0 +1,107 @@\n+/* Debug counter for debugging support\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  \n+\n+See dbgcnt.def for usage information.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"dbgcnt.h\"\n+\n+struct string2counter_map {\n+  const char *name;\n+  enum debug_counter counter;\n+};\n+\n+#define DEBUG_COUNTER(a) { #a , a },\n+\n+static struct string2counter_map map[debug_counter_number_of_counters] =\n+{\n+#include \"dbgcnt.def\"\n+};\n+#undef DEBUG_COUNTER\n+\n+#define DEBUG_COUNTER(a) UINT_MAX,\n+static unsigned int limit[debug_counter_number_of_counters] =\n+{\n+#include \"dbgcnt.def\"\n+};\n+#undef DEBUG_COUNTER\n+\n+static unsigned int count[debug_counter_number_of_counters];\n+\n+bool\n+dbg_cnt_is_enabled (enum debug_counter index)\n+{\n+  return count[index] <= limit[index];\n+}\n+\n+bool\n+dbg_cnt (enum debug_counter index)\n+{\n+  count[index]++;\n+  return dbg_cnt_is_enabled (index);\n+}\n+\n+\n+static void\n+dbg_cnt_set_limit_by_index (enum debug_counter index, int value)\n+{\n+  limit[index] = value;\n+\n+  fprintf (stderr, \"dbg_cnt '%s' set to %d\\n\", map[index].name, value);\n+}\n+\n+static void\n+dbg_cnt_set_limit_by_name (const char *name, int len, int value)\n+{\n+  int i;\n+  for (i = debug_counter_number_of_counters - 1; i >= 0; i--)\n+    if (!strncmp (map[i].name, name, len))\n+      break;\n+\n+  if (i < 0)\n+    return;\n+\n+  dbg_cnt_set_limit_by_index (i, value);\n+}\n+\n+void\n+dbg_cnt_process_opt (const char *arg)\n+{\n+   char *colon = strchr (arg, ':');\n+   char *comma;\n+   \n+   if (colon == NULL)\n+     return;\n+\n+   dbg_cnt_set_limit_by_name (arg, colon - arg, atoi (colon + 1));\n+\n+   comma = strchr (colon + 1, ',');\n+   while (comma)\n+     {\n+       colon = strchr (comma + 1, ':');\n+       if (colon == NULL || !(colon[1] >= '0' && colon[1] <= '9'))\n+         return;\n+       dbg_cnt_set_limit_by_name (comma + 1, colon - (comma + 1), atoi (colon + 1));\n+       comma = strchr (colon + 1, ',');\n+     }\n+}"}, {"sha": "5c0b7496d7d87842b917621f1f689f3ce29a53e1", "filename": "gcc/dbgcnt.def", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -0,0 +1,84 @@\n+/* This file contains the list of the debug counter for GCC.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+\n+/* A debug counter provides you a way to count an event\n+   and return false after the counter has exceeded the threshold\n+   specified by the option.\n+\n+   What is it used for ?\n+\n+   This is primarily used to speed up the search for the bad transformation\n+   an optimization pass does. By doing a binary search on N,\n+   you can quickly narrow down to one transformation\n+   which is bad, or which triggers the bad behavior downstream\n+   (usually in the form of the badly generated code).\n+\n+   How does it work ?\n+\n+   Everytime dbg_cnt(named-counter) is called,\n+   the counter is incremented for the named-counter.\n+   And the incremented value is compared against the threshold (limit)\n+   specified by the option.\n+   dbg_cnt () returns true if it is at or below threshold, and false if above.\n+\n+   How to add a new one ?\n+\n+   To add a new counter, simply add an entry below with some descriptive name,\n+   and add call(s) to dbg_cnt(your-counter-name) in appropriate places.\n+   Usually, you want to control at the finest granularity\n+   any particular transformation can happen.\n+   e.g. for each instruction in a dead code elimination,\n+   or for each copy instruction in register coalescing,\n+   or constant-propagation for each insn,\n+   or a block straightening, etc.\n+   See dce.c for an example. With the dbg_cnt () call in dce.c,\n+   now a developer can use -fdbg-cnt=dce:N\n+   to stop doing the dead code elimination after N times.\n+\n+   How to use it ?\n+\n+   By default, all limits are UINT_MAX.\n+   Since debug count is unsigned int, <= UINT_MAX returns true always.\n+   i.e.  dbg_cnt() returns true always regardless of the counter value\n+   (although it still counts the event).\n+   Use -fdbg-cnt=counter1:N,counter2:M,...\n+   which sets the limit for counter1 to N, and the limit for counter2 to M, etc.\n+   e.g. setting a limit to zero will make dbg_cnt () return false *always*.\n+*/\n+\n+/* Debug counter definitions.  */\n+DEBUG_COUNTER (auto_inc_dec)\n+DEBUG_COUNTER (cse2_move2add)\n+DEBUG_COUNTER (dce)\n+DEBUG_COUNTER (delete_trivial_dead)\n+DEBUG_COUNTER (dse)\n+DEBUG_COUNTER (gcse2_delete)\n+DEBUG_COUNTER (ia64_sched2)\n+DEBUG_COUNTER (local_alloc_for_sched)\n+DEBUG_COUNTER (postreload_cse)\n+DEBUG_COUNTER (pre_insn)\n+DEBUG_COUNTER (sched2_func)\n+DEBUG_COUNTER (sched_block)\n+DEBUG_COUNTER (sched_func)\n+DEBUG_COUNTER (sched_insn)\n+DEBUG_COUNTER (sched_region)\n+DEBUG_COUNTER (split_for_sched2)\n+DEBUG_COUNTER (tail_call)"}, {"sha": "38591e9b2ed7c4c5d53c10b2dbe1994ce1e04acc", "filename": "gcc/dbgcnt.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdbgcnt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdbgcnt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -0,0 +1,39 @@\n+/* Debug counter for debugging support\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  \n+\n+See dbgcnt.def for usage information.  */\n+\n+#ifndef GCC_DBGCNT_H\n+#define GCC_DBGCNT_H\n+\n+#define DEBUG_COUNTER(a) a,\n+\n+enum debug_counter {\n+#include \"dbgcnt.def\"\n+   debug_counter_number_of_counters\n+};\n+\n+#undef DEBUG_COUNTER\n+\n+extern bool dbg_cnt_is_enabled (enum debug_counter index);\n+extern bool dbg_cnt (enum debug_counter index);\n+extern void dbg_cnt_process_opt (const char *arg);\n+\n+#endif /* GCC_DBGCNT_H */"}, {"sha": "902dbd923a8a97dee19d6966e29e683277570b40", "filename": "gcc/dce.c", "status": "added", "additions": 789, "deletions": 0, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -0,0 +1,789 @@\n+/* RTL dead code elimination.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"hashtab.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"df.h\"\n+#include \"cselib.h\"\n+#include \"dce.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+#include \"dbgcnt.h\"\n+\n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n+\n+\n+/* -------------------------------------------------------------------------\n+   Core mark/delete routines\n+   ------------------------------------------------------------------------- */\n+\n+/* The data-flow information needed by this pass.  */\n+static bool df_in_progress = false;\n+\n+/* True if we deleted at least one instruction.  */\n+static bool something_changed;\n+\n+/* Instructions that have been marked but whose dependencies have not\n+   yet been processed.  */\n+static VEC(rtx,heap) *worklist;\n+\n+static bitmap_obstack dce_blocks_bitmap_obstack;\n+static bitmap_obstack dce_tmp_bitmap_obstack;\n+\n+static sbitmap marked = NULL;\n+\n+/* Return true if INSN a normal instruction that can be deleted by the\n+   DCE pass.  */\n+\n+static bool\n+deletable_insn_p (rtx insn, bool fast)\n+{\n+  rtx x;\n+\n+  switch (GET_CODE (PATTERN (insn)))\n+    {\n+    case USE:\n+    case PREFETCH:\n+    case TRAP_IF:\n+      /* The UNSPEC case was added here because the ia-64 claims that\n+\t USEs do not work after reload and generates UNSPECS rather\n+\t than USEs.  Since dce is run after reload we need to avoid\n+\t deleting these even if they are dead.  If it turns out that\n+\t USEs really do work after reload, the ia-64 should be\n+\t changed, and the UNSPEC case can be removed.  */\n+    case UNSPEC:\n+      return false;\n+\n+    case CLOBBER:\n+      if (fast)\n+\t{\n+\t  /* A CLOBBER of a dead pseudo register serves no purpose.\n+\t     That is not necessarily true for hard registers until\n+\t     after reload.  */\n+\t  x = XEXP (PATTERN (insn), 0);\n+\t  return REG_P (x) && (!HARD_REGISTER_P (x) || reload_completed);\n+\t}\n+      else \n+\t/* Because of the way that use-def chains are built, it is not\n+\t   possible to tell if the clobber is dead because it can\n+\t   never be the target of a use-def chain.  */\n+\treturn false;\n+\n+    default:\n+      if (!NONJUMP_INSN_P (insn))\n+\treturn false;\n+\n+      if (volatile_insn_p (PATTERN (insn)))\n+\treturn false;\n+\n+      if (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))\n+\treturn false;\n+\n+      return true;\n+    }\n+}\n+\n+\n+/* Return true if INSN has not been marked as needed.  */\n+\n+static inline int\n+marked_insn_p (rtx insn)\n+{\n+  if (insn)\n+    return TEST_BIT (marked, INSN_UID (insn));\n+  else \n+    /* Artificial defs are always needed and they do not have an\n+       insn.  */\n+    return true;\n+}\n+\n+\n+/* If INSN has not yet been marked as needed, mark it now, and add it to\n+   the worklist.  */\n+\n+static void\n+mark_insn (rtx insn, bool fast)\n+{\n+  if (!marked_insn_p (insn))\n+    {\n+      if (!fast)\n+\tVEC_safe_push (rtx, heap, worklist, insn);\n+      SET_BIT (marked, INSN_UID (insn));\n+      if (dump_file)\n+\tfprintf (dump_file, \"  Adding insn %d to worklist\\n\", INSN_UID (insn));\n+    }\n+}\n+\n+\n+/* A note_stores callback used by mark_nonreg_stores.  DATA is the\n+   instruction containing DEST.  */\n+\n+static void\n+mark_nonreg_stores_1 (rtx dest, rtx pattern, void *data)\n+{\n+  if (GET_CODE (pattern) != CLOBBER && !REG_P (dest))\n+    mark_insn ((rtx) data, true);\n+}\n+\n+\n+/* A note_stores callback used by mark_nonreg_stores.  DATA is the\n+   instruction containing DEST.  */\n+\n+static void\n+mark_nonreg_stores_2 (rtx dest, rtx pattern, void *data)\n+{\n+  if (GET_CODE (pattern) != CLOBBER && !REG_P (dest))\n+    mark_insn ((rtx) data, false);\n+}\n+\n+\n+/* Mark INSN if BODY stores to a non-register destination.  */\n+\n+static void\n+mark_nonreg_stores (rtx body, rtx insn, bool fast)\n+{\n+  if (fast)\n+    note_stores (body, mark_nonreg_stores_1, insn);\n+  else\n+    note_stores (body, mark_nonreg_stores_2, insn);\n+}\n+\n+\n+/* Initialize global variables for a new DCE pass.  */\n+\n+static void\n+init_dce (bool fast)\n+{\n+  if (!df_in_progress)\n+    {\n+      if (!fast)\n+\tdf_chain_add_problem (DF_UD_CHAIN);\n+      df_analyze ();\n+    }\n+\n+  if (dump_file)\n+    df_dump (dump_file);\n+\n+  bitmap_obstack_initialize (&dce_blocks_bitmap_obstack);\n+  bitmap_obstack_initialize (&dce_tmp_bitmap_obstack);\n+  marked = sbitmap_alloc (get_max_uid () + 1);\n+  sbitmap_zero (marked);\n+}\n+\n+\n+/* Delete all REG_EQUAL notes of the registers INSN writes, to prevent\n+   bad dangling REG_EQUAL notes. */\n+\n+static void\n+delete_corresponding_reg_eq_notes (rtx insn)\n+{\n+  struct df_ref **def_rec;\n+  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      unsigned int regno = DF_REF_REGNO (def);\n+      /* This loop is a little tricky.  We cannot just go down the\n+\t chain because it is being modified by the actions in the\n+\t loop.  So we just get the head.  We plan to drain the list\n+\t anyway.  */\n+      while (DF_REG_EQ_USE_CHAIN (regno))\n+\t{\n+\t  struct df_ref *eq_use = DF_REG_EQ_USE_CHAIN (regno);\n+\t  rtx noted_insn = DF_REF_INSN (eq_use);\n+\t  rtx note = find_reg_note (noted_insn, REG_EQUAL, NULL_RTX);\n+\t  if (!note)\n+\t    note = find_reg_note (noted_insn, REG_EQUIV, NULL_RTX);\n+\n+\t  /* This assert is generally triggered when someone deletes a\n+\t     REG_EQUAL or REG_EQUIV note by hacking the list manually\n+\t     rather than calling remove_note.  */\n+\t  gcc_assert (note);\n+\t  remove_note (noted_insn, note);\n+\t}\n+    }\n+}\n+\n+\n+/* Delete every instruction that hasn't been marked.  Clear the insn\n+   from DCE_DF if DF_DELETE is true.  */\n+\n+static void\n+delete_unmarked_insns (void)\n+{\n+  basic_block bb;\n+  rtx insn, next;\n+\n+  something_changed = false;\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS_SAFE (bb, insn, next)\n+      if (INSN_P (insn))\n+\t{\n+\t  if (noop_move_p (insn))\n+\t    {\n+\t      /* Note that this code does not handle the case where\n+\t\t the last insn of libcall is deleted.  As it turns out\n+\t\t this case is excluded in the call to noop_move_p.  */\n+\t      rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n+\t      if (note && (XEXP (note, 0) != insn))\n+\t\t{\n+\t\t  rtx new_libcall_insn = next_real_insn (insn);\n+\t\t  rtx retval_note = find_reg_note (XEXP (note, 0),\n+\t\t\t\t\t\t   REG_RETVAL, NULL_RTX);\n+\t\t  REG_NOTES (new_libcall_insn)\n+\t\t    = gen_rtx_INSN_LIST (REG_LIBCALL, XEXP (note, 0),\n+\t\t\t\t\t REG_NOTES (new_libcall_insn));\n+\t\t  XEXP (retval_note, 0) = new_libcall_insn;\n+\t\t}\n+\t    }\n+\t  else if (marked_insn_p (insn))\n+\t    continue;\n+\n+\t  /* WARNING, this debugging can itself cause problems if the\n+\t     edge of the counter causes part of a libcall to be\n+\t     deleted but not all of it.  */\n+\t  if (!dbg_cnt (dce))\n+\t    continue;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"DCE: Deleting insn %d\\n\", INSN_UID (insn));\n+\n+          /* Before we delete the insn, we have to delete\n+             REG_EQUAL of the destination regs of the deleted insn\n+             to prevent dangling REG_EQUAL. */\n+          delete_corresponding_reg_eq_notes (insn);\n+\n+\t  delete_insn_and_edges (insn);\n+\t  something_changed = true;\n+\t}\n+}\n+\n+\n+/* Mark all insns using DELETE_PARM in the libcall that contains\n+   START_INSN.  */\n+static void \n+mark_libcall (rtx start_insn, bool delete_parm)\n+{\n+  rtx note = find_reg_note (start_insn, REG_LIBCALL_ID, NULL_RTX);\n+  int id = INTVAL (XEXP (note, 0));\n+  rtx insn;\n+\n+  mark_insn (start_insn, delete_parm);\n+  insn = NEXT_INSN (start_insn);\n+\n+  /* There are tales, long ago and far away, of the mystical nested\n+     libcall.  No one alive has actually seen one, but other parts of\n+     the compiler support them so we will here.  */\n+  for (insn = NEXT_INSN (start_insn); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  /* Stay in the loop as long as we are in any libcall.  */\n+\t  if ((note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX)))\n+\t    {\n+\t      if (id == INTVAL (XEXP (note, 0)))\n+\t\t{\n+\t\t  mark_insn (insn, delete_parm);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"matching forward libcall %d[%d]\\n\",\n+\t\t\t     INSN_UID (insn), id);\n+\t\t}\n+\t    }\n+\t  else \n+\t    break;\n+\t}\n+    }\n+  \n+  for (insn = PREV_INSN (start_insn); insn; insn = PREV_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  /* Stay in the loop as long as we are in any libcall.  */\n+\t  if ((note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX)))\n+\t    {\n+\t      if (id == INTVAL (XEXP (note, 0)))\n+\t\t{\n+\t\t  mark_insn (insn, delete_parm);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"matching backward libcall %d[%d]\\n\",\n+\t\t\t     INSN_UID (insn), id);\n+\t\t}\n+\t    }\n+\t  else \n+\t    break;\n+\t}\n+    }\n+}\n+\n+\n+/* Go through the instructions and mark those whose necessity is not\n+   dependent on inter-instruction information.  Make sure all other\n+   instructions are not marked.  */\n+\n+static void\n+prescan_insns_for_dce (bool fast)\n+{\n+  basic_block bb;\n+  rtx insn;\n+  \n+  if (dump_file)\n+    fprintf (dump_file, \"Finding needed instructions:\\n\");\n+  \n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+    if (INSN_P (insn))\n+      {\n+        rtx note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX);\n+        if (note)\n+          mark_libcall (insn, fast);\n+        else if (deletable_insn_p (insn, fast))\n+          mark_nonreg_stores (PATTERN (insn), insn, fast);\n+        else\n+          mark_insn (insn, fast);\n+      }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Finished finding needed instructions:\\n\");\n+}\n+\n+\n+/* UD-based DSE routines. */\n+\n+/* Mark instructions that define artifically-used registers, such as\n+   the frame pointer and the stack pointer.  */\n+\n+static void\n+mark_artificial_uses (void)\n+{\n+  basic_block bb;\n+  struct df_link *defs;\n+  struct df_ref **use_rec;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      for (use_rec = df_get_artificial_uses (bb->index); \n+\t   *use_rec; use_rec++)\n+\tfor (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t  mark_insn (DF_REF_INSN (defs->ref), false);\n+    }\n+}\n+\n+/* Mark every instruction that defines a register value that INSN uses.  */\n+\n+static void\n+mark_reg_dependencies (rtx insn)\n+{\n+  struct df_link *defs;\n+  struct df_ref **use_rec;\n+\n+  /* If this is part of a libcall, mark the entire libcall.  */\n+  if (find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX))\n+    mark_libcall (insn, false);\n+\n+  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Processing use of \");\n+\t  print_simple_rtl (dump_file, DF_REF_REG (use));\n+\t  fprintf (dump_file, \" in insn %d:\\n\", INSN_UID (insn));\n+\t}\n+      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n+\tmark_insn (DF_REF_INSN (defs->ref), false);\n+    }\n+}\n+\n+\n+static void\n+end_ud_dce (void)\n+{\n+  sbitmap_free (marked);\n+  gcc_assert (VEC_empty (rtx, worklist));\n+}\n+\n+\n+/* UD-chain based DCE.  */\n+\n+static unsigned int\n+rest_of_handle_ud_dce (void)\n+{\n+  rtx insn;\n+\n+  df_in_progress = false;\n+  init_dce (false);\n+\n+  prescan_insns_for_dce (false);\n+  mark_artificial_uses ();\n+  while (VEC_length (rtx, worklist) > 0)\n+    {\n+      insn = VEC_pop (rtx, worklist);\n+      mark_reg_dependencies (insn);\n+    }\n+  /* Before any insns are deleted, we must remove the chains since\n+     they are not bidirectional.  */\n+  df_remove_problem (df_chain);\n+  delete_unmarked_insns ();\n+\n+  end_ud_dce ();\n+  return 0;\n+}\n+\n+\n+static bool\n+gate_ud_dce (void)\n+{\n+  return optimize > 1 && flag_dce;\n+}\n+\n+struct tree_opt_pass pass_ud_rtl_dce =\n+{\n+  \"dce\",                                /* name */\n+  gate_ud_dce,                        /* gate */\n+  rest_of_handle_ud_dce,              /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_DCE,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_df_finish |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'w'                                   /* letter */\n+};\n+\n+/* -------------------------------------------------------------------------\n+   Fast DCE functions\n+   ------------------------------------------------------------------------- */\n+\n+\n+/* Free the data allocated by init_dce.  */\n+\n+static void\n+fini_dce (void)\n+{\n+  sbitmap_free (marked);\n+  bitmap_obstack_release (&dce_blocks_bitmap_obstack);\n+  bitmap_obstack_release (&dce_tmp_bitmap_obstack);\n+  df_in_progress = false;\n+}\n+\n+\n+/* Process basic block BB.  Return true if the live_in set has\n+   changed.  */\n+\n+static bool\n+dce_process_block (basic_block bb, bool redo_out)\n+{\n+  bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n+  rtx insn;\n+  bool block_changed;\n+  struct df_ref **def_rec, **use_rec;\n+  unsigned int bb_index = bb->index;\n+\n+  if (redo_out)\n+    {\n+      /* Need to redo the live_out set of this block if when one of\n+\t the succs of this block has had a change in it live in\n+\t set.  */\n+      edge e;\n+      edge_iterator ei;\n+      df_confluence_function_n con_fun_n = df_lr->problem->con_fun_n;\n+      bitmap_clear (DF_LR_OUT (bb));\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t(*con_fun_n) (e);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"processing block %d live out = \", bb->index);\n+      df_print_regset (dump_file, DF_LR_OUT (bb));\n+    }\n+\n+  bitmap_copy (local_live, DF_LR_OUT (bb));\n+\n+  /* Process the artificial defs and uses at the bottom of the block.  */\n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if (((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+\t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n+\tbitmap_clear_bit (local_live, DF_REF_REGNO (def));\n+    }\n+\n+  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n+\tbitmap_set_bit (local_live, DF_REF_REGNO (use));\n+    }\n+\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n+    if (INSN_P (insn))\n+      {\n+\t/* If this is a recursive call, the libcall will have already\n+\t   been marked.  */\n+\tif (!marked_insn_p (insn))\n+\t  {\t\n+\t    bool needed = false;\n+\n+\t    /* The insn is needed if there is someone who uses the output.  */\n+\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t      if (bitmap_bit_p (local_live, DF_REF_REGNO (*def_rec)))\n+\t\t{\n+\t\t  needed = true;\n+\t\t  break;\n+\t\t}\n+\t    \n+\t    if (needed)\n+\t      {\n+\t\trtx note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX);\n+\n+\t\t/* If we need to mark an insn in the middle of a\n+\t\t   libcall, we need to back up to mark the entire\n+\t\t   libcall.  Given that libcalls are rare, rescanning\n+\t\t   the block should be a reasonable solution to trying\n+\t\t   to figure out how to back up.  */\n+\t\tif (note)\n+\t\t  {\n+\t\t    if (dump_file)\n+\t\t      fprintf (dump_file, \"needed libcall %d\\n\", INSN_UID (insn));\n+\t\t    mark_libcall (insn, true);\n+\t\t    BITMAP_FREE (local_live);\n+\t\t    return dce_process_block (bb, false);\n+\t\t  }\n+\t\telse\n+\t\t  mark_insn (insn, true);\n+\t      }\n+\t  }\n+\t\n+\t/* No matter if the instruction is needed or not, we remove\n+\t   any regno in the defs from the live set.  */\n+\tdf_simulate_defs (insn, local_live);\n+\n+\t/* On the other hand, we do not allow the dead uses to set\n+\t   anything in local_live.  */\n+\tif (marked_insn_p (insn))\n+\t  df_simulate_uses (insn, local_live);\n+      }\n+  \n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n+\tbitmap_clear_bit (local_live, DF_REF_REGNO (def));\n+    }\n+#ifdef EH_USES\n+  /* Process the uses that are live into an exception handler.  */\n+  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+    {\n+      /* Add use to set of uses in this BB.  */\n+      struct df_ref *use = *use_rec;\n+      if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n+\tbitmap_set_bit (local_live, DF_REF_REGNO (use));\n+    }\n+#endif\n+\n+  block_changed = !bitmap_equal_p (local_live, DF_LR_IN (bb));\n+  if (block_changed)\n+    bitmap_copy (DF_LR_IN (bb), local_live);\n+\n+  BITMAP_FREE (local_live);\n+  return block_changed;\n+}\n+\n+static void\n+fast_dce (void)\n+{\n+  int *postorder = df_get_postorder (DF_BACKWARD);\n+  int n_blocks = df_get_n_blocks (DF_BACKWARD);\n+  int i;\n+  /* The set of blocks that have been seen on this iteration.  */\n+  bitmap processed = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n+  /* The set of blocks that need to have the out vectors reset because\n+     the in of one of their successors has changed.  */\n+  bitmap redo_out = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n+  bitmap all_blocks = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n+  bool global_changed = true;\n+\n+  int loop_count = 0;\n+\n+  prescan_insns_for_dce (true);\n+\n+  for (i = 0; i < n_blocks; i++)\n+    bitmap_set_bit (all_blocks, postorder[i]);\n+\n+  while (global_changed)\n+    {\n+      global_changed = false;\n+      for (i = 0; i < n_blocks; i++)\n+\t{\n+\t  int index = postorder[i];\n+\t  basic_block bb = BASIC_BLOCK (index);\n+\t  bool local_changed;\n+\n+\t  if (index < NUM_FIXED_BLOCKS)\n+\t    {\n+\t      bitmap_set_bit (processed, index);\n+\t      continue;\n+\t    }\n+\n+\t  local_changed \n+\t    = dce_process_block (bb, bitmap_bit_p (redo_out, index));\n+\t  bitmap_set_bit (processed, index);\n+\t  \n+\t  if (local_changed)\n+\t    {\n+\t      edge e;\n+\t      edge_iterator ei;\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\tif (bitmap_bit_p (processed, e->src->index))\n+\t\t  /* Be tricky about when we need to iterate the\n+\t\t     analysis.  We only have redo the analysis if the\n+\t\t     bitmaps change at the top of a block that is the\n+\t\t     entry to a loop.  */\n+\t\t  global_changed = true;\n+\t\telse\n+\t\t  bitmap_set_bit (redo_out, e->src->index);\n+\t    }\n+\t}\n+      \n+      if (global_changed)\n+\t{\n+\t  /* Turn off the RUN_DCE flag to prevent recursive calls to\n+\t     dce.  */\n+\t  int old_flag = df_clear_flags (DF_LR_RUN_DCE);\n+\n+\t  /* So something was deleted that requires a redo.  Do it on\n+\t     the cheap.  */\n+\t  delete_unmarked_insns ();\n+\t  sbitmap_zero (marked);\n+\t  bitmap_clear (processed);\n+\t  bitmap_clear (redo_out);\n+\t  \n+\t  /* We do not need to rescan any instructions.  We only need\n+\t     to redo the dataflow equations for the blocks that had a\n+\t     change at the top of the block.  Then we need to redo the\n+\t     iteration.  */ \n+\t  df_analyze_problem (df_lr, all_blocks, postorder, n_blocks);\n+\n+\t  if (old_flag & DF_LR_RUN_DCE)\n+\t    df_set_flags (DF_LR_RUN_DCE);\n+\t  prescan_insns_for_dce (true);\n+\t}\n+      loop_count++;\n+    }\n+\n+  delete_unmarked_insns ();\n+\n+  BITMAP_FREE (processed);\n+  BITMAP_FREE (redo_out);\n+  BITMAP_FREE (all_blocks);\n+}\n+\n+\n+/* Callback for running pass_rtl_dce.  */\n+\n+static unsigned int\n+rest_of_handle_fast_dce (void)\n+{\n+  init_dce (true);\n+  fast_dce ();\n+  fini_dce ();\n+  df_in_progress = false;\n+  return 0;\n+}\n+\n+\n+/* This is an internal call that is used by the df live register\n+   problem to run fast dce as a side effect of creating the live\n+   information.  The stack is organized so that the lr problem is run,\n+   this pass is run, which updates the live info and the df scanning\n+   info, and then returns to allow the rest of the problems to be run.\n+\n+   This can be called by elsewhere but it will not update the bit\n+   vectors for any other problems than LR.\n+*/\n+\n+void\n+run_fast_df_dce (void)\n+{\n+  if (flag_dce)\n+    {\n+      /* If dce is able to delete something, it has to happen\n+\t immediately.  Otherwise there will be problems handling the\n+\t eq_notes.  */\n+      enum df_changeable_flags old_flags \n+\t= df_clear_flags (DF_DEFER_INSN_RESCAN + DF_NO_INSN_RESCAN);\n+      \n+      df_in_progress = true;\n+      rest_of_handle_fast_dce ();\n+      df_set_flags (old_flags);\n+    }\n+}\n+\n+static bool\n+gate_fast_dce (void)\n+{\n+  return optimize > 0 && flag_dce;\n+}\n+\n+\n+/* Run a fast DCE pass and return true if any instructions were\n+   deleted.  */\n+\n+bool\n+run_fast_dce (void)\n+{\n+  return gate_fast_dce () && (rest_of_handle_fast_dce (), something_changed);\n+}\n+\n+\n+struct tree_opt_pass pass_fast_rtl_dce =\n+{\n+  \"dce\",                                /* name */\n+  gate_fast_dce,                        /* gate */\n+  rest_of_handle_fast_dce,              /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_DCE,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_df_finish |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'w'                                   /* letter */\n+};\n+"}, {"sha": "2971961d8edd9470e3ba20d1512b8b2fb76097a4", "filename": "gcc/dce.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -0,0 +1,29 @@\n+/* RTL dead code elimination.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef GCC_DCE_H\n+#define GCC_DCE_H\n+\n+struct df;\n+\n+extern bool run_fast_dce (void);\n+extern void run_fast_df_dce (void);\n+\n+#endif /* GCC_DCE_H */"}, {"sha": "7f298fb7e5b17f119199c6cd5a633310fcd50db0", "filename": "gcc/ddg.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* DDG - Data Dependence Graph implementation.\n-   Copyright (C) 2004, 2005, 2006\n+   Copyright (C) 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -43,7 +43,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"sbitmap.h\"\n #include \"expr.h\"\n #include \"bitmap.h\"\n-#include \"df.h\"\n #include \"ddg.h\"\n \n /* A flag indicating that a ddg edge belongs to an SCC or not.  */\n@@ -230,10 +229,10 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n    for all its uses in the next iteration, and an output dependence to the\n    first def of the next iteration.  */\n static void\n-add_deps_for_def (ddg_ptr g, struct df *df, struct df_ref *rd)\n+add_deps_for_def (ddg_ptr g, struct df_ref *rd)\n {\n   int regno = DF_REF_REGNO (rd);\n-  struct df_ru_bb_info *bb_info = DF_RU_BB_INFO (df, g->bb);\n+  struct df_ru_bb_info *bb_info = DF_RU_BB_INFO (g->bb);\n   struct df_link *r_use;\n   int use_before_def = false;\n   rtx def_insn = DF_REF_INSN (rd);\n@@ -265,7 +264,7 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct df_ref *rd)\n      there is a use between the two defs.  */\n   if (! use_before_def)\n     {\n-      struct df_ref *def = df_bb_regno_first_def_find (df, g->bb, regno);\n+      struct df_ref *def = df_bb_regno_first_def_find (g->bb, regno);\n       int i;\n       ddg_node_ptr dest_node;\n \n@@ -274,7 +273,7 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct df_ref *rd)\n \n       /* Check if there are uses after RD.  */\n       for (i = src_node->cuid + 1; i < g->num_nodes; i++)\n-\t if (df_find_use (df, g->nodes[i].insn, rd->reg))\n+\t if (df_find_use (g->nodes[i].insn, DF_REF_REG (rd)))\n \t   return;\n \n       dest_node = get_node_of_insn (g, def->insn);\n@@ -286,16 +285,16 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct df_ref *rd)\n    (nearest BLOCK_BEGIN) def of the next iteration, unless USE is followed\n    by a def in the block.  */\n static void\n-add_deps_for_use (ddg_ptr g, struct df *df, struct df_ref *use)\n+add_deps_for_use (ddg_ptr g, struct df_ref *use)\n {\n   int i;\n   int regno = DF_REF_REGNO (use);\n-  struct df_ref *first_def = df_bb_regno_first_def_find (df, g->bb, regno);\n+  struct df_ref *first_def = df_bb_regno_first_def_find (g->bb, regno);\n   ddg_node_ptr use_node;\n   ddg_node_ptr def_node;\n   struct df_rd_bb_info *bb_info;\n \n-  bb_info = DF_RD_BB_INFO (df, g->bb);\n+  bb_info = DF_RD_BB_INFO (g->bb);\n \n   if (!first_def)\n     return;\n@@ -307,7 +306,7 @@ add_deps_for_use (ddg_ptr g, struct df *df, struct df_ref *use)\n \n   /* Make sure there are no defs after USE.  */\n   for (i = use_node->cuid + 1; i < g->num_nodes; i++)\n-     if (df_find_def (df, g->nodes[i].insn, use->reg))\n+     if (df_find_def (g->nodes[i].insn, DF_REF_REG (use)))\n        return;\n   /* We must not add ANTI dep when there is an intra-loop TRUE dep in\n      the opposite direction. If the first_def reaches the USE then there is\n@@ -318,35 +317,35 @@ add_deps_for_use (ddg_ptr g, struct df *df, struct df_ref *use)\n \n /* Build inter-loop dependencies, by looking at DF analysis backwards.  */\n static void\n-build_inter_loop_deps (ddg_ptr g, struct df *df)\n+build_inter_loop_deps (ddg_ptr g)\n {\n   unsigned rd_num, u_num;\n   struct df_rd_bb_info *rd_bb_info;\n   struct df_ru_bb_info *ru_bb_info;\n   bitmap_iterator bi;\n \n-  rd_bb_info = DF_RD_BB_INFO (df, g->bb);\n+  rd_bb_info = DF_RD_BB_INFO (g->bb);\n \n   /* Find inter-loop output and true deps by connecting downward exposed defs\n      to the first def of the BB and to upwards exposed uses.  */\n   EXECUTE_IF_SET_IN_BITMAP (rd_bb_info->gen, 0, rd_num, bi)\n     {\n-      struct df_ref *rd = DF_DEFS_GET (df, rd_num);\n+      struct df_ref *rd = DF_DEFS_GET (rd_num);\n \n-      add_deps_for_def (g, df, rd);\n+      add_deps_for_def (g, rd);\n     }\n \n-  ru_bb_info = DF_RU_BB_INFO (df, g->bb);\n+  ru_bb_info = DF_RU_BB_INFO (g->bb);\n \n   /* Find inter-loop anti deps.  We are interested in uses of the block that\n      appear below all defs; this implies that these uses are killed.  */\n   EXECUTE_IF_SET_IN_BITMAP (ru_bb_info->kill, 0, u_num, bi)\n     {\n-      struct df_ref *use = DF_USES_GET (df, u_num);\n-\n-      /* We are interested in uses of this BB.  */\n-      if (BLOCK_FOR_INSN (use->insn) == g->bb)\n-      \tadd_deps_for_use (g, df, use);\n+      struct df_ref *use = DF_USES_GET (u_num);\n+      if (!(DF_REF_FLAGS (use) & DF_REF_IN_NOTE))\n+\t/* We are interested in uses of this BB.  */\n+\tif (BLOCK_FOR_INSN (use->insn) == g->bb)\n+\t  add_deps_for_use (g, use);\n     }\n }\n \n@@ -443,7 +442,7 @@ build_intra_loop_deps (ddg_ptr g)\n    of ddg type that represents it.\n    Initialize the ddg structure fields to the appropriate values.  */\n ddg_ptr\n-create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n+create_ddg (basic_block bb, int closing_branch_deps)\n {\n   ddg_ptr g;\n   rtx insn, first_note;\n@@ -520,7 +519,7 @@ create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n \n   /* Build the data dependency graph.  */\n   build_intra_loop_deps (g);\n-  build_inter_loop_deps (g, df);\n+  build_inter_loop_deps (g);\n   return g;\n }\n "}, {"sha": "ef293b0c04759b23abffb3b3ba6e025287ee0feb", "filename": "gcc/ddg.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* DDG - Data Dependence Graph - interface.\n-   Copyright (C) 2004\n+   Copyright (C) 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -27,7 +27,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"sbitmap.h\"\n /* For basic_block.  */\n #include \"basic-block.h\"\n-/* For struct df.  */\n #include \"df.h\"\n  \n typedef struct ddg_node *ddg_node_ptr;\n@@ -166,7 +165,7 @@ struct ddg_all_sccs\n };\n \n \f\n-ddg_ptr create_ddg (basic_block, struct df *, int closing_branch_deps);\n+ddg_ptr create_ddg (basic_block, int closing_branch_deps);\n void free_ddg (ddg_ptr);\n \n void print_ddg (FILE *, ddg_ptr);"}, {"sha": "56eb0390284e58ab033cebd5e26718235cc5085d", "filename": "gcc/df-core.c", "status": "modified", "additions": 1237, "deletions": 480, "changes": 1717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Allocation for dataflow support routines.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n@@ -36,51 +36,57 @@ dataflow problems: reaching defs, upward exposed uses, live variables,\n uninitialized variables, def-use chains, and use-def chains.  However,\n the interface allows other dataflow problems to be defined as well.\n \n+Dataflow analysis is available in most of the rtl backend (the parts\n+between pass_df_initialize and pass_df_finish).  It is quite likely\n+that these boundaries will be expanded in the future.  The only\n+requirement is that there be a correct control flow graph.\n \n-USAGE:\n-\n-Here is an example of using the dataflow routines.\n-\n-      struct df *df;\n+There are three variations of the live variable problem that are\n+available whenever dataflow is available.  The LR problem finds the\n+areas that can reach a use of a variable, the UR problems finds the\n+areas tha can be reached from a definition of a variable.  The LIVE\n+problem finds the intersection of these two areas.  \n \n-      df = df_init (init_flags);\n-      \n-      df_add_problem (df, problem, flags);\n+There are several optional problems.  These can be enabled when they\n+are needed and disabled when they are not needed.\n \n-      df_set_blocks (df, blocks);\n+Dataflow problems are generally solved in three layers.  The bottom\n+layer is called scanning where a data structure is built for each rtl\n+insn that describes the set of defs and uses of that insn.  Scanning\n+is generally kept up to date, i.e. as the insns changes, the scanned\n+version of that insn changes also.  There are various mechanisms for\n+making this happen and are described in the INCREMENTAL SCANNING\n+section.\n \n-      df_rescan_blocks (df, blocks);\n+In the middle layer, basic blocks are scanned to produce transfer\n+functions which describe the effects of that block on the a global\n+dataflow solution.  The transfer functions are only rebuilt if the\n+some instruction within the block has changed.  \n \n-      df_analyze (df);\n-\n-      df_dump (df, stderr);\n-\n-      df_finish (df);\n+The top layer is the dataflow solution itself.  The dataflow solution\n+is computed by using an efficient iterative solver and the trasfer\n+functions.  The dataflow solution must be recomputed whenever the\n+control changes or if one of the transfer function changes.\n \n \n+USAGE:\n \n-DF_INIT simply creates a poor man's object (df) that needs to be\n-passed to all the dataflow routines.  df_finish destroys this object\n-and frees up any allocated memory.\n+Here is an example of using the dataflow routines.\n \n-There are three flags that can be passed to df_init, each of these\n-flags controls the scanning of the rtl:\n+      df_[ru,rd,urec,ri,chain]_add_problem (flags);\n \n-DF_HARD_REGS means that the scanning is to build information about\n-both pseudo registers and hardware registers.  Without this\n-information, the problems will be solved only on pseudo registers.\n-DF_EQUIV_NOTES marks the uses present in EQUIV/EQUAL notes.\n-DF_SUBREGS return subregs rather than the inner reg.\n+      df_set_blocks (blocks);\n \n+      df_analyze ();\n \n-DF_ADD_PROBLEM adds a problem, defined by an instance to struct\n-df_problem, to the set of problems solved in this instance of df.  All\n-calls to add a problem for a given instance of df must occur before\n-the first call to DF_RESCAN_BLOCKS, DF_SET_BLOCKS or DF_ANALYZE.\n+      df_dump (stderr);\n \n-For all of the problems defined in df-problems.c, there are\n-convenience functions named DF_*_ADD_PROBLEM.\n+      df_finish_pass ();\n \n+DF_[ru,rd,urec,ri,chain]_ADD_PROBLEM adds a problem, defined by an\n+instance to struct df_problem, to the set of problems solved in this\n+instance of df.  All calls to add a problem for a given instance of df\n+must occur before the first call to DF_ANALYZE.\n \n Problems can be dependent on other problems.  For instance, solving\n def-use or use-def chains is dependent on solving reaching\n@@ -95,40 +101,117 @@ that case, df will just be used to do the scanning.\n DF_SET_BLOCKS is an optional call used to define a region of the\n function on which the analysis will be performed.  The normal case is\n to analyze the entire function and no call to df_set_blocks is made.\n+DF_SET_BLOCKS only effects the blocks that are effected when computing\n+the transfer functions and final solution.  The insn level information\n+is always kept up to date.\n \n When a subset is given, the analysis behaves as if the function only\n contains those blocks and any edges that occur directly between the\n blocks in the set.  Care should be taken to call df_set_blocks right\n before the call to analyze in order to eliminate the possibility that\n optimizations that reorder blocks invalidate the bitvector.\n \n-\n-\n-DF_RESCAN_BLOCKS is an optional call that causes the scanner to be\n- (re)run over the set of blocks passed in.  If blocks is NULL, the entire\n-function (or all of the blocks defined in df_set_blocks) is rescanned.\n-If blocks contains blocks that were not defined in the call to\n-df_set_blocks, these blocks are added to the set of blocks.\n-\n-\n-DF_ANALYZE causes all of the defined problems to be (re)solved.  It\n-does not cause blocks to be (re)scanned at the rtl level unless no\n-prior call is made to df_rescan_blocks.  When DF_ANALYZE is completes,\n-the IN and OUT sets for each basic block contain the computer\n-information.  The DF_*_BB_INFO macros can be used to access these\n-bitvectors.\n-\n+DF_ANALYZE causes all of the defined problems to be (re)solved.  When\n+DF_ANALYZE is completes, the IN and OUT sets for each basic block\n+contain the computer information.  The DF_*_BB_INFO macros can be used\n+to access these bitvectors.  All defered rescannings are down before\n+the transfer functions are recompited.\n \n DF_DUMP can then be called to dump the information produce to some\n-file.\n-\n-\n-\n-DF_FINISH causes all of the datastructures to be cleaned up and freed.\n-The df_instance is also freed and its pointer should be NULLed.\n-\n-\n-\n+file.  This calls DF_DUMP_START, to print the information that is not\n+basic block specific, and then calls DF_DUMP_TOP and DF_DUMP_BOTTOM\n+for each block to print the basic specific information.  These parts\n+can all be called separately as part of a larger dump function.\n+\n+\n+DF_FINISH_PASS causes df_remove_problem to be called on all of the\n+optional problems.  It also causes any insns whose scanning has been\n+defered to be rescanned as well as clears all of the changeable flags.\n+Setting the pass manager TODO_df_finish flag causes this function to\n+be run.  However, the pass manager will call df_finish_pass AFTER the\n+pass dumping has been done, so if you want to see the results of the\n+optional problems in the pass dumps, use the TODO flag rather than\n+calling the function yourself.\n+\n+INCREMENTAL SCANNING\n+\n+There are four ways of doing the incremental scanning:\n+\n+1) Immediate rescanning - Calls to df_insn_rescan, df_notes_rescan,\n+   df_bb_delete, df_insn_change_bb have been added to most of\n+   the low level service functions that maintain the cfg and change\n+   rtl.  Calling and of these routines many cause some number of insns\n+   to be rescanned.\n+\n+   For most modern rtl passes, this is certainly the easiest way to\n+   manage rescanning the insns.  This technique also has the advantage\n+   that the scanning information is always correct and can be relied\n+   apon even after changes have been made to the instructions.  This\n+   technique is contra indicated in several cases:\n+\n+   a) If def-use chains OR use-def chains (but not both) are built,\n+      using this is SIMPLY WRONG.  The problem is that when a ref is\n+      deleted that is the target of an edge, there is not enough\n+      information to efficiently find the source of the edge and\n+      delete the edge.  This leaves a dangling reference that may\n+      cause problems.\n+\n+   b) If def-use chains AND use-def chains are built, this may\n+      produce unexpected results.  The problem is that the incremental\n+      scanning of an insn does not know how to repair the chains that\n+      point into an insn when the insn changes.  So the incremental\n+      scanning just deletes the chains that enter and exit the insn\n+      being changed.  The dangling reference issue in (a) is not a\n+      problem here, but if the pass is depending on the chains being\n+      maintained after insns have been modified, this technique will\n+      not do the correct thing.\n+\n+   c) If the pass modifies insns several times, this incremental\n+      updating may be expensive.\n+\n+   d) If the pass modifies all of the insns, as does register\n+      allocation, it is simply better to rescan the entire function.\n+\n+   e) If the pass uses either non-standard or ancient techniques to\n+      modify insns, automatic detection of the insns that need to be\n+      rescanned may be impractical.  Cse and regrename fall into this\n+      category.\n+\n+2) Defered rescanning - Calls to df_insn_rescan, df_notes_rescan, and\n+   df_insn_delete do not immediately change the insn but instead make\n+   a note that the insn needs to be rescanned.  The next call to\n+   df_analyze, df_finish_pass, or df_process_deferred_rescans will\n+   cause all of the pending rescans to be processed.\n+\n+   This is the technique of choice if either 1a, 1b, or 1c are issues\n+   in the pass.  In the case of 1a or 1b, a call to df_remove_problem\n+   (df_chain) should be made before the next call to df_analyze or\n+   df_process_deferred_rescans.\n+\n+   To enable this mode, call df_set_flags (DF_DEFER_INSN_RESCAN).\n+   (This mode can be cleared by calling df_clear_flags\n+   (DF_DEFER_INSN_RESCAN) but this does not cause the defered insns to\n+   be rescanned.\n+\n+   3) Total rescanning - In this mode the rescanning is disabled.\n+   However, the df information associated with deleted insn is delete\n+   at the time the insn is deleted.  At the end of the pass, a call\n+   must be made to df_insn_rescan_all.  This method is used by the\n+   register allocator since it generally changes each insn multiple\n+   times (once for each ref) and does not need to make use of the\n+   updated scanning information.\n+\n+   It is also currently used by two older passes (cse, and regrename)\n+   which change insns in hard to track ways.  It is hoped that this\n+   will be fixed soon since this it is expensive to rescan all of the\n+   insns when only a small number of them have really changed.\n+\n+4) Do it yourself - In this mechanism, the pass updates the insns\n+   itself using the low level df primatives.  Currently no pass does\n+   this, but it has the advantage that it is quite efficient given\n+   that the pass generally has exact knowledge of what it is changing.  \n+\n+DATA STRUCTURES\n \n Scanning produces a `struct df_ref' data structure (ref) is allocated\n for every register reference (def or use) and this records the insn\n@@ -145,7 +228,6 @@ The rest of the backend should be upgraded to using and maintaining\n the linked information such as def use or use def chains.\n \n \n-\n PHILOSOPHY:\n \n While incremental bitmaps are not worthwhile to maintain, incremental\n@@ -186,26 +268,39 @@ register.\n Note that the reg-def and reg-use chains are generally short for\n pseudos and long for the hard registers.\n \n+ACCESSING INSNS:\n+\n+1) The df insn information is kept in the insns array.  This array is\n+   indexed by insn uid.  \n+\n+2) Each insn has three sets of refs: They are linked into one of three\n+   lists: the insn's defs list (accessed by the DF_INSN_DEFS or\n+   DF_INSN_UID_DEFS macros), the insn's uses list (accessed by the\n+   DF_INSN_USES or DF_INSN_UID_USES macros) or the insn's eq_uses list\n+   (accessed by the DF_INSN_EQ_USES or DF_INSN_UID_EQ_USES macros).\n+   The latter list are the list of references in REG_EQUAL or\n+   REG_EQUIV notes.  These macros produce a ref (or NULL), the rest of\n+   the list can be obtained by traversal of the NEXT_REF field\n+   (accessed by the DF_REF_NEXT_REF macro.)  There is no significance\n+   to the ordering of the uses or refs in an instruction.\n+\n+3) Each insn has a logical uid field (LUID).  When properly set, this\n+   is an integer that numbers each insn in the basic block, in order from\n+   the start of the block.  The numbers are only correct after a call to\n+   df_analyse.  They will rot after insns are added deleted or moved\n+   around.\n+\n ACCESSING REFS:\n \n There are 4 ways to obtain access to refs:\n \n 1) References are divided into two categories, REAL and ARTIFICIAL.\n \n-   REAL refs are associated with instructions.  They are linked into\n-   either in the insn's defs list (accessed by the DF_INSN_DEFS or\n-   DF_INSN_UID_DEFS macros) or the insn's uses list (accessed by the\n-   DF_INSN_USES or DF_INSN_UID_USES macros).  These macros produce a\n-   ref (or NULL), the rest of the list can be obtained by traversal of\n-   the NEXT_REF field (accessed by the DF_REF_NEXT_REF macro.)  There\n-   is no significance to the ordering of the uses or refs in an\n-   instruction.\n+   REAL refs are associated with instructions.  \n \n    ARTIFICIAL refs are associated with basic blocks.  The heads of\n-   these lists can be accessed by calling get_artificial_defs or\n-   get_artificial_uses for the particular basic block.  Artificial\n-   defs and uses are only there if DF_HARD_REGS was specified when the\n-   df instance was created.\n+   these lists can be accessed by calling df_get_artificial_defs or\n+   df_get_artificial_uses for the particular basic block.  \n  \n    Artificial defs and uses occur both at the beginning and ends of blocks.\n \n@@ -225,34 +320,45 @@ There are 4 ways to obtain access to refs:\n      Artificial defs occur at the end of the entry block.  These arise\n      from registers that are live at entry to the function.\n \n-2) All of the uses and defs associated with each pseudo or hard\n-   register are linked in a bidirectional chain.  These are called\n-   reg-use or reg_def chains.\n+2) There are three types of refs: defs, uses and eq_uses.  (Eq_uses are \n+   uses that appear inside a REG_EQUAL or REG_EQUIV note.)\n \n-   The first use (or def) for a register can be obtained using the\n-   DF_REG_USE_GET macro (or DF_REG_DEF_GET macro).  Subsequent uses\n-   for the same regno can be obtained by following the next_reg field\n-   of the ref.\n+   All of the eq_uses, uses and defs associated with each pseudo or\n+   hard register may be linked in a bidirectional chain.  These are\n+   called reg-use or reg_def chains.  If the changeable flag\n+   DF_EQ_NOTES is set when the chains are built, the eq_uses will be\n+   treated like uses.  If it is not set they are ignored.  \n+\n+   The first use, eq_use or def for a register can be obtained using\n+   the DF_REG_USE_CHAIN, DF_REG_EQ_USE_CHAIN or DF_REG_DEF_CHAIN\n+   macros.  Subsequent uses for the same regno can be obtained by\n+   following the next_reg field of the ref.  The number of elements in\n+   each of the chains can be found by using the DF_REG_USE_COUNT,\n+   DF_REG_EQ_USE_COUNT or DF_REG_DEF_COUNT macros.\n \n    In previous versions of this code, these chains were ordered.  It\n    has not been practical to continue this practice.\n \n 3) If def-use or use-def chains are built, these can be traversed to\n-   get to other refs.\n+   get to other refs.  If the flag DF_EQ_NOTES has been set, the chains\n+   include the eq_uses.  Otherwise these are ignored when building the\n+   chains.\n \n 4) An array of all of the uses (and an array of all of the defs) can\n+\n    be built.  These arrays are indexed by the value in the id\n    structure.  These arrays are only lazily kept up to date, and that\n    process can be expensive.  To have these arrays built, call\n-   df_reorganize_refs.   Note that the values in the id field of a ref\n-   may change across calls to df_analyze or df_reorganize refs.\n+   df_reorganize_defs or df_reorganize_uses.  If the flag DF_EQ_NOTES\n+   has been set the array will contain the eq_uses.  Otherwise these\n+   are ignored when building the array and assigning the ids.  Note\n+   that the values in the id field of a ref may change across calls to\n+   df_analyze or df_reorganize_defs or df_reorganize_uses. \n \n    If the only use of this array is to find all of the refs, it is\n    better to traverse all of the registers and then traverse all of\n    reg-use or reg-def chains.\n \n-\n-\n NOTES:\n  \n Embedded addressing side-effects, such as POST_INC or PRE_INC, generate\n@@ -296,113 +402,118 @@ are write-only operations.\n #include \"df.h\"\n #include \"tree-pass.h\"\n \n-static struct df *ddf = NULL;\n-struct df *shared_df = NULL;\n-\n static void *df_get_bb_info (struct dataflow *, unsigned int);\n static void df_set_bb_info (struct dataflow *, unsigned int, void *);\n-/*----------------------------------------------------------------------------\n-  Functions to create, destroy and manipulate an instance of df.\n-----------------------------------------------------------------------------*/\n+#ifdef DF_DEBUG_CFG\n+static void df_set_clean_cfg (void);\n+#endif\n \n+/* An obstack for bitmap not related to specific dataflow problems.\n+   This obstack should e.g. be used for bitmaps with a short life time\n+   such as temporary bitmaps.  */\n \n-/* Initialize dataflow analysis and allocate and initialize dataflow\n-   memory.  */\n+bitmap_obstack df_bitmap_obstack;\n \n-struct df *\n-df_init (int flags)\n-{\n-  struct df *df = XCNEW (struct df);\n \n-  /* This is executed once per compilation to initialize platform\n-     specific data structures. */\n-  df_hard_reg_init ();\n-  \n-  /* All df instance must define the scanning problem.  */\n-  df_scan_add_problem (df, flags);\n-  ddf = df;\n-  return df;\n-}\n+/*----------------------------------------------------------------------------\n+  Functions to create, destroy and manipulate an instance of df.\n+----------------------------------------------------------------------------*/\n+\n+struct df *df;\n \n-/* Add PROBLEM to the DF instance.  */\n+/* Add PROBLEM (and any dependent problems) to the DF instance.  */\n \n-struct dataflow *\n-df_add_problem (struct df *df, struct df_problem *problem, int flags)\n+void\n+df_add_problem (struct df_problem *problem)\n {\n   struct dataflow *dflow;\n+  int i;\n \n   /* First try to add the dependent problem. */\n-  if (problem->dependent_problem_fun)\n-    (problem->dependent_problem_fun) (df, 0);\n+  if (problem->dependent_problem)\n+    df_add_problem (problem->dependent_problem);\n \n   /* Check to see if this problem has already been defined.  If it\n      has, just return that instance, if not, add it to the end of the\n      vector.  */\n   dflow = df->problems_by_index[problem->id];\n   if (dflow)\n-    return dflow;\n+    return;\n \n   /* Make a new one and add it to the end.  */\n   dflow = XCNEW (struct dataflow);\n-  dflow->flags = flags;\n-  dflow->df = df;\n   dflow->problem = problem;\n-  df->problems_in_order[df->num_problems_defined++] = dflow;\n+  dflow->computed = false;\n+  dflow->solutions_dirty = true;\n   df->problems_by_index[dflow->problem->id] = dflow;\n \n-  return dflow;\n+  /* Keep the defined problems ordered by index.  This solves the\n+     problem that RI will use the information from UREC if UREC has\n+     been defined, or from LIVE if LIVE is defined and otherwise LR.\n+     However for this to work, the computation of RI must be pushed\n+     after which ever of those problems is defined, but we do not\n+     require any of those except for LR to have actually been\n+     defined.  */ \n+  df->num_problems_defined++;\n+  for (i = df->num_problems_defined - 2; i >= 0; i--)\n+    {\n+      if (problem->id < df->problems_in_order[i]->problem->id)\n+\tdf->problems_in_order[i+1] = df->problems_in_order[i];\n+      else\n+\t{\n+\t  df->problems_in_order[i+1] = dflow;\n+\t  return;\n+\t}\n+    }\n+  df->problems_in_order[0] = dflow;\n }\n \n \n /* Set the MASK flags in the DFLOW problem.  The old flags are\n    returned.  If a flag is not allowed to be changed this will fail if\n    checking is enabled.  */\n-int \n-df_set_flags (struct dataflow *dflow, int mask)\n+enum df_changeable_flags\n+df_set_flags (enum df_changeable_flags changeable_flags)\n {\n-  int old_flags = dflow->flags;\n-\n-  gcc_assert (!(mask & (~dflow->problem->changeable_flags)));\n-\n-  dflow->flags |= mask;\n-\n+  enum df_changeable_flags old_flags = df->changeable_flags;\n+  df->changeable_flags |= changeable_flags;\n   return old_flags;\n }\n \n+\n /* Clear the MASK flags in the DFLOW problem.  The old flags are\n    returned.  If a flag is not allowed to be changed this will fail if\n    checking is enabled.  */\n-int \n-df_clear_flags (struct dataflow *dflow, int mask)\n+enum df_changeable_flags\n+df_clear_flags (enum df_changeable_flags changeable_flags)\n {\n-  int old_flags = dflow->flags;\n-\n-  gcc_assert (!(mask & (~dflow->problem->changeable_flags)));\n-\n-  dflow->flags &= !mask;\n-\n+  enum df_changeable_flags old_flags = df->changeable_flags;\n+  df->changeable_flags &= ~changeable_flags;\n   return old_flags;\n }\n \n+\n /* Set the blocks that are to be considered for analysis.  If this is\n    not called or is called with null, the entire function in\n    analyzed.  */\n \n void \n-df_set_blocks (struct df *df, bitmap blocks)\n+df_set_blocks (bitmap blocks)\n {\n   if (blocks)\n     {\n+      if (dump_file)\n+\tbitmap_print (dump_file, blocks, \"setting blocks to analyze \", \"\\n\");\n       if (df->blocks_to_analyze)\n \t{\n \t  int p;\n-\t  bitmap diff = BITMAP_ALLOC (NULL);\n+\t  bitmap diff = BITMAP_ALLOC (&df_bitmap_obstack);\n \t  bitmap_and_compl (diff, df->blocks_to_analyze, blocks);\n-\t  for (p = df->num_problems_defined - 1; p >= 0 ;p--)\n+\t  for (p = df->num_problems_defined - 1; p >= DF_FIRST_OPTIONAL_PROBLEM ;p--)\n \t    {\n \t      struct dataflow *dflow = df->problems_in_order[p];\n \t      if (dflow->problem->reset_fun)\n-\t\tdflow->problem->reset_fun (dflow, df->blocks_to_analyze);\n+\t\tdflow->problem->reset_fun (df->blocks_to_analyze);\n \t      else if (dflow->problem->free_bb_fun)\n \t\t{\n \t\t  bitmap_iterator bi;\n@@ -413,9 +524,12 @@ df_set_blocks (struct df *df, bitmap blocks)\n \t\t      basic_block bb = BASIC_BLOCK (bb_index);\n \t\t      if (bb)\n \t\t\t{\n-\t\t\t  dflow->problem->free_bb_fun\n-\t\t\t    (dflow, bb, df_get_bb_info (dflow, bb_index));\n-\t\t\t  df_set_bb_info (dflow, bb_index, NULL); \n+\t\t\t  void *bb_info = df_get_bb_info (dflow, bb_index);\n+\t\t\t  if (bb_info)\n+\t\t\t    {\n+\t\t\t      dflow->problem->free_bb_fun (bb, bb_info);\n+\t\t\t      df_set_bb_info (dflow, bb_index, NULL);\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -427,280 +541,471 @@ df_set_blocks (struct df *df, bitmap blocks)\n \t{\n \t  /* If we have not actually run scanning before, do not try\n \t     to clear anything.  */\n-\t  struct dataflow *scan_dflow = df->problems_by_index [DF_SCAN];\n-\t  if (scan_dflow->problem_data)\n+\t  if (df_scan->problem_data)\n \t    {\n \t      bitmap blocks_to_reset = NULL;\n \t      int p;\n-\t      for (p = df->num_problems_defined - 1; p >= 0 ;p--)\n+\t      for (p = df->num_problems_defined - 1; p >= DF_FIRST_OPTIONAL_PROBLEM ;p--)\n \t\t{\n \t\t  struct dataflow *dflow = df->problems_in_order[p];\n \t\t  if (dflow->problem->reset_fun)\n \t\t    {\n \t\t      if (!blocks_to_reset)\n \t\t\t{\n \t\t\t  basic_block bb;\n-\t\t\t  blocks_to_reset = BITMAP_ALLOC (NULL);\n+\t\t\t  blocks_to_reset =\n+\t\t\t    BITMAP_ALLOC (&df_bitmap_obstack);\n \t\t\t  FOR_ALL_BB(bb)\n \t\t\t    {\n \t\t\t      bitmap_set_bit (blocks_to_reset, bb->index); \n \t\t\t    }\n \t\t\t}\n-\t\t      dflow->problem->reset_fun (dflow, blocks_to_reset);\n+\t\t      dflow->problem->reset_fun (blocks_to_reset);\n \t\t    }\n \t\t}\n \t      if (blocks_to_reset)\n \t\tBITMAP_FREE (blocks_to_reset);\n \t    }\n-\t  df->blocks_to_analyze = BITMAP_ALLOC (NULL);\n+\t  df->blocks_to_analyze = BITMAP_ALLOC (&df_bitmap_obstack);\n \t}\n       bitmap_copy (df->blocks_to_analyze, blocks);\n+      df->analyze_subset = true;\n     }\n   else\n     {\n+      if (dump_file)\n+\tfprintf (dump_file, \"clearing blocks to analyze\\n\");\n       if (df->blocks_to_analyze)\n \t{\n \t  BITMAP_FREE (df->blocks_to_analyze);\n \t  df->blocks_to_analyze = NULL;\n \t}\n+      df->analyze_subset = false;\n     }\n+\n+  /* Setting the blocks causes the refs to be unorganized since only\n+     the refs in the blocks are seen.  */\n+  df_maybe_reorganize_def_refs (DF_REF_ORDER_NO_TABLE);\n+  df_maybe_reorganize_use_refs (DF_REF_ORDER_NO_TABLE);\n+  df_mark_solutions_dirty ();\n }\n \n \n-/* Free all of the per basic block dataflow from all of the problems.\n-   This is typically called before a basic block is deleted and the\n-   problem will be reanalyzed.  */\n+/* Delete a DFLOW problem (and any problems that depend on this\n+   problem).  */\n \n void\n-df_delete_basic_block (struct df *df, int bb_index)\n+df_remove_problem (struct dataflow *dflow)\n {\n-  basic_block bb = BASIC_BLOCK (bb_index);\n+  struct df_problem *problem;\n   int i;\n-  \n-  for (i = 0; i < df->num_problems_defined; i++)\n+  int start = 0;\n+\n+  if (!dflow)\n+    return;\n+\n+  problem = dflow->problem;\n+  gcc_assert (problem->remove_problem_fun);\n+\n+  /* Normally only optional problems are removed, but during global,\n+     we remove ur and live and replace it with urec.  */\n+  if (problem->id >= DF_FIRST_OPTIONAL_PROBLEM)\n+    start = DF_FIRST_OPTIONAL_PROBLEM;\n+\n+  /* Delete any problems that depended on this problem first.  */\n+  for (i = start; i < df->num_problems_defined; i++)\n+    if (df->problems_in_order[i]->problem->dependent_problem == problem)\n+      df_remove_problem (df->problems_in_order[i]);\n+\n+  /* Now remove this problem.  */\n+  for (i = start; i < df->num_problems_defined; i++)\n+    if (df->problems_in_order[i] == dflow)\n+      {\n+\tint j;\n+\tfor (j = i + 1; j < df->num_problems_defined; j++)\n+\t  df->problems_in_order[j-1] = df->problems_in_order[j];\n+\tdf->problems_in_order[j] = NULL;\n+\tdf->num_problems_defined--;\n+\tbreak;\n+      }\n+\n+  (problem->remove_problem_fun) ();\n+  df->problems_by_index[problem->id] = NULL;\n+}\n+\n+\n+/* Remove all of the problems that are not permanent.  Scanning, lr,\n+   ur and live are permanent, the rest are removeable.  Also clear all\n+   of the changeable_flags.  */\n+\n+void\n+df_finish_pass (void)\n+{\n+  int i;\n+  int removed = 0;\n+\n+#ifdef ENABLE_CHECKING\n+  enum df_changeable_flags saved_flags;\n+#endif\n+\n+  if (!df)\n+    return;\n+\n+  df_maybe_reorganize_def_refs (DF_REF_ORDER_NO_TABLE);\n+  df_maybe_reorganize_use_refs (DF_REF_ORDER_NO_TABLE);\n+\n+#ifdef ENABLE_CHECKING\n+  saved_flags = df->changeable_flags;\n+#endif\n+\n+  for (i = DF_FIRST_OPTIONAL_PROBLEM; i < df->num_problems_defined; i++)\n     {\n       struct dataflow *dflow = df->problems_in_order[i];\n-      if (dflow->problem->free_bb_fun)\n-\tdflow->problem->free_bb_fun \n-\t  (dflow, bb, df_get_bb_info (dflow, bb_index)); \n+      struct df_problem *problem = dflow->problem;\n+\n+      gcc_assert (problem->remove_problem_fun);\n+      (problem->remove_problem_fun) ();\n+      df->problems_in_order[i] = NULL;\n+      df->problems_by_index[problem->id] = NULL;\n+      removed++;\n+    }\n+  df->num_problems_defined -= removed;\n+\n+  /* Clear all of the flags.  */\n+  df->changeable_flags = 0;\n+  df_process_deferred_rescans ();\n+\n+  /* Set the focus back to the whole function.  */\n+  if (df->blocks_to_analyze)\n+    {\n+      BITMAP_FREE (df->blocks_to_analyze);\n+      df->blocks_to_analyze = NULL;\n+      df_mark_solutions_dirty ();\n+      df->analyze_subset = false;\n     }\n+\n+#ifdef ENABLE_CHECKING\n+  /* Verification will fail in DF_NO_INSN_RESCAN.  */\n+  if (!(saved_flags & DF_NO_INSN_RESCAN))\n+    {\n+      df_lr_verify_transfer_functions ();\n+      if (df_live)\n+\tdf_live_verify_transfer_functions ();\n+    }\n+\n+#ifdef DF_DEBUG_CFG\n+  df_set_clean_cfg ();\n+#endif\n+#endif\n+}\n+\n+\n+/* Set up the dataflow instance for the entire back end.  */\n+\n+static unsigned int\n+rest_of_handle_df_initialize (void)\n+{\n+  gcc_assert (!df);\n+  df = XCNEW (struct df);\n+  df->changeable_flags = 0;\n+\n+  bitmap_obstack_initialize (&df_bitmap_obstack);\n+\n+  /* Set this to a conservative value.  Stack_ptr_mod will compute it\n+     correctly later.  */\n+  current_function_sp_is_unchanging = 0;\n+\n+  df_scan_add_problem ();\n+  df_scan_alloc (NULL);\n+\n+  /* These three problems are permanent.  */\n+  df_lr_add_problem ();\n+  if (optimize)\n+    df_live_add_problem ();\n+\n+  df->postorder = XNEWVEC (int, last_basic_block);\n+  df->postorder_inverted = XNEWVEC (int, last_basic_block);\n+  df->n_blocks = post_order_compute (df->postorder, true, true);\n+  df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n+  gcc_assert (df->n_blocks == df->n_blocks_inverted);\n+\n+  df->hard_regs_live_count = XNEWVEC (unsigned int, FIRST_PSEUDO_REGISTER);\n+  memset (df->hard_regs_live_count, 0, \n+\t  sizeof (unsigned int) * FIRST_PSEUDO_REGISTER);\n+\n+  df_hard_reg_init ();\n+  /* After reload, some ports add certain bits to regs_ever_live so\n+     this cannot be reset.  */\n+  df_compute_regs_ever_live (true);\n+  df_scan_blocks ();\n+  df_compute_regs_ever_live (false);\n+  return 0;\n+}\n+\n+\n+static bool\n+gate_opt (void)\n+{\n+  return optimize > 0;\n }\n \n \n+struct tree_opt_pass pass_df_initialize_opt =\n+{\n+  \"dfinit\",                             /* name */\n+  gate_opt,                             /* gate */\n+  rest_of_handle_df_initialize,         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  'z'                                   /* letter */\n+};\n+\n+\n+static bool\n+gate_no_opt (void)\n+{\n+  return optimize == 0;\n+}\n+\n+\n+struct tree_opt_pass pass_df_initialize_no_opt =\n+{\n+  \"dfinit\",                             /* name */\n+  gate_no_opt,                          /* gate */\n+  rest_of_handle_df_initialize,         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  'z'                                   /* letter */\n+};\n+\n+\n /* Free all the dataflow info and the DF structure.  This should be\n    called from the df_finish macro which also NULLs the parm.  */\n \n-void\n-df_finish1 (struct df *df)\n+static unsigned int\n+rest_of_handle_df_finish (void)\n {\n   int i;\n \n+  gcc_assert (df);\n+\n   for (i = 0; i < df->num_problems_defined; i++)\n-    df->problems_in_order[i]->problem->free_fun (df->problems_in_order[i]); \n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      dflow->problem->free_fun (); \n+    }\n \n+  if (df->postorder)\n+    free (df->postorder);\n+  if (df->postorder_inverted)\n+    free (df->postorder_inverted);\n+  free (df->hard_regs_live_count);\n   free (df);\n+  df = NULL;\n+\n+  bitmap_obstack_release (&df_bitmap_obstack);\n+  return 0;\n }\n \n+\n+struct tree_opt_pass pass_df_finish =\n+{\n+  \"dfinish\",                            /* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  rest_of_handle_df_finish,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  'z'                                   /* letter */\n+};\n+\n+\n+\n+\n \f\n /*----------------------------------------------------------------------------\n    The general data flow analysis engine.\n ----------------------------------------------------------------------------*/\n \n \n-/* Hybrid search algorithm from \"Implementation Techniques for\n-   Efficient Data-Flow Analysis of Large Programs\".  */\n+/* Helper function for df_worklist_dataflow.\n+   Propagate the dataflow forward. \n+   Given a BB_INDEX, do the dataflow propagation\n+   and set bits on for successors in PENDING\n+   if the out set of the dataflow has changed. */\n \n static void\n-df_hybrid_search_forward (basic_block bb, \n-\t\t\t  struct dataflow *dataflow,\n-\t\t\t  bool single_pass)\n+df_worklist_propagate_forward (struct dataflow *dataflow,\n+                               unsigned bb_index,\n+                               unsigned *bbindex_to_postorder,\n+                               bitmap pending,\n+                               sbitmap considered)\n {\n-  int result_changed;\n-  int i = bb->index;\n   edge e;\n   edge_iterator ei;\n+  basic_block bb = BASIC_BLOCK (bb_index);\n \n-  SET_BIT (dataflow->visited, bb->index);\n-  gcc_assert (TEST_BIT (dataflow->pending, bb->index));\n-  RESET_BIT (dataflow->pending, i);\n-\n-  /*  Calculate <conf_op> of predecessor_outs.  */\n+  /*  Calculate <conf_op> of incoming edges.  */\n   if (EDGE_COUNT (bb->preds) > 0)\n     FOR_EACH_EDGE (e, ei, bb->preds)\n-      {\n-\tif (!TEST_BIT (dataflow->considered, e->src->index))\n-\t  continue;\n-\t\n-\tdataflow->problem->con_fun_n (dataflow, e);\n-      }\n+      {\t\t\t\t\t\t\t\t\n+        if (TEST_BIT (considered, e->src->index))\t\t\n+          dataflow->problem->con_fun_n (e);\n+      }\t\t\t\t\t\t\t\t\n   else if (dataflow->problem->con_fun_0)\n-    dataflow->problem->con_fun_0 (dataflow, bb);\n-  \n-  result_changed = dataflow->problem->trans_fun (dataflow, i);\n-  \n-  if (!result_changed || single_pass)\n-    return;\n-  \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      if (e->dest->index == i)\n-\tcontinue;\n-      if (!TEST_BIT (dataflow->considered, e->dest->index))\n-\tcontinue;\n-      SET_BIT (dataflow->pending, e->dest->index);\n-    }\n-  \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n+    dataflow->problem->con_fun_0 (bb);\n+\n+  if (dataflow->problem->trans_fun (bb_index))\n     {\n-      if (e->dest->index == i)\n-\tcontinue;\n-      \n-      if (!TEST_BIT (dataflow->considered, e->dest->index))\n-\tcontinue;\n-      if (!TEST_BIT (dataflow->visited, e->dest->index))\n-\tdf_hybrid_search_forward (e->dest, dataflow, single_pass);\n+      /* The out set of this block has changed. \n+         Propagate to the outgoing blocks.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        {\n+          unsigned ob_index = e->dest->index;\n+\n+          if (TEST_BIT (considered, ob_index))\n+            bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n+        }\n     }\n }\n \n+\n+/* Helper function for df_worklist_dataflow.\n+   Propagate the dataflow backward.  */\n+\n static void\n-df_hybrid_search_backward (basic_block bb,\n-\t\t\t   struct dataflow *dataflow,\n-\t\t\t   bool single_pass)\n+df_worklist_propagate_backward (struct dataflow *dataflow,\n+                                unsigned bb_index,\n+                                unsigned *bbindex_to_postorder,\n+                                bitmap pending,\n+                                sbitmap considered)\n {\n-  int result_changed;\n-  int i = bb->index;\n   edge e;\n   edge_iterator ei;\n-  \n-  SET_BIT (dataflow->visited, bb->index);\n-  gcc_assert (TEST_BIT (dataflow->pending, bb->index));\n-  RESET_BIT (dataflow->pending, i);\n+  basic_block bb = BASIC_BLOCK (bb_index);\n \n-  /*  Calculate <conf_op> of predecessor_outs.  */\n+  /*  Calculate <conf_op> of incoming edges.  */\n   if (EDGE_COUNT (bb->succs) > 0)\n-    FOR_EACH_EDGE (e, ei, bb->succs)\t\t\t\t\t\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n       {\t\t\t\t\t\t\t\t\n-\tif (!TEST_BIT (dataflow->considered, e->dest->index))\t\t\n-\t  continue;\t\t\t\t\t\t\t\n-\t\n-\tdataflow->problem->con_fun_n (dataflow, e);\n+        if (TEST_BIT (considered, e->dest->index))\t\t\n+          dataflow->problem->con_fun_n (e);\n       }\t\t\t\t\t\t\t\t\n   else if (dataflow->problem->con_fun_0)\n-    dataflow->problem->con_fun_0 (dataflow, bb);\n-\n-  result_changed = dataflow->problem->trans_fun (dataflow, i);\n-  \n-  if (!result_changed || single_pass)\n-    return;\n-  \n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\t\t\t\t\t\t\t\t\n-      if (e->src->index == i)\n-\tcontinue;\n-      \n-      if (!TEST_BIT (dataflow->considered, e->src->index))\n-\tcontinue;\n+    dataflow->problem->con_fun_0 (bb);\n \n-      SET_BIT (dataflow->pending, e->src->index);\n-    }\t\t\t\t\t\t\t\t\n-  \n-  FOR_EACH_EDGE (e, ei, bb->preds)\n+  if (dataflow->problem->trans_fun (bb_index))\n     {\n-      if (e->src->index == i)\n-\tcontinue;\n-\n-      if (!TEST_BIT (dataflow->considered, e->src->index))\n-\tcontinue;\n-      \n-      if (!TEST_BIT (dataflow->visited, e->src->index))\n-\tdf_hybrid_search_backward (e->src, dataflow, single_pass);\n+      /* The out set of this block has changed. \n+         Propagate to the outgoing blocks.  */\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+        {\n+          unsigned ob_index = e->src->index;\n+\n+          if (TEST_BIT (considered, ob_index))\n+            bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n+        }\n     }\n }\n \n \n-/* This function will perform iterative bitvector dataflow described\n-   by DATAFLOW, producing the in and out sets.  Only the part of the\n-   cfg induced by blocks in DATAFLOW->order is taken into account.\n-\n-   SINGLE_PASS is true if you just want to make one pass over the\n-   blocks.  */\n+/* Worklist-based dataflow solver. It uses sbitmap as a worklist,\n+   with \"n\"-th bit representing the n-th block in the reverse-postorder order. \n+   This is so-called over-eager algorithm where it propagates\n+   changes on demand. This algorithm may visit blocks more than\n+   iterative method if there are deeply nested loops. \n+   Worklist algorithm works better than iterative algorithm\n+   for CFGs with no nested loops.\n+   In practice, the measurement shows worklist algorithm beats \n+   iterative algorithm by some margin overall.  \n+   Note that this is slightly different from the traditional textbook worklist solver,\n+   in that the worklist is effectively sorted by the reverse postorder.\n+   For CFGs with no nested loops, this is optimal.  */\n \n-void\n-df_iterative_dataflow (struct dataflow *dataflow,\n-\t\t       bitmap blocks_to_consider, bitmap blocks_to_init, \n-\t\t       int *blocks_in_postorder, int n_blocks, \n-\t\t       bool single_pass)\n+void \n+df_worklist_dataflow (struct dataflow *dataflow,\n+                      bitmap blocks_to_consider,\n+                      int *blocks_in_postorder,\n+                      int n_blocks)\n {\n-  unsigned int idx;\n-  int i;\n-  sbitmap visited = sbitmap_alloc (last_basic_block);\n-  sbitmap pending = sbitmap_alloc (last_basic_block);\n+  bitmap pending = BITMAP_ALLOC (&df_bitmap_obstack);\n   sbitmap considered = sbitmap_alloc (last_basic_block);\n   bitmap_iterator bi;\n+  unsigned int *bbindex_to_postorder;\n+  int i;\n+  unsigned int index;\n+  enum df_flow_dir dir = dataflow->problem->dir;\n \n-  dataflow->visited = visited;\n-  dataflow->pending = pending;\n-  dataflow->considered = considered;\n+  gcc_assert (dir != DF_NONE);\n \n-  sbitmap_zero (visited);\n-  sbitmap_zero (pending);\n-  sbitmap_zero (considered);\n+  /* BBINDEX_TO_POSTORDER maps the bb->index to the reverse postorder.  */\n+  bbindex_to_postorder =\n+    (unsigned int *)xmalloc (last_basic_block * sizeof (unsigned int));\n \n-  gcc_assert (dataflow->problem->dir);\n+  /* Initialize the array to an out-of-bound value.  */\n+  for (i = 0; i < last_basic_block; i++)\n+    bbindex_to_postorder[i] = last_basic_block;\n \n-  EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, idx, bi)\n+  /* Initialize the considered map.  */\n+  sbitmap_zero (considered);\n+  EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, index, bi)\n     {\n-      SET_BIT (considered, idx);\n+      SET_BIT (considered, index);\n     }\n \n+  /* Initialize the mapping of block index to postorder.  */\n   for (i = 0; i < n_blocks; i++)\n     {\n-      idx = blocks_in_postorder[i];\n-      SET_BIT (pending, idx);\n-    };\n+      bbindex_to_postorder[blocks_in_postorder[i]] = i;\n+      /* Add all blocks to the worklist.  */\n+      bitmap_set_bit (pending, i);\n+    }\n \n-  dataflow->problem->init_fun (dataflow, blocks_to_init);\n+  if (dataflow->problem->init_fun)\n+    dataflow->problem->init_fun (blocks_to_consider);\n \n-  while (1)\n+  while (!bitmap_empty_p (pending))\n     {\n+      unsigned bb_index;\n \n-      /* For forward problems, you want to pass in reverse postorder\n-         and for backward problems you want postorder.  This has been\n-         shown to be as good as you can do by several people, the\n-         first being Mathew Hecht in his phd dissertation.\n-\n-\t The nodes are passed into this function in postorder.  */\n-\n-      if (dataflow->problem->dir == DF_FORWARD)\n-\t{\n-\t  for (i = n_blocks - 1 ; i >= 0 ; i--)\n-\t    {\n-\t      idx = blocks_in_postorder[i];\n-\t      \n-\t      if (TEST_BIT (pending, idx) && !TEST_BIT (visited, idx))\n-\t\tdf_hybrid_search_forward (BASIC_BLOCK (idx), dataflow, single_pass);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (i = 0; i < n_blocks; i++)\n-\t    {\n-\t      idx = blocks_in_postorder[i];\n-\t      \n-\t      if (TEST_BIT (pending, idx) && !TEST_BIT (visited, idx))\n-\t\tdf_hybrid_search_backward (BASIC_BLOCK (idx), dataflow, single_pass);\n-\t    }\n-\t}\n+      index = bitmap_first_set_bit (pending);\n+      bitmap_clear_bit (pending, index);\n \n-      if (sbitmap_first_set_bit (pending) == -1)\n-\tbreak;\n+      bb_index = blocks_in_postorder[index];\n \n-      sbitmap_zero (visited);\n+      if (dir == DF_FORWARD)\n+        df_worklist_propagate_forward (dataflow, bb_index,\n+                                       bbindex_to_postorder,\n+                                       pending, considered);\n+      else \n+        df_worklist_propagate_backward (dataflow, bb_index,\n+                                        bbindex_to_postorder,\n+                                        pending, considered);\n     }\n \n-  sbitmap_free (pending);\n-  sbitmap_free (visited);\n+  BITMAP_FREE (pending);\n   sbitmap_free (considered);\n+  free (bbindex_to_postorder);\n }\n \n \n@@ -723,95 +1028,105 @@ df_prune_to_subcfg (int list[], unsigned len, bitmap blocks)\n \n /* Execute dataflow analysis on a single dataflow problem. \n \n-   There are three sets of blocks passed in: \n-\n    BLOCKS_TO_CONSIDER are the blocks whose solution can either be\n    examined or will be computed.  For calls from DF_ANALYZE, this is\n-   the set of blocks that has been passed to DF_SET_BLOCKS.  For calls\n-   from DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS, this is the set of\n-   blocks in the fringe (the set of blocks passed in plus the set of\n-   immed preds and succs of those blocks).\n-\n-   BLOCKS_TO_INIT are the blocks whose solution will be changed by\n-   this iteration.  For calls from DF_ANALYZE, this is the set of\n-   blocks that has been passed to DF_SET_BLOCKS.  For calls from\n-   DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS, this is the set of blocks\n-   passed in.\n-\n-   BLOCKS_TO_SCAN are the set of blocks that need to be rescanned.\n-   For calls from DF_ANALYZE, this is the accumulated set of blocks\n-   that has been passed to DF_RESCAN_BLOCKS since the last call to\n-   DF_ANALYZE.  For calls from DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS,\n-   this is the set of blocks passed in.\n- \n-                   blocks_to_consider    blocks_to_init    blocks_to_scan\n-   full redo       all                   all               all\n-   partial redo    all                   all               sub\n-   small fixup     fringe                sub               sub\n+   the set of blocks that has been passed to DF_SET_BLOCKS.  \n */\n \n void\n df_analyze_problem (struct dataflow *dflow, \n \t\t    bitmap blocks_to_consider, \n-\t\t    bitmap blocks_to_init,\n-\t\t    bitmap blocks_to_scan,\n-\t\t    int *postorder, int n_blocks, bool single_pass)\n+\t\t    int *postorder, int n_blocks)\n {\n+  timevar_push (dflow->problem->tv_id);\n+\n+#ifdef ENABLE_CHECKING\n+  if (dflow->problem->verify_start_fun)\n+    dflow->problem->verify_start_fun ();\n+#endif\n+\n   /* (Re)Allocate the datastructures necessary to solve the problem.  */ \n   if (dflow->problem->alloc_fun)\n-    dflow->problem->alloc_fun (dflow, blocks_to_scan, blocks_to_init);\n+    dflow->problem->alloc_fun (blocks_to_consider);\n \n-  /* Set up the problem and compute the local information.  This\n-     function is passed both the blocks_to_consider and the\n-     blocks_to_scan because the RD and RU problems require the entire\n-     function to be rescanned if they are going to be updated.  */\n+  /* Set up the problem and compute the local information.  */\n   if (dflow->problem->local_compute_fun)\n-    dflow->problem->local_compute_fun (dflow, blocks_to_consider, blocks_to_scan);\n+    dflow->problem->local_compute_fun (blocks_to_consider);\n \n   /* Solve the equations.  */\n   if (dflow->problem->dataflow_fun)\n-    dflow->problem->dataflow_fun (dflow, blocks_to_consider, blocks_to_init,\n-\t\t\t\t  postorder, n_blocks, single_pass);\n+    dflow->problem->dataflow_fun (dflow, blocks_to_consider,\n+\t\t\t\t  postorder, n_blocks);\n \n   /* Massage the solution.  */\n   if (dflow->problem->finalize_fun)\n-    dflow->problem->finalize_fun (dflow, blocks_to_consider);\n+    dflow->problem->finalize_fun (blocks_to_consider);\n+\n+#ifdef ENABLE_CHECKING\n+  if (dflow->problem->verify_end_fun)\n+    dflow->problem->verify_end_fun ();\n+#endif\n+\n+  timevar_pop (dflow->problem->tv_id);\n+\n+  dflow->computed = true;\n }\n \n \n /* Analyze dataflow info for the basic blocks specified by the bitmap\n    BLOCKS, or for the whole CFG if BLOCKS is zero.  */\n \n void\n-df_analyze (struct df *df)\n+df_analyze (void)\n {\n-  int *postorder = XNEWVEC (int, last_basic_block);\n-  bitmap current_all_blocks = BITMAP_ALLOC (NULL);\n-  int n_blocks;\n-  int i;\n+  bitmap current_all_blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n   bool everything;\n-\n-  n_blocks = post_order_compute (postorder, true);\n-\n-  if (n_blocks != n_basic_blocks)\n-    delete_unreachable_blocks ();\n-\n-  for (i = 0; i < n_blocks; i++)\n-    bitmap_set_bit (current_all_blocks, postorder[i]);\n-\n-  /* No one called df_rescan_blocks, so do it.  */\n-  if (!df->blocks_to_scan)\n-    df_rescan_blocks (df, NULL);\n+  int i;\n+  \n+  if (df->postorder)\n+    free (df->postorder);\n+  if (df->postorder_inverted)\n+    free (df->postorder_inverted);\n+  df->postorder = XNEWVEC (int, last_basic_block);\n+  df->postorder_inverted = XNEWVEC (int, last_basic_block);\n+  df->n_blocks = post_order_compute (df->postorder, true, true);\n+  df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n+\n+  /* These should be the same.  */\n+  gcc_assert (df->n_blocks == df->n_blocks_inverted);\n+\n+  /* We need to do this before the df_verify_all because this is\n+     not kept incrementally up to date.  */\n+  df_compute_regs_ever_live (false);\n+  df_process_deferred_rescans ();\n+\n+#ifdef ENABLE_CHECKING\n+  if (dump_file)\n+    fprintf (dump_file, \"df_analyze called\\n\");\n+  df_verify ();\n+#endif \n+\n+  for (i = 0; i < df->n_blocks; i++)\n+    bitmap_set_bit (current_all_blocks, df->postorder[i]);\n+\n+#ifdef ENABLE_CHECKING\n+  /* Verify that POSTORDER_INVERTED only contains blocks reachable from\n+     the ENTRY block.  */\n+  for (i = 0; i < df->n_blocks_inverted; i++)\n+    gcc_assert (bitmap_bit_p (current_all_blocks, df->postorder_inverted[i]));\n+#endif\n \n   /* Make sure that we have pruned any unreachable blocks from these\n      sets.  */\n-  bitmap_and_into (df->blocks_to_scan, current_all_blocks);\n-\n-  if (df->blocks_to_analyze)\n+  if (df->analyze_subset)\n     {\n       everything = false;\n       bitmap_and_into (df->blocks_to_analyze, current_all_blocks);\n-      n_blocks = df_prune_to_subcfg (postorder, n_blocks, df->blocks_to_analyze);\n+      df->n_blocks = df_prune_to_subcfg (df->postorder, \n+\t\t\t\t\t df->n_blocks, df->blocks_to_analyze);\n+      df->n_blocks_inverted = df_prune_to_subcfg (df->postorder_inverted, \n+\t\t\t                          df->n_blocks_inverted, \n+                                                  df->blocks_to_analyze);\n       BITMAP_FREE (current_all_blocks);\n     }\n   else\n@@ -823,23 +1138,101 @@ df_analyze (struct df *df)\n \n   /* Skip over the DF_SCAN problem. */\n   for (i = 1; i < df->num_problems_defined; i++)\n-    df_analyze_problem (df->problems_in_order[i], \n-\t\t\tdf->blocks_to_analyze, df->blocks_to_analyze, \n-\t\t\tdf->blocks_to_scan,\n-\t\t\tpostorder, n_blocks, false);\n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->solutions_dirty)\n+        {\n+          if (dflow->problem->dir == DF_FORWARD)\n+            df_analyze_problem (dflow,\n+                                df->blocks_to_analyze,\n+                                df->postorder_inverted,\n+                                df->n_blocks_inverted);\n+          else\n+            df_analyze_problem (dflow,\n+                                df->blocks_to_analyze,\n+                                df->postorder,\n+                                df->n_blocks);\n+        }\n+    }\n \n   if (everything)\n     {\n       BITMAP_FREE (df->blocks_to_analyze);\n       df->blocks_to_analyze = NULL;\n     }\n \n-  BITMAP_FREE (df->blocks_to_scan);\n-  df->blocks_to_scan = NULL;\n-  free (postorder);\n+#ifdef DF_DEBUG_CFG\n+  df_set_clean_cfg ();\n+#endif\n+}\n+\n+\n+/* Return the number of basic blocks from the last call to df_analyze.  */\n+\n+int \n+df_get_n_blocks (enum df_flow_dir dir)\n+{\n+  gcc_assert (dir != DF_NONE);\n+\n+  if (dir == DF_FORWARD)\n+    {\n+      gcc_assert (df->postorder_inverted);\n+      return df->n_blocks_inverted;\n+    }\n+\n+  gcc_assert (df->postorder);\n+  return df->n_blocks;\n+}\n+\n+\n+/* Return a pointer to the array of basic blocks in the reverse postorder. \n+   Depending on the direction of the dataflow problem,\n+   it returns either the usual reverse postorder array\n+   or the reverse postorder of inverted traversal. */\n+int *\n+df_get_postorder (enum df_flow_dir dir)\n+{\n+  gcc_assert (dir != DF_NONE);\n+\n+  if (dir == DF_FORWARD)\n+    {\n+      gcc_assert (df->postorder_inverted);\n+      return df->postorder_inverted;\n+    }\n+  gcc_assert (df->postorder);\n+  return df->postorder;\n }\n \n+static struct df_problem user_problem; \n+static struct dataflow user_dflow;\n \n+/* Interface for calling iterative dataflow with user defined\n+   confluence and transfer functions.  All that is necessary is to\n+   supply DIR, a direction, CONF_FUN_0, a confluence function for\n+   blocks with no logical preds (or NULL), CONF_FUN_N, the normal\n+   confluence function, TRANS_FUN, the basic block transfer function,\n+   and BLOCKS, the set of blocks to examine, POSTORDER the blocks in\n+   postorder, and N_BLOCKS, the number of blocks in POSTORDER. */\n+\n+void\n+df_simple_dataflow (enum df_flow_dir dir,\n+\t\t    df_init_function init_fun,\n+\t\t    df_confluence_function_0 con_fun_0,\n+\t\t    df_confluence_function_n con_fun_n,\n+\t\t    df_transfer_function trans_fun,\n+\t\t    bitmap blocks, int * postorder, int n_blocks)\n+{\n+  memset (&user_problem, 0, sizeof (struct df_problem));\n+  user_problem.dir = dir;\n+  user_problem.init_fun = init_fun;\n+  user_problem.con_fun_0 = con_fun_0;\n+  user_problem.con_fun_n = con_fun_n;\n+  user_problem.trans_fun = trans_fun;\n+  user_dflow.problem = &user_problem;\n+  df_worklist_dataflow (&user_dflow, blocks, postorder, n_blocks);\n+}\n+\n+\t\t\t      \n \f\n /*----------------------------------------------------------------------------\n    Functions to support limited incremental change.\n@@ -851,6 +1244,10 @@ df_analyze (struct df *df)\n static void *\n df_get_bb_info (struct dataflow *dflow, unsigned int index)\n {\n+  if (dflow->block_info == NULL)\n+    return NULL;\n+  if (index >= dflow->block_info_size)\n+    return NULL;\n   return (struct df_scan_bb_info *) dflow->block_info[index];\n }\n \n@@ -861,33 +1258,116 @@ static void\n df_set_bb_info (struct dataflow *dflow, unsigned int index, \n \t\tvoid *bb_info)\n {\n+  gcc_assert (dflow->block_info);\n   dflow->block_info[index] = bb_info;\n }\n \n \n+/* Mark the solutions as being out of date.  */\n+\n+void \n+df_mark_solutions_dirty (void)\n+{\n+  if (df)\n+    {\n+      int p; \n+      for (p = 1; p < df->num_problems_defined; p++)\n+\tdf->problems_in_order[p]->solutions_dirty = true;\n+    }\n+}\n+\n+\n+/* Return true if BB needs it's transfer functions recomputed.  */\n+\n+bool \n+df_get_bb_dirty (basic_block bb)\n+{\n+  if (df && df_live)\n+    return bitmap_bit_p (df_live->out_of_date_transfer_functions, bb->index);\n+  else \n+    return false;\n+}\n+\n+\n+/* Mark BB as needing it's transfer functions as being out of\n+   date.  */\n+\n+void \n+df_set_bb_dirty (basic_block bb)\n+{\n+  if (df)\n+    {\n+      int p; \n+      for (p = 1; p < df->num_problems_defined; p++)\n+\t{\n+\t  struct dataflow *dflow = df->problems_in_order[p];\n+\t  if (dflow->out_of_date_transfer_functions)\n+\t    bitmap_set_bit (dflow->out_of_date_transfer_functions, bb->index);\n+\t}\n+      df_mark_solutions_dirty ();\n+    }\n+}\n+\n+\n+/* Clear the dirty bits.  This is called from places that delete\n+   blocks.  */\n+static void\n+df_clear_bb_dirty (basic_block bb)\n+{\n+  int p; \n+  for (p = 1; p < df->num_problems_defined; p++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[p];\n+      if (dflow->out_of_date_transfer_functions)\n+\tbitmap_clear_bit (dflow->out_of_date_transfer_functions, bb->index);\n+    }\n+}\n /* Called from the rtl_compact_blocks to reorganize the problems basic\n    block info.  */\n \n void \n-df_compact_blocks (struct df *df)\n+df_compact_blocks (void)\n {\n   int i, p;\n   basic_block bb;\n   void **problem_temps;\n-  int size = last_basic_block *sizeof (void *);\n+  int size = last_basic_block * sizeof (void *);\n+  bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n   problem_temps = xmalloc (size);\n \n   for (p = 0; p < df->num_problems_defined; p++)\n     {\n       struct dataflow *dflow = df->problems_in_order[p];\n+\n+      /* Need to reorganize the out_of_date_transfer_functions for the\n+\t dflow problem.  */\n+      if (dflow->out_of_date_transfer_functions)\n+\t{\n+\t  bitmap_copy (tmp, dflow->out_of_date_transfer_functions);\n+\t  bitmap_clear (dflow->out_of_date_transfer_functions);\n+\t  if (bitmap_bit_p (tmp, ENTRY_BLOCK))\n+\t    bitmap_set_bit (dflow->out_of_date_transfer_functions, ENTRY_BLOCK);\n+\t  if (bitmap_bit_p (tmp, EXIT_BLOCK))\n+\t    bitmap_set_bit (dflow->out_of_date_transfer_functions, EXIT_BLOCK);\n+\n+\t  i = NUM_FIXED_BLOCKS;\n+\t  FOR_EACH_BB (bb) \n+\t    {\n+\t      if (bitmap_bit_p (tmp, bb->index))\n+\t\tbitmap_set_bit (dflow->out_of_date_transfer_functions, i);\n+\t      i++;\n+\t    }\n+\t}\n+\n+      /* Now shuffle the block info for the problem.  */\n       if (dflow->problem->free_bb_fun)\n \t{\n \t  df_grow_bb_info (dflow);\n \t  memcpy (problem_temps, dflow->block_info, size);\n \n \t  /* Copy the bb info from the problem tmps to the proper\n \t     place in the block_info vector.  Null out the copied\n-\t     item.  */\n+\t     item.  The entry and exit blocks never move.  */\n \t  i = NUM_FIXED_BLOCKS;\n \t  FOR_EACH_BB (bb) \n \t    {\n@@ -905,11 +1385,32 @@ df_compact_blocks (struct df *df)\n \t      basic_block bb = BASIC_BLOCK (i); \n \t      if (problem_temps[i] && bb)\n \t\tdflow->problem->free_bb_fun\n-\t\t  (dflow, bb, problem_temps[i]);\n+\t\t  (bb, problem_temps[i]);\n \t    }\n \t}\n     }\n \n+  /* Shuffle the bits in the basic_block indexed arrays.  */\n+\n+  if (df->blocks_to_analyze)\n+    {\n+      if (bitmap_bit_p (tmp, ENTRY_BLOCK))\n+\tbitmap_set_bit (df->blocks_to_analyze, ENTRY_BLOCK);\n+      if (bitmap_bit_p (tmp, EXIT_BLOCK))\n+\tbitmap_set_bit (df->blocks_to_analyze, EXIT_BLOCK);\n+      bitmap_copy (tmp, df->blocks_to_analyze);\n+      bitmap_clear (df->blocks_to_analyze);\n+      i = NUM_FIXED_BLOCKS;\n+      FOR_EACH_BB (bb) \n+\t{\n+\t  if (bitmap_bit_p (tmp, bb->index))\n+\t    bitmap_set_bit (df->blocks_to_analyze, i);\n+\t  i++;\n+\t}\n+    }\n+\n+  BITMAP_FREE (tmp);\n+\n   free (problem_temps);\n \n   i = NUM_FIXED_BLOCKS;\n@@ -924,39 +1425,175 @@ df_compact_blocks (struct df *df)\n \n   for (; i < last_basic_block; i++)\n     SET_BASIC_BLOCK (i, NULL);\n+\n+#ifdef DF_DEBUG_CFG\n+  if (!df_lr->solutions_dirty)\n+    df_set_clean_cfg ();\n+#endif\n }\n \n \n-/* Shove NEW_BLOCK in at OLD_INDEX.  Called from if-cvt to hack a\n+/* Shove NEW_BLOCK in at OLD_INDEX.  Called from ifcvt to hack a\n    block.  There is no excuse for people to do this kind of thing.  */\n \n void \n-df_bb_replace (struct df *df, int old_index, basic_block new_block)\n+df_bb_replace (int old_index, basic_block new_block)\n {\n+  int new_block_index = new_block->index;\n   int p;\n \n+  if (dump_file)\n+    fprintf (dump_file, \"shoving block %d into %d\\n\", new_block_index, old_index);\n+\n+  gcc_assert (df);\n+  gcc_assert (BASIC_BLOCK (old_index) == NULL);\n+\n   for (p = 0; p < df->num_problems_defined; p++)\n     {\n       struct dataflow *dflow = df->problems_in_order[p];\n       if (dflow->block_info)\n \t{\n-\t  void *temp;\n-\n \t  df_grow_bb_info (dflow);\n-\n-\t  /* The old switcheroo.  */\n-\n-\t  temp = df_get_bb_info (dflow, old_index);\n+\t  gcc_assert (df_get_bb_info (dflow, old_index) == NULL);\n \t  df_set_bb_info (dflow, old_index, \n-\t\t\t  df_get_bb_info (dflow, new_block->index));\n-\t  df_set_bb_info (dflow, new_block->index, temp);\n+\t\t\t  df_get_bb_info (dflow, new_block_index));\n \t}\n     }\n \n+  df_clear_bb_dirty (new_block);\n   SET_BASIC_BLOCK (old_index, new_block);\n   new_block->index = old_index;\n+  df_set_bb_dirty (BASIC_BLOCK (old_index));\n+  SET_BASIC_BLOCK (new_block_index, NULL);\n+}\n+\n+\n+/* Free all of the per basic block dataflow from all of the problems.\n+   This is typically called before a basic block is deleted and the\n+   problem will be reanalyzed.  */\n+\n+void\n+df_bb_delete (int bb_index)\n+{\n+  basic_block bb = BASIC_BLOCK (bb_index);\n+  int i;\n+\n+  if (!df)\n+    return;\n+  \n+  for (i = 0; i < df->num_problems_defined; i++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->problem->free_bb_fun)\n+\t{\n+\t  void *bb_info = df_get_bb_info (dflow, bb_index);\n+\t  if (bb_info)\n+\t    {\n+\t      dflow->problem->free_bb_fun (bb, bb_info); \n+\t      df_set_bb_info (dflow, bb_index, NULL);\n+\t    }\n+\t}\n+    }\n+  df_clear_bb_dirty (bb);\n+  df_mark_solutions_dirty ();\n+}\n+\n+\n+/* Verify that there is a place for everything and everything is in\n+   its place.  This is too expensive to run after every pass in the\n+   mainline.  However this is an excellent debugging tool if the\n+   dataflow infomation is not being updated properly.  You can just\n+   sprinkle calls in until you find the place that is changing an\n+   underlying structure without calling the proper updating\n+   rountine.  */\n+\n+void\n+df_verify (void)\n+{\n+  df_scan_verify ();\n+  df_lr_verify_transfer_functions ();\n+  if (df_live)\n+    df_live_verify_transfer_functions ();\n+}\n+\n+#ifdef DF_DEBUG_CFG\n+\n+/* Compute an array of ints that describes the cfg.  This can be used\n+   to discover places where the cfg is modified by the appropriate\n+   calls have not been made to the keep df informed.  The internals of\n+   this are unexciting, the key is that two instances of this can be\n+   compared to see if any changes have been made to the cfg.  */\n+\n+static int *\n+df_compute_cfg_image (void)\n+{\n+  basic_block bb;\n+  int size = 2 + (2 * n_basic_blocks);\n+  int i;\n+  int * map;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      size += EDGE_COUNT (bb->succs);\n+    }\n+\n+  map = XNEWVEC (int, size);\n+  map[0] = size;\n+  i = 1;\n+  FOR_ALL_BB (bb)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+\n+      map[i++] = bb->index;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tmap[i++] = e->dest->index;\n+      map[i++] = -1;\n+    }\n+  map[i] = -1;\n+  return map;\n+}\n+\n+static int *saved_cfg = NULL;\n+\n+\n+/* This function compares the saved version of the cfg with the\n+   current cfg and aborts if the two are identical.  The function\n+   silently returns if the cfg has been marked as dirty or the two are\n+   the same.  */\n+\n+void\n+df_check_cfg_clean (void)\n+{\n+  int *new_map;\n+\n+  if (!df)\n+    return;\n+\n+  if (df_lr->solutions_dirty)\n+    return;\n+\n+  if (saved_cfg == NULL) \n+    return;\n+\n+  new_map = df_compute_cfg_image ();\n+  gcc_assert (memcmp (saved_cfg, new_map, saved_cfg[0] * sizeof (int)) == 0);\n+  free (new_map);\n }\n \n+\n+/* This function builds a cfg fingerprint and squirrels it away in\n+   saved_cfg.  */\n+\n+static void\n+df_set_clean_cfg (void)\n+{\n+  if (saved_cfg)\n+    free (saved_cfg);\n+  saved_cfg = df_compute_cfg_image ();\n+}\n+\n+#endif /* DF_DEBUG_CFG  */\n /*----------------------------------------------------------------------------\n    PUBLIC INTERFACES TO QUERY INFORMATION.\n ----------------------------------------------------------------------------*/\n@@ -965,10 +1602,10 @@ df_bb_replace (struct df *df, int old_index, basic_block new_block)\n /* Return last use of REGNO within BB.  */\n \n struct df_ref *\n-df_bb_regno_last_use_find (struct df *df, basic_block bb, unsigned int regno)\n+df_bb_regno_last_use_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  struct df_ref *use;\n+  struct df_ref **use_rec;\n   unsigned int uid;\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n@@ -977,9 +1614,20 @@ df_bb_regno_last_use_find (struct df *df, basic_block bb, unsigned int regno)\n \tcontinue;\n \n       uid = INSN_UID (insn);\n-      for (use = DF_INSN_UID_GET (df, uid)->uses; use; use = use->next_ref)\n-\tif (DF_REF_REGNO (use) == regno)\n-\t  return use;\n+      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t{\n+\t  struct df_ref *use = *use_rec;\n+\t  if (DF_REF_REGNO (use) == regno)\n+\t    return use;\n+\t}\n+\n+      if (df->changeable_flags & DF_EQ_NOTES)\n+\tfor (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n+\t  {\n+\t    struct df_ref *use = *use_rec;\n+\t    if (DF_REF_REGNO (use) == regno)\n+\t      return use;\n+\t  }\n     }\n   return NULL;\n }\n@@ -988,10 +1636,10 @@ df_bb_regno_last_use_find (struct df *df, basic_block bb, unsigned int regno)\n /* Return first def of REGNO within BB.  */\n \n struct df_ref *\n-df_bb_regno_first_def_find (struct df *df, basic_block bb, unsigned int regno)\n+df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  struct df_ref *def;\n+  struct df_ref **def_rec;\n   unsigned int uid;\n \n   FOR_BB_INSNS (bb, insn)\n@@ -1000,9 +1648,12 @@ df_bb_regno_first_def_find (struct df *df, basic_block bb, unsigned int regno)\n \tcontinue;\n \n       uid = INSN_UID (insn);\n-      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n-\tif (DF_REF_REGNO (def) == regno)\n-\t  return def;\n+      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t{\n+\t  struct df_ref *def = *def_rec;\n+\t  if (DF_REF_REGNO (def) == regno)\n+\t    return def;\n+\t}\n     }\n   return NULL;\n }\n@@ -1011,10 +1662,10 @@ df_bb_regno_first_def_find (struct df *df, basic_block bb, unsigned int regno)\n /* Return last def of REGNO within BB.  */\n \n struct df_ref *\n-df_bb_regno_last_def_find (struct df *df, basic_block bb, unsigned int regno)\n+df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n-  struct df_ref *def;\n+  struct df_ref **def_rec;\n   unsigned int uid;\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n@@ -1023,9 +1674,12 @@ df_bb_regno_last_def_find (struct df *df, basic_block bb, unsigned int regno)\n \tcontinue;\n \n       uid = INSN_UID (insn);\n-      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n-\tif (DF_REF_REGNO (def) == regno)\n-\t  return def;\n+      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t{\n+\t  struct df_ref *def = *def_rec;\n+\t  if (DF_REF_REGNO (def) == regno)\n+\t    return def;\n+\t}\n     }\n \n   return NULL;\n@@ -1034,15 +1688,18 @@ df_bb_regno_last_def_find (struct df *df, basic_block bb, unsigned int regno)\n /* Return true if INSN defines REGNO.  */\n \n bool\n-df_insn_regno_def_p (struct df *df, rtx insn, unsigned int regno)\n+df_insn_regno_def_p (rtx insn, unsigned int regno)\n {\n   unsigned int uid;\n-  struct df_ref *def;\n+  struct df_ref **def_rec;\n \n   uid = INSN_UID (insn);\n-  for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n-    if (DF_REF_REGNO (def) == regno)\n-      return true;\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if (DF_REF_REGNO (def) == regno)\n+\treturn true;\n+    }\n   \n   return false;\n }\n@@ -1052,19 +1709,22 @@ df_insn_regno_def_p (struct df *df, rtx insn, unsigned int regno)\n    DF is the dataflow object.  */\n \n struct df_ref *\n-df_find_def (struct df *df, rtx insn, rtx reg)\n+df_find_def (rtx insn, rtx reg)\n {\n   unsigned int uid;\n-  struct df_ref *def;\n+  struct df_ref **def_rec;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n \n   uid = INSN_UID (insn);\n-  for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n-    if (rtx_equal_p (DF_REF_REAL_REG (def), reg))\n-      return def;\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if (rtx_equal_p (DF_REF_REAL_REG (def), reg))\n+\treturn def;\n+    }\n \n   return NULL;\n }\n@@ -1073,50 +1733,103 @@ df_find_def (struct df *df, rtx insn, rtx reg)\n /* Return true if REG is defined in INSN, zero otherwise.  */ \n \n bool\n-df_reg_defined (struct df *df, rtx insn, rtx reg)\n+df_reg_defined (rtx insn, rtx reg)\n {\n-  return df_find_def (df, insn, reg) != NULL;\n+  return df_find_def (insn, reg) != NULL;\n }\n   \n \n /* Finds the reference corresponding to the use of REG in INSN.\n    DF is the dataflow object.  */\n   \n struct df_ref *\n-df_find_use (struct df *df, rtx insn, rtx reg)\n+df_find_use (rtx insn, rtx reg)\n {\n   unsigned int uid;\n-  struct df_ref *use;\n+  struct df_ref **use_rec;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n \n   uid = INSN_UID (insn);\n-  for (use = DF_INSN_UID_GET (df, uid)->uses; use; use = use->next_ref)\n-    if (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n-      return use; \n-\n+  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      if (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n+\treturn use;\n+    } \n+  if (df->changeable_flags & DF_EQ_NOTES)\n+    for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n+      {\n+\tstruct df_ref *use = *use_rec;\n+\tif (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n+\t  return use; \n+      }\n   return NULL;\n }\n \n \n /* Return true if REG is referenced in INSN, zero otherwise.  */ \n \n bool\n-df_reg_used (struct df *df, rtx insn, rtx reg)\n+df_reg_used (rtx insn, rtx reg)\n {\n-  return df_find_use (df, insn, reg) != NULL;\n+  return df_find_use (insn, reg) != NULL;\n }\n   \n \f\n /*----------------------------------------------------------------------------\n    Debugging and printing functions.\n ----------------------------------------------------------------------------*/\n \n+\n+/* Write information about registers and basic blocks into FILE.\n+   This is part of making a debugging dump.  */\n+\n+void\n+df_print_regset (FILE *file, bitmap r)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n+  if (r == NULL)\n+    fputs (\" (nil)\", file);\n+  else\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (r, 0, i, bi)\n+\t{\n+\t  fprintf (file, \" %d\", i);\n+\t  if (i < FIRST_PSEUDO_REGISTER)\n+\t    fprintf (file, \" [%s]\", reg_names[i]);\n+\t}\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n /* Dump dataflow info.  */\n void\n-df_dump (struct df *df, FILE *file)\n+df_dump (FILE *file)\n+{\n+  basic_block bb;\n+  df_dump_start (file);\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      df_print_bb_index (bb, file);\n+      df_dump_top (bb, file);\n+      df_dump_bottom (bb, file);\n+    }\n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n+/* Dump the introductory information for each problem defined.  */\n+\n+void\n+df_dump_start (FILE *file)\n {\n   int i;\n \n@@ -1125,29 +1838,83 @@ df_dump (struct df *df, FILE *file)\n \n   fprintf (file, \"\\n\\n%s\\n\", current_function_name ());\n   fprintf (file, \"\\nDataflow summary:\\n\");\n-  fprintf (file, \"def_info->bitmap_size = %d, use_info->bitmap_size = %d\\n\",\n-\t   df->def_info.bitmap_size, df->use_info.bitmap_size);\n+  if (df->blocks_to_analyze)\n+    fprintf (file, \"def_info->table_size = %d, use_info->table_size = %d\\n\",\n+\t     DF_DEFS_TABLE_SIZE (), DF_USES_TABLE_SIZE ());\n \n   for (i = 0; i < df->num_problems_defined; i++)\n-    df->problems_in_order[i]->problem->dump_fun (df->problems_in_order[i], file); \n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->computed)\n+\t{\n+\t  df_dump_problem_function fun = dflow->problem->dump_start_fun;\n+\t  if (fun)\n+\t    fun(file); \n+\t}\n+    }\n+}\n \n-  fprintf (file, \"\\n\");\n+\n+/* Dump the top of the block information for BB.  */ \n+\n+void\n+df_dump_top (basic_block bb, FILE *file)\n+{\n+  int i;\n+\n+  if (!df || !file)\n+    return;\n+\n+  for (i = 0; i < df->num_problems_defined; i++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->computed)\n+\t{\n+\t  df_dump_bb_problem_function bbfun = dflow->problem->dump_top_fun;\n+\t  if (bbfun)\n+\t    bbfun (bb, file); \n+\t}\n+    }\n+}\n+\n+\n+/* Dump the bottom of the block information for BB.  */ \n+\n+void\n+df_dump_bottom (basic_block bb, FILE *file)\n+{\n+  int i;\n+\n+  if (!df || !file)\n+    return;\n+\n+  for (i = 0; i < df->num_problems_defined; i++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->computed)\n+\t{\n+\t  df_dump_bb_problem_function bbfun = dflow->problem->dump_bottom_fun;\n+\t  if (bbfun)\n+\t    bbfun (bb, file); \n+\t}\n+    }\n }\n \n \n void\n-df_refs_chain_dump (struct df_ref *ref, bool follow_chain, FILE *file)\n+df_refs_chain_dump (struct df_ref **ref_rec, bool follow_chain, FILE *file)\n {\n   fprintf (file, \"{ \");\n-  while (ref)\n+  while (*ref_rec)\n     {\n-      fprintf (file, \"%c%d(%d) \",\n-\t       DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n+      struct df_ref *ref = *ref_rec;\n+      fprintf (file, \"%c%d(%d)\",\n+\t       DF_REF_REG_DEF_P (ref) ? 'd' : (DF_REF_FLAGS (ref) & DF_REF_IN_NOTE) ? 'e' : 'u',\n \t       DF_REF_ID (ref),\n \t       DF_REF_REGNO (ref));\n       if (follow_chain)\n \tdf_chain_dump (DF_REF_CHAIN (ref), file);\n-      ref = ref->next_ref;\n+      ref_rec++;\n     }\n   fprintf (file, \"}\");\n }\n@@ -1156,7 +1923,7 @@ df_refs_chain_dump (struct df_ref *ref, bool follow_chain, FILE *file)\n /* Dump either a ref-def or reg-use chain.  */\n \n void\n-df_regs_chain_dump (struct df *df ATTRIBUTE_UNUSED, struct df_ref *ref,  FILE *file)\n+df_regs_chain_dump (struct df_ref *ref,  FILE *file)\n {\n   fprintf (file, \"{ \");\n   while (ref)\n@@ -1172,99 +1939,84 @@ df_regs_chain_dump (struct df *df ATTRIBUTE_UNUSED, struct df_ref *ref,  FILE *f\n \n \n static void\n-df_mws_dump (struct df_mw_hardreg *mws, FILE *file)\n+df_mws_dump (struct df_mw_hardreg **mws, FILE *file)\n {\n-  while (mws)\n+  while (*mws)\n     {\n-      struct df_link *regs = mws->regs;\n-      fprintf (file, \"%c%d(\", \n-\t       (mws->type == DF_REF_REG_DEF) ? 'd' : 'u',\n-\t       DF_REF_REGNO (regs->ref));\n-      while (regs)\n-\t{\n-\t  fprintf (file, \"%d \", DF_REF_REGNO (regs->ref));\n-\t  regs = regs->next;\n-\t}\n-\n-      fprintf (file, \") \"); \n-      mws = mws->next;\n+      fprintf (file, \"mw %c r[%d..%d]\\n\", \n+\t       ((*mws)->type == DF_REF_REG_DEF) ? 'd' : 'u',\n+\t       (*mws)->start_regno, (*mws)->end_regno);\n+      mws++;\n     }\n }\n \n \n static void \n-df_insn_uid_debug (struct df *df, unsigned int uid, \n+df_insn_uid_debug (unsigned int uid, \n \t\t   bool follow_chain, FILE *file)\n {\n-  int bbi;\n-\n-  if (DF_INSN_UID_DEFS (df, uid))\n-    bbi = DF_REF_BBNO (DF_INSN_UID_DEFS (df, uid));\n-  else if (DF_INSN_UID_USES(df, uid))\n-    bbi = DF_REF_BBNO (DF_INSN_UID_USES (df, uid));\n-  else\n-    bbi = -1;\n+  fprintf (file, \"insn %d luid %d\",\n+\t   uid, DF_INSN_UID_LUID (uid));\n \n-  fprintf (file, \"insn %d bb %d luid %d\",\n-\t   uid, bbi, DF_INSN_UID_LUID (df, uid));\n-\n-  if (DF_INSN_UID_DEFS (df, uid))\n+  if (DF_INSN_UID_DEFS (uid))\n     {\n       fprintf (file, \" defs \");\n-      df_refs_chain_dump (DF_INSN_UID_DEFS (df, uid), follow_chain, file);\n+      df_refs_chain_dump (DF_INSN_UID_DEFS (uid), follow_chain, file);\n     }\n \n-  if (DF_INSN_UID_USES (df, uid))\n+  if (DF_INSN_UID_USES (uid))\n     {\n       fprintf (file, \" uses \");\n-      df_refs_chain_dump (DF_INSN_UID_USES (df, uid), follow_chain, file);\n+      df_refs_chain_dump (DF_INSN_UID_USES (uid), follow_chain, file);\n+    }\n+\n+  if (DF_INSN_UID_EQ_USES (uid))\n+    {\n+      fprintf (file, \" eq uses \");\n+      df_refs_chain_dump (DF_INSN_UID_EQ_USES (uid), follow_chain, file);\n     }\n \n-  if (DF_INSN_UID_MWS (df, uid))\n+  if (DF_INSN_UID_MWS (uid))\n     {\n       fprintf (file, \" mws \");\n-      df_mws_dump (DF_INSN_UID_MWS (df, uid), file);\n+      df_mws_dump (DF_INSN_UID_MWS (uid), file);\n     }\n   fprintf (file, \"\\n\");\n }\n \n \n void\n-df_insn_debug (struct df *df, rtx insn, bool follow_chain, FILE *file)\n+df_insn_debug (rtx insn, bool follow_chain, FILE *file)\n {\n-  df_insn_uid_debug (df, INSN_UID (insn), follow_chain, file);\n+  df_insn_uid_debug (INSN_UID (insn), follow_chain, file);\n }\n \n void\n-df_insn_debug_regno (struct df *df, rtx insn, FILE *file)\n+df_insn_debug_regno (rtx insn, FILE *file)\n {\n-  unsigned int uid;\n-  int bbi;\n-\n-  uid = INSN_UID (insn);\n-  if (DF_INSN_UID_DEFS (df, uid))\n-    bbi = DF_REF_BBNO (DF_INSN_UID_DEFS (df, uid));\n-  else if (DF_INSN_UID_USES(df, uid))\n-    bbi = DF_REF_BBNO (DF_INSN_UID_USES (df, uid));\n-  else\n-    bbi = -1;\n+  unsigned int uid = INSN_UID(insn);\n \n   fprintf (file, \"insn %d bb %d luid %d defs \",\n-\t   uid, bbi, DF_INSN_LUID (df, insn));\n-  df_regs_chain_dump (df, DF_INSN_UID_DEFS (df, uid), file);\n+\t   uid, BLOCK_FOR_INSN (insn)->index, DF_INSN_LUID (insn));\n+  df_refs_chain_dump (DF_INSN_UID_DEFS (uid), false, file);\n     \n   fprintf (file, \" uses \");\n-  df_regs_chain_dump (df, DF_INSN_UID_USES (df, uid), file);\n+  df_refs_chain_dump (DF_INSN_UID_USES (uid), false, file);\n+\n+  fprintf (file, \" eq_uses \");\n+  df_refs_chain_dump (DF_INSN_UID_EQ_USES (uid), false, file);\n   fprintf (file, \"\\n\");\n }\n \n void\n-df_regno_debug (struct df *df, unsigned int regno, FILE *file)\n+df_regno_debug (unsigned int regno, FILE *file)\n {\n   fprintf (file, \"reg %d defs \", regno);\n-  df_regs_chain_dump (df, DF_REG_DEF_GET (df, regno)->reg_chain, file);\n+  df_regs_chain_dump (DF_REG_DEF_CHAIN (regno), file);\n   fprintf (file, \" uses \");\n-  df_regs_chain_dump (df, DF_REG_USE_GET (df, regno)->reg_chain, file);\n+  df_regs_chain_dump (DF_REG_USE_CHAIN (regno), file);\n+  fprintf (file, \" eq_uses \");\n+  df_regs_chain_dump (DF_REG_EQ_USE_CHAIN (regno), file);\n   fprintf (file, \"\\n\");\n }\n \n@@ -1275,11 +2027,16 @@ df_ref_debug (struct df_ref *ref, FILE *file)\n   fprintf (file, \"%c%d \",\n \t   DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n \t   DF_REF_ID (ref));\n-  fprintf (file, \"reg %d bb %d insn %d flag %x chain \",\n+  fprintf (file, \"reg %d bb %d insn %d flag 0x%x type 0x%x \",\n \t   DF_REF_REGNO (ref),\n \t   DF_REF_BBNO (ref),\n \t   DF_REF_INSN (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1,\n-\t   DF_REF_FLAGS (ref));\n+\t   DF_REF_FLAGS (ref),\n+\t   DF_REF_TYPE (ref));\n+  if (DF_REF_LOC (ref))\n+    fprintf (file, \"loc %p(%p) chain \", (void *)DF_REF_LOC (ref), (void *)*DF_REF_LOC (ref));\n+  else\n+    fprintf (file, \"chain \");\n   df_chain_dump (DF_REF_CHAIN (ref), file);\n   fprintf (file, \"\\n\");\n }\n@@ -1289,22 +2046,22 @@ df_ref_debug (struct df_ref *ref, FILE *file)\n void\n debug_df_insn (rtx insn)\n {\n-  df_insn_debug (ddf, insn, true, stderr);\n+  df_insn_debug (insn, true, stderr);\n   debug_rtx (insn);\n }\n \n \n void\n debug_df_reg (rtx reg)\n {\n-  df_regno_debug (ddf, REGNO (reg), stderr);\n+  df_regno_debug (REGNO (reg), stderr);\n }\n \n \n void\n debug_df_regno (unsigned int regno)\n {\n-  df_regno_debug (ddf, regno, stderr);\n+  df_regno_debug (regno, stderr);\n }\n \n \n@@ -1318,14 +2075,14 @@ debug_df_ref (struct df_ref *ref)\n void\n debug_df_defno (unsigned int defno)\n {\n-  df_ref_debug (DF_DEFS_GET (ddf, defno), stderr);\n+  df_ref_debug (DF_DEFS_GET (defno), stderr);\n }\n \n \n void\n debug_df_useno (unsigned int defno)\n {\n-  df_ref_debug (DF_USES_GET (ddf, defno), stderr);\n+  df_ref_debug (DF_USES_GET (defno), stderr);\n }\n \n "}, {"sha": "67a8cb0a916ac202e42253aba7df45260a572915", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2118, "deletions": 1576, "changes": 3694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "8c7cbf0c49b3be39141289d7bbdfcc2db5a81b2e", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3189, "deletions": 950, "changes": 4139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "1474c0ae204628196082f7dec341cf84e1779690", "filename": "gcc/df.h", "status": "modified", "additions": 586, "deletions": 241, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,6 +1,6 @@\n /* Form lists of pseudo register references for autoinc optimization\n    for GNU compiler.  This is part of flow optimization.\n-   Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2006\n+   Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n@@ -36,20 +36,23 @@ struct df;\n struct df_problem;\n struct df_link;\n \n-/* Data flow problems.  All problems must have a unique here.  */ \n+/* Data flow problems.  All problems must have a unique id here.  */ \n /* Scanning is not really a dataflow problem, but it is useful to have\n    the basic block functions in the vector so that things get done in\n-   a uniform manner.  */\n+   a uniform manner.  The first four problems are always defined.  The\n+   last 5 are optional and can be added or deleted at any time.  */\n #define DF_SCAN  0 \n-#define DF_RU    1      /* Reaching Uses. */\n-#define DF_RD    2      /* Reaching Defs. */\n-#define DF_LR    3      /* Live Registers. */\n-#define DF_UR    4      /* Uninitialized Registers. */\n+#define DF_LR    1      /* Live Registers backward. */\n+#define DF_LIVE  2      /* Live Registers & Uninitialized Registers */\n+\n+#define DF_RU    3      /* Reaching Uses. */\n+#define DF_RD    4      /* Reaching Defs. */\n #define DF_UREC  5      /* Uninitialized Registers with Early Clobber. */\n #define DF_CHAIN 6      /* Def-Use and/or Use-Def Chains. */\n-#define DF_RI    7      /* Register Info. */\n-#define DF_LAST_PROBLEM_PLUS1 (DF_RI + 1)\n+#define DF_NOTE  7      /* REG_DEF and REG_UNUSED notes. */\n \n+#define DF_LAST_PROBLEM_PLUS1 (DF_NOTE + 1)\n+#define DF_FIRST_OPTIONAL_PROBLEM DF_RU\n \n /* Dataflow direction.  */\n enum df_flow_dir\n@@ -73,33 +76,26 @@ enum df_ref_flags\n     /* Read-modify-write refs generate both a use and a def and\n        these are marked with this flag to show that they are not\n        independent.  */\n-    DF_REF_READ_WRITE = 1,\n-\n-    /* This flag is set, if we stripped the subreg from the reference.\n-       In this case we must make conservative guesses, at what the\n-       outer mode was.  */\n-    DF_REF_STRIPPED = 2,\n-    \n-    /* If this flag is set, this is not a real definition/use, but an\n-       artificial one created to model always live registers, eh uses, etc.  */\n-    DF_REF_ARTIFICIAL = 4,\n-\n+    DF_REF_READ_WRITE = 1 << 0,\n \n     /* If this flag is set for an artificial use or def, that ref\n        logically happens at the top of the block.  If it is not set\n        for an artificial use or def, that ref logically happens at the\n        bottom of the block.  This is never set for regular refs.  */\n-    DF_REF_AT_TOP = 8,\n+    DF_REF_AT_TOP = 1 << 1,\n \n-    /* This flag is set if the use is inside a REG_EQUAL note.  */\n-    DF_REF_IN_NOTE = 16,\n+    /* This flag is set if the use is inside a REG_EQUAL or REG_EQUIV\n+       note.  */\n+    DF_REF_IN_NOTE = 1 << 2,\n \n     /* This flag is set if this ref, generally a def, may clobber the\n        referenced register.  This is generally only set for hard\n        registers that cross a call site.  With better information\n        about calls, some of these could be changed in the future to\n        DF_REF_MUST_CLOBBER.  */\n-    DF_REF_MAY_CLOBBER = 32,\n+    DF_REF_MAY_CLOBBER = 1 << 3,\n+\n+\n \n     /* This flag is set if this ref, generally a def, is a real\n        clobber. This is not currently set for registers live across a\n@@ -110,65 +106,122 @@ enum df_ref_flags\n        clobber is to a subreg.  So in order to tell if the clobber\n        wipes out the entire register, it is necessary to also check\n        the DF_REF_PARTIAL flag.  */\n-    DF_REF_MUST_CLOBBER = 64,\n+    DF_REF_MUST_CLOBBER = 1 << 4,\n \n     /* This bit is true if this ref is part of a multiword hardreg.  */\n-    DF_REF_MW_HARDREG = 128,\n+    DF_REF_MW_HARDREG = 1 << 5,\n \n     /* This flag is set if this ref is a partial use or def of the\n        associated register.  */\n-    DF_REF_PARTIAL = 256\n+    DF_REF_PARTIAL = 1 << 6,\n+    \n+    /* This flag is set if this ref occurs inside of a conditional\n+       execution instruction.  */\n+    DF_REF_CONDITIONAL = 1 << 7,\n+\n+\n+\n+    /* This flag is set if this ref is inside a pre/post modify.  */\n+    DF_REF_PRE_POST_MODIFY = 1 << 8,\n+\n+    /* This flag is set if this ref is a usage of the stack pointer by\n+       a function call.  */\n+    DF_REF_CALL_STACK_USAGE = 1 << 9,\n+\n+    /* This flag is used for verification of existing refs. */\n+    DF_REF_REG_MARKER = 1 << 10,\n+\n+    /* This bit is true if this ref can make regs_ever_live true for\n+       this regno.  */\n+    DF_HARD_REG_LIVE = 1 << 11\n   };\n \n+/* The possible ordering of refs within the df_ref_info.  */\n+enum df_ref_order\n+  {\n+    /* There is not table.  */ \n+    DF_REF_ORDER_NO_TABLE,\n+\n+    /* There is a table of refs but it is not (or no longer) organized\n+       by one of the following methods.  */\n+    DF_REF_ORDER_UNORDERED,\n+    DF_REF_ORDER_UNORDERED_WITH_NOTES,\n+  \n+    /* Organize the table by reg order, all of the refs with regno 0\n+       followed by all of the refs with regno 1 ... .  Within all of\n+       the regs for a particular regno, the refs are unordered.  */\n+    DF_REF_ORDER_BY_REG,\n+\n+    /* For uses, the refs within eq notes may be added for\n+       DF_REF_ORDER_BY_REG.  */\n+    DF_REF_ORDER_BY_REG_WITH_NOTES,\n+\n+    /* Organize the refs in insn order.  The insns are ordered within a\n+       block, and the blocks are ordered by FOR_ALL_BB.  */  \n+    DF_REF_ORDER_BY_INSN,\n+\n+    /* For uses, the refs within eq notes may be added for\n+       DF_REF_ORDER_BY_INSN.  */\n+    DF_REF_ORDER_BY_INSN_WITH_NOTES\n+  };\n \n /* Function prototypes added to df_problem instance.  */\n \n /* Allocate the problem specific data.  */\n-typedef void (*df_alloc_function) (struct dataflow *, bitmap, bitmap);\n+typedef void (*df_alloc_function) (bitmap);\n \n /* This function is called if the problem has global data that needs\n    to be cleared when ever the set of blocks changes.  The bitmap\n    contains the set of blocks that may require special attention.\n    This call is only made if some of the blocks are going to change.\n    If everything is to be deleted, the wholesale deletion mechanisms\n    apply. */\n-typedef void (*df_reset_function) (struct dataflow *, bitmap);\n+typedef void (*df_reset_function) (bitmap);\n \n /* Free the basic block info.  Called from the block reordering code\n    to get rid of the blocks that have been squished down.   */\n-typedef void (*df_free_bb_function) (struct dataflow *, basic_block, void *);\n+typedef void (*df_free_bb_function) (basic_block, void *);\n \n /* Local compute function.  */\n-typedef void (*df_local_compute_function) (struct dataflow *, bitmap, bitmap);\n+typedef void (*df_local_compute_function) (bitmap);\n \n /* Init the solution specific data.  */\n-typedef void (*df_init_function) (struct dataflow *, bitmap);\n+typedef void (*df_init_function) (bitmap);\n \n /* Iterative dataflow function.  */\n-typedef void (*df_dataflow_function) (struct dataflow *, bitmap, bitmap, \n-\t\t\t\t   int *, int, bool);\n+typedef void (*df_dataflow_function) (struct dataflow *, bitmap, int *, int);\n \n /* Confluence operator for blocks with 0 out (or in) edges.  */\n-typedef void (*df_confluence_function_0) (struct dataflow *, basic_block);\n+typedef void (*df_confluence_function_0) (basic_block);\n \n /* Confluence operator for blocks with 1 or more out (or in) edges.  */\n-typedef void (*df_confluence_function_n) (struct dataflow *, edge);\n+typedef void (*df_confluence_function_n) (edge);\n \n /* Transfer function for blocks.  */\n-typedef bool (*df_transfer_function) (struct dataflow *, int);\n+typedef bool (*df_transfer_function) (int);\n \n /* Function to massage the information after the problem solving.  */\n-typedef void (*df_finalizer_function) (struct dataflow*, bitmap);\n+typedef void (*df_finalizer_function) (bitmap);\n \n /* Function to free all of the problem specific datastructures.  */\n-typedef void (*df_free_function) (struct dataflow *);\n+typedef void (*df_free_function) (void);\n+\n+/* Function to remove this problem from the stack of dataflow problems\n+   without effecting the other problems in the stack except for those\n+   that depend on this problem.  */\n+typedef void (*df_remove_problem_function) (void);\n+\n+/* Function to dump basic block independent results to FILE.  */\n+typedef void (*df_dump_problem_function) (FILE *);\n \n-/* Function to dump results to FILE.  */\n-typedef void (*df_dump_problem_function) (struct dataflow *, FILE *);\n+/* Function to dump top or bottom of basic block results to FILE.  */\n+typedef void (*df_dump_bb_problem_function) (basic_block, FILE *);\n \n-/* Function to add problem a dataflow problem that must be solved\n-   before this problem can be solved.  */\n-typedef struct dataflow * (*df_dependent_problem_function) (struct df *, int);\n+/* Function to dump top or bottom of basic block results to FILE.  */\n+typedef void (*df_verify_solution_start) (void);\n+\n+/* Function to dump top or bottom of basic block results to FILE.  */\n+typedef void (*df_verify_solution_end) (void);\n \n /* The static description of a dataflow problem to solve.  See above\n    typedefs for doc for the function fields.  */\n@@ -189,23 +242,23 @@ struct df_problem {\n   df_transfer_function trans_fun;\n   df_finalizer_function finalize_fun;\n   df_free_function free_fun;\n-  df_dump_problem_function dump_fun;\n-  df_dependent_problem_function dependent_problem_fun;\n-\n-  /* Flags can be changed after analysis starts.  */\n-  int changeable_flags;\n+  df_remove_problem_function remove_problem_fun;\n+  df_dump_problem_function dump_start_fun;\n+  df_dump_bb_problem_function dump_top_fun;\n+  df_dump_bb_problem_function dump_bottom_fun;\n+  df_verify_solution_start verify_start_fun;\n+  df_verify_solution_end verify_end_fun;\n+  struct df_problem *dependent_problem;\n+  /* The timevar id associated with this pass.  */\n+  unsigned int tv_id;\n };\n \n \n /* The specific instance of the problem to solve.  */\n struct dataflow\n {\n-  struct df *df;                        /* Instance of df we are working in.  */\n   struct df_problem *problem;           /* The problem to be solved.  */\n \n-  /* Communication between iterative_dataflow and hybrid_search. */\n-  sbitmap visited, pending, considered; \n-\n   /* Array indexed by bb->index, that contains basic block problem and\n      solution specific information.  */\n   void **block_info;\n@@ -214,25 +267,32 @@ struct dataflow\n   /* The pool to allocate the block_info from. */\n   alloc_pool block_pool;                \n \n-  /* Problem specific control information.  */\n-\n-  /* Scanning flags.  */\n-#define DF_HARD_REGS\t     1\t/* Mark hard registers.  */\n-#define DF_EQUIV_NOTES\t     2\t/* Mark uses present in EQUIV/EQUAL notes.  */\n-#define DF_SUBREGS\t     4\t/* Return subregs rather than the inner reg.  */\n-  /* Flags that control the building of chains.  */\n-#define DF_DU_CHAIN          1    /* Build DU chains.  */  \n-#define DF_UD_CHAIN          2    /* Build UD chains.  */\n-  /* Flag to control the building of register info.  */\n-#define DF_RI_LIFE           1    /* Build register info.  */\n-\n-  int flags;\n+  /* The lr and live problems have their transfer functions recomputed\n+     only if necessary.  This is possible for them because, the\n+     problems are kept active for the entire backend and their\n+     transfer functions are indexed by the REGNO.  These are not\n+     defined for any other problem.  */\n+  bitmap out_of_date_transfer_functions;\n \n   /* Other problem specific data that is not on a per basic block\n      basis.  The structure is generally defined privately for the\n      problem.  The exception being the scanning problem where it is\n      fully public.  */\n-  void *problem_data;                  \n+  void *problem_data;\n+\n+  /* Local flags for some of the problems. */\n+  unsigned int local_flags;\n+  \n+  /* True if this problem of this instance has been initialized.  This\n+     is used by the dumpers to keep garbage out of the dumps if, for\n+     debugging a dump is produced before the first call to\n+     df_analyze after a new problem is added.  */\n+  bool computed;\n+\n+  /* True if the something has changed which invalidates the dataflow\n+     solutions.  Note that this bit is always true for all problems except \n+     lr and live.  */\n+  bool solutions_dirty;\n };\n \n \n@@ -243,36 +303,31 @@ struct dataflow\n struct df_mw_hardreg\n {\n   rtx mw_reg;                   /* The multiword hardreg.  */ \n+  rtx *loc;\t\t\t/* The location of the reg.  */\n   enum df_ref_type type;        /* Used to see if the ref is read or write.  */\n   enum df_ref_flags flags;\t/* Various flags.  */\n-  struct df_link *regs;         /* The individual regs that make up\n-\t\t\t\t   this hardreg.  */\n-  struct df_mw_hardreg *next;   /* The next mw_hardreg in this insn.  */\n+  unsigned int start_regno;     /* First word of the multi word subreg.  */\n+  unsigned int end_regno;       /* Last word of the multi word subreg.  */\n+  unsigned int mw_order;        /* Same as df_ref.ref_order.  */\n };\n  \n \n /* One of these structures is allocated for every insn.  */\n struct df_insn_info\n {\n-  struct df_ref *defs;\t        /* Head of insn-def chain.  */\n-  struct df_ref *uses;\t        /* Head of insn-use chain.  */\n-  struct df_mw_hardreg *mw_hardregs;   \n-  /* ???? The following luid field should be considered private so that\n-     we can change it on the fly to accommodate new insns?  */\n-  int luid;\t\t\t/* Logical UID.  */\n-  bool contains_asm;            /* Contains an asm instruction.  */\n+  rtx insn;                     /* The insn this info comes from.  */\n+  struct df_ref **defs;\t        /* Head of insn-def chain.  */\n+  struct df_ref **uses;\t        /* Head of insn-use chain.  */\n+  /* Head of insn-use chain for uses in REG_EQUAL/EQUIV notes.  */\n+  struct df_ref **eq_uses;       \n+  struct df_mw_hardreg **mw_hardregs;\n+  /* The logical uid of the insn in the basic block.  This is valid\n+     after any call to df_analyze but may rot after insns are added,\n+     deleted or moved. */\n+  int luid; \n };\n \n \n-/* Two of these structures are allocated for every pseudo reg, one for\n-   the uses and one for the defs.  */\n-struct df_reg_info\n-{\n-  struct df_ref *reg_chain;     /* Head of reg-use or def chain.  */\n-  unsigned int begin;           /* First def_index for this pseudo.  */\n-  unsigned int n_refs;          /* Number of refs or defs for this pseudo.  */\n-};\n-\n /* Define a register reference structure.  One of these is allocated\n    for every register reference (use or def).  Note some register\n    references (e.g., post_inc, subreg) generate both a def and a use.  */\n@@ -287,20 +342,21 @@ struct df_ref\n   rtx insn;\n   rtx *loc;\t\t\t/* The location of the reg.  */\n   struct df_link *chain;\t/* Head of def-use, use-def.  */\n-  unsigned int id;\t\t/* Location in table.  */\n+  /* Location in the ref table.  This is only valid after a call to \n+     df_maybe_reorganize_[use,def]_refs which is an expensive operation.  */\n+  int id;\n+  /* The index at which the operand was scanned in the insn.  This is\n+     used to totally order the refs in an insn.  */\n+  unsigned int ref_order;\n+\n   enum df_ref_type type;\t/* Type of ref.  */\n   enum df_ref_flags flags;\t/* Various flags.  */\n \n-  /* For each regno, there are two chains of refs, one for the uses\n-     and one for the defs.  These chains go thru the refs themselves\n-     rather than using an external structure.  */\n+  /* For each regno, there are three chains of refs, one for the uses,\n+     the eq_uses and the defs.  These chains go thru the refs\n+     themselves rather than using an external structure.  */\n   struct df_ref *next_reg;     /* Next ref with same regno and type.  */\n   struct df_ref *prev_reg;     /* Prev ref with same regno and type.  */\n-\n-  /* Each insn has two lists, one for the uses and one for the\n-     defs. This is the next field in either of these chains. */\n-  struct df_ref *next_ref; \n-  void *data;\t\t\t/* The data assigned to it by user.  */\n };\n \n /* These links are used for two purposes:\n@@ -312,26 +368,67 @@ struct df_link\n   struct df_link *next;\n };\n \n-/* Two of these structures are allocated, one for the uses and one for\n-   the defs.  */\n+\f\n+enum df_chain_flags\n+{\n+  /* Flags that control the building of chains.  */\n+  DF_DU_CHAIN      =  1, /* Build DU chains.  */  \n+  DF_UD_CHAIN      =  2  /* Build UD chains.  */\n+};\n+\n+enum df_changeable_flags \n+{\n+  /* Scanning flags.  */\n+  /* Flag to control the running of dce as a side effect of building LR.  */\n+  DF_LR_RUN_DCE           =  1, /* Run DCE.  */\n+  DF_NO_HARD_REGS         =  2, /* Skip hard registers in RD and CHAIN Building.  */\n+  DF_EQ_NOTES             =  4, /* Build chains with uses present in EQUIV/EQUAL notes. */\n+  DF_NO_REGS_EVER_LIVE    =  8, /* Do not compute the regs_ever_live.  */\n+\n+  /* Cause df_insn_rescan df_notes_rescan and df_insn_delete, to\n+  return immediately.  This is used by passes that know how to update\n+  the scanning them selves.  */\n+  DF_NO_INSN_RESCAN       = 16,\n+\n+  /* Cause df_insn_rescan df_notes_rescan and df_insn_delete, to\n+  return after marking the insn for later processing.  This allows all\n+  rescans to be batched.  */\n+  DF_DEFER_INSN_RESCAN    = 32\n+};\n+\n+/* Two of these structures are inline in df, one for the uses and one\n+   for the defs.  This structure is only contains the refs within the\n+   boundary of the df_set_blocks if that has been defined.  */\n struct df_ref_info\n {\n-  struct df_reg_info **regs;    /* Array indexed by pseudo regno. */\n-  unsigned int regs_size;       /* Size of currently allocated regs table.  */\n-  unsigned int regs_inited;     /* Number of regs with reg_infos allocated.  */\n   struct df_ref **refs;         /* Ref table, indexed by id.  */\n+  unsigned int *begin;          /* First ref_index for this pseudo.  */\n+  unsigned int *count;          /* Count of refs for this pseudo.  */\n   unsigned int refs_size;       /* Size of currently allocated refs table.  */\n-  unsigned int bitmap_size;\t/* Number of refs seen.  */\n-\n-  /* >0 if refs table is organized so that every reference for a\n-     pseudo is contiguous.  */\n-  unsigned int refs_organized_size;\n-  /* True if the next refs should be added immediately or false to\n-     defer to later to reorganize the table.  */\n-  bool add_refs_inline; \n+\n+  /* Table_size is the number of elements in the refs table.  This\n+     will also be the width of the bitvectors in the rd and ru\n+     problems.  Total_size is the number of refs.  These will be the\n+     same if the focus has not been reduced by df_set_blocks.  If the\n+     focus has been reduced, table_size will be smaller since it only\n+     contains the refs in the set blocks.  */\n+  unsigned int table_size;\n+  unsigned int total_size;\n+\n+  enum df_ref_order ref_order;\n };\n \n-\f\n+/* Three of these structures are allocated for every pseudo reg. One\n+   for the uses, one for the eq_uses and one for the defs.  */\n+struct df_reg_info\n+{\n+  /* Head of chain for refs of that type and regno.  */\n+  struct df_ref *reg_chain;\n+  /* Number of refs in the chain.  */\n+  unsigned int n_refs;\n+};\n+\n+\n /*----------------------------------------------------------------------------\n    Problem data for the scanning dataflow problem.  Unlike the other\n    dataflow problems, the problem data for scanning is fully exposed and\n@@ -349,65 +446,118 @@ struct df\n      the problem local data without having to search the first\n      array.  */\n \n-  struct dataflow *problems_in_order [DF_LAST_PROBLEM_PLUS1]; \n-  struct dataflow *problems_by_index [DF_LAST_PROBLEM_PLUS1]; \n+  struct dataflow *problems_in_order[DF_LAST_PROBLEM_PLUS1]; \n+  struct dataflow *problems_by_index[DF_LAST_PROBLEM_PLUS1]; \n   int num_problems_defined;\n \n-  /* Set after calls to df_scan_blocks, this contains all of the\n-     blocks that higher level problems must rescan before solving the\n-     dataflow equations.  If this is NULL, the blocks_to_analyze is\n-     used. */\n-  bitmap blocks_to_scan;\n-\n-  /* If not NULL, the subset of blocks of the program to be considered\n-     for analysis.  */ \n+  /* If not NULL, this subset of blocks of the program to be\n+     considered for analysis.  At certain times, this will contain all\n+     the blocks in the function so it cannot be used as an indicator\n+     of if we are analyzing a subset.  See analyze_subset.  */ \n   bitmap blocks_to_analyze;\n \n+  /* If this is true, then only a subset of the blocks of the program\n+     is considered to compute the solutions of dataflow problems.  */\n+  bool analyze_subset;\n+\n+  /* True if someone added or deleted something from regs_ever_live so\n+     that the entry and exit blocks need be reprocessed.  */\n+  bool redo_entry_and_exit;\n+\n   /* The following information is really the problem data for the\n      scanning instance but it is used too often by the other problems\n      to keep getting it from there.  */\n   struct df_ref_info def_info;   /* Def info.  */\n   struct df_ref_info use_info;   /* Use info.  */\n+\n+  /* The following three arrays are allocated in parallel.   They contain\n+     the sets of refs of each type for each reg.  */\n+  struct df_reg_info **def_regs;       /* Def reg info.  */\n+  struct df_reg_info **use_regs;       /* Eq_use reg info.  */\n+  struct df_reg_info **eq_use_regs;    /* Eq_use info.  */\n+  unsigned int regs_size;       /* Size of currently allocated regs table.  */\n+  unsigned int regs_inited;     /* Number of regs with reg_infos allocated.  */\n+\n+\n   struct df_insn_info **insns;   /* Insn table, indexed by insn UID.  */\n   unsigned int insns_size;       /* Size of insn table.  */\n   bitmap hardware_regs_used;     /* The set of hardware registers used.  */\n-  bitmap entry_block_defs;       /* The set of hardware registers live on entry to the function.  */\n+  /* The set of hard regs that are in the artificial uses at the end\n+     of a regular basic block.  */\n+  bitmap regular_block_artificial_uses;\n+  /* The set of hard regs that are in the artificial uses at the end\n+     of a basic block that has an EH pred.  */\n+  bitmap eh_block_artificial_uses;\n+  /* The set of hardware registers live on entry to the function.  */\n+  bitmap entry_block_defs;\n   bitmap exit_block_uses;        /* The set of hardware registers used in exit block.  */\n+\n+  /* Insns to delete, rescan or reprocess the notes at next\n+     df_rescan_all or df_process_deferred_rescans. */\n+  bitmap insns_to_delete;\n+  bitmap insns_to_rescan;\n+  bitmap insns_to_notes_rescan;\n+  int *postorder;                /* The current set of basic blocks \n+                                    in reverse postorder.  */\n+  int *postorder_inverted;       /* The current set of basic blocks \n+                                    in reverse postorder of inverted CFG.  */\n+  int n_blocks;                  /* The number of blocks in reverse postorder.  */\n+  int n_blocks_inverted;         /* The number of blocks \n+                                    in reverse postorder of inverted CFG.  */\n+\n+  /* An array [FIRST_PSEUDO_REGISTER], indexed by regno, of the number\n+     of refs that qualify as being real hard regs uses.  Artificial\n+     uses and defs as well as refs in eq notes are ignored.  If the\n+     ref is a def, it cannot be a MAY_CLOBBER def.  If the ref is a\n+     use, it cannot be the emim_reg_set or be the frame or arg pointer\n+     register.\n+\n+     IT IS NOT ACCEPTABLE TO MANUALLY CHANGE THIS ARRAY.  This array\n+     always reflects the actual number of refs in the insn stream that\n+     satisfy the above criteria.  */\n+  unsigned int *hard_regs_live_count;\n+\n+  /* This counter provides a way to totally order refs without using\n+     addresses.  It is incremented whenever a ref is created.  */\n+  unsigned int ref_order;\n+\n+  /* Problem specific control infomation.  */\n+  enum df_changeable_flags changeable_flags;\n };\n \n-#define DF_SCAN_BB_INFO(DF, BB) (df_scan_get_bb_info((DF)->problems_by_index[DF_SCAN],(BB)->index))\n-#define DF_RU_BB_INFO(DF, BB) (df_ru_get_bb_info((DF)->problems_by_index[DF_RU],(BB)->index))\n-#define DF_RD_BB_INFO(DF, BB) (df_rd_get_bb_info((DF)->problems_by_index[DF_RD],(BB)->index))\n-#define DF_LR_BB_INFO(DF, BB) (df_lr_get_bb_info((DF)->problems_by_index[DF_LR],(BB)->index))\n-#define DF_UR_BB_INFO(DF, BB) (df_ur_get_bb_info((DF)->problems_by_index[DF_UR],(BB)->index))\n-#define DF_UREC_BB_INFO(DF, BB) (df_urec_get_bb_info((DF)->problems_by_index[DF_UREC],(BB)->index))\n+#define DF_SCAN_BB_INFO(BB) (df_scan_get_bb_info((BB)->index))\n+#define DF_RU_BB_INFO(BB) (df_ru_get_bb_info((BB)->index))\n+#define DF_RD_BB_INFO(BB) (df_rd_get_bb_info((BB)->index))\n+#define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n+#define DF_UREC_BB_INFO(BB) (df_urec_get_bb_info((BB)->index))\n+#define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n-   use these macros.  The DF_UPWARD_LIVE* macros are only half of the\n-   solution.  */\n-#define DF_LIVE_IN(DF, BB) (DF_UR_BB_INFO(DF, BB)->in) \n-#define DF_LIVE_OUT(DF, BB) (DF_UR_BB_INFO(DF, BB)->out) \n+   use these macros.  This info is the and of the lr and live sets.  */\n+#define DF_LIVE_IN(BB) (DF_LIVE_BB_INFO(BB)->in) \n+#define DF_LIVE_OUT(BB) (DF_LIVE_BB_INFO(BB)->out) \n \n \n /* Live in for register allocation also takes into account several other factors.  */\n-#define DF_RA_LIVE_IN(DF, BB) (DF_UREC_BB_INFO(DF, BB)->in) \n-#define DF_RA_LIVE_OUT(DF, BB) (DF_UREC_BB_INFO(DF, BB)->out) \n+#define DF_RA_LIVE_IN(BB) (DF_UREC_BB_INFO(BB)->in) \n+#define DF_RA_LIVE_TOP(BB) (DF_UREC_BB_INFO(BB)->top) \n+#define DF_RA_LIVE_OUT(BB) (DF_UREC_BB_INFO(BB)->out) \n \n /* These macros are currently used by only reg-stack since it is not\n    tolerant of uninitialized variables.  This intolerance should be\n    fixed because it causes other problems.  */ \n-#define DF_UPWARD_LIVE_IN(DF, BB) (DF_LR_BB_INFO(DF, BB)->in) \n-#define DF_UPWARD_LIVE_OUT(DF, BB) (DF_LR_BB_INFO(DF, BB)->out) \n-\n+#define DF_LR_IN(BB) (DF_LR_BB_INFO(BB)->in) \n+#define DF_LR_TOP(BB) (DF_LR_BB_INFO(BB)->top) \n+#define DF_LR_OUT(BB) (DF_LR_BB_INFO(BB)->out) \n \n /* Macros to access the elements within the ref structure.  */\n \n \n #define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n \t\t\t\t? SUBREG_REG ((REF)->reg) : ((REF)->reg))\n #define DF_REF_REGNO(REF) ((REF)->regno)\n-#define DF_REF_REAL_LOC(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n-\t\t\t        ? &SUBREG_REG ((REF)->reg) : ((REF)->loc))\n+#define DF_REF_REAL_LOC(REF) (GET_CODE (*((REF)->loc)) == SUBREG \\\n+                               ? &SUBREG_REG (*((REF)->loc)) : ((REF)->loc))\n #define DF_REF_REG(REF) ((REF)->reg)\n #define DF_REF_LOC(REF) ((REF)->loc)\n #define DF_REF_BB(REF) ((REF)->bb)\n@@ -418,10 +568,20 @@ struct df\n #define DF_REF_CHAIN(REF) ((REF)->chain)\n #define DF_REF_ID(REF) ((REF)->id)\n #define DF_REF_FLAGS(REF) ((REF)->flags)\n+#define DF_REF_FLAGS_IS_SET(REF, v) ((DF_REF_FLAGS (REF) & (v)) != 0)\n+#define DF_REF_FLAGS_SET(REF, v) (DF_REF_FLAGS (REF) |= (v))\n+#define DF_REF_FLAGS_CLEAR(REF, v) (DF_REF_FLAGS (REF) &= ~(v))\n+#define DF_REF_ORDER(REF) ((REF)->ref_order)\n+/* If DF_REF_IS_ARTIFICIAL () is true, this is not a real definition/use, \n+   but an artificial one created to model \n+   always live registers, eh uses, etc.  \n+   ARTIFICIAL refs has NULL insn.  */\n+#define DF_REF_IS_ARTIFICIAL(REF) ((REF)->insn == NULL)\n+#define DF_REF_REG_MARK(REF) (DF_REF_FLAGS_SET ((REF),DF_REF_REG_MARKER))\n+#define DF_REF_REG_UNMARK(REF) (DF_REF_FLAGS_CLEAR ((REF),DF_REF_REG_MARKER))\n+#define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_NEXT_REG(REF) ((REF)->next_reg)\n #define DF_REF_PREV_REG(REF) ((REF)->prev_reg)\n-#define DF_REF_NEXT_REF(REF) ((REF)->next_ref)\n-#define DF_REF_DATA(REF) ((REF)->data)\n \n /* Macros to determine the reference type.  */\n \n@@ -432,46 +592,74 @@ struct df\n #define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n                                || DF_REF_REG_MEM_LOAD_P (REF))\n \n-/* Macros to get the refs out of def_info or use_info refs table.  */\n-#define DF_DEFS_SIZE(DF) ((DF)->def_info.refs_organized_size)\n-#define DF_DEFS_GET(DF,ID) ((DF)->def_info.refs[(ID)])\n-#define DF_DEFS_SET(DF,ID,VAL) ((DF)->def_info.refs[(ID)]=(VAL))\n-#define DF_USES_SIZE(DF) ((DF)->use_info.refs_organized_size)\n-#define DF_USES_GET(DF,ID) ((DF)->use_info.refs[(ID)])\n-#define DF_USES_SET(DF,ID,VAL) ((DF)->use_info.refs[(ID)]=(VAL))\n+/* Macros to get the refs out of def_info or use_info refs table.  If\n+   the focus of the dataflow has been set to some subset of blocks\n+   with df_set_blocks, these macros will only find the uses and defs\n+   in that subset of blocks.  \n+\n+   These macros should be used with care.  The def macros are only\n+   usable after a call to df_maybe_reorganize_def_refs and the use\n+   macros are only usable after a call to\n+   df_maybe_reorganize_use_refs.  HOWEVER, BUILDING AND USING THESE\n+   ARRAYS ARE A CACHE LOCALITY KILLER.  */\n+\n+#define DF_DEFS_TABLE_SIZE() (df->def_info.table_size)\n+#define DF_DEFS_GET(ID) (df->def_info.refs[(ID)])\n+#define DF_DEFS_SET(ID,VAL) (df->def_info.refs[(ID)]=(VAL))\n+#define DF_DEFS_COUNT(ID) (df->def_info.count[(ID)])\n+#define DF_DEFS_BEGIN(ID) (df->def_info.begin[(ID)])\n+#define DF_USES_TABLE_SIZE() (df->use_info.table_size)\n+#define DF_USES_GET(ID) (df->use_info.refs[(ID)])\n+#define DF_USES_SET(ID,VAL) (df->use_info.refs[(ID)]=(VAL))\n+#define DF_USES_COUNT(ID) (df->use_info.count[(ID)])\n+#define DF_USES_BEGIN(ID) (df->use_info.begin[(ID)])\n \n /* Macros to access the register information from scan dataflow record.  */\n \n-#define DF_REG_SIZE(DF) ((DF)->def_info.regs_inited)\n-#define DF_REG_DEF_GET(DF, REG) ((DF)->def_info.regs[(REG)])\n-#define DF_REG_DEF_SET(DF, REG, VAL) ((DF)->def_info.regs[(REG)]=(VAL))\n-#define DF_REG_DEF_COUNT(DF, REG) ((DF)->def_info.regs[(REG)]->n_refs)\n-#define DF_REG_USE_GET(DF, REG) ((DF)->use_info.regs[(REG)])\n-#define DF_REG_USE_SET(DF, REG, VAL) ((DF)->use_info.regs[(REG)]=(VAL))\n-#define DF_REG_USE_COUNT(DF, REG) ((DF)->use_info.regs[(REG)]->n_refs)\n+#define DF_REG_SIZE(DF) (df->regs_inited)\n+#define DF_REG_DEF_GET(REG) (df->def_regs[(REG)])\n+#define DF_REG_DEF_CHAIN(REG) (df->def_regs[(REG)]->reg_chain)\n+#define DF_REG_DEF_COUNT(REG) (df->def_regs[(REG)]->n_refs)\n+#define DF_REG_USE_GET(REG) (df->use_regs[(REG)])\n+#define DF_REG_USE_CHAIN(REG) (df->use_regs[(REG)]->reg_chain)\n+#define DF_REG_USE_COUNT(REG) (df->use_regs[(REG)]->n_refs)\n+#define DF_REG_EQ_USE_GET(REG) (df->eq_use_regs[(REG)])\n+#define DF_REG_EQ_USE_CHAIN(REG) (df->eq_use_regs[(REG)]->reg_chain)\n+#define DF_REG_EQ_USE_COUNT(REG) (df->eq_use_regs[(REG)]->n_refs)\n \n /* Macros to access the elements within the reg_info structure table.  */\n \n-#define DF_REGNO_FIRST_DEF(DF, REGNUM) \\\n-(DF_REG_DEF_GET(DF, REGNUM) ? DF_REG_DEF_GET(DF, REGNUM) : 0)\n-#define DF_REGNO_LAST_USE(DF, REGNUM) \\\n-(DF_REG_USE_GET(DF, REGNUM) ? DF_REG_USE_GET(DF, REGNUM) : 0)\n+#define DF_REGNO_FIRST_DEF(REGNUM) \\\n+(DF_REG_DEF_GET(REGNUM) ? DF_REG_DEF_GET(REGNUM) : 0)\n+#define DF_REGNO_LAST_USE(REGNUM) \\\n+(DF_REG_USE_GET(REGNUM) ? DF_REG_USE_GET(REGNUM) : 0)\n \n /* Macros to access the elements within the insn_info structure table.  */\n \n-#define DF_INSN_SIZE(DF) ((DF)->insns_size)\n-#define DF_INSN_GET(DF,INSN) ((DF)->insns[(INSN_UID(INSN))])\n-#define DF_INSN_SET(DF,INSN,VAL) ((DF)->insns[(INSN_UID (INSN))]=(VAL))\n-#define DF_INSN_CONTAINS_ASM(DF, INSN) (DF_INSN_GET(DF,INSN)->contains_asm)\n-#define DF_INSN_LUID(DF, INSN) (DF_INSN_GET(DF,INSN)->luid)\n-#define DF_INSN_DEFS(DF, INSN) (DF_INSN_GET(DF,INSN)->defs)\n-#define DF_INSN_USES(DF, INSN) (DF_INSN_GET(DF,INSN)->uses)\n-\n-#define DF_INSN_UID_GET(DF,UID) ((DF)->insns[(UID)])\n-#define DF_INSN_UID_LUID(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->luid)\n-#define DF_INSN_UID_DEFS(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->defs)\n-#define DF_INSN_UID_USES(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->uses)\n-#define DF_INSN_UID_MWS(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->mw_hardregs)\n+#define DF_INSN_SIZE() ((df)->insns_size)\n+#define DF_INSN_GET(INSN) (df->insns[(INSN_UID(INSN))])\n+#define DF_INSN_SET(INSN,VAL) (df->insns[(INSN_UID (INSN))]=(VAL))\n+#define DF_INSN_LUID(INSN) (DF_INSN_GET(INSN)->luid)\n+#define DF_INSN_DEFS(INSN) (DF_INSN_GET(INSN)->defs)\n+#define DF_INSN_USES(INSN) (DF_INSN_GET(INSN)->uses)\n+#define DF_INSN_EQ_USES(INSN) (DF_INSN_GET(INSN)->eq_uses)\n+\n+#define DF_INSN_UID_GET(UID) (df->insns[(UID)])\n+#define DF_INSN_UID_SET(UID,VAL) (df->insns[(UID)]=(VAL))\n+#define DF_INSN_UID_SAFE_GET(UID) (((unsigned)(UID) < DF_INSN_SIZE())\t\\\n+                                     ? DF_INSN_UID_GET (UID) \\\n+                                     : NULL)\n+#define DF_INSN_UID_LUID(INSN) (DF_INSN_UID_GET(INSN)->luid)\n+#define DF_INSN_UID_DEFS(INSN) (DF_INSN_UID_GET(INSN)->defs)\n+#define DF_INSN_UID_USES(INSN) (DF_INSN_UID_GET(INSN)->uses)\n+#define DF_INSN_UID_EQ_USES(INSN) (DF_INSN_UID_GET(INSN)->eq_uses)\n+#define DF_INSN_UID_MWS(INSN) (DF_INSN_UID_GET(INSN)->mw_hardregs)\n+\n+/* An obstack for bitmap not related to specific dataflow problems.\n+   This obstack should e.g. be used for bitmaps with a short life time\n+   such as temporary bitmaps.  This obstack is declared in df-core.c.  */\n+\n+extern bitmap_obstack df_bitmap_obstack;\n \n /* This is a bitmap copy of regs_invalidated_by_call so that we can\n    easily add it into bitmaps, etc. */ \n@@ -484,10 +672,10 @@ struct df_scan_bb_info\n {\n   /* Defs at the start of a basic block that is the target of an\n      exception edge.  */\n-  struct df_ref *artificial_defs;\n+  struct df_ref **artificial_defs;\n \n   /* Uses of hard registers that are live at every block.  */\n-  struct df_ref *artificial_uses;\n+  struct df_ref **artificial_uses;\n };\n \n \n@@ -531,21 +719,45 @@ struct df_rd_bb_info\n };\n \n \n-/* Live registers.  All bitmaps are referenced by the register number.  */\n+/* Live registers.  All bitmaps are referenced by the register number.  \n+\n+   df_lr_bb_info:IN is the \"in\" set of the traditional dataflow sense\n+   which is the confluence of out sets of all predecessor blocks.\n+   The difference between IN and TOP is \n+   due to the artificial defs and uses at the top (DF_REF_TOP)\n+   (e.g. exception handling dispatch block, which can have\n+   a few registers defined by the runtime) - which is NOT included\n+   in the \"in\" set before this function but is included after.  \n+   For the initial live set of forward scanning, TOP should be used\n+   instead of IN - otherwise, artificial defs won't be in IN set\n+   causing the bad transformation. TOP set can not simply be\n+   the union of IN set and artificial defs at the top, \n+   because artificial defs might not be used at all,\n+   in which case those defs are not live at any point\n+   (except as a dangling def) - hence TOP has to be calculated\n+   during the LR problem computation and stored in df_lr_bb_info.  */\n+\n struct df_lr_bb_info \n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap def;   /* The set of registers set in this block.  */\n+  bitmap def;   /* The set of registers set in this block \n+                   - except artificial defs at the top.  */\n   bitmap use;   /* The set of registers used in this block.  */\n+  bitmap adef;  /* The artificial defs at top. */\n+  bitmap ause;  /* The artificial uses at top. */\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* At the top of the block.  */\n+  bitmap in;    /* Just before the block itself. */\n+  bitmap top;   /* Just before the first insn in the block. */\n   bitmap out;   /* At the bottom of the block.  */\n };\n \n \n-/* Uninitialized registers.  All bitmaps are referenced by the register number.  */\n-struct df_ur_bb_info \n+/* Uninitialized registers.  All bitmaps are referenced by the\n+   register number.  Anded results of the forwards and backward live\n+   info.  Note that the forwards live information is not available\n+   separately.  */\n+struct df_live_bb_info \n {\n   /* Local sets to describe the basic blocks.  */\n   bitmap kill;  /* The set of registers unset in this block.  Calls,\n@@ -557,6 +769,7 @@ struct df_ur_bb_info\n   bitmap out;   /* At the bottom of the block.  */\n };\n \n+\n /* Uninitialized registers.  All bitmaps are referenced by the register number.  */\n struct df_urec_bb_info \n {\n@@ -568,41 +781,81 @@ struct df_urec_bb_info\n   bitmap gen;\n \n   /* The results of the dataflow problem.  */\n-  bitmap in;    /* At the top of the block.  */\n+  bitmap in;    /* Just before the block.  */\n+  bitmap top;   /* Just before the first insn in the block. */\n   bitmap out;   /* At the bottom of the block.  */\n };\n \n \n-#define df_finish(df) {df_finish1(df); df=NULL;}\n+/* This is used for debugging and for the dumpers to find the latest\n+   instance so that the df info can be added to the dumps.  This\n+   should not be used by regular code.  */ \n+extern struct df *df;\n+#define df_scan  (df->problems_by_index[DF_SCAN])\n+#define df_ru    (df->problems_by_index[DF_RU])\n+#define df_rd    (df->problems_by_index[DF_RD])\n+#define df_lr    (df->problems_by_index[DF_LR])\n+#define df_live  (df->problems_by_index[DF_LIVE])\n+#define df_urec  (df->problems_by_index[DF_UREC])\n+#define df_chain (df->problems_by_index[DF_CHAIN])\n+#define df_note  (df->problems_by_index[DF_NOTE])\n+\n+/* This symbol turns on checking that each modfication of the cfg has\n+  been identified to the appropriate df routines.  It is not part of\n+  verification per se because the check that the final solution has\n+  not changed covers this.  However, if the solution is not being\n+  properly recomputed because the cfg is being modified, adding in\n+  calls to df_check_cfg_clean can be used to find the source of that\n+  kind of problem.  */\n+#if 0\n+#define DF_DEBUG_CFG\n+#endif\n+\n \n /* Functions defined in df-core.c.  */\n \n-extern struct df *df_init (int);\n-extern struct dataflow *df_add_problem (struct df *, struct df_problem *, int);\n-extern int df_set_flags (struct dataflow *, int);\n-extern int df_clear_flags (struct dataflow *, int);\n-extern void df_set_blocks (struct df*, bitmap);\n-extern void df_delete_basic_block (struct df *, int);\n-extern void df_finish1 (struct df *);\n-extern void df_analyze_problem (struct dataflow *, bitmap, bitmap, bitmap, int *, int, bool);\n-extern void df_analyze (struct df *);\n-extern void df_compact_blocks (struct df *);\n-extern void df_bb_replace (struct df *, int, basic_block);\n-extern struct df_ref *df_bb_regno_last_use_find (struct df *, basic_block, unsigned int);\n-extern struct df_ref *df_bb_regno_first_def_find (struct df *, basic_block, unsigned int);\n-extern struct df_ref *df_bb_regno_last_def_find (struct df *, basic_block, unsigned int);\n-extern bool df_insn_regno_def_p (struct df *, rtx, unsigned int);\n-extern struct df_ref *df_find_def (struct df *, rtx, rtx);\n-extern bool df_reg_defined (struct df *, rtx, rtx);\n-extern struct df_ref *df_find_use (struct df *, rtx, rtx);\n-extern bool df_reg_used (struct df *, rtx, rtx);\n-extern void df_iterative_dataflow (struct dataflow *, bitmap, bitmap, int *, int, bool);\n-extern void df_dump (struct df *, FILE *);\n-extern void df_refs_chain_dump (struct df_ref *, bool, FILE *);\n-extern void df_regs_chain_dump (struct df *, struct df_ref *,  FILE *);\n-extern void df_insn_debug (struct df *, rtx, bool, FILE *);\n-extern void df_insn_debug_regno (struct df *, rtx, FILE *);\n-extern void df_regno_debug (struct df *, unsigned int, FILE *);\n+extern void df_add_problem (struct df_problem *);\n+extern enum df_changeable_flags df_set_flags (enum df_changeable_flags);\n+extern enum df_changeable_flags df_clear_flags (enum df_changeable_flags);\n+extern void df_set_blocks (bitmap);\n+extern void df_remove_problem (struct dataflow *);\n+extern void df_finish_pass (void);\n+extern void df_analyze_problem (struct dataflow *, bitmap, int *, int);\n+extern void df_analyze (void);\n+extern int df_get_n_blocks (enum df_flow_dir);\n+extern int *df_get_postorder (enum df_flow_dir);\n+extern void df_simple_dataflow (enum df_flow_dir, df_init_function,\n+\t\t\t\tdf_confluence_function_0, df_confluence_function_n,\n+\t\t\t\tdf_transfer_function, bitmap, int *, int);\n+extern void df_mark_solutions_dirty (void);\n+extern bool df_get_bb_dirty (basic_block);\n+extern void df_set_bb_dirty (basic_block);\n+extern void df_compact_blocks (void);\n+extern void df_bb_replace (int, basic_block);\n+extern void df_bb_delete (int);\n+extern void df_verify (void);\n+#ifdef DF_DEBUG_CFG\n+extern void df_check_cfg_clean (void);\n+#endif\n+extern struct df_ref *df_bb_regno_last_use_find (basic_block, unsigned int);\n+extern struct df_ref *df_bb_regno_first_def_find (basic_block, unsigned int);\n+extern struct df_ref *df_bb_regno_last_def_find (basic_block, unsigned int);\n+extern bool df_insn_regno_def_p (rtx, unsigned int);\n+extern struct df_ref *df_find_def (rtx, rtx);\n+extern bool df_reg_defined (rtx, rtx);\n+extern struct df_ref *df_find_use (rtx, rtx);\n+extern bool df_reg_used (rtx, rtx);\n+extern void df_worklist_dataflow (struct dataflow *,bitmap, int *, int);\n+extern void df_print_regset (FILE *file, bitmap r);\n+extern void df_dump (FILE *);\n+extern void df_dump_start (FILE *);\n+extern void df_dump_top (basic_block, FILE *);\n+extern void df_dump_bottom (basic_block, FILE *);\n+extern void df_refs_chain_dump (struct df_ref **, bool, FILE *);\n+extern void df_regs_chain_dump (struct df_ref *,  FILE *);\n+extern void df_insn_debug (rtx, bool, FILE *);\n+extern void df_insn_debug_regno (rtx, FILE *);\n+extern void df_regno_debug (unsigned int, FILE *);\n extern void df_ref_debug (struct df_ref *, FILE *);\n extern void debug_df_insn (rtx);\n extern void debug_df_regno (unsigned int);\n@@ -611,51 +864,144 @@ extern void debug_df_defno (unsigned int);\n extern void debug_df_useno (unsigned int);\n extern void debug_df_ref (struct df_ref *);\n extern void debug_df_chain (struct df_link *);\n-/* An instance of df that can be shared between passes.  */\n-extern struct df *shared_df; \n-\n \n /* Functions defined in df-problems.c. */\n \n-extern struct df_link *df_chain_create (struct dataflow *, struct df_ref *, struct df_ref *);\n-extern void df_chain_unlink (struct dataflow *, struct df_ref *, struct df_link *);\n-extern void df_chain_copy (struct dataflow *, struct df_ref *, struct df_link *);\n-extern bitmap df_get_live_in (struct df *, basic_block);\n-extern bitmap df_get_live_out (struct df *, basic_block);\n+extern struct df_link *df_chain_create (struct df_ref *, struct df_ref *);\n+extern void df_chain_unlink (struct df_ref *);\n+extern void df_chain_copy (struct df_ref *, struct df_link *);\n+extern bitmap df_get_live_in (basic_block);\n+extern bitmap df_get_live_out (basic_block);\n+extern bitmap df_get_live_top (basic_block);\n extern void df_grow_bb_info (struct dataflow *);\n extern void df_chain_dump (struct df_link *, FILE *);\n extern void df_print_bb_index (basic_block bb, FILE *file);\n-extern struct dataflow *df_ru_add_problem (struct df *, int);\n-extern struct df_ru_bb_info *df_ru_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_rd_add_problem (struct df *, int);\n-extern struct df_rd_bb_info *df_rd_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_lr_add_problem (struct df *, int);\n-extern struct df_lr_bb_info *df_lr_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_ur_add_problem (struct df *, int);\n-extern struct df_ur_bb_info *df_ur_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_urec_add_problem (struct df *, int);\n-extern struct df_urec_bb_info *df_urec_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_chain_add_problem (struct df *, int);\n-extern struct dataflow *df_ri_add_problem (struct df *, int);\n-\n+extern void df_ru_add_problem (void);\n+extern void df_rd_add_problem (void);\n+extern void df_lr_add_problem (void);\n+extern void df_lr_verify_transfer_functions (void);\n+extern void df_live_verify_transfer_functions (void);\n+extern void df_live_add_problem (void);\n+extern void df_urec_add_problem (void);\n+extern void df_chain_add_problem (enum df_chain_flags);\n+extern void df_note_add_problem (void);\n+extern void df_simulate_find_defs (rtx, bitmap);\n+extern void df_simulate_defs (rtx, bitmap);\n+extern void df_simulate_uses (rtx, bitmap);\n+extern void df_simulate_artificial_refs_at_top (basic_block, bitmap);\n+extern void df_simulate_one_insn_forwards (basic_block, rtx, bitmap);\n+extern void df_simulate_artificial_refs_at_end (basic_block, bitmap);\n+extern void df_simulate_one_insn_backwards (basic_block, rtx, bitmap);\n \n /* Functions defined in df-scan.c.  */\n \n-extern struct df_scan_bb_info *df_scan_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_scan_add_problem (struct df *, int);\n-extern void df_rescan_blocks (struct df *, bitmap);\n-extern struct df_ref *df_ref_create (struct df *, rtx, rtx *, rtx,basic_block,enum df_ref_type, enum df_ref_flags);\n-extern struct df_ref *df_get_artificial_defs (struct df *, unsigned int);\n-extern struct df_ref *df_get_artificial_uses (struct df *, unsigned int);\n-extern void df_reg_chain_create (struct df_reg_info *, struct df_ref *);\n-extern struct df_ref *df_reg_chain_unlink (struct dataflow *, struct df_ref *);\n-extern void df_ref_remove (struct df *, struct df_ref *);\n-extern void df_insn_refs_delete (struct dataflow *, rtx);\n-extern void df_bb_refs_delete (struct dataflow *, int);\n-extern void df_refs_delete (struct dataflow *, bitmap);\n-extern void df_reorganize_refs (struct df_ref_info *);\n+extern void df_scan_alloc (bitmap);\n+extern void df_scan_add_problem (void);\n+extern void df_grow_reg_info (void);\n+extern void df_grow_insn_info (void);\n+extern void df_scan_blocks (void);\n+extern struct df_ref *df_ref_create (rtx, rtx *, rtx,basic_block, \n+\t\t\t\t     enum df_ref_type, enum df_ref_flags);\n+extern void df_ref_remove (struct df_ref *);\n+extern struct df_insn_info * df_insn_create_insn_record (rtx);\n+extern void df_insn_delete (basic_block, unsigned int);\n+extern void df_bb_refs_record (int, bool);\n+extern bool df_insn_rescan (rtx);\n+extern void df_insn_rescan_all (void);\n+extern void df_process_deferred_rescans (void);\n+extern bool df_has_eh_preds (basic_block);\n+extern void df_recompute_luids (basic_block);\n+extern void df_insn_change_bb (rtx);\n+extern void df_maybe_reorganize_use_refs (enum df_ref_order);\n+extern void df_maybe_reorganize_def_refs (enum df_ref_order);\n+extern void df_ref_change_reg_with_loc (int, int, rtx);\n+extern void df_notes_rescan (rtx);\n extern void df_hard_reg_init (void);\n+extern void df_update_entry_block_defs (void);\n+extern void df_update_exit_block_uses (void);\n+extern void df_update_entry_exit_and_calls (void);\n+extern bool df_hard_reg_used_p (unsigned int);\n+extern unsigned int df_hard_reg_used_count (unsigned int);\n+extern bool df_regs_ever_live_p (unsigned int);\n+extern void df_set_regs_ever_live (unsigned int, bool);\n+extern void df_compute_regs_ever_live (bool);\n extern bool df_read_modify_subreg_p (rtx);\n+extern void df_scan_verify (void);\n+\n+\n+/* Get basic block info.  */\n+\n+static inline struct df_scan_bb_info *\n+df_scan_get_bb_info (unsigned int index)\n+{\n+  if (index < df_scan->block_info_size)\n+    return (struct df_scan_bb_info *) df_scan->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n+static inline struct df_ru_bb_info *\n+df_ru_get_bb_info (unsigned int index)\n+{\n+  if (index < df_ru->block_info_size)\n+    return (struct df_ru_bb_info *) df_ru->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n+static inline struct df_rd_bb_info *\n+df_rd_get_bb_info (unsigned int index)\n+{\n+  if (index < df_rd->block_info_size)\n+    return (struct df_rd_bb_info *) df_rd->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n+static inline struct df_lr_bb_info *\n+df_lr_get_bb_info (unsigned int index)\n+{\n+  if (index < df_lr->block_info_size)\n+    return (struct df_lr_bb_info *) df_lr->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n+static inline struct df_live_bb_info *\n+df_live_get_bb_info (unsigned int index)\n+{\n+  if (index < df_live->block_info_size)\n+    return (struct df_live_bb_info *) df_live->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n+static inline struct df_urec_bb_info *\n+df_urec_get_bb_info (unsigned int index)\n+{\n+  if (index < df_urec->block_info_size)\n+    return (struct df_urec_bb_info *) df_urec->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n+\n+/* Get the artificial defs for a basic block.  */\n+\n+static inline struct df_ref **\n+df_get_artificial_defs (unsigned int bb_index)\n+{\n+  return df_scan_get_bb_info (bb_index)->artificial_defs;\n+}\n+\n+\n+/* Get the artificial uses for a basic block.  */\n+\n+static inline struct df_ref **\n+df_get_artificial_uses (unsigned int bb_index)\n+{\n+  return df_scan_get_bb_info (bb_index)->artificial_uses;\n+}\n \n \n /* web */\n@@ -672,9 +1018,8 @@ struct web_entry\n \n extern struct web_entry *unionfind_root (struct web_entry *);\n extern bool unionfind_union (struct web_entry *, struct web_entry *);\n-extern void union_defs (struct df *, struct df_ref *,\n+extern void union_defs (struct df_ref *,\n                         struct web_entry *, struct web_entry *,\n \t\t\tbool (*fun) (struct web_entry *, struct web_entry *));\n \n-\n #endif /* GCC_DF_H */"}, {"sha": "dca88479db4232bf61a6e7702f594a78a56e93db", "filename": "gcc/doc/cfg.texi", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdoc%2Fcfg.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdoc%2Fcfg.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcfg.texi?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n @c -*-texinfo-*-\n-@c Copyright (C) 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+@c Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -626,41 +626,34 @@ may be used at a later point in the program.  This information is\n used, for instance, during register allocation, as the pseudo\n registers only need to be assigned to a unique hard register or to a\n stack slot if they are live.  The hard registers and stack slots may\n-be freely reused for other values when a register is dead.\n+be freely reused for other values when a register is dead.  \n+\n+Liveness information is available in the back end starting with\n+@code{pass_df_initialize} and ending with @code{pass_df_finish}.  Three\n+flavors of live analysis are available: With @code{LR}, it is possible\n+to determine at any point @code{P} in the function if the register may be\n+used on some path from @code{P} to the end of the function.  With\n+@code{UR}, it is possible to determine if there is a path from the\n+beginning of the function to @code{P} that defines the variable.  \n+@code{LIVE} is the intersection of the @code{LR} and @code{UR} and a\n+variable is live at @code{P} if there is both an assignment that reaches\n+it from the beginning of the function and a uses that can be reached on\n+some path from @code{P} to the end of the function.\n+\n+In general @code{LIVE} is the most useful of the three.  The macros\n+@code{DF_[LR,UR,LIVE]_[IN,OUT]} can be used to access this information.\n+The macros take a basic block number and return a bitmap that is indexed\n+by the register number.  This information is only guaranteed to be up to\n+date after calls are made to @code{df_analyze}.  See the file\n+@code{df-core.c} for details on using the dataflow.  \n+\n \n @findex REG_DEAD, REG_UNUSED\n-The liveness information is stored partly in the RTL instruction\n-stream and partly in the flow graph.  Local information is stored in\n-the instruction stream:\n-Each instruction may contain @code{REG_DEAD} notes representing that\n-the value of a given register is no longer needed, or\n+The liveness information is stored partly in the RTL instruction stream\n+and partly in the flow graph.  Local information is stored in the\n+instruction stream: Each instruction may contain @code{REG_DEAD} notes\n+representing that the value of a given register is no longer needed, or\n @code{REG_UNUSED} notes representing that the value computed by the\n instruction is never used.  The second is useful for instructions\n computing multiple values at once.\n \n-@findex global_live_at_start, global_live_at_end\n-Global liveness information is stored in the control flow graph.\n-Each basic block contains two bitmaps, @code{global_live_at_start} and\n-@code{global_live_at_end} representing liveness of each register at\n-the entry and exit of the basic block.  The file @code{flow.c}\n-contains functions to compute liveness of each register at any given\n-place in the instruction stream using this information.\n-\n-@findex BB_DIRTY, clear_bb_flags, update_life_info_in_dirty_blocks\n-Liveness is expensive to compute and thus it is desirable to keep it\n-up to date during code modifying passes.  This can be easily\n-accomplished using the @code{flags} field of a basic block.  Functions\n-modifying the instruction stream automatically set the @code{BB_DIRTY}\n-flag of a modifies basic block, so the pass may simply\n-use@code{clear_bb_flags} before doing any modifications and then ask\n-the data flow module to have liveness updated via the\n-@code{update_life_info_in_dirty_blocks} function.\n-\n-This scheme works reliably as long as no control flow graph\n-transformations are done.  The task of updating liveness after control\n-flow graph changes is more difficult as normal iterative data flow\n-analysis may produce invalid results or get into an infinite cycle\n-when the initial solution is not below the desired one.  Only simple\n-transformations, like splitting basic blocks or inserting on edges,\n-are safe, as functions to implement them already know how to update\n-liveness information locally."}, {"sha": "09e73e1435d3f7499a710c9355e85d69d84595dc", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1994, 1997, 1998, 1999, 2000, 2001, 2002,\n-@c 2003, 2004, 2005\n+@c 2003, 2004, 2005, 2006, 2007\n @c Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -3250,7 +3250,9 @@ file as some small positive or negative offset from a named pattern.\n @item LOG_LINKS (@var{i})\n A list (chain of @code{insn_list} expressions) giving information about\n dependencies between instructions within a basic block.  Neither a jump\n-nor a label may come between the related insns.\n+nor a label may come between the related insns.  These are only used by\n+the schedulers and by combine.  This is a deprecated data structure.\n+Def-use and use-def chains are now prefered. \n \n @findex REG_NOTES\n @item REG_NOTES (@var{i})\n@@ -3531,6 +3533,12 @@ of the JUMP@.  The format is a bitmask of ATTR_FLAG_* values.\n This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression\n is used in place of the actual insn pattern.  This is done in cases where\n the pattern is either complex or misleading.\n+\n+@findex REG_LIBCALL_ID\n+@item REG_LIBCALL_ID\n+This is used to specify that an insn is part of a libcall.  Each libcall\n+in a function has a unique id, and all the insns that are part of that\n+libcall will have a REG_LIBCALL_ID note attached with the same ID.\n @end table\n \n For convenience, the machine mode in an @code{insn_list} or"}, {"sha": "6fa765ca3dc08a461dee78ab782b8a945211b769", "filename": "gcc/dominance.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb", "patch": "@@ -1,5 +1,5 @@\n /* Calculate (post)dominators in slightly super-linear time.\n-   Copyright (C) 2000, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Michael Matz (matz@ifh.de).\n \n    This file is part of GCC.\n@@ -152,6 +152,7 @@ static unsigned n_bbs_in_dom_tree[2];\n static void\n init_dom_info (struct dom_info *di, enum cdi_direction dir)\n {\n+  /* We need memory for n_basic_blocks nodes.  */\n   unsigned int num = n_basic_blocks;\n   init_ar (di->dfs_parent, TBB, num, 0);\n   init_ar (di->path_min, TBB, num, i);"}, {"sha": "e846f3f1459a3532a3c49de6c3d85fc09d82ae2b", "filename": "gcc/dse.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "1a845e372c0a11af14bbc11b1a23dc8495a30c8b", "filename": "gcc/dse.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fdse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "2f9ddbf758124d57f750960c934de5555804d324", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 120, "deletions": 77, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "ad00973a06d6956ebf601ab0e7b5ccc51dd47b4c", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "19b404f00f98a45d19ba03e843817e60786e6e5a", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "3dc4981fb7b16cc9f9bb27dd3e8a4c88e126cd3c", "filename": "gcc/final.c", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "5b0249bec979520008cd882afe94313d5c6f7681", "filename": "gcc/flow.c", "status": "removed", "additions": 0, "deletions": 4786, "changes": 4786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91d32a4a65d54cccf639a1541417e39cb7b7deb/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91d32a4a65d54cccf639a1541417e39cb7b7deb/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a91d32a4a65d54cccf639a1541417e39cb7b7deb"}, {"sha": "10fe7febe6cf5e1b745fb65eb11cbcac3b38e0ef", "filename": "gcc/function.c", "status": "modified", "additions": 111, "deletions": 17, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "bc3378b951dd9dcd837bc6f19d951d2b8d5dece7", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "a3c8bc1eddec0b367996f13323e52ca38033f3f5", "filename": "gcc/fwprop.c", "status": "modified", "additions": 85, "deletions": 56, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "9d800b2aad6775f9f6da99ce3e0ea1ff8ba017d3", "filename": "gcc/gcse.c", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "d9d942f70a3c7f9c28e50599eaa5117a0f8a1901", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "c60c57df64e3816195f2c5be8b22148748cdc95c", "filename": "gcc/global.c", "status": "modified", "additions": 160, "deletions": 579, "changes": 739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "92ed9bb492bb03bc7764af7f56d6894c83dea89d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 24, "deletions": 182, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "e5d88970be03fd91ecf100948ff469c00ce51dcc", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 83, "deletions": 82, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "adde3fa2cd746c5f4c670a27872b135186c05136", "filename": "gcc/init-regs.c", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "827afb7fe51546f9e288409a169cad0a787836a5", "filename": "gcc/integrate.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "93bdbfac1c3fb89657c82bfe73a061b13eb15836", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "303c2da1b72fdb2fb9c1831b779dba7c15a1d19a", "filename": "gcc/loop-init.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "3d4ce61dd84ee165873decd79dde7fec0db81790", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 130, "deletions": 73, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "5016aaf46ef9e8a7bb16112c41768b96990b9d5d", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 72, "deletions": 43, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "ea141401cf2c593a1bf0a514a2c355598f853b1b", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "0e4f58caef00ba2f5ee4638a2d2f750d3a37304d", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "25cd53a7975ffd528d30b4f4d216ebb9dbc7046e", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "e86ed62545b5ee6404d44f597152092326759761", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "c1d57f67469bf07ee9fb8a3031ed9f4694b4536b", "filename": "gcc/optabs.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "aac35583fcec9285ca5dc1cba9a16b4ba343af28", "filename": "gcc/opts.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "d542c660d678fcfdd1959ae10b1d78e8a2575d57", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "7c2754dee04412ea2e9ceb4f1728b4b94e8cc8f8", "filename": "gcc/passes.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "fdf5b04fc7864878efff2c62411ee2f31f34db2b", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "3182ac0b8e98830c3b2da9ae41ed245a6aa1294d", "filename": "gcc/postreload.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "b12541edb996a4981d7367f4cf4365ee444d4e61", "filename": "gcc/recog.c", "status": "modified", "additions": 122, "deletions": 295, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "cf52cd3f0f098a4ffeda58d8f84b563639d26f46", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "36891b1a770abbfbf19a22efc57441526e17a435", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "851a440a207aeab254648c3e73f3262343bed5f0", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "0c86dbfc8c20584cf3cee6a00727a944d0b3746b", "filename": "gcc/regclass.c", "status": "modified", "additions": 202, "deletions": 288, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "c54879bc3a7f32cbbf2b1219f5621c743c6652e3", "filename": "gcc/regmove.c", "status": "modified", "additions": 92, "deletions": 24, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "7026ef3b47defc54f38f1b8ee1b2922ff192b308", "filename": "gcc/regrename.c", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "320fd2e794523221ec5ac72e2f4bd36d9614d85d", "filename": "gcc/regs.h", "status": "modified", "additions": 90, "deletions": 70, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "cfd904f83040bbb34dabd1cdecc8d676c46f7a5f", "filename": "gcc/regstat.c", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "7df7f22123ac78cd4294bdcebeaada923a9ccaf0", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "b19be93073a1862a3094a0cf207c04075b553ec5", "filename": "gcc/reload1.c", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "dcdcfd74e9d8629000a0b344544dcd1b711479df", "filename": "gcc/reorg.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "c2b08495d0ace51dcd653fe3c39986821217b923", "filename": "gcc/resource.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "3024567d7a2d71f98a0f94baf583b8e9a830f34d", "filename": "gcc/resource.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "8ab5e8bd3ddfc401854e8b6f5e35dd6a885bed9c", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "7d3dac7d56705f40950421c9fd0d085837a5267c", "filename": "gcc/rtl.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "5acf4750b9fdbdba3fb049c5fef2eaf7c8e0a339", "filename": "gcc/rtl.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "b9399f87c58a2f45bce2ed6722abff1788831392", "filename": "gcc/rtl.h", "status": "modified", "additions": 52, "deletions": 68, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "3a26d8f490ed1f7d75630778cf3ffd2005e39618", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "65a4686eff9eb37362af0edbdb0c6e68a07d2d9a", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "86febb4609b7aa59bd4592dff9314ecf98b39a2e", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "cf63a91cfd3aa180fa61d5a41d8e96d756789e9b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "dbece7d80e323d20668f10ffb41e007447962c5e", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 15, "deletions": 98, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "c8652c3607d9172f88ec1f870ba88247156ebe1c", "filename": "gcc/sched-int.h", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "aafb8121ea0031b09cfd08542de20dbb79eb0f81", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 60, "deletions": 230, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "7fa0038503516ed2f9ea190c6019a2cf9e052d31", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "f5cacdee93f904a60e345d99afe100447c4a6872", "filename": "gcc/see.c", "status": "modified", "additions": 351, "deletions": 290, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "d3f282cd196a486e0ce820dcec3cafac5eb5aba5", "filename": "gcc/stack-ptr-mod.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "11cae96088a634276cbd7cf8b93f8e59cfcdd6f9", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "3658e87b748fe5b872bbcc3989f3e1f1db2a0198", "filename": "gcc/struct-equiv.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "4b014c8db13abe0ad201863346fe286ca39929a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "53fecf864abeba01b1189d20f2f3f2b5c11b5d74", "filename": "gcc/testsuite/gfortran.dg/pr31025.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr31025.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr31025.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr31025.f90?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "f89a9dfb891971ac88191c397604ac73eda81cd4", "filename": "gcc/timevar.def", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "8afce8bc876869607b70be5eea073304ce0d1177", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "d938a0f140547f6858a52e2ebecd5c7e464f0727", "filename": "gcc/tracer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "1f00e856a2b87d551df4d93feb09cc1012b2eba0", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "6dfc166b3d9d456da64ecc5d1a85c87d0ffb05a5", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "c2e7d332cee56f102ebcc7d73f2a5dbc0b6b4f75", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "572a1e7c6f9a6cd772ad1bf820847ce1350fe482", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}, {"sha": "09d045ee82e572927908be9fdf408258e3dd8758", "filename": "gcc/web.c", "status": "modified", "additions": 144, "deletions": 76, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=6fb5fa3cbc0d78cf9f4ff7cac5e1d8af1e65c5bb"}]}