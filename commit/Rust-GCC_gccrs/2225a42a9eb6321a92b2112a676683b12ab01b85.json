{"sha": "2225a42a9eb6321a92b2112a676683b12ab01b85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIyNWE0MmE5ZWI2MzIxYTkyYjIxMTJhNjc2NjgzYjEyYWIwMWI4NQ==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-05-04T22:14:12Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-05-04T22:14:12Z"}, "message": "2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/SimpleDateFormat.java:\n\t(formatWithAttribute): New method. It implements\n\tthe formatting process with attributes.\n\t(format): Use formatWithAttribute.\n\t(formatToCharacterIterator): New method. Use\n\tformatWithAttribute.\n\nFrom-SVN: r81493", "tree": {"sha": "efea129faee80759862121f5d53765bc4a0d27bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efea129faee80759862121f5d53765bc4a0d27bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2225a42a9eb6321a92b2112a676683b12ab01b85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2225a42a9eb6321a92b2112a676683b12ab01b85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2225a42a9eb6321a92b2112a676683b12ab01b85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2225a42a9eb6321a92b2112a676683b12ab01b85/comments", "author": null, "committer": null, "parents": [{"sha": "1f6461426733ebf74be8e451c0b4d5b72710e800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6461426733ebf74be8e451c0b4d5b72710e800", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6461426733ebf74be8e451c0b4d5b72710e800"}], "stats": {"total": 267, "additions": 168, "deletions": 99}, "files": [{"sha": "3e419de7c668b962f30e649942251b9a451562b8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225a42a9eb6321a92b2112a676683b12ab01b85/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225a42a9eb6321a92b2112a676683b12ab01b85/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2225a42a9eb6321a92b2112a676683b12ab01b85", "patch": "@@ -1,3 +1,12 @@\n+2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/SimpleDateFormat.java:\n+\t(formatWithAttribute): New method. It implements\n+\tthe formatting process with attributes.\n+\t(format): Use formatWithAttribute.\n+\t(formatToCharacterIterator): New method. Use\n+\tformatWithAttribute.\n+\n 2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n \n \t* java/text/MessageFormat.java:"}, {"sha": "5f3614eefcf287a51d287c32e9466b9a081d90c7", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 159, "deletions": 99, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2225a42a9eb6321a92b2112a676683b12ab01b85/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2225a42a9eb6321a92b2112a676683b12ab01b85/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=2225a42a9eb6321a92b2112a676683b12ab01b85", "patch": "@@ -39,16 +39,21 @@\n \n package java.text;\n \n+import gnu.java.text.AttributedFormatBuffer;\n+import gnu.java.text.FormatBuffer;\n+import gnu.java.text.FormatCharacterIterator;\n+import gnu.java.text.StringFormatBuffer;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.Iterator;\n import java.util.Locale;\n-import java.util.TimeZone;\n import java.util.SimpleTimeZone;\n-import java.io.ObjectInputStream;\n-import java.io.IOException;\n+import java.util.TimeZone;\n \n /**\n  * SimpleDateFormat provides convenient methods for parsing and formatting\n@@ -82,7 +87,7 @@ public FieldSizePair(int f, int s) {\n   // This string is specified in the JCL.  We set it here rather than\n   // do a DateFormatSymbols(Locale.US).getLocalPatternChars() since\n   // someone could theoretically change those values (though unlikely).\n-  private static final String standardChars = \"GyMdkHmsSEDFwWahKz\";\n+  private static final String standardChars = \"GyMdkHmsSEDFwWahKzZ\";\n \n   private void readObject(ObjectInputStream stream)\n     throws IOException, ClassNotFoundException\n@@ -411,109 +416,164 @@ public int hashCode()\n    * appending to the specified StringBuffer.  The input StringBuffer\n    * is returned as output for convenience.\n    */\n-  public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos)\n+  final private void formatWithAttribute(Date date, FormatBuffer buffer, FieldPosition pos)\n   {\n     String temp;\n+    AttributedCharacterIterator.Attribute attribute;\n     calendar.setTime(date);\n-    \n-    // go through ArrayList, filling in fields where applicable, else toString\n-    Iterator i = tokens.iterator();\n-    while (i.hasNext()) {\n-      Object o = i.next();\n-      if (o instanceof FieldSizePair) {\n-\tFieldSizePair p = (FieldSizePair) o;\n-\tint beginIndex = buffer.length();\n-\tswitch (p.field) {\n-\tcase ERA_FIELD:\n-\t  buffer.append(formatData.eras[calendar.get(Calendar.ERA)]);\n-\t  break;\n-\tcase YEAR_FIELD:\n-\t  // If we have two digits, then we truncate.  Otherwise, we\n-\t  // use the size of the pattern, and zero pad.\n-\t  if (p.size == 2)\n-\t    {\n-\t      temp = String.valueOf(calendar.get(Calendar.YEAR));\n-\t      buffer.append(temp.substring(temp.length() - 2));\n-\t    }\n-\t  else\n-\t    withLeadingZeros(calendar.get(Calendar.YEAR), p.size, buffer);\n-\t  break;\n-\tcase MONTH_FIELD:\n-\t  if (p.size < 3)\n-\t    withLeadingZeros(calendar.get(Calendar.MONTH)+1,p.size,buffer);\n-\t  else if (p.size < 4)\n-\t    buffer.append(formatData.shortMonths[calendar.get(Calendar.MONTH)]);\n-\t  else\n-\t    buffer.append(formatData.months[calendar.get(Calendar.MONTH)]);\n-\t  break;\n-\tcase DATE_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.DATE),p.size,buffer);\n-\t  break;\n-\tcase HOUR_OF_DAY1_FIELD: // 1-24\n-\t  withLeadingZeros(((calendar.get(Calendar.HOUR_OF_DAY)+23)%24)+1,p.size,buffer);\n-\t  break;\n-\tcase HOUR_OF_DAY0_FIELD: // 0-23\n-\t  withLeadingZeros(calendar.get(Calendar.HOUR_OF_DAY),p.size,buffer);\n-\t  break;\n-\tcase MINUTE_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.MINUTE),p.size,buffer);\n-\t  break;\n-\tcase SECOND_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.SECOND),p.size,buffer);\n-\t  break;\n-\tcase MILLISECOND_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.MILLISECOND),p.size,buffer);\n-\t  break;\n-\tcase DAY_OF_WEEK_FIELD:\n-\t  if (p.size < 4)\n-\t    buffer.append(formatData.shortWeekdays[calendar.get(Calendar.DAY_OF_WEEK)]);\n-\t  else\n-\t    buffer.append(formatData.weekdays[calendar.get(Calendar.DAY_OF_WEEK)]);\n-\t  break;\n-\tcase DAY_OF_YEAR_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.DAY_OF_YEAR),p.size,buffer);\n-\t  break;\n-\tcase DAY_OF_WEEK_IN_MONTH_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH),p.size,buffer);\n-\t  break;\n-\tcase WEEK_OF_YEAR_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.WEEK_OF_YEAR),p.size,buffer);\n-\t  break;\n-\tcase WEEK_OF_MONTH_FIELD:\n-\t  withLeadingZeros(calendar.get(Calendar.WEEK_OF_MONTH),p.size,buffer);\n-\t  break;\n-\tcase AM_PM_FIELD:\n-\t  buffer.append(formatData.ampms[calendar.get(Calendar.AM_PM)]);\n-\t  break;\n-\tcase HOUR1_FIELD: // 1-12\n-\t  withLeadingZeros(((calendar.get(Calendar.HOUR)+11)%12)+1,p.size,buffer);\n-\t  break;\n-\tcase HOUR0_FIELD: // 0-11\n-\t  withLeadingZeros(calendar.get(Calendar.HOUR),p.size,buffer);\n-\t  break;\n-\tcase TIMEZONE_FIELD:\n-\t  TimeZone zone = calendar.getTimeZone();\n-\t  boolean isDST = calendar.get(Calendar.DST_OFFSET) != 0;\n-\t  // FIXME: XXX: This should be a localized time zone.\n-\t  String zoneID = zone.getDisplayName(isDST, p.size > 3 ? TimeZone.LONG : TimeZone.SHORT);\n-\t  buffer.append(zoneID);\n-\t  break;\n-\tdefault:\n-\t  throw new IllegalArgumentException(\"Illegal pattern character\");\n-\t}\n-\tif (pos != null && p.field == pos.getField())\n+\n+    // go through vector, filling in fields where applicable, else toString\n+    Iterator iter = tokens.iterator();\n+    while (iter.hasNext())\n+      {\n+\tObject o = iter.next();\n+\tif (o instanceof FieldSizePair)\n \t  {\n-\t    pos.setBeginIndex(beginIndex);\n-\t    pos.setEndIndex(buffer.length());\n-\t  }\n-      } else {\n-\tbuffer.append(o.toString());\n+\t    FieldSizePair p = (FieldSizePair) o;\n+\t    int beginIndex = buffer.length();\n+\t    \n+\t    switch (p.field)\n+\t      {\n+\t      case ERA_FIELD:\n+\t\tbuffer.append (formatData.eras[calendar.get (Calendar.ERA)], DateFormat.Field.ERA);\n+\t\tbreak;\n+\t      case YEAR_FIELD:\n+\t\t// If we have two digits, then we truncate.  Otherwise, we\n+\t\t// use the size of the pattern, and zero pad.\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.YEAR);\n+\t\tif (p.size == 2)\n+\t\t  {\n+\t\t    temp = String.valueOf (calendar.get (Calendar.YEAR));\n+\t\t    buffer.append (temp.substring (temp.length() - 2));\n+\t\t  }\n+\t\telse\n+\t\t  withLeadingZeros (calendar.get (Calendar.YEAR), p.size, buffer);\n+\t\tbreak;\n+\t      case MONTH_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.MONTH);\n+\t\tif (p.size < 3)\n+\t\t  withLeadingZeros (calendar.get (Calendar.MONTH) + 1, p.size, buffer);\n+\t\telse if (p.size < 4)\n+\t\t  buffer.append (formatData.shortMonths[calendar.get (Calendar.MONTH)]);\n+\t\telse\n+\t\t  buffer.append (formatData.months[calendar.get (Calendar.MONTH)]);\n+\t\tbreak;\n+\t      case DATE_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_MONTH);\n+\t\twithLeadingZeros (calendar.get (Calendar.DATE), p.size, buffer);\n+\t\tbreak;\n+\t      case HOUR_OF_DAY1_FIELD: // 1-24\n+\t\tbuffer.setDefaultAttribute(DateFormat.Field.HOUR_OF_DAY1);\n+\t\twithLeadingZeros ( ((calendar.get (Calendar.HOUR_OF_DAY) + 23) % 24) + 1, \n+\t\t\t\t   p.size, buffer);\n+\t\tbreak;\n+\t      case HOUR_OF_DAY0_FIELD: // 0-23\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR_OF_DAY0);\n+\t\twithLeadingZeros (calendar.get (Calendar.HOUR_OF_DAY), p.size, buffer);\n+\t\tbreak;\n+\t      case MINUTE_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.MINUTE);\n+\t\twithLeadingZeros (calendar.get (Calendar.MINUTE),\n+\t\t\t\t  p.size, buffer);\n+\t\tbreak;\n+\t      case SECOND_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.SECOND);\n+\t\twithLeadingZeros(calendar.get (Calendar.SECOND), \n+\t\t\t\t p.size, buffer);\n+\t\tbreak;\n+\t      case MILLISECOND_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.MILLISECOND);\n+\t\twithLeadingZeros (calendar.get (Calendar.MILLISECOND), p.size, buffer);\n+\t\tbreak;\n+\t      case DAY_OF_WEEK_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_WEEK);\n+\t\tif (p.size < 4)\n+\t\t  buffer.append (formatData.shortWeekdays[calendar.get (Calendar.DAY_OF_WEEK)]);\n+\t\telse\n+\t\t  buffer.append (formatData.weekdays[calendar.get (Calendar.DAY_OF_WEEK)]);\n+\t\tbreak;\n+\t      case DAY_OF_YEAR_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_YEAR);\n+\t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_YEAR), p.size, buffer);\n+\t\tbreak;\n+\t      case DAY_OF_WEEK_IN_MONTH_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_WEEK_IN_MONTH);\n+\t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_WEEK_IN_MONTH), \n+\t\t\t\t p.size, buffer);\n+\t\tbreak;\n+\t      case WEEK_OF_YEAR_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.WEEK_OF_YEAR);\n+\t\twithLeadingZeros (calendar.get (Calendar.WEEK_OF_YEAR),\n+\t\t\t\t  p.size, buffer);\n+\t\tbreak;\n+\t      case WEEK_OF_MONTH_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.WEEK_OF_MONTH);\n+\t\twithLeadingZeros (calendar.get (Calendar.WEEK_OF_MONTH),\n+\t\t\t\t  p.size, buffer);\n+\t\tbreak;\n+\t      case AM_PM_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.AM_PM);\n+\t\tbuffer.append (formatData.ampms[calendar.get (Calendar.AM_PM)]);\n+\t\tbreak;\n+\t      case HOUR1_FIELD: // 1-12\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR1);\n+\t\twithLeadingZeros (((calendar.get (Calendar.HOUR) + 11) % 12) + 1, p.size, buffer);\n+\t\tbreak;\n+\t      case HOUR0_FIELD: // 0-11\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR0);\n+\t\twithLeadingZeros (calendar.get (Calendar.HOUR), p.size, buffer);\n+\t\tbreak;\n+\t      case TIMEZONE_FIELD:\n+\t\tbuffer.setDefaultAttribute (DateFormat.Field.TIME_ZONE);\n+\t\tTimeZone zone = calendar.getTimeZone();\n+\t\tboolean isDST = calendar.get (Calendar.DST_OFFSET) != 0;\n+\t\t// FIXME: XXX: This should be a localized time zone.\n+\t\tString zoneID = zone.getDisplayName (isDST, p.size > 3 ? TimeZone.LONG : TimeZone.SHORT);\n+\t\tbuffer.append (zoneID);\n+\t\tbreak;\n+\t      default:\n+\t\tthrow new IllegalArgumentException (\"Illegal pattern character \" + p.field);\n+\t      }\n+\t    if (pos != null && (buffer.getDefaultAttribute() == pos.getFieldAttribute()\n+\t\t\t\t|| p.field == pos.getField()))\n+\t      {\n+\t\tpos.setBeginIndex(beginIndex);\n+\t\tpos.setEndIndex(buffer.length());\n+\t      }\n+\t  } \n+      else\n+\t{  \n+\t  buffer.append(o.toString(), null);\n+\t}\n       }\n-    }\n+  }\n+  \n+  public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos)\n+  {\n+    formatWithAttribute(date, new StringFormatBuffer (buffer), pos);\n+\n     return buffer;\n   }\n \n-  private void withLeadingZeros(int value, int length, StringBuffer buffer) \n+  public AttributedCharacterIterator formatToCharacterIterator(Object date)\n+    throws IllegalArgumentException\n+  {\n+    if (date == null)\n+      throw new NullPointerException(\"null argument\");\n+    if (!(date instanceof Date))\n+      throw new IllegalArgumentException(\"argument should be an instance of java.util.Date\");\n+\n+    AttributedFormatBuffer buf = new AttributedFormatBuffer();\n+    formatWithAttribute((Date)date, buf,\n+\t\t\tnull);\n+    buf.sync();\n+        \n+    return new FormatCharacterIterator(buf.getBuffer().toString(),\n+\t\t\t\t       buf.getRanges(),\n+\t\t\t\t       buf.getAttributes());\n+  }\n+\n+  private void withLeadingZeros(int value, int length, FormatBuffer buffer) \n   {\n     String valStr = String.valueOf(value);\n     for (length -= valStr.length(); length > 0; length--)"}]}