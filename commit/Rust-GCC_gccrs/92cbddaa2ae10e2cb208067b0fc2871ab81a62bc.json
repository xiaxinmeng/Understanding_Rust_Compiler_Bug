{"sha": "92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJjYmRkYWEyYWUxMGUyY2IyMDgwNjdiMGZjMjg3MWFiODFhNjJiYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T09:42:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T09:42:31Z"}, "message": "[multiple changes]\n\n2010-10-12  Robert Dewar  <dewar@adacore.com>\n\n\t* par-endh.adb (Check_End): Don't swallow semicolon or aspects after\n\tEND RECORD.\n\t* sem_attr.adb (Eval_Attribute): Code clean up.\n\n2010-10-12  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch12.adb (P_Formal_Private_Type_Definition): Improve error\n\tmessages and recovery for case of out of order Abstract/Tagged/Private\n\tkeywords.\n\t* par-ch3.adb (P_Type_Declaration): Improve error messages and recovery\n\tfor case of out of order Abstract/Tagged/Private keywords.\n\n2010-10-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.adb (Analyze_Inlined_Bodies): Restrict previous change to case\n\twhere child unit is main unit of compilation.\n\nFrom-SVN: r165354", "tree": {"sha": "99e4763094e799e398df88b7a5f9765b442ca1c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99e4763094e799e398df88b7a5f9765b442ca1c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/comments", "author": null, "committer": null, "parents": [{"sha": "718deaf1af8c923d15f417fd3b49ba909c5f26eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/718deaf1af8c923d15f417fd3b49ba909c5f26eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/718deaf1af8c923d15f417fd3b49ba909c5f26eb"}], "stats": {"total": 204, "additions": 125, "deletions": 79}, "files": [{"sha": "02f1e543cd729c24c2577d3543677eb0c00958c8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "patch": "@@ -1,3 +1,22 @@\n+2010-10-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-endh.adb (Check_End): Don't swallow semicolon or aspects after\n+\tEND RECORD.\n+\t* sem_attr.adb (Eval_Attribute): Code clean up.\n+\n+2010-10-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch12.adb (P_Formal_Private_Type_Definition): Improve error\n+\tmessages and recovery for case of out of order Abstract/Tagged/Private\n+\tkeywords.\n+\t* par-ch3.adb (P_Type_Declaration): Improve error messages and recovery\n+\tfor case of out of order Abstract/Tagged/Private keywords.\n+\n+2010-10-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* inline.adb (Analyze_Inlined_Bodies): Restrict previous change to case\n+\twhere child unit is main unit of compilation.\n+\n 2010-10-12  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads, aspects.adb (Move_Aspects): New procedure."}, {"sha": "e5371445ea3868bb835b01f3679c21bcf9791cbe", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "patch": "@@ -626,19 +626,19 @@ package body Inline is\n       Pack      : Entity_Id;\n       S         : Succ_Index;\n \n-      function Is_Ancestor\n+      function Is_Ancestor_Of_Main\n         (U_Name : Entity_Id;\n          Nam    : Node_Id) return Boolean;\n       --  Determine whether the unit whose body is loaded is an ancestor of\n-      --  a unit mentioned in a with_clause of that body. The body is not\n+      --  the main unit, and has a with_clause on it. The body is not\n       --  analyzed yet, so the check is purely lexical: the name of the with\n       --  clause is a selected component, and names of ancestors must match.\n \n-      -----------------\n-      -- Is_Ancestor --\n-      -----------------\n+      -------------------------\n+      -- Is_Ancestor_Of_Main --\n+      -------------------------\n \n-      function Is_Ancestor\n+      function Is_Ancestor_Of_Main\n         (U_Name : Entity_Id;\n          Nam    : Node_Id) return Boolean\n       is\n@@ -649,6 +649,12 @@ package body Inline is\n             return False;\n \n          else\n+            if Chars (Selector_Name (Nam)) /=\n+               Chars (Cunit_Entity (Main_Unit))\n+            then\n+               return False;\n+            end if;\n+\n             Pref := Prefix (Nam);\n             if Nkind (Pref) = N_Identifier then\n \n@@ -666,10 +672,10 @@ package body Inline is\n             else\n                --  A is an ancestor of A.B.C if it is an ancestor of A.B\n \n-               return Is_Ancestor (U_Name, Pref);\n+               return Is_Ancestor_Of_Main (U_Name, Pref);\n             end if;\n          end if;\n-      end Is_Ancestor;\n+      end Is_Ancestor_Of_Main;\n \n    --  Start of processing for  Analyze_Inlined_Bodies\n \n@@ -751,7 +757,8 @@ package body Inline is\n                            Item := First (Context_Items (Body_Unit));\n                            while Present (Item) loop\n                               if Nkind (Item) = N_With_Clause\n-                                and then Is_Ancestor (U_Id, Name (Item))\n+                                and then\n+                                  Is_Ancestor_Of_Main (U_Id, Name (Item))\n                               then\n                                  Set_Is_Inlined (U_Id, False);\n                                  exit;"}, {"sha": "20dfde989dc3e369423cede62a203e46d692f132", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "patch": "@@ -834,6 +834,20 @@ package body Ch12 is\n \n       Set_Sloc (Def_Node, Token_Ptr);\n       T_Private;\n+\n+      if Token = Tok_Tagged then -- CODEFIX\n+         Error_Msg_SC (\"TAGGED must come before PRIVATE\");\n+         Scan; -- past TAGGED\n+\n+      elsif Token = Tok_Abstract then -- CODEFIX\n+         Error_Msg_SC (\"`ABSTRACT TAGGED` must come before PRIVATE\");\n+         Scan; -- past ABSTRACT\n+\n+         if Token = Tok_Tagged then\n+            Scan; -- past TAGGED\n+         end if;\n+      end if;\n+\n       return Def_Node;\n    end P_Formal_Private_Type_Definition;\n "}, {"sha": "27a9cfc8cf182c4db9733d1322283b4bd567cc0c", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "patch": "@@ -309,11 +309,11 @@ package body Ch3 is\n \n    --  Error recovery: can raise Error_Resync\n \n-   --  Note: The processing for full type declaration, incomplete type\n-   --  declaration, private type declaration and type definition is\n-   --  included in this function. The processing for concurrent type\n-   --  declarations is NOT here, but rather in chapter 9 (i.e. this\n-   --  function handles only declarations starting with TYPE).\n+   --  The processing for full type declarations, incomplete type declarations,\n+   --  private type declarations and type definitions is included in this\n+   --  function. The processing for concurrent type declarations is NOT here,\n+   --  but rather in chapter 9 (this function handles only declarations\n+   --  starting with TYPE).\n \n    function P_Type_Declaration return Node_Id is\n       Abstract_Present : Boolean := False;\n@@ -770,6 +770,22 @@ package body Ch3 is\n             when Tok_Private =>\n                Decl_Node := New_Node (N_Private_Type_Declaration, Type_Loc);\n                Scan; -- past PRIVATE\n+\n+               --  Check error cases of private [abstract] tagged\n+\n+               if Token = Tok_Abstract then\n+                  Error_Msg_SC (\"`ABSTRACT TAGGED` must come before PRIVATE\");\n+                  Scan; -- past ABSTRACT\n+\n+                  if Token = Tok_Tagged then\n+                     Scan; -- past TAGGED\n+                  end if;\n+\n+               elsif Token = Tok_Tagged then\n+                  Error_Msg_SC (\"TAGGED must come before PRIVATE\");\n+                  Scan; -- past TAGGED\n+               end if;\n+\n                exit;\n \n             --  Ada 2005 (AI-345): Protected, synchronized or task interface"}, {"sha": "8bb75f831e310c3a7a895e1d5978aac5cc5692b7", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "patch": "@@ -387,48 +387,51 @@ package body Endh is\n             end if;\n          end if;\n \n-         --  Scan aspect specifications if permitted here\n+         --  Deal with terminating aspect specifications and following semi-\n+         --  colon. We skip this in the case of END RECORD, since in this\n+         --  case the aspect specifications and semicolon are handled at\n+         --  a higher level.\n \n-         if Aspect_Specifications_Present then\n-            if No (Decl) then\n-               P_Aspect_Specifications (Error);\n-            else\n-               P_Aspect_Specifications (Decl);\n-            end if;\n+         if End_Type /= E_Record then\n \n-         --  Except in case of END RECORD, semicolon must follow. For END\n-         --  RECORD, a semicolon does follow, but it is part of a higher level\n-         --  construct. In any case, a missing semicolon is not serious enough\n-         --  to consider the END statement to be bad in the sense that we\n-         --  are dealing with (i.e. to be suspicious that it is not in fact\n-         --  the END statement we are looking for!)\n-\n-         elsif End_Type /= E_Record then\n-            if Token = Tok_Semicolon then\n-               T_Semicolon;\n-\n-            --  Semicolon is missing. If the missing semicolon is at the end\n-            --  of the line, i.e. we are at the start of the line now, then\n-            --  a missing semicolon gets flagged, but is not serious enough\n-            --  to consider the END statement to be bad in the sense that we\n-            --  are dealing with (i.e. to be suspicious that this END is not\n-            --  the END statement we are looking for).\n-\n-            --  Similarly, if we are at a colon, we flag it but a colon for\n-            --  a semicolon is not serious enough to consider the END to be\n-            --  incorrect. Same thing for a period in place of a semicolon.\n-\n-            elsif Token_Is_At_Start_Of_Line\n-              or else Token = Tok_Colon\n-              or else Token = Tok_Dot\n-            then\n-               T_Semicolon;\n+            --  Scan aspect specifications if permitted here\n+\n+            if Aspect_Specifications_Present then\n+               if No (Decl) then\n+                  P_Aspect_Specifications (Error);\n+               else\n+                  P_Aspect_Specifications (Decl);\n+               end if;\n \n-            --  If the missing semicolon is not at the start of the line,\n-            --  then we do consider the END line to be dubious in this sense.\n+            --  If no aspect specifications, must have a semicolon\n \n-            else\n-               End_OK := False;\n+            elsif End_Type /= E_Record then\n+               if Token = Tok_Semicolon then\n+                  T_Semicolon;\n+\n+               --  Semicolon is missing. If the missing semicolon is at the end\n+               --  of the line, i.e. we are at the start of the line now, then\n+               --  a missing semicolon gets flagged, but is not serious enough\n+               --  to consider the END statement to be bad in the sense that we\n+               --  are dealing with (i.e. to be suspicious that this END is not\n+               --  the END statement we are looking for).\n+\n+               --  Similarly, if we are at a colon, we flag it but a colon for\n+               --  a semicolon is not serious enough to consider the END to be\n+               --  incorrect. Same thing for a period in place of a semicolon.\n+\n+               elsif Token_Is_At_Start_Of_Line\n+                 or else Token = Tok_Colon\n+                 or else Token = Tok_Dot\n+               then\n+                  T_Semicolon;\n+\n+               --  If the missing semicolon is not at the start of the line,\n+               --  then we consider the END line to be dubious in this sense.\n+\n+               else\n+                  End_OK := False;\n+               end if;\n             end if;\n          end if;\n       end if;"}, {"sha": "3c8a03d723d73ff3aae11d5e39d1300383288214", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "patch": "@@ -5375,33 +5375,20 @@ package body Sem_Attr is\n       --  constructs from this test comes from some internal usage in packed\n       --  arrays, which otherwise fails, could use more analysis perhaps???\n \n-      declare\n-         function Within_Aspect (N : Node_Id) return Boolean;\n-         --  True if within aspect expression. Giant kludge, do this test only\n-         --  within an aspect, since doing it more widely, even though clearly\n-         --  correct, causes regressions notably in GA19-001 ???\n-\n-         function Within_Aspect (N : Node_Id) return Boolean\n-         is\n-         begin\n-            if No (Parent (N)) then\n-               return False;\n-            elsif Nkind (N) = N_Aspect_Specification then\n-               return True;\n-            else\n-               return Within_Aspect (Parent (N));\n-            end if;\n-         end Within_Aspect;\n-\n-      begin\n-         if In_Spec_Expression\n-           and then Comes_From_Source (N)\n-           and then not (Is_Entity_Name (P) and then Is_Frozen (Entity (P)))\n-           and then Within_Aspect (N)\n-         then\n-            return;\n-         end if;\n-      end;\n+      --  We do however go ahead with generic actual types, otherwise we get\n+      --  some regressions, probably these types should be frozen anyway???\n+\n+      if In_Spec_Expression\n+        and then Comes_From_Source (N)\n+        and then not (Is_Entity_Name (P)\n+                       and then\n+                        (Is_Frozen (Entity (P))\n+                          or else (Is_Type (Entity (P))\n+                                    and then\n+                                      Is_Generic_Actual_Type (Entity (P)))))\n+      then\n+         return;\n+      end if;\n \n       --  Acquire first two expressions (at the moment, no attributes take more\n       --  than two expressions in any case)."}]}