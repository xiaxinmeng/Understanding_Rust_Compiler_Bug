{"sha": "3aa775d63150d286c3637033ab5751fb15bb9a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhNzc1ZDYzMTUwZDI4NmMzNjM3MDMzYWI1NzUxZmIxNWJiOWE0Mg==", "commit": {"author": {"name": "Walter Lee", "email": "walt@tilera.com", "date": "2012-08-28T06:09:45Z"}, "committer": {"name": "Walter Lee", "email": "walt@gcc.gnu.org", "date": "2012-08-28T06:09:45Z"}, "message": "Fix some typos and coding style violations.\n\n\t* confg/tilegx/tilegx.md: Fix code style.\n\t(*zero_extendsidi_truncdisi): Fix typo.\n\t* config/tilegx/tilegx.c: Fix code style.\n\t(tilegx_function_profiler): Fix typo.\n\nFrom-SVN: r190739", "tree": {"sha": "a5e8e32b0966500c87da1121b6549459c31357a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5e8e32b0966500c87da1121b6549459c31357a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aa775d63150d286c3637033ab5751fb15bb9a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa775d63150d286c3637033ab5751fb15bb9a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa775d63150d286c3637033ab5751fb15bb9a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa775d63150d286c3637033ab5751fb15bb9a42/comments", "author": {"login": "walt-tilera", "id": 6602917, "node_id": "MDQ6VXNlcjY2MDI5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/6602917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/walt-tilera", "html_url": "https://github.com/walt-tilera", "followers_url": "https://api.github.com/users/walt-tilera/followers", "following_url": "https://api.github.com/users/walt-tilera/following{/other_user}", "gists_url": "https://api.github.com/users/walt-tilera/gists{/gist_id}", "starred_url": "https://api.github.com/users/walt-tilera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/walt-tilera/subscriptions", "organizations_url": "https://api.github.com/users/walt-tilera/orgs", "repos_url": "https://api.github.com/users/walt-tilera/repos", "events_url": "https://api.github.com/users/walt-tilera/events{/privacy}", "received_events_url": "https://api.github.com/users/walt-tilera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a433d31f14ff338e05d189db67d60525c627a33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a433d31f14ff338e05d189db67d60525c627a33b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a433d31f14ff338e05d189db67d60525c627a33b"}], "stats": {"total": 254, "additions": 126, "deletions": 128}, "files": [{"sha": "03644e2ffe1d5f0b081206504469ba5cd3a05c33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa775d63150d286c3637033ab5751fb15bb9a42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa775d63150d286c3637033ab5751fb15bb9a42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aa775d63150d286c3637033ab5751fb15bb9a42", "patch": "@@ -1,3 +1,9 @@\n+2012-08-28  Walter Lee  <walt@tilera.com>\n+\t* confg/tilegx/tilegx.md: Fix code style.\n+\t(*zero_extendsidi_truncdisi): Fix typo.\n+\t* config/tilegx/tilegx.c: Fix code style.\n+\t(tilegx_function_profiler): Fix typo.\n+\n 2012-08-28  Walter Lee  <walt@tilera.com>\n \n \t* doc/invoke.texi: Document -mcmodel=small, -mcmodel=large."}, {"sha": "22209269fd4ef085e2cc564ff008e20e5f6881b9", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 104, "deletions": 102, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa775d63150d286c3637033ab5751fb15bb9a42/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa775d63150d286c3637033ab5751fb15bb9a42/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=3aa775d63150d286c3637033ab5751fb15bb9a42", "patch": "@@ -168,7 +168,7 @@ tilegx_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n }\n \n \n-/* TARGET_MODE_REP_EXTENDED.  */\n+/* Implement TARGET_MODE_REP_EXTENDED.  */\n static int\n tilegx_mode_rep_extended (enum machine_mode mode, enum machine_mode mode_rep)\n {\n@@ -430,7 +430,7 @@ tilegx_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \n   addr = create_tmp_var (ptr_type_node, \"va_arg\");\n \n-  /* if an object is dynamically sized, a pointer to it is passed\n+  /* If an object is dynamically sized, a pointer to it is passed\n      instead of the object itself.  */\n   pass_by_reference_p = pass_by_reference (NULL, TYPE_MODE (type), type,\n \t\t\t\t\t   false);\n@@ -482,11 +482,11 @@ tilegx_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n     {\n     case CONST_INT:\n       /* If this is an 8-bit constant, return zero since it can be\n-         used nearly anywhere with no cost.  If it is a valid operand\n-         for an ADD or AND, likewise return 0 if we know it will be\n-         used in that context.  Otherwise, return 2 since it might be\n-         used there later.  All other constants take at least two\n-         insns.  */\n+\t used nearly anywhere with no cost.  If it is a valid operand\n+\t for an ADD or AND, likewise return 0 if we know it will be\n+\t used in that context.  Otherwise, return 2 since it might be\n+\t used there later.  All other constants take at least two\n+\t insns.  */\n       if (satisfies_constraint_I (x))\n \t{\n \t  *total = 0;\n@@ -531,8 +531,8 @@ tilegx_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \n     case MEM:\n       /* If outer-code was a sign or zero extension, a cost of\n-         COSTS_N_INSNS (1) was already added in, so account for\n-         that.  */\n+\t COSTS_N_INSNS (1) was already added in, so account for\n+\t that.  */\n       if (outer_code == ZERO_EXTEND || outer_code == SIGN_EXTEND)\n \t*total = COSTS_N_INSNS (1);\n       else\n@@ -660,7 +660,7 @@ tilegx_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n static rtx\n create_temp_reg_if_possible (enum machine_mode mode, rtx default_reg)\n {\n-  return can_create_pseudo_p ()? gen_reg_rtx (mode) : default_reg;\n+  return can_create_pseudo_p () ? gen_reg_rtx (mode) : default_reg;\n }\n \n \n@@ -1092,7 +1092,7 @@ tilegx_compute_pcrel_address (rtx result, rtx addr)\n \n /* Returns a register that points to the plt entry of ADDR, a symbolic\n    address, by computing its address relative to\n-   tilegx_text_label_symbol. */\n+   tilegx_text_label_symbol.  */\n void\n tilegx_compute_pcrel_plt_address (rtx result, rtx addr)\n {\n@@ -1264,13 +1264,13 @@ tilegx_legitimize_pic_address (rtx orig,\n \t}\n \n       /* If not during reload, allocate another temp reg here for\n-         loading in the address, so that these instructions can be\n-         optimized properly.  */\n+\t loading in the address, so that these instructions can be\n+\t optimized properly.  */\n       temp_reg = create_temp_reg_if_possible (Pmode, reg);\n       tilegx_compute_pcrel_address (temp_reg, orig);\n \n       /* Note: this is conservative.  We use the text_label but we\n-         don't use the pic_offset_table.  */\n+\t don't use the pic_offset_table.  */\n       crtl->uses_pic_offset_table = 1;\n \n       address = temp_reg;\n@@ -1413,8 +1413,8 @@ tilegx_simd_int (rtx num, enum machine_mode mode)\n \n \n /* Returns true iff VAL can be moved into a register in one\n-   instruction.  And if it can, it emits the code to move the\n-   constant into DEST_REG.\n+   instruction.  And if it can, it emits the code to move the constant\n+   into DEST_REG.\n \n    If THREE_WIDE_ONLY is true, this insists on an instruction that\n    works in a bundle containing three instructions.  */\n@@ -1474,7 +1474,7 @@ tilegx_bitfield_operand_p (HOST_WIDE_INT n, int *first_bit, int *last_bit)\n \tcontinue;\n \n       /* See if x is a power of two minus one, i.e. only consecutive 1\n-         bits starting from bit 0.  */\n+\t bits starting from bit 0.  */\n       if ((x & (x + 1)) == 0)\n \t{\n \t  if (first_bit != NULL)\n@@ -1558,8 +1558,8 @@ expand_set_cint64 (rtx dest_reg, rtx src_val)\n \t  if (expand_set_cint64_one_inst (temp, r, three_wide_only))\n \t    {\n \t      /* 0xFFFFFFFFFFA5FFFF becomes:\n-\t         movei temp, 0xFFFFFFFFFFFFFFA5\n-\t         rotli dest, temp, 16  */\n+\t\t movei temp, 0xFFFFFFFFFFFFFFA5\n+\t\t rotli dest, temp, 16  */\n \t      emit_move_insn (dest_reg,\n \t\t\t      gen_rtx_ROTATE (DImode, temp, GEN_INT (count)));\n \t      return;\n@@ -1608,11 +1608,11 @@ expand_set_cint64 (rtx dest_reg, rtx src_val)\n       unsigned HOST_WIDE_INT leftover;\n \n       /* Recursively create the constant above the lowest 16 zero\n-         bits.  */\n+\t bits.  */\n       expand_set_cint64 (temp, GEN_INT (val >> shift));\n \n       /* See if we can easily insert the remaining bits, or if we need\n-         to fall through to the more general case.  */\n+\t to fall through to the more general case.  */\n       leftover = val - ((val >> shift) << shift);\n       if (leftover == 0)\n \t{\n@@ -1649,8 +1649,8 @@ expand_set_cint64 (rtx dest_reg, rtx src_val)\n   else\n     {\n       /* Set as many high 16-bit blocks as we can with a single\n-         instruction.  We'll insert the remaining 16-bit blocks\n-         below.  */\n+\t instruction.  We'll insert the remaining 16-bit blocks\n+\t below.  */\n       for (shift = 16;; shift += 16)\n \t{\n \t  gcc_assert (shift < 64);\n@@ -1693,10 +1693,10 @@ tilegx_expand_set_const64 (rtx op0, rtx op1)\n   if (CONST_INT_P (op1))\n     {\n       /* TODO: I don't know if we want to split large constants\n-         now, or wait until later (with a define_split).\n+\t now, or wait until later (with a define_split).\n \n-         Does splitting early help CSE?  Does it harm other\n-         optimizations that might fold loads? */\n+\t Does splitting early help CSE?  Does it harm other\n+\t optimizations that might fold loads?  */\n       expand_set_cint64 (op0, op1);\n     }\n   else\n@@ -1794,7 +1794,7 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n   if (bitsize == 2 * BITS_PER_UNIT && (bit_offset % BITS_PER_UNIT) == 0)\n     {\n       /* When just loading a two byte value, we can load the two bytes\n-         individually and combine them efficiently.  */\n+\t individually and combine them efficiently.  */\n \n       mem_lo = adjust_address (mem, QImode, byte_offset);\n       mem_hi = adjust_address (mem, QImode, byte_offset + 1);\n@@ -2131,6 +2131,7 @@ tilegx_expand_const_muldi (rtx op0, rtx op1, long long multiplier)\n     return false;\n }\n \n+\n /* Expand the muldi pattern.  */\n bool\n tilegx_expand_muldi (rtx op0, rtx op1, rtx op2)\n@@ -2305,7 +2306,7 @@ tilegx_emit_setcc_internal (rtx res, enum rtx_code code, rtx op0, rtx op1,\n     case GEU:\n     case GTU:\n       /* We do not have these compares, so we reverse the\n-         operands.  */\n+\t operands.  */\n       swap = true;\n       break;\n \n@@ -2400,7 +2401,7 @@ tilegx_emit_cc_test (enum rtx_code code, rtx op0, rtx op1,\n     case GEU:\n     case GTU:\n       /* These must be reversed (except NE, but let's\n-         canonicalize).  */\n+\t canonicalize).  */\n       code = reverse_condition (code);\n       branch_code = EQ;\n       break;\n@@ -2430,7 +2431,7 @@ tilegx_emit_cc_test (enum rtx_code code, rtx op0, rtx op1,\n \t\t   || (REG_P (op0) && REG_POINTER (op0))))\n \t    {\n \t      /* TODO: Use a SIMD add immediate to hit zero for tiled\n-\t         constants in a single instruction.  */\n+\t\t constants in a single instruction.  */\n \t      if (GET_MODE (op0) != DImode)\n \t\t{\n \t\t  /* Convert to DImode so we can use addli.  Note that\n@@ -3454,47 +3455,47 @@ tilegx_expand_builtin (tree exp,\n \n   opnum = nonvoid;\n   FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n-  {\n-    const struct insn_operand_data *insn_op;\n+    {\n+      const struct insn_operand_data *insn_op;\n \n-    if (arg == error_mark_node)\n-      return NULL_RTX;\n-    if (opnum > MAX_BUILTIN_ARGS)\n-      return NULL_RTX;\n+      if (arg == error_mark_node)\n+\treturn NULL_RTX;\n+      if (opnum > MAX_BUILTIN_ARGS)\n+\treturn NULL_RTX;\n \n-    insn_op = &insn_data[icode].operand[opnum];\n+      insn_op = &insn_data[icode].operand[opnum];\n \n-    op[opnum] = expand_expr (arg, NULL_RTX, insn_op->mode, EXPAND_NORMAL);\n+      op[opnum] = expand_expr (arg, NULL_RTX, insn_op->mode, EXPAND_NORMAL);\n \n-    if (!(*insn_op->predicate) (op[opnum], insn_op->mode))\n-      {\n-\tenum machine_mode opmode = insn_op->mode;\n+      if (!(*insn_op->predicate) (op[opnum], insn_op->mode))\n+\t{\n+\t  enum machine_mode opmode = insn_op->mode;\n \n-\t/* pointer_operand and pmode_register_operand operands do\n-\t   not specify a mode, so use the operand's mode instead\n-\t   (which should always be right by the time we get here,\n-\t   except for constants, which are VOIDmode).  */\n-\tif (opmode == VOIDmode)\n-\t  {\n-\t    enum machine_mode m = GET_MODE (op[opnum]);\n-\t    gcc_assert (m == Pmode || m == VOIDmode);\n-\t    opmode = Pmode;\n-\t  }\n+\t  /* pointer_operand and pmode_register_operand operands do\n+\t     not specify a mode, so use the operand's mode instead\n+\t     (which should always be right by the time we get here,\n+\t     except for constants, which are VOIDmode).  */\n+\t  if (opmode == VOIDmode)\n+\t    {\n+\t      enum machine_mode m = GET_MODE (op[opnum]);\n+\t      gcc_assert (m == Pmode || m == VOIDmode);\n+\t      opmode = Pmode;\n+\t    }\n \n-\top[opnum] = copy_to_mode_reg (opmode, op[opnum]);\n-      }\n+\t  op[opnum] = copy_to_mode_reg (opmode, op[opnum]);\n+\t}\n \n-    if (!(*insn_op->predicate) (op[opnum], insn_op->mode))\n-      {\n-\t/* We still failed to meet the predicate even after moving\n-\t   into a register. Assume we needed an immediate.  */\n-\terror_at (EXPR_LOCATION (exp),\n-\t\t  \"operand must be an immediate of the right size\");\n-\treturn const0_rtx;\n-      }\n+      if (!(*insn_op->predicate) (op[opnum], insn_op->mode))\n+\t{\n+\t  /* We still failed to meet the predicate even after moving\n+\t     into a register. Assume we needed an immediate.  */\n+\t  error_at (EXPR_LOCATION (exp),\n+\t\t    \"operand must be an immediate of the right size\");\n+\t  return const0_rtx;\n+\t}\n \n-    opnum++;\n-  }\n+      opnum++;\n+    }\n \n   if (nonvoid)\n     {\n@@ -3928,7 +3929,7 @@ tilegx_expand_prologue (void)\n       REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = STACK_BOUNDARY;\n \n       /* fp holds a copy of the incoming sp, in case we need to store\n-         it.  */\n+\t it.  */\n       sp_copy_regno = HARD_FRAME_POINTER_REGNUM;\n     }\n   else if (!tilegx_current_function_is_leaf ())\n@@ -4123,7 +4124,7 @@ tilegx_expand_epilogue (bool sibcall_p)\n   if (frame_pointer_needed)\n     {\n       /* Restore the old stack pointer by copying from the frame\n-         pointer.  */\n+\t pointer.  */\n       if (TARGET_32BIT)\n \t{\n \t  insn = emit_insn (gen_sp_restore_32bit (stack_pointer_rtx,\n@@ -4320,6 +4321,7 @@ get_jump_target (rtx branch)\n   return 0;\n }\n \n+\n /* Implement TARGET_SCHED_ADJUST_COST.  */\n static int\n tilegx_sched_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n@@ -4365,37 +4367,37 @@ tilegx_gen_bundles (void)\n {\n   basic_block bb;\n   FOR_EACH_BB (bb)\n-  {\n-    rtx insn, next;\n-    rtx end = NEXT_INSN (BB_END (bb));\n+    {\n+      rtx insn, next;\n+      rtx end = NEXT_INSN (BB_END (bb));\n \n-    for (insn = next_insn_to_bundle (BB_HEAD (bb), end); insn; insn = next)\n-      {\n-\tnext = next_insn_to_bundle (NEXT_INSN (insn), end);\n+      for (insn = next_insn_to_bundle (BB_HEAD (bb), end); insn; insn = next)\n+\t{\n+\t  next = next_insn_to_bundle (NEXT_INSN (insn), end);\n \n-\t/* Never wrap {} around inline asm.  */\n-\tif (GET_CODE (PATTERN (insn)) != ASM_INPUT)\n-\t  {\n-\t    if (next == NULL_RTX || GET_MODE (next) == TImode\n-\t\t/* NOTE: The scheduler incorrectly believes a call\n-\t\t   insn can execute in the same cycle as the insn\n-\t\t   after the call.  This is of course impossible.\n-\t\t   Really we need to fix the scheduler somehow, so\n-\t\t   the code after the call gets scheduled\n-\t\t   optimally.  */\n-\t\t|| CALL_P (insn))\n-\t      {\n-\t\t/* Mark current insn as the end of a bundle.  */\n-\t\tPUT_MODE (insn, QImode);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Mark it as part of a bundle.  */\n-\t\tPUT_MODE (insn, SImode);\n-\t      }\n-\t  }\n-      }\n-  }\n+\t  /* Never wrap {} around inline asm.  */\n+\t  if (GET_CODE (PATTERN (insn)) != ASM_INPUT)\n+\t    {\n+\t      if (next == NULL_RTX || GET_MODE (next) == TImode\n+\t\t  /* NOTE: The scheduler incorrectly believes a call\n+\t\t     insn can execute in the same cycle as the insn\n+\t\t     after the call.  This is of course impossible.\n+\t\t     Really we need to fix the scheduler somehow, so\n+\t\t     the code after the call gets scheduled\n+\t\t     optimally.  */\n+\t\t  || CALL_P (insn))\n+\t\t{\n+\t\t  /* Mark current insn as the end of a bundle.  */\n+\t\t  PUT_MODE (insn, QImode);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Mark it as part of a bundle.  */\n+\t\t  PUT_MODE (insn, SImode);\n+\t\t}\n+\t    }\n+\t}\n+    }\n }\n \n \n@@ -4960,7 +4962,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n   switch (code)\n     {\n     case 'c':\n-      /* Print the compare operator opcode for conditional moves. */\n+      /* Print the compare operator opcode for conditional moves.  */\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n@@ -4975,7 +4977,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'C':\n-      /* Print the compare operator opcode for conditional moves. */\n+      /* Print the compare operator opcode for conditional moves.  */\n       switch (GET_CODE (x))\n \t{\n \tcase EQ:\n@@ -4991,7 +4993,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \n     case 'd':\n       {\n-\t/* Print the compare operator opcode for conditional moves. */\n+\t/* Print the compare operator opcode for conditional moves.  */\n \tswitch (GET_CODE (x))\n \t  {\n \t  case EQ:\n@@ -5008,7 +5010,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \n     case 'D':\n       {\n-\t/* Print the compare operator opcode for conditional moves. */\n+\t/* Print the compare operator opcode for conditional moves.  */\n \tswitch (GET_CODE (x))\n \t  {\n \t  case EQ:\n@@ -5270,7 +5272,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \n     case 'r':\n       /* In this case we need a register.  Use 'zero' if the operand\n-         is const0_rtx.  */\n+\t is const0_rtx.  */\n       if (x == const0_rtx\n \t  || (GET_MODE (x) != VOIDmode && x == CONST0_RTX (GET_MODE (x))))\n \t{\n@@ -5357,7 +5359,7 @@ tilegx_final_prescan_insn (rtx insn)\n }\n \n \n-/* While emitting asm, are we currently inside '{' for a bundle? */\n+/* While emitting asm, are we currently inside '{' for a bundle?  */\n static bool tilegx_in_bundle = false;\n \n /* Implement ASM_OUTPUT_OPCODE.  Prepend/append curly braces as\n@@ -5419,7 +5421,7 @@ tilegx_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)\n \t       \"\\t{\\n\"\n \t       \"\\tmove\\tr10, lr\\n\"\n \t       \"\\tjal\\t%s\\n\"\n-\t       \"\\t}\\t\\n\", MCOUNT_NAME);\n+\t       \"\\t}\\n\", MCOUNT_NAME);\n     }\n \n   tilegx_in_bundle = false;\n@@ -5532,7 +5534,7 @@ tilegx_file_end (void)\n #undef  TARGET_BUILTIN_DECL\n #define TARGET_BUILTIN_DECL tilegx_builtin_decl\n \n-#undef   TARGET_EXPAND_BUILTIN\n+#undef  TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN tilegx_expand_builtin\n \n #undef  TARGET_CONDITIONAL_REGISTER_USAGE"}, {"sha": "92a6d651edab8861887c7da61dd380d5dda652cb", "filename": "gcc/config/tilegx/tilegx.md", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa775d63150d286c3637033ab5751fb15bb9a42/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa775d63150d286c3637033ab5751fb15bb9a42/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=3aa775d63150d286c3637033ab5751fb15bb9a42", "patch": "@@ -417,7 +417,7 @@\n \t\t\t(ss_minus \"\")\n \t\t\t(us_minus \"\")\n \t\t\t])\n- \n+\n ;; <s> is the load/store extension suffix.\n (define_code_attr s [(zero_extend \"u\")\n \t\t     (sign_extend \"s\")])\n@@ -825,11 +825,11 @@\n       bit_width = INTVAL (operands[2]);\n       bit_offset = INTVAL (operands[3]);\n \n-      /* Reject bitfields that can be done with a normal load */\n+      /* Reject bitfields that can be done with a normal load.  */\n       if (MEM_ALIGN (operands[1]) >= bit_offset + bit_width)\n         FAIL;\n \n-      /* The value in memory cannot span more than 8 bytes. */\n+      /* The value in memory cannot span more than 8 bytes.  */\n       first_byte_offset = bit_offset / BITS_PER_UNIT;\n       last_byte_offset = (bit_offset + bit_width - 1) / BITS_PER_UNIT;\n       if (last_byte_offset - first_byte_offset > 7)\n@@ -854,19 +854,18 @@\n   HOST_WIDE_INT bit_width = INTVAL (operands[2]);\n   HOST_WIDE_INT bit_offset = INTVAL (operands[3]);\n \n-\n   if (MEM_P (operands[1]))\n     {\n       HOST_WIDE_INT first_byte_offset, last_byte_offset;\n \n       if (GET_MODE (operands[1]) != QImode)\n         FAIL;\n \n-      /* Reject bitfields that can be done with a normal load */\n+      /* Reject bitfields that can be done with a normal load.  */\n       if (MEM_ALIGN (operands[1]) >= bit_offset + bit_width)\n         FAIL;\n \n-      /* The value in memory cannot span more than 8 bytes. */\n+      /* The value in memory cannot span more than 8 bytes.  */\n       first_byte_offset = bit_offset / BITS_PER_UNIT;\n       last_byte_offset = (bit_offset + bit_width - 1) / BITS_PER_UNIT;\n       if (last_byte_offset - first_byte_offset > 7)\n@@ -882,7 +881,7 @@\n \n     if (bit_offset == 0)\n       {\n-\t /* Extracting the low bits is just a bitwise AND. */\n+\t /* Extracting the low bits is just a bitwise AND.  */\n \t HOST_WIDE_INT mask = ((HOST_WIDE_INT)1 << bit_width) - 1;\n \t emit_insn (gen_anddi3 (operands[0], operands[1], GEN_INT (mask)));\n \t DONE;\n@@ -902,7 +901,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(const:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n \t\t\t     UNSPEC_HW2_LAST)))])\n-  \n+\n (define_expand \"mov_address_step2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(unspec:DI\n@@ -954,7 +953,7 @@\n   \"%1 = . + 8\\n\\tlnk\\t%0\"\n   [(set_attr \"type\" \"Y1\")])\n \n-;; First step of the 3-insn sequence to materialize a position\n+;; The next three patterns are used to to materialize a position\n ;; independent address by adding the difference of two labels to a\n ;; base label in the text segment, assuming that the difference fits\n ;; in 32 signed bits.\n@@ -966,10 +965,6 @@\n                         UNSPEC_HW1_LAST_PCREL)))]\n   \"flag_pic\")\n   \n-;; Second step of the 3-insn sequence to materialize a position\n-;; independent address by adding the difference of two labels to a\n-;; base label in the text segment, assuming that the difference fits\n-;; in 32 signed bits.\n (define_expand \"mov_pcrel_step2<bitsuffix>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"\")\n \t(unspec:I48MODE\n@@ -980,11 +975,7 @@\n \t\t\t   UNSPEC_HW0_PCREL))]\n \t UNSPEC_INSN_ADDR_SHL16INSLI))]\n   \"flag_pic\")\n-  \n-;; Third step of the 3-insn sequence to materialize a position\n-;; independent address by adding the difference of two labels to a base\n-;; label in the text segment, assuming that the difference fits in 32\n-;; signed bits.\n+\n (define_insn \"mov_pcrel_step3<bitsuffix>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n         (unspec:I48MODE [(match_operand:I48MODE 1 \"reg_or_0_operand\" \"rO\")\n@@ -1442,7 +1433,6 @@\n   DONE;\n })\n \n-\n (define_expand \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (minus:DF (match_operand:DF 1 \"register_operand\" \"\")\n@@ -1815,7 +1805,6 @@\n   \"ctz\\t%0, %r1\"\n   [(set_attr \"type\" \"Y0\")])\n \n-\n (define_insn \"popcount<mode>2\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n \t(popcount:I48MODE (match_operand:DI 1 \"reg_or_0_operand\" \"rO\")))]\n@@ -2044,7 +2033,7 @@\n (define_insn \"*zero_extendsidi_truncdisi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t (truncate:SI (match_operand:DI 1 \"reg_or_0_operand\" \"0\"))))]\n+\t (truncate:SI (match_operand:DI 1 \"reg_or_0_operand\" \"rO\"))))]\n   \"\"\n   \"v4int_l\\t%0, zero, %r1\"\n   [(set_attr \"type\" \"X01\")])\n@@ -2115,7 +2104,7 @@\n   shruxi\\t%0, %r1, %2\n   shrux\\t%0, %r1, %r2\"\n   [(set_attr \"type\" \"X01,X01\")])\n-  \n+\n (define_insn \"*lshrsi_truncdisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:SI\n@@ -2320,7 +2309,8 @@\n ;; Loops\n ;;\n \n-;; Define the subtract-one-and-jump insns so loop.c knows what to generate.\n+;; Define the subtract-one-and-jump insns so loop.c knows what to\n+;; generate.\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))    ;; loop pseudo\n    (use (match_operand 1 \"\" \"\"))    ;; iterations; zero if unknown\n@@ -2470,7 +2460,7 @@\n \t    tilegx_compute_pcrel_plt_address (addr, orig_addr);\n           operands[1] = gen_rtx_MEM (DImode, addr);\n         }\n-      }\n+    }\n })\n \n (define_insn \"*call_value_insn\"\n@@ -2633,8 +2623,8 @@\n  [(set_attr \"type\" \"*,*,X01\")])\n \n ;; Used for move sp, r52, to pop a stack frame.  We need to make sure\n-;; that stack frame memory operations have been issued before we do this.\n-;; TODO: see above TODO.\n+;; that stack frame memory operations have been issued before we do\n+;; this.  TODO: see above TODO.\n (define_insn \"sp_restore<bitsuffix>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n         (match_operand:I48MODE 1 \"register_operand\" \"r\"))"}]}