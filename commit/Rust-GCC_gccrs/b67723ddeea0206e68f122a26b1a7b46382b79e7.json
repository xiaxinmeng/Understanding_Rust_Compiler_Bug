{"sha": "b67723ddeea0206e68f122a26b1a7b46382b79e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3NzIzZGRlZWEwMjA2ZTY4ZjEyMmEyNmIxYTdiNDYzODJiNzllNw==", "commit": {"author": {"name": "Nicolas Roche", "email": "roche@adacore.com", "date": "2019-09-18T08:32:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-18T08:32:23Z"}, "message": "[Ada] Ensure that Scan_Real result does not depend on trailing zeros\n\nPrevious change in that procedure to handle overflow issues during\nscanning removed the special handling for trailing zeros in the decimal\npart. Beside the absence of overflow during scanning the special\nhandling of these zeros is still necessary.\n\n2019-09-18  Nicolas Roche  <roche@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-valrea.adb (Scan_Integral_Digits): New procedure.\n\t(Scan_Decimal_Digits): New procedure.\n\t(As_Digit): New function.\n\t(Scan_Real): Use Scan_Integral_Digits and Scan_Decimal_Digits.\n\ngcc/testsuite/\n\n\t* gnat.dg/float_value2.adb: New testcase.\n\nFrom-SVN: r275849", "tree": {"sha": "679d3f9a2a3cd0c71e0f14cbc55318b4c748deb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/679d3f9a2a3cd0c71e0f14cbc55318b4c748deb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b67723ddeea0206e68f122a26b1a7b46382b79e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67723ddeea0206e68f122a26b1a7b46382b79e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67723ddeea0206e68f122a26b1a7b46382b79e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67723ddeea0206e68f122a26b1a7b46382b79e7/comments", "author": {"login": "Nikokrock", "id": 7796165, "node_id": "MDQ6VXNlcjc3OTYxNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7796165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nikokrock", "html_url": "https://github.com/Nikokrock", "followers_url": "https://api.github.com/users/Nikokrock/followers", "following_url": "https://api.github.com/users/Nikokrock/following{/other_user}", "gists_url": "https://api.github.com/users/Nikokrock/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nikokrock/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nikokrock/subscriptions", "organizations_url": "https://api.github.com/users/Nikokrock/orgs", "repos_url": "https://api.github.com/users/Nikokrock/repos", "events_url": "https://api.github.com/users/Nikokrock/events{/privacy}", "received_events_url": "https://api.github.com/users/Nikokrock/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d2880e695410cf607d77be03908d7107e41a5271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2880e695410cf607d77be03908d7107e41a5271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2880e695410cf607d77be03908d7107e41a5271"}], "stats": {"total": 673, "additions": 409, "deletions": 264}, "files": [{"sha": "e77725c2c29a1ade3bb657b3774dc4669b4bf8c9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b67723ddeea0206e68f122a26b1a7b46382b79e7", "patch": "@@ -1,3 +1,10 @@\n+2019-09-18  Nicolas Roche  <roche@adacore.com>\n+\n+\t* libgnat/s-valrea.adb (Scan_Integral_Digits): New procedure.\n+\t(Scan_Decimal_Digits): New procedure.\n+\t(As_Digit): New function.\n+\t(Scan_Real): Use Scan_Integral_Digits and Scan_Decimal_Digits.\n+\n 2019-09-18  Claire Dross  <dross@adacore.com>\n \n \t* exp_attr.adb (Expand_N_Attribute_Reference): Call routine from"}, {"sha": "519e369d94ff77c65b9113ac407a175596b9b163", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 388, "deletions": 264, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=b67723ddeea0206e68f122a26b1a7b46382b79e7", "patch": "@@ -29,353 +29,477 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Powten_Table;  use System.Powten_Table;\n with System.Val_Util;      use System.Val_Util;\n with System.Float_Control;\n \n package body System.Val_Real is\n \n-   ---------------\n-   -- Scan_Real --\n-   ---------------\n+   procedure Scan_Integral_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : out Long_Long_Integer;\n+       Scale          : out Integer;\n+       Base_Violation : in out Boolean;\n+       Base           : Long_Long_Integer := 10;\n+       Base_Specified : Boolean := False);\n+   --  Scan the integral part of a real (i.e: before decimal separator)\n+   --\n+   --  The string parsed is Str (Index .. Max), and after the call Index will\n+   --  point to the first non parsed character.\n+   --\n+   --  For each digit parsed either value := value * base + digit, or scale\n+   --  is incremented by 1.\n+   --\n+   --  Base_Violation will be set to True a digit found is not part of the Base\n+\n+   procedure Scan_Decimal_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : in out Long_Long_Integer;\n+       Scale          : in out Integer;\n+       Base_Violation : in out Boolean;\n+       Base           : Long_Long_Integer := 10;\n+       Base_Specified : Boolean := False);\n+   --  Scan the decimal part of a real (i.e: after decimal separator)\n+   --\n+   --  The string parsed is Str (Index .. Max), and after the call Index will\n+   --  point to the first non parsed character.\n+   --\n+   --  For each digit parsed value = value * base + digit and scale is\n+   --  decremented by 1. If precision limit is reached remaining digits are\n+   --  still parsed but ignored.\n+   --\n+   --  Base_Violation will be set to True a digit found is not part of the Base\n+\n+   subtype Char_As_Digit is Long_Long_Integer range -2 .. 15;\n+   subtype Valid_Digit is Char_As_Digit range 0 .. Char_As_Digit'Last;\n+   Underscore : constant Char_As_Digit := -2;\n+   E_Digit : constant Char_As_Digit := 14;\n+\n+   function As_Digit (C : Character) return Char_As_Digit;\n+   --  Given a character return the digit it represent. If the character is\n+   --  not a digit then a negative value is returned, -2 for underscore and\n+   --  -1 for any other character.\n+\n+   Precision_Limit : constant Long_Long_Integer :=\n+      2 ** (Long_Long_Float'Machine_Mantissa - 1) - 1;\n+   --  This is an upper bound for the number of bits used to represent the\n+   --  mantissa. Beyond that number, any digits parsed are useless.\n+\n+   --------------\n+   -- As_Digit --\n+   --------------\n+\n+   function As_Digit (C : Character) return Char_As_Digit\n+   is\n+   begin\n+      case C is\n+         when '0' .. '9' =>\n+            return Character'Pos (C) - Character'Pos ('0');\n+         when 'a' .. 'f' =>\n+            return Character'Pos (C) - (Character'Pos ('a') - 10);\n+         when 'A' .. 'F' =>\n+            return Character'Pos (C) - (Character'Pos ('A') - 10);\n+         when '_' =>\n+            return Underscore;\n+         when others =>\n+            return -1;\n+      end case;\n+   end As_Digit;\n+\n+   -------------------------\n+   -- Scan_Decimal_Digits --\n+   -------------------------\n+\n+   procedure Scan_Decimal_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : in out Long_Long_Integer;\n+       Scale          : in out Integer;\n+       Base_Violation : in out Boolean;\n+       Base           : Long_Long_Integer := 10;\n+       Base_Specified : Boolean := False)\n \n-   function Scan_Real\n-     (Str : String;\n-      Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Float\n    is\n-      P : Integer;\n-      --  Local copy of string pointer\n+      Precision_Limit_Reached : Boolean := False;\n+      --  Set to True if addition of a digit will cause Value to be superior\n+      --  to Precision_Limit.\n \n-      Base : Long_Long_Float;\n-      --  Base value\n+      Digit : Char_As_Digit;\n+      --  The current digit.\n \n-      Uval : Long_Long_Float;\n-      --  Accumulated float result\n+      Trailing_Zeros : Natural := 0;\n+      --  Number of trailing zeros at a given point.\n+   begin\n \n-      subtype Digs is Character range '0' .. '9';\n-      --  Used to check for decimal digit\n+      --  If initial Scale is not 0 then it means that Precision_Limit was\n+      --  reached during integral part scanning.\n+      if Scale > 0 then\n+         Precision_Limit_Reached := True;\n+      end if;\n \n-      Scale : Integer := 0;\n-      --  Power of Base to multiply result by\n+      --  The function precondition is that the first character is a valid\n+      --  digit.\n+      Digit := As_Digit (Str (Index));\n+\n+      loop\n+         --  Check if base is correct. If the base is not specified the digit\n+         --  E or e cannot be considered as a base violation as it can be used\n+         --  for exponentiation.\n+         if Digit >= Base then\n+            if Base_Specified then\n+               Base_Violation := True;\n+            elsif Digit = E_Digit then\n+               return;\n+            else\n+               Base_Violation := True;\n+            end if;\n+         end if;\n \n-      Start : Positive;\n-      --  Position of starting non-blank character\n+         --  If precision limit has been reached just ignore any remaining\n+         --  digits for the computation of Value and Scale. The scanning\n+         --  should continue only to assess the validity of the string\n+         if not Precision_Limit_Reached then\n+            if Digit = 0 then\n+               --  Trailing '0' digits are ignored unless a non-zero digit is\n+               --  found.\n+               Trailing_Zeros := Trailing_Zeros + 1;\n+            else\n \n-      Minus : Boolean;\n-      --  Set to True if minus sign is present, otherwise to False\n+               --  Handle accumulated zeros.\n+               for J in 1 .. Trailing_Zeros loop\n+                  if Value > Precision_Limit / Base then\n+                     Precision_Limit_Reached := True;\n+                     exit;\n+                  else\n+                     Value := Value * Base;\n+                     Scale := Scale - 1;\n+                  end if;\n+               end loop;\n \n-      Bad_Base : Boolean := False;\n-      --  Set True if Base out of range or if out of range digit\n-\n-      After_Point : Natural := 0;\n-      --  Set to 1 after the point\n-\n-      Precision_Limit : constant Long_Long_Float :=\n-         2.0 ** (Long_Long_Float'Machine_Mantissa - 1);\n-      --  This is an upper bound for the number of bits used to represent the\n-      --  mantissa. Beyond that number, any digits parsed by Scanf are useless.\n-      --  Thus, only the scale should be updated. This ensures that infinity is\n-      --  not reached by the temporary Uval, which could lead to erroneous\n-      --  rounding (for example: 0.4444444... or 1<n zero>E-n).\n-\n-      procedure Scanf;\n-      --  Scans integer literal value starting at current character position.\n-      --  For each digit encountered, Uval is multiplied by 10.0, and the new\n-      --  digit value is incremented. In addition Scale is decremented for each\n-      --  digit encountered if we are after the point (After_Point = 1). The\n-      --  longest possible syntactically valid numeral is scanned out, and on\n-      --  return P points past the last character. On entry, the current\n-      --  character is known to be a digit, so a numeral is definitely present.\n-\n-      -----------\n-      -- Scanf --\n-      -----------\n-\n-      procedure Scanf is\n-         Digit                   : Natural;\n-         Uval_Tmp                : Long_Long_Float;\n-         Precision_Limit_Reached : Boolean := False;\n-      begin\n-         loop\n-            Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-\n-            if not Precision_Limit_Reached then\n-               --  Compute potential new value\n-               Uval_Tmp := Uval * 10.0 + Long_Long_Float (Digit);\n-\n-               if Uval_Tmp > Precision_Limit then\n+               --  Reset trailing zero counter\n+               Trailing_Zeros := 0;\n+\n+               --  Handle current non zero digit\n+               if Value > (Precision_Limit - Digit) / Base then\n                   Precision_Limit_Reached := True;\n+               else\n+                  Value := Value * Base + Digit;\n+                  Scale := Scale - 1;\n                end if;\n             end if;\n+         end if;\n \n-            if Precision_Limit_Reached then\n-               --  If beyond the precision of the mantissa then just ignore the\n-               --  digit, to avoid rounding issues.\n-               if After_Point = 0 then\n-                  Scale := Scale + 1;\n-               end if;\n-            else\n-               Uval := Uval_Tmp;\n-               Scale := Scale - After_Point;\n-            end if;\n+         --  Check next character\n+         Index := Index + 1;\n \n-            --  Check next character\n-            P := P + 1;\n+         if Index > Max then\n+            return;\n+         end if;\n \n-            if P > Max then\n-               --  Done if end of input field\n-               return;\n+         Digit := As_Digit (Str (Index));\n \n-            elsif Str (P) not in Digs then\n-               --  If next character is not a digit, check if this is an\n-               --  underscore. If this is not the case, then return.\n-               if Str (P) = '_' then\n-                  Scan_Underscore (Str, P, Ptr, Max, False);\n+         if Digit < 0 then\n+            if Digit = Underscore and Index + 1 <= Max then\n+               --  Underscore is only alllowed if followed by a digit\n+               Digit := As_Digit (Str (Index + 1));\n+               if Digit in Valid_Digit then\n+                  Index := Index + 1;\n                else\n                   return;\n                end if;\n+            else\n+               --  Neither a valid underscore nor a digit.\n+               return;\n             end if;\n+         end if;\n+      end loop;\n+\n+   end Scan_Decimal_Digits;\n+\n+   --------------------------\n+   -- Scan_Integral_Digits --\n+   --------------------------\n+\n+   procedure Scan_Integral_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : out Long_Long_Integer;\n+       Scale          : out Integer;\n+       Base_Violation : in out Boolean;\n+       Base           : Long_Long_Integer := 10;\n+       Base_Specified : Boolean := False)\n+   is\n+      Precision_Limit_Reached : Boolean := False;\n+      --  Set to True if addition of a digit will cause Value to be superior\n+      --  to Precision_Limit.\n \n-         end loop;\n-      end Scanf;\n-\n-   --  Start of processing for System.Scan_Real\n-\n+      Digit : Char_As_Digit;\n+      --  The current digit\n    begin\n-      --  We do not tolerate strings with Str'Last = Positive'Last\n \n-      if Str'Last = Positive'Last then\n-         raise Program_Error with\n-           \"string upper bound is Positive'Last, not supported\";\n-      end if;\n-\n-      --  We call the floating-point processor reset routine so that we can\n-      --  be sure the floating-point processor is properly set for conversion\n-      --  calls. This is notably need on Windows, where calls to the operating\n-      --  system randomly reset the processor into 64-bit mode.\n-\n-      System.Float_Control.Reset;\n-\n-      Scan_Sign (Str, Ptr, Max, Minus, Start);\n-      P := Ptr.all;\n-      Ptr.all := Start;\n-\n-      --  If digit, scan numeral before point\n-\n-      if Str (P) in Digs then\n-         Uval := 0.0;\n-         Scanf;\n-\n-      --  Initial point, allowed only if followed by digit (RM 3.5(47))\n-\n-      elsif Str (P) = '.'\n-        and then P < Max\n-        and then Str (P + 1) in Digs\n-      then\n-         Uval := 0.0;\n-\n-      --  Any other initial character is an error\n-\n-      else\n-         Bad_Value (Str);\n-      end if;\n-\n-      --  Deal with based case. We reognize either the standard '#' or the\n-      --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-      if P < Max and then (Str (P) = '#' or else Str (P) = ':') then\n-         declare\n-            Base_Char : constant Character := Str (P);\n-            Digit     : Natural;\n-            Fdigit    : Long_Long_Float;\n-            Uval_Tmp  : Long_Long_Float;\n-            Precision_Limit_Reached : Boolean := False;\n-         begin\n-            --  Set bad base if out of range, and use safe base of 16.0,\n-            --  to guard against division by zero in the loop below.\n-\n-            if Uval < 2.0 or else Uval > 16.0 then\n-               Bad_Base := True;\n-               Uval := 16.0;\n+      --  Initialize Scale and Value\n+      Value := 0;\n+      Scale := 0;\n+\n+      --  The function precondition is that the first character is a valid\n+      --  digit.\n+      Digit := As_Digit (Str (Index));\n+\n+      loop\n+         --  Check if base is correct. If the base is not specified the digit\n+         --  E or e cannot be considered as a base violation as it can be used\n+         --  for exponentiation.\n+         if Digit >= Base then\n+            if Base_Specified then\n+               Base_Violation := True;\n+            elsif Digit = E_Digit then\n+               return;\n+            else\n+               Base_Violation := True;\n             end if;\n+         end if;\n \n-            Base := Uval;\n-            Uval := 0.0;\n-            P := P + 1;\n-\n-            --  Special check to allow initial point (RM 3.5(49))\n-\n-            if Str (P) = '.' then\n-               After_Point := 1;\n-               P := P + 1;\n+         if Precision_Limit_Reached then\n+            --  Precision limit has been reached so just update the exponent\n+            Scale := Scale + 1;\n+         else\n+            if Value > (Precision_Limit - Digit) / Base then\n+               --  Updating Value will overflow so ignore this digit and any\n+               --  following ones. Only update the scale\n+               Precision_Limit_Reached := True;\n+               Scale := Scale + 1;\n+            else\n+               Value := Value * Base + Digit;\n             end if;\n+         end if;\n \n-            --  Loop to scan digits of based number. On entry to the loop we\n-            --  must have a valid digit. If we don't, then we have an illegal\n-            --  floating-point value, and we raise Constraint_Error, note that\n-            --  Ptr at this stage was reset to the proper (Start) value.\n-\n-            loop\n-               if P > Max then\n-                  Bad_Value (Str);\n-\n-               elsif Str (P) in Digs then\n-                  Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-\n-               elsif Str (P) in 'A' .. 'F' then\n-                  Digit :=\n-                    Character'Pos (Str (P)) - (Character'Pos ('A') - 10);\n+         --  Look for the next character\n+         Index := Index + 1;\n+         if Index > Max then\n+            return;\n+         end if;\n \n-               elsif Str (P) in 'a' .. 'f' then\n-                  Digit :=\n-                    Character'Pos (Str (P)) - (Character'Pos ('a') - 10);\n+         Digit := As_Digit (Str (Index));\n \n+         if Digit not in Valid_Digit then\n+            --  Next character is not a digit. In that case stop scanning\n+            --  unless the next chracter is an underscore followed by a digit.\n+            if Digit = Underscore and Index + 1 <= Max then\n+               Digit := As_Digit (Str (Index + 1));\n+               if Digit in Valid_Digit then\n+                  Index := Index + 1;\n                else\n-                  Bad_Value (Str);\n+                  return;\n                end if;\n+            else\n+               return;\n+            end if;\n+         end if;\n+      end loop;\n \n-               if not Precision_Limit_Reached then\n-                  --  Compute potential new value\n-                  Uval_Tmp := Uval * Base + Long_Long_Float (Digit);\n+   end Scan_Integral_Digits;\n \n-                  if Uval_Tmp > Precision_Limit then\n-                     Precision_Limit_Reached := True;\n-                  end if;\n-               end if;\n+   ---------------\n+   -- Scan_Real --\n+   ---------------\n \n-               if Precision_Limit_Reached then\n-                  --  If beyond precision of the mantissa then just update\n-                  --  the scale and discard remaining digits.\n+   function Scan_Real\n+      (Str : String;\n+       Ptr : not null access Integer;\n+       Max : Integer)\n+      return Long_Long_Float\n \n-                  if After_Point = 0 then\n-                     Scale := Scale + 1;\n-                  end if;\n+   is\n+      Start : Positive;\n+      --  Position of starting non-blank character\n \n-               else\n-                  --  Now accumulate the new digit\n+      Minus : Boolean;\n+      --  Set to True if minus sign is present, otherwise to False\n \n-                  Fdigit := Long_Long_Float (Digit);\n+      Index : Integer;\n+      --  Local copy of string pointer\n \n-                  if Fdigit >= Base then\n-                     Bad_Base := True;\n-                  else\n-                     Scale := Scale - After_Point;\n-                     Uval := Uval_Tmp;\n-                  end if;\n-               end if;\n+      Int_Value : Long_Long_Integer := -1;\n+      --  Mantissa as an Integer\n \n-               P := P + 1;\n+      Int_Scale : Integer := 0;\n+      --  Exponent value\n \n-               if P > Max then\n-                  Bad_Value (Str);\n+      Base_Violation : Boolean := False;\n+      --  If True some digits where not in the base. The float is still scan\n+      --  till the end even if an error will be raised.\n \n-               elsif Str (P) = '_' then\n-                  Scan_Underscore (Str, P, Ptr, Max, True);\n+      Uval : Long_Long_Float := 0.0;\n+      --  Contain the final value at the end of the function\n \n-               else\n-                  --  Skip past period after digit. Note that the processing\n-                  --  here will permit either a digit after the period, or the\n-                  --  terminating base character, as allowed in (RM 3.5(48))\n+      After_Point : Boolean := False;\n+      --  True if a decimal should be parsed\n \n-                  if Str (P) = '.' and then After_Point = 0 then\n-                     P := P + 1;\n-                     After_Point := 1;\n+      Base : Long_Long_Integer := 10;\n+      --  Current base (default: 10)\n \n-                     if P > Max then\n-                        Bad_Value (Str);\n-                     end if;\n-                  end if;\n+      Base_Char : Character := ASCII.NUL;\n+      --  Character used to set the base. If Nul this means that default\n+      --  base is used.\n \n-                  exit when Str (P) = Base_Char;\n-               end if;\n-            end loop;\n+   begin\n+      --  We do not tolerate strings with Str'Last = Positive'Last\n+\n+      if Str'Last = Positive'Last then\n+         raise Program_Error with\n+           \"string upper bound is Positive'Last, not supported\";\n+      end if;\n \n-            --  Based number successfully scanned out (point was found)\n+      --  We call the floating-point processor reset routine so that we can\n+      --  be sure the floating-point processor is properly set for conversion\n+      --  calls. This is notably need on Windows, where calls to the operating\n+      --  system randomly reset the processor into 64-bit mode.\n \n-            Ptr.all := P + 1;\n-         end;\n+      System.Float_Control.Reset;\n \n-      --  Non-based case, check for being at decimal point now. Note that\n-      --  in Ada 95, we do not insist on a decimal point being present\n+      --  Scan the optional sign\n+      Scan_Sign (Str, Ptr, Max, Minus, Start);\n+      Index := Ptr.all;\n+      Ptr.all := Start;\n \n+      --  First character can be either a decimal digit or a dot.\n+      if Str (Index) in '0' .. '9' then\n+         --  If this is a digit it can indicates either the float decimal\n+         --  part or the base to use\n+         Scan_Integral_Digits\n+            (Str,\n+             Index,\n+             Max            => Max,\n+             Value          => Int_Value,\n+             Scale          => Int_Scale,\n+             Base_Violation => Base_Violation,\n+             Base           => 10);\n+      elsif Str (Index) = '.' and then\n+         --  A dot is only allowed if followed by a digit.\n+         Index < Max and then\n+         Str (Index + 1) in '0' .. '9'\n+      then\n+         --  Initial point, allowed only if followed by digit (RM 3.5(47))\n+         After_Point := True;\n+         Index := Index + 1;\n+         Int_Value := 0;\n       else\n-         Base := 10.0;\n-         After_Point := 1;\n+         Bad_Value (Str);\n+      end if;\n \n-         if P <= Max and then Str (P) = '.' then\n-            P := P + 1;\n+      --  Check if the first number encountered is a base\n+      if Index < Max and then\n+         (Str (Index) = '#' or else Str (Index) = ':')\n+      then\n+         Base_Char := Str (Index);\n+         Base := Int_Value;\n+\n+         --  Reset Int_Value to indicate that parsing of integral value should\n+         --  be done\n+         Int_Value := -1;\n+         if Base < 2 or else Base > 16 then\n+            Base_Violation := True;\n+            Base := 16;\n+         end if;\n \n-            --  Scan digits after point if any are present (RM 3.5(46))\n+         Index := Index + 1;\n \n-            if P <= Max and then Str (P) in Digs then\n-               Scanf;\n-            end if;\n+         if Str (Index) = '.' and then\n+            Index < Max and then\n+            As_Digit (Str (Index + 1)) in Valid_Digit\n+         then\n+            After_Point := True;\n+            Index := Index + 1;\n+            Int_Value := 0;\n          end if;\n-\n-         Ptr.all := P;\n       end if;\n \n-      --  At this point, we have Uval containing the digits of the value as\n-      --  an integer, and Scale indicates the negative of the number of digits\n-      --  after the point. Base contains the base value (an integral value in\n-      --  the range 2.0 .. 16.0). Test for exponent, must be at least one\n-      --  character after the E for the exponent to be valid.\n-\n-      Scale := Scale + Scan_Exponent (Str, Ptr, Max, Real => True);\n+      --  Does scanning of integral part needed\n+      if Int_Value < 0 then\n+         if Index > Max or else As_Digit (Str (Index)) not in Valid_Digit then\n+            Bad_Value (Str);\n+         end if;\n \n-      --  At this point the exponent has been scanned if one is present and\n-      --  Scale is adjusted to include the exponent value. Uval contains the\n-      --  the integral value which is to be multiplied by Base ** Scale.\n+         Scan_Integral_Digits\n+            (Str,\n+             Index,\n+             Max => Max,\n+             Value => Int_Value,\n+             Scale => Int_Scale,\n+             Base_Violation => Base_Violation,\n+             Base => Base,\n+             Base_Specified => Base_Char /= ASCII.NUL);\n+      end if;\n \n-      --  If base is not 10, use exponentiation for scaling\n+      --  Do we have a dot ?\n+      if not After_Point and then\n+         Index <= Max and then\n+         Str (Index) = '.'\n+      then\n+         --  At this stage if After_Point was not set, this means that an\n+         --  integral part has been found. Thus the dot is valid even if not\n+         --  followed by a digit.\n+         if Index < Max and then As_Digit (Str (Index + 1)) in Valid_Digit then\n+            After_Point := True;\n+         end if;\n \n-      if Base /= 10.0 then\n-         Uval := Uval * Base ** Scale;\n+         Index := Index + 1;\n+      end if;\n \n-      --  For base 10, use power of ten table, repeatedly if necessary\n+      if After_Point then\n+         --  Parse decimal part\n+         Scan_Decimal_Digits\n+            (Str,\n+             Index,\n+             Max => Max,\n+             Value => Int_Value,\n+             Scale => Int_Scale,\n+             Base_Violation => Base_Violation,\n+             Base => Base,\n+             Base_Specified => Base_Char /= ASCII.NUL);\n+      end if;\n \n-      elsif Scale > 0 then\n-         while Scale > Maxpow and then Uval'Valid loop\n-            Uval := Uval * Powten (Maxpow);\n-            Scale := Scale - Maxpow;\n-         end loop;\n+      --  If an explicit base was specified ensure that the delimiter is found\n+      if Base_Char /= ASCII.NUL then\n+         if Index > Max or else Str (Index) /= Base_Char then\n+            Bad_Value (Str);\n+         else\n+            Index := Index + 1;\n+         end if;\n+      end if;\n \n-         --  Note that we still know that Scale > 0, since the loop\n-         --  above leaves Scale in the range 1 .. Maxpow.\n+      --  Compute the final value\n+      Uval := Long_Long_Float (Int_Value);\n \n-         if Uval'Valid then\n-            Uval := Uval * Powten (Scale);\n-         end if;\n+      --  Update pointer and scan exponent.\n+      Ptr.all := Index;\n \n-      elsif Scale < 0 then\n-         while (-Scale) > Maxpow and then Uval'Valid loop\n-            Uval := Uval / Powten (Maxpow);\n-            Scale := Scale + Maxpow;\n-         end loop;\n+      Int_Scale := Int_Scale + Scan_Exponent (Str,\n+                                              Ptr,\n+                                              Max,\n+                                              Real => True);\n \n-         --  Note that we still know that Scale < 0, since the loop\n-         --  above leaves Scale in the range -Maxpow .. -1.\n-         if Uval'Valid then\n-            Uval := Uval / Powten (-Scale);\n-         end if;\n-      end if;\n+      Uval := Uval * Long_Long_Float (Base) ** Int_Scale;\n \n       --  Here is where we check for a bad based number\n-\n-      if Bad_Base then\n+      if Base_Violation then\n          Bad_Value (Str);\n \n       --  If OK, then deal with initial minus sign, note that this processing\n       --  is done even if Uval is zero, so that -0.0 is correctly interpreted.\n-\n       else\n          if Minus then\n             return -Uval;\n          else\n             return Uval;\n          end if;\n       end if;\n+\n    end Scan_Real;\n \n    ----------------"}, {"sha": "8951eb63c815542fe095d11c4d2fbfc95785ad75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b67723ddeea0206e68f122a26b1a7b46382b79e7", "patch": "@@ -1,3 +1,7 @@\n+2019-09-18  Nicolas Roche  <roche@adacore.com>\n+\n+\t* gnat.dg/float_value2.adb: New testcase.\n+\n 2019-09-18  Vadim Godunko  <godunko@adacore.com>\n \n \t* gnat.dg/expect4.adb: New testcase."}, {"sha": "d1f19f810b32a1f308b15e7e415d366065d9b403", "filename": "gcc/testsuite/gnat.dg/float_value2.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Ftestsuite%2Fgnat.dg%2Ffloat_value2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67723ddeea0206e68f122a26b1a7b46382b79e7/gcc%2Ftestsuite%2Fgnat.dg%2Ffloat_value2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ffloat_value2.adb?ref=b67723ddeea0206e68f122a26b1a7b46382b79e7", "patch": "@@ -0,0 +1,10 @@\n+--  { dg-do run }\n+\n+procedure Float_Value2 is\n+   F1 : Long_Long_Float := Long_Long_Float'Value (\"1.e40\");\n+   F2 : Long_Long_Float := Long_Long_Float'Value (\"1.0e40\");\n+begin\n+   if F1 /= F2 then\n+      raise Program_Error;\n+   end if;\n+end Float_Value2;\n\\ No newline at end of file"}]}