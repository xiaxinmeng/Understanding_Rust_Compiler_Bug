{"sha": "4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3NjA3OWZkZmEzZDM2ZWJkOTVhYzhiNDg5NTE5OTQ1ZThlZTg4Zg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-11-04T22:33:11Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-11-04T22:33:11Z"}, "message": "middle-end: Move load/store-lanes check till late.\n\nThis moves the code that checks for load/store lanes further in the pipeline and\nplaces it after slp_optimize.  This would allow us to perform optimizations on\nthe SLP tree and only bail out if we really have a permute.\n\nWith this change it allows us to handle permutes such as {1,1,1,1} which should\nbe handled by a load and replicate.\n\nThis change however makes it all or nothing. Either all instances can be handled\nor none at all.  This is why some of the test cases have been adjusted.\n\ngcc/ChangeLog:\n\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Moved load/store lanes\n\tcheck to ...\n\t* tree-vect-loop.c (vect_analyze_loop_2): ..Here\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/vect/slp-11b.c: Update output scan.\n\t* gcc.dg/vect/slp-perm-6.c: Likewise.", "tree": {"sha": "137fc0337746424a1379b9b5812f1bae11208f70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/137fc0337746424a1379b9b5812f1bae11208f70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6682ef4363b32977aeca590fced2221329c92c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6682ef4363b32977aeca590fced2221329c92c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6682ef4363b32977aeca590fced2221329c92c02"}], "stats": {"total": 130, "additions": 77, "deletions": 53}, "files": [{"sha": "3f16c9cec3e0ab6672d321e1bb265e7853920341", "filename": "gcc/testsuite/gcc.dg/vect/slp-11b.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11b.c?ref=4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "patch": "@@ -45,4 +45,4 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_strided4 && vect_int_mult } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { target { ! { vect_strided4 && vect_int_mult } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */"}, {"sha": "816486a050d4fbf7d3365c829d48175ff7ba7f60", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c?ref=4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "patch": "@@ -106,7 +106,7 @@ int main (int argc, const char* argv[])\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && { {! vect_load_lanes } && {! vect_partial_vectors_usage_1 } } } } } } */\n /* The epilogues are vectorized using partial vectors.  */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\" { target { vect_perm3_int && { {! vect_load_lanes } && vect_partial_vectors_usage_1 } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n-/* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_load_lanes } } } */\n+/* { dg-final { scan-tree-dump \"Built SLP cancelled: can use load/store-lanes\" \"vect\" { xfail { vect_perm3_int && vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { xfail vect_load_lanes } } } */\n+/* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { xfail vect_load_lanes } } } */"}, {"sha": "547894c39c8033ff7348718b118864a9ea763494", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "patch": "@@ -2365,6 +2365,78 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t\t\t       \"unsupported SLP instances\\n\");\n \t  goto again;\n \t}\n+\n+      /* Check whether any load in ALL SLP instances is possibly permuted.  */\n+      slp_tree load_node, slp_root;\n+      unsigned i, x;\n+      slp_instance instance;\n+      bool can_use_lanes = true;\n+      FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (loop_vinfo), x, instance)\n+\t{\n+\t  slp_root = SLP_INSTANCE_TREE (instance);\n+\t  int group_size = SLP_TREE_LANES (slp_root);\n+\t  tree vectype = SLP_TREE_VECTYPE (slp_root);\n+\t  bool loads_permuted = false;\n+\t  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, load_node)\n+\t    {\n+\t      if (!SLP_TREE_LOAD_PERMUTATION (load_node).exists ())\n+\t\tcontinue;\n+\t      unsigned j;\n+\t      stmt_vec_info load_info;\n+\t      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n+\t\tif (SLP_TREE_LOAD_PERMUTATION (load_node)[j] != j)\n+\t\t  {\n+\t\t    loads_permuted = true;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n+\t  /* If the loads and stores can be handled with load/store-lane\n+\t     instructions record it and move on to the next instance.  */\n+\t  if (loads_permuted\n+\t      && vect_store_lanes_supported (vectype, group_size, false))\n+\t    {\n+\t      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, load_node)\n+\t\t{\n+\t\t  stmt_vec_info stmt_vinfo = DR_GROUP_FIRST_ELEMENT\n+\t\t      (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n+\t\t  /* Use SLP for strided accesses (or if we can't\n+\t\t     load-lanes).  */\n+\t\t  if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n+\t\t      || ! vect_load_lanes_supported\n+\t\t\t    (STMT_VINFO_VECTYPE (stmt_vinfo),\n+\t\t\t     DR_GROUP_SIZE (stmt_vinfo), false))\n+\t\t    break;\n+\t\t}\n+\n+\t      can_use_lanes\n+\t\t= can_use_lanes && i == SLP_INSTANCE_LOADS (instance).length ();\n+\n+\t      if (can_use_lanes && dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"SLP instance %p can use load/store-lanes\\n\",\n+\t\t\t\t instance);\n+\t    }\n+\t  else\n+\t    {\n+\t      can_use_lanes = false;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* If all SLP instances can use load/store-lanes abort SLP and try again\n+\t with SLP disabled.  */\n+      if (can_use_lanes)\n+\t{\n+\t  ok = opt_result::failure_at (vect_location,\n+\t\t\t\t       \"Built SLP cancelled: can use \"\n+\t\t\t\t       \"load/store-lanes\\n\");\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Built SLP cancelled: all SLP instances support \"\n+\t\t\t     \"load/store-lanes\\n\");\n+\t  goto again;\n+\t}\n     }\n \n   /* Dissolve SLP-only groups.  */"}, {"sha": "d498cd466eb7e8d98230f6b662437cf4fa312f27", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d76079fdfa3d36ebd95ac8b489519945e8ee88f/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4d76079fdfa3d36ebd95ac8b489519945e8ee88f", "patch": "@@ -2263,54 +2263,6 @@ vect_build_slp_instance (vec_info *vinfo,\n \t\t\t     \"SLP size %u vs. limit %u.\\n\",\n \t\t\t     tree_size, max_tree_size);\n \n-\t  /* Check whether any load is possibly permuted.  */\n-\t  slp_tree load_node;\n-\t  bool loads_permuted = false;\n-\t  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (new_instance), i, load_node)\n-\t    {\n-\t      if (!SLP_TREE_LOAD_PERMUTATION (load_node).exists ())\n-\t\tcontinue;\n-\t      unsigned j;\n-\t      stmt_vec_info load_info;\n-\t      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n-\t\tif (SLP_TREE_LOAD_PERMUTATION (load_node)[j] != j)\n-\t\t  {\n-\t\t    loads_permuted = true;\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\n-\t  /* If the loads and stores can be handled with load/store-lane\n-\t     instructions do not generate this SLP instance.  */\n-\t  if (is_a <loop_vec_info> (vinfo)\n-\t      && loads_permuted\n-\t      && kind == slp_inst_kind_store\n-\t      && vect_store_lanes_supported\n-\t\t   (STMT_VINFO_VECTYPE (scalar_stmts[0]), group_size, false))\n-\t    {\n-\t      slp_tree load_node;\n-\t      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (new_instance), i, load_node)\n-\t\t{\n-\t\t  stmt_vec_info stmt_vinfo = DR_GROUP_FIRST_ELEMENT\n-\t\t      (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n-\t\t  /* Use SLP for strided accesses (or if we can't load-lanes).  */\n-\t\t  if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n-\t\t      || ! vect_load_lanes_supported\n-\t\t      (STMT_VINFO_VECTYPE (stmt_vinfo),\n-\t\t       DR_GROUP_SIZE (stmt_vinfo), false))\n-\t\t    break;\n-\t\t}\n-\t      if (i == SLP_INSTANCE_LOADS (new_instance).length ())\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"Built SLP cancelled: can use \"\n-\t\t\t\t     \"load/store-lanes\\n\");\n-\t\t  vect_free_slp_instance (new_instance);\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\n \t  /* Fixup SLP reduction chains.  */\n \t  if (kind == slp_inst_kind_reduc_chain)\n \t    {"}]}