{"sha": "b93ae1a01bbad59ee77b7c84f4743a730138ba87", "node_id": "C_kwDOANBUbNoAKGI5M2FlMWEwMWJiYWQ1OWVlNzdiN2M4NGY0NzQzYTczMDEzOGJhODc", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-28T17:22:34Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-29T00:28:20Z"}, "message": "d: Add SIMD intrinsics module and compiler built-ins.\n\nVectors in D are exposed by the use of the `__vector(T[N])' type, and\nwhilst most unary and binary operations work as you'd expect, there are\nsome operations that are not possible without doing the operation\nunrolled, or calling some target-specific built-in, or with inline asm.\n\nThis introduces a new `gcc.simd' module that introduces the following.\n\n - Prefetching has been exposed by a convenient `prefetch' function in\n   the library.\n\n - Loading and storing from an unaligned address have been exposed by\n   `loadUnaligned' and `storeUnaligned' intrinsics.\n\n - Vector permutations have been exposed by `shuffle`, and\n   `shufflevector' intrinsics.\n\n - Converting between two vectors with a different element type has been\n   exposed by a `convertvector' intrinsic.\n\n - The ternary operator has been exposed with a `blendvector' intrinsic.\n\n - Comparison operators have been exposed by `equalMask',\n   `notEqualMask', `greaterMask', and `greaterEqualMask' intrinsics.\n\n - Logic operators have been exposed by convenient `notMask',\n   `andAndMask', and `orOrMask' functions in the library.\n\nTo be compatible with the LLVM D compiler's own SIMD intrinsic module,\nthere is also the addition of an `extractelement' and `insertelement'\nconvenience functions, and an alternative interface for calling the\n`shufflevector' function.\n\nThe addition of these intrinsics lowers the boundary for users working\nin SIMD to get the desired codegen they want out of the compiler.\n\nMost of what is present here - apart from tests - is the adding of\nmachinery in the intrinsics suite of functions to do validation on\ntemplated intrinsics.  Whilst these are still matched from the library\nby their generic (untyped) signature, there is a still an assumption\nthat what has been instantiated and handed down to the code generator is\nvalid, because why would these definitions be found outside of the\nin-tree D runtime library?  The majority of intrinsics are not\ntemplates, so the test on the mangled signature string still guarantees\nall types are as we expect them to be.  However there are still a small\nhandful of other templated intrinsics (core.bitop.{rol,ror},\ncore.math.toPrec, std.math.traits.isNaN, ...) that are currently\nunchecked, so would benefit from being included into this built-in\nchecking function at some point in the future.\n\ngcc/d/ChangeLog:\n\n\t* intrinsics.cc: Include diagnostic.h, langhooks.h,\n\tvec-perm-indices.h.\n\t(maybe_set_intrinsic): Add cases for new simd intrinsics.\n\t(warn_mismatched_return_type): New function.\n\t(warn_mismatched_argument): New function.\n\t(build_shuffle_mask_type): New function.\n\t(maybe_warn_intrinsic_mismatch): New function.\n\t(expand_intrinsic_vec_cond): New function.\n\t(expand_intrinsic_vec_convert): New function.\n\t(expand_intrinsic_vec_blend): New function.\n\t(expand_intrinsic_vec_shuffle): New function.\n\t(expand_intrinsic_vec_shufflevector): New function.\n\t(expand_intrinsic_vec_load_unaligned): New function.\n\t(expand_intrinsic_vec_store_unaligned): New function.\n\t(maybe_expand_intrinsic): Check signature of intrinsic before handing\n\toff to front-end lowering.  Add cases for new simd intrinsics.\n\t* intrinsics.def (INTRINSIC_LOADUNALIGNED): Define intrinsic.\n\t(INTRINSIC_STOREUNALIGNED): Define intrinsic.\n\t(INTRINSIC_SHUFFLE): Define intrinsic.\n\t(INTRINSIC_SHUFFLEVECTOR): Define intrinsic.\n\t(INTRINSIC_CONVERTVECTOR): Define intrinsic.\n\t(INTRINSIC_BLENDVECTOR): Define intrinsic.\n\t(INTRINSIC_EQUALMASK): Define intrinsic.\n\t(INTRINSIC_NOTEQUALMASK): Define intrinsic.\n\t(INTRINSIC_GREATERMASK): Define intrinsic.\n\t(INTRINSIC_GREATEREQUALMASK): Define intrinsic.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add gcc/simd.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* libdruntime/gcc/simd.d: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/Wbuiltin_declaration_mismatch.d: Rename to...\n\t* gdc.dg/Wbuiltin_declaration_mismatch1.d: ...this.\n\t* gdc.dg/Wbuiltin_declaration_mismatch2.d: New test.\n\t* gdc.dg/torture/simd_blendvector.d: New test.\n\t* gdc.dg/torture/simd_cond.d: New test.\n\t* gdc.dg/torture/simd_convertvector.d: New test.\n\t* gdc.dg/torture/simd_load.d: New test.\n\t* gdc.dg/torture/simd_logical.d: New test.\n\t* gdc.dg/torture/simd_shuffle.d: New test.\n\t* gdc.dg/torture/simd_shufflevector.d: New test.\n\t* gdc.dg/torture/simd_store.d: New test.", "tree": {"sha": "e34e03818aa63ee9df776904df1ae30436e4b682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e34e03818aa63ee9df776904df1ae30436e4b682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b93ae1a01bbad59ee77b7c84f4743a730138ba87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b93ae1a01bbad59ee77b7c84f4743a730138ba87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b93ae1a01bbad59ee77b7c84f4743a730138ba87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b93ae1a01bbad59ee77b7c84f4743a730138ba87/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb29fdea9cc36f4abeb8566968b2c1bd9054c7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb29fdea9cc36f4abeb8566968b2c1bd9054c7af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb29fdea9cc36f4abeb8566968b2c1bd9054c7af"}], "stats": {"total": 2372, "additions": 2355, "deletions": 17}, "files": [{"sha": "454d940d1b533248a43aa1fafe7d588641859412", "filename": "gcc/d/intrinsics.cc", "status": "modified", "additions": 587, "deletions": 0, "changes": 587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Fd%2Fintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Fd%2Fintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.cc?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -29,9 +29,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"function.h\"\n #include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"langhooks.h\"\n #include \"fold-const.h\"\n #include \"stringpool.h\"\n #include \"builtins.h\"\n+#include \"vec-perm-indices.h\"\n \n #include \"d-tree.h\"\n \n@@ -161,6 +164,16 @@ maybe_set_intrinsic (FuncDeclaration *decl)\n \t    case INTRINSIC_MULUL:\n \t    case INTRINSIC_NEGS:\n \t    case INTRINSIC_NEGSL:\n+\t    case INTRINSIC_LOADUNALIGNED:\n+\t    case INTRINSIC_STOREUNALIGNED:\n+\t    case INTRINSIC_SHUFFLE:\n+\t    case INTRINSIC_SHUFFLEVECTOR:\n+\t    case INTRINSIC_CONVERTVECTOR:\n+\t    case INTRINSIC_BLENDVECTOR:\n+\t    case INTRINSIC_EQUALMASK:\n+\t    case INTRINSIC_NOTEQUALMASK:\n+\t    case INTRINSIC_GREATERMASK:\n+\t    case INTRINSIC_GREATEREQUALMASK:\n \t    case INTRINSIC_VLOAD8:\n \t    case INTRINSIC_VLOAD16:\n \t    case INTRINSIC_VLOAD32:\n@@ -169,6 +182,8 @@ maybe_set_intrinsic (FuncDeclaration *decl)\n \t    case INTRINSIC_VSTORE16:\n \t    case INTRINSIC_VSTORE32:\n \t    case INTRINSIC_VSTORE64:\n+\t      /* Cannot interpret function during CTFE.  If the library\n+\t\t provides a definition, its body will be used instead.  */\n \t      break;\n \n \t    case INTRINSIC_POW:\n@@ -196,6 +211,314 @@ maybe_set_intrinsic (FuncDeclaration *decl)\n     }\n }\n \n+/* Helper function for maybe_warn_intrinsic_mismatch.  Issue warning about\n+   mismatch in the EXPECTED return type in call to the intrinsic function in\n+   CALLEXP, and return TRUE.  */\n+\n+static bool\n+warn_mismatched_return_type (tree callexp, const char *expected)\n+{\n+  warning_at (EXPR_LOCATION (callexp), OPT_Wbuiltin_declaration_mismatch,\n+\t      \"mismatch in return type of intrinsic function %qD \"\n+\t      \"(%qT, should be %qs)\", get_callee_fndecl (callexp),\n+\t      TREE_TYPE (callexp), expected);\n+  return true;\n+}\n+\n+/* Helper function for maybe_warn_intrinsic_mismatch.  Issue warning or error\n+   about mismatch in the EXPECTED argument type at ARGNO in call to the\n+   intrinsic function in CALLEXP, and return TRUE.  */\n+\n+static bool\n+warn_mismatched_argument (tree callexp, unsigned argno, const char *expected)\n+{\n+  warning_at (EXPR_LOCATION (callexp), OPT_Wbuiltin_declaration_mismatch,\n+\t      \"mismatch in argument %u type of intrinsic function %qD \"\n+\t      \"(%qT, should be %qs)\", argno + 1, get_callee_fndecl (callexp),\n+\t      TREE_TYPE (CALL_EXPR_ARG (callexp, argno)), expected);\n+  return true;\n+}\n+\n+static bool\n+warn_mismatched_argument (tree callexp, unsigned argno, tree expected,\n+\t\t\t  bool error_p = false)\n+{\n+  if (error_p)\n+    error_at (EXPR_LOCATION (callexp),\n+\t      \"mismatch in argument %u type of intrinsic function %qD \"\n+\t      \"(%qT, should be %qT)\", argno + 1, get_callee_fndecl (callexp),\n+\t      TREE_TYPE (CALL_EXPR_ARG (callexp, argno)), expected);\n+  else\n+    warning_at (EXPR_LOCATION (callexp), OPT_Wbuiltin_declaration_mismatch,\n+\t\t\"mismatch in argument %u type of intrinsic function %qD \"\n+\t\t\"(%qT, should be %qT)\", argno + 1, get_callee_fndecl (callexp),\n+\t\tTREE_TYPE (CALL_EXPR_ARG (callexp, argno)), expected);\n+\n+  return true;\n+}\n+\n+/* Helper function for maybe_warn_intrinsic_mismatch.  Builds a vector integer\n+   type suitable for the mask argument of INTRINSIC_SHUFFLE from the given\n+   input argument TYPE.  */\n+\n+static tree\n+build_shuffle_mask_type (tree type)\n+{\n+  const unsigned bits = GET_MODE_BITSIZE (SCALAR_TYPE_MODE (TREE_TYPE (type)));\n+  const int unsignedp = TYPE_UNSIGNED (TREE_TYPE (type));\n+  tree inner = lang_hooks.types.type_for_size (bits, unsignedp);\n+  gcc_assert (inner && TREE_CODE (inner) == INTEGER_TYPE);\n+\n+  /* %% Get the front-end type for the vector so the D type will be\n+     printed (this should really be handled by a D tree printer).  */\n+  Type *t = build_frontend_type (inner);\n+  gcc_assert (t != NULL);\n+  unsigned HOST_WIDE_INT nunits;\n+  TYPE_VECTOR_SUBPARTS (type).is_constant (&nunits);\n+\n+  return build_ctype (TypeVector::create (t->sarrayOf (nunits)));\n+}\n+\n+/* Checks if call to intrinsic FUNCTION in CALLEXP matches the internal\n+   type and value constraints that we expect from the library definitions.\n+   Returns TRUE and issues a warning if there is a mismatch.\n+\n+   Note: The return type and parameters are encoded into the signature `deco'\n+   string that we match on in maybe_set_intrinsic(), so if the deco mangle\n+   string has 'i' in the part that specifies the return type, then the matched\n+   intrinsic will always have the return type `int'.\n+\n+   For templated intrinsics however, we rely on template constraints to ensure\n+   that the generic type matches what we expect it to be.  There is still an\n+   enforced relationship between a template argument and its instantiated type.\n+   For example: `T func(T)(T*)' would have the generic return type `@1T' and\n+   generic parameter type `@1PT', so it can be assumed that if the return type\n+   matches what we expect then all parameters are fine as well.  Otherwise it\n+   can be assumed that some internal_error has occurred for this to be the case.\n+   Where a templated intrinsic has multiple template arguments, each generic\n+   type will need to be checked for its validity.  */\n+\n+static bool\n+maybe_warn_intrinsic_mismatch (tree function, tree callexp)\n+{\n+  switch (DECL_INTRINSIC_CODE (function))\n+    {\n+    case INTRINSIC_NONE:\n+    default:\n+      return false;\n+\n+    case INTRINSIC_LOADUNALIGNED:\n+      {\n+\t/* Expects the signature:\n+\t   vector(T) loadUnaligned (vector(T)*);  */\n+\tgcc_assert (call_expr_nargs (callexp) == 1);\n+\n+\ttree ptr = TREE_TYPE (CALL_EXPR_ARG (callexp, 0));\n+\tif (!VECTOR_TYPE_P (TREE_TYPE (callexp))\n+\t    || !POINTER_TYPE_P (ptr) || !VECTOR_TYPE_P (TREE_TYPE (ptr)))\n+\t  return warn_mismatched_return_type (callexp, \"__vector(T)\");\n+\n+\treturn false;\n+      }\n+\n+    case INTRINSIC_STOREUNALIGNED:\n+      {\n+\t/* Expects the signature:\n+\t   vector(T) storeUnaligned (vector(T)*, vector(T));  */\n+\tgcc_assert (call_expr_nargs (callexp) == 2);\n+\n+\ttree ptr = TREE_TYPE (CALL_EXPR_ARG (callexp, 0));\n+\ttree val = TREE_TYPE (CALL_EXPR_ARG (callexp, 1));\n+\tif (!VECTOR_TYPE_P (TREE_TYPE (callexp))\n+\t    || !POINTER_TYPE_P (ptr) || !VECTOR_TYPE_P (TREE_TYPE (ptr))\n+\t    || !VECTOR_TYPE_P (val))\n+\t  return warn_mismatched_return_type (callexp, \"__vector(T)\");\n+\n+\treturn false;\n+      }\n+\n+    case INTRINSIC_SHUFFLE:\n+    case INTRINSIC_BLENDVECTOR:\n+      {\n+\t/* Expects the signature:\n+\t   vector(T) shuffle (vector(T), vector(U), vector(V));\n+\t   vector(T) blendvector (vector(T), vector(U), vector(V));  */\n+\tgcc_assert (call_expr_nargs (callexp) == 3);\n+\n+\ttree vec0 = TREE_TYPE (CALL_EXPR_ARG (callexp, 0));\n+\tif (!VECTOR_TYPE_P (TREE_TYPE (callexp))\n+\t    || !VECTOR_TYPE_P (vec0))\n+\t  return warn_mismatched_return_type (callexp, \"__vector(T)\");\n+\n+\ttree vec1 = TREE_TYPE (CALL_EXPR_ARG (callexp, 1));\n+\tif (!VECTOR_TYPE_P (vec1))\n+\t  return warn_mismatched_argument (callexp, 1, vec0);\n+\n+\ttree mask = TREE_TYPE (CALL_EXPR_ARG (callexp, 2));\n+\tif (!VECTOR_TYPE_P (mask) || !VECTOR_INTEGER_TYPE_P (mask))\n+\t  {\n+\t    tree expected = build_shuffle_mask_type (vec0);\n+\t    return warn_mismatched_argument (callexp, 2, expected,\n+\t\t\t\t\t     VECTOR_TYPE_P (mask));\n+\t  }\n+\n+\t/* Types have been validated, now issue errors about violations on the\n+\t   constraints of the intrinsic.  */\n+\tif (TYPE_MAIN_VARIANT (vec0) != TYPE_MAIN_VARIANT (vec1))\n+\t  return warn_mismatched_argument (callexp, 1, vec0, true);\n+\n+\t/* Vector element sizes should be equal between arguments and mask.  */\n+\tif (GET_MODE_BITSIZE (SCALAR_TYPE_MODE (TREE_TYPE (vec0)))\n+\t    != GET_MODE_BITSIZE (SCALAR_TYPE_MODE (TREE_TYPE (mask)))\n+\t    || maybe_ne (TYPE_VECTOR_SUBPARTS (vec0),\n+\t\t\t TYPE_VECTOR_SUBPARTS (mask))\n+\t    || maybe_ne (TYPE_VECTOR_SUBPARTS (vec1),\n+\t\t\t TYPE_VECTOR_SUBPARTS (mask)))\n+\t  {\n+\t    tree expected = build_shuffle_mask_type (vec0);\n+\t    return warn_mismatched_argument (callexp, 2, expected, true);\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case INTRINSIC_SHUFFLEVECTOR:\n+      {\n+\t/* Expects the signature:\n+\t   vector(T[N]) shufflevector (vector(T), vector(U), N...);  */\n+\tgcc_assert (call_expr_nargs (callexp) >= 3);\n+\tgcc_assert (VECTOR_TYPE_P (TREE_TYPE (callexp)));\n+\n+\ttree vec0 = TREE_TYPE (CALL_EXPR_ARG (callexp, 0));\n+\tif (!VECTOR_TYPE_P (vec0))\n+\t  return warn_mismatched_argument (callexp, 0, \"__vector(T)\");\n+\n+\ttree vec1 = TREE_TYPE (CALL_EXPR_ARG (callexp, 1));\n+\tif (!VECTOR_TYPE_P (vec1))\n+\t  return warn_mismatched_argument (callexp, 1, vec0);\n+\n+\tfor (int i = 2; i < call_expr_nargs (callexp); i++)\n+\t  {\n+\t    tree idx = TREE_TYPE (CALL_EXPR_ARG (callexp, i));\n+\t    if (TREE_CODE (idx) != INTEGER_TYPE)\n+\t      return warn_mismatched_argument (callexp, i, d_int_type);\n+\t  }\n+\n+\t/* Types have been validated, now issue errors about violations on the\n+\t   constraints of the intrinsic.  */\n+\tif (TYPE_MAIN_VARIANT (TREE_TYPE (vec0))\n+\t    != TYPE_MAIN_VARIANT (TREE_TYPE (vec1)))\n+\t  {\n+\t    /* %% Get the front-end type for the vector so the D type will be\n+\t       printed (this should really be handled by a D tree printer).  */\n+\t    unsigned HOST_WIDE_INT nunits;\n+\t    if (!TYPE_VECTOR_SUBPARTS (vec1).is_constant (&nunits))\n+\t      break;\n+\n+\t    Type *inner = build_frontend_type (TREE_TYPE (vec0));\n+\t    Type *vector = TypeVector::create (inner->sarrayOf (nunits));\n+\t    return warn_mismatched_argument (callexp, 1,\n+\t\t\t\t\t     build_ctype (vector), true);\n+\t  }\n+\n+\t/* Vector sizes should be known, and number of indices a power of 2.  */\n+\tunsigned HOST_WIDE_INT vec0_length;\n+\tunsigned HOST_WIDE_INT vec1_length;\n+\tif (!TYPE_VECTOR_SUBPARTS (vec0).is_constant (&vec0_length)\n+\t    || !TYPE_VECTOR_SUBPARTS (vec1).is_constant (&vec1_length)\n+\t    || !pow2p_hwi (call_expr_nargs (callexp) - 2))\n+\t  break;\n+\n+\t/* All index arguments must be valid constants as well.  */\n+\tfor (int i = 2; i < call_expr_nargs (callexp); i++)\n+\t  {\n+\t    tree idx = CALL_EXPR_ARG (callexp, i);\n+\t    if (!tree_fits_shwi_p (idx))\n+\t      {\n+\t\terror_at (EXPR_LOCATION (callexp),\n+\t\t\t  \"argument %qE cannot be read at compile time\", idx);\n+\t\treturn true;\n+\t      }\n+\n+\t    HOST_WIDE_INT iidx = tree_to_shwi (idx);\n+\t    if (iidx < 0\n+\t\t|| (unsigned HOST_WIDE_INT) iidx >= vec0_length + vec1_length)\n+\t      {\n+\t\terror_at (EXPR_LOCATION (callexp),\n+\t\t\t  \"element index %qE is out of bounds %<[0 .. %E]%>\",\n+\t\t\t  idx, build_integer_cst (vec0_length + vec1_length));\n+\t\treturn true;\n+\t      }\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case INTRINSIC_CONVERTVECTOR:\n+      {\n+\t/* Expects the signature:\n+\t   vector(T) convertvector (vector(U));  */\n+\tgcc_assert (call_expr_nargs (callexp) == 1);\n+\n+\ttree ret = TREE_TYPE (callexp);\n+\tif (!VECTOR_TYPE_P (ret)\n+\t    || (!VECTOR_INTEGER_TYPE_P (ret) && !VECTOR_FLOAT_TYPE_P (ret)))\n+\t  return warn_mismatched_return_type (callexp, \"__vector(T)\");\n+\n+\ttree arg = TREE_TYPE (CALL_EXPR_ARG (callexp, 0));\n+\tif (!VECTOR_TYPE_P (arg)\n+\t    || (!VECTOR_INTEGER_TYPE_P (arg) && !VECTOR_FLOAT_TYPE_P (arg)))\n+\t  return warn_mismatched_argument (callexp, 0, \"__vector(T)\");\n+\n+\t/* Types have been validated, now issue errors about violations on the\n+\t   constraints of the intrinsic.  */\n+\tif (maybe_ne (TYPE_VECTOR_SUBPARTS (ret), TYPE_VECTOR_SUBPARTS (arg)))\n+\t  {\n+\t    /* %% Get the front-end type for the vector so the D type will be\n+\t       printed (this should really be handled by a D tree printer).  */\n+\t    unsigned HOST_WIDE_INT nunits;\n+\t    if (!TYPE_VECTOR_SUBPARTS (ret).is_constant (&nunits))\n+\t      break;\n+\n+\t    Type *inner = build_frontend_type (TREE_TYPE (arg));\n+\t    Type *vector = TypeVector::create (inner->sarrayOf (nunits));\n+\t    return warn_mismatched_argument (callexp, 0,\n+\t\t\t\t\t     build_ctype (vector), true);\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case INTRINSIC_EQUALMASK:\n+    case INTRINSIC_NOTEQUALMASK:\n+    case INTRINSIC_GREATERMASK:\n+    case INTRINSIC_GREATEREQUALMASK:\n+      {\n+\t/* Expects the signature:\n+\t   vector(T) equalMask(vector(T), vector(T));\n+\t   vector(T) notEqualMask(vector(T), vector(T));\n+\t   vector(T) greaterMask(vector(T), vector(T));\n+\t   vector(T) greateOrEqualMask(vector(T), vector(T));  */\n+\tgcc_assert (call_expr_nargs (callexp) == 2);\n+\n+\ttree vec0 = TREE_TYPE (CALL_EXPR_ARG (callexp, 0));\n+\ttree vec1 = TREE_TYPE (CALL_EXPR_ARG (callexp, 1));\n+\tif (!VECTOR_TYPE_P (TREE_TYPE (callexp))\n+\t    || !VECTOR_TYPE_P (vec0)\n+\t    || !VECTOR_TYPE_P (vec1)\n+\t    || TYPE_MAIN_VARIANT (vec0) != TYPE_MAIN_VARIANT (vec1))\n+\t  return warn_mismatched_return_type (callexp, \"__vector(T)\");\n+\n+\treturn false;\n+      }\n+    }\n+\n+  /* Generic mismatch warning if it hasn't already been handled.  */\n+  warning_at (EXPR_LOCATION (callexp), OPT_Wbuiltin_declaration_mismatch,\n+\t      \"mismatch in call of intrinsic function %qD\",  function);\n+  return true;\n+}\n+\n /* Construct a function call to the built-in function CODE, N is the number of\n    arguments, and the `...' parameters are the argument expressions.\n    The original call expression is held in CALLEXP.  */\n@@ -750,6 +1073,231 @@ expand_volatile_store (tree callexp)\n   return modify_expr (result, value);\n }\n \n+/* Expand a front-end intrinsic call to a vector comparison intrinsic, which is\n+   either a call to equalMask(), notEqualMask(), greaterMask(), or\n+   greaterOrEqualMask().  These intrinsics take two arguments, the signature to\n+   which can be either:\n+\n+\tvector(T) equalMask(vector(T) vec0, vector(T) vec1);\n+\tvector(T) notEqualMask(vector(T) vec0, vector(T) vec1);\n+\tvector(T) greaterMask(vector(T) vec0, vector(T) vec1);\n+\tvector(T) greaterOrEqualMask(vector(T) vec0, vector(T) vec1);\n+\n+   This performs an element-wise comparison between two vectors VEC0 and VEC1,\n+   returning a vector with signed integral elements.  */\n+\n+static tree\n+expand_intrinsic_vec_cond (tree_code code, tree callexp)\n+{\n+  tree vec0 = CALL_EXPR_ARG (callexp, 0);\n+  tree vec1 = CALL_EXPR_ARG (callexp, 1);\n+  tree type = TREE_TYPE (callexp);\n+\n+  tree cmp = fold_build2_loc (EXPR_LOCATION (callexp), code,\n+\t\t\t      truth_type_for (type), vec0, vec1);\n+  return fold_build3_loc (EXPR_LOCATION (callexp), VEC_COND_EXPR, type, cmp,\n+\t\t\t  build_minus_one_cst (type), build_zero_cst (type));\n+}\n+\n+/* Expand a front-end instrinsic call to convertvector().  This takes one\n+   argument, the signature to which is:\n+\n+\tvector(T) convertvector (vector(F) vec);\n+\n+   This converts a vector VEC to TYPE by casting every element in VEC to the\n+   element type of TYPE.  The original call expression is held in CALLEXP.  */\n+\n+static tree\n+expand_intrinsic_vec_convert (tree callexp)\n+{\n+  tree vec = CALL_EXPR_ARG (callexp, 0);\n+  tree type = TREE_TYPE (callexp);\n+\n+  /* Use VIEW_CONVERT for simple vector conversions.  */\n+  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (vec)))\n+       == TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n+      || (VECTOR_INTEGER_TYPE_P (TREE_TYPE (vec))\n+\t  && VECTOR_INTEGER_TYPE_P (type)\n+\t  && (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (vec)))\n+\t      == TYPE_PRECISION (TREE_TYPE (type)))))\n+    return build1_loc (EXPR_LOCATION (callexp), VIEW_CONVERT_EXPR, type, vec);\n+\n+  return build_call_expr_internal_loc (EXPR_LOCATION (callexp), IFN_VEC_CONVERT,\n+\t\t\t\t       type, 1, vec);\n+}\n+\n+/* Expand a front-end instrinsic call to blendvector().  This expects to take\n+   three arguments, the signature to which is:\n+\n+\tvector(T) blendvector (vector(T) vec0, vector(U) vec1, vector(M) mask);\n+\n+   This builds a VEC_COND_EXPR if VEC0, VEC1, and MASK are vector types, VEC0\n+   has the same type as VEC1, and the number of elements of VEC0, VEC1, and MASK\n+   are the same.  The original call expression is held in CALLEXP.  */\n+\n+static tree\n+expand_intrinsic_vec_blend (tree callexp)\n+{\n+  tree vec0 = CALL_EXPR_ARG (callexp, 0);\n+  tree vec1 = CALL_EXPR_ARG (callexp, 1);\n+  tree mask = CALL_EXPR_ARG (callexp, 2);\n+\n+  tree cmp = fold_build2_loc (EXPR_LOCATION (callexp), NE_EXPR,\n+\t\t\t      truth_type_for (TREE_TYPE (mask)),\n+\t\t\t      mask, build_zero_cst (TREE_TYPE (mask)));\n+\n+  tree ret = fold_build3_loc (EXPR_LOCATION (callexp), VEC_COND_EXPR,\n+\t\t\t      TREE_TYPE (callexp), cmp, vec0, vec1);\n+\n+  if (!CONSTANT_CLASS_P (vec0) || !CONSTANT_CLASS_P (vec1))\n+    ret = force_target_expr (ret);\n+\n+  return ret;\n+}\n+\n+/* Expand a front-end instrinsic call to shuffle().  This expects to take three\n+   arguments, the signature to which is:\n+\n+\tvector(T) shuffle (vector(T) vec0, vector(T) vec1, vector(M) mask);\n+\n+   This builds a VEC_PERM_EXPR if VEC0, VEC1, and MASK are vector types, VEC0\n+   has the same type as VEC1, and the number of elements of VEC0, VEC1, and MASK\n+   are the same.  The original call expression is held in CALLEXP.  */\n+\n+static tree\n+expand_intrinsic_vec_shuffle (tree callexp)\n+{\n+  tree vec0 = CALL_EXPR_ARG (callexp, 0);\n+  tree vec1 = CALL_EXPR_ARG (callexp, 1);\n+  tree mask = CALL_EXPR_ARG (callexp, 2);\n+\n+  return build3_loc (EXPR_LOCATION (callexp), VEC_PERM_EXPR,\n+\t\t     TREE_TYPE (callexp), vec0, vec1, mask);\n+}\n+\n+/* Expand a front-end instrinsic call to shufflevector().  This takes two\n+   positional arguments and a variadic list, the signature to which is:\n+\n+\tvector(TM) shuffle (vector(T) vec1, vector(T) vec2, index...);\n+\n+   This builds a VEC_PERM_EXPR if VEC0 and VEC1 are vector types, VEC0 has the\n+   same element type as VEC1, and the number of elements in INDEX is a valid\n+   power of two.  The original call expression is held in CALLEXP.  */\n+\n+static tree\n+expand_intrinsic_vec_shufflevector (tree callexp)\n+{\n+  tree vec0 = CALL_EXPR_ARG (callexp, 0);\n+  tree vec1 = CALL_EXPR_ARG (callexp, 1);\n+\n+  unsigned HOST_WIDE_INT v0elems, v1elems;\n+  TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec0)).is_constant (&v0elems);\n+  TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec1)).is_constant (&v1elems);\n+\n+  unsigned HOST_WIDE_INT num_indices = call_expr_nargs (callexp) - 2;\n+  unsigned HOST_WIDE_INT masklen = MAX (num_indices, MAX (v0elems, v1elems));\n+  unsigned HOST_WIDE_INT pad_size = (v0elems < masklen ? masklen - v0elems : 0);\n+  vec_perm_builder sel (masklen, masklen, 1);\n+\n+  unsigned n = 0;\n+  for (; n < num_indices; ++n)\n+    {\n+      tree idx = CALL_EXPR_ARG (callexp, n + 2);\n+      HOST_WIDE_INT iidx = tree_to_shwi (idx);\n+      /* VEC_PERM_EXPR does not allow different sized inputs.  */\n+      if ((unsigned HOST_WIDE_INT) iidx >= v0elems)\n+\tiidx += pad_size;\n+\n+      sel.quick_push (iidx);\n+    }\n+\n+  /* VEC_PERM_EXPR does not support a result that is smaller than the inputs.  */\n+  for (; n < masklen; ++n)\n+    sel.quick_push (n);\n+\n+  vec_perm_indices indices (sel, 2, masklen);\n+\n+  /* Pad out arguments to the common vector size.  */\n+  tree ret_type = build_vector_type (TREE_TYPE (TREE_TYPE (vec0)), masklen);\n+  if (v0elems < masklen)\n+    {\n+      constructor_elt elt = { NULL_TREE, build_zero_cst (TREE_TYPE (vec0)) };\n+      vec0 = build_constructor_single (ret_type, NULL_TREE, vec0);\n+      for (unsigned i = 1; i < masklen / v0elems; ++i)\n+        vec_safe_push (CONSTRUCTOR_ELTS (vec0), elt);\n+    }\n+\n+  if (v1elems < masklen)\n+    {\n+      constructor_elt elt = { NULL_TREE, build_zero_cst (TREE_TYPE (vec1)) };\n+      vec1 = build_constructor_single (ret_type, NULL_TREE, vec1);\n+      for (unsigned i = 1; i < masklen / v1elems; ++i)\n+        vec_safe_push (CONSTRUCTOR_ELTS (vec1), elt);\n+    }\n+\n+  tree mask_type = build_vector_type (build_nonstandard_integer_type\n+                (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (ret_type))), 1),\n+                masklen);\n+  tree ret = build3_loc (EXPR_LOCATION (callexp), VEC_PERM_EXPR, ret_type, vec0,\n+\t\t\t vec1, vec_perm_indices_to_tree (mask_type, indices));\n+\n+  /* Get the low part we are interested in.  */\n+  if (num_indices < masklen)\n+    {\n+      ret = build3_loc (EXPR_LOCATION (callexp), BIT_FIELD_REF,\n+\t\t\tTREE_TYPE (callexp), ret,\n+\t\t\tTYPE_SIZE (TREE_TYPE (callexp)), bitsize_zero_node);\n+      /* Wrap the low part operation in a TARGET_EXPR so it gets a separate\n+         temporary during gimplification.  */\n+      ret = force_target_expr (ret);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Expand a front-end instrinsic call to loadUnaligned().  This takes one\n+   argument, the signature to which is:\n+\n+\tvector(T) loadUnaligned (vector(T)* ptr)\n+\n+   This generates a load of a vector from an unaligned address PTR.\n+   The original call expression is held in CALLEXP.  */\n+\n+static tree\n+expand_intrinsic_vec_load_unaligned (tree callexp)\n+{\n+  tree ptr = CALL_EXPR_ARG (callexp, 0);\n+\n+  tree unaligned_type = build_variant_type_copy (TREE_TYPE (TREE_TYPE (ptr)));\n+  SET_TYPE_ALIGN (unaligned_type, 1 * BITS_PER_UNIT);\n+  TYPE_USER_ALIGN (unaligned_type) = 1;\n+\n+  tree load = indirect_ref (unaligned_type, ptr);\n+  return convert (TREE_TYPE (callexp), load);\n+}\n+\n+/* Expand a front-end instrinsic call to storeUnaligned().  This takes two\n+   arguments, the signature to which is:\n+\n+\tvector(T) storeUnaligned (vector(T)* ptr, vector(T) value)\n+\n+   This generates an assignment of a vector VALUE to an unaligned address PTR.\n+   The original call expression is held in CALLEXP.  */\n+\n+static tree\n+expand_intrinsic_vec_store_unaligned (tree callexp)\n+{\n+  tree ptr = CALL_EXPR_ARG (callexp, 0);\n+  tree vec = CALL_EXPR_ARG (callexp, 1);\n+\n+  tree unaligned_type = build_variant_type_copy (TREE_TYPE (TREE_TYPE (ptr)));\n+  SET_TYPE_ALIGN (unaligned_type, 1 * BITS_PER_UNIT);\n+  TYPE_USER_ALIGN (unaligned_type) = 1;\n+\n+  tree load = indirect_ref (unaligned_type, ptr);\n+  return build_assign (MODIFY_EXPR, load, vec);\n+}\n+\n /* If CALLEXP is for an intrinsic , expand and return inlined compiler\n    generated instructions.  Most map directly to GCC builtins, others\n    require a little extra work around them.  */\n@@ -766,6 +1314,15 @@ maybe_expand_intrinsic (tree callexp)\n   if (DECL_BUILT_IN_CTFE (callee) && !doing_semantic_analysis_p)\n     return callexp;\n \n+  /* Gate the expansion of the intrinsic with constraint checks, if any fail\n+     then bail out without any lowering.  */\n+  if (maybe_warn_intrinsic_mismatch (callee, callexp))\n+    {\n+      /* Reset the built-in flag so that we don't trip fold_builtin.  */\n+      set_decl_built_in_function (callee, NOT_BUILT_IN, 0);\n+      return callexp;\n+    }\n+\n   intrinsic_code intrinsic = DECL_INTRINSIC_CODE (callee);\n   built_in_function code;\n \n@@ -913,6 +1470,36 @@ maybe_expand_intrinsic (tree callexp)\n     case INTRINSIC_VSTORE64:\n       return expand_volatile_store (callexp);\n \n+    case INTRINSIC_LOADUNALIGNED:\n+      return expand_intrinsic_vec_load_unaligned (callexp);\n+\n+    case INTRINSIC_STOREUNALIGNED:\n+      return expand_intrinsic_vec_store_unaligned (callexp);\n+\n+    case INTRINSIC_SHUFFLE:\n+      return expand_intrinsic_vec_shuffle (callexp);\n+\n+    case INTRINSIC_SHUFFLEVECTOR:\n+      return expand_intrinsic_vec_shufflevector (callexp);\n+\n+    case INTRINSIC_CONVERTVECTOR:\n+      return expand_intrinsic_vec_convert (callexp);\n+\n+    case INTRINSIC_BLENDVECTOR:\n+      return expand_intrinsic_vec_blend (callexp);\n+\n+    case INTRINSIC_EQUALMASK:\n+      return expand_intrinsic_vec_cond (EQ_EXPR, callexp);\n+\n+    case INTRINSIC_NOTEQUALMASK:\n+      return expand_intrinsic_vec_cond (NE_EXPR, callexp);\n+\n+    case INTRINSIC_GREATERMASK:\n+      return expand_intrinsic_vec_cond (GT_EXPR, callexp);\n+\n+    case INTRINSIC_GREATEREQUALMASK:\n+      return expand_intrinsic_vec_cond (GE_EXPR, callexp);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "b8d1ec50d57c3913d022f877447430e6743e3ae4", "filename": "gcc/d/intrinsics.def", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Fd%2Fintrinsics.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Fd%2Fintrinsics.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.def?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -252,5 +252,28 @@ DEF_D_BUILTIN (INTRINSIC_C_VA_ARG, BUILT_IN_NONE, \"va_arg\", \"core.stdc.stdarg\",\n DEF_D_BUILTIN (INTRINSIC_VASTART, BUILT_IN_NONE, \"va_start\", \"core.stdc.stdarg\",\n \t       \"FJ@7va_listK@1TZv\")\n \n+/* gcc.simd intrinsics.  */\n+\n+DEF_D_BUILTIN (INTRINSIC_LOADUNALIGNED, BUILT_IN_NONE, \"loadUnaligned\",\n+\t       \"gcc.simd\", \"FP@1VZ@1V\")\n+DEF_D_BUILTIN (INTRINSIC_STOREUNALIGNED, BUILT_IN_NONE, \"storeUnaligned\",\n+\t       \"gcc.simd\", \"FP@1V@1VZ@1V\")\n+DEF_D_BUILTIN (INTRINSIC_SHUFFLE, BUILT_IN_NONE, \"shuffle\", \"gcc.simd\",\n+\t       \"F@2V0@2V1@1MZ@2V0\")\n+DEF_D_BUILTIN (INTRINSIC_SHUFFLEVECTOR, BUILT_IN_NONE, \"shufflevector\",\n+\t       \"gcc.simd\", \"F@2V1@2V2@1MZNhH@1M@\")\n+DEF_D_BUILTIN (INTRINSIC_CONVERTVECTOR, BUILT_IN_NONE, \"convertvector\",\n+\t       \"gcc.simd\", \"F@1TZ@1V\")\n+DEF_D_BUILTIN (INTRINSIC_BLENDVECTOR, BUILT_IN_NONE, \"blendvector\", \"gcc.simd\",\n+\t       \"F@2V0@2V1@1MZ@2V0\")\n+DEF_D_BUILTIN (INTRINSIC_EQUALMASK, BUILT_IN_NONE, \"equalMask\", \"gcc.simd\",\n+\t       \"F@1V@1VZ@1V\")\n+DEF_D_BUILTIN (INTRINSIC_NOTEQUALMASK, BUILT_IN_NONE, \"notEqualMask\",\n+\t       \"gcc.simd\", \"F@1V@1VZ@1V\")\n+DEF_D_BUILTIN (INTRINSIC_GREATERMASK, BUILT_IN_NONE, \"greaterMask\", \"gcc.simd\",\n+\t       \"F@1V@1VZ@1V\")\n+DEF_D_BUILTIN (INTRINSIC_GREATEREQUALMASK, BUILT_IN_NONE,\n+\t       \"greaterOrEqualMask\", \"gcc.simd\", \"F@1V@1VZ@1V\")\n+\n #undef DEF_D_BUILTIN\n #undef DEF_CTFE_BUILTIN"}, {"sha": "53406474a851cc54331b1134f9dec919b60d106f", "filename": "gcc/testsuite/gdc.dg/Wbuiltin_declaration_mismatch1.d", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch1.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "previous_filename": "gcc/testsuite/gdc.dg/Wbuiltin_declaration_mismatch.d"}, {"sha": "9e90c15deb602383af04ec331bf9c862e5022a64", "filename": "gcc/testsuite/gdc.dg/Wbuiltin_declaration_mismatch2.d", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch2.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,250 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do compile { target { avx_runtime || vect_sizes_16B_8B } } }\n+module gcc.simd;\n+\n+alias int4 = __vector(int[4]);\n+alias short8 = __vector(short[8]);\n+alias float4 = __vector(float[4]);\n+alias byte16 = __vector(byte[16]);\n+struct fake4 { int[4] v; }\n+enum f = fake4();\n+\n+void test_load_store()\n+{\n+    loadUnaligned!int(null); // { dg-warning \"mismatch in return type\" }\n+    loadUnaligned!double(null); // { dg-warning \"mismatch in return type\" }\n+    loadUnaligned!int4(null);\n+    loadUnaligned!short8(null);\n+    loadUnaligned!float4(null);\n+    loadUnaligned!byte16(null);\n+    loadUnaligned!fake4(null); // { dg-warning \"mismatch in return type\" }\n+\n+    storeUnaligned!int(null, 1); // { dg-warning \"mismatch in return type\" }\n+    storeUnaligned!double(null, 1); // { dg-warning \"mismatch in return type\" }\n+    storeUnaligned!int4(null, 1);\n+    storeUnaligned!short8(null, 1);\n+    storeUnaligned!float4(null, 1);\n+    storeUnaligned!byte16(null, 1);\n+    storeUnaligned!fake4(null, f); // { dg-warning \"mismatch in return type\" }\n+}\n+\n+void test_shuffle()\n+{\n+    shuffle!(int, int, int)(0, 0, 0); // { dg-warning \"mismatch in return type\" }\n+    shuffle!(double, int, int)(0, 0, 0); // { dg-warning \"mismatch in return type\" }\n+    shuffle!(fake4, int, int)(f, 0, 0); // { dg-warning \"mismatch in return type\" }\n+\n+    shuffle!(int4, int, int)(0, 0, 0); // { dg-warning \"mismatch in argument 2\" }\n+    shuffle!(int4, double, int)(0, 0, 0); // { dg-warning \"mismatch in argument 2\" }\n+    shuffle!(int4, fake4, int)(0, f, 0); // { dg-warning \"mismatch in argument 2\" }\n+\n+    shuffle!(int4, int4, int)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    shuffle!(int4, int4, double)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    shuffle!(int4, int4, fake4)(0, 0, f); // { dg-warning \"mismatch in argument 3\" }\n+\n+    shuffle!(int4, int4, int4)(0, 0, 0);\n+    shuffle!(int4, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(int4, float4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(int4, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(int4, int4, short8)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(int4, int4, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(int4, int4, byte16)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+\n+    shuffle!(float4, int4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(float4, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(float4, float4, int4)(0, 0, 0);\n+    shuffle!(float4, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(float4, float4, short8)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(float4, float4, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(float4, float4, byte16)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+\n+    shuffle!(short8, int4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(short8, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(short8, float4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(short8, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(short8, short8, short8)(0, 0, 0);\n+    shuffle!(short8, short8, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(short8, short8, byte16)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+\n+    shuffle!(byte16, int4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(byte16, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(byte16, float4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shuffle!(byte16, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(byte16, byte16, short8)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(byte16, byte16, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    shuffle!(byte16, byte16, byte16)(0, 0, 0);\n+}\n+\n+void test_shufflevector()\n+{\n+    shufflevector!(int, int4, int)(0, 0, 0); // { dg-warning \"mismatch in argument 1\" }\n+    shufflevector!(double, int4, int)(0, 0, 0); // { dg-warning \"mismatch in argument 1\" }\n+    shufflevector!(fake4, int4, int)(f, 0, 0); // { dg-warning \"mismatch in argument 1\" }\n+\n+    shufflevector!(int4, int, int)(0, 0, 0); // { dg-warning \"mismatch in argument 2\" }\n+    shufflevector!(int4, double, int)(0, 0, 0); // { dg-warning \"mismatch in argument 2\" }\n+    shufflevector!(int4, int4, int)(0, 0, 0);\n+    shufflevector!(int4, short8, int)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shufflevector!(int4, float4, int)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shufflevector!(int4, byte16, int)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    shufflevector!(int4, fake4, int)(0, f, 0); // { dg-warning \"mismatch in argument 2\" }\n+\n+    shufflevector!(int4, int4, double)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    shufflevector!(int4, int4, int4)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    shufflevector!(int4, int4, short8)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    shufflevector!(int4, int4, float4)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    shufflevector!(int4, int4, byte16)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+\n+    shufflevector!(int4, int4, int, double)(0, 0, 0, 0); // { dg-warning \"mismatch in argument 4\" }\n+    shufflevector!(int4, int4, int, int, double, int)(0, 0, 0, 0, 0, 0); // { dg-warning \"mismatch in argument 5\" }\n+    shufflevector!(int4, int4, int, int, int, double)(0, 0, 0, 0, 0, 0); // { dg-warning \"mismatch in argument 6\" }\n+\n+    int i;\n+    shufflevector!(int4, int4, int)(0, 0, i); // { dg-error \"argument .i. cannot be read at compile time\" }\n+    shufflevector!(int4, int4, int)(0, 0, -1u); // { dg-error \"element index .-1. is out of bounds\" }\n+    shufflevector!(int4, int4, int)(0, 0, 8); // { dg-error \"element index .8. is out of bounds\" }\n+}\n+\n+void test_convertvector()\n+{\n+    convertvector!(int, int)(0); // { dg-warning \"mismatch in return type\" }\n+    convertvector!(double, int)(0); // { dg-warning \"mismatch in return type\" }\n+    convertvector!(fake4, int)(0); // { dg-warning \"mismatch in return type\" }\n+\n+    convertvector!(int4, int)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(int4, double)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(int4, int4)(0);\n+    convertvector!(int4, short8)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(int4, float4)(0);\n+    convertvector!(int4, byte16)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(int4, fake4)(f); // { dg-warning \"mismatch in argument 1\" }\n+\n+    convertvector!(short8, int)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(short8, double)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(short8, int4)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(short8, short8)(0);\n+    convertvector!(short8, float4)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(short8, byte16)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(short8, fake4)(f); // { dg-warning \"mismatch in argument 1\" }\n+\n+    convertvector!(float4, int)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(float4, double)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(float4, int4)(0);\n+    convertvector!(float4, short8)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(float4, float4)(0);\n+    convertvector!(float4, byte16)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(float4, fake4)(f); // { dg-warning \"mismatch in argument 1\" }\n+\n+    convertvector!(byte16, int)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(byte16, double)(0); // { dg-warning \"mismatch in argument 1\" }\n+    convertvector!(byte16, int4)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(byte16, short8)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(byte16, float4)(0); // { dg-error \"mismatch in argument 1\" }\n+    convertvector!(byte16, byte16)(0);\n+    convertvector!(byte16, fake4)(f); // { dg-warning \"mismatch in argument 1\" }\n+}\n+\n+void test_blendvector()\n+{\n+    blendvector!(int, int, int)(0, 0, 0); // { dg-warning \"mismatch in return type\" }\n+    blendvector!(double, int, int)(0, 0, 0); // { dg-warning \"mismatch in return type\" }\n+    blendvector!(fake4, int, int)(f, 0, 0); // { dg-warning \"mismatch in return type\" }\n+\n+    blendvector!(int4, int, int)(0, 0, 0); // { dg-warning \"mismatch in argument 2\" }\n+    blendvector!(int4, double, int)(0, 0, 0); // { dg-warning \"mismatch in argument 2\" }\n+    blendvector!(int4, fake4, int)(0, f, 0); // { dg-warning \"mismatch in argument 2\" }\n+\n+    blendvector!(int4, int4, int)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    blendvector!(int4, int4, double)(0, 0, 0); // { dg-warning \"mismatch in argument 3\" }\n+    blendvector!(int4, int4, fake4)(0, 0, f); // { dg-warning \"mismatch in argument 3\" }\n+\n+    blendvector!(int4, int4, int4)(0, 0, 0);\n+    blendvector!(int4, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(int4, float4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(int4, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(int4, int4, short8)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(int4, int4, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(int4, int4, byte16)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+\n+    blendvector!(float4, int4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(float4, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(float4, float4, int4)(0, 0, 0);\n+    blendvector!(float4, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(float4, float4, short8)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(float4, float4, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(float4, float4, byte16)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+\n+    blendvector!(short8, int4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(short8, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(short8, float4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(short8, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(short8, short8, short8)(0, 0, 0);\n+    blendvector!(short8, short8, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(short8, short8, byte16)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+\n+    blendvector!(byte16, int4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(byte16, short8, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(byte16, float4, int4)(0, 0, 0); // { dg-error \"mismatch in argument 2\" }\n+    blendvector!(byte16, byte16, int4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(byte16, byte16, short8)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(byte16, byte16, float4)(0, 0, 0); // { dg-error \"mismatch in argument 3\" }\n+    blendvector!(byte16, byte16, byte16)(0, 0, 0);\n+}\n+\n+void test_comparison()\n+{\n+    equalMask!int(0, 0); // { dg-warning \"mismatch in return type\" }\n+    equalMask!double(0, 0); // { dg-warning \"mismatch in return type\" }\n+    equalMask!int4(0, 0);\n+    equalMask!short8(0, 0);\n+    equalMask!float4(0, 0);\n+    equalMask!byte16(0, 0);\n+    equalMask!fake4(f, f); // { dg-warning \"mismatch in return type\" }\n+\n+    notEqualMask!int(0, 0); // { dg-warning \"mismatch in return type\" }\n+    notEqualMask!double(0, 0); // { dg-warning \"mismatch in return type\" }\n+    notEqualMask!int4(0, 0);\n+    notEqualMask!short8(0, 0);\n+    notEqualMask!float4(0, 0);\n+    notEqualMask!byte16(0, 0);\n+    notEqualMask!fake4(f, f); // { dg-warning \"mismatch in return type\" }\n+\n+    greaterMask!int(0, 0); // { dg-warning \"mismatch in return type\" }\n+    greaterMask!double(0, 0); // { dg-warning \"mismatch in return type\" }\n+    greaterMask!int4(0, 0);\n+    greaterMask!short8(0, 0);\n+    greaterMask!float4(0, 0);\n+    greaterMask!byte16(0, 0);\n+    greaterMask!fake4(f, f); // { dg-warning \"mismatch in return type\" }\n+\n+    greaterOrEqualMask!int(0, 0); // { dg-warning \"mismatch in return type\" }\n+    greaterOrEqualMask!double(0, 0); // { dg-warning \"mismatch in return type\" }\n+    greaterOrEqualMask!int4(0, 0);\n+    greaterOrEqualMask!short8(0, 0);\n+    greaterOrEqualMask!float4(0, 0);\n+    greaterOrEqualMask!byte16(0, 0);\n+    greaterOrEqualMask!fake4(f, f); // { dg-warning \"mismatch in return type\" }\n+}\n+\n+// The following declarations of the simd intrinsics are without any guards\n+// to verify `d/intrinsics.cc` is doing checks to prevent invalid lowerings.\n+V loadUnaligned(V)(const V*);\n+V storeUnaligned(V)(V*, V);\n+\n+V0 shuffle(V0, V1, M)(V0, V1, M);\n+\n+// Use overloads to test different argument positions.\n+template E(V) { alias typeof(V.array[0]) E; }\n+enum isV(T) = is(T : __vector(V[N]), V, size_t N);\n+\n+__vector(E!V1[M.length]) shufflevector(V1, V2, M...)(V1, V2, M) if (isV!V1 && !isV!V2);\n+__vector(E!V2[M.length]) shufflevector(V1, V2, M...)(V1, V2, M) if (isV!V2 && !isV!V1);\n+__vector(E!V1[M.length]) shufflevector(V1, V2, M...)(V1, V2, M) if (isV!V1 && isV!V2);\n+\n+V convertvector(V, T)(T);\n+V0 blendvector(V0, V1, M)(V0, V1, M);\n+\n+V equalMask(V)(V, V);\n+V notEqualMask(V)(V, V);\n+V greaterMask(V)(V, V);\n+V greaterOrEqualMask(V)(V, V);"}, {"sha": "42459bd69d7ebb3f2c3c16c424bb6b35ecda645e", "filename": "gcc/testsuite/gdc.dg/torture/simd_blendvector.d", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_blendvector.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_blendvector.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_blendvector.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,345 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import gcc.simd;\n+\n+void testblendvector(V, VI = V)()\n+{\n+    alias E = typeof(V.array[0]);\n+    enum numElements = V.sizeof / E.sizeof;\n+\n+    static if (numElements == 16)\n+    {\n+        // Test fragment for vectors with 16 elements\n+        immutable V[5] in1 =\n+            [[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ]];\n+\n+        immutable V in2 =\n+            [ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45 ];\n+\n+        immutable VI[5] mask1 =\n+            [[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n+             [ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n+             [ 7, 6, 5, 4, 16, 17, 18, 19, 31, 30, 29, 28, 3, 2, 1, 0 ],\n+             [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n+             [ 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 ]];\n+\n+        immutable V[5] out1 =\n+            [[30, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],\n+             [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],\n+             [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 45],\n+             [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45],\n+             [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]];\n+    }\n+    else static if (numElements == 8)\n+    {\n+        // Test fragment for vectors with 8 elements\n+        static if (is(E == uint))\n+        {\n+            enum E A1 = 0x11121314;\n+            enum E B1 = 0x21222324;\n+            enum E C1 = 0x31323334;\n+            enum E D1 = 0x41424344;\n+            enum E E1 = 0x51525354;\n+            enum E F1 = 0x61626364;\n+            enum E G1 = 0x71727374;\n+            enum E H1 = 0x81828384;\n+\n+            enum E A2 = 0x91929394;\n+            enum E B2 = 0xa1a2a3a4;\n+            enum E C2 = 0xb1b2b3b4;\n+            enum E D2 = 0xc1c2c3c4;\n+            enum E E2 = 0xd1d2d3d4;\n+            enum E F2 = 0xe1e2e3e4;\n+            enum E G2 = 0xf1f2f3f4;\n+            enum E H2 = 0x01020304;\n+        }\n+        else static if (is(E == ushort))\n+        {\n+            enum E A1 = 0x1112;\n+            enum E B1 = 0x2122;\n+            enum E C1 = 0x3132;\n+            enum E D1 = 0x4142;\n+            enum E E1 = 0x5152;\n+            enum E F1 = 0x6162;\n+            enum E G1 = 0x7172;\n+            enum E H1 = 0x8182;\n+\n+            enum E A2 = 0x9192;\n+            enum E B2 = 0xa1a2;\n+            enum E C2 = 0xb1b2;\n+            enum E D2 = 0xc1c2;\n+            enum E E2 = 0xd1d2;\n+            enum E F2 = 0xe1e2;\n+            enum E G2 = 0xf1f2;\n+            enum E H2 = 0x0102;\n+        }\n+        else static if (is(E == ubyte))\n+        {\n+            enum E A1 = 0x11;\n+            enum E B1 = 0x12;\n+            enum E C1 = 0x13;\n+            enum E D1 = 0x14;\n+            enum E E1 = 0x15;\n+            enum E F1 = 0x16;\n+            enum E G1 = 0x17;\n+            enum E H1 = 0x18;\n+\n+            enum E A2 = 0xf1;\n+            enum E B2 = 0xf2;\n+            enum E C2 = 0xf3;\n+            enum E D2 = 0xf4;\n+            enum E E2 = 0xf5;\n+            enum E F2 = 0xf6;\n+            enum E G2 = 0xf7;\n+            enum E H2 = 0xf8;\n+        }\n+        else\n+            enum unsupported = true;\n+\n+        static if (!__traits(compiles, unsupported))\n+        {\n+            immutable V[6] in1 =\n+                [[ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ]];\n+\n+\n+            immutable V in2 =\n+                [ A2, B2, C2, D2, E2, F2, G2, H2 ];\n+\n+            immutable VI[6] mask1 =\n+                [[ 0,  1,  2 , 3 , 4 , 5 , 6 , 0 ],\n+                 [ 8,  9,  0, 11, 12, 13,  0, 15 ],\n+                 [ 0,  8,  1,  0,  2,  0,  3, 11 ],\n+                 [ 0, 15,  4, 11,  0,  3,  7,  8 ],\n+                 [ 0,  0,  0,  0,  0,  0,  0,  0 ],\n+                 [ 0x1e, 0x2e, 0x3e, 0x4e, 0x5e, 0x6e, 0x7e, 0x8e ]];\n+\n+            immutable V[6] out1 =\n+                [[ A2, B1, C1, D1, E1, F1, G1, H2 ],\n+                 [ A1, B1, C2, D1, E1, F1, G2, H1 ],\n+                 [ A2, B1, C1, D2, E1, F2, G1, H1 ],\n+                 [ A2, B1, C1, D1, E2, F1, G1, H1 ],\n+                 [ A2, B2, C2, D2, E2, F2, G2, H2 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ]];\n+        }\n+    }\n+    else static if (numElements == 4)\n+    {\n+        // Test fragment for vectors with 4 elements\n+        static if (is(E == double))\n+        {\n+            enum E A = 0.69314718055994530942;\n+            enum E B = 2.7182818284590452354;\n+            enum E C = 2.30258509299404568402;\n+            enum E D = 1.4426950408889634074;\n+\n+            enum E W = 0.31830988618379067154;\n+            enum E X = 3.14159265358979323846;\n+            enum E Y = 1.41421356237309504880;\n+            enum E Z = 0.70710678118654752440;\n+        }\n+        else static if (is(E == float))\n+        {\n+            enum E A = 0.69314718055994530942f;\n+            enum E B = 2.7182818284590452354f;\n+            enum E C = 2.30258509299404568402f;\n+            enum E D = 1.4426950408889634074f;\n+\n+            enum E W = 0.31830988618379067154f;\n+            enum E X = 3.14159265358979323846f;\n+            enum E Y = 1.41421356237309504880f;\n+            enum E Z = 0.70710678118654752440f;\n+        }\n+        else static if (is(E == ulong))\n+        {\n+            enum E A = 0x1112131415161718;\n+            enum E B = 0x2122232425262728;\n+            enum E C = 0x3132333435363738;\n+            enum E D = 0x4142434445464748;\n+\n+            enum E W = 0xc1c2c3c4c5c6c7c8;\n+            enum E X = 0xd1d2d3d4d5d6d7d8;\n+            enum E Y = 0xe1e2e3e4e5e6e7e8;\n+            enum E Z = 0xf1f2f3f4f5f6f7f8;\n+        }\n+        else static if (is(E == uint))\n+        {\n+            enum E A = 0x11121314;\n+            enum E B = 0x21222324;\n+            enum E C = 0x31323334;\n+            enum E D = 0x41424344;\n+\n+            enum E W = 0xc1c2c3c4;\n+            enum E X = 0xd1d2d3d4;\n+            enum E Y = 0xe1e2e3e4;\n+            enum E Z = 0xf1f2f3f4;\n+        }\n+        else\n+            enum unsupported = true;\n+\n+        static if (!__traits(compiles, unsupported))\n+        {\n+            immutable V[6] in1 =\n+                [[ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ]];\n+\n+            immutable V in2 = [ W, X, Y, Z ];\n+\n+            immutable VI[6] mask1 =\n+                [[ 0, 1, 2, 3 ],\n+                 [ 4, 0, 6, 7 ],\n+                 [ 0, 4, 0, 5 ],\n+                 [ 0, 7, 4, 0 ],\n+                 [ 0, 0, 0, 0 ],\n+                 [ 7, 7, 7, 7 ]];\n+\n+            immutable V[6] out1 =\n+                [[ W, B, C, D ],\n+                 [ A, X, C, D ],\n+                 [ W, B, Y, D ],\n+                 [ W, B, C, Z ],\n+                 [ W, X, Y, Z ],\n+                 [ A, B, C, D ]];\n+        }\n+    }\n+    else static if (numElements == 2)\n+    {\n+        // Test fragment for vectors with 2 elements\n+        static if (is(E == double))\n+        {\n+            enum E A = 0.69314718055994530942;\n+            enum E B = 2.7182818284590452354;\n+\n+            enum E X = 3.14159265358979323846;\n+            enum E Y = 1.41421356237309504880;\n+        }\n+        else static if (is(E == float))\n+        {\n+            enum E A = 0.69314718055994530942f;\n+            enum E B = 2.7182818284590452354f;\n+\n+            enum E X = 3.14159265358979323846f;\n+            enum E Y = 1.41421356237309504880f;\n+        }\n+        else static if (is(E == ulong))\n+        {\n+            enum E A = 0x1112131415161718;\n+            enum E B = 0x2122232425262728;\n+\n+            enum E X = 0xc1c2c3c4c5c6c7c8;\n+            enum E Y = 0xd1d2d3d4d5d6d7d8;\n+        }\n+        else static if (is(E == uint))\n+        {\n+            enum E A = 0x11121314;\n+            enum E B = 0x21222324;\n+\n+            enum E X = 0xd1d2d3d4;\n+            enum E Y = 0xe1e2e3e4;\n+        }\n+        else\n+            enum unsupported = true;\n+\n+        static if (!__traits(compiles, unsupported))\n+        {\n+            immutable V[7] in1 =\n+                [[ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ]];\n+\n+            immutable V in2 = [ X, Y ];\n+\n+            immutable VI[7] mask1 =\n+                [[ 0, 1 ],\n+                 [ 2, 3 ],\n+                 [ 0, 2 ],\n+                 [ 2, 1 ],\n+                 [ 3, 0 ],\n+                 [ 0, 0 ],\n+                 [ 3, 3 ]];\n+\n+            immutable V[7] out1 =\n+                [[ X, B ],\n+                 [ A, B ],\n+                 [ X, B ],\n+                 [ A, B ],\n+                 [ A, Y ],\n+                 [ X, Y ],\n+                 [ A, B ]];\n+        }\n+    }\n+    else\n+        enum unsupported = true;\n+\n+    static if (!__traits(compiles, unsupported))\n+    {\n+        static foreach (i; 0 .. in1.length)\n+            assert(blendvector(in1[i], in2, mask1[i]).array == out1[i].array);\n+    }\n+}\n+\n+void main()\n+{\n+    static if (__traits(compiles, __vector(ubyte[16])))\n+        testblendvector!(__vector(ubyte[16]))();\n+\n+    static if (__traits(compiles, __vector(ushort[16])))\n+        testblendvector!(__vector(ushort[16]))();\n+\n+    static if (__traits(compiles, __vector(ubyte[8])))\n+        testblendvector!(__vector(ubyte[8]))();\n+\n+    static if (__traits(compiles, __vector(ushort[8])))\n+        testblendvector!(__vector(ushort[8]))();\n+\n+    static if (__traits(compiles, __vector(uint[8])))\n+        testblendvector!(__vector(uint[8]))();\n+\n+    static if (__traits(compiles, __vector(ulong[4])))\n+    {\n+        testblendvector!(__vector(ulong[4]));\n+\n+        static if (__traits(compiles, __vector(double[4])))\n+            testblendvector!(__vector(double[4]), __vector(ulong[4]));\n+    }\n+\n+    static if (__traits(compiles, __vector(uint[4])))\n+    {\n+        testblendvector!(__vector(uint[4]));\n+\n+        static if (__traits(compiles, __vector(float[4])))\n+            testblendvector!(__vector(float[4]), __vector(uint[4]));\n+    }\n+\n+    static if (__traits(compiles, __vector(ulong[2])))\n+    {\n+        testblendvector!(__vector(ulong[2]));\n+\n+        static if (__traits(compiles, __vector(double[2])))\n+            testblendvector!(__vector(double[2]), __vector(ulong[2]));\n+    }\n+\n+    static if (__traits(compiles, __vector(uint[2])))\n+    {\n+        testblendvector!(__vector(uint[2]));\n+\n+        static if (__traits(compiles, __vector(float[2])))\n+            testblendvector!(__vector(float[2]), __vector(uint[2]));\n+    }\n+}"}, {"sha": "15489567b75658533b5f73660dfc5052a43c3921", "filename": "gcc/testsuite/gdc.dg/torture/simd_cond.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_cond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_cond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_cond.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,17 @@\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+import gcc.simd;\n+\n+void main()\n+{\n+    static if (__traits(compiles, __vector(int[4])))\n+    {\n+        __gshared __vector(int[4]) a = [1,3,5,7];\n+        __gshared __vector(int[4]) b = [2,3,4,5];\n+\n+        assert(equalMask(a, b).array == [0,-1,0,0]);\n+        assert(notEqualMask(a, b).array == [-1,0,-1,-1]);\n+        assert(greaterMask(a, b).array == [0,0,-1,-1]);\n+        assert(greaterOrEqualMask(a, b).array == [0,-1,-1,-1]);\n+    }\n+}"}, {"sha": "0d6b18e1e5c081e435aa91c9076cd32cac08641f", "filename": "gcc/testsuite/gdc.dg/torture/simd_convertvector.d", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_convertvector.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_convertvector.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_convertvector.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,122 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import gcc.simd;\n+\n+void main ()\n+{\n+    static if (__traits(compiles, __vector(int[4])))\n+        alias int4 = __vector(int[4]);\n+    static if (__traits(compiles, __vector(uint[4])))\n+        alias uint4 = __vector(uint[4]);\n+    static if (__traits(compiles, __vector(float[4])))\n+        alias float4 = __vector(float[4]);\n+    static if (__traits(compiles, __vector(double[4])))\n+        alias double4 = __vector(double[4]);\n+\n+    static if (__traits(compiles, int4))\n+    {\n+        union U1 { int4 v; int[4] a; }\n+        U1 u1;\n+    }\n+    static if (__traits(compiles, uint4))\n+    {\n+        union U2 { uint4 v; uint[4] a; }\n+        U2 u2;\n+    }\n+    static if (__traits(compiles, float4))\n+    {\n+        union U3 { float4 v; float[4] a; }\n+        U3 u3;\n+    }\n+    static if (__traits(compiles, double4))\n+    {\n+        union U4 { double4 v; double[4] a; }\n+        U4 u4;\n+    }\n+\n+    static if (__traits(compiles, u1) && __traits(compiles, u2))\n+    {\n+        static void f1(ref uint4 x, out int4 y)\n+        {\n+            y = convertvector!int4(x);\n+        }\n+        static foreach (i; 0 .. 4)\n+            u2.a[i] = i * 2;\n+        f1(u2.v, u1.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u1.a[i] == i * 2);\n+    }\n+\n+    static if (__traits(compiles, u1) && __traits(compiles, u3))\n+    {\n+        static void f2(ref float4 x, out int4 y)\n+        {\n+            y = convertvector!int4(x);\n+        }\n+\n+        static void f3(ref int4 x, out float4 y)\n+        {\n+            y = convertvector!float4(x);\n+        }\n+\n+        static foreach (i; 0 .. 4)\n+            u3.a[i] = i - 2.25f;\n+        f2(u3.v, u1.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u1.a[i] == (i == 3 ? 0 : i - 2));\n+\n+        static foreach (i; 0 .. 4)\n+            u3.a[i] = i + 0.75f;\n+        f2(u3.v, u1.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u1.a[i] == i);\n+\n+        static foreach (i; 0 .. 4)\n+            u1.a[i] = 7 * i - 5;\n+        f3(u1.v, u3.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u3.a[i] == 7 * i - 5);\n+    }\n+    static if (__traits(compiles, u1) && __traits(compiles, u4))\n+    {\n+        static void f4(ref double4 x, out int4 y)\n+        {\n+            y = convertvector!int4(x);\n+        }\n+\n+        static void f5(ref int4 x, out double4 y)\n+        {\n+            y = convertvector!double4(x);\n+        }\n+\n+        static foreach (i; 0 .. 4)\n+            u4.a[i] = i - 2.25;\n+        f4(u4.v, u1.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u1.a[i] == (i == 3 ? 0 : i - 2));\n+\n+        static foreach (i; 0 .. 4)\n+            u4.a[i] = i + 0.75;\n+        f4(u4.v, u1.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u1.a[i] == i);\n+\n+        static foreach (i; 0 .. 4)\n+            u1.a[i] = 7 * i - 5;\n+        f5(u1.v, u4.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u4.a[i] == 7 * i - 5);\n+    }\n+    static if (__traits(compiles, u4))\n+    {\n+        static void f6(out double4 x)\n+        {\n+            int4 a = [1, 2, -3, -4];\n+            x = convertvector!double4(a);\n+        }\n+\n+        f6(u4.v);\n+        static foreach (i; 0 .. 4)\n+            assert(u4.a[i] == (i >= 2 ? -1 - i : i + 1));\n+    }\n+}"}, {"sha": "188ffda983721bbc3999521751872bf68aac2892", "filename": "gcc/testsuite/gdc.dg/torture/simd_load.d", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_load.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_load.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_load.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,52 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import gcc.simd;\n+\n+void main()\n+{\n+    ubyte[32] data;\n+    foreach (i; 0..data.length)\n+    {   \n+        data[i] = cast(ubyte)i;\n+    }\n+\n+    // to test all alignments from 1 ~ 16\n+    foreach (i; 0..16)\n+    {\n+        ubyte* d = &data[i];\n+\n+        void test(T)()\n+        {\n+            // load the data\n+            T v = loadUnaligned(cast(T*)d);\n+\n+            // check that the data was loaded correctly\n+            ubyte* ptrToV = cast(ubyte*)&v;\n+            foreach (j; 0..T.sizeof)\n+                assert(ptrToV[j] == d[j]);\n+        }\n+\n+        static if (__traits(compiles, __vector(void[16])))\n+            test!(__vector(void[16]))();\n+        static if (__traits(compiles, __vector(byte[16])))\n+            test!(__vector(byte[16]))();\n+        static if (__traits(compiles, __vector(ubyte[16])))\n+            test!(__vector(ubyte[16]))();\n+        static if (__traits(compiles, __vector(short[8])))\n+            test!(__vector(short[8]))();\n+        static if (__traits(compiles, __vector(ushort[8])))\n+            test!(__vector(ushort[8]))();\n+        static if (__traits(compiles, __vector(int[4])))\n+            test!(__vector(int[4]))();\n+        static if (__traits(compiles, __vector(uint[4])))\n+            test!(__vector(uint[4]))();\n+        static if (__traits(compiles, __vector(long[2])))\n+            test!(__vector(long[2]))();\n+        static if (__traits(compiles, __vector(ulong[2])))\n+            test!(__vector(ulong[2]))();\n+        static if (__traits(compiles, __vector(double[2])))\n+            test!(__vector(double[2]))();\n+        static if (__traits(compiles, __vector(float[4])))\n+            test!(__vector(float[4]))();\n+    }\n+}"}, {"sha": "e9c23f54782f8e181539decc00b5b425ad9c5374", "filename": "gcc/testsuite/gdc.dg/torture/simd_logical.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_logical.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_logical.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_logical.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,19 @@\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+import gcc.simd;\n+\n+void main()\n+{\n+    static if (__traits(compiles, __vector(int[4])))\n+    {\n+        __gshared __vector(int[4]) a = [1,0,-1,2];\n+\n+        assert(notMask(a).array == [0,-1,0,0]);\n+\n+        assert(andAndMask(a, 1).array == [-1,0,-1,-1]);\n+        assert(andAndMask(a, 0).array == [0,0,0,0]);\n+\n+        assert(orOrMask(a, 1).array == [-1,-1,-1,-1]);\n+        assert(orOrMask(a, 0).array == [-1,0,-1,-1]);\n+    }\n+}"}, {"sha": "3629ceec699fdedcf3939bf844ced259ad4af51d", "filename": "gcc/testsuite/gdc.dg/torture/simd_shuffle.d", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_shuffle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_shuffle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_shuffle.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,454 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import gcc.simd;\n+\n+void testshuffle(V, VI = V)()\n+{\n+    alias E = typeof(V.array[0]);\n+    enum numElements = V.sizeof / E.sizeof;\n+\n+    static if (numElements == 16)\n+    {\n+        // Test fragment for vectors with 16 elements\n+        immutable V[5] in1 =\n+            [[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],\n+             [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],\n+             [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],\n+             [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],\n+             [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]];\n+\n+        immutable VI[5] mask1 =\n+            [[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ],\n+             [ 0x10, 0x21, 0x32, 0x43, 0x54, 0x65, 0x76, 0x87,\n+               0x98, 0xa9, 0xba, 0xcb, 0xdc, 0xed, 0xfe, 0xff ]\t,\n+             [ 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],\n+             [ 0, 2, 4, 6, 8, 10, 12, 14, 1, 3, 5, 7, 9, 11, 13, 15 ],\n+             [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ]];\n+\n+        immutable V[5] out1 =\n+            [[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],\n+             [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],\n+             [ 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 ],\n+             [ 1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16 ],\n+             [ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ]];\n+\n+        immutable V[5] in2 =\n+            [[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ]];\n+\n+        immutable V in3 =\n+            [ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45 ];\n+\n+        immutable VI[5] mask2 =\n+            [[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n+             [ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ],\n+             [ 7, 6, 5, 4, 16, 17, 18, 19, 31, 30, 29, 28, 3, 2, 1, 0 ],\n+             [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n+             [ 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 ]];\n+\n+        immutable V[5] out2 =\n+            [[ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 ],\n+             [ 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45 ],\n+             [ 17, 16, 15, 14, 30, 31, 32, 33, 45, 44, 43, 42, 13, 12, 11, 10 ],\n+             [ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 ],\n+             [ 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45 ]];\n+    }\n+    else static if (numElements == 8)\n+    {\n+        // Test fragment for vectors with 8 elements\n+        static if (is(E == uint))\n+        {\n+            enum E A1 = 0x11121314;\n+            enum E B1 = 0x21222324;\n+            enum E C1 = 0x31323334;\n+            enum E D1 = 0x41424344;\n+            enum E E1 = 0x51525354;\n+            enum E F1 = 0x61626364;\n+            enum E G1 = 0x71727374;\n+            enum E H1 = 0x81828384;\n+\n+            enum E A2 = 0x91929394;\n+            enum E B2 = 0xa1a2a3a4;\n+            enum E C2 = 0xb1b2b3b4;\n+            enum E D2 = 0xc1c2c3c4;\n+            enum E E2 = 0xd1d2d3d4;\n+            enum E F2 = 0xe1e2e3e4;\n+            enum E G2 = 0xf1f2f3f4;\n+            enum E H2 = 0x01020304;\n+        }\n+        else static if (is(E == ushort))\n+        {\n+            enum E A1 = 0x1112;\n+            enum E B1 = 0x2122;\n+            enum E C1 = 0x3132;\n+            enum E D1 = 0x4142;\n+            enum E E1 = 0x5152;\n+            enum E F1 = 0x6162;\n+            enum E G1 = 0x7172;\n+            enum E H1 = 0x8182;\n+\n+            enum E A2 = 0x9192;\n+            enum E B2 = 0xa1a2;\n+            enum E C2 = 0xb1b2;\n+            enum E D2 = 0xc1c2;\n+            enum E E2 = 0xd1d2;\n+            enum E F2 = 0xe1e2;\n+            enum E G2 = 0xf1f2;\n+            enum E H2 = 0x0102;\n+        }\n+        else static if (is(E == ubyte))\n+        {\n+            enum E A1 = 0x11;\n+            enum E B1 = 0x12;\n+            enum E C1 = 0x13;\n+            enum E D1 = 0x14;\n+            enum E E1 = 0x15;\n+            enum E F1 = 0x16;\n+            enum E G1 = 0x17;\n+            enum E H1 = 0x18;\n+\n+            enum E A2 = 0xf1;\n+            enum E B2 = 0xf2;\n+            enum E C2 = 0xf3;\n+            enum E D2 = 0xf4;\n+            enum E E2 = 0xf5;\n+            enum E F2 = 0xf6;\n+            enum E G2 = 0xf7;\n+            enum E H2 = 0xf8;\n+        }\n+        else\n+            enum unsupported = true;\n+\n+        static if (!__traits(compiles, unsupported))\n+        {\n+            immutable V[8] in1 =\n+                [[ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A2, B2, C2, D2, E2, F2, G2, H2 ],\n+                 [ A2, B2, C2, D2, E2, F2, G2, H2 ],\n+                 [ A2, B2, C2, D2, E2, F2, G2, H2 ]];\n+\n+            immutable VI[8] mask1 =\n+                [[  0,  1,  2,  3,  4,  5,  6,  7 ],\n+                 [ 0x10, 0x21, 0x32, 0x43, 0x54, 0x65, 0x76, 0x87 ],\n+                 [  7,  6,  5,  4,  3,  2,  1,  0 ],\n+                 [  7,  0,  5,  3,  2,  4,  1,  6 ],\n+                 [  0,  2,  1,  3,  4,  6,  5,  7 ],\n+                 [  3,  1,  2,  0,  7,  5,  6,  4 ],\n+                 [ 0, 0, 0, 0 ],\n+                 [  1,  6,  1,  6,  1,  6,  1,  6 ]];\n+\n+            immutable V[8] out1 =\n+                [[ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ H1, G1, F1, E1, D1, C1, B1, A1 ],\n+                 [ H1, A1, F1, D1, C1, E1, B1, G1 ],\n+                 [ A1, C1, B1, D1, E1, G1, F1, H1 ],\n+                 [ D2, B2, C2, A2, H2, F2, G2, E2 ],\n+                 [ A2, A2, A2, A2, A2, A2, A2, A2 ],\n+                 [ B2, G2, B2, G2, B2, G2, B2, G2 ]];\n+\n+            immutable V[6] in2 =\n+                [[ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A1, B1, C1, D1, E1, F1, G1, H1 ]];\n+\n+\n+            immutable V in3 =\n+                [ A2, B2, C2, D2, E2, F2, G2, H2 ];\n+\n+            immutable VI[6] mask2 =\n+                [[ 0, 1, 2, 3, 4, 5, 6, 7 ],\n+                 [  8,  9, 10, 11, 12, 13, 14, 15 ],\n+                 [  0,  8,  1,  9,  2, 10,  3, 11 ],\n+                 [  0, 15,  4, 11, 12,  3,  7,  8 ],\n+                 [  0,  0,  0,  0,  0,  0,  0,  0 ],\n+                 [ 0x1e, 0x2e, 0x3e, 0x4e, 0x5e, 0x6e, 0x7e, 0x8e ]];\n+\n+            immutable V[6] out2 =\n+                [[ A1, B1, C1, D1, E1, F1, G1, H1 ],\n+                 [ A2, B2, C2, D2, E2, F2, G2, H2 ],\n+                 [ A1, A2, B1, B2, C1, C2, D1, D2 ],\n+                 [ A1, H2, E1, D2, E2, D1, H1, A2 ],\n+                 [ A1, A1, A1, A1, A1, A1, A1, A1 ],\n+                 [ G2, G2, G2, G2, G2, G2, G2, G2 ]];\n+        }\n+    }\n+    else static if (numElements == 4)\n+    {\n+        // Test fragment for vectors with 4 elements\n+        static if (is(E == double))\n+        {\n+            enum E A = 0.69314718055994530942;\n+            enum E B = 2.7182818284590452354;\n+            enum E C = 2.30258509299404568402;\n+            enum E D = 1.4426950408889634074;\n+\n+            enum E W = 0.31830988618379067154;\n+            enum E X = 3.14159265358979323846;\n+            enum E Y = 1.41421356237309504880;\n+            enum E Z = 0.70710678118654752440;\n+        }\n+        else static if (is(E == float))\n+        {\n+            enum E A = 0.69314718055994530942f;\n+            enum E B = 2.7182818284590452354f;\n+            enum E C = 2.30258509299404568402f;\n+            enum E D = 1.4426950408889634074f;\n+\n+            enum E W = 0.31830988618379067154f;\n+            enum E X = 3.14159265358979323846f;\n+            enum E Y = 1.41421356237309504880f;\n+            enum E Z = 0.70710678118654752440f;\n+        }\n+        else static if (is(E == ulong))\n+        {\n+            enum E A = 0x1112131415161718;\n+            enum E B = 0x2122232425262728;\n+            enum E C = 0x3132333435363738;\n+            enum E D = 0x4142434445464748;\n+\n+            enum E W = 0xc1c2c3c4c5c6c7c8;\n+            enum E X = 0xd1d2d3d4d5d6d7d8;\n+            enum E Y = 0xe1e2e3e4e5e6e7e8;\n+            enum E Z = 0xf1f2f3f4f5f6f7f8;\n+        }\n+        else static if (is(E == uint))\n+        {\n+            enum E A = 0x11121314;\n+            enum E B = 0x21222324;\n+            enum E C = 0x31323334;\n+            enum E D = 0x41424344;\n+\n+            enum E W = 0xc1c2c3c4;\n+            enum E X = 0xd1d2d3d4;\n+            enum E Y = 0xe1e2e3e4;\n+            enum E Z = 0xf1f2f3f4;\n+        }\n+        else\n+            enum unsupported = true;\n+\n+        static if (!__traits(compiles, unsupported))\n+        {\n+            immutable V[8] in1 =\n+                [[ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ W, X, Y, Z ],\n+                 [ W, X, Y, Z ],\n+                 [ W, X, Y, Z ]];\n+\n+            immutable VI[8] mask1 =\n+                [[ 0, 1, 2, 3 ],\n+                 [ 0+1*4, 1+2*4, 2+3*4, 3+4*4 ],\n+                 [ 3, 2, 1, 0 ],\n+                 [ 0, 3, 2, 1 ],\n+                 [ 0, 2, 1, 3 ],\n+                 [ 3, 1, 2, 0 ],\n+                 [ 0, 0, 0, 0 ],\n+                 [ 1, 2, 1, 2 ]];\n+\n+            immutable V[8] out1 =\n+                [[ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ D, C, B, A ],\n+                 [ A, D, C, B ],\n+                 [ A, C, B, D ],\n+                 [ Z, X, Y, W ],\n+                 [ W, W, W, W ],\n+                 [ X, Y, X, Y ]];\n+\n+\n+            immutable V[6] in2 =\n+                [[ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ],\n+                 [ A, B, C, D ]];\n+\n+            immutable V in3 = [ W, X, Y, Z ];\n+\n+            immutable VI[6] mask2 =\n+                [[ 0, 1, 2, 3 ],\n+                 [ 4, 5, 6, 7 ],\n+                 [ 0, 4, 1, 5 ],\n+                 [ 0, 7, 4, 3 ],\n+                 [ 0, 0, 0, 0 ],\n+                 [ 7, 7, 7, 7 ]];\n+\n+            immutable V[6] out2 =\n+                [[ A, B, C, D ],\n+                 [ W, X, Y, Z ],\n+                 [ A, W, B, X ],\n+                 [ A, Z, W, D ],\n+                 [ A, A, A, A ],\n+                 [ Z, Z, Z, Z ]];\n+        }\n+    }\n+    else static if (numElements == 2)\n+    {\n+        // Test fragment for vectors with 2 elements\n+        static if (is(E == double))\n+        {\n+            enum E A = 0.69314718055994530942;\n+            enum E B = 2.7182818284590452354;\n+\n+            enum E X = 3.14159265358979323846;\n+            enum E Y = 1.41421356237309504880;\n+        }\n+        else static if (is(E == float))\n+        {\n+            enum E A = 0.69314718055994530942f;\n+            enum E B = 2.7182818284590452354f;\n+\n+            enum E X = 3.14159265358979323846f;\n+            enum E Y = 1.41421356237309504880f;\n+        }\n+        else static if (is(E == ulong))\n+        {\n+            enum E A = 0x1112131415161718;\n+            enum E B = 0x2122232425262728;\n+\n+            enum E X = 0xc1c2c3c4c5c6c7c8;\n+            enum E Y = 0xd1d2d3d4d5d6d7d8;\n+        }\n+        else static if (is(E == uint))\n+        {\n+            enum E A = 0x11121314;\n+            enum E B = 0x21222324;\n+\n+            enum E X = 0xd1d2d3d4;\n+            enum E Y = 0xe1e2e3e4;\n+        }\n+        else\n+            enum unsupported = true;\n+\n+        static if (!__traits(compiles, unsupported))\n+        {\n+            immutable V[6] in1 =\n+                [[ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ X, Y ],\n+                 [ X, Y ]];\n+\n+            immutable VI[6] mask1 =\n+                [[ 0, 1 ],\n+                 [ -16, 1 ],\n+                 [ 1, 0 ],\n+                 [ 0, 0 ],\n+                 [ 1, 1 ],\n+                 [ 1, 0 ]];\n+\n+            immutable V[6] out1 =\n+                [[ A, B ],\n+                 [ A, B ],\n+                 [ B, A ],\n+                 [ A, A ],\n+                 [ Y, Y ],\n+                 [ Y, X ]];\n+\n+            immutable V[7] in2 =\n+                [[ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ],\n+                 [ A, B ]];\n+\n+            immutable V in3 = [ X, Y ];\n+\n+            immutable VI[7] mask2 =\n+                [[ 0, 1 ],\n+                 [ 2, 3 ],\n+                 [ 0, 2 ],\n+                 [ 2, 1 ],\n+                 [ 3, 0 ],\n+                 [ 0, 0 ],\n+                 [ 3, 3 ]];\n+\n+            immutable V[7] out2 =\n+                [[ A, B ],\n+                 [ X, Y ],\n+                 [ A, X ],\n+                 [ X, B ],\n+                 [ Y, A ],\n+                 [ A, A ],\n+                 [ Y, Y ]];\n+        }\n+    }\n+    else\n+        enum unsupported = true;\n+\n+    static if (!__traits(compiles, unsupported))\n+    {\n+        static foreach (i; 0 .. in1.length)\n+            assert(shuffle(in1[i], mask1[i]).array == out1[i].array);\n+        static foreach (i; 0 .. in2.length)\n+            assert(shuffle(in2[i], in3, mask2[i]).array == out2[i].array);\n+    }\n+}\n+\n+void main()\n+{\n+    static if (__traits(compiles, __vector(ubyte[16])))\n+        testshuffle!(__vector(ubyte[16]))();\n+\n+    static if (__traits(compiles, __vector(ushort[16])))\n+        testshuffle!(__vector(ushort[16]))();\n+\n+    static if (__traits(compiles, __vector(ubyte[8])))\n+        testshuffle!(__vector(ubyte[8]))();\n+\n+    static if (__traits(compiles, __vector(ushort[8])))\n+        testshuffle!(__vector(ushort[8]))();\n+\n+    static if (__traits(compiles, __vector(uint[8])))\n+        testshuffle!(__vector(uint[8]))();\n+\n+    static if (__traits(compiles, __vector(ulong[4])))\n+    {\n+        testshuffle!(__vector(ulong[4]));\n+\n+        static if (__traits(compiles, __vector(double[4])))\n+            testshuffle!(__vector(double[4]), __vector(ulong[4]));\n+    }\n+\n+    static if (__traits(compiles, __vector(uint[4])))\n+    {\n+        testshuffle!(__vector(uint[4]));\n+\n+        static if (__traits(compiles, __vector(float[4])))\n+            testshuffle!(__vector(float[4]), __vector(uint[4]));\n+    }\n+\n+    static if (__traits(compiles, __vector(ulong[2])))\n+    {\n+        testshuffle!(__vector(ulong[2]));\n+\n+        static if (__traits(compiles, __vector(double[2])))\n+            testshuffle!(__vector(double[2]), __vector(ulong[2]));\n+    }\n+\n+    static if (__traits(compiles, __vector(uint[2])))\n+    {\n+        testshuffle!(__vector(uint[2]));\n+\n+        static if (__traits(compiles, __vector(float[2])))\n+            testshuffle!(__vector(float[2]), __vector(uint[2]));\n+    }\n+}"}, {"sha": "cc559992e12b636ee37e5d23a3b20f8997bda848", "filename": "gcc/testsuite/gdc.dg/torture/simd_shufflevector.d", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_shufflevector.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_shufflevector.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_shufflevector.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,55 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import gcc.simd;\n+import gcc.attributes;\n+\n+void main()\n+{\n+    static if (__traits(compiles, __vector(int[4])))\n+        alias int4 = __vector(int[4]);\n+    static if (__traits(compiles, __vector(int[8])))\n+        alias int8 = __vector(int[8]);\n+\n+    static if (__traits(compiles, int4) && __traits(compiles, int8))\n+    {\n+        __gshared int4[5] res;\n+        __gshared int4 a;\n+        __gshared int4 b;\n+        __gshared int8[3] res8;\n+        __gshared int8 a8;\n+        __gshared int8 b8;\n+\n+        @noipa static void foo()\n+        {\n+            res[0] = shufflevector(a, b, 0, 1, 4, 5);\n+            res[1] = shufflevector(a, b, 0, 1, 2, 5);\n+            res8[0] = shufflevector(a, b, 0, 1, 2, 2 + 1, 4, 5, 6, 7);\n+            res[2] = shufflevector(a8, b8, 0, 8, 1, 9);\n+            res[3] = shufflevector(a8, b, 0, 8, 1, 9);\n+            res[4] = shufflevector(a, b8, 0, 4, 1, 5);\n+            res8[1] = shufflevector(a8, b, 0, 8, 1, 9, 10, 11, 2, 3);\n+            res8[2] = shufflevector(a, b8, 0, 4, 1, 5, 4, 5, 6, 7);\n+        }\n+\n+        a = [0, 1, 2, 3];\n+        b = [4, 5, 6, 7];\n+        a8 = [0, 1, 2, 3, 4, 5, 6, 7];\n+        b8 = [8, 9, 10, 11, 12, 13, 14, 15];\n+        foo();\n+        assert(res[0].array == [0, 1, 4, 5]);\n+\n+        res[1][2] = 9;\n+        assert(res[1].array == [0, 1, 9, 5]);\n+        assert(res8[0].array == [0, 1, 2, 3, 4, 5, 6, 7]);\n+        assert(res[2].array == [0, 8, 1, 9]);\n+        assert(res[3].array == [0, 4, 1, 5]);\n+        assert(res[4].array == [0, 8, 1, 9]);\n+        assert(res8[1].array == [0, 4, 1, 5, 6, 7, 2, 3]);\n+\n+        res8[2][4] = 42;\n+        res8[2][5] = 42;\n+        res8[2][6] = 42;\n+        res8[2][7] = 42;\n+        assert(res8[2].array == [0, 8, 1, 9, 42, 42, 42, 42]);\n+    }\n+}"}, {"sha": "b96ed42de3341cf1934f016ffeb8632cf7662e74", "filename": "gcc/testsuite/gdc.dg/torture/simd_store.d", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_store.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_store.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd_store.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,54 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import gcc.simd;\n+\n+void main()\n+{\n+    ubyte[32] data;\n+\n+    // to test all alignments from 1 ~ 16\n+    foreach (i; 0..16)\n+    {\n+        ubyte* d = &data[i];\n+\n+        void test(T)()\n+        {\n+            T v;\n+\n+            // populate v` with data\n+            ubyte* ptrToV = cast(ubyte*)&v;\n+            foreach (j; 0..T.sizeof)\n+                ptrToV[j] = cast(ubyte)j;\n+\n+            // store `v` to location pointed to by `d`\n+            storeUnaligned(cast(T*)d, v);\n+\n+            // check that the the data was stored correctly\n+            foreach (j; 0..T.sizeof)\n+                assert(ptrToV[j] == d[j]);\n+        }\n+\n+        static if (__traits(compiles, __vector(void[16])))\n+            test!(__vector(void[16]))();\n+        static if (__traits(compiles, __vector(byte[16])))\n+            test!(__vector(byte[16]))();\n+        static if (__traits(compiles, __vector(ubyte[16])))\n+            test!(__vector(ubyte[16]))();\n+        static if (__traits(compiles, __vector(short[8])))\n+            test!(__vector(short[8]))();\n+        static if (__traits(compiles, __vector(ushort[8])))\n+            test!(__vector(ushort[8]))();\n+        static if (__traits(compiles, __vector(int[4])))\n+            test!(__vector(int[4]))();\n+        static if (__traits(compiles, __vector(uint[4])))\n+            test!(__vector(uint[4]))();\n+        static if (__traits(compiles, __vector(long[2])))\n+            test!(__vector(long[2]))();\n+        static if (__traits(compiles, __vector(ulong[2])))\n+            test!(__vector(ulong[2]))();\n+        static if (__traits(compiles, __vector(double[2])))\n+            test!(__vector(double[2]))();\n+        static if (__traits(compiles, __vector(float[4])))\n+            test!(__vector(float[4]))();\n+    }\n+}"}, {"sha": "56b332d4efa6be55d8c45155cd78b1d512258002", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -207,14 +207,14 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/vararg.d core/volatile.d gcc/attribute.d gcc/attributes.d \\\n \tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n \tgcc/sections/common.d gcc/sections/elf.d gcc/sections/macho.d \\\n-\tgcc/sections/package.d gcc/sections/pecoff.d gcc/unwind/arm.d \\\n-\tgcc/unwind/arm_common.d gcc/unwind/c6x.d gcc/unwind/generic.d \\\n-\tgcc/unwind/package.d gcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d \\\n-\trt/aaA.d rt/adi.d rt/arrayassign.d rt/arraycat.d rt/cast_.d \\\n-\trt/config.d rt/critical_.d rt/deh.d rt/dmain2.d rt/ehalloc.d \\\n-\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n-\trt/profilegc.d rt/sections.d rt/tlsgc.d rt/util/typeinfo.d \\\n-\trt/util/utility.d\n+\tgcc/sections/package.d gcc/sections/pecoff.d gcc/simd.d \\\n+\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n+\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n+\trt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d rt/deh.d \\\n+\trt/dmain2.d rt/ehalloc.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n+\trt/minfo.d rt/monitor_.d rt/profilegc.d rt/sections.d rt/tlsgc.d \\\n+\trt/util/typeinfo.d rt/util/utility.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/allocator.d core/stdcpp/array.d \\\n \tcore/stdcpp/exception.d core/stdcpp/memory.d core/stdcpp/new_.d \\"}, {"sha": "24865fb258aceefe909d11a38060c3648e00d4f0", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -236,7 +236,7 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tgcc/backtrace.lo gcc/builtins.lo gcc/deh.lo gcc/emutls.lo \\\n \tgcc/gthread.lo gcc/sections/common.lo gcc/sections/elf.lo \\\n \tgcc/sections/macho.lo gcc/sections/package.lo \\\n-\tgcc/sections/pecoff.lo gcc/unwind/arm.lo \\\n+\tgcc/sections/pecoff.lo gcc/simd.lo gcc/unwind/arm.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n@@ -874,14 +874,14 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/vararg.d core/volatile.d gcc/attribute.d gcc/attributes.d \\\n \tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n \tgcc/sections/common.d gcc/sections/elf.d gcc/sections/macho.d \\\n-\tgcc/sections/package.d gcc/sections/pecoff.d gcc/unwind/arm.d \\\n-\tgcc/unwind/arm_common.d gcc/unwind/c6x.d gcc/unwind/generic.d \\\n-\tgcc/unwind/package.d gcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d \\\n-\trt/aaA.d rt/adi.d rt/arrayassign.d rt/arraycat.d rt/cast_.d \\\n-\trt/config.d rt/critical_.d rt/deh.d rt/dmain2.d rt/ehalloc.d \\\n-\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n-\trt/profilegc.d rt/sections.d rt/tlsgc.d rt/util/typeinfo.d \\\n-\trt/util/utility.d\n+\tgcc/sections/package.d gcc/sections/pecoff.d gcc/simd.d \\\n+\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n+\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n+\trt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d rt/deh.d \\\n+\trt/dmain2.d rt/ehalloc.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n+\trt/minfo.d rt/monitor_.d rt/profilegc.d rt/sections.d rt/tlsgc.d \\\n+\trt/util/typeinfo.d rt/util/utility.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/allocator.d core/stdcpp/array.d \\\n \tcore/stdcpp/exception.d core/stdcpp/memory.d core/stdcpp/new_.d \\\n@@ -1340,6 +1340,7 @@ gcc/sections/elf.lo: gcc/sections/$(am__dirstamp)\n gcc/sections/macho.lo: gcc/sections/$(am__dirstamp)\n gcc/sections/package.lo: gcc/sections/$(am__dirstamp)\n gcc/sections/pecoff.lo: gcc/sections/$(am__dirstamp)\n+gcc/simd.lo: gcc/$(am__dirstamp)\n gcc/unwind/$(am__dirstamp):\n \t@$(MKDIR_P) gcc/unwind\n \t@: > gcc/unwind/$(am__dirstamp)"}, {"sha": "ffca50f2a5e7ab7cd4befa2d04e2925ad1fd2822", "filename": "libphobos/libdruntime/gcc/simd.d", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93ae1a01bbad59ee77b7c84f4743a730138ba87/libphobos%2Flibdruntime%2Fgcc%2Fsimd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93ae1a01bbad59ee77b7c84f4743a730138ba87/libphobos%2Flibdruntime%2Fgcc%2Fsimd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsimd.d?ref=b93ae1a01bbad59ee77b7c84f4743a730138ba87", "patch": "@@ -0,0 +1,359 @@\n+// GNU D Compiler SIMD support functions and intrinsics.\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.simd;\n+\n+pure:\n+nothrow:\n+@safe:\n+@nogc:\n+pragma(inline, true):\n+\n+/**\n+* Emit prefetch instruction.\n+* Params:\n+*    address = address to be prefetched\n+*    writeFetch = true for write fetch, false for read fetch\n+*    locality = 0..3 (0 meaning least local, 3 meaning most local)\n+*/\n+void prefetch(bool writeFetch, ubyte locality)(const(void)* address)\n+{\n+    static assert(locality < 4, \"0..3 expected for locality\");\n+    import gcc.builtins : __builtin_prefetch;\n+    __builtin_prefetch(address, writeFetch, locality);\n+}\n+\n+/**\n+ * Load unaligned vector from address.\n+ * This is a compiler intrinsic.\n+ * Params:\n+ *    p = pointer to vector\n+ * Returns:\n+ *    vector\n+ */\n+V loadUnaligned(V)(const V* p) if (isVectorType!V);\n+\n+/**\n+ * Store vector to unaligned address.\n+ * This is a compiler intrinsic.\n+ * Params:\n+ *    p = pointer to vector\n+ *    value = value to store\n+ * Returns:\n+ *    value\n+ */\n+V storeUnaligned(V)(V* p, V value) if (isVectorType!V);\n+\n+/**\n+ * Construct a permutation of elements from one or two vectors, returning a\n+ * vector of the same type as the input vector(s). The `mask` is an integral\n+ * vector with the same width and element count as the output vector.\n+ * Params:\n+ *    op1 = input vector\n+ *    op2 = input vector\n+ *    mask = integer vector mask\n+ * Returns:\n+ *    vector with the same type as `op1` and `op2`\n+ * Example:\n+ * ---\n+ * int4 a = [1, 2, 3, 4];\n+ * int4 b = [5, 6, 7, 8];\n+ * int4 mask1 = [0, 1, 1, 3];\n+ * int4 mask2 = [0, 4, 2, 5];\n+ * assert(shuffle(a, mask1).array == [1, 2, 2, 4]);\n+ * assert(shuffle(a, b, mask2).array == [1, 5, 3, 6]);\n+ * ---\n+ */\n+template shuffle(V0, V1, M)\n+{\n+    static assert(isVectorType!V0, \"first argument must be vector\");\n+    static assert(isVectorType!V1, \"second argument must be vector\");\n+    static assert(is(BaseType!V0 == BaseType!V1),\n+                  \"first and second argument vectors must have the same element type\");\n+    static assert(isVectorType!M && is(BaseType!M : long),\n+                  \"last argument must be an integer vector\");\n+    static assert(numElements!V0 == numElements!M && numElements!V1 == numElements!M,\n+                  \"argument vectors and mask vector should have the same number of elements\");\n+    static assert(BaseType!V0.sizeof == BaseType!M.sizeof,\n+                  \"argument vectors and mask vector should have the same element type size\");\n+\n+    V0 shuffle(V0 op1, V1 op2, M mask);\n+}\n+\n+/// Ditto\n+template shuffle(V, M)\n+{\n+    static assert(isVectorType!V, \"first argument must be a vector\");\n+    static assert(isVectorType!M && is(BaseType!M : long),\n+                  \"last argument must be an integer vector\");\n+    static assert(numElements!V == numElements!M,\n+                  \"argument vector and mask vector should have the same number of elements\");\n+    static assert(BaseType!V.sizeof == BaseType!M.sizeof,\n+                  \"argument vector and mask vector should have the same element type size\");\n+\n+    V shuffle(V op1, M mask)\n+    {\n+        return shuffle(op1, op1, mask);\n+    }\n+}\n+\n+/**\n+ * Construct a permutation of elements from two vectors, returning a vector with\n+ * the same element type as the input vector(s), and same length as the `mask`.\n+ * Params:\n+ *    op1 = input vector\n+ *    op2 = input vector\n+ *    index = elements indices of the vectors that should be extracted and returned\n+ * Returns:\n+ *    vector with the same element type as `op1` and `op2`, but has an element count\n+ *    equal to the number of indices in `index`.\n+ * Example:\n+ * ---\n+ * int8 a = [1, -2, 3, -4, 5, -6, 7, -8];\n+ * int4 b = shufflevector(a, a, 0, 2, 4, 6);\n+ * assert(b.array == [1, 3, 5, 7]);\n+ * int4 c = [-2, -4, -6, -8];\n+ * int d = shufflevector(c, b, 4, 0, 5, 1, 6, 2, 7, 3);\n+ * assert(d.array == a.array);\n+ * ---\n+ */\n+template shufflevector(V1, V2, M...)\n+{\n+    static assert(isVectorType!V1, \"first argument must be vector\");\n+    static assert(isVectorType!V2, \"second argument must be vector\");\n+    static assert(is(BaseType!V1 == BaseType!V2),\n+                  \"first and second argument vectors must have the same element type\");\n+    static assert(isPowerOf2!(M.length),\n+                  \"number of index arguments must be a power of 2\");\n+\n+    __vector(BaseType!V1[M.length]) shufflevector(V1 op1, V2 op2, M index);\n+}\n+\n+/// Ditto\n+template shufflevector(V, index...)\n+{\n+    // Defined for compatibility with LDC.\n+    static assert(isVectorType!V, \"first argument must be a vector type\");\n+    static assert(numElements!V == index.length,\n+                  \"number of index arguments must be the same number of vector elements\");\n+\n+    private template ctfeConstants(m...)\n+    {\n+        static if (m.length == 0) enum ctfeConstants = 1;\n+        else enum ctfeConstants = m[0] | ctfeConstants!(m[1 .. $]);\n+    }\n+    static assert(__traits(compiles, ctfeConstants!index),\n+                  \"all index arguments must be compile time constants\");\n+\n+    private template validIndexes(m...)\n+    {\n+        static if (m.length == 0) enum validIndexes = true;\n+        else enum validIndexes = (cast(long)m[0] > -1) && validIndexes!(m[1 .. $]);\n+    }\n+    static assert(validIndexes!index,\n+                  \"all index arguments must be greater than or equal to 0\");\n+\n+    V shufflevector(V op1, V op2)\n+    {\n+        return shufflevector(op1, op2, index);\n+    }\n+}\n+\n+/**\n+ * Extracts a single scalar element from a vector at a specified index.\n+ * Defined for compatibility with LDC.\n+ * Params:\n+ *    val = vector to extract element from\n+ *    idx = index indicating the position from which to extract the element\n+ * Returns:\n+ *    scalar of the same type as the element type of val\n+ * Example:\n+ * ---\n+ * int4 a = [0, 10, 20, 30];\n+ * int k = extractelement!(int4, 2)(a);\n+ * assert(k == 20);\n+ * ---\n+ */\n+BaseType!V extractelement(V, int idx)(V val)\n+    if (isVectorType!V && idx < numElements!V)\n+{\n+    return val[idx];\n+}\n+\n+/**\n+ * Inserts a scalar element into a vector at a specified index.\n+ * Defined for compatibility with LDC.\n+ * Params:\n+ *    val = vector to assign element to\n+ *    elt = scalar whose type is the element type of val\n+ *    idx = index indicating the position from which to extract the element\n+ * Returns:\n+ *    vector of the same type as val\n+ * Example:\n+ * ---\n+ * int4 a = [0, 10, 20, 30];\n+ * int4 b = insertelement!(int4, 2)(a, 50);\n+ * assert(b.array == [0, 10, 50, 30]);\n+ * ---\n+ */\n+V insertelement(V, int idx)(V val, BaseType!V elt)\n+    if (isVectorType!V && idx < numElements!V)\n+{\n+    val[idx] = elt;\n+    return val;\n+}\n+\n+/**\n+ * Convert a vector from one integral or floating vector type to another.\n+ * The result is an integral or floating vector that has had every element\n+ * cast to the element type of the return type.\n+ * Params:\n+ *    from = input vector\n+ * Returns:\n+ *    converted vector\n+ * Example:\n+ * ---\n+ * int4 a = [1, -2, 3, -4];\n+ * float4 b = [1.5, -2.5, 3, 7];\n+ * assert(convertvector!float4(a).array == [1, -2, 3, -4]);\n+ * assert(convertvector!double4(a).array == [1, -2, 3, -4]);\n+ * assert(convertvector!double4(b).array == [1.5, -2.5, 3, 7]);\n+ * assert(convertvector!int4(b).array == [1, -2, 3, 7]);\n+ * ---\n+ */\n+\n+template convertvector(V, T)\n+{\n+    static assert(isVectorType!V && (is(BaseType!V : long) || is(BaseType!V : real)),\n+                  \"first argument must be an integer or floating vector type\");\n+    static assert(isVectorType!T && (is(BaseType!T : long) || is(BaseType!T : real)),\n+                  \"second argument must be an integer or floating vector\");\n+    static assert(numElements!V == numElements!T,\n+                  \"first and second argument vectors should have the same number of elements\");\n+\n+    V convertvector(T);\n+}\n+\n+/**\n+ * Construct a conditional merge of elements from two vectors, returning a\n+ * vector of the same type as the input vector(s). The `mask` is an integral\n+ * vector with the same width and element count as the output vector.\n+ * Params:\n+ *    op1 = input vector\n+ *    op2 = input vector\n+ *    mask = integer vector mask\n+ * Returns:\n+ *    vector with the same type as `op1` and `op2`\n+ * Example:\n+ * ---\n+ * int4 a = [1, 2, 3, 4];\n+ * int4 b = [5, 6, 7, 8];\n+ * int4 mask1 = [0, 1, 1, 3];\n+ * int4 mask2 = [0, 4, 2, 5];\n+ * assert(shuffle(a, mask1).array == [1, 2, 2, 4]);\n+ * assert(shuffle(a, b, mask2).array == [1, 5, 3, 6]);\n+ * ---\n+ */\n+template blendvector(V0, V1, M)\n+{\n+    static assert(isVectorType!V0, \"first argument must be vector\");\n+    static assert(isVectorType!V1, \"second argument must be vector\");\n+    static assert(is(BaseType!V0 == BaseType!V1),\n+                  \"first and second argument vectors must have the same element type\");\n+    static assert(isVectorType!M && is(BaseType!M : long),\n+                  \"last argument must be an integer vector\");\n+    static assert(numElements!V0 == numElements!M && numElements!V1 == numElements!M,\n+                  \"argument vectors and mask vector should have the same number of elements\");\n+    static assert(BaseType!V0.sizeof == BaseType!M.sizeof,\n+                  \"argument vectors and mask vector should have the same element type size\");\n+\n+    V0 blendvector(V0 op1, V1 op2, M mask);\n+}\n+\n+/**\n+ * Perform an element-wise comparison between two vectors, producing `0` when\n+ * the comparison is false and `-1` (all bits are set to 1) otherwise.\n+ * Params:\n+ *    op1 = input vector\n+ *    op2 = input vector\n+ * Returns:\n+ *    vector of the same width and number of elements as the comparison\n+ *    operands with a signed integral element type\n+ * Example:\n+ * ---\n+ * float4 a = [1, 3, 5, 7];\n+ * float4 b = [2, 3, 4, 5];\n+ * int4 c = greaterMask!float4(a, b);\n+ * assert(c.array == [0, 0, -1, -1]);\n+ * ---\n+ */\n+V equalMask(V)(V op1, V op2) if (isVectorType!V);\n+/// Ditto\n+V notEqualMask(V)(V op1, V op2) if (isVectorType!V);\n+/// Ditto\n+V greaterMask(V)(V op1, V op2) if (isVectorType!V);\n+/// Ditto\n+V greaterOrEqualMask(V)(V op1, V op2) if (isVectorType!V);\n+\n+/**\n+ * Perform an element-wise logical comparison between two vectors, producing\n+ * `0` when the comparison is false and `-1` (all bits are set to 1) otherwise.\n+ * Params:\n+ *    op1 = input vector\n+ *    op2 = input vector\n+ * Returns:\n+ *    vector of the same width and number of elements as the comparison\n+ *    operands with a signed integral element type\n+ */\n+V notMask(V)(V op1) if (isVectorType!V)\n+{\n+    return equalMask(op1, 0);\n+}\n+\n+/// Ditto\n+V andAndMask(V)(V op1, V op2) if (isVectorType!V)\n+{\n+    return notEqualMask(op1, 0) & notEqualMask(op2, 0);\n+}\n+\n+/// Ditto\n+V orOrMask(V)(V op1, V op2) if (isVectorType!V)\n+{\n+    return notEqualMask(op1, 0) | notEqualMask(op2, 0);\n+}\n+\n+// Private helper templates.\n+private:\n+\n+enum bool isVectorType(T) = is(T : __vector(V[N]), V, size_t N);\n+\n+template BaseType(V)\n+{\n+    alias typeof(V.array[0]) BaseType;\n+}\n+\n+template numElements(V)\n+{\n+    enum numElements = V.sizeof / BaseType!(V).sizeof;\n+}\n+\n+enum bool isPowerOf2(int Y) = Y && (Y & -Y) == Y;"}]}