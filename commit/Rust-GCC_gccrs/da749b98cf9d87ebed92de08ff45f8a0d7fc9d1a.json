{"sha": "da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3NDliOThjZjlkODdlYmVkOTJkZTA4ZmY0NWY4YTBkN2ZjOWQxYQ==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:24Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:24Z"}, "message": "RTL: Also support HOST_WIDE_INT with int iterators\n\nAdd wide integer aka 'w' rtx format support to int iterators so that\nmachine description can iterate over `const_int' expressions.\n\nThis is made by expanding standard integer aka 'i' format support,\nobserving that any standard integer already present in any of our\nexisting RTL code will also fit into HOST_WIDE_INT, so there is no need\nfor a separate handler.  Any truncation of the number parsed is made by\nthe caller.  An assumption is made however that no place relies on\ncapping out of range values to INT_MAX.\n\nNow the 'p' format is handled explicitly rather than being implied by\nrtx being a SUBREG, so actually assert that it is, just to play safe.\n\n\tgcc/\n\t* read-rtl.c: Add a page-feed separator at the start of iterator\n\tcode.\n\t(struct iterator_group): Change the return type to HOST_WIDE_INT\n\tfor the `find_builtin' member.  Likewise the second parameter\n\ttype for the `apply_iterator' member.\n\t(atoll) [!HAVE_ATOQ]: Reorder.\n\t(find_mode, find_code): Change the return type to HOST_WIDE_INT.\n\t(apply_mode_iterator, apply_code_iterator)\n\t(apply_subst_iterator): Change the second parameter type to\n\tHOST_WIDE_INT.\n\t(find_int): Handle input suitable for HOST_WIDE_INT output.\n\t(apply_int_iterator): Rewrite in terms of explicit format\n\tinterpretation.\n\t(rtx_reader::read_rtx_operand) <'w'>: Fold into...\n\t<'i', 'n', 'p'>: ... this.\n\t* doc/md.texi (Int Iterators): Document 'w' rtx format support.", "tree": {"sha": "203ee7142b585b6cbf8ed40d4ef44827d9ec981a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/203ee7142b585b6cbf8ed40d4ef44827d9ec981a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a/comments", "author": null, "committer": null, "parents": [{"sha": "8c18e22afb061329766be3532a06a85ccc492d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c18e22afb061329766be3532a06a85ccc492d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c18e22afb061329766be3532a06a85ccc492d9c"}], "stats": {"total": 175, "additions": 93, "deletions": 82}, "files": [{"sha": "573a340c14b17fab2393d3ac2f2a6b7b9b681003", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a", "patch": "@@ -11223,11 +11223,11 @@ The construct:\n @end smallexample\n \n defines a pseudo integer constant @var{name} that can be instantiated as\n-@var{inti} if condition @var{condi} is true.  Each @var{int}\n-must have the same rtx format.  @xref{RTL Classes}. Int iterators can appear\n-in only those rtx fields that have 'i' as the specifier. This means that\n-each @var{int} has to be a constant defined using define_constant or\n-define_c_enum.\n+@var{inti} if condition @var{condi} is true.  Each @var{int} must have the\n+same rtx format.  @xref{RTL Classes}.  Int iterators can appear in only\n+those rtx fields that have 'i', 'n', 'w', or 'p' as the specifier.  This\n+means that each @var{int} has to be a constant defined using define_constant\n+or define_c_enum.\n \n As with mode and code iterators, each pattern that uses @var{name} will be\n expanded @var{n} times, once with all uses of @var{name} replaced by"}, {"sha": "403f254f3cb6e56172c4c0a7a081621570d011a2", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 88, "deletions": 77, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=da749b98cf9d87ebed92de08ff45f8a0d7fc9d1a", "patch": "@@ -77,12 +77,12 @@ struct iterator_group {\n \n   /* Treat the given string as the name of a standard mode, etc., and\n      return its integer value.  */\n-  int (*find_builtin) (const char *);\n+  HOST_WIDE_INT (*find_builtin) (const char *);\n \n   /* Make the given rtx use the iterator value given by the third argument.\n      If the iterator applies to operands, the second argument gives the\n      operand index, otherwise it is ignored.  */\n-  void (*apply_iterator) (rtx, unsigned int, int);\n+  void (*apply_iterator) (rtx, unsigned int, HOST_WIDE_INT);\n \n   /* Return the C token for the given standard mode, code, etc.  */\n   const char *(*get_c_token) (int);\n@@ -139,7 +139,7 @@ static void one_time_initialization (void);\n \n /* Global singleton.  */\n rtx_reader *rtx_reader_ptr = NULL;\n-\n+\f\n /* The mode and code iterator structures.  */\n static struct iterator_group modes, codes, ints, substs;\n \n@@ -152,9 +152,49 @@ static vec<iterator_use> iterator_uses;\n /* The list of all attribute uses in the current rtx.  */\n static vec<attribute_use> attribute_uses;\n \n+/* Provide a version of a function to read a long long if the system does\n+   not provide one.  */\n+#if (HOST_BITS_PER_WIDE_INT > HOST_BITS_PER_LONG\t\t\t\\\n+     && !HAVE_DECL_ATOLL\t\t\t\t\t\t\\\n+     && !defined (HAVE_ATOQ))\n+HOST_WIDE_INT atoll (const char *);\n+\n+HOST_WIDE_INT\n+atoll (const char *p)\n+{\n+  int neg = 0;\n+  HOST_WIDE_INT tmp_wide;\n+\n+  while (ISSPACE (*p))\n+    p++;\n+  if (*p == '-')\n+    neg = 1, p++;\n+  else if (*p == '+')\n+    p++;\n+\n+  tmp_wide = 0;\n+  while (ISDIGIT (*p))\n+    {\n+      HOST_WIDE_INT new_wide = tmp_wide*10 + (*p - '0');\n+      if (new_wide < tmp_wide)\n+\t{\n+\t  /* Return INT_MAX equiv on overflow.  */\n+\t  tmp_wide = HOST_WIDE_INT_M1U >> 1;\n+\t  break;\n+\t}\n+      tmp_wide = new_wide;\n+      p++;\n+    }\n+\n+  if (neg)\n+    tmp_wide = -tmp_wide;\n+  return tmp_wide;\n+}\n+#endif\n+\n /* Implementations of the iterator_group callbacks for modes.  */\n \n-static int\n+static HOST_WIDE_INT\n find_mode (const char *name)\n {\n   int i;\n@@ -167,7 +207,7 @@ find_mode (const char *name)\n }\n \n static void\n-apply_mode_iterator (rtx x, unsigned int, int mode)\n+apply_mode_iterator (rtx x, unsigned int, HOST_WIDE_INT mode)\n {\n   PUT_MODE (x, (machine_mode) mode);\n }\n@@ -215,7 +255,7 @@ maybe_find_code (const char *name)\n \n /* Implementations of the iterator_group callbacks for codes.  */\n \n-static int\n+static HOST_WIDE_INT\n find_code (const char *name)\n {\n   rtx_code code = maybe_find_code (name);\n@@ -225,7 +265,7 @@ find_code (const char *name)\n }\n \n static void\n-apply_code_iterator (rtx x, unsigned int, int code)\n+apply_code_iterator (rtx x, unsigned int, HOST_WIDE_INT code)\n {\n   PUT_CODE (x, (enum rtx_code) code);\n }\n@@ -245,20 +285,52 @@ get_code_token (int code)\n    we have to accept any int as valid.  No cross-checking can\n    be done.  */\n \n-static int\n+static HOST_WIDE_INT\n find_int (const char *name)\n {\n+  HOST_WIDE_INT tmp;\n+\n   validate_const_int (name);\n-  return atoi (name);\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+  tmp = atoi (name);\n+#else\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n+  tmp = atol (name);\n+#else\n+  /* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n+     But prefer not to use our hand-rolled function above either.  */\n+#if HAVE_DECL_ATOLL || !defined(HAVE_ATOQ)\n+  tmp = atoll (name);\n+#else\n+  tmp = atoq (name);\n+#endif\n+#endif\n+#endif\n+  return tmp;\n }\n \n static void\n-apply_int_iterator (rtx x, unsigned int index, int value)\n+apply_int_iterator (rtx x, unsigned int index, HOST_WIDE_INT value)\n {\n-  if (GET_CODE (x) == SUBREG)\n-    SUBREG_BYTE (x) = value;\n-  else\n-    XINT (x, index) = value;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *format_ptr = GET_RTX_FORMAT (code);\n+\n+  switch (format_ptr[index])\n+    {\n+    case 'i':\n+    case 'n':\n+      XINT (x, index) = value;\n+      break;\n+    case 'w':\n+      XWINT (x, index) = value;\n+      break;\n+    case 'p':\n+      gcc_assert (code == SUBREG);\n+      SUBREG_BYTE (x) = value;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n static const char *\n@@ -279,7 +351,7 @@ get_int_token (int value)\n    applied.  If such attribute has already been added, then no the\n    routine has no effect.  */\n static void\n-apply_subst_iterator (rtx rt, unsigned int, int value)\n+apply_subst_iterator (rtx rt, unsigned int, HOST_WIDE_INT value)\n {\n   rtx new_attr;\n   rtvec attrs_vec, new_attrs_vec;\n@@ -1003,44 +1075,6 @@ initialize_iterators (void)\n     }\n }\n \f\n-/* Provide a version of a function to read a long long if the system does\n-   not provide one.  */\n-#if HOST_BITS_PER_WIDE_INT > HOST_BITS_PER_LONG && !HAVE_DECL_ATOLL && !defined(HAVE_ATOQ)\n-HOST_WIDE_INT atoll (const char *);\n-\n-HOST_WIDE_INT\n-atoll (const char *p)\n-{\n-  int neg = 0;\n-  HOST_WIDE_INT tmp_wide;\n-\n-  while (ISSPACE (*p))\n-    p++;\n-  if (*p == '-')\n-    neg = 1, p++;\n-  else if (*p == '+')\n-    p++;\n-\n-  tmp_wide = 0;\n-  while (ISDIGIT (*p))\n-    {\n-      HOST_WIDE_INT new_wide = tmp_wide*10 + (*p - '0');\n-      if (new_wide < tmp_wide)\n-\t{\n-\t  /* Return INT_MAX equiv on overflow.  */\n-\t  tmp_wide = HOST_WIDE_INT_M1U >> 1;\n-\t  break;\n-\t}\n-      tmp_wide = new_wide;\n-      p++;\n-    }\n-\n-  if (neg)\n-    tmp_wide = -tmp_wide;\n-  return tmp_wide;\n-}\n-#endif\n-\f\n \n #ifdef GENERATOR_FILE\n /* Process a define_conditions directive, starting with the optional\n@@ -1939,32 +1973,9 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n       }\n       break;\n \n-    case 'w':\n-      {\n-\tHOST_WIDE_INT tmp_wide;\n-\tread_name (&name);\n-\tvalidate_const_int (name.string);\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\ttmp_wide = atoi (name.string);\n-#else\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n-\ttmp_wide = atol (name.string);\n-#else\n-\t/* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n-\t   But prefer not to use our hand-rolled function above either.  */\n-#if HAVE_DECL_ATOLL || !defined(HAVE_ATOQ)\n-\ttmp_wide = atoll (name.string);\n-#else\n-\ttmp_wide = atoq (name.string);\n-#endif\n-#endif\n-#endif\n-\tXWINT (return_rtx, idx) = tmp_wide;\n-      }\n-      break;\n-\n     case 'i':\n     case 'n':\n+    case 'w':\n     case 'p':\n       {\n \t/* Can be an iterator or an integer constant.  */"}]}