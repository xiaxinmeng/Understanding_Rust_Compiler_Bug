{"sha": "8f6b7459551d535ac1d279964c0d30145cd75eb5", "node_id": "C_kwDOANBUbNoAKDhmNmI3NDU5NTUxZDUzNWFjMWQyNzk5NjRjMGQzMDE0NWNkNzVlYjU", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-05-02T14:34:46Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-05-11T07:38:21Z"}, "message": "ast: Move token converter out of ast module\n\nMove the token vector to tokenstream converter out of the TokenCollector\nclass. This code is not exactly related to the token collection and the\ncode would be clearer with this rather lengthy conversion split on it's\nown.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add new rust-token-converter file.\n\t* ast/rust-ast-collector.cc (pop_group): Function moved from\n\tTokenCollector.\n\t(dispatch_float_literals): Likewise.\n\t(dispatch_integer_literals): Likewise.\n\t(TokenCollector::collect): Removed function.\n\t* ast/rust-ast-collector.h: Removed function prototype.\n\t* util/rust-token-converter.cc: New file.\n\t* util/rust-token-converter.h: New file.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "70b8309c7be86199674ec27c70316999447324a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70b8309c7be86199674ec27c70316999447324a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f6b7459551d535ac1d279964c0d30145cd75eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f6b7459551d535ac1d279964c0d30145cd75eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f6b7459551d535ac1d279964c0d30145cd75eb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f6b7459551d535ac1d279964c0d30145cd75eb5/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dc0dab7e8e626e3f4fc2df2c64a8671bf90fe89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dc0dab7e8e626e3f4fc2df2c64a8671bf90fe89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dc0dab7e8e626e3f4fc2df2c64a8671bf90fe89"}], "stats": {"total": 646, "additions": 345, "deletions": 301}, "files": [{"sha": "14f1d08a6f723851b03e9c936e0e50be29bdf219", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=8f6b7459551d535ac1d279964c0d30145cd75eb5", "patch": "@@ -94,6 +94,7 @@ GRS_OBJS = \\\n     rust/rust-hir-map.o \\\n     rust/rust-attributes.o \\\n     rust/rust-abi.o \\\n+    rust/rust-token-converter.o \\\n \trust/rust-macro.o \\\n     rust/rust-ast-lower.o \\\n     rust/rust-ast-lower-base.o \\"}, {"sha": "586fc031af01f83a9a8e768cda5f07c4061d003f", "filename": "gcc/rust/ast/rust-ast-collector.cc", "status": "modified", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Fast%2Frust-ast-collector.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Fast%2Frust-ast-collector.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-collector.cc?ref=8f6b7459551d535ac1d279964c0d30145cd75eb5", "patch": "@@ -16,7 +16,6 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n #include \"rust-ast-collector.h\"\n-#include \"libproc_macro/proc_macro.h\"\n \n namespace Rust {\n namespace AST {\n@@ -31,302 +30,6 @@ TokenCollector::collect_tokens () const\n   return tokens;\n }\n \n-static void\n-pop_group (std::vector<ProcMacro::TokenStream> &streams,\n-\t   ProcMacro::Delimiter delim)\n-{\n-  auto g = ProcMacro::Group::make_group (streams.back (), delim);\n-  streams.pop_back ();\n-  auto tt = ProcMacro::TokenTree::make_tokentree (g);\n-\n-  streams.back ().push (tt);\n-}\n-\n-static void\n-dispatch_float_literals (ProcMacro::TokenStream &ts, TokenPtr &token)\n-{\n-  std::string::size_type sz;\n-  auto str = token->as_string ();\n-  switch (token->get_type_hint ())\n-    {\n-      case CORETYPE_F32: {\n-\tauto value = std::stof (str, &sz);\n-\tbool suffixed = sz == str.length ();\n-\tts.push (ProcMacro::TokenTree::make_tokentree (\n-\t  ProcMacro::Literal::make_f32 (value, suffixed)));\n-      }\n-      break;\n-      case CORETYPE_F64: {\n-\tauto value = std::stod (str, &sz);\n-\tbool suffixed = sz == str.length ();\n-\tts.push (ProcMacro::TokenTree::make_tokentree (\n-\t  ProcMacro::Literal::make_f64 (value, suffixed)));\n-      }\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-static void\n-dispatch_integer_literals (ProcMacro::TokenStream &ts, TokenPtr &token)\n-{\n-  std::string::size_type sz;\n-  auto str = token->as_string ();\n-  unsigned long long uvalue;\n-  long long svalue;\n-  bool suffixed = false;\n-\n-  switch (token->get_type_hint ())\n-    {\n-    case CORETYPE_U8:\n-      uvalue = std::stoull (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u8 (uvalue, suffixed)));\n-      break;\n-    case CORETYPE_U16:\n-      uvalue = std::stoull (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u16 (uvalue, suffixed)));\n-      break;\n-    case CORETYPE_U32:\n-      uvalue = std::stoull (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u32 (uvalue, suffixed)));\n-      break;\n-    case CORETYPE_U64:\n-      uvalue = std::stoull (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u32 (uvalue, suffixed)));\n-      break;\n-    case CORETYPE_I8:\n-      svalue = std::stoll (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i8 (svalue, suffixed)));\n-      break;\n-    case CORETYPE_I16:\n-      svalue = std::stoll (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i16 (svalue, suffixed)));\n-      break;\n-    case CORETYPE_I32:\n-      svalue = std::stoll (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i32 (svalue, suffixed)));\n-      break;\n-    case CORETYPE_I64:\n-      svalue = std::stoll (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i32 (svalue, suffixed)));\n-      break;\n-    case CORETYPE_INT:\n-      svalue = std::stoll (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_isize (svalue, suffixed)));\n-      break;\n-    case CORETYPE_UINT:\n-      uvalue = std::stoull (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_usize (uvalue, suffixed)));\n-      break;\n-    case CORETYPE_UNKNOWN:\n-      svalue = std::stoll (str, &sz);\n-      suffixed = sz == str.length ();\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i32 (svalue, false)));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-}\n-\n-ProcMacro::TokenStream\n-TokenCollector::collect () const\n-{\n-  std::vector<ProcMacro::TokenStream> trees;\n-  trees.push_back (ProcMacro::TokenStream::make_tokenstream ());\n-  for (auto &token : collect_tokens ())\n-    {\n-      switch (token->get_id ())\n-\t{\n-\t// Literals\n-\tcase FLOAT_LITERAL:\n-\t  dispatch_float_literals (trees.back (), token);\n-\t  break;\n-\tcase INT_LITERAL:\n-\t  dispatch_integer_literals (trees.back (), token);\n-\t  break;\n-\t// FIXME: Why does BYTE_CHAR_LITERAL is not handled by rustc ?\n-\tcase CHAR_LITERAL: // TODO: UTF-8 handling\n-\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t    ProcMacro::Literal::make_char (token->as_string ()[0])));\n-\t  break;\n-\tcase STRING_LITERAL:\n-\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t    ProcMacro::Literal::make_string (token->as_string ())));\n-\t  break;\n-\t  case BYTE_STRING_LITERAL: {\n-\t    auto str = token->as_string ();\n-\t    std::vector<uint8_t> data (str.begin (), str.end ());\n-\t    trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t      ProcMacro::Literal::make_byte_string (data)));\n-\t  }\n-\t  break;\n-\t// Ident\n-\tcase IDENTIFIER:\n-\tcase ABSTRACT:\n-\tcase AS:\n-\tcase ASYNC:\n-\tcase AUTO:\n-\tcase BECOME:\n-\tcase BOX:\n-\tcase BREAK:\n-\tcase CONST:\n-\tcase CONTINUE:\n-\tcase CRATE:\n-\tcase DO:\n-\tcase DYN:\n-\tcase ELSE:\n-\tcase ENUM_TOK:\n-\tcase EXTERN_TOK:\n-\tcase FINAL_TOK:\n-\tcase FN_TOK:\n-\tcase FOR:\n-\tcase IF:\n-\tcase IMPL:\n-\tcase IN:\n-\tcase LET:\n-\tcase LOOP:\n-\tcase MACRO:\n-\tcase MATCH_TOK:\n-\tcase MOD:\n-\tcase MOVE:\n-\tcase MUT:\n-\tcase OVERRIDE_TOK:\n-\tcase PRIV:\n-\tcase PUB:\n-\tcase REF:\n-\tcase RETURN_TOK:\n-\tcase SELF_ALIAS:\n-\tcase SELF:\n-\tcase STATIC_TOK:\n-\tcase STRUCT_TOK:\n-\tcase SUPER:\n-\tcase TRAIT:\n-\tcase TRY:\n-\tcase TYPE:\n-\tcase TYPEOF:\n-\tcase UNSAFE:\n-\tcase UNSIZED:\n-\tcase USE:\n-\tcase VIRTUAL:\n-\tcase WHERE:\n-\tcase WHILE:\n-\tcase YIELD:\n-\t// Underscore is not a Punct, considered as an Ident\n-\tcase UNDERSCORE:\n-\t// True and false are idents, not literals\n-\t// (https://doc.rust-lang.org/proc_macro/struct.Literal.html)\n-\tcase FALSE_LITERAL:\n-\tcase TRUE_LITERAL:\n-\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t    ProcMacro::Ident::make_ident (token->as_string ())));\n-\t  break;\n-\t// Joint punct\n-\tcase OR:\n-\tcase PIPE_EQ:\n-\tcase CARET_EQ:\n-\tcase RIGHT_SHIFT_EQ:\n-\tcase RIGHT_SHIFT:\n-\tcase GREATER_OR_EQUAL:\n-\tcase MATCH_ARROW:\n-\tcase LESS_OR_EQUAL:\n-\tcase LEFT_SHIFT_EQ:\n-\tcase LEFT_SHIFT:\n-\tcase DIV_EQ:\n-\tcase ELLIPSIS:\n-\tcase DOT_DOT_EQ:\n-\tcase DOT_DOT:\n-\tcase RETURN_TYPE:\n-\tcase MINUS_EQ:\n-\tcase PLUS_EQ:\n-\tcase ASTERISK_EQ:\n-\tcase LOGICAL_AND:\n-\tcase AMP_EQ:\n-\tcase PERCENT_EQ:\n-\tcase SCOPE_RESOLUTION:\n-\tcase NOT_EQUAL:\n-\t  case EQUAL_EQUAL: {\n-\t    auto str = token->as_string ();\n-\t    auto it = str.cbegin ();\n-\t    for (; it != str.cend () - 1; it++)\n-\t      {\n-\t\ttrees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t\t  ProcMacro::Punct::make_punct (*it, ProcMacro::JOINT)));\n-\t      }\n-\t    trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t      ProcMacro::Punct::make_punct (*it, ProcMacro::ALONE)));\n-\t  }\n-\t  break;\n-\t// Alone punct tokens\n-\tcase EQUAL:\n-\tcase RIGHT_ANGLE:\n-\tcase LEFT_ANGLE:\n-\tcase EXCLAM:\n-\tcase TILDE:\n-\tcase PLUS:\n-\tcase MINUS:\n-\tcase ASTERISK:\n-\tcase DIV:\n-\tcase PERCENT:\n-\tcase CARET:\n-\tcase AMP:\n-\tcase PIPE:\n-\tcase PATTERN_BIND:\n-\tcase DOT:\n-\tcase COMMA:\n-\tcase SEMICOLON:\n-\tcase COLON:\n-\tcase HASH:\n-\tcase DOLLAR_SIGN:\n-\tcase QUESTION_MARK:\n-\tcase SINGLE_QUOTE:\n-\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t    ProcMacro::Punct::make_punct (token->as_string ()[0],\n-\t\t\t\t\t  ProcMacro::ALONE)));\n-\t  break;\n-\tcase RIGHT_PAREN:\n-\t  pop_group (trees, ProcMacro::PARENTHESIS);\n-\t  break;\n-\tcase RIGHT_CURLY:\n-\t  pop_group (trees, ProcMacro::BRACE);\n-\t  break;\n-\tcase RIGHT_SQUARE:\n-\t  pop_group (trees, ProcMacro::BRACKET);\n-\t  break;\n-\tcase LEFT_SQUARE:\n-\tcase LEFT_CURLY:\n-\tcase LEFT_PAREN:\n-\t  trees.push_back (ProcMacro::TokenStream::make_tokenstream ());\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  return trees.back ();\n-}\n-\n void\n TokenCollector::visit (AST::Crate &crate)\n {"}, {"sha": "868de037c3e05b38b1a59d58bdbb3c03f54caeb6", "filename": "gcc/rust/ast/rust-ast-collector.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Fast%2Frust-ast-collector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Fast%2Frust-ast-collector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-collector.h?ref=8f6b7459551d535ac1d279964c0d30145cd75eb5", "patch": "@@ -24,8 +24,6 @@\n #include \"rust-ast.h\"\n #include \"rust-ast-full.h\"\n \n-#include \"libproc_macro/tokenstream.h\"\n-\n namespace Rust {\n namespace AST {\n \n@@ -40,8 +38,6 @@ class TokenCollector : public ASTVisitor\n \n   std::vector<TokenPtr> collect_tokens () const;\n \n-  ProcMacro::TokenStream collect () const;\n-\n private:\n   std::vector<TokenPtr> &tokens;\n "}, {"sha": "344822f5ea0af38009732954bc0373882e364160", "filename": "gcc/rust/util/rust-token-converter.cc", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Futil%2Frust-token-converter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Futil%2Frust-token-converter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-token-converter.cc?ref=8f6b7459551d535ac1d279964c0d30145cd75eb5", "patch": "@@ -0,0 +1,313 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-token-converter.h\"\n+#include \"libproc_macro/proc_macro.h\"\n+\n+namespace Rust {\n+\n+static void\n+pop_group (std::vector<ProcMacro::TokenStream> &streams,\n+\t   ProcMacro::Delimiter delim)\n+{\n+  auto g = ProcMacro::Group::make_group (streams.back (), delim);\n+  streams.pop_back ();\n+  auto tt = ProcMacro::TokenTree::make_tokentree (g);\n+\n+  streams.back ().push (tt);\n+}\n+\n+static void\n+dispatch_float_literals (ProcMacro::TokenStream &ts, TokenPtr &token)\n+{\n+  std::string::size_type sz;\n+  auto str = token->as_string ();\n+  switch (token->get_type_hint ())\n+    {\n+      case CORETYPE_F32: {\n+\tauto value = std::stof (str, &sz);\n+\tbool suffixed = sz == str.length ();\n+\tts.push (ProcMacro::TokenTree::make_tokentree (\n+\t  ProcMacro::Literal::make_f32 (value, suffixed)));\n+      }\n+      break;\n+      case CORETYPE_F64: {\n+\tauto value = std::stod (str, &sz);\n+\tbool suffixed = sz == str.length ();\n+\tts.push (ProcMacro::TokenTree::make_tokentree (\n+\t  ProcMacro::Literal::make_f64 (value, suffixed)));\n+      }\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static void\n+dispatch_integer_literals (ProcMacro::TokenStream &ts, TokenPtr &token)\n+{\n+  std::string::size_type sz;\n+  auto str = token->as_string ();\n+  unsigned long long uvalue;\n+  long long svalue;\n+  bool suffixed = false;\n+\n+  switch (token->get_type_hint ())\n+    {\n+    case CORETYPE_U8:\n+      uvalue = std::stoull (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_u8 (uvalue, suffixed)));\n+      break;\n+    case CORETYPE_U16:\n+      uvalue = std::stoull (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_u16 (uvalue, suffixed)));\n+      break;\n+    case CORETYPE_U32:\n+      uvalue = std::stoull (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_u32 (uvalue, suffixed)));\n+      break;\n+    case CORETYPE_U64:\n+      uvalue = std::stoull (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_u32 (uvalue, suffixed)));\n+      break;\n+    case CORETYPE_I8:\n+      svalue = std::stoll (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_i8 (svalue, suffixed)));\n+      break;\n+    case CORETYPE_I16:\n+      svalue = std::stoll (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_i16 (svalue, suffixed)));\n+      break;\n+    case CORETYPE_I32:\n+      svalue = std::stoll (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_i32 (svalue, suffixed)));\n+      break;\n+    case CORETYPE_I64:\n+      svalue = std::stoll (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_i32 (svalue, suffixed)));\n+      break;\n+    case CORETYPE_INT:\n+      svalue = std::stoll (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_isize (svalue, suffixed)));\n+      break;\n+    case CORETYPE_UINT:\n+      uvalue = std::stoull (str, &sz);\n+      suffixed = sz == str.length ();\n+      ts.push (ProcMacro::TokenTree::make_tokentree (\n+\tProcMacro::Literal::make_usize (uvalue, suffixed)));\n+      break;\n+    case CORETYPE_UNKNOWN:\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+ProcMacro::TokenStream\n+to_tokenstream (std::vector<TokenPtr> tokens)\n+{\n+  std::vector<ProcMacro::TokenStream> trees;\n+  trees.push_back (ProcMacro::TokenStream::make_tokenstream ());\n+  for (auto &token : tokens)\n+    {\n+      switch (token->get_id ())\n+\t{\n+\t// Literals\n+\tcase FLOAT_LITERAL:\n+\t  dispatch_float_literals (trees.back (), token);\n+\t  break;\n+\tcase INT_LITERAL:\n+\t  dispatch_integer_literals (trees.back (), token);\n+\t  break;\n+\t// FIXME: Why does BYTE_CHAR_LITERAL is not handled by rustc ?\n+\tcase CHAR_LITERAL: // TODO: UTF-8 handling\n+\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t    ProcMacro::Literal::make_char (token->as_string ()[0])));\n+\t  break;\n+\tcase STRING_LITERAL:\n+\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t    ProcMacro::Literal::make_string (token->as_string ())));\n+\t  break;\n+\t  case BYTE_STRING_LITERAL: {\n+\t    auto str = token->as_string ();\n+\t    std::vector<uint8_t> data (str.begin (), str.end ());\n+\t    trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t      ProcMacro::Literal::make_byte_string (data)));\n+\t  }\n+\t  break;\n+\t// Ident\n+\tcase IDENTIFIER:\n+\tcase ABSTRACT:\n+\tcase AS:\n+\tcase ASYNC:\n+\tcase AUTO:\n+\tcase BECOME:\n+\tcase BOX:\n+\tcase BREAK:\n+\tcase CONST:\n+\tcase CONTINUE:\n+\tcase CRATE:\n+\tcase DO:\n+\tcase DYN:\n+\tcase ELSE:\n+\tcase ENUM_TOK:\n+\tcase EXTERN_TOK:\n+\tcase FINAL_TOK:\n+\tcase FN_TOK:\n+\tcase FOR:\n+\tcase IF:\n+\tcase IMPL:\n+\tcase IN:\n+\tcase LET:\n+\tcase LOOP:\n+\tcase MACRO:\n+\tcase MATCH_TOK:\n+\tcase MOD:\n+\tcase MOVE:\n+\tcase MUT:\n+\tcase OVERRIDE_TOK:\n+\tcase PRIV:\n+\tcase PUB:\n+\tcase REF:\n+\tcase RETURN_TOK:\n+\tcase SELF_ALIAS:\n+\tcase SELF:\n+\tcase STATIC_TOK:\n+\tcase STRUCT_TOK:\n+\tcase SUPER:\n+\tcase TRAIT:\n+\tcase TRY:\n+\tcase TYPE:\n+\tcase TYPEOF:\n+\tcase UNSAFE:\n+\tcase UNSIZED:\n+\tcase USE:\n+\tcase VIRTUAL:\n+\tcase WHERE:\n+\tcase WHILE:\n+\tcase YIELD:\n+\t// Underscore is not a Punct, considered as an Ident\n+\tcase UNDERSCORE:\n+\t// True and false are idents, not literals\n+\t// (https://doc.rust-lang.org/proc_macro/struct.Literal.html)\n+\tcase FALSE_LITERAL:\n+\tcase TRUE_LITERAL:\n+\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t    ProcMacro::Ident::make_ident (token->as_string ())));\n+\t  break;\n+\t// Joint punct\n+\tcase OR:\n+\tcase PIPE_EQ:\n+\tcase CARET_EQ:\n+\tcase RIGHT_SHIFT_EQ:\n+\tcase RIGHT_SHIFT:\n+\tcase GREATER_OR_EQUAL:\n+\tcase MATCH_ARROW:\n+\tcase LESS_OR_EQUAL:\n+\tcase LEFT_SHIFT_EQ:\n+\tcase LEFT_SHIFT:\n+\tcase DIV_EQ:\n+\tcase ELLIPSIS:\n+\tcase DOT_DOT_EQ:\n+\tcase DOT_DOT:\n+\tcase RETURN_TYPE:\n+\tcase MINUS_EQ:\n+\tcase PLUS_EQ:\n+\tcase ASTERISK_EQ:\n+\tcase LOGICAL_AND:\n+\tcase AMP_EQ:\n+\tcase PERCENT_EQ:\n+\tcase SCOPE_RESOLUTION:\n+\tcase NOT_EQUAL:\n+\t  case EQUAL_EQUAL: {\n+\t    auto str = token->as_string ();\n+\t    auto it = str.cbegin ();\n+\t    for (; it != str.cend () - 1; it++)\n+\t      {\n+\t\ttrees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t\t  ProcMacro::Punct::make_punct (*it, ProcMacro::JOINT)));\n+\t      }\n+\t    trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t      ProcMacro::Punct::make_punct (*it, ProcMacro::ALONE)));\n+\t  }\n+\t  break;\n+\t// Alone punct tokens\n+\tcase EQUAL:\n+\tcase RIGHT_ANGLE:\n+\tcase LEFT_ANGLE:\n+\tcase EXCLAM:\n+\tcase TILDE:\n+\tcase PLUS:\n+\tcase MINUS:\n+\tcase ASTERISK:\n+\tcase DIV:\n+\tcase PERCENT:\n+\tcase CARET:\n+\tcase AMP:\n+\tcase PIPE:\n+\tcase PATTERN_BIND:\n+\tcase DOT:\n+\tcase COMMA:\n+\tcase SEMICOLON:\n+\tcase COLON:\n+\tcase HASH:\n+\tcase DOLLAR_SIGN:\n+\tcase QUESTION_MARK:\n+\tcase SINGLE_QUOTE:\n+\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t    ProcMacro::Punct::make_punct (token->as_string ()[0],\n+\t\t\t\t\t  ProcMacro::ALONE)));\n+\t  break;\n+\tcase RIGHT_PAREN:\n+\t  pop_group (trees, ProcMacro::PARENTHESIS);\n+\t  break;\n+\tcase RIGHT_CURLY:\n+\t  pop_group (trees, ProcMacro::BRACE);\n+\t  break;\n+\tcase RIGHT_SQUARE:\n+\t  pop_group (trees, ProcMacro::BRACKET);\n+\t  break;\n+\tcase LEFT_SQUARE:\n+\tcase LEFT_CURLY:\n+\tcase LEFT_PAREN:\n+\t  trees.push_back (ProcMacro::TokenStream::make_tokenstream ());\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  return trees.back ();\n+}\n+\n+} // namespace Rust"}, {"sha": "5be745cd66c1a438a7568aabbfeef6e5905e873f", "filename": "gcc/rust/util/rust-token-converter.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Futil%2Frust-token-converter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f6b7459551d535ac1d279964c0d30145cd75eb5/gcc%2Frust%2Futil%2Frust-token-converter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-token-converter.h?ref=8f6b7459551d535ac1d279964c0d30145cd75eb5", "patch": "@@ -0,0 +1,31 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TOKEN_CONVERTER_H\n+#define RUST_TOKEN_CONVERTER_H\n+\n+#include <vector>\n+#include \"rust-token.h\"\n+#include \"libproc_macro/tokenstream.h\"\n+\n+namespace Rust {\n+\n+ProcMacro::TokenStream\n+to_tokenstream (std::vector<TokenPtr> tokens);\n+\n+} // namespace Rust\n+\n+#endif /* ! RUST_TOKEN_CONVERTER_H */"}]}