{"sha": "90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlNDYwNzRlNmIzNTYxYWU3ZDhlYmQyMDUxMjdmMjg2Y2MwYzZiNg==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-07-20T17:44:37Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-07-20T21:21:51Z"}, "message": "libsanitizer: Merge with upstream\n\nMerged revision: 7704fedfff6ef5676adb6415f3be0ac927d1a746", "tree": {"sha": "6f21ee7eafae85d0aacc994e221c48d3bb172df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f21ee7eafae85d0aacc994e221c48d3bb172df0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf5b49ebd2176b8c535147377381dd07fbdd643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf5b49ebd2176b8c535147377381dd07fbdd643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf5b49ebd2176b8c535147377381dd07fbdd643"}], "stats": {"total": 4992, "additions": 2284, "deletions": 2708}, "files": [{"sha": "81d00f27de45653f7783663a169bb7b2f0f18a1f", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -1,4 +1,4 @@\n-f58e0513dd95944b81ce7a6e7b49ba656de7d75f\n+7704fedfff6ef5676adb6415f3be0ac927d1a746\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "74658ca7b9c72f952693c1277fa4f0256433a11c", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -38,7 +38,6 @@ asan_files = \\\n \tasan_posix.cpp \\\n \tasan_premap_shadow.cpp \\\n \tasan_report.cpp \\\n-\tasan_rtems.cpp \\\n \tasan_rtl.cpp \\\n \tasan_shadow_setup.cpp \\\n \tasan_stack.cpp \\"}, {"sha": "53efe526f9c4fbdba054e9db30cc2675e1050f4e", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -156,9 +156,9 @@ am__objects_1 = asan_activation.lo asan_allocator.lo asan_debugging.lo \\\n \tasan_interceptors_memintrinsics.lo asan_linux.lo asan_mac.lo \\\n \tasan_malloc_linux.lo asan_malloc_mac.lo asan_malloc_win.lo \\\n \tasan_memory_profile.lo asan_new_delete.lo asan_poisoning.lo \\\n-\tasan_posix.lo asan_premap_shadow.lo asan_report.lo \\\n-\tasan_rtems.lo asan_rtl.lo asan_shadow_setup.lo asan_stack.lo \\\n-\tasan_stats.lo asan_suppressions.lo asan_thread.lo asan_win.lo \\\n+\tasan_posix.lo asan_premap_shadow.lo asan_report.lo asan_rtl.lo \\\n+\tasan_shadow_setup.lo asan_stack.lo asan_stats.lo \\\n+\tasan_suppressions.lo asan_thread.lo asan_win.lo \\\n \tasan_win_dll_thunk.lo asan_win_dynamic_runtime_thunk.lo \\\n \tasan_interceptors_vfork.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n@@ -446,7 +446,6 @@ asan_files = \\\n \tasan_posix.cpp \\\n \tasan_premap_shadow.cpp \\\n \tasan_report.cpp \\\n-\tasan_rtems.cpp \\\n \tasan_rtl.cpp \\\n \tasan_shadow_setup.cpp \\\n \tasan_stack.cpp \\\n@@ -604,7 +603,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_premap_shadow.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_report.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtems.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_shadow_setup.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@"}, {"sha": "414fba3b427d44924548d41abaa2d31bae10c28f", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -852,12 +852,12 @@ struct Allocator {\n     quarantine.PrintStats();\n   }\n \n-  void ForceLock() {\n+  void ForceLock() ACQUIRE(fallback_mutex) {\n     allocator.ForceLock();\n     fallback_mutex.Lock();\n   }\n \n-  void ForceUnlock() {\n+  void ForceUnlock() RELEASE(fallback_mutex) {\n     fallback_mutex.Unlock();\n     allocator.ForceUnlock();\n   }\n@@ -1081,11 +1081,9 @@ uptr asan_mz_size(const void *ptr) {\n   return instance.AllocationSize(reinterpret_cast<uptr>(ptr));\n }\n \n-void asan_mz_force_lock() {\n-  instance.ForceLock();\n-}\n+void asan_mz_force_lock() NO_THREAD_SAFETY_ANALYSIS { instance.ForceLock(); }\n \n-void asan_mz_force_unlock() {\n+void asan_mz_force_unlock() NO_THREAD_SAFETY_ANALYSIS {\n   instance.ForceUnlock();\n }\n "}, {"sha": "45166c0648773622baba3628868da8b5ddd34026", "filename": "libsanitizer/asan/asan_errors.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_errors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_errors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -533,7 +533,6 @@ static void PrintLegend(InternalScopedString *str) {\n   PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n   PrintShadowByte(str, \"  Left alloca redzone:     \", kAsanAllocaLeftMagic);\n   PrintShadowByte(str, \"  Right alloca redzone:    \", kAsanAllocaRightMagic);\n-  PrintShadowByte(str, \"  Shadow gap:              \", kAsanShadowGap);\n }\n \n static void PrintShadowBytes(InternalScopedString *str, const char *before,"}, {"sha": "bf5c342ee59db5215648f1d553e93b5ed1ee331a", "filename": "libsanitizer/asan/asan_fake_stack.cpp", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_fake_stack.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_fake_stack.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -187,7 +187,7 @@ void SetTLSFakeStack(FakeStack *fs) { }\n static FakeStack *GetFakeStack() {\n   AsanThread *t = GetCurrentThread();\n   if (!t) return nullptr;\n-  return t->fake_stack();\n+  return t->get_or_create_fake_stack();\n }\n \n static FakeStack *GetFakeStackFast() {\n@@ -198,7 +198,13 @@ static FakeStack *GetFakeStackFast() {\n   return GetFakeStack();\n }\n \n-ALWAYS_INLINE uptr OnMalloc(uptr class_id, uptr size) {\n+static FakeStack *GetFakeStackFastAlways() {\n+  if (FakeStack *fs = GetTLSFakeStack())\n+    return fs;\n+  return GetFakeStack();\n+}\n+\n+static ALWAYS_INLINE uptr OnMalloc(uptr class_id, uptr size) {\n   FakeStack *fs = GetFakeStackFast();\n   if (!fs) return 0;\n   uptr local_stack;\n@@ -210,7 +216,21 @@ ALWAYS_INLINE uptr OnMalloc(uptr class_id, uptr size) {\n   return ptr;\n }\n \n-ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size) {\n+static ALWAYS_INLINE uptr OnMallocAlways(uptr class_id, uptr size) {\n+  FakeStack *fs = GetFakeStackFastAlways();\n+  if (!fs)\n+    return 0;\n+  uptr local_stack;\n+  uptr real_stack = reinterpret_cast<uptr>(&local_stack);\n+  FakeFrame *ff = fs->Allocate(fs->stack_size_log(), class_id, real_stack);\n+  if (!ff)\n+    return 0;  // Out of fake stack.\n+  uptr ptr = reinterpret_cast<uptr>(ff);\n+  SetShadow(ptr, size, class_id, 0);\n+  return ptr;\n+}\n+\n+static ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size) {\n   FakeStack::Deallocate(ptr, class_id);\n   SetShadow(ptr, size, class_id, kMagic8);\n }\n@@ -219,14 +239,18 @@ ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size) {\n \n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;\n-#define DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(class_id)                       \\\n-  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr                                \\\n-      __asan_stack_malloc_##class_id(uptr size) {                              \\\n-    return OnMalloc(class_id, size);                                           \\\n-  }                                                                            \\\n-  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __asan_stack_free_##class_id(  \\\n-      uptr ptr, uptr size) {                                                   \\\n-    OnFree(ptr, class_id, size);                                               \\\n+#define DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(class_id)                      \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr                               \\\n+      __asan_stack_malloc_##class_id(uptr size) {                             \\\n+    return OnMalloc(class_id, size);                                          \\\n+  }                                                                           \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr                               \\\n+      __asan_stack_malloc_always_##class_id(uptr size) {                      \\\n+    return OnMallocAlways(class_id, size);                                    \\\n+  }                                                                           \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __asan_stack_free_##class_id( \\\n+      uptr ptr, uptr size) {                                                  \\\n+    OnFree(ptr, class_id, size);                                              \\\n   }\n \n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(0)\n@@ -240,7 +264,11 @@ DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(7)\n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(8)\n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(9)\n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(10)\n+\n extern \"C\" {\n+// TODO: remove this method and fix tests that use it by setting\n+// -asan-use-after-return=never, after modal UAR flag lands\n+// (https://github.com/google/sanitizers/issues/1394)\n SANITIZER_INTERFACE_ATTRIBUTE\n void *__asan_get_current_fake_stack() { return GetFakeStackFast(); }\n "}, {"sha": "c64e464702875219491992209a3936b3e9e7ca21", "filename": "libsanitizer/asan/asan_flags.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -155,10 +155,6 @@ void InitializeFlags() {\n   CHECK_LE(f->max_redzone, 2048);\n   CHECK(IsPowerOfTwo(f->redzone));\n   CHECK(IsPowerOfTwo(f->max_redzone));\n-  if (SANITIZER_RTEMS) {\n-    CHECK(!f->unmap_shadow_on_exit);\n-    CHECK(!f->protect_shadow_gap);\n-  }\n \n   // quarantine_size is deprecated but we still honor it.\n   // quarantine_size can not be used together with quarantine_size_mb."}, {"sha": "514b225c40731e0e3a434915ec7a084d1214897c", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -87,8 +87,7 @@ ASAN_FLAG(bool, check_malloc_usable_size, true,\n           \"295.*.\")\n ASAN_FLAG(bool, unmap_shadow_on_exit, false,\n           \"If set, explicitly unmaps the (huge) shadow at exit.\")\n-ASAN_FLAG(bool, protect_shadow_gap, !SANITIZER_RTEMS,\n-          \"If set, mprotect the shadow gap\")\n+ASAN_FLAG(bool, protect_shadow_gap, true, \"If set, mprotect the shadow gap\")\n ASAN_FLAG(bool, print_stats, false,\n           \"Print various statistics after printing an error message or if \"\n           \"atexit=1.\")"}, {"sha": "9d7dbc6f264cea7b80a71a91da37cfa0cfbbd0db", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "d0a6dd48a74860b7fdffede2075e8c3d623d9967", "filename": "libsanitizer/asan/asan_interceptors.cpp", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -23,25 +23,25 @@\n #include \"lsan/lsan_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n-// There is no general interception at all on Fuchsia and RTEMS.\n+// There is no general interception at all on Fuchsia.\n // Only the functions in asan_interceptors_memintrinsics.cpp are\n // really defined to replace libc functions.\n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+#if !SANITIZER_FUCHSIA\n \n-#if SANITIZER_POSIX\n-#include \"sanitizer_common/sanitizer_posix.h\"\n-#endif\n+#  if SANITIZER_POSIX\n+#    include \"sanitizer_common/sanitizer_posix.h\"\n+#  endif\n \n-#if ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION || \\\n-    ASAN_INTERCEPT__SJLJ_UNWIND_RAISEEXCEPTION\n-#include <unwind.h>\n-#endif\n+#  if ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION || \\\n+      ASAN_INTERCEPT__SJLJ_UNWIND_RAISEEXCEPTION\n+#    include <unwind.h>\n+#  endif\n \n-#if defined(__i386) && SANITIZER_LINUX\n-#define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.1\"\n-#elif defined(__mips__) && SANITIZER_LINUX\n-#define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.2\"\n-#endif\n+#  if defined(__i386) && SANITIZER_LINUX\n+#    define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.1\"\n+#  elif defined(__mips__) && SANITIZER_LINUX\n+#    define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.2\"\n+#  endif\n \n namespace __asan {\n "}, {"sha": "a9249dea45b9a9031101a750c392f65ad197fb78", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -34,10 +34,10 @@ void InitializePlatformInterceptors();\n \n }  // namespace __asan\n \n-// There is no general interception at all on Fuchsia and RTEMS.\n+// There is no general interception at all on Fuchsia.\n // Only the functions in asan_interceptors_memintrinsics.h are\n // really defined to replace libc functions.\n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+#if !SANITIZER_FUCHSIA\n \n // Use macro to describe if specific function should be\n // intercepted on a given platform.\n@@ -81,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else"}, {"sha": "9c316bb95749351b130d8a8af8d9769c7f162cbb", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -30,14 +30,14 @@ void *__asan_memmove(void *to, const void *from, uptr size) {\n   ASAN_MEMMOVE_IMPL(nullptr, to, from, size);\n }\n \n-#if SANITIZER_FUCHSIA || SANITIZER_RTEMS\n+#if SANITIZER_FUCHSIA\n \n-// Fuchsia and RTEMS don't use sanitizer_common_interceptors.inc, but\n+// Fuchsia doesn't use sanitizer_common_interceptors.inc, but\n // the only things there it wants are these three.  Just define them\n // as aliases here rather than repeating the contents.\n \n extern \"C\" decltype(__asan_memcpy) memcpy[[gnu::alias(\"__asan_memcpy\")]];\n extern \"C\" decltype(__asan_memmove) memmove[[gnu::alias(\"__asan_memmove\")]];\n extern \"C\" decltype(__asan_memset) memset[[gnu::alias(\"__asan_memset\")]];\n \n-#endif  // SANITIZER_FUCHSIA || SANITIZER_RTEMS\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "ea28fc8ae87c519389804bcdde9f82c8b4e828ae", "filename": "libsanitizer/asan/asan_interface.inc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface.inc?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -134,6 +134,17 @@ INTERFACE_FUNCTION(__asan_stack_malloc_7)\n INTERFACE_FUNCTION(__asan_stack_malloc_8)\n INTERFACE_FUNCTION(__asan_stack_malloc_9)\n INTERFACE_FUNCTION(__asan_stack_malloc_10)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_0)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_1)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_2)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_3)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_4)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_5)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_6)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_7)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_8)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_9)\n+INTERFACE_FUNCTION(__asan_stack_malloc_always_10)\n INTERFACE_FUNCTION(__asan_store1)\n INTERFACE_FUNCTION(__asan_store2)\n INTERFACE_FUNCTION(__asan_store4)"}, {"sha": "ad3320304d0ddcca2ee99583b05b03b25e462fff", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -35,11 +35,11 @@\n // If set, values like allocator chunk size, as well as defaults for some flags\n // will be changed towards less memory overhead.\n #ifndef ASAN_LOW_MEMORY\n-# if SANITIZER_IOS || SANITIZER_ANDROID || SANITIZER_RTEMS\n-#  define ASAN_LOW_MEMORY 1\n-# else\n-#  define ASAN_LOW_MEMORY 0\n-# endif\n+#  if SANITIZER_IOS || SANITIZER_ANDROID\n+#    define ASAN_LOW_MEMORY 1\n+#  else\n+#    define ASAN_LOW_MEMORY 0\n+#  endif\n #endif\n \n #ifndef ASAN_DYNAMIC\n@@ -77,7 +77,7 @@ void InitializeShadowMemory();\n // asan_malloc_linux.cpp / asan_malloc_mac.cpp\n void ReplaceSystemMalloc();\n \n-// asan_linux.cpp / asan_mac.cpp / asan_rtems.cpp / asan_win.cpp\n+// asan_linux.cpp / asan_mac.cpp / asan_win.cpp\n uptr FindDynamicShadowStart();\n void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n@@ -159,9 +159,6 @@ const int kAsanArrayCookieMagic = 0xac;\n const int kAsanIntraObjectRedzone = 0xbb;\n const int kAsanAllocaLeftMagic = 0xca;\n const int kAsanAllocaRightMagic = 0xcb;\n-// Used to populate the shadow gap for systems without memory\n-// protection there (i.e. Myriad).\n-const int kAsanShadowGap = 0xcc;\n \n static const uptr kCurrentStackFrameMagic = 0x41B58AB3;\n static const uptr kRetiredStackFrameMagic = 0x45E0360E;"}, {"sha": "c6bec8551bc5ad60c2673de88dbe4ac8e65b8ded", "filename": "libsanitizer/asan/asan_malloc_linux.cpp", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -15,23 +15,22 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_FREEBSD || SANITIZER_FUCHSIA || SANITIZER_LINUX || \\\n-    SANITIZER_NETBSD || SANITIZER_RTEMS || SANITIZER_SOLARIS\n+    SANITIZER_NETBSD || SANITIZER_SOLARIS\n \n-#include \"sanitizer_common/sanitizer_allocator_checks.h\"\n-#include \"sanitizer_common/sanitizer_errno.h\"\n-#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n-#include \"asan_allocator.h\"\n-#include \"asan_interceptors.h\"\n-#include \"asan_internal.h\"\n-#include \"asan_malloc_local.h\"\n-#include \"asan_stack.h\"\n+#  include \"asan_allocator.h\"\n+#  include \"asan_interceptors.h\"\n+#  include \"asan_internal.h\"\n+#  include \"asan_stack.h\"\n+#  include \"sanitizer_common/sanitizer_allocator_checks.h\"\n+#  include \"sanitizer_common/sanitizer_errno.h\"\n+#  include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n // ---------------------- Replacement functions ---------------- {{{1\n using namespace __asan;\n \n static uptr allocated_for_dlsym;\n static uptr last_dlsym_alloc_size_in_words;\n-static const uptr kDlsymAllocPoolSize = SANITIZER_RTEMS ? 4096 : 1024;\n+static const uptr kDlsymAllocPoolSize = 1024;\n static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n \n static inline bool IsInDlsymAllocPool(const void *ptr) {\n@@ -82,27 +81,12 @@ static int PosixMemalignFromLocalPool(void **memptr, uptr alignment,\n   return 0;\n }\n \n-#if SANITIZER_RTEMS\n-void* MemalignFromLocalPool(uptr alignment, uptr size) {\n-  void *ptr = nullptr;\n-  alignment = Max(alignment, kWordSize);\n-  PosixMemalignFromLocalPool(&ptr, alignment, size);\n-  return ptr;\n-}\n-\n-bool IsFromLocalPool(const void *ptr) {\n-  return IsInDlsymAllocPool(ptr);\n-}\n-#endif\n-\n static inline bool MaybeInDlsym() {\n   // Fuchsia doesn't use dlsym-based interceptors.\n   return !SANITIZER_FUCHSIA && asan_init_is_running;\n }\n \n-static inline bool UseLocalPool() {\n-  return EarlyMalloc() || MaybeInDlsym();\n-}\n+static inline bool UseLocalPool() { return MaybeInDlsym(); }\n \n static void *ReallocFromLocalPool(void *ptr, uptr size) {\n   const uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;"}, {"sha": "e2c9be0379f2f3029e1d8d8a6a3ee9a28081c77b", "filename": "libsanitizer/asan/asan_malloc_local.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fasan%2Fasan_malloc_local.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fasan%2Fasan_malloc_local.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_local.h?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,52 +0,0 @@\n-//===-- asan_malloc_local.h -------------------------------------*- C++ -*-===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Provide interfaces to check for and handle local pool memory allocation.\n-//===----------------------------------------------------------------------===//\n-\n-#ifndef ASAN_MALLOC_LOCAL_H\n-#define ASAN_MALLOC_LOCAL_H\n-\n-#include \"sanitizer_common/sanitizer_platform.h\"\n-#include \"asan_internal.h\"\n-\n-static inline bool EarlyMalloc() {\n-  return SANITIZER_RTEMS &&\n-         (!__asan::asan_inited || __asan::asan_init_is_running);\n-}\n-\n-#if SANITIZER_RTEMS\n-\n-bool IsFromLocalPool(const void *ptr);\n-void *MemalignFromLocalPool(uptr alignment, uptr size);\n-\n-// On RTEMS, we use the local pool to handle memory allocation when the ASan\n-// run-time is not up. This macro is expanded in the context of the operator new\n-// implementation.\n-#define MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow)                    \\\n-  do {                                                             \\\n-    if (UNLIKELY(EarlyMalloc())) {                                 \\\n-      void *res = MemalignFromLocalPool(SHADOW_GRANULARITY, size); \\\n-      if (!nothrow)                                                \\\n-        CHECK(res);                                                \\\n-      return res;                                                  \\\n-    }                                                              \\\n-  } while (0)\n-\n-#define IS_FROM_LOCAL_POOL(ptr) UNLIKELY(IsFromLocalPool(ptr))\n-\n-#else  // SANITIZER_RTEMS\n-\n-#define MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow)\n-#define IS_FROM_LOCAL_POOL(ptr) 0\n-\n-#endif  // SANITIZER_RTEMS\n-\n-#endif  // ASAN_MALLOC_LOCAL_H"}, {"sha": "e5a7f2007aea8b8208e929e08ee675a55cd252eb", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -150,17 +150,11 @@\n // || `[0x36000000, 0x39ffffff]` || ShadowGap  ||\n // || `[0x30000000, 0x35ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x2fffffff]` || LowMem     ||\n-//\n-// Shadow mapping on Myriad2 (for shadow scale 5):\n-// || `[0x9ff80000, 0x9fffffff]` || ShadowGap  ||\n-// || `[0x9f000000, 0x9ff7ffff]` || LowShadow  ||\n-// || `[0x80000000, 0x9effffff]` || LowMem     ||\n-// || `[0x00000000, 0x7fffffff]` || Ignored    ||\n \n #if defined(ASAN_SHADOW_SCALE)\n static const u64 kDefaultShadowScale = ASAN_SHADOW_SCALE;\n #else\n-static const u64 kDefaultShadowScale = SANITIZER_MYRIAD2 ? 5 : 3;\n+static const u64 kDefaultShadowScale = 3;\n #endif\n static const u64 kDefaultShadowSentinel = ~(uptr)0;\n static const u64 kDefaultShadowOffset32 = 1ULL << 29;  // 0x20000000\n@@ -171,7 +165,7 @@ static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kRiscv64_ShadowOffset64 = 0xd55550000;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n@@ -180,15 +174,6 @@ static const u64 kNetBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kNetBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n \n-static const u64 kMyriadMemoryOffset32 = 0x80000000ULL;\n-static const u64 kMyriadMemorySize32 = 0x20000000ULL;\n-static const u64 kMyriadMemoryEnd32 =\n-    kMyriadMemoryOffset32 + kMyriadMemorySize32 - 1;\n-static const u64 kMyriadShadowOffset32 =\n-    (kMyriadMemoryOffset32 + kMyriadMemorySize32 -\n-     (kMyriadMemorySize32 >> kDefaultShadowScale));\n-static const u64 kMyriadCacheBitMask32 = 0x40000000ULL;\n-\n #define SHADOW_SCALE kDefaultShadowScale\n \n #if SANITIZER_FUCHSIA\n@@ -206,8 +191,6 @@ static const u64 kMyriadCacheBitMask32 = 0x40000000ULL;\n #    define SHADOW_OFFSET kWindowsShadowOffset32\n #  elif SANITIZER_IOS\n #    define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n-#  elif SANITIZER_MYRIAD2\n-#    define SHADOW_OFFSET kMyriadShadowOffset32\n #  else\n #    define SHADOW_OFFSET kDefaultShadowOffset32\n #  endif\n@@ -278,10 +261,8 @@ extern uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;  // Initialized in __asan_init.\n \n }  // namespace __asan\n \n-#if SANITIZER_MYRIAD2\n-#include \"asan_mapping_myriad.h\"\n-#elif defined(__sparc__) && SANITIZER_WORDSIZE == 64\n-#include \"asan_mapping_sparc64.h\"\n+#if defined(__sparc__) && SANITIZER_WORDSIZE == 64\n+#  include \"asan_mapping_sparc64.h\"\n #else\n #define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) + (SHADOW_OFFSET))\n \n@@ -363,7 +344,7 @@ static inline bool AddrIsInShadowGap(uptr a) {\n \n }  // namespace __asan\n \n-#endif  // SANITIZER_MYRIAD2\n+#endif\n \n namespace __asan {\n \n@@ -393,8 +374,6 @@ static inline bool AddrIsAlignedByGranularity(uptr a) {\n \n static inline bool AddressIsPoisoned(uptr a) {\n   PROFILE_ASAN_MAPPING();\n-  if (SANITIZER_MYRIAD2 && !AddrIsInMem(a) && !AddrIsInShadow(a))\n-    return false;\n   const uptr kAccessSize = 1;\n   u8 *shadow_address = (u8*)MEM_TO_SHADOW(a);\n   s8 shadow_value = *shadow_address;"}, {"sha": "6969e3a49310b05eda6fd179644fbfe1ef794654", "filename": "libsanitizer/asan/asan_mapping_myriad.h", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fasan%2Fasan_mapping_myriad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fasan%2Fasan_mapping_myriad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping_myriad.h?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,85 +0,0 @@\n-//===-- asan_mapping_myriad.h -----------------------------------*- C++ -*-===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Myriad-specific definitions for ASan memory mapping.\n-//===----------------------------------------------------------------------===//\n-#ifndef ASAN_MAPPING_MYRIAD_H\n-#define ASAN_MAPPING_MYRIAD_H\n-\n-#define RAW_ADDR(mem) ((mem) & ~kMyriadCacheBitMask32)\n-#define MEM_TO_SHADOW(mem) \\\n-  (((RAW_ADDR(mem) - kLowMemBeg) >> SHADOW_SCALE) + (SHADOW_OFFSET))\n-\n-#define kLowMemBeg     kMyriadMemoryOffset32\n-#define kLowMemEnd     (SHADOW_OFFSET - 1)\n-\n-#define kLowShadowBeg  SHADOW_OFFSET\n-#define kLowShadowEnd  MEM_TO_SHADOW(kLowMemEnd)\n-\n-#define kHighMemBeg    0\n-\n-#define kHighShadowBeg 0\n-#define kHighShadowEnd 0\n-\n-#define kMidShadowBeg  0\n-#define kMidShadowEnd  0\n-\n-#define kShadowGapBeg  (kLowShadowEnd + 1)\n-#define kShadowGapEnd  kMyriadMemoryEnd32\n-\n-#define kShadowGap2Beg 0\n-#define kShadowGap2End 0\n-\n-#define kShadowGap3Beg 0\n-#define kShadowGap3End 0\n-\n-namespace __asan {\n-\n-static inline bool AddrIsInLowMem(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  a = RAW_ADDR(a);\n-  return a >= kLowMemBeg && a <= kLowMemEnd;\n-}\n-\n-static inline bool AddrIsInLowShadow(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  a = RAW_ADDR(a);\n-  return a >= kLowShadowBeg && a <= kLowShadowEnd;\n-}\n-\n-static inline bool AddrIsInMidMem(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  return false;\n-}\n-\n-static inline bool AddrIsInMidShadow(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  return false;\n-}\n-\n-static inline bool AddrIsInHighMem(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  return false;\n-}\n-\n-static inline bool AddrIsInHighShadow(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  return false;\n-}\n-\n-static inline bool AddrIsInShadowGap(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  a = RAW_ADDR(a);\n-  return a >= kShadowGapBeg && a <= kShadowGapEnd;\n-}\n-\n-}  // namespace __asan\n-\n-#endif  // ASAN_MAPPING_MYRIAD_H"}, {"sha": "da446072de1852e6e15657e3749ab7f66ee98642", "filename": "libsanitizer/asan/asan_new_delete.cpp", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -11,16 +11,14 @@\n // Interceptors for operators new and delete.\n //===----------------------------------------------------------------------===//\n \n+#include <stddef.h>\n+\n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n-#include \"asan_malloc_local.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n-\n #include \"interception/interception.h\"\n \n-#include <stddef.h>\n-\n // C++ operators can't have dllexport attributes on Windows. We export them\n // anyway by passing extra -export flags to the linker, which is exactly that\n // dllexport would normally do. We need to export them in order to make the\n@@ -72,14 +70,12 @@ enum class align_val_t: size_t {};\n // For local pool allocation, align to SHADOW_GRANULARITY to match asan\n // allocator behavior.\n #define OPERATOR_NEW_BODY(type, nothrow)            \\\n-  MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow);          \\\n   GET_STACK_TRACE_MALLOC;                           \\\n   void *res = asan_memalign(0, size, &stack, type); \\\n   if (!nothrow && UNLIKELY(!res))                   \\\n     ReportOutOfMemory(size, &stack);                \\\n   return res;\n #define OPERATOR_NEW_BODY_ALIGN(type, nothrow)                \\\n-  MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow);                    \\\n   GET_STACK_TRACE_MALLOC;                                     \\\n   void *res = asan_memalign((uptr)align, size, &stack, type); \\\n   if (!nothrow && UNLIKELY(!res))                             \\\n@@ -135,23 +131,19 @@ INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n #endif  // !SANITIZER_MAC\n \n #define OPERATOR_DELETE_BODY(type) \\\n-  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n-  GET_STACK_TRACE_FREE;\\\n+  GET_STACK_TRACE_FREE;            \\\n   asan_delete(ptr, 0, 0, &stack, type);\n \n #define OPERATOR_DELETE_BODY_SIZE(type) \\\n-  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n-  GET_STACK_TRACE_FREE;\\\n+  GET_STACK_TRACE_FREE;                 \\\n   asan_delete(ptr, size, 0, &stack, type);\n \n #define OPERATOR_DELETE_BODY_ALIGN(type) \\\n-  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n-  GET_STACK_TRACE_FREE;\\\n+  GET_STACK_TRACE_FREE;                  \\\n   asan_delete(ptr, 0, static_cast<uptr>(align), &stack, type);\n \n #define OPERATOR_DELETE_BODY_SIZE_ALIGN(type) \\\n-  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n-  GET_STACK_TRACE_FREE;\\\n+  GET_STACK_TRACE_FREE;                       \\\n   asan_delete(ptr, size, static_cast<uptr>(align), &stack, type);\n \n #if !SANITIZER_MAC"}, {"sha": "5f215fe0f9bbb9948cca1aaf2f9c4a5bb666f6da", "filename": "libsanitizer/asan/asan_poisoning.cpp", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -173,17 +173,13 @@ int __asan_address_is_poisoned(void const volatile *addr) {\n }\n \n uptr __asan_region_is_poisoned(uptr beg, uptr size) {\n-  if (!size) return 0;\n+  if (!size)\n+    return 0;\n   uptr end = beg + size;\n-  if (SANITIZER_MYRIAD2) {\n-    // On Myriad, address not in DRAM range need to be treated as\n-    // unpoisoned.\n-    if (!AddrIsInMem(beg) && !AddrIsInShadow(beg)) return 0;\n-    if (!AddrIsInMem(end) && !AddrIsInShadow(end)) return 0;\n-  } else {\n-    if (!AddrIsInMem(beg)) return beg;\n-    if (!AddrIsInMem(end)) return end;\n-  }\n+  if (!AddrIsInMem(beg))\n+    return beg;\n+  if (!AddrIsInMem(end))\n+    return end;\n   CHECK_LT(beg, end);\n   uptr aligned_b = RoundUpTo(beg, SHADOW_GRANULARITY);\n   uptr aligned_e = RoundDownTo(end, SHADOW_GRANULARITY);\n@@ -192,8 +188,7 @@ uptr __asan_region_is_poisoned(uptr beg, uptr size) {\n   // First check the first and the last application bytes,\n   // then check the SHADOW_GRANULARITY-aligned region by calling\n   // mem_is_zero on the corresponding shadow.\n-  if (!__asan::AddressIsPoisoned(beg) &&\n-      !__asan::AddressIsPoisoned(end - 1) &&\n+  if (!__asan::AddressIsPoisoned(beg) && !__asan::AddressIsPoisoned(end - 1) &&\n       (shadow_end <= shadow_beg ||\n        __sanitizer::mem_is_zero((const char *)shadow_beg,\n                                 shadow_end - shadow_beg)))"}, {"sha": "3d536f2d3097acc6778a27a87e8d080871cf99f6", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -51,9 +51,6 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n   // probably provide higher-level interface for these operations.\n   // For now, just memset on Windows.\n   if (value || SANITIZER_WINDOWS == 1 ||\n-      // RTEMS doesn't have have pages, let alone a fast way to zero\n-      // them, so default to memset.\n-      SANITIZER_RTEMS == 1 ||\n       shadow_end - shadow_beg < common_flags()->clear_shadow_mmap_threshold) {\n     REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n   } else {"}, {"sha": "ea0b4ad9db681a1e0c8edf81a02b56a633232022", "filename": "libsanitizer/asan/asan_rtems.cpp", "status": "removed", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fasan%2Fasan_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fasan%2Fasan_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtems.cpp?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,266 +0,0 @@\n-//===-- asan_rtems.cpp ----------------------------------------------------===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// RTEMS-specific details.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_common/sanitizer_rtems.h\"\n-#if SANITIZER_RTEMS\n-\n-#include \"asan_internal.h\"\n-#include \"asan_interceptors.h\"\n-#include \"asan_mapping.h\"\n-#include \"asan_poisoning.h\"\n-#include \"asan_report.h\"\n-#include \"asan_stack.h\"\n-#include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_libc.h\"\n-\n-#include <pthread.h>\n-#include <stdlib.h>\n-\n-namespace __asan {\n-\n-static void ResetShadowMemory() {\n-  uptr shadow_start = SHADOW_OFFSET;\n-  uptr shadow_end = MEM_TO_SHADOW(kMyriadMemoryEnd32);\n-  uptr gap_start = MEM_TO_SHADOW(shadow_start);\n-  uptr gap_end = MEM_TO_SHADOW(shadow_end);\n-\n-  REAL(memset)((void *)shadow_start, 0, shadow_end - shadow_start);\n-  REAL(memset)((void *)gap_start, kAsanShadowGap, gap_end - gap_start);\n-}\n-\n-void InitializeShadowMemory() {\n-  kHighMemEnd = 0;\n-  kMidMemBeg =  0;\n-  kMidMemEnd =  0;\n-\n-  ResetShadowMemory();\n-}\n-\n-void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n-  UNIMPLEMENTED();\n-}\n-\n-void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n-  // Since asan's mapping is compacting, the shadow chunk may be\n-  // not page-aligned, so we only flush the page-aligned portion.\n-  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n-}\n-\n-void AsanCheckDynamicRTPrereqs() {}\n-void AsanCheckIncompatibleRT() {}\n-void InitializeAsanInterceptors() {}\n-void InitializePlatformInterceptors() {}\n-void InitializePlatformExceptionHandlers() {}\n-\n-// RTEMS only support static linking; it sufficies to return with no\n-// error.\n-void *AsanDoesNotSupportStaticLinkage() { return nullptr; }\n-\n-void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n-  UNIMPLEMENTED();\n-}\n-\n-bool PlatformUnpoisonStacks() { return false; }\n-\n-void EarlyInit() {\n-  // Provide early initialization of shadow memory so that\n-  // instrumented code running before full initialzation will not\n-  // report spurious errors.\n-  ResetShadowMemory();\n-}\n-\n-// We can use a plain thread_local variable for TSD.\n-static thread_local void *per_thread;\n-\n-void *AsanTSDGet() { return per_thread; }\n-\n-void AsanTSDSet(void *tsd) { per_thread = tsd; }\n-\n-// There's no initialization needed, and the passed-in destructor\n-// will never be called.  Instead, our own thread destruction hook\n-// (below) will call AsanThread::TSDDtor directly.\n-void AsanTSDInit(void (*destructor)(void *tsd)) {\n-  DCHECK(destructor == &PlatformTSDDtor);\n-}\n-\n-void PlatformTSDDtor(void *tsd) { UNREACHABLE(__func__); }\n-\n-//\n-// Thread registration.  We provide an API similar to the Fushia port.\n-//\n-\n-struct AsanThread::InitOptions {\n-  uptr stack_bottom, stack_size, tls_bottom, tls_size;\n-};\n-\n-// Shared setup between thread creation and startup for the initial thread.\n-static AsanThread *CreateAsanThread(StackTrace *stack, u32 parent_tid,\n-                                    uptr user_id, bool detached,\n-                                    uptr stack_bottom, uptr stack_size,\n-                                    uptr tls_bottom, uptr tls_size) {\n-  // In lieu of AsanThread::Create.\n-  AsanThread *thread = (AsanThread *)MmapOrDie(sizeof(AsanThread), __func__);\n-  AsanThreadContext::CreateThreadContextArgs args = {thread, stack};\n-  asanThreadRegistry().CreateThread(user_id, detached, parent_tid, &args);\n-\n-  // On other systems, AsanThread::Init() is called from the new\n-  // thread itself.  But on RTEMS we already know the stack address\n-  // range beforehand, so we can do most of the setup right now.\n-  const AsanThread::InitOptions options = {stack_bottom, stack_size,\n-                                           tls_bottom, tls_size};\n-  thread->Init(&options);\n-  return thread;\n-}\n-\n-// This gets the same arguments passed to Init by CreateAsanThread, above.\n-// We're in the creator thread before the new thread is actually started, but\n-// its stack and tls address range are already known.\n-void AsanThread::SetThreadStackAndTls(const AsanThread::InitOptions *options) {\n-  DCHECK_NE(GetCurrentThread(), this);\n-  DCHECK_NE(GetCurrentThread(), nullptr);\n-  CHECK_NE(options->stack_bottom, 0);\n-  CHECK_NE(options->stack_size, 0);\n-  stack_bottom_ = options->stack_bottom;\n-  stack_top_ = options->stack_bottom + options->stack_size;\n-  tls_begin_ = options->tls_bottom;\n-  tls_end_ = options->tls_bottom + options->tls_size;\n-}\n-\n-// Called by __asan::AsanInitInternal (asan_rtl.c).  Unlike other ports, the\n-// main thread on RTEMS does not require special treatment; its AsanThread is\n-// already created by the provided hooks.  This function simply looks up and\n-// returns the created thread.\n-AsanThread *CreateMainThread() {\n-  return GetThreadContextByTidLocked(0)->thread;\n-}\n-\n-// This is called before each thread creation is attempted.  So, in\n-// its first call, the calling thread is the initial and sole thread.\n-static void *BeforeThreadCreateHook(uptr user_id, bool detached,\n-                                    uptr stack_bottom, uptr stack_size,\n-                                    uptr tls_bottom, uptr tls_size) {\n-  EnsureMainThreadIDIsCorrect();\n-  // Strict init-order checking is thread-hostile.\n-  if (flags()->strict_init_order) StopInitOrderChecking();\n-\n-  GET_STACK_TRACE_THREAD;\n-  u32 parent_tid = GetCurrentTidOrInvalid();\n-\n-  return CreateAsanThread(&stack, parent_tid, user_id, detached,\n-                          stack_bottom, stack_size, tls_bottom, tls_size);\n-}\n-\n-// This is called after creating a new thread (in the creating thread),\n-// with the pointer returned by BeforeThreadCreateHook (above).\n-static void ThreadCreateHook(void *hook, bool aborted) {\n-  AsanThread *thread = static_cast<AsanThread *>(hook);\n-  if (!aborted) {\n-    // The thread was created successfully.\n-    // ThreadStartHook is already running in the new thread.\n-  } else {\n-    // The thread wasn't created after all.\n-    // Clean up everything we set up in BeforeThreadCreateHook.\n-    asanThreadRegistry().FinishThread(thread->tid());\n-    UnmapOrDie(thread, sizeof(AsanThread));\n-  }\n-}\n-\n-// This is called (1) in the newly-created thread before it runs anything else,\n-// with the pointer returned by BeforeThreadCreateHook (above).  (2) before a\n-// thread restart.\n-static void ThreadStartHook(void *hook, uptr os_id) {\n-  if (!hook)\n-    return;\n-\n-  AsanThread *thread = static_cast<AsanThread *>(hook);\n-  SetCurrentThread(thread);\n-\n-  ThreadStatus status =\n-      asanThreadRegistry().GetThreadLocked(thread->tid())->status;\n-  DCHECK(status == ThreadStatusCreated || status == ThreadStatusRunning);\n-  // Determine whether we are starting or restarting the thread.\n-  if (status == ThreadStatusCreated) {\n-    // In lieu of AsanThread::ThreadStart.\n-    asanThreadRegistry().StartThread(thread->tid(), os_id, ThreadType::Regular,\n-                                     nullptr);\n-  } else {\n-    // In a thread restart, a thread may resume execution at an\n-    // arbitrary function entry point, with its stack and TLS state\n-    // reset.  We unpoison the stack in that case.\n-    PoisonShadow(thread->stack_bottom(), thread->stack_size(), 0);\n-  }\n-}\n-\n-// Each thread runs this just before it exits,\n-// with the pointer returned by BeforeThreadCreateHook (above).\n-// All per-thread destructors have already been called.\n-static void ThreadExitHook(void *hook, uptr os_id) {\n-  AsanThread *thread = static_cast<AsanThread *>(hook);\n-  if (thread)\n-    AsanThread::TSDDtor(thread->context());\n-}\n-\n-static void HandleExit() {\n-  // Disable ASan by setting it to uninitialized.  Also reset the\n-  // shadow memory to avoid reporting errors after the run-time has\n-  // been desroyed.\n-  if (asan_inited) {\n-    asan_inited = false;\n-    ResetShadowMemory();\n-  }\n-}\n-\n-bool HandleDlopenInit() {\n-  // Not supported on this platform.\n-  static_assert(!SANITIZER_SUPPORTS_INIT_FOR_DLOPEN,\n-                \"Expected SANITIZER_SUPPORTS_INIT_FOR_DLOPEN to be false\");\n-  return false;\n-}\n-}  // namespace __asan\n-\n-// These are declared (in extern \"C\") by <some_path/sanitizer.h>.\n-// The system runtime will call our definitions directly.\n-\n-extern \"C\" {\n-void __sanitizer_early_init() {\n-  __asan::EarlyInit();\n-}\n-\n-void *__sanitizer_before_thread_create_hook(uptr thread, bool detached,\n-                                            const char *name,\n-                                            void *stack_base, size_t stack_size,\n-                                            void *tls_base, size_t tls_size) {\n-  return __asan::BeforeThreadCreateHook(\n-      thread, detached,\n-      reinterpret_cast<uptr>(stack_base), stack_size,\n-      reinterpret_cast<uptr>(tls_base), tls_size);\n-}\n-\n-void __sanitizer_thread_create_hook(void *handle, uptr thread, int status) {\n-  __asan::ThreadCreateHook(handle, status != 0);\n-}\n-\n-void __sanitizer_thread_start_hook(void *handle, uptr self) {\n-  __asan::ThreadStartHook(handle, self);\n-}\n-\n-void __sanitizer_thread_exit_hook(void *handle, uptr self) {\n-  __asan::ThreadExitHook(handle, self);\n-}\n-\n-void __sanitizer_exit() {\n-  __asan::HandleExit();\n-}\n-}  // \"C\"\n-\n-#endif  // SANITIZER_RTEMS"}, {"sha": "e06a1113f4edc35e25e98d691bab75d1bf3435ee", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -13,6 +13,7 @@\n \n #include \"asan_activation.h\"\n #include \"asan_allocator.h\"\n+#include \"asan_fake_stack.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_interface_internal.h\"\n #include \"asan_internal.h\"\n@@ -23,11 +24,11 @@\n #include \"asan_stats.h\"\n #include \"asan_suppressions.h\"\n #include \"asan_thread.h\"\n+#include \"lsan/lsan_common.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n-#include \"lsan/lsan_common.h\"\n #include \"ubsan/ubsan_init.h\"\n #include \"ubsan/ubsan_platform.h\"\n \n@@ -137,24 +138,21 @@ ASAN_REPORT_ERROR_N(load, false)\n ASAN_REPORT_ERROR_N(store, true)\n \n #define ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp_arg, fatal) \\\n-    if (SANITIZER_MYRIAD2 && !AddrIsInMem(addr) && !AddrIsInShadow(addr))      \\\n-      return;                                                                  \\\n-    uptr sp = MEM_TO_SHADOW(addr);                                             \\\n-    uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)          \\\n-                                        : *reinterpret_cast<u16 *>(sp);        \\\n-    if (UNLIKELY(s)) {                                                         \\\n-      if (UNLIKELY(size >= SHADOW_GRANULARITY ||                               \\\n-                   ((s8)((addr & (SHADOW_GRANULARITY - 1)) + size - 1)) >=     \\\n-                       (s8)s)) {                                               \\\n-        if (__asan_test_only_reported_buggy_pointer) {                         \\\n-          *__asan_test_only_reported_buggy_pointer = addr;                     \\\n-        } else {                                                               \\\n-          GET_CALLER_PC_BP_SP;                                                 \\\n-          ReportGenericError(pc, bp, sp, addr, is_write, size, exp_arg,        \\\n-                              fatal);                                          \\\n-        }                                                                      \\\n+  uptr sp = MEM_TO_SHADOW(addr);                                               \\\n+  uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)            \\\n+                                      : *reinterpret_cast<u16 *>(sp);          \\\n+  if (UNLIKELY(s)) {                                                           \\\n+    if (UNLIKELY(size >= SHADOW_GRANULARITY ||                                 \\\n+                 ((s8)((addr & (SHADOW_GRANULARITY - 1)) + size - 1)) >=       \\\n+                     (s8)s)) {                                                 \\\n+      if (__asan_test_only_reported_buggy_pointer) {                           \\\n+        *__asan_test_only_reported_buggy_pointer = addr;                       \\\n+      } else {                                                                 \\\n+        GET_CALLER_PC_BP_SP;                                                   \\\n+        ReportGenericError(pc, bp, sp, addr, is_write, size, exp_arg, fatal);  \\\n       }                                                                        \\\n-    }\n+    }                                                                          \\\n+  }\n \n #define ASAN_MEMORY_ACCESS_CALLBACK(type, is_write, size)                      \\\n   extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n@@ -305,15 +303,13 @@ static void asan_atexit() {\n }\n \n static void InitializeHighMemEnd() {\n-#if !SANITIZER_MYRIAD2\n #if !ASAN_FIXED_MAPPING\n   kHighMemEnd = GetMaxUserVirtualAddress();\n   // Increase kHighMemEnd to make sure it's properly\n   // aligned together with kHighMemBeg:\n   kHighMemEnd |= (GetMmapGranularity() << SHADOW_SCALE) - 1;\n #endif  // !ASAN_FIXED_MAPPING\n   CHECK_EQ((kHighMemBeg % GetMmapGranularity()), 0);\n-#endif  // !SANITIZER_MYRIAD2\n }\n \n void PrintAddressSpaceLayout() {\n@@ -569,9 +565,6 @@ static void UnpoisonDefaultStack() {\n     const uptr page_size = GetPageSizeCached();\n     top = curr_thread->stack_top();\n     bottom = ((uptr)&local_stack - page_size) & ~(page_size - 1);\n-  } else if (SANITIZER_RTEMS) {\n-    // Give up On RTEMS.\n-    return;\n   } else {\n     CHECK(!SANITIZER_FUCHSIA);\n     // If we haven't seen this thread, try asking the OS for stack bounds.\n@@ -586,8 +579,12 @@ static void UnpoisonDefaultStack() {\n \n static void UnpoisonFakeStack() {\n   AsanThread *curr_thread = GetCurrentThread();\n-  if (curr_thread && curr_thread->has_fake_stack())\n-    curr_thread->fake_stack()->HandleNoReturn();\n+  if (!curr_thread)\n+    return;\n+  FakeStack *stack = curr_thread->get_fake_stack();\n+  if (!stack)\n+    return;\n+  stack->HandleNoReturn();\n }\n \n }  // namespace __asan"}, {"sha": "6e6260d3413fc8c11d4873a62f9e14bc4ef65f8d", "filename": "libsanitizer/asan/asan_shadow_setup.cpp", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -13,12 +13,11 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n \n-// asan_fuchsia.cpp and asan_rtems.cpp have their own\n-// InitializeShadowMemory implementation.\n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+// asan_fuchsia.cpp has their own InitializeShadowMemory implementation.\n+#if !SANITIZER_FUCHSIA\n \n-#include \"asan_internal.h\"\n-#include \"asan_mapping.h\"\n+#  include \"asan_internal.h\"\n+#  include \"asan_mapping.h\"\n \n namespace __asan {\n \n@@ -123,4 +122,4 @@ void InitializeShadowMemory() {\n \n }  // namespace __asan\n \n-#endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+#endif  // !SANITIZER_FUCHSIA"}, {"sha": "048295d6928ad5d08bff4df5ea2c26c36869ae33", "filename": "libsanitizer/asan/asan_stack.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_stack.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_stack.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -74,7 +74,8 @@ void __sanitizer::BufferedStackTrace::UnwindImpl(\n   if (SANITIZER_MIPS && t &&\n       !IsValidFrame(bp, t->stack_top(), t->stack_bottom()))\n     return;\n-  Unwind(max_depth, pc, bp, context, 0, 0, false);\n+  Unwind(max_depth, pc, bp, context, t ? t->stack_top() : 0,\n+         t ? t->stack_bottom() : 0, false);\n }\n \n // ------------------ Interface -------------- {{{1"}, {"sha": "35d4467e7b53a010bb325557fb55ebf49892b342", "filename": "libsanitizer/asan/asan_thread.cpp", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -60,8 +60,8 @@ ThreadRegistry &asanThreadRegistry() {\n     // in TSD and can't reliably tell when no more TSD destructors will\n     // be called. It would be wrong to reuse AsanThreadContext for another\n     // thread before all TSD destructors will be called for it.\n-    asan_thread_registry = new(thread_registry_placeholder) ThreadRegistry(\n-        GetAsanThreadContext, kMaxNumberOfThreads, kMaxNumberOfThreads);\n+    asan_thread_registry =\n+        new (thread_registry_placeholder) ThreadRegistry(GetAsanThreadContext);\n     initialized = true;\n   }\n   return *asan_thread_registry;\n@@ -257,10 +257,9 @@ void AsanThread::Init(const InitOptions *options) {\n           &local);\n }\n \n-// Fuchsia and RTEMS don't use ThreadStart.\n-// asan_fuchsia.c/asan_rtems.c define CreateMainThread and\n-// SetThreadStackAndTls.\n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+// Fuchsia doesn't use ThreadStart.\n+// asan_fuchsia.c definies CreateMainThread and SetThreadStackAndTls.\n+#if !SANITIZER_FUCHSIA\n \n thread_return_t AsanThread::ThreadStart(tid_t os_id) {\n   Init();\n@@ -317,7 +316,7 @@ void AsanThread::SetThreadStackAndTls(const InitOptions *options) {\n   }\n }\n \n-#endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+#endif  // !SANITIZER_FUCHSIA\n \n void AsanThread::ClearShadowForThreadStackAndTLS() {\n   if (stack_top_ != stack_bottom_)\n@@ -339,8 +338,8 @@ bool AsanThread::GetStackFrameAccessByAddr(uptr addr,\n   uptr bottom = 0;\n   if (AddrIsInStack(addr)) {\n     bottom = stack_bottom();\n-  } else if (has_fake_stack()) {\n-    bottom = fake_stack()->AddrIsInFakeStack(addr);\n+  } else if (FakeStack *fake_stack = get_fake_stack()) {\n+    bottom = fake_stack->AddrIsInFakeStack(addr);\n     CHECK(bottom);\n     access->offset = addr - bottom;\n     access->frame_pc = ((uptr*)bottom)[2];\n@@ -380,8 +379,8 @@ uptr AsanThread::GetStackVariableShadowStart(uptr addr) {\n   uptr bottom = 0;\n   if (AddrIsInStack(addr)) {\n     bottom = stack_bottom();\n-  } else if (has_fake_stack()) {\n-    bottom = fake_stack()->AddrIsInFakeStack(addr);\n+  } else if (FakeStack *fake_stack = get_fake_stack()) {\n+    bottom = fake_stack->AddrIsInFakeStack(addr);\n     if (bottom == 0) {\n       return 0;\n     }\n@@ -409,19 +408,19 @@ bool AsanThread::AddrIsInStack(uptr addr) {\n \n static bool ThreadStackContainsAddress(ThreadContextBase *tctx_base,\n                                        void *addr) {\n-  AsanThreadContext *tctx = static_cast<AsanThreadContext*>(tctx_base);\n+  AsanThreadContext *tctx = static_cast<AsanThreadContext *>(tctx_base);\n   AsanThread *t = tctx->thread;\n-  if (!t) return false;\n-  if (t->AddrIsInStack((uptr)addr)) return true;\n-  if (t->has_fake_stack() && t->fake_stack()->AddrIsInFakeStack((uptr)addr))\n+  if (!t)\n+    return false;\n+  if (t->AddrIsInStack((uptr)addr))\n     return true;\n-  return false;\n+  FakeStack *fake_stack = t->get_fake_stack();\n+  if (!fake_stack)\n+    return false;\n+  return fake_stack->AddrIsInFakeStack((uptr)addr);\n }\n \n AsanThread *GetCurrentThread() {\n-  if (SANITIZER_RTEMS && !asan_inited)\n-    return nullptr;\n-\n   AsanThreadContext *context =\n       reinterpret_cast<AsanThreadContext *>(AsanTSDGet());\n   if (!context) {\n@@ -503,8 +502,12 @@ void GetAllThreadAllocatorCachesLocked(InternalMmapVector<uptr> *caches) {}\n void ForEachExtraStackRange(tid_t os_id, RangeIteratorCallback callback,\n                             void *arg) {\n   __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);\n-  if (t && t->has_fake_stack())\n-    t->fake_stack()->ForEachFakeFrame(callback, arg);\n+  if (!t)\n+    return;\n+  __asan::FakeStack *fake_stack = t->get_fake_stack();\n+  if (!fake_stack)\n+    return;\n+  fake_stack->ForEachFakeFrame(callback, arg);\n }\n \n void LockThreadRegistry() {"}, {"sha": "801a3960ec6cb67a48080859ef670bf7123e9c6d", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -28,8 +28,6 @@ struct DTLS;\n \n namespace __asan {\n \n-const u32 kMaxNumberOfThreads = (1 << 22);  // 4M\n-\n class AsanThread;\n \n // These objects are created for every thread and are never deleted,\n@@ -104,17 +102,18 @@ class AsanThread {\n   void FinishSwitchFiber(FakeStack *fake_stack_save, uptr *bottom_old,\n                          uptr *size_old);\n \n-  bool has_fake_stack() {\n-    return !atomic_load(&stack_switching_, memory_order_relaxed) &&\n-           (reinterpret_cast<uptr>(fake_stack_) > 1);\n+  FakeStack *get_fake_stack() {\n+    if (atomic_load(&stack_switching_, memory_order_relaxed))\n+      return nullptr;\n+    if (reinterpret_cast<uptr>(fake_stack_) <= 1)\n+      return nullptr;\n+    return fake_stack_;\n   }\n \n-  FakeStack *fake_stack() {\n-    if (!__asan_option_detect_stack_use_after_return)\n-      return nullptr;\n+  FakeStack *get_or_create_fake_stack() {\n     if (atomic_load(&stack_switching_, memory_order_relaxed))\n       return nullptr;\n-    if (!has_fake_stack())\n+    if (reinterpret_cast<uptr>(fake_stack_) <= 1)\n       return AsyncSignalSafeLazyInitFakeStack();\n     return fake_stack_;\n   }"}, {"sha": "5e3a0f1b0a10128710c5e723040ad960dd55f0c2", "filename": "libsanitizer/hwasan/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2FMakefile.am?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -13,11 +13,13 @@ ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n toolexeclib_LTLIBRARIES = libhwasan.la\n \n hwasan_files = \\\n+\thwasan_allocation_functions.cpp \\\n \thwasan_allocator.cpp \\\n \thwasan.cpp \\\n \thwasan_dynamic_shadow.cpp \\\n \thwasan_exceptions.cpp \\\n \thwasan_flags.inc \\\n+\thwasan_fuchsia.cpp \\\n \thwasan_globals.cpp \\\n \thwasan_interceptors.cpp \\\n \thwasan_interceptors_vfork.S \\"}, {"sha": "22c5266a120c020e042e63a2a8387fb0966da0e2", "filename": "libsanitizer/hwasan/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2FMakefile.in?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -146,8 +146,9 @@ am__DEPENDENCIES_1 =\n libhwasan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(am__append_1) $(am__append_2) $(am__DEPENDENCIES_1)\n-am__objects_1 = hwasan_allocator.lo hwasan.lo hwasan_dynamic_shadow.lo \\\n-\thwasan_exceptions.lo hwasan_globals.lo hwasan_interceptors.lo \\\n+am__objects_1 = hwasan_allocation_functions.lo hwasan_allocator.lo \\\n+\thwasan.lo hwasan_dynamic_shadow.lo hwasan_exceptions.lo \\\n+\thwasan_fuchsia.lo hwasan_globals.lo hwasan_interceptors.lo \\\n \thwasan_interceptors_vfork.lo hwasan_linux.lo \\\n \thwasan_memintrinsics.lo hwasan_new_delete.lo \\\n \thwasan_poisoning.lo hwasan_report.lo hwasan_setjmp.lo \\\n@@ -411,11 +412,13 @@ AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n toolexeclib_LTLIBRARIES = libhwasan.la\n hwasan_files = \\\n+\thwasan_allocation_functions.cpp \\\n \thwasan_allocator.cpp \\\n \thwasan.cpp \\\n \thwasan_dynamic_shadow.cpp \\\n \thwasan_exceptions.cpp \\\n \thwasan_flags.inc \\\n+\thwasan_fuchsia.cpp \\\n \thwasan_globals.cpp \\\n \thwasan_interceptors.cpp \\\n \thwasan_interceptors_vfork.S \\\n@@ -554,9 +557,11 @@ distclean-compile:\n \t-rm -f *.tab.c\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_allocation_functions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_dynamic_shadow.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_exceptions.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_fuchsia.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_globals.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_interceptors.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hwasan_interceptors_vfork.Plo@am__quote@"}, {"sha": "cbe0dee66dcda7c36d59572ea8355b67b33f5f90", "filename": "libsanitizer/hwasan/hwasan.cpp", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -50,6 +50,11 @@ bool hwasan_init_is_running;\n \n int hwasan_report_count = 0;\n \n+uptr kLowShadowStart;\n+uptr kLowShadowEnd;\n+uptr kHighShadowStart;\n+uptr kHighShadowEnd;\n+\n void Flags::SetDefaults() {\n #define HWASAN_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n #include \"hwasan_flags.inc\"\n@@ -177,6 +182,65 @@ void UpdateMemoryUsage() {\n void UpdateMemoryUsage() {}\n #endif\n \n+void HwasanAtExit() {\n+  if (common_flags()->print_module_map)\n+    DumpProcessMap();\n+  if (flags()->print_stats && (flags()->atexit || hwasan_report_count > 0))\n+    ReportStats();\n+  if (hwasan_report_count > 0) {\n+    // ReportAtExitStatistics();\n+    if (common_flags()->exitcode)\n+      internal__exit(common_flags()->exitcode);\n+  }\n+}\n+\n+void HandleTagMismatch(AccessInfo ai, uptr pc, uptr frame, void *uc,\n+                       uptr *registers_frame) {\n+  InternalMmapVector<BufferedStackTrace> stack_buffer(1);\n+  BufferedStackTrace *stack = stack_buffer.data();\n+  stack->Reset();\n+  stack->Unwind(pc, frame, uc, common_flags()->fast_unwind_on_fatal);\n+\n+  // The second stack frame contains the failure __hwasan_check function, as\n+  // we have a stack frame for the registers saved in __hwasan_tag_mismatch that\n+  // we wish to ignore. This (currently) only occurs on AArch64, as x64\n+  // implementations use SIGTRAP to implement the failure, and thus do not go\n+  // through the stack saver.\n+  if (registers_frame && stack->trace && stack->size > 0) {\n+    stack->trace++;\n+    stack->size--;\n+  }\n+\n+  bool fatal = flags()->halt_on_error || !ai.recover;\n+  ReportTagMismatch(stack, ai.addr, ai.size, ai.is_store, fatal,\n+                    registers_frame);\n+}\n+\n+void HwasanTagMismatch(uptr addr, uptr access_info, uptr *registers_frame,\n+                       size_t outsize) {\n+  __hwasan::AccessInfo ai;\n+  ai.is_store = access_info & 0x10;\n+  ai.is_load = !ai.is_store;\n+  ai.recover = access_info & 0x20;\n+  ai.addr = addr;\n+  if ((access_info & 0xf) == 0xf)\n+    ai.size = outsize;\n+  else\n+    ai.size = 1 << (access_info & 0xf);\n+\n+  HandleTagMismatch(ai, (uptr)__builtin_return_address(0),\n+                    (uptr)__builtin_frame_address(0), nullptr, registers_frame);\n+  __builtin_unreachable();\n+}\n+\n+Thread *GetCurrentThread() {\n+  uptr *ThreadLongPtr = GetCurrentThreadLongPtr();\n+  if (UNLIKELY(*ThreadLongPtr == 0))\n+    return nullptr;\n+  auto *R = (StackAllocationsRingBuffer *)ThreadLongPtr;\n+  return hwasanThreadList().GetThreadByBufferAddress((uptr)R->Next());\n+}\n+\n } // namespace __hwasan\n \n using namespace __hwasan;\n@@ -216,7 +280,7 @@ static void InitLoadedGlobals() {\n static void InitInstrumentation() {\n   if (hwasan_instrumentation_inited) return;\n \n-  InitPrctl();\n+  InitializeOsSupport();\n \n   if (!InitShadow()) {\n     Printf(\"FATAL: HWAddressSanitizer cannot mmap the shadow memory.\\n\");\n@@ -225,7 +289,6 @@ static void InitInstrumentation() {\n   }\n \n   InitThreads();\n-  hwasanThreadList().CreateCurrentThread();\n \n   hwasan_instrumentation_inited = 1;\n }\n@@ -495,7 +558,7 @@ void __hwasan_print_memory_usage() {\n   Printf(\"%s\\n\", s.data());\n }\n \n-static const u8 kFallbackTag = 0xBB;\n+static const u8 kFallbackTag = 0xBB & kTagMask;\n \n u8 __hwasan_generate_tag() {\n   Thread *t = GetCurrentThread();\n@@ -516,4 +579,12 @@ void __sanitizer_print_stack_trace() {\n   GET_FATAL_STACK_TRACE_PC_BP(StackTrace::GetCurrentPc(), GET_CURRENT_FRAME());\n   stack.Print();\n }\n+\n+// Entry point for interoperability between __hwasan_tag_mismatch (ASM) and the\n+// rest of the mismatch handling code (C++).\n+void __hwasan_tag_mismatch4(uptr addr, uptr access_info, uptr *registers_frame,\n+                            size_t outsize) {\n+  __hwasan::HwasanTagMismatch(addr, access_info, registers_frame, outsize);\n+}\n+\n } // extern \"C\""}, {"sha": "7338b696ad341d844776c491984a1a0b21ce9b58", "filename": "libsanitizer/hwasan/hwasan.h", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -36,7 +36,10 @@\n \n typedef u8 tag_t;\n \n-#if defined(__x86_64__)\n+#if defined(HWASAN_ALIASING_MODE)\n+#  if !defined(__x86_64__)\n+#    error Aliasing mode is only supported on x86_64\n+#  endif\n // Tags are done in middle bits using userspace aliasing.\n constexpr unsigned kAddressTagShift = 39;\n constexpr unsigned kTagBits = 3;\n@@ -49,12 +52,16 @@ constexpr unsigned kTagBits = 3;\n // simpler/faster shadow calculation.\n constexpr unsigned kTaggableRegionCheckShift =\n     __sanitizer::Max(kAddressTagShift + kTagBits + 1U, 44U);\n+#elif defined(__x86_64__)\n+// Tags are done in upper bits using Intel LAM.\n+constexpr unsigned kAddressTagShift = 57;\n+constexpr unsigned kTagBits = 6;\n #else\n // TBI (Top Byte Ignore) feature of AArch64: bits [63:56] are ignored in address\n // translation and can be used to store a tag.\n constexpr unsigned kAddressTagShift = 56;\n constexpr unsigned kTagBits = 8;\n-#endif  // defined(__x86_64__)\n+#endif  // defined(HWASAN_ALIASING_MODE)\n \n // Mask for extracting tag bits from the lower 8 bits.\n constexpr uptr kTagMask = (1UL << kTagBits) - 1;\n@@ -95,7 +102,7 @@ extern bool hwasan_init_is_running;\n extern int hwasan_report_count;\n \n bool InitShadow();\n-void InitPrctl();\n+void InitializeOsSupport();\n void InitThreads();\n void InitializeInterceptors();\n \n@@ -129,6 +136,7 @@ void InstallAtExitHandler();\n \n void HwasanTSDInit();\n void HwasanTSDThreadInit();\n+void HwasanAtExit();\n \n void HwasanOnDeadlySignal(int signo, void *info, void *context);\n \n@@ -138,6 +146,26 @@ void AppendToErrorMessageBuffer(const char *buffer);\n \n void AndroidTestTlsSlot();\n \n+// This is a compiler-generated struct that can be shared between hwasan\n+// implementations.\n+struct AccessInfo {\n+  uptr addr;\n+  uptr size;\n+  bool is_store;\n+  bool is_load;\n+  bool recover;\n+};\n+\n+// Given access info and frame information, unwind the stack and report the tag\n+// mismatch.\n+void HandleTagMismatch(AccessInfo ai, uptr pc, uptr frame, void *uc,\n+                       uptr *registers_frame = nullptr);\n+\n+// This dispatches to HandleTagMismatch but sets up the AccessInfo, program\n+// counter, and frame pointer.\n+void HwasanTagMismatch(uptr addr, uptr access_info, uptr *registers_frame,\n+                       size_t outsize);\n+\n }  // namespace __hwasan\n \n #define HWASAN_MALLOC_HOOK(ptr, size)       \\\n@@ -175,4 +203,12 @@ typedef struct __hw_jmp_buf_struct __hw_jmp_buf[1];\n typedef struct __hw_jmp_buf_struct __hw_sigjmp_buf[1];\n #endif // HWASAN_WITH_INTERCEPTORS && __aarch64__\n \n+#define ENSURE_HWASAN_INITED()      \\\n+  do {                              \\\n+    CHECK(!hwasan_init_is_running); \\\n+    if (!hwasan_inited) {           \\\n+      __hwasan_init();              \\\n+    }                               \\\n+  } while (0)\n+\n #endif  // HWASAN_H"}, {"sha": "6c2a6077866fb572d766d27424096c6206d1bfdc", "filename": "libsanitizer/hwasan/hwasan_allocation_functions.cpp", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_allocation_functions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_allocation_functions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocation_functions.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -0,0 +1,172 @@\n+//===-- hwasan_allocation_functions.cpp -----------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of HWAddressSanitizer.\n+//\n+// Definitions for __sanitizer allocation functions.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"hwasan.h\"\n+#include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n+\n+using namespace __hwasan;\n+\n+static uptr allocated_for_dlsym;\n+static const uptr kDlsymAllocPoolSize = 1024;\n+static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n+\n+static bool IsInDlsymAllocPool(const void *ptr) {\n+  uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n+  return off < sizeof(alloc_memory_for_dlsym);\n+}\n+\n+static void *AllocateFromLocalPool(uptr size_in_bytes) {\n+  uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;\n+  void *mem = (void *)&alloc_memory_for_dlsym[allocated_for_dlsym];\n+  allocated_for_dlsym += size_in_words;\n+  CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);\n+  return mem;\n+}\n+\n+int __sanitizer_posix_memalign(void **memptr, uptr alignment, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  CHECK_NE(memptr, 0);\n+  int res = hwasan_posix_memalign(memptr, alignment, size, &stack);\n+  return res;\n+}\n+\n+void *__sanitizer_memalign(uptr alignment, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  return hwasan_memalign(alignment, size, &stack);\n+}\n+\n+void *__sanitizer_aligned_alloc(uptr alignment, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  return hwasan_aligned_alloc(alignment, size, &stack);\n+}\n+\n+void *__sanitizer___libc_memalign(uptr alignment, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  void *ptr = hwasan_memalign(alignment, size, &stack);\n+  if (ptr)\n+    DTLS_on_libc_memalign(ptr, size);\n+  return ptr;\n+}\n+\n+void *__sanitizer_valloc(uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  return hwasan_valloc(size, &stack);\n+}\n+\n+void *__sanitizer_pvalloc(uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  return hwasan_pvalloc(size, &stack);\n+}\n+\n+void __sanitizer_free(void *ptr) {\n+  GET_MALLOC_STACK_TRACE;\n+  if (!ptr || UNLIKELY(IsInDlsymAllocPool(ptr)))\n+    return;\n+  hwasan_free(ptr, &stack);\n+}\n+\n+void __sanitizer_cfree(void *ptr) {\n+  GET_MALLOC_STACK_TRACE;\n+  if (!ptr || UNLIKELY(IsInDlsymAllocPool(ptr)))\n+    return;\n+  hwasan_free(ptr, &stack);\n+}\n+\n+uptr __sanitizer_malloc_usable_size(const void *ptr) {\n+  return __sanitizer_get_allocated_size(ptr);\n+}\n+\n+struct __sanitizer_struct_mallinfo __sanitizer_mallinfo() {\n+  __sanitizer_struct_mallinfo sret;\n+  internal_memset(&sret, 0, sizeof(sret));\n+  return sret;\n+}\n+\n+int __sanitizer_mallopt(int cmd, int value) { return 0; }\n+\n+void __sanitizer_malloc_stats(void) {\n+  // FIXME: implement, but don't call REAL(malloc_stats)!\n+}\n+\n+void *__sanitizer_calloc(uptr nmemb, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  if (UNLIKELY(!hwasan_inited))\n+    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n+    return AllocateFromLocalPool(nmemb * size);\n+  return hwasan_calloc(nmemb, size, &stack);\n+}\n+\n+void *__sanitizer_realloc(void *ptr, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n+    uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n+    uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n+    void *new_ptr;\n+    if (UNLIKELY(!hwasan_inited)) {\n+      new_ptr = AllocateFromLocalPool(copy_size);\n+    } else {\n+      copy_size = size;\n+      new_ptr = hwasan_malloc(copy_size, &stack);\n+    }\n+    internal_memcpy(new_ptr, ptr, copy_size);\n+    return new_ptr;\n+  }\n+  return hwasan_realloc(ptr, size, &stack);\n+}\n+\n+void *__sanitizer_reallocarray(void *ptr, uptr nmemb, uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  return hwasan_reallocarray(ptr, nmemb, size, &stack);\n+}\n+\n+void *__sanitizer_malloc(uptr size) {\n+  GET_MALLOC_STACK_TRACE;\n+  if (UNLIKELY(!hwasan_init_is_running))\n+    ENSURE_HWASAN_INITED();\n+  if (UNLIKELY(!hwasan_inited))\n+    // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n+    return AllocateFromLocalPool(size);\n+  return hwasan_malloc(size, &stack);\n+}\n+\n+#if HWASAN_WITH_INTERCEPTORS\n+#  define INTERCEPTOR_ALIAS(RET, FN, ARGS...)                                 \\\n+    extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE RET WRAP(FN)(ARGS)               \\\n+        ALIAS(\"__sanitizer_\" #FN);                                            \\\n+    extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE RET FN( \\\n+        ARGS) ALIAS(\"__sanitizer_\" #FN)\n+\n+INTERCEPTOR_ALIAS(int, posix_memalign, void **memptr, SIZE_T alignment,\n+                  SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, aligned_alloc, SIZE_T alignment, SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, __libc_memalign, SIZE_T alignment, SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, valloc, SIZE_T size);\n+INTERCEPTOR_ALIAS(void, free, void *ptr);\n+INTERCEPTOR_ALIAS(uptr, malloc_usable_size, const void *ptr);\n+INTERCEPTOR_ALIAS(void *, calloc, SIZE_T nmemb, SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, realloc, void *ptr, SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, reallocarray, void *ptr, SIZE_T nmemb, SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, malloc, SIZE_T size);\n+\n+#  if !SANITIZER_FREEBSD && !SANITIZER_NETBSD\n+INTERCEPTOR_ALIAS(void *, memalign, SIZE_T alignment, SIZE_T size);\n+INTERCEPTOR_ALIAS(void *, pvalloc, SIZE_T size);\n+INTERCEPTOR_ALIAS(void, cfree, void *ptr);\n+INTERCEPTOR_ALIAS(__sanitizer_struct_mallinfo, mallinfo);\n+INTERCEPTOR_ALIAS(int, mallopt, int cmd, int value);\n+INTERCEPTOR_ALIAS(void, malloc_stats, void);\n+#  endif\n+#endif  // #if HWASAN_WITH_INTERCEPTORS"}, {"sha": "ef6d4d6c7678eb5726de2699369e3f6a051bffec", "filename": "libsanitizer/hwasan/hwasan_allocator.cpp", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocator.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -80,12 +80,29 @@ void GetAllocatorStats(AllocatorStatCounters s) {\n   allocator.GetStats(s);\n }\n \n+uptr GetAliasRegionStart() {\n+#if defined(HWASAN_ALIASING_MODE)\n+  constexpr uptr kAliasRegionOffset = 1ULL << (kTaggableRegionCheckShift - 1);\n+  uptr AliasRegionStart =\n+      __hwasan_shadow_memory_dynamic_address + kAliasRegionOffset;\n+\n+  CHECK_EQ(AliasRegionStart >> kTaggableRegionCheckShift,\n+           __hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n+  CHECK_EQ(\n+      (AliasRegionStart + kAliasRegionOffset - 1) >> kTaggableRegionCheckShift,\n+      __hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n+  return AliasRegionStart;\n+#else\n+  return 0;\n+#endif\n+}\n+\n void HwasanAllocatorInit() {\n   atomic_store_relaxed(&hwasan_allocator_tagging_enabled,\n                        !flags()->disable_allocator_tagging);\n   SetAllocatorMayReturnNull(common_flags()->allocator_may_return_null);\n   allocator.Init(common_flags()->allocator_release_to_os_interval_ms,\n-                 kAliasRegionStart);\n+                 GetAliasRegionStart());\n   for (uptr i = 0; i < sizeof(tail_magic); i++)\n     tail_magic[i] = GetCurrentThread()->GenerateRandomTag();\n }\n@@ -196,6 +213,7 @@ static void HwasanDeallocate(StackTrace *stack, void *tagged_ptr) {\n                            : tagged_ptr;\n   void *aligned_ptr = reinterpret_cast<void *>(\n       RoundDownTo(reinterpret_cast<uptr>(untagged_ptr), kShadowAlignment));\n+  tag_t pointer_tag = GetTagFromPointer(reinterpret_cast<uptr>(tagged_ptr));\n   Metadata *meta =\n       reinterpret_cast<Metadata *>(allocator.GetMetaData(aligned_ptr));\n   uptr orig_size = meta->get_requested_size();\n@@ -229,7 +247,20 @@ static void HwasanDeallocate(StackTrace *stack, void *tagged_ptr) {\n       flags()->tag_in_free && malloc_bisect(stack, 0) &&\n       atomic_load_relaxed(&hwasan_allocator_tagging_enabled)) {\n     // Always store full 8-bit tags on free to maximize UAF detection.\n-    tag_t tag = t ? t->GenerateRandomTag(/*num_bits=*/8) : kFallbackFreeTag;\n+    tag_t tag;\n+    if (t) {\n+      // Make sure we are not using a short granule tag as a poison tag. This\n+      // would make us attempt to read the memory on a UaF.\n+      // The tag can be zero if tagging is disabled on this thread.\n+      do {\n+        tag = t->GenerateRandomTag(/*num_bits=*/8);\n+      } while (\n+          UNLIKELY((tag < kShadowAlignment || tag == pointer_tag) && tag != 0));\n+    } else {\n+      static_assert(kFallbackFreeTag >= kShadowAlignment,\n+                    \"fallback tag must not be a short granule tag.\");\n+      tag = kFallbackFreeTag;\n+    }\n     TagMemoryAligned(reinterpret_cast<uptr>(aligned_ptr), TaggedSize(orig_size),\n                      tag);\n   }"}, {"sha": "35c3d6b4bf434148a9a21c1fac928fd94144156c", "filename": "libsanitizer/hwasan/hwasan_allocator.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocator.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -15,6 +15,7 @@\n \n #include \"hwasan.h\"\n #include \"hwasan_interface_internal.h\"\n+#include \"hwasan_mapping.h\"\n #include \"hwasan_poisoning.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_allocator_checks.h\"\n@@ -58,7 +59,7 @@ static const uptr kMaxAllowedMallocSize = 1UL << 40;  // 1T\n struct AP64 {\n   static const uptr kSpaceBeg = ~0ULL;\n \n-#if defined(__x86_64__)\n+#if defined(HWASAN_ALIASING_MODE)\n   static const uptr kSpaceSize = 1ULL << kAddressTagShift;\n #else\n   static const uptr kSpaceSize = 0x2000000000ULL;\n@@ -110,11 +111,11 @@ typedef RingBuffer<HeapAllocationRecord> HeapAllocationsRingBuffer;\n void GetAllocatorStats(AllocatorStatCounters s);\n \n inline bool InTaggableRegion(uptr addr) {\n-#if defined(__x86_64__)\n+#if defined(HWASAN_ALIASING_MODE)\n   // Aliases are mapped next to shadow so that the upper bits match the shadow\n   // base.\n   return (addr >> kTaggableRegionCheckShift) ==\n-         (__hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n+         (GetShadowOffset() >> kTaggableRegionCheckShift);\n #endif\n   return true;\n }"}, {"sha": "bde22dfa4bc4c03028c78baa0422b1394bcbdd04", "filename": "libsanitizer/hwasan/hwasan_dynamic_shadow.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_dynamic_shadow.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_dynamic_shadow.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_dynamic_shadow.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -119,12 +119,12 @@ namespace __hwasan {\n void InitShadowGOT() {}\n \n uptr FindDynamicShadowStart(uptr shadow_size_bytes) {\n-#if defined(__x86_64__)\n+#  if defined(HWASAN_ALIASING_MODE)\n   constexpr uptr kAliasSize = 1ULL << kAddressTagShift;\n   constexpr uptr kNumAliases = 1ULL << kTagBits;\n   return MapDynamicShadowAndAliases(shadow_size_bytes, kAliasSize, kNumAliases,\n                                     RingBufferSize());\n-#endif\n+#  endif\n   return MapDynamicShadow(shadow_size_bytes, kShadowScale, kShadowBaseAlignment,\n                           kHighMemEnd);\n }"}, {"sha": "e61f6ada72fc47284f9fd8b1e4730d8f465dba81", "filename": "libsanitizer/hwasan/hwasan_fuchsia.cpp", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -0,0 +1,192 @@\n+//===-- hwasan_fuchsia.cpp --------------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+///\n+/// \\file\n+/// This file is a part of HWAddressSanitizer and contains Fuchsia-specific\n+/// code.\n+///\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_fuchsia.h\"\n+#if SANITIZER_FUCHSIA\n+\n+#include \"hwasan.h\"\n+#include \"hwasan_interface_internal.h\"\n+#include \"hwasan_report.h\"\n+#include \"hwasan_thread.h\"\n+#include \"hwasan_thread_list.h\"\n+\n+// This TLS variable contains the location of the stack ring buffer and can be\n+// used to always find the hwasan thread object associated with the current\n+// running thread.\n+[[gnu::tls_model(\"initial-exec\")]]\n+SANITIZER_INTERFACE_ATTRIBUTE\n+THREADLOCAL uptr __hwasan_tls;\n+\n+namespace __hwasan {\n+\n+bool InitShadow() {\n+  __sanitizer::InitShadowBounds();\n+  CHECK_NE(__sanitizer::ShadowBounds.shadow_limit, 0);\n+\n+  return true;\n+}\n+\n+bool MemIsApp(uptr p) {\n+  CHECK(GetTagFromPointer(p) == 0);\n+  return __sanitizer::ShadowBounds.shadow_limit <= p &&\n+         p <= (__sanitizer::ShadowBounds.memory_limit - 1);\n+}\n+\n+// These are known parameters passed to the hwasan runtime on thread creation.\n+struct Thread::InitState {\n+  uptr stack_bottom, stack_top;\n+};\n+\n+static void FinishThreadInitialization(Thread *thread);\n+\n+void InitThreads() {\n+  // This is the minimal alignment needed for the storage where hwasan threads\n+  // and their stack ring buffers are placed. This alignment is necessary so the\n+  // stack ring buffer can perform a simple calculation to get the next element\n+  // in the RB. The instructions for this calculation are emitted by the\n+  // compiler. (Full explanation in hwasan_thread_list.h.)\n+  uptr alloc_size = UINT64_C(1) << kShadowBaseAlignment;\n+  uptr thread_start = reinterpret_cast<uptr>(\n+      MmapAlignedOrDieOnFatalError(alloc_size, alloc_size, __func__));\n+\n+  InitThreadList(thread_start, alloc_size);\n+\n+  // Create the hwasan thread object for the current (main) thread. Stack info\n+  // for this thread is known from information passed via\n+  // __sanitizer_startup_hook.\n+  const Thread::InitState state = {\n+      .stack_bottom = __sanitizer::MainThreadStackBase,\n+      .stack_top =\n+          __sanitizer::MainThreadStackBase + __sanitizer::MainThreadStackSize,\n+  };\n+  FinishThreadInitialization(hwasanThreadList().CreateCurrentThread(&state));\n+}\n+\n+uptr *GetCurrentThreadLongPtr() { return &__hwasan_tls; }\n+\n+// This is called from the parent thread before the new thread is created. Here\n+// we can propagate known info like the stack bounds to Thread::Init before\n+// jumping into the thread. We cannot initialize the stack ring buffer yet since\n+// we have not entered the new thread.\n+static void *BeforeThreadCreateHook(uptr user_id, bool detached,\n+                                    const char *name, uptr stack_bottom,\n+                                    uptr stack_size) {\n+  const Thread::InitState state = {\n+      .stack_bottom = stack_bottom,\n+      .stack_top = stack_bottom + stack_size,\n+  };\n+  return hwasanThreadList().CreateCurrentThread(&state);\n+}\n+\n+// This sets the stack top and bottom according to the InitState passed to\n+// CreateCurrentThread above.\n+void Thread::InitStackAndTls(const InitState *state) {\n+  CHECK_NE(state->stack_bottom, 0);\n+  CHECK_NE(state->stack_top, 0);\n+  stack_bottom_ = state->stack_bottom;\n+  stack_top_ = state->stack_top;\n+  tls_end_ = tls_begin_ = 0;\n+}\n+\n+// This is called after creating a new thread with the pointer returned by\n+// BeforeThreadCreateHook. We are still in the creating thread and should check\n+// if it was actually created correctly.\n+static void ThreadCreateHook(void *hook, bool aborted) {\n+  Thread *thread = static_cast<Thread *>(hook);\n+  if (!aborted) {\n+    // The thread was created successfully.\n+    // ThreadStartHook can already be running in the new thread.\n+  } else {\n+    // The thread wasn't created after all.\n+    // Clean up everything we set up in BeforeThreadCreateHook.\n+    atomic_signal_fence(memory_order_seq_cst);\n+    hwasanThreadList().ReleaseThread(thread);\n+  }\n+}\n+\n+// This is called in the newly-created thread before it runs anything else,\n+// with the pointer returned by BeforeThreadCreateHook (above). Here we can\n+// setup the stack ring buffer.\n+static void ThreadStartHook(void *hook, thrd_t self) {\n+  Thread *thread = static_cast<Thread *>(hook);\n+  FinishThreadInitialization(thread);\n+  thread->InitRandomState();\n+}\n+\n+// This is the function that sets up the stack ring buffer and enables us to use\n+// GetCurrentThread. This function should only be called while IN the thread\n+// that we want to create the hwasan thread object for so __hwasan_tls can be\n+// properly referenced.\n+static void FinishThreadInitialization(Thread *thread) {\n+  CHECK_NE(thread, nullptr);\n+\n+  // The ring buffer is located immediately before the thread object.\n+  uptr stack_buffer_size = hwasanThreadList().GetRingBufferSize();\n+  uptr stack_buffer_start = reinterpret_cast<uptr>(thread) - stack_buffer_size;\n+  thread->InitStackRingBuffer(stack_buffer_start, stack_buffer_size);\n+}\n+\n+static void ThreadExitHook(void *hook, thrd_t self) {\n+  Thread *thread = static_cast<Thread *>(hook);\n+  atomic_signal_fence(memory_order_seq_cst);\n+  hwasanThreadList().ReleaseThread(thread);\n+}\n+\n+// Not implemented because Fuchsia does not use signal handlers.\n+void HwasanOnDeadlySignal(int signo, void *info, void *context) {}\n+\n+// Not implemented because Fuchsia does not use interceptors.\n+void InitializeInterceptors() {}\n+\n+// Not implemented because this is only relevant for Android.\n+void AndroidTestTlsSlot() {}\n+\n+// TSD was normally used on linux as a means of calling the hwasan thread exit\n+// handler passed to pthread_key_create. This is not needed on Fuchsia because\n+// we will be using __sanitizer_thread_exit_hook.\n+void HwasanTSDInit() {}\n+void HwasanTSDThreadInit() {}\n+\n+// On linux, this just would call `atexit(HwasanAtExit)`. The functions in\n+// HwasanAtExit are unimplemented for Fuchsia and effectively no-ops, so this\n+// function is unneeded.\n+void InstallAtExitHandler() {}\n+\n+}  // namespace __hwasan\n+\n+extern \"C\" {\n+\n+void *__sanitizer_before_thread_create_hook(thrd_t thread, bool detached,\n+                                            const char *name, void *stack_base,\n+                                            size_t stack_size) {\n+  return __hwasan::BeforeThreadCreateHook(\n+      reinterpret_cast<uptr>(thread), detached, name,\n+      reinterpret_cast<uptr>(stack_base), stack_size);\n+}\n+\n+void __sanitizer_thread_create_hook(void *hook, thrd_t thread, int error) {\n+  __hwasan::ThreadCreateHook(hook, error != thrd_success);\n+}\n+\n+void __sanitizer_thread_start_hook(void *hook, thrd_t self) {\n+  __hwasan::ThreadStartHook(hook, reinterpret_cast<uptr>(self));\n+}\n+\n+void __sanitizer_thread_exit_hook(void *hook, thrd_t self) {\n+  __hwasan::ThreadExitHook(hook, self);\n+}\n+\n+}  // extern \"C\"\n+\n+#endif  // SANITIZER_FUCHSIA"}, {"sha": "68f8adec0776a7cbfad090cb3e62d7297ef786f0", "filename": "libsanitizer/hwasan/hwasan_interceptors.cpp", "status": "modified", "additions": 3, "deletions": 179, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -16,192 +16,14 @@\n \n #include \"interception/interception.h\"\n #include \"hwasan.h\"\n-#include \"hwasan_allocator.h\"\n-#include \"hwasan_mapping.h\"\n #include \"hwasan_thread.h\"\n-#include \"hwasan_poisoning.h\"\n-#include \"hwasan_report.h\"\n-#include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n-#include \"sanitizer_common/sanitizer_allocator.h\"\n-#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n-#include \"sanitizer_common/sanitizer_allocator_internal.h\"\n-#include \"sanitizer_common/sanitizer_atomic.h\"\n-#include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_errno.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n-#include \"sanitizer_common/sanitizer_libc.h\"\n-#include \"sanitizer_common/sanitizer_linux.h\"\n-#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n-#include <stdarg.h>\n-// ACHTUNG! No other system header includes in this file.\n-// Ideally, we should get rid of stdarg.h as well.\n+#if !SANITIZER_FUCHSIA\n \n using namespace __hwasan;\n \n-using __sanitizer::memory_order;\n-using __sanitizer::atomic_load;\n-using __sanitizer::atomic_store;\n-using __sanitizer::atomic_uintptr_t;\n-\n-static uptr allocated_for_dlsym;\n-static const uptr kDlsymAllocPoolSize = 1024;\n-static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n-\n-static bool IsInDlsymAllocPool(const void *ptr) {\n-  uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-  return off < sizeof(alloc_memory_for_dlsym);\n-}\n-\n-static void *AllocateFromLocalPool(uptr size_in_bytes) {\n-  uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;\n-  void *mem = (void *)&alloc_memory_for_dlsym[allocated_for_dlsym];\n-  allocated_for_dlsym += size_in_words;\n-  CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);\n-  return mem;\n-}\n-\n-#define ENSURE_HWASAN_INITED() do { \\\n-  CHECK(!hwasan_init_is_running); \\\n-  if (!hwasan_inited) { \\\n-    __hwasan_init(); \\\n-  } \\\n-} while (0)\n-\n-\n-int __sanitizer_posix_memalign(void **memptr, uptr alignment, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  CHECK_NE(memptr, 0);\n-  int res = hwasan_posix_memalign(memptr, alignment, size, &stack);\n-  return res;\n-}\n-\n-void * __sanitizer_memalign(uptr alignment, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  return hwasan_memalign(alignment, size, &stack);\n-}\n-\n-void * __sanitizer_aligned_alloc(uptr alignment, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  return hwasan_aligned_alloc(alignment, size, &stack);\n-}\n-\n-void * __sanitizer___libc_memalign(uptr alignment, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  void *ptr = hwasan_memalign(alignment, size, &stack);\n-  if (ptr)\n-    DTLS_on_libc_memalign(ptr, size);\n-  return ptr;\n-}\n-\n-void * __sanitizer_valloc(uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  return hwasan_valloc(size, &stack);\n-}\n-\n-void * __sanitizer_pvalloc(uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  return hwasan_pvalloc(size, &stack);\n-}\n-\n-void __sanitizer_free(void *ptr) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (!ptr || UNLIKELY(IsInDlsymAllocPool(ptr))) return;\n-  hwasan_free(ptr, &stack);\n-}\n-\n-void __sanitizer_cfree(void *ptr) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (!ptr || UNLIKELY(IsInDlsymAllocPool(ptr))) return;\n-  hwasan_free(ptr, &stack);\n-}\n-\n-uptr __sanitizer_malloc_usable_size(const void *ptr) {\n-  return __sanitizer_get_allocated_size(ptr);\n-}\n-\n-struct __sanitizer_struct_mallinfo __sanitizer_mallinfo() {\n-  __sanitizer_struct_mallinfo sret;\n-  internal_memset(&sret, 0, sizeof(sret));\n-  return sret;\n-}\n-\n-int __sanitizer_mallopt(int cmd, int value) {\n-  return 0;\n-}\n-\n-void __sanitizer_malloc_stats(void) {\n-  // FIXME: implement, but don't call REAL(malloc_stats)!\n-}\n-\n-void * __sanitizer_calloc(uptr nmemb, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (UNLIKELY(!hwasan_inited))\n-    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n-    return AllocateFromLocalPool(nmemb * size);\n-  return hwasan_calloc(nmemb, size, &stack);\n-}\n-\n-void * __sanitizer_realloc(void *ptr, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n-    uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-    uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n-    void *new_ptr;\n-    if (UNLIKELY(!hwasan_inited)) {\n-      new_ptr = AllocateFromLocalPool(copy_size);\n-    } else {\n-      copy_size = size;\n-      new_ptr = hwasan_malloc(copy_size, &stack);\n-    }\n-    internal_memcpy(new_ptr, ptr, copy_size);\n-    return new_ptr;\n-  }\n-  return hwasan_realloc(ptr, size, &stack);\n-}\n-\n-void * __sanitizer_reallocarray(void *ptr, uptr nmemb, uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  return hwasan_reallocarray(ptr, nmemb, size, &stack);\n-}\n-\n-void * __sanitizer_malloc(uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (UNLIKELY(!hwasan_init_is_running))\n-    ENSURE_HWASAN_INITED();\n-  if (UNLIKELY(!hwasan_inited))\n-    // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n-    return AllocateFromLocalPool(size);\n-  return hwasan_malloc(size, &stack);\n-}\n-\n #if HWASAN_WITH_INTERCEPTORS\n-#define INTERCEPTOR_ALIAS(RET, FN, ARGS...)                                  \\\n-  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE RET WRAP(FN)(ARGS)                \\\n-      ALIAS(\"__sanitizer_\" #FN);                                             \\\n-  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE RET FN(  \\\n-      ARGS) ALIAS(\"__sanitizer_\" #FN)\n-\n-INTERCEPTOR_ALIAS(int, posix_memalign, void **memptr, SIZE_T alignment,\n-                  SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, aligned_alloc, SIZE_T alignment, SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, __libc_memalign, SIZE_T alignment, SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, valloc, SIZE_T size);\n-INTERCEPTOR_ALIAS(void, free, void *ptr);\n-INTERCEPTOR_ALIAS(uptr, malloc_usable_size, const void *ptr);\n-INTERCEPTOR_ALIAS(void *, calloc, SIZE_T nmemb, SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, realloc, void *ptr, SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, reallocarray, void *ptr, SIZE_T nmemb, SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, malloc, SIZE_T size);\n-\n-#if !SANITIZER_FREEBSD && !SANITIZER_NETBSD\n-INTERCEPTOR_ALIAS(void *, memalign, SIZE_T alignment, SIZE_T size);\n-INTERCEPTOR_ALIAS(void *, pvalloc, SIZE_T size);\n-INTERCEPTOR_ALIAS(void, cfree, void *ptr);\n-INTERCEPTOR_ALIAS(__sanitizer_struct_mallinfo, mallinfo);\n-INTERCEPTOR_ALIAS(int, mallopt, int cmd, int value);\n-INTERCEPTOR_ALIAS(void, malloc_stats, void);\n-#endif\n \n struct ThreadStartArg {\n   thread_callback_t callback;\n@@ -346,3 +168,5 @@ void InitializeInterceptors() {\n   inited = 1;\n }\n } // namespace __hwasan\n+\n+#endif  // #if !SANITIZER_FUCHSIA"}, {"sha": "e22723529f449e9a8d49c94664fd3b0c32a2960d", "filename": "libsanitizer/hwasan/hwasan_linux.cpp", "status": "modified", "additions": 65, "deletions": 101, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -69,15 +69,9 @@ static void ProtectGap(uptr addr, uptr size) {\n \n uptr kLowMemStart;\n uptr kLowMemEnd;\n-uptr kLowShadowEnd;\n-uptr kLowShadowStart;\n-uptr kHighShadowStart;\n-uptr kHighShadowEnd;\n uptr kHighMemStart;\n uptr kHighMemEnd;\n \n-uptr kAliasRegionStart;  // Always 0 on non-x86.\n-\n static void PrintRange(uptr start, uptr end, const char *name) {\n   Printf(\"|| [%p, %p] || %.*s ||\\n\", (void *)start, (void *)end, 10, name);\n }\n@@ -116,7 +110,7 @@ static void InitializeShadowBaseAddress(uptr shadow_size_bytes) {\n       FindDynamicShadowStart(shadow_size_bytes);\n }\n \n-void InitPrctl() {\n+void InitializeOsSupport() {\n #define PR_SET_TAGGED_ADDR_CTRL 55\n #define PR_GET_TAGGED_ADDR_CTRL 56\n #define PR_TAGGED_ADDR_ENABLE (1UL << 0)\n@@ -125,33 +119,50 @@ void InitPrctl() {\n   if (internal_iserror(internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0),\n                        &local_errno) &&\n       local_errno == EINVAL) {\n-#if SANITIZER_ANDROID || defined(__x86_64__)\n+#  if SANITIZER_ANDROID || defined(HWASAN_ALIASING_MODE)\n     // Some older Android kernels have the tagged pointer ABI on\n     // unconditionally, and hence don't have the tagged-addr prctl while still\n     // allow the ABI.\n     // If targeting Android and the prctl is not around we assume this is the\n     // case.\n     return;\n-#else\n+#  else\n     if (flags()->fail_without_syscall_abi) {\n       Printf(\n           \"FATAL: \"\n           \"HWAddressSanitizer requires a kernel with tagged address ABI.\\n\");\n       Die();\n     }\n-#endif\n+#  endif\n   }\n \n   // Turn on the tagged address ABI.\n   if ((internal_iserror(internal_prctl(PR_SET_TAGGED_ADDR_CTRL,\n                                        PR_TAGGED_ADDR_ENABLE, 0, 0, 0)) ||\n-       !internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0)) &&\n-      flags()->fail_without_syscall_abi) {\n-    Printf(\n-        \"FATAL: HWAddressSanitizer failed to enable tagged address syscall \"\n-        \"ABI.\\nSuggest check `sysctl abi.tagged_addr_disabled` \"\n-        \"configuration.\\n\");\n-    Die();\n+       !internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0))) {\n+#  if defined(__x86_64__) && !defined(HWASAN_ALIASING_MODE)\n+    // Try the new prctl API for Intel LAM.  The API is based on a currently\n+    // unsubmitted patch to the Linux kernel (as of May 2021) and is thus\n+    // subject to change.  Patch is here:\n+    // https://lore.kernel.org/linux-mm/20210205151631.43511-12-kirill.shutemov@linux.intel.com/\n+    int tag_bits = kTagBits;\n+    int tag_shift = kAddressTagShift;\n+    if (!internal_iserror(\n+            internal_prctl(PR_SET_TAGGED_ADDR_CTRL, PR_TAGGED_ADDR_ENABLE,\n+                           reinterpret_cast<unsigned long>(&tag_bits),\n+                           reinterpret_cast<unsigned long>(&tag_shift), 0))) {\n+      CHECK_EQ(tag_bits, kTagBits);\n+      CHECK_EQ(tag_shift, kAddressTagShift);\n+      return;\n+    }\n+#  endif  // defined(__x86_64__) && !defined(HWASAN_ALIASING_MODE)\n+    if (flags()->fail_without_syscall_abi) {\n+      Printf(\n+          \"FATAL: HWAddressSanitizer failed to enable tagged address syscall \"\n+          \"ABI.\\nSuggest check `sysctl abi.tagged_addr_disabled` \"\n+          \"configuration.\\n\");\n+      Die();\n+    }\n   }\n #undef PR_SET_TAGGED_ADDR_CTRL\n #undef PR_GET_TAGGED_ADDR_CTRL\n@@ -181,18 +192,6 @@ bool InitShadow() {\n   // High memory starts where allocated shadow allows.\n   kHighMemStart = ShadowToMem(kHighShadowStart);\n \n-#if defined(__x86_64__)\n-  constexpr uptr kAliasRegionOffset = 1ULL << (kTaggableRegionCheckShift - 1);\n-  kAliasRegionStart =\n-      __hwasan_shadow_memory_dynamic_address + kAliasRegionOffset;\n-\n-  CHECK_EQ(kAliasRegionStart >> kTaggableRegionCheckShift,\n-           __hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n-  CHECK_EQ(\n-      (kAliasRegionStart + kAliasRegionOffset - 1) >> kTaggableRegionCheckShift,\n-      __hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n-#endif\n-\n   // Check the sanity of the defined memory ranges (there might be gaps).\n   CHECK_EQ(kHighMemStart % GetMmapGranularity(), 0);\n   CHECK_GT(kHighMemStart, kHighShadowEnd);\n@@ -233,25 +232,16 @@ void InitThreads() {\n   ProtectGap(thread_space_end,\n              __hwasan_shadow_memory_dynamic_address - thread_space_end);\n   InitThreadList(thread_space_start, thread_space_end - thread_space_start);\n+  hwasanThreadList().CreateCurrentThread();\n }\n \n bool MemIsApp(uptr p) {\n-#if !defined(__x86_64__)  // Memory outside the alias range has non-zero tags.\n+// Memory outside the alias range has non-zero tags.\n+#  if !defined(HWASAN_ALIASING_MODE)\n   CHECK(GetTagFromPointer(p) == 0);\n-#endif\n-  return p >= kHighMemStart || (p >= kLowMemStart && p <= kLowMemEnd);\n-}\n+#  endif\n \n-static void HwasanAtExit(void) {\n-  if (common_flags()->print_module_map)\n-    DumpProcessMap();\n-  if (flags()->print_stats && (flags()->atexit || hwasan_report_count > 0))\n-    ReportStats();\n-  if (hwasan_report_count > 0) {\n-    // ReportAtExitStatistics();\n-    if (common_flags()->exitcode)\n-      internal__exit(common_flags()->exitcode);\n-  }\n+  return p >= kHighMemStart || (p >= kLowMemStart && p <= kLowMemEnd);\n }\n \n void InstallAtExitHandler() {\n@@ -330,22 +320,6 @@ void AndroidTestTlsSlot() {\n void AndroidTestTlsSlot() {}\n #endif\n \n-Thread *GetCurrentThread() {\n-  uptr *ThreadLongPtr = GetCurrentThreadLongPtr();\n-  if (UNLIKELY(*ThreadLongPtr == 0))\n-    return nullptr;\n-  auto *R = (StackAllocationsRingBuffer *)ThreadLongPtr;\n-  return hwasanThreadList().GetThreadByBufferAddress((uptr)R->Next());\n-}\n-\n-struct AccessInfo {\n-  uptr addr;\n-  uptr size;\n-  bool is_store;\n-  bool is_load;\n-  bool recover;\n-};\n-\n static AccessInfo GetAccessInfo(siginfo_t *info, ucontext_t *uc) {\n   // Access type is passed in a platform dependent way (see below) and encoded\n   // as 0xXY, where X&1 is 1 for store, 0 for load, and X&2 is 1 if the error is\n@@ -396,28 +370,6 @@ static AccessInfo GetAccessInfo(siginfo_t *info, ucontext_t *uc) {\n   return AccessInfo{addr, size, is_store, !is_store, recover};\n }\n \n-static void HandleTagMismatch(AccessInfo ai, uptr pc, uptr frame,\n-                              ucontext_t *uc, uptr *registers_frame = nullptr) {\n-  InternalMmapVector<BufferedStackTrace> stack_buffer(1);\n-  BufferedStackTrace *stack = stack_buffer.data();\n-  stack->Reset();\n-  stack->Unwind(pc, frame, uc, common_flags()->fast_unwind_on_fatal);\n-\n-  // The second stack frame contains the failure __hwasan_check function, as\n-  // we have a stack frame for the registers saved in __hwasan_tag_mismatch that\n-  // we wish to ignore. This (currently) only occurs on AArch64, as x64\n-  // implementations use SIGTRAP to implement the failure, and thus do not go\n-  // through the stack saver.\n-  if (registers_frame && stack->trace && stack->size > 0) {\n-    stack->trace++;\n-    stack->size--;\n-  }\n-\n-  bool fatal = flags()->halt_on_error || !ai.recover;\n-  ReportTagMismatch(stack, ai.addr, ai.size, ai.is_store, fatal,\n-                    registers_frame);\n-}\n-\n static bool HwasanOnSIGTRAP(int signo, siginfo_t *info, ucontext_t *uc) {\n   AccessInfo ai = GetAccessInfo(info, uc);\n   if (!ai.is_store && !ai.is_load)\n@@ -450,27 +402,39 @@ void HwasanOnDeadlySignal(int signo, void *info, void *context) {\n   HandleDeadlySignal(info, context, GetTid(), &OnStackUnwind, nullptr);\n }\n \n+void Thread::InitStackAndTls(const InitState *) {\n+  uptr tls_size;\n+  uptr stack_size;\n+  GetThreadStackAndTls(IsMainThread(), &stack_bottom_, &stack_size, &tls_begin_,\n+                       &tls_size);\n+  stack_top_ = stack_bottom_ + stack_size;\n+  tls_end_ = tls_begin_ + tls_size;\n+}\n \n-} // namespace __hwasan\n-\n-// Entry point for interoperability between __hwasan_tag_mismatch (ASM) and the\n-// rest of the mismatch handling code (C++).\n-void __hwasan_tag_mismatch4(uptr addr, uptr access_info, uptr *registers_frame,\n-                            size_t outsize) {\n-  __hwasan::AccessInfo ai;\n-  ai.is_store = access_info & 0x10;\n-  ai.is_load = !ai.is_store;\n-  ai.recover = access_info & 0x20;\n-  ai.addr = addr;\n-  if ((access_info & 0xf) == 0xf)\n-    ai.size = outsize;\n-  else\n-    ai.size = 1 << (access_info & 0xf);\n-\n-  __hwasan::HandleTagMismatch(ai, (uptr)__builtin_return_address(0),\n-                              (uptr)__builtin_frame_address(0), nullptr,\n-                              registers_frame);\n-  __builtin_unreachable();\n+uptr TagMemoryAligned(uptr p, uptr size, tag_t tag) {\n+  CHECK(IsAligned(p, kShadowAlignment));\n+  CHECK(IsAligned(size, kShadowAlignment));\n+  uptr shadow_start = MemToShadow(p);\n+  uptr shadow_size = MemToShadowSize(size);\n+\n+  uptr page_size = GetPageSizeCached();\n+  uptr page_start = RoundUpTo(shadow_start, page_size);\n+  uptr page_end = RoundDownTo(shadow_start + shadow_size, page_size);\n+  uptr threshold = common_flags()->clear_shadow_mmap_threshold;\n+  if (SANITIZER_LINUX &&\n+      UNLIKELY(page_end >= page_start + threshold && tag == 0)) {\n+    internal_memset((void *)shadow_start, tag, page_start - shadow_start);\n+    internal_memset((void *)page_end, tag,\n+                    shadow_start + shadow_size - page_end);\n+    // For an anonymous private mapping MADV_DONTNEED will return a zero page on\n+    // Linux.\n+    ReleaseMemoryPagesToOSAndZeroFill(page_start, page_end);\n+  } else {\n+    internal_memset((void *)shadow_start, tag, shadow_size);\n+  }\n+  return AddTagToPointer(p, tag);\n }\n \n+} // namespace __hwasan\n+\n #endif // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD"}, {"sha": "79a143632f6abf3b64c731981c3eae555ab1bf8e", "filename": "libsanitizer/hwasan/hwasan_mapping.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_mapping.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -48,21 +48,28 @@ extern uptr kHighShadowEnd;\n extern uptr kHighMemStart;\n extern uptr kHighMemEnd;\n \n-extern uptr kAliasRegionStart;\n-\n+inline uptr GetShadowOffset() {\n+  return SANITIZER_FUCHSIA ? 0 : __hwasan_shadow_memory_dynamic_address;\n+}\n inline uptr MemToShadow(uptr untagged_addr) {\n-  return (untagged_addr >> kShadowScale) +\n-         __hwasan_shadow_memory_dynamic_address;\n+  return (untagged_addr >> kShadowScale) + GetShadowOffset();\n }\n inline uptr ShadowToMem(uptr shadow_addr) {\n-  return (shadow_addr - __hwasan_shadow_memory_dynamic_address) << kShadowScale;\n+  return (shadow_addr - GetShadowOffset()) << kShadowScale;\n }\n inline uptr MemToShadowSize(uptr size) {\n   return size >> kShadowScale;\n }\n \n bool MemIsApp(uptr p);\n \n+inline bool MemIsShadow(uptr p) {\n+  return (kLowShadowStart <= p && p <= kLowShadowEnd) ||\n+         (kHighShadowStart <= p && p <= kHighShadowEnd);\n+}\n+\n+uptr GetAliasRegionStart();\n+\n }  // namespace __hwasan\n \n #endif  // HWASAN_MAPPING_H"}, {"sha": "4e057a651e1dd95daeaba151d4fd798f621eddb4", "filename": "libsanitizer/hwasan/hwasan_new_delete.cpp", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_new_delete.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -56,7 +56,6 @@ using namespace __hwasan;\n // Fake std::nothrow_t to avoid including <new>.\n namespace std {\n   struct nothrow_t {};\n-  enum class align_val_t : size_t {};\n }  // namespace std\n \n \n@@ -73,6 +72,32 @@ INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void *operator new[](size_t size, std::nothrow_t const&) {\n   OPERATOR_NEW_BODY(true /*nothrow*/);\n }\n+\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete(void *ptr)\n+    NOEXCEPT {\n+  OPERATOR_DELETE_BODY;\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete[](\n+    void *ptr) NOEXCEPT {\n+  OPERATOR_DELETE_BODY;\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete(\n+    void *ptr, std::nothrow_t const &) {\n+  OPERATOR_DELETE_BODY;\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete[](\n+    void *ptr, std::nothrow_t const &) {\n+  OPERATOR_DELETE_BODY;\n+}\n+\n+#endif  // OPERATOR_NEW_BODY\n+\n+#ifdef OPERATOR_NEW_ALIGN_BODY\n+\n+namespace std {\n+enum class align_val_t : size_t {};\n+}  // namespace std\n+\n INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void *operator new(\n     size_t size, std::align_val_t align) {\n   OPERATOR_NEW_ALIGN_BODY(false /*nothrow*/);\n@@ -90,16 +115,6 @@ INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void *operator new[](\n   OPERATOR_NEW_ALIGN_BODY(true /*nothrow*/);\n }\n \n-INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void operator delete(void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n-INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void operator delete[](void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n-INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void operator delete(void *ptr, std::nothrow_t const&) { OPERATOR_DELETE_BODY; }\n-INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void operator delete[](void *ptr, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY;\n-}\n INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete(\n     void *ptr, std::align_val_t align) NOEXCEPT {\n   OPERATOR_DELETE_BODY;\n@@ -117,4 +132,4 @@ INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete[](\n   OPERATOR_DELETE_BODY;\n }\n \n-#endif // OPERATOR_NEW_BODY\n+#endif  // OPERATOR_NEW_ALIGN_BODY"}, {"sha": "5aafdb1884b5c9a5d636d827d39e97064fb587f2", "filename": "libsanitizer/hwasan/hwasan_poisoning.cpp", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_poisoning.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -19,30 +19,6 @@\n \n namespace __hwasan {\n \n-uptr TagMemoryAligned(uptr p, uptr size, tag_t tag) {\n-  CHECK(IsAligned(p, kShadowAlignment));\n-  CHECK(IsAligned(size, kShadowAlignment));\n-  uptr shadow_start = MemToShadow(p);\n-  uptr shadow_size = MemToShadowSize(size);\n-\n-  uptr page_size = GetPageSizeCached();\n-  uptr page_start = RoundUpTo(shadow_start, page_size);\n-  uptr page_end = RoundDownTo(shadow_start + shadow_size, page_size);\n-  uptr threshold = common_flags()->clear_shadow_mmap_threshold;\n-  if (SANITIZER_LINUX &&\n-      UNLIKELY(page_end >= page_start + threshold && tag == 0)) {\n-    internal_memset((void *)shadow_start, tag, page_start - shadow_start);\n-    internal_memset((void *)page_end, tag,\n-                    shadow_start + shadow_size - page_end);\n-    // For an anonymous private mapping MADV_DONTNEED will return a zero page on\n-    // Linux.\n-    ReleaseMemoryPagesToOSAndZeroFill(page_start, page_end);\n-  } else {\n-    internal_memset((void *)shadow_start, tag, shadow_size);\n-  }\n-  return AddTagToPointer(p, tag);\n-}\n-\n uptr TagMemory(uptr p, uptr size, tag_t tag) {\n   uptr start = RoundDownTo(p, kShadowAlignment);\n   uptr end = RoundUpTo(p + size, kShadowAlignment);"}, {"sha": "44047c9fdaf8ec3171c0c50bc2831ead348b9887", "filename": "libsanitizer/hwasan/hwasan_report.cpp", "status": "modified", "additions": 131, "deletions": 75, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_report.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -236,12 +236,12 @@ static void PrintStackAllocations(StackAllocationsRingBuffer *sa,\n     frame_desc.append(\"  record_addr:0x%zx record:0x%zx\",\n                       reinterpret_cast<uptr>(record_addr), record);\n     if (SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc)) {\n-      RenderFrame(&frame_desc, \" %F %L\\n\", 0, frame->info.address, &frame->info,\n+      RenderFrame(&frame_desc, \" %F %L\", 0, frame->info.address, &frame->info,\n                   common_flags()->symbolize_vs_style,\n                   common_flags()->strip_path_prefix);\n       frame->ClearAll();\n     }\n-    Printf(\"%s\", frame_desc.data());\n+    Printf(\"%s\\n\", frame_desc.data());\n     frame_desc.clear();\n   }\n }\n@@ -296,6 +296,75 @@ static uptr GetGlobalSizeFromDescriptor(uptr ptr) {\n   return 0;\n }\n \n+static void ShowHeapOrGlobalCandidate(uptr untagged_addr, tag_t *candidate,\n+                                      tag_t *left, tag_t *right) {\n+  Decorator d;\n+  uptr mem = ShadowToMem(reinterpret_cast<uptr>(candidate));\n+  HwasanChunkView chunk = FindHeapChunkByAddress(mem);\n+  if (chunk.IsAllocated()) {\n+    uptr offset;\n+    const char *whence;\n+    if (untagged_addr < chunk.End() && untagged_addr >= chunk.Beg()) {\n+      offset = untagged_addr - chunk.Beg();\n+      whence = \"inside\";\n+    } else if (candidate == left) {\n+      offset = untagged_addr - chunk.End();\n+      whence = \"to the right of\";\n+    } else {\n+      offset = chunk.Beg() - untagged_addr;\n+      whence = \"to the left of\";\n+    }\n+    Printf(\"%s\", d.Error());\n+    Printf(\"\\nCause: heap-buffer-overflow\\n\");\n+    Printf(\"%s\", d.Default());\n+    Printf(\"%s\", d.Location());\n+    Printf(\"%p is located %zd bytes %s %zd-byte region [%p,%p)\\n\",\n+           untagged_addr, offset, whence, chunk.UsedSize(), chunk.Beg(),\n+           chunk.End());\n+    Printf(\"%s\", d.Allocation());\n+    Printf(\"allocated here:\\n\");\n+    Printf(\"%s\", d.Default());\n+    GetStackTraceFromId(chunk.GetAllocStackId()).Print();\n+    return;\n+  }\n+  // Check whether the address points into a loaded library. If so, this is\n+  // most likely a global variable.\n+  const char *module_name;\n+  uptr module_address;\n+  Symbolizer *sym = Symbolizer::GetOrInit();\n+  if (sym->GetModuleNameAndOffsetForPC(mem, &module_name, &module_address)) {\n+    Printf(\"%s\", d.Error());\n+    Printf(\"\\nCause: global-overflow\\n\");\n+    Printf(\"%s\", d.Default());\n+    DataInfo info;\n+    Printf(\"%s\", d.Location());\n+    if (sym->SymbolizeData(mem, &info) && info.start) {\n+      Printf(\n+          \"%p is located %zd bytes to the %s of %zd-byte global variable \"\n+          \"%s [%p,%p) in %s\\n\",\n+          untagged_addr,\n+          candidate == left ? untagged_addr - (info.start + info.size)\n+                            : info.start - untagged_addr,\n+          candidate == left ? \"right\" : \"left\", info.size, info.name,\n+          info.start, info.start + info.size, module_name);\n+    } else {\n+      uptr size = GetGlobalSizeFromDescriptor(mem);\n+      if (size == 0)\n+        // We couldn't find the size of the global from the descriptors.\n+        Printf(\"%p is located to the %s of a global variable in (%s+0x%x)\\n\",\n+               untagged_addr, candidate == left ? \"right\" : \"left\", module_name,\n+               module_address);\n+      else\n+        Printf(\n+            \"%p is located to the %s of a %zd-byte global variable in \"\n+            \"(%s+0x%x)\\n\",\n+            untagged_addr, candidate == left ? \"right\" : \"left\", size,\n+            module_name, module_address);\n+    }\n+    Printf(\"%s\", d.Default());\n+  }\n+}\n+\n void PrintAddressDescription(\n     uptr tagged_addr, uptr access_size,\n     StackAllocationsRingBuffer *current_stack_allocations) {\n@@ -317,78 +386,59 @@ void PrintAddressDescription(\n            d.Default());\n   }\n \n+  tag_t addr_tag = GetTagFromPointer(tagged_addr);\n+\n+  bool on_stack = false;\n+  // Check stack first. If the address is on the stack of a live thread, we\n+  // know it cannot be a heap / global overflow.\n+  hwasanThreadList().VisitAllLiveThreads([&](Thread *t) {\n+    if (t->AddrIsInStack(untagged_addr)) {\n+      on_stack = true;\n+      // TODO(fmayer): figure out how to distinguish use-after-return and\n+      // stack-buffer-overflow.\n+      Printf(\"%s\", d.Error());\n+      Printf(\"\\nCause: stack tag-mismatch\\n\");\n+      Printf(\"%s\", d.Location());\n+      Printf(\"Address %p is located in stack of thread T%zd\\n\", untagged_addr,\n+             t->unique_id());\n+      Printf(\"%s\", d.Default());\n+      t->Announce();\n+\n+      auto *sa = (t == GetCurrentThread() && current_stack_allocations)\n+                     ? current_stack_allocations\n+                     : t->stack_allocations();\n+      PrintStackAllocations(sa, addr_tag, untagged_addr);\n+      num_descriptions_printed++;\n+    }\n+  });\n+\n   // Check if this looks like a heap buffer overflow by scanning\n   // the shadow left and right and looking for the first adjacent\n   // object with a different memory tag. If that tag matches addr_tag,\n   // check the allocator if it has a live chunk there.\n-  tag_t addr_tag = GetTagFromPointer(tagged_addr);\n   tag_t *tag_ptr = reinterpret_cast<tag_t*>(MemToShadow(untagged_addr));\n   tag_t *candidate = nullptr, *left = tag_ptr, *right = tag_ptr;\n-  for (int i = 0; i < 1000; i++) {\n-    if (TagsEqual(addr_tag, left)) {\n+  uptr candidate_distance = 0;\n+  for (; candidate_distance < 1000; candidate_distance++) {\n+    if (MemIsShadow(reinterpret_cast<uptr>(left)) &&\n+        TagsEqual(addr_tag, left)) {\n       candidate = left;\n       break;\n     }\n     --left;\n-    if (TagsEqual(addr_tag, right)) {\n+    if (MemIsShadow(reinterpret_cast<uptr>(right)) &&\n+        TagsEqual(addr_tag, right)) {\n       candidate = right;\n       break;\n     }\n     ++right;\n   }\n \n-  if (candidate) {\n-    uptr mem = ShadowToMem(reinterpret_cast<uptr>(candidate));\n-    HwasanChunkView chunk = FindHeapChunkByAddress(mem);\n-    if (chunk.IsAllocated()) {\n-      Printf(\"%s\", d.Location());\n-      Printf(\"%p is located %zd bytes to the %s of %zd-byte region [%p,%p)\\n\",\n-             untagged_addr,\n-             candidate == left ? untagged_addr - chunk.End()\n-                               : chunk.Beg() - untagged_addr,\n-             candidate == left ? \"right\" : \"left\", chunk.UsedSize(),\n-             chunk.Beg(), chunk.End());\n-      Printf(\"%s\", d.Allocation());\n-      Printf(\"allocated here:\\n\");\n-      Printf(\"%s\", d.Default());\n-      GetStackTraceFromId(chunk.GetAllocStackId()).Print();\n-      num_descriptions_printed++;\n-    } else {\n-      // Check whether the address points into a loaded library. If so, this is\n-      // most likely a global variable.\n-      const char *module_name;\n-      uptr module_address;\n-      Symbolizer *sym = Symbolizer::GetOrInit();\n-      if (sym->GetModuleNameAndOffsetForPC(mem, &module_name,\n-                                           &module_address)) {\n-        DataInfo info;\n-        if (sym->SymbolizeData(mem, &info) && info.start) {\n-          Printf(\n-              \"%p is located %zd bytes to the %s of %zd-byte global variable \"\n-              \"%s [%p,%p) in %s\\n\",\n-              untagged_addr,\n-              candidate == left ? untagged_addr - (info.start + info.size)\n-                                : info.start - untagged_addr,\n-              candidate == left ? \"right\" : \"left\", info.size, info.name,\n-              info.start, info.start + info.size, module_name);\n-        } else {\n-          uptr size = GetGlobalSizeFromDescriptor(mem);\n-          if (size == 0)\n-            // We couldn't find the size of the global from the descriptors.\n-            Printf(\n-                \"%p is located to the %s of a global variable in (%s+0x%x)\\n\",\n-                untagged_addr, candidate == left ? \"right\" : \"left\",\n-                module_name, module_address);\n-          else\n-            Printf(\n-                \"%p is located to the %s of a %zd-byte global variable in \"\n-                \"(%s+0x%x)\\n\",\n-                untagged_addr, candidate == left ? \"right\" : \"left\", size,\n-                module_name, module_address);\n-        }\n-        num_descriptions_printed++;\n-      }\n-    }\n+  constexpr auto kCloseCandidateDistance = 1;\n+\n+  if (!on_stack && candidate && candidate_distance <= kCloseCandidateDistance) {\n+    ShowHeapOrGlobalCandidate(untagged_addr, candidate, left, right);\n+    num_descriptions_printed++;\n   }\n \n   hwasanThreadList().VisitAllLiveThreads([&](Thread *t) {\n@@ -398,6 +448,8 @@ void PrintAddressDescription(\n     if (FindHeapAllocation(t->heap_allocations(), tagged_addr, &har,\n                            &ring_index, &num_matching_addrs,\n                            &num_matching_addrs_4b)) {\n+      Printf(\"%s\", d.Error());\n+      Printf(\"\\nCause: use-after-free\\n\");\n       Printf(\"%s\", d.Location());\n       Printf(\"%p is located %zd bytes inside of %zd-byte region [%p,%p)\\n\",\n              untagged_addr, untagged_addr - UntagAddr(har.tagged_addr),\n@@ -424,29 +476,25 @@ void PrintAddressDescription(\n       t->Announce();\n       num_descriptions_printed++;\n     }\n-\n-    // Very basic check for stack memory.\n-    if (t->AddrIsInStack(untagged_addr)) {\n-      Printf(\"%s\", d.Location());\n-      Printf(\"Address %p is located in stack of thread T%zd\\n\", untagged_addr,\n-             t->unique_id());\n-      Printf(\"%s\", d.Default());\n-      t->Announce();\n-\n-      auto *sa = (t == GetCurrentThread() && current_stack_allocations)\n-                     ? current_stack_allocations\n-                     : t->stack_allocations();\n-      PrintStackAllocations(sa, addr_tag, untagged_addr);\n-      num_descriptions_printed++;\n-    }\n   });\n \n+  if (candidate && num_descriptions_printed == 0) {\n+    ShowHeapOrGlobalCandidate(untagged_addr, candidate, left, right);\n+    num_descriptions_printed++;\n+  }\n+\n   // Print the remaining threads, as an extra information, 1 line per thread.\n   hwasanThreadList().VisitAllLiveThreads([&](Thread *t) { t->Announce(); });\n \n   if (!num_descriptions_printed)\n     // We exhausted our possibilities. Bail out.\n     Printf(\"HWAddressSanitizer can not describe address in more detail.\\n\");\n+  if (num_descriptions_printed > 1) {\n+    Printf(\n+        \"There are %d potential causes, printed above in order \"\n+        \"of likeliness.\\n\",\n+        num_descriptions_printed);\n+  }\n }\n \n void ReportStats() {}\n@@ -538,6 +586,12 @@ void ReportTailOverwritten(StackTrace *stack, uptr tagged_addr, uptr orig_size,\n   Report(\"ERROR: %s: %s; heap object [%p,%p) of size %zd\\n\", SanitizerToolName,\n          bug_type, untagged_addr, untagged_addr + orig_size, orig_size);\n   Printf(\"\\n%s\", d.Default());\n+  Printf(\n+      \"Stack of invalid access unknown. Issue detected at deallocation \"\n+      \"time.\\n\");\n+  Printf(\"%s\", d.Allocation());\n+  Printf(\"deallocated here:\\n\");\n+  Printf(\"%s\", d.Default());\n   stack->Print();\n   HwasanChunkView chunk = FindHeapChunkByAddress(untagged_addr);\n   if (chunk.Beg()) {\n@@ -657,8 +711,10 @@ void ReportRegisters(uptr *frame, uptr pc) {\n        frame[20], frame[21], frame[22], frame[23]);\n   Printf(\"    x24 %016llx  x25 %016llx  x26 %016llx  x27 %016llx\\n\",\n        frame[24], frame[25], frame[26], frame[27]);\n-  Printf(\"    x28 %016llx  x29 %016llx  x30 %016llx\\n\",\n-       frame[28], frame[29], frame[30]);\n+  // hwasan_check* reduces the stack pointer by 256, then __hwasan_tag_mismatch\n+  // passes it to this function.\n+  Printf(\"    x28 %016llx  x29 %016llx  x30 %016llx   sp %016llx\\n\", frame[28],\n+         frame[29], frame[30], reinterpret_cast<u8 *>(frame) + 256);\n }\n \n }  // namespace __hwasan"}, {"sha": "ee747a3beea5e58d7c2203d3de85ca2008d989d8", "filename": "libsanitizer/hwasan/hwasan_thread.cpp", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -34,7 +34,8 @@ void Thread::InitRandomState() {\n     stack_allocations_->push(0);\n }\n \n-void Thread::Init(uptr stack_buffer_start, uptr stack_buffer_size) {\n+void Thread::Init(uptr stack_buffer_start, uptr stack_buffer_size,\n+                  const InitState *state) {\n   CHECK_EQ(0, unique_id_);  // try to catch bad stack reuse\n   CHECK_EQ(0, stack_top_);\n   CHECK_EQ(0, stack_bottom_);\n@@ -44,6 +45,17 @@ void Thread::Init(uptr stack_buffer_start, uptr stack_buffer_size) {\n   if (auto sz = flags()->heap_history_size)\n     heap_allocations_ = HeapAllocationsRingBuffer::New(sz);\n \n+  InitStackAndTls(state);\n+#if !SANITIZER_FUCHSIA\n+  // Do not initialize the stack ring buffer just yet on Fuchsia. Threads will\n+  // be initialized before we enter the thread itself, so we will instead call\n+  // this later.\n+  InitStackRingBuffer(stack_buffer_start, stack_buffer_size);\n+#endif\n+}\n+\n+void Thread::InitStackRingBuffer(uptr stack_buffer_start,\n+                                 uptr stack_buffer_size) {\n   HwasanTSDThreadInit();  // Only needed with interceptors.\n   uptr *ThreadLong = GetCurrentThreadLongPtr();\n   // The following implicitly sets (this) as the current thread.\n@@ -55,13 +67,6 @@ void Thread::Init(uptr stack_buffer_start, uptr stack_buffer_size) {\n   // ScopedTaggingDisable needs GetCurrentThread to be set up.\n   ScopedTaggingDisabler disabler;\n \n-  uptr tls_size;\n-  uptr stack_size;\n-  GetThreadStackAndTls(IsMainThread(), &stack_bottom_, &stack_size, &tls_begin_,\n-                       &tls_size);\n-  stack_top_ = stack_bottom_ + stack_size;\n-  tls_end_ = tls_begin_ + tls_size;\n-\n   if (stack_bottom_) {\n     int local;\n     CHECK(AddrIsInStack((uptr)&local));"}, {"sha": "9f20afe1dc76226d642d06c5347b150c93668277", "filename": "libsanitizer/hwasan/hwasan_thread.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -23,8 +23,17 @@ typedef __sanitizer::CompactRingBuffer<uptr> StackAllocationsRingBuffer;\n \n class Thread {\n  public:\n-  void Init(uptr stack_buffer_start, uptr stack_buffer_size);  // Must be called from the thread itself.\n+  // These are optional parameters that can be passed to Init.\n+  struct InitState;\n+\n+  void Init(uptr stack_buffer_start, uptr stack_buffer_size,\n+            const InitState *state = nullptr);\n   void InitRandomState();\n+  void InitStackAndTls(const InitState *state = nullptr);\n+\n+  // Must be called from the thread itself.\n+  void InitStackRingBuffer(uptr stack_buffer_start, uptr stack_buffer_size);\n+\n   void Destroy();\n \n   uptr stack_top() { return stack_top_; }"}, {"sha": "fa46e658b69d535c70a4696f6b1c774801536e1d", "filename": "libsanitizer/hwasan/hwasan_thread_list.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread_list.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread_list.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread_list.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -12,4 +12,4 @@ void InitThreadList(uptr storage, uptr size) {\n       new (thread_list_placeholder) HwasanThreadList(storage, size);\n }\n \n-} // namespace\n+} // namespace __hwasan"}, {"sha": "15916a802d6ee4c50c6189ad144d195f86ceba78", "filename": "libsanitizer/hwasan/hwasan_thread_list.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fhwasan%2Fhwasan_thread_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread_list.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -85,7 +85,7 @@ class HwasanThreadList {\n         RoundUpTo(ring_buffer_size_ + sizeof(Thread), ring_buffer_size_ * 2);\n   }\n \n-  Thread *CreateCurrentThread() {\n+  Thread *CreateCurrentThread(const Thread::InitState *state = nullptr) {\n     Thread *t = nullptr;\n     {\n       SpinMutexLock l(&free_list_mutex_);\n@@ -104,7 +104,7 @@ class HwasanThreadList {\n       SpinMutexLock l(&live_list_mutex_);\n       live_list_.push_back(t);\n     }\n-    t->Init((uptr)t - ring_buffer_size_, ring_buffer_size_);\n+    t->Init((uptr)t - ring_buffer_size_, ring_buffer_size_, state);\n     AddThreadStats(t);\n     return t;\n   }\n@@ -171,6 +171,8 @@ class HwasanThreadList {\n     return stats_;\n   }\n \n+  uptr GetRingBufferSize() const { return ring_buffer_size_; }\n+\n  private:\n   Thread *AllocThread() {\n     SpinMutexLock l(&free_space_mutex_);\n@@ -200,4 +202,4 @@ class HwasanThreadList {\n void InitThreadList(uptr storage, uptr size);\n HwasanThreadList &hwasanThreadList();\n \n-} // namespace\n+} // namespace __hwasan"}, {"sha": "cd3b6d6e2b163f3be0dce16713c1944f06206765", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -21,34 +21,15 @@\n extern \"C\" {\n #endif\n \n-typedef uint16_t dfsan_label;\n+typedef uint8_t dfsan_label;\n typedef uint32_t dfsan_origin;\n \n-/// Stores information associated with a specific label identifier.  A label\n-/// may be a base label created using dfsan_create_label, with associated\n-/// text description and user data, or an automatically created union label,\n-/// which represents the union of two label identifiers (which may themselves\n-/// be base or union labels).\n-struct dfsan_label_info {\n-  // Fields for union labels, set to 0 for base labels.\n-  dfsan_label l1;\n-  dfsan_label l2;\n-\n-  // Fields for base labels.\n-  const char *desc;\n-  void *userdata;\n-};\n-\n /// Signature of the callback argument to dfsan_set_write_callback().\n typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);\n \n-/// Computes the union of \\c l1 and \\c l2, possibly creating a union label in\n-/// the process.\n+/// Computes the union of \\c l1 and \\c l2, resulting in a union label.\n dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);\n \n-/// Creates and returns a base label with the given description and user data.\n-dfsan_label dfsan_create_label(const char *desc, void *userdata);\n-\n /// Sets the label for each address in [addr,addr+size) to \\c label.\n void dfsan_set_label(dfsan_label label, void *addr, size_t size);\n \n@@ -73,19 +54,9 @@ dfsan_origin dfsan_get_origin(long data);\n /// Retrieves the label associated with the data at the given address.\n dfsan_label dfsan_read_label(const void *addr, size_t size);\n \n-/// Retrieves a pointer to the dfsan_label_info struct for the given label.\n-const struct dfsan_label_info *dfsan_get_label_info(dfsan_label label);\n-\n /// Returns whether the given label label contains the label elem.\n int dfsan_has_label(dfsan_label label, dfsan_label elem);\n \n-/// If the given label label contains a label with the description desc, returns\n-/// that label, else returns 0.\n-dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc);\n-\n-/// Returns the number of labels allocated.\n-size_t dfsan_get_label_count(void);\n-\n /// Flushes the DFSan shadow, i.e. forgets about all labels currently associated\n /// with the application memory.  Use this call to start over the taint tracking\n /// within the same process.\n@@ -99,12 +70,6 @@ void dfsan_flush(void);\n /// callback executes.  Pass in NULL to remove any callback.\n void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);\n \n-/// Writes the labels currently used by the program to the given file\n-/// descriptor. The lines of the output have the following format:\n-///\n-/// <label> <parent label 1> <parent label 2> <label description if any>\n-void dfsan_dump_labels(int fd);\n-\n /// Interceptor hooks.\n /// Whenever a dfsan's custom function is called the corresponding\n /// hook is called it non-zero. The hooks should be defined by the user.\n@@ -123,9 +88,65 @@ void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,\n /// on, or the address is not labeled, it prints nothing.\n void dfsan_print_origin_trace(const void *addr, const char *description);\n \n+/// Prints the origin trace of the label at the address \\p addr to a\n+/// pre-allocated output buffer. If origin tracking is not on, or the address is\n+/// not labeled, it prints nothing.\n+///\n+/// Typical usage:\n+/// \\code\n+///   char kDescription[] = \"...\";\n+///   char buf[1024];\n+///   dfsan_sprint_origin_trace(&tainted_var, kDescription, buf, sizeof(buf));\n+/// \\endcode\n+///\n+/// Typical usage that handles truncation:\n+/// \\code\n+///   char buf[1024];\n+///   int len = dfsan_sprint_origin_trace(&var, nullptr, buf, sizeof(buf));\n+///\n+///   if (len < sizeof(buf)) {\n+///     ProcessOriginTrace(buf);\n+///   } else {\n+///     char *tmpbuf = new char[len + 1];\n+///     dfsan_sprint_origin_trace(&var, nullptr, tmpbuf, len + 1);\n+///     ProcessOriginTrace(tmpbuf);\n+///     delete[] tmpbuf;\n+///   }\n+/// \\endcode\n+///\n+/// \\param addr The tainted memory address whose origin we are printing.\n+/// \\param description A description printed at the beginning of the trace.\n+/// \\param [out] out_buf The output buffer to write the results to.\n+/// \\param out_buf_size The size of \\p out_buf.\n+///\n+/// \\returns The number of symbols that should have been written to \\p out_buf\n+/// (not including trailing null byte '\\0'). Thus, the string is truncated iff\n+/// return value is not less than \\p out_buf_size.\n+size_t dfsan_sprint_origin_trace(const void *addr, const char *description,\n+                                 char *out_buf, size_t out_buf_size);\n+\n+/// Prints the stack trace leading to this call to a pre-allocated output\n+/// buffer.\n+///\n+/// For usage examples, see dfsan_sprint_origin_trace.\n+///\n+/// \\param [out] out_buf The output buffer to write the results to.\n+/// \\param out_buf_size The size of \\p out_buf.\n+///\n+/// \\returns The number of symbols that should have been written to \\p out_buf\n+/// (not including trailing null byte '\\0'). Thus, the string is truncated iff\n+/// return value is not less than \\p out_buf_size.\n+size_t dfsan_sprint_stack_trace(char *out_buf, size_t out_buf_size);\n+\n /// Retrieves the very first origin associated with the data at the given\n /// address.\n dfsan_origin dfsan_get_init_origin(const void *addr);\n+\n+/// Returns the value of -dfsan-track-origins.\n+/// * 0: do not track origins.\n+/// * 1: track origins at memory store operations.\n+/// * 2: track origins at memory load and store operations.\n+int dfsan_get_track_origins(void);\n #ifdef __cplusplus\n }  // extern \"C\"\n "}, {"sha": "d8dc092c45f56e167fe872b64c94c0481b2ff372", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -16,10 +16,10 @@\n \n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n \n-#if !SANITIZER_LINUX && !SANITIZER_FREEBSD && !SANITIZER_MAC && \\\n-    !SANITIZER_NETBSD && !SANITIZER_WINDOWS && \\\n-    !SANITIZER_FUCHSIA && !SANITIZER_RTEMS && !SANITIZER_SOLARIS\n-# error \"Interception doesn't work on this operating system.\"\n+#if !SANITIZER_LINUX && !SANITIZER_FREEBSD && !SANITIZER_MAC &&      \\\n+    !SANITIZER_NETBSD && !SANITIZER_WINDOWS && !SANITIZER_FUCHSIA && \\\n+    !SANITIZER_SOLARIS\n+#  error \"Interception doesn't work on this operating system.\"\n #endif\n \n // These typedefs should be used only in the interceptor definitions to replace\n@@ -130,11 +130,6 @@ const interpose_substitution substitution_##func_name[] \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n # define DECLARE_WRAPPER_WINAPI(ret_type, func, ...) \\\n     extern \"C\" __declspec(dllimport) ret_type __stdcall func(__VA_ARGS__);\n-#elif SANITIZER_RTEMS\n-# define WRAP(x) x\n-# define WRAPPER_NAME(x) #x\n-# define INTERCEPTOR_ATTRIBUTE\n-# define DECLARE_WRAPPER(ret_type, func, ...)\n #elif SANITIZER_FREEBSD || SANITIZER_NETBSD\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x\n@@ -162,10 +157,6 @@ const interpose_substitution substitution_##func_name[] \\\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n # define REAL(x) __unsanitized_##x\n # define DECLARE_REAL(ret_type, func, ...)\n-#elif SANITIZER_RTEMS\n-# define REAL(x) __real_ ## x\n-# define DECLARE_REAL(ret_type, func, ...) \\\n-    extern \"C\" ret_type REAL(func)(__VA_ARGS__);\n #elif !SANITIZER_MAC\n # define PTR_TO_REAL(x) real_##x\n # define REAL(x) __interception::PTR_TO_REAL(x)\n@@ -184,10 +175,10 @@ const interpose_substitution substitution_##func_name[] \\\n # define ASSIGN_REAL(x, y)\n #endif  // SANITIZER_MAC\n \n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n-# define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n-  DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n-  extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n+#if !SANITIZER_FUCHSIA\n+#  define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n+    DECLARE_REAL(ret_type, func, __VA_ARGS__)               \\\n+    extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n // Declare an interceptor and its wrapper defined in a different translation\n // unit (ex. asm).\n # define DECLARE_EXTERN_INTERCEPTOR_AND_WRAPPER(ret_type, func, ...)    \\\n@@ -202,11 +193,11 @@ const interpose_substitution substitution_##func_name[] \\\n // macros does its job. In exceptional cases you may need to call REAL(foo)\n // without defining INTERCEPTOR(..., foo, ...). For example, if you override\n // foo with an interceptor for other function.\n-#if !SANITIZER_MAC && !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n-# define DEFINE_REAL(ret_type, func, ...) \\\n+#if !SANITIZER_MAC && !SANITIZER_FUCHSIA\n+#  define DEFINE_REAL(ret_type, func, ...)            \\\n     typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n-    namespace __interception { \\\n-      FUNC_TYPE(func) PTR_TO_REAL(func); \\\n+    namespace __interception {                        \\\n+    FUNC_TYPE(func) PTR_TO_REAL(func);                \\\n     }\n #else\n # define DEFINE_REAL(ret_type, func, ...)"}, {"sha": "b6adc248157b6d15478f2865b697d707bd948eba", "filename": "libsanitizer/lsan/lsan.cpp", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Flsan%2Flsan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Flsan%2Flsan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -35,18 +35,14 @@ void __sanitizer::BufferedStackTrace::UnwindImpl(\n     uptr pc, uptr bp, void *context, bool request_fast, u32 max_depth) {\n   using namespace __lsan;\n   uptr stack_top = 0, stack_bottom = 0;\n-  ThreadContext *t;\n-  if (StackTrace::WillUseFastUnwind(request_fast) &&\n-      (t = CurrentThreadContext())) {\n+  if (ThreadContext *t = CurrentThreadContext()) {\n     stack_top = t->stack_end();\n     stack_bottom = t->stack_begin();\n   }\n-  if (!SANITIZER_MIPS || IsValidFrame(bp, stack_top, stack_bottom)) {\n-    if (StackTrace::WillUseFastUnwind(request_fast))\n-      Unwind(max_depth, pc, bp, nullptr, stack_top, stack_bottom, true);\n-    else\n-      Unwind(max_depth, pc, 0, context, 0, 0, false);\n-  }\n+  if (SANITIZER_MIPS && !IsValidFrame(bp, stack_top, stack_bottom))\n+    return;\n+  bool fast = StackTrace::WillUseFastUnwind(request_fast);\n+  Unwind(max_depth, pc, bp, context, stack_top, stack_bottom, fast);\n }\n \n using namespace __lsan;"}, {"sha": "776ca60b1e9756bd342bf202528a9859f21855fa", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -221,8 +221,8 @@ void UnlockAllocator();\n // Returns true if [addr, addr + sizeof(void *)) is poisoned.\n bool WordIsPoisoned(uptr addr);\n // Wrappers for ThreadRegistry access.\n-void LockThreadRegistry();\n-void UnlockThreadRegistry();\n+void LockThreadRegistry() NO_THREAD_SAFETY_ANALYSIS;\n+void UnlockThreadRegistry() NO_THREAD_SAFETY_ANALYSIS;\n ThreadRegistry *GetThreadRegistryLocked();\n bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end, uptr *cache_begin,"}, {"sha": "1d224ebca693b631596b395752b88fd5d2a75156", "filename": "libsanitizer/lsan/lsan_thread.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Flsan%2Flsan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Flsan%2Flsan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -30,13 +30,10 @@ static ThreadContextBase *CreateThreadContext(u32 tid) {\n   return new (mem) ThreadContext(tid);\n }\n \n-static const uptr kMaxThreads = 1 << 13;\n-static const uptr kThreadQuarantineSize = 64;\n-\n void InitializeThreadRegistry() {\n   static ALIGNED(64) char thread_registry_placeholder[sizeof(ThreadRegistry)];\n-  thread_registry = new (thread_registry_placeholder)\n-      ThreadRegistry(CreateThreadContext, kMaxThreads, kThreadQuarantineSize);\n+  thread_registry =\n+      new (thread_registry_placeholder) ThreadRegistry(CreateThreadContext);\n }\n \n ThreadContextLsanBase::ThreadContextLsanBase(int tid)"}, {"sha": "d04f2d8bd166a07eba3297b41456017ede484fa4", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -41,6 +41,7 @@ sanitizer_common_files = \\\n \tsanitizer_linux_s390.cpp \\\n \tsanitizer_mac.cpp \\\n \tsanitizer_mac_libcdep.cpp \\\n+\tsanitizer_mutex.cpp \\\n \tsanitizer_netbsd.cpp \\\n \tsanitizer_openbsd.cpp \\\n \tsanitizer_persistent_allocator.cpp \\\n@@ -57,7 +58,6 @@ sanitizer_common_files = \\\n \tsanitizer_procmaps_linux.cpp \\\n \tsanitizer_procmaps_mac.cpp \\\n \tsanitizer_procmaps_solaris.cpp \\\n-\tsanitizer_rtems.cpp \\\n \tsanitizer_solaris.cpp \\\n \tsanitizer_stackdepot.cpp \\\n \tsanitizer_stacktrace.cpp \\"}, {"sha": "2856894d62bfe338ac812adda6506e681ce8189b", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -128,8 +128,9 @@ am__objects_1 = sancov_flags.lo sanitizer_allocator.lo \\\n \tsanitizer_file.lo sanitizer_flags.lo sanitizer_flag_parser.lo \\\n \tsanitizer_libc.lo sanitizer_libignore.lo sanitizer_linux.lo \\\n \tsanitizer_linux_libcdep.lo sanitizer_linux_s390.lo \\\n-\tsanitizer_mac.lo sanitizer_mac_libcdep.lo sanitizer_netbsd.lo \\\n-\tsanitizer_openbsd.lo sanitizer_persistent_allocator.lo \\\n+\tsanitizer_mac.lo sanitizer_mac_libcdep.lo sanitizer_mutex.lo \\\n+\tsanitizer_netbsd.lo sanitizer_openbsd.lo \\\n+\tsanitizer_persistent_allocator.lo \\\n \tsanitizer_platform_limits_freebsd.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n \tsanitizer_platform_limits_openbsd.lo \\\n@@ -138,11 +139,11 @@ am__objects_1 = sancov_flags.lo sanitizer_allocator.lo \\\n \tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n \tsanitizer_procmaps_bsd.lo sanitizer_procmaps_common.lo \\\n \tsanitizer_procmaps_linux.lo sanitizer_procmaps_mac.lo \\\n-\tsanitizer_procmaps_solaris.lo sanitizer_rtems.lo \\\n-\tsanitizer_solaris.lo sanitizer_stackdepot.lo \\\n-\tsanitizer_stacktrace.lo sanitizer_stacktrace_libcdep.lo \\\n-\tsanitizer_stacktrace_sparc.lo sanitizer_symbolizer_mac.lo \\\n-\tsanitizer_symbolizer_report.lo sanitizer_stacktrace_printer.lo \\\n+\tsanitizer_procmaps_solaris.lo sanitizer_solaris.lo \\\n+\tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n+\tsanitizer_stacktrace_libcdep.lo sanitizer_stacktrace_sparc.lo \\\n+\tsanitizer_symbolizer_mac.lo sanitizer_symbolizer_report.lo \\\n+\tsanitizer_stacktrace_printer.lo \\\n \tsanitizer_stoptheworld_linux_libcdep.lo \\\n \tsanitizer_stoptheworld_mac.lo sanitizer_suppressions.lo \\\n \tsanitizer_symbolizer.lo sanitizer_symbolizer_libbacktrace.lo \\\n@@ -400,6 +401,7 @@ sanitizer_common_files = \\\n \tsanitizer_linux_s390.cpp \\\n \tsanitizer_mac.cpp \\\n \tsanitizer_mac_libcdep.cpp \\\n+\tsanitizer_mutex.cpp \\\n \tsanitizer_netbsd.cpp \\\n \tsanitizer_openbsd.cpp \\\n \tsanitizer_persistent_allocator.cpp \\\n@@ -416,7 +418,6 @@ sanitizer_common_files = \\\n \tsanitizer_procmaps_linux.cpp \\\n \tsanitizer_procmaps_mac.cpp \\\n \tsanitizer_procmaps_solaris.cpp \\\n-\tsanitizer_rtems.cpp \\\n \tsanitizer_solaris.cpp \\\n \tsanitizer_stackdepot.cpp \\\n \tsanitizer_stacktrace.cpp \\\n@@ -557,6 +558,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_s390.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mutex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_netbsd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_openbsd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_persistent_allocator.Plo@am__quote@\n@@ -573,7 +575,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_solaris.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_rtems.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_solaris.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@"}, {"sha": "15f81a04350f2270398dd69286dc76e56b4bd8af", "filename": "libsanitizer/sanitizer_common/sanitizer_addrhashmap.h", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -162,8 +162,8 @@ AddrHashMap<T, kSize>::AddrHashMap() {\n   table_ = (Bucket*)MmapOrDie(kSize * sizeof(table_[0]), \"AddrHashMap\");\n }\n \n-template<typename T, uptr kSize>\n-void AddrHashMap<T, kSize>::acquire(Handle *h) {\n+template <typename T, uptr kSize>\n+void AddrHashMap<T, kSize>::acquire(Handle *h) NO_THREAD_SAFETY_ANALYSIS {\n   uptr addr = h->addr_;\n   uptr hash = calcHash(addr);\n   Bucket *b = &table_[hash];\n@@ -289,57 +289,57 @@ void AddrHashMap<T, kSize>::acquire(Handle *h) {\n   CHECK_EQ(atomic_load(&c->addr, memory_order_relaxed), 0);\n   h->addidx_ = i;\n   h->cell_ = c;\n-}\n-\n-template<typename T, uptr kSize>\n-void AddrHashMap<T, kSize>::release(Handle *h) {\n-  if (!h->cell_)\n-    return;\n-  Bucket *b = h->bucket_;\n-  Cell *c = h->cell_;\n-  uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n-  if (h->created_) {\n-    // Denote completion of insertion.\n-    CHECK_EQ(addr1, 0);\n-    // After the following store, the element becomes available\n-    // for lock-free reads.\n-    atomic_store(&c->addr, h->addr_, memory_order_release);\n-    b->mtx.Unlock();\n-  } else if (h->remove_) {\n-    // Denote that the cell is empty now.\n-    CHECK_EQ(addr1, h->addr_);\n-    atomic_store(&c->addr, 0, memory_order_release);\n-    // See if we need to compact the bucket.\n-    AddBucket *add = (AddBucket*)atomic_load(&b->add, memory_order_relaxed);\n-    if (h->addidx_ == -1U) {\n-      // Removed from embed array, move an add element into the freed cell.\n-      if (add && add->size != 0) {\n-        uptr last = --add->size;\n-        Cell *c1 = &add->cells[last];\n-        c->val = c1->val;\n-        uptr addr1 = atomic_load(&c1->addr, memory_order_relaxed);\n-        atomic_store(&c->addr, addr1, memory_order_release);\n-        atomic_store(&c1->addr, 0, memory_order_release);\n-      }\n-    } else {\n-      // Removed from add array, compact it.\n-      uptr last = --add->size;\n-      Cell *c1 = &add->cells[last];\n-      if (c != c1) {\n-        *c = *c1;\n-        atomic_store(&c1->addr, 0, memory_order_relaxed);\n-      }\n-    }\n-    if (add && add->size == 0) {\n-      // FIXME(dvyukov): free add?\n-    }\n-    b->mtx.Unlock();\n-  } else {\n-    CHECK_EQ(addr1, h->addr_);\n-    if (h->addidx_ != -1U)\n-      b->mtx.ReadUnlock();\n-  }\n-}\n+ }\n+\n+ template <typename T, uptr kSize>\n+ void AddrHashMap<T, kSize>::release(Handle *h) NO_THREAD_SAFETY_ANALYSIS {\n+   if (!h->cell_)\n+     return;\n+   Bucket *b = h->bucket_;\n+   Cell *c = h->cell_;\n+   uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n+   if (h->created_) {\n+     // Denote completion of insertion.\n+     CHECK_EQ(addr1, 0);\n+     // After the following store, the element becomes available\n+     // for lock-free reads.\n+     atomic_store(&c->addr, h->addr_, memory_order_release);\n+     b->mtx.Unlock();\n+   } else if (h->remove_) {\n+     // Denote that the cell is empty now.\n+     CHECK_EQ(addr1, h->addr_);\n+     atomic_store(&c->addr, 0, memory_order_release);\n+     // See if we need to compact the bucket.\n+     AddBucket *add = (AddBucket *)atomic_load(&b->add, memory_order_relaxed);\n+     if (h->addidx_ == -1U) {\n+       // Removed from embed array, move an add element into the freed cell.\n+       if (add && add->size != 0) {\n+         uptr last = --add->size;\n+         Cell *c1 = &add->cells[last];\n+         c->val = c1->val;\n+         uptr addr1 = atomic_load(&c1->addr, memory_order_relaxed);\n+         atomic_store(&c->addr, addr1, memory_order_release);\n+         atomic_store(&c1->addr, 0, memory_order_release);\n+       }\n+     } else {\n+       // Removed from add array, compact it.\n+       uptr last = --add->size;\n+       Cell *c1 = &add->cells[last];\n+       if (c != c1) {\n+         *c = *c1;\n+         atomic_store(&c1->addr, 0, memory_order_relaxed);\n+       }\n+     }\n+     if (add && add->size == 0) {\n+       // FIXME(dvyukov): free add?\n+     }\n+     b->mtx.Unlock();\n+   } else {\n+     CHECK_EQ(addr1, h->addr_);\n+     if (h->addidx_ != -1U)\n+       b->mtx.ReadUnlock();\n+   }\n+ }\n \n template<typename T, uptr kSize>\n uptr AddrHashMap<T, kSize>::calcHash(uptr addr) {"}, {"sha": "bcb7370a79061ff0e050041943368a73417f4443", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cpp", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -137,14 +137,6 @@ static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n \n #endif  // SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n \n-namespace {\n-const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n-\n-struct BlockHeader {\n-  u64 magic;\n-};\n-}  // namespace\n-\n static void NORETURN ReportInternalAllocatorOutOfMemory(uptr requested_size) {\n   SetAllocatorOutOfMemory();\n   Report(\"FATAL: %s: internal allocator is out of memory trying to allocate \"\n@@ -153,28 +145,17 @@ static void NORETURN ReportInternalAllocatorOutOfMemory(uptr requested_size) {\n }\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache, uptr alignment) {\n-  uptr s = size + sizeof(BlockHeader);\n-  if (s < size)\n-    return nullptr;\n-  BlockHeader *p = (BlockHeader *)RawInternalAlloc(s, cache, alignment);\n+  void *p = RawInternalAlloc(size, cache, alignment);\n   if (UNLIKELY(!p))\n-    ReportInternalAllocatorOutOfMemory(s);\n-  p->magic = kBlockMagic;\n-  return p + 1;\n+    ReportInternalAllocatorOutOfMemory(size);\n+  return p;\n }\n \n void *InternalRealloc(void *addr, uptr size, InternalAllocatorCache *cache) {\n-  if (!addr)\n-    return InternalAlloc(size, cache);\n-  uptr s = size + sizeof(BlockHeader);\n-  if (s < size)\n-    return nullptr;\n-  BlockHeader *p = (BlockHeader *)addr - 1;\n-  CHECK_EQ(kBlockMagic, p->magic);\n-  p = (BlockHeader *)RawInternalRealloc(p, s, cache);\n+  void *p = RawInternalRealloc(addr, size, cache);\n   if (UNLIKELY(!p))\n-    ReportInternalAllocatorOutOfMemory(s);\n-  return p + 1;\n+    ReportInternalAllocatorOutOfMemory(size);\n+  return p;\n }\n \n void *InternalReallocArray(void *addr, uptr count, uptr size,\n@@ -203,12 +184,7 @@ void *InternalCalloc(uptr count, uptr size, InternalAllocatorCache *cache) {\n }\n \n void InternalFree(void *addr, InternalAllocatorCache *cache) {\n-  if (!addr)\n-    return;\n-  BlockHeader *p = (BlockHeader *)addr - 1;\n-  CHECK_EQ(kBlockMagic, p->magic);\n-  p->magic = 0;\n-  RawInternalFree(p, cache);\n+  RawInternalFree(addr, cache);\n }\n \n // LowLevelAllocator"}, {"sha": "0e81e6764f9a6ad8b33e4449172fadad2ee0b109", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -177,12 +177,12 @@ class CombinedAllocator {\n \n   // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n   // introspection API.\n-  void ForceLock() {\n+  void ForceLock() NO_THREAD_SAFETY_ANALYSIS {\n     primary_.ForceLock();\n     secondary_.ForceLock();\n   }\n \n-  void ForceUnlock() {\n+  void ForceUnlock() NO_THREAD_SAFETY_ANALYSIS {\n     secondary_.ForceUnlock();\n     primary_.ForceUnlock();\n   }"}, {"sha": "e495c56f03775e26a3752e203dcc40d437cc1d3f", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_local_cache.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -17,6 +17,7 @@\n template <class SizeClassAllocator>\n struct SizeClassAllocator64LocalCache {\n   typedef SizeClassAllocator Allocator;\n+  typedef MemoryMapper<Allocator> MemoryMapperT;\n \n   void Init(AllocatorGlobalStats *s) {\n     stats_.Init();\n@@ -53,7 +54,7 @@ struct SizeClassAllocator64LocalCache {\n     PerClass *c = &per_class_[class_id];\n     InitCache(c);\n     if (UNLIKELY(c->count == c->max_count))\n-      Drain(c, allocator, class_id, c->max_count / 2);\n+      DrainHalfMax(c, allocator, class_id);\n     CompactPtrT chunk = allocator->PointerToCompactPtr(\n         allocator->GetRegionBeginBySizeClass(class_id),\n         reinterpret_cast<uptr>(p));\n@@ -62,10 +63,10 @@ struct SizeClassAllocator64LocalCache {\n   }\n \n   void Drain(SizeClassAllocator *allocator) {\n+    MemoryMapperT memory_mapper(*allocator);\n     for (uptr i = 1; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n-      while (c->count > 0)\n-        Drain(c, allocator, i, c->count);\n+      while (c->count > 0) Drain(&memory_mapper, c, allocator, i, c->count);\n     }\n   }\n \n@@ -106,12 +107,18 @@ struct SizeClassAllocator64LocalCache {\n     return true;\n   }\n \n-  NOINLINE void Drain(PerClass *c, SizeClassAllocator *allocator, uptr class_id,\n-                      uptr count) {\n+  NOINLINE void DrainHalfMax(PerClass *c, SizeClassAllocator *allocator,\n+                             uptr class_id) {\n+    MemoryMapperT memory_mapper(*allocator);\n+    Drain(&memory_mapper, c, allocator, class_id, c->max_count / 2);\n+  }\n+\n+  void Drain(MemoryMapperT *memory_mapper, PerClass *c,\n+             SizeClassAllocator *allocator, uptr class_id, uptr count) {\n     CHECK_GE(c->count, count);\n     const uptr first_idx_to_drain = c->count - count;\n     c->count -= count;\n-    allocator->ReturnToAllocator(&stats_, class_id,\n+    allocator->ReturnToAllocator(memory_mapper, &stats_, class_id,\n                                  &c->chunks[first_idx_to_drain], count);\n   }\n };"}, {"sha": "38d2a7d117fbfa608c02096a7c1fe009afd26ac6", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -237,13 +237,13 @@ class SizeClassAllocator32 {\n \n   // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n   // introspection API.\n-  void ForceLock() {\n+  void ForceLock() NO_THREAD_SAFETY_ANALYSIS {\n     for (uptr i = 0; i < kNumClasses; i++) {\n       GetSizeClassInfo(i)->mutex.Lock();\n     }\n   }\n \n-  void ForceUnlock() {\n+  void ForceUnlock() NO_THREAD_SAFETY_ANALYSIS {\n     for (int i = kNumClasses - 1; i >= 0; i--) {\n       GetSizeClassInfo(i)->mutex.Unlock();\n     }"}, {"sha": "b142ee0131b2bfb6d05b24aaeaeafa032d5aa1e2", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 78, "deletions": 92, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -42,6 +42,44 @@ struct SizeClassAllocator64FlagMasks {  //  Bit masks.\n   };\n };\n \n+template <typename Allocator>\n+class MemoryMapper {\n+ public:\n+  typedef typename Allocator::CompactPtrT CompactPtrT;\n+\n+  explicit MemoryMapper(const Allocator &allocator) : allocator_(allocator) {}\n+\n+  bool GetAndResetStats(uptr &ranges, uptr &bytes) {\n+    ranges = released_ranges_count_;\n+    released_ranges_count_ = 0;\n+    bytes = released_bytes_;\n+    released_bytes_ = 0;\n+    return ranges != 0;\n+  }\n+\n+  u64 *MapPackedCounterArrayBuffer(uptr count) {\n+    buffer_.clear();\n+    buffer_.resize(count);\n+    return buffer_.data();\n+  }\n+\n+  // Releases [from, to) range of pages back to OS.\n+  void ReleasePageRangeToOS(uptr class_id, CompactPtrT from, CompactPtrT to) {\n+    const uptr region_base = allocator_.GetRegionBeginBySizeClass(class_id);\n+    const uptr from_page = allocator_.CompactPtrToPointer(region_base, from);\n+    const uptr to_page = allocator_.CompactPtrToPointer(region_base, to);\n+    ReleaseMemoryPagesToOS(from_page, to_page);\n+    released_ranges_count_++;\n+    released_bytes_ += to_page - from_page;\n+  }\n+\n+ private:\n+  const Allocator &allocator_;\n+  uptr released_ranges_count_ = 0;\n+  uptr released_bytes_ = 0;\n+  InternalMmapVector<u64> buffer_;\n+};\n+\n template <class Params>\n class SizeClassAllocator64 {\n  public:\n@@ -57,6 +95,7 @@ class SizeClassAllocator64 {\n \n   typedef SizeClassAllocator64<Params> ThisT;\n   typedef SizeClassAllocator64LocalCache<ThisT> AllocatorCache;\n+  typedef MemoryMapper<ThisT> MemoryMapperT;\n \n   // When we know the size class (the region base) we can represent a pointer\n   // as a 4-byte integer (offset from the region start shifted right by 4).\n@@ -120,9 +159,10 @@ class SizeClassAllocator64 {\n   }\n \n   void ForceReleaseToOS() {\n+    MemoryMapperT memory_mapper(*this);\n     for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n       BlockingMutexLock l(&GetRegionInfo(class_id)->mutex);\n-      MaybeReleaseToOS(class_id, true /*force*/);\n+      MaybeReleaseToOS(&memory_mapper, class_id, true /*force*/);\n     }\n   }\n \n@@ -131,7 +171,8 @@ class SizeClassAllocator64 {\n       alignment <= SizeClassMap::kMaxSize;\n   }\n \n-  NOINLINE void ReturnToAllocator(AllocatorStats *stat, uptr class_id,\n+  NOINLINE void ReturnToAllocator(MemoryMapperT *memory_mapper,\n+                                  AllocatorStats *stat, uptr class_id,\n                                   const CompactPtrT *chunks, uptr n_chunks) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     uptr region_beg = GetRegionBeginBySizeClass(class_id);\n@@ -154,7 +195,7 @@ class SizeClassAllocator64 {\n     region->num_freed_chunks = new_num_freed_chunks;\n     region->stats.n_freed += n_chunks;\n \n-    MaybeReleaseToOS(class_id, false /*force*/);\n+    MaybeReleaseToOS(memory_mapper, class_id, false /*force*/);\n   }\n \n   NOINLINE bool GetFromAllocator(AllocatorStats *stat, uptr class_id,\n@@ -312,13 +353,13 @@ class SizeClassAllocator64 {\n \n   // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n   // introspection API.\n-  void ForceLock() {\n+  void ForceLock() NO_THREAD_SAFETY_ANALYSIS {\n     for (uptr i = 0; i < kNumClasses; i++) {\n       GetRegionInfo(i)->mutex.Lock();\n     }\n   }\n \n-  void ForceUnlock() {\n+  void ForceUnlock() NO_THREAD_SAFETY_ANALYSIS {\n     for (int i = (int)kNumClasses - 1; i >= 0; i--) {\n       GetRegionInfo(i)->mutex.Unlock();\n     }\n@@ -362,11 +403,11 @@ class SizeClassAllocator64 {\n   // For the performance sake, none of the accessors check the validity of the\n   // arguments, it is assumed that index is always in [0, n) range and the value\n   // is not incremented past max_value.\n-  template<class MemoryMapperT>\n   class PackedCounterArray {\n    public:\n-    PackedCounterArray(u64 num_counters, u64 max_value, MemoryMapperT *mapper)\n-        : n(num_counters), memory_mapper(mapper) {\n+    template <typename MemoryMapper>\n+    PackedCounterArray(u64 num_counters, u64 max_value, MemoryMapper *mapper)\n+        : n(num_counters) {\n       CHECK_GT(num_counters, 0);\n       CHECK_GT(max_value, 0);\n       constexpr u64 kMaxCounterBits = sizeof(*buffer) * 8ULL;\n@@ -383,16 +424,8 @@ class SizeClassAllocator64 {\n       packing_ratio_log = Log2(packing_ratio);\n       bit_offset_mask = packing_ratio - 1;\n \n-      buffer_size =\n-          (RoundUpTo(n, 1ULL << packing_ratio_log) >> packing_ratio_log) *\n-          sizeof(*buffer);\n-      buffer = reinterpret_cast<u64*>(\n-          memory_mapper->MapPackedCounterArrayBuffer(buffer_size));\n-    }\n-    ~PackedCounterArray() {\n-      if (buffer) {\n-        memory_mapper->UnmapPackedCounterArrayBuffer(buffer, buffer_size);\n-      }\n+      buffer = mapper->MapPackedCounterArrayBuffer(\n+          RoundUpTo(n, 1ULL << packing_ratio_log) >> packing_ratio_log);\n     }\n \n     bool IsAllocated() const {\n@@ -429,19 +462,16 @@ class SizeClassAllocator64 {\n     u64 counter_mask;\n     u64 packing_ratio_log;\n     u64 bit_offset_mask;\n-\n-    MemoryMapperT* const memory_mapper;\n-    u64 buffer_size;\n     u64* buffer;\n   };\n \n-  template<class MemoryMapperT>\n+  template <class MemoryMapperT>\n   class FreePagesRangeTracker {\n    public:\n-    explicit FreePagesRangeTracker(MemoryMapperT* mapper)\n+    FreePagesRangeTracker(MemoryMapperT *mapper, uptr class_id)\n         : memory_mapper(mapper),\n-          page_size_scaled_log(Log2(GetPageSizeCached() >> kCompactPtrScale)),\n-          in_the_range(false), current_page(0), current_range_start_page(0) {}\n+          class_id(class_id),\n+          page_size_scaled_log(Log2(GetPageSizeCached() >> kCompactPtrScale)) {}\n \n     void NextPage(bool freed) {\n       if (freed) {\n@@ -463,28 +493,30 @@ class SizeClassAllocator64 {\n     void CloseOpenedRange() {\n       if (in_the_range) {\n         memory_mapper->ReleasePageRangeToOS(\n-            current_range_start_page << page_size_scaled_log,\n+            class_id, current_range_start_page << page_size_scaled_log,\n             current_page << page_size_scaled_log);\n         in_the_range = false;\n       }\n     }\n \n-    MemoryMapperT* const memory_mapper;\n-    const uptr page_size_scaled_log;\n-    bool in_the_range;\n-    uptr current_page;\n-    uptr current_range_start_page;\n+    MemoryMapperT *const memory_mapper = nullptr;\n+    const uptr class_id = 0;\n+    const uptr page_size_scaled_log = 0;\n+    bool in_the_range = false;\n+    uptr current_page = 0;\n+    uptr current_range_start_page = 0;\n   };\n \n   // Iterates over the free_array to identify memory pages containing freed\n   // chunks only and returns these pages back to OS.\n   // allocated_pages_count is the total number of pages allocated for the\n   // current bucket.\n-  template<class MemoryMapperT>\n+  template <typename MemoryMapper>\n   static void ReleaseFreeMemoryToOS(CompactPtrT *free_array,\n                                     uptr free_array_count, uptr chunk_size,\n                                     uptr allocated_pages_count,\n-                                    MemoryMapperT *memory_mapper) {\n+                                    MemoryMapper *memory_mapper,\n+                                    uptr class_id) {\n     const uptr page_size = GetPageSizeCached();\n \n     // Figure out the number of chunks per page and whether we can take a fast\n@@ -520,9 +552,8 @@ class SizeClassAllocator64 {\n       UNREACHABLE(\"All chunk_size/page_size ratios must be handled.\");\n     }\n \n-    PackedCounterArray<MemoryMapperT> counters(allocated_pages_count,\n-                                               full_pages_chunk_count_max,\n-                                               memory_mapper);\n+    PackedCounterArray counters(allocated_pages_count,\n+                                full_pages_chunk_count_max, memory_mapper);\n     if (!counters.IsAllocated())\n       return;\n \n@@ -547,7 +578,7 @@ class SizeClassAllocator64 {\n \n     // Iterate over pages detecting ranges of pages with chunk counters equal\n     // to the expected number of chunks for the particular page.\n-    FreePagesRangeTracker<MemoryMapperT> range_tracker(memory_mapper);\n+    FreePagesRangeTracker<MemoryMapper> range_tracker(memory_mapper, class_id);\n     if (same_chunk_count_per_page) {\n       // Fast path, every page has the same number of chunks affecting it.\n       for (uptr i = 0; i < counters.GetCount(); i++)\n@@ -586,7 +617,7 @@ class SizeClassAllocator64 {\n   }\n \n  private:\n-  friend class MemoryMapper;\n+  friend class MemoryMapper<ThisT>;\n \n   ReservedAddressRange address_range;\n \n@@ -820,57 +851,13 @@ class SizeClassAllocator64 {\n     return true;\n   }\n \n-  class MemoryMapper {\n-   public:\n-    MemoryMapper(const ThisT& base_allocator, uptr class_id)\n-        : allocator(base_allocator),\n-          region_base(base_allocator.GetRegionBeginBySizeClass(class_id)),\n-          released_ranges_count(0),\n-          released_bytes(0) {\n-    }\n-\n-    uptr GetReleasedRangesCount() const {\n-      return released_ranges_count;\n-    }\n-\n-    uptr GetReleasedBytes() const {\n-      return released_bytes;\n-    }\n-\n-    void *MapPackedCounterArrayBuffer(uptr buffer_size) {\n-      // TODO(alekseyshl): The idea to explore is to check if we have enough\n-      // space between num_freed_chunks*sizeof(CompactPtrT) and\n-      // mapped_free_array to fit buffer_size bytes and use that space instead\n-      // of mapping a temporary one.\n-      return MmapOrDieOnFatalError(buffer_size, \"ReleaseToOSPageCounters\");\n-    }\n-\n-    void UnmapPackedCounterArrayBuffer(void *buffer, uptr buffer_size) {\n-      UnmapOrDie(buffer, buffer_size);\n-    }\n-\n-    // Releases [from, to) range of pages back to OS.\n-    void ReleasePageRangeToOS(CompactPtrT from, CompactPtrT to) {\n-      const uptr from_page = allocator.CompactPtrToPointer(region_base, from);\n-      const uptr to_page = allocator.CompactPtrToPointer(region_base, to);\n-      ReleaseMemoryPagesToOS(from_page, to_page);\n-      released_ranges_count++;\n-      released_bytes += to_page - from_page;\n-    }\n-\n-   private:\n-    const ThisT& allocator;\n-    const uptr region_base;\n-    uptr released_ranges_count;\n-    uptr released_bytes;\n-  };\n-\n   // Attempts to release RAM occupied by freed chunks back to OS. The region is\n   // expected to be locked.\n   //\n   // TODO(morehouse): Support a callback on memory release so HWASan can release\n   // aliases as well.\n-  void MaybeReleaseToOS(uptr class_id, bool force) {\n+  void MaybeReleaseToOS(MemoryMapperT *memory_mapper, uptr class_id,\n+                        bool force) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     const uptr chunk_size = ClassIdToSize(class_id);\n     const uptr page_size = GetPageSizeCached();\n@@ -894,17 +881,16 @@ class SizeClassAllocator64 {\n       }\n     }\n \n-    MemoryMapper memory_mapper(*this, class_id);\n-\n-    ReleaseFreeMemoryToOS<MemoryMapper>(\n+    ReleaseFreeMemoryToOS(\n         GetFreeArray(GetRegionBeginBySizeClass(class_id)), n, chunk_size,\n-        RoundUpTo(region->allocated_user, page_size) / page_size,\n-        &memory_mapper);\n+        RoundUpTo(region->allocated_user, page_size) / page_size, memory_mapper,\n+        class_id);\n \n-    if (memory_mapper.GetReleasedRangesCount() > 0) {\n+    uptr ranges, bytes;\n+    if (memory_mapper->GetAndResetStats(ranges, bytes)) {\n       region->rtoi.n_freed_at_last_release = region->stats.n_freed;\n-      region->rtoi.num_releases += memory_mapper.GetReleasedRangesCount();\n-      region->rtoi.last_released_bytes = memory_mapper.GetReleasedBytes();\n+      region->rtoi.num_releases += ranges;\n+      region->rtoi.last_released_bytes = bytes;\n     }\n     region->rtoi.last_release_at_ns = MonotonicNanoTime();\n   }"}, {"sha": "dd34fe85cc3a8c8e36d006a309ac2c518f54169a", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -267,13 +267,9 @@ class LargeMmapAllocator {\n \n   // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n   // introspection API.\n-  void ForceLock() {\n-    mutex_.Lock();\n-  }\n+  void ForceLock() ACQUIRE(mutex_) { mutex_.Lock(); }\n \n-  void ForceUnlock() {\n-    mutex_.Unlock();\n-  }\n+  void ForceUnlock() RELEASE(mutex_) { mutex_.Unlock(); }\n \n   // Iterate over all existing chunks.\n   // The allocator must be locked when calling this function."}, {"sha": "5fae8e33b9058da24921c8bd16eb7679ee3c5556", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cpp", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -37,10 +37,9 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                       const char *mmap_type, error_t err,\n                                       bool raw_report) {\n   static int recursion_count;\n-  if (SANITIZER_RTEMS || raw_report || recursion_count) {\n-    // If we are on RTEMS or raw report is requested or we went into recursion,\n-    // just die.  The Report() and CHECK calls below may call mmap recursively\n-    // and fail.\n+  if (raw_report || recursion_count) {\n+    // If raw report is requested or we went into recursion just die.  The\n+    // Report() and CHECK calls below may call mmap recursively and fail.\n     RawWrite(\"ERROR: Failed to mmap\\n\");\n     Die();\n   }\n@@ -331,6 +330,14 @@ static int InstallMallocFreeHooks(void (*malloc_hook)(const void *, uptr),\n   return 0;\n }\n \n+void internal_sleep(unsigned seconds) {\n+  internal_usleep((u64)seconds * 1000 * 1000);\n+}\n+void SleepForSeconds(unsigned seconds) {\n+  internal_usleep((u64)seconds * 1000 * 1000);\n+}\n+void SleepForMillis(unsigned millis) { internal_usleep((u64)millis * 1000); }\n+\n } // namespace __sanitizer\n \n using namespace __sanitizer;"}, {"sha": "cbdbb0c4c4bd4b3e67d40cdb7f40d1cbc52d4c57", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -237,10 +237,16 @@ void SetPrintfAndReportCallback(void (*callback)(const char *));\n // Lock sanitizer error reporting and protects against nested errors.\n class ScopedErrorReportLock {\n  public:\n-  ScopedErrorReportLock();\n-  ~ScopedErrorReportLock();\n+  ScopedErrorReportLock() ACQUIRE(mutex_) { Lock(); }\n+  ~ScopedErrorReportLock() RELEASE(mutex_) { Unlock(); }\n \n-  static void CheckLocked();\n+  static void Lock() ACQUIRE(mutex_);\n+  static void Unlock() RELEASE(mutex_);\n+  static void CheckLocked() CHECK_LOCKED(mutex_);\n+\n+ private:\n+  static atomic_uintptr_t reporting_thread_;\n+  static StaticSpinMutex mutex_;\n };\n \n extern uptr stoptheworld_tracer_pid;\n@@ -288,8 +294,8 @@ void InitTlsSize();\n uptr GetTlsSize();\n \n // Other\n-void SleepForSeconds(int seconds);\n-void SleepForMillis(int millis);\n+void SleepForSeconds(unsigned seconds);\n+void SleepForMillis(unsigned millis);\n u64 NanoTime();\n u64 MonotonicNanoTime();\n int Atexit(void (*function)(void));\n@@ -1057,6 +1063,13 @@ class ArrayRef {\n   T *end_ = nullptr;\n };\n \n+#define PRINTF_128(v)                                                         \\\n+  (*((u8 *)&v + 0)), (*((u8 *)&v + 1)), (*((u8 *)&v + 2)), (*((u8 *)&v + 3)), \\\n+      (*((u8 *)&v + 4)), (*((u8 *)&v + 5)), (*((u8 *)&v + 6)),                \\\n+      (*((u8 *)&v + 7)), (*((u8 *)&v + 8)), (*((u8 *)&v + 9)),                \\\n+      (*((u8 *)&v + 10)), (*((u8 *)&v + 11)), (*((u8 *)&v + 12)),             \\\n+      (*((u8 *)&v + 13)), (*((u8 *)&v + 14)), (*((u8 *)&v + 15))\n+\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,"}, {"sha": "6205d853a4c9d72f49e324f113a339102be1c7cd", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 62, "deletions": 22, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -134,11 +134,11 @@ extern const short *_tolower_tab_;\n \n // Platform-specific options.\n #if SANITIZER_MAC\n-#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE 0\n #elif SANITIZER_WINDOWS64\n-#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE 0\n #else\n-#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n+#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE 1\n #endif  // SANITIZER_MAC\n \n #ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n@@ -823,11 +823,11 @@ INTERCEPTOR(void *, memcpy, void *dst, const void *src, uptr size) {\n   // N.B.: If we switch this to internal_ we'll have to use internal_memmove\n   // due to memcpy being an alias of memmove on OS X.\n   void *ctx;\n-  if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n+#if PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE\n     COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, dst, src, size);\n-  } else {\n+#else\n     COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n-  }\n+#endif\n }\n \n #define INIT_MEMCPY                                  \\\n@@ -957,6 +957,7 @@ INTERCEPTOR(double, frexp, double x, int *exp) {\n   // Assuming frexp() always writes to |exp|.\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n   double res = REAL(frexp)(x, exp);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(exp, sizeof(*exp));\n   return res;\n }\n \n@@ -969,22 +970,18 @@ INTERCEPTOR(double, frexp, double x, int *exp) {\n INTERCEPTOR(float, frexpf, float x, int *exp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, frexpf, x, exp);\n-  // FIXME: under ASan the call below may write to freed memory and corrupt\n-  // its metadata. See\n-  // https://github.com/google/sanitizers/issues/321.\n-  float res = REAL(frexpf)(x, exp);\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n+  float res = REAL(frexpf)(x, exp);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(exp, sizeof(*exp));\n   return res;\n }\n \n INTERCEPTOR(long double, frexpl, long double x, int *exp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, frexpl, x, exp);\n-  // FIXME: under ASan the call below may write to freed memory and corrupt\n-  // its metadata. See\n-  // https://github.com/google/sanitizers/issues/321.\n-  long double res = REAL(frexpl)(x, exp);\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n+  long double res = REAL(frexpl)(x, exp);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(exp, sizeof(*exp));\n   return res;\n }\n \n@@ -5303,6 +5300,12 @@ INTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n #define INIT_TIMES\n #endif\n \n+#if SANITIZER_S390 && \\\n+    (SANITIZER_INTERCEPT_TLS_GET_ADDR || SANITIZER_INTERCEPT_TLS_GET_OFFSET)\n+extern \"C\" uptr __tls_get_offset_wrapper(void *arg, uptr (*fn)(void *arg));\n+DEFINE_REAL(uptr, __tls_get_offset, void *arg)\n+#endif\n+\n #if SANITIZER_INTERCEPT_TLS_GET_ADDR\n #if !SANITIZER_S390\n #define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_addr)\n@@ -5342,11 +5345,7 @@ void *__tls_get_addr_opt(void *arg);\n //   descriptor offset as an argument instead of a pointer.  GOT address\n //   is passed in r12, so it's necessary to write it in assembly.  This is\n //   the function used by the compiler.\n-extern \"C\" uptr __tls_get_offset_wrapper(void *arg, uptr (*fn)(void *arg));\n #define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_offset)\n-DEFINE_REAL(uptr, __tls_get_offset, void *arg)\n-extern \"C\" uptr __tls_get_offset(void *arg);\n-extern \"C\" uptr __interceptor___tls_get_offset(void *arg);\n INTERCEPTOR(uptr, __tls_get_addr_internal, void *arg) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr_internal, arg);\n@@ -5362,6 +5361,15 @@ INTERCEPTOR(uptr, __tls_get_addr_internal, void *arg) {\n   }\n   return res;\n }\n+#endif // SANITIZER_S390\n+#else\n+#define INIT_TLS_GET_ADDR\n+#endif\n+\n+#if SANITIZER_S390 && \\\n+    (SANITIZER_INTERCEPT_TLS_GET_ADDR || SANITIZER_INTERCEPT_TLS_GET_OFFSET)\n+extern \"C\" uptr __tls_get_offset(void *arg);\n+extern \"C\" uptr __interceptor___tls_get_offset(void *arg);\n // We need a hidden symbol aliasing the above, so that we can jump\n // directly to it from the assembly below.\n extern \"C\" __attribute__((alias(\"__interceptor___tls_get_addr_internal\"),\n@@ -5400,9 +5408,6 @@ asm(\n   \"br %r3\\n\"\n   \".size __tls_get_offset_wrapper, .-__tls_get_offset_wrapper\\n\"\n );\n-#endif // SANITIZER_S390\n-#else\n-#define INIT_TLS_GET_ADDR\n #endif\n \n #if SANITIZER_INTERCEPT_LISTXATTR\n@@ -6099,6 +6104,40 @@ INTERCEPTOR(__sanitizer_FILE *, freopen, const char *path, const char *mode,\n #define INIT_FOPEN\n #endif\n \n+#if SANITIZER_INTERCEPT_FLOPEN\n+INTERCEPTOR(int, flopen, const char *path, int flags, ...) {\n+  void *ctx;\n+  va_list ap;\n+  va_start(ap, flags);\n+  u16 mode = static_cast<u16>(va_arg(ap, u32));\n+  va_end(ap);\n+  COMMON_INTERCEPTOR_ENTER(ctx, flopen, path, flags, mode);\n+  if (path) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  }\n+  return REAL(flopen)(path, flags, mode);\n+}\n+\n+INTERCEPTOR(int, flopenat, int dirfd, const char *path, int flags, ...) {\n+  void *ctx;\n+  va_list ap;\n+  va_start(ap, flags);\n+  u16 mode = static_cast<u16>(va_arg(ap, u32));\n+  va_end(ap);\n+  COMMON_INTERCEPTOR_ENTER(ctx, flopen, path, flags, mode);\n+  if (path) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  }\n+  return REAL(flopenat)(dirfd, path, flags, mode);\n+}\n+\n+#define INIT_FLOPEN    \\\n+  COMMON_INTERCEPT_FUNCTION(flopen); \\\n+  COMMON_INTERCEPT_FUNCTION(flopenat);\n+#else\n+#define INIT_FLOPEN\n+#endif\n+\n #if SANITIZER_INTERCEPT_FOPEN64\n INTERCEPTOR(__sanitizer_FILE *, fopen64, const char *path, const char *mode) {\n   void *ctx;\n@@ -6463,7 +6502,7 @@ INTERCEPTOR(int, sem_wait, __sanitizer_sem_t *s) {\n INTERCEPTOR(int, sem_trywait, __sanitizer_sem_t *s) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sem_trywait, s);\n-  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_trywait)(s);\n+  int res = REAL(sem_trywait)(s);\n   if (res == 0) {\n     COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n   }\n@@ -10264,6 +10303,7 @@ static void InitializeCommonInterceptors() {\n   INIT_LIBIO_INTERNALS;\n   INIT_FOPEN;\n   INIT_FOPEN64;\n+  INIT_FLOPEN;\n   INIT_OPEN_MEMSTREAM;\n   INIT_OBSTACK;\n   INIT_FFLUSH;"}, {"sha": "01ccacc6f32020ec8682bde4aaacd604efd9dc49", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -138,7 +138,7 @@ uptr ReservedAddressRange::InitAligned(uptr size, uptr align,\n   return start;\n }\n \n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+#if !SANITIZER_FUCHSIA\n \n // Reserve memory range [beg, end].\n // We need to use inclusive range because end+1 may not be representable.\n@@ -189,7 +189,7 @@ void ProtectGap(uptr addr, uptr size, uptr zero_base_shadow_start,\n   Die();\n }\n \n-#endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+#endif  // !SANITIZER_FUCHSIA\n \n }  // namespace __sanitizer\n "}, {"sha": "9a4e5388f24d13de44947f31eb27ee0e06fd2041", "filename": "libsanitizer/sanitizer_common/sanitizer_common_nolibc.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -25,7 +25,6 @@ void LogMessageOnPrintf(const char *str) {}\n #endif\n void WriteToSyslog(const char *buffer) {}\n void Abort() { internal__exit(1); }\n-void SleepForSeconds(int seconds) { internal_sleep(seconds); }\n #endif // !SANITIZER_WINDOWS\n \n #if !SANITIZER_WINDOWS && !SANITIZER_MAC"}, {"sha": "ccb7065b07aed961e367c0ada403fdc5d927d0fd", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector1.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -136,7 +136,7 @@ void DD::ReportDeadlock(DDCallback *cb, DDMutex *m) {\n     DDMutex *m0 = (DDMutex*)dd.getData(from);\n     DDMutex *m1 = (DDMutex*)dd.getData(to);\n \n-    u32 stk_from = -1U, stk_to = -1U;\n+    u32 stk_from = 0, stk_to = 0;\n     int unique_tid = 0;\n     dd.findEdge(from, to, &stk_from, &stk_to, &unique_tid);\n     // Printf(\"Edge: %zd=>%zd: %u/%u T%d\\n\", from, to, stk_from, stk_to,"}, {"sha": "1fbbbcccfa993e867b94f7f925d678e9438fc6ef", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector2.cpp", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -73,7 +73,7 @@ struct DDLogicalThread {\n   int         nlocked;\n };\n \n-struct Mutex {\n+struct MutexState {\n   StaticSpinMutex mtx;\n   u32 seq;\n   int nlink;\n@@ -101,12 +101,12 @@ struct DD final : public DDetector {\n   void CycleCheck(DDPhysicalThread *pt, DDLogicalThread *lt, DDMutex *mtx);\n   void Report(DDPhysicalThread *pt, DDLogicalThread *lt, int npath);\n   u32 allocateId(DDCallback *cb);\n-  Mutex *getMutex(u32 id);\n-  u32 getMutexId(Mutex *m);\n+  MutexState *getMutex(u32 id);\n+  u32 getMutexId(MutexState *m);\n \n   DDFlags flags;\n \n-  Mutex* mutex[kL1Size];\n+  MutexState *mutex[kL1Size];\n \n   SpinMutex mtx;\n   InternalMmapVector<u32> free_id;\n@@ -152,13 +152,11 @@ void DD::MutexInit(DDCallback *cb, DDMutex *m) {\n   atomic_store(&m->owner, 0, memory_order_relaxed);\n }\n \n-Mutex *DD::getMutex(u32 id) {\n-  return &mutex[id / kL2Size][id % kL2Size];\n-}\n+MutexState *DD::getMutex(u32 id) { return &mutex[id / kL2Size][id % kL2Size]; }\n \n-u32 DD::getMutexId(Mutex *m) {\n+u32 DD::getMutexId(MutexState *m) {\n   for (int i = 0; i < kL1Size; i++) {\n-    Mutex *tab = mutex[i];\n+    MutexState *tab = mutex[i];\n     if (tab == 0)\n       break;\n     if (m >= tab && m < tab + kL2Size)\n@@ -176,8 +174,8 @@ u32 DD::allocateId(DDCallback *cb) {\n   } else {\n     CHECK_LT(id_gen, kMaxMutex);\n     if ((id_gen % kL2Size) == 0) {\n-      mutex[id_gen / kL2Size] = (Mutex*)MmapOrDie(kL2Size * sizeof(Mutex),\n-          \"deadlock detector (mutex table)\");\n+      mutex[id_gen / kL2Size] = (MutexState *)MmapOrDie(\n+          kL2Size * sizeof(MutexState), \"deadlock detector (mutex table)\");\n     }\n     id = id_gen++;\n   }\n@@ -216,11 +214,11 @@ void DD::MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock) {\n   }\n \n   bool added = false;\n-  Mutex *mtx = getMutex(m->id);\n+  MutexState *mtx = getMutex(m->id);\n   for (int i = 0; i < lt->nlocked - 1; i++) {\n     u32 id1 = lt->locked[i].id;\n     u32 stk1 = lt->locked[i].stk;\n-    Mutex *mtx1 = getMutex(id1);\n+    MutexState *mtx1 = getMutex(id1);\n     SpinMutexLock l(&mtx1->mtx);\n     if (mtx1->nlink == kMaxLink) {\n       // FIXME(dvyukov): check stale links\n@@ -342,7 +340,7 @@ void DD::MutexDestroy(DDCallback *cb, DDMutex *m) {\n \n   // Clear and invalidate the mutex descriptor.\n   {\n-    Mutex *mtx = getMutex(m->id);\n+    MutexState *mtx = getMutex(m->id);\n     SpinMutexLock l(&mtx->mtx);\n     mtx->seq++;\n     mtx->nlink = 0;\n@@ -361,7 +359,7 @@ void DD::CycleCheck(DDPhysicalThread *pt, DDLogicalThread *lt,\n   int npath = 0;\n   int npending = 0;\n   {\n-    Mutex *mtx = getMutex(m->id);\n+    MutexState *mtx = getMutex(m->id);\n     SpinMutexLock l(&mtx->mtx);\n     for (int li = 0; li < mtx->nlink; li++)\n       pt->pending[npending++] = mtx->link[li];\n@@ -374,7 +372,7 @@ void DD::CycleCheck(DDPhysicalThread *pt, DDLogicalThread *lt,\n     }\n     if (pt->visited[link.id])\n       continue;\n-    Mutex *mtx1 = getMutex(link.id);\n+    MutexState *mtx1 = getMutex(link.id);\n     SpinMutexLock l(&mtx1->mtx);\n     if (mtx1->seq != link.seq)\n       continue;\n@@ -387,7 +385,7 @@ void DD::CycleCheck(DDPhysicalThread *pt, DDLogicalThread *lt,\n       return Report(pt, lt, npath);  // Bingo!\n     for (int li = 0; li < mtx1->nlink; li++) {\n       Link *link1 = &mtx1->link[li];\n-      // Mutex *mtx2 = getMutex(link->id);\n+      // MutexState *mtx2 = getMutex(link->id);\n       // FIXME(dvyukov): fast seq check\n       // FIXME(dvyukov): fast nlink != 0 check\n       // FIXME(dvyukov): fast pending check?"}, {"sha": "70a6e88dbaad457d7f9b647d157a57ed1db9f3e0", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -23,8 +23,7 @@\n \n #if SANITIZER_FREEBSD || SANITIZER_MAC\n #  define __errno_location __error\n-#elif SANITIZER_ANDROID || SANITIZER_NETBSD || \\\n-  SANITIZER_RTEMS\n+#elif SANITIZER_ANDROID || SANITIZER_NETBSD\n #  define __errno_location __errno\n #elif SANITIZER_SOLARIS\n #  define __errno_location ___errno"}, {"sha": "65bc398656c936850f16fe11a6ec33c80e59bdfd", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cpp", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -36,16 +36,11 @@ uptr internal_sched_yield() {\n   return 0;  // Why doesn't this return void?\n }\n \n-static void internal_nanosleep(zx_time_t ns) {\n-  zx_status_t status = _zx_nanosleep(_zx_deadline_after(ns));\n+void internal_usleep(u64 useconds) {\n+  zx_status_t status = _zx_nanosleep(_zx_deadline_after(ZX_USEC(useconds)));\n   CHECK_EQ(status, ZX_OK);\n }\n \n-unsigned int internal_sleep(unsigned int seconds) {\n-  internal_nanosleep(ZX_SEC(seconds));\n-  return 0;\n-}\n-\n u64 NanoTime() {\n   zx_handle_t utc_clock = _zx_utc_reference_get();\n   CHECK_NE(utc_clock, ZX_HANDLE_INVALID);\n@@ -78,10 +73,6 @@ void Abort() { abort(); }\n \n int Atexit(void (*function)(void)) { return atexit(function); }\n \n-void SleepForSeconds(int seconds) { internal_sleep(seconds); }\n-\n-void SleepForMillis(int millis) { internal_nanosleep(ZX_MSEC(millis)); }\n-\n void GetThreadStackTopAndBottom(bool, uptr *stack_top, uptr *stack_bottom) {\n   pthread_attr_t attr;\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n@@ -109,6 +100,18 @@ bool SignalContext::IsStackOverflow() const { return false; }\n void SignalContext::DumpAllRegisters(void *context) { UNIMPLEMENTED(); }\n const char *SignalContext::Describe() const { UNIMPLEMENTED(); }\n \n+void FutexWait(atomic_uint32_t *p, u32 cmp) {\n+  zx_status_t status = _zx_futex_wait(reinterpret_cast<zx_futex_t *>(p), cmp,\n+                                      ZX_HANDLE_INVALID, ZX_TIME_INFINITE);\n+  if (status != ZX_ERR_BAD_STATE)  // Normal race.\n+    CHECK_EQ(status, ZX_OK);\n+}\n+\n+void FutexWake(atomic_uint32_t *p, u32 count) {\n+  zx_status_t status = _zx_futex_wake(reinterpret_cast<zx_futex_t *>(p), count);\n+  CHECK_EQ(status, ZX_OK);\n+}\n+\n enum MutexState : int { MtxUnlocked = 0, MtxLocked = 1, MtxSleeping = 2 };\n \n BlockingMutex::BlockingMutex() {\n@@ -145,8 +148,8 @@ void BlockingMutex::Unlock() {\n   }\n }\n \n-void BlockingMutex::CheckLocked() {\n-  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+void BlockingMutex::CheckLocked() const {\n+  auto m = reinterpret_cast<atomic_uint32_t const *>(&opaque_storage_);\n   CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n }\n \n@@ -156,8 +159,10 @@ uptr GetMmapGranularity() { return _zx_system_get_page_size(); }\n \n sanitizer_shadow_bounds_t ShadowBounds;\n \n+void InitShadowBounds() { ShadowBounds = __sanitizer_shadow_bounds(); }\n+\n uptr GetMaxUserVirtualAddress() {\n-  ShadowBounds = __sanitizer_shadow_bounds();\n+  InitShadowBounds();\n   return ShadowBounds.memory_limit - 1;\n }\n "}, {"sha": "26c1deab9e5fe50e78dfe3d946a0050ff89e0734", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -30,6 +30,8 @@ struct MemoryMappingLayoutData {\n   size_t current;  // Current index into the vector.\n };\n \n+void InitShadowBounds();\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_FUCHSIA"}, {"sha": "bcb81ebbc803edfb1dec1e022e1e114266f58b5e", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -67,7 +67,8 @@ uptr internal_ftruncate(fd_t fd, uptr size);\n \n // OS\n void NORETURN internal__exit(int exitcode);\n-unsigned int internal_sleep(unsigned int seconds);\n+void internal_sleep(unsigned seconds);\n+void internal_usleep(u64 useconds);\n \n uptr internal_getpid();\n uptr internal_getppid();"}, {"sha": "431efc574fa6595ed30a0b1be0d5a27bf32ddbb7", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cpp", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -84,6 +84,7 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n         ignored_code_ranges_[idx].begin = range.beg;\n         ignored_code_ranges_[idx].end = range.end;\n         atomic_store(&ignored_ranges_count_, idx + 1, memory_order_release);\n+        atomic_store(&enabled_, 1, memory_order_release);\n         break;\n       }\n     }\n@@ -114,6 +115,7 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n         instrumented_code_ranges_[idx].end = range.end;\n         atomic_store(&instrumented_ranges_count_, idx + 1,\n                      memory_order_release);\n+        atomic_store(&enabled_, 1, memory_order_release);\n       }\n     }\n   }\n@@ -123,6 +125,29 @@ void LibIgnore::OnLibraryUnloaded() {\n   OnLibraryLoaded(nullptr);\n }\n \n+bool LibIgnore::IsIgnoredSlow(uptr pc, bool *pc_in_ignored_lib) const {\n+  const uptr n = atomic_load(&ignored_ranges_count_, memory_order_acquire);\n+  for (uptr i = 0; i < n; i++) {\n+    if (IsInRange(pc, ignored_code_ranges_[i])) {\n+      *pc_in_ignored_lib = true;\n+      return true;\n+    }\n+  }\n+  *pc_in_ignored_lib = false;\n+  if (track_instrumented_libs_ && !IsPcInstrumented(pc))\n+    return true;\n+  return false;\n+}\n+\n+bool LibIgnore::IsPcInstrumented(uptr pc) const {\n+  const uptr n = atomic_load(&instrumented_ranges_count_, memory_order_acquire);\n+  for (uptr i = 0; i < n; i++) {\n+    if (IsInRange(pc, instrumented_code_ranges_[i]))\n+      return true;\n+  }\n+  return false;\n+}\n+\n } // namespace __sanitizer\n \n #endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC ||"}, {"sha": "85452e57ba3c2d32041d373f4b5a363f21ff6f9c", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.h", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -45,9 +45,6 @@ class LibIgnore {\n   // \"pc_in_ignored_lib\" if the PC is in an ignored library, false otherwise.\n   bool IsIgnored(uptr pc, bool *pc_in_ignored_lib) const;\n \n-  // Checks whether the provided PC belongs to an instrumented module.\n-  bool IsPcInstrumented(uptr pc) const;\n-\n  private:\n   struct Lib {\n     char *templ;\n@@ -61,6 +58,10 @@ class LibIgnore {\n     uptr end;\n   };\n \n+  // Checks whether the provided PC belongs to an instrumented module.\n+  bool IsPcInstrumented(uptr pc) const;\n+  bool IsIgnoredSlow(uptr pc, bool *pc_in_ignored_lib) const;\n+\n   inline bool IsInRange(uptr pc, const LibCodeRange &range) const {\n     return (pc >= range.begin && pc < range.end);\n   }\n@@ -70,6 +71,8 @@ class LibIgnore {\n   static const uptr kMaxLibs = 1024;\n \n   // Hot part:\n+  atomic_uintptr_t enabled_;\n+\n   atomic_uintptr_t ignored_ranges_count_;\n   LibCodeRange ignored_code_ranges_[kMaxIgnoredRanges];\n \n@@ -87,27 +90,11 @@ class LibIgnore {\n   void operator = (const LibIgnore&);  // not implemented\n };\n \n-inline bool LibIgnore::IsIgnored(uptr pc, bool *pc_in_ignored_lib) const {\n-  const uptr n = atomic_load(&ignored_ranges_count_, memory_order_acquire);\n-  for (uptr i = 0; i < n; i++) {\n-    if (IsInRange(pc, ignored_code_ranges_[i])) {\n-      *pc_in_ignored_lib = true;\n-      return true;\n-    }\n-  }\n-  *pc_in_ignored_lib = false;\n-  if (track_instrumented_libs_ && !IsPcInstrumented(pc))\n-    return true;\n-  return false;\n-}\n-\n-inline bool LibIgnore::IsPcInstrumented(uptr pc) const {\n-  const uptr n = atomic_load(&instrumented_ranges_count_, memory_order_acquire);\n-  for (uptr i = 0; i < n; i++) {\n-    if (IsInRange(pc, instrumented_code_ranges_[i]))\n-      return true;\n-  }\n-  return false;\n+ALWAYS_INLINE\n+bool LibIgnore::IsIgnored(uptr pc, bool *pc_in_ignored_lib) const {\n+  if (LIKELY(atomic_load(&enabled_, memory_order_acquire) == 0))\n+    return false;\n+  return IsIgnoredSlow(pc, pc_in_ignored_lib);\n }\n \n }  // namespace __sanitizer"}, {"sha": "9b7d87eb85e1ac7fe945c3373951172bc3037351", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -430,13 +430,11 @@ uptr internal_sched_yield() {\n   return internal_syscall(SYSCALL(sched_yield));\n }\n \n-unsigned int internal_sleep(unsigned int seconds) {\n+void internal_usleep(u64 useconds) {\n   struct timespec ts;\n-  ts.tv_sec = seconds;\n-  ts.tv_nsec = 0;\n-  int res = internal_syscall(SYSCALL(nanosleep), &ts, &ts);\n-  if (res) return ts.tv_sec;\n-  return 0;\n+  ts.tv_sec = useconds / 1000000;\n+  ts.tv_nsec = (useconds % 1000000) * 1000;\n+  internal_syscall(SYSCALL(nanosleep), &ts, &ts);\n }\n \n uptr internal_execve(const char *filename, char *const argv[],\n@@ -641,11 +639,27 @@ char **GetEnviron() {\n }\n \n #if !SANITIZER_SOLARIS\n-enum MutexState {\n-  MtxUnlocked = 0,\n-  MtxLocked = 1,\n-  MtxSleeping = 2\n-};\n+void FutexWait(atomic_uint32_t *p, u32 cmp) {\n+#    if SANITIZER_FREEBSD\n+  _umtx_op(p, UMTX_OP_WAIT_UINT, cmp, 0, 0);\n+#    elif SANITIZER_NETBSD\n+  sched_yield();   /* No userspace futex-like synchronization */\n+#    else\n+  internal_syscall(SYSCALL(futex), (uptr)p, FUTEX_WAIT_PRIVATE, cmp, 0, 0, 0);\n+#    endif\n+}\n+\n+void FutexWake(atomic_uint32_t *p, u32 count) {\n+#    if SANITIZER_FREEBSD\n+  _umtx_op(p, UMTX_OP_WAKE, count, 0, 0);\n+#    elif SANITIZER_NETBSD\n+                   /* No userspace futex-like synchronization */\n+#    else\n+  internal_syscall(SYSCALL(futex), (uptr)p, FUTEX_WAKE_PRIVATE, count, 0, 0, 0);\n+#    endif\n+}\n+\n+enum { MtxUnlocked = 0, MtxLocked = 1, MtxSleeping = 2 };\n \n BlockingMutex::BlockingMutex() {\n   internal_memset(this, 0, sizeof(*this));\n@@ -683,11 +697,11 @@ void BlockingMutex::Unlock() {\n   }\n }\n \n-void BlockingMutex::CheckLocked() {\n-  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+void BlockingMutex::CheckLocked() const {\n+  auto m = reinterpret_cast<atomic_uint32_t const *>(&opaque_storage_);\n   CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n }\n-#endif // !SANITIZER_SOLARIS\n+#  endif  // !SANITIZER_SOLARIS\n \n // ----------------- sanitizer_linux.h\n // The actual size of this structure is specified by d_reclen.\n@@ -884,7 +898,7 @@ void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {\n   __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n   const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);\n   const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);\n-  k_set->sig[idx] &= ~(1 << bit);\n+  k_set->sig[idx] &= ~((uptr)1 << bit);\n }\n \n bool internal_sigismember(__sanitizer_sigset_t *set, int signum) {\n@@ -894,7 +908,7 @@ bool internal_sigismember(__sanitizer_sigset_t *set, int signum) {\n   __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n   const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);\n   const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);\n-  return k_set->sig[idx] & (1 << bit);\n+  return k_set->sig[idx] & ((uptr)1 << bit);\n }\n #elif SANITIZER_FREEBSD\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {"}, {"sha": "7ce9e25da342d8d70312d956a68b137f29326eb8", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -203,7 +203,7 @@ void InitTlsSize() {\n   g_use_dlpi_tls_data =\n       GetLibcVersion(&major, &minor, &patch) && major == 2 && minor >= 25;\n \n-#if defined(__x86_64__) || defined(__powerpc64__)\n+#if defined(__aarch64__) || defined(__x86_64__) || defined(__powerpc64__)\n   void *get_tls_static_info = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n   size_t tls_align;\n   ((void (*)(size_t *, size_t *))get_tls_static_info)(&g_tls_size, &tls_align);\n@@ -317,21 +317,44 @@ struct TlsBlock {\n };\n }  // namespace\n \n+#ifdef __s390__\n+extern \"C\" uptr __tls_get_offset(void *arg);\n+\n+static uptr TlsGetOffset(uptr ti_module, uptr ti_offset) {\n+  // The __tls_get_offset ABI requires %r12 to point to GOT and %r2 to be an\n+  // offset of a struct tls_index inside GOT. We don't possess either of the\n+  // two, so violate the letter of the \"ELF Handling For Thread-Local\n+  // Storage\" document and assume that the implementation just dereferences\n+  // %r2 + %r12.\n+  uptr tls_index[2] = {ti_module, ti_offset};\n+  register uptr r2 asm(\"2\") = 0;\n+  register void *r12 asm(\"12\") = tls_index;\n+  asm(\"basr %%r14, %[__tls_get_offset]\"\n+      : \"+r\"(r2)\n+      : [__tls_get_offset] \"r\"(__tls_get_offset), \"r\"(r12)\n+      : \"memory\", \"cc\", \"0\", \"1\", \"3\", \"4\", \"5\", \"14\");\n+  return r2;\n+}\n+#else\n extern \"C\" void *__tls_get_addr(size_t *);\n+#endif\n \n static int CollectStaticTlsBlocks(struct dl_phdr_info *info, size_t size,\n                                   void *data) {\n   if (!info->dlpi_tls_modid)\n     return 0;\n   uptr begin = (uptr)info->dlpi_tls_data;\n-#ifndef __s390__\n   if (!g_use_dlpi_tls_data) {\n     // Call __tls_get_addr as a fallback. This forces TLS allocation on glibc\n     // and FreeBSD.\n+#ifdef __s390__\n+    begin = (uptr)__builtin_thread_pointer() +\n+            TlsGetOffset(info->dlpi_tls_modid, 0);\n+#else\n     size_t mod_and_off[2] = {info->dlpi_tls_modid, 0};\n     begin = (uptr)__tls_get_addr(mod_and_off);\n-  }\n #endif\n+  }\n   for (unsigned i = 0; i != info->dlpi_phnum; ++i)\n     if (info->dlpi_phdr[i].p_type == PT_TLS) {\n       static_cast<InternalMmapVector<TlsBlock> *>(data)->push_back(\n@@ -427,12 +450,16 @@ static void GetTls(uptr *addr, uptr *size) {\n     *size = 0;\n   }\n #elif SANITIZER_GLIBC && defined(__x86_64__)\n-  // For x86-64, use an O(1) approach which requires precise\n-  // ThreadDescriptorSize. g_tls_size was initialized in InitTlsSize.\n+  // For aarch64 and x86-64, use an O(1) approach which requires relatively\n+  // precise ThreadDescriptorSize. g_tls_size was initialized in InitTlsSize.\n   asm(\"mov %%fs:16,%0\" : \"=r\"(*addr));\n   *size = g_tls_size;\n   *addr -= *size;\n   *addr += ThreadDescriptorSize();\n+#elif SANITIZER_GLIBC && defined(__aarch64__)\n+  *addr = reinterpret_cast<uptr>(__builtin_thread_pointer()) -\n+          ThreadDescriptorSize();\n+  *size = g_tls_size + ThreadDescriptorSize();\n #elif SANITIZER_GLIBC && defined(__powerpc64__)\n   // Workaround for glibc<2.25(?). 2.27 is known to not need this.\n   uptr tp;\n@@ -732,13 +759,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "125ecac8b1287895b2eda5b445ac96e149fa6e31", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -37,7 +37,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -70,15 +70,7 @@ extern \"C\" {\n #include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n #include <malloc/malloc.h>\n-#if defined(__has_builtin) && __has_builtin(__builtin_os_log_format)\n-# include <os/log.h>\n-#else\n-   /* Without support for __builtin_os_log_format, fall back to the older\n-      method.  */\n-# define OS_LOG_DEFAULT 0\n-# define os_log_error(A,B,C) \\\n-  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", (C));\n-#endif\n+#include <os/log.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n@@ -227,9 +219,7 @@ void internal__exit(int exitcode) {\n   _exit(exitcode);\n }\n \n-unsigned int internal_sleep(unsigned int seconds) {\n-  return sleep(seconds);\n-}\n+void internal_usleep(u64 useconds) { usleep(useconds); }\n \n uptr internal_getpid() {\n   return getpid();\n@@ -519,6 +509,13 @@ void MprotectMallocZones(void *addr, int prot) {\n   }\n }\n \n+void FutexWait(atomic_uint32_t *p, u32 cmp) {\n+  // FIXME: implement actual blocking.\n+  sched_yield();\n+}\n+\n+void FutexWake(atomic_uint32_t *p, u32 count) {}\n+\n BlockingMutex::BlockingMutex() {\n   internal_memset(this, 0, sizeof(*this));\n }\n@@ -534,7 +531,7 @@ void BlockingMutex::Unlock() {\n   OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n }\n \n-void BlockingMutex::CheckLocked() {\n+void BlockingMutex::CheckLocked() const {\n   CHECK_NE(*(OSSpinLock*)&opaque_storage_, 0);\n }\n "}, {"sha": "0b6af5a3c0edc649c4d65dfd1a6ca1bce13aa9b9", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -14,26 +14,6 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n-\n-/* TARGET_OS_OSX is not present in SDKs before Darwin16 (macOS 10.12) use\n-   TARGET_OS_MAC (we have no support for iOS in any form for these versions,\n-   so there's no ambiguity).  */\n-#if !defined(TARGET_OS_OSX) && TARGET_OS_MAC\n-# define TARGET_OS_OSX 1\n-#endif\n-\n-/* Other TARGET_OS_xxx are not present on earlier versions, define them to\n-   0 (we have no support for them; they are not valid targets anyway).  */\n-#ifndef TARGET_OS_IOS\n-#define TARGET_OS_IOS 0\n-#endif\n-#ifndef TARGET_OS_TV\n-#define TARGET_OS_TV 0\n-#endif\n-#ifndef TARGET_OS_WATCH\n-#define TARGET_OS_WATCH 0\n-#endif\n-\n #if SANITIZER_MAC\n #include \"sanitizer_posix.h\"\n "}, {"sha": "bc2d83c42c1a371a460adc3b3744eb66c7313f08", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.cpp", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -0,0 +1,39 @@\n+//===-- sanitizer_mutex.cpp -----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_mutex.h\"\n+\n+#include \"sanitizer_common.h\"\n+\n+namespace __sanitizer {\n+\n+void Semaphore::Wait() {\n+  u32 count = atomic_load(&state_, memory_order_relaxed);\n+  for (;;) {\n+    if (count == 0) {\n+      FutexWait(&state_, 0);\n+      count = atomic_load(&state_, memory_order_relaxed);\n+      continue;\n+    }\n+    if (atomic_compare_exchange_weak(&state_, &count, count - 1,\n+                                     memory_order_acquire))\n+      break;\n+  }\n+}\n+\n+void Semaphore::Post(u32 count) {\n+  CHECK_NE(count, 0);\n+  atomic_fetch_add(&state_, count, memory_order_release);\n+  FutexWake(&state_, count);\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "e3ff650b2c5924f0b39479a930f0c46ca834cd41", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 232, "deletions": 40, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -16,30 +16,29 @@\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_thread_safety.h\"\n \n namespace __sanitizer {\n \n-class StaticSpinMutex {\n+class MUTEX StaticSpinMutex {\n  public:\n   void Init() {\n     atomic_store(&state_, 0, memory_order_relaxed);\n   }\n \n-  void Lock() {\n+  void Lock() ACQUIRE() {\n     if (TryLock())\n       return;\n     LockSlow();\n   }\n \n-  bool TryLock() {\n+  bool TryLock() TRY_ACQUIRE(true) {\n     return atomic_exchange(&state_, 1, memory_order_acquire) == 0;\n   }\n \n-  void Unlock() {\n-    atomic_store(&state_, 0, memory_order_release);\n-  }\n+  void Unlock() RELEASE() { atomic_store(&state_, 0, memory_order_release); }\n \n-  void CheckLocked() {\n+  void CheckLocked() const CHECK_LOCKED() {\n     CHECK_EQ(atomic_load(&state_, memory_order_relaxed), 1);\n   }\n \n@@ -59,24 +58,223 @@ class StaticSpinMutex {\n   }\n };\n \n-class SpinMutex : public StaticSpinMutex {\n+class MUTEX SpinMutex : public StaticSpinMutex {\n  public:\n   SpinMutex() {\n     Init();\n   }\n \n  private:\n-  SpinMutex(const SpinMutex&);\n-  void operator=(const SpinMutex&);\n+  SpinMutex(const SpinMutex &) = delete;\n+  void operator=(const SpinMutex &) = delete;\n+};\n+\n+// Semaphore provides an OS-dependent way to park/unpark threads.\n+// The last thread returned from Wait can destroy the object\n+// (destruction-safety).\n+class Semaphore {\n+ public:\n+  constexpr Semaphore() {}\n+  Semaphore(const Semaphore &) = delete;\n+  void operator=(const Semaphore &) = delete;\n+\n+  void Wait();\n+  void Post(u32 count = 1);\n+\n+ private:\n+  atomic_uint32_t state_ = {0};\n+};\n+\n+// Reader-writer mutex.\n+class MUTEX Mutex2 {\n+ public:\n+  constexpr Mutex2() {}\n+\n+  void Lock() ACQUIRE() {\n+    u64 reset_mask = ~0ull;\n+    u64 state = atomic_load_relaxed(&state_);\n+    const uptr kMaxSpinIters = 1500;\n+    for (uptr spin_iters = 0;; spin_iters++) {\n+      u64 new_state;\n+      bool locked = (state & (kWriterLock | kReaderLockMask)) != 0;\n+      if (LIKELY(!locked)) {\n+        // The mutex is not read-/write-locked, try to lock.\n+        new_state = (state | kWriterLock) & reset_mask;\n+      } else if (spin_iters > kMaxSpinIters) {\n+        // We've spun enough, increment waiting writers count and block.\n+        // The counter will be decremented by whoever wakes us.\n+        new_state = (state + kWaitingWriterInc) & reset_mask;\n+      } else if ((state & kWriterSpinWait) == 0) {\n+        // Active spinning, but denote our presence so that unlocking\n+        // thread does not wake up other threads.\n+        new_state = state | kWriterSpinWait;\n+      } else {\n+        // Active spinning.\n+        state = atomic_load(&state_, memory_order_relaxed);\n+        continue;\n+      }\n+      if (UNLIKELY(!atomic_compare_exchange_weak(&state_, &state, new_state,\n+                                                 memory_order_acquire)))\n+        continue;\n+      if (LIKELY(!locked))\n+        return;  // We've locked the mutex.\n+      if (spin_iters > kMaxSpinIters) {\n+        // We've incremented waiting writers, so now block.\n+        writers_.Wait();\n+        spin_iters = 0;\n+        state = atomic_load(&state_, memory_order_relaxed);\n+        DCHECK_NE(state & kWriterSpinWait, 0);\n+      } else {\n+        // We've set kWriterSpinWait, but we are still in active spinning.\n+      }\n+      // We either blocked and were unblocked,\n+      // or we just spun but set kWriterSpinWait.\n+      // Either way we need to reset kWriterSpinWait\n+      // next time we take the lock or block again.\n+      reset_mask = ~kWriterSpinWait;\n+    }\n+  }\n+\n+  void Unlock() RELEASE() {\n+    bool wake_writer;\n+    u64 wake_readers;\n+    u64 new_state;\n+    u64 state = atomic_load_relaxed(&state_);\n+    do {\n+      DCHECK_NE(state & kWriterLock, 0);\n+      DCHECK_EQ(state & kReaderLockMask, 0);\n+      new_state = state & ~kWriterLock;\n+      wake_writer =\n+          (state & kWriterSpinWait) == 0 && (state & kWaitingWriterMask) != 0;\n+      if (wake_writer)\n+        new_state = (new_state - kWaitingWriterInc) | kWriterSpinWait;\n+      wake_readers =\n+          (state & (kWriterSpinWait | kWaitingWriterMask)) != 0\n+              ? 0\n+              : ((state & kWaitingReaderMask) >> kWaitingReaderShift);\n+      if (wake_readers)\n+        new_state = (new_state & ~kWaitingReaderMask) +\n+                    (wake_readers << kReaderLockShift);\n+    } while (UNLIKELY(!atomic_compare_exchange_weak(&state_, &state, new_state,\n+                                                    memory_order_release)));\n+    if (UNLIKELY(wake_writer))\n+      writers_.Post();\n+    else if (UNLIKELY(wake_readers))\n+      readers_.Post(wake_readers);\n+  }\n+\n+  void ReadLock() ACQUIRE_SHARED() {\n+    bool locked;\n+    u64 new_state;\n+    u64 state = atomic_load_relaxed(&state_);\n+    do {\n+      locked =\n+          (state & kReaderLockMask) == 0 &&\n+          (state & (kWriterLock | kWriterSpinWait | kWaitingWriterMask)) != 0;\n+      if (LIKELY(!locked))\n+        new_state = state + kReaderLockInc;\n+      else\n+        new_state = state + kWaitingReaderInc;\n+    } while (UNLIKELY(!atomic_compare_exchange_weak(&state_, &state, new_state,\n+                                                    memory_order_acquire)));\n+    if (UNLIKELY(locked))\n+      readers_.Wait();\n+    DCHECK_EQ(atomic_load_relaxed(&state_) & kWriterLock, 0);\n+    DCHECK_NE(atomic_load_relaxed(&state_) & kReaderLockMask, 0);\n+  }\n+\n+  void ReadUnlock() RELEASE_SHARED() {\n+    bool wake;\n+    u64 new_state;\n+    u64 state = atomic_load_relaxed(&state_);\n+    do {\n+      DCHECK_NE(state & kReaderLockMask, 0);\n+      DCHECK_EQ(state & (kWaitingReaderMask | kWriterLock), 0);\n+      new_state = state - kReaderLockInc;\n+      wake = (new_state & (kReaderLockMask | kWriterSpinWait)) == 0 &&\n+             (new_state & kWaitingWriterMask) != 0;\n+      if (wake)\n+        new_state = (new_state - kWaitingWriterInc) | kWriterSpinWait;\n+    } while (UNLIKELY(!atomic_compare_exchange_weak(&state_, &state, new_state,\n+                                                    memory_order_release)));\n+    if (UNLIKELY(wake))\n+      writers_.Post();\n+  }\n+\n+  // This function does not guarantee an explicit check that the calling thread\n+  // is the thread which owns the mutex. This behavior, while more strictly\n+  // correct, causes problems in cases like StopTheWorld, where a parent thread\n+  // owns the mutex but a child checks that it is locked. Rather than\n+  // maintaining complex state to work around those situations, the check only\n+  // checks that the mutex is owned.\n+  void CheckWriteLocked() const CHECK_LOCKED() {\n+    CHECK(atomic_load(&state_, memory_order_relaxed) & kWriterLock);\n+  }\n+\n+  void CheckLocked() const CHECK_LOCKED() { CheckWriteLocked(); }\n+\n+  void CheckReadLocked() const CHECK_LOCKED() {\n+    CHECK(atomic_load(&state_, memory_order_relaxed) & kReaderLockMask);\n+  }\n+\n+ private:\n+  atomic_uint64_t state_ = {0};\n+  Semaphore writers_;\n+  Semaphore readers_;\n+\n+  // The state has 3 counters:\n+  //  - number of readers holding the lock,\n+  //    if non zero, the mutex is read-locked\n+  //  - number of waiting readers,\n+  //    if not zero, the mutex is write-locked\n+  //  - number of waiting writers,\n+  //    if non zero, the mutex is read- or write-locked\n+  // And 2 flags:\n+  //  - writer lock\n+  //    if set, the mutex is write-locked\n+  //  - a writer is awake and spin-waiting\n+  //    the flag is used to prevent thundering herd problem\n+  //    (new writers are not woken if this flag is set)\n+  //\n+  // Writer support active spinning, readers does not.\n+  // But readers are more aggressive and always take the mutex\n+  // if there are any other readers.\n+  // Writers hand off the mutex to readers: after wake up readers\n+  // already assume ownership of the mutex (don't need to do any\n+  // state updates). But the mutex is not handed off to writers,\n+  // after wake up writers compete to lock the mutex again.\n+  // This is needed to allow repeated write locks even in presence\n+  // of other blocked writers.\n+  static constexpr u64 kCounterWidth = 20;\n+  static constexpr u64 kReaderLockShift = 0;\n+  static constexpr u64 kReaderLockInc = 1ull << kReaderLockShift;\n+  static constexpr u64 kReaderLockMask = ((1ull << kCounterWidth) - 1)\n+                                         << kReaderLockShift;\n+  static constexpr u64 kWaitingReaderShift = kCounterWidth;\n+  static constexpr u64 kWaitingReaderInc = 1ull << kWaitingReaderShift;\n+  static constexpr u64 kWaitingReaderMask = ((1ull << kCounterWidth) - 1)\n+                                            << kWaitingReaderShift;\n+  static constexpr u64 kWaitingWriterShift = 2 * kCounterWidth;\n+  static constexpr u64 kWaitingWriterInc = 1ull << kWaitingWriterShift;\n+  static constexpr u64 kWaitingWriterMask = ((1ull << kCounterWidth) - 1)\n+                                            << kWaitingWriterShift;\n+  static constexpr u64 kWriterLock = 1ull << (3 * kCounterWidth);\n+  static constexpr u64 kWriterSpinWait = 1ull << (3 * kCounterWidth + 1);\n+\n+  Mutex2(const Mutex2 &) = delete;\n+  void operator=(const Mutex2 &) = delete;\n };\n \n-class BlockingMutex {\n+void FutexWait(atomic_uint32_t *p, u32 cmp);\n+void FutexWake(atomic_uint32_t *p, u32 count);\n+\n+class MUTEX BlockingMutex {\n  public:\n   explicit constexpr BlockingMutex(LinkerInitialized)\n       : opaque_storage_ {0, }, owner_ {0} {}\n   BlockingMutex();\n-  void Lock();\n-  void Unlock();\n+  void Lock() ACQUIRE();\n+  void Unlock() RELEASE();\n \n   // This function does not guarantee an explicit check that the calling thread\n   // is the thread which owns the mutex. This behavior, while more strictly\n@@ -85,7 +283,7 @@ class BlockingMutex {\n   // maintaining complex state to work around those situations, the check only\n   // checks that the mutex is owned, and assumes callers to be generally\n   // well-behaved.\n-  void CheckLocked();\n+  void CheckLocked() const CHECK_LOCKED();\n \n  private:\n   // Solaris mutex_t has a member that requires 64-bit alignment.\n@@ -94,7 +292,7 @@ class BlockingMutex {\n };\n \n // Reader-writer spin mutex.\n-class RWMutex {\n+class MUTEX RWMutex {\n  public:\n   RWMutex() {\n     atomic_store(&state_, kUnlocked, memory_order_relaxed);\n@@ -104,35 +302,35 @@ class RWMutex {\n     CHECK_EQ(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n   }\n \n-  void Lock() {\n+  void Lock() ACQUIRE() {\n     u32 cmp = kUnlocked;\n     if (atomic_compare_exchange_strong(&state_, &cmp, kWriteLock,\n                                        memory_order_acquire))\n       return;\n     LockSlow();\n   }\n \n-  void Unlock() {\n+  void Unlock() RELEASE() {\n     u32 prev = atomic_fetch_sub(&state_, kWriteLock, memory_order_release);\n     DCHECK_NE(prev & kWriteLock, 0);\n     (void)prev;\n   }\n \n-  void ReadLock() {\n+  void ReadLock() ACQUIRE_SHARED() {\n     u32 prev = atomic_fetch_add(&state_, kReadLock, memory_order_acquire);\n     if ((prev & kWriteLock) == 0)\n       return;\n     ReadLockSlow();\n   }\n \n-  void ReadUnlock() {\n+  void ReadUnlock() RELEASE_SHARED() {\n     u32 prev = atomic_fetch_sub(&state_, kReadLock, memory_order_release);\n     DCHECK_EQ(prev & kWriteLock, 0);\n     DCHECK_GT(prev & ~kWriteLock, 0);\n     (void)prev;\n   }\n \n-  void CheckLocked() {\n+  void CheckLocked() const CHECK_LOCKED() {\n     CHECK_NE(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n   }\n \n@@ -171,46 +369,40 @@ class RWMutex {\n     }\n   }\n \n-  RWMutex(const RWMutex&);\n-  void operator = (const RWMutex&);\n+  RWMutex(const RWMutex &) = delete;\n+  void operator=(const RWMutex &) = delete;\n };\n \n-template<typename MutexType>\n-class GenericScopedLock {\n+template <typename MutexType>\n+class SCOPED_LOCK GenericScopedLock {\n  public:\n-  explicit GenericScopedLock(MutexType *mu)\n-      : mu_(mu) {\n+  explicit GenericScopedLock(MutexType *mu) ACQUIRE(mu) : mu_(mu) {\n     mu_->Lock();\n   }\n \n-  ~GenericScopedLock() {\n-    mu_->Unlock();\n-  }\n+  ~GenericScopedLock() RELEASE() { mu_->Unlock(); }\n \n  private:\n   MutexType *mu_;\n \n-  GenericScopedLock(const GenericScopedLock&);\n-  void operator=(const GenericScopedLock&);\n+  GenericScopedLock(const GenericScopedLock &) = delete;\n+  void operator=(const GenericScopedLock &) = delete;\n };\n \n-template<typename MutexType>\n-class GenericScopedReadLock {\n+template <typename MutexType>\n+class SCOPED_LOCK GenericScopedReadLock {\n  public:\n-  explicit GenericScopedReadLock(MutexType *mu)\n-      : mu_(mu) {\n+  explicit GenericScopedReadLock(MutexType *mu) ACQUIRE(mu) : mu_(mu) {\n     mu_->ReadLock();\n   }\n \n-  ~GenericScopedReadLock() {\n-    mu_->ReadUnlock();\n-  }\n+  ~GenericScopedReadLock() RELEASE() { mu_->ReadUnlock(); }\n \n  private:\n   MutexType *mu_;\n \n-  GenericScopedReadLock(const GenericScopedReadLock&);\n-  void operator=(const GenericScopedReadLock&);\n+  GenericScopedReadLock(const GenericScopedReadLock &) = delete;\n+  void operator=(const GenericScopedReadLock &) = delete;\n };\n \n typedef GenericScopedLock<StaticSpinMutex> SpinMutexLock;"}, {"sha": "5e601bdcde1e565160b5706165235034202c0825", "filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cpp", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -215,15 +215,12 @@ void internal__exit(int exitcode) {\n   Die();  // Unreachable.\n }\n \n-unsigned int internal_sleep(unsigned int seconds) {\n+void internal_usleep(u64 useconds) {\n   struct timespec ts;\n-  ts.tv_sec = seconds;\n-  ts.tv_nsec = 0;\n+  ts.tv_sec = useconds / 1000000;\n+  ts.tv_nsec = (useconds % 1000000) * 1000;\n   CHECK(&_sys___nanosleep50);\n-  int res = _sys___nanosleep50(&ts, &ts);\n-  if (res)\n-    return ts.tv_sec;\n-  return 0;\n+  _sys___nanosleep50(&ts, &ts);\n }\n \n uptr internal_execve(const char *filename, char *const argv[],"}, {"sha": "4d3c08893c11c11f59a6461fafe16d5fa4a4a78b", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -13,10 +13,9 @@\n #define SANITIZER_PLATFORM_H\n \n #if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && \\\n-  !defined(__APPLE__) && !defined(_WIN32) && \\\n-  !defined(__Fuchsia__) && !defined(__rtems__) && \\\n-  !(defined(__sun__) && defined(__svr4__))\n-# error \"This operating system is not supported\"\n+    !defined(__APPLE__) && !defined(_WIN32) && !defined(__Fuchsia__) &&     \\\n+    !(defined(__sun__) && defined(__svr4__))\n+#  error \"This operating system is not supported\"\n #endif\n \n // Get __GLIBC__ on a glibc platform. Exclude Android: features.h includes C\n@@ -117,12 +116,6 @@\n # define SANITIZER_FUCHSIA 0\n #endif\n \n-#if defined(__rtems__)\n-# define SANITIZER_RTEMS 1\n-#else\n-# define SANITIZER_RTEMS 0\n-#endif\n-\n #define SANITIZER_POSIX \\\n   (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || \\\n     SANITIZER_NETBSD || SANITIZER_SOLARIS)\n@@ -226,12 +219,6 @@\n # define SANITIZER_SOLARIS32 0\n #endif\n \n-#if defined(__myriad2__)\n-# define SANITIZER_MYRIAD2 1\n-#else\n-# define SANITIZER_MYRIAD2 0\n-#endif\n-\n #if defined(__riscv) && (__riscv_xlen == 64)\n #define SANITIZER_RISCV64 1\n #else\n@@ -374,9 +361,9 @@\n # define SANITIZER_CACHE_LINE_SIZE 64\n #endif\n \n-// Enable offline markup symbolizer for Fuchsia and RTEMS.\n-#if SANITIZER_FUCHSIA || SANITIZER_RTEMS\n-#define SANITIZER_SYMBOLIZER_MARKUP 1\n+// Enable offline markup symbolizer for Fuchsia.\n+#if SANITIZER_FUCHSIA\n+#  define SANITIZER_SYMBOLIZER_MARKUP 1\n #else\n #define SANITIZER_SYMBOLIZER_MARKUP 0\n #endif"}, {"sha": "5b710c23fd0048fe1a10d8bbd83d45be66d22f18", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -114,12 +114,6 @@\n #define SI_NOT_FUCHSIA 1\n #endif\n \n-#if SANITIZER_RTEMS\n-#define SI_NOT_RTEMS 0\n-#else\n-#define SI_NOT_RTEMS 1\n-#endif\n-\n #if SANITIZER_SOLARIS\n #define SI_SOLARIS 1\n #else\n@@ -482,13 +476,12 @@\n #define SANITIZER_INTERCEPT_MMAP SI_POSIX\n #define SANITIZER_INTERCEPT_MMAP64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO (SI_GLIBC || SI_ANDROID)\n-#define SANITIZER_INTERCEPT_MEMALIGN \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_RTEMS)\n+#define SANITIZER_INTERCEPT_MEMALIGN (!SI_FREEBSD && !SI_MAC && !SI_NETBSD)\n #define SANITIZER_INTERCEPT___LIBC_MEMALIGN SI_GLIBC\n #define SANITIZER_INTERCEPT_PVALLOC (SI_GLIBC || SI_ANDROID)\n #define SANITIZER_INTERCEPT_CFREE (SI_GLIBC && !SANITIZER_RISCV64)\n #define SANITIZER_INTERCEPT_REALLOCARRAY SI_POSIX\n-#define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC && SI_NOT_RTEMS)\n+#define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC)\n #define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_MCHECK_MPROBE SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WCSCAT SI_POSIX\n@@ -584,6 +577,7 @@\n   (SI_POSIX && !(SANITIZER_MAC && SANITIZER_I386))\n #define SANITIZER_INTERCEPT_UNAME (SI_POSIX && !SI_FREEBSD)\n #define SANITIZER_INTERCEPT___XUNAME SI_FREEBSD\n+#define SANITIZER_INTERCEPT_FLOPEN SI_FREEBSD\n \n // This macro gives a way for downstream users to override the above\n // interceptor macros irrespective of the platform they are on. They have"}, {"sha": "c51327e1269e081cb0e231b75cbce71b62601e88", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -26,12 +26,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t"}, {"sha": "4dd27644ed1161986fbac4b35a968a0a1218fe6a", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -83,7 +83,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                            ? FIRST_32_SECOND_64(104, 128)\n-                                           : FIRST_32_SECOND_64(144, 216);\n+                                           : FIRST_32_SECOND_64(160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;\n@@ -650,14 +650,14 @@ struct __sanitizer_sigaction {\n #endif // !SANITIZER_ANDROID\n \n #if defined(__mips__)\n-struct __sanitizer_kernel_sigset_t {\n-  uptr sig[2];\n-};\n+#define __SANITIZER_KERNEL_NSIG 128\n #else\n+#define __SANITIZER_KERNEL_NSIG 64\n+#endif\n+\n struct __sanitizer_kernel_sigset_t {\n-  u8 sig[8];\n+  uptr sig[__SANITIZER_KERNEL_NSIG / (sizeof(uptr) * 8)];\n };\n-#endif\n \n // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n #if SANITIZER_MIPS"}, {"sha": "ddf6844bed13efeb3f7f87aee664b6b96682a8f6", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -128,14 +128,6 @@ void SetAddressSpaceUnlimited() {\n   CHECK(AddressSpaceIsUnlimited());\n }\n \n-void SleepForSeconds(int seconds) {\n-  sleep(seconds);\n-}\n-\n-void SleepForMillis(int millis) {\n-  usleep(millis * 1000);\n-}\n-\n void Abort() {\n #if !SANITIZER_GO\n   // If we are handling SIGABRT, unhandle it first.\n@@ -166,9 +158,10 @@ bool SupportsColoredOutput(fd_t fd) {\n #if !SANITIZER_GO\n // TODO(glider): different tools may require different altstack size.\n static uptr GetAltStackSize() {\n-  // SIGSTKSZ is not enough.\n-  static const uptr kAltStackSize = SIGSTKSZ * 4;\n-  return kAltStackSize;\n+  // Note: since GLIBC_2.31, SIGSTKSZ may be a function call, so this may be\n+  // more costly that you think. However GetAltStackSize is only call 2-3 times\n+  // per thread so don't cache the evaluation.\n+  return SIGSTKSZ * 4;\n }\n \n void SetAlternateSignalStack() {"}, {"sha": "b913c92e16f10dccbe1de7a79c42e3164a54174c", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cpp", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -20,6 +20,10 @@\n #include <stdio.h>\n #include <stdarg.h>\n \n+#if defined(__x86_64__)\n+#  include <emmintrin.h>\n+#endif\n+\n #if SANITIZER_WINDOWS && defined(_MSC_VER) && _MSC_VER < 1800 &&               \\\n       !defined(va_copy)\n # define va_copy(dst, src) ((dst) = (src))\n@@ -128,7 +132,7 @@ static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {\n int VSNPrintf(char *buff, int buff_length,\n               const char *format, va_list args) {\n   static const char *kPrintfFormatsHelp =\n-      \"Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x,X}; %p; \"\n+      \"Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x,X,V}; %p; \"\n       \"%[-]([0-9]*)?(\\\\.\\\\*)?s; %c\\n\";\n   RAW_CHECK(format);\n   RAW_CHECK(buff_length > 0);\n@@ -162,32 +166,37 @@ int VSNPrintf(char *buff, int buff_length,\n     cur += have_z;\n     bool have_ll = !have_z && (cur[0] == 'l' && cur[1] == 'l');\n     cur += have_ll * 2;\n-    s64 dval;\n-    u64 uval;\n     const bool have_length = have_z || have_ll;\n     const bool have_flags = have_width || have_length;\n     // At the moment only %s supports precision and left-justification.\n     CHECK(!((precision >= 0 || left_justified) && *cur != 's'));\n     switch (*cur) {\n       case 'd': {\n-        dval = have_ll ? va_arg(args, s64)\n-             : have_z ? va_arg(args, sptr)\n-             : va_arg(args, int);\n+        s64 dval = have_ll  ? va_arg(args, s64)\n+                   : have_z ? va_arg(args, sptr)\n+                            : va_arg(args, int);\n         result += AppendSignedDecimal(&buff, buff_end, dval, width,\n                                       pad_with_zero);\n         break;\n       }\n       case 'u':\n       case 'x':\n       case 'X': {\n-        uval = have_ll ? va_arg(args, u64)\n-             : have_z ? va_arg(args, uptr)\n-             : va_arg(args, unsigned);\n+        u64 uval = have_ll  ? va_arg(args, u64)\n+                   : have_z ? va_arg(args, uptr)\n+                            : va_arg(args, unsigned);\n         bool uppercase = (*cur == 'X');\n         result += AppendUnsigned(&buff, buff_end, uval, (*cur == 'u') ? 10 : 16,\n                                  width, pad_with_zero, uppercase);\n         break;\n       }\n+      case 'V': {\n+        for (uptr i = 0; i < 16; i++) {\n+          unsigned x = va_arg(args, unsigned);\n+          result += AppendUnsigned(&buff, buff_end, x, 16, 2, true, false);\n+        }\n+        break;\n+      }\n       case 'p': {\n         RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);\n         result += AppendPointer(&buff, buff_end, va_arg(args, uptr));"}, {"sha": "1a074d2bb700cdcf82d1806cafa6be0565c0f451", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -149,7 +149,8 @@ class Quarantine {\n   Cache cache_;\n   char pad2_[kCacheLineSize];\n \n-  void NOINLINE Recycle(uptr min_size, Callback cb) {\n+  void NOINLINE Recycle(uptr min_size, Callback cb) REQUIRES(recycle_mutex_)\n+      RELEASE(recycle_mutex_) {\n     Cache tmp;\n     {\n       SpinMutexLock l(&cache_mutex_);"}, {"sha": "d58bd08fb1a899ea5652eda39a6fdbb6f29c8ce8", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.cpp", "status": "removed", "additions": 0, "deletions": 281, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,281 +0,0 @@\n-//===-- sanitizer_rtems.cpp -----------------------------------------------===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is shared between various sanitizers' runtime libraries and\n-// implements RTEMS-specific functions.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_rtems.h\"\n-#if SANITIZER_RTEMS\n-\n-#define posix_memalign __real_posix_memalign\n-#define free __real_free\n-#define memset __real_memset\n-\n-#include \"sanitizer_file.h\"\n-#include \"sanitizer_symbolizer.h\"\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <pthread.h>\n-#include <sched.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <unistd.h>\n-\n-// There is no mmap on RTEMS.  Use memalign, etc.\n-#define __mmap_alloc_aligned posix_memalign\n-#define __mmap_free free\n-#define __mmap_memset memset\n-\n-namespace __sanitizer {\n-\n-#include \"sanitizer_syscall_generic.inc\"\n-\n-void NORETURN internal__exit(int exitcode) {\n-  _exit(exitcode);\n-}\n-\n-uptr internal_sched_yield() {\n-  return sched_yield();\n-}\n-\n-uptr internal_getpid() {\n-  return getpid();\n-}\n-\n-int internal_dlinfo(void *handle, int request, void *p) {\n-  UNIMPLEMENTED();\n-}\n-\n-bool FileExists(const char *filename) {\n-  struct stat st;\n-  if (stat(filename, &st))\n-    return false;\n-  // Sanity check: filename is a regular file.\n-  return S_ISREG(st.st_mode);\n-}\n-\n-uptr GetThreadSelf() { return static_cast<uptr>(pthread_self()); }\n-\n-tid_t GetTid() { return GetThreadSelf(); }\n-\n-void Abort() { abort(); }\n-\n-int Atexit(void (*function)(void)) { return atexit(function); }\n-\n-void SleepForSeconds(int seconds) { sleep(seconds); }\n-\n-void SleepForMillis(int millis) { usleep(millis * 1000); }\n-\n-bool SupportsColoredOutput(fd_t fd) { return false; }\n-\n-void GetThreadStackTopAndBottom(bool at_initialization,\n-                                uptr *stack_top, uptr *stack_bottom) {\n-  pthread_attr_t attr;\n-  pthread_attr_init(&attr);\n-  CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n-  void *base = nullptr;\n-  size_t size = 0;\n-  CHECK_EQ(pthread_attr_getstack(&attr, &base, &size), 0);\n-  CHECK_EQ(pthread_attr_destroy(&attr), 0);\n-\n-  *stack_bottom = reinterpret_cast<uptr>(base);\n-  *stack_top = *stack_bottom + size;\n-}\n-\n-void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n-                          uptr *tls_addr, uptr *tls_size) {\n-  uptr stack_top, stack_bottom;\n-  GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n-  *stk_addr = stack_bottom;\n-  *stk_size = stack_top - stack_bottom;\n-  *tls_addr = *tls_size = 0;\n-}\n-\n-void InitializePlatformEarly() {}\n-void MaybeReexec() {}\n-void CheckASLR() {}\n-void CheckMPROTECT() {}\n-void DisableCoreDumperIfNecessary() {}\n-void InstallDeadlySignalHandlers(SignalHandlerType handler) {}\n-void SetAlternateSignalStack() {}\n-void UnsetAlternateSignalStack() {}\n-void InitTlsSize() {}\n-\n-void SignalContext::DumpAllRegisters(void *context) {}\n-const char *DescribeSignalOrException(int signo) { UNIMPLEMENTED(); }\n-\n-enum MutexState { MtxUnlocked = 0, MtxLocked = 1, MtxSleeping = 2 };\n-\n-BlockingMutex::BlockingMutex() {\n-  internal_memset(this, 0, sizeof(*this));\n-}\n-\n-void BlockingMutex::Lock() {\n-  CHECK_EQ(owner_, 0);\n-  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n-  if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n-    return;\n-  while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked) {\n-    internal_sched_yield();\n-  }\n-}\n-\n-void BlockingMutex::Unlock() {\n-  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n-  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_release);\n-  CHECK_NE(v, MtxUnlocked);\n-}\n-\n-void BlockingMutex::CheckLocked() {\n-  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n-  CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n-}\n-\n-uptr GetPageSize() { return getpagesize(); }\n-\n-uptr GetMmapGranularity() { return GetPageSize(); }\n-\n-uptr GetMaxVirtualAddress() {\n-  return (1ULL << 32) - 1;  // 0xffffffff\n-}\n-\n-void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n-  void* ptr = 0;\n-  int res = __mmap_alloc_aligned(&ptr, GetPageSize(), size);\n-  if (UNLIKELY(res))\n-    ReportMmapFailureAndDie(size, mem_type, \"allocate\", res, raw_report);\n-  __mmap_memset(ptr, 0, size);\n-  IncreaseTotalMmap(size);\n-  return ptr;\n-}\n-\n-void *MmapOrDieOnFatalError(uptr size, const char *mem_type) {\n-  void* ptr = 0;\n-  int res = __mmap_alloc_aligned(&ptr, GetPageSize(), size);\n-  if (UNLIKELY(res)) {\n-    if (res == ENOMEM)\n-      return nullptr;\n-    ReportMmapFailureAndDie(size, mem_type, \"allocate\", false);\n-  }\n-  __mmap_memset(ptr, 0, size);\n-  IncreaseTotalMmap(size);\n-  return ptr;\n-}\n-\n-void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n-                                   const char *mem_type) {\n-  CHECK(IsPowerOfTwo(size));\n-  CHECK(IsPowerOfTwo(alignment));\n-  void* ptr = 0;\n-  int res = __mmap_alloc_aligned(&ptr, alignment, size);\n-  if (res)\n-    ReportMmapFailureAndDie(size, mem_type, \"align allocate\", res, false);\n-  __mmap_memset(ptr, 0, size);\n-  IncreaseTotalMmap(size);\n-  return ptr;\n-}\n-\n-void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n-  return MmapOrDie(size, mem_type, false);\n-}\n-\n-void UnmapOrDie(void *addr, uptr size) {\n-  if (!addr || !size) return;\n-  __mmap_free(addr);\n-  DecreaseTotalMmap(size);\n-}\n-\n-fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {\n-  int flags;\n-  switch (mode) {\n-    case RdOnly: flags = O_RDONLY; break;\n-    case WrOnly: flags = O_WRONLY | O_CREAT | O_TRUNC; break;\n-    case RdWr: flags = O_RDWR | O_CREAT; break;\n-  }\n-  fd_t res = open(filename, flags, 0660);\n-  if (internal_iserror(res, errno_p))\n-    return kInvalidFd;\n-  return res;\n-}\n-\n-void CloseFile(fd_t fd) {\n-  close(fd);\n-}\n-\n-bool ReadFromFile(fd_t fd, void *buff, uptr buff_size, uptr *bytes_read,\n-                  error_t *error_p) {\n-  uptr res = read(fd, buff, buff_size);\n-  if (internal_iserror(res, error_p))\n-    return false;\n-  if (bytes_read)\n-    *bytes_read = res;\n-  return true;\n-}\n-\n-bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,\n-                 error_t *error_p) {\n-  uptr res = write(fd, buff, buff_size);\n-  if (internal_iserror(res, error_p))\n-    return false;\n-  if (bytes_written)\n-    *bytes_written = res;\n-  return true;\n-}\n-\n-void ReleaseMemoryPagesToOS(uptr beg, uptr end) {}\n-void DumpProcessMap() {}\n-\n-// There is no page protection so everything is \"accessible.\"\n-bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n-  return true;\n-}\n-\n-char **GetArgv() { return nullptr; }\n-char **GetEnviron() { return nullptr; }\n-\n-const char *GetEnv(const char *name) {\n-  return getenv(name);\n-}\n-\n-uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n-  internal_strncpy(buf, \"StubBinaryName\", buf_len);\n-  return internal_strlen(buf);\n-}\n-\n-uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {\n-  internal_strncpy(buf, \"StubProcessName\", buf_len);\n-  return internal_strlen(buf);\n-}\n-\n-bool IsPathSeparator(const char c) {\n-  return c == '/';\n-}\n-\n-bool IsAbsolutePath(const char *path) {\n-  return path != nullptr && IsPathSeparator(path[0]);\n-}\n-\n-void ReportFile::Write(const char *buffer, uptr length) {\n-  SpinMutexLock l(mu);\n-  static const char *kWriteError =\n-      \"ReportFile::Write() can't output requested buffer!\\n\";\n-  ReopenIfNecessary();\n-  if (length != write(fd, buffer, length)) {\n-    write(fd, kWriteError, internal_strlen(kWriteError));\n-    Die();\n-  }\n-}\n-\n-uptr MainThreadStackBase, MainThreadStackSize;\n-uptr MainThreadTlsBase, MainThreadTlsSize;\n-\n-} // namespace __sanitizer\n-\n-#endif  // SANITIZER_RTEMS"}, {"sha": "e8adfd500dffa8f52c3bf4ad35c175001f9d80cf", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.h", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,20 +0,0 @@\n-//===-- sanitizer_rtems.h ---------------------------------------*- C++ -*-===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is shared between various sanitizers' runtime libraries and\n-// provides definitions for RTEMS-specific functions.\n-//===----------------------------------------------------------------------===//\n-#ifndef SANITIZER_RTEMS_H\n-#define SANITIZER_RTEMS_H\n-\n-#include \"sanitizer_platform.h\"\n-#if SANITIZER_RTEMS\n-#include \"sanitizer_common.h\"\n-\n-#endif  // SANITIZER_RTEMS\n-#endif  // SANITIZER_RTEMS_H"}, {"sha": "cb53eab8da150ea37f28e288dd1ce6369186cefa", "filename": "libsanitizer/sanitizer_common/sanitizer_solaris.cpp", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -160,6 +160,13 @@ DECLARE__REAL_AND_INTERNAL(uptr, sched_yield, void) {\n   return sched_yield();\n }\n \n+DECLARE__REAL_AND_INTERNAL(void, usleep, u64 useconds) {\n+  struct timespec ts;\n+  ts.tv_sec = useconds / 1000000;\n+  ts.tv_nsec = (useconds % 1000000) * 1000;\n+  nanosleep(&ts, nullptr);\n+}\n+\n DECLARE__REAL_AND_INTERNAL(uptr, execve, const char *filename,\n                            char *const argv[], char *const envp[]) {\n   return _REAL(execve)(filename, argv, envp);\n@@ -211,6 +218,13 @@ uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp) {\n }\n \n // ----------------- sanitizer_common.h\n+void FutexWait(atomic_uint32_t *p, u32 cmp) {\n+  // FIXME: implement actual blocking.\n+  sched_yield();\n+}\n+\n+void FutexWake(atomic_uint32_t *p, u32 count) {}\n+\n BlockingMutex::BlockingMutex() {\n   CHECK(sizeof(mutex_t) <= sizeof(opaque_storage_));\n   internal_memset(this, 0, sizeof(*this));\n@@ -231,9 +245,7 @@ void BlockingMutex::Unlock() {\n   CHECK_EQ(mutex_unlock((mutex_t *)&opaque_storage_), 0);\n }\n \n-void BlockingMutex::CheckLocked() {\n-  CHECK_EQ((uptr)thr_self(), owner_);\n-}\n+void BlockingMutex::CheckLocked() const { CHECK_EQ((uptr)thr_self(), owner_); }\n \n }  // namespace __sanitizer\n "}, {"sha": "07e4409f4a5d6680db353a449d6b861f48d8b7ac", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -85,8 +85,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -109,21 +109,14 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #elif defined(__riscv)"}, {"sha": "ea330f36f7d79af6c4192d0236796cce2afd7309", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -12,6 +12,7 @@\n #ifndef SANITIZER_STACKTRACE_H\n #define SANITIZER_STACKTRACE_H\n \n+#include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n@@ -32,8 +33,8 @@ static const u32 kStackTraceMax = 256;\n // Fast unwind is the only option on Mac for now; we will need to\n // revisit this macro when slow unwind works on Mac, see\n // https://github.com/google/sanitizers/issues/137\n-#if SANITIZER_MAC || SANITIZER_RTEMS\n-# define SANITIZER_CAN_SLOW_UNWIND 0\n+#if SANITIZER_MAC\n+#  define SANITIZER_CAN_SLOW_UNWIND 0\n #else\n # define SANITIZER_CAN_SLOW_UNWIND 1\n #endif\n@@ -56,6 +57,16 @@ struct StackTrace {\n   // Prints a symbolized stacktrace, followed by an empty line.\n   void Print() const;\n \n+  // Prints a symbolized stacktrace to the output string, followed by an empty\n+  // line.\n+  void PrintTo(InternalScopedString *output) const;\n+\n+  // Prints a symbolized stacktrace to the output buffer, followed by an empty\n+  // line. Returns the number of symbols that should have been written to buffer\n+  // (not including trailing '\\0'). Thus, the string is truncated iff return\n+  // value is not less than \"out_buf_size\".\n+  uptr PrintTo(char *out_buf, uptr out_buf_size) const;\n+\n   static bool WillUseFastUnwind(bool request_fast_unwind) {\n     if (!SANITIZER_CAN_FAST_UNWIND)\n       return false;\n@@ -185,5 +196,26 @@ static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n   uptr local_stack;                           \\\n   uptr sp = (uptr)&local_stack\n \n+// GET_CURRENT_PC() is equivalent to StackTrace::GetCurrentPc().\n+// Optimized x86 version is faster than GetCurrentPc because\n+// it does not involve a function call, instead it reads RIP register.\n+// Reads of RIP by an instruction return RIP pointing to the next\n+// instruction, which is exactly what we want here, thus 0 offset.\n+// It needs to be a macro because otherwise we will get the name\n+// of this function on the top of most stacks. Attribute artificial\n+// does not do what it claims to do, unfortunatley. And attribute\n+// __nodebug__ is clang-only. If we would have an attribute that\n+// would remove this function from debug info, we could simply make\n+// StackTrace::GetCurrentPc() faster.\n+#if defined(__x86_64__)\n+#  define GET_CURRENT_PC()                \\\n+    ({                                    \\\n+      uptr pc;                            \\\n+      asm(\"lea 0(%%rip), %0\" : \"=r\"(pc)); \\\n+      pc;                                 \\\n+    })\n+#else\n+#  define GET_CURRENT_PC() StackTrace::GetCurrentPc()\n+#endif\n \n #endif  // SANITIZER_STACKTRACE_H"}, {"sha": "f60ea7731748be59a0702a57f506b8726314deb4", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "status": "modified", "additions": 119, "deletions": 66, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -18,46 +18,119 @@\n \n namespace __sanitizer {\n \n-void StackTrace::Print() const {\n+namespace {\n+\n+class StackTraceTextPrinter {\n+ public:\n+  StackTraceTextPrinter(const char *stack_trace_fmt, char frame_delimiter,\n+                        InternalScopedString *output,\n+                        InternalScopedString *dedup_token)\n+      : stack_trace_fmt_(stack_trace_fmt),\n+        frame_delimiter_(frame_delimiter),\n+        output_(output),\n+        dedup_token_(dedup_token),\n+        symbolize_(RenderNeedsSymbolization(stack_trace_fmt)) {}\n+\n+  bool ProcessAddressFrames(uptr pc) {\n+    SymbolizedStack *frames = symbolize_\n+                                  ? Symbolizer::GetOrInit()->SymbolizePC(pc)\n+                                  : SymbolizedStack::New(pc);\n+    if (!frames)\n+      return false;\n+\n+    for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n+      uptr prev_len = output_->length();\n+      RenderFrame(output_, stack_trace_fmt_, frame_num_++, cur->info.address,\n+                  symbolize_ ? &cur->info : nullptr,\n+                  common_flags()->symbolize_vs_style,\n+                  common_flags()->strip_path_prefix);\n+\n+      if (prev_len != output_->length())\n+        output_->append(\"%c\", frame_delimiter_);\n+\n+      ExtendDedupToken(cur);\n+    }\n+    frames->ClearAll();\n+    return true;\n+  }\n+\n+ private:\n+  // Extend the dedup token by appending a new frame.\n+  void ExtendDedupToken(SymbolizedStack *stack) {\n+    if (!dedup_token_)\n+      return;\n+\n+    if (dedup_frames_-- > 0) {\n+      if (dedup_token_->length())\n+        dedup_token_->append(\"--\");\n+      if (stack->info.function != nullptr)\n+        dedup_token_->append(stack->info.function);\n+    }\n+  }\n+\n+  const char *stack_trace_fmt_;\n+  const char frame_delimiter_;\n+  int dedup_frames_ = common_flags()->dedup_token_length;\n+  uptr frame_num_ = 0;\n+  InternalScopedString *output_;\n+  InternalScopedString *dedup_token_;\n+  const bool symbolize_ = false;\n+};\n+\n+static void CopyStringToBuffer(const InternalScopedString &str, char *out_buf,\n+                               uptr out_buf_size) {\n+  if (!out_buf_size)\n+    return;\n+\n+  CHECK_GT(out_buf_size, 0);\n+  uptr copy_size = Min(str.length(), out_buf_size - 1);\n+  internal_memcpy(out_buf, str.data(), copy_size);\n+  out_buf[copy_size] = '\\0';\n+}\n+\n+}  // namespace\n+\n+void StackTrace::PrintTo(InternalScopedString *output) const {\n+  CHECK(output);\n+\n+  InternalScopedString dedup_token;\n+  StackTraceTextPrinter printer(common_flags()->stack_trace_format, '\\n',\n+                                output, &dedup_token);\n+\n   if (trace == nullptr || size == 0) {\n-    Printf(\"    <empty stack>\\n\\n\");\n+    output->append(\"    <empty stack>\\n\\n\");\n     return;\n   }\n-  InternalScopedString frame_desc;\n-  InternalScopedString dedup_token;\n-  int dedup_frames = common_flags()->dedup_token_length;\n-  bool symbolize = RenderNeedsSymbolization(common_flags()->stack_trace_format);\n-  uptr frame_num = 0;\n+\n   for (uptr i = 0; i < size && trace[i]; i++) {\n     // PCs in stack traces are actually the return addresses, that is,\n     // addresses of the next instructions after the call.\n     uptr pc = GetPreviousInstructionPc(trace[i]);\n-    SymbolizedStack *frames;\n-    if (symbolize)\n-      frames = Symbolizer::GetOrInit()->SymbolizePC(pc);\n-    else\n-      frames = SymbolizedStack::New(pc);\n-    CHECK(frames);\n-    for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n-      frame_desc.clear();\n-      RenderFrame(&frame_desc, common_flags()->stack_trace_format, frame_num++,\n-                  cur->info.address, symbolize ? &cur->info : nullptr,\n-                  common_flags()->symbolize_vs_style,\n-                  common_flags()->strip_path_prefix);\n-      Printf(\"%s\\n\", frame_desc.data());\n-      if (dedup_frames-- > 0) {\n-        if (dedup_token.length())\n-          dedup_token.append(\"--\");\n-        if (cur->info.function != nullptr)\n-          dedup_token.append(cur->info.function);\n-      }\n-    }\n-    frames->ClearAll();\n+    CHECK(printer.ProcessAddressFrames(pc));\n   }\n-  // Always print a trailing empty line after stack trace.\n-  Printf(\"\\n\");\n+\n+  // Always add a trailing empty line after stack trace.\n+  output->append(\"\\n\");\n+\n+  // Append deduplication token, if non-empty.\n   if (dedup_token.length())\n-    Printf(\"DEDUP_TOKEN: %s\\n\", dedup_token.data());\n+    output->append(\"DEDUP_TOKEN: %s\\n\", dedup_token.data());\n+}\n+\n+uptr StackTrace::PrintTo(char *out_buf, uptr out_buf_size) const {\n+  CHECK(out_buf);\n+\n+  InternalScopedString output;\n+  PrintTo(&output);\n+  CopyStringToBuffer(output, out_buf, out_buf_size);\n+\n+  return output.length();\n+}\n+\n+void StackTrace::Print() const {\n+  InternalScopedString output;\n+  PrintTo(&output);\n+  Printf(\"%s\", output.data());\n }\n \n void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n@@ -82,12 +155,15 @@ void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n       UnwindSlow(pc, context, max_depth);\n     else\n       UnwindSlow(pc, max_depth);\n+    // If there are too few frames, the program may be built with\n+    // -fno-asynchronous-unwind-tables. Fall back to fast unwinder below.\n+    if (size > 2 || size >= max_depth)\n+      return;\n #else\n     UNREACHABLE(\"slow unwind requested but not available\");\n #endif\n-  } else {\n-    UnwindFast(pc, bp, stack_top, stack_bottom, max_depth);\n   }\n+  UnwindFast(pc, bp, stack_top, stack_bottom, max_depth);\n }\n \n static int GetModuleAndOffsetForPc(uptr pc, char *module_name,\n@@ -112,41 +188,18 @@ extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_symbolize_pc(uptr pc, const char *fmt, char *out_buf,\n                               uptr out_buf_size) {\n-  if (!out_buf_size) return;\n-  pc = StackTrace::GetPreviousInstructionPc(pc);\n-  SymbolizedStack *frame;\n-  bool symbolize = RenderNeedsSymbolization(fmt);\n-  if (symbolize)\n-    frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n-  else\n-    frame = SymbolizedStack::New(pc);\n-  if (!frame) {\n-    internal_strncpy(out_buf, \"<can't symbolize>\", out_buf_size);\n-    out_buf[out_buf_size - 1] = 0;\n+  if (!out_buf_size)\n     return;\n+\n+  pc = StackTrace::GetPreviousInstructionPc(pc);\n+\n+  InternalScopedString output;\n+  StackTraceTextPrinter printer(fmt, '\\0', &output, nullptr);\n+  if (!printer.ProcessAddressFrames(pc)) {\n+    output.clear();\n+    output.append(\"<can't symbolize>\");\n   }\n-  InternalScopedString frame_desc;\n-  uptr frame_num = 0;\n-  // Reserve one byte for the final 0.\n-  char *out_end = out_buf + out_buf_size - 1;\n-  for (SymbolizedStack *cur = frame; cur && out_buf < out_end;\n-       cur = cur->next) {\n-    frame_desc.clear();\n-    RenderFrame(&frame_desc, fmt, frame_num++, cur->info.address,\n-                symbolize ? &cur->info : nullptr,\n-                common_flags()->symbolize_vs_style,\n-                common_flags()->strip_path_prefix);\n-    if (!frame_desc.length())\n-      continue;\n-    // Reserve one byte for the terminating 0.\n-    uptr n = out_end - out_buf - 1;\n-    internal_strncpy(out_buf, frame_desc.data(), n);\n-    out_buf += __sanitizer::Min<uptr>(n, frame_desc.length());\n-    *out_buf++ = 0;\n-  }\n-  CHECK(out_buf <= out_end);\n-  *out_buf = 0;\n-  frame->ClearAll();\n+  CopyStringToBuffer(output, out_buf, out_buf_size);\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "9a5b4a8c54c74956ecc2c001aa709ed4bfe1623d", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cpp", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -16,14 +16,13 @@\n \n #if SANITIZER_FUCHSIA\n #include \"sanitizer_symbolizer_fuchsia.h\"\n-#elif SANITIZER_RTEMS\n-#include \"sanitizer_symbolizer_rtems.h\"\n-#endif\n-#include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_symbolizer.h\"\n-\n-#include <limits.h>\n-#include <unwind.h>\n+#  endif\n+\n+#  include <limits.h>\n+#  include <unwind.h>\n+\n+#  include \"sanitizer_stacktrace.h\"\n+#  include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n "}, {"sha": "f330ed36640a9627173957ed07258df00c97194a", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cpp", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -120,7 +120,7 @@ void ReportMmapWriteExec(int prot) {\n #endif\n }\n \n-#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS && !SANITIZER_GO\n+#if !SANITIZER_FUCHSIA && !SANITIZER_GO\n void StartReportDeadlySignal() {\n   // Write the first message using fd=2, just in case.\n   // It may actually fail to write in case stderr is closed.\n@@ -250,17 +250,17 @@ void HandleDeadlySignal(void *siginfo, void *context, u32 tid,\n \n #endif  // !SANITIZER_FUCHSIA && !SANITIZER_GO\n \n-static atomic_uintptr_t reporting_thread = {0};\n-static StaticSpinMutex CommonSanitizerReportMutex;\n+atomic_uintptr_t ScopedErrorReportLock::reporting_thread_ = {0};\n+StaticSpinMutex ScopedErrorReportLock::mutex_;\n \n-ScopedErrorReportLock::ScopedErrorReportLock() {\n+void ScopedErrorReportLock::Lock() {\n   uptr current = GetThreadSelf();\n   for (;;) {\n     uptr expected = 0;\n-    if (atomic_compare_exchange_strong(&reporting_thread, &expected, current,\n+    if (atomic_compare_exchange_strong(&reporting_thread_, &expected, current,\n                                        memory_order_relaxed)) {\n       // We've claimed reporting_thread so proceed.\n-      CommonSanitizerReportMutex.Lock();\n+      mutex_.Lock();\n       return;\n     }\n \n@@ -282,13 +282,11 @@ ScopedErrorReportLock::ScopedErrorReportLock() {\n   }\n }\n \n-ScopedErrorReportLock::~ScopedErrorReportLock() {\n-  CommonSanitizerReportMutex.Unlock();\n-  atomic_store_relaxed(&reporting_thread, 0);\n+void ScopedErrorReportLock::Unlock() {\n+  mutex_.Unlock();\n+  atomic_store_relaxed(&reporting_thread_, 0);\n }\n \n-void ScopedErrorReportLock::CheckLocked() {\n-  CommonSanitizerReportMutex.CheckLocked();\n-}\n+void ScopedErrorReportLock::CheckLocked() { mutex_.CheckLocked(); }\n \n }  // namespace __sanitizer"}, {"sha": "3371092e0687599f374a4cd1477e52c504f1b418", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_rtems.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,40 +0,0 @@\n-//===-- sanitizer_symbolizer_rtems.h -----------------------------------===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is shared between various sanitizers' runtime libraries.\n-//\n-// Define RTEMS's string formats and limits for the markup symbolizer.\n-//===----------------------------------------------------------------------===//\n-#ifndef SANITIZER_SYMBOLIZER_RTEMS_H\n-#define SANITIZER_SYMBOLIZER_RTEMS_H\n-\n-#include \"sanitizer_internal_defs.h\"\n-\n-namespace __sanitizer {\n-\n-// The Myriad RTEMS symbolizer currently only parses backtrace lines,\n-// so use a format that the symbolizer understands.  For other\n-// markups, keep them the same as the Fuchsia's.\n-\n-// This is used by UBSan for type names, and by ASan for global variable names.\n-constexpr const char *kFormatDemangle = \"{{{symbol:%s}}}\";\n-constexpr uptr kFormatDemangleMax = 1024;  // Arbitrary.\n-\n-// Function name or equivalent from PC location.\n-constexpr const char *kFormatFunction = \"{{{pc:%p}}}\";\n-constexpr uptr kFormatFunctionMax = 64;  // More than big enough for 64-bit hex.\n-\n-// Global variable name or equivalent from data memory address.\n-constexpr const char *kFormatData = \"{{{data:%p}}}\";\n-\n-// One frame in a backtrace (printed on a line by itself).\n-constexpr const char *kFormatFrame = \"    [%u] IP: %p\";\n-\n-}  // namespace __sanitizer\n-\n-#endif  // SANITIZER_SYMBOLIZER_RTEMS_H"}, {"sha": "745fbf76b01f63e4cbbedfc0ad17b441cd806769", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cpp", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -99,28 +99,29 @@ void ThreadContextBase::Reset() {\n \n // ThreadRegistry implementation.\n \n+ThreadRegistry::ThreadRegistry(ThreadContextFactory factory)\n+    : ThreadRegistry(factory, UINT32_MAX, UINT32_MAX, 0) {}\n+\n ThreadRegistry::ThreadRegistry(ThreadContextFactory factory, u32 max_threads,\n                                u32 thread_quarantine_size, u32 max_reuse)\n     : context_factory_(factory),\n       max_threads_(max_threads),\n       thread_quarantine_size_(thread_quarantine_size),\n       max_reuse_(max_reuse),\n       mtx_(),\n-      n_contexts_(0),\n       total_threads_(0),\n       alive_threads_(0),\n       max_alive_threads_(0),\n       running_threads_(0) {\n-  threads_ = (ThreadContextBase **)MmapOrDie(max_threads_ * sizeof(threads_[0]),\n-                                             \"ThreadRegistry\");\n   dead_threads_.clear();\n   invalid_threads_.clear();\n }\n \n void ThreadRegistry::GetNumberOfThreads(uptr *total, uptr *running,\n                                         uptr *alive) {\n   BlockingMutexLock l(&mtx_);\n-  if (total) *total = n_contexts_;\n+  if (total)\n+    *total = threads_.size();\n   if (running) *running = running_threads_;\n   if (alive) *alive = alive_threads_;\n }\n@@ -137,11 +138,11 @@ u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,\n   ThreadContextBase *tctx = QuarantinePop();\n   if (tctx) {\n     tid = tctx->tid;\n-  } else if (n_contexts_ < max_threads_) {\n+  } else if (threads_.size() < max_threads_) {\n     // Allocate new thread context and tid.\n-    tid = n_contexts_++;\n+    tid = threads_.size();\n     tctx = context_factory_(tid);\n-    threads_[tid] = tctx;\n+    threads_.push_back(tctx);\n   } else {\n #if !SANITIZER_GO\n     Report(\"%s: Thread limit (%u threads) exceeded. Dying.\\n\",\n@@ -169,7 +170,7 @@ u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,\n void ThreadRegistry::RunCallbackForEachThreadLocked(ThreadCallback cb,\n                                                     void *arg) {\n   CheckLocked();\n-  for (u32 tid = 0; tid < n_contexts_; tid++) {\n+  for (u32 tid = 0; tid < threads_.size(); tid++) {\n     ThreadContextBase *tctx = threads_[tid];\n     if (tctx == 0)\n       continue;\n@@ -179,7 +180,7 @@ void ThreadRegistry::RunCallbackForEachThreadLocked(ThreadCallback cb,\n \n u32 ThreadRegistry::FindThread(FindThreadCallback cb, void *arg) {\n   BlockingMutexLock l(&mtx_);\n-  for (u32 tid = 0; tid < n_contexts_; tid++) {\n+  for (u32 tid = 0; tid < threads_.size(); tid++) {\n     ThreadContextBase *tctx = threads_[tid];\n     if (tctx != 0 && cb(tctx, arg))\n       return tctx->tid;\n@@ -190,7 +191,7 @@ u32 ThreadRegistry::FindThread(FindThreadCallback cb, void *arg) {\n ThreadContextBase *\n ThreadRegistry::FindThreadContextLocked(FindThreadCallback cb, void *arg) {\n   CheckLocked();\n-  for (u32 tid = 0; tid < n_contexts_; tid++) {\n+  for (u32 tid = 0; tid < threads_.size(); tid++) {\n     ThreadContextBase *tctx = threads_[tid];\n     if (tctx != 0 && cb(tctx, arg))\n       return tctx;\n@@ -211,7 +212,6 @@ ThreadContextBase *ThreadRegistry::FindThreadContextByOsIDLocked(tid_t os_id) {\n \n void ThreadRegistry::SetThreadName(u32 tid, const char *name) {\n   BlockingMutexLock l(&mtx_);\n-  CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   CHECK_EQ(SANITIZER_FUCHSIA ? ThreadStatusCreated : ThreadStatusRunning,\n@@ -221,7 +221,7 @@ void ThreadRegistry::SetThreadName(u32 tid, const char *name) {\n \n void ThreadRegistry::SetThreadNameByUserId(uptr user_id, const char *name) {\n   BlockingMutexLock l(&mtx_);\n-  for (u32 tid = 0; tid < n_contexts_; tid++) {\n+  for (u32 tid = 0; tid < threads_.size(); tid++) {\n     ThreadContextBase *tctx = threads_[tid];\n     if (tctx != 0 && tctx->user_id == user_id &&\n         tctx->status != ThreadStatusInvalid) {\n@@ -233,7 +233,6 @@ void ThreadRegistry::SetThreadNameByUserId(uptr user_id, const char *name) {\n \n void ThreadRegistry::DetachThread(u32 tid, void *arg) {\n   BlockingMutexLock l(&mtx_);\n-  CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   if (tctx->status == ThreadStatusInvalid) {\n@@ -254,7 +253,6 @@ void ThreadRegistry::JoinThread(u32 tid, void *arg) {\n   do {\n     {\n       BlockingMutexLock l(&mtx_);\n-      CHECK_LT(tid, n_contexts_);\n       ThreadContextBase *tctx = threads_[tid];\n       CHECK_NE(tctx, 0);\n       if (tctx->status == ThreadStatusInvalid) {\n@@ -280,7 +278,6 @@ ThreadStatus ThreadRegistry::FinishThread(u32 tid) {\n   BlockingMutexLock l(&mtx_);\n   CHECK_GT(alive_threads_, 0);\n   alive_threads_--;\n-  CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   bool dead = tctx->detached;\n@@ -306,7 +303,6 @@ void ThreadRegistry::StartThread(u32 tid, tid_t os_id, ThreadType thread_type,\n                                  void *arg) {\n   BlockingMutexLock l(&mtx_);\n   running_threads_++;\n-  CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   CHECK_EQ(ThreadStatusCreated, tctx->status);\n@@ -339,7 +335,6 @@ ThreadContextBase *ThreadRegistry::QuarantinePop() {\n \n void ThreadRegistry::SetThreadUserId(u32 tid, uptr user_id) {\n   BlockingMutexLock l(&mtx_);\n-  CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   CHECK_NE(tctx->status, ThreadStatusInvalid);"}, {"sha": "0b28bbe6ddf6e06fd0636299fd796de49b8ce769", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -85,22 +85,22 @@ class ThreadContextBase {\n \n typedef ThreadContextBase* (*ThreadContextFactory)(u32 tid);\n \n-class ThreadRegistry {\n+class MUTEX ThreadRegistry {\n  public:\n+  ThreadRegistry(ThreadContextFactory factory);\n   ThreadRegistry(ThreadContextFactory factory, u32 max_threads,\n-                 u32 thread_quarantine_size, u32 max_reuse = 0);\n+                 u32 thread_quarantine_size, u32 max_reuse);\n   void GetNumberOfThreads(uptr *total = nullptr, uptr *running = nullptr,\n                           uptr *alive = nullptr);\n   uptr GetMaxAliveThreads();\n \n-  void Lock() { mtx_.Lock(); }\n-  void CheckLocked() { mtx_.CheckLocked(); }\n-  void Unlock() { mtx_.Unlock(); }\n+  void Lock() ACQUIRE() { mtx_.Lock(); }\n+  void CheckLocked() const CHECK_LOCKED() { mtx_.CheckLocked(); }\n+  void Unlock() RELEASE() { mtx_.Unlock(); }\n \n   // Should be guarded by ThreadRegistryLock.\n   ThreadContextBase *GetThreadLocked(u32 tid) {\n-    DCHECK_LT(tid, n_contexts_);\n-    return threads_[tid];\n+    return threads_.empty() ? nullptr : threads_[tid];\n   }\n \n   u32 CreateThread(uptr user_id, bool detached, u32 parent_tid, void *arg);\n@@ -137,15 +137,13 @@ class ThreadRegistry {\n \n   BlockingMutex mtx_;\n \n-  u32 n_contexts_;      // Number of created thread contexts,\n-                        // at most max_threads_.\n   u64 total_threads_;   // Total number of created threads. May be greater than\n                         // max_threads_ if contexts were reused.\n   uptr alive_threads_;  // Created or running.\n   uptr max_alive_threads_;\n   uptr running_threads_;\n \n-  ThreadContextBase **threads_;  // Array of thread contexts is leaked.\n+  InternalMmapVector<ThreadContextBase *> threads_;\n   IntrusiveList<ThreadContextBase> dead_threads_;\n   IntrusiveList<ThreadContextBase> invalid_threads_;\n "}, {"sha": "52b25edaa7a3e7b115676efb813b3b7dfa2de1ca", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_safety.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_safety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_safety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_safety.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -0,0 +1,42 @@\n+//===-- sanitizer_thread_safety.h -------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between sanitizer tools.\n+//\n+// Wrappers around thread safety annotations.\n+// https://clang.llvm.org/docs/ThreadSafetyAnalysis.html\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_THREAD_SAFETY_H\n+#define SANITIZER_THREAD_SAFETY_H\n+\n+#if defined(__clang__)\n+#  define THREAD_ANNOTATION(x) __attribute__((x))\n+#else\n+#  define THREAD_ANNOTATION(x)\n+#endif\n+\n+#define MUTEX THREAD_ANNOTATION(capability(\"mutex\"))\n+#define SCOPED_LOCK THREAD_ANNOTATION(scoped_lockable)\n+#define GUARDED_BY(x) THREAD_ANNOTATION(guarded_by(x))\n+#define PT_GUARDED_BY(x) THREAD_ANNOTATION(pt_guarded_by(x))\n+#define REQUIRES(...) THREAD_ANNOTATION(requires_capability(__VA_ARGS__))\n+#define REQUIRES_SHARED(...) \\\n+  THREAD_ANNOTATION(requires_shared_capability(__VA_ARGS__))\n+#define ACQUIRE(...) THREAD_ANNOTATION(acquire_capability(__VA_ARGS__))\n+#define ACQUIRE_SHARED(...) \\\n+  THREAD_ANNOTATION(acquire_shared_capability(__VA_ARGS__))\n+#define TRY_ACQUIRE(...) THREAD_ANNOTATION(try_acquire_capability(__VA_ARGS__))\n+#define RELEASE(...) THREAD_ANNOTATION(release_capability(__VA_ARGS__))\n+#define RELEASE_SHARED(...) \\\n+  THREAD_ANNOTATION(release_shared_capability(__VA_ARGS__))\n+#define EXCLUDES(...) THREAD_ANNOTATION(locks_excluded(__VA_ARGS__))\n+#define CHECK_LOCKED(...) THREAD_ANNOTATION(assert_capability(__VA_ARGS__))\n+#define NO_THREAD_SAFETY_ANALYSIS THREAD_ANNOTATION(no_thread_safety_analysis)\n+\n+#endif"}, {"sha": "dddd885a45dd24a87fe6b6892b554e6fc63058f2", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -44,6 +44,9 @@ TRACELOGGING_DEFINE_PROVIDER(g_asan_provider, \"AddressSanitizerLoggingProvider\",\n #define TraceLoggingUnregister(x)\n #endif\n \n+// For WaitOnAddress\n+#  pragma comment(lib, \"synchronization.lib\")\n+\n // A macro to tell the compiler that this part of the code cannot be reached,\n // if the compiler supports this feature. Since we're using this in\n // code that is called when terminating the process, the expansion of the\n@@ -541,13 +544,7 @@ bool IsAbsolutePath(const char *path) {\n          IsPathSeparator(path[2]);\n }\n \n-void SleepForSeconds(int seconds) {\n-  Sleep(seconds * 1000);\n-}\n-\n-void SleepForMillis(int millis) {\n-  Sleep(millis);\n-}\n+void internal_usleep(u64 useconds) { Sleep(useconds / 1000); }\n \n u64 NanoTime() {\n   static LARGE_INTEGER frequency = {};\n@@ -819,6 +816,17 @@ uptr GetRSS() {\n void *internal_start_thread(void *(*func)(void *arg), void *arg) { return 0; }\n void internal_join_thread(void *th) { }\n \n+void FutexWait(atomic_uint32_t *p, u32 cmp) {\n+  WaitOnAddress(p, &cmp, sizeof(cmp), INFINITE);\n+}\n+\n+void FutexWake(atomic_uint32_t *p, u32 count) {\n+  if (count == 1)\n+    WakeByAddressSingle(p);\n+  else\n+    WakeByAddressAll(p);\n+}\n+\n // ---------------------- BlockingMutex ---------------- {{{1\n \n BlockingMutex::BlockingMutex() {\n@@ -838,9 +846,7 @@ void BlockingMutex::Unlock() {\n   ReleaseSRWLockExclusive((PSRWLOCK)opaque_storage_);\n }\n \n-void BlockingMutex::CheckLocked() {\n-  CHECK_EQ(owner_, GetThreadSelf());\n-}\n+void BlockingMutex::CheckLocked() const { CHECK_EQ(owner_, GetThreadSelf()); }\n \n uptr GetTlsSize() {\n   return 0;"}, {"sha": "dcb247ec032c17c13e9750fbebfbeb0ea72d4f2d", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -43,13 +43,12 @@ tsan_files = \\\n \ttsan_rtl_report.cpp \\\n \ttsan_rtl_thread.cpp \\\n \ttsan_stack_trace.cpp \\\n-\ttsan_stat.cpp \\\n \ttsan_suppressions.cpp \\\n \ttsan_symbolize.cpp \\\n \ttsan_sync.cpp \n \n libtsan_la_SOURCES = $(tsan_files)\n-EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S tsan_rtl_mips64.S tsan_rtl_ppc64.S\n+EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S tsan_rtl_mips64.S tsan_rtl_ppc64.S tsan_rtl_s390x.S\n libtsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(TSAN_TARGET_DEPENDENT_OBJECTS)\n libtsan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(TSAN_TARGET_DEPENDENT_OBJECTS)\n if LIBBACKTRACE_SUPPORTED"}, {"sha": "83617cf6ab7f714ce73b5eec926de1c05024b37e", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -155,8 +155,7 @@ am__objects_1 = tsan_clock.lo tsan_debugging.lo tsan_external.lo \\\n \ttsan_platform_posix.lo tsan_platform_windows.lo tsan_report.lo \\\n \ttsan_rtl.lo tsan_rtl_mutex.lo tsan_rtl_proc.lo \\\n \ttsan_rtl_report.lo tsan_rtl_thread.lo tsan_stack_trace.lo \\\n-\ttsan_stat.lo tsan_suppressions.lo tsan_symbolize.lo \\\n-\ttsan_sync.lo\n+\ttsan_suppressions.lo tsan_symbolize.lo tsan_sync.lo\n am_libtsan_la_OBJECTS = $(am__objects_1)\n libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n AM_V_lt = $(am__v_lt_@AM_V@)\n@@ -446,13 +445,12 @@ tsan_files = \\\n \ttsan_rtl_report.cpp \\\n \ttsan_rtl_thread.cpp \\\n \ttsan_stack_trace.cpp \\\n-\ttsan_stat.cpp \\\n \ttsan_suppressions.cpp \\\n \ttsan_symbolize.cpp \\\n \ttsan_sync.cpp \n \n libtsan_la_SOURCES = $(tsan_files)\n-EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S tsan_rtl_mips64.S tsan_rtl_ppc64.S\n+EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S tsan_rtl_mips64.S tsan_rtl_ppc64.S tsan_rtl_s390x.S\n libtsan_la_LIBADD =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(top_builddir)/interception/libinterception.la \\\n@@ -612,9 +610,9 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_ppc64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_proc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_report.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_s390x.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_stack_trace.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_stat.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_suppressions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_symbolize.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_sync.Plo@am__quote@"}, {"sha": "61848c21d162b4c11b0ee6e36a4300c3704eeb6c", "filename": "libsanitizer/tsan/tsan_clock.cpp", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_clock.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_clock.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -80,14 +80,6 @@\n //   release-store operation by the thread with release_store_tid_ index.\n // release_store_reused_ - reuse count of release_store_tid_.\n \n-// We don't have ThreadState in these methods, so this is an ugly hack that\n-// works only in C++.\n-#if !SANITIZER_GO\n-# define CPP_STAT_INC(typ) StatInc(cur_thread(), typ)\n-#else\n-# define CPP_STAT_INC(typ) (void)0\n-#endif\n-\n namespace __tsan {\n \n static atomic_uint32_t *ref_ptr(ClockBlock *cb) {\n@@ -138,14 +130,11 @@ void ThreadClock::ResetCached(ClockCache *c) {\n void ThreadClock::acquire(ClockCache *c, SyncClock *src) {\n   DCHECK_LE(nclk_, kMaxTid);\n   DCHECK_LE(src->size_, kMaxTid);\n-  CPP_STAT_INC(StatClockAcquire);\n \n   // Check if it's empty -> no need to do anything.\n   const uptr nclk = src->size_;\n-  if (nclk == 0) {\n-    CPP_STAT_INC(StatClockAcquireEmpty);\n+  if (nclk == 0)\n     return;\n-  }\n \n   bool acquired = false;\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n@@ -162,7 +151,6 @@ void ThreadClock::acquire(ClockCache *c, SyncClock *src) {\n   // Check if we've already acquired src after the last release operation on src\n   if (tid_ >= nclk || src->elem(tid_).reused != reused_) {\n     // O(N) acquire.\n-    CPP_STAT_INC(StatClockAcquireFull);\n     nclk_ = max(nclk_, nclk);\n     u64 *dst_pos = &clk_[0];\n     for (ClockElem &src_elem : *src) {\n@@ -180,7 +168,6 @@ void ThreadClock::acquire(ClockCache *c, SyncClock *src) {\n   }\n \n   if (acquired) {\n-    CPP_STAT_INC(StatClockAcquiredSomething);\n     last_acquire_ = clk_[tid_];\n     ResetCached(c);\n   }\n@@ -223,7 +210,6 @@ void ThreadClock::releaseStoreAcquire(ClockCache *c, SyncClock *sc) {\n   sc->release_store_reused_ = 0;\n \n   if (acquired) {\n-    CPP_STAT_INC(StatClockAcquiredSomething);\n     last_acquire_ = clk_[tid_];\n     ResetCached(c);\n   }\n@@ -240,7 +226,6 @@ void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n     return;\n   }\n \n-  CPP_STAT_INC(StatClockRelease);\n   // Check if we need to resize dst.\n   if (dst->size_ < nclk_)\n     dst->Resize(c, nclk_);\n@@ -257,12 +242,9 @@ void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n   }\n \n   // O(N) release.\n-  CPP_STAT_INC(StatClockReleaseFull);\n   dst->Unshare(c);\n   // First, remember whether we've acquired dst.\n   bool acquired = IsAlreadyAcquired(dst);\n-  if (acquired)\n-    CPP_STAT_INC(StatClockReleaseAcquired);\n   // Update dst->clk_.\n   dst->FlushDirty();\n   uptr i = 0;\n@@ -272,8 +254,6 @@ void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n     i++;\n   }\n   // Clear 'acquired' flag in the remaining elements.\n-  if (nclk_ < dst->size_)\n-    CPP_STAT_INC(StatClockReleaseClearTail);\n   dst->release_store_tid_ = kInvalidTid;\n   dst->release_store_reused_ = 0;\n   // If we've acquired dst, remember this fact,\n@@ -285,7 +265,6 @@ void ThreadClock::release(ClockCache *c, SyncClock *dst) {\n void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) {\n   DCHECK_LE(nclk_, kMaxTid);\n   DCHECK_LE(dst->size_, kMaxTid);\n-  CPP_STAT_INC(StatClockStore);\n \n   if (dst->size_ == 0 && cached_idx_ != 0) {\n     // Reuse the cached clock.\n@@ -320,13 +299,11 @@ void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) {\n   if (dst->release_store_tid_ == tid_ &&\n       dst->release_store_reused_ == reused_ &&\n       !HasAcquiredAfterRelease(dst)) {\n-    CPP_STAT_INC(StatClockStoreFast);\n     UpdateCurrentThread(c, dst);\n     return;\n   }\n \n   // O(N) release-store.\n-  CPP_STAT_INC(StatClockStoreFull);\n   dst->Unshare(c);\n   // Note: dst can be larger than this ThreadClock.\n   // This is fine since clk_ beyond size is all zeros.\n@@ -358,7 +335,6 @@ void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) {\n }\n \n void ThreadClock::acq_rel(ClockCache *c, SyncClock *dst) {\n-  CPP_STAT_INC(StatClockAcquireRelease);\n   acquire(c, dst);\n   ReleaseStore(c, dst);\n }\n@@ -370,7 +346,6 @@ void ThreadClock::UpdateCurrentThread(ClockCache *c, SyncClock *dst) const {\n     SyncClock::Dirty *dirty = &dst->dirty_[i];\n     const unsigned tid = dirty->tid();\n     if (tid == tid_ || tid == kInvalidTid) {\n-      CPP_STAT_INC(StatClockReleaseFast);\n       dirty->set_tid(tid_);\n       dirty->epoch = clk_[tid_];\n       return;\n@@ -379,7 +354,6 @@ void ThreadClock::UpdateCurrentThread(ClockCache *c, SyncClock *dst) const {\n   // Reset all 'acquired' flags, O(N).\n   // We are going to touch dst elements, so we need to unshare it.\n   dst->Unshare(c);\n-  CPP_STAT_INC(StatClockReleaseSlow);\n   dst->elem(tid_).epoch = clk_[tid_];\n   for (uptr i = 0; i < dst->size_; i++)\n     dst->elem(i).reused = 0;\n@@ -456,7 +430,6 @@ void SyncClock::ResetImpl() {\n }\n \n void SyncClock::Resize(ClockCache *c, uptr nclk) {\n-  CPP_STAT_INC(StatClockReleaseResize);\n   Unshare(c);\n   if (nclk <= capacity()) {\n     // Memory is already allocated, just increase the size."}, {"sha": "5c8f2801b0c2b00b8aa1e22fecdced75d86db3cb", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -15,18 +15,13 @@\n \n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n-#include \"tsan_stat.h\"\n #include \"ubsan/ubsan_platform.h\"\n \n // Setup defaults for compile definitions.\n #ifndef TSAN_NO_HISTORY\n # define TSAN_NO_HISTORY 0\n #endif\n \n-#ifndef TSAN_COLLECT_STATS\n-# define TSAN_COLLECT_STATS 0\n-#endif\n-\n #ifndef TSAN_CONTAINS_UBSAN\n # if CAN_SANITIZE_UB && !SANITIZER_GO\n #  define TSAN_CONTAINS_UBSAN 1\n@@ -107,23 +102,12 @@ void build_consistency_debug();\n void build_consistency_release();\n #endif\n \n-#if TSAN_COLLECT_STATS\n-void build_consistency_stats();\n-#else\n-void build_consistency_nostats();\n-#endif\n-\n static inline void USED build_consistency() {\n #if SANITIZER_DEBUG\n   build_consistency_debug();\n #else\n   build_consistency_release();\n #endif\n-#if TSAN_COLLECT_STATS\n-  build_consistency_stats();\n-#else\n-  build_consistency_nostats();\n-#endif\n }\n \n template<typename T>"}, {"sha": "c5716f53a323a025298d445df3c7ad773666b6fd", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -30,14 +30,14 @@ inline bool in_symbolizer() {\n \n }  // namespace __tsan\n \n-#define SCOPED_INTERCEPTOR_RAW(func, ...) \\\n-    cur_thread_init(); \\\n-    ThreadState *thr = cur_thread(); \\\n-    const uptr caller_pc = GET_CALLER_PC(); \\\n-    ScopedInterceptor si(thr, #func, caller_pc); \\\n-    const uptr pc = StackTrace::GetCurrentPc(); \\\n-    (void)pc; \\\n-/**/\n+#define SCOPED_INTERCEPTOR_RAW(func, ...)      \\\n+  cur_thread_init();                           \\\n+  ThreadState *thr = cur_thread();             \\\n+  const uptr caller_pc = GET_CALLER_PC();      \\\n+  ScopedInterceptor si(thr, #func, caller_pc); \\\n+  const uptr pc = GET_CURRENT_PC();            \\\n+  (void)pc;                                    \\\n+  /**/\n \n #define SCOPED_TSAN_INTERCEPTOR(func, ...) \\\n     SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__); \\"}, {"sha": "2d400c7e7098dcd9e81abdcb8ed78c2df92de3ad", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -44,8 +44,9 @@ namespace __tsan {\n // actually aliases of each other, and we cannot have different interceptors for\n // them, because they're actually the same function.  Thus, we have to stay\n // conservative and treat the non-barrier versions as mo_acq_rel.\n-static const morder kMacOrderBarrier = mo_acq_rel;\n-static const morder kMacOrderNonBarrier = mo_acq_rel;\n+static constexpr morder kMacOrderBarrier = mo_acq_rel;\n+static constexpr morder kMacOrderNonBarrier = mo_acq_rel;\n+static constexpr morder kMacFailureOrder = mo_relaxed;\n \n #define OSATOMIC_INTERCEPTOR(return_t, t, tsan_t, f, tsan_atomic_f, mo) \\\n   TSAN_INTERCEPTOR(return_t, f, t x, volatile t *ptr) {                 \\\n@@ -110,15 +111,15 @@ OSATOMIC_INTERCEPTORS_BITWISE(OSAtomicXor, fetch_xor,\n     SCOPED_TSAN_INTERCEPTOR(f, old_value, new_value, ptr);                  \\\n     return tsan_atomic_f##_compare_exchange_strong(                         \\\n         (volatile tsan_t *)ptr, (tsan_t *)&old_value, (tsan_t)new_value,    \\\n-        kMacOrderNonBarrier, kMacOrderNonBarrier);                          \\\n+        kMacOrderNonBarrier, kMacFailureOrder);                             \\\n   }                                                                         \\\n                                                                             \\\n   TSAN_INTERCEPTOR(bool, f##Barrier, t old_value, t new_value,              \\\n                    t volatile *ptr) {                                       \\\n     SCOPED_TSAN_INTERCEPTOR(f##Barrier, old_value, new_value, ptr);         \\\n     return tsan_atomic_f##_compare_exchange_strong(                         \\\n         (volatile tsan_t *)ptr, (tsan_t *)&old_value, (tsan_t)new_value,    \\\n-        kMacOrderBarrier, kMacOrderNonBarrier);                             \\\n+        kMacOrderBarrier, kMacFailureOrder);                                \\\n   }\n \n OSATOMIC_INTERCEPTORS_CAS(OSAtomicCompareAndSwapInt, __tsan_atomic32, a32, int)"}, {"sha": "6808f2e0e2d3da72d91ce5077e602aed49cc3031", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -71,7 +71,8 @@ struct ucontext_t {\n };\n #endif\n \n-#if defined(__x86_64__) || defined(__mips__) || SANITIZER_PPC64V1\n+#if defined(__x86_64__) || defined(__mips__) || SANITIZER_PPC64V1 || \\\n+    defined(__s390x__)\n #define PTHREAD_ABI_BASE  \"GLIBC_2.3.2\"\n #elif defined(__aarch64__) || SANITIZER_PPC64V2\n #define PTHREAD_ABI_BASE  \"GLIBC_2.17\"\n@@ -2270,6 +2271,7 @@ static void HandleRecvmsg(ThreadState *thr, uptr pc,\n #define NEED_TLS_GET_ADDR\n #endif\n #undef SANITIZER_INTERCEPT_TLS_GET_ADDR\n+#define SANITIZER_INTERCEPT_TLS_GET_OFFSET 1\n #undef SANITIZER_INTERCEPT_PTHREAD_SIGMASK\n \n #define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n@@ -2585,6 +2587,20 @@ static void syscall_post_fork(uptr pc, int pid) {\n #include \"sanitizer_common/sanitizer_syscalls_netbsd.inc\"\n \n #ifdef NEED_TLS_GET_ADDR\n+\n+static void handle_tls_addr(void *arg, void *res) {\n+  ThreadState *thr = cur_thread();\n+  if (!thr)\n+    return;\n+  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, thr->tls_addr,\n+                                        thr->tls_addr + thr->tls_size);\n+  if (!dtv)\n+    return;\n+  // New DTLS block has been allocated.\n+  MemoryResetRange(thr, 0, dtv->beg, dtv->size);\n+}\n+\n+#if !SANITIZER_S390\n // Define own interceptor instead of sanitizer_common's for three reasons:\n // 1. It must not process pending signals.\n //    Signal handlers may contain MOVDQA instruction (see below).\n@@ -2597,18 +2613,18 @@ static void syscall_post_fork(uptr pc, int pid) {\n // execute MOVDQA with stack addresses.\n TSAN_INTERCEPTOR(void *, __tls_get_addr, void *arg) {\n   void *res = REAL(__tls_get_addr)(arg);\n-  ThreadState *thr = cur_thread();\n-  if (!thr)\n-    return res;\n-  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, thr->tls_addr,\n-                                        thr->tls_addr + thr->tls_size);\n-  if (!dtv)\n-    return res;\n-  // New DTLS block has been allocated.\n-  MemoryResetRange(thr, 0, dtv->beg, dtv->size);\n+  handle_tls_addr(arg, res);\n+  return res;\n+}\n+#else // SANITIZER_S390\n+TSAN_INTERCEPTOR(uptr, __tls_get_addr_internal, void *arg) {\n+  uptr res = __tls_get_offset_wrapper(arg, REAL(__tls_get_offset));\n+  char *tp = static_cast<char *>(__builtin_thread_pointer());\n+  handle_tls_addr(arg, res + tp);\n   return res;\n }\n #endif\n+#endif\n \n #if SANITIZER_NETBSD\n TSAN_INTERCEPTOR(void, _lwp_exit) {\n@@ -2830,7 +2846,12 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(_exit);\n \n #ifdef NEED_TLS_GET_ADDR\n+#if !SANITIZER_S390\n   TSAN_INTERCEPT(__tls_get_addr);\n+#else\n+  TSAN_INTERCEPT(__tls_get_addr_internal);\n+  TSAN_INTERCEPT(__tls_get_offset);\n+#endif\n #endif\n \n   TSAN_MAYBE_INTERCEPT__LWP_EXIT;"}, {"sha": "124aa2fd21431e02bc9fa19c4a881368e75dbd76", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -196,7 +196,8 @@ typedef unsigned short a16;\n typedef unsigned int       a32;\n typedef unsigned long long a64;\n #if !SANITIZER_GO && (defined(__SIZEOF_INT128__) \\\n-    || (__clang_major__ * 100 + __clang_minor__ >= 302)) && !defined(__mips64)\n+    || (__clang_major__ * 100 + __clang_minor__ >= 302)) && \\\n+    !defined(__mips64) && !defined(__s390x__)\n __extension__ typedef __int128 a128;\n # define __TSAN_HAS_INT128 1\n #else"}, {"sha": "175855f66c8cbfab3649c9ec883cd98399906815", "filename": "libsanitizer/tsan/tsan_interface_ann.cpp", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interface_ann.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interface_ann.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -49,8 +49,6 @@ class ScopedAnnotation {\n       return ret; \\\n     ThreadState *thr = cur_thread(); \\\n     const uptr caller_pc = (uptr)__builtin_return_address(0); \\\n-    StatInc(thr, StatAnnotation); \\\n-    StatInc(thr, Stat##typ); \\\n     ScopedAnnotation sa(thr, __func__, caller_pc); \\\n     const uptr pc = StackTrace::GetCurrentPc(); \\\n     (void)pc; \\\n@@ -77,9 +75,7 @@ struct DynamicAnnContext {\n   ExpectRace expect;\n   ExpectRace benign;\n \n-  DynamicAnnContext()\n-    : mtx(MutexTypeAnnotations, StatMtxAnnotations) {\n-  }\n+  DynamicAnnContext() : mtx(MutexTypeAnnotations) {}\n };\n \n static DynamicAnnContext *dyn_ann_ctx;"}, {"sha": "21fe4a19619ad779acf64bb1504130f8f40813f1", "filename": "libsanitizer/tsan/tsan_interface_atomic.cpp", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -402,34 +402,45 @@ static T NoTsanAtomicCAS(volatile T *a, T c, T v, morder mo, morder fmo) {\n template<typename T>\n static bool AtomicCAS(ThreadState *thr, uptr pc,\n     volatile T *a, T *c, T v, morder mo, morder fmo) {\n-  (void)fmo;  // Unused because llvm does not pass it yet.\n+  // 31.7.2.18: \"The failure argument shall not be memory_order_release\n+  // nor memory_order_acq_rel\". LLVM (2021-05) fallbacks to Monotonic\n+  // (mo_relaxed) when those are used.\n+  CHECK(IsLoadOrder(fmo));\n+\n   MemoryWriteAtomic(thr, pc, (uptr)a, SizeLog<T>());\n   SyncVar *s = 0;\n-  bool write_lock = mo != mo_acquire && mo != mo_consume;\n-  if (mo != mo_relaxed) {\n+  bool write_lock = IsReleaseOrder(mo);\n+\n+  if (mo != mo_relaxed || fmo != mo_relaxed)\n     s = ctx->metamap.GetOrCreateAndLock(thr, pc, (uptr)a, write_lock);\n+\n+  T cc = *c;\n+  T pr = func_cas(a, cc, v);\n+  bool success = pr == cc;\n+  if (!success) {\n+    *c = pr;\n+    mo = fmo;\n+  }\n+\n+  if (s) {\n     thr->fast_state.IncrementEpoch();\n     // Can't increment epoch w/o writing to the trace as well.\n     TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n-    if (IsAcqRelOrder(mo))\n+\n+    if (success && IsAcqRelOrder(mo))\n       AcquireReleaseImpl(thr, pc, &s->clock);\n-    else if (IsReleaseOrder(mo))\n+    else if (success && IsReleaseOrder(mo))\n       ReleaseImpl(thr, pc, &s->clock);\n     else if (IsAcquireOrder(mo))\n       AcquireImpl(thr, pc, &s->clock);\n-  }\n-  T cc = *c;\n-  T pr = func_cas(a, cc, v);\n-  if (s) {\n+\n     if (write_lock)\n       s->mtx.Unlock();\n     else\n       s->mtx.ReadUnlock();\n   }\n-  if (pr == cc)\n-    return true;\n-  *c = pr;\n-  return false;\n+\n+  return success;\n }\n \n template<typename T>\n@@ -481,7 +492,6 @@ static morder convert_morder(morder mo) {\n     const uptr callpc = (uptr)__builtin_return_address(0); \\\n     uptr pc = StackTrace::GetCurrentPc(); \\\n     mo = convert_morder(mo); \\\n-    AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n     ScopedAtomic sa(thr, callpc, a, mo, __func__); \\\n     return Atomic##func(thr, pc, __VA_ARGS__); \\\n /**/\n@@ -502,22 +512,6 @@ class ScopedAtomic {\n   ThreadState *thr_;\n };\n \n-static void AtomicStatInc(ThreadState *thr, uptr size, morder mo, StatType t) {\n-  StatInc(thr, StatAtomic);\n-  StatInc(thr, t);\n-  StatInc(thr, size == 1 ? StatAtomic1\n-             : size == 2 ? StatAtomic2\n-             : size == 4 ? StatAtomic4\n-             : size == 8 ? StatAtomic8\n-             :             StatAtomic16);\n-  StatInc(thr, mo == mo_relaxed ? StatAtomicRelaxed\n-             : mo == mo_consume ? StatAtomicConsume\n-             : mo == mo_acquire ? StatAtomicAcquire\n-             : mo == mo_release ? StatAtomicRelease\n-             : mo == mo_acq_rel ? StatAtomicAcq_Rel\n-             :                    StatAtomicSeq_Cst);\n-}\n-\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n a8 __tsan_atomic8_load(const volatile a8 *a, morder mo) {"}, {"sha": "7765bc070522acefce58a03ef8d140072f408c60", "filename": "libsanitizer/tsan/tsan_mman.cpp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_mman.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_mman.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -70,10 +70,7 @@ struct GlobalProc {\n   Mutex mtx;\n   Processor *proc;\n \n-  GlobalProc()\n-      : mtx(MutexTypeGlobalProc, StatMtxGlobalProc)\n-      , proc(ProcCreate()) {\n-  }\n+  GlobalProc() : mtx(MutexTypeGlobalProc), proc(ProcCreate()) {}\n };\n \n static char global_proc_placeholder[sizeof(GlobalProc)] ALIGNED(64);"}, {"sha": "d8b1826ee47bba38fba5309ad58ab0817dc356b9", "filename": "libsanitizer/tsan/tsan_mutex.cpp", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_mutex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_mutex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -207,14 +207,11 @@ class Backoff {\n   static const int kActiveSpinCnt = 20;\n };\n \n-Mutex::Mutex(MutexType type, StatType stat_type) {\n+Mutex::Mutex(MutexType type) {\n   CHECK_GT(type, MutexTypeInvalid);\n   CHECK_LT(type, MutexTypeCount);\n #if SANITIZER_DEBUG\n   type_ = type;\n-#endif\n-#if TSAN_COLLECT_STATS\n-  stat_type_ = stat_type;\n #endif\n   atomic_store(&state_, kUnlocked, memory_order_relaxed);\n }\n@@ -236,9 +233,6 @@ void Mutex::Lock() {\n       cmp = kUnlocked;\n       if (atomic_compare_exchange_weak(&state_, &cmp, kWriteLock,\n                                        memory_order_acquire)) {\n-#if TSAN_COLLECT_STATS && !SANITIZER_GO\n-        StatInc(cur_thread(), stat_type_, backoff.Contention());\n-#endif\n         return;\n       }\n     }\n@@ -264,9 +258,6 @@ void Mutex::ReadLock() {\n   for (Backoff backoff; backoff.Do();) {\n     prev = atomic_load(&state_, memory_order_acquire);\n     if ((prev & kWriteLock) == 0) {\n-#if TSAN_COLLECT_STATS && !SANITIZER_GO\n-      StatInc(cur_thread(), stat_type_, backoff.Contention());\n-#endif\n       return;\n     }\n   }"}, {"sha": "9a579eaf9144a18c6cd8aada8334cf601315b06c", "filename": "libsanitizer/tsan/tsan_mutex.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -41,7 +41,7 @@ enum MutexType {\n \n class Mutex {\n  public:\n-  explicit Mutex(MutexType type, StatType stat_type);\n+  explicit Mutex(MutexType type);\n   ~Mutex();\n \n   void Lock();\n@@ -57,9 +57,6 @@ class Mutex {\n #if SANITIZER_DEBUG\n   MutexType type_;\n #endif\n-#if TSAN_COLLECT_STATS\n-  StatType stat_type_;\n-#endif\n \n   Mutex(const Mutex&);\n   void operator = (const Mutex&);"}, {"sha": "8bd218e25fd6f5a322514c1f255aa70dd3900b37", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -365,6 +365,38 @@ struct Mapping47 {\n \n // Indicates the runtime will define the memory regions at runtime.\n #define TSAN_RUNTIME_VMA 1\n+#elif defined(__s390x__)\n+/*\n+C/C++ on linux/s390x\n+While the kernel provides a 64-bit address space, we have to restrict ourselves\n+to 48 bits due to how e.g. SyncVar::GetId() works.\n+0000 0000 1000 - 0e00 0000 0000: binary, modules, stacks - 14 TiB\n+0e00 0000 0000 - 4000 0000 0000: -\n+4000 0000 0000 - 8000 0000 0000: shadow - 64TiB (4 * app)\n+8000 0000 0000 - 9000 0000 0000: -\n+9000 0000 0000 - 9800 0000 0000: metainfo - 8TiB (0.5 * app)\n+9800 0000 0000 - a000 0000 0000: -\n+a000 0000 0000 - b000 0000 0000: traces - 16TiB (max history * 128k threads)\n+b000 0000 0000 - be00 0000 0000: -\n+be00 0000 0000 - c000 0000 0000: heap - 2TiB (max supported by the allocator)\n+*/\n+struct Mapping {\n+  static const uptr kMetaShadowBeg = 0x900000000000ull;\n+  static const uptr kMetaShadowEnd = 0x980000000000ull;\n+  static const uptr kTraceMemBeg   = 0xa00000000000ull;\n+  static const uptr kTraceMemEnd   = 0xb00000000000ull;\n+  static const uptr kShadowBeg     = 0x400000000000ull;\n+  static const uptr kShadowEnd     = 0x800000000000ull;\n+  static const uptr kHeapMemBeg    = 0xbe0000000000ull;\n+  static const uptr kHeapMemEnd    = 0xc00000000000ull;\n+  static const uptr kLoAppMemBeg   = 0x000000001000ull;\n+  static const uptr kLoAppMemEnd   = 0x0e0000000000ull;\n+  static const uptr kHiAppMemBeg   = 0xc00000004000ull;\n+  static const uptr kHiAppMemEnd   = 0xc00000004000ull;\n+  static const uptr kAppMemMsk     = 0xb00000000000ull;\n+  static const uptr kAppMemXor     = 0x100000000000ull;\n+  static const uptr kVdsoBeg       = 0xfffffffff000ull;\n+};\n #endif\n \n #elif SANITIZER_GO && !SANITIZER_WINDOWS && HAS_48_BIT_ADDRESS_SPACE\n@@ -528,6 +560,28 @@ struct Mapping47 {\n \n #define TSAN_RUNTIME_VMA 1\n \n+#elif SANITIZER_GO && defined(__s390x__)\n+/*\n+Go on linux/s390x\n+0000 0000 1000 - 1000 0000 0000: executable and heap - 16 TiB\n+1000 0000 0000 - 4000 0000 0000: -\n+4000 0000 0000 - 8000 0000 0000: shadow - 64TiB (4 * app)\n+8000 0000 0000 - 9000 0000 0000: -\n+9000 0000 0000 - 9800 0000 0000: metainfo - 8TiB (0.5 * app)\n+9800 0000 0000 - a000 0000 0000: -\n+a000 0000 0000 - b000 0000 0000: traces - 16TiB (max history * 128k threads)\n+*/\n+struct Mapping {\n+  static const uptr kMetaShadowBeg = 0x900000000000ull;\n+  static const uptr kMetaShadowEnd = 0x980000000000ull;\n+  static const uptr kTraceMemBeg   = 0xa00000000000ull;\n+  static const uptr kTraceMemEnd   = 0xb00000000000ull;\n+  static const uptr kShadowBeg     = 0x400000000000ull;\n+  static const uptr kShadowEnd     = 0x800000000000ull;\n+  static const uptr kAppMemBeg     = 0x000000001000ull;\n+  static const uptr kAppMemEnd     = 0x100000000000ull;\n+};\n+\n #else\n # error \"Unknown platform\"\n #endif"}, {"sha": "cfe597e5380e5e0320597fa3fd221b26752ba9f0", "filename": "libsanitizer/tsan/tsan_platform_linux.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -391,6 +391,10 @@ static uptr UnmangleLongJmpSp(uptr mangled_sp) {\n   return mangled_sp ^ xor_key;\n #elif defined(__mips__)\n   return mangled_sp;\n+#elif defined(__s390x__)\n+  // tcbhead_t.stack_guard\n+  uptr xor_key = ((uptr *)__builtin_thread_pointer())[5];\n+  return mangled_sp ^ xor_key;\n #else\n   #error \"Unknown platform\"\n #endif\n@@ -411,6 +415,8 @@ static uptr UnmangleLongJmpSp(uptr mangled_sp) {\n #  define LONG_JMP_SP_ENV_SLOT 13\n # elif defined(__mips64)\n #  define LONG_JMP_SP_ENV_SLOT 1\n+# elif defined(__s390x__)\n+#  define LONG_JMP_SP_ENV_SLOT 9\n # else\n #  define LONG_JMP_SP_ENV_SLOT 6\n # endif"}, {"sha": "1c6198cefcd78e54abf229be5e96fe1e9607576c", "filename": "libsanitizer/tsan/tsan_platform_posix.cpp", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -72,11 +72,15 @@ void InitializeShadowMemory() {\n   InitializeShadowMemoryPlatform();\n }\n \n-static void ProtectRange(uptr beg, uptr end) {\n+static bool TryProtectRange(uptr beg, uptr end) {\n   CHECK_LE(beg, end);\n   if (beg == end)\n-    return;\n-  if (beg != (uptr)MmapFixedNoAccess(beg, end - beg)) {\n+    return true;\n+  return beg == (uptr)MmapFixedNoAccess(beg, end - beg);\n+}\n+\n+static void ProtectRange(uptr beg, uptr end) {\n+  if (!TryProtectRange(beg, end)) {\n     Printf(\"FATAL: ThreadSanitizer can not protect [%zx,%zx]\\n\", beg, end);\n     Printf(\"FATAL: Make sure you are not using unlimited stack\\n\");\n     Die();\n@@ -118,6 +122,16 @@ void CheckAndProtect() {\n   ProtectRange(TraceMemEnd(), HeapMemBeg());\n   ProtectRange(HeapEnd(), HiAppMemBeg());\n #endif\n+\n+#if defined(__s390x__)\n+  // Protect the rest of the address space.\n+  const uptr user_addr_max_l4 = 0x0020000000000000ull;\n+  const uptr user_addr_max_l5 = 0xfffffffffffff000ull;\n+  // All the maintained s390x kernels support at least 4-level page tables.\n+  ProtectRange(HiAppMemEnd(), user_addr_max_l4);\n+  // Older s390x kernels may not support 5-level page tables.\n+  TryProtectRange(user_addr_max_l4, user_addr_max_l5);\n+#endif\n }\n #endif\n "}, {"sha": "bcf489a71d55bed3a81a4ccfd03d3e8074f46490", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -77,7 +77,7 @@ void OnInitialize() {\n }\n #endif\n \n-static char thread_registry_placeholder[sizeof(ThreadRegistry)];\n+static ALIGNED(64) char thread_registry_placeholder[sizeof(ThreadRegistry)];\n \n static ThreadContextBase *CreateThreadContext(u32 tid) {\n   // Map thread trace when context is created.\n@@ -115,15 +115,15 @@ static const u32 kThreadQuarantineSize = 64;\n \n Context::Context()\n     : initialized(),\n-      report_mtx(MutexTypeReport, StatMtxReport),\n+      report_mtx(MutexTypeReport),\n       nreported(),\n       nmissed_expected(),\n       thread_registry(new (thread_registry_placeholder) ThreadRegistry(\n           CreateThreadContext, kMaxTid, kThreadQuarantineSize, kMaxTidReuse)),\n-      racy_mtx(MutexTypeRacy, StatMtxRacy),\n+      racy_mtx(MutexTypeRacy),\n       racy_stacks(),\n       racy_addresses(),\n-      fired_suppressions_mtx(MutexTypeFired, StatMtxFired),\n+      fired_suppressions_mtx(MutexTypeFired),\n       clock_alloc(LINKER_INITIALIZED, \"clock allocator\") {\n   fired_suppressions.reserve(8);\n }\n@@ -522,18 +522,14 @@ int Finalize(ThreadState *thr) {\n \n   failed = OnFinalize(failed);\n \n-#if TSAN_COLLECT_STATS\n-  StatAggregate(ctx->stat, thr->stat);\n-  StatOutput(ctx->stat);\n-#endif\n-\n   return failed ? common_flags()->exitcode : 0;\n }\n \n #if !SANITIZER_GO\n-void ForkBefore(ThreadState *thr, uptr pc) {\n+void ForkBefore(ThreadState *thr, uptr pc) NO_THREAD_SAFETY_ANALYSIS {\n   ctx->thread_registry->Lock();\n   ctx->report_mtx.Lock();\n+  ScopedErrorReportLock::Lock();\n   // Suppress all reports in the pthread_atfork callbacks.\n   // Reports will deadlock on the report_mtx.\n   // We could ignore sync operations as well,\n@@ -545,16 +541,18 @@ void ForkBefore(ThreadState *thr, uptr pc) {\n   thr->ignore_interceptors++;\n }\n \n-void ForkParentAfter(ThreadState *thr, uptr pc) {\n+void ForkParentAfter(ThreadState *thr, uptr pc) NO_THREAD_SAFETY_ANALYSIS {\n   thr->suppress_reports--;  // Enabled in ForkBefore.\n   thr->ignore_interceptors--;\n+  ScopedErrorReportLock::Unlock();\n   ctx->report_mtx.Unlock();\n   ctx->thread_registry->Unlock();\n }\n \n-void ForkChildAfter(ThreadState *thr, uptr pc) {\n+void ForkChildAfter(ThreadState *thr, uptr pc) NO_THREAD_SAFETY_ANALYSIS {\n   thr->suppress_reports--;  // Enabled in ForkBefore.\n   thr->ignore_interceptors--;\n+  ScopedErrorReportLock::Unlock();\n   ctx->report_mtx.Unlock();\n   ctx->thread_registry->Unlock();\n \n@@ -693,9 +691,6 @@ ALWAYS_INLINE\n void MemoryAccessImpl1(ThreadState *thr, uptr addr,\n     int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic,\n     u64 *shadow_mem, Shadow cur) {\n-  StatInc(thr, StatMop);\n-  StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n-  StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n \n   // This potentially can live in an MMX/SSE scratch register.\n   // The required intrinsics are:\n@@ -752,7 +747,6 @@ void MemoryAccessImpl1(ThreadState *thr, uptr addr,\n     return;\n   // choose a random candidate slot and replace it\n   StoreShadow(shadow_mem + (cur.epoch() % kShadowCnt), store_word);\n-  StatInc(thr, StatShadowReplace);\n   return;\n  RACE:\n   HandleRace(thr, shadow_mem, cur, old);\n@@ -891,19 +885,11 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   if (!SANITIZER_GO && !kAccessIsWrite && *shadow_mem == kShadowRodata) {\n     // Access to .rodata section, no races here.\n     // Measurements show that it can be 10-20% of all memory accesses.\n-    StatInc(thr, StatMop);\n-    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n-    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n-    StatInc(thr, StatMopRodata);\n     return;\n   }\n \n   FastState fast_state = thr->fast_state;\n   if (UNLIKELY(fast_state.GetIgnoreBit())) {\n-    StatInc(thr, StatMop);\n-    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n-    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n-    StatInc(thr, StatMopIgnored);\n     return;\n   }\n \n@@ -914,10 +900,6 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n \n   if (LIKELY(ContainsSameAccess(shadow_mem, cur.raw(),\n       thr->fast_synch_epoch, kAccessIsWrite))) {\n-    StatInc(thr, StatMop);\n-    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n-    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n-    StatInc(thr, StatMopSame);\n     return;\n   }\n \n@@ -939,10 +921,6 @@ void MemoryAccessImpl(ThreadState *thr, uptr addr,\n     u64 *shadow_mem, Shadow cur) {\n   if (LIKELY(ContainsSameAccess(shadow_mem, cur.raw(),\n       thr->fast_synch_epoch, kAccessIsWrite))) {\n-    StatInc(thr, StatMop);\n-    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n-    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n-    StatInc(thr, StatMopSame);\n     return;\n   }\n \n@@ -999,7 +977,6 @@ static void MemoryRangeSet(ThreadState *thr, uptr pc, uptr addr, uptr size,\n     // Reset middle part.\n     u64 *p1 = p;\n     p = RoundDown(end, kPageSize);\n-    UnmapOrDie((void*)p1, (uptr)p - (uptr)p1);\n     if (!MmapFixedSuperNoReserve((uptr)p1, (uptr)p - (uptr)p1))\n       Die();\n     // Set the ending.\n@@ -1059,7 +1036,6 @@ void MemoryRangeImitateWriteOrResetRange(ThreadState *thr, uptr pc, uptr addr,\n \n ALWAYS_INLINE USED\n void FuncEntry(ThreadState *thr, uptr pc) {\n-  StatInc(thr, StatFuncEnter);\n   DPrintf2(\"#%d: FuncEntry %p\\n\", (int)thr->fast_state.tid(), (void*)pc);\n   if (kCollectHistory) {\n     thr->fast_state.IncrementEpoch();\n@@ -1081,7 +1057,6 @@ void FuncEntry(ThreadState *thr, uptr pc) {\n \n ALWAYS_INLINE USED\n void FuncExit(ThreadState *thr) {\n-  StatInc(thr, StatFuncExit);\n   DPrintf2(\"#%d: FuncExit\\n\", (int)thr->fast_state.tid());\n   if (kCollectHistory) {\n     thr->fast_state.IncrementEpoch();\n@@ -1156,12 +1131,6 @@ void build_consistency_debug() {}\n void build_consistency_release() {}\n #endif\n \n-#if TSAN_COLLECT_STATS\n-void build_consistency_stats() {}\n-#else\n-void build_consistency_nostats() {}\n-#endif\n-\n }  // namespace __tsan\n \n #if !SANITIZER_GO"}, {"sha": "6576d40aa488c285c14f8beef6bd4f46ad63147f", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -399,9 +399,6 @@ struct ThreadState {\n #if !SANITIZER_GO\n   Vector<JmpBuf> jmp_bufs;\n   int ignore_interceptors;\n-#endif\n-#if TSAN_COLLECT_STATS\n-  u64 stat[StatCnt];\n #endif\n   const u32 tid;\n   const int unique_id;\n@@ -550,7 +547,6 @@ struct Context {\n \n   Flags flags;\n \n-  u64 stat[StatCnt];\n   u64 int_alloc_cnt[MBlockTypeCount];\n   u64 int_alloc_siz[MBlockTypeCount];\n };\n@@ -658,22 +654,6 @@ void ObtainCurrentStack(ThreadState *thr, uptr toppc, StackTraceTy *stack,\n   ObtainCurrentStack(thr, pc, &stack); \\\n   stack.ReverseOrder();\n \n-#if TSAN_COLLECT_STATS\n-void StatAggregate(u64 *dst, u64 *src);\n-void StatOutput(u64 *stat);\n-#endif\n-\n-void ALWAYS_INLINE StatInc(ThreadState *thr, StatType typ, u64 n = 1) {\n-#if TSAN_COLLECT_STATS\n-  thr->stat[typ] += n;\n-#endif\n-}\n-void ALWAYS_INLINE StatSet(ThreadState *thr, StatType typ, u64 n) {\n-#if TSAN_COLLECT_STATS\n-  thr->stat[typ] = n;\n-#endif\n-}\n-\n void MapShadow(uptr addr, uptr size);\n void MapThreadTrace(uptr addr, uptr size, const char *name);\n void DontNeedShadowFor(uptr addr, uptr size);\n@@ -854,7 +834,6 @@ void ALWAYS_INLINE TraceAddEvent(ThreadState *thr, FastState fs,\n   DCHECK_GE((int)typ, 0);\n   DCHECK_LE((int)typ, 7);\n   DCHECK_EQ(GetLsb(addr, kEventPCBits), addr);\n-  StatInc(thr, StatEvents);\n   u64 pos = fs.GetTracePos();\n   if (UNLIKELY((pos % kTracePartSize) == 0)) {\n #if !SANITIZER_GO"}, {"sha": "a214a336d69f58ac147f4d3d4d77c33aded851d6", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cpp", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -65,7 +65,6 @@ static void ReportMutexMisuse(ThreadState *thr, uptr pc, ReportType typ,\n \n void MutexCreate(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n   DPrintf(\"#%d: MutexCreate %zx flagz=0x%x\\n\", thr->tid, addr, flagz);\n-  StatInc(thr, StatMutexCreate);\n   if (!(flagz & MutexFlagLinkerInit) && IsAppMem(addr)) {\n     CHECK(!thr->is_freeing);\n     thr->is_freeing = true;\n@@ -81,7 +80,6 @@ void MutexCreate(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n \n void MutexDestroy(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n   DPrintf(\"#%d: MutexDestroy %zx\\n\", thr->tid, addr);\n-  StatInc(thr, StatMutexDestroy);\n   SyncVar *s = ctx->metamap.GetIfExistsAndLock(addr, true);\n   if (s == 0)\n     return;\n@@ -183,11 +181,9 @@ void MutexPostLock(ThreadState *thr, uptr pc, uptr addr, u32 flagz, int rec) {\n   const bool first = s->recursion == 0;\n   s->recursion += rec;\n   if (first) {\n-    StatInc(thr, StatMutexLock);\n     AcquireImpl(thr, pc, &s->clock);\n     AcquireImpl(thr, pc, &s->read_clock);\n   } else if (!s->IsFlagSet(MutexFlagWriteReentrant)) {\n-    StatInc(thr, StatMutexRecLock);\n   }\n   thr->mset.Add(s->GetId(), true, thr->fast_state.epoch());\n   bool pre_lock = false;\n@@ -229,11 +225,9 @@ int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n     rec = (flagz & MutexFlagRecursiveUnlock) ? s->recursion : 1;\n     s->recursion -= rec;\n     if (s->recursion == 0) {\n-      StatInc(thr, StatMutexUnlock);\n       s->owner_tid = kInvalidTid;\n       ReleaseStoreImpl(thr, pc, &s->clock);\n     } else {\n-      StatInc(thr, StatMutexRecUnlock);\n     }\n   }\n   thr->mset.Del(s->GetId(), true);\n@@ -268,7 +262,6 @@ void MutexPreReadLock(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n \n void MutexPostReadLock(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n   DPrintf(\"#%d: MutexPostReadLock %zx flagz=0x%x\\n\", thr->tid, addr, flagz);\n-  StatInc(thr, StatMutexReadLock);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, false);\n@@ -308,7 +301,6 @@ void MutexPostReadLock(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n \n void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: MutexReadUnlock %zx\\n\", thr->tid, addr);\n-  StatInc(thr, StatMutexReadUnlock);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n   SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n@@ -348,7 +340,6 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   if (s->owner_tid == kInvalidTid) {\n     // Seems to be read unlock.\n     write = false;\n-    StatInc(thr, StatMutexReadUnlock);\n     thr->fast_state.IncrementEpoch();\n     TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, s->GetId());\n     ReleaseImpl(thr, pc, &s->read_clock);\n@@ -359,11 +350,9 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     CHECK_GT(s->recursion, 0);\n     s->recursion--;\n     if (s->recursion == 0) {\n-      StatInc(thr, StatMutexUnlock);\n       s->owner_tid = kInvalidTid;\n       ReleaseStoreImpl(thr, pc, &s->clock);\n     } else {\n-      StatInc(thr, StatMutexRecUnlock);\n     }\n   } else if (!s->IsFlagSet(MutexFlagBroken)) {\n     s->SetFlags(MutexFlagBroken);\n@@ -494,7 +483,6 @@ void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n     return;\n   thr->clock.set(thr->fast_state.epoch());\n   thr->clock.acquire(&thr->proc()->clock_cache, c);\n-  StatInc(thr, StatSyncAcquire);\n }\n \n void ReleaseStoreAcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n@@ -503,7 +491,6 @@ void ReleaseStoreAcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n   thr->clock.releaseStoreAcquire(&thr->proc()->clock_cache, c);\n-  StatInc(thr, StatSyncReleaseStoreAcquire);\n }\n \n void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n@@ -512,7 +499,6 @@ void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n   thr->clock.release(&thr->proc()->clock_cache, c);\n-  StatInc(thr, StatSyncRelease);\n }\n \n void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n@@ -521,7 +507,6 @@ void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n   thr->clock.ReleaseStore(&thr->proc()->clock_cache, c);\n-  StatInc(thr, StatSyncRelease);\n }\n \n void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n@@ -530,8 +515,6 @@ void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n   thr->clock.acq_rel(&thr->proc()->clock_cache, c);\n-  StatInc(thr, StatSyncAcquire);\n-  StatInc(thr, StatSyncRelease);\n }\n \n void ReportDeadlock(ThreadState *thr, uptr pc, DDReport *r) {"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "fcff35fbc7e070fa012c0ae856cc3f875d8ba8bf", "filename": "libsanitizer/tsan/tsan_rtl_s390x.S", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_s390x.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_s390x.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_s390x.S?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -0,0 +1,47 @@\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+#define CFA_OFFSET 160\n+#define R2_REL_OFFSET 16\n+#define R3_REL_OFFSET 24\n+#define R14_REL_OFFSET 112\n+#define R15_REL_OFFSET 120\n+#define FRAME_SIZE 160\n+\n+.text\n+\n+ASM_HIDDEN(__tsan_setjmp)\n+\n+.macro intercept symbol, real\n+.comm \\real, 8, 8\n+.globl ASM_SYMBOL_INTERCEPTOR(\\symbol)\n+ASM_TYPE_FUNCTION(ASM_SYMBOL_INTERCEPTOR(\\symbol))\n+ASM_SYMBOL_INTERCEPTOR(\\symbol):\n+  CFI_STARTPROC\n+  stmg %r2, %r3, R2_REL_OFFSET(%r15)\n+  CFI_REL_OFFSET(%r2, R2_REL_OFFSET)\n+  CFI_REL_OFFSET(%r3, R3_REL_OFFSET)\n+  stmg %r14, %r15, R14_REL_OFFSET(%r15)\n+  CFI_REL_OFFSET(%r14, R14_REL_OFFSET)\n+  CFI_REL_OFFSET(%r15, R15_REL_OFFSET)\n+  aghi %r15, -FRAME_SIZE\n+  CFI_ADJUST_CFA_OFFSET(FRAME_SIZE)\n+  la %r2, FRAME_SIZE(%r15)\n+  brasl %r14, ASM_SYMBOL(__tsan_setjmp)\n+  lmg %r14, %r15, FRAME_SIZE + R14_REL_OFFSET(%r15)\n+  CFI_RESTORE(%r14)\n+  CFI_RESTORE(%r15)\n+  CFI_DEF_CFA_OFFSET(CFA_OFFSET)\n+  lmg %r2, %r3, R2_REL_OFFSET(%r15)\n+  CFI_RESTORE(%r2)\n+  CFI_RESTORE(%r3)\n+  larl %r1, \\real\n+  lg %r1, 0(%r1)\n+  br %r1\n+  CFI_ENDPROC\n+  ASM_SIZE(ASM_SYMBOL_INTERCEPTOR(\\symbol))\n+.endm\n+\n+intercept setjmp, _ZN14__interception11real_setjmpE\n+intercept _setjmp, _ZN14__interception12real__setjmpE\n+intercept sigsetjmp, _ZN14__interception14real_sigsetjmpE\n+intercept __sigsetjmp, _ZN14__interception16real___sigsetjmpE"}, {"sha": "cdb6e60ebbd0314b758007272cb0b72ddb50443d", "filename": "libsanitizer/tsan/tsan_rtl_thread.cpp", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -61,8 +61,6 @@ void ThreadContext::OnCreated(void *arg) {\n   TraceAddEvent(args->thr, args->thr->fast_state, EventTypeMop, 0);\n   ReleaseImpl(args->thr, 0, &sync);\n   creation_stack_id = CurrentStackId(args->thr, args->pc);\n-  if (reuse_count == 0)\n-    StatInc(args->thr, StatThreadMaxTid);\n }\n \n void ThreadContext::OnReset() {\n@@ -115,7 +113,6 @@ void ThreadContext::OnStarted(void *arg) {\n \n   thr->fast_synch_epoch = epoch0;\n   AcquireImpl(thr, 0, &sync);\n-  StatInc(thr, StatSyncAcquire);\n   sync.Reset(&thr->proc()->clock_cache);\n   thr->is_inited = true;\n   DPrintf(\"#%d: ThreadStart epoch=%zu stk_addr=%zx stk_size=%zx \"\n@@ -149,9 +146,6 @@ void ThreadContext::OnFinished() {\n   PlatformCleanUpThreadState(thr);\n #endif\n   thr->~ThreadState();\n-#if TSAN_COLLECT_STATS\n-  StatAggregate(ctx->stat, thr->stat);\n-#endif\n   thr = 0;\n }\n \n@@ -232,13 +226,11 @@ int ThreadCount(ThreadState *thr) {\n }\n \n int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n-  StatInc(thr, StatThreadCreate);\n   OnCreatedArgs args = { thr, pc };\n   u32 parent_tid = thr ? thr->tid : kInvalidTid;  // No parent for GCD workers.\n   int tid =\n       ctx->thread_registry->CreateThread(uid, detached, parent_tid, &args);\n   DPrintf(\"#%d: ThreadCreate tid=%d uid=%zu\\n\", parent_tid, tid, uid);\n-  StatSet(thr, StatThreadMaxAlive, ctx->thread_registry->GetMaxAliveThreads());\n   return tid;\n }\n \n@@ -280,7 +272,6 @@ void ThreadStart(ThreadState *thr, int tid, tid_t os_id,\n \n void ThreadFinish(ThreadState *thr) {\n   ThreadCheckIgnore(thr);\n-  StatInc(thr, StatThreadFinish);\n   if (thr->stk_addr && thr->stk_size)\n     DontNeedShadowFor(thr->stk_addr, thr->stk_size);\n   if (thr->tls_addr && thr->tls_size)\n@@ -372,13 +363,10 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n   }\n #endif\n \n-  StatInc(thr, StatMopRange);\n-\n   if (*shadow_mem == kShadowRodata) {\n     DCHECK(!is_write);\n     // Access to .rodata section, no races here.\n     // Measurements show that it can be 10-20% of all memory accesses.\n-    StatInc(thr, StatMopRangeRodata);\n     return;\n   }\n "}, {"sha": "6c703d7f2b1038f4e9717c88d3d177ed2c67eb33", "filename": "libsanitizer/tsan/tsan_stack_trace.cpp", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_stack_trace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_stack_trace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -54,10 +54,8 @@ void __sanitizer::BufferedStackTrace::UnwindImpl(\n     uptr pc, uptr bp, void *context, bool request_fast, u32 max_depth) {\n   uptr top = 0;\n   uptr bottom = 0;\n-  if (StackTrace::WillUseFastUnwind(request_fast)) {\n-    GetThreadStackTopAndBottom(false, &top, &bottom);\n-    Unwind(max_depth, pc, bp, nullptr, top, bottom, true);\n-  } else\n-    Unwind(max_depth, pc, 0, context, 0, 0, false);\n+  GetThreadStackTopAndBottom(false, &top, &bottom);\n+  bool fast = StackTrace::WillUseFastUnwind(request_fast);\n+  Unwind(max_depth, pc, bp, context, top, bottom, fast);\n }\n #endif  // SANITIZER_GO"}, {"sha": "78f3cce913842ac45df6a5b55c6ef6fea86863fe", "filename": "libsanitizer/tsan/tsan_stat.cpp", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Ftsan%2Ftsan_stat.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Ftsan%2Ftsan_stat.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cpp?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,186 +0,0 @@\n-//===-- tsan_stat.cpp -----------------------------------------------------===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of ThreadSanitizer (TSan), a race detector.\n-//\n-//===----------------------------------------------------------------------===//\n-#include \"tsan_stat.h\"\n-#include \"tsan_rtl.h\"\n-\n-namespace __tsan {\n-\n-#if TSAN_COLLECT_STATS\n-\n-void StatAggregate(u64 *dst, u64 *src) {\n-  for (int i = 0; i < StatCnt; i++)\n-    dst[i] += src[i];\n-}\n-\n-void StatOutput(u64 *stat) {\n-  stat[StatShadowNonZero] = stat[StatShadowProcessed] - stat[StatShadowZero];\n-\n-  static const char *name[StatCnt] = {};\n-  name[StatMop]                          = \"Memory accesses                   \";\n-  name[StatMopRead]                      = \"  Including reads                 \";\n-  name[StatMopWrite]                     = \"            writes                \";\n-  name[StatMop1]                         = \"  Including size 1                \";\n-  name[StatMop2]                         = \"            size 2                \";\n-  name[StatMop4]                         = \"            size 4                \";\n-  name[StatMop8]                         = \"            size 8                \";\n-  name[StatMopSame]                      = \"  Including same                  \";\n-  name[StatMopIgnored]                   = \"  Including ignored               \";\n-  name[StatMopRange]                     = \"  Including range                 \";\n-  name[StatMopRodata]                    = \"  Including .rodata               \";\n-  name[StatMopRangeRodata]               = \"  Including .rodata range         \";\n-  name[StatShadowProcessed]              = \"Shadow processed                  \";\n-  name[StatShadowZero]                   = \"  Including empty                 \";\n-  name[StatShadowNonZero]                = \"  Including non empty             \";\n-  name[StatShadowSameSize]               = \"  Including same size             \";\n-  name[StatShadowIntersect]              = \"            intersect             \";\n-  name[StatShadowNotIntersect]           = \"            not intersect         \";\n-  name[StatShadowSameThread]             = \"  Including same thread           \";\n-  name[StatShadowAnotherThread]          = \"            another thread        \";\n-  name[StatShadowReplace]                = \"  Including evicted               \";\n-\n-  name[StatFuncEnter]                    = \"Function entries                  \";\n-  name[StatFuncExit]                     = \"Function exits                    \";\n-  name[StatEvents]                       = \"Events collected                  \";\n-\n-  name[StatThreadCreate]                 = \"Total threads created             \";\n-  name[StatThreadFinish]                 = \"  threads finished                \";\n-  name[StatThreadReuse]                  = \"  threads reused                  \";\n-  name[StatThreadMaxTid]                 = \"  max tid                         \";\n-  name[StatThreadMaxAlive]               = \"  max alive threads               \";\n-\n-  name[StatMutexCreate]                  = \"Mutexes created                   \";\n-  name[StatMutexDestroy]                 = \"  destroyed                       \";\n-  name[StatMutexLock]                    = \"  lock                            \";\n-  name[StatMutexUnlock]                  = \"  unlock                          \";\n-  name[StatMutexRecLock]                 = \"  recursive lock                  \";\n-  name[StatMutexRecUnlock]               = \"  recursive unlock                \";\n-  name[StatMutexReadLock]                = \"  read lock                       \";\n-  name[StatMutexReadUnlock]              = \"  read unlock                     \";\n-\n-  name[StatSyncCreated]                  = \"Sync objects created              \";\n-  name[StatSyncDestroyed]                = \"             destroyed            \";\n-  name[StatSyncAcquire]                  = \"             acquired             \";\n-  name[StatSyncRelease]                  = \"             released             \";\n-\n-  name[StatClockAcquire]                 = \"Clock acquire                     \";\n-  name[StatClockAcquireEmpty]            = \"  empty clock                     \";\n-  name[StatClockAcquireFastRelease]      = \"  fast from release-store         \";\n-  name[StatClockAcquireFull]             = \"  full (slow)                     \";\n-  name[StatClockAcquiredSomething]       = \"  acquired something              \";\n-  name[StatClockRelease]                 = \"Clock release                     \";\n-  name[StatClockReleaseResize]           = \"  resize                          \";\n-  name[StatClockReleaseFast]             = \"  fast                            \";\n-  name[StatClockReleaseSlow]             = \"  dirty overflow (slow)           \";\n-  name[StatClockReleaseFull]             = \"  full (slow)                     \";\n-  name[StatClockReleaseAcquired]         = \"  was acquired                    \";\n-  name[StatClockReleaseClearTail]        = \"  clear tail                      \";\n-  name[StatClockStore]                   = \"Clock release store               \";\n-  name[StatClockStoreResize]             = \"  resize                          \";\n-  name[StatClockStoreFast]               = \"  fast                            \";\n-  name[StatClockStoreFull]               = \"  slow                            \";\n-  name[StatClockStoreTail]               = \"  clear tail                      \";\n-  name[StatClockAcquireRelease]          = \"Clock acquire-release             \";\n-\n-  name[StatAtomic]                       = \"Atomic operations                 \";\n-  name[StatAtomicLoad]                   = \"  Including load                  \";\n-  name[StatAtomicStore]                  = \"            store                 \";\n-  name[StatAtomicExchange]               = \"            exchange              \";\n-  name[StatAtomicFetchAdd]               = \"            fetch_add             \";\n-  name[StatAtomicFetchSub]               = \"            fetch_sub             \";\n-  name[StatAtomicFetchAnd]               = \"            fetch_and             \";\n-  name[StatAtomicFetchOr]                = \"            fetch_or              \";\n-  name[StatAtomicFetchXor]               = \"            fetch_xor             \";\n-  name[StatAtomicFetchNand]              = \"            fetch_nand            \";\n-  name[StatAtomicCAS]                    = \"            compare_exchange      \";\n-  name[StatAtomicFence]                  = \"            fence                 \";\n-  name[StatAtomicRelaxed]                = \"  Including relaxed               \";\n-  name[StatAtomicConsume]                = \"            consume               \";\n-  name[StatAtomicAcquire]                = \"            acquire               \";\n-  name[StatAtomicRelease]                = \"            release               \";\n-  name[StatAtomicAcq_Rel]                = \"            acq_rel               \";\n-  name[StatAtomicSeq_Cst]                = \"            seq_cst               \";\n-  name[StatAtomic1]                      = \"  Including size 1                \";\n-  name[StatAtomic2]                      = \"            size 2                \";\n-  name[StatAtomic4]                      = \"            size 4                \";\n-  name[StatAtomic8]                      = \"            size 8                \";\n-  name[StatAtomic16]                     = \"            size 16               \";\n-\n-  name[StatAnnotation]                   = \"Dynamic annotations               \";\n-  name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";\n-  name[StatAnnotateHappensAfter]         = \"  HappensAfter                    \";\n-  name[StatAnnotateCondVarSignal]        = \"  CondVarSignal                   \";\n-  name[StatAnnotateCondVarSignalAll]     = \"  CondVarSignalAll                \";\n-  name[StatAnnotateMutexIsNotPHB]        = \"  MutexIsNotPHB                   \";\n-  name[StatAnnotateCondVarWait]          = \"  CondVarWait                     \";\n-  name[StatAnnotateRWLockCreate]         = \"  RWLockCreate                    \";\n-  name[StatAnnotateRWLockCreateStatic]   = \"  StatAnnotateRWLockCreateStatic  \";\n-  name[StatAnnotateRWLockDestroy]        = \"  RWLockDestroy                   \";\n-  name[StatAnnotateRWLockAcquired]       = \"  RWLockAcquired                  \";\n-  name[StatAnnotateRWLockReleased]       = \"  RWLockReleased                  \";\n-  name[StatAnnotateTraceMemory]          = \"  TraceMemory                     \";\n-  name[StatAnnotateFlushState]           = \"  FlushState                      \";\n-  name[StatAnnotateNewMemory]            = \"  NewMemory                       \";\n-  name[StatAnnotateNoOp]                 = \"  NoOp                            \";\n-  name[StatAnnotateFlushExpectedRaces]   = \"  FlushExpectedRaces              \";\n-  name[StatAnnotateEnableRaceDetection]  = \"  EnableRaceDetection             \";\n-  name[StatAnnotateMutexIsUsedAsCondVar] = \"  MutexIsUsedAsCondVar            \";\n-  name[StatAnnotatePCQGet]               = \"  PCQGet                          \";\n-  name[StatAnnotatePCQPut]               = \"  PCQPut                          \";\n-  name[StatAnnotatePCQDestroy]           = \"  PCQDestroy                      \";\n-  name[StatAnnotatePCQCreate]            = \"  PCQCreate                       \";\n-  name[StatAnnotateExpectRace]           = \"  ExpectRace                      \";\n-  name[StatAnnotateBenignRaceSized]      = \"  BenignRaceSized                 \";\n-  name[StatAnnotateBenignRace]           = \"  BenignRace                      \";\n-  name[StatAnnotateIgnoreReadsBegin]     = \"  IgnoreReadsBegin                \";\n-  name[StatAnnotateIgnoreReadsEnd]       = \"  IgnoreReadsEnd                  \";\n-  name[StatAnnotateIgnoreWritesBegin]    = \"  IgnoreWritesBegin               \";\n-  name[StatAnnotateIgnoreWritesEnd]      = \"  IgnoreWritesEnd                 \";\n-  name[StatAnnotateIgnoreSyncBegin]      = \"  IgnoreSyncBegin                 \";\n-  name[StatAnnotateIgnoreSyncEnd]        = \"  IgnoreSyncEnd                   \";\n-  name[StatAnnotatePublishMemoryRange]   = \"  PublishMemoryRange              \";\n-  name[StatAnnotateUnpublishMemoryRange] = \"  UnpublishMemoryRange            \";\n-  name[StatAnnotateThreadName]           = \"  ThreadName                      \";\n-  name[Stat__tsan_mutex_create]          = \"  __tsan_mutex_create             \";\n-  name[Stat__tsan_mutex_destroy]         = \"  __tsan_mutex_destroy            \";\n-  name[Stat__tsan_mutex_pre_lock]        = \"  __tsan_mutex_pre_lock           \";\n-  name[Stat__tsan_mutex_post_lock]       = \"  __tsan_mutex_post_lock          \";\n-  name[Stat__tsan_mutex_pre_unlock]      = \"  __tsan_mutex_pre_unlock         \";\n-  name[Stat__tsan_mutex_post_unlock]     = \"  __tsan_mutex_post_unlock        \";\n-  name[Stat__tsan_mutex_pre_signal]      = \"  __tsan_mutex_pre_signal         \";\n-  name[Stat__tsan_mutex_post_signal]     = \"  __tsan_mutex_post_signal        \";\n-  name[Stat__tsan_mutex_pre_divert]      = \"  __tsan_mutex_pre_divert         \";\n-  name[Stat__tsan_mutex_post_divert]     = \"  __tsan_mutex_post_divert        \";\n-\n-  name[StatMtxTotal]                     = \"Contentionz                       \";\n-  name[StatMtxTrace]                     = \"  Trace                           \";\n-  name[StatMtxThreads]                   = \"  Threads                         \";\n-  name[StatMtxReport]                    = \"  Report                          \";\n-  name[StatMtxSyncVar]                   = \"  SyncVar                         \";\n-  name[StatMtxSyncTab]                   = \"  SyncTab                         \";\n-  name[StatMtxSlab]                      = \"  Slab                            \";\n-  name[StatMtxAtExit]                    = \"  Atexit                          \";\n-  name[StatMtxAnnotations]               = \"  Annotations                     \";\n-  name[StatMtxMBlock]                    = \"  MBlock                          \";\n-  name[StatMtxDeadlockDetector]          = \"  DeadlockDetector                \";\n-  name[StatMtxFired]                     = \"  FiredSuppressions               \";\n-  name[StatMtxRacy]                      = \"  RacyStacks                      \";\n-  name[StatMtxFD]                        = \"  FD                              \";\n-  name[StatMtxGlobalProc]                = \"  GlobalProc                      \";\n-\n-  Printf(\"Statistics:\\n\");\n-  for (int i = 0; i < StatCnt; i++)\n-    Printf(\"%s: %16zu\\n\", name[i], (uptr)stat[i]);\n-}\n-\n-#endif\n-\n-}  // namespace __tsan"}, {"sha": "8b26a59bb2ed77f14b592de7c4f6321cebc2519f", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf5b49ebd2176b8c535147377381dd07fbdd643/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=8bf5b49ebd2176b8c535147377381dd07fbdd643", "patch": "@@ -1,191 +0,0 @@\n-//===-- tsan_stat.h ---------------------------------------------*- C++ -*-===//\n-//\n-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n-// See https://llvm.org/LICENSE.txt for license information.\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of ThreadSanitizer (TSan), a race detector.\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#ifndef TSAN_STAT_H\n-#define TSAN_STAT_H\n-\n-namespace __tsan {\n-\n-enum StatType {\n-  // Memory access processing related stuff.\n-  StatMop,\n-  StatMopRead,\n-  StatMopWrite,\n-  StatMop1,  // These must be consequtive.\n-  StatMop2,\n-  StatMop4,\n-  StatMop8,\n-  StatMopSame,\n-  StatMopIgnored,\n-  StatMopRange,\n-  StatMopRodata,\n-  StatMopRangeRodata,\n-  StatShadowProcessed,\n-  StatShadowZero,\n-  StatShadowNonZero,  // Derived.\n-  StatShadowSameSize,\n-  StatShadowIntersect,\n-  StatShadowNotIntersect,\n-  StatShadowSameThread,\n-  StatShadowAnotherThread,\n-  StatShadowReplace,\n-\n-  // Func processing.\n-  StatFuncEnter,\n-  StatFuncExit,\n-\n-  // Trace processing.\n-  StatEvents,\n-\n-  // Threads.\n-  StatThreadCreate,\n-  StatThreadFinish,\n-  StatThreadReuse,\n-  StatThreadMaxTid,\n-  StatThreadMaxAlive,\n-\n-  // Mutexes.\n-  StatMutexCreate,\n-  StatMutexDestroy,\n-  StatMutexLock,\n-  StatMutexUnlock,\n-  StatMutexRecLock,\n-  StatMutexRecUnlock,\n-  StatMutexReadLock,\n-  StatMutexReadUnlock,\n-\n-  // Synchronization.\n-  StatSyncCreated,\n-  StatSyncDestroyed,\n-  StatSyncAcquire,\n-  StatSyncRelease,\n-  StatSyncReleaseStoreAcquire,\n-\n-  // Clocks - acquire.\n-  StatClockAcquire,\n-  StatClockAcquireEmpty,\n-  StatClockAcquireFastRelease,\n-  StatClockAcquireFull,\n-  StatClockAcquiredSomething,\n-  // Clocks - release.\n-  StatClockRelease,\n-  StatClockReleaseResize,\n-  StatClockReleaseFast,\n-  StatClockReleaseSlow,\n-  StatClockReleaseFull,\n-  StatClockReleaseAcquired,\n-  StatClockReleaseClearTail,\n-  // Clocks - release store.\n-  StatClockStore,\n-  StatClockStoreResize,\n-  StatClockStoreFast,\n-  StatClockStoreFull,\n-  StatClockStoreTail,\n-  // Clocks - acquire-release.\n-  StatClockAcquireRelease,\n-\n-  // Atomics.\n-  StatAtomic,\n-  StatAtomicLoad,\n-  StatAtomicStore,\n-  StatAtomicExchange,\n-  StatAtomicFetchAdd,\n-  StatAtomicFetchSub,\n-  StatAtomicFetchAnd,\n-  StatAtomicFetchOr,\n-  StatAtomicFetchXor,\n-  StatAtomicFetchNand,\n-  StatAtomicCAS,\n-  StatAtomicFence,\n-  StatAtomicRelaxed,\n-  StatAtomicConsume,\n-  StatAtomicAcquire,\n-  StatAtomicRelease,\n-  StatAtomicAcq_Rel,\n-  StatAtomicSeq_Cst,\n-  StatAtomic1,\n-  StatAtomic2,\n-  StatAtomic4,\n-  StatAtomic8,\n-  StatAtomic16,\n-\n-  // Dynamic annotations.\n-  StatAnnotation,\n-  StatAnnotateHappensBefore,\n-  StatAnnotateHappensAfter,\n-  StatAnnotateCondVarSignal,\n-  StatAnnotateCondVarSignalAll,\n-  StatAnnotateMutexIsNotPHB,\n-  StatAnnotateCondVarWait,\n-  StatAnnotateRWLockCreate,\n-  StatAnnotateRWLockCreateStatic,\n-  StatAnnotateRWLockDestroy,\n-  StatAnnotateRWLockAcquired,\n-  StatAnnotateRWLockReleased,\n-  StatAnnotateTraceMemory,\n-  StatAnnotateFlushState,\n-  StatAnnotateNewMemory,\n-  StatAnnotateNoOp,\n-  StatAnnotateFlushExpectedRaces,\n-  StatAnnotateEnableRaceDetection,\n-  StatAnnotateMutexIsUsedAsCondVar,\n-  StatAnnotatePCQGet,\n-  StatAnnotatePCQPut,\n-  StatAnnotatePCQDestroy,\n-  StatAnnotatePCQCreate,\n-  StatAnnotateExpectRace,\n-  StatAnnotateBenignRaceSized,\n-  StatAnnotateBenignRace,\n-  StatAnnotateIgnoreReadsBegin,\n-  StatAnnotateIgnoreReadsEnd,\n-  StatAnnotateIgnoreWritesBegin,\n-  StatAnnotateIgnoreWritesEnd,\n-  StatAnnotateIgnoreSyncBegin,\n-  StatAnnotateIgnoreSyncEnd,\n-  StatAnnotatePublishMemoryRange,\n-  StatAnnotateUnpublishMemoryRange,\n-  StatAnnotateThreadName,\n-  Stat__tsan_mutex_create,\n-  Stat__tsan_mutex_destroy,\n-  Stat__tsan_mutex_pre_lock,\n-  Stat__tsan_mutex_post_lock,\n-  Stat__tsan_mutex_pre_unlock,\n-  Stat__tsan_mutex_post_unlock,\n-  Stat__tsan_mutex_pre_signal,\n-  Stat__tsan_mutex_post_signal,\n-  Stat__tsan_mutex_pre_divert,\n-  Stat__tsan_mutex_post_divert,\n-\n-  // Internal mutex contentionz.\n-  StatMtxTotal,\n-  StatMtxTrace,\n-  StatMtxThreads,\n-  StatMtxReport,\n-  StatMtxSyncVar,\n-  StatMtxSyncTab,\n-  StatMtxSlab,\n-  StatMtxAnnotations,\n-  StatMtxAtExit,\n-  StatMtxMBlock,\n-  StatMtxDeadlockDetector,\n-  StatMtxFired,\n-  StatMtxRacy,\n-  StatMtxFD,\n-  StatMtxGlobalProc,\n-\n-  // This must be the last.\n-  StatCnt\n-};\n-\n-}  // namespace __tsan\n-\n-#endif  // TSAN_STAT_H"}, {"sha": "d25434af52a1fd4426588dd92ccc3720088df99a", "filename": "libsanitizer/tsan/tsan_sync.cpp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_sync.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_sync.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -18,10 +18,7 @@ namespace __tsan {\n \n void DDMutexInit(ThreadState *thr, uptr pc, SyncVar *s);\n \n-SyncVar::SyncVar()\n-    : mtx(MutexTypeSyncVar, StatMtxSyncVar) {\n-  Reset(0);\n-}\n+SyncVar::SyncVar() : mtx(MutexTypeSyncVar) { Reset(0); }\n \n void SyncVar::Init(ThreadState *thr, uptr pc, uptr addr, u64 uid) {\n   this->addr = addr;"}, {"sha": "9f2677b778de524b3c70d9a5ac7273d76f7de6fc", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -65,9 +65,7 @@ struct Trace {\n   // CreateThreadContext.\n   TraceHeader headers[kTraceParts];\n \n-  Trace()\n-    : mtx(MutexTypeTrace, StatMtxTrace) {\n-  }\n+  Trace() : mtx(MutexTypeTrace) {}\n };\n \n }  // namespace __tsan"}, {"sha": "d23dfb0ba061c7c693d076fa0fcbf24621b72b8d", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -13,12 +13,10 @@\n // produce sligtly less efficient code.\n //===----------------------------------------------------------------------===//\n do {\n-  StatInc(thr, StatShadowProcessed);\n   const unsigned kAccessSize = 1 << kAccessSizeLog;\n   u64 *sp = &shadow_mem[idx];\n   old = LoadShadow(sp);\n   if (LIKELY(old.IsZero())) {\n-    StatInc(thr, StatShadowZero);\n     if (!stored) {\n       StoreIfNotYetStored(sp, &store_word);\n       stored = true;\n@@ -27,17 +25,14 @@ do {\n   }\n   // is the memory access equal to the previous?\n   if (LIKELY(Shadow::Addr0AndSizeAreEqual(cur, old))) {\n-    StatInc(thr, StatShadowSameSize);\n     // same thread?\n     if (LIKELY(Shadow::TidsAreEqual(old, cur))) {\n-      StatInc(thr, StatShadowSameThread);\n       if (LIKELY(old.IsRWWeakerOrEqual(kAccessIsWrite, kIsAtomic))) {\n         StoreIfNotYetStored(sp, &store_word);\n         stored = true;\n       }\n       break;\n     }\n-    StatInc(thr, StatShadowAnotherThread);\n     if (HappensBefore(old, thr)) {\n       if (old.IsRWWeakerOrEqual(kAccessIsWrite, kIsAtomic)) {\n         StoreIfNotYetStored(sp, &store_word);\n@@ -51,19 +46,14 @@ do {\n   }\n   // Do the memory access intersect?\n   if (Shadow::TwoRangesIntersect(old, cur, kAccessSize)) {\n-    StatInc(thr, StatShadowIntersect);\n-    if (Shadow::TidsAreEqual(old, cur)) {\n-      StatInc(thr, StatShadowSameThread);\n+    if (Shadow::TidsAreEqual(old, cur))\n       break;\n-    }\n-    StatInc(thr, StatShadowAnotherThread);\n     if (old.IsBothReadsOrAtomic(kAccessIsWrite, kIsAtomic))\n       break;\n     if (LIKELY(HappensBefore(old, thr)))\n       break;\n     goto RACE;\n   }\n   // The accesses do not intersect.\n-  StatInc(thr, StatShadowNotIntersect);\n   break;\n } while (0);"}, {"sha": "5526ae051650412ad5fb962fe8c7cf81fbfb4f99", "filename": "libsanitizer/ubsan/ubsan_diag_standalone.cpp", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_diag_standalone.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_diag_standalone.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag_standalone.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -20,11 +20,9 @@ void __sanitizer::BufferedStackTrace::UnwindImpl(\n     uptr pc, uptr bp, void *context, bool request_fast, u32 max_depth) {\n   uptr top = 0;\n   uptr bottom = 0;\n-  if (StackTrace::WillUseFastUnwind(request_fast)) {\n-    GetThreadStackTopAndBottom(false, &top, &bottom);\n-    Unwind(max_depth, pc, bp, nullptr, top, bottom, true);\n-  } else\n-    Unwind(max_depth, pc, bp, context, 0, 0, false);\n+  GetThreadStackTopAndBottom(false, &top, &bottom);\n+  bool fast = StackTrace::WillUseFastUnwind(request_fast);\n+  Unwind(max_depth, pc, bp, context, top, bottom, fast);\n }\n \n extern \"C\" {"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -50,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "e201e6bba22078e3d873aeb5792b98ecd860cdaa", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -894,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -215,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "d2cc2e10bd2f023b8d9aa1685a79a192a6d1e1e8", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e46074e6b3561ae7d8ebd205127f286cc0c6b6/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=90e46074e6b3561ae7d8ebd205127f286cc0c6b6", "patch": "@@ -12,16 +12,14 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n-    defined(__NetBSD__) || defined(__DragonFly__) || \\\n-    (defined(__sun__) && defined(__svr4__)) || \\\n-    defined(_WIN32) || defined(__Fuchsia__) || defined(__rtems__)\n-# define CAN_SANITIZE_UB 1\n+    defined(__NetBSD__) || defined(__DragonFly__) ||                           \\\n+    (defined(__sun__) && defined(__svr4__)) || defined(_WIN32) ||              \\\n+    defined(__Fuchsia__)\n+#define CAN_SANITIZE_UB 1\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}]}