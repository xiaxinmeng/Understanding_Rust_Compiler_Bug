{"sha": "279c9bde625781e47709a2a5900c3c56966e67e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5YzliZGU2MjU3ODFlNDc3MDlhMmE1OTAwYzNjNTY5NjZlNjdlNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-11T04:53:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-11T04:53:33Z"}, "message": "* Automatic generation of inline long call sequences when needed.\n\n\t* pa.h (TARGET_LONG_CALLS): Delete.  Replace all uses of with\n\tTARGET_PORTABLE_RUNTIME.\n\t(TARGET_MILLICODE_LONG_CALLS): New target flag.\n\t* pa.c (output_function_prologue): Keep track of the total number\n\tof code bytes emitted for each source file.\n\t(output_call): Handle TARGET_PORTABLE_RUNTIME and millicode calls\n\tfor TARGET_MILLICODE_LONG_CALLS.  Emit an inline long-call if\n\tneeded.  If emitting an inline long-call, perform argument relocations\n\tbefore the call if they are needed, unfill the delay slot of the\n\tcall if necessary.\n\t* pa.md (define_delay for millicode): Disable the delay slot if\n\tTARGET_MILLICODE_LONG_CALLS.\n\t(millicode insns and indirect calls): Properly compute length for\n\tboth TARGET_PORTABLE_RUNTIME and TARGET_MILLICODE_LONG_CALLS.\n\t(call_internal_symref): Properly compute the length when more\n\tthan 240000 bytes of code have already been output.  Take\n\tTARGET_MILLICODE_LONG_CALLS into account in the length\n\tcomputation.\n\nFrom-SVN: r8422", "tree": {"sha": "f47e4f49d247da38fa20c4e200c92e0ecdfdb123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f47e4f49d247da38fa20c4e200c92e0ecdfdb123"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/279c9bde625781e47709a2a5900c3c56966e67e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279c9bde625781e47709a2a5900c3c56966e67e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279c9bde625781e47709a2a5900c3c56966e67e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279c9bde625781e47709a2a5900c3c56966e67e7/comments", "author": null, "committer": null, "parents": [{"sha": "ba25ac36a7b77df8d3021f270fa28d64997d3d65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba25ac36a7b77df8d3021f270fa28d64997d3d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba25ac36a7b77df8d3021f270fa28d64997d3d65"}], "stats": {"total": 286, "additions": 225, "deletions": 61}, "files": [{"sha": "21d207f421500fb70e53429c373d29dc25ab08ba", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 133, "deletions": 12, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279c9bde625781e47709a2a5900c3c56966e67e7/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279c9bde625781e47709a2a5900c3c56966e67e7/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=279c9bde625781e47709a2a5900c3c56966e67e7", "patch": "@@ -52,6 +52,11 @@ static int gr_saved, fr_saved;\n \n static rtx find_addr_reg ();\n \n+/* Keep track of the number of bytes we have output in the CODE subspaces\n+   during this compilation so we'll know when to emit inline long-calls.  */\n+\n+unsigned int total_code_bytes;\n+\n /* Return non-zero only if OP is a register of mode MODE,\n    or CONST0_RTX.  */\n int\n@@ -72,7 +77,7 @@ call_operand_address (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return (CONSTANT_P (op) && ! TARGET_LONG_CALLS);\n+  return (CONSTANT_P (op) && ! TARGET_PORTABLE_RUNTIME);\n }\n \n /* Return 1 if X contains a symbolic expression.  We know these\n@@ -2044,6 +2049,19 @@ output_function_prologue (file, size)\n   if (profile_flag)\n     ASM_GENERATE_INTERNAL_LABEL (hp_profile_label_name, \"LP\",\n \t\t\t\t hp_profile_labelno);\n+\n+  if (insn_addresses)\n+    {\n+      unsigned int old_total = total_code_bytes;\n+\n+      total_code_bytes += insn_addresses[INSN_UID (get_last_insn())];\n+      total_code_bytes += FUNCTION_BOUNDARY /BITS_PER_UNIT;\n+\n+      /* Be prepared to handle overflows.  */\n+      total_code_bytes = old_total > total_code_bytes ? -1 : total_code_bytes;\n+    }\n+  else\n+    total_code_bytes = -1;\n }\n \n void\n@@ -3760,9 +3778,9 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n    RETURN_POINTER is the register which will hold the return address.\n    %r2 for most calls, %r31 for millicode calls. \n \n-   When TARGET_LONG_CALLS is true, output_call is only called for\n-   millicode calls.  In addition, no delay slots are available when\n-   TARGET_LONG_CALLS is true.  */\n+   When TARGET_MILLICODE_LONG_CALLS is true, then we have to assume\n+   that two instruction sequences must be used to reach the millicode\n+   routines (including dyncall!).  */\n \n char *\n output_call (insn, call_dest, return_pointer)\n@@ -3775,21 +3793,124 @@ output_call (insn, call_dest, return_pointer)\n   rtx xoperands[4];\n   rtx seq_insn;\n \n-  /* Handle common case -- empty delay slot or no jump in the delay slot.  */\n-  if (dbr_sequence_length () == 0\n+  /* Handle long millicode calls for mod, div, and mul.  */\n+  if (TARGET_PORTABLE_RUNTIME\n+      || (TARGET_MILLICODE_LONG_CALLS && REGNO (return_pointer) == 31))\n+    {\n+      xoperands[0] = call_dest;\n+      xoperands[1] = return_pointer;\n+      output_asm_insn (\"ldil L%%%0,%%r29\", xoperands);\n+      output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n+      output_asm_insn (\"blr 0,%r1\\n\\tbv,n 0(%%r29)\\n\\tnop\", xoperands);\n+      return \"\";\n+    }\n+\n+  /* Handle common case -- empty delay slot or no jump in the delay slot,\n+     and we're sure that the branch will reach the beginning of the $CODE$\n+     subspace.  */\n+  if ((dbr_sequence_length () == 0\n+       && get_attr_length (insn) == 8)\n       || (dbr_sequence_length () != 0\n-\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN))\n+\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t  && get_attr_length (insn) == 4))\n     {\n       xoperands[0] = call_dest;\n       xoperands[1] = return_pointer;\n-      if (TARGET_LONG_CALLS)\n+      output_asm_insn (\"bl %0,%r1%#\", xoperands);\n+      return \"\";\n+    }\n+\n+  /* This call may not reach the beginning of the $CODE$ subspace.  */\n+  if (get_attr_length (insn) > 8)\n+    {\n+      int delay_insn_deleted = 0;\n+      rtx xoperands[2];\n+      rtx link;\n+\n+      /* We need to emit an inline long-call branch.  Furthermore,\n+\t because we're changing a named function call into an indirect\n+\t function call well after the parameters have been set up, we\n+\t need to make sure any FP args appear in both the integer\n+\t and FP registers.  Also, we need move any delay slot insn\n+\t out of the delay slot -- Yuk!  */\n+      if (dbr_sequence_length () != 0\n+\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n \t{\n-\t  output_asm_insn (\"ldil L%%%0,%%r29\", xoperands);\n-\t  output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n-\t  output_asm_insn (\"blr 0,%r1\\n\\tbv,n 0(%%r29)\\n\\tnop\", xoperands);\n+\t  /* A non-jump insn in the delay slot.  By definition we can\n+\t  emit this insn before the call (and in fact before argument\n+\t  relocating.  */\n+\t  final_scan_insn (NEXT_INSN (insn), asm_out_file, optimize, 0, 0);\n+\n+\t  /* Now delete the delay insn.  */\n+\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n+\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t  delay_insn_deleted = 1;\n+\t}\n+\n+      /* Now copy any FP arguments into integer registers.  */\n+      for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+\t{\n+\t  int arg_mode, regno;\n+\t  rtx use = XEXP (link, 0);\n+\t  if (! (GET_CODE (use) == USE\n+\t\t && GET_CODE (XEXP (use, 0)) == REG\n+\t\t && FUNCTION_ARG_REGNO_P (REGNO (XEXP (use, 0)))))\n+\t    continue;\n+\n+\t  arg_mode = GET_MODE (XEXP (use, 0));\n+\t  regno = REGNO (XEXP (use, 0));\n+\t  /* Is it a floating point register?  */\n+\t  if (regno >= 32 && regno <= 39)\n+\t    {\n+\t      /* Copy from the FP register into an integer register\n+\t\t (via memory).  */\n+\t      if (arg_mode == SFmode)\n+\t\t{\n+\t\t  xoperands[0] = XEXP (use, 0);\n+\t\t  xoperands[1] = gen_rtx (REG, SImode, 26 - (regno - 32) / 2);\n+\t\t  output_asm_insn (\"fstws %0,-16(%%sr0,%%r30)\", xoperands);\n+\t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  xoperands[0] = XEXP (use, 0);\n+\t\t  xoperands[1] = gen_rtx (REG, DImode, 25 - (regno - 34) / 2);\n+\t\t  output_asm_insn (\"fstds %0,-16(%%sr0,%%r30)\", xoperands);\n+\t\t  output_asm_insn (\"ldw -12(%%sr0,%%r30),%R1\", xoperands);\n+\t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n+\t\t}\n+\t\t\n+\t    }\n+\t}\n+\n+      /* Now emit the inline long-call.  */\n+      xoperands[0] = call_dest;\n+      output_asm_insn (\"ldil L%%%0,%%r22\\n\\tldo R%%%0(%%r22),%%r22\", xoperands);\n+\n+      /* If TARGET_MILLICODE_LONG_CALLS, then we must use a long-call sequence\n+\t to call dyncall!  */\n+      if (TARGET_MILLICODE_LONG_CALLS)\n+\t{\n+\t  output_asm_insn (\"ldil L%%$$dyncall,%%r31\", xoperands);\n+\t  output_asm_insn (\"ldo R%%$$dyncall(%%r31),%%r31\", xoperands);\n+\t  output_asm_insn (\"blr 0,%%r2\\n\\tbv,n 0(%%r31)\\n\\tnop\", xoperands);\n \t}\n       else\n-\toutput_asm_insn (\"bl %0,%r1%#\", xoperands);\n+\toutput_asm_insn (\"bl $$dyncall,%%r31\\n\\tcopy %%r31,%%r2\", xoperands);\n+\n+      /* If we had a jump in the call's delay slot, output it now.  */\n+      if (dbr_sequence_length () != 0\n+\t  && !delay_insn_deleted)\n+\t{\n+\t  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n+\t  output_asm_insn (\"b,n %0\", xoperands);\n+\n+\t  /* Now delete the delay insn.  */\n+\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n+\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t}\n       return \"\";\n     }\n "}, {"sha": "218a97de0bc5bb4890e72969eca61063cef6200e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279c9bde625781e47709a2a5900c3c56966e67e7/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279c9bde625781e47709a2a5900c3c56966e67e7/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=279c9bde625781e47709a2a5900c3c56966e67e7", "patch": "@@ -28,6 +28,9 @@ enum cmp_type\t\t\t\t/* comparison type */\n   CMP_MAX\t\t\t\t/* max comparison type */\n };\n \n+/* For long call handling.  */\n+extern unsigned int total_code_bytes;\n+\n /* Print subsidiary information on the compiler version in use.  */\n \n #define TARGET_VERSION fprintf (stderr, \" (hppa)\");\n@@ -57,13 +60,18 @@ extern int target_flags;\n /* Allow unconditional jumps in the delay slots of call instructions.  */\n #define TARGET_JUMP_IN_DELAY (target_flags & 8)\n \n-/* Force all function calls to indirect addressing via a register.  This\n-   avoids lossage when the function is very far away from the current PC.\n+/* In rare cases, a millicode call via \"bl\" can not be turned into\n+   a millicode call using \"ble\" (when SHLIB_INFO subspace is very large).\n+\n+   This option forces just millicode calls to use inline long-calls\n+   This is far more efficient than the old long-call option which forced\n+   every function to be called indirectly (as is still the case for\n+   TARGET_PORTABLE_RUNTIME).\n \n    ??? What about simple jumps, they can suffer from the same problem.\n    Would require significant surgery in pa.md.  */\n \n-#define TARGET_LONG_CALLS (target_flags & 16)\n+#define TARGET_MILLICODE_LONG_CALLS (target_flags & 16)\n \n /* Disable indexed addressing modes.  */\n \n@@ -73,7 +81,8 @@ extern int target_flags;\n    HP wants everyone to use for ELF objects.  If at all possible you want\n    to avoid this since it's a performance loss for non-prototyped code.\n \n-   Note TARGET_PORTABLE_RUNTIME also implies TARGET_LONG_CALLS.  */\n+   Note TARGET_PORTABLE_RUNTIME also forces all calls to use inline\n+   long-call stubs which is quite expensive.  */\n \n #define TARGET_PORTABLE_RUNTIME (target_flags & 64)\n \n@@ -100,8 +109,8 @@ extern int target_flags;\n    {\"no-fast-indirect-calls\", -4},\\\n    {\"jump-in-delay\", 8},\t\\\n    {\"no-jump-in-delay\", -8},\t\\\n-   {\"long-calls\", 16},\t\t\\\n-   {\"no-long-calls\", -16},\t\\\n+   {\"millicode-long-calls\", 16},\\\n+   {\"no-millicode-long-calls\", -16},\\\n    {\"disable-indexing\", 32},\t\\\n    {\"no-disable-indexing\", -32},\\\n    {\"portable-runtime\", 64+16},\\\n@@ -832,9 +841,7 @@ struct hppa_args {int words, nargs_prototype; };\n    The caller must make a distinction between calls to explicitly named\n    functions and calls through pointers to functions -- the conventions\n    are different!  Calls through pointers to functions only use general\n-   registers for the first four argument words.  Note the indirect function\n-   calling conventions are in effect during TARGET_LONG_CALLS, but \n-   current_call_is_indirect will not be set in such situations. \n+   registers for the first four argument words.\n \n    Of course all this is different for the portable runtime model\n    HP wants everyone to use for ELF.  Ugh.  Here's a quick description\n@@ -869,12 +876,12 @@ struct hppa_args {int words, nargs_prototype; };\n       || !FLOAT_MODE_P (MODE) || (CUM).nargs_prototype > 0)\t\t\\\n       ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n \t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n-\t\t  ? (((!(current_call_is_indirect || TARGET_LONG_CALLS)\t\\\n+\t\t  ? (((!current_call_is_indirect \t\t\t\\\n \t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n \t\t      && (MODE) == DFmode)\t\t\t\t\\\n \t\t     ? ((CUM).words ? 38 : 34)\t\t\t\t\\\n \t\t     : ((CUM).words ? 23 : 25))\t\t\t\t\\\n-\t\t  : (((!(current_call_is_indirect || TARGET_LONG_CALLS)\t\\\n+\t\t  : (((!current_call_is_indirect\t\t\t\\\n \t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n \t\t      && (MODE) == SFmode)\t\t\t\t\\\n \t\t     ? (32 + 2 * (CUM).words)\t\t\t\t\\"}, {"sha": "db6cf972615aba2aa3537fb880b85430aed700ab", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279c9bde625781e47709a2a5900c3c56966e67e7/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279c9bde625781e47709a2a5900c3c56966e67e7/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=279c9bde625781e47709a2a5900c3c56966e67e7", "patch": "@@ -93,10 +93,11 @@\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n ;; millicode call delay slot description.  Note it disallows delay slot\n-;; when TARGET_LONG_CALLS is true.\n+;; when TARGET_PORTABLE_RUNTIME or TARGET_MILLICODE_LONG_CALLS is true.\n (define_delay (eq_attr \"type\" \"milli\")\n   [(and (eq_attr \"in_call_delay\" \"true\")\n-\t(eq (symbol_ref \"TARGET_LONG_CALLS\") (const_int 0)))\n+\t(and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0))\n+\t     (eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\") (const_int 0))))\n    (nil) (nil)])\n \n ;; Unconditional branch, return and other similar instructions.\n@@ -2268,10 +2269,13 @@\n   \"\"\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 24)))])\n \n ;;; Division and mod.\n (define_expand \"divsi3\"\n@@ -2318,10 +2322,13 @@\n   \"*\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 24)))])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -2367,10 +2374,13 @@\n   \"*\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 24)))])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -2412,10 +2422,13 @@\n   \"*\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 24)))])\n \n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -2457,10 +2470,13 @@\n   \"*\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 4)\n+\t\t   (const_int 24)))])\n \n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n@@ -3143,7 +3159,7 @@\n   rtx op;\n   rtx call_insn;\n \n-  if (TARGET_LONG_CALLS)\n+  if (TARGET_PORTABLE_RUNTIME)\n     op = force_reg (SImode, XEXP (operands[0], 0));\n   else\n     op = XEXP (operands[0], 0);\n@@ -3185,14 +3201,21 @@\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (reg:SI 2))\n    (use (const_int 0))]\n-  \"! TARGET_LONG_CALLS\"\n+  \"! TARGET_PORTABLE_RUNTIME\"\n   \"*\n {\n   output_arg_descriptor (insn);\n   return output_call (insn, operands[0], gen_rtx (REG, SImode, 2));\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set_attr \"length\" \"4\")])\n+   (set (attr \"length\")\n+      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+\t\t\t(const_int 240000))\n+\t\t    (const_int 4)\n+\t\t    (if_then_else (ne (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t\t      (const_int 0))\n+\t\t\t\t  (const_int 64)\n+\t\t\t\t  (const_int 52))))])\n \n (define_insn \"call_internal_reg\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n@@ -3206,16 +3229,19 @@\n     return \\\"blr 0,%%r2\\;bv,n 0(%r0)\\;ldo 4(%%r2),%%r2\\\";\n \n   /* Yuk!  bl may not be able to reach $$dyncall.  */\n-  if (TARGET_LONG_CALLS)\n+  if (TARGET_PORTABLE_RUNTIME || TARGET_MILLICODE_LONG_CALLS)\n     return \\\"copy %r0,%%r22\\;ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr 0,%%r2\\;bv,n 0(%%r31)\\;nop\\\";\n   else\n     return \\\"copy %r0,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 12)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(ne (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 12)\n+\t\t   (const_int 24)))])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -3228,7 +3254,7 @@\n   rtx op;\n   rtx call_insn;\n \n-  if (TARGET_LONG_CALLS)\n+  if (TARGET_PORTABLE_RUNTIME)\n     op = force_reg (SImode, XEXP (operands[1], 0));\n   else\n     op = XEXP (operands[1], 0);\n@@ -3275,14 +3301,21 @@\n    (clobber (reg:SI 2))\n    (use (const_int 0))]\n   ;;- Don't use operand 1 for most machines.\n-  \"! TARGET_LONG_CALLS\"\n+  \"! TARGET_PORTABLE_RUNTIME\"\n   \"*\n {\n   output_arg_descriptor (insn);\n   return output_call (insn, operands[1], gen_rtx (REG, SImode, 2));\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set_attr \"length\" \"4\")])\n+   (set (attr \"length\")\n+      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+\t\t\t(const_int 240000))\n+\t\t    (const_int 4)\n+\t\t    (if_then_else (ne (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t\t      (const_int 0))\n+\t\t\t\t  (const_int 64)\n+\t\t\t\t  (const_int 52))))])\n \n (define_insn \"call_value_internal_reg\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -3297,16 +3330,19 @@\n     return \\\"blr 0,%%r2\\;bv,n 0(%r1)\\;ldo 4(%%r2),%%r2\\\";\n \n   /* Yuk!  bl may not be able to reach $$dyncall.  */\n-  if (TARGET_LONG_CALLS)\n+  if (TARGET_PORTABLE_RUNTIME || TARGET_MILLICODE_LONG_CALLS)\n     return \\\"copy %r1,%%r22\\;ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr 0,%%r2\\;bv,n 0(%%r31)\\;nop\\\";\n   else\n     return \\\"copy %r1,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\")\n-\t\t\t\t\t  (const_int 0))\n-\t\t\t\t      (const_int 12)\n-\t\t\t\t      (const_int 24)))])\n+   (set (attr \"length\")\n+     (if_then_else (and (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t\t    (const_int 0))\n+\t\t\t(ne (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_int 12)\n+\t\t   (const_int 24)))])\n \n ;; Call subroutine returning any type.\n "}]}