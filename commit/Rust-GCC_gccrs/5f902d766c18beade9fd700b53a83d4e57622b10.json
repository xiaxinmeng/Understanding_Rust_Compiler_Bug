{"sha": "5f902d766c18beade9fd700b53a83d4e57622b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY5MDJkNzY2YzE4YmVhZGU5ZmQ3MDBiNTNhODNkNGU1NzYyMmIxMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-12T21:32:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-12T21:32:59Z"}, "message": "cgraphbuild.c (build_cgraph_edges, [...]): Build indrect edges too.\n\n\n\t* cgraphbuild.c (build_cgraph_edges, rebuild_cgraph_edges): Build\n\tindrect edges too.\n\t* cgraph.c (cgraph_create_indirect_edge): Take ecf_flags argument.\n\t(cgraph_clone_edge): Update.\n\t(cgraph_node_remove_callees): Remove indirect calls too.\n\t* cgraph.h (cgraph_indirect_call_info): Add ecf_flags.\n\t(cgraph_create_indirect_edge): Update prototype.\n\t* ipa-reference.c (has_proper_scope_for_analysis): Rename to\n\tis_proper_for_analysis.\n\t(add_new_function, visited_nodes, function_insertion_hook_holder,\n\tget_local_reference_vars_info, mark_address_taken, mark_address,\n\tmark_load, mark_store, check_asm_memory_clobber, check_call,\n\tscan_stmt_for_static_refs, scan_initializer_for_static_refs): Remove.\n\t(ipa_init): Do not initialize visited_nodes;\n\tfunction_insertion_hook_holder.\n\t(analyze_variable): Rewrite.\n\t(analyze_function): Rewrite.\n\t(copy_local_bitmap): Remove.\n\t(duplicate_node_dat): Do not duplicate local info.\n\t(generate_summary): Simplify to only walk cgraph.\n\t(write_node_summary_p, ipa_reference_write_summary,\n\tipa_reference_read_summary): Remove.\n\t(propagate): Do not remove function insertion;\n\tgenerate summary.\n\t(pass_ipa_reference): NULLify summary handling fields.\n\t* lto-cgraph.c (lto_output_edge): Output ecf_flags.\n\t(input_edge): Input ecf_flags.\n\t* ipa-prop.c (ipa_note_parm_call): Expect edge to be around.\n\t(update_indirect_edges_after_inlining): Ignore edges with unknown\n\tparam.\n\nFrom-SVN: r159343", "tree": {"sha": "d7aef00d4cbf971dd328d8e3e60c9fd6278373a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7aef00d4cbf971dd328d8e3e60c9fd6278373a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f902d766c18beade9fd700b53a83d4e57622b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f902d766c18beade9fd700b53a83d4e57622b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f902d766c18beade9fd700b53a83d4e57622b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f902d766c18beade9fd700b53a83d4e57622b10/comments", "author": null, "committer": null, "parents": [{"sha": "87a0ebfd203382a034b76c3a087d310908005454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a0ebfd203382a034b76c3a087d310908005454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87a0ebfd203382a034b76c3a087d310908005454"}], "stats": {"total": 665, "additions": 185, "deletions": 480}, "files": [{"sha": "8d8f5b465a8b2129f559908c5a896b3a357ef167", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -1,3 +1,36 @@\n+2010-05-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (build_cgraph_edges, rebuild_cgraph_edges): Build\n+\tindrect edges too.\n+\t* cgraph.c (cgraph_create_indirect_edge): Take ecf_flags argument.\n+\t(cgraph_clone_edge): Update.\n+\t(cgraph_node_remove_callees): Remove indirect calls too.\n+\t* cgraph.h (cgraph_indirect_call_info): Add ecf_flags.\n+\t(cgraph_create_indirect_edge): Update prototype.\n+\t* ipa-reference.c (has_proper_scope_for_analysis): Rename to\n+\tis_proper_for_analysis.\n+\t(add_new_function, visited_nodes, function_insertion_hook_holder,\n+\tget_local_reference_vars_info, mark_address_taken, mark_address,\n+\tmark_load, mark_store, check_asm_memory_clobber, check_call,\n+\tscan_stmt_for_static_refs, scan_initializer_for_static_refs): Remove.\n+\t(ipa_init): Do not initialize visited_nodes;\n+\tfunction_insertion_hook_holder.\n+\t(analyze_variable): Rewrite.\n+\t(analyze_function): Rewrite.\n+\t(copy_local_bitmap): Remove.\n+\t(duplicate_node_dat): Do not duplicate local info.\n+\t(generate_summary): Simplify to only walk cgraph.\n+\t(write_node_summary_p, ipa_reference_write_summary,\n+\tipa_reference_read_summary): Remove.\n+\t(propagate): Do not remove function insertion;\n+\tgenerate summary.\n+\t(pass_ipa_reference): NULLify summary handling fields.\n+\t* lto-cgraph.c (lto_output_edge): Output ecf_flags.\n+\t(input_edge): Input ecf_flags.\n+\t* ipa-prop.c (ipa_note_parm_call): Expect edge to be around.\n+\t(update_indirect_edges_after_inlining): Ignore edges with unknown\n+\tparam.\n+\n 2010-05-12  Sriraman Tallam  <tmsriram@google.com>\n \n \t* implicit-zee.c: New file."}, {"sha": "b16a10d3f629b59d80bf7bb1b204bcef1ee49b9a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -1036,6 +1036,7 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n \n struct cgraph_edge *\n cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n+\t\t\t     int ecf_flags,\n \t\t\t     gcov_type count, int freq, int nest)\n {\n   struct cgraph_edge *edge = cgraph_create_edge_1 (caller, NULL, call_stmt,\n@@ -1046,6 +1047,7 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n \n   edge->indirect_info = GGC_NEW (struct cgraph_indirect_call_info);\n   edge->indirect_info->param_index = -1;\n+  edge->indirect_info->ecf_flags = ecf_flags;\n \n   edge->next_callee = caller->indirect_calls;\n   if (caller->indirect_calls)\n@@ -1292,6 +1294,15 @@ cgraph_node_remove_callees (struct cgraph_node *node)\n \tcgraph_edge_remove_callee (e);\n       cgraph_free_edge (e);\n     }\n+  for (e = node->indirect_calls; e; e = f)\n+    {\n+      f = e->next_callee;\n+      cgraph_call_edge_removal_hooks (e);\n+      if (!e->indirect_unknown_callee)\n+\tcgraph_edge_remove_callee (e);\n+      cgraph_free_edge (e);\n+    }\n+  node->indirect_calls = NULL;\n   node->callees = NULL;\n   if (node->call_site_hash)\n     {\n@@ -2009,7 +2020,9 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t}\n       else\n \t{\n-\t  new_edge = cgraph_create_indirect_edge (n, call_stmt, count, freq,\n+\t  new_edge = cgraph_create_indirect_edge (n, call_stmt,\n+\t\t\t\t\t\t  e->indirect_info->ecf_flags,\n+\t\t\t\t\t\t  count, freq,\n \t\t\t\t\t\t  e->loop_nest + loop_nest);\n \t  new_edge->indirect_info->param_index = e->indirect_info->param_index;\n \t}"}, {"sha": "dbfc89f8f1d37f532c31b45ebaded113f71b392e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -376,6 +376,8 @@ struct GTY(()) cgraph_indirect_call_info\n {\n   /* Index of the parameter that is called.  */\n   int param_index;\n+  /* ECF flags determined from the caller.  */\n+  int ecf_flags;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {\n@@ -519,7 +521,7 @@ void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n \t\t\t\t\tgimple, gcov_type, int, int);\n-struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n+struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple, int,\n \t\t\t\t\t\t gcov_type, int, int);\n struct cgraph_node * cgraph_get_node (tree);\n struct cgraph_node *cgraph_node (tree);"}, {"sha": "c63b5afc81c1c56adaa6526e144fb3e34076acc4", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -339,12 +339,21 @@ build_cgraph_edges (void)\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree decl;\n \n-\t  if (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n-\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count,\n-\t\t\t\tcompute_call_stmt_bb_frequency\n-\t\t\t\t  (current_function_decl, bb),\n-\t\t\t\tbb->loop_depth);\n+\t  if (is_gimple_call (stmt))\n+\t    {\n+\t      int freq = compute_call_stmt_bb_frequency (current_function_decl,\n+\t\t\t\t\t\t\t bb);\n+\t      decl = gimple_call_fndecl (stmt);\n+\t      if (decl)\n+\t\tcgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t\t    bb->count, freq,\n+\t\t\t\t    bb->loop_depth);\n+\t      else\n+\t\tcgraph_create_indirect_edge (node, stmt,\n+\t\t\t\t\t     gimple_call_flags (stmt),\n+\t\t\t\t\t     bb->count, freq,\n+\t\t\t\t\t     bb->loop_depth);\n+\t    }\n \t  walk_stmt_load_store_addr_ops (stmt, node, mark_load,\n \t\t\t\t\t mark_store, mark_address);\n \t  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n@@ -443,12 +452,21 @@ rebuild_cgraph_edges (void)\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree decl;\n \n-\t  if (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n-\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count,\n-\t\t\t\tcompute_call_stmt_bb_frequency\n-\t\t\t\t  (current_function_decl, bb),\n-\t\t\t\tbb->loop_depth);\n+\t  if (is_gimple_call (stmt))\n+\t    {\n+\t      int freq = compute_call_stmt_bb_frequency (current_function_decl,\n+\t\t\t\t\t\t\t bb);\n+\t      decl = gimple_call_fndecl (stmt);\n+\t      if (decl)\n+\t\tcgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t\t    bb->count, freq,\n+\t\t\t\t    bb->loop_depth);\n+\t      else\n+\t\tcgraph_create_indirect_edge (node, stmt,\n+\t\t\t\t\t     gimple_call_flags (stmt),\n+\t\t\t\t\t     bb->count, freq,\n+\t\t\t\t\t     bb->loop_depth);\n+\t    }\n \t  walk_stmt_load_store_addr_ops (stmt, node, mark_load,\n \t\t\t\t\t mark_store, mark_address);\n "}, {"sha": "d40fe448a3a948d2d061e03a4503e34ad67700a5", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -757,12 +757,8 @@ static void\n ipa_note_param_call (struct cgraph_node *node, int formal_id, gimple stmt)\n {\n   struct cgraph_edge *cs;\n-  basic_block bb = gimple_bb (stmt);\n-  int freq;\n \n-  freq = compute_call_stmt_bb_frequency (current_function_decl, bb);\n-  cs = cgraph_create_indirect_edge (node, stmt, bb->count, freq,\n-\t\t\t\t    bb->loop_depth);\n+  cs = cgraph_edge (node, stmt);\n   cs->indirect_info->param_index = formal_id;\n }\n \n@@ -1071,7 +1067,8 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \n       /* If we ever use indirect edges for anything other than indirect\n \t inlining, we will need to skip those with negative param_indices. */\n-      gcc_assert (ici->param_index >= 0);\n+      if (ici->param_index == -1)\n+\tcontinue;\n \n       /* We must check range due to calls with variable number of arguments:  */\n       if (ici->param_index >= ipa_get_cs_argument_count (top))"}, {"sha": "184229d1a2c0b09416778c47d506e11a9f1fd331", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 69, "deletions": 459, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -71,8 +71,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"lto-streamer.h\"\n \n-static void add_new_function (struct cgraph_node *node,\n-\t\t\t      void *data ATTRIBUTE_UNUSED);\n static void remove_node_data (struct cgraph_node *node,\n \t\t\t      void *data ATTRIBUTE_UNUSED);\n static void duplicate_node_data (struct cgraph_node *src,\n@@ -147,16 +145,13 @@ static bitmap module_statics_written;\n    memory. */\n static bitmap all_module_statics;\n \n-static struct pointer_set_t *visited_nodes;\n-\n /* Obstack holding bitmaps of local analysis (live from analysis to\n    propagation)  */\n static bitmap_obstack local_info_obstack;\n /* Obstack holding global analysis live forever.  */\n static bitmap_obstack global_info_obstack;\n \n /* Holders of ipa cgraph hooks: */\n-static struct cgraph_node_hook_list *function_insertion_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n \n@@ -194,20 +189,6 @@ set_reference_vars_info (struct cgraph_node *node, ipa_reference_vars_info_t inf\n   VEC_replace (ipa_reference_vars_info_t, ipa_reference_vars_vector, node->uid, info);\n }\n \n-/* Get a bitmap that contains all of the locally referenced static\n-   variables for function FN.  */\n-static ipa_reference_local_vars_info_t\n-get_local_reference_vars_info (struct cgraph_node *fn)\n-{\n-  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n-\n-  if (info)\n-    return info->local;\n-  else\n-    /* This phase was not run.  */\n-    return NULL;\n-}\n-\n /* Get a bitmap that contains all of the globally referenced static\n    variables for function FN.  */\n \n@@ -303,7 +284,7 @@ add_static_var (tree var)\n    perform compilation unit scope escape analysis.  */\n \n static inline bool\n-has_proper_scope_for_analysis (tree t)\n+is_proper_for_analysis (tree t)\n {\n   /* If the variable has the \"used\" attribute, treat it as if it had a\n      been touched by the devil.  */\n@@ -315,15 +296,6 @@ has_proper_scope_for_analysis (tree t)\n   if (TREE_THIS_VOLATILE (t))\n     return false;\n \n-  /* Do not care about a local automatic that is not static.  */\n-  if (!TREE_STATIC (t) && !DECL_EXTERNAL (t))\n-    return false;\n-\n-  /* FIXME: for LTO we should include PUBLIC vars too.  This is bit difficult\n-     as summarie would need unsharing.  */\n-  if (DECL_EXTERNAL (t) || TREE_PUBLIC (t))\n-    return false;\n-\n   /* We cannot touch decls where the type needs constructing.  */\n   if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (t)))\n     return false;\n@@ -336,160 +308,6 @@ has_proper_scope_for_analysis (tree t)\n   return true;\n }\n \n-/* Mark tree T as having address taken.  */\n-\n-static void\n-mark_address_taken (tree x)\n-{\n-  if (TREE_CODE (x) == VAR_DECL\n-      && module_statics_escape && has_proper_scope_for_analysis (x))\n-    bitmap_set_bit (module_statics_escape, DECL_UID (x));\n-}\n-\n-/* Wrapper around mark_address_taken for the stmt walker.  */\n-\n-static bool\n-mark_address (gimple stmt ATTRIBUTE_UNUSED, tree addr,\n-\t      void *data ATTRIBUTE_UNUSED)\n-{\n-  addr = get_base_address (addr);\n-  if (addr)\n-    mark_address_taken (addr);\n-  return false;\n-}\n-\n-/* Mark load of T.  */\n-\n-static bool\n-mark_load (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n-{\n-  ipa_reference_local_vars_info_t local = (ipa_reference_local_vars_info_t)data;\n-  t = get_base_address (t);\n-  if (t && TREE_CODE (t) == VAR_DECL\n-      && has_proper_scope_for_analysis (t))\n-    bitmap_set_bit (local->statics_read, DECL_UID (t));\n-  return false;\n-}\n-\n-/* Mark store of T.  */\n-\n-static bool\n-mark_store (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n-{\n-  ipa_reference_local_vars_info_t local = (ipa_reference_local_vars_info_t)data;\n-  t = get_base_address (t);\n-  if (t && TREE_CODE (t) == VAR_DECL\n-      && has_proper_scope_for_analysis (t))\n-    {\n-      if (local)\n-\tbitmap_set_bit (local->statics_written, DECL_UID (t));\n-      /* Mark the write so we can tell which statics are\n-\t readonly.  */\n-      if (module_statics_written)\n-\tbitmap_set_bit (module_statics_written, DECL_UID (t));\n-    }\n-  return false;\n-}\n-\n-/* Look for memory clobber and set read_all/write_all if present.  */\n-\n-static void\n-check_asm_memory_clobber (ipa_reference_local_vars_info_t local, gimple stmt)\n-{\n-  size_t i;\n-  tree op;\n-\n-  for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n-    {\n-      op = gimple_asm_clobber_op (stmt, i);\n-      if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1)\n-\t{\n-\t  /* Abandon all hope, ye who enter here. */\n-\t  local->calls_read_all = true;\n-\t  local->calls_write_all = true;\n-\t}\n-    }\n-}\n-\n-/* Look for external calls and set read_all/write_all correspondingly.  */\n-\n-static void\n-check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n-{\n-  int flags = gimple_call_flags (stmt);\n-  tree callee_t = gimple_call_fndecl (stmt);\n-\n-  /* Process indirect calls.  All direct calles are handled at propagation\n-     time.  */\n-  if (!callee_t)\n-    {\n-      if (flags & ECF_CONST)\n-\t;\n-      else if (flags & ECF_PURE)\n-\tlocal->calls_read_all = true;\n-      else\n-\t{\n-\t  local->calls_read_all = true;\n-\t  /* When function does not reutrn, it is safe to ignore anythign it writes\n-\t     to, because the effect will never happen.  */\n-\t  if ((flags & (ECF_NOTHROW | ECF_NORETURN))\n-\t      != (ECF_NOTHROW | ECF_NORETURN))\n-\t    local->calls_write_all = true;\n-\t}\n-    }\n-}\n-\n-/* TP is the part of the tree currently under the microscope.\n-   WALK_SUBTREES is part of the walk_tree api but is unused here.\n-   DATA is cgraph_node of the function being walked.  */\n-\n-static tree\n-scan_stmt_for_static_refs (gimple_stmt_iterator *gsip,\n-\t\t\t   struct cgraph_node *fn)\n-{\n-  gimple stmt = gsi_stmt (*gsip);\n-  ipa_reference_local_vars_info_t local = NULL;\n-\n-  if (is_gimple_debug (stmt))\n-    return NULL;\n-\n-  if (fn)\n-    local = get_reference_vars_info (fn)->local;\n-\n-  /* Look for direct loads and stores.  */\n-  walk_stmt_load_store_addr_ops (stmt, local, mark_load, mark_store,\n-\t\t\t\t mark_address);\n-\n-  if (is_gimple_call (stmt))\n-    check_call (local, stmt);\n-  else if (gimple_code (stmt) == GIMPLE_ASM)\n-    check_asm_memory_clobber (local, stmt);\n-\n-  return NULL;\n-}\n-\n-/* Call-back to scan variable initializers for static references.\n-   Called using walk_tree.  */\n-\n-static tree\n-scan_initializer_for_static_refs (tree *tp, int *walk_subtrees,\n-\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-\n-  if (TREE_CODE (t) == ADDR_EXPR)\n-    {\n-      mark_address_taken (get_base_var (t));\n-      *walk_subtrees = 0;\n-    }\n-  /* Save some cycles by not walking types and declaration as we\n-     won't find anything useful there anyway.  */\n-  else if (IS_TYPE_OR_DECL_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  return NULL;\n-}\n-\n /* Lookup the tree node for the static variable that has UID.  */\n static tree\n get_static_decl (int index)\n@@ -604,14 +422,6 @@ ipa_init (void)\n   module_statics_written = BITMAP_ALLOC (&local_info_obstack);\n   all_module_statics = BITMAP_ALLOC (&global_info_obstack);\n \n-  /* There are some shared nodes, in particular the initializers on\n-     static declarations.  We do not need to scan them more than once\n-     since all we would be interested in are the addressof\n-     operations.  */\n-  visited_nodes = pointer_set_create ();\n-\n-  function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n   node_removal_hook_holder =\n       cgraph_add_node_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n@@ -627,13 +437,29 @@ ipa_init (void)\n static void\n analyze_variable (struct varpool_node *vnode)\n {\n-  struct walk_stmt_info wi;\n-  tree global = vnode->decl;\n-\n-  memset (&wi, 0, sizeof (wi));\n-  wi.pset = visited_nodes;\n-  walk_tree (&DECL_INITIAL (global), scan_initializer_for_static_refs,\n-             &wi, wi.pset);\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref); i++)\n+    {\n+      tree var;\n+      if (ref->refered_type != IPA_REF_VARPOOL)\n+\tcontinue;\n+      var = ipa_ref_varpool_node (ref)->decl;\n+      if (ipa_ref_varpool_node (ref)->externally_visible\n+\t  || !ipa_ref_varpool_node (ref)->analyzed\n+\t  || !is_proper_for_analysis (var))\n+\tcontinue;\n+      switch (ref->use)\n+\t{\n+\tcase IPA_REF_LOAD:\n+\tcase IPA_REF_STORE:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase IPA_REF_ADDR:\n+\t  bitmap_set_bit (module_statics_escape, DECL_UID (var));\n+\t  break;\n+\t}\n+    }\n }\n \n \n@@ -664,49 +490,49 @@ init_function_info (struct cgraph_node *fn)\n static void\n analyze_function (struct cgraph_node *fn)\n {\n-  tree decl = fn->decl;\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n-  basic_block this_block;\n-#ifdef ENABLE_CHECKING\n-  tree step;\n-#endif\n   ipa_reference_local_vars_info_t local;\n+  struct ipa_ref *ref;\n+  int i;\n+  tree var;\n+  struct cgraph_edge *ie;\n \n-  if (dump_file)\n-    fprintf (dump_file, \"\\n local analysis of %s\\n\", cgraph_node_name (fn));\n-\n-  push_cfun (DECL_STRUCT_FUNCTION (decl));\n-  current_function_decl = decl;\n-\n-  init_function_info (fn);\n-  FOR_EACH_BB_FN (this_block, this_cfun)\n+  local = init_function_info (fn);\n+  /* Process indirect calls.  All direct calles are handled at propagation\n+     time.  */\n+  for (ie = fn->indirect_calls; ie; ie = ie->next_callee)\n+    if (!(ie->indirect_info->ecf_flags & ECF_CONST))\n+      {\n+        local->calls_read_all = true;\n+        if (!(ie->indirect_info->ecf_flags & ECF_PURE)\n+\t    && ((ie->indirect_info->ecf_flags & (ECF_NOTHROW | ECF_NORETURN))\n+\t\t!=  (ECF_NOTHROW | ECF_NORETURN)))\n+\t  local->calls_write_all = true;\n+      }\n+  for (i = 0; ipa_ref_list_reference_iterate (&fn->ref_list, i, ref); i++)\n     {\n-      gimple_stmt_iterator gsi;\n-      gimple phi;\n-      tree op;\n-      use_operand_p use;\n-      ssa_op_iter iter;\n-\n-      /* Find the addresses taken in phi node arguments.  */\n-      for (gsi = gsi_start_phis (this_block);\n-\t   !gsi_end_p (gsi);\n-\t   gsi_next (&gsi))\n+      if (ref->refered_type != IPA_REF_VARPOOL)\n+\tcontinue;\n+      var = ipa_ref_varpool_node (ref)->decl;\n+      if (ipa_ref_varpool_node (ref)->externally_visible\n+\t  || !ipa_ref_varpool_node (ref)->analyzed\n+\t  || !is_proper_for_analysis (var))\n+\tcontinue;\n+      switch (ref->use)\n \t{\n-\t  phi = gsi_stmt (gsi);\n-\t  FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n-\t    {\n-\t      op = USE_FROM_PTR (use);\n-\t      if (TREE_CODE (op) == ADDR_EXPR)\n-\t\tmark_address_taken (get_base_var (op));\n-\t    }\n+\tcase IPA_REF_LOAD:\n+          bitmap_set_bit (local->statics_read, DECL_UID (var));\n+\t  break;\n+\tcase IPA_REF_STORE:\n+          bitmap_set_bit (local->statics_written, DECL_UID (var));\n+\t  bitmap_set_bit (module_statics_written, DECL_UID (var));\n+\t  break;\n+\tcase IPA_REF_ADDR:\n+\t  bitmap_set_bit (module_statics_escape, DECL_UID (var));\n+\t  break;\n \t}\n-\n-      for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tscan_stmt_for_static_refs (&gsi, fn);\n     }\n \n-  local = get_reference_vars_info (fn)->local;\n-  if ((flags_from_decl_or_type (decl) & (ECF_NOTHROW | ECF_NORETURN))\n+  if ((flags_from_decl_or_type (fn->decl) & (ECF_NOTHROW | ECF_NORETURN))\n       == (ECF_NOTHROW | ECF_NORETURN))\n     {\n       local->calls_write_all = false;\n@@ -718,23 +544,6 @@ analyze_function (struct cgraph_node *fn)\n     BITMAP_FREE (local->statics_written);\n   if (local->calls_read_all)\n     BITMAP_FREE (local->statics_read);\n-\n-\n-#ifdef ENABLE_CHECKING\n-  /* Verify that all local initializers was expanded by gimplifier.  */\n-  for (step = DECL_STRUCT_FUNCTION (decl)->local_decls;\n-       step;\n-       step = TREE_CHAIN (step))\n-    {\n-      tree var = TREE_VALUE (step);\n-      if (TREE_CODE (var) == VAR_DECL\n-\t  && DECL_INITIAL (var)\n-\t  && !TREE_STATIC (var))\n-\tgcc_unreachable ();\n-    }\n-#endif\n-  pop_cfun ();\n-  current_function_decl = NULL;\n }\n \n /* Remove local data associated with function FN.  */\n@@ -790,31 +599,6 @@ clean_function (struct cgraph_node *fn)\n   set_reference_vars_info (fn, NULL);\n }\n \n-/* Called when new function is inserted to callgraph late.  */\n-static void\n-add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n-{\n-  /* There are some shared nodes, in particular the initializers on\n-     static declarations.  We do not need to scan them more than once\n-     since all we would be interested in are the addressof\n-     operations.  */\n-  analyze_function (node);\n-  visited_nodes = NULL;\n-}\n-\n-static bitmap\n-copy_local_bitmap (bitmap src)\n-{\n-  bitmap dst;\n-  if (!src)\n-    return NULL;\n-  if (src == all_module_statics)\n-    return all_module_statics;\n-  dst = BITMAP_ALLOC (&local_info_obstack);\n-  bitmap_copy (dst, src);\n-  return dst;\n-}\n-\n static bitmap\n copy_global_bitmap (bitmap src)\n {\n@@ -828,30 +612,20 @@ copy_global_bitmap (bitmap src)\n   return dst;\n }\n \n+\n /* Called when new clone is inserted to callgraph late.  */\n \n static void\n duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n \t \t     void *data ATTRIBUTE_UNUSED)\n {\n   ipa_reference_global_vars_info_t ginfo;\n-  ipa_reference_local_vars_info_t linfo;\n   ipa_reference_global_vars_info_t dst_ginfo;\n-  ipa_reference_local_vars_info_t dst_linfo;\n \n   ginfo = get_global_reference_vars_info (src);\n-  linfo = get_local_reference_vars_info (src);\n-  if (!linfo && !ginfo)\n+  if (!ginfo)\n     return;\n   init_function_info (dst);\n-  if (linfo)\n-    {\n-      dst_linfo = get_local_reference_vars_info (dst);\n-      dst_linfo->statics_read = copy_local_bitmap (linfo->statics_read);\n-      dst_linfo->statics_written = copy_local_bitmap (linfo->statics_written);\n-      dst_linfo->calls_read_all = linfo->calls_read_all;\n-      dst_linfo->calls_write_all = linfo->calls_write_all;\n-    }\n   if (ginfo)\n     {\n       get_reference_vars_info (dst)->global = XCNEW (struct ipa_reference_global_vars_info_d);\n@@ -893,24 +667,11 @@ generate_summary (void)\n   FOR_EACH_STATIC_INITIALIZER (vnode)\n     analyze_variable (vnode);\n \n-  /* Process all of the functions next.\n-\n-     We do not want to process any of the clones so we check that this\n-     is a master clone.  However, we do need to process any\n-     AVAIL_OVERWRITABLE functions (these are never clones) because\n-     they may cause a static variable to escape.  The code that can\n-     overwrite such a function cannot access the statics because it\n-     would not be in the same compilation unit.  When the analysis is\n-     finished, the computed information of these AVAIL_OVERWRITABLE is\n-     replaced with worst case info.\n-  */\n+  /* Process all of the functions next.  */\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+    if (node->analyzed)\n       analyze_function (node);\n \n-  pointer_set_destroy (visited_nodes);\n-  visited_nodes = NULL;\n-\n   /* Prune out the variables that were found to behave badly\n      (i.e. have their address taken).  */\n   EXECUTE_IF_SET_IN_BITMAP (module_statics_escape, 0, index, bi)\n@@ -1024,158 +785,6 @@ generate_summary (void)\n \t     fprintf (dump_file, \"\\n  calls read all: \");\n \t}\n }\n-\n-\n-/* Return true if we need to write summary of NODE. */\n-\n-static bool\n-write_node_summary_p (struct cgraph_node *node)\n-{\n-  gcc_assert (node->global.inlined_to == NULL);\n-  return (node->analyzed\n-\t  && cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE\n-\t  && get_reference_vars_info (node) != NULL);\n-}\n-\n-/* Serialize the ipa info for lto.  */\n-\n-static void\n-ipa_reference_write_summary (cgraph_node_set set,\n-\t\t\t     varpool_node_set vset ATTRIBUTE_UNUSED)\n-{\n-  struct cgraph_node *node;\n-  struct lto_simple_output_block *ob\n-    = lto_create_simple_output_block (LTO_section_ipa_reference);\n-  unsigned int count = 0;\n-  cgraph_node_set_iterator csi;\n-\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-    if (write_node_summary_p (csi_node (csi)))\n-\tcount++;\n-\n-  lto_output_uleb128_stream (ob->main_stream, count);\n-\n-  /* Process all of the functions.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-    {\n-      node = csi_node (csi);\n-      if (write_node_summary_p (node))\n-\t{\n-\t  ipa_reference_local_vars_info_t l\n-\t    = get_reference_vars_info (node)->local;\n-\t  unsigned int index;\n-\t  bitmap_iterator bi;\n-\t  lto_cgraph_encoder_t encoder;\n-\t  int node_ref;\n-\n-\t  encoder = ob->decl_state->cgraph_node_encoder;\n-\t  node_ref = lto_cgraph_encoder_encode (encoder, node);\n-\t  lto_output_uleb128_stream (ob->main_stream, node_ref);\n-\n-\t  /* Stream out the statics read.  */\n-\t  if (l->calls_read_all)\n-\t    lto_output_sleb128_stream (ob->main_stream, -1);\n-\t  else\n-\t    {\n-\t      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t\t bitmap_count_bits (l->statics_read));\n-\t      EXECUTE_IF_SET_IN_BITMAP (l->statics_read, 0, index, bi)\n-\t\tlto_output_var_decl_index(ob->decl_state, ob->main_stream,\n-\t\t\t\t\t  get_static_decl (index));\n-\t    }\n-\n-\t  /* Stream out the statics written.  */\n-\t  if (l->calls_write_all)\n-\t    lto_output_sleb128_stream (ob->main_stream, -1);\n-\t  else\n-\t    {\n-\t      lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t\t bitmap_count_bits (l->statics_written));\n-\t      EXECUTE_IF_SET_IN_BITMAP (l->statics_written, 0, index, bi)\n-\t\tlto_output_var_decl_index(ob->decl_state, ob->main_stream,\n-\t\t\t\t\t  get_static_decl (index));\n-\t    }\n-\t}\n-    }\n-  lto_destroy_simple_output_block (ob);\n-}\n-\n-\n-/* Deserialize the ipa info for lto.  */\n-\n-static void\n-ipa_reference_read_summary (void)\n-{\n-  struct lto_file_decl_data ** file_data_vec\n-    = lto_get_file_decl_data ();\n-  struct lto_file_decl_data * file_data;\n-  unsigned int j = 0;\n-\n-  ipa_init ();\n-\n-  while ((file_data = file_data_vec[j++]))\n-    {\n-      const char *data;\n-      size_t len;\n-      struct lto_input_block *ib\n-\t= lto_create_simple_input_block (file_data,\n-\t\t\t\t\t LTO_section_ipa_reference,\n-\t\t\t\t\t &data, &len);\n-      if (ib)\n-\t{\n-\t  unsigned int i;\n-\t  unsigned int f_count = lto_input_uleb128 (ib);\n-\n-\t  for (i = 0; i < f_count; i++)\n-\t    {\n-\t      unsigned int j, index;\n-\t      struct cgraph_node *node;\n-\t      ipa_reference_local_vars_info_t l;\n-\t      int v_count;\n-\t      lto_cgraph_encoder_t encoder;\n-\n-\t      index = lto_input_uleb128 (ib);\n-\t      encoder = file_data->cgraph_node_encoder;\n-\t      node = lto_cgraph_encoder_deref (encoder, index);\n-\t      l = init_function_info (node);\n-\n-\t      /* Set the statics read.  */\n-\t      v_count = lto_input_sleb128 (ib);\n-\t      if (v_count == -1)\n-\t        l->calls_read_all = true;\n-\t      else\n-\t\tfor (j = 0; j < (unsigned int)v_count; j++)\n-\t\t  {\n-\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n-\t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t\t\t   var_index);\n-\t\t    add_static_var (v_decl);\n-\t\t    bitmap_set_bit (l->statics_read, DECL_UID (v_decl));\n-\t\t  }\n-\n-\t      /* Set the statics written.  */\n-\t      v_count = lto_input_sleb128 (ib);\n-\t      if (v_count == -1)\n-\t        l->calls_write_all = true;\n-\t      else\n-\t\tfor (j = 0; j < (unsigned int)v_count; j++)\n-\t\t  {\n-\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n-\t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t\t\t   var_index);\n-\t\t    add_static_var (v_decl);\n-\t\t    bitmap_set_bit (l->statics_written, DECL_UID (v_decl));\n-\t\t  }\n-\t    }\n-\n-\t  lto_destroy_simple_input_block (file_data,\n-\t\t\t\t\t  LTO_section_ipa_reference,\n-\t\t\t\t\t  ib, data, len);\n-\t}\n-    }\n-}\n-\n-\n \f\n /* Set READ_ALL/WRITE_ALL based on DECL flags.  */\n static void\n@@ -1215,10 +824,11 @@ propagate (void)\n   int order_pos = ipa_utils_reduced_inorder (order, false, true, NULL);\n   int i;\n \n-  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n   if (dump_file)\n     dump_cgraph (dump_file);\n \n+  generate_summary ();\n+\n   /* Propagate the local information thru the call graph to produce\n      the global information.  All the nodes within a cycle will have\n      the same info so we collapse cycles first.  Then we can do the\n@@ -1512,9 +1122,9 @@ struct ipa_opt_pass_d pass_ipa_reference =\n   0,\t\t\t\t\t/* todo_flags_start */\n   0                                     /* todo_flags_finish */\n  },\n- generate_summary,\t\t        /* generate_summary */\n- ipa_reference_write_summary,\t\t/* write_summary */\n- ipa_reference_read_summary,\t\t/* read_summary */\n+ NULL,\t\t\t\t        /* generate_summary */\n+ NULL,\t\t\t\t\t/* write_summary */\n+ NULL,\t\t\t\t \t/* read_summary */\n  NULL,\t\t\t\t\t/* write_optimization_summary */\n  NULL,\t\t\t\t\t/* read_optimization_summary */\n  NULL,\t\t\t\t\t/* stmt_fixup */"}, {"sha": "88741f5a12adb34d813e2b13b43ce08056b48628", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f902d766c18beade9fd700b53a83d4e57622b10/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=5f902d766c18beade9fd700b53a83d4e57622b10", "patch": "@@ -282,6 +282,21 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp_pack_value (bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (bp, edge->call_stmt_cannot_inline_p, 1);\n   bp_pack_value (bp, edge->can_throw_external, 1);\n+  if (edge->indirect_unknown_callee)\n+    {\n+      int flags = edge->indirect_info->ecf_flags;\n+      bp_pack_value (bp, (flags & ECF_CONST) != 0, 1);\n+      bp_pack_value (bp, (flags & ECF_PURE) != 0, 1);\n+      bp_pack_value (bp, (flags & ECF_NORETURN) != 0, 1);\n+      bp_pack_value (bp, (flags & ECF_MALLOC) != 0, 1);\n+      bp_pack_value (bp, (flags & ECF_NOTHROW) != 0, 1);\n+      bp_pack_value (bp, (flags & ECF_RETURNS_TWICE) != 0, 1);\n+      /* Flags that should not appear on indirect calls.  */\n+      gcc_assert (!(flags & (ECF_LOOPING_CONST_OR_PURE\n+\t\t\t     | ECF_MAY_BE_ALLOCA\n+\t\t\t     | ECF_SIBCALL\n+\t\t\t     | ECF_NOVOPS)));\n+    }\n   lto_output_bitpack (ob->main_stream, bp);\n   bitpack_delete (bp);\n }\n@@ -1060,6 +1075,7 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   cgraph_inline_failed_t inline_failed;\n   struct bitpack_d *bp;\n   enum ld_plugin_symbol_resolution caller_resolution;\n+  int ecf_flags = 0;\n \n   caller = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n   if (caller == NULL || caller->decl == NULL_TREE)\n@@ -1091,7 +1107,7 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n     return;\n \n   if (indirect)\n-    edge = cgraph_create_indirect_edge (caller, NULL, count, freq, nest);\n+    edge = cgraph_create_indirect_edge (caller, NULL, 0, count, freq, nest);\n   else\n     edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n \n@@ -1100,6 +1116,22 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   edge->inline_failed = inline_failed;\n   edge->call_stmt_cannot_inline_p = bp_unpack_value (bp, 1);\n   edge->can_throw_external = bp_unpack_value (bp, 1);\n+  if (indirect)\n+    {\n+      if (bp_unpack_value (bp, 1))\n+\tecf_flags |= ECF_CONST;\n+      if (bp_unpack_value (bp, 1))\n+\tecf_flags |= ECF_PURE;\n+      if (bp_unpack_value (bp, 1))\n+\tecf_flags |= ECF_NORETURN;\n+      if (bp_unpack_value (bp, 1))\n+\tecf_flags |= ECF_MALLOC;\n+      if (bp_unpack_value (bp, 1))\n+\tecf_flags |= ECF_NOTHROW;\n+      if (bp_unpack_value (bp, 1))\n+\tecf_flags |= ECF_RETURNS_TWICE;\n+      edge->indirect_info->ecf_flags = ecf_flags;\n+    }\n   bitpack_delete (bp);\n }\n "}]}