{"sha": "53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "node_id": "C_kwDOANBUbNoAKDUzZTZkN2EzMTAyNDA5ZjBmMmE1YTlmZmJmYmVhYTYyYzEzNWQ5OTE", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-18T20:29:49Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-20T00:37:11Z"}, "message": "Add assume support to VRP.\n\nThis provides an assume_query class using rangers GORI module to\ndetermine what ranges would be applied to any SSA NAMES in the function\nif the return value were [1, 1].  Any parameter ranges are stored in\nthe SSA_NAME_RANGE_INFO field, and ranger's inferred range machinery is\nthen used to look these up and match them to assume call parameteres\nin the bodies of other functions..\n\n        PR c++/106654\n\tgcc/\n\t* gimple-range-gori.h (compute_operand_range): Make public.\n\t* gimple-range-infer.cc (gimple_infer_range::check_assume_func): New.\n\t(gimple_infer_range::gimple_infer_range): Check for assume calls.\n\t* gimple-range-infer.h (check_assume_func): Add prototype.\n\t* gimple-range.cc (assume_query::assume_range_p): New.\n\t(assume_query::range_of_expr): New.\n\t(assume_query::assume_query): New.\n\t(assume_query::calculate_op): New.\n\t(assume_query::calculate_phi): New.\n\t(assume_query::check_taken_edge): New.\n\t(assume_query::calculate_stmt): New.\n\t(assume_query::dump): New.\n\t* gimple-range.h (class assume_query): New.\n\t* tree-vrp.cc (pass_assumptions::execute): Add processing.\n\n\tgcc/testsuite/\n\t* g++.dg/cpp23/attr-assume-opt.C: New.", "tree": {"sha": "4a51214bd66f7d9ce476499a83cf4232b22feca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a51214bd66f7d9ce476499a83cf4232b22feca4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/comments", "author": null, "committer": null, "parents": [{"sha": "87f9c4a433523a41bcb314bdce91b55a98d00e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f9c4a433523a41bcb314bdce91b55a98d00e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f9c4a433523a41bcb314bdce91b55a98d00e28"}], "stats": {"total": 345, "additions": 342, "deletions": 3}, "files": [{"sha": "6cc533b58b2254992c3d65a395ab30bad5c32b79", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -165,15 +165,15 @@ class gori_compute : public gori_map\n   bool has_edge_range_p (tree name, basic_block bb = NULL);\n   bool has_edge_range_p (tree name, edge e);\n   void dump (FILE *f);\n+  bool compute_operand_range (vrange &r, gimple *stmt, const vrange &lhs,\n+\t\t\t      tree name, class fur_source &src,\n+\t\t\t      value_relation *rel = NULL);\n private:\n   bool refine_using_relation (tree op1, vrange &op1_range,\n \t\t\t      tree op2, vrange &op2_range,\n \t\t\t      fur_source &src, relation_kind k);\n   bool may_recompute_p (tree name, edge e);\n   bool may_recompute_p (tree name, basic_block bb = NULL);\n-  bool compute_operand_range (vrange &r, gimple *stmt, const vrange &lhs,\n-\t\t\t      tree name, class fur_source &src,\n-\t\t\t      value_relation *rel = NULL);\n   bool compute_operand_range_switch (vrange &r, gswitch *s, const vrange &lhs,\n \t\t\t\t     tree name, fur_source &src);\n   bool compute_operand1_range (vrange &r, gimple_range_op_handler &handler,"}, {"sha": "010b34a6bde3a2069d00432f3376fc66fbae7dd2", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"gimple-walk.h\"\n #include \"cfganal.h\"\n+#include \"tree-dfa.h\"\n \n // Adapted from infer_nonnull_range_by_dereference and check_loadstore\n // to process nonnull ssa_name OP in S.  DATA contains a pointer to a\n@@ -56,6 +57,54 @@ non_null_loadstore (gimple *, tree op, tree, void *data)\n   return false;\n }\n \n+// Process an ASSUME call to see if there are any inferred ranges available.\n+\n+void\n+gimple_infer_range::check_assume_func (gcall *call)\n+{\n+  tree arg;\n+  unsigned i;\n+  tree assume_id = TREE_OPERAND (gimple_call_arg (call, 0), 0);\n+  if (!assume_id)\n+    return;\n+  struct function *fun = DECL_STRUCT_FUNCTION (assume_id);\n+  if (!fun)\n+    return;\n+  // Loop over arguments, matching them to the assume paramters.\n+  for (arg = DECL_ARGUMENTS (assume_id), i = 1;\n+       arg && i < gimple_call_num_args (call);\n+       i++, arg = DECL_CHAIN (arg))\n+    {\n+      tree op = gimple_call_arg (call, i);\n+      tree type = TREE_TYPE (op);\n+      if (gimple_range_ssa_p (op) && Value_Range::supports_type_p (type))\n+\t{\n+\t  tree default_def = ssa_default_def (fun, arg);\n+\t  if (!default_def || type != TREE_TYPE (default_def))\n+\t    continue;\n+\t  // Query the global range of the default def in the assume function.\n+\t  Value_Range assume_range (type);\n+\t  global_ranges.range_of_expr (assume_range, default_def);\n+\t  // If there is a non-varying result, add it as an inferred range.\n+\t  if (!assume_range.varying_p ())\n+\t    {\n+\t      add_range (op, assume_range);\n+\t      if (dump_file)\n+\t\t{\n+\t\t  print_generic_expr (dump_file, assume_id, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" assume inferred range of \");\n+\t\t  print_generic_expr (dump_file, op, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" (param \");\n+\t\t  print_generic_expr (dump_file, arg, TDF_SLIM);\n+\t\t  fprintf (dump_file, \") = \");\n+\t\t  assume_range.dump (dump_file);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n // Add NAME and RANGE to the range inference summary.\n \n void\n@@ -111,6 +160,11 @@ gimple_infer_range::gimple_infer_range (gimple *s)\n       // Fallthru and walk load/store ops now.\n     }\n \n+  // Check for inferred ranges from ASSUME calls.\n+  if (is_a<gcall *> (s) && gimple_call_internal_p (s)\n+      && gimple_call_internal_fn (s) == IFN_ASSUME)\n+    check_assume_func (as_a<gcall *> (s));\n+\n   // Look for possible non-null values.\n   if (flag_delete_null_pointer_checks && gimple_code (s) != GIMPLE_ASM\n       && !gimple_clobber_p (s))"}, {"sha": "adfe1fd8c692fafe43397034cce1ded2d6397621", "filename": "gcc/gimple-range-infer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -40,6 +40,7 @@ class gimple_infer_range\n   void add_range (tree name, vrange &range);\n   void add_nonzero (tree name);\n private:\n+  void check_assume_func (gcall *call);\n   unsigned num_args;\n   static const int size_limit = 10;\n   tree m_names[size_limit];"}, {"sha": "058439733ee05bb23a0268039f418331a3992d5c", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -645,3 +645,193 @@ disable_ranger (struct function *fun)\n   delete fun->x_range_query;\n   fun->x_range_query = NULL;\n }\n+\n+// ------------------------------------------------------------------------\n+\n+// If there is a non-varying value associated with NAME, return true and the\n+// range in R.\n+\n+bool\n+assume_query::assume_range_p (vrange &r, tree name)\n+{\n+  if (global.get_global_range (r, name))\n+    return !r.varying_p ();\n+  return false;\n+}\n+\n+// Query used by GORI to pick up any known value on entry to a block.\n+\n+bool\n+assume_query::range_of_expr (vrange &r, tree expr, gimple *stmt)\n+{\n+  if (!gimple_range_ssa_p (expr))\n+    return get_tree_range (r, expr, stmt);\n+\n+  if (!global.get_global_range (r, expr))\n+    r.set_varying (TREE_TYPE (expr));\n+  return true;\n+}\n+\n+// If the current function returns an integral value, and has a single return\n+// statement, it will calculate any SSA_NAMES is can determine ranges forr\n+// assuming the function returns 1.\n+\n+assume_query::assume_query ()\n+{\n+  basic_block exit_bb = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  if (single_pred_p (exit_bb))\n+    {\n+      basic_block bb = single_pred (exit_bb);\n+      gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n+      if (gsi_end_p (gsi))\n+\treturn;\n+      gimple *s = gsi_stmt (gsi);\n+      if (!is_a<greturn *> (s))\n+\treturn;\n+      greturn *gret = as_a<greturn *> (s);\n+      tree op = gimple_return_retval (gret);\n+      if (!gimple_range_ssa_p (op))\n+\treturn;\n+      tree lhs_type = TREE_TYPE (op);\n+      if (!irange::supports_p (lhs_type))\n+\treturn;\n+\n+      unsigned prec = TYPE_PRECISION (lhs_type);\n+      int_range<2> lhs_range (lhs_type, wi::one (prec), wi::one (prec));\n+      global.set_global_range (op, lhs_range);\n+\n+      gimple *def = SSA_NAME_DEF_STMT (op);\n+      if (!def || gimple_get_lhs (def) != op)\n+\treturn;\n+      fur_stmt src (gret, this);\n+      calculate_stmt (def, lhs_range, src);\n+    }\n+}\n+\n+// Evaluate operand OP on statement S, using the provided LHS range.\n+// If successful, set the range in the global table, then visit OP's def stmt.\n+\n+void\n+assume_query::calculate_op (tree op, gimple *s, vrange &lhs, fur_source &src)\n+{\n+  Value_Range op_range (TREE_TYPE (op));\n+  if (m_gori.compute_operand_range (op_range, s, lhs, op, src)\n+      && !op_range.varying_p ())\n+    {\n+      Value_Range range (TREE_TYPE (op));\n+      if (global.get_global_range (range, op))\n+\top_range.intersect (range);\n+      global.set_global_range (op, op_range);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (op);\n+      if (def_stmt && gimple_get_lhs (def_stmt) == op)\n+\tcalculate_stmt (def_stmt, op_range, src);\n+    }\n+}\n+\n+// Evaluate PHI statement, using the provided LHS range.\n+// Check each constant argument predecessor if it can be taken\n+// provide LHS to any symbolic argmeuents, and process their def statements.\n+\n+void\n+assume_query::calculate_phi (gphi *phi, vrange &lhs_range, fur_source &src)\n+{\n+  for (unsigned x= 0; x < gimple_phi_num_args (phi); x++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, x);\n+      Value_Range arg_range (TREE_TYPE (arg));\n+      if (gimple_range_ssa_p (arg))\n+\t{\n+\t  // A symbol arg will be the LHS value.\n+\t  arg_range = lhs_range;\n+\t  range_cast (arg_range, TREE_TYPE (arg));\n+\t  if (!global.get_global_range (arg_range, arg))\n+\t    {\n+\t      global.set_global_range (arg, arg_range);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t      if (def_stmt && gimple_get_lhs (def_stmt) == arg)\n+\t\tcalculate_stmt (def_stmt, arg_range, src);\n+\t    }\n+\t}\n+      else if (get_tree_range (arg_range, arg, NULL))\n+\t{\n+\t  // If this is a constant value that differs from LHS, this\n+\t  // edge cannot be taken.\n+\t  arg_range.intersect (lhs_range);\n+\t  if (arg_range.undefined_p ())\n+\t    continue;\n+\t  // Otherwise check the condition feeding this edge.\n+\t  edge e = gimple_phi_arg_edge (phi, x);\n+\t  check_taken_edge (e, src);\n+\t}\n+    }\n+}\n+\n+// If an edge is known to be taken, examine the outgoing edge to see\n+// if it carries any range information that can also be evaluated.\n+\n+void\n+assume_query::check_taken_edge (edge e, fur_source &src)\n+{\n+  gimple *stmt = gimple_outgoing_range_stmt_p (e->src);\n+  if (stmt && is_a<gcond *> (stmt))\n+    {\n+      int_range<2> cond;\n+      gcond_edge_range (cond, e);\n+      calculate_stmt (stmt, cond, src);\n+    }\n+}\n+\n+// Evaluate statement S which produces range LHS_RANGE.\n+\n+void\n+assume_query::calculate_stmt (gimple *s, vrange &lhs_range, fur_source &src)\n+{\n+  gimple_range_op_handler handler (s);\n+  if (handler)\n+    {\n+      tree op = gimple_range_ssa_p (handler.operand1 ());\n+      if (op)\n+\tcalculate_op (op, s, lhs_range, src);\n+      op = gimple_range_ssa_p (handler.operand2 ());\n+      if (op)\n+\tcalculate_op (op, s, lhs_range, src);\n+    }\n+  else if (is_a<gphi *> (s))\n+    {\n+      calculate_phi (as_a<gphi *> (s), lhs_range, src);\n+      // Don't further check predecessors of blocks with PHIs.\n+      return;\n+    }\n+\n+  // Even if the walk back terminates before the top, if this is a single\n+  // predecessor block, see if the predecessor provided any ranges to get here.\n+  if (single_pred_p (gimple_bb (s)))\n+    check_taken_edge (single_pred_edge (gimple_bb (s)), src);\n+}\n+\n+// Show everything that was calculated.\n+\n+void\n+assume_query::dump (FILE *f)\n+{\n+  fprintf (f, \"Assumption details calculated:\\n\");\n+  for (unsigned i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (!name || !gimple_range_ssa_p (name))\n+\tcontinue;\n+      tree type = TREE_TYPE (name);\n+      if (!Value_Range::supports_type_p (type))\n+\tcontinue;\n+\n+      Value_Range assume_range (type);\n+      if (assume_range_p (assume_range, name))\n+\t{\n+\t  print_generic_expr (f, name, TDF_SLIM);\n+\t  fprintf (f, \" -> \");\n+\t  assume_range.dump (f);\n+\t  fputc ('\\n', f);\n+\t}\n+    }\n+  fprintf (f, \"------------------------------\\n\");\n+}"}, {"sha": "4800bfbf890852a73dd668f28405eb21aa9fbed5", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -80,4 +80,22 @@ extern gimple_ranger *enable_ranger (struct function *m,\n \t\t\t\t     bool use_imm_uses = true);\n extern void disable_ranger (struct function *);\n \n+class assume_query : public range_query\n+{\n+public:\n+  assume_query ();\n+  bool assume_range_p (vrange &r, tree name);\n+  virtual bool range_of_expr (vrange &r, tree expr, gimple * = NULL);\n+  void dump (FILE *f);\n+protected:\n+  void calculate_stmt (gimple *s, vrange &lhs_range, fur_source &src);\n+  void calculate_op (tree op, gimple *s, vrange &lhs, fur_source &src);\n+  void calculate_phi (gphi *phi, vrange &lhs_range, fur_source &src);\n+  void check_taken_edge (edge e, fur_source &src);\n+\n+  ssa_global_cache global;\n+  gori_compute m_gori;\n+};\n+\n+\n #endif // GCC_GIMPLE_RANGE_H"}, {"sha": "88d5e78dbbaedd72a1c43a34c9def163733b5e04", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume-opt.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume-opt.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume-opt.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume-opt.C?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -0,0 +1,42 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fdump-tree-vrp2\" }\n+// Test the we can optimize based on conditions in assume.\n+\n+int\n+f1 (unsigned x, unsigned y, unsigned z)\n+{\n+  [[assume (x == 2 && y < 3 && z < 20)]];\n+  unsigned q = x + y + z;\n+  if (q > 23)\n+    return 0;\n+  return 1;\n+}\n+\n+\n+int\n+f2 (int x, int y, int z)\n+{\n+  [[assume (x+12 == 14 && y >= 0 && y + 10 < 13 && z + 4 >= 4 && z - 2 < 18)]];\n+  unsigned q = x + y + z;\n+  if (q*2 > 46)\n+    return 0;\n+  return 1;\n+}\n+\n+int\n+f3 (int x, int y, int z)\n+{\n+  [[assume (x + 12 == 14 && z / 2 > 0)]];\n+  [[assume (y >= 0 && z - 2 < 18)]];\n+  [[assume (y + 10 < 13 && z + 4 >= 2)]];\n+  int q = x + y + z;\n+  if (q * 2 > 46)\n+    return 0;\n+  if (z < 0)\n+    return 0;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 0 \"vrp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 1\" 3 \"vrp2\" } } */"}, {"sha": "e5a292bb875aa7352c5f77b656d980e355af3ff6", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=53e6d7a3102409f0f2a5a9ffbfbeaa62c135d991", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range-path.h\"\n #include \"value-pointer-equiv.h\"\n #include \"gimple-fold.h\"\n+#include \"tree-dfa.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -4465,6 +4466,39 @@ class pass_assumptions : public gimple_opt_pass\n   bool gate (function *fun) final override { return fun->assume_function; }\n   unsigned int execute (function *) final override\n     {\n+      assume_query query;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Assumptions :\\n--------------\\n\");\n+\n+      for (tree arg = DECL_ARGUMENTS (cfun->decl); arg; arg = DECL_CHAIN (arg))\n+\t{\n+\t  tree name = ssa_default_def (cfun, arg);\n+\t  if (!name || !gimple_range_ssa_p (name))\n+\t    continue;\n+\t  tree type = TREE_TYPE (name);\n+\t  if (!Value_Range::supports_type_p (type))\n+\t    continue;\n+\t  Value_Range assume_range (type);\n+\t  if (query.assume_range_p (assume_range, name))\n+\t    {\n+\t      // Set the global range of NAME to anything calculated.\n+\t      set_range_info (name, assume_range);\n+\t      if (dump_file)\n+\t\t{\n+\t\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" -> \");\n+\t\t  assume_range.dump (dump_file);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\t    }\n+\t}\n+      if (dump_file)\n+\t{\n+\t  fputc ('\\n', dump_file);\n+\t  gimple_dump_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n+\t  if (dump_flags & TDF_DETAILS)\n+\t    query.dump (dump_file);\n+\t}\n       return TODO_discard_function;\n     }\n "}]}