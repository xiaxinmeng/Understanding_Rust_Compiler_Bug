{"sha": "a28fee0388e157e0778a7203b79718744bb0bcbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4ZmVlMDM4OGUxNTdlMDc3OGE3MjAzYjc5NzE4NzQ0YmIwYmNiYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-01-14T18:40:30Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-01-14T18:40:30Z"}, "message": "tree-ssa-dce.c (visited_control_parents): New sbitmap to replace BB_VISITED uses.\n\n\t* tree-ssa-dce.c (visited_control_parents): New sbitmap to\n\treplace BB_VISITED uses.\n\t(find_obviously_necessary_stmts): Don't clear BB_VISITED.\n\t(propagate_necessity): Check the bitmap instead of BB_VISITED.\n\t(tree_dce_done): Free visited_control_parents.\n\t(perform_tree_ssa_dce): Allocate and clear it.\n\t* tree-ssa-pre.c (compute_antic_aux): Make non-recursive.\n\t(compute_antic): Iterate from here using a DFS.  Use an sbitmap\n\tinstead of BB_VISITED.\n\nFrom-SVN: r93654", "tree": {"sha": "a22f0af11a0134a6fea37711e4f1ff20133eb8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a22f0af11a0134a6fea37711e4f1ff20133eb8b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a28fee0388e157e0778a7203b79718744bb0bcbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28fee0388e157e0778a7203b79718744bb0bcbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28fee0388e157e0778a7203b79718744bb0bcbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28fee0388e157e0778a7203b79718744bb0bcbc/comments", "author": null, "committer": null, "parents": [{"sha": "103a83e0fabbc85f12580a3d09cdfd429d05cacf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/103a83e0fabbc85f12580a3d09cdfd429d05cacf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/103a83e0fabbc85f12580a3d09cdfd429d05cacf"}], "stats": {"total": 171, "additions": 101, "deletions": 70}, "files": [{"sha": "08556ae24b4c02e1e72dba41268749ac83775670", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fee0388e157e0778a7203b79718744bb0bcbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fee0388e157e0778a7203b79718744bb0bcbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a28fee0388e157e0778a7203b79718744bb0bcbc", "patch": "@@ -1,3 +1,15 @@\n+2005-01-14  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* tree-ssa-dce.c (visited_control_parents): New sbitmap to\n+\treplace BB_VISITED uses.\n+\t(find_obviously_necessary_stmts): Don't clear BB_VISITED.\n+\t(propagate_necessity): Check the bitmap instead of BB_VISITED.\n+\t(tree_dce_done): Free visited_control_parents.\n+\t(perform_tree_ssa_dce): Allocate and clear it.\n+\t* tree-ssa-pre.c (compute_antic_aux): Make non-recursive.\n+\t(compute_antic): Iterate from here using a DFS.  Use an sbitmap\n+\tinstead of BB_VISITED.\n+\n 2005-01-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-tree.h, coverage.h, langhooks-def.h, optabs.h, output.h,"}, {"sha": "4f72d82f92c6f6c8f6a8de94770cf937080fba1c", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fee0388e157e0778a7203b79718744bb0bcbc/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fee0388e157e0778a7203b79718744bb0bcbc/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=a28fee0388e157e0778a7203b79718744bb0bcbc", "patch": "@@ -93,6 +93,10 @@ static sbitmap last_stmt_necessary;\n    on the Ith edge.  */\n bitmap *control_dependence_map;\n \n+/* Vector indicating that a basic block has already had all the edges\n+   processed that it is control dependent on.  */\n+sbitmap visited_control_parents;\n+\n /* Execute CODE for each edge (given number EDGE_NUMBER within the CODE)\n    for which the block with index N is control dependent.  */\n #define EXECUTE_IF_CONTROL_DEPENDENT(N, EDGE_NUMBER, CODE)\t\t      \\\n@@ -482,11 +486,6 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t  NECESSARY (stmt) = 0;\n \t  mark_stmt_if_obviously_necessary (stmt, el != NULL);\n \t}\n-\n-      /* Mark this basic block as `not visited'.  A block will be marked\n-\t visited when the edges that it is control dependent on have been\n-\t marked.  */\n-      bb->flags &= ~BB_VISITED;\n     }\n \n   if (el)\n@@ -565,9 +564,10 @@ propagate_necessity (struct edge_list *el)\n \t     containing `i' is control dependent on, but only if we haven't\n \t     already done so.  */\n \t  basic_block bb = bb_for_stmt (i);\n-\t  if (! (bb->flags & BB_VISITED))\n+\t  if (bb != ENTRY_BLOCK_PTR\n+\t      && ! TEST_BIT (visited_control_parents, bb->index))\n \t    {\n-\t      bb->flags |= BB_VISITED;\n+\t      SET_BIT (visited_control_parents, bb->index);\n \t      mark_control_dependent_edges_necessary (bb, el);\n \t    }\n \t}\n@@ -593,9 +593,10 @@ propagate_necessity (struct edge_list *el)\n \t      for (k = 0; k < PHI_NUM_ARGS (i); k++)\n \t\t{\n \t\t  basic_block arg_bb = PHI_ARG_EDGE (i, k)->src;\n-\t\t  if (! (arg_bb->flags & BB_VISITED))\n+\t\t  if (arg_bb != ENTRY_BLOCK_PTR\n+\t\t      && ! TEST_BIT (visited_control_parents, arg_bb->index))\n \t\t    {\n-\t\t      arg_bb->flags |= BB_VISITED;\n+\t\t      SET_BIT (visited_control_parents, arg_bb->index);\n \t\t      mark_control_dependent_edges_necessary (arg_bb, el);\n \t\t    }\n \t\t}\n@@ -903,6 +904,7 @@ tree_dce_done (bool aggressive)\n \tBITMAP_XFREE (control_dependence_map[i]);\n       free (control_dependence_map);\n \n+      sbitmap_free (visited_control_parents);\n       sbitmap_free (last_stmt_necessary);\n     }\n \n@@ -939,6 +941,9 @@ perform_tree_ssa_dce (bool aggressive)\n       find_all_control_dependences (el);\n       timevar_pop (TV_CONTROL_DEPENDENCES);\n \n+      visited_control_parents = sbitmap_alloc (last_basic_block);\n+      sbitmap_zero (visited_control_parents);\n+\n       mark_dfs_back_edges ();\n     }\n "}, {"sha": "8e22e20292855121c6a542d9775ca05778ca4402", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 75, "deletions": 61, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fee0388e157e0778a7203b79718744bb0bcbc/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fee0388e157e0778a7203b79718744bb0bcbc/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=a28fee0388e157e0778a7203b79718744bb0bcbc", "patch": "@@ -1113,52 +1113,32 @@ DEF_VEC_MALLOC_P (basic_block);\n \n    ANTIC_IN[BLOCK] = clean(ANTIC_OUT[BLOCK] U EXP_GEN[BLOCK] - TMP_GEN[BLOCK])\n \n-   Iterate until fixpointed.\n-\n    XXX: It would be nice to either write a set_clear, and use it for\n    ANTIC_OUT, or to mark the antic_out set as deleted at the end\n    of this routine, so that the pool can hand the same memory back out\n    again for the next ANTIC_OUT.  */\n \n-\n static bool\n-compute_antic_aux (basic_block block)\n+compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n {\n-  basic_block son;\n-  edge e;\n   bool changed = false;\n   value_set_t S, old, ANTIC_OUT;\n   value_set_node_t node;\n-  \n+\n   ANTIC_OUT = S = NULL;\n-  /* If any edges from predecessors are abnormal, antic_in is empty, so\n-     punt.  Remember that the block has an incoming abnormal edge by\n-     setting the BB_VISITED flag.  */\n-  if (! (block->flags & BB_VISITED))\n-    {\n-      edge_iterator ei;\n-      FOR_EACH_EDGE (e, ei, block->preds)\n-\tif (e->flags & EDGE_ABNORMAL)\n-\t  {\n-\t    block->flags |= BB_VISITED;\n-\t    break;\n-\t  }\n-    }\n-  if (block->flags & BB_VISITED)\n-    {\n-      S = NULL;\n-      goto visit_sons;\n-    }\n-  \n+\n+  /* If any edges from predecessors are abnormal, antic_in is empty,\n+     so do nothing.  */\n+  if (block_has_abnormal_pred_edge)\n+    goto maybe_dump_sets;\n \n   old = set_new (false);\n   set_copy (old, ANTIC_IN (block));\n   ANTIC_OUT = set_new (true);\n \n-  /* If the block has no successors, ANTIC_OUT is empty, because it is\n-     the exit block.  */\n-  if (EDGE_COUNT (block->succs) == 0);\n-\n+  /* If the block has no successors, ANTIC_OUT is empty.  */\n+  if (EDGE_COUNT (block->succs) == 0)\n+    ;\n   /* If we have one successor, we could have some phi nodes to\n      translate through.  */\n   else if (EDGE_COUNT (block->succs) == 1)\n@@ -1206,65 +1186,99 @@ compute_antic_aux (basic_block block)\n \t\t\t\t\t\t\t TMP_GEN (block),\n \t\t\t\t\t\t\t true);\n   \n-  /* Then union in the ANTIC_OUT - TMP_GEN values, to get ANTIC_OUT U\n-     EXP_GEN - TMP_GEN */\n-  for (node = S->head;\n-       node;\n-       node = node->next)\n-    {\n-      value_insert_into_set (ANTIC_IN (block), node->expr);\n-    }\n-  clean (ANTIC_IN (block));\n-  \n+  /* Then union in the ANTIC_OUT - TMP_GEN values,\n+     to get ANTIC_OUT U EXP_GEN - TMP_GEN */\n+  for (node = S->head; node; node = node->next)\n+    value_insert_into_set (ANTIC_IN (block), node->expr);\n \n+  clean (ANTIC_IN (block));\n   if (!set_equal (old, ANTIC_IN (block)))\n     changed = true;\n \n- visit_sons:\n+ maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       if (ANTIC_OUT)\n \tprint_value_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n       print_value_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\", block->index);\n       if (S)\n \tprint_value_set (dump_file, S, \"S\", block->index);\n-\n     }\n \n-  for (son = first_dom_son (CDI_POST_DOMINATORS, block);\n-       son;\n-       son = next_dom_son (CDI_POST_DOMINATORS, son))\n-    {\n-      changed |= compute_antic_aux (son);\n-    }\n   return changed;\n }\n \n-/* Compute ANTIC sets.  */\n+/* Compute ANTIC sets.  Iterates until fixpointed.  */\n \n static void\n compute_antic (void)\n {\n-  bool changed = true;\n-  basic_block bb;\n+  bool changed= true;\n   int num_iterations = 0;\n-  FOR_ALL_BB (bb)\n+  basic_block block, *worklist;\n+  size_t sp = 0;\n+  sbitmap has_abnormal_preds;\n+\n+  /* If any predecessor edges are abnormal, we punt, so antic_in is empty.\n+     We pre-build the map of blocks with incoming abnormal edges here.  */\n+  has_abnormal_preds = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (has_abnormal_preds);\n+  FOR_EACH_BB (block)\n     {\n-      ANTIC_IN (bb) = set_new (true);\n-      gcc_assert (!(bb->flags & BB_VISITED));\n+      edge_iterator ei;\n+      edge e;\n+\n+      FOR_EACH_EDGE (e, ei, block->preds)\n+        if (e->flags & EDGE_ABNORMAL)\n+          {\n+            SET_BIT (has_abnormal_preds, block->index);\n+            break;\n+          }\n+\n+      /* While we are here, give empty ANTIC_IN sets to each block.  */\n+      ANTIC_IN (block) = set_new (true);\n     }\n+  /* At the exit block we anticipate nothing.  */\n+  ANTIC_IN (EXIT_BLOCK_PTR) = set_new (true);\n+\n+  /* Allocate the worklist.  */\n+  worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n+  /* Loop until fixpointed.  */\n   while (changed)\n     {\n-      num_iterations++;\n+      basic_block son, bb;\n+\n       changed = false;\n-      changed = compute_antic_aux (EXIT_BLOCK_PTR);\n-    }\n-  FOR_ALL_BB (bb)\n-    {\n-      bb->flags &= ~BB_VISITED;\n+      num_iterations++;\n+\n+      /* Seed the algorithm by putting post-dominator children of\n+         the exit block in the worklist.  */\n+      for (son = first_dom_son (CDI_POST_DOMINATORS, EXIT_BLOCK_PTR);\n+\t   son;\n+\t   son = next_dom_son (CDI_POST_DOMINATORS, son))\n+\tworklist[sp++] = son;\n+\n+      /* Now visit all blocks in a DFS of the post dominator tree.  */\n+      while (sp)\n+\t{\n+\t  bool bb_has_abnormal_pred;\n+\n+\t  bb = worklist[--sp];\n+\t  bb_has_abnormal_pred = TEST_BIT (has_abnormal_preds, bb->index);\n+ \t  changed |= compute_antic_aux (bb, bb_has_abnormal_pred);\n+\n+\t  for (son = first_dom_son (CDI_POST_DOMINATORS, bb);\n+\t       son;\n+\t       son = next_dom_son (CDI_POST_DOMINATORS, son))\n+\t    worklist[sp++] = son;\n+\t}\n     }\n-  if (num_iterations > 2 && dump_file && (dump_flags & TDF_STATS))\n+\n+  free (worklist);\n+  sbitmap_free (has_abnormal_preds);\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n     fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n }\n "}]}