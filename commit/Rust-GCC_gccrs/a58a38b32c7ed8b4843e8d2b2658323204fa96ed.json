{"sha": "a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU4YTM4YjMyYzdlZDhiNDg0M2U4ZDJiMjY1ODMyMzIwNGZhOTZlZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-11-08T16:45:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-11-08T16:45:54Z"}, "message": "shared_ptr_base.h (_Sp_counted_ptr): Make 'final'.\n\n\t* include/bits/shared_ptr_base.h (_Sp_counted_ptr): Make 'final'.\n\t(_Sp_counted_deleter): Make 'final'. Use allocator_traits.\n\t(_Sp_counted_ptr_inplace): Make 'final'. Use allocator_traits.\n\tDerive from _Sp_counted_ptr instead of _Sp_counted_deleter to use EBO\n\tfor the allocator.\n\t(__shared_count, __shared_ptr): Use allocator_traits.\n\t* include/std/future (__future_base::_Result_alloc): Make 'final'. Use\n\tallocator traits.\n\t(__future_base::_Task_state): Make 'final'.\n\t(__future_base::_Deferred_state): Likewise.\n\t(__future_base::_Async_state): Likewise.\n\t* testsuite/20_util/shared_ptr/cons/alloc_min.cc: New.\n\t* testsuite/20_util/shared_ptr/creation/alloc_min.cc: New.\n\t* testsuite/20_util/shared_ptr/creation/private.cc: New.\n\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust line numbers.\n\t* testsuite/30_threads/packaged_task/cons/alloc_min.cc: New.\n\t* testsuite/30_threads/promise/cons/alloc_min.cc: New.\n\nFrom-SVN: r181171", "tree": {"sha": "be2c8d9ffb3c692a724ab2604acbeee10a7e8e42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be2c8d9ffb3c692a724ab2604acbeee10a7e8e42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ebe5133dc24e17df3136e379fedc4ad43c239e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ebe5133dc24e17df3136e379fedc4ad43c239e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ebe5133dc24e17df3136e379fedc4ad43c239e2"}], "stats": {"total": 386, "additions": 307, "deletions": 79}, "files": [{"sha": "24cc7b67b62556eac3f3edc8aad5b289da47a373", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -1,3 +1,23 @@\n+2011-11-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/shared_ptr_base.h (_Sp_counted_ptr): Make 'final'.\n+\t(_Sp_counted_deleter): Make 'final'. Use allocator_traits.\n+\t(_Sp_counted_ptr_inplace): Make 'final'. Use allocator_traits.\n+\tDerive from _Sp_counted_ptr instead of _Sp_counted_deleter to use EBO\n+\tfor the allocator.\n+\t(__shared_count, __shared_ptr): Use allocator_traits.\n+\t* include/std/future (__future_base::_Result_alloc): Make 'final'. Use\n+\tallocator traits.\n+\t(__future_base::_Task_state): Make 'final'.\n+\t(__future_base::_Deferred_state): Likewise.\n+\t(__future_base::_Async_state): Likewise.\n+\t* testsuite/20_util/shared_ptr/cons/alloc_min.cc: New.\n+\t* testsuite/20_util/shared_ptr/creation/alloc_min.cc: New.\n+\t* testsuite/20_util/shared_ptr/creation/private.cc: New.\n+\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust line numbers.\n+\t* testsuite/30_threads/packaged_task/cons/alloc_min.cc: New.\n+\t* testsuite/30_threads/promise/cons/alloc_min.cc: New.\n+\n 2011-11-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* acinclude.m4 ([GLIBCXX_ENABLE_VISIBILITY]): Rename to"}, {"sha": "fbbadd1aaaac3d7529a4cee844942e94941234d8", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -281,7 +281,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Counted ptr with no deleter or allocator support\n   template<typename _Ptr, _Lock_policy _Lp>\n-    class _Sp_counted_ptr : public _Sp_counted_base<_Lp>\n+    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>\n     {\n     public:\n       explicit\n@@ -321,20 +321,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Support for custom deleter and/or allocator\n   template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n-    class _Sp_counted_deleter : public _Sp_counted_base<_Lp>\n+    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>\n     {\n-      typedef typename _Alloc::template\n-\t  rebind<_Sp_counted_deleter>::other _My_alloc_type;\n-\n       // Helper class that stores the Deleter and also acts as an allocator.\n       // Used to dispose of the owned pointer and the internal refcount\n       // Requires that copies of _Alloc can free each other's memory.\n       struct _My_Deleter\n-      : public _My_alloc_type    // copy constructor must not throw\n+      : public _Alloc           // copy constructor must not throw\n       {\n-\t_Deleter _M_del;         // copy constructor must not throw\n+\t_Deleter _M_del;        // copy constructor must not throw\n \t_My_Deleter(_Deleter __d, const _Alloc& __a)\n-\t: _My_alloc_type(__a), _M_del(__d) { }\n+\t: _Alloc(__a), _M_del(__d) { }\n       };\n \n     public:\n@@ -353,9 +350,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       virtual void\n       _M_destroy() noexcept\n       {\n-\t_My_alloc_type __a(_M_del);\n-\tthis->~_Sp_counted_deleter();\n-\t__a.deallocate(this, 1);\n+\ttypedef typename allocator_traits<_Alloc>::template\n+\t  rebind_traits<_Sp_counted_deleter> _Alloc_traits;\n+\ttypename _Alloc_traits::allocator_type __a(_M_del);\n+\t_Alloc_traits::destroy(__a, this);\n+\t_Alloc_traits::deallocate(__a, this, 1);\n       }\n \n       virtual void*\n@@ -375,51 +374,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // helpers for make_shared / allocate_shared\n \n-  template<typename _Tp>\n-    struct _Sp_destroy_inplace\n-    {\n-      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }\n-    };\n-\n   struct _Sp_make_shared_tag { };\n \n   template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n-    class _Sp_counted_ptr_inplace\n-    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>\n     {\n-      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n-\t_Base_type;\n-\n-    public:\n-      explicit\n-      _Sp_counted_ptr_inplace(_Alloc __a)\n-      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n-      , _M_storage()\n+      // Helper class that stores the pointer and also acts as an allocator.\n+      // Used to dispose of the owned pointer and the internal refcount\n+      // Requires that copies of _Alloc can free each other's memory.\n+      struct _Impl\n+      : public _Alloc           // copy constructor must not throw\n       {\n-\tvoid* __p = &_M_storage;\n-\t::new (__p) _Tp();  // might throw\n-\t_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n-      }\n+\t_Impl(_Alloc __a) : _Alloc(__a), _M_ptr() { }\n+\t_Tp* _M_ptr;\n+      };\n \n+    public:\n       template<typename... _Args>\n \t_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n-\t: _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n-\t, _M_storage()\n+\t: _M_impl(__a), _M_storage()\n \t{\n-\t  void* __p = &_M_storage;\n-\t  ::new (__p) _Tp(std::forward<_Args>(__args)...);  // might throw\n-\t  _Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+\t  _M_impl._M_ptr = static_cast<_Tp*>(static_cast<void*>(&_M_storage));\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 2070.  allocate_shared should use allocator_traits<A>::construct\n+\t  allocator_traits<_Alloc>::construct(__a, _M_impl._M_ptr,\n+\t      std::forward<_Args>(__args)...); // might throw\n \t}\n \n+      virtual void\n+      _M_dispose() noexcept\n+      { allocator_traits<_Alloc>::destroy(_M_impl, _M_impl._M_ptr); }\n+\n       // Override because the allocator needs to know the dynamic type\n       virtual void\n       _M_destroy() noexcept\n       {\n-\ttypedef typename _Alloc::template\n-\t    rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;\n-\t_My_alloc_type __a(_Base_type::_M_del);\n-\tthis->~_Sp_counted_ptr_inplace();\n-\t__a.deallocate(this, 1);\n+\ttypedef typename allocator_traits<_Alloc>::template\n+\t  rebind_traits<_Sp_counted_ptr_inplace> _Alloc_traits;\n+\ttypename _Alloc_traits::allocator_type __a(_M_impl);\n+\t_Alloc_traits::destroy(__a, this);\n+\t_Alloc_traits::deallocate(__a, this, 1);\n       }\n \n       // Sneaky trick so __shared_ptr can get the managed pointer\n@@ -429,13 +423,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #ifdef __GXX_RTTI\n \treturn __ti == typeid(_Sp_make_shared_tag)\n \t       ? static_cast<void*>(&_M_storage)\n-\t       : _Base_type::_M_get_deleter(__ti);\n+\t       : 0;\n #else\n         return 0;\n #endif\n       }\n \n     private:\n+      _Impl _M_impl;\n       typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type\n \t_M_storage;\n     };\n@@ -468,18 +463,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // The allocator's value_type doesn't matter, will rebind it anyway.\n \t  typedef std::allocator<int> _Alloc;\n \t  typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n-\t  typedef std::allocator<_Sp_cd_type> _Alloc2;\n-\t  _Alloc2 __a2;\n+\t  typedef typename allocator_traits<_Alloc>::template\n+\t    rebind_traits<_Sp_cd_type> _Alloc_traits;\n+\t  typename _Alloc_traits::allocator_type __a;\n+\t  _Sp_cd_type* __mem = 0;\n \t  __try\n \t    {\n-\t      _M_pi = __a2.allocate(1);\n-\t      ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);\n+\t      __mem = _Alloc_traits::allocate(__a, 1);\n+\t      _Alloc_traits::construct(__a, __mem, __p, std::move(__d));\n+\t      _M_pi = __mem;\n \t    }\n \t  __catch(...)\n \t    {\n \t      __d(__p); // Call _Deleter on __p.\n-\t      if (_M_pi)\n-\t\t__a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+\t      if (__mem)\n+\t        _Alloc_traits::deallocate(__a, __mem, 1);\n \t      __throw_exception_again;\n \t    }\n \t}\n@@ -488,18 +486,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n \t{\n \t  typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n-\t  typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;\n-\t  _Alloc2 __a2(__a);\n+\t  typedef typename allocator_traits<_Alloc>::template\n+\t    rebind_traits<_Sp_cd_type> _Alloc_traits;\n+\t  typename _Alloc_traits::allocator_type __a2(__a);\n+\t  _Sp_cd_type* __mem = 0;\n \t  __try\n \t    {\n-\t      _M_pi = __a2.allocate(1);\n-\t      ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);\n+\t      __mem = _Alloc_traits::allocate(__a2, 1);\n+\t      _Alloc_traits::construct(__a2, __mem,\n+\t\t  __p, std::move(__d), std::move(__a));\n+\t      _M_pi = __mem;\n \t    }\n \t  __catch(...)\n \t    {\n \t      __d(__p); // Call _Deleter on __p.\n-\t      if (_M_pi)\n-\t\t__a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+\t      if (__mem)\n+\t        _Alloc_traits::deallocate(__a2, __mem, 1);\n \t      __throw_exception_again;\n \t    }\n \t}\n@@ -510,18 +512,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _M_pi(0)\n \t{\n \t  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n-\t  typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;\n-\t  _Alloc2 __a2(__a);\n+\t  typedef typename allocator_traits<_Alloc>::template\n+\t    rebind_traits<_Sp_cp_type> _Alloc_traits;\n+\t  typename _Alloc_traits::allocator_type __a2(__a);\n+\t  _Sp_cp_type* __mem = _Alloc_traits::allocate(__a2, 1);\n \t  __try\n \t    {\n-\t      _M_pi = __a2.allocate(1);\n-\t      ::new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,\n+\t      _Alloc_traits::construct(__a2, __mem, std::move(__a),\n \t\t    std::forward<_Args>(__args)...);\n+\t      _M_pi = __mem;\n \t    }\n \t  __catch(...)\n \t    {\n-\t      if (_M_pi)\n-\t\t__a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);\n+\t      _Alloc_traits::deallocate(__a2, __mem, 1);\n \t      __throw_exception_again;\n \t    }\n \t}\n@@ -1001,8 +1004,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         {\n           void operator()(_Tp* __ptr)\n           {\n-            _M_alloc.destroy(__ptr);\n-            _M_alloc.deallocate(__ptr, 1);\n+\t    typedef allocator_traits<_Alloc> _Alloc_traits;\n+\t    _Alloc_traits::destroy(_M_alloc, __ptr);\n+\t    _Alloc_traits::deallocate(_M_alloc, __ptr, 1);\n           }\n           _Alloc _M_alloc;\n         };\n@@ -1014,14 +1018,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         {\n \t  typedef typename _Alloc::template rebind<_Tp>::other _Alloc2;\n           _Deleter<_Alloc2> __del = { _Alloc2(__a) };\n-          _M_ptr = __del._M_alloc.allocate(1);\n+\t  typedef allocator_traits<_Alloc2> __traits;\n+          _M_ptr = __traits::allocate(__del._M_alloc, 1);\n \t  __try\n \t    {\n-              __del._M_alloc.construct(_M_ptr, std::forward<_Args>(__args)...);\n+\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t      // 2070. allocate_shared should use allocator_traits<A>::construct\n+\t      __traits::construct(__del._M_alloc, _M_ptr,\n+\t\t                  std::forward<_Args>(__args)...);\n \t    }\n \t  __catch(...)\n \t    {\n-              __del._M_alloc.deallocate(_M_ptr, 1);\n+\t      __traits::deallocate(__del._M_alloc, _M_ptr, 1);\n \t      __throw_exception_again;\n \t    }\n           __shared_count<_Lp> __count(_M_ptr, __del, __del._M_alloc);"}, {"sha": "bfd1ff9e9bb04c97eaf46108a446f717ba2c5fa2", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -264,10 +264,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     /// Result_alloc.\n     template<typename _Res, typename _Alloc>\n-      struct _Result_alloc : _Result<_Res>, _Alloc\n+      struct _Result_alloc final : _Result<_Res>, _Alloc\n       {\n-        typedef typename _Alloc::template rebind<_Result_alloc>::other\n-          __allocator_type;\n+        typedef typename allocator_traits<_Alloc>::template\n+          rebind_alloc<_Result_alloc> __allocator_type;\n \n         explicit\n \t_Result_alloc(const _Alloc& __a) : _Result<_Res>(), _Alloc(__a)\n@@ -276,9 +276,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private:\n \tvoid _M_destroy()\n         {\n+\t  typedef allocator_traits<__allocator_type> __traits;\n           __allocator_type __a(*this);\n-          __a.destroy(this);\n-          __a.deallocate(this, 1);\n+\t  __traits::destroy(__a, this);\n+\t  __traits::deallocate(__a, this, 1);\n         }\n       };\n \n@@ -287,15 +288,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _S_allocate_result(const _Allocator& __a)\n       {\n         typedef _Result_alloc<_Res, _Allocator>\t__result_type;\n-        typename __result_type::__allocator_type __a2(__a);\n-        __result_type* __p = __a2.allocate(1);\n+\ttypedef allocator_traits<typename __result_type::__allocator_type>\n+\t  __traits;\n+        typename __traits::allocator_type __a2(__a);\n+        __result_type* __p = __traits::allocate(__a2, 1);\n         __try\n \t{\n-          __a2.construct(__p, __a);\n+\t  __traits::construct(__a2, __p, __a);\n         }\n         __catch(...)\n         {\n-          __a2.deallocate(__p, 1);\n+\t  __traits::deallocate(__a2, __p, 1);\n           __throw_exception_again;\n         }\n         return _Ptr<__result_type>(__p);\n@@ -1239,7 +1242,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Res, typename... _Args>\n-    struct __future_base::_Task_state<_Res(_Args...)>\n+    struct __future_base::_Task_state<_Res(_Args...)> final\n     : __future_base::_State_base\n     {\n       typedef _Res _Res_type;\n@@ -1393,7 +1396,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \n   template<typename _BoundFn, typename _Res>\n-    class __future_base::_Deferred_state : public __future_base::_State_base\n+    class __future_base::_Deferred_state final\n+    : public __future_base::_State_base\n     {\n     public:\n       explicit\n@@ -1415,7 +1419,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _BoundFn, typename _Res>\n-    class __future_base::_Async_state : public __future_base::_State_base\n+    class __future_base::_Async_state final\n+    : public __future_base::_State_base\n     {\n     public:\n       explicit"}, {"sha": "4276c406269ea7495131ef185c0d189eebc8d8b2", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -32,9 +32,9 @@ void test01()\n {\n   X* px = 0;\n   std::shared_ptr<X> p1(px);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 768 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 771 }\n \n   std::shared_ptr<X> p9(ap());  // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 862 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 865 }\n \n }"}, {"sha": "86f725d53902dbaa7aadb47c7ec4535d96ffbe11", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/alloc_min.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falloc_min.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falloc_min.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Falloc_min.cc?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.2.2 Class template shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_allocator.h>\n+\n+struct X { };\n+\n+// 20.7.2.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// test shared_ptr with minimal allocator\n+\n+__gnu_test::SimpleAllocator<X> alloc;\n+auto deleter = [](X* p) { delete p; };\n+std::shared_ptr<X> p(new X, deleter, alloc);\n+"}, {"sha": "7def5b1c7bcce1bfdaac8531f4626fd2267c6e74", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/alloc_min.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Falloc_min.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Falloc_min.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Falloc_min.cc?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.2.2 Class template shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_allocator.h>\n+\n+struct X { };\n+\n+// 20.7.2.2.6 shared_ptr creation [util.smartptr.shared.create]\n+\n+// test shared_ptr with minimal allocator\n+\n+__gnu_test::SimpleAllocator<X> alloc;\n+auto p = std::allocate_shared<X>(alloc);\n+"}, {"sha": "c741fc5f74ca6d0068f1bca96a695a3ccff9601d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/creation/private.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fprivate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fprivate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcreation%2Fprivate.cc?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <new>\n+\n+// The behaviour tested here relies on the resolution of LWG issue 2070\n+\n+template<typename T> struct MyAlloc;\n+\n+class Private\n+{\n+  Private() = default;\n+  Private(const Private&) = default;\n+  ~Private() = default;\n+\n+  friend class MyAlloc<Private>;\n+\n+public:\n+  int get() const { return 0; }\n+};\n+\n+template<typename T>\n+struct MyAlloc : std::allocator<Private>\n+{\n+  void construct(T* p) { ::new((void*)p) T(); }\n+  void destroy(T* p) { p->~T(); }\n+};\n+\n+int main()\n+{\n+  MyAlloc<Private> a;\n+  auto p = std::allocate_shared<Private>(a);\n+  return p->get();\n+}\n+"}, {"sha": "aa8934d47e60c148ed87a7710849d6bbea5744ce", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/alloc_min.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Falloc_min.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Falloc_min.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Falloc_min.cc?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Test that packaged_task can use a minimal C++11 allocator\n+// and doesn't rely on C++98 allocator interface.\n+\n+#include <future>\n+#include <testsuite_allocator.h>\n+\n+using std::packaged_task;\n+using std::allocator_arg;\n+\n+__gnu_test::SimpleAllocator<int> a;\n+packaged_task<int()> p(allocator_arg, a, []() { return 1; });"}, {"sha": "ba7c55334f0537350df6fa78fd1826f86709be5d", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/alloc_min.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Falloc_min.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58a38b32c7ed8b4843e8d2b2658323204fa96ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Falloc_min.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Falloc_min.cc?ref=a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Test that promise can use a minimal C++11 allocator\n+// and doesn't rely on C++98 allocator interface.\n+\n+#include <future>\n+#include <testsuite_allocator.h>\n+\n+using std::promise;\n+using std::allocator_arg;\n+using std::tuple;\n+\n+typedef promise<int>  p;\n+typedef promise<int&> pr;\n+typedef promise<void> pv;\n+__gnu_test::SimpleAllocator<p> a;\n+\n+tuple<p, pr, pv> t1{ allocator_arg, a };\n+tuple<p, pr, pv> t2{ allocator_arg, a, p{}, pr{}, pv{} };"}]}