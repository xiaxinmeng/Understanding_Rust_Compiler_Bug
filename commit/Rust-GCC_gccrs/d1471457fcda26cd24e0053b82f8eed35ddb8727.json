{"sha": "d1471457fcda26cd24e0053b82f8eed35ddb8727", "node_id": "C_kwDOANBUbNoAKGQxNDcxNDU3ZmNkYTI2Y2QyNGUwMDUzYjgyZjhlZWQzNWRkYjg3Mjc", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-28T18:25:33Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-28T18:25:33Z"}, "message": "Improve -fprofile-report\n\nProfile-report was never properly updated after switch to new profile\nrepresentation.  This patch fixes the way profile mismatches are calculated:\nwe used to collect separately count and freq mismatches, while now we have\nonly counts & probabilities.  So we verify\n - in count: that total count of incomming edges is close to acutal count of\n   the BB\n - out prob: that total sum of outgoing edge edge probabilities is close\n   to 1 (except for BB containing noreturn calls or EH).\n\nMoreover I added dumping of absolute data which is useful to plot them: with\nMartin Liska we plan to setup regular testing so we keep optimizers profie\nupdates bit under control.\n\nFinally I added both static and dynamic stats about mismatches - static one is\nsimply number of inconsistencies in the cfg while dynamic is scaled by the\nprofile - I think in order to keep eye on optimizers the first number is quite\nrelevant. WHile when tracking why code quality regressed the second number\nmatters more.\n\n2021-11-28  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* cfghooks.c: Include sreal.h, profile.h.\n\t(profile_record_check_consistency): Fix checking of count counsistency;\n\trecord also dynamic mismatches.\n\t* cfgrtl.c (rtl_account_profile_record): Similarly.\n\t* tree-cfg.c (gimple_account_profile_record): Likewise.\n\t* cfghooks.h (struct profile_record): Remove num_mismatched_freq_in,\n\tnum_mismatched_freq_out, turn time to double, add\n\tdyn_mismatched_prob_out, dyn_mismatched_count_in,\n\tnum_mismatched_prob_out; remove num_mismatched_count_out.\n\t* passes.c (account_profile_1): New function.\n\t(account_profile_in_list): New function.\n\t(pass_manager::dump_profile_report): Rewrite.\n\t(execute_one_ipa_transform_pass): Check profile consistency after\n\trunning all passes.\n\t(execute_all_ipa_transforms): Remove cfun test; record all transform\n\tmethods.\n\t(execute_one_pass): Fix collecting of profile stats.", "tree": {"sha": "ccb130300fe101af002265cb1efebb51938b17a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccb130300fe101af002265cb1efebb51938b17a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1471457fcda26cd24e0053b82f8eed35ddb8727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1471457fcda26cd24e0053b82f8eed35ddb8727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1471457fcda26cd24e0053b82f8eed35ddb8727", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1471457fcda26cd24e0053b82f8eed35ddb8727/comments", "author": null, "committer": null, "parents": [{"sha": "7393fa8b1d21eeeb37e59ff8efaebf178fd891e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7393fa8b1d21eeeb37e59ff8efaebf178fd891e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7393fa8b1d21eeeb37e59ff8efaebf178fd891e5"}], "stats": {"total": 393, "additions": 269, "deletions": 124}, "files": [{"sha": "550dc4a2a8fd99309dadc37014838fca92390e4c", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=d1471457fcda26cd24e0053b82f8eed35ddb8727", "patch": "@@ -31,6 +31,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfganal.h\"\n #include \"tree-ssa.h\"\n #include \"cfgloop.h\"\n+#include \"sreal.h\"\n+#include \"profile.h\"\n \n /* Disable warnings about missing quoting in GCC diagnostics.  */\n #if __GNUC__ >= 10\n@@ -1467,41 +1469,73 @@ profile_record_check_consistency (profile_record *record)\n   FOR_ALL_BB_FN (bb, cfun)\n    {\n       if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t  && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n+\t  && profile_status_for_fn (cfun) != PROFILE_ABSENT\n+\t  && EDGE_COUNT (bb->succs))\n \t{\n-\t  profile_probability sum = profile_probability::never ();\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    sum += e->probability;\n-\t  if (EDGE_COUNT (bb->succs)\n-\t      && sum.differs_from_p (profile_probability::always ()))\n-\t    record->num_mismatched_freq_out++;\n-\t  profile_count lsum = profile_count::zero ();\n+\t  sreal sum = 0;\n+\t  bool found = false;\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    lsum += e->count ();\n-\t  if (EDGE_COUNT (bb->succs) && (lsum.differs_from_p (bb->count)))\n-\t    record->num_mismatched_count_out++;\n+\t    {\n+\t      if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+\t\tfound = true;\n+\t      if (e->probability.initialized_p ())\n+\t        sum += e->probability.to_sreal ();\n+\t    }\n+\t  double dsum = sum.to_double ();\n+\t  if (found && (dsum < 0.9 || dsum > 1.1)\n+\t      && !(bb->count == profile_count::zero ()))\n+\t    {\n+\t      record->num_mismatched_prob_out++;\n+\t      dsum = dsum > 1 ? dsum - 1 : 1 - dsum;\n+\t      if (profile_info)\n+\t\t{\n+\t\t  if (ENTRY_BLOCK_PTR_FOR_FN\n+\t\t\t (cfun)->count.ipa ().initialized_p ()\n+\t\t      && ENTRY_BLOCK_PTR_FOR_FN\n+\t\t\t (cfun)->count.ipa ().nonzero_p ()\n+\t\t      && bb->count.ipa ().initialized_p ())\n+\t\t    record->dyn_mismatched_prob_out\n+\t\t\t+= dsum * bb->count.ipa ().to_gcov_type ();\n+\t\t}\n+\t      else if (bb->count.initialized_p ())\n+\t\trecord->dyn_mismatched_prob_out\n+\t\t    += dsum * bb->count.to_sreal_scale\n+\t\t\t(ENTRY_BLOCK_PTR_FOR_FN (cfun)->count).to_double ();\n+\t    }\n \t}\n       if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t{\n-\t  profile_probability sum = profile_probability::never ();\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    lsum += e->count ();\n+\t  if (lsum.differs_from_p (bb->count))\n \t    {\n-\t      sum += e->probability;\n-\t      lsum += e->count ();\n+\t      record->num_mismatched_count_in++;\n+\t      profile_count max;\n+\t      if (lsum < bb->count)\n+\t\tmax = bb->count;\n+\t      else\n+\t\tmax = lsum;\n+\t      if (profile_info)\n+\t\t{\n+\t\t  if (ENTRY_BLOCK_PTR_FOR_FN\n+\t\t\t (cfun)->count.ipa ().initialized_p ()\n+\t\t      && ENTRY_BLOCK_PTR_FOR_FN\n+\t\t\t (cfun)->count.ipa ().nonzero_p ()\n+\t\t      && max.ipa ().initialized_p ())\n+\t\t    record->dyn_mismatched_count_in\n+\t\t\t+= max.ipa ().to_gcov_type ();\n+\t\t}\n+\t      else if (bb->count.initialized_p ())\n+\t\trecord->dyn_mismatched_prob_out\n+\t\t    += max.to_sreal_scale\n+\t\t\t(ENTRY_BLOCK_PTR_FOR_FN (cfun)->count).to_double ();\n \t    }\n-\t  if (EDGE_COUNT (bb->preds)\n-\t      && sum.differs_from_p (profile_probability::always ()))\n-\t    record->num_mismatched_freq_in++;\n-\t  if (lsum.differs_from_p (bb->count))\n-\t    record->num_mismatched_count_in++;\n \t}\n       if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n-      gcc_assert (cfg_hooks->account_profile_record);\n-      cfg_hooks->account_profile_record (bb, record);\n    }\n }\n "}, {"sha": "684e6319d2631f1fdf012acd5a779274344ea92f", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=d1471457fcda26cd24e0053b82f8eed35ddb8727", "patch": "@@ -36,22 +36,25 @@ along with GCC; see the file COPYING3.  If not see\n    and one CFG hook per CFG mode.  */\n struct profile_record\n {\n-  /* The number of basic blocks where sum(freq) of the block's predecessors\n-     doesn't match reasonably well with the incoming frequency.  */\n-  int num_mismatched_freq_in;\n-  /* Likewise for a basic block's successors.  */\n-  int num_mismatched_freq_out;\n+  /* A weighted cost of the run-time of the function body.  */\n+  double time;\n+  /* Frequency of execution of basic blocks where sum(prob) of the block's\n+     predecessors doesn't match reasonably probability 1.  */\n+  double dyn_mismatched_prob_out;\n+  /* Frequency of execution basic blocks where sum(count) of the block's\n+     predecessors doesn't match reasonably well with the incoming frequency.  */\n+  double dyn_mismatched_count_in;\n+  /* The number of basic blocks where sum(prob) of the block's predecessors\n+     doesn't match reasonably probability 1.  */\n+  int num_mismatched_prob_out;\n   /* The number of basic blocks where sum(count) of the block's predecessors\n      doesn't match reasonably well with the incoming frequency.  */\n   int num_mismatched_count_in;\n-  /* Likewise for a basic block's successors.  */\n-  int num_mismatched_count_out;\n-  /* A weighted cost of the run-time of the function body.  */\n-  gcov_type_unsigned time;\n   /* A weighted cost of the size of the function body.  */\n   int size;\n   /* True iff this pass actually was run.  */\n   bool run;\n+  bool fdo;\n };\n \n typedef int_hash <unsigned short, 0> dependence_hash;"}, {"sha": "3744adcc2ba1045836406a244a628a9d860bc259", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=d1471457fcda26cd24e0053b82f8eed35ddb8727", "patch": "@@ -63,6 +63,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"print-rtl.h\"\n #include \"rtl-iter.h\"\n #include \"gimplify.h\"\n+#include \"profile.h\"\n+#include \"sreal.h\"\n \n /* Disable warnings about missing quoting in GCC diagnostics.  */\n #if __GNUC__ >= 10\n@@ -5264,12 +5266,22 @@ rtl_account_profile_record (basic_block bb, struct profile_record *record)\n     if (INSN_P (insn))\n       {\n \trecord->size += insn_cost (insn, false);\n-\tif (bb->count.initialized_p ())\n-\t  record->time\n-\t    += insn_cost (insn, true) * bb->count.to_gcov_type ();\n-\telse if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n+\tif (profile_info)\n+\t  {\n+\t    if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ().initialized_p ()\n+\t\t&& ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ().nonzero_p ()\n+\t\t&& bb->count.ipa ().initialized_p ())\n+\t      record->time\n+\t\t+= insn_cost (insn, true) * bb->count.ipa ().to_gcov_type ();\n+\t  }\n+\telse if (bb->count.initialized_p ()\n+\t\t && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ())\n \t  record->time\n-\t    += insn_cost (insn, true) * bb->count.to_frequency (cfun);\n+\t    += insn_cost (insn, true)\n+\t       * bb->count.to_sreal_scale\n+\t\t      (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count).to_double ();\n+\telse\n+\t  record->time += insn_cost (insn, true);\n       }\n }\n "}, {"sha": "4bea6ae5b6a3fba69bb9378bc0a6605b7989338b", "filename": "gcc/passes.c", "status": "modified", "additions": 162, "deletions": 81, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d1471457fcda26cd24e0053b82f8eed35ddb8727", "patch": "@@ -1882,6 +1882,33 @@ account_profile (int index, bool run)\n   profile_record_account_profile (&profile_record[index]);\n }\n \n+/* Account profile for IPA pass.  Callback for do_per_function.  */\n+\n+static void\n+account_profile_1 (function *fn, void *data)\n+{\n+  opt_pass *pass = (opt_pass *)data;\n+\n+  push_cfun (fn);\n+  check_profile_consistency (pass->static_pass_number, true);\n+  account_profile (pass->static_pass_number, true);\n+  pop_cfun ();\n+}\n+\n+/* Account profile chnages to all passes in list starting in SUB.  */\n+\n+static void\n+account_profile_in_list (opt_pass *sub)\n+{\n+  for (; sub; sub = sub->next)\n+    {\n+      check_profile_consistency (sub->static_pass_number, false);\n+      account_profile (sub->static_pass_number, false);\n+      if (sub->sub)\n+\taccount_profile_in_list (sub->sub);\n+    }\n+}\n+\n /* Output profile consistency.  */\n \n void\n@@ -1893,10 +1920,12 @@ dump_profile_report (void)\n void\n pass_manager::dump_profile_report () const\n {\n-  int last_freq_in = 0, last_count_in = 0, last_freq_out = 0, last_count_out = 0;\n-  gcov_type last_time = 0, last_size = 0;\n+  int last_count_in = 0, last_prob_out = 0;\n+  double last_dyn_count_in = 0, last_dyn_prob_out = 0;\n+  double last_time = 0;\n+  int last_size = 0;\n   double rel_time_change, rel_size_change;\n-  int last_reported = 0;\n+  gcc::dump_manager *dumps = m_ctxt->get_dumps ();\n \n   if (!profile_record)\n     return;\n@@ -1906,16 +1935,21 @@ pass_manager::dump_profile_report () const\n     dump_file = stderr;\n \n   fprintf (dump_file, \"Profile consistency report:\\n\\n\");\n-  fprintf (dump_file, \"                                 |mismatch     |mismatch     |                     |\\n\");\n-  fprintf (dump_file, \"Pass name                        |IN    |IN    |OUT   |OUT   |overall              |\\n\");\n-  fprintf (dump_file, \"                                 |freq  |count |freq  |count |size      |time      |\\n\");\n+  fprintf (dump_file,\n+\t   \"Pass dump id and name            |static mismatch            \"\n+\t   \"|dynamic mismatch                                     \"\n+\t   \"|overall                                       |\\n\");\n+  fprintf (dump_file,\n+\t   \"                                 |in count     |out prob     \"\n+\t   \"|in count                  |out prob                  \"\n+\t   \"|size               |time                      |\\n\");\n \t   \n   for (int i = 1; i < passes_by_id_size; i++)\n     if (profile_record[i].run)\n       {\n \tif (last_time)\n \t  rel_time_change = (profile_record[i].time\n-\t\t\t     - (double)last_time) * 100 / (double)last_time;\n+\t\t\t     - last_time) * 100 / last_time;\n \telse\n \t  rel_time_change = 0;\n \tif (last_size)\n@@ -1924,65 +1958,73 @@ pass_manager::dump_profile_report () const\n \telse\n \t  rel_size_change = 0;\n \n-\tif (profile_record[i].num_mismatched_freq_in != last_freq_in\n-\t    || profile_record[i].num_mismatched_freq_out != last_freq_out\n-\t    || profile_record[i].num_mismatched_count_in != last_count_in\n-\t    || profile_record[i].num_mismatched_count_out != last_count_out\n-\t    || rel_time_change || rel_size_change)\n+\tdump_file_info *dfi = dumps->get_dump_file_info (i);\n+\n+\tfprintf (dump_file, \"%3i%c %-28s| %6i\",\n+\t\t dfi->num,\n+\t\t passes_by_id[i]->type == GIMPLE_PASS ? 't'\n+\t\t : passes_by_id[i]->type == RTL_PASS ? 'r'\n+\t\t : 'i',\n+\t\t passes_by_id[i]->name,\n+\t\t profile_record[i].num_mismatched_count_in);\n+\tif (profile_record[i].num_mismatched_count_in != last_count_in)\n+\t  fprintf (dump_file, \" %+5i\",\n+\t\t   profile_record[i].num_mismatched_count_in\n+\t\t   - last_count_in);\n+\telse\n+\t  fprintf (dump_file, \"      \");\n+\tfprintf (dump_file, \"| %6i\",\n+\t\t profile_record[i].num_mismatched_prob_out);\n+\tif (profile_record[i].num_mismatched_prob_out != last_prob_out)\n+\t  fprintf (dump_file, \" %+5i\",\n+\t\t   profile_record[i].num_mismatched_prob_out\n+\t\t   - last_prob_out);\n+\telse\n+\t  fprintf (dump_file, \"      \");\n+\n+\tfprintf (dump_file, \"| %12.0f\",\n+\t\t profile_record[i].dyn_mismatched_count_in);\n+\tif (profile_record[i].dyn_mismatched_count_in != last_dyn_count_in)\n+\t  fprintf (dump_file, \" %+12.0f\",\n+\t\t   profile_record[i].dyn_mismatched_count_in\n+\t\t   - last_dyn_count_in);\n+\telse\n+\t  fprintf (dump_file, \"             \");\n+\tfprintf (dump_file, \"| %12.0f\",\n+\t\t profile_record[i].dyn_mismatched_prob_out);\n+\tif (profile_record[i].dyn_mismatched_prob_out != last_dyn_prob_out)\n+\t  fprintf (dump_file, \" %+12.0f\",\n+\t\t   profile_record[i].dyn_mismatched_prob_out\n+\t\t   - last_dyn_prob_out);\n+\telse\n+\t  fprintf (dump_file, \"             \");\n+\n+\t/* Size/time units change across gimple and RTL.  */\n+\tif (i == pass_expand_1->static_pass_number)\n+\t  fprintf (dump_file,\n+\t\t   \"|-------------------|--------------------------\");\n+\telse\n \t  {\n-\t    last_reported = i;\n-\t    fprintf (dump_file, \"%-33s\", passes_by_id[i]->name);\n-\t    if (profile_record[i].num_mismatched_freq_in != last_freq_in)\n-\t      fprintf (dump_file, \"| %+5i\",\n-\t\t       profile_record[i].num_mismatched_freq_in\n-\t\t       - last_freq_in);\n-\t    else\n-\t      fprintf (dump_file, \"|      \");\n-\t    if (profile_record[i].num_mismatched_count_in != last_count_in)\n-\t      fprintf (dump_file, \"| %+5i\",\n-\t\t       profile_record[i].num_mismatched_count_in\n-\t\t       - last_count_in);\n-\t    else\n-\t      fprintf (dump_file, \"|      \");\n-\t    if (profile_record[i].num_mismatched_freq_out != last_freq_out)\n-\t      fprintf (dump_file, \"| %+5i\",\n-\t\t       profile_record[i].num_mismatched_freq_out\n-\t\t       - last_freq_out);\n-\t    else\n-\t      fprintf (dump_file, \"|      \");\n-\t    if (profile_record[i].num_mismatched_count_out != last_count_out)\n-\t      fprintf (dump_file, \"| %+5i\",\n-\t\t       profile_record[i].num_mismatched_count_out\n-\t\t       - last_count_out);\n+\t    fprintf (dump_file, \"| %8i\", profile_record[i].size);\n+\t    if (rel_size_change)\n+\t      fprintf (dump_file, \" %+8.1f%%\", rel_size_change);\n \t    else\n-\t      fprintf (dump_file, \"|      \");\n-\n-\t    /* Size/time units change across gimple and RTL.  */\n-\t    if (i == pass_expand_1->static_pass_number)\n-\t      fprintf (dump_file, \"|----------|----------\");\n+\t      fprintf (dump_file, \"          \");\n+\t    fprintf (dump_file, \"| %12.0f\", profile_record[i].time);\n+\t    /* Time units changes with profile estimate and feedback.  */\n+\t    if (i == pass_profile_1->static_pass_number\n+\t\t|| i == pass_ipa_tree_profile_1->static_pass_number)\n+\t      fprintf (dump_file, \"-------------\");\n+\t    else if (rel_time_change)\n+\t      fprintf (dump_file, \" %+11.1f%%\", rel_time_change);\n \t    else\n-\t      {\n-\t\tif (rel_size_change)\n-\t\t  fprintf (dump_file, \"| %+8.1f%%\", rel_size_change);\n-\t\telse\n-\t\t  fprintf (dump_file, \"|          \");\n-\t\tif (rel_time_change)\n-\t\t  fprintf (dump_file, \"| %+8.1f%%\", rel_time_change);\n-\t\telse\n-\t\t  fprintf (dump_file, \"|          \");\n-\t      }\n-\t    fprintf (dump_file, \"|\\n\");\n-\t    last_freq_in = profile_record[i].num_mismatched_freq_in;\n-\t    last_freq_out = profile_record[i].num_mismatched_freq_out;\n-\t    last_count_in = profile_record[i].num_mismatched_count_in;\n-\t    last_count_out = profile_record[i].num_mismatched_count_out;\n-\t  }\n-\telse if (last_reported != i)\n-\t  {\n-\t    last_reported = i;\n-\t    fprintf (dump_file, \"%-20s ------------|      |      |      |      |          |          |\\n\",\n-\t\t     passes_by_id[i]->name);\n+\t      fprintf (dump_file, \"             \");\n \t  }\n+\tfprintf (dump_file, \"|\\n\");\n+\tlast_prob_out = profile_record[i].num_mismatched_prob_out;\n+\tlast_count_in = profile_record[i].num_mismatched_count_in;\n+\tlast_dyn_prob_out = profile_record[i].dyn_mismatched_prob_out;\n+\tlast_dyn_count_in = profile_record[i].dyn_mismatched_count_in;\n \tlast_time = profile_record[i].time;\n \tlast_size = profile_record[i].size;\n       }\n@@ -2280,9 +2322,6 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n   if (pass->tv_id != TV_NONE)\n     timevar_push (pass->tv_id);\n \n-  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    check_profile_consistency (pass->static_pass_number, true);\n-\n   /* Run pre-pass verification.  */\n   execute_todo (ipa_pass->function_transform_todo_flags_start);\n \n@@ -2292,8 +2331,6 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after);\n   verify_interpass_invariants ();\n-  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    account_profile (pass->static_pass_number, true);\n \n   /* Stop timevar.  */\n   if (pass->tv_id != TV_NONE)\n@@ -2317,10 +2354,9 @@ void\n execute_all_ipa_transforms (bool do_not_collect)\n {\n   struct cgraph_node *node;\n-  if (!cfun)\n-    return;\n   node = cgraph_node::get (current_function_decl);\n \n+\n   cgraph_node *next_clone;\n   for (cgraph_node *n = node->clones; n; n = next_clone)\n     {\n@@ -2329,15 +2365,48 @@ execute_all_ipa_transforms (bool do_not_collect)\n \tn->materialize_clone ();\n     }\n \n-  if (node->ipa_transforms_to_apply.exists ())\n-    {\n-      unsigned int i;\n+  int j = 0;\n+  gcc::pass_manager *passes = g->get_passes ();\n+  bool report = profile_report && (cfun->curr_properties & PROP_gimple) != 0;\n \n-      for (i = 0; i < node->ipa_transforms_to_apply.length (); i++)\n-\texecute_one_ipa_transform_pass (node, node->ipa_transforms_to_apply[i],\n-\t\t\t\t\tdo_not_collect);\n-      node->ipa_transforms_to_apply.release ();\n+  if (report)\n+    push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+  for (auto p : node->ipa_transforms_to_apply)\n+    {\n+      /* To get consistent statistics, we need to account each functio\n+\t to each IPA pass.  */\n+      if (report)\n+\t{\n+\t  for (;j < p->static_pass_number; j++)\n+\t    if (passes->get_pass_for_id (j)\n+\t\t&& passes->get_pass_for_id (j)->type == IPA_PASS\n+\t\t&& ((ipa_opt_pass_d *)passes->get_pass_for_id (j))\n+\t\t   ->function_transform)\n+\t      {\n+\t\tcheck_profile_consistency (j, true);\n+\t\taccount_profile (j, true);\n+\t      }\n+\t  gcc_checking_assert (passes->get_pass_for_id (j) == p);\n+\t}\n+      execute_one_ipa_transform_pass (node, p, do_not_collect);\n     }\n+  /* Account remaining IPA passes.  */\n+  if (report)\n+    {\n+      for (;!passes->get_pass_for_id (j)\n+\t    || passes->get_pass_for_id (j)->type != RTL_PASS; j++)\n+\tif (passes->get_pass_for_id (j)\n+\t    && passes->get_pass_for_id (j)->type == IPA_PASS\n+\t    && ((ipa_opt_pass_d *)passes->get_pass_for_id (j))\n+\t       ->function_transform)\n+\t  {\n+\t    check_profile_consistency (j, true);\n+\t    account_profile (j, true);\n+\t  }\n+      pop_cfun ();\n+    }\n+  node->ipa_transforms_to_apply.release ();\n }\n \n /* Check if PASS is explicitly disabled or enabled and return\n@@ -2521,10 +2590,13 @@ execute_one_pass (opt_pass *pass)\n     {\n       /* Run so passes selectively disabling themselves on a given function\n \t are not miscounted.  */\n-      if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+      if (profile_report && cfun && (cfun->curr_properties & PROP_cfg)\n+\t  && pass->type != IPA_PASS && pass->type != SIMPLE_IPA_PASS)\n \t{\n \t  check_profile_consistency (pass->static_pass_number, false);\n \t  account_profile (pass->static_pass_number, false);\n+\t  if (pass->sub)\n+\t    account_profile_in_list (pass->sub);\n \t}\n       current_pass = NULL;\n       return false;\n@@ -2553,8 +2625,6 @@ execute_one_pass (opt_pass *pass)\n   if (pass->tv_id != TV_NONE)\n     timevar_push (pass->tv_id);\n \n-  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    check_profile_consistency (pass->static_pass_number, true);\n \n   /* Run pre-pass verification.  */\n   execute_todo (pass->todo_flags_start);\n@@ -2602,8 +2672,19 @@ execute_one_pass (opt_pass *pass)\n \n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after | pass->todo_flags_finish | TODO_verify_il);\n-  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n-    account_profile (pass->static_pass_number, true);\n+  if (profile_report)\n+    {\n+      /* IPA passes are accounted at transform time.  */\n+      if (pass->type == IPA_PASS)\n+\t;\n+      else if (pass->type == SIMPLE_IPA_PASS)\n+\tdo_per_function (account_profile_1, pass);\n+      else if (cfun && (cfun->curr_properties & PROP_cfg))\n+\t{\n+\t  check_profile_consistency (pass->static_pass_number, true);\n+\t  account_profile (pass->static_pass_number, true);\n+\t}\n+    }\n \n   verify_interpass_invariants ();\n "}, {"sha": "ebbd894ae0312e23b9bce68051c9101c7a7c3867", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1471457fcda26cd24e0053b82f8eed35ddb8727/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d1471457fcda26cd24e0053b82f8eed35ddb8727", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"asan.h\"\n #include \"profile.h\"\n+#include \"sreal.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -9084,18 +9085,32 @@ gimple_account_profile_record (basic_block bb,\n \t\t\t       struct profile_record *record)\n {\n   gimple_stmt_iterator i;\n-  for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+  for (i = gsi_start_nondebug_after_labels_bb (bb); !gsi_end_p (i);\n+       gsi_next_nondebug (&i))\n     {\n       record->size\n \t+= estimate_num_insns (gsi_stmt (i), &eni_size_weights);\n-      if (bb->count.initialized_p ())\n+      if (profile_info)\n+\t{\n+\t  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ().initialized_p ()\n+\t      && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ().nonzero_p ()\n+\t      && bb->count.ipa ().initialized_p ())\n+\t    record->time\n+\t      += estimate_num_insns (gsi_stmt (i),\n+\t\t\t\t     &eni_time_weights)\n+\t\t\t\t     * bb->count.ipa ().to_gcov_type ();\n+\t}\n+      else if (bb->count.initialized_p ()\n+\t       && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ())\n \trecord->time\n-\t  += estimate_num_insns (gsi_stmt (i),\n-\t\t\t\t &eni_time_weights) * bb->count.to_gcov_type ();\n-      else if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n-\trecord->time\n-\t  += estimate_num_insns (gsi_stmt (i),\n-\t\t\t\t &eni_time_weights) * bb->count.to_frequency (cfun);\n+\t  += estimate_num_insns\n+\t\t(gsi_stmt (i),\n+\t\t &eni_time_weights)\n+\t\t * bb->count.to_sreal_scale\n+\t\t\t(ENTRY_BLOCK_PTR_FOR_FN (cfun)->count).to_double ();\n+     else\n+      record->time\n+\t+= estimate_num_insns (gsi_stmt (i), &eni_time_weights);\n     }\n }\n "}]}