{"sha": "a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU5MTdmZmIyY2Q3MDk3ZjliOGI3NTRjMjc0NWMyM2Q4NjBjYjMxYQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2011-10-13T10:56:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:56:08Z"}, "message": "a-ngrear.adb (Solve): Make generic and move to System.Generic_Array_Operations.\n\n2011-10-13  Geert Bosch  <bosch@adacore.com>\n\n\t* a-ngrear.adb (Solve): Make generic and move to\n\tSystem.Generic_Array_Operations.\n\t* s-gearop.ads (Matrix_Vector_Solution, Matrix_Matrix_Solution):\n\tNew generic solvers to\tcompute a vector resp. matrix Y such\n\tthat A * Y = X, approximately.\n\t* s-gearop.adb (Matrix_Vector_Solution, Matrix_Matrix_Solution):\n\tImplement using Forward_Eliminate and Back_Substitute\n\t* a-ngcoar.adb: Reimplement in pure Ada to remove dependencies\n\ton BLAS and LAPACK.\n\t* a-ngcoar.ads (\"abs\"): Fix return type to be real.\n\nFrom-SVN: r179912", "tree": {"sha": "faa2dafc5d78a37661ab07fb69bb75daae1fcfc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faa2dafc5d78a37661ab07fb69bb75daae1fcfc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/comments", "author": null, "committer": null, "parents": [{"sha": "574ec9452d38bc8b3c14aea7afd72b073f973c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574ec9452d38bc8b3c14aea7afd72b073f973c86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574ec9452d38bc8b3c14aea7afd72b073f973c86"}], "stats": {"total": 765, "additions": 293, "deletions": 472}, "files": [{"sha": "04b04fd7e8f5140e5cf07774123a810531c9229c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "patch": "@@ -1,3 +1,16 @@\n+2011-10-13  Geert Bosch  <bosch@adacore.com>\n+\n+\t* a-ngrear.adb (Solve): Make generic and move to\n+\tSystem.Generic_Array_Operations.\n+\t* s-gearop.ads (Matrix_Vector_Solution, Matrix_Matrix_Solution):\n+\tNew generic solvers to\tcompute a vector resp. matrix Y such\n+\tthat A * Y = X, approximately.\n+\t* s-gearop.adb (Matrix_Vector_Solution, Matrix_Matrix_Solution):\n+\tImplement using Forward_Eliminate and Back_Substitute\n+\t* a-ngcoar.adb: Reimplement in pure Ada to remove dependencies\n+\ton BLAS and LAPACK.\n+\t* a-ngcoar.ads (\"abs\"): Fix return type to be real.\n+\n 2011-10-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/50589"}, {"sha": "3be88491d7fdfd68712f0d6bc8b3c4a38b1b2d0f", "filename": "gcc/ada/a-ngcoar.adb", "status": "modified", "additions": 171, "deletions": 419, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fa-ngcoar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fa-ngcoar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoar.adb?ref=a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2006-2009, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2006-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,66 +30,35 @@\n ------------------------------------------------------------------------------\n \n with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n-with System.Generic_Complex_BLAS;\n-with System.Generic_Complex_LAPACK;\n+with Ada.Numerics; use Ada.Numerics;\n \n package body Ada.Numerics.Generic_Complex_Arrays is\n \n-   --  Operations involving inner products use BLAS library implementations.\n-   --  This allows larger matrices and vectors to be computed efficiently,\n-   --  taking into account memory hierarchy issues and vector instructions\n-   --  that vary widely between machines.\n-\n    --  Operations that are defined in terms of operations on the type Real,\n    --  such as addition, subtraction and scaling, are computed in the canonical\n    --  way looping over all elements.\n \n-   --  Operations for solving linear systems and computing determinant,\n-   --  eigenvalues, eigensystem and inverse, are implemented using the\n-   --  LAPACK library.\n-\n-   type BLAS_Real_Vector is array (Integer range <>) of Real;\n-\n-   package BLAS is new System.Generic_Complex_BLAS\n-     (Real           => Real,\n-      Complex_Types  => Complex_Types,\n-      Complex_Vector => Complex_Vector,\n-      Complex_Matrix => Complex_Matrix);\n-\n-   package LAPACK is new System.Generic_Complex_LAPACK\n-     (Real           => Real,\n-      Real_Vector    => BLAS_Real_Vector,\n-      Complex_Types  => Complex_Types,\n-      Complex_Vector => Complex_Vector,\n-      Complex_Matrix => Complex_Matrix);\n+   package Ops renames System.Generic_Array_Operations;\n \n    subtype Real is Real_Arrays.Real;\n    --  Work around visibility bug ???\n \n-   use BLAS, LAPACK;\n-\n-   --  Procedure versions of functions returning unconstrained values.\n-   --  This allows for inlining the function wrapper.\n+   function Is_Non_Zero (X : Complex) return Boolean is (X /= (0.0, 0.0));\n+   --  Needed by Back_Substitute\n \n-   procedure Eigenvalues\n-     (A      : Complex_Matrix;\n-      Values : out Real_Vector);\n+   procedure Back_Substitute is new Ops.Back_Substitute\n+     (Scalar        => Complex,\n+      Matrix        => Complex_Matrix,\n+      Is_Non_Zero   => Is_Non_Zero);\n \n-   procedure Inverse\n-     (A      : Complex_Matrix;\n-      R      : out Complex_Matrix);\n+   procedure Forward_Eliminate is new Ops.Forward_Eliminate\n+    (Scalar        => Complex,\n+     Real          => Real'Base,\n+     Matrix        => Complex_Matrix,\n+     Zero          => (0.0, 0.0),\n+     One           => (1.0, 0.0));\n \n-   procedure Solve\n-     (A      : Complex_Matrix;\n-      X      : Complex_Vector;\n-      B      : out Complex_Vector);\n-\n-   procedure Solve\n-     (A      : Complex_Matrix;\n-      X      : Complex_Matrix;\n-      B      : out Complex_Matrix);\n-\n-   procedure Transpose is new System.Generic_Array_Operations.Transpose\n+   procedure Transpose is new Ops.Transpose\n                                 (Scalar => Complex,\n                                  Matrix => Complex_Matrix);\n \n@@ -98,6 +67,12 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n \n    function Length is new Square_Matrix_Length (Complex, Complex_Matrix);\n \n+   --  Instant a generic square root implementation here, in order to avoid\n+   --  instantiating a complete copy of Generic_Elementary_Functions.\n+   --  Speed of the square root is not a big concern here.\n+\n+   function Sqrt is new Ops.Sqrt (Real'Base);\n+\n    --  Instantiating the following subprograms directly would lead to\n    --  name clashes, so use a local package.\n \n@@ -155,6 +130,14 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n                              Right_Vector  => Complex_Vector,\n                              Zero          => (0.0, 0.0));\n \n+      function \"*\" is new Inner_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Right_Vector  => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n       function \"*\" is new Outer_Product\n                             (Left_Scalar   => Complex,\n                              Right_Scalar  => Complex,\n@@ -229,6 +212,15 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n                              Result_Vector => Complex_Vector,\n                              Zero          => (0.0, 0.0));\n \n+      function \"*\" is new Matrix_Vector_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Matrix        => Complex_Matrix,\n+                             Right_Vector  => Complex_Vector,\n+                             Result_Vector => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n       function \"*\" is new Vector_Matrix_Product\n                             (Left_Scalar   => Real'Base,\n                              Right_Scalar  => Complex,\n@@ -247,6 +239,24 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n                              Result_Vector => Complex_Vector,\n                              Zero          => (0.0, 0.0));\n \n+      function \"*\" is new Vector_Matrix_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Vector   => Complex_Vector,\n+                             Matrix        => Complex_Matrix,\n+                             Result_Vector => Complex_Vector,\n+                             Zero          => (0.0, 0.0));\n+\n+      function \"*\" is new Matrix_Matrix_Product\n+                            (Left_Scalar   => Complex,\n+                             Right_Scalar  => Complex,\n+                             Result_Scalar => Complex,\n+                             Left_Matrix   => Complex_Matrix,\n+                             Right_Matrix  => Complex_Matrix,\n+                             Result_Matrix => Complex_Matrix,\n+                             Zero          => (0.0, 0.0));\n+\n       function \"*\" is new Matrix_Matrix_Product\n                             (Left_Scalar   => Real'Base,\n                              Right_Scalar  => Complex,\n@@ -445,6 +455,15 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n                              Result_Matrix => Complex_Matrix,\n                              Operation     => \"/\");\n \n+      -----------\n+      -- \"abs\" --\n+      -----------\n+\n+      function \"abs\" is new L2_Norm\n+                              (X_Scalar      => Complex,\n+                               Result_Real   => Real'Base,\n+                               X_Vector      => Complex_Vector);\n+\n       --------------\n       -- Argument --\n       --------------\n@@ -671,6 +690,16 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n                              Y_Matrix      => Real_Matrix,\n                              Update        => Set_Re);\n \n+      -----------\n+      -- Solve --\n+      -----------\n+\n+      function Solve is\n+         new Matrix_Vector_Solution (Complex, Complex_Vector, Complex_Matrix);\n+\n+      function Solve is\n+         new Matrix_Matrix_Solution (Complex, Complex_Matrix);\n+\n       -----------------\n       -- Unit_Matrix --\n       -----------------\n@@ -686,7 +715,6 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n                              Vector        => Complex_Vector,\n                              Zero          => (0.0, 0.0),\n                              One           => (1.0, 0.0));\n-\n    end Instantiations;\n \n    ---------\n@@ -696,15 +724,7 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n    function \"*\"\n      (Left  : Complex_Vector;\n       Right : Complex_Vector) return Complex\n-   is\n-   begin\n-      if Left'Length /= Right'Length then\n-         raise Constraint_Error with\n-            \"vectors are of different length in inner product\";\n-      end if;\n-\n-      return dot (Left'Length, X => Left, Y => Right);\n-   end \"*\";\n+     renames Instantiations.\"*\";\n \n    function \"*\"\n      (Left  : Real_Vector;\n@@ -738,31 +758,8 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n \n    function \"*\"\n      (Left  : Complex_Matrix;\n-      Right : Complex_Matrix)\n-      return  Complex_Matrix\n-   is\n-      R : Complex_Matrix (Left'Range (1), Right'Range (2));\n-\n-   begin\n-      if Left'Length (2) /= Right'Length (1) then\n-         raise Constraint_Error with\n-            \"incompatible dimensions in matrix-matrix multiplication\";\n-      end if;\n-\n-      gemm (Trans_A => No_Trans'Access,\n-            Trans_B => No_Trans'Access,\n-            M       => Right'Length (2),\n-            N       => Left'Length (1),\n-            K       => Right'Length (1),\n-            A       => Right,\n-            Ld_A    => Right'Length (2),\n-            B       => Left,\n-            Ld_B    => Left'Length (2),\n-            C       => R,\n-            Ld_C    => R'Length (2));\n-\n-      return R;\n-   end \"*\";\n+      Right : Complex_Matrix) return  Complex_Matrix\n+     renames Instantiations.\"*\";\n \n    function \"*\"\n      (Left  : Complex_Vector;\n@@ -772,48 +769,12 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n    function \"*\"\n      (Left  : Complex_Vector;\n       Right : Complex_Matrix) return Complex_Vector\n-   is\n-      R : Complex_Vector (Right'Range (2));\n-\n-   begin\n-      if Left'Length /= Right'Length (1) then\n-         raise Constraint_Error with\n-           \"incompatible dimensions in vector-matrix multiplication\";\n-      end if;\n-\n-      gemv (Trans => No_Trans'Access,\n-            M     => Right'Length (2),\n-            N     => Right'Length (1),\n-            A     => Right,\n-            Ld_A  => Right'Length (2),\n-            X     => Left,\n-            Y     => R);\n-\n-      return R;\n-   end \"*\";\n+     renames Instantiations.\"*\";\n \n    function \"*\"\n      (Left  : Complex_Matrix;\n       Right : Complex_Vector) return Complex_Vector\n-   is\n-      R : Complex_Vector (Left'Range (1));\n-\n-   begin\n-      if Left'Length (2) /= Right'Length then\n-         raise Constraint_Error with\n-            \"incompatible dimensions in matrix-vector multiplication\";\n-      end if;\n-\n-      gemv (Trans => Trans'Access,\n-            M     => Left'Length (2),\n-            N     => Left'Length (1),\n-            A     => Left,\n-            Ld_A  => Left'Length (2),\n-            X     => Right,\n-            Y     => R);\n-\n-      return R;\n-   end \"*\";\n+     renames Instantiations.\"*\";\n \n    function \"*\"\n      (Left  : Real_Matrix;\n@@ -984,10 +945,8 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n    -- \"abs\" --\n    -----------\n \n-   function \"abs\" (Right : Complex_Vector) return Complex is\n-   begin\n-      return (nrm2 (Right'Length, Right), 0.0);\n-   end \"abs\";\n+   function \"abs\" (Right : Complex_Vector) return Real'Base\n+      renames Instantiations.\"abs\";\n \n    --------------\n    -- Argument --\n@@ -1070,38 +1029,12 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n    -----------------\n \n    function Determinant (A : Complex_Matrix) return Complex is\n-      N    : constant Integer := Length (A);\n-      LU   : Complex_Matrix (1 .. N, 1 .. N) := A;\n-      Piv  : Integer_Vector (1 .. N);\n-      Info : aliased Integer := -1;\n-      Neg  : Boolean;\n-      Det  : Complex;\n-\n+      M : Complex_Matrix := A;\n+      B : Complex_Matrix (A'Range (1), 1 .. 0);\n+      R : Complex;\n    begin\n-      if N = 0 then\n-         return (0.0, 0.0);\n-      end if;\n-\n-      getrf (N, N, LU, N, Piv, Info'Access);\n-\n-      if Info /= 0 then\n-         raise Constraint_Error with \"ill-conditioned matrix\";\n-      end if;\n-\n-      Det := LU (1, 1);\n-      Neg := Piv (1) /= 1;\n-\n-      for J in 2 .. N loop\n-         Det := Det * LU (J, J);\n-         Neg := Neg xor (Piv (J) /= J);\n-      end loop;\n-\n-      if Neg then\n-         return -Det;\n-\n-      else\n-         return Det;\n-      end if;\n+      Forward_Eliminate (M, B, R);\n+      return R;\n    end Determinant;\n \n    -----------------\n@@ -1113,174 +1046,96 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n       Values  : out Real_Vector;\n       Vectors : out Complex_Matrix)\n    is\n-      Job_Z    : aliased Character := 'V';\n-      Rng      : aliased Character := 'A';\n-      Uplo     : aliased Character := 'U';\n-\n-      N        : constant Natural := Length (A);\n-      W        : BLAS_Real_Vector (Values'Range);\n-      M        : Integer;\n-      B        : Complex_Matrix (1 .. N, 1 .. N);\n-      L_Work   : Complex_Vector (1 .. 1);\n-      LR_Work  : BLAS_Real_Vector (1 .. 1);\n-      LI_Work  : Integer_Vector (1 .. 1);\n-      I_Supp_Z : Integer_Vector (1 .. 2 * N);\n-      Info     : aliased Integer;\n+      N : constant Natural := Length (A);\n+\n+      --  For a Hermitian matrix C, we convert the eigenvalue problem to a\n+      --  real symmetric one: if C = A + i * B, then the (N, N) complex\n+      --  eigenvalue problem:\n+      --     (A + i * B) * (u + i * v) = Lambda * (u + i * v)\n+      --\n+      --  is equivalent to the (2 * N, 2 * N) real eigenvalue problem:\n+      --     [  A, B ] [ u ] = Lambda * [ u ]\n+      --     [ -B, A ] [ v ]            [ v ]\n+      --\n+      --  Note that the (2 * N, 2 * N) matrix above is symmetric, as\n+      --  Transpose (A) = A and Transpose (B) = -B if C is Hermitian.\n+\n+      --  We solve this eigensystem using the real-valued algorithms. The final\n+      --  result will have every eigenvalue twice, so in the sorted output we\n+      --  just pick every second value, with associated eigenvector u + i * v.\n+\n+      M    : Real_Matrix (1 .. 2 * N, 1 .. 2 * N);\n+      Vals : Real_Vector (1 .. 2 * N);\n+      Vecs : Real_Matrix (1 .. 2 * N, 1 .. 2 * N);\n \n    begin\n-      if Values'Length /= N then\n-         raise Constraint_Error with \"wrong length for output vector\";\n-      end if;\n-\n-      if Vectors'First (1) /= A'First (1)\n-        or else Vectors'Last (1) /= A'Last (1)\n-        or else Vectors'First (2) /= A'First (2)\n-        or else Vectors'Last (2) /= A'Last (2)\n-      then\n-         raise Constraint_Error with \"wrong dimensions for output matrix\";\n-      end if;\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      --  Check for hermitian matrix ???\n-      --  Copy only required triangle ???\n-\n-      B := A;\n-\n-      --  Find size of work area\n-\n-      heevr\n-        (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n-         M        => M,\n-         W        => W,\n-         Z        => Vectors,\n-         Ld_Z     => N,\n-         I_Supp_Z => I_Supp_Z,\n-         Work     => L_Work,\n-         L_Work   => -1,\n-         R_Work   => LR_Work,\n-         LR_Work  => -1,\n-         I_Work   => LI_Work,\n-         LI_Work  => -1,\n-         Info     => Info'Access);\n-\n-      if Info /= 0 then\n-         raise Constraint_Error;\n-      end if;\n-\n-      declare\n-         Work   : Complex_Vector (1 .. Integer (L_Work (1).Re));\n-         R_Work : BLAS_Real_Vector (1 .. Integer (LR_Work (1)));\n-         I_Work : Integer_Vector (1 .. LI_Work (1));\n-\n-      begin\n-         heevr\n-           (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n-            M        => M,\n-            W        => W,\n-            Z        => Vectors,\n-            Ld_Z     => N,\n-            I_Supp_Z => I_Supp_Z,\n-            Work     => Work,\n-            L_Work   => Work'Length,\n-            R_Work   => R_Work,\n-            LR_Work  => LR_Work'Length,\n-            I_Work   => I_Work,\n-            LI_Work  => LI_Work'Length,\n-            Info     => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Constraint_Error with \"inverting non-Hermitian matrix\";\n-         end if;\n-\n-         for J in Values'Range loop\n-            Values (J) := W (J);\n+      for J in 1 .. N loop\n+         for K in 1 .. N loop\n+            declare\n+               C : constant Complex :=\n+                     (A (A'First (1) + (J - 1), A'First (2) + (K - 1)));\n+            begin\n+               M (J, K) := Re (C);\n+               M (J + N, K + N) := Re (C);\n+               M (J + N, K) := Im (C);\n+               M (J, K + N) := -Im (C);\n+            end;\n          end loop;\n-      end;\n+      end loop;\n+\n+      Eigensystem (M, Vals, Vecs);\n+\n+      for J in 1 .. N loop\n+         declare\n+            Col : constant Integer := Values'First + (J - 1);\n+         begin\n+            Values (Col) := Vals (2 * J);\n+\n+            for K in 1 .. N loop\n+               declare\n+                  Row : constant Integer := Vectors'First (2) + (K - 1);\n+               begin\n+                  Vectors (Row, Col)\n+                     := (Vecs (J * 2, Col), Vecs (J * 2, Col + N));\n+               end;\n+            end loop;\n+         end;\n+      end loop;\n    end Eigensystem;\n \n    -----------------\n    -- Eigenvalues --\n    -----------------\n \n-   procedure Eigenvalues\n-     (A      : Complex_Matrix;\n-      Values : out Real_Vector)\n-   is\n-      Job_Z    : aliased Character := 'N';\n-      Rng      : aliased Character := 'A';\n-      Uplo     : aliased Character := 'U';\n-      N        : constant Natural := Length (A);\n-      B        : Complex_Matrix (1 .. N, 1 .. N) := A;\n-      Z        : Complex_Matrix (1 .. 1, 1 .. 1);\n-      W        : BLAS_Real_Vector (Values'Range);\n-      L_Work   : Complex_Vector (1 .. 1);\n-      LR_Work  : BLAS_Real_Vector (1 .. 1);\n-      LI_Work  : Integer_Vector (1 .. 1);\n-      I_Supp_Z : Integer_Vector (1 .. 2 * N);\n-      M        : Integer;\n-      Info     : aliased Integer;\n+   function Eigenvalues (A : Complex_Matrix) return Real_Vector is\n+      --  See Eigensystem for a description of the algorithm\n \n+      N : constant Natural := Length (A);\n+      R : Real_Vector (A'Range (1));\n+\n+      M    : Real_Matrix (1 .. 2 * N, 1 .. 2 * N);\n+      Vals : Real_Vector (1 .. 2 * N);\n    begin\n-      if Values'Length /= N then\n-         raise Constraint_Error with \"wrong length for output vector\";\n-      end if;\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      --  Check for hermitian matrix ???\n-\n-      --  Find size of work area\n-\n-      heevr (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n-             M        => M,\n-             W        => W,\n-             Z        => Z,\n-             Ld_Z     => 1,\n-             I_Supp_Z => I_Supp_Z,\n-             Work     => L_Work,  L_Work  => -1,\n-             R_Work   => LR_Work, LR_Work => -1,\n-             I_Work   => LI_Work, LI_Work => -1,\n-             Info     => Info'Access);\n-\n-      if Info /= 0 then\n-         raise Constraint_Error;\n-      end if;\n-\n-      declare\n-         Work : Complex_Vector (1 .. Integer (L_Work (1).Re));\n-         R_Work : BLAS_Real_Vector (1 .. Integer (LR_Work (1)));\n-         I_Work : Integer_Vector (1 .. LI_Work (1));\n-      begin\n-         heevr (Job_Z'Access, Rng'Access, Uplo'Access, N, B, N,\n-                M        => M,\n-                W        => W,\n-                Z        => Z,\n-                Ld_Z     => 1,\n-                I_Supp_Z => I_Supp_Z,\n-                Work     => Work,   L_Work  => Work'Length,\n-                R_Work   => R_Work, LR_Work => R_Work'Length,\n-                I_Work   => I_Work, LI_Work => I_Work'Length,\n-                Info     => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Constraint_Error with \"inverting singular matrix\";\n-         end if;\n-\n-         for J in Values'Range loop\n-            Values (J) := W (J);\n+      for J in 1 .. N loop\n+         for K in 1 .. N loop\n+            declare\n+               C : constant Complex :=\n+                     (A (A'First (1) + (J - 1), A'First (2) + (K - 1)));\n+            begin\n+               M (J, K) := Re (C);\n+               M (J + N, K + N) := Re (C);\n+               M (J + N, K) := Im (C);\n+               M (J, K + N) := -Im (C);\n+            end;\n          end loop;\n-      end;\n-   end Eigenvalues;\n+      end loop;\n+\n+      Vals := Eigenvalues (M);\n+\n+      for J in 1 .. N loop\n+         R (A'First (1) + (J - 1)) := Vals (2 * J);\n+      end loop;\n \n-   function Eigenvalues (A : Complex_Matrix) return Real_Vector is\n-      R : Real_Vector (A'Range (1));\n-   begin\n-      Eigenvalues (A, R);\n       return R;\n    end Eigenvalues;\n \n@@ -1298,73 +1153,8 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n    -- Inverse --\n    -------------\n \n-   procedure Inverse (A : Complex_Matrix; R : out Complex_Matrix) is\n-      N      : constant Integer := Length (A);\n-      Piv    : Integer_Vector (1 .. N);\n-      L_Work : Complex_Vector (1 .. 1);\n-      Info   : aliased Integer := -1;\n-\n-   begin\n-      --  All computations are done using column-major order, but this works\n-      --  out fine, because Transpose (Inverse (Transpose (A))) = Inverse (A).\n-\n-      R := A;\n-\n-      --  Compute LU decomposition\n-\n-      getrf (M      => N,\n-             N      => N,\n-             A      => R,\n-             Ld_A   => N,\n-             I_Piv  => Piv,\n-             Info   => Info'Access);\n-\n-      if Info /= 0 then\n-         raise Constraint_Error with \"inverting singular matrix\";\n-      end if;\n-\n-      --  Determine size of work area\n-\n-      getri (N      => N,\n-             A      => R,\n-             Ld_A   => N,\n-             I_Piv  => Piv,\n-             Work   => L_Work,\n-             L_Work => -1,\n-             Info   => Info'Access);\n-\n-      if Info /= 0 then\n-         raise Constraint_Error;\n-      end if;\n-\n-      declare\n-         Work : Complex_Vector (1 .. Integer (L_Work (1).Re));\n-\n-      begin\n-         --  Compute inverse from LU decomposition\n-\n-         getri (N      => N,\n-                A      => R,\n-                Ld_A   => N,\n-                I_Piv  => Piv,\n-                Work   => Work,\n-                L_Work => Work'Length,\n-                Info   => Info'Access);\n-\n-         if Info /= 0 then\n-            raise Constraint_Error with \"inverting singular matrix\";\n-         end if;\n-\n-         --  ??? Should iterate with gerfs, based on implementation advice\n-      end;\n-   end Inverse;\n-\n    function Inverse (A : Complex_Matrix) return Complex_Matrix is\n-      R : Complex_Matrix (A'Range (2), A'Range (1));\n-   begin\n-      Inverse (A, R);\n-      return R;\n-   end Inverse;\n+     (Solve (A, Unit_Matrix (Length (A))));\n \n    -------------\n    -- Modulus --\n@@ -1418,53 +1208,15 @@ package body Ada.Numerics.Generic_Complex_Arrays is\n    -- Solve --\n    -----------\n \n-   procedure Solve\n-     (A : Complex_Matrix;\n-      X : Complex_Vector;\n-      B : out Complex_Vector)\n-   is\n-   begin\n-      if Length (A) /= X'Length then\n-         raise Constraint_Error with\n-           \"incompatible matrix and vector dimensions\";\n-      end if;\n-\n-      --  ??? Should solve directly, is faster and more accurate\n-\n-      B := Inverse (A) * X;\n-   end Solve;\n-\n-   procedure Solve\n-     (A : Complex_Matrix;\n-      X : Complex_Matrix;\n-      B : out Complex_Matrix)\n-   is\n-   begin\n-      if Length (A) /= X'Length (1) then\n-         raise Constraint_Error with \"incompatible matrix dimensions\";\n-      end if;\n-\n-      --  ??? Should solve directly, is faster and more accurate\n-\n-      B := Inverse (A) * X;\n-   end Solve;\n-\n    function Solve\n      (A : Complex_Matrix;\n       X : Complex_Vector) return Complex_Vector\n-   is\n-      B : Complex_Vector (A'Range (2));\n-   begin\n-      Solve (A, X, B);\n-      return B;\n-   end Solve;\n+     renames Instantiations.Solve;\n \n-   function Solve (A, X : Complex_Matrix) return Complex_Matrix is\n-      B : Complex_Matrix (A'Range (2), X'Range (2));\n-   begin\n-      Solve (A, X, B);\n-      return B;\n-   end Solve;\n+   function Solve\n+     (A : Complex_Matrix;\n+      X : Complex_Matrix) return Complex_Matrix\n+     renames Instantiations.Solve;\n \n    ---------------\n    -- Transpose --"}, {"sha": "8f8f37a79062fd50ed4181abc6c21410eb81e85a", "filename": "gcc/ada/a-ngcoar.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fa-ngcoar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fa-ngcoar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoar.ads?ref=a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "patch": "@@ -66,7 +66,7 @@ package Ada.Numerics.Generic_Complex_Arrays is\n    function \"+\" (Left, Right : Complex_Vector) return Complex_Vector;\n    function \"-\" (Left, Right : Complex_Vector) return Complex_Vector;\n    function \"*\" (Left, Right : Complex_Vector) return Complex;\n-   function \"abs\" (Right : Complex_Vector) return Complex;\n+   function \"abs\" (Right : Complex_Vector) return Real'Base;\n \n    --  Mixed Real_Vector and Complex_Vector arithmetic operations\n "}, {"sha": "2a740b5c6b4a099bd1e44a2c1c373e99de9330c1", "filename": "gcc/ada/a-ngrear.adb", "status": "modified", "additions": 10, "deletions": 52, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fa-ngrear.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fa-ngrear.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngrear.adb?ref=a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "patch": "@@ -33,7 +33,7 @@\n --  reason for this is new Ada 2012 requirements that prohibit algorithms such\n --  as Strassen's algorithm, which may be used by some BLAS implementations. In\n --  addition, some platforms lacked suitable compilers to compile the reference\n---  BLAS/LAPACK implementation. Finally, on some platforms there are be more\n+--  BLAS/LAPACK implementation. Finally, on some platforms there are more\n --  floating point types than supported by BLAS/LAPACK.\n \n with Ada.Containers.Generic_Anonymous_Array_Sort; use Ada.Containers;\n@@ -337,6 +337,11 @@ package body Ada.Numerics.Generic_Real_Arrays is\n            Result_Matrix => Real_Matrix,\n            Operation     => \"abs\");\n \n+      function Solve is\n+         new Matrix_Vector_Solution (Real'Base, Real_Vector, Real_Matrix);\n+\n+      function Solve is new Matrix_Matrix_Solution (Real'Base, Real_Matrix);\n+\n       function Unit_Matrix is new\n         Generic_Array_Operations.Unit_Matrix\n           (Scalar        => Real'Base,\n@@ -696,58 +701,11 @@ package body Ada.Numerics.Generic_Real_Arrays is\n    -- Solve --\n    -----------\n \n-   function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector is\n-      N   : constant Natural := Length (A);\n-      MA  : Real_Matrix := A;\n-      MX  : Real_Matrix (A'Range (1), 1 .. 1);\n-      R   : Real_Vector (A'Range (2));\n-      Det : Real'Base;\n-\n-   begin\n-      if X'Length /= N then\n-         raise Constraint_Error with \"incompatible vector length\";\n-      end if;\n-\n-      for J in 0 .. MX'Length (1) - 1 loop\n-         MX (MX'First (1) + J, 1) := X (X'First + J);\n-      end loop;\n-\n-      Forward_Eliminate (MA, MX, Det);\n-      Back_Substitute (MA, MX);\n-\n-      for J in 0 .. R'Length - 1 loop\n-         R (R'First + J) := MX (MX'First (1) + J, 1);\n-      end loop;\n-\n-      return R;\n-   end Solve;\n-\n-   function Solve (A, X : Real_Matrix) return Real_Matrix is\n-      N  : constant Natural := Length (A);\n-      MA : Real_Matrix (A'Range (2), A'Range (2));\n-      MB : Real_Matrix (A'Range (2), X'Range (2));\n-      Det : Real'Base;\n-\n-   begin\n-      if X'Length (1) /= N then\n-         raise Constraint_Error with \"matrices have unequal number of rows\";\n-      end if;\n-\n-      for J in 0 .. A'Length (1) - 1 loop\n-         for K in MA'Range (2) loop\n-            MA (MA'First (1) + J, K) := A (A'First (1) + J, K);\n-         end loop;\n-\n-         for K in MB'Range (2) loop\n-            MB (MB'First (1) + J, K) := X (X'First (1) + J, K);\n-         end loop;\n-      end loop;\n-\n-      Forward_Eliminate (MA, MB, Det);\n-      Back_Substitute (MA, MB);\n+   function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector\n+      renames Instantiations.Solve;\n \n-      return MB;\n-   end Solve;\n+   function Solve (A, X : Real_Matrix) return Real_Matrix\n+      renames Instantiations.Solve;\n \n    ----------------------\n    -- Sort_Eigensystem --"}, {"sha": "58602e1e0a81f32c133aa8a49daf50988bd84f66", "filename": "gcc/ada/s-gearop.adb", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.adb?ref=a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "patch": "@@ -651,6 +651,75 @@ package body System.Generic_Array_Operations is\n       return R;\n    end  Matrix_Matrix_Product;\n \n+   ----------------------------\n+   -- Matrix_Vector_Solution --\n+   ----------------------------\n+\n+   function Matrix_Vector_Solution (A : Matrix; X : Vector) return Vector is\n+      N   : constant Natural := A'Length (1);\n+      MA  : Matrix := A;\n+      MX  : Matrix (A'Range (1), 1 .. 1);\n+      R   : Vector (A'Range (2));\n+      Det : Scalar;\n+\n+   begin\n+      if A'Length (2) /= N then\n+         raise Constraint_Error with \"matrix is not square\";\n+      end if;\n+\n+      if X'Length /= N then\n+         raise Constraint_Error with \"incompatible vector length\";\n+      end if;\n+\n+      for J in 0 .. MX'Length (1) - 1 loop\n+         MX (MX'First (1) + J, 1) := X (X'First + J);\n+      end loop;\n+\n+      Forward_Eliminate (MA, MX, Det);\n+      Back_Substitute (MA, MX);\n+\n+      for J in 0 .. R'Length - 1 loop\n+         R (R'First + J) := MX (MX'First (1) + J, 1);\n+      end loop;\n+\n+      return R;\n+   end Matrix_Vector_Solution;\n+\n+   ----------------------------\n+   -- Matrix_Matrix_Solution --\n+   ----------------------------\n+\n+   function Matrix_Matrix_Solution (A, X : Matrix) return Matrix is\n+      N  : constant Natural := A'Length (1);\n+      MA : Matrix (A'Range (2), A'Range (2));\n+      MB : Matrix (A'Range (2), X'Range (2));\n+      Det : Scalar;\n+\n+   begin\n+      if A'Length (2) /= N then\n+         raise Constraint_Error with \"matrix is not square\";\n+      end if;\n+\n+      if X'Length (1) /= N then\n+         raise Constraint_Error with \"matrices have unequal number of rows\";\n+      end if;\n+\n+      for J in 0 .. A'Length (1) - 1 loop\n+         for K in MA'Range (2) loop\n+            MA (MA'First (1) + J, K) := A (A'First (1) + J, K);\n+         end loop;\n+\n+         for K in MB'Range (2) loop\n+            MB (MB'First (1) + J, K) := X (X'First (1) + J, K);\n+         end loop;\n+      end loop;\n+\n+      Forward_Eliminate (MA, MB, Det);\n+      Back_Substitute (MA, MB);\n+\n+      return MB;\n+   end Matrix_Matrix_Solution;\n+\n    ---------------------------\n    -- Matrix_Vector_Product --\n    ---------------------------"}, {"sha": "f401da219e36fd2636bda36793fbef05a049094f", "filename": "gcc/ada/s-gearop.ads", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fs-gearop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5917ffb2cd7097f9b8b754c2745c23d860cb31a/gcc%2Fada%2Fs-gearop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.ads?ref=a5917ffb2cd7097f9b8b754c2745c23d860cb31a", "patch": "@@ -390,6 +390,35 @@ pragma Pure (Generic_Array_Operations);\n      (Left  : Left_Matrix;\n       Right : Right_Matrix) return Result_Matrix;\n \n+   ----------------------------\n+   -- Matrix_Vector_Solution --\n+   ----------------------------\n+\n+   generic\n+      type Scalar is private;\n+      type Vector is array (Integer range <>) of Scalar;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+      with procedure Back_Substitute (M, N : in out Matrix) is <>;\n+      with procedure Forward_Eliminate\n+             (M   : in out Matrix;\n+              N   : in out Matrix;\n+              Det : out Scalar) is <>;\n+   function Matrix_Vector_Solution (A : Matrix; X : Vector) return Vector;\n+\n+   ----------------------------\n+   -- Matrix_Matrix_Solution --\n+   ----------------------------\n+\n+   generic\n+      type Scalar is private;\n+      type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n+      with procedure Back_Substitute (M, N : in out Matrix) is <>;\n+      with procedure Forward_Eliminate\n+             (M   : in out Matrix;\n+              N   : in out Matrix;\n+              Det : out Scalar) is <>;\n+   function Matrix_Matrix_Solution (A : Matrix; X : Matrix) return Matrix;\n+\n    ----------\n    -- Sqrt --\n    ----------"}]}