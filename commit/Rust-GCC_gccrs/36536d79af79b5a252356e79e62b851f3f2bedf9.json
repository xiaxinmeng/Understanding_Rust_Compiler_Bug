{"sha": "36536d79af79b5a252356e79e62b851f3f2bedf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY1MzZkNzlhZjc5YjVhMjUyMzU2ZTc5ZTYyYjg1MWYzZjJiZWRmOQ==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-05-28T19:55:10Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-05-28T19:55:10Z"}, "message": "Implemented Cilk Plus Array Notation for C Compiler.\n\ngcc/ChangeLog\n2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* doc/extend.texi (C Extensions): Added documentation about Cilk \nPlus\n\tarray notation built-in reduction functions.\n\t* doc/passes.texi (Passes): Added documentation about changes done\n\tfor Cilk Plus.\n\t* doc/invoke.texi (C Dialect Options): Added documentation about\n\tthe -fcilkplus flag.\n\t* Makefile.in (C_COMMON_OBJS): Added \nc-family/array-notation-common.o.\n\t(BUILTINS_DEF): Depend on cilkplus.def.\n\t* builtins.def: Include cilkplus.def.  Define \nDEF_CILKPLUS_BUILTIN.\n\t* builtin-types.def: Define BT_FN_INT_PTR_PTR_PTR.\n\t* cilkplus.def: New file.\n\ngcc/c-family/ChangeLog\n2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* c-common.c (c_define_builtins): When cilkplus is enabled, the\n\tfunction array_notation_init_builtins is called.\n\t(c_common_init_ts): Added ARRAY_NOTATION_REF as typed.\n\t* c-common.def (ARRAY_NOTATION_REF): New tree.\n\t* c-common.h (build_array_notation_expr): New function declaration.\n\t(build_array_notation_ref): Likewise.\n\t(extract_sec_implicit_index_arg): New extern declaration.\n\t(is_sec_implicit_index_fn): Likewise.\n\t(ARRAY_NOTATION_CHECK): New define.\n\t(ARRAY_NOTATION_ARRAY): Likewise.\n\t(ARRAY_NOTATION_START): Likewise.\n\t(ARRAY_NOTATION_LENGTH): Likewise.\n\t(ARRAY_NOTATION_STRIDE): Likewise.\n\t* c-pretty-print.c (pp_c_postifix_expression): Added a new case for\n\tARRAY_NOTATION_REF.\n\t(pp_c_expression): Likewise.\n\t* c.opt (flag_enable_cilkplus): New flag.\n\t* array-notation-common.c: New file.\n\ngcc/c/ChangeLog\n2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* c-typeck.c (build_array_ref): Added a check to see if array's\n\tindex is greater than one.  If true, then emit an error.\n\t(build_function_call_vec): Exclude error reporting and checking\n\tfor builtin array-notation functions.\n\t(convert_arguments): Likewise.\n\t(c_finish_return): Added a check for array notations as a return\n\texpression.  If true, then emit an error.\n\t(c_finish_loop): Added a check for array notations in a loop\n\tcondition.  If true then emit an error.\n\t(lvalue_p): Added a ARRAY_NOTATION_REF case.\n\t(build_binary_op): Added a check for array notation expr inside\n\top1 and op0.  If present, we call another function to find correct\n\ttype.\n\t* Make-lang.in (C_AND_OBJC_OBJS): Added c-array-notation.o.\n\t* c-parser.c (c_parser_compound_statement): Check if array\n\tnotation code is used in tree, if so, then transform them into\n\tappropriate C code.\n\t(c_parser_expr_no_commas): Check if array notation is used in LHS\n\tor RHS, if so, then build array notation expression instead of\n\tregular modify.\n\t(c_parser_postfix_expression_after_primary): Added a check for\n\tcolon(s) after square braces, if so then handle it like an array\n\tnotation.  Also, break up array notations in unary op if found.\n\t(c_parser_direct_declarator_inner): Added a check for array\n\tnotation.\n\t(c_parser_compound_statement): Added a check for array notation in\n\ta stmt.  If one is present, then expand array notation expr.\n\t(c_parser_if_statement): Likewise.\n\t(c_parser_switch_statement): Added a check for array notations in\n\ta switch statement's condition.  If true, then output an error.\n\t(c_parser_while_statement): Similarly, but for a while.\n\t(c_parser_do_statement): Similarly, but for a do-while.\n\t(c_parser_for_statement): Similarly, but for a for-loop.\n\t(c_parser_unary_expression): Check if array notation is used in a\n\tpre-increment or pre-decrement expression.  If true, then expand\n\tthem.\n\t(c_parser_array_notation): New function.\n\t* c-array-notation.c: New file.\n\t* c-tree.h (is_cilkplus_reduce_builtin): Protoize.\n\ngcc/testsuite/ChangeLog\n2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* c-c++-common/cilk-plus/AN/array_test1.c: New test.\n\t* c-c++-common/cilk-plus/AN/array_test2.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/array_test_ND.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/builtin_func_double.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/builtin_func_double2.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/gather-scatter-errors.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/if_test.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/sec_implicit_ex.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/decl-ptr-colon.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/dimensionless-arrays.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/fn_ptr.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/fp_triplet_values.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/gather-scatter.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/misc.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/parser_errors.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/parser_errors2.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/parser_errors3.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/parser_errors4.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/rank_mismatch.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/rank_mismatch2.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/rank_mismatch3.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/sec_implicit.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/sec_implicit2.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/sec_reduce_max_min_ind.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/tst_lngth.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/vla.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/an-if.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/builtin_fn_custom.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/builtin_fn_mutating.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/comma_exp.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/conditional.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/exec-once.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/exec-once2.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/gather_scatter.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/n-ptr-test.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/side-effects-1.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/test_builtin_return.c: Likewise.\n\t* c-c++-common/cilk-plus/AN/test_sec_limits.c: Likewise.\n\t* gcc.dg/cilk-plus/cilk-plus.exp: New script.\n\nFrom-SVN: r199389", "tree": {"sha": "7bd32114bcd1a25d4a1caa95b66d2894e6e75dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bd32114bcd1a25d4a1caa95b66d2894e6e75dc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36536d79af79b5a252356e79e62b851f3f2bedf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36536d79af79b5a252356e79e62b851f3f2bedf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36536d79af79b5a252356e79e62b851f3f2bedf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36536d79af79b5a252356e79e62b851f3f2bedf9/comments", "author": null, "committer": null, "parents": [{"sha": "6d2bee95d82dcf40d115a3ba3a793a9b71a17a64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2bee95d82dcf40d115a3ba3a793a9b71a17a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d2bee95d82dcf40d115a3ba3a793a9b71a17a64"}], "stats": {"total": 5646, "additions": 5618, "deletions": 28}, "files": [{"sha": "c797f1ddbe51e1f87887711ab4fe45f6beab9ffc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1,3 +1,17 @@\n+2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* doc/extend.texi (C Extensions): Added documentation about Cilk Plus\n+\tarray notation built-in reduction functions.\n+\t* doc/passes.texi (Passes): Added documentation about changes done\n+\tfor Cilk Plus.\n+\t* doc/invoke.texi (C Dialect Options): Added documentation about\n+\tthe -fcilkplus flag.\n+\t* Makefile.in (C_COMMON_OBJS): Added c-family/array-notation-common.o.\n+\t(BUILTINS_DEF): Depend on cilkplus.def.\n+\t* builtins.def: Include cilkplus.def.  Define DEF_CILKPLUS_BUILTIN.\n+\t* builtin-types.def: Define BT_FN_INT_PTR_PTR_PTR.\n+\t* cilkplus.def: New file.\n+\n 2013-05-28  Joern Rennecke <joern.rennecke@embecosm.com>\n \n \tPR rtl-optimization/57439"}, {"sha": "e95dd63c7dbdc61652aa13ff867d30712c4fedf0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -869,7 +869,7 @@ RTL_ERROR_H = rtl-error.h $(RTL_H) $(DIAGNOSTIC_CORE_H)\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n-\tgtm-builtins.def sanitizer.def\n+\tgtm-builtins.def sanitizer.def cilkplus.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \\\n@@ -1149,7 +1149,8 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-format.o c-family/c-gimplify.o c-family/c-lex.o \\\n   c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n-  c-family/c-semantics.o c-family/c-ada-spec.o tree-mudflap.o\n+  c-family/c-semantics.o c-family/c-ada-spec.o tree-mudflap.o \\\n+  c-family/array-notation-common.o\n \n # Language-independent object files.\n # We put the insn-*.o files first so that a parallel make will build\n@@ -2014,6 +2015,9 @@ c-family/c-ada-spec.o : c-family/c-ada-spec.c c-family/c-ada-spec.h \\\n \t$(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(CPP_ID_DATA_H) $(TM_H) \\\n \tcoretypes.h tree-iterator.h $(DUMPFILE_H)\n \n+c-family/array-notation-common.o : c-family/array-notation-common.c $(TREE_H) \\\n+\t$(SYSTEM_H) $(TREE_H) coretypes.h tree-iterator.h $(DIAGNOSTIC_CORE_H)\n+\n c-family/stub-objc.o : c-family/stub-objc.c $(CONFIG_H) $(SYSTEM_H) \\\n \tcoretypes.h $(TREE_H) $(C_COMMON_H) c-family/c-objc.h\n "}, {"sha": "2634eccababd53bb5224a7a28a16da2c39a1db44", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -368,6 +368,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_CONST_STRING, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_FILEPTR_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_FILEPTR, BT_CONST_STRING, BT_VALIST_ARG)\n+DEF_FUNCTION_TYPE_3 (BT_FN_INT_PTR_PTR_PTR,\n+\t\t     BT_INT, BT_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_STRING_CONST_STRING_CONST_STRING_INT,\n \t\t     BT_STRING, BT_CONST_STRING, BT_CONST_STRING, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_FLOAT_FLOAT_FLOAT_FLOAT,"}, {"sha": "91879a64dc0be48e293244cf4e987f2b85db78a7", "filename": "gcc/builtins.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -157,6 +157,11 @@ along with GCC; see the file COPYING3.  If not see\n \t       true, true, true, ATTRS, true, \\\n \t       (flag_asan || flag_tsan))\n \n+#undef DEF_CILKPLUS_BUILTIN\n+#define DEF_CILKPLUS_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE, \\\n+  \t       false, false, true, ATTRS, false, flag_enable_cilkplus)\n+\n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for\n    `errno'.  If !flag_errno_math they are instead \"const\".  */\n@@ -837,3 +842,5 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Sanitizer builtins. */\n #include \"sanitizer.def\"\n \n+/* Cilk Plus builtins.  */\n+#include \"cilkplus.def\""}, {"sha": "d434a2f8ad655b6c7968a1e52192af6987bdb3d8", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1,3 +1,24 @@\n+2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-common.c (c_define_builtins): When cilkplus is enabled, the\n+\tfunction array_notation_init_builtins is called.\n+\t(c_common_init_ts): Added ARRAY_NOTATION_REF as typed.\n+\t* c-common.def (ARRAY_NOTATION_REF): New tree.\n+\t* c-common.h (build_array_notation_expr): New function declaration.\n+\t(build_array_notation_ref): Likewise.\n+\t(extract_sec_implicit_index_arg): New extern declaration.\n+\t(is_sec_implicit_index_fn): Likewise.\n+\t(ARRAY_NOTATION_CHECK): New define.\n+\t(ARRAY_NOTATION_ARRAY): Likewise.\n+\t(ARRAY_NOTATION_START): Likewise.\n+\t(ARRAY_NOTATION_LENGTH): Likewise.\n+\t(ARRAY_NOTATION_STRIDE): Likewise.\n+\t* c-pretty-print.c (pp_c_postifix_expression): Added a new case for\n+\tARRAY_NOTATION_REF.\n+\t(pp_c_expression): Likewise.\n+\t* c.opt (flag_enable_cilkplus): New flag.\n+\t* array-notation-common.c: New file.\n+\n 2013-05-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/57274"}, {"sha": "1d288464eee6a8c805ef627d58c14249da5ae143", "filename": "gcc/c-family/array-notation-common.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,76 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   This file contains the builtin functions for Array\n+   notations.\n+   Copyright (C) 2013  Free Software Foundation, Inc.\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n+                  Intel Corporation\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\" \n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\" \n+#include \"tree-iterator.h\"\n+#include \"diagnostic-core.h\"\n+\n+\n+/* Returns true if the function call in FNDECL is  __sec_implicit_index.  */\n+\n+bool\n+is_sec_implicit_index_fn (tree fndecl)\n+{\n+  if (TREE_CODE (fndecl) == ADDR_EXPR)\n+    fndecl = TREE_OPERAND (fndecl, 0);\n+\n+  return\n+    (TREE_CODE (fndecl) == FUNCTION_DECL\n+     && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+     && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CILKPLUS_SEC_IMPLICIT_INDEX);\n+}\n+\n+/* Returns the first and only argument for FN, which should be a\n+   sec_implicit_index function.  FN's location in the source file is as \n+   indicated by LOCATION.  The argument to FN must be a constant integer\n+   expression, otherwise returns -1.  */\n+\n+HOST_WIDE_INT\n+extract_sec_implicit_index_arg (location_t location, tree fn)\n+{\n+  tree fn_arg;\n+  HOST_WIDE_INT return_int = 0;\n+\n+  if (TREE_CODE (fn) == CALL_EXPR)\n+    {\n+      fn_arg = CALL_EXPR_ARG (fn, 0);\n+      if (TREE_CODE (fn_arg) == INTEGER_CST)\n+\treturn_int = int_cst_value (fn_arg);\n+      else\n+\t{\n+\t  /* If the location is unknown, and if fn has a location, then use that\n+\t     information so that the user has a better idea where the error\n+\t     could be.  */\n+\t  if (location == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (fn))\n+\t    location = EXPR_LOCATION (fn);\n+\t  error_at (location, \"__sec_implicit_index parameter must be an \" \n+\t\t    \"integer constant expression\");\n+\t  return -1;\n+\t}\n+    }\n+  return return_int;\n+}"}, {"sha": "dec887fb4c0457db1d9c3a62262d72db285281a4", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -11424,6 +11424,7 @@ c_common_init_ts (void)\n {\n   MARK_TS_TYPED (C_MAYBE_CONST_EXPR);\n   MARK_TS_TYPED (EXCESS_PRECISION_EXPR);\n+  MARK_TS_TYPED (ARRAY_NOTATION_REF);\n }\n \n /* Build a user-defined numeric literal out of an integer constant type VALUE"}, {"sha": "fac50e23777b965d1b0a07a68b1b9cf5b770db23", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -55,6 +55,13 @@ DEFTREECODE (USERDEF_LITERAL, \"userdef_literal\", tcc_exceptional, 3)\n    or for the purpose of -Wsizeof-pointer-memaccess warning.  */\n DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", tcc_expression, 1)\n \n+/* Array Notation expression.\n+   Operand 0 is the array.\n+   Operand 1 is the starting array index.\n+   Operand 2 contains the number of elements you need to access.\n+   Operand 3 is the stride.  */\n+DEFTREECODE (ARRAY_NOTATION_REF, \"array_notation_ref\", tcc_reference, 4) \n+\n /*\n Local variables:\n mode:c"}, {"sha": "d89982174bb1b8b4995ddc35e7564dac7ed9b5eb", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -538,6 +538,10 @@ extern tree pushdecl_top_level (tree);\n extern tree pushdecl (tree);\n extern tree build_modify_expr (location_t, tree, tree, enum tree_code,\n \t\t\t       location_t, tree, tree);\n+extern tree build_array_notation_expr (location_t, tree, tree, enum tree_code,\n+\t\t\t\t       location_t, tree, tree);\n+extern tree build_array_notation_ref (location_t, tree, tree, tree, tree, tree);\n+extern bool find_rank (location_t, tree, tree, bool, size_t *);\n extern tree build_indirect_ref (location_t, tree, ref_operator);\n \n extern int field_decl_cmp (const void *, const void *);\n@@ -1133,4 +1137,26 @@ enum stv_conv {\n extern enum stv_conv scalar_to_vector (location_t loc, enum tree_code code,\n \t\t\t\t       tree op0, tree op1, bool);\n \n+/* These #defines allow users to access different operands of the\n+   array notation tree.  */\n+\n+#define ARRAY_NOTATION_CHECK(NODE) TREE_CHECK (NODE, ARRAY_NOTATION_REF)\n+#define ARRAY_NOTATION_ARRAY(NODE) \\\n+  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 0)\n+#define ARRAY_NOTATION_START(NODE) \\\n+  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 1)\n+#define ARRAY_NOTATION_LENGTH(NODE) \\\n+  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 2)\n+#define ARRAY_NOTATION_STRIDE(NODE) \\\n+  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 3)\n+\n+extern int extract_sec_implicit_index_arg (location_t, tree);\n+extern bool is_sec_implicit_index_fn (tree);\n+extern void array_notation_init_builtins (void);\n+extern struct c_expr fix_array_notation_expr (location_t, enum tree_code, \n+\t\t\t\t\t      struct c_expr);\n+extern bool contains_array_notation_expr (tree);\n+extern tree expand_array_notation_exprs (tree);\n+extern tree fix_conditional_array_notations (tree);\n+extern tree find_correct_array_notation_type (tree);\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "b8af90c053c840e8fda365ab414e659898f6f7d8", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1476,6 +1476,17 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n       pp_c_right_bracket (pp);\n       break;\n \n+    case ARRAY_NOTATION_REF:\n+      pp_postfix_expression (pp, ARRAY_NOTATION_ARRAY (e));\n+      pp_c_left_bracket (pp);\n+      pp_expression (pp, ARRAY_NOTATION_START (e));\n+      pp_colon (pp);\n+      pp_expression (pp, ARRAY_NOTATION_LENGTH (e));\n+      pp_colon (pp);\n+      pp_expression (pp, ARRAY_NOTATION_STRIDE (e));\n+      pp_c_right_bracket (pp);\n+      break;\n+      \n     case CALL_EXPR:\n       {\n \tcall_expr_arg_iterator iter;\n@@ -2150,6 +2161,7 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n     case ARRAY_REF:\n+    case ARRAY_NOTATION_REF:\n     case CALL_EXPR:\n     case COMPONENT_REF:\n     case BIT_FIELD_REF:"}, {"sha": "857813474c9a3e66a87e0bf024fc975422964dfb", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -843,6 +843,10 @@ fcanonical-system-headers\n C ObjC C++ ObjC++\n Where shorter, use canonicalized paths to systems headers.\n \n+fcilkplus\n+C ObjC C++ ObjC++ LTO Report Var(flag_enable_cilkplus) Init(0)\n+Enable Cilk Plus\n+\n fcheck-new\n C++ ObjC++ Var(flag_check_new)\n Check the return value of new"}, {"sha": "d6d9856cf3b8978b703074c265eb19c4a0200c7e", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1,3 +1,45 @@\n+2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-typeck.c (build_array_ref): Added a check to see if array's\n+\tindex is greater than one.  If true, then emit an error.\n+\t(build_function_call_vec): Exclude error reporting and checking\n+\tfor builtin array-notation functions.\n+\t(convert_arguments): Likewise.\n+\t(c_finish_return): Added a check for array notations as a return\n+\texpression.  If true, then emit an error.\n+\t(c_finish_loop): Added a check for array notations in a loop\n+\tcondition.  If true then emit an error.\n+\t(lvalue_p): Added a ARRAY_NOTATION_REF case.\n+\t(build_binary_op): Added a check for array notation expr inside\n+\top1 and op0.  If present, we call another function to find correct\n+\ttype.\n+\t* Make-lang.in (C_AND_OBJC_OBJS): Added c-array-notation.o.\n+\t* c-parser.c (c_parser_compound_statement): Check if array\n+\tnotation code is used in tree, if so, then transform them into\n+\tappropriate C code.\n+\t(c_parser_expr_no_commas): Check if array notation is used in LHS\n+\tor RHS, if so, then build array notation expression instead of\n+\tregular modify.\n+\t(c_parser_postfix_expression_after_primary): Added a check for\n+\tcolon(s) after square braces, if so then handle it like an array\n+\tnotation.  Also, break up array notations in unary op if found.\n+\t(c_parser_direct_declarator_inner): Added a check for array\n+\tnotation.\n+\t(c_parser_compound_statement): Added a check for array notation in\n+\ta stmt.  If one is present, then expand array notation expr.\n+\t(c_parser_if_statement): Likewise.\n+\t(c_parser_switch_statement): Added a check for array notations in\n+\ta switch statement's condition.  If true, then output an error.\n+\t(c_parser_while_statement): Similarly, but for a while.\n+\t(c_parser_do_statement): Similarly, but for a do-while.\n+\t(c_parser_for_statement): Similarly, but for a for-loop.\n+\t(c_parser_unary_expression): Check if array notation is used in a\n+\tpre-increment or pre-decrement expression.  If true, then expand\n+\tthem.\n+\t(c_parser_array_notation): New function.\n+\t* c-array-notation.c: New file.\n+\t* c-tree.h (is_cilkplus_reduce_builtin): Protoize.\n+\t\n 2013-05-23  Mike Stump  <mikestump@comcast.net>\n \n \t* c-typeck.c (convert_for_assignment): Handle references to memory"}, {"sha": "1161742c2740ba73c1f3502976950ce45d63326f", "filename": "gcc/c/Make-lang.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FMake-lang.in?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -56,7 +56,7 @@ c/gccspec.o: c/gccspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) \\\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c/c-errors.o c/c-decl.o c/c-typeck.o \\\n   c/c-convert.o c/c-aux-info.o c/c-objc-common.o c/c-parser.o \\\n-  $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n+  c/c-array-notation.o $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n C_OBJS = c/c-lang.o c-family/stub-objc.o $(C_AND_OBJC_OBJS)\n@@ -192,3 +192,8 @@ c/c-typeck.o : c/c-typeck.c c/c-lang.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_\n \tlanghooks.h tree-iterator.h $(BITMAP_H) $(GIMPLE_H) \\\n \tc-family/c-objc.h c-family/c-common.h\n \n+c/c-array-notation.o: c/c-array-notation.c c/c-lang.h $(CONFIG_H) \\\n+\t$(SYSTEM_H) coretypes.h $(TREE_H) $(C_TREE_H) $(TARGET_H) \\\n+\tintl.h output.h $(EXPR_H) langhooks.h tree-iterator.h $(BITMAP_H) \\\n+\t$(GIMPLE_H) c-family/c-objc.h\n+"}, {"sha": "c70345cfa983f5bf120b1686a0823fba79d34b7f", "filename": "gcc/c/c-array-notation.c", "status": "added", "additions": 2875, "deletions": 0, "changes": 2875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,2875 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   This file contains routines to handle Array Notation expression\n+   handling routines in the C Compiler.\n+   Copyright (C) 2013  Free Software Foundation, Inc.\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n+                  Intel Corporation.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The Array Notation Transformation Technique:\n+\n+   An array notation expression has 4 major components:\n+   1. The array name\n+   2. Start Index\n+   3. Number of elements we need to acess (we call it length)\n+   4. Stride\n+\n+   For example, A[0:5:2], implies that we are accessing A[0], A[2], A[4],\n+   A[6] and A[8]. The user is responsible to make sure the access length does\n+   not step outside the array's size.\n+   \n+   In this section, I highlight the overall method on how array notations are\n+   broken up into C/C++ code.  Almost all the functions follows this overall\n+   technique:\n+\n+   Let's say we have an array notation in a statement like this:\n+\n+   A[St1:Ln:Str1] = B[St2:Ln:Str2] + <NON ARRAY_NOTATION_STMT>\n+\n+   where St{1,2} = Starting index,\n+   Ln = Number of elements we need to access,\n+   and Str{1,2} = the stride.\n+   Note: The length of both the array notation expressions must be the same.\n+   \n+   The above expression is broken into the following\n+   (with the help of c_finish_loop function from c-typeck.c):\n+   \n+   Tmp_Var = 0;\n+   goto compare_label:\n+   body_label:\n+\n+   A[St1+Tmp_Var*Str1] = B[St1+Tmp_Var*Str2] + <NON ARRAY_NOTATION_STMT>;\n+   Tmp_Var++;\n+   \n+   compare_label:\t\t\t\t\n+     if (Tmp_Var < Ln)\n+       goto body_label;\n+     else\n+       goto exit_label;\n+   exit_label:\t\t  \t      \n+\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"opts.h\"\n+#include \"c-family/c-common.h\"\n+\n+static void replace_array_notations (tree *, bool, vec<tree, va_gc> *,\n+\t\t\t\t     vec<tree, va_gc> *);\n+static void extract_array_notation_exprs (tree, bool, vec<tree, va_gc> **);\n+\n+/* This structure holds all the scalar values and its appropriate variable \n+   replacment.  It is mainly used by the function that pulls all the invariant\n+   parts that should be executed only once, which comes with array notation \n+   expressions.  */\n+struct inv_list\n+{\n+  vec<tree, va_gc> *list_values;\n+  vec<tree, va_gc> *replacement;\n+};\n+\n+/* Returns true if there is length mismatch among expressions\n+   on the same dimension and on the same side of the equal sign.  The\n+   expressions (or ARRAY_NOTATION lengths) are passed in through 2-D array\n+   **LIST where X and Y indicate first and second dimension sizes of LIST,\n+   respectively.  */\n+\n+static bool\n+length_mismatch_in_expr_p (location_t loc, tree **list, size_t x, size_t y)\n+{\n+  size_t ii, jj;\n+  tree start = NULL_TREE;\n+  HOST_WIDE_INT l_start, l_node;\n+  for (jj = 0; jj < y; jj++)\n+    {\n+      start = NULL_TREE;\n+      for (ii = 0; ii < x; ii++)\n+\t{\n+\t  if (!start)\n+\t    start = list[ii][jj];\n+\t  else if (TREE_CODE (start) == INTEGER_CST)\n+\t    {\n+\t      /* If start is a INTEGER, and list[ii][jj] is an integer then\n+\t\t check if they are equal.  If they are not equal then return\n+\t\t true.  */\n+\t      if (TREE_CODE (list[ii][jj]) == INTEGER_CST)\n+\t\t{\n+\t\t  l_node = int_cst_value (list[ii][jj]);\n+\t\t  l_start = int_cst_value (start);\n+\t\t  if (abs (l_start) != abs (l_node))\n+\t\t    {\n+\t\t      error_at (loc, \"length mismatch in expression\");\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* We set the start node as the current node just in case it turns\n+\t       out to be an integer.  */\n+\t    start = list[ii][jj];\n+\t}\n+    }\n+  return false;\n+}\n+\n+\n+/* Given an FNDECL of type FUNCTION_DECL or ADDR_EXPR, return the corresponding\n+   BUILT_IN_CILKPLUS_SEC_REDUCE_* being called.  If none, return\n+   BUILT_IN_NONE.  */\n+\n+enum built_in_function\n+is_cilkplus_reduce_builtin (tree fndecl)\n+{\n+  if (TREE_CODE (fndecl) == ADDR_EXPR)\n+    fndecl = TREE_OPERAND (fndecl, 0);\n+\n+  if (TREE_CODE (fndecl) == FUNCTION_DECL\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (fndecl))\n+      {\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+\treturn DECL_FUNCTION_CODE (fndecl);\n+      default:\n+\tbreak;\n+      }\n+\n+  return BUILT_IN_NONE;\n+}\n+\n+/* This function will recurse into EXPR finding any\n+   ARRAY_NOTATION_EXPRs and calculate the overall rank of EXPR,\n+   storing it in *RANK. LOC is the location of the original expression.\n+\n+   ORIG_EXPR is the original expression used to display if any rank\n+   mismatch errors are found.\n+\n+   Upon entry, *RANK must be either 0, or the rank of a parent\n+   expression that must have the same rank as the one being\n+   calculated.  It is illegal to have multiple array notation with different\n+   rank in the same expression (see examples below for clarification).\n+\n+   If there were any rank mismatches while calculating the rank, an\n+   error will be issued, and FALSE will be returned.  Otherwise, TRUE\n+   is returned.  \n+\n+   If IGNORE_BUILTIN_FN is TRUE, ignore array notation specific\n+   built-in functions (__sec_reduce_*, etc).\n+\n+   Here are some examples of array notations and their rank:\n+\n+   Expression\t\t\t    RANK\n+   5\t\t\t\t    0\n+   X (a variable)\t\t    0\n+   *Y (a pointer)\t\t    0\n+   A[5]\t\t\t\t    0\n+   B[5][10]\t\t\t    0\n+   A[:]\t\t\t\t    1 \n+   B[0:10]\t\t\t    1\n+   C[0:10:2]\t\t\t    1\n+   D[5][0:10:2]\t\t\t    1 (since D[5] is considered \"scalar\")\n+   D[5][:][10]\t\t\t    1 \n+   E[:] + 5\t\t\t    1 \n+   F[:][:][:] + 5 + X\t\t    3\n+   F[:][:][:] + E[:] + 5 + X\t    RANKMISMATCH-ERROR since rank (E[:]) = 1 and\n+                                    rank (F[:][:][:]) = 3.  They must be equal \n+\t\t\t\t    or have a rank of zero.\n+   F[:][5][10] + E[:] * 5 + *Y      1\n+\n+   int func (int);\n+   func (A[:])\t\t\t    1\n+   func (B[:][:][:][:])             4 \n+   \n+   int func2 (int, int)\n+   func2 (A[:], B[:][:][:][:])\t    RANKMISMATCH-ERROR -- Since Rank (A[:]) = 1 \n+\t\t\t\t    and Rank (B[:][:][:][:]) = 4\n+\n+   A[:] + func (B[:][:][:][:])\t    RANKMISMATCH-ERROR\n+   func2 (A[:], B[:]) + func (A)    1 \n+\n+ */\n+\n+bool\n+find_rank (location_t loc, tree orig_expr, tree expr, bool ignore_builtin_fn,\n+\t   size_t *rank)\n+{\n+  tree ii_tree;\n+  size_t ii = 0, current_rank = 0;\n+ \n+  if (TREE_CODE (expr) == ARRAY_NOTATION_REF)\n+    {\n+      ii_tree = expr;\n+      while (ii_tree)\n+\t{\n+\t  if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n+\t    {\n+\t      current_rank++;\n+\t      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t    }\n+\t  else if (TREE_CODE (ii_tree) == ARRAY_REF)\n+\t    ii_tree = TREE_OPERAND (ii_tree, 0);\n+\t  else if (TREE_CODE (ii_tree) == PARM_DECL\n+\t\t   || TREE_CODE (ii_tree) == VAR_DECL)\n+\t    break;\n+\t}\n+      if (*rank == 0)\n+\t/* In this case, all the expressions this function has encountered thus\n+\t   far have been scalars or expressions with zero rank.  Please see\n+\t   header comment for examples of such expression.  */\n+\t*rank = current_rank;\n+      else if (*rank != current_rank)\n+\t{\n+\t  /* In this case, find rank is being recursed through a set of \n+\t     expression of the form A <OPERATION> B, where A and B both have\n+\t     array notations in them and the rank of A is not equal to rank of\n+\t     B.  \n+\t     A simple example of such case is the following: X[:] + Y[:][:] */ \n+\t  *rank = current_rank;\n+\t  return false;\n+\t}\n+    }\n+  else if (TREE_CODE (expr) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator ii_tsi;\n+      for (ii_tsi = tsi_start (expr); !tsi_end_p (ii_tsi);\n+\t   tsi_next (&ii_tsi))\n+\tif (!find_rank (loc, orig_expr, *tsi_stmt_ptr (ii_tsi),\n+\t\t\tignore_builtin_fn, rank))\n+\t  return false;\n+    }\n+  else\n+    {\n+      if (TREE_CODE (expr) == CALL_EXPR)\n+\t{\n+\t  tree func_name = CALL_EXPR_FN (expr);\n+\t  tree prev_arg = NULL_TREE, arg;\n+\t  call_expr_arg_iterator iter;\n+\t  size_t prev_rank = 0;\n+\t  if (TREE_CODE (func_name) == ADDR_EXPR)\n+\t    if (!ignore_builtin_fn)\n+\t      if (is_cilkplus_reduce_builtin (func_name))\n+\t\t/* If it is a built-in function, then we know it returns a \n+\t\t   scalar.  */\n+\t\treturn true;\n+\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n+\t    {\n+\t      if (!find_rank (loc, orig_expr, arg, ignore_builtin_fn, rank))\n+\t\t{\n+\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg)\n+\t\t      && prev_rank != *rank)\n+\t\t    error_at (EXPR_LOCATION (prev_arg),\n+\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n+\t\t\t      arg);\n+\t\t  else if (prev_arg && prev_rank != *rank)\n+\t\t    /* Here the original expression is printed as a \"heads-up\"\n+\t\t       to the programmer.  This is because since there is no \n+\t\t       location information for the offending argument, the \n+\t\t       error could be in some internally generated code that is\n+\t\t       not visible for the programmer.  Thus, the correct fix\n+\t\t       may lie in the original expression.  */\n+\t\t    error_at (loc, \"rank mismatch in expression %qE\",\n+\t\t\t      orig_expr);\n+\t\t  return false;\n+\t\t}\n+\t      prev_arg = arg;\n+\t      prev_rank = *rank;\n+\t    }\t\n+\t}\n+      else\n+\t{\n+\t  tree prev_arg = NULL_TREE;\n+\t  for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (expr)); ii++)\n+\t    {\n+\t      if (TREE_OPERAND (expr, ii)\n+\t\t  && !find_rank (loc, orig_expr, TREE_OPERAND (expr, ii),\n+\t\t\t\t ignore_builtin_fn, rank))\n+\t\t{\n+\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg))\n+\t\t    error_at (EXPR_LOCATION (prev_arg),\n+\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n+\t\t\t      TREE_OPERAND (expr, ii));\n+\t\t  else if (prev_arg)\n+\t\t    error_at (loc, \"rank mismatch in expression %qE\",\n+\t\t\t      orig_expr);\n+\t\t  return false;\n+\t\t}\n+\t      prev_arg = TREE_OPERAND (expr, ii);\n+\t    }\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Extracts all array notations in NODE and stores them in ARRAY_LIST.  If \n+   IGNORE_BUILTIN_FN is set, then array notations inside array notation\n+   specific built-in functions are ignored.  The NODE can be constants,\n+   VAR_DECL, PARM_DECLS, STATEMENT_LISTS or full expressions.   */\n+\n+static void\n+extract_array_notation_exprs (tree node, bool ignore_builtin_fn,\n+\t\t\t      vec<tree, va_gc> **array_list)\n+{\n+  size_t ii = 0;  \n+  if (TREE_CODE (node) == ARRAY_NOTATION_REF)\n+    {\n+      vec_safe_push (*array_list, node);\n+      return;\n+    }\n+  else if (TREE_CODE (node) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator ii_tsi;\n+      for (ii_tsi = tsi_start (node); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n+\textract_array_notation_exprs (*tsi_stmt_ptr (ii_tsi),\n+\t\t\t\t      ignore_builtin_fn, array_list);\n+    }\n+  else if (TREE_CODE (node) == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n+      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (node)))\n+\t{\n+\t  if (ignore_builtin_fn)\n+\t    return;\n+\t  else\n+\t    {\n+\t      vec_safe_push (*array_list, node);\n+\t      return;\n+\t    }\n+\t}\n+      if (is_sec_implicit_index_fn (CALL_EXPR_FN (node)))\n+\t{\n+\t  vec_safe_push (*array_list, node);\n+\t  return;\n+\t}\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n+\textract_array_notation_exprs (arg, ignore_builtin_fn, array_list);\n+    } \n+  else \n+    for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (node)); ii++) \n+      if (TREE_OPERAND (node, ii))\n+\textract_array_notation_exprs (TREE_OPERAND (node, ii),\n+\t\t\t\t      ignore_builtin_fn, array_list);\n+  return;\n+}\n+\n+/* LIST contains all the array notations found in *ORIG and ARRAY_OPERAND\n+   contains the expanded ARRAY_REF.  E.g., if LIST[<some_index>] contains\n+   an array_notation expression, then ARRAY_OPERAND[<some_index>] contains its\n+   expansion.  If *ORIG matches LIST[<some_index>] then *ORIG is set to\n+   ARRAY_OPERAND[<some_index>].  This function recursively steps through\n+   all the sub-trees of *ORIG, if it is larger than a single\n+   ARRAY_NOTATION_REF.  */\n+\n+static void\n+replace_array_notations (tree *orig, bool ignore_builtin_fn,\n+\t\t\t vec<tree, va_gc> *list,\n+\t\t\t vec<tree, va_gc> *array_operand)\n+{\n+  size_t ii = 0;\n+  tree node = NULL_TREE, node_replacement = NULL_TREE;\n+  \n+  if (vec_safe_length (list) == 0)\n+    return;\n+\n+  if (TREE_CODE (*orig) == ARRAY_NOTATION_REF)\n+    {\n+      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n+\tif (*orig == node)\n+\t  {\n+\t    node_replacement = (*array_operand)[ii];\n+\t    *orig = node_replacement;\n+\t  }\n+    }\n+  else if (TREE_CODE (*orig) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator ii_tsi;\n+      for (ii_tsi = tsi_start (*orig); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n+\treplace_array_notations (tsi_stmt_ptr (ii_tsi), ignore_builtin_fn, list,\n+\t\t\t\t array_operand);\n+    }\n+  else if (TREE_CODE (*orig) == CALL_EXPR)\n+    {\n+      tree arg;\n+      call_expr_arg_iterator iter;\n+      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (*orig)))\n+\t{\n+\t  if (!ignore_builtin_fn)\n+\t    {\n+\t      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n+\t\tif (*orig == node)\n+\t\t  {\n+\t\t    node_replacement = (*array_operand)[ii];\n+\t\t    *orig = node_replacement;\n+\t\t  }\n+\t    }\n+\t  return;\n+\t}\n+      if (is_sec_implicit_index_fn (CALL_EXPR_FN (*orig)))\n+\t{\n+\t  for (ii = 0; vec_safe_iterate (list, ii, &node); ii++)\n+\t    if (*orig == node)\n+\t      {\n+\t\tnode_replacement = (*array_operand)[ii];\n+\t\t*orig = node_replacement;\n+\t      }\n+\t  return;\n+\t}\n+      ii = 0;\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, *orig)\n+\t{\n+\t  replace_array_notations (&arg, ignore_builtin_fn, list,\n+\t\t\t\t   array_operand);\n+\t  CALL_EXPR_ARG (*orig, ii) = arg;\n+\t  ii++;\n+\t}     \n+    }\n+  else\n+    {\n+      for (ii = 0; ii < (size_t) TREE_CODE_LENGTH (TREE_CODE (*orig)); ii++) \n+\tif (TREE_OPERAND (*orig, ii))\n+\t  replace_array_notations (&TREE_OPERAND (*orig, ii), ignore_builtin_fn,\n+\t\t\t\t   list, array_operand);\n+    }\n+  return;\n+}\n+\n+/* Callback for walk_tree.  Find all the scalar expressions in *TP and push \n+   them in DATA struct, typecasted to (void *).  If *WALK_SUBTREES is set to 0 \n+   then do not go into the *TP's subtrees.  Since this function steps through \n+   all the subtrees, *TP and TP can be NULL_TREE and NULL, respectively.  The \n+   function returns NULL_TREE unconditionally.  */\n+\n+static tree\n+find_inv_trees (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct inv_list *i_list = (struct inv_list *) data;\n+\n+  if (!tp || !*tp)\n+    return NULL_TREE;\n+  if (TREE_CONSTANT (*tp))\n+    return NULL_TREE; /* No need to save constant to a variable.  */\n+  if (TREE_CODE (*tp) != COMPOUND_EXPR && !contains_array_notation_expr (*tp))\n+    {\n+      vec_safe_push (i_list->list_values, *tp);\n+      *walk_subtrees = 0;\n+    }\n+  else if (TREE_CODE (*tp) == ARRAY_NOTATION_REF\n+\t   || TREE_CODE (*tp) == ARRAY_REF\n+\t   || TREE_CODE (*tp) == CALL_EXPR)\n+    /* No need to step through the internals of array notation.  */\n+    *walk_subtrees = 0;\n+  else\n+    *walk_subtrees = 1;\n+  return NULL_TREE;\n+}\n+\n+/* Callback for walk_tree.  Replace all the scalar expressions in *TP with the \n+   appropriate replacement stored in the struct *DATA (typecasted to void*).  \n+   The subtrees are not touched if *WALK_SUBTREES is set to zero.  */\n+\n+static tree\n+replace_inv_trees (tree *tp, int *walk_subtrees, void *data)\n+{\n+  size_t ii = 0;\n+  tree t, r;\n+  struct inv_list *i_list = (struct inv_list *) data;\n+\n+  if (vec_safe_length (i_list->list_values))\n+    {\n+      for (ii = 0; vec_safe_iterate (i_list->list_values, ii, &t); ii++)\n+\tif (simple_cst_equal (*tp, t) == 1)\n+\t  {\n+\t    vec_safe_iterate (i_list->replacement, ii, &r);\n+\t    gcc_assert (r != NULL_TREE);\n+\t    *tp = r;\n+\t    *walk_subtrees = 0;\n+\t  }\n+    }\n+  else\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n+/* Replaces all the scalar expressions in *NODE.  Returns a STATEMENT_LIST that\n+   holds the NODE along with variables that holds the results of the invariant\n+   expressions.  */\n+\n+tree\n+replace_invariant_exprs (tree *node)\n+{\n+  size_t ix = 0;\n+  tree node_list = NULL_TREE;\n+  tree t = NULL_TREE, new_var = NULL_TREE, new_node; \n+  struct inv_list data;\n+\n+  data.list_values = NULL;\n+  data.replacement = NULL;\n+  walk_tree (node, find_inv_trees, (void *)&data, NULL);\n+\n+  if (vec_safe_length (data.list_values))\n+    {\n+      node_list = push_stmt_list ();\n+      for (ix = 0; vec_safe_iterate (data.list_values, ix, &t); ix++)\n+\t{\n+\t  new_var = build_decl (EXPR_LOCATION (t), VAR_DECL, NULL_TREE,\n+\t\t\t\tTREE_TYPE (t));\n+\t  gcc_assert (new_var != NULL_TREE && new_var != error_mark_node);\n+\t  new_node = build2 (MODIFY_EXPR, TREE_TYPE (t), new_var, t);\n+\t  add_stmt (new_node);\n+\t  vec_safe_push (data.replacement, new_var);\n+\t}\n+      walk_tree (node, replace_inv_trees, (void *)&data, NULL);\n+      node_list = pop_stmt_list (node_list);\n+    }\n+  return node_list;\n+}\n+\n+/* Given a CALL_EXPR to an array notation built-in function in\n+   AN_BUILTIN_FN, replace the call with the appropriate loop and\n+   computation.  Return the computation in *NEW_VAR.\n+\n+   The return value in *NEW_VAR will always be a scalar.  If the\n+   built-in is __sec_reduce_mutating, *NEW_VAR is set to NULL_TREE.  */\n+\n+static tree\n+fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n+{\n+  tree new_var_type = NULL_TREE, func_parm, new_expr, new_yes_expr, new_no_expr;\n+  tree array_ind_value = NULL_TREE, new_no_ind, new_yes_ind, new_no_list;\n+  tree new_yes_list, new_cond_expr, new_var_init = NULL_TREE;\n+  tree new_exp_init = NULL_TREE;\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  size_t list_size = 0, rank = 0, ii = 0, jj = 0;\n+  int s_jj = 0;\n+  tree **array_ops, *array_var, jj_tree, loop_init, array_op0;\n+  tree **array_value, **array_stride, **array_length, **array_start;\n+  tree *compare_expr, *expr_incr, *ind_init;\n+  tree identity_value = NULL_TREE, call_fn = NULL_TREE, new_call_expr, body;\n+  bool **count_down, **array_vector;\n+  location_t location = UNKNOWN_LOCATION;\n+  tree loop_with_init = alloc_stmt_list ();\n+  \n+  enum built_in_function an_type =\n+    is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n+  if (an_type == BUILT_IN_NONE)\n+    return NULL_TREE;\n+\n+  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE\n+      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    {\n+      call_fn = CALL_EXPR_ARG (an_builtin_fn, 2);\n+      while (TREE_CODE (call_fn) == CONVERT_EXPR\n+\t     || TREE_CODE (call_fn) == NOP_EXPR)\n+\tcall_fn = TREE_OPERAND (call_fn, 0);\n+      call_fn = TREE_OPERAND (call_fn, 0);\n+      \n+      identity_value = CALL_EXPR_ARG (an_builtin_fn, 0);\n+      while (TREE_CODE (identity_value) == CONVERT_EXPR\n+\t     || TREE_CODE (identity_value) == NOP_EXPR)\n+\tidentity_value = TREE_OPERAND (identity_value, 0);\n+      func_parm = CALL_EXPR_ARG (an_builtin_fn, 1);\n+    }\n+  else\n+    func_parm = CALL_EXPR_ARG (an_builtin_fn, 0);\n+  \n+  while (TREE_CODE (func_parm) == CONVERT_EXPR\n+\t || TREE_CODE (func_parm) == EXCESS_PRECISION_EXPR\n+\t || TREE_CODE (func_parm) == NOP_EXPR)\n+    func_parm = TREE_OPERAND (func_parm, 0);\n+\n+  location = EXPR_LOCATION (an_builtin_fn);\n+  \n+  if (!find_rank (location, an_builtin_fn, an_builtin_fn, true, &rank))\n+    return error_mark_node;\n+ \n+  if (rank == 0)\n+    return an_builtin_fn;\n+  else if (rank > 1 \n+\t   && (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+\t       || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND))\n+    {\n+      error_at (location, \"__sec_reduce_min_ind or __sec_reduce_max_ind cannot\"\n+\t\t\" have arrays with dimension greater than 1\");\n+      return error_mark_node;\n+    }\n+  \n+  extract_array_notation_exprs (func_parm, true, &array_list);\n+  list_size = vec_safe_length (array_list);\n+  switch (an_type)\n+    {\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      new_var_type = TREE_TYPE ((*array_list)[0]);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+      new_var_type = integer_type_node;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+      new_var_type = integer_type_node;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+      if (call_fn && identity_value) \n+\tnew_var_type = TREE_TYPE ((*array_list)[0]);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+      new_var_type = NULL_TREE;\n+      break;\n+    default:\n+      gcc_unreachable (); \n+    }\n+  \n+  array_ops = XNEWVEC (tree *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_ops[ii] = XNEWVEC (tree, rank);\n+  \n+  array_vector = XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_vector[ii] = XNEWVEC (bool, rank);\n+\n+  array_value = XNEWVEC (tree *, list_size);\n+  array_stride = XNEWVEC (tree *, list_size);\n+  array_length = XNEWVEC (tree *, list_size);\n+  array_start = XNEWVEC (tree *, list_size);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      array_value[ii]  = XNEWVEC (tree, rank);\n+      array_stride[ii] = XNEWVEC (tree, rank);\n+      array_length[ii] = XNEWVEC (tree, rank);\n+      array_start[ii]  = XNEWVEC (tree, rank);\n+    }\n+\n+  compare_expr = XNEWVEC (tree, rank);\n+  expr_incr = XNEWVEC (tree,  rank);\n+  ind_init = XNEWVEC (tree, rank);\n+  \n+  count_down = XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    count_down[ii] = XNEWVEC (bool,  rank);\n+  \n+  array_var = XNEWVEC (tree, rank);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      jj = 0;\n+      for (jj_tree = (*array_list)[ii];\n+\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n+\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n+\t{\n+\t  array_ops[ii][jj] = jj_tree;\n+\t  jj++;\n+\t}\n+    }\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (jj = 0; jj < rank; jj++)\n+\t    {\n+\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  array_value[ii][jj] =\n+\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n+\t\t  array_start[ii][jj] =\n+\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n+\t\t  array_length[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n+\t\t  array_stride[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n+\t\t  array_vector[ii][jj] = true;\n+\n+\t\t  if (!TREE_CONSTANT (array_length[ii][jj]))\n+\t\t    count_down[ii][jj] = false;\n+\t\t  else if (tree_int_cst_lt\n+\t\t\t   (array_length[ii][jj],\n+\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n+\t\t\t\t\t   0)))\n+\t\t    count_down[ii][jj] = true;\n+\t\t  else\n+\t\t    count_down[ii][jj] = false;\n+\t\t}\n+\t      else\n+\t\tarray_vector[ii][jj] = false;\n+\t    }\n+\t}\n+    }\n+\n+  loop_init = alloc_stmt_list ();\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+      ind_init[ii] =\n+\tbuild_modify_expr (location, array_var[ii],\n+\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+\t\t\t   location,\n+\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n+\t\t\t   TREE_TYPE (array_var[ii]));\t\n+    }\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      if (array_vector[ii][0])\n+\t{\n+\t  tree array_opr_node  = array_value[ii][rank - 1];\n+\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n+\t    {\n+\t      if (count_down[ii][s_jj])\n+\t\t{\n+\t\t  /* Array[start_index - (induction_var * stride)] */\n+\t\t  array_opr_node = build_array_ref\n+\t\t    (location, array_opr_node,\n+\t\t     build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t     array_start[ii][s_jj],\n+\t\t\t     build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t     array_var[s_jj], array_stride[ii][s_jj])));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Array[start_index + (induction_var * stride)] */\n+\t\t  array_opr_node = build_array_ref\n+\t\t    (location, array_opr_node,\n+\t\t     build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t     array_start[ii][s_jj],\n+\t\t\t     build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t     array_var[s_jj], array_stride[ii][s_jj])));\n+\t\t}\n+\t    }\n+\t  vec_safe_push (array_operand, array_opr_node);\n+\t}\n+      else\n+\t/* This is just a dummy node to make sure the list sizes for both\n+\t   array list and array operand list are the same.  */\n+\tvec_safe_push (array_operand, integer_one_node);\n+    }\n+  replace_array_notations (&func_parm, true, array_list, array_operand);\n+  for (ii = 0; ii < rank; ii++)\n+    expr_incr[ii] =\n+      build2 (MODIFY_EXPR, void_type_node, array_var[ii],\n+\t      build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), array_var[ii],\n+\t\t      build_int_cst (TREE_TYPE (array_var[ii]), 1)));\n+  for (jj = 0; jj < rank; jj++)\n+    {\n+      if (rank && expr_incr[jj])\n+\t{\n+\t  if (count_down[0][jj])\n+\t    compare_expr[jj] =\n+\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n+\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n+\t\t\t      array_length[0][jj],\n+\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n+\t  else\n+\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t       array_var[jj], array_length[0][jj]);\n+\t}\n+    }\n+\n+  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    {\n+      *new_var = build_decl (location, VAR_DECL, NULL_TREE, new_var_type);\n+      gcc_assert (*new_var && *new_var != error_mark_node);\n+    }\n+  else\n+    *new_var = NULL_TREE;\n+  \n+  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n+    array_ind_value = build_decl (location, VAR_DECL, NULL_TREE, \n+\t\t\t\t  TREE_TYPE (func_parm));\n+  array_op0 = (*array_operand)[0];\t\t\t      \n+  switch (an_type)\n+    {\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (new_var_type), new_var_type);\n+      new_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), PLUS_EXPR,\n+\t location, func_parm, TREE_TYPE (func_parm));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_one_cst (new_var_type), new_var_type);\n+      new_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), MULT_EXPR,\n+\t location, func_parm, TREE_TYPE (func_parm));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_one_cst (new_var_type), new_var_type);\n+      /* Initially you assume everything is zero, now if we find a case where \n+\t it is NOT true, then we set the result to false. Otherwise \n+\t we just keep the previous value.  */\n+      new_yes_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (TREE_TYPE (*new_var)),\n+\t TREE_TYPE (*new_var));\n+      new_no_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_cond_expr = build2 (NE_EXPR, TREE_TYPE (func_parm), func_parm,\n+\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n+      new_expr = build_conditional_expr\n+\t(location, new_cond_expr, false, new_yes_expr,\n+\t TREE_TYPE (new_yes_expr), new_no_expr, TREE_TYPE (new_no_expr));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_one_cst (new_var_type), new_var_type);\n+      /* Initially you assume everything is non-zero, now if we find a case\n+\t where it is NOT true, then we set the result to false.  Otherwise\n+\t we just keep the previous value.  */\n+      new_yes_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (TREE_TYPE (*new_var)),\n+\t TREE_TYPE (*new_var));\n+      new_no_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_cond_expr = build2 (EQ_EXPR, TREE_TYPE (func_parm), func_parm,\n+\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n+      new_expr = build_conditional_expr\n+\t(location, new_cond_expr, false, new_yes_expr,\n+\t TREE_TYPE (new_yes_expr), new_no_expr, TREE_TYPE (new_no_expr));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (new_var_type), new_var_type);\n+      /* Initially we assume there are NO zeros in the list. When we find \n+\t a non-zero, we keep the previous value.  If we find a zero, we \n+\t set the value to true.  */\n+      new_yes_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_one_cst (new_var_type), new_var_type);\n+      new_no_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_cond_expr = build2 (EQ_EXPR, TREE_TYPE (func_parm), func_parm,\n+\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n+      new_expr = build_conditional_expr\n+\t(location, new_cond_expr, false, new_yes_expr,\n+\t TREE_TYPE (new_yes_expr), new_no_expr, TREE_TYPE (new_no_expr));   \n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (new_var_type), new_var_type);\n+      /* Initially we assume there are NO non-zeros in the list. When we find \n+\t a zero, we keep the previous value.  If we find a non-zero, we set \n+\t the value to true.  */\n+      new_yes_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_one_cst (new_var_type), new_var_type);\n+      new_no_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_cond_expr = build2 (NE_EXPR, TREE_TYPE (func_parm), func_parm,\n+\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n+      new_expr = build_conditional_expr\n+\t(location, new_cond_expr, false, new_yes_expr,\n+\t TREE_TYPE (new_yes_expr), new_no_expr, TREE_TYPE (new_no_expr));   \n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+      if (TYPE_MIN_VALUE (new_var_type))\n+\tnew_var_init = build_modify_expr\n+\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t   location, TYPE_MIN_VALUE (new_var_type), new_var_type);\n+      else\n+\tnew_var_init = build_modify_expr\n+\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t   location, func_parm, new_var_type);\n+      new_no_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_yes_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, func_parm, TREE_TYPE (*new_var));\n+      new_expr = build_conditional_expr\n+\t(location,\n+\t build2 (LT_EXPR, TREE_TYPE (*new_var), *new_var, func_parm), false,\n+\t new_yes_expr, TREE_TYPE (*new_var), new_no_expr, TREE_TYPE (*new_var));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      if (TYPE_MAX_VALUE (new_var_type))\n+\tnew_var_init = build_modify_expr\n+\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t   location, TYPE_MAX_VALUE (new_var_type), new_var_type);\n+      else\n+\tnew_var_init = build_modify_expr\n+\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t   location, func_parm, new_var_type);\n+      new_no_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_yes_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, func_parm, TREE_TYPE (*new_var));\n+      new_expr = build_conditional_expr\n+\t(location,\n+\t build2 (GT_EXPR, TREE_TYPE (*new_var), *new_var, func_parm), false,\n+\t new_yes_expr, TREE_TYPE (*new_var), new_no_expr, TREE_TYPE (*new_var));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (new_var_type), new_var_type);\n+      new_exp_init = build_modify_expr\n+\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t NOP_EXPR, location, func_parm, TREE_TYPE (func_parm));\n+      new_no_ind = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_no_expr = build_modify_expr\n+\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t NOP_EXPR,\n+\t location, array_ind_value, TREE_TYPE (array_ind_value));\n+      if (list_size > 1)\n+\t{\n+\t  new_yes_ind = build_modify_expr\n+\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t     location, array_var[0], TREE_TYPE (array_var[0]));\n+\t  new_yes_expr = build_modify_expr\n+\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t     NOP_EXPR,\n+\t     location, func_parm, TREE_TYPE ((*array_operand)[0]));\n+\t}\n+      else\n+\t{\n+\t  new_yes_ind = build_modify_expr\n+\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t     location, TREE_OPERAND (array_op0, 1),\n+\t     TREE_TYPE (TREE_OPERAND (array_op0, 1)));\n+\t  new_yes_expr = build_modify_expr\n+\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t     NOP_EXPR,\n+\t     location, func_parm, TREE_OPERAND (array_op0, 1));\n+\t}\n+      new_yes_list = alloc_stmt_list ();\n+      append_to_statement_list (new_yes_ind, &new_yes_list);\n+      append_to_statement_list (new_yes_expr, &new_yes_list);\n+\n+      new_no_list = alloc_stmt_list ();\n+      append_to_statement_list (new_no_ind, &new_no_list);\n+      append_to_statement_list (new_no_expr, &new_no_list);\n+ \n+      new_expr = build_conditional_expr\n+\t(location,\n+\t build2 (LE_EXPR, TREE_TYPE (array_ind_value), array_ind_value,\n+\t\t func_parm),\n+\t false,\n+\t new_yes_list, TREE_TYPE (*new_var), new_no_list, TREE_TYPE (*new_var));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, build_zero_cst (new_var_type), new_var_type);\n+      new_exp_init = build_modify_expr\n+\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t NOP_EXPR, location, func_parm, TREE_TYPE (func_parm));\n+      new_no_ind = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, *new_var, TREE_TYPE (*new_var));\n+      new_no_expr = build_modify_expr\n+\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t NOP_EXPR,\n+\t location, array_ind_value, TREE_TYPE (array_ind_value));\n+      if (list_size > 1)\n+\t{\n+\t  new_yes_ind = build_modify_expr\n+\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t     location, array_var[0], TREE_TYPE (array_var[0]));\n+\t  new_yes_expr = build_modify_expr\n+\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t     NOP_EXPR,\n+\t     location, func_parm, TREE_TYPE (array_op0));\n+\t}\n+      else\n+\t{\n+\t  new_yes_ind = build_modify_expr\n+\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t     location, TREE_OPERAND (array_op0, 1),\n+\t     TREE_TYPE (TREE_OPERAND (array_op0, 1)));\n+\t  new_yes_expr = build_modify_expr\n+\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n+\t     NOP_EXPR,\n+\t     location, func_parm, TREE_OPERAND (array_op0, 1));\n+\t}\n+      new_yes_list = alloc_stmt_list ();\n+      append_to_statement_list (new_yes_ind, &new_yes_list);\n+      append_to_statement_list (new_yes_expr, &new_yes_list);\n+\n+      new_no_list = alloc_stmt_list ();\n+      append_to_statement_list (new_no_ind, &new_no_list);\n+      append_to_statement_list (new_no_expr, &new_no_list);\n+ \n+      new_expr = build_conditional_expr\n+\t(location,\n+\t build2 (GE_EXPR, TREE_TYPE (array_ind_value), array_ind_value,\n+\t\t func_parm),\n+\t false,\n+\t new_yes_list, TREE_TYPE (*new_var), new_no_list, TREE_TYPE (*new_var));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+      new_var_init = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, identity_value, new_var_type);\n+      new_call_expr = build_call_expr (call_fn, 2, *new_var, func_parm);\n+      new_expr = build_modify_expr\n+\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n+\t location, new_call_expr, TREE_TYPE (*new_var));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+      new_expr = build_call_expr (call_fn, 2, identity_value, func_parm);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  for (ii = 0; ii < rank; ii++)\n+    append_to_statement_list (ind_init [ii], &loop_init);\n+\n+  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n+    append_to_statement_list (new_exp_init, &loop_init);\n+  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    append_to_statement_list (new_var_init, &loop_init);\n+\n+  append_to_statement_list_force (loop_init, &loop_with_init);\n+  body = new_expr;\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n+\t\t     NULL_TREE, true);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+  \n+  XDELETEVEC (compare_expr);\n+  XDELETEVEC (expr_incr);\n+  XDELETEVEC (ind_init);\n+  XDELETEVEC (array_var);  \n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      XDELETEVEC (count_down[ii]);\n+      XDELETEVEC (array_value[ii]);\n+      XDELETEVEC (array_stride[ii]);\n+      XDELETEVEC (array_length[ii]);\n+      XDELETEVEC (array_start[ii]);\n+      XDELETEVEC (array_ops[ii]);\n+      XDELETEVEC (array_vector[ii]);\n+    }\n+  XDELETEVEC (count_down);\n+  XDELETEVEC (array_value);\n+  XDELETEVEC (array_stride);\n+  XDELETEVEC (array_length);\n+  XDELETEVEC (array_start);\n+  XDELETEVEC (array_ops);\n+  XDELETEVEC (array_vector);\n+  \n+  return loop_with_init;\n+}\n+\n+/* Returns a loop with ARRAY_REF inside it with an appropriate modify expr.\n+   The LHS and/or RHS will be array notation expressions that have a MODIFYCODE\n+   Their locations are specified by LHS_LOC, RHS_LOC.  The location of the\n+   modify expression is location.  The original type of LHS and RHS are passed\n+   in LHS_ORIGTYPE and RHS_ORIGTYPE.  */\n+\n+tree\n+build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n+\t\t\t   enum tree_code modifycode, location_t rhs_loc,\n+\t\t\t   tree rhs, tree rhs_origtype)\n+{\n+  bool **lhs_vector = NULL, **rhs_vector = NULL, found_builtin_fn = false;\n+  tree **lhs_array = NULL, **rhs_array = NULL;\n+  tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n+  tree array_expr = NULL_TREE;\n+  tree **lhs_value = NULL, **rhs_value = NULL;\n+  tree **lhs_stride = NULL, **lhs_length = NULL, **lhs_start = NULL;\n+  tree **rhs_stride = NULL, **rhs_length = NULL, **rhs_start = NULL;\n+  tree an_init = NULL_TREE, *lhs_var = NULL, *rhs_var = NULL;\n+  tree *cond_expr = NULL;\n+  tree body, loop_with_init = alloc_stmt_list();\n+  tree scalar_mods = NULL_TREE;\n+  tree *lhs_expr_incr = NULL, *rhs_expr_incr = NULL;\n+  tree *lhs_ind_init = NULL, *rhs_ind_init = NULL;\n+  bool **lhs_count_down = NULL, **rhs_count_down = NULL;\n+  tree *lhs_compare = NULL, *rhs_compare = NULL;\n+  vec<tree, va_gc> *rhs_array_operand = NULL, *lhs_array_operand = NULL;\n+  size_t lhs_rank = 0, rhs_rank = 0;\n+  size_t ii = 0, jj = 0;\n+  int s_jj = 0;\n+  tree ii_tree = NULL_TREE, new_modify_expr;\n+  vec<tree, va_gc> *lhs_list = NULL, *rhs_list = NULL;\n+  tree new_var = NULL_TREE, builtin_loop = NULL_TREE;\n+  tree begin_var, lngth_var, strde_var;\n+  size_t rhs_list_size = 0, lhs_list_size = 0;\n+\n+  /* If either of this is true, an error message must have been send out\n+     already.  Not necessary to send out multiple error messages.  */\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n+    return error_mark_node;\n+  \n+  if (!find_rank (location, rhs, rhs, false, &rhs_rank))\n+    return error_mark_node;\n+  \n+  extract_array_notation_exprs (rhs, false, &rhs_list);\n+  rhs_list_size = vec_safe_length (rhs_list);\n+  an_init = push_stmt_list ();\n+  if (rhs_rank)\n+    {\n+      scalar_mods = replace_invariant_exprs (&rhs);\n+      if (scalar_mods)\n+\tadd_stmt (scalar_mods);\n+    }\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    {\n+      tree rhs_node = (*rhs_list)[ii];\n+      if (TREE_CODE (rhs_node) == CALL_EXPR)\n+\t{\n+\t  builtin_loop = fix_builtin_array_notation_fn (rhs_node, &new_var);\n+\t  if (builtin_loop == error_mark_node)\n+\t    {\n+\t      pop_stmt_list (an_init); \n+\t      return error_mark_node;\n+\t    }\n+\t  else if (builtin_loop)\n+\t    {\n+\t      add_stmt (builtin_loop);\n+\t      found_builtin_fn = true;\n+\t      if (new_var)\n+\t\t{\n+\t\t  vec<tree, va_gc> *rhs_sub_list = NULL, *new_var_list = NULL;\n+\t\t  vec_safe_push (rhs_sub_list, rhs_node);\n+\t\t  vec_safe_push (new_var_list, new_var);\n+\t\t  replace_array_notations (&rhs, false, rhs_sub_list,\n+\t\t\t\t\t   new_var_list);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  lhs_rank = 0;\n+  rhs_rank = 0;\n+  if (!find_rank (location, lhs, lhs, true, &lhs_rank))\n+    {\n+      pop_stmt_list (an_init);\n+      return error_mark_node;\n+    }\n+  \n+  if (!find_rank (location, rhs, rhs, true, &rhs_rank))\n+    {\n+      pop_stmt_list (an_init);\n+      return error_mark_node;\n+    }\n+\n+  if (lhs_rank == 0 && rhs_rank == 0)\n+    {\n+      if (found_builtin_fn)\n+\t{\n+\t  new_modify_expr = build_modify_expr (location, lhs, lhs_origtype,\n+\t\t\t\t\t       modifycode, rhs_loc, rhs,\n+\t\t\t\t\t       rhs_origtype);\n+\t  add_stmt (new_modify_expr);\n+\t  pop_stmt_list (an_init);\t  \n+\t  return an_init;\n+\t}\n+      else\n+\t{\n+\t  pop_stmt_list (an_init);\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  rhs_list_size = 0;\n+  rhs_list = NULL;\n+  extract_array_notation_exprs (rhs, true, &rhs_list);\n+  extract_array_notation_exprs (lhs, true, &lhs_list);\n+  rhs_list_size = vec_safe_length (rhs_list);\n+  lhs_list_size = vec_safe_length (lhs_list);\n+  \n+  if (lhs_rank == 0 && rhs_rank != 0 && TREE_CODE (rhs) != CALL_EXPR)\n+    {\n+      tree rhs_base = rhs;\n+      if (TREE_CODE (rhs_base) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (ii = 0; ii < (size_t) rhs_rank; ii++)\n+\t    rhs_base = ARRAY_NOTATION_ARRAY (rhs);\n+      \n+\t  error_at (location, \"%qE cannot be scalar when %qE is not\", lhs,\n+\t\t    rhs_base);\n+\t  return error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  error_at (location, \"%qE cannot be scalar when %qE is not\", lhs,\n+\t\t    rhs_base);\n+\t  return error_mark_node;\n+\t}\n+    }\n+  if (lhs_rank != 0 && rhs_rank != 0 && lhs_rank != rhs_rank)\n+    {\n+      tree lhs_base = lhs;\n+      tree rhs_base = rhs;\n+      \n+      for (ii = 0; ii < lhs_rank; ii++)\n+\tlhs_base = ARRAY_NOTATION_ARRAY (lhs_base);\n+\n+      while (rhs_base && TREE_CODE (rhs_base) != ARRAY_NOTATION_REF)\n+\trhs_base = TREE_OPERAND (rhs_base, 0);\n+      for (ii = 0; ii < rhs_rank; ii++)\n+\trhs_base = ARRAY_NOTATION_ARRAY (rhs_base);\n+      \n+      error_at (location, \"rank mismatch between %qE and %qE\", lhs, rhs);\n+      pop_stmt_list (an_init);\n+      return error_mark_node;\n+    }\n+  \n+  /* Here we assign the array notation components to variable so that we can\n+     satisfy the exec once rule.  */\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    {\n+      tree array_node = (*lhs_list)[ii];\n+      tree array_begin = ARRAY_NOTATION_START (array_node);\n+      tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n+      tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n+\n+      if (TREE_CODE (array_begin) != INTEGER_CST)\n+\t{\n+\t  begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+\t  add_stmt (build_modify_expr (location, begin_var,\n+\t\t\t\t       TREE_TYPE (begin_var),\n+\t\t\t\t       NOP_EXPR, location, array_begin,\n+\t\t\t\t       TREE_TYPE (array_begin)));      \n+\t  ARRAY_NOTATION_START (array_node) = begin_var;\n+\t}\n+\n+      if (TREE_CODE (array_lngth) != INTEGER_CST)\n+\t{\n+\t  lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+\t  add_stmt (build_modify_expr (location, lngth_var,\n+\t\t\t\t       TREE_TYPE (lngth_var),\n+\t\t\t\t       NOP_EXPR, location, array_lngth,\n+\t\t\t\t       TREE_TYPE (array_lngth)));\n+\t  ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n+\t}\n+      if (TREE_CODE (array_strde) != INTEGER_CST)\n+\t{\n+\t  strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+\n+\t  add_stmt (build_modify_expr (location, strde_var,\n+\t\t\t\t       TREE_TYPE (strde_var),\n+\t\t\t\t       NOP_EXPR, location, array_strde,\n+\t\t\t\t       TREE_TYPE (array_strde)));\n+\t  ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n+\t}\n+    }\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    {\n+      tree array_node = (*rhs_list)[ii];\n+      if (array_node && TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  tree array_begin = ARRAY_NOTATION_START (array_node);\n+\t  tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n+\t  tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n+\n+\t  if (TREE_CODE (array_begin) != INTEGER_CST)\n+\t    {\n+\t      begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, begin_var,\n+\t\t\t\t\t   TREE_TYPE (begin_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_begin,\n+\t\t\t\t\t   TREE_TYPE (array_begin)));\n+\t      ARRAY_NOTATION_START (array_node) = begin_var;\n+\t    }\n+\t  if (TREE_CODE (array_lngth) != INTEGER_CST)\n+\t    {\n+\t      lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, lngth_var,\n+\t\t\t\t\t   TREE_TYPE (lngth_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_lngth,\n+\t\t\t\t\t   TREE_TYPE (array_lngth)));\n+\t      ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n+\t    }\n+\t  if (TREE_CODE (array_strde) != INTEGER_CST)\n+\t    {\n+\t      strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\n+\t      add_stmt (build_modify_expr (location, strde_var,\n+\t\t\t\t\t   TREE_TYPE (strde_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_strde,\n+\t\t\t\t\t   TREE_TYPE (array_strde)));\n+\t      ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n+\t    }\n+\t}\n+    }\n+  \n+  lhs_vector = XNEWVEC (bool *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_vector[ii] = XNEWVEC (bool, lhs_rank);\n+  \n+  rhs_vector = XNEWVEC (bool *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_vector[ii] = XNEWVEC (bool, rhs_rank);\n+  \n+  lhs_array = XNEWVEC (tree *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_array[ii] = XNEWVEC (tree, lhs_rank);\n+  \n+  rhs_array = XNEWVEC (tree *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_array[ii] = XNEWVEC (tree, rhs_rank);\n+\n+  lhs_value = XNEWVEC (tree *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_value[ii] = XNEWVEC (tree, lhs_rank);\n+  \n+  rhs_value = XNEWVEC (tree *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_value[ii] = XNEWVEC (tree, rhs_rank);\n+\n+  lhs_stride = XNEWVEC (tree *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_stride[ii] = XNEWVEC (tree, lhs_rank);\n+  \n+  rhs_stride = XNEWVEC (tree *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_stride[ii] = XNEWVEC (tree, rhs_rank);\n+\n+  lhs_length = XNEWVEC (tree *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_length[ii] = XNEWVEC (tree, lhs_rank);\n+  \n+  rhs_length = XNEWVEC (tree *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_length[ii] = XNEWVEC (tree, rhs_rank);\n+  \n+  lhs_start = XNEWVEC (tree *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_start[ii] = XNEWVEC (tree, lhs_rank);\n+  \n+  rhs_start = XNEWVEC (tree *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_start[ii] = XNEWVEC (tree, rhs_rank);\n+\n+  lhs_var = XNEWVEC (tree, lhs_rank);\n+  rhs_var = XNEWVEC (tree, rhs_rank);\n+  cond_expr = XNEWVEC (tree, MAX (lhs_rank, rhs_rank));\n+\n+  lhs_expr_incr = XNEWVEC (tree, lhs_rank);\n+  rhs_expr_incr =XNEWVEC (tree, rhs_rank);\n+\n+  lhs_ind_init = XNEWVEC (tree, lhs_rank);\n+  rhs_ind_init = XNEWVEC (tree, rhs_rank);\n+\n+  lhs_count_down = XNEWVEC (bool *, lhs_list_size);\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    lhs_count_down[ii] =  XNEWVEC (bool, lhs_rank);\n+  \n+  rhs_count_down =  XNEWVEC (bool *, rhs_list_size);\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    rhs_count_down[ii] = XNEWVEC (bool, rhs_rank);\n+\n+  lhs_compare =  XNEWVEC (tree, lhs_rank);\n+  rhs_compare =  XNEWVEC (tree, rhs_rank);\n+  \n+  if (lhs_rank)\n+    {\n+      for (ii = 0; ii < lhs_list_size; ii++)\n+\t{\n+\t  jj = 0;\n+\t  ii_tree = (*lhs_list)[ii];\n+\t  while (ii_tree)\n+\t    {\n+\t      if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  lhs_array[ii][jj] = ii_tree;\n+\t\t  jj++;\n+\t\t  ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t\t}\n+\t      else if (TREE_CODE (ii_tree) == ARRAY_REF)\n+\t\tii_tree = TREE_OPERAND (ii_tree, 0);\n+\t      else if (TREE_CODE (ii_tree) == VAR_DECL\n+\t\t       || TREE_CODE (ii_tree) == PARM_DECL)\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+  else\n+    lhs_array[0][0] = NULL_TREE;\n+  \n+  if (rhs_rank)\n+    {\n+      for (ii = 0; ii < rhs_list_size; ii++)\n+\t{ \n+\t  jj = 0; \n+\t  ii_tree = (*rhs_list)[ii];\n+\t  while (ii_tree)\n+\t    {\n+\t      if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  rhs_array[ii][jj] = ii_tree;\n+\t\t  jj++;\n+\t\t  ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t\t}\n+\t      else if (TREE_CODE (ii_tree) == ARRAY_REF)\n+\t\tii_tree = TREE_OPERAND (ii_tree, 0);\n+\t      else if (TREE_CODE (ii_tree) == VAR_DECL\n+\t\t       || TREE_CODE (ii_tree) == PARM_DECL\n+\t\t       || TREE_CODE (ii_tree) == CALL_EXPR)\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    {\n+      tree lhs_node = (*lhs_list)[ii];\n+      if (TREE_CODE (lhs_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (jj = 0; jj < lhs_rank; jj++)\n+\t    {\n+\t      if (TREE_CODE (lhs_array[ii][jj]) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  lhs_value[ii][jj] = ARRAY_NOTATION_ARRAY (lhs_array[ii][jj]);\n+\t\t  lhs_start[ii][jj] = ARRAY_NOTATION_START (lhs_array[ii][jj]);\n+\t\t  lhs_length[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_LENGTH (lhs_array[ii][jj]));\n+\t\t  lhs_stride[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_STRIDE (lhs_array[ii][jj]));\n+\t\t  lhs_vector[ii][jj] = true;\n+\t\t  /* IF the stride value is variable (i.e. not constant) then \n+\t\t     assume that the length is positive.  */\n+\t\t  if (!TREE_CONSTANT (lhs_length[ii][jj]))\n+\t\t    lhs_count_down[ii][jj] = false;\n+\t\t  else if (tree_int_cst_lt\n+\t\t\t   (lhs_length[ii][jj],\n+\t\t\t    build_zero_cst (TREE_TYPE (lhs_length[ii][jj]))))\n+\t\t    lhs_count_down[ii][jj] = true;\n+\t\t  else\n+\t\t    lhs_count_down[ii][jj] = false;\n+\t\t}\n+\t      else\n+\t\tlhs_vector[ii][jj] = false;\n+\t    }\n+\t}\n+    }\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    {\n+      if (TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (jj = 0; jj < rhs_rank; jj++)\n+\t    {\n+\t      if (TREE_CODE (rhs_array[ii][jj]) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  rhs_value[ii][jj]  = ARRAY_NOTATION_ARRAY (rhs_array[ii][jj]);\n+\t\t  rhs_start[ii][jj]  = ARRAY_NOTATION_START (rhs_array[ii][jj]);\n+\t\t  rhs_length[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_LENGTH (rhs_array[ii][jj]));\n+\t\t  rhs_stride[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_STRIDE (rhs_array[ii][jj]));\n+\t\t  rhs_vector[ii][jj] = true;\n+\t\t  /* If the stride value is variable (i.e. not constant) then \n+\t\t     assume that the length is positive.  */\n+\t\t  if (!TREE_CONSTANT (rhs_length[ii][jj]))\n+\t\t    rhs_count_down[ii][jj] = false;\n+\t\t  else if (tree_int_cst_lt\n+\t\t\t   (rhs_length[ii][jj],\n+\t\t\t    build_int_cst (TREE_TYPE (rhs_length[ii][jj]), 0)))\n+\t\t    rhs_count_down[ii][jj] = true;\n+\t\t  else\n+\t\t    rhs_count_down[ii][jj] = false;\t\n+\t\t}\n+\t      else\n+\t\trhs_vector[ii][jj] = false;\n+\t    }\n+\t}\n+      else\n+\tfor (jj = 0; jj < rhs_rank; jj++)\n+\t  rhs_vector[ii][jj] = false;\n+    }\n+\n+  if (length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_length,\n+\t\t\t\t lhs_list_size, lhs_rank)\n+      || length_mismatch_in_expr_p (EXPR_LOCATION (rhs), rhs_length,\n+\t\t\t\t    rhs_list_size, rhs_rank))\n+    {\n+      pop_stmt_list (an_init);\n+      return error_mark_node;\n+    }\n+\n+  if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n+      && TREE_CODE (lhs_length[0][0]) == INTEGER_CST\n+      && TREE_CODE (rhs_length[0][0]) == INTEGER_CST)\n+    {\n+      HOST_WIDE_INT l_length = int_cst_value (lhs_length[0][0]);\n+      HOST_WIDE_INT r_length = int_cst_value (rhs_length[0][0]);\n+      /* Length can be negative or positive.  As long as the magnitude is OK,\n+\t then the array notation is valid.  */\n+      if (abs (l_length) != abs (r_length))\n+\t{\n+\t  error_at (location, \"length mismatch between LHS and RHS\");\n+\t  pop_stmt_list (an_init);\n+\t  return error_mark_node;\n+\t}\n+    }\n+  for (ii = 0; ii < lhs_rank; ii++)\n+    {\n+      if (lhs_vector[0][ii])\n+\t{\n+\t  lhs_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t    integer_type_node);\n+\t  lhs_ind_init[ii] = build_modify_expr\n+\t    (location, lhs_var[ii], TREE_TYPE (lhs_var[ii]),\n+\t     NOP_EXPR,\n+\t     location, build_zero_cst (TREE_TYPE (lhs_var[ii])),\n+\t     TREE_TYPE (lhs_var[ii]));\n+\t}\n+    }\n+\n+  for (ii = 0; ii < rhs_rank; ii++)\n+    {\n+      /* When we have a polynomial, we assume that the indices are of type \n+\t integer.  */\n+      rhs_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\tinteger_type_node);\n+      rhs_ind_init[ii] = build_modify_expr\n+\t(location, rhs_var[ii], TREE_TYPE (rhs_var[ii]),\n+\t NOP_EXPR,\n+\t location, build_int_cst (TREE_TYPE (rhs_var[ii]), 0),\n+\t TREE_TYPE (rhs_var[ii]));\n+    }\n+  if (lhs_rank)\n+    {\n+      for (ii = 0; ii < lhs_list_size; ii++)\n+\t{\n+\t  if (lhs_vector[ii][0])\n+\t    { \n+\t      /* The last ARRAY_NOTATION element's ARRAY component should be \n+\t\t the array's base value.  */\n+\t      tree lhs_array_opr = lhs_value[ii][lhs_rank - 1];\n+\t      for (s_jj = lhs_rank - 1; s_jj >= 0; s_jj--)\n+\t\t{\n+\t\t  if (lhs_count_down[ii][s_jj])\n+\t  \t      /* Array[start_index + (induction_var * stride)].  */\n+\t\t      lhs_array_opr = build_array_ref\n+\t\t\t(location, lhs_array_opr,\n+\t\t\t build2 (MINUS_EXPR, TREE_TYPE (lhs_var[s_jj]),\n+\t\t\t\t lhs_start[ii][s_jj],\n+\t\t\t\t build2 (MULT_EXPR, TREE_TYPE (lhs_var[s_jj]),\n+\t\t\t\t\t lhs_var[s_jj],\n+\t\t\t\t\t lhs_stride[ii][s_jj])));\n+\t\t  else\n+\t\t    lhs_array_opr = build_array_ref\n+\t\t      (location, lhs_array_opr,\n+\t\t       build2 (PLUS_EXPR, TREE_TYPE (lhs_var[s_jj]),\n+\t\t\t       lhs_start[ii][s_jj],\n+\t\t\t       build2 (MULT_EXPR, TREE_TYPE (lhs_var[s_jj]),\n+\t\t\t\t       lhs_var[s_jj],\n+\t\t\t\t       lhs_stride[ii][s_jj])));\n+\t\t}\n+\t      vec_safe_push (lhs_array_operand, lhs_array_opr);\n+\t    }\n+\t  else\n+\t    vec_safe_push (lhs_array_operand, integer_one_node);\n+\t}\n+      replace_array_notations (&lhs, true, lhs_list, lhs_array_operand);\n+      array_expr_lhs = lhs;\n+    }\n+\n+  if (rhs_rank)\n+    {\n+      for (ii = 0; ii < rhs_list_size; ii++)\n+\t{\n+\t  if (rhs_vector[ii][0])\n+\t    {\n+\t      tree rhs_array_opr = rhs_value[ii][rhs_rank - 1];\n+\t      for (s_jj = rhs_rank - 1; s_jj >= 0; s_jj--)\n+\t\t{\n+\t\t  if (rhs_count_down[ii][s_jj])\n+\t\t    /* Array[start_index - (induction_var * stride)] */\n+\t\t    rhs_array_opr = build_array_ref\n+\t\t      (location, rhs_array_opr,\n+\t\t       build2 (MINUS_EXPR, TREE_TYPE (rhs_var[s_jj]),\n+\t\t\t       rhs_start[ii][s_jj],\n+\t\t\t       build2 (MULT_EXPR, TREE_TYPE (rhs_var[s_jj]),\n+\t\t\t\t       rhs_var[s_jj],\n+\t\t\t\t       rhs_stride[ii][s_jj])));\n+\t\t  else\n+\t\t    /* Array[start_index  + (induction_var * stride)] */\n+\t\t    rhs_array_opr = build_array_ref\n+\t\t      (location, rhs_array_opr,\n+\t\t       build2 (PLUS_EXPR, TREE_TYPE (rhs_var[s_jj]),\n+\t\t\t       rhs_start[ii][s_jj],\n+\t\t\t       build2 (MULT_EXPR, TREE_TYPE (rhs_var[s_jj]),\n+\t\t\t\t       rhs_var[s_jj],\n+\t\t\t\t       rhs_stride[ii][s_jj])));\n+\t\t}\n+\t      vec_safe_push (rhs_array_operand, rhs_array_opr);\n+\t    }\n+\t  else\n+\t  /* This is just a dummy node to make sure the list sizes for both\n+\t     array list and array operand list are the same.  */\n+\t  vec_safe_push (rhs_array_operand, integer_one_node);\n+\t}\n+\n+      for (ii = 0; ii < rhs_list_size; ii++)\n+\t{\n+\t  tree rhs_node = (*rhs_list)[ii];\n+\t  if (TREE_CODE (rhs_node) == CALL_EXPR)\n+\t    {\n+\t      int idx_value = 0;\n+\t      tree func_name = CALL_EXPR_FN (rhs_node);\n+\t      if (TREE_CODE (func_name) == ADDR_EXPR)\n+\t\tif (is_sec_implicit_index_fn (func_name))\n+\t\t  {\n+\t\t    idx_value = \n+\t\t      extract_sec_implicit_index_arg (location, rhs_node);\n+\t\t    if (idx_value == -1) /* This means we have an error.  */\n+\t\t      return error_mark_node;\n+\t\t    else if (idx_value < (int) lhs_rank && idx_value >= 0)\n+\t\t      vec_safe_push (rhs_array_operand, lhs_var[idx_value]);\n+\t\t    else\n+\t\t      {\n+\t\t\tsize_t ee = 0;\n+\t\t\ttree lhs_base = (*lhs_list)[ii];\n+\t\t\tfor (ee = 0; ee < lhs_rank; ee++)\n+\t\t\t  lhs_base = ARRAY_NOTATION_ARRAY (lhs_base);\n+\t\t\terror_at (location, \"__sec_implicit_index argument %d \"\n+\t\t\t\t  \"must be less than rank of %qD\", idx_value,\n+\t\t\t\t  lhs_base);\n+\t\t\treturn error_mark_node;\n+\t\t      }\n+\t\t  }  \n+\t    }\n+\t}\n+      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n+      array_expr_rhs = rhs;\n+    }\n+  else\n+    {\n+      for (ii = 0; ii < rhs_list_size; ii++)\n+\t{\n+\t  tree rhs_node = (*rhs_list)[ii];\n+\t  if (TREE_CODE (rhs_node) == CALL_EXPR)\n+\t    {\n+\t      int idx_value = 0;\n+\t      tree func_name = CALL_EXPR_FN (rhs_node);\n+\t      if (TREE_CODE (func_name) == ADDR_EXPR)\n+\t\tif (is_sec_implicit_index_fn (func_name))\n+\t\t  {\n+\t\t    idx_value = \n+\t\t      extract_sec_implicit_index_arg (location, rhs_node);\n+\t\t    if (idx_value == -1) /* This means we have an error.  */\n+\t\t      return error_mark_node;\n+\t\t    else if (idx_value < (int) lhs_rank && idx_value >= 0)\n+\t\t      vec_safe_push (rhs_array_operand, lhs_var[idx_value]);\n+\t\t    else\n+\t\t      {\n+\t\t\tsize_t ee = 0;\n+\t\t\ttree lhs_base = (*lhs_list)[ii];\n+\t\t\tfor (ee = 0; ee < lhs_rank; ee++)\n+\t\t\t  lhs_base = ARRAY_NOTATION_ARRAY (lhs_base);\n+\t\t\terror_at (location, \"__sec_implicit_index argument %d \"\n+\t\t\t\t  \"must be less than rank of %qD\", idx_value,\n+\t\t\t\t  lhs_base);\n+\t\t\treturn error_mark_node;\n+\t\t      }\n+\t\t  }  \n+\t    }\n+\t}\n+      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n+      array_expr_rhs = rhs;\n+      rhs_expr_incr[0] = NULL_TREE;\n+    }\n+\n+  for (ii = 0; ii < rhs_rank; ii++) \n+    rhs_expr_incr[ii] = build2 (MODIFY_EXPR, void_type_node, rhs_var[ii], \n+\t\t\t\tbuild2 \n+\t\t\t\t(PLUS_EXPR, TREE_TYPE (rhs_var[ii]), \n+\t\t\t\t rhs_var[ii], \n+\t\t\t\t build_one_cst (TREE_TYPE (rhs_var[ii]))));\n+\n+  for (ii = 0; ii < lhs_rank; ii++) \n+    lhs_expr_incr[ii] = build2 \n+      (MODIFY_EXPR, void_type_node, lhs_var[ii], \n+       build2 (PLUS_EXPR, TREE_TYPE (lhs_var[ii]), lhs_var[ii], \n+\t       build_one_cst (TREE_TYPE (lhs_var[ii]))));\n+  \n+  /* If array_expr_lhs is NULL, then we have function that returns void or\n+     its return value is ignored.  */\n+  if (!array_expr_lhs)\n+    array_expr_lhs = lhs;\n+\n+  array_expr = build_modify_expr (location, array_expr_lhs, lhs_origtype, \n+\t\t\t\t  modifycode, rhs_loc, array_expr_rhs, \n+\t\t\t\t  rhs_origtype);\n+\n+  for (jj = 0; jj < MAX (lhs_rank, rhs_rank); jj++)\n+    {\n+      if (rhs_rank && rhs_expr_incr[jj])\n+\t{\n+\t  size_t iii = 0;\n+\t  if (lhs_rank == 0)\n+\t    lhs_compare[jj] = integer_one_node;\n+\t  else if (lhs_count_down[0][jj])\n+\t    lhs_compare[jj] = build2\n+\t      (GT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n+\t  else\n+\t    lhs_compare[jj] = build2\n+\t      (LT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n+\n+\n+\t  /* The reason why we have this here is for the following case:\n+\t         Array[:][:] = function_call(something) + Array2[:][:];\n+\n+\t     So, we will skip the first operand of RHS and then go to the\n+\t     2nd to find whether we should count up or down.  */\n+\t \n+\t  for (iii = 0; iii < rhs_list_size; iii++)\n+\t    if (rhs_vector[iii][jj])\n+\t      break;\n+\t      \n+\t  /* What we are doing here is this:\n+\t     We always count up, so:\n+\t       if (length is negative ==> which means we count down)\n+\t          we multiply length by -1 and count up => ii < -LENGTH\n+\t       else\n+\t          we just count up, so we compare for  ii < LENGTH\n+\t   */\n+\t  if (rhs_count_down[iii][jj])\n+\t    /* We use iii for rhs_length because that is the correct countdown\n+\t       we have to use.  */\n+\t      rhs_compare[jj] = build2\n+\t\t(LT_EXPR, boolean_type_node, rhs_var[jj],\n+\t\t build2 (MULT_EXPR, TREE_TYPE (rhs_var[jj]),\n+\t\t\t rhs_length[iii][jj],\n+\t\t\t build_int_cst (TREE_TYPE (rhs_var[jj]), -1)));\n+\t  else\n+\t    rhs_compare[jj] = build2 (LT_EXPR, boolean_type_node, rhs_var[jj],\n+\t\t\t\t      rhs_length[iii][jj]);\n+\t  if (lhs_compare[ii] != integer_one_node)\n+\t    cond_expr[jj] = build2 (TRUTH_ANDIF_EXPR, void_type_node,\n+\t\t\t\t    lhs_compare[jj], rhs_compare[jj]);\n+\t  else\n+\t    cond_expr[jj] = rhs_compare[jj];\n+\t}\n+      else\n+\t{\n+\t  if (lhs_count_down[0][jj])\n+\t    cond_expr[jj] = build2\n+\t      (GT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n+\t  else\n+\t    cond_expr[jj] = build2\n+\t      (LT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n+\t}\n+    }\n+\n+  an_init = pop_stmt_list (an_init);\n+  append_to_statement_list_force (an_init, &loop_with_init);\n+  body = array_expr;\n+  for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n+    {\n+      tree incr_list = alloc_stmt_list ();\n+      tree new_loop = push_stmt_list ();\n+      if (lhs_rank)\n+\tadd_stmt (lhs_ind_init[ii]);\n+      if (rhs_rank)\n+\tadd_stmt (rhs_ind_init[ii]);\n+      if (lhs_rank)\n+\tappend_to_statement_list_force (lhs_expr_incr[ii], &incr_list);\n+      if (rhs_rank && rhs_expr_incr[ii])\n+\tappend_to_statement_list_force (rhs_expr_incr[ii], &incr_list);\n+      c_finish_loop (location, cond_expr[ii], incr_list, body, NULL_TREE,\n+\t\t     NULL_TREE, true);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+  return loop_with_init;\n+}\n+\n+/* Helper function for fix_conditional_array_notations.  Encloses the \n+   conditional statement passed in STMT with a loop around it\n+   and replaces the condition in STMT with a ARRAY_REF tree-node to the array.\n+   The condition must have an ARRAY_NOTATION_REF tree.  An expansion of array\n+   notation in STMT is returned in a STATEMENT_LIST.  */\n+\n+static tree\n+fix_conditional_array_notations_1 (tree stmt)\n+{\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  size_t list_size = 0;\n+  tree cond = NULL_TREE, builtin_loop = NULL_TREE, new_var = NULL_TREE;\n+  size_t rank = 0, ii = 0, jj = 0;\n+  int s_jj = 0;\n+  tree **array_ops, *array_var, jj_tree, loop_init;\n+  tree **array_value, **array_stride, **array_length, **array_start;\n+  tree *compare_expr, *expr_incr, *ind_init;\n+  bool **count_down, **array_vector;\n+  tree begin_var, lngth_var, strde_var;\n+  location_t location = EXPR_LOCATION (stmt);\n+  tree body = NULL_TREE, loop_with_init = alloc_stmt_list ();\n+  if (TREE_CODE (stmt) == COND_EXPR)\n+    cond = COND_EXPR_COND (stmt);\n+  else if (TREE_CODE (stmt) == SWITCH_EXPR)\n+    cond = SWITCH_COND (stmt);\n+  else\n+    /* Otherwise dont even touch the statement.  */\n+    return stmt;\n+\n+  if (!find_rank (location, cond, cond, false, &rank))\n+    return error_mark_node;\n+  \n+  extract_array_notation_exprs (cond, false, &array_list);\n+  loop_init = push_stmt_list ();\n+  for (ii = 0; ii < vec_safe_length (array_list); ii++)\n+    { \n+      tree array_node = (*array_list)[ii];\n+      if (TREE_CODE (array_node) == CALL_EXPR)\n+\t{\n+\t  builtin_loop = fix_builtin_array_notation_fn (array_node, &new_var);\n+\t  if (builtin_loop == error_mark_node)\n+\t    {\n+\t      add_stmt (error_mark_node);\n+\t      pop_stmt_list (loop_init);\n+\t      return loop_init;\n+\t    }\n+\t  else if (builtin_loop)\n+\t    {\n+\t      vec <tree, va_gc>* sub_list = NULL, *new_var_list = NULL;\n+\t      vec_safe_push (sub_list, array_node);\n+\t      vec_safe_push (new_var_list, new_var);\n+\t      add_stmt (builtin_loop);\n+\t      replace_array_notations (&cond, false, sub_list, new_var_list); \n+\t    }\n+\t}\n+    }\n+\n+  if (!find_rank (location, cond, cond, true, &rank))\n+    {\n+      pop_stmt_list (loop_init);\n+      return error_mark_node;\n+    }\n+  if (rank == 0)\n+    {\n+      add_stmt (stmt);\n+      pop_stmt_list (loop_init); \n+      return loop_init;\n+    }  \n+  extract_array_notation_exprs (cond, true, &array_list);\n+\n+  if (vec_safe_length (array_list) == 0)\n+    return stmt;\n+\n+  list_size = vec_safe_length (array_list);\n+\n+  array_ops =  XNEWVEC (tree *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_ops[ii] =  XNEWVEC (tree, rank);\n+\n+  array_vector =  XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_vector[ii] =  XNEWVEC (bool, rank);\n+\n+  array_value = XNEWVEC (tree *, list_size);\n+  array_stride = XNEWVEC (tree *, list_size);\n+  array_length = XNEWVEC (tree *, list_size);\n+  array_start =  XNEWVEC (tree *, list_size);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      array_value[ii]  = XNEWVEC (tree, rank);\n+      array_stride[ii] = XNEWVEC (tree, rank);\n+      array_length[ii] = XNEWVEC (tree, rank);\n+      array_start[ii]  = XNEWVEC (tree, rank);\n+    }\n+\n+  compare_expr = XNEWVEC (tree, rank);\n+  expr_incr = XNEWVEC (tree, rank);\n+  ind_init = XNEWVEC (tree,  rank);\n+\n+  count_down = XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    count_down[ii] = XNEWVEC (bool, rank);\n+\n+  array_var = XNEWVEC (tree, rank);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (array_node && TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  tree array_begin = ARRAY_NOTATION_START (array_node);\n+\t  tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n+\t  tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n+\n+\t  if (TREE_CODE (array_begin) != INTEGER_CST)\n+\t    {\n+\t      begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, begin_var,\n+\t\t\t\t\t   TREE_TYPE (begin_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_begin,\n+\t\t\t\t\t   TREE_TYPE (array_begin)));\n+\t      ARRAY_NOTATION_START (array_node) = begin_var;\n+\t    }\n+\t  if (TREE_CODE (array_lngth) != INTEGER_CST)\n+\t    {\n+\t      lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, lngth_var,\n+\t\t\t\t\t   TREE_TYPE (lngth_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_lngth,\n+\t\t\t\t\t   TREE_TYPE (array_lngth)));\n+\t      ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n+\t    }\n+\t  if (TREE_CODE (array_strde) != INTEGER_CST)\n+\t    {\n+\t      strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, strde_var,\n+\t\t\t\t\t   TREE_TYPE (strde_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_strde,\n+\t\t\t\t\t   TREE_TYPE (array_strde)));\n+\t      ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n+\t    }\n+\t}\n+    }  \n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      jj = 0;\n+      for (jj_tree = array_node;\n+\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n+\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n+\t{\n+\t  array_ops[ii][jj] = jj_tree;\n+\t  jj++;\n+\t}\n+    }\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (jj = 0; jj < rank; jj++)\n+\t    {\n+\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  array_value[ii][jj] =\n+\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n+\t\t  array_start[ii][jj] =\n+\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n+\t\t  array_length[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n+\t\t  array_stride[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n+\t\t  array_vector[ii][jj] = true;\n+\n+\t\t  if (!TREE_CONSTANT (array_length[ii][jj]))\n+\t\t      count_down[ii][jj] = false;\n+\t\t  else if (tree_int_cst_lt\n+\t\t\t   (array_length[ii][jj],\n+\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n+\t\t\t\t\t   0)))\n+\t\t    count_down[ii][jj] = true;\n+\t\t  else\n+\t\t    count_down[ii][jj] = false;\n+\t\t}\n+\t      else\n+\t\tarray_vector[ii][jj] = false;\n+\t    }\n+\t}\n+    }\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+      ind_init[ii] =\n+\tbuild_modify_expr (location, array_var[ii],\n+\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+\t\t\t   location,\n+\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n+\t\t\t   TREE_TYPE (array_var[ii]));\n+    }\n+  \n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      if (array_vector[ii][0])\n+\t{\n+\t  tree array_opr = array_value[ii][rank - 1];\n+\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n+\t    {\n+\t      if (count_down[ii][s_jj])\n+\t\t/* Array[start_index - (induction_var * stride)] */\n+\t\tarray_opr = build_array_ref\n+\t\t  (location, array_opr,\n+\t\t   build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t   array_start[ii][s_jj],\n+\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n+\t      else\n+\t\t/* Array[start_index + (induction_var * stride)] */\n+\t\tarray_opr = build_array_ref\n+\t\t  (location, array_opr,\n+\t\t   build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t   array_start[ii][s_jj],\n+\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n+\t    }\n+\t  vec_safe_push (array_operand, array_opr);\n+\t}\n+      else\n+\t/* This is just a dummy node to make sure the list sizes for both\n+\t   array list and array operand list are the same.  */\n+\tvec_safe_push (array_operand, integer_one_node);\n+    }\n+  replace_array_notations (&stmt, true, array_list, array_operand);\n+  for (ii = 0; ii < rank; ii++) \n+    expr_incr[ii] = build2 (MODIFY_EXPR, void_type_node, array_var[ii], \n+\t\t\t    build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), \n+\t\t\t\t    array_var[ii], \n+\t\t\t\t    build_int_cst (TREE_TYPE (array_var[ii]), \n+\t\t\t\t\t\t   1)));\n+  for (jj = 0; jj < rank; jj++)\n+    {\n+      if (rank && expr_incr[jj])\n+\t{\n+\t  if (count_down[0][jj])\n+\t    compare_expr[jj] =\n+\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n+\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n+\t\t\t      array_length[0][jj],\n+\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n+\t  else\n+\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t       array_var[jj], array_length[0][jj]);\n+\t}\n+    }\n+\n+  loop_init = pop_stmt_list (loop_init);\n+  body = stmt;\n+  append_to_statement_list_force (loop_init, &loop_with_init);\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      add_stmt (ind_init[ii]);\n+      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n+\t\t     NULL_TREE, true);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+  XDELETEVEC (expr_incr);\n+  XDELETEVEC (ind_init);\n+  \n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      XDELETEVEC (count_down[ii]);\n+      XDELETEVEC (array_value[ii]);\n+      XDELETEVEC (array_stride[ii]);\n+      XDELETEVEC (array_length[ii]);\n+      XDELETEVEC (array_start[ii]);\n+      XDELETEVEC (array_ops[ii]);\n+      XDELETEVEC (array_vector[ii]);\n+    }\n+\n+  XDELETEVEC (count_down);\n+  XDELETEVEC (array_value);\n+  XDELETEVEC (array_stride);\n+  XDELETEVEC (array_length);\n+  XDELETEVEC (array_start);\n+  XDELETEVEC (array_ops);\n+  XDELETEVEC (array_vector);\n+\n+  return loop_with_init;\n+}\n+\n+/* Top-level function to replace ARRAY_NOTATION_REF in a conditional statement\n+   in STMT.   An expansion of array notation in STMT is returned as a \n+   STATEMENT_LIST.  */\n+\n+tree\n+fix_conditional_array_notations (tree stmt)\n+{\n+  if (TREE_CODE (stmt) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator tsi;\n+      for (tsi = tsi_start (stmt); !tsi_end_p (tsi); tsi_next (&tsi))\n+\t{\n+\t  tree single_stmt = *tsi_stmt_ptr (tsi);\n+\t  *tsi_stmt_ptr (tsi) =\n+\t    fix_conditional_array_notations_1 (single_stmt);\n+\t}\n+      return stmt;\n+    }\n+  else\n+    return fix_conditional_array_notations_1 (stmt);\n+}\n+\n+/* Create a struct c_expr that contains a loop with ARRAY_REF expr at location\n+   LOCATION with the tree_code CODE and the array notation expr is\n+   passed in ARG.  Returns the fixed c_expr in ARG itself.  */\n+\n+struct c_expr \n+fix_array_notation_expr (location_t location, enum tree_code code,\n+\t\t\t struct c_expr arg)\n+{\n+\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  size_t list_size = 0, rank = 0, ii = 0, jj = 0;\n+  int s_jj = 0;\n+  tree **array_ops, *array_var, jj_tree, loop_init;\n+  tree **array_value, **array_stride, **array_length, **array_start;\n+  tree *compare_expr, *expr_incr, *ind_init;\n+  tree body, loop_with_init = alloc_stmt_list ();\n+  bool **count_down, **array_vector;\n+  \n+  if (!find_rank (location, arg.value, arg.value, false, &rank))\n+    {\n+      /* If this function returns a NULL, we convert the tree value in the\n+\t structure to error_mark_node and the parser should take care of the\n+\t rest.  */\n+      arg.value = error_mark_node;\n+      return arg;\n+    }\n+  \n+  if (rank == 0)\n+    return arg;\n+  \n+  extract_array_notation_exprs (arg.value, true, &array_list);\n+\n+  if (vec_safe_length (array_list) == 0)\n+    return arg;\n+\n+  list_size = vec_safe_length (array_list);\n+  \n+  array_ops = XNEWVEC (tree *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_ops[ii] = XNEWVEC (tree,  rank);\n+  \n+  array_vector =  XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_vector[ii] = XNEWVEC (bool, rank);\n+\n+  array_value = XNEWVEC (tree *, list_size);\n+  array_stride = XNEWVEC (tree *, list_size);\n+  array_length = XNEWVEC (tree *, list_size);\n+  array_start = XNEWVEC (tree *, list_size);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      array_value[ii]  = XNEWVEC (tree, rank);\n+      array_stride[ii] = XNEWVEC (tree, rank);\n+      array_length[ii] = XNEWVEC (tree, rank);\n+      array_start[ii]  = XNEWVEC (tree, rank);\n+    }\n+\n+  compare_expr = XNEWVEC (tree, rank);\n+  expr_incr = XNEWVEC (tree, rank);\n+  ind_init = XNEWVEC (tree, rank);\n+  \n+  count_down = XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    count_down[ii] = XNEWVEC (bool, rank);\n+  array_var = XNEWVEC (tree, rank);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      jj = 0;\n+      for (jj_tree = (*array_list)[ii];\n+\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n+\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n+\t{\n+\t  array_ops[ii][jj] = jj_tree;\n+\t  jj++;\n+\t}\n+    }\n+  \n+  loop_init = push_stmt_list ();\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (jj = 0; jj < rank; jj++)\n+\t    {\n+\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  array_value[ii][jj] =\n+\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n+\t\t  array_start[ii][jj] =\n+\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n+\t\t  array_length[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n+\t\t  array_stride[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n+\t\t  array_vector[ii][jj] = true;\n+\n+\t\t  if (!TREE_CONSTANT (array_length[ii][jj])) \n+\t\t    count_down[ii][jj] = false;\n+\t\t  else if (tree_int_cst_lt\n+\t\t\t   (array_length[ii][jj],\n+\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n+\t\t\t\t\t   0)))\n+\t\t    count_down[ii][jj] = true;\n+\t\t  else\n+\t\t    count_down[ii][jj] = false;\n+\t\t}\n+\t      else\n+\t\tarray_vector[ii][jj] = false;\n+\t    }\n+\t}\n+    }\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+      ind_init[ii] =\n+\tbuild_modify_expr (location, array_var[ii],\n+\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+\t\t\t   location,\n+\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n+\t\t\t   TREE_TYPE (array_var[ii]));\n+\t\n+    }\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      if (array_vector[ii][0])\n+\t{\n+\t  tree array_opr = array_value[ii][rank - 1];\n+\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n+\t    {\n+\t      if (count_down[ii][s_jj])\n+\t\t/* Array[start_index - (induction_var * stride)] */\n+\t\tarray_opr = build_array_ref\n+\t\t  (location, array_opr,\n+\t\t   build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t   array_start[ii][s_jj],\n+\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n+\t      else\n+\t\t/* Array[start_index + (induction_var * stride)] */\n+\t\tarray_opr = build_array_ref\n+\t\t  (location, array_opr,\n+\t\t   build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t   array_start[ii][s_jj],\n+\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n+\t    }\n+\t  vec_safe_push (array_operand, array_opr);\n+\t}\n+      else\n+      \t/* This is just a dummy node to make sure the list sizes for both\n+\t   array list and array operand list are the same.  */\n+\tvec_safe_push (array_operand, integer_one_node);\n+    }\n+  replace_array_notations (&arg.value, true, array_list, array_operand);\n+\n+  for (ii = 0; ii < rank; ii++)\n+    expr_incr[ii] =\n+      build2 (MODIFY_EXPR, void_type_node, array_var[ii],\n+\t      build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), array_var[ii],\n+\t\t      build_int_cst (TREE_TYPE (array_var[ii]), 1)));\n+  \n+  for (jj = 0; jj < rank; jj++)\n+    {\n+      if (rank && expr_incr[jj])\n+\t{\n+\t  if (count_down[0][jj])\n+\t    compare_expr[jj] =\n+\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n+\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n+\t\t\t      array_length[0][jj],\n+\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n+\t  else\n+\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t       array_var[jj], array_length[0][jj]);\n+\t}\n+    }\n+  \n+  if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n+    {\n+      arg = default_function_array_read_conversion (location, arg);\n+      arg.value = build_unary_op (location, code, arg.value, 0);\n+    }\n+  else if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n+    {\n+      arg = default_function_array_read_conversion (location, arg);\n+      arg = parser_build_unary_op (location, code, arg);\n+    }\n+\n+  loop_init = pop_stmt_list (loop_init);\n+  append_to_statement_list_force (loop_init, &loop_with_init);\n+  body = arg.value;\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      add_stmt (ind_init[ii]);\n+      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n+\t\t     NULL_TREE, true);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+   XDELETEVEC (expr_incr);\n+  XDELETEVEC (ind_init);\n+  XDELETEVEC (array_var);\n+  \n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      XDELETEVEC (count_down[ii]);\n+      XDELETEVEC (array_value[ii]);\n+      XDELETEVEC (array_stride[ii]);\n+      XDELETEVEC (array_length[ii]);\n+      XDELETEVEC (array_start[ii]);\n+      XDELETEVEC (array_ops[ii]);\n+      XDELETEVEC (array_vector[ii]);\n+    }\n+\n+  XDELETEVEC (count_down);\n+  XDELETEVEC (array_value);\n+  XDELETEVEC (array_stride);\n+  XDELETEVEC (array_length);\n+  XDELETEVEC (array_start);\n+  XDELETEVEC (array_ops);\n+  XDELETEVEC (array_vector);\n+\n+  arg.value = loop_with_init;\n+  return arg;\n+}\n+\n+/* Returns true if EXPR or any of its subtrees contain ARRAY_NOTATION_EXPR \n+   node.  */\n+\n+bool\n+contains_array_notation_expr (tree expr)\n+{\n+  vec<tree, va_gc> *array_list = NULL;\n+\n+  if (!expr)\n+    return false;\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    if (is_cilkplus_reduce_builtin (expr))\n+      return true;\n+  \n+  extract_array_notation_exprs (expr, false, &array_list);\n+  if (vec_safe_length (array_list) == 0)\n+    return false;\n+  else\n+    return true;\n+}\n+\n+/* Replaces array notations in a void function call arguments in ARG and returns\n+   a STATEMENT_LIST.  */\n+\n+static tree\n+fix_array_notation_call_expr (tree arg)\n+{\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  tree new_var = NULL_TREE;\n+  size_t list_size = 0, rank = 0, ii = 0, jj = 0;\n+  int s_jj = 0;\n+  tree **array_ops, *array_var, jj_tree, loop_init;\n+  tree **array_value, **array_stride, **array_length, **array_start;\n+  tree body, loop_with_init = alloc_stmt_list ();\n+  tree *compare_expr, *expr_incr, *ind_init;\n+  bool **count_down, **array_vector;\n+  tree begin_var, lngth_var, strde_var;\n+  location_t location = UNKNOWN_LOCATION;\n+\n+  if (TREE_CODE (arg) == CALL_EXPR\n+      && is_cilkplus_reduce_builtin (CALL_EXPR_FN (arg)))\n+    {\n+      loop_init = fix_builtin_array_notation_fn (arg, &new_var);\n+      /* We are ignoring the new var because either the user does not want to\n+\t capture it OR he is using sec_reduce_mutating function.  */\n+      return loop_init;\n+    }\n+  \n+  if (!find_rank (location, arg, arg, false, &rank))\n+    return error_mark_node;\n+  \n+  if (rank == 0)\n+    return arg;\n+  \n+  extract_array_notation_exprs (arg, true, &array_list);\n+  if (vec_safe_length (array_list) == 0)\n+    return arg;\n+  \n+  list_size = vec_safe_length (array_list);\n+  location = EXPR_LOCATION (arg);\n+\n+  array_ops = XNEWVEC (tree *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_ops[ii] = XNEWVEC (tree, rank);\n+  \n+  array_vector = XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    array_vector[ii] = (bool *) XNEWVEC (bool, rank);\n+\n+  array_value = XNEWVEC (tree *, list_size);\n+  array_stride = XNEWVEC (tree *, list_size);\n+  array_length = XNEWVEC (tree *, list_size);\n+  array_start = XNEWVEC (tree *, list_size);\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      array_value[ii]  = XNEWVEC (tree, rank);\n+      array_stride[ii] = XNEWVEC (tree, rank);\n+      array_length[ii] = XNEWVEC (tree, rank);\n+      array_start[ii]  = XNEWVEC (tree, rank);\n+    }\n+\n+  compare_expr = XNEWVEC (tree, rank);\n+  expr_incr = XNEWVEC (tree, rank);\n+  ind_init = XNEWVEC (tree, rank);\n+  \n+  count_down =  XNEWVEC (bool *, list_size);\n+  for (ii = 0; ii < list_size; ii++)\n+    count_down[ii] = XNEWVEC (bool, rank);\n+  \n+  array_var = XNEWVEC (tree, rank);\n+  \n+  loop_init = push_stmt_list ();\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (array_node && TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  tree array_begin = ARRAY_NOTATION_START (array_node);\n+\t  tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n+\t  tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n+\n+\t  if (TREE_CODE (array_begin) != INTEGER_CST)\n+\t    {\n+\t      begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, begin_var,\n+\t\t\t\t\t   TREE_TYPE (begin_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_begin,\n+\t\t\t\t\t   TREE_TYPE (array_begin)));\n+\t      ARRAY_NOTATION_START (array_node) = begin_var;\n+\t    }\n+\t  if (TREE_CODE (array_lngth) != INTEGER_CST)\n+\t    {\n+\t      lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, lngth_var,\n+\t\t\t\t\t   TREE_TYPE (lngth_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_lngth,\n+\t\t\t\t\t   TREE_TYPE (array_lngth)));\n+\t      ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n+\t    }\n+\t  if (TREE_CODE (array_strde) != INTEGER_CST)\n+\t    {\n+\t      strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t      integer_type_node);\n+\t      add_stmt (build_modify_expr (location, strde_var,\n+\t\t\t\t\t   TREE_TYPE (strde_var),\n+\t\t\t\t\t   NOP_EXPR, location, array_strde,\n+\t\t\t\t\t   TREE_TYPE (array_strde)));\n+\t      ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n+\t    }\n+\t}\n+    }\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      jj = 0;\n+      for (jj_tree = (*array_list)[ii];\n+\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n+\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n+\t{\n+\t  array_ops[ii][jj] = jj_tree;\n+\t  jj++;\n+\t}\n+    }\n+\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n+\t{\n+\t  for (jj = 0; jj < rank; jj++)\n+\t    {\n+\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n+\t\t{\n+\t\t  array_value[ii][jj] =\n+\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n+\t\t  array_start[ii][jj] =\n+\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n+\t\t  array_length[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n+\t\t  array_stride[ii][jj] =\n+\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n+\t\t  array_vector[ii][jj] = true;\n+\n+\t\t  if (!TREE_CONSTANT (array_length[ii][jj])) \n+\t\t    count_down[ii][jj] = false;\n+\t\t  else if (tree_int_cst_lt\n+\t\t\t   (array_length[ii][jj],\n+\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n+\t\t\t\t\t   0)))\n+\t\t    count_down[ii][jj] = true;\n+\t\t  else\n+\t\t    count_down[ii][jj] = false;\n+\t\t}\n+\t      else\n+\t\tarray_vector[ii][jj] = false;\n+\t    }\n+\t}\n+    }\n+\n+  if (length_mismatch_in_expr_p (location, array_length, list_size, rank))\n+    {\n+      pop_stmt_list (loop_init);\n+      return error_mark_node;\n+    }\n+  \n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  integer_type_node);\n+      ind_init[ii] =\n+\tbuild_modify_expr (location, array_var[ii],\n+\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+\t\t\t   location,\n+\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n+\t\t\t   TREE_TYPE (array_var[ii]));\n+\t\n+    }\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      if (array_vector[ii][0])\n+\t{\n+\t  tree array_opr_node = array_value[ii][rank - 1];\n+\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n+\t    {\n+\t      if (count_down[ii][s_jj])\n+\t\t/* Array[start_index - (induction_var * stride)] */\n+\t\tarray_opr_node = build_array_ref\n+\t\t  (location, array_opr_node,\n+\t\t   build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t   array_start[ii][s_jj],\n+\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n+\t      else\n+\t\t/* Array[start_index + (induction_var * stride)] */\n+\t\tarray_opr_node = build_array_ref\n+\t\t  (location, array_opr_node,\n+\t\t   build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t   array_start[ii][s_jj],\n+\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n+\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n+\t    }\n+\t  vec_safe_push (array_operand, array_opr_node);\n+\t}\n+      else\n+\t/* This is just a dummy node to make sure the list sizes for both\n+\t   array list and array operand list are the same.  */\n+\tvec_safe_push (array_operand, integer_one_node);\n+    }\n+  replace_array_notations (&arg, true, array_list, array_operand);\n+  for (ii = 0; ii < rank; ii++) \n+    expr_incr[ii] = \n+      build2 (MODIFY_EXPR, void_type_node, array_var[ii], \n+\t      build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), array_var[ii], \n+\t\t      build_int_cst (TREE_TYPE (array_var[ii]), 1)));\n+  \n+  for (jj = 0; jj < rank; jj++)\n+    {\n+      if (rank && expr_incr[jj])\n+\t{\n+\t  if (count_down[0][jj])\n+\t    compare_expr[jj] =\n+\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n+\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n+\t\t\t      array_length[0][jj],\n+\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n+\t  else\n+\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t       array_var[jj], array_length[0][jj]);\n+\t}\n+    }\n+\n+  loop_init = pop_stmt_list (loop_init);\n+  append_to_statement_list_force (loop_init, &loop_with_init);\n+  body = arg;\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      add_stmt (ind_init[ii]);\n+      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n+\t\t     NULL_TREE, true);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+  XDELETEVEC (compare_expr);\n+  XDELETEVEC (expr_incr);\n+  XDELETEVEC (ind_init);\n+  XDELETEVEC (array_var);\n+  \n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      XDELETEVEC (count_down[ii]);\n+      XDELETEVEC (array_value[ii]);\n+      XDELETEVEC (array_stride[ii]);\n+      XDELETEVEC (array_length[ii]);\n+      XDELETEVEC (array_start[ii]);\n+      XDELETEVEC (array_ops[ii]);\n+      XDELETEVEC (array_vector[ii]);\n+    }\n+\n+  XDELETEVEC (count_down);\n+  XDELETEVEC (array_value);\n+  XDELETEVEC (array_stride);\n+  XDELETEVEC (array_length);\n+  XDELETEVEC (array_start);\n+  XDELETEVEC (array_ops);\n+  XDELETEVEC (array_vector);\n+  \n+  return loop_with_init;\n+}\n+\n+/* Expands the built-in functions in a return.  EXPR is a RETURN_EXPR with\n+   a built-in reduction function.  This function returns the expansion code for\n+   the built-in function.  */\n+\n+static tree\n+fix_return_expr (tree expr)\n+{\n+  tree new_mod_list, new_var, new_mod, retval_expr, retval_type;\n+  location_t loc = EXPR_LOCATION (expr);\n+\n+  new_mod_list = alloc_stmt_list ();\n+  retval_expr = TREE_OPERAND (expr, 0);\n+  retval_type = TREE_TYPE (TREE_OPERAND (retval_expr, 1));\n+  new_var = build_decl (loc, VAR_DECL, NULL_TREE, TREE_TYPE (retval_expr));\n+  new_mod = build_array_notation_expr (loc, new_var, TREE_TYPE (new_var),\n+\t\t\t\t       NOP_EXPR, loc,\n+\t\t\t\t       TREE_OPERAND (retval_expr, 1),\n+\t\t\t\t       retval_type);\n+  TREE_OPERAND (retval_expr, 1) = new_var;\n+  TREE_OPERAND (expr, 0) = retval_expr;\n+  append_to_statement_list_force (new_mod, &new_mod_list);\n+  append_to_statement_list_force (expr, &new_mod_list);\n+  return new_mod_list;\n+}\n+\n+/* Walks through tree node T and find all the call-statements that do not return\n+   anything and fix up any array notations they may carry.  The return value\n+   is the same type as T but with all array notations replaced with appropriate\n+   STATEMENT_LISTS.  */\n+\n+tree\n+expand_array_notation_exprs (tree t)\n+{\n+  if (!contains_array_notation_expr (t))\n+    return t;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case BIND_EXPR:\n+      t = expand_array_notation_exprs (BIND_EXPR_BODY (t));\n+      return t;\n+    case COND_EXPR:\n+      t = fix_conditional_array_notations (t);\n+\n+      /* After the expansion if they are still a COND_EXPR, we go into its\n+\t subtrees.  */\n+      if (TREE_CODE (t) == COND_EXPR)\n+\t{\n+\t  if (COND_EXPR_THEN (t))\n+\t    COND_EXPR_THEN (t) =\n+\t      expand_array_notation_exprs (COND_EXPR_THEN (t));\n+\t  if (COND_EXPR_ELSE (t))\n+\t    COND_EXPR_ELSE (t) =\n+\t      expand_array_notation_exprs (COND_EXPR_ELSE (t));\n+\t}\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator ii_tsi;\n+\tfor (ii_tsi = tsi_start (t); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n+\t  *tsi_stmt_ptr (ii_tsi) = \n+\t    expand_array_notation_exprs (*tsi_stmt_ptr (ii_tsi));\n+      }\n+      return t;\n+    case CALL_EXPR:\n+      t = fix_array_notation_call_expr (t);\n+      return t;\n+    case RETURN_EXPR:\n+      if (contains_array_notation_expr (t))\n+\tt = fix_return_expr (t);\n+    default:\n+      return t;\n+    }\n+  return t;\n+}\n+\n+/* This handles expression of the form \"a[i:j:k]\" or \"a[:]\" or \"a[i:j],\" which\n+   denotes an array notation expression.  If a is a variable or a member, then\n+   we generate a ARRAY_NOTATION_REF front-end tree and return it.\n+   This tree is broken down to ARRAY_REF toward the end of parsing.\n+   ARRAY_NOTATION_REF tree holds the START_INDEX, LENGTH, STRIDE and the TYPE\n+   of ARRAY_REF.  Restrictions on START_INDEX, LENGTH and STRIDE is same as that\n+   of the index field passed into ARRAY_REF.  The only additional restriction\n+   is that, unlike index in ARRAY_REF, stride, length and start_index cannot\n+   contain ARRAY_NOTATIONS.   */\n+\n+tree\n+build_array_notation_ref (location_t loc, tree array, tree start_index, \n+\t\t\t  tree length, tree stride, tree type)\n+{\n+  tree array_ntn_tree = NULL_TREE;\n+  size_t stride_rank = 0, length_rank = 0, start_rank = 0;\n+  \n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (start_index)))\n+    {\n+      error_at (loc,\n+\t\t\"start-index of array notation triplet is not an integer\");\n+      return error_mark_node;\n+    }\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (length)))\n+    {\n+      error_at (loc, \"length of array notation triplet is not an integer\");\n+      return error_mark_node;\n+    }\n+\n+  /* The stride is an optional field.  */\n+  if (stride && !INTEGRAL_TYPE_P (TREE_TYPE (stride)))\n+    {\n+      error_at (loc, \"stride of array notation triplet is not an integer\");\n+      return error_mark_node;\n+    }  \n+  if (!stride)\n+    {\n+      if (TREE_CONSTANT (start_index) && TREE_CONSTANT (length) \n+\t  && tree_int_cst_lt (length, start_index))\n+\tstride = build_int_cst (TREE_TYPE (start_index), -1);\n+      else\n+\tstride = build_int_cst (TREE_TYPE (start_index), 1);\n+    }\t      \n+\n+  if (!find_rank (loc, start_index, start_index, false, &start_rank))\n+    return error_mark_node;\n+  if (!find_rank (loc, length, length, false, &length_rank))\n+    return error_mark_node;\n+  if (!find_rank (loc, stride, stride, false, &stride_rank))\n+    return error_mark_node;\n+\n+  if (start_rank != 0)\n+    {\n+      error_at (loc, \"rank of an array notation triplet's start-index is not \"\n+\t\t\"zero\");\n+      return error_mark_node;\n+    }\n+  if (length_rank != 0)\n+    {\n+      error_at (loc, \"rank of an array notation triplet's length is not zero\");\n+      return error_mark_node;\n+    }\n+  if (stride_rank != 0)\n+    {\n+      error_at (loc, \"rank of array notation triplet's stride is not zero\");\n+      return error_mark_node;\n+    }  \n+  array_ntn_tree = build4 (ARRAY_NOTATION_REF, NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+  ARRAY_NOTATION_ARRAY (array_ntn_tree) = array;\n+  ARRAY_NOTATION_START (array_ntn_tree) = start_index;\n+  ARRAY_NOTATION_LENGTH (array_ntn_tree) = length;\n+  ARRAY_NOTATION_STRIDE (array_ntn_tree) = stride;\n+  TREE_TYPE (array_ntn_tree) = type;\n+  \n+  return array_ntn_tree;\n+}\n+\n+/* This function will check if OP is a CALL_EXPR that is a built-in array \n+   notation function.  If so, then we will return its type to be the type of\n+   the array notation inside.  */\n+\n+tree\n+find_correct_array_notation_type (tree op)\n+{\n+  tree fn_arg, return_type = NULL_TREE;\n+\n+  if (op)\n+    {\n+      return_type = TREE_TYPE (op); /* This is the default case.  */\n+      if (TREE_CODE (op) == CALL_EXPR) \n+\tif (is_cilkplus_reduce_builtin (CALL_EXPR_FN (op))) \n+\t  { \n+\t    fn_arg = CALL_EXPR_ARG (op, 0); \n+\t    if (fn_arg) \n+\t      return_type = TREE_TYPE (fn_arg); \n+\t  }\n+    } \n+  return return_type;\n+}"}, {"sha": "b89d8c1ff17fe04ed52bee3b6514b26d23453c50", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 308, "deletions": 19, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1216,6 +1216,8 @@ static void c_parser_objc_at_dynamic_declaration (c_parser *);\n static bool c_parser_objc_diagnose_bad_element_prefix\n   (c_parser *, struct c_declspecs *);\n \n+static tree c_parser_array_notation (location_t, c_parser *, tree, tree);\n+\n /* Parse a translation unit (C90 6.7, C99 6.9).\n \n    translation-unit:\n@@ -3067,6 +3069,15 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t      dimen = NULL_TREE;\n \t      star_seen = false;\n \t    }\n+\t  else if (flag_enable_cilkplus\n+\t\t   && c_parser_next_token_is (parser, CPP_COLON))\n+\t    {\n+\t      dimen = error_mark_node;\n+\t      star_seen = false;\n+\t      error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\"array notations cannot be used in declaration\");\n+\t      c_parser_consume_token (parser);\n+\t    }   \n \t  else if (c_parser_next_token_is (parser, CPP_MULT))\n \t    {\n \t      if (c_parser_peek_2nd_token (parser)->type == CPP_CLOSE_SQUARE)\n@@ -3089,6 +3100,14 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t}\n       if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \tc_parser_consume_token (parser);\n+      else if (flag_enable_cilkplus\n+\t       && c_parser_next_token_is (parser, CPP_COLON))\n+\t{\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"array notations cannot be used in declaration\");\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+\t  return NULL;\n+\t}\n       else\n \t{\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n@@ -4071,6 +4090,10 @@ c_parser_compound_statement (c_parser *parser)\n     }\n   stmt = c_begin_compound_stmt (true);\n   c_parser_compound_statement_nostart (parser);\n+\n+  /* If the compound stmt contains array notations, then we expand them.  */\n+  if (flag_enable_cilkplus && contains_array_notation_expr (stmt))\n+    stmt = expand_array_notation_exprs (stmt);\n   return c_end_compound_stmt (brace_loc, stmt, true);\n }\n \n@@ -4714,6 +4737,7 @@ c_parser_if_statement (c_parser *parser)\n   bool first_if = false;\n   tree first_body, second_body;\n   bool in_if_block;\n+  tree if_stmt;\n \n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_IF));\n   c_parser_consume_token (parser);\n@@ -4732,7 +4756,12 @@ c_parser_if_statement (c_parser *parser)\n   else\n     second_body = NULL_TREE;\n   c_finish_if_stmt (loc, cond, first_body, second_body, first_if);\n-  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n+  if_stmt = c_end_compound_stmt (loc, block, flag_isoc99);\n+\n+  /* If the if statement contains array notations, then we expand them.  */\n+  if (flag_enable_cilkplus && contains_array_notation_expr (if_stmt))\n+    if_stmt = fix_conditional_array_notations (if_stmt);\n+  add_stmt (if_stmt);\n }\n \n /* Parse a switch statement (C90 6.6.4, C99 6.8.4).\n@@ -4754,6 +4783,13 @@ c_parser_switch_statement (c_parser *parser)\n     {\n       switch_cond_loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_expression (parser).value;\n+      if (flag_enable_cilkplus && contains_array_notation_expr (expr))\n+\t{\n+\t  error_at (switch_cond_loc,\n+\t\t    \"array notations cannot be used as a condition for switch \"\n+\t\t    \"statement\");\n+\t  expr = error_mark_node;\n+\t}\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   else\n@@ -4793,6 +4829,12 @@ c_parser_while_statement (c_parser *parser)\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_paren_condition (parser);\n+  if (flag_enable_cilkplus && contains_array_notation_expr (cond))\n+    {\n+      error_at (loc, \"array notations cannot be used as a condition for while \"\n+\t\t\"statement\");\n+      cond = error_mark_node;\n+    }\n   save_break = c_break_label;\n   c_break_label = NULL_TREE;\n   save_cont = c_cont_label;\n@@ -4834,6 +4876,13 @@ c_parser_do_statement (c_parser *parser)\n   new_cont = c_cont_label;\n   c_cont_label = save_cont;\n   cond = c_parser_paren_condition (parser);\n+  if (flag_enable_cilkplus && contains_array_notation_expr (cond))\n+    {\n+      error_at (loc, \"array notations cannot be used as a condition for a \"\n+\t\t\"do-while statement\");\n+      cond = error_mark_node;\n+    }\n+\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n   c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);\n@@ -5009,7 +5058,14 @@ c_parser_for_statement (c_parser *parser)\n \t  else\n \t    {\n \t      cond = c_parser_condition (parser);\n-\t      c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t      if (flag_enable_cilkplus && contains_array_notation_expr (cond))\n+\t\t{\n+\t\t  error_at (loc, \"array notations cannot be used in a \"\n+\t\t\t    \"condition for a for-loop\");\n+\t\t  cond = error_mark_node;\n+\t\t}\n+\t      c_parser_skip_until_found (parser, CPP_SEMICOLON,\n+\t\t\t\t\t \"expected %<;%>\");\n \t    }\n \t}\n       /* Parse the increment expression (the third expression in a\n@@ -5388,9 +5444,21 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n   exp_location = c_parser_peek_token (parser)->location;\n   rhs = c_parser_expr_no_commas (parser, NULL);\n   rhs = default_function_array_read_conversion (exp_location, rhs);\n-  ret.value = build_modify_expr (op_location, lhs.value, lhs.original_type,\n-\t\t\t\t code, exp_location, rhs.value,\n-\t\t\t\t rhs.original_type);\n+  \n+  /* The line below is where the statement has the form:\n+     A = B, where A and B contain array notation exprs. So this is where\n+     we handle those.  */\n+  if (flag_enable_cilkplus\n+      && (contains_array_notation_expr (lhs.value)\n+\t  || contains_array_notation_expr (rhs.value)))\n+    ret.value = build_array_notation_expr (op_location, lhs.value,\n+\t\t\t\t\t   lhs.original_type, code,\n+\t\t\t\t\t   exp_location, rhs.value,\n+\t\t\t\t\t   rhs.original_type);\n+  else\n+    ret.value = build_modify_expr (op_location, lhs.value, lhs.original_type,\n+\t\t\t\t   code, exp_location, rhs.value,\n+\t\t\t\t   rhs.original_type);\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n   else\n@@ -5870,14 +5938,28 @@ c_parser_unary_expression (c_parser *parser)\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n-      return parser_build_unary_op (op_loc, PREINCREMENT_EXPR, op);\n+\n+      /* If there is array notations in op, we expand them.  */\n+      if (flag_enable_cilkplus && TREE_CODE (op.value) == ARRAY_NOTATION_REF)\n+\treturn fix_array_notation_expr (exp_loc, PREINCREMENT_EXPR, op);\n+      else\n+\t{\n+\t  op = default_function_array_read_conversion (exp_loc, op);\n+\t  return parser_build_unary_op (op_loc, PREINCREMENT_EXPR, op);\n+\t}\n     case CPP_MINUS_MINUS:\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_read_conversion (exp_loc, op);\n-      return parser_build_unary_op (op_loc, PREDECREMENT_EXPR, op);\n+      \n+      /* If there is array notations in op, we expand them.  */\n+      if (flag_enable_cilkplus && TREE_CODE (op.value) == ARRAY_NOTATION_REF)\n+\treturn fix_array_notation_expr (exp_loc, PREDECREMENT_EXPR, op);\n+      else\n+\t{\n+\t  op = default_function_array_read_conversion (exp_loc, op);\n+\t  return parser_build_unary_op (op_loc, PREDECREMENT_EXPR, op);\n+\t}\n     case CPP_AND:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n@@ -6880,10 +6962,36 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_OPEN_SQUARE:\n \t  /* Array reference.  */\n \t  c_parser_consume_token (parser);\n-\t  idx = c_parser_expression (parser).value;\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n-\t\t\t\t     \"expected %<]%>\");\n-\t  expr.value = build_array_ref (op_loc, expr.value, idx);\n+\t  if (flag_enable_cilkplus\n+\t      && c_parser_peek_token (parser)->type == CPP_COLON)\n+\t    /* If we are here, then we have something like this:\n+\t       Array [ : ]\n+\t    */\n+\t    expr.value = c_parser_array_notation (expr_loc, parser, NULL_TREE,\n+\t\t\t\t\t\t  expr.value);\n+\t  else\n+\t    {\t      \n+\t      idx = c_parser_expression (parser).value;\n+\t      /* Here we have 3 options:\n+\t\t 1. Array [EXPR] -- Normal Array call.\n+\t\t 2. Array [EXPR : EXPR] -- Array notation without stride.\n+\t\t 3. Array [EXPR : EXPR : EXPR] -- Array notation with stride.\n+\n+\t\t For 1, we just handle it just like a normal array expression.\n+\t\t For 2 and 3 we handle it like we handle array notations.  The\n+\t\t idx value we have above becomes the initial/start index.\n+\t      */\n+\t      if (flag_enable_cilkplus\n+\t\t  && c_parser_peek_token (parser)->type == CPP_COLON)\n+\t\texpr.value = c_parser_array_notation (expr_loc, parser, idx, \n+\t\t\t\t\t\t      expr.value);\n+\t      else\n+\t\t{\n+\t\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n+\t\t\t\t\t     \"expected %<]%>\");\n+\t\t  expr.value = build_array_ref (op_loc, expr.value, idx);\n+\t\t}\n+\t    }\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n@@ -6991,18 +7099,32 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_read_conversion (expr_loc, expr);\n-\t  expr.value = build_unary_op (op_loc,\n-\t\t\t\t       POSTINCREMENT_EXPR, expr.value, 0);\n+\t  /* If the expressions have array notations, we expand them.  */\n+\t  if (flag_enable_cilkplus\n+\t      && TREE_CODE (expr.value) == ARRAY_NOTATION_REF)\n+\t    expr = fix_array_notation_expr (expr_loc, POSTINCREMENT_EXPR, expr);\n+\t  else\n+\t    {\n+\t      expr = default_function_array_read_conversion (expr_loc, expr);\n+\t      expr.value = build_unary_op (op_loc,\n+\t\t\t\t\t   POSTINCREMENT_EXPR, expr.value, 0);\n+\t    }\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_read_conversion (expr_loc, expr);\n-\t  expr.value = build_unary_op (op_loc,\n-\t\t\t\t       POSTDECREMENT_EXPR, expr.value, 0);\n+\t  /* If the expressions have array notations, we expand them.  */\n+\t  if (flag_enable_cilkplus\n+\t      && TREE_CODE (expr.value) == ARRAY_NOTATION_REF)\n+\t    expr = fix_array_notation_expr (expr_loc, POSTDECREMENT_EXPR, expr);\n+\t  else\n+\t    {\n+\t      expr = default_function_array_read_conversion (expr_loc, expr);\n+\t      expr.value = build_unary_op (op_loc,\n+\t\t\t\t\t   POSTDECREMENT_EXPR, expr.value, 0);\n+\t    }\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n@@ -10888,4 +11010,171 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n+/* This function parses Cilk Plus array notation.  The starting index is\n+   passed in INITIAL_INDEX and the array name is passes in ARRAY_VALUE.  The\n+   return value of this function is a tree_node called VALUE_TREE of type\n+   ARRAY_NOTATION_REF.  */\n+\n+static tree \n+c_parser_array_notation (location_t loc, c_parser *parser, tree initial_index, \n+\t\t\t tree array_value)\n+{\n+  c_token *token = NULL;\n+  tree start_index = NULL_TREE, end_index = NULL_TREE, stride = NULL_TREE;\n+  tree value_tree = NULL_TREE, type = NULL_TREE, array_type = NULL_TREE;\n+  tree array_type_domain = NULL_TREE; \n+\n+  if (array_value == error_mark_node)\n+    {\n+      /* No need to continue.  If either of these 2 were true, then an error\n+\t must be emitted already.  Thus, no need to emit them twice.  */\n+      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+      return error_mark_node;\n+    }\n+  \n+  array_type = TREE_TYPE (array_value);\n+  gcc_assert (array_type);\n+  type = TREE_TYPE (array_type);\n+  token = c_parser_peek_token (parser);\n+   \n+  if (token->type == CPP_EOF)\n+    {\n+      c_parser_error (parser, \"expected %<:%> or numeral\");\n+      return value_tree;\n+    }\n+  else if (token->type == CPP_COLON)\n+    {\n+      if (!initial_index)\n+\t{\n+\t  /* If we are here, then we have a case like this A[:].  */\n+\t  c_parser_consume_token (parser);\n+\t  if (TREE_CODE (array_type) == POINTER_TYPE)\n+\t    {\n+\t      error_at (loc, \"start-index and length fields necessary for \"\n+\t\t\t\"using array notations in pointers\");\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+\t      return error_mark_node;\n+\t    }\n+\t  if (TREE_CODE (array_type) == FUNCTION_TYPE)\n+\t    {\n+\t      error_at (loc, \"array notations cannot be used with function \"\n+\t\t\t\"type\");\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+\t      return error_mark_node;\n+\t    }\n+\t  if (TREE_CODE (array_type) == ARRAY_TYPE)\n+\t    {\n+\t      tree subtype = TREE_TYPE (array_type);\n+\t      while (subtype && TREE_CODE (subtype) == POINTER_TYPE)\n+\t\t{\n+\t\t  /* Now this could be a function pointer.  Find them and\n+\t\t     give out an error.  */\n+\t\t  subtype = TREE_TYPE (subtype);\n+\t\t  if (subtype && TREE_CODE (subtype) == FUNCTION_TYPE)\n+\t\t    {\n+\t\t      error_at (loc, \"array notations cannot be used with \"\n+\t\t\t\t\"function pointer arrays\");\n+\t\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n+\t\t\t\t\t\t NULL);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  array_type_domain = TYPE_DOMAIN (array_type);\n+\n+\t  if (!array_type_domain)\n+\t    {\n+\t      error_at (loc, \"start-index and length fields necessary for \"\n+\t\t\t\"using array notations in dimensionless arrays\");\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  start_index = TYPE_MINVAL (array_type_domain);\n+\t  start_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node,\n+\t\t\t\t     start_index);\n+\t  if (!TYPE_MAXVAL (array_type_domain)\n+\t      || !TREE_CONSTANT (TYPE_MAXVAL (array_type_domain)))\n+\t    {\n+\t      error_at (loc, \"start-index and length fields necessary for \"\n+\t\t\t\"using array notations in variable-length arrays\");\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+\t      return error_mark_node;\n+\t    }\n+\t  end_index = TYPE_MAXVAL (array_type_domain);\n+\t  end_index = fold_build2 (PLUS_EXPR, TREE_TYPE (end_index),\n+\t\t\t\t   end_index, integer_one_node);\n+\t  end_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node, end_index);\n+\t  stride = build_int_cst (integer_type_node, 1);\n+\t  stride = fold_build1 (CONVERT_EXPR, ptrdiff_type_node, stride);\n+\t}\n+      else if (initial_index != error_mark_node)\n+\t{\n+\t  /* If we are here, then there should be 2 possibilities:\n+\t     1. Array [EXPR : EXPR]\n+\t     2. Array [EXPR : EXPR : EXPR]\n+\t  */\n+\t  start_index = initial_index;\n+\n+\t  if (TREE_CODE (array_type) == FUNCTION_TYPE)\n+\t    {\n+\t      error_at (loc, \"array notations cannot be used with function \"\n+\t\t\t\"type\");\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n+\t      return error_mark_node;\n+\t    }\n+\t  if (TREE_CODE (array_type) == ARRAY_TYPE\n+\t      || TREE_CODE (array_type) == POINTER_TYPE)\n+\t    {\n+\t      tree subtype = TREE_TYPE (array_type);\n+\t      while (subtype\n+\t\t     && (TREE_CODE (subtype) == POINTER_TYPE\n+\t\t\t || TREE_CODE (subtype) == ARRAY_TYPE))\n+\t\t{\n+\t\t  /* Now this could be a function pointer.  Find them and\n+\t\t     give out an error.  */\n+\t\t  subtype = TREE_TYPE (subtype);\n+\t\t  if (subtype && TREE_CODE (subtype) == FUNCTION_TYPE)\n+\t\t    {\n+\t\t      error_at (loc, \"array notations cannot be used with \"\n+\t\t\t\t\"function pointer arrays\");\n+\t\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n+\t\t\t\t\t\t NULL);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  c_parser_consume_token (parser); /* consume the ':' */\n+\t  end_index = c_parser_expression (parser).value;\n+\t  if (!end_index || end_index == error_mark_node)\n+\t    {\n+\t      c_parser_skip_to_end_of_block_or_statement (parser);\n+\t      return error_mark_node;\n+\t    }\n+\t  if (c_parser_peek_token (parser)->type == CPP_COLON)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      stride = c_parser_expression (parser).value;\n+\t      if (!stride || stride == error_mark_node)\n+\t\t{\n+\t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tc_parser_error (parser, \"expected array notation expression\");\n+    }\n+  else\n+    c_parser_error (parser, \"expected array notation expression\");\n+  \n+  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+\n+  value_tree = build_array_notation_ref (loc, array_value, start_index,\n+\t\t\t\t\t end_index, stride, type);\n+  if (value_tree != error_mark_node)\n+    SET_EXPR_LOCATION (value_tree, loc);\n+  return value_tree;\n+}\n+\n #include \"gt-c-c-parser.h\""}, {"sha": "c8f673710e64732bbfea814070893133bff734ba", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -668,4 +668,7 @@ extern void c_write_global_declarations (void);\n extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);\n extern void pedwarn_c99 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);\n \n+/* In c-array-notation.c */\n+enum built_in_function is_cilkplus_reduce_builtin (tree);\n+\n #endif /* ! GCC_C_TREE_H */"}, {"sha": "749c8e2b8e92117774a42c094cfafc86a3cb2c95", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -2304,6 +2304,17 @@ build_array_ref (location_t loc, tree array, tree index)\n       || TREE_TYPE (index) == error_mark_node)\n     return error_mark_node;\n \n+  if (flag_enable_cilkplus && contains_array_notation_expr (index))\n+    {\n+      size_t rank = 0;\n+      if (!find_rank (loc, index, index, true, &rank))\n+\treturn error_mark_node;\n+      if (rank > 1)\n+\t{\n+\t  error_at (loc, \"rank of the array's index is greater than 1\");\n+\t  return error_mark_node;\n+\t}\n+    }\n   if (TREE_CODE (TREE_TYPE (array)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (array)) != POINTER_TYPE\n       /* Allow vector[index] but not index[vector].  */\n@@ -2722,6 +2733,10 @@ build_function_call_vec (location_t loc, tree function,\n \t often rewritten and don't match the original parameter list.  */\n       if (name && !strncmp (IDENTIFIER_POINTER (name), \"__atomic_\", 9))\n         origtypes = NULL;\n+\n+      if (flag_enable_cilkplus\n+\t  && is_cilkplus_reduce_builtin (function))\n+\torigtypes = NULL;\n     }\n   if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n     function = function_to_pointer_conversion (loc, function);\n@@ -2944,6 +2959,17 @@ convert_arguments (tree typelist, vec<tree, va_gc> *values,\n       bool npc;\n       tree parmval;\n \n+      // FIXME: I assume this code is here to handle the overloaded\n+      // behavior of the __sec_reduce* builtins, and avoid giving\n+      // argument mismatch warnings/errors.  We should probably handle\n+      // this with the resolve_overloaded_builtin infrastructure.\n+      /* If the function call is a builtin function call, then we do not\n+\t worry about it since we break them up into its equivalent later and\n+\t we do the appropriate checks there.  */\n+      if (flag_enable_cilkplus\n+\t  && is_cilkplus_reduce_builtin (fundecl))\n+\tcontinue;\n+      \n       if (type == void_type_node)\n \t{\n \t  if (selector)\n@@ -3181,10 +3207,16 @@ convert_arguments (tree typelist, vec<tree, va_gc> *values,\n \n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n-      error_at (input_location,\n-\t\t\"too few arguments to function %qE\", function);\n-      inform_declaration (fundecl);\n-      return -1;\n+      /* If array notation is used and Cilk Plus is enabled, then we do not\n+\t worry about this error now.  We will handle them in a later place.  */\n+      if (!flag_enable_cilkplus\n+\t  || !is_cilkplus_reduce_builtin (fundecl))\n+\t{\n+\t  error_at (input_location,\n+\t\t    \"too few arguments to function %qE\", function);\n+\t  inform_declaration (fundecl);\n+\t  return -1;\n+\t}\n     }\n \n   return error_args ? -1 : (int) parmnum;\n@@ -3875,6 +3907,7 @@ lvalue_p (const_tree ref)\n \n     case INDIRECT_REF:\n     case ARRAY_REF:\n+    case ARRAY_NOTATION_REF:\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n@@ -8640,11 +8673,25 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl)), ret_stmt;\n   bool no_warning = false;\n   bool npc = false;\n+  size_t rank = 0;\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n     warning_at (loc, 0,\n \t\t\"function declared %<noreturn%> has a %<return%> statement\");\n \n+  if (flag_enable_cilkplus && contains_array_notation_expr (retval))\n+    {\n+      /* Array notations are allowed in a return statement if it is inside a\n+\t built-in array notation reduction function.  */\n+      if (!find_rank (loc, retval, retval, false, &rank))\n+\treturn error_mark_node;\n+      if (rank >= 1)\n+\t{\n+\t  error_at (loc, \"array notation expression cannot be used as a \"\n+\t\t    \"return value\");\n+\t  return error_mark_node;\n+\t}\n+    }\n   if (retval)\n     {\n       tree semantic_type = NULL_TREE;\n@@ -8987,6 +9034,13 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n {\n   tree entry = NULL, exit = NULL, t;\n \n+  if (flag_enable_cilkplus && contains_array_notation_expr (cond))\n+    {\n+      error_at (start_locus, \"array notation expression cannot be used in a \"\n+\t\t\"loop%'s condition\");\n+      return;\n+    }\n+  \n   /* If the condition is zero don't generate a loop construct.  */\n   if (cond && integer_zerop (cond))\n     {\n@@ -9493,8 +9547,18 @@ build_binary_op (location_t location, enum tree_code code,\n       op1 = default_conversion (op1);\n     }\n \n-  orig_type0 = type0 = TREE_TYPE (op0);\n-  orig_type1 = type1 = TREE_TYPE (op1);\n+  /* When Cilk Plus is enabled and there are array notations inside op0, then\n+     we check to see if there are builtin array notation functions.  If\n+     so, then we take on the type of the array notation inside it.  */\n+  if (flag_enable_cilkplus && contains_array_notation_expr (op0)) \n+    orig_type0 = type0 = find_correct_array_notation_type (op0);\n+  else\n+    orig_type0 = type0 = TREE_TYPE (op0);\n+\n+  if (flag_enable_cilkplus && contains_array_notation_expr (op1))\n+    orig_type1 = type1 = find_correct_array_notation_type (op1);\n+  else \n+    orig_type1 = type1 = TREE_TYPE (op1);\n \n   /* The expression codes of the data types of the arguments tell us\n      whether the arguments are integers, floating, pointers, etc.  */"}, {"sha": "cb3824f4ee6355bd444bd8818380a11456eccee1", "filename": "gcc/cilkplus.def", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fcilkplus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fcilkplus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilkplus.def?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,59 @@\n+/* This file contains the definitions and documentation for the\n+   CilkPlus builtins used in the GNU compiler.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Before including this file, you should define a macro:\n+\n+     DEF_CILKPLUS_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n+\n+   See builtins.def for details.  */\n+\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ADD,\n+\t\t      \"__sec_reduce_add\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MUL,\n+\t\t      \"__sec_reduce_mul\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO,\n+\t\t      \"__sec_reduce_all_zero\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO,\n+\t\t      \"__sec_reduce_any_zero\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MAX,\n+\t\t      \"__sec_reduce_max\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MIN,\n+\t\t      \"__sec_reduce_min\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND,\n+\t\t      \"__sec_reduce_min_ind\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND,\n+\t\t      \"__sec_reduce_max_ind\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO,\n+\t\t      \"__sec_reduce_any_nonzero\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO,\n+\t\t      \"__sec_reduce_all_nonzero\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE,\n+\t\t      \"__sec_reduce\", BT_FN_INT_PTR_PTR_PTR, ATTR_NULL)\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING,\n+\t\t      \"__sec_reduce_mutating\", BT_FN_INT_PTR_PTR_PTR, ATTR_NULL)\n+// FIXME: This probably needs to be rewritten as a keyword.\n+DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_IMPLICIT_INDEX,\n+\t\t      \"__sec_implicit_index\", BT_FN_INT_INT, ATTR_NULL)\n+\n+/*\n+Local variables:\n+mode:c\n+End:\n+*/"}, {"sha": "c71924ba6dd104121921d042f4deb7d5b11a27b5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -82,6 +82,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * x86 specific memory model extensions for transactional memory:: x86 memory models.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n+* Cilk Plus Builtins::  Built-in functions for the Cilk Plus language extension.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n * Target Format Checks:: Format checks specific to particular targets.\n@@ -8788,6 +8789,32 @@ Similar to @code{__builtin_bswap32}, except the argument and return types\n are 64 bit.\n @end deftypefn\n \n+@node Cilk Plus Builtins\n+@section Cilk Plus C/C++ language extension Built-in Functions.\n+\n+GCC provides support for the following built-in reduction funtions if Cilk Plus\n+is enabled. Cilk Plus can be enabled using the @option{-fcilkplus} flag.\n+\n+@itemize @bullet\n+@item __sec_implicit_index\n+@item __sec_reduce\n+@item __sec_reduce_add\n+@item __sec_reduce_all_nonzero\n+@item __sec_reduce_all_zero\n+@item __sec_reduce_any_nonzero\n+@item __sec_reduce_any_zero\n+@item __sec_reduce_max\n+@item __sec_reduce_min\n+@item __sec_reduce_max_ind\n+@item __sec_reduce_min_ind\n+@item __sec_reduce_mul\n+@item __sec_reduce_mutating\n+@end itemize\n+\n+Further details and examples about these built-in functions are described \n+in the Cilk Plus language manual which can be found at \n+@uref{http://www.cilkplus.org}.\n+\n @node Target Builtins\n @section Built-in Functions Specific to Particular Target Machines\n "}, {"sha": "06c55fe4808650455bc1c60a5796bd34cadb36b8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1799,6 +1799,17 @@ Program Interface v3.0 @w{@uref{http://www.openmp.org/}}.  This option\n implies @option{-pthread}, and thus is only supported on targets that\n have support for @option{-pthread}.\n \n+@item -fcilkplus\n+@opindex fcilkplus\n+@cindex Enable Cilk Plus\n+Enable the usage of Cilk Language extension features for C/C++.  When the flag\n+@option{-fcilkplus} is specified, all the Cilk Plus components are converted \n+to the appropriate C/C++ code.  The present implementation follows ABI version \n+0.9.  There are four major parts to Cilk Plus language \n+extension: Array Notations, Cilk Keywords, SIMD annotations and elemental \n+functions.  Detailed information about Cilk Plus can be found at \n+@w{@uref{http://www.cilkplus.org}}. \n+\n @item -fgnu-tm\n @opindex fgnu-tm\n When the option @option{-fgnu-tm} is specified, the compiler"}, {"sha": "045f964a939d91b8dbeb25f2d92fad61a107440c", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -17,6 +17,7 @@ where near complete.\n \n @menu\n * Parsing pass::         The language front end turns text into bits.\n+* Cilk Plus Transformation:: Transform Cilk Plus Code to equivalent C/C++.\n * Gimplification pass::  The bits are turned into something we can optimize.\n * Pass manager::         Sequencing the optimization passes.\n * Tree SSA passes::      Optimizations on a high-level representation.\n@@ -101,6 +102,36 @@ that is more descriptive than \"rest_of\".\n The middle-end will, at its option, emit the function and data\n definitions immediately or queue them for later processing.\n \n+@node Cilk Plus Transformation\n+@section Cilk Plus Transformation\n+@cindex CILK_PLUS\n+\n+If Cilk Plus generation (flag @option{-fcilkplus}) is enabled, all the Cilk \n+Plus code is transformed into equivalent C and C++ functions.  Majority of this \n+transformation occurs toward the end of the parsing and right before the \n+gimplification pass.  \n+\n+These are the major components to the Cilk Plus language extension:\n+@itemize @bullet\n+@item Array Notations:\n+During parsing phase, all the array notation specific information is stored in \n+@code{ARRAY_NOTATION_REF} tree using the function \n+@code{c_parser_array_notation}.  During the end of parsing, we check the entire\n+function to see if there are any array notation specific code (using the \n+function @code{contains_array_notation_expr}).  If this function returns \n+true, then we expand them using either @code{expand_array_notation_exprs} or\n+@code{build_array_notation_expr}.  For the cases where array notations are \n+inside conditions, they are transformed using the function \n+@code{fix_conditional_array_notations}.  The C language-specific routines are \n+located in @file{c/c-array-notation.c} and the equivalent C++ routines are in \n+file @file{cp/cp-array-notation.c}.  Common routines such as functions to \n+initialize builtin functions are stored in @file{array-notation-common.c}.\n+@end itemize\n+\n+Detailed information about Cilk Plus and language specification is provided in \n+@w{@uref{http://www.cilkplus.org/}}.  It is worth mentioning that the current \n+implementation follows ABI 0.9.\n+\n @node Gimplification pass\n @section Gimplification pass\n "}, {"sha": "869371a1edd88b4d9288cb89db2c3b2caf8d5da8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -1,3 +1,45 @@\n+2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-c++-common/cilk-plus/AN/array_test1.c: New test.\n+\t* c-c++-common/cilk-plus/AN/array_test2.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/array_test_ND.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/builtin_func_double.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/builtin_func_double2.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/gather-scatter-errors.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/if_test.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/sec_implicit_ex.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/decl-ptr-colon.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/dimensionless-arrays.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/fn_ptr.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/fp_triplet_values.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/gather-scatter.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/misc.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors2.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors3.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors4.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch2.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch3.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/sec_implicit.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/sec_implicit2.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/sec_reduce_max_min_ind.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/tst_lngth.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/vla.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/an-if.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/builtin_fn_custom.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/builtin_fn_mutating.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/comma_exp.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/conditional.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/exec-once.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/exec-once2.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/gather_scatter.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/n-ptr-test.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/side-effects-1.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/test_builtin_return.c: Likewise.\n+\t* c-c++-common/cilk-plus/AN/test_sec_limits.c: Likewise.\n+\t* gcc.dg/cilk-plus/cilk-plus.exp: New script.\n+\n 2013-05-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37336"}, {"sha": "4bf85b5ca9393f500051082b4518ffbc6daee10b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/an-if.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fan-if.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fan-if.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fan-if.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+#include <assert.h>\n+\n+const int n = 8;\n+\n+float x[8], y[8], z[8];\n+\n+int main() {\n+    int i = 0;\n+    float x_sum =0;\n+    for(i=1; i<=5; i+=4 ) {\n+        x[0:n] = 3;\n+        y[0:n] = i;\n+        z[0:n] = 0;\n+#if HAVE_IO\n+        printf(\"x\\ty\\tz\\n\");\n+        for( size_t k=0; k<n; ++k ) {\n+            printf(\"%g\\t%g\\t%g\\n\",x[k],y[k],z[k]);\n+        }\n+\tx_sum = __sec_reduce_add (x[0:n]);\n+\tprintf(\"sec_reduce_add (x[0:n]) = %6.3f\\n\", x_sum);\n+#endif\n+        assert( __sec_reduce_add(x[0:n])==3*n );\n+        assert( __sec_reduce_add(y[0:n])==i*n );\n+        assert( __sec_reduce_add(z[0:n])==0 );\n+\n+        if (x[0:n] >= y[0:n]) {  \n+            z[0:n] = x[0:n] - y[0:n];\n+        } else {   \n+            z[0:n] = x[0:n] + y[0:n];\n+        }\n+#if HAVE_IO\n+        printf(\"x\\ty\\tz\\n\");\n+        for( size_t k=0; k<n; ++k ) {\n+            printf(\"%g\\t%g\\t%g\\n\",x[k],y[k],z[k]);\n+        }\n+#endif\n+        assert( __sec_reduce_add(x[0:n])==3*n );\n+        assert( __sec_reduce_add(y[0:n])==i*n );\n+        assert( __sec_reduce_add(z[0:n])==(3>=i?3-i:3+i)*n );\n+    }\n+    return 0;\n+}"}, {"sha": "bdd271a77300648e709f56df717ffd7c7881591b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/array_test1.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test1.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <stdlib.h>\n+\n+int main2 (int argc, char **argv);\n+\n+int main(int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\t     \n+      x = main2 (2, (char **)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+      \n+  return x;\n+}\n+\n+int main2 (int argc, char **argv)\n+{\n+  int array[10], ii = 0, x = 2, z= 0 , y = 0 ;\n+  for (ii = 0; ii < 10; ii++)\n+    array[ii] = 10;\n+\n+  array[0:10:1] = 15;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array[ii] != 15)\n+      return 5;\n+  array[0:5:2] = 20;\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    if (array[ii] != 20)\n+      return 4;\n+\n+\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+\n+  array[x:5:z] = 50;\n+  \n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != 50)\n+      return 3;\n+\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+  \n+  array[x:y:z] = 505;\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != 505)\n+      return 2;\n+    \n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+  \n+  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = 25;\n+\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != 25)\n+      return 1;\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+ \n+  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n+    1400;\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != 1400)\n+      return 1;\n+  \n+\n+  array[atoi(\"5\"):5:1] = 5555;\n+  \n+  for (ii = atoi (\"5\"); ii < 10; ii++)\n+    if (array[ii] != 5555)\n+      return 2;\n+  \n+\n+  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = 9999;\n+  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n+    if (array[ii] != 9999)\n+      return 3;\n+  return 0;\n+}"}, {"sha": "bd7a4ad2b62e687d750e9b48952af6340c4abbd9", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/array_test2.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test2.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,134 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <stdlib.h>\n+int main2(int argc, char **argv);\n+int main(int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\t     \n+      x = main2 (2, (char **)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+      \n+  return x;\n+}\n+\n+\n+int main2(int argc, char **argv)\n+{\n+  int array[10], array2[10], ii = 0, x = 2, z= 0 , y = 0 ;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 10;\n+      array2[ii] = 5000000;\n+    }\n+\n+  array2[0:10:1] = array[0:10:1];\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array2[ii] != array[ii])\n+      return 1;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 10;\n+      array2[ii] = 5000000;\n+    }\n+  \n+  array2[0:5:2] = array[0:5:2];\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    if (array[ii] != array2[ii])\n+      return 2;\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 10;\n+      array2[ii] = 5000000;\n+    }\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+ \n+  array2[x:5:z] = array[x:5:z];\n+\n+  for (ii = x; ii < 5; ii += z)\n+    if (array2[ii] != array[ii])\n+      return 3;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 500;\n+      array2[ii] = 1000000;\n+    }\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+\n+  array2[x:y:z] = array[x:y:z];\n+  for (ii = x; ii < 10; ii = ii + z)\n+    if (array2[ii] != array[ii])\n+      return 4;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 500;\n+      array2[ii] = 1000000;\n+    }\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+\n+  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = \n+    array2[x:y:((10-atoi(argv[1]))/atoi(argv[1]))];\n+\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != array2[ii])\n+      return 5;\n+  \n+  \n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 500;\n+      array2[ii] = 1000000;\n+    }\n+  \n+  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n+    array2[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))];\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != array2[ii])\n+      return 6;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 4;\n+      array2[ii] = 2;\n+    }\n+\n+  array[atoi(\"5\"):5:1] = array2[atoi(\"5\"):5:1];\n+\n+  for (ii = atoi (\"5\"); ii < 10; ii++)\n+    if (array[ii] != array2[ii])\n+      return (7);\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 5;\n+      array2[ii] = 1;\n+    }\n+  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = array2[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")];\n+\n+  for (ii = 5; ii < 10; ii++)\n+    if (array2[ii] != array[ii])\n+      return 8;\n+ \n+  return 0;\n+}"}, {"sha": "1431c22b261e3c22fe2f20dc8924a6c04b9e315a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/array_test_ND.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test_ND.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test_ND.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test_ND.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <stdlib.h>\n+int main2(int argc, char **argv);\n+int main(int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"10\", \"15\"};\t     \n+      x = main2 (3, (char **)array);\n+    }\n+  else if (argc == 3)\n+    x = main2 (argc, argv);\n+  else\n+    return 1;\n+      \n+  return x;\n+}\n+\n+int main2(int argc, char **argv)\n+{  \n+  int array[10][15], ii = 0, jj = 0,x = 0, z= 1 , y = 10 ;\n+  int array_2[10][15];\n+ \n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  array_2[0:5:2][0:5:3] = array[0:5:2][0:5:3] + 1 + 5 + array[0][5] + x;\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    {\n+      for (jj = 0; jj < 15; jj += 3)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + 1 + 5 + array[0][5] + x)\n+\t    return 2;\n+\t}\n+    }\n+\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  x = atoi(argv[1]);\n+  y = atoi(argv[2]);\n+  array_2[0:x:1][0:y:1] = array[0:x:1][0:y:1] + x + y + array[0:x:1][0:y:1];\n+\n+  for (ii = 0; ii < x; ii++)\n+    {\n+      for (jj = 0; jj < y; jj++)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + x + y + array[ii][jj])\n+\t    return 3;\n+\t}\n+    }\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  x = atoi(argv[1]);\n+  y = atoi(argv[2]);\n+  z = (20- atoi (argv[1]))/atoi(argv[1]);\n+  /* (20-10)/10 evaluates to 1 all the time :-). */\n+  array_2[0:x:z][0:y:z] = array[0:x:z][0:y:z] + array[0:x:z][0:y:z] + y + z;\n+  \n+  for (ii = 0; ii < x; ii += z)\n+    {\n+      for (jj = 0; jj < y; jj += z)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] + y + z)\n+\t    return 4;\n+\t}\n+    }\n+\n+\n+ \n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  x = argc-3;\n+  y = 20-atoi(argv[1]);\n+  z = (20- atoi (argv[1]))/atoi(argv[1]);\n+  /* (20-10)/10 evaluates to 1 all the time :-). */\n+  array_2[(argc-3):(20-atoi(argv[1])):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): ((30-atoi(argv[2]))/atoi(argv[2]))] = array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] + array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] * array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])];\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      for (jj = 0; jj < 15; jj++)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] * array[ii][jj])\n+\t    return 5;\n+\t}\n+    }\n+  return 0;\n+}"}, {"sha": "8bdf1fd3ca114dcfb09f63441c1565451e55ccd6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_fn_custom.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+/* #include <stdlib.h> */\n+\n+double my_func (double x, double y)\n+{\n+  if (x > y)\n+    return x;\n+  else\n+    return y;\n+}\n+\n+\n+/* char __sec_reduce_add (int *); */\n+int main(int argc, char **argv)\n+{\n+  int ii,array[10], y = 0, y_int = 0, array2[10];\n+  double x, yy, array3[10], array4[10];\n+  double max_value = 0.000, min_value = 0.000, add_value, mul_value = 1.00;\n+  int max_index = 0, min_index = 0;\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 1+ii;\n+      array2[ii]= 2; \n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (ii%2 && ii)\n+\tarray3[ii] = (double)(1.0000/(double)ii);\n+      else\n+\tarray3[ii] = (double) ii + 0.10;\n+      array4[ii] = (double) (1.00000/ (double)(ii+1));\n+    }\n+\n+  /* array[:] = 5; */\n+  x = __sec_reduce (0, array3[:] * array4[:], my_func); \n+  y = __sec_reduce_max_ind ( array3[:] * array4[:]);\n+\n+  /* Initialize it to the first variable.  */\n+  max_value = array3[0] * array4[0];\n+  for (ii = 0; ii < 10; ii++)\n+    if (array3[ii] * array4[ii] > max_value) {\n+      max_value = array3[ii] * array4[ii];\n+      max_index = ii;\n+    }\n+    \n+  \n+  \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) \n+    printf(\"%5.3f \", array3[ii] * array4[ii]);\n+  printf(\"\\n\");\n+  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", x, y);\n+#endif\n+\n+  if (x != max_value)\n+    return 1;\n+\n+  if (y != max_index)\n+    return 2;\n+\n+  return 0;\n+}"}, {"sha": "34cbd2c4cc3cc1ca629196a9680ea623b231059d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_fn_mutating.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+/* #include <stdlib.h> */\n+\n+void my_func (double *x, double y)\n+{\n+  if (*x < y)\n+    *x = y;\n+}\n+\n+\n+int main(int argc, char **argv)\n+{\n+  int ii,array[10], y = 0, y_int = 0, array2[10];\n+  double x = 0.000, yy, array3[10], array4[10];\n+  double max_value = 0.000, min_value = 0.000, add_value, mul_value = 1.00;\n+  int max_index = 0, min_index = 0;\n+#if 1\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 1+ii;\n+      array2[ii]= 2; \n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (ii%2 && ii)\n+\tarray3[ii] = (double)(1.0000/(double)ii);\n+      else\n+\tarray3[ii] = (double) ii + 0.10;\n+      array4[ii] = (double) (1.00000/ (double)(ii+1));\n+    }\n+#endif \n+  /* array[:] = 5; */\n+  __sec_reduce_mutating (&x, array3[:] * array4[:], my_func); \n+#if  1\n+  y = __sec_reduce_max_ind ( array3[:] * array4[:]);\n+\n+  /* Initialize it to the first variable.  */\n+  max_value = array3[0] * array4[0];\n+  for (ii = 0; ii < 10; ii++)\n+    if (array3[ii] * array4[ii] > max_value) {\n+      max_value = array3[ii] * array4[ii];\n+      max_index = ii;\n+    }\n+    \n+  \n+  \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) \n+    printf(\"%5.3f \", array3[ii] * array4[ii]);\n+  printf(\"\\n\");\n+  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", x, y);\n+  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", max_value, max_index);\n+#endif\n+\n+  if (x != max_value)\n+    return 1;\n+\n+  if (y != max_index)\n+    return 2;\n+#endif\n+  return 0;\n+}"}, {"sha": "c6b518e622986e552d585517f4650d458e93e31e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_func_double.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,124 @@\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+/* #include <stdlib.h> */\n+\n+/* char __sec_reduce_add (int *); */\n+int main(int argc, char **argv)\n+{\n+  int ii,array[10], y = 0, y_int = 0, array2[10];\n+  double x, yy, array3[10], array4[10];\n+  double max_value = 0.000, min_value = 0.000, add_value, mul_value = 1.00;\n+  int max_index = 0, min_index = 0;\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 1+ii;\n+      array2[ii]= 2; \n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (ii%2 && ii)\n+\tarray3[ii] = (double)(1.0000/(double)ii);\n+      else\n+\tarray3[ii] = (double) ii + 0.10;\n+      array4[ii] = (double) (1.00000/ (double)(ii+1));\n+    }\n+\n+  /* array[:] = 5; */\n+  x = __sec_reduce_max (array3[:] * array4[:]); \n+  y = __sec_reduce_max_ind ( array3[:] * array4[:]);\n+\n+  /* Initialize it to the first variable.  */\n+  max_value = array3[0] * array4[0];\n+  for (ii = 0; ii < 10; ii++)\n+    if (array3[ii] * array4[ii] > max_value) {\n+      max_value = array3[ii] * array4[ii];\n+      max_index = ii;\n+    }\n+    \n+  \n+  \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) \n+    printf(\"%5.3f \", array3[ii] * array4[ii]);\n+  printf(\"\\n\");\n+  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", x, y);\n+#endif\n+\n+  if (x != max_value)\n+    return 1;\n+\n+  if (y != max_index)\n+    return 2;\n+\n+  x = __sec_reduce_min (array3[:] * array4[:]); \n+  y = __sec_reduce_min_ind ( array3[:] * array4[:]); \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) \n+    printf(\"%5.3f \", array3[ii] * array4[ii]);\n+  printf(\"\\n\");\n+  printf(\"Min = %5.3f\\t Min Index = %2d\\n\", x, y);\n+#endif\n+\n+  /* Initialize it to the first variable.  */\n+  min_value = array3[0] * array4[0];\n+  for (ii = 0; ii < 10; ii++)\n+    if (array3[ii] * array4[ii] < min_value) {\n+      min_value = array3[ii] * array4[ii];\n+      min_index = ii;\n+    }\n+\n+  if (x != min_value)\n+    return 3;\n+  if (y != min_index)\n+    return 4;\n+\n+  x = __sec_reduce_add (array3[:] * array4[:]); \n+  yy = __sec_reduce_mul ( array3[:] * array4[:]); \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) \n+    printf(\"%5.3f \", array3[ii] * array4[ii]);\n+  printf(\"\\n\");\n+  printf(\"Add = %5.3f\\t Mul = %f\\n\", x, yy);\n+#endif\n+\n+   /* Initialize it to the first variable.  */\n+  add_value = 0.0000;\n+  mul_value = 1.0000;\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      add_value += (array3[ii] * array4[ii]);\n+      mul_value *= (array3[ii] * array4[ii]);\n+    }\n+\n+  if (x != add_value)\n+    return 5;\n+  if (yy != mul_value)\n+    return 6;\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (ii%2 && ii)\n+\tarray3[ii] = (double)(1.0000/(double)ii);\n+      else\n+\tarray3[ii] = (double) ii + 0.00;\n+      array4[ii] = (double) (1.00000/ (double)(ii+1));\n+    }\n+  y_int = __sec_reduce_any_zero (array3[:] * array4[:]); \n+  y = __sec_reduce_all_zero ( array3[:] * array4[:]);\n+\n+  if (y_int != 1)\n+    return 7;\n+\n+  if (y != 0)\n+    return 8;\n+  \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) \n+    printf(\"%5.3f \", array3[ii] * array4[ii]);\n+  printf(\"\\n\");\n+  printf(\"Any Zeros = %d\\t All Zeros = %d\\n\", y_int, y);\n+#endif\n+  return 0;\n+}"}, {"sha": "c8a3ed7880f475235a62817b6f757210b2be0cc1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_func_double2.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double2.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int main(int argc, char **argv)\n+{\n+  int ii,array[10], y = 0, y_int = 0, array2[10], y_int2=0, y2=0;\n+  double x, yy, array3[10], array4[10];\n+  int all_zero, all_nonzero, any_zero, any_nonzero;\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 0;\n+      array2[ii] = 5;\n+      if (ii%2 && ii)\n+\tarray3[ii] = (double)(1.0000/(double)ii);\n+      else\n+\tarray3[ii] = (double) ii + 0.00;\n+      array4[ii] = (double) (1.00000/ (double)(ii+1));\n+    }\n+  y_int = __sec_reduce_any_nonzero (array3[:] + array[4]); \n+  y_int2 = __sec_reduce_any_zero (array3[:] + array[4]); \n+  y = __sec_reduce_all_nonzero ((array3[:] + array4[:]) * (argc-1)); \n+  y2 = __sec_reduce_all_zero ((array3[:] + array4[:]) * (argc-1));\n+\n+  any_zero = 0;\n+  any_nonzero = 0;\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if ((array3[ii] + array[4]) == 0)\n+\tany_zero = 1;\n+      else\n+\tany_nonzero = 1;\n+    }\n+\n+  if (any_nonzero != y_int)\n+    return 1;\n+  if (any_zero != y_int2)\n+    return 2;\n+\n+\n+  all_zero = 0;\n+  all_nonzero = 0;\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (((array3[ii] + array4[ii]) * (argc-1)) == 0)\n+\tall_zero = 1;\n+      else\n+\tall_nonzero = 1;\n+    }\n+\n+  if (y != all_nonzero)\n+    return 3;\n+  if (all_zero != y2)\n+    return 4;\n+ \n+\n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) {\n+    printf(\"%5.3f \", array3[ii] +array4[ii]);\n+  }\n+  printf(\"\\n\");\n+  for (ii = 0; ii < 10; ii++) {\n+    printf(\"%5.3f \", (array3[ii] + array4[ii]) * (argc-1));\n+  }\n+  printf(\"\\n\");\n+  printf(\"Any Non-zeros (1st line) = %d\\t All non-zeros (1st line) = %d\\n\", \n+\t y_int, y);\n+  printf(\"Any zeros (2nd line) = %d\\t All zeros (2nd line) = %d\\n\", y_int2, y2);\n+#endif\n+  return 0;\n+}"}, {"sha": "bcb3e1b161285d26b8121e0628b0b71b6dd241f5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/comma_exp.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fcomma_exp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fcomma_exp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fcomma_exp.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <stdlib.h>\n+\n+int main2 (int argc, char **argv);\n+int main(int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\t     \n+      x = main2 (2, (char **)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+      \n+  return x;\n+}\n+\n+int main2 (int argc, char **argv)\n+{\n+  int array[10], array2[10], ii = 0, x = 2, z= 0 , y = 0 ;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    array[ii] = 10;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    array2[ii] = 1;\n+\n+  array[0:10:1] = (array[:], 15);\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array[ii] != 15)\n+      return 1;\n+  array[0:5:2] = (argc+2, 20);\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    if (array[ii] != 20)\n+      return 2;\n+\n+\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+\n+  array[x:5:z] = 50;\n+\n+  array[:]  = (atoi(argv[1]), (array2[0:10]+5));\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array[ii] != 6)\n+      return (3);\n+\n+  array[:] = (atoi(argv[1]), (array2[0:10]+array2[0:10]));\n+  for (ii = 0; ii < 10; ii++)\n+    if (array[ii] != 2)\n+      return 4;\n+  \n+  return 0;\n+}"}, {"sha": "0be99b2102bcb4534282234d8c532c036de32f1a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/conditional.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fconditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fconditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fconditional.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <stdlib.h>\n+int main(int argc, char **argv)\n+{\n+  short array[1000], array2[1000], *array3, cond[1000], ii = 0;\n+\n+  for (ii = 0; ii < 1000; ii++) {\n+    cond[ii] = 1;\n+    array[ii] = 1000;\n+    array2[ii] = 2000;\n+  }\n+  array2[:] = cond[:] ?  array[:] : array2[:];\n+ \n+  for (ii = 0; ii < 1000; ii++) {\n+   if (array2[ii] != 1000)\n+     return 1;\n+  }\n+\n+  array2[0:500:2] = cond[0:500] ? array[0:500:1] : array2[0:500:2];\n+\n+  for (ii = 0; ii < 1000; ii++) {\n+   if (array2[ii] != 1000)\n+     return 2;\n+  }\n+\n+  for (ii = 0; ii < 1000; ii++) {\n+    cond[ii] = ii % 2; /* This should give 0, 1, 0, 1, 0, 1, 0,... */\n+    array2[ii] = 5;\n+    array[ii] = 3; \n+  }\n+  array3 = (short *) malloc (sizeof (short) * 1000);\n+  array3[0:1000:argc] = cond[:] ? array[0:(argc * 1000)] : array2[argc-1:1000];\n+  \n+  for (ii = 0; ii < 1000; ii++) {\n+    if ((cond[ii] == 0 && array3[ii] != 5) \n+        || (cond[ii] == 1 && array3[ii] != 3))\n+     return 3;\n+  }\n+  return 0;\n+}"}, {"sha": "68c88590da2ae564480429c12b4c7fb2b9d37780", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/decl-ptr-colon.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main(void)\n+{\n+  extern int func(int);\n+  int array3[:], x, q; /* { dg-error \"array notations cannot be used in declaration\" } */\n+  int  array3[1:2:x]; /* { dg-error \"array notations cannot be used in declaration\" } */\n+  extern char array3[1:func(x)]; /* { dg-error \"array notations cannot be used in declaration\" } */\n+  int *a, ***b;\n+  extern char *c;\n+  int array2[10];\n+\n+  a[:] = 5; /* { dg-error  \"start-index and length fields necessary for using array notations in pointers\" } */\n+  c[1:2] =  3; /* This is OK.  */\n+  (array2)[:] = 5; /* This is OK.  */\n+  b[1:2][1:func(x)][:] = 3; /*  { dg-error  \"start-index and length fields necessary for using array notations in pointers\" }  */\n+}\n+"}, {"sha": "69aaa523727ee0306ce9c370c0a04b58192344ec", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/dimensionless-arrays.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-fcilkplus\" } */\n+\n+extern int a[];\n+extern int *b;\n+\n+void foo()\n+{\n+  a[:] = 5;\t// { dg-error \"start-index and length fields necessary for using array notations in dimensionless arrays\" }\n+  b[:] = 5;    // { dg-error \"start-index and length fields necessary for using array notations in pointers\" }\n+}"}, {"sha": "4b2a09f48b082ac5b00f0276c38883ac0adf6f07", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/exec-once.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#define NUMBER 1000\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int func (int *x)\n+{\n+  int q = *x;\n+   q++;\n+   *x = q;\n+#if HAVE_IO\n+   printf(\"%d\\n\", (q));\n+#endif\n+   return *x;\n+}\n+int main (int argc, char **argv)\n+{\n+  char array[NUMBER], array2[NUMBER];\n+  int ii, d = 2;\n+#if 1\n+  for (ii = 0; ii < NUMBER; ii++)  {\n+   array[ii] = 5;\n+   array2[ii]= 2;\n+  }\n+#endif\n+  d = func (&d);    /* d = 1 */\n+  array2[:] = d * array[:] + (char) func (&d); /* 3 * 5 + 4 */\n+#if HAVE_IO\n+  for (ii = 0; ii < NUMBER; ii++)\n+    printf(\"array2[%d] = %d\\n\", ii, array2[ii]);\n+#endif  \n+  for (ii = 0; ii < NUMBER; ii++)\n+    if (array2[ii] !=  (3 * 5 + 4))\n+      return 1;\n+  \n+  return 0;\n+}\n+  \n+\n+"}, {"sha": "8d208b92c8fe6296f52a0c614e58044e28d6094b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/exec-once2.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once2.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#ifdef HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+\n+int func1(int x)\n+{\n+  /* If x == 2 then it should return 0.  */\n+  return (x - 2);\n+}\n+\n+int func2(int x)\n+{\n+  /* If x == 2 then it should return 1000.  */\n+  return (x * 500);\n+}\n+\n+int func3 (int x)\n+{\n+  /* If x == 2 then it should return 1.  */\n+  /* If x == 1 then it should return 0.  */\n+  return (x-1);\n+}\n+\n+int func4(int x)\n+{\n+  if (x > 0) \n+    return x;\n+  else \n+    return x--;\n+}\n+\n+\n+/* This program makes an assumption that argc == 1.  */\n+int main (int argc, char **argv)\n+{\n+\n+  int array[2500];\n+\n+  /* This should set array[0->999] to 5.  */\n+  array[argc-1:func2(++argc):1] = 5;\n+  array[1000:500:1] = 10; /* set all variables in array[1000-->1499] to 10.  */\n+  array[1500:500:1] = 15; /* set all variables in array[1500-->1999] to 15.  */\n+  array[2000:500:1] = 20; /* set all variables in array[2000-->2499] to 20.  */\n+  array[2000:500:1] = 25; /* set all variables in array[2500-->2999] to 25.  */\n+  array[2000:500:1] = 30; /* set all variables in array[3000-->3499] to 30.  */\n+  \n+  argc = func3 (argc); /* This will set argc back to 1.  */\n+#if HAVE_IO\n+  printf(\"argc = %d\\n\", argc);\n+#endif\n+  /* If the parameters inside the function get evaluated only once, then this\n+     if statement must work fine, i.e. the triplet values will be 0, 1000, 1.\n+\n+     Otherwise, the program should crash or give some uneasy value.  */\n+\n+  /* If done correctly, it should boil down to: array[0:1000:1].  */\n+  if (array[func3(argc):func2(++argc)] != 5) {\n+#ifdef HAVE_IO\n+    printf (\"Should not be there(1).\\n\");\n+#endif\n+    return 1;\n+  }\n+  \n+  /* If done correctly, it should boil down to: array[999:500:-1].  */\n+  if (func4(array[func2(argc)-1:func2(argc--):func1(argc)]) != 5) {\n+#ifdef HAVE_IO\n+    printf (\"Should not be there(2).\\n\");\n+#endif\n+    return 2;\n+  }\n+\n+  /* If done correctly, it should boil down to: array[1000:500:1].  */\n+  if (func4 (func4(array[func2(argc++):500: func1(argc--)])) != 5) {\n+#ifdef HAVE_IO\n+    printf (\"Should not be there(3).\\n\");\n+#endif\n+    return 3;\n+  }\n+\n+  return 0;\n+}"}, {"sha": "1010920b3aac18ff09e62f864f1a87a180a79896", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/fn_ptr.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-fcilkplus\" } */\n+\n+typedef int (*foo)(int);\n+\n+int main(int argc, char **argv)\n+{\n+  int array[10], array2[10][10];\n+  foo func_array[10];\n+  foo func_array2[10][10];\n+  foo ***func_array_ptr;\n+\n+  array[:] =  func_array[:](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n+  func_array[0:5](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n+  func_array2[0:5][:](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n+  array2[0:5][:] = func_array2[0:5][:](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n+  func_array_ptr[0:5][0:4][0:argc:2](argc); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n+\n+  return 0;\n+}"}, {"sha": "cb504f309ed96f269953a527ac707869a9aed131", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/fp_triplet_values.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffp_triplet_values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffp_triplet_values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffp_triplet_values.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+float q;\n+\n+int main2 (int argc, char **argv);\n+int main (int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\n+      x = main2 (2, (char **)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+\n+  return x;\n+}\n+\n+void func (int *x)\n+{\n+  *x = 5;\n+}\n+\n+int main2 (int argc, char **argv)\n+{\n+  int array[10], array2[10];\n+  array2[:] = array[1.5:2]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n+  array2[:] = array[1:2.32333333333]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[1:2:1.5] = array[:]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n+  func (&array2[1:2.34:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[1.43:9]++; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n+  array2[1:9.3]++; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[1:9:0.3]++; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n+  \n+  ++array2[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[:] = array[q:1:3]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n+  array2[:] = array[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[:] = array[1:3:q]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n+  func (&array2[1:q:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  return 0;\n+} "}, {"sha": "f4283dbf11fed1dba609707ad588522e875f5cd6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/gather-scatter-errors.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather-scatter-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather-scatter-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather-scatter-errors.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  extern int func (int);\n+  int array[10][10], array2[10];\n+\n+  array2[array[:][:]] = 5; /* { dg-error \"rank of the array's index is greater than 1\" } */\n+\n+  array2[array[:][:]] = 5; /* { dg-error \"rank of the array's index is greater than 1\" } */\n+  func (array2[array[:][:]]); /* { dg-error \"rank of the array's index is greater than 1\" } */\n+  func (array2[array[argc:func(5)][0:10:2]]); /* { dg-error \"rank of the array's index is greater than 1\" } */\n+  \n+  array[array2[:]][array2[:]] = 5; /* This is OK.  */\n+  array[array2[:]][array2[:]] = array2[array[:][:]]; /* { dg-error \"rank of the array's index is greater than 1\" }  */\n+  array[array2[:]][array2[:]] = array2[array[0:10:1][:]]; /* { dg-error \"rank of the array's index is greater than 1\" }  */\n+  array[array2[:]][array2[:]] = array2[array[:][argc:func (argc)]]; /* { dg-error \"rank of the array's index is greater than 1\" }  */\n+  return 0;\n+}"}, {"sha": "67e1c19d6cce34a1d911b6c5a146bfc1b45c60ca", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/gather_scatter.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather_scatter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather_scatter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather_scatter.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int main(int argc, char **argv)\n+{\n+  int array[10][10], array2[10], array3[10], x = 0, y;\n+  int x_correct, y_correct, ii, jj = 0;\n+  float array4[10][10][10][10];\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      for (jj = 0; jj < 10; jj++)\n+\t{\n+\t  array[ii][jj] = 1+ii;\n+\t  array2[ii]= 2;\n+\t  array3[ii]= 3;\n+\t}\n+    }\n+  \n+  array[array2[:]][array3[:]] = 1000;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array[array2[ii]][array3[ii]] != 1000)\n+      return 1;\n+  \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj < 10; jj++) {\n+      printf(\"%4d\\t\", array[ii][jj]);\n+    }\n+    printf(\"\\n\");\n+  }\n+#endif\n+\n+  array4[array2[:]][array3[0:10:1]][array2[0:10:1]][array3[0:10:1]] =\n+    (float)array[array2[:]][array3[:]]; \n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array4[array2[ii]][array3[ii]][array2[ii]][array3[ii]] !=\n+\t(float)array[array2[ii]][array3[ii]])\n+      return 2;\n+  \n+#if HAVE_IO\n+  for (ii = 0; ii < 10; ii++) {\n+      for (jj = 0; jj < 10; jj++) {\n+\t  for (kk = 0; kk < 10; kk++) {\n+\t      for (ll = 0; ll < 10; ll++) {\n+\t\t  printf(\"%4d\\n\", array4[ii][jj][kk][ll]);\n+\t      }\n+\t  }\n+      }\n+  }\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "b150b18f2972fcfd0d0611df9377f296ced2aeba", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/if_test.c", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,250 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <stdlib.h>\n+int main2 (int argc, char **argv);\n+int main(int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"10\", \"15\"};\t     \n+      x = main2 (3, (char **) array);\n+    }\n+  else if (argc == 3)\n+    x = main2 (argc, argv);\n+  else\n+    return 1;\n+ \n+  return x;\n+}\n+\n+\n+int main2 (int argc, char **argv)\n+{\n+  int x = 3, y, z, array[10], array2[10], TwodArray[10][10], jj,kk,ll ;\n+  int array2_check[10];\n+  int FourDArray[10][10][10][10];\n+  int ii = 0; \n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = argc%3;\n+      array2[ii]= 10;\n+      array2_check[ii] = 10;\n+    }\n+\n+  if (!array[:])\n+    array2[:] = 5;\n+  else\n+    array2[:] = 10;\n+\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (!array[ii])\n+\tarray2_check[ii] = 5;\n+      else\n+\tarray2_check[ii] = 10;\n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array2_check[ii] != array2[ii])\n+      return 2;\n+  \n+\n+  \n+  if (!(array[0:10:1] + array[0:10:1]))\n+    array2[:] = 5;\n+  else\n+    array2[:] = 10;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (!(array[ii]+ array[ii]))\n+\tarray2_check[ii] = 5;\n+      else\n+\tarray2_check[ii] = 10;\n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array2_check[ii] != array2[ii])\n+      return 3;\n+  \n+\n+      \n+       \n+\n+  x = atoi (argv[1])-10;\n+  y = atoi (argv[1])/2;\n+  z = (atoi (argv[1]))/5;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      if (ii % 2)\n+\tarray[ii] = 0;\n+      else\n+\tarray[ii] = 1;\n+    }\n+\n+  /*printf(\"x = %2d y = %2d z = %2d\\n\", x, y, z); */\n+\n+  for (ii = 0; ii < 10; ii++)\n+    array[ii] = 10;\n+\n+  /* This if loop will change all the 10's to 5's */\n+  if (array[x:y:z] != 9)\n+    array2[:] = 5;\n+  else\n+    array2[:] = 10;\n+\n+  for (ii = x; ii < (x+y); ii += z)\n+    {\n+      if (array[ii] != 9)\n+\tarray2_check[ii] = 5;\n+      else\n+\tarray2_check[ii] = 10;\n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array2_check[ii] != array2[ii])\n+      return 4;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    array2[ii] = 10;\n+\n+  /* This if loop will change all the 10's to 5's */\n+  if (array[atoi(argv[1])-10:atoi(argv[1]): atoi(argv[1])/5])\n+    array2[:] = 5;\n+  else\n+    array2[:] = 10;\n+\n+  for (ii = atoi(argv[1])-10; ii < atoi(argv[1]) + (atoi (argv[1])-10);\n+       ii +=atoi(argv[1])/5)\n+    if (array[ii])\n+      array2_check[ii] = 5;\n+    else\n+      array2_check[ii] = 10;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array2_check[ii] != array2[ii])\n+      return 5;\n+ \n+\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < 10; jj++)\n+      TwodArray[ii][jj] = atoi(argv[1]);\n+\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array2[ii] = 10;\n+      array2_check[ii] = 10;\n+    }\n+\n+  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n+  if (TwodArray[:][:] != 10) \n+    array2[:] = 10; \n+  else\n+    array2[:] = 5;\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj < 10; jj++) {\n+      if (TwodArray[ii][jj] != 10)\n+\tarray2_check[ii] = 10;\n+    }\n+  }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array2[ii] = 10;\n+      array2_check[ii] = 10;\n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < 10; jj++)\n+      for (kk = 0; kk < 10; kk++)\n+\tfor (ll = 0; ll < 10; ll++) \n+\t  FourDArray[ii][jj][kk][ll] = atoi(argv[1]);\n+  \n+  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n+  if (FourDArray[:][:][:][:] != 10) \n+    array2[:] = 10; \n+  else\n+    array2[:] = 5;\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj < 10; jj++) {\n+      for (kk = 0; kk < 10; kk++) {\n+\tfor (ll = 0; ll < 10; ll++) {\n+\t  if (FourDArray[ii][jj][kk][ll] != 10)\n+\t    array2_check[ii] = 10;\n+\t}\n+      }\n+    }\n+  }\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array2[ii] = 10;\n+      array2_check[ii] = 10;\n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < 10; jj++)\n+      for (kk = 0; kk < 10; kk++)\n+\tfor (ll = 0; ll < 10; ll++) \n+\t  FourDArray[ii][jj][kk][ll] = atoi(argv[1]);\n+  \n+  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n+  if (FourDArray[0:10:1][0:5:2][9:10:-1][x:y:z] != 10) \n+    array2[:] = 10; \n+  else\n+    array2[:] = 5;\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj < 10; jj += 2) {\n+      for (kk = 9; kk >= 0; kk--) {\n+\tfor (ll = x; ll < 10; ll = ll += z) {\n+\t  if (FourDArray[ii][jj][kk][ll] != 10)\n+\t    array2_check[ii] = 10;\n+\t  else\n+\t    array2_check[ii] = 5;\n+\t}\n+      }\n+    }\n+  }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array2[ii] = 10;\n+      array2_check[ii] = 10;\n+    }\n+\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < 10; jj++)\n+      for (kk = 0; kk < 10; kk++)\n+\tfor (ll = 0; ll < 10; ll++) \n+\t  FourDArray[ii][jj][kk][ll] = atoi(argv[1]);\n+  \n+  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n+  if (FourDArray[0:10:1][0:5:2][9:10:-1][x:y:z] +\n+      FourDArray[0:10:1][0:5:2][9:-10:1][x:y:z]  != 20) \n+    array2[:] = 10; \n+  else\n+    array2[:] = 5;\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj < 10; jj += 2) {\n+      for (kk = 9; kk >= 0; kk--) {\n+\tfor (ll = x; ll < 10; ll = ll += z) {\n+\t  if (FourDArray[ii][jj][kk][ll] != 10)\n+\t    array2_check[ii] = 10;\n+\t  else\n+\t    array2_check[ii] = 5;\n+\t}\n+      }\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "891e1dc55597befcc2687ddc850001fac0797eac", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/misc.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,112 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  int array[10], array2[10][10];\n+  int x, ii, jj ;\n+\n+  switch (array[:]) {  /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  case 1:\n+    x = 5;\n+    break;\n+  case 2:\n+    x = 2;\n+    break;\n+  default:\n+    x = 9;\n+  }\n+\n+  switch (array2[:][:]) { /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  case 1:\n+    x = 5;\n+    break;\n+  case 2:\n+    x = 2;\n+    break;\n+  default:\n+    x = 9;\n+  }\n+\n+  switch (array[:] + x) { /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  case 1:\n+    x = 5;\n+    break;\n+  case 2:\n+    x = 2;\n+    break;\n+  default:\n+    x = 9;\n+  }\n+  \n+  switch (array2[:][1:x:4] + x) { /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  case 1:\n+    x = 5;\n+    break;\n+  case 2:\n+    x = 2;\n+    break;\n+  default:\n+    x = 9;\n+  }\n+\n+  for (ii = 0; ii < array[:]; ii++) /* { dg-error \"array notations cannot be used in a condition for a for-loop\" } */\n+    {\n+      x = 2;\n+    }\n+\n+  for (ii = 0; ii < array2[:][:]; ii++) /* { dg-error \"array notations cannot be used in a condition for a for-loop\" } */\n+    {\n+      x = 3;\n+    }\n+\n+  for (; array2[:][:] < 2;) /* { dg-error \"array notations cannot be used in a condition for a for-loop\" } */\n+    x = 4;\n+\n+\n+  while (array2[:][:]) /* { dg-error \"array notations cannot be used as a condition for while statement\" } */\n+    x = 3;\n+\n+  while (array[1:1:1]) /* { dg-error \"array notations cannot be used as a condition for while statement\" } */\n+    x = 1;\n+\n+  while (ii != array2[1:x:3][1:2:1]) /* { dg-error \"array notations cannot be used as a condition for while statement\"  } */\n+    x = 2;\n+\n+  do { /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" } */\n+    x = 3;\n+  } while (ii != array2[:][:]); \n+\n+  do {  /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" } */\n+    x = 2;\n+  } while (ii != (x + array2[:][1:x:2]) + 2);\n+  \n+  do { \n+    x += 3;\n+    if (x == 5)\n+      return array2[:][:]; /* { dg-error \"array notation expression cannot be used as a return value\" } */\n+  } while (ii != 0);\n+\n+  for (ii = 0;  ii < 10; ii++)\n+    if (ii % 2)\n+      return array[1:x:ii]; /* { dg-error \"array notation expression cannot be used as a return value\" } */\n+\n+  for (ii = 0; ii < x; ii++)\n+    if (ii)\n+      return array2[:][:]; /* { dg-error \"array notation expression cannot be used as a return value\" } */\n+\n+  for (array[:] = 0; ii < x; ii++) /* This should be OK.  */\n+    x= 2;\n+\n+  for (ii = 0; ii < 10; array[:]++) /* This is OK.  */\n+    x = 5;\n+\n+  for (jj = 0; jj < 10; array2[:][:]++) /* This is OK.  */\n+    x = 3;\n+\n+  for (jj = 0; jj < 10; array2[:][1:x:4]++, jj++) /* This is OK.  */\n+    x = 3;\n+  \n+  return x;\n+}\n+ "}, {"sha": "750446c87d239365625ecc215c4cc655e4f78ab2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/n-ptr-test.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fn-ptr-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fn-ptr-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fn-ptr-test.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#define NUMBER 10\n+#include <stdlib.h>\n+\n+int ***func2 (int ***a1, int ***a2, int size)\n+{\n+  a1[0:size:1][0:size:1][0:size] += (a2[0:size][0:size][0:size:1]  + size);\n+  return a1;\n+}\n+\n+int main (void)\n+{\n+  int ii, jj, kk;\n+  int ***array3, ***array2 = NULL, ***array = NULL;\n+\n+  array = (int ***) malloc (sizeof (int **) * NUMBER);\n+  array2 = (int ***) malloc (sizeof (int **) * NUMBER);\n+  for (ii = 0; ii < NUMBER; ii++) {\n+    array[ii] = (int **) malloc (sizeof (int *) * NUMBER);\n+    array2[ii] = (int **) malloc (sizeof (int *) * NUMBER);\n+    for (jj = 0; jj < NUMBER; jj++) { \n+      array[ii][jj] = (int *) malloc (sizeof (int) * NUMBER);\n+      array2[ii][jj] = (int *) malloc (sizeof (int) * NUMBER);\n+    } \n+  }\n+\n+  for (ii = 0; ii < NUMBER; ii++) {\n+    for (jj = 0; jj < NUMBER; jj++) {\n+      for (kk = 0; kk < NUMBER; kk++) {\n+\tarray[ii][jj][kk] = 5;\n+\tarray2[ii][jj][kk]= 2;\n+      }\n+    }\n+  }\n+  array3 = func2 ((int ***)array, (int ***)array2, NUMBER);\n+  \n+  for (ii = 0; ii < NUMBER; ii++) {\n+    for (jj = 0; jj < NUMBER; jj++) {\n+      for (kk = 0; kk < NUMBER; kk++) {\n+\tif (array3[ii][jj][kk] != (7 + NUMBER))\n+          return 1;\n+      }\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "7b1aa89517f9d7592092a5d7eec06caf264742a1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+  \n+  array2[:] = array2[: ;  /* { dg-error \"expected ']'\" } */\n+\n+  return 0;\n+} /* { dg-error \"expected ';' before\" } */"}, {"sha": "8bf2282088e945dff1acd1508db0624b70f248e5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+  \n+  array2[:] = array2[1:2:] ;  /* { dg-error \"expected expression before\" } */\n+\n+  return 0; /* { dg-error \"expected ';' before\" } */\n+}"}, {"sha": "824e18660fd449576e4f437a739264364d7d44a1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+  \n+  array2[:] = array2[1::] ;  /* { dg-error \"expected expression before\" } */\n+\n+  return 0; /* { dg-error \"expected ';' before\" } */\n+}"}, {"sha": "25a8a8fb62cb87862f9770231afca4efc02d710b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+  \n+  array2[:] = array2[::] ;  /* { dg-error \" expected ']' before ':' token\" } */\n+\n+  return 0;\n+}"}, {"sha": "a8c9dab56738a6fd3d3a1545bf7c5f83f0d0e801", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (int argc, char **argv)\n+{\n+  int x = 0;\n+  int array[10][10], array2[10];\n+\n+  array[:][:] = array[:]; /* { dg-error \"rank mismatch between\" } */\n+\n+  x = array2[:]; /* { dg-error \"cannot be scalar when\" } */\n+\n+  return 0;\n+}"}, {"sha": "74fece4d172dcfc4881844381af8a04fdd987ef6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch2.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int function_call (int x);\n+int function_call (int x)\n+{\n+  return x;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+  int array[100], array2[100][100];\n+\n+  array[:] = array[:] + array2[:][:]; /* { dg-error \"rank mismatch between\" } */\n+\n+  if (array[:] + array2[:][:]) /* { dg-error \"rank mismatch between\" } */\n+    return argc == 5;\n+\n+  argc += function_call (array[:] + array2[5:10:2][:]); /* { dg-error \"rank mismatch between\" } */\n+\n+  argc += function_call (function_call (array[:] + array2[5:10:2][:])); /* { dg-error \"rank mismatch between\" } */\n+\n+   argc += __sec_reduce_add (array[:], array2[:][:]); /* { dg-error \"rank mismatch between\" } */\n+\n+   argc += __sec_reduce_add (array2[:][:]) + argc; /* This is OK.  */\n+  return argc;\n+}"}, {"sha": "de335922f8a5e0a38856ce107b2723bcaa1a4a07", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch3.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int funct (int x, int y);\n+void funct_void (int x, int y, int z);\n+int main(void)\n+{\n+  int y, array[100], array2[100], array3[100][100], array4[100];\n+\n+  array[:] = ((array2[:] + array[:]) * array4[:]) + array3[:][:]; /* { dg-error \"rank mismatch between\" } */\n+  array[:] = funct (array2[:], array3[:][:]); /* { dg-error \"rank mismatch between\" } */\n+  array[:] = array3[:][:]; /* { dg-error \"rank mismatch between\" } */\n+  array3[:][:] = array[:]; /* { dg-error \"rank mismatch between\" } */\n+  array3[:][:] = array[5]; /* This is OK!  */\n+  funct_void (array2[:], array3[:][:], array[:]); /* { dg-error \"rank mismatch between\" } */\n+  funct_void (array2[:], array3[:][:], array[:]); /* { dg-error \"rank mismatch between\" } */\n+  funct_void (array3[:][:], array2[:], array[:]); /* { dg-error \"rank mismatch between\" }  */\n+  funct_void (array2[:], array[:], array3[:][0:10:1]); /* { dg-error \"rank mismatch between\" } */\n+  return 0;\n+}"}, {"sha": "fe66cf87be04fd1ae05aa9b6750ca7395254bb8e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_implicit.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main2 (int argc, char **argv);\n+int main (int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\n+      x = main2 (2, (char **)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+\n+  return x;\n+}\n+\n+int main2 (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+\n+  array[:][:] = __sec_implicit_index(5) + array[:][:]; /* { dg-error \"__sec_implicit_index argument\" } */\n+\n+  return 0;\n+}"}, {"sha": "29f8c32d4a00f3715e1090a8e3013dede9ee61ab", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_implicit2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit2.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main2 (int argc, char **argv);\n+int main (int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\n+      x = main2 (2, (char**)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+\n+  return x;\n+}\n+\n+int main2 (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+\n+  array[:][:] = __sec_implicit_index(argc) + array[:][:]; /* { dg-error \"__sec_implicit_index parameter\" } */\n+  return 0;\n+}"}, {"sha": "c5f7cdf18e7a91ef3751827c9efc3f0059fd4e93", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_implicit_ex.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit_ex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit_ex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit_ex.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+void abort (void);\n+void exit  (int);\n+\n+\n+int main(int argc, char **argv)\n+{\n+  int jj, kk, array_3C[10][10][10];\n+  int ii,array[10], y = 0, y_int = 0, array2[10], array_3[10][10][10];\n+  double x, yy, array3[10], array4[10];\n+\n+  array[:] = __sec_implicit_index (0);\n+  array_3[:][:][:] = __sec_implicit_index (1) + __sec_implicit_index(0) +\n+    __sec_implicit_index (2);\n+\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < 10; jj++)\n+      for (kk = 0; kk < 10; kk++)\n+\tarray_3C[ii][jj][kk] = ii+jj+kk;\n+\t\n+  for (ii = 0; ii < 10; ii++)\n+    for (jj = 0; jj < 10; jj++)\n+      for (kk = 0; kk < 10; kk++)\n+\tif (array_3[ii][jj][kk] != array_3C[ii][jj][kk])\n+\t  abort ();\n+\t\n+\n+  exit (0);\n+  \n+  return 0;\n+}"}, {"sha": "4bd6030a61d3b40fc3e7594ae2bcf569cf13fba5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_reduce_max_min_ind.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_max_min_ind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_max_min_ind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_max_min_ind.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main2 (int argc, char **argv);\n+int main (int argc, char **argv)\n+{\n+  int x = 0;\n+  if (argc == 1)\n+    {\n+      const char *array[] = {\"a.out\", \"5\"};\n+      x = main2 (2, (char **)array);\n+    }\n+  else\n+    x = main2 (argc, argv);\n+\n+  return x;\n+}\n+\n+int main2 (int argc, char **argv)\n+{\n+  int array[10][10], array2[10];\n+  int x, y;\n+  x = __sec_reduce_max_ind (array[:][:]); /* { dg-error \"cannot have arrays with dimension greater than\" } */\n+\n+  y = __sec_reduce_max_ind (array2[:]); /* this should be OK. */\n+\n+  x = __sec_reduce_min_ind (array[:][:]); /* { dg-error \"cannot have arrays with dimension greater than\" } */\n+\n+  y = __sec_reduce_min_ind (array2[:]); /* this should be OK. */\n+\n+  return 0;\n+}"}, {"sha": "a72cfafba1c52fb06b365e7a384316ecfb61923e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_reduce_return.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_return.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int add_all (int *my_array, int size)\n+{\n+  return __sec_reduce_add (my_array[0:size]);\n+}\n+\n+int mult_all (int *my_array, int size)\n+{\n+  return __sec_reduce_mul (my_array[0:size]);\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  int array[10000];\n+\n+  array[:] = argc; /* All elements should be one.  */\n+\n+  if (add_all (array, 10000) != 10000)\n+    return 1;\n+\n+  if (mult_all (array, 10000) != 1)\n+    return 2;\n+\n+  return 0;\n+}"}, {"sha": "8b0034e727b808ffdce16084925e24e3a33e71a2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/side-effects-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fside-effects-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fside-effects-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fside-effects-1.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+/* Test that the array index, limit, and stride are evaluated only\n+   once.  */\n+\n+int array[1000];\n+\n+int func1_times = 0;\n+int func2_times = 0;\n+int func3_times = 0;\n+int func1() { func1_times++; return 0; }\n+int func2() { func2_times++; return 0; }\n+int func3() { func3_times++; return 0; }\n+\n+int main()\n+{\n+  array[func1() + 11 : func2() + 22 : func3() + 33] = 666;\n+\n+  if (func1_times != 1\n+      || func2_times != 1\n+      || func3_times != 1)\n+    return 1;\n+\n+  return 0;\n+}"}, {"sha": "0df324a80d464baade7049db5c6e91f4c960c60b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/test_builtin_return.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_builtin_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_builtin_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_builtin_return.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-options \"-lm -fcilkplus\" } */\n+/* { dg-do run } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+#include <math.h>\n+#define NUMBER 5\n+\n+int func1 (int *a1, int *a2)\n+{\n+  return __sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER:1]);\n+}\n+\n+int func2 (int *a1, int *a2)\n+{\n+  return (__sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER]) + \n+\t  __sec_reduce_mul (a1[0:NUMBER] + a2[0:NUMBER]));\n+}\n+\n+int func3 (int *a1, int *a2)\n+{\n+  return (int) sqrt ((double)(__sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER]) +\n+\t\t\t      a2[0] + a2[1] + a2[3]));\n+}\n+\n+int func4 (int *a1, int *a2)\n+{\n+  return a1[NUMBER-1] * (__sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER]) + a2[0] + a2[1] + a2[3])/a1[NUMBER-2];\n+}\n+int main(int argc, char **argv)\n+{\n+  int array[NUMBER], array2[NUMBER];\n+  int return_value = 0;\n+  int ii = 0;\n+  for (ii = 0; ii < NUMBER; ii++)\n+    {\n+      array[ii] = argc; /* This should calculate to 1.  */\n+      array2[ii]  = argc * argc + argc;  /* This should calculate to 2.  */\n+    }\n+\n+  return_value = func1 (array, array2);\n+#if HAVE_IO\n+  printf(\"Return_value = %d\\n\", return_value);\n+#endif\n+  if (return_value != (2+2+2+2+2))\n+    return 1;\n+\n+  return_value = func2 (array2, array);\n+#if HAVE_IO\n+  printf(\"Return_value = %d\\n\", return_value);\n+#endif\n+  if (return_value != (3*3*3*3*3) + (2+2+2+2+2))\n+    return 2;\n+\n+  return_value = func3 (array, array2);\n+#if HAVE_IO\n+  printf(\"Return_value = %d\\n\", return_value);\n+#endif\n+  if (return_value != 4)\n+    return 3;\n+\n+  return_value = func4 (array, array2);\n+#if HAVE_IO\n+  printf(\"Return_value = %d\\n\", return_value);\n+#endif\n+  if (return_value != 16)\n+    return 4;\n+\n+  return 0;\n+}"}, {"sha": "f4f3ca5a6bb0de0db091c935ae304b0a263a0d72", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/test_sec_limits.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_sec_limits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_sec_limits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_sec_limits.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <limits.h>\n+int A[16];\n+int a = 0;\n+\n+int main () {\n+      if (__sec_reduce_max(A[0:0:2]) != INT_MIN)\n+\t    a++;\n+\n+        if (__sec_reduce_min(A[0:0:2]) != INT_MAX)\n+\t      a++;\n+\n+\t  return a;\n+}\n+\n+"}, {"sha": "015a7eb737085484f1c13710873d5ffa52013704", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/tst_lngth.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftst_lngth.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftst_lngth.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftst_lngth.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \" -fcilkplus \" } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+#define N 256\n+int A[N], B[N];\n+\n+int\n+main ()\n+{\n+    A[0:(N / 4)] = A[4]+ B[0:(N / 2):2]; /* { dg-error \"length mismatch between\" } */ \n+    A[0:(N / 4)] = B[0:(N / 2):2] + N; /* { dg-error \"length mismatch between\" } */\n+    A[0:(N / 4)] = B[0:(N / 2):2] + A[4]; /* { dg-error \"length mismatch between\" } */\n+    return 0;\n+}\n+"}, {"sha": "038ae482df8478b39eb0b64b07a97047d5f41cdd", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/vla.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus -std=c99\" } */\n+\n+int func (int x)\n+{\n+  return x++;\n+}\n+int main(int argc, char **argv)\n+{\n+  int array[argc];\n+\n+  array[:] = 5; /* { dg-error \"start-index and length fields necessary for using array notations in variable-length arrays.\" }  */\n+  array[0:argc] = 5;               /* This is OK.  */\n+  array[0:5:2] = 5;                /* This is OK.  */\n+  array[0:argc:2] = 5;             /* This is OK.  */\n+  array[0:argc:func (argc-2)] = 5; /* This is OK.  */\n+  return 0;\n+}"}, {"sha": "59b23056c722fc1b7d112eabbedc7505b392918f", "filename": "gcc/testsuite/gcc.dg/cilk-plus/cilk-plus.exp", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36536d79af79b5a252356e79e62b851f3f2bedf9/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=36536d79af79b5a252356e79e62b851f3f2bedf9", "patch": "@@ -0,0 +1,45 @@\n+#   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Written by Balaji V. Iyer <balaji.v.iyer@intel.com>\n+\n+\n+load_lib gcc-dg.exp\n+\n+dg-init\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O3 -ftree-vectorize -fcilkplus -g\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -O0 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -O1 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -O2 -ftree-vectorize -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -O3 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -O0 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -O1 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -O2 -ftree-vectorize -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -O3 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O3 -ftree-vectorize -std=c99 -g -fcilkplus\" \" \"\n+dg-finish"}]}