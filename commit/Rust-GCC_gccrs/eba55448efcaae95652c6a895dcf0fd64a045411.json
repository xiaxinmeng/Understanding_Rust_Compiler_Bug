{"sha": "eba55448efcaae95652c6a895dcf0fd64a045411", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJhNTU0NDhlZmNhYWU5NTY1MmM2YTg5NWRjZjBmZDY0YTA0NTQxMQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2014-11-10T23:41:41Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-11-10T23:41:41Z"}, "message": "i386.c (ix86_decompose_address): Replace open-coded swap with std::swap to swap values.\n\n\t* config/i386/i386.c (ix86_decompose_address): Replace open-coded\n\tswap with std::swap to swap values.\n\t(ix86_fixup_binary_operands): Ditto.\n\t(ix86_binary_operator_ok): Ditto.\n\t(ix86_prepare_fp_compare_args): Ditto.\n\t(ix86_expand_branch): Ditto.\n\t(ix86_expand_carry_flag_compare): Ditto.\n\t(ix86_expand_int_movcc): Ditto.\n\t(ix86_prepare_sse_fp_compare_args): Ditto.\n\t(ix86_expand_sse_fp_minmax): Ditto.\n\t(ix86_expand_int_vcond): Ditto.\n\t(ix86_split_long_move): Ditto.\n\t(ix86_expand_sse_comi): Ditto.\n\t(ix86_expand_sse_compare_and_jump): Ditto.\n\t(ix86_expand_sse_compare_mask): Ditto.\n\t* config/i386/i386.md (*add<mode>_1): Ditto.\n\t(addsi_1_zext): Ditto.\n\t(*addhi_1): Ditto.\n\t(*addqi_1): Ditto.\n\t(*add<mode>_2): Ditto.\n\t(*addsi_2_zext): Ditto.\n\t(*add<mode>_3): Ditto.\n\t(*addsi_3_zext): Ditto.\n\t(*add<mode>_5): Ditto.\n\t(absneg splitter): Ditto.\n\nFrom-SVN: r217326", "tree": {"sha": "9249f53aa62eb2275309ede8dfc30481a4c60be3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9249f53aa62eb2275309ede8dfc30481a4c60be3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eba55448efcaae95652c6a895dcf0fd64a045411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eba55448efcaae95652c6a895dcf0fd64a045411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eba55448efcaae95652c6a895dcf0fd64a045411", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eba55448efcaae95652c6a895dcf0fd64a045411/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "516119bd60f8544888280be3823db10beeafbf2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516119bd60f8544888280be3823db10beeafbf2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516119bd60f8544888280be3823db10beeafbf2a"}], "stats": {"total": 165, "additions": 61, "deletions": 104}, "files": [{"sha": "ce5759ef22520110b9edcf8b07bdb745bc6dbc70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55448efcaae95652c6a895dcf0fd64a045411/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55448efcaae95652c6a895dcf0fd64a045411/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eba55448efcaae95652c6a895dcf0fd64a045411", "patch": "@@ -1,3 +1,31 @@\n+2014-11-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_decompose_address): Replace open-coded\n+\tswap with std::swap to swap values.\n+\t(ix86_fixup_binary_operands): Ditto.\n+\t(ix86_binary_operator_ok): Ditto.\n+\t(ix86_prepare_fp_compare_args): Ditto.\n+\t(ix86_expand_branch): Ditto.\n+\t(ix86_expand_carry_flag_compare): Ditto.\n+\t(ix86_expand_int_movcc): Ditto.\n+\t(ix86_prepare_sse_fp_compare_args): Ditto.\n+\t(ix86_expand_sse_fp_minmax): Ditto.\n+\t(ix86_expand_int_vcond): Ditto.\n+\t(ix86_split_long_move): Ditto.\n+\t(ix86_expand_sse_comi): Ditto.\n+\t(ix86_expand_sse_compare_and_jump): Ditto.\n+\t(ix86_expand_sse_compare_mask): Ditto.\n+\t* config/i386/i386.md (*add<mode>_1): Ditto.\n+\t(addsi_1_zext): Ditto.\n+\t(*addhi_1): Ditto.\n+\t(*addqi_1): Ditto.\n+\t(*add<mode>_2): Ditto.\n+\t(*addsi_2_zext): Ditto.\n+\t(*add<mode>_3): Ditto.\n+\t(*addsi_3_zext): Ditto.\n+\t(*add<mode>_5): Ditto.\n+\t(absneg splitter): Ditto.\n+\n 2014-11-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \tRevert:"}, {"sha": "28669009014022afb3e1be8668fe8abc19dbe799", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 23, "deletions": 63, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55448efcaae95652c6a895dcf0fd64a045411/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55448efcaae95652c6a895dcf0fd64a045411/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=eba55448efcaae95652c6a895dcf0fd64a045411", "patch": "@@ -12698,9 +12698,8 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t  || index_reg == frame_pointer_rtx\n \t  || (REG_P (index_reg) && REGNO (index_reg) == STACK_POINTER_REGNUM)))\n     {\n-      rtx tmp;\n-      tmp = base, base = index, index = tmp;\n-      tmp = base_reg, base_reg = index_reg, index_reg = tmp;\n+      std::swap (base, index);\n+      std::swap (base_reg, index_reg);\n     }\n \n   /* Special case: %ebp cannot be encoded as a base without a displacement.\n@@ -17753,14 +17752,10 @@ ix86_fixup_binary_operands (enum rtx_code code, machine_mode mode,\n   /* Canonicalize operand order.  */\n   if (ix86_swap_binary_operands_p (code, mode, operands))\n     {\n-      rtx temp;\n-\n       /* It is invalid to swap operands of different modes.  */\n       gcc_assert (GET_MODE (src1) == GET_MODE (src2));\n \n-      temp = src1;\n-      src1 = src2;\n-      src2 = temp;\n+      std::swap (src1, src2);\n     }\n \n   /* Both source operands cannot be in memory.  */\n@@ -17950,11 +17945,7 @@ ix86_binary_operator_ok (enum rtx_code code, machine_mode mode,\n \n   /* Canonicalize operand order for commutative operators.  */\n   if (ix86_swap_binary_operands_p (code, mode, operands))\n-    {\n-      rtx temp = src1;\n-      src1 = src2;\n-      src2 = temp;\n-    }\n+    std::swap (src1, src2);\n \n   /* If the destination is memory, we must have a matching source operand.  */\n   if (MEM_P (dst) && !rtx_equal_p (dst, src1))\n@@ -19994,8 +19985,7 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  enum rtx_code new_code = ix86_fp_swap_condition (code);\n \t  if (new_code != UNKNOWN)\n \t    {\n-\t      rtx tmp;\n-\t      tmp = op0, op0 = op1, op1 = tmp;\n+\t      std::swap (op0, op1);\n \t      code = new_code;\n \t    }\n \t}\n@@ -20023,8 +20013,7 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n       > ix86_fp_comparison_cost (swap_condition (code))\n       && (REG_P (op1) || can_create_pseudo_p ()))\n     {\n-      rtx tmp;\n-      tmp = op0, op0 = op1, op1 = tmp;\n+      std::swap (op0, op1);\n       code = swap_condition (code);\n       if (!REG_P (op0))\n \top0 = force_reg (op_mode, op0);\n@@ -20290,7 +20279,7 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n \n \tif (CONSTANT_P (op0) && !CONSTANT_P (op1))\n \t  {\n-\t    tmp = op0, op0 = op1, op1 = tmp;\n+\t    std::swap (op0, op1);\n \t    code = swap_condition (code);\n \t  }\n \n@@ -20471,9 +20460,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n       if ((code == GT || code == UNLE || code == LE || code == UNGT)\n \t  && !TARGET_IEEE_FP)\n \t{\n-\t  rtx tmp = op0;\n-\t  op0 = op1;\n-\t  op1 = tmp;\n+\t  std::swap (op0, op1);\n \t  code = swap_condition (code);\n \t}\n \n@@ -20533,9 +20520,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n \t}\n       else\n \t{\n-\t  rtx tmp = op1;\n-\t  op1 = op0;\n-\t  op0 = tmp;\n+\t  std::swap (op1, op0);\n \t  code = (code == GTU ? LTU : GEU);\n \t}\n       break;\n@@ -20764,8 +20749,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t{\n \t  machine_mode cmp_mode = GET_MODE (op0);\n \n-\t  HOST_WIDE_INT tmp;\n-\t  tmp = ct, ct = cf, cf = tmp;\n+\t  std::swap (ct, cf);\n \t  diff = -diff;\n \n \t  if (SCALAR_FLOAT_MODE_P (cmp_mode))\n@@ -20962,11 +20946,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t\t  compare_code = LT;\n \t\t}\n \t      else\n-\t\t{\n-\t\t  HOST_WIDE_INT tmp = cf;\n-\t\t  cf = ct;\n-\t\t  ct = tmp;\n-\t\t}\n+\t\tstd::swap (cf, ct);\n \n \t      out = emit_store_flag (out, code, op0, op1, VOIDmode, 0, -1);\n \t    }\n@@ -21090,8 +21070,6 @@ static enum rtx_code\n ix86_prepare_sse_fp_compare_args (rtx dest, enum rtx_code code,\n \t\t\t\t  rtx *pop0, rtx *pop1)\n {\n-  rtx tmp;\n-\n   switch (code)\n     {\n     case LTGT:\n@@ -21133,9 +21111,7 @@ ix86_prepare_sse_fp_compare_args (rtx dest, enum rtx_code code,\n \t ix86_expand_sse_fp_minmax only optimizes LT/UNGE.  Swap the\n \t comparison operands to transform into something that is\n \t supported.  */\n-      tmp = *pop0;\n-      *pop0 = *pop1;\n-      *pop1 = tmp;\n+      std::swap (*pop0, *pop1);\n       code = swap_condition (code);\n       break;\n \n@@ -21164,11 +21140,7 @@ ix86_expand_sse_fp_minmax (rtx dest, enum rtx_code code, rtx cmp_op0,\n   if (code == LT)\n     ;\n   else if (code == UNGE)\n-    {\n-      tmp = if_true;\n-      if_true = if_false;\n-      if_false = tmp;\n-    }\n+    std::swap (if_true, if_false);\n   else\n     return false;\n \n@@ -21632,8 +21604,8 @@ ix86_expand_int_vcond (rtx operands[])\n \n \tcase LT:\n \tcase LTU:\n+\t  std::swap (cop0, cop1);\n \t  code = swap_condition (code);\n-\t  x = cop0, cop0 = cop1, cop1 = x;\n \t  break;\n \n \tdefault:\n@@ -22742,22 +22714,22 @@ ix86_split_long_move (rtx operands[])\n       /* Collision in the middle part can be handled by reordering.  */\n       if (collisions == 1 && nparts == 3 && collisionparts [1])\n \t{\n-\t  tmp = part[0][1]; part[0][1] = part[0][2]; part[0][2] = tmp;\n-\t  tmp = part[1][1]; part[1][1] = part[1][2]; part[1][2] = tmp;\n+\t  std::swap (part[0][1], part[0][2]);\n+\t  std::swap (part[1][1], part[1][2]);\n \t}\n       else if (collisions == 1\n \t       && nparts == 4\n \t       && (collisionparts [1] || collisionparts [2]))\n \t{\n \t  if (collisionparts [1])\n \t    {\n-\t      tmp = part[0][1]; part[0][1] = part[0][2]; part[0][2] = tmp;\n-\t      tmp = part[1][1]; part[1][1] = part[1][2]; part[1][2] = tmp;\n+\t      std::swap (part[0][1], part[0][2]);\n+\t      std::swap (part[1][1], part[1][2]);\n \t    }\n \t  else\n \t    {\n-\t      tmp = part[0][2]; part[0][2] = part[0][3]; part[0][3] = tmp;\n-\t      tmp = part[1][2]; part[1][2] = part[1][3]; part[1][3] = tmp;\n+\t      std::swap (part[0][2], part[0][3]);\n+\t      std::swap (part[1][2], part[1][3]);\n \t    }\n \t}\n \n@@ -35906,11 +35878,7 @@ ix86_expand_sse_comi (const struct builtin_description *d, tree exp,\n   /* Swap operands if we have a comparison that isn't available in\n      hardware.  */\n   if (d->flag & BUILTIN_DESC_SWAP_OPERANDS)\n-    {\n-      rtx tmp = op1;\n-      op1 = op0;\n-      op0 = tmp;\n-    }\n+    std::swap (op1, op0);\n \n   target = gen_reg_rtx (SImode);\n   emit_move_insn (target, const0_rtx);\n@@ -45751,11 +45719,7 @@ ix86_expand_sse_compare_and_jump (enum rtx_code code, rtx op0, rtx op1,\n   rtx tmp;\n \n   if (swap_operands)\n-    {\n-      tmp = op0;\n-      op0 = op1;\n-      op1 = tmp;\n-    }\n+    std::swap (op0, op1);\n \n   label = gen_label_rtx ();\n   tmp = gen_rtx_REG (fpcmp_mode, FLAGS_REG);\n@@ -45782,11 +45746,7 @@ ix86_expand_sse_compare_mask (enum rtx_code code, rtx op0, rtx op1,\n   rtx mask = gen_reg_rtx (mode);\n \n   if (swap_operands)\n-    {\n-      rtx tmp = op0;\n-      op0 = op1;\n-      op1 = tmp;\n-    }\n+    std::swap (op0, op1);\n \n   insn = mode == DFmode ? gen_setcc_df_sse : gen_setcc_sf_sse;\n "}, {"sha": "83619b1a2edfac3a551c4fdaa4df4fd4fcfb77d5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eba55448efcaae95652c6a895dcf0fd64a045411/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eba55448efcaae95652c6a895dcf0fd64a045411/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=eba55448efcaae95652c6a895dcf0fd64a045411", "patch": "@@ -5232,10 +5232,7 @@\n       /* For most processors, ADD is faster than LEA.  This alternative\n \t was added to use ADD as much as possible.  */\n       if (which_alternative == 2)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n         \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n@@ -5290,10 +5287,7 @@\n       /* For most processors, ADD is faster than LEA.  This alternative\n \t was added to use ADD as much as possible.  */\n       if (which_alternative == 1)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       if (x86_maybe_negate_const_int (&operands[2], SImode))\n         return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n@@ -5341,10 +5335,7 @@\n       /* For most processors, ADD is faster than LEA.  This alternative\n \t was added to use ADD as much as possible.  */\n       if (which_alternative == 2)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], HImode))\n@@ -5396,10 +5387,7 @@\n       /* For most processors, ADD is faster than LEA.  These alternatives\n \t were added to use ADD as much as possible.  */\n       if (which_alternative == 2 || which_alternative == 4)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], QImode))\n@@ -5553,10 +5541,7 @@\n \n     default:\n       if (which_alternative == 2)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n         \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n@@ -5601,10 +5586,7 @@\n \n     default:\n       if (which_alternative == 1)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       if (x86_maybe_negate_const_int (&operands[2], SImode))\n         return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n@@ -5645,10 +5627,7 @@\n \n     default:\n       if (which_alternative == 1)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n@@ -5692,10 +5671,7 @@\n \n     default:\n       if (which_alternative == 1)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       if (x86_maybe_negate_const_int (&operands[2], SImode))\n         return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n@@ -5827,10 +5803,7 @@\n \n     default:\n       if (which_alternative == 1)\n-\t{\n-\t  rtx tmp;\n-\t  tmp = operands[1], operands[1] = operands[2], operands[2] = tmp;\n-\t}\n+        std::swap (operands[1], operands[2]);\n \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n@@ -8786,11 +8759,7 @@\n   operands[0] = simplify_gen_subreg (vmode, operands[0], mode, 0);\n   operands[1] = simplify_gen_subreg (vmode, operands[1], mode, 0);\n   if (operands_match_p (operands[0], operands[2]))\n-    {\n-      tmp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-    }\n+    std::swap (operands[1], operands[2]);\n   if (GET_CODE (operands[3]) == ABS)\n     tmp = gen_rtx_AND (vmode, operands[1], operands[2]);\n   else"}]}