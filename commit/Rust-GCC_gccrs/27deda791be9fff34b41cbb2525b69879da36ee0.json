{"sha": "27deda791be9fff34b41cbb2525b69879da36ee0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdkZWRhNzkxYmU5ZmZmMzRiNDFjYmIyNTI1YjY5ODc5ZGEzNmVlMA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-03-24T01:48:57Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-03-24T01:48:57Z"}, "message": "re PR libfortran/48030 (Implement read_x using fbuf_getc)\n\n2011-03-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/48030\n\t* io/read.c (read_x): Re-implement using fbuf_getc.\n\nFrom-SVN: r171378", "tree": {"sha": "3bfddd974381485ec49aa6ceb5bdc05d2a0427ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bfddd974381485ec49aa6ceb5bdc05d2a0427ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27deda791be9fff34b41cbb2525b69879da36ee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27deda791be9fff34b41cbb2525b69879da36ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27deda791be9fff34b41cbb2525b69879da36ee0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27deda791be9fff34b41cbb2525b69879da36ee0/comments", "author": null, "committer": null, "parents": [{"sha": "fd68e6ba7254ebe7feeeafe1fd6686b2ada8eeff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd68e6ba7254ebe7feeeafe1fd6686b2ada8eeff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd68e6ba7254ebe7feeeafe1fd6686b2ada8eeff"}], "stats": {"total": 58, "additions": 22, "deletions": 36}, "files": [{"sha": "b6dc507f3fd4bdda3d3d1dfa3ef2d53f496e715b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27deda791be9fff34b41cbb2525b69879da36ee0/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27deda791be9fff34b41cbb2525b69879da36ee0/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=27deda791be9fff34b41cbb2525b69879da36ee0", "patch": "@@ -1,3 +1,8 @@\n+2011-03-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/48030\n+\t* io/read.c (read_x): Re-implement using fbuf_getc.\n+\n 2011-03-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR bootstrap/48135"}, {"sha": "3ee5717e823843f85a66a41509e753686382adb1", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27deda791be9fff34b41cbb2525b69879da36ee0/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27deda791be9fff34b41cbb2525b69879da36ee0/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=27deda791be9fff34b41cbb2525b69879da36ee0", "patch": "@@ -1186,8 +1186,7 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n void\n read_x (st_parameter_dt *dtp, int n)\n {\n-  int length;\n-  char *p, q;\n+  int length, q, q2;\n \n   if ((dtp->u.p.current_unit->pad_status == PAD_NO || is_internal_unit (dtp))\n        && dtp->u.p.current_unit->bytes_left < n)\n@@ -1200,7 +1199,7 @@ read_x (st_parameter_dt *dtp, int n)\n \n   if (is_internal_unit (dtp))\n     {\n-      p = mem_alloc_r (dtp->u.p.current_unit->s, &length);\n+      mem_alloc_r (dtp->u.p.current_unit->s, &length);\n       if (unlikely (length < n))\n \tn = length;\n       goto done;\n@@ -1209,55 +1208,37 @@ read_x (st_parameter_dt *dtp, int n)\n   if (dtp->u.p.sf_seen_eor)\n     return;\n \n-  p = fbuf_read (dtp->u.p.current_unit, &length);\n-  if (p == NULL)\n-    {\n-      hit_eof (dtp);\n-      return;\n-    }\n-  \n-  if (length == 0 && dtp->u.p.item_count == 1)\n-    {\n-      if (dtp->u.p.current_unit->pad_status == PAD_NO)\n-\t{\n-\t  hit_eof (dtp);\n-\t  return;\n-\t}\n-      else\n-\treturn;\n-    }\n-\n   n = 0;\n   while (n < length)\n     {\n-      q = *p;\n-      if (q == '\\n' || q == '\\r')\n+      q = fbuf_getc (dtp->u.p.current_unit);\n+      if (q == EOF)\n+\tbreak;\n+      else if (q == '\\n' || q == '\\r')\n \t{\n \t  /* Unexpected end of line. Set the position.  */\n-\t  fbuf_seek (dtp->u.p.current_unit, n + 1 ,SEEK_CUR);\n \t  dtp->u.p.sf_seen_eor = 1;\n \n+\t  /* If we see an EOR during non-advancing I/O, we need to skip\n+\t     the rest of the I/O statement.  Set the corresponding flag.  */\n+\t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n+\t    dtp->u.p.eor_condition = 1;\n+\t    \n \t  /* If we encounter a CR, it might be a CRLF.  */\n \t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n-\t      /* See if there is an LF. Use fbuf_read rather then fbuf_getc so\n-\t\t the position is not advanced unless it really is an LF.  */\n-\t      int readlen = 1;\n-\t      p = fbuf_read (dtp->u.p.current_unit, &readlen);\n-\t      if (*p == '\\n' && readlen == 1)\n-\t        {\n-\t\t  dtp->u.p.sf_seen_eor = 2;\n-\t\t  fbuf_seek (dtp->u.p.current_unit, 1 ,SEEK_CUR);\n-\t\t}\n+\t      /* See if there is an LF.  */\n+\t      q2 = fbuf_getc (dtp->u.p.current_unit);\n+\t      if (q2 == '\\n')\n+\t\tdtp->u.p.sf_seen_eor = 2;\n+\t      else if (q2 != EOF) /* Oops, seek back.  */\n+\t\tfbuf_seek (dtp->u.p.current_unit, -1, SEEK_CUR);\n \t    }\n \t  goto done;\n \t}\n       n++;\n-      p++;\n     } \n \n-  fbuf_seek (dtp->u.p.current_unit, n, SEEK_CUR);\n-  \n  done:\n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n     dtp->u.p.size_used += (GFC_IO_INT) n;"}]}