{"sha": "0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2MGY5YWQ0MDQ4ZWE1NGIxMjNlM2Y3YzVjYzA2OTZmMzc5NThhNw==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2019-04-09T15:45:26Z"}, "committer": {"name": "Thomas Rodgers", "email": "rodgertq@gcc.gnu.org", "date": "2019-04-09T15:45:26Z"}, "message": "Add PSTL internal namespace qualifications\n\n\t* include/pstl/algorithm_impl.h: Add namespace qualification.\n\t* include/pstl/execution_defs.h: Add namespace qualification.\n\t* include/pstl/execution_impl.h: Add namespace qualification.\n\t* include/pstl/numeric_impl.h: Add namespace qualification.\n\t* include/pstl/parallel_backend_tbb.h: Add namespace qualification.\n\t* include/pstl/unseq_backend_simd.h: Add namespace qualification.\n\t* include/pstl/parallel_backend_utils.h: Include <cassert>.\n\nFrom-SVN: r270231", "tree": {"sha": "0a5e7dcfc8b1191972b093ef8bb168f4910f4e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a5e7dcfc8b1191972b093ef8bb168f4910f4e97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a22feb67aa1f6b434f01fdf52b37148f4946306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a22feb67aa1f6b434f01fdf52b37148f4946306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a22feb67aa1f6b434f01fdf52b37148f4946306"}], "stats": {"total": 557, "additions": 285, "deletions": 272}, "files": [{"sha": "eaad7c62100d028510b5c8f936da4408d75a3a29", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -1,3 +1,13 @@\n+2019-04-09  Thomas Rodgers  <trodgers@redhat.com>\n+\n+\t* include/pstl/algorithm_impl.h: Add namespace qualification.\n+\t* include/pstl/execution_defs.h: Add namespace qualification.\n+\t* include/pstl/execution_impl.h: Add namespace qualification.\n+\t* include/pstl/numeric_impl.h: Add namespace qualification.\n+\t* include/pstl/parallel_backend_tbb.h: Add namespace qualification.\n+\t* include/pstl/unseq_backend_simd.h: Add namespace qualification.\n+\t* include/pstl/parallel_backend_utils.h: Include <cassert>.\n+\n 2019-04-08  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tFix visit<R> for variant."}, {"sha": "e06bf60151e7b2a09745750198868d31193f267e", "filename": "libstdc++-v3/include/pstl/algorithm_impl.h", "status": "modified", "additions": 214, "deletions": 213, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -18,6 +18,7 @@\n \n #include \"execution_impl.h\"\n #include \"memory_impl.h\"\n+#include \"parallel_backend_utils.h\"\n #include \"unseq_backend_simd.h\"\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -55,7 +56,7 @@ bool\n __pattern_any_of(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Pred __pred,\n                  _IsVector __is_vector, /*parallel=*/std::false_type) noexcept\n {\n-    return __brick_any_of(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_any_of(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -64,10 +65,10 @@ bool\n __pattern_any_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Pred __pred,\n                  _IsVector __is_vector, /*parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n-        return __parallel_or(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+    return __internal::__except_handler([&]() {\n+       return __internal::__parallel_or(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                              [__pred, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {\n-                                 return __brick_any_of(__i, __j, __pred, __is_vector);\n+                                 return __internal::__brick_any_of(__i, __j, __pred, __is_vector);\n                              });\n     });\n }\n@@ -111,7 +112,7 @@ __pattern_walk1(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator _\n                 _IsVector __is_vector,\n                 /*parallel=*/std::false_type) noexcept\n {\n-    __brick_walk1(__first, __last, __f, __is_vector);\n+    __internal::__brick_walk1(__first, __last, __f, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -121,10 +122,10 @@ __pattern_walk1(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIte\n                 _IsVector __is_vector,\n                 /*parallel=*/std::true_type)\n {\n-    __except_handler([&]() {\n+    __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                                       [__f, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {\n-                                          __brick_walk1(__i, __j, __f, __is_vector);\n+                                          __internal::__brick_walk1(__i, __j, __f, __is_vector);\n                                       });\n     });\n }\n@@ -144,7 +145,7 @@ void\n __pattern_walk_brick(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Brick __brick,\n                      /*parallel=*/std::true_type)\n {\n-    __except_handler([&]() {\n+    __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                                       [__brick](_ForwardIterator __i, _ForwardIterator __j) { __brick(__i, __j); });\n     });\n@@ -158,7 +159,7 @@ template <class _ForwardIterator, class _Size, class _Function>\n _ForwardIterator\n __brick_walk1_n(_ForwardIterator __first, _Size __n, _Function __f, /*_IsVectorTag=*/std::false_type)\n {\n-    return __for_each_n_it_serial(__first, __n,\n+    return __internal::__for_each_n_it_serial(__first, __n,\n                                   [&__f](_ForwardIterator __it) { __f(*__it); }); // calling serial version\n }\n \n@@ -175,7 +176,7 @@ _ForwardIterator\n __pattern_walk1_n(_ExecutionPolicy&&, _ForwardIterator __first, _Size __n, _Function __f, _IsVector __is_vector,\n                   /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_walk1_n(__first, __n, __f, __is_vector);\n+    return __internal::__brick_walk1_n(__first, __n, __f, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -185,7 +186,7 @@ __pattern_walk1_n(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Siz\n                   _IsVector __is_vector,\n                   /*is_parallel=*/std::true_type)\n {\n-    __pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __first + __n, __f, __is_vector, std::true_type());\n+    __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __first + __n, __f, __is_vector, std::true_type());\n     return __first + __n;\n }\n #endif\n@@ -204,7 +205,7 @@ _RandomAccessIterator\n __pattern_walk_brick_n(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Size __n, _Brick __brick,\n                        /*is_parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(\n             std::forward<_ExecutionPolicy>(__exec), __first, __first + __n,\n             [__brick](_RandomAccessIterator __i, _RandomAccessIterator __j) { __brick(__i, __j - __i); });\n@@ -259,7 +260,7 @@ _ForwardIterator2\n __pattern_walk2(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n                 _Function __f, _IsVector __is_vector, /*parallel=*/std::false_type) noexcept\n {\n-    return __brick_walk2(__first1, __last1, __first2, __f, __is_vector);\n+    return __internal::__brick_walk2(__first1, __last1, __first2, __f, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -268,11 +269,11 @@ _ForwardIterator2\n __pattern_walk2(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _Function __f, _IsVector __is_vector, /*parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n             [__f, __first1, __first2, __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {\n-                __brick_walk2(__i, __j, __first2 + (__i - __first1), __f, __is_vector);\n+                __internal::__brick_walk2(__i, __j, __first2 + (__i - __first1), __f, __is_vector);\n             });\n         return __first2 + (__last1 - __first1);\n     });\n@@ -285,7 +286,7 @@ _ForwardIterator2\n __pattern_walk2_n(_ExecutionPolicy&&, _ForwardIterator1 __first1, _Size n, _ForwardIterator2 __first2, _Function f,\n                   _IsVector is_vector, /*parallel=*/std::false_type) noexcept\n {\n-    return __brick_walk2_n(__first1, n, __first2, f, is_vector);\n+    return __internal::__brick_walk2_n(__first1, n, __first2, f, is_vector);\n }\n \n template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size, class _RandomAccessIterator2,\n@@ -294,7 +295,7 @@ _RandomAccessIterator2\n __pattern_walk2_n(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _Size n, _RandomAccessIterator2 __first2,\n                   _Function f, _IsVector is_vector, /*parallel=*/std::true_type)\n {\n-    return __pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + n, __first2, f, is_vector,\n+    return __internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + n, __first2, f, is_vector,\n                            std::true_type());\n }\n \n@@ -312,7 +313,7 @@ _RandomAccessIterator2\n __pattern_walk2_brick(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n                       _RandomAccessIterator2 __first2, _Brick __brick, /*parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n             [__first1, __first2, __brick](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j) {\n@@ -329,7 +330,7 @@ _RandomAccessIterator2\n __pattern_walk2_brick_n(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _Size __n,\n                         _RandomAccessIterator2 __first2, _Brick __brick, /*parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + __n,\n             [__first1, __first2, __brick](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j) {\n@@ -377,7 +378,7 @@ _ForwardIterator3\n __pattern_walk3(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n                 _ForwardIterator3 __first3, _Function __f, _IsVector __is_vector, /*parallel=*/std::false_type) noexcept\n {\n-    return __brick_walk3(__first1, __last1, __first2, __first3, __f, __is_vector);\n+    return __internal::__brick_walk3(__first1, __last1, __first2, __first3, __f, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -388,11 +389,11 @@ __pattern_walk3(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _Ran\n                 _RandomAccessIterator2 __first2, _RandomAccessIterator3 __first3, _Function __f, _IsVector __is_vector,\n                 /*parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n             [__f, __first1, __first2, __first3, __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j) {\n-                __brick_walk3(__i, __j, __first2 + (__i - __first1), __first3 + (__i - __first1), __f, __is_vector);\n+                __internal::__brick_walk3(__i, __j, __first2 + (__i - __first1), __first3 + (__i - __first1), __f, __is_vector);\n             });\n         return __first3 + (__last1 - __first1);\n     });\n@@ -426,7 +427,7 @@ bool\n __pattern_equal(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n                 _BinaryPredicate __p, _IsVector __is_vector, /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_equal(__first1, __last1, __first2, __p, __is_vector);\n+    return __internal::__brick_equal(__first1, __last1, __first2, __p, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -437,11 +438,11 @@ __pattern_equal(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _Ran\n                 _RandomAccessIterator2 __first2, _BinaryPredicate __p, _IsVector __is_vector,\n                 /*is_parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n-        return !__parallel_or(\n+    return __internal::__except_handler([&]() {\n+        return !__internal::__parallel_or(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n             [__first1, __first2, __p, __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j) {\n-                return !__brick_equal(__i, __j, __first2 + (__i - __first1), __p, __is_vector);\n+                return !__internal::__brick_equal(__i, __j, __first2 + (__i - __first1), __p, __is_vector);\n             });\n     });\n }\n@@ -475,7 +476,7 @@ __pattern_find_if(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator\n                   _IsVector __is_vector,\n                   /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_find_if(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_find_if(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -485,10 +486,10 @@ __pattern_find_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardI\n                   _IsVector __is_vector,\n                   /*is_parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n-        return __parallel_find(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+    return __internal::__except_handler([&]() {\n+\t\t\treturn __internal::__parallel_find(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                                [__pred, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {\n-                                   return __brick_find_if(__i, __j, __pred, __is_vector);\n+                                   return __internal::__brick_find_if(__i, __j, __pred, __is_vector);\n                                },\n                                std::less<typename std::iterator_traits<_ForwardIterator>::difference_type>(),\n                                /*is_first=*/true);\n@@ -526,14 +527,14 @@ __find_subrange(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _\n     while (__first != __last && (__global_last - __first >= __n2))\n     {\n         // find position of *s_first in [first, last) (it can be start of subsequence)\n-        __first = __brick_find_if(__first, __last,\n+        __first = __internal::__brick_find_if(__first, __last,\n                                   __equal_value_by_pred<_ValueType, _BinaryPredicate>(*__s_first, __pred), __is_vector);\n \n         // if position that was found previously is the start of subsequence\n         // then we can exit the loop (b_first == true) or keep the position\n         // (b_first == false)\n         if (__first != __last && (__global_last - __first >= __n2) &&\n-            __brick_equal(__s_first + 1, __s_last, __first + 1, __pred, __is_vector))\n+            __internal::__brick_equal(__s_first + 1, __s_last, __first + 1, __pred, __is_vector))\n         {\n             if (__b_first)\n             {\n@@ -573,11 +574,11 @@ __find_subrange(_RandomAccessIterator __first, _RandomAccessIterator __last, _Ra\n     auto __unary_pred = __equal_value_by_pred<_Tp, _BinaryPredicate>(__value, __pred);\n     while (__first != __last && (__global_last - __first >= __count))\n     {\n-        __first = __brick_find_if(__first, __last, __unary_pred, __is_vector);\n+        __first = __internal::__brick_find_if(__first, __last, __unary_pred, __is_vector);\n \n         // check that all of elements in [first+1, first+count) equal to value\n         if (__first != __last && (__global_last - __first >= __count) &&\n-            !__brick_any_of(__first + 1, __first + __count, __not_pred<decltype(__unary_pred)>(__unary_pred),\n+            !__internal::__brick_any_of(__first + 1, __first + __count, __not_pred<decltype(__unary_pred)>(__unary_pred),\n                             __is_vector))\n         {\n             return __first;\n@@ -617,7 +618,7 @@ __pattern_find_end(_ExecutionPolicy&&, _ForwardIterator1 __first, _ForwardIterat\n                    _ForwardIterator2 __s_last, _BinaryPredicate __pred, _IsVector __is_vector,\n                    /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_find_end(__first, __last, __s_first, __s_last, __pred, __is_vector);\n+    return __internal::__brick_find_end(__first, __last, __s_first, __s_last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -630,17 +631,17 @@ __pattern_find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Forwar\n {\n     if (__last - __first == __s_last - __s_first)\n     {\n-        const bool __res = __pattern_equal(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __pred,\n+        const bool __res = __internal::__pattern_equal(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __pred,\n                                            __is_vector, std::true_type());\n         return __res ? __first : __last;\n     }\n     else\n     {\n-        return __except_handler([&]() {\n-            return __parallel_find(\n+        return __internal::__except_handler([&]() {\n+           return __internal::__parallel_find(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                 [__last, __s_first, __s_last, __pred, __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {\n-                    return __find_subrange(__i, __j, __last, __s_first, __s_last, __pred, false, __is_vector);\n+                    return __internal::__find_subrange(__i, __j, __last, __s_first, __s_last, __pred, false, __is_vector);\n                 },\n                 std::greater<typename std::iterator_traits<_ForwardIterator1>::difference_type>(), /*is_first=*/false);\n         });\n@@ -674,7 +675,7 @@ __pattern_find_first_of(_ExecutionPolicy&&, _ForwardIterator1 __first, _ForwardI\n                         _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred,\n                         _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_find_first_of(__first, __last, __s_first, __s_last, __pred, __is_vector);\n+    return __internal::__brick_find_first_of(__first, __last, __s_first, __s_last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -685,11 +686,11 @@ __pattern_find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _F\n                         _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred,\n                         _IsVector __is_vector, /*is_parallel=*/std::true_type) noexcept\n {\n-    return __except_handler([&]() {\n-        return __parallel_find(\n+    return __internal::__except_handler([&]() {\n+         return __internal::__parallel_find(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last,\n             [__s_first, __s_last, __pred, __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {\n-                return __brick_find_first_of(__i, __j, __s_first, __s_last, __pred, __is_vector);\n+                return __internal::__brick_find_first_of(__i, __j, __s_first, __s_last, __pred, __is_vector);\n             },\n             std::less<typename std::iterator_traits<_ForwardIterator1>::difference_type>(), /*is_first=*/true);\n     });\n@@ -712,7 +713,7 @@ _ForwardIterator1\n __brick_search(_ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n                _ForwardIterator2 __s_last, _BinaryPredicate __pred, /*vector=*/std::true_type) noexcept\n {\n-    return __find_subrange(__first, __last, __last, __s_first, __s_last, __pred, true, std::true_type());\n+    return __internal::__find_subrange(__first, __last, __last, __s_first, __s_last, __pred, true, std::true_type());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n@@ -722,7 +723,7 @@ __pattern_search(_ExecutionPolicy&&, _ForwardIterator1 __first, _ForwardIterator\n                  _ForwardIterator2 __s_last, _BinaryPredicate __pred, _IsVector __is_vector,\n                  /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_search(__first, __last, __s_first, __s_last, __pred, __is_vector);\n+    return __internal::__brick_search(__first, __last, __s_first, __s_last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -736,17 +737,17 @@ __pattern_search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardI\n {\n     if (__last - __first == __s_last - __s_first)\n     {\n-        const bool __res = __pattern_equal(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __pred,\n+        const bool __res = __internal::__pattern_equal(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __pred,\n                                            __is_vector, std::true_type());\n         return __res ? __first : __last;\n     }\n     else\n     {\n-        return __except_handler([&]() {\n-            return __parallel_find(\n+        return __internal::__except_handler([&]() {\n+            return __internal::__parallel_find(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                 [__last, __s_first, __s_last, __pred, __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {\n-                    return __find_subrange(__i, __j, __last, __s_first, __s_last, __pred, true, __is_vector);\n+                    return __internal::__find_subrange(__i, __j, __last, __s_first, __s_last, __pred, true, __is_vector);\n                 },\n                 std::less<typename std::iterator_traits<_ForwardIterator1>::difference_type>(), /*is_first=*/true);\n         });\n@@ -770,7 +771,7 @@ _ForwardIterator\n __brick_search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value,\n                  _BinaryPredicate __pred, /*vector=*/std::true_type) noexcept\n {\n-    return __find_subrange(__first, __last, __last, __count, __value, __pred, std::true_type());\n+    return __internal::__find_subrange(__first, __last, __last, __count, __value, __pred, std::true_type());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate,\n@@ -780,7 +781,7 @@ __pattern_search_n(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterato\n                    const _Tp& __value, _BinaryPredicate __pred, _IsVector __is_vector,\n                    /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_search_n(__first, __last, __count, __value, __pred, __is_vector);\n+    return __internal::__brick_search_n(__first, __last, __count, __value, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -794,18 +795,18 @@ __pattern_search_n(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Ra\n     if (__last - __first == __count)\n     {\n         const bool __result =\n-            !__pattern_any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+            !__internal::__pattern_any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                               [&__value, &__pred](const _Tp& __val) { return !__pred(__val, __value); }, __is_vector,\n                               /*is_parallel*/ std::true_type());\n         return __result ? __first : __last;\n     }\n     else\n     {\n-        return __except_handler([&__exec, __first, __last, __count, &__value, __pred, __is_vector]() {\n-            return __parallel_find(\n+        return __internal::__except_handler([&__exec, __first, __last, __count, &__value, __pred, __is_vector]() {\n+            return __internal::__parallel_find(\n                 std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                 [__last, __count, &__value, __pred, __is_vector](_RandomAccessIterator __i, _RandomAccessIterator __j) {\n-                    return __find_subrange(__i, __j, __last, __count, __value, __pred, __is_vector);\n+                    return __internal::__find_subrange(__i, __j, __last, __count, __value, __pred, __is_vector);\n                 },\n                 std::less<typename std::iterator_traits<_RandomAccessIterator>::difference_type>(), /*is_first=*/true);\n         });\n@@ -973,7 +974,7 @@ __brick_copy_by_mask(_ForwardIterator __first, _ForwardIterator __last, _OutputI\n #if (__PSTL_MONOTONIC_PRESENT)\n     __unseq_backend::__simd_copy_by_mask(__first, __last - __first, __result, __mask, __assigner);\n #else\n-    __brick_copy_by_mask(__first, __last, __result, __mask, __assigner, std::false_type());\n+    __internal::__brick_copy_by_mask(__first, __last, __result, __mask, __assigner, std::false_type());\n #endif\n }\n \n@@ -1005,7 +1006,7 @@ __brick_partition_by_mask(_RandomAccessIterator __first, _RandomAccessIterator _\n #if (__PSTL_MONOTONIC_PRESENT)\n     __unseq_backend::__simd_partition_by_mask(__first, __last - __first, __out_true, __out_false, __mask);\n #else\n-    __brick_partition_by_mask(__first, __last, __out_true, __out_false, __mask, std::false_type());\n+    __internal::__brick_partition_by_mask(__first, __last, __out_true, __out_false, __mask, std::false_type());\n #endif\n }\n \n@@ -1014,7 +1015,7 @@ _OutputIterator\n __pattern_copy_if(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n                   _UnaryPredicate __pred, _IsVector __is_vector, /*parallel=*/std::false_type) noexcept\n {\n-    return __brick_copy_if(__first, __last, __result, __pred, __is_vector);\n+    return __internal::__brick_copy_if(__first, __last, __result, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1029,19 +1030,19 @@ __pattern_copy_if(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Ran\n     if (_DifferenceType(1) < __n)\n     {\n         __par_backend::__buffer<bool> __mask_buf(__n);\n-        return __except_handler([&__exec, __n, __first, __result, __is_vector, __pred, &__mask_buf]() {\n+        return __internal::__except_handler([&__exec, __n, __first, __result, __is_vector, __pred, &__mask_buf]() {\n             bool* __mask = __mask_buf.get();\n             _DifferenceType __m{};\n             __par_backend::parallel_strict_scan(\n                 std::forward<_ExecutionPolicy>(__exec), __n, _DifferenceType(0),\n                 [=](_DifferenceType __i, _DifferenceType __len) { // Reduce\n-                    return __brick_calc_mask_1<_DifferenceType>(__first + __i, __first + (__i + __len), __mask + __i,\n+                    return __internal::__brick_calc_mask_1<_DifferenceType>(__first + __i, __first + (__i + __len), __mask + __i,\n                                                                 __pred, __is_vector)\n                         .first;\n                 },\n                 std::plus<_DifferenceType>(),                                                // Combine\n                 [=](_DifferenceType __i, _DifferenceType __len, _DifferenceType __initial) { // Scan\n-                    __brick_copy_by_mask(__first + __i, __first + (__i + __len), __result + __initial, __mask + __i,\n+                    __internal::__brick_copy_by_mask(__first + __i, __first + (__i + __len), __result + __initial, __mask + __i,\n                                          [](_RandomAccessIterator __x, _OutputIterator __z) { *__z = *__x; },\n                                          __is_vector);\n                 },\n@@ -1050,7 +1051,7 @@ __pattern_copy_if(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _Ran\n         });\n     }\n     // trivial sequence - use serial algorithm\n-    return __brick_copy_if(__first, __last, __result, __pred, __is_vector);\n+    return __internal::__brick_copy_if(__first, __last, __result, __pred, __is_vector);\n }\n #endif\n \n@@ -1078,7 +1079,7 @@ typename std::iterator_traits<_ForwardIterator>::difference_type\n __pattern_count(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                 /* is_parallel */ std::false_type, _IsVector __is_vector) noexcept\n {\n-    return __brick_count(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_count(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1088,11 +1089,11 @@ __pattern_count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIte\n                 /* is_parallel */ std::true_type, _IsVector __is_vector)\n {\n     typedef typename std::iterator_traits<_ForwardIterator>::difference_type _SizeType;\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         return __par_backend::__parallel_reduce(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last, _SizeType(0),\n             [__pred, __is_vector](_ForwardIterator __begin, _ForwardIterator __end, _SizeType __value) -> _SizeType {\n-                return __value + __brick_count(__begin, __end, __pred, __is_vector);\n+                return __value + __internal::__brick_count(__begin, __end, __pred, __is_vector);\n             },\n             std::plus<_SizeType>());\n     });\n@@ -1125,23 +1126,23 @@ _ForwardIterator\n __pattern_unique(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred,\n                  _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_unique(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_unique(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n // That function is shared between two algorithms - remove_if (__pattern_remove_if) and unique (pattern unique). But a mask calculation is different.\n // So, a caller passes _CalcMask brick into remove_elements.\n template <class _ExecutionPolicy, class _ForwardIterator, class _CalcMask, class _IsVector>\n _ForwardIterator\n-remove_elements(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _CalcMask __calc_mask,\n+__remove_elements(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _CalcMask __calc_mask,\n                 _IsVector __is_vector)\n {\n     typedef typename std::iterator_traits<_ForwardIterator>::difference_type _DifferenceType;\n     typedef typename std::iterator_traits<_ForwardIterator>::value_type _Tp;\n     _DifferenceType __n = __last - __first;\n     __par_backend::__buffer<bool> __mask_buf(__n);\n     // 1. find a first iterator that should be removed\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         bool* __mask = __mask_buf.get();\n         _DifferenceType __min = __par_backend::__parallel_reduce(\n             std::forward<_ExecutionPolicy>(__exec), _DifferenceType(0), __n, __n,\n@@ -1157,7 +1158,7 @@ remove_elements(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIte\n                 }\n                 // find first iterator that should be removed\n                 bool* __result =\n-                    __brick_find_if(__mask + __i, __mask + __j, [](bool __val) { return !__val; }, __is_vector);\n+                    __internal::__brick_find_if(__mask + __i, __mask + __j, [](bool __val) { return !__val; }, __is_vector);\n                 if (__result - __mask == __j)\n                 {\n                     return __local_min;\n@@ -1184,13 +1185,13 @@ remove_elements(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIte\n         __par_backend::parallel_strict_scan(\n             std::forward<_ExecutionPolicy>(__exec), __n, _DifferenceType(0),\n             [__mask, __is_vector](_DifferenceType __i, _DifferenceType __len) {\n-                return __brick_count(__mask + __i, __mask + __i + __len, [](bool __val) { return __val; }, __is_vector);\n+                return __internal::__brick_count(__mask + __i, __mask + __i + __len, [](bool __val) { return __val; }, __is_vector);\n             },\n             std::plus<_DifferenceType>(),\n             [=](_DifferenceType __i, _DifferenceType __len, _DifferenceType __initial) {\n-                __brick_copy_by_mask(__first + __i, __first + __i + __len, __result + __initial, __mask + __i,\n+                __internal::__brick_copy_by_mask(__first + __i, __first + __i + __len, __result + __initial, __mask + __i,\n                                      [](_ForwardIterator __x, _Tp* __z) {\n-                                         __invoke_if_else(std::is_trivial<_Tp>(), [&]() { *__z = std::move(*__x); },\n+                                         __internal::__invoke_if_else(std::is_trivial<_Tp>(), [&]() { *__z = std::move(*__x); },\n                                                           [&]() { ::new (std::addressof(*__z)) _Tp(std::move(*__x)); });\n                                      },\n                                      __is_vector);\n@@ -1200,7 +1201,7 @@ remove_elements(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIte\n         // 3. Elements from result are moved to [first, last)\n         __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,\n                                       [__result, __first, __is_vector](_Tp* __i, _Tp* __j) {\n-                                          __brick_move(__i, __j, __first + (__i - __result), __is_vector);\n+                                          __internal::__brick_move(__i, __j, __first + (__i - __result), __is_vector);\n                                       });\n         return __first + __m;\n     });\n@@ -1222,12 +1223,12 @@ __pattern_unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIt\n     if (__first + 1 == __last || __first + 2 == __last)\n     {\n         // Trivial sequence - use serial algorithm\n-        return __brick_unique(__first, __last, __pred, __is_vector);\n+        return __internal::__brick_unique(__first, __last, __pred, __is_vector);\n     }\n-    return remove_elements(\n+    return __internal::__remove_elements(\n         std::forward<_ExecutionPolicy>(__exec), ++__first, __last,\n         [&__pred, __is_vector](bool* __b, bool* __e, _ForwardIterator __it) {\n-            __brick_walk3(__b, __e, __it - 1, __it,\n+            __internal::__brick_walk3(__b, __e, __it - 1, __it,\n                           [&__pred](bool& __x, _ReferenceType __y, _ReferenceType __z) { __x = !__pred(__y, __z); },\n                           __is_vector);\n         },\n@@ -1265,7 +1266,7 @@ _OutputIterator\n __pattern_unique_copy(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n                       _BinaryPredicate __pred, _IsVector __is_vector, /*parallel=*/std::false_type) noexcept\n {\n-    return __brick_unique_copy(__first, __last, __result, __pred, __is_vector);\n+    return __internal::__brick_unique_copy(__first, __last, __result, __pred, __is_vector);\n }\n \n template <class _DifferenceType, class _RandomAccessIterator, class _BinaryPredicate>\n@@ -1305,7 +1306,7 @@ __pattern_unique_copy(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n         __par_backend::__buffer<bool> __mask_buf(__n);\n         if (_DifferenceType(2) < __n)\n         {\n-            return __except_handler([&__exec, __n, __first, __result, __pred, __is_vector, &__mask_buf]() {\n+            return __internal::__except_handler([&__exec, __n, __first, __result, __pred, __is_vector, &__mask_buf]() {\n                 bool* __mask = __mask_buf.get();\n                 _DifferenceType __m{};\n                 __par_backend::parallel_strict_scan(\n@@ -1321,14 +1322,14 @@ __pattern_unique_copy(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n                             ++__i;\n                             ++__extra;\n                         }\n-                        return __brick_calc_mask_2<_DifferenceType>(__first + __i, __first + (__i + __len),\n+                        return __internal::__brick_calc_mask_2<_DifferenceType>(__first + __i, __first + (__i + __len),\n                                                                     __mask + __i, __pred, __is_vector) +\n                                __extra;\n                     },\n                     std::plus<_DifferenceType>(),                                                // Combine\n                     [=](_DifferenceType __i, _DifferenceType __len, _DifferenceType __initial) { // Scan\n                         // Phase 2 is same as for __pattern_copy_if\n-                        __brick_copy_by_mask(__first + __i, __first + (__i + __len), __result + __initial, __mask + __i,\n+                        __internal::__brick_copy_by_mask(__first + __i, __first + (__i + __len), __result + __initial, __mask + __i,\n                                              [](_RandomAccessIterator __x, _OutputIterator __z) { *__z = *__x; },\n                                              __is_vector);\n                     },\n@@ -1338,7 +1339,7 @@ __pattern_unique_copy(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n         }\n     }\n     // trivial sequence - use serial algorithm\n-    return __brick_unique_copy(__first, __last, __result, __pred, __is_vector);\n+    return __internal::__brick_unique_copy(__first, __last, __result, __pred, __is_vector);\n }\n #endif\n \n@@ -1400,7 +1401,7 @@ __pattern_reverse(_ExecutionPolicy&&, _BidirectionalIterator __first, _Bidirecti\n                   _IsVector _is_vector,\n                   /*is_parallel=*/std::false_type) noexcept\n {\n-    __brick_reverse(__first, __last, _is_vector);\n+    __internal::__brick_reverse(__first, __last, _is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1412,7 +1413,7 @@ __pattern_reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _Bi\n     __par_backend::__parallel_for(\n         std::forward<_ExecutionPolicy>(__exec), __first, __first + (__last - __first) / 2,\n         [__is_vector, __first, __last](_BidirectionalIterator __inner_first, _BidirectionalIterator __inner_last) {\n-            __brick_reverse(__inner_first, __inner_last, __last - (__inner_first - __first), __is_vector);\n+            __internal::__brick_reverse(__inner_first, __inner_last, __last - (__inner_first - __first), __is_vector);\n         });\n }\n #endif\n@@ -1446,7 +1447,7 @@ _OutputIterator\n __pattern_reverse_copy(_ExecutionPolicy&&, _BidirectionalIterator __first, _BidirectionalIterator __last,\n                        _OutputIterator __d_first, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_reverse_copy(__first, __last, __d_first, __is_vector);\n+    return __internal::__brick_reverse_copy(__first, __last, __d_first, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1459,7 +1460,7 @@ __pattern_reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first\n     __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                                   [__is_vector, __first, __len, __d_first](_BidirectionalIterator __inner_first,\n                                                                            _BidirectionalIterator __inner_last) {\n-                                      __brick_reverse_copy(__inner_first, __inner_last,\n+                                      __internal::__brick_reverse_copy(__inner_first, __inner_last,\n                                                            __d_first + (__len - (__inner_last - __first)), __is_vector);\n                                   });\n     return __d_first + __len;\n@@ -1528,7 +1529,7 @@ _ForwardIterator\n __pattern_rotate(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n                  _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_rotate(__first, __middle, __last, __is_vector);\n+    return __internal::__brick_rotate(__first, __middle, __last, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1543,22 +1544,22 @@ __pattern_rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIt\n     if (__m <= __n / 2)\n     {\n         __par_backend::__buffer<_Tp> __buf(__n - __m);\n-        return __except_handler([&__exec, __n, __m, __first, __middle, __last, __is_vector, &__buf]() {\n+        return __internal::__except_handler([&__exec, __n, __m, __first, __middle, __last, __is_vector, &__buf]() {\n             _Tp* __result = __buf.get();\n             __par_backend::__parallel_for(\n                 std::forward<_ExecutionPolicy>(__exec), __middle, __last,\n                 [__middle, __result, __is_vector](_ForwardIterator __b, _ForwardIterator __e) {\n-                    __brick_uninitialized_move(__b, __e, __result + (__b - __middle), __is_vector);\n+                    __internal::__brick_uninitialized_move(__b, __e, __result + (__b - __middle), __is_vector);\n                 });\n \n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __middle,\n                                           [__last, __middle, __is_vector](_ForwardIterator __b, _ForwardIterator __e) {\n-                                              __brick_move(__b, __e, __b + (__last - __middle), __is_vector);\n+                                              __internal::__brick_move(__b, __e, __b + (__last - __middle), __is_vector);\n                                           });\n \n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __result, __result + (__n - __m),\n                                           [__first, __result, __is_vector](_Tp* __b, _Tp* __e) {\n-                                              __brick_move(__b, __e, __first + (__b - __result), __is_vector);\n+                                              __internal::__brick_move(__b, __e, __first + (__b - __result), __is_vector);\n                                           });\n \n             return __first + (__last - __middle);\n@@ -1567,22 +1568,22 @@ __pattern_rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIt\n     else\n     {\n         __par_backend::__buffer<_Tp> __buf(__m);\n-        return __except_handler([&__exec, __n, __m, __first, __middle, __last, __is_vector, &__buf]() {\n+        return __internal::__except_handler([&__exec, __n, __m, __first, __middle, __last, __is_vector, &__buf]() {\n             _Tp* __result = __buf.get();\n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __middle,\n                                           [__first, __result, __is_vector](_ForwardIterator __b, _ForwardIterator __e) {\n-                                              __brick_uninitialized_move(__b, __e, __result + (__b - __first),\n+                                              __internal::__brick_uninitialized_move(__b, __e, __result + (__b - __first),\n                                                                          __is_vector);\n                                           });\n \n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __middle, __last,\n                                           [__first, __middle, __is_vector](_ForwardIterator __b, _ForwardIterator __e) {\n-                                              __brick_move(__b, __e, __first + (__b - __middle), __is_vector);\n+                                              __internal::__brick_move(__b, __e, __first + (__b - __middle), __is_vector);\n                                           });\n \n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,\n                                           [__n, __m, __first, __result, __is_vector](_Tp* __b, _Tp* __e) {\n-                                              __brick_move(__b, __e, __first + ((__n - __m) + (__b - __result)),\n+                                              __internal::__brick_move(__b, __e, __first + ((__n - __m) + (__b - __result)),\n                                                            __is_vector);\n                                           });\n \n@@ -1609,16 +1610,16 @@ _OutputIterator\n __brick_rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n                     _OutputIterator __result, /*__is_vector=*/std::true_type) noexcept\n {\n-    _OutputIterator __res = __brick_copy(__middle, __last, __result, std::true_type());\n-    return __brick_copy(__first, __middle, __res, std::true_type());\n+    _OutputIterator __res = __internal::__brick_copy(__middle, __last, __result, std::true_type());\n+    return __internal::__brick_copy(__first, __middle, __res, std::true_type());\n }\n \n template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _IsVector>\n _OutputIterator\n __pattern_rotate_copy(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n                       _OutputIterator __result, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_rotate_copy(__first, __middle, __last, __result, __is_vector);\n+    return __internal::__brick_rotate_copy(__first, __middle, __last, __result, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1633,19 +1634,19 @@ __pattern_rotate_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forw\n         [__first, __last, __middle, __result, __is_vector](_ForwardIterator __b, _ForwardIterator __e) {\n             if (__b > __middle)\n             {\n-                __brick_copy(__b, __e, __result + (__b - __middle), __is_vector);\n+                __internal::__brick_copy(__b, __e, __result + (__b - __middle), __is_vector);\n             }\n             else\n             {\n                 _OutputIterator __new_result = __result + ((__last - __middle) + (__b - __first));\n                 if (__e < __middle)\n                 {\n-                    __brick_copy(__b, __e, __new_result, __is_vector);\n+                    __internal::__brick_copy(__b, __e, __new_result, __is_vector);\n                 }\n                 else\n                 {\n-                    __brick_copy(__b, __middle, __new_result, __is_vector);\n-                    __brick_copy(__middle, __e, __result, __is_vector);\n+                    __internal::__brick_copy(__b, __middle, __new_result, __is_vector);\n+                    __internal::__brick_copy(__middle, __e, __result, __is_vector);\n                 }\n             }\n         });\n@@ -1697,7 +1698,7 @@ bool\n __pattern_is_partitioned(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,\n                          _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_is_partitioned(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_is_partitioned(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1712,7 +1713,7 @@ __pattern_is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _F\n     }\n     else\n     {\n-        return __except_handler([&]() {\n+        return __internal::__except_handler([&]() {\n             // State of current range:\n             // broken     - current range is not partitioned by pred\n             // all_true   - all elements in current range satisfy pred\n@@ -1748,12 +1749,11 @@ __pattern_is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _F\n                     {\n                         // find first element that don't satisfy pred\n                         _ForwardIterator __x =\n-                            __brick_find_if(__i + 1, __j, __not_pred<_UnaryPredicate>(__pred), __is_vector);\n-\n+                            __internal::__brick_find_if(__i + 1, __j, __not_pred<_UnaryPredicate>(__pred), __is_vector);\n                         if (__x != __j)\n                         {\n                             // find first element after \"x\" that satisfy pred\n-                            _ForwardIterator __y = __brick_find_if(__x + 1, __j, __pred, __is_vector);\n+                            _ForwardIterator __y = __internal::__brick_find_if(__x + 1, __j, __pred, __is_vector);\n                             // if it was found then range isn't partitioned by pred\n                             if (__y != __j)\n                             {\n@@ -1773,7 +1773,7 @@ __pattern_is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _F\n                     { // if first element doesn't satisfy pred\n                         // then we should find the first element that satisfy pred.\n                         // If we found it then range isn't partitioned by pred\n-                        if (__brick_find_if(__i + 1, __j, __pred, __is_vector) != __j)\n+                        if (__internal::__brick_find_if(__i + 1, __j, __pred, __is_vector) != __j)\n                         {\n                             return __broken;\n                         }\n@@ -1826,7 +1826,7 @@ _ForwardIterator\n __pattern_partition(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,\n                     _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_partition(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_partition(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1845,7 +1845,7 @@ __pattern_partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forwar\n         _ForwardIterator __end;\n     };\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         _PartitionRange __init{__last, __last, __last};\n \n         // lambda for merging two partitioned ranges to one partitioned range\n@@ -1866,7 +1866,7 @@ __pattern_partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forwar\n                 __par_backend::__parallel_for(\n                     std::forward<_ExecutionPolicy>(__exec), __val1.__pivot, __val1.__pivot + __size1,\n                     [__val1, __val2, __size1, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {\n-                        __brick_swap_ranges(__i, __j, (__val2.__pivot - __size1) + (__i - __val1.__pivot), __is_vector);\n+                        __internal::__brick_swap_ranges(__i, __j, (__val2.__pivot - __size1) + (__i - __val1.__pivot), __is_vector);\n                     });\n                 return {__new_begin, __val2.__pivot - __size1, __val2.__end};\n             }\n@@ -1876,7 +1876,7 @@ __pattern_partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forwar\n                 __par_backend::__parallel_for(\n                     std::forward<_ExecutionPolicy>(__exec), __val1.__pivot, __val1.__pivot + __size2,\n                     [__val1, __val2, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {\n-                        __brick_swap_ranges(__i, __j, __val2.__begin + (__i - __val1.__pivot), __is_vector);\n+                        __internal::__brick_swap_ranges(__i, __j, __val2.__begin + (__i - __val1.__pivot), __is_vector);\n                     });\n                 return {__new_begin, __val1.__pivot + __size2, __val2.__end};\n             }\n@@ -1887,7 +1887,7 @@ __pattern_partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forwar\n             [__pred, __is_vector, __reductor](_ForwardIterator __i, _ForwardIterator __j,\n                                               _PartitionRange __value) -> _PartitionRange {\n                 //1. serial partition\n-                _ForwardIterator __pivot = __brick_partition(__i, __j, __pred, __is_vector);\n+                _ForwardIterator __pivot = __internal::__brick_partition(__i, __j, __pred, __is_vector);\n \n                 // 2. merging of two ranges (left and right respectively)\n                 return __reductor(__value, {__i, __pivot, __j});\n@@ -1925,7 +1925,7 @@ __pattern_stable_partition(_ExecutionPolicy&&, _BidirectionalIterator __first, _\n                            _UnaryPredicate __pred, _IsVector __is_vector,\n                            /*is_parallelization=*/std::false_type) noexcept\n {\n-    return __brick_stable_partition(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_stable_partition(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -1944,7 +1944,7 @@ __pattern_stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __f\n         _BidirectionalIterator __end;\n     };\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         _PartitionRange __init{__last, __last, __last};\n \n         // lambda for merging two partitioned ranges to one partitioned range\n@@ -1961,7 +1961,7 @@ __pattern_stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __f\n             // then we should swap the false part of left range and last part of true part of right range\n             else\n             {\n-                __brick_rotate(__val1.__pivot, __val2.__begin, __val2.__pivot, __is_vector);\n+                __internal::__brick_rotate(__val1.__pivot, __val2.__begin, __val2.__pivot, __is_vector);\n                 return {__new_begin, __val2.__pivot - __size1, __val2.__end};\n             }\n         };\n@@ -1971,7 +1971,7 @@ __pattern_stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __f\n             [&__pred, __is_vector, __reductor](_BidirectionalIterator __i, _BidirectionalIterator __j,\n                                                _PartitionRange __value) -> _PartitionRange {\n                 //1. serial stable_partition\n-                _BidirectionalIterator __pivot = __brick_stable_partition(__i, __j, __pred, __is_vector);\n+                _BidirectionalIterator __pivot = __internal::__brick_stable_partition(__i, __j, __pred, __is_vector);\n \n                 // 2. merging of two ranges (left and right respectively)\n                 return __reductor(__value, {__i, __pivot, __j});\n@@ -2013,7 +2013,7 @@ __pattern_partition_copy(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardI\n                          _OutputIterator1 __out_true, _OutputIterator2 __out_false, _UnaryPredicate __pred,\n                          _IsVector __is_vector, /*is_parallelization=*/std::false_type) noexcept\n {\n-    return __brick_partition_copy(__first, __last, __out_true, __out_false, __pred, __is_vector);\n+    return __internal::__brick_partition_copy(__first, __last, __out_true, __out_false, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2030,28 +2030,28 @@ __pattern_partition_copy(_ExecutionPolicy&& __exec, _RandomAccessIterator __firs\n     if (_DifferenceType(1) < __n)\n     {\n         __par_backend::__buffer<bool> __mask_buf(__n);\n-        return __except_handler([&__exec, __n, __first, __out_true, __out_false, __is_vector, __pred, &__mask_buf]() {\n+        return __internal::__except_handler([&__exec, __n, __first, __out_true, __out_false, __is_vector, __pred, &__mask_buf]() {\n             bool* __mask = __mask_buf.get();\n             _ReturnType __m{};\n             __par_backend::parallel_strict_scan(\n                 std::forward<_ExecutionPolicy>(__exec), __n, std::make_pair(_DifferenceType(0), _DifferenceType(0)),\n                 [=](_DifferenceType __i, _DifferenceType __len) { // Reduce\n-                    return __brick_calc_mask_1<_DifferenceType>(__first + __i, __first + (__i + __len), __mask + __i,\n+                    return __internal::__brick_calc_mask_1<_DifferenceType>(__first + __i, __first + (__i + __len), __mask + __i,\n                                                                 __pred, __is_vector);\n                 },\n                 [](const _ReturnType& __x, const _ReturnType& __y) -> _ReturnType {\n                     return std::make_pair(__x.first + __y.first, __x.second + __y.second);\n                 },                                                                       // Combine\n                 [=](_DifferenceType __i, _DifferenceType __len, _ReturnType __initial) { // Scan\n-                    __brick_partition_by_mask(__first + __i, __first + (__i + __len), __out_true + __initial.first,\n+                    __internal::__brick_partition_by_mask(__first + __i, __first + (__i + __len), __out_true + __initial.first,\n                                               __out_false + __initial.second, __mask + __i, __is_vector);\n                 },\n                 [&__m](_ReturnType __total) { __m = __total; });\n             return std::make_pair(__out_true + __m.first, __out_false + __m.second);\n         });\n     }\n     // trivial sequence - use serial algorithm\n-    return __brick_partition_copy(__first, __last, __out_true, __out_false, __pred, __is_vector);\n+    return __internal::__brick_partition_copy(__first, __last, __out_true, __out_false, __pred, __is_vector);\n }\n #endif\n \n@@ -2074,7 +2074,7 @@ void\n __pattern_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n                _IsVector /*is_vector*/, /*is_parallel=*/std::true_type, /*is_move_constructible=*/std::true_type)\n {\n-    __except_handler([&]() {\n+    __internal::__except_handler([&]() {\n         __par_backend::__parallel_stable_sort(std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n                                               [](_RandomAccessIterator __first, _RandomAccessIterator __last,\n                                                  _Compare __comp) { std::sort(__first, __last, __comp); },\n@@ -2101,7 +2101,7 @@ void\n __pattern_stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last,\n                       _Compare __comp, _IsVector /*is_vector*/, /*is_parallel=*/std::true_type)\n {\n-    __except_handler([&]() {\n+    __internal::__except_handler([&]() {\n         __par_backend::__parallel_stable_sort(std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n                                               [](_RandomAccessIterator __first, _RandomAccessIterator __last,\n                                                  _Compare __comp) { std::stable_sort(__first, __last, __comp); });\n@@ -2129,7 +2129,7 @@ __pattern_partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n                        _RandomAccessIterator __last, _Compare __comp, _IsVector, /*is_parallel=*/std::true_type)\n {\n     const auto __n = __middle - __first;\n-    __except_handler([&]() {\n+    __internal::__except_handler([&]() {\n         __par_backend::__parallel_stable_sort(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n             [__n](_RandomAccessIterator __begin, _RandomAccessIterator __end, _Compare __comp) {\n@@ -2169,7 +2169,7 @@ __pattern_partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first,\n     }\n     auto __n1 = __last - __first;\n     auto __n2 = __d_last - __d_first;\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         if (__n2 >= __n1)\n         {\n             __par_backend::__parallel_stable_sort(\n@@ -2181,7 +2181,7 @@ __pattern_partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first,\n \n                 // 1. Copy elements from input to output\n #if !__PSTL_ICC_18_OMP_SIMD_BROKEN\n-                    __brick_copy(__i1, __j1, __i, __is_vector);\n+                    __internal::__brick_copy(__i1, __j1, __i, __is_vector);\n #else\n                     std::copy(__i1, __j1, __i);\n #endif\n@@ -2219,7 +2219,7 @@ __pattern_partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first,\n             // 3. Move elements from temporary __buffer to output\n             __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __r, __r + __n2,\n                                           [__r, __d_first, __is_vector](_T1* __i, _T1* __j) {\n-                                              __brick_move(__i, __j, __d_first + (__i - __r), __is_vector);\n+                                              __internal::__brick_move(__i, __j, __d_first + (__i - __r), __is_vector);\n                                           });\n             return __d_first + __n2;\n         }\n@@ -2251,7 +2251,7 @@ _ForwardIterator\n __pattern_adjacent_find(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred,\n                         /* is_parallel */ std::false_type, _IsVector __is_vector, bool __or_semantic) noexcept\n {\n-    return __brick_adjacent_find(__first, __last, __pred, __is_vector, __or_semantic);\n+    return __internal::__brick_adjacent_find(__first, __last, __pred, __is_vector, __or_semantic);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2264,7 +2264,7 @@ __pattern_adjacent_find(_ExecutionPolicy&& __exec, _RandomAccessIterator __first\n     if (__last - __first < 2)\n         return __last;\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         return __par_backend::__parallel_reduce(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last, __last,\n             [__last, __pred, __is_vector, __or_semantic](_RandomAccessIterator __begin, _RandomAccessIterator __end,\n@@ -2288,7 +2288,7 @@ __pattern_adjacent_find(_ExecutionPolicy&& __exec, _RandomAccessIterator __first\n \n                     //correct the global result iterator if the \"brick\" returns a local \"__last\"\n                     const _RandomAccessIterator __res =\n-                        __brick_adjacent_find(__begin, __end, __pred, __is_vector, __or_semantic);\n+                        __internal::__brick_adjacent_find(__begin, __end, __pred, __is_vector, __or_semantic);\n                     if (__res < __end)\n                         __value = __res;\n                 }\n@@ -2332,7 +2332,7 @@ __pattern_nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n     _RandomAccessIterator __x;\n     do\n     {\n-        __x = __pattern_partition(std::forward<_ExecutionPolicy>(__exec), __first + 1, __last,\n+        __x = __internal::__pattern_partition(std::forward<_ExecutionPolicy>(__exec), __first + 1, __last,\n                                   [&__comp, __first](const _Tp& __x) { return __comp(__x, *__first); }, __is_vector,\n                                   /*is_parallel=*/std::true_type());\n         --__x;\n@@ -2387,7 +2387,7 @@ void\n __pattern_fill(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value,\n                /*is_parallel=*/std::false_type, _IsVector __is_vector) noexcept\n {\n-    __brick_fill(__first, __last, __value, __is_vector);\n+    __internal::__brick_fill(__first, __last, __value, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2396,10 +2396,10 @@ _ForwardIterator\n __pattern_fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value,\n                /*is_parallel=*/std::true_type, _IsVector __is_vector)\n {\n-    return __except_handler([&__exec, __first, __last, &__value, __is_vector]() {\n+    return __internal::__except_handler([&__exec, __first, __last, &__value, __is_vector]() {\n         __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                                       [&__value, __is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n-                                          __brick_fill(__begin, __end, __value, __is_vector);\n+                                          __internal::__brick_fill(__begin, __end, __value, __is_vector);\n                                       });\n         return __last;\n     });\n@@ -2425,15 +2425,15 @@ _OutputIterator\n __pattern_fill_n(_ExecutionPolicy&&, _OutputIterator __first, _Size __count, const _Tp& __value,\n                  /*is_parallel=*/std::false_type, _IsVector __is_vector) noexcept\n {\n-    return __brick_fill_n(__first, __count, __value, __is_vector);\n+    return __internal::__brick_fill_n(__first, __count, __value, __is_vector);\n }\n \n template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp, class _IsVector>\n _OutputIterator\n __pattern_fill_n(_ExecutionPolicy&& __exec, _OutputIterator __first, _Size __count, const _Tp& __value,\n                  /*is_parallel=*/std::true_type, _IsVector __is_vector)\n {\n-    return __pattern_fill(std::forward<_ExecutionPolicy>(__exec), __first, __first + __count, __value, std::true_type(),\n+    return __internal::__pattern_fill(std::forward<_ExecutionPolicy>(__exec), __first, __first + __count, __value, std::true_type(),\n                           __is_vector);\n }\n \n@@ -2461,7 +2461,7 @@ void\n __pattern_generate(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Generator __g,\n                    /*is_parallel=*/std::false_type, _IsVector __is_vector) noexcept\n {\n-    __brick_generate(__first, __last, __g, __is_vector);\n+    __internal::__brick_generate(__first, __last, __g, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2470,10 +2470,10 @@ _ForwardIterator\n __pattern_generate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Generator __g,\n                    /*is_parallel=*/std::true_type, _IsVector __is_vector)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                                       [__g, __is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n-                                          __brick_generate(__begin, __end, __g, __is_vector);\n+                                          __internal::__brick_generate(__begin, __end, __g, __is_vector);\n                                       });\n         return __last;\n     });\n@@ -2499,7 +2499,7 @@ _OutputIterator\n __pattern_generate_n(_ExecutionPolicy&&, _OutputIterator __first, _Size __count, _Generator __g,\n                      /*is_parallel=*/std::false_type, _IsVector __is_vector) noexcept\n {\n-    return __brick_generate_n(__first, __count, __g, __is_vector);\n+    return __internal::__brick_generate_n(__first, __count, __g, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2510,7 +2510,7 @@ __pattern_generate_n(_ExecutionPolicy&& __exec, _OutputIterator __first, _Size _\n {\n     static_assert(__is_random_access_iterator<_OutputIterator>::value,\n                   \"Pattern-brick error. Should be a random access iterator.\");\n-    return __pattern_generate(std::forward<_ExecutionPolicy>(__exec), __first, __first + __count, __g, std::true_type(),\n+    return __internal::__pattern_generate(std::forward<_ExecutionPolicy>(__exec), __first, __first + __count, __g, std::true_type(),\n                               __is_vector);\n }\n #endif\n@@ -2544,7 +2544,7 @@ _ForwardIterator\n __pattern_remove_if(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,\n                     _IsVector __is_vector, /*is_parallel*/ std::false_type) noexcept\n {\n-    return __brick_remove_if(__first, __last, __pred, __is_vector);\n+    return __internal::__brick_remove_if(__first, __last, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2558,12 +2558,12 @@ __pattern_remove_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Forwar\n     if (__first == __last || __first + 1 == __last)\n     {\n         // Trivial sequence - use serial algorithm\n-        return __brick_remove_if(__first, __last, __pred, __is_vector);\n+        return __internal::__brick_remove_if(__first, __last, __pred, __is_vector);\n     }\n \n-    return remove_elements(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+    return __internal::__remove_elements(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n                            [&__pred, __is_vector](bool* __b, bool* __e, _ForwardIterator __it) {\n-                               __brick_walk2(__b, __e, __it,\n+                               __internal::__brick_walk2(__b, __e, __it,\n                                              [&__pred](bool& __x, _ReferenceType __y) { __x = !__pred(__y); },\n                                              __is_vector);\n                            },\n@@ -2601,7 +2601,7 @@ __pattern_merge(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIterator\n                 _ForwardIterator2 __last2, _OutputIterator __d_first, _Compare __comp, _IsVector __is_vector,\n                 /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_merge(__first1, __last1, __first2, __last2, __d_first, __comp, __is_vector);\n+    return __internal::__brick_merge(__first1, __last1, __first2, __last2, __d_first, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2616,7 +2616,7 @@ __pattern_merge(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _Ran\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __d_first, __comp,\n         [__is_vector](_RandomAccessIterator1 __f1, _RandomAccessIterator1 __l1, _RandomAccessIterator2 __f2,\n                       _RandomAccessIterator2 __l2, _OutputIterator __f3,\n-                      _Compare __comp) { return __brick_merge(__f1, __l1, __f2, __l2, __f3, __comp, __is_vector); });\n+                      _Compare __comp) { return __internal::__brick_merge(__f1, __l1, __f2, __l2, __f3, __comp, __is_vector); });\n     return __d_first + (__last1 - __first1) + (__last2 - __first2);\n }\n #endif\n@@ -2647,7 +2647,7 @@ __pattern_inplace_merge(_ExecutionPolicy&&, _BidirectionalIterator __first, _Bid\n                         _BidirectionalIterator __last, _Compare __comp, _IsVector __is_vector,\n                         /* is_parallel = */ std::false_type) noexcept\n {\n-    __brick_inplace_merge(__first, __middle, __last, __comp, __is_vector);\n+    __internal::__brick_inplace_merge(__first, __middle, __last, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -2665,14 +2665,14 @@ __pattern_inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __firs\n     auto __n = __last - __first;\n     __par_backend::__buffer<_Tp> __buf(__n);\n     _Tp* __r = __buf.get();\n-    __except_handler([&]() {\n+    __internal::__except_handler([&]() {\n         auto __move_values = [](_BidirectionalIterator __x, _Tp* __z) {\n-            __invoke_if_else(std::is_trivial<_Tp>(), [&]() { *__z = std::move(*__x); },\n-                             [&]() { ::new (std::addressof(*__z)) _Tp(std::move(*__x)); });\n+                                 __internal::__invoke_if_else(std::is_trivial<_Tp>(), [&]() { *__z = std::move(*__x); },\n+                                                              [&]() { ::new (std::addressof(*__z)) _Tp(std::move(*__x)); });\n         };\n \n         auto __move_sequences = [](_BidirectionalIterator __first1, _BidirectionalIterator __last1, _Tp* __first2) {\n-            return __brick_uninitialized_move(__first1, __last1, __first2, _IsVector());\n+            return __internal::__brick_uninitialized_move(__first1, __last1, __first2, _IsVector());\n         };\n \n         __par_backend::__parallel_merge(\n@@ -2685,9 +2685,10 @@ __pattern_inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __firs\n                 __func(__f1, __l1, __f2, __l2, __f3, __comp);\n                 return __f3 + (__l1 - __f1) + (__l2 - __f2);\n             });\n+\n         __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __r, __r + __n,\n                                       [__r, __first, __is_vector](_Tp* __i, _Tp* __j) {\n-                                          __brick_move(__i, __j, __first + (__i - __r), __is_vector);\n+                                          __internal::__brick_move(__i, __j, __first + (__i - __r), __is_vector);\n                                       });\n     });\n }\n@@ -2726,8 +2727,8 @@ __pattern_includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forwa\n     if (__last2 - __first2 == 1)\n         return !__comp(*__first1, *__first2) && !__comp(*__first2, *__first1);\n \n-    return __except_handler([&]() {\n-        return !__parallel_or(\n+    return __internal::__except_handler([&]() {\n+         return !__internal::__parallel_or(\n             std::forward<_ExecutionPolicy>(__exec), __first2, __last2,\n             [__first1, __last1, __first2, __last2, &__comp](_ForwardIterator2 __i, _ForwardIterator2 __j) {\n                 assert(__j > __i);\n@@ -2791,13 +2792,13 @@ __parallel_set_op(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forwar\n \n     __par_backend::__buffer<_T> __buf(__size_func(__n1, __n2));\n \n-    return __except_handler([&__exec, __n1, __first1, __last1, __first2, __last2, __result, __is_vector, __comp,\n+    return __internal::__except_handler([&__exec, __n1, __first1, __last1, __first2, __last2, __result, __is_vector, __comp,\n                              __size_func, __set_op, &__buf]() {\n         auto __buffer = __buf.get();\n         _DifferenceType __m{};\n         auto __scan = [=](_DifferenceType, _DifferenceType, const _SetRange& __s) { // Scan\n             if (!__s.empty())\n-                __brick_move(__buffer + __s.__buf_pos, __buffer + (__s.__buf_pos + __s.__len), __result + __s.__pos,\n+                __internal::__brick_move(__buffer + __s.__buf_pos, __buffer + (__s.__buf_pos + __s.__len), __result + __s.__pos,\n                              __is_vector);\n         };\n         __par_backend::parallel_strict_scan(\n@@ -2871,54 +2872,54 @@ __parallel_set_union_op(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _\n     const auto __n2 = __last2 - __first2;\n \n     auto copy_range1 = [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _OutputIterator __res) {\n-        return __brick_copy(__begin, __end, __res, __is_vector);\n+        return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n     };\n     auto copy_range2 = [__is_vector](_ForwardIterator2 __begin, _ForwardIterator2 __end, _OutputIterator __res) {\n-        return __brick_copy(__begin, __end, __res, __is_vector);\n+        return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n     };\n \n     // {1} {}: parallel copying just first sequence\n     if (__n2 == 0)\n-        return __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result, copy_range1,\n+        return __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result, copy_range1,\n                                      std::true_type());\n \n     // {} {2}: parallel copying justmake  second sequence\n     if (__n1 == 0)\n-        return __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2, __last2, __result, copy_range2,\n+        return __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2, __last2, __result, copy_range2,\n                                      std::true_type());\n \n     // testing  whether the sequences are intersected\n-    _ForwardIterator1 __left_bound_seq_1 = lower_bound(__first1, __last1, *__first2, __comp);\n+    _ForwardIterator1 __left_bound_seq_1 = std::lower_bound(__first1, __last1, *__first2, __comp);\n \n     if (__left_bound_seq_1 == __last1)\n     {\n         //{1} < {2}: seq2 is wholly greater than seq1, so, do parallel copying seq1 and seq2\n         __par_backend::__parallel_invoke(std::forward<_ExecutionPolicy>(__exec),\n                                          [=] {\n-                                             __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1,\n+                                             __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1,\n                                                                    __last1, __result, copy_range1, std::true_type());\n                                          },\n                                          [=] {\n-                                             __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2,\n+                                             __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2,\n                                                                    __last2, __result + __n1, copy_range2,\n                                                                    std::true_type());\n                                          });\n         return __result + __n1 + __n2;\n     }\n \n     // testing  whether the sequences are intersected\n-    _ForwardIterator2 __left_bound_seq_2 = lower_bound(__first2, __last2, *__first1, __comp);\n+    _ForwardIterator2 __left_bound_seq_2 = std::lower_bound(__first2, __last2, *__first1, __comp);\n \n     if (__left_bound_seq_2 == __last2)\n     {\n         //{2} < {1}: seq2 is wholly greater than seq1, so, do parallel copying seq1 and seq2\n         __par_backend::__parallel_invoke(std::forward<_ExecutionPolicy>(__exec),\n                                          [=] {\n-                                             __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2,\n+                                             __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2,\n                                                                    __last2, __result, copy_range2, std::true_type());\n                                          },\n                                          [=] {\n-                                             __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1,\n+                                             __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1,\n                                                                    __last1, __result + __n2, copy_range1,\n                                                                    std::true_type());\n                                          });\n@@ -2934,11 +2935,11 @@ __parallel_set_union_op(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _\n             std::forward<_ExecutionPolicy>(__exec),\n             //do parallel copying of [first1; left_bound_seq_1)\n             [=] {\n-                __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1, __left_bound_seq_1, __res_or,\n+                __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first1, __left_bound_seq_1, __res_or,\n                                       copy_range1, std::true_type());\n             },\n             [=, &__result] {\n-                __result = __parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __left_bound_seq_1, __last1,\n+                __result = __internal::__parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __left_bound_seq_1, __last1,\n                                              __first2, __last2, __result, __comp,\n                                              [](_DifferenceType __n, _DifferenceType __m) { return __n + __m; },\n                                              __set_union_op, __is_vector);\n@@ -2956,19 +2957,19 @@ __parallel_set_union_op(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _\n             std::forward<_ExecutionPolicy>(__exec),\n             //do parallel copying of [first2; left_bound_seq_2)\n             [=] {\n-                __pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2, __left_bound_seq_2, __res_or,\n+                __internal::__pattern_walk2_brick(std::forward<_ExecutionPolicy>(__exec), __first2, __left_bound_seq_2, __res_or,\n                                       copy_range2, std::true_type());\n             },\n             [=, &__result] {\n-                __result = __parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n+                __result = __internal::__parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n                                              __left_bound_seq_2, __last2, __result, __comp,\n                                              [](_DifferenceType __n, _DifferenceType __m) { return __n + __m; },\n                                              __set_union_op, __is_vector);\n             });\n         return __result;\n     }\n \n-    return __parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+    return __internal::__parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n                              __comp, [](_DifferenceType __n, _DifferenceType __m) { return __n + __m; }, __set_union_op,\n                              __is_vector);\n }\n@@ -3005,7 +3006,7 @@ __pattern_set_union(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIter\n                     _IsVector __is_vector,\n                     /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_set_union(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n+    return __internal::__brick_set_union(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3025,7 +3026,7 @@ __pattern_set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _Forw\n         return std::set_union(__first1, __last1, __first2, __last2, __result, __comp);\n \n     typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n-    return __parallel_set_union_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+    return __internal::__parallel_set_union_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n                                  __comp,\n                                  [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n                                     _ForwardIterator2 __last2, _T* __result, _Compare __comp) {\n@@ -3065,7 +3066,7 @@ __pattern_set_intersection(_ExecutionPolicy&&, _ForwardIterator1 __first1, _Forw\n                            _ForwardIterator2 __first2, _ForwardIterator2 __last2, _OutputIterator __result,\n                            _Compare __comp, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_set_intersection(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n+    return __internal::__brick_set_intersection(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3087,13 +3088,13 @@ __pattern_set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1\n         return __result;\n \n     // testing  whether the sequences are intersected\n-    _ForwardIterator1 __left_bound_seq_1 = lower_bound(__first1, __last1, *__first2, __comp);\n+    _ForwardIterator1 __left_bound_seq_1 = std::lower_bound(__first1, __last1, *__first2, __comp);\n     //{1} < {2}: seq 2 is wholly greater than seq 1, so, the intersection is empty\n     if (__left_bound_seq_1 == __last1)\n         return __result;\n \n     // testing  whether the sequences are intersected\n-    _ForwardIterator2 __left_bound_seq_2 = lower_bound(__first2, __last2, *__first1, __comp);\n+    _ForwardIterator2 __left_bound_seq_2 = std::lower_bound(__first2, __last2, *__first1, __comp);\n     //{2} < {1}: seq 1 is wholly greater than seq 2, so, the intersection is empty\n     if (__left_bound_seq_2 == __last2)\n         return __result;\n@@ -3102,7 +3103,7 @@ __pattern_set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1\n     if (__m1 > __set_algo_cut_off)\n     {\n         //we know proper offset due to [first1; left_bound_seq_1) < [first2; last2)\n-        return __parallel_set_op(\n+        return __internal::__parallel_set_op(\n             std::forward<_ExecutionPolicy>(__exec), __left_bound_seq_1, __last1, __first2, __last2, __result, __comp,\n             [](_DifferenceType __n, _DifferenceType __m) { return std::min(__n, __m); },\n             [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n@@ -3116,7 +3117,7 @@ __pattern_set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1\n     if (__m2 > __set_algo_cut_off)\n     {\n         //we know proper offset due to [first2; left_bound_seq_2) < [first1; last1)\n-        __result = __parallel_set_op(\n+        __result = __internal::__parallel_set_op(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __left_bound_seq_2, __last2, __result, __comp,\n             [](_DifferenceType __n, _DifferenceType __m) { return std::min(__n, __m); },\n             [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n@@ -3162,7 +3163,7 @@ __pattern_set_difference(_ExecutionPolicy&&, _ForwardIterator1 __first1, _Forwar\n                          _ForwardIterator2 __first2, _ForwardIterator2 __last2, _OutputIterator __result,\n                          _Compare __comp, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_set_difference(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n+    return __internal::__brick_set_difference(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3185,37 +3186,37 @@ __pattern_set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1,\n \n     // {1} \\ {}: parallel copying just first sequence\n     if (__n2 == 0)\n-        return __pattern_walk2_brick(\n+        return __internal::__pattern_walk2_brick(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,\n             [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _OutputIterator __res) {\n-                return __brick_copy(__begin, __end, __res, __is_vector);\n+                return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n             },\n             std::true_type());\n \n     // testing  whether the sequences are intersected\n-    _ForwardIterator1 __left_bound_seq_1 = lower_bound(__first1, __last1, *__first2, __comp);\n+    _ForwardIterator1 __left_bound_seq_1 = std::lower_bound(__first1, __last1, *__first2, __comp);\n     //{1} < {2}: seq 2 is wholly greater than seq 1, so, parallel copying just first sequence\n     if (__left_bound_seq_1 == __last1)\n-        return __pattern_walk2_brick(\n+        return __internal::__pattern_walk2_brick(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,\n             [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _OutputIterator __res) {\n-                return __brick_copy(__begin, __end, __res, __is_vector);\n+                return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n             },\n             std::true_type());\n \n     // testing  whether the sequences are intersected\n-    _ForwardIterator2 __left_bound_seq_2 = lower_bound(__first2, __last2, *__first1, __comp);\n+    _ForwardIterator2 __left_bound_seq_2 = std::lower_bound(__first2, __last2, *__first1, __comp);\n     //{2} < {1}: seq 1 is wholly greater than seq 2, so, parallel copying just first sequence\n     if (__left_bound_seq_2 == __last2)\n-        return __pattern_walk2_brick(\n+        return __internal::__pattern_walk2_brick(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,\n             [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _OutputIterator __res) {\n-                return __brick_copy(__begin, __end, __res, __is_vector);\n+                return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n             },\n             std::true_type());\n \n     if (__n1 + __n2 > __set_algo_cut_off)\n-        return __parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+        return __internal::__parallel_set_op(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n                                  __comp, [](_DifferenceType __n, _DifferenceType __m) { return __n; },\n                                  [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n                                     _ForwardIterator2 __last2, _T* __result, _Compare __comp) {\n@@ -3258,7 +3259,7 @@ __pattern_set_symmetric_difference(_ExecutionPolicy&&, _ForwardIterator1 __first\n                                    _ForwardIterator2 __first2, _ForwardIterator2 __last2, _OutputIterator __result,\n                                    _Compare __comp, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n+    return __internal::__brick_set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3278,7 +3279,7 @@ __pattern_set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1\n         return std::set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);\n \n     typedef typename std::iterator_traits<_OutputIterator>::value_type _T;\n-    return __parallel_set_union_op(\n+    return __internal::__parallel_set_union_op(\n         std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n         [](_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n            _T* __result, _Compare __comp) {\n@@ -3318,7 +3319,7 @@ _RandomAccessIterator\n __pattern_is_heap_until(_ExecutionPolicy&&, _RandomAccessIterator __first, _RandomAccessIterator __last,\n                         _Compare __comp, _IsVector __is_vector, /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_is_heap_until(__first, __last, __comp, __is_vector);\n+    return __internal::__brick_is_heap_until(__first, __last, __comp, __is_vector);\n }\n \n template <class _RandomAccessIterator, class _DifferenceType, class _Compare>\n@@ -3356,11 +3357,11 @@ __pattern_is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first\n     if (__last - __first < 2)\n         return __last;\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         return __parallel_find(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last,\n             [__first, __comp, __is_vector](_RandomAccessIterator __i, _RandomAccessIterator __j) {\n-                return __is_heap_until_local(__first, __i - __first, __j - __first, __comp, __is_vector);\n+                return __internal::__is_heap_until_local(__first, __i - __first, __j - __first, __comp, __is_vector);\n             },\n             std::less<typename std::iterator_traits<_RandomAccessIterator>::difference_type>(), /*is_first=*/true);\n     });\n@@ -3396,7 +3397,7 @@ _ForwardIterator\n __pattern_min_element(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp,\n                       _IsVector __is_vector, /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_min_element(__first, __last, __comp, __is_vector);\n+    return __internal::__brick_min_element(__first, __last, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3408,16 +3409,16 @@ __pattern_min_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first,\n     if (__first == __last)\n         return __last;\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         return __par_backend::__parallel_reduce(\n             std::forward<_ExecutionPolicy>(__exec), __first + 1, __last, __first,\n             [=](_RandomAccessIterator __begin, _RandomAccessIterator __end,\n                 _RandomAccessIterator __init) -> _RandomAccessIterator {\n-                const _RandomAccessIterator subresult = __brick_min_element(__begin, __end, __comp, __is_vector);\n-                return __cmp_iterators_by_values(__init, subresult, __comp);\n+                const _RandomAccessIterator subresult = __internal::__brick_min_element(__begin, __end, __comp, __is_vector);\n+                return __internal::__cmp_iterators_by_values(__init, subresult, __comp);\n             },\n             [=](_RandomAccessIterator __it1, _RandomAccessIterator __it2) -> _RandomAccessIterator {\n-                return __cmp_iterators_by_values(__it1, __it2, __comp);\n+                return __internal::__cmp_iterators_by_values(__it1, __it2, __comp);\n             });\n     });\n }\n@@ -3452,7 +3453,7 @@ std::pair<_ForwardIterator, _ForwardIterator>\n __pattern_minmax_element(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp,\n                          _IsVector __is_vector, /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_minmax_element(__first, __last, __comp, __is_vector);\n+    return __internal::__brick_minmax_element(__first, __last, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3464,21 +3465,21 @@ __pattern_minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _F\n     if (__first == __last)\n         return std::make_pair(__first, __first);\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         typedef std::pair<_ForwardIterator, _ForwardIterator> _Result;\n \n         return __par_backend::__parallel_reduce(\n             std::forward<_ExecutionPolicy>(__exec), __first + 1, __last, std::make_pair(__first, __first),\n             [=](_ForwardIterator __begin, _ForwardIterator __end, _Result __init) -> _Result {\n-                const _Result __subresult = __brick_minmax_element(__begin, __end, __comp, __is_vector);\n+                const _Result __subresult = __internal::__brick_minmax_element(__begin, __end, __comp, __is_vector);\n                 return std::make_pair(\n-                    __cmp_iterators_by_values(__subresult.first, __init.first, __comp),\n-                    __cmp_iterators_by_values(__init.second, __subresult.second, __not_pred<_Compare>(__comp)));\n+                    __internal::__cmp_iterators_by_values(__subresult.first, __init.first, __comp),\n+                    __internal::__cmp_iterators_by_values(__init.second, __subresult.second, __not_pred<_Compare>(__comp)));\n             },\n             [=](_Result __p1, _Result __p2) -> _Result {\n                 return std::make_pair(\n-                    __cmp_iterators_by_values(__p1.first, __p2.first, __comp),\n-                    __cmp_iterators_by_values(__p2.second, __p1.second, __not_pred<_Compare>(__comp)));\n+                    __internal::__cmp_iterators_by_values(__p1.first, __p2.first, __comp),\n+                    __internal::__cmp_iterators_by_values(__p2.second, __p1.second, __not_pred<_Compare>(__comp)));\n             });\n     });\n }\n@@ -3525,7 +3526,7 @@ __pattern_mismatch(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardItera\n                    _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Predicate __pred, _IsVector __is_vector,\n                    /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_mismatch(__first1, __last1, __first2, __last2, __pred, __is_vector);\n+    return __internal::__brick_mismatch(__first1, __last1, __first2, __last2, __pred, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3536,12 +3537,12 @@ __pattern_mismatch(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _\n                    _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _Predicate __pred,\n                    _IsVector __is_vector, /* is_parallel = */ std::true_type) noexcept\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         auto __n = std::min(__last1 - __first1, __last2 - __first2);\n-        auto __result = __parallel_find(\n+        auto __result = __internal::__parallel_find(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + __n,\n             [__first1, __first2, __pred, __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j) {\n-                return __brick_mismatch(__i, __j, __first2 + (__i - __first1), __first2 + (__j - __first1), __pred,\n+                return __internal::__brick_mismatch(__i, __j, __first2 + (__i - __first1), __first2 + (__j - __first1), __pred,\n                                         __is_vector)\n                     .first;\n             },\n@@ -3606,7 +3607,7 @@ __pattern_lexicographical_compare(_ExecutionPolicy&&, _ForwardIterator1 __first1\n                                   _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp,\n                                   _IsVector __is_vector, /* is_parallel = */ std::false_type) noexcept\n {\n-    return __brick_lexicographical_compare(__first1, __last1, __first2, __last2, __comp, __is_vector);\n+    return __internal::__brick_lexicographical_compare(__first1, __last1, __first2, __last2, __comp, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -3631,10 +3632,10 @@ __pattern_lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 _\n         --__last1;\n         --__last2;\n         auto __n = std::min(__last1 - __first1, __last2 - __first2);\n-        auto __result = __parallel_find(\n+        auto __result = __internal::__parallel_find(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + __n,\n             [__first1, __first2, &__comp, __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {\n-                return __brick_mismatch(__i, __j, __first2 + (__i - __first1), __first2 + (__j - __first1),\n+                return __internal::__brick_mismatch(__i, __j, __first2 + (__i - __first1), __first2 + (__j - __first1),\n                                         [&__comp](const _RefType1 __x, const _RefType2 __y) {\n                                             return !__comp(__x, __y) && !__comp(__y, __x);\n                                         },"}, {"sha": "9a4b49bd46a15156624307d0131c01fca3354ac0", "filename": "libstdc++-v3/include/pstl/execution_defs.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_defs.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -123,27 +123,27 @@ struct is_execution_policy : std::false_type\n };\n \n template <>\n-struct is_execution_policy<sequenced_policy> : std::true_type\n+struct is_execution_policy<__pstl::execution::sequenced_policy> : std::true_type\n {\n };\n #if __PSTL_USE_PAR_POLICIES\n template <>\n-struct is_execution_policy<parallel_policy> : std::true_type\n+struct is_execution_policy<__pstl::execution::parallel_policy> : std::true_type\n {\n };\n template <>\n-struct is_execution_policy<parallel_unsequenced_policy> : std::true_type\n+struct is_execution_policy<__pstl::execution::parallel_unsequenced_policy> : std::true_type\n {\n };\n #endif\n template <>\n-struct is_execution_policy<unsequenced_policy> : std::true_type\n+struct is_execution_policy<__pstl::execution::unsequenced_policy> : std::true_type\n {\n };\n \n #if __PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT\n template <class T>\n-constexpr bool is_execution_policy_v = is_execution_policy<T>::value;\n+constexpr bool is_execution_policy_v = __pstl::execution::is_execution_policy<T>::value;\n #endif\n \n } // namespace v1"}, {"sha": "8ee5fa062a8716b441e92b960a6d695be294cca3", "filename": "libstdc++-v3/include/pstl/execution_impl.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -55,7 +55,7 @@ template <typename _IteratorType, typename... _OtherIteratorTypes>\n struct __is_random_access_iterator\n {\n     static constexpr bool value =\n-        __is_random_access_iterator<_IteratorType>::value && __is_random_access_iterator<_OtherIteratorTypes...>::value;\n+      __internal::__is_random_access_iterator<_IteratorType>::value && __internal::__is_random_access_iterator<_OtherIteratorTypes...>::value;\n     typedef std::integral_constant<bool, value> type;\n };\n \n@@ -106,46 +106,46 @@ struct __policy_traits<parallel_unsequenced_policy>\n #endif\n \n template <typename _ExecutionPolicy>\n-using __collector_t = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__collector_type;\n+using __collector_t = typename __internal::__policy_traits<typename std::decay<_ExecutionPolicy>::type>::__collector_type;\n \n template <typename _ExecutionPolicy>\n-using __allow_vector = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_vector;\n+using __allow_vector = typename __internal::__policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_vector;\n \n template <typename _ExecutionPolicy>\n-using __allow_unsequenced = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_unsequenced;\n+using __allow_unsequenced = typename __internal::__policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_unsequenced;\n \n template <typename _ExecutionPolicy>\n-using __allow_parallel = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_parallel;\n+using __allow_parallel = typename __internal::__policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_parallel;\n \n template <typename _ExecutionPolicy, typename... _IteratorTypes>\n auto\n __is_vectorization_preferred(_ExecutionPolicy&& __exec)\n-    -> decltype(__lazy_and(__exec.__allow_vector(), typename __is_random_access_iterator<_IteratorTypes...>::type()))\n+    -> decltype(__internal::__lazy_and(__exec.__allow_vector(), typename __internal::__is_random_access_iterator<_IteratorTypes...>::type()))\n {\n-    return __lazy_and(__exec.__allow_vector(), typename __is_random_access_iterator<_IteratorTypes...>::type());\n+    return __internal::__lazy_and(__exec.__allow_vector(), typename __internal::__is_random_access_iterator<_IteratorTypes...>::type());\n }\n \n template <typename _ExecutionPolicy, typename... _IteratorTypes>\n auto\n __is_parallelization_preferred(_ExecutionPolicy&& __exec)\n-    -> decltype(__lazy_and(__exec.__allow_parallel(), typename __is_random_access_iterator<_IteratorTypes...>::type()))\n+    -> decltype(__internal::__lazy_and(__exec.__allow_parallel(), typename __internal::__is_random_access_iterator<_IteratorTypes...>::type()))\n {\n-    return __lazy_and(__exec.__allow_parallel(), typename __is_random_access_iterator<_IteratorTypes...>::type());\n+    return __internal::__lazy_and(__exec.__allow_parallel(), typename __internal::__is_random_access_iterator<_IteratorTypes...>::type());\n }\n \n template <typename policy, typename... _IteratorTypes>\n struct __prefer_unsequenced_tag\n {\n     static constexpr bool value =\n-        __allow_unsequenced<policy>::value && __is_random_access_iterator<_IteratorTypes...>::value;\n+        __internal::__allow_unsequenced<policy>::value && __internal::__is_random_access_iterator<_IteratorTypes...>::value;\n     typedef std::integral_constant<bool, value> type;\n };\n \n template <typename policy, typename... _IteratorTypes>\n struct __prefer_parallel_tag\n {\n     static constexpr bool value =\n-        __allow_parallel<policy>::value && __is_random_access_iterator<_IteratorTypes...>::value;\n+        __internal::__allow_parallel<policy>::value && __internal::__is_random_access_iterator<_IteratorTypes...>::value;\n     typedef std::integral_constant<bool, value> type;\n };\n "}, {"sha": "49a4abf5a95c879b4e454ef5d7367f869b485038", "filename": "libstdc++-v3/include/pstl/numeric_impl.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -71,7 +71,7 @@ __pattern_transform_reduce(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __f\n                            _RandomAccessIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1,\n                            _BinaryOperation2 __binary_op2, _IsVector __is_vector, /*is_parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         return __par_backend::__parallel_transform_reduce(\n             std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n             [__first1, __first2, __binary_op2](_RandomAccessIterator1 __i) mutable {\n@@ -81,7 +81,7 @@ __pattern_transform_reduce(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __f\n             __binary_op1, // Combine\n             [__first1, __first2, __binary_op1, __binary_op2,\n              __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j, _Tp __init) -> _Tp {\n-                return __brick_transform_reduce(__i, __j, __first2 + (__i - __first1), __init, __binary_op1,\n+                return __internal::__brick_transform_reduce(__i, __j, __first2 + (__i - __first1), __init, __binary_op1,\n                                                 __binary_op2, __is_vector);\n             });\n     });\n@@ -122,7 +122,7 @@ __pattern_transform_reduce(_ExecutionPolicy&&, _ForwardIterator __first, _Forwar\n                            _BinaryOperation __binary_op, _UnaryOperation __unary_op, _IsVector __is_vector,\n                            /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_transform_reduce(__first, __last, __init, __binary_op, __unary_op, __is_vector);\n+    return __internal::__brick_transform_reduce(__first, __last, __init, __binary_op, __unary_op, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -133,12 +133,12 @@ __pattern_transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first,\n                            _BinaryOperation __binary_op, _UnaryOperation __unary_op, _IsVector __is_vector,\n                            /*is_parallel=*/std::true_type)\n {\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         return __par_backend::__parallel_transform_reduce(\n             std::forward<_ExecutionPolicy>(__exec), __first, __last,\n             [__unary_op](_ForwardIterator __i) mutable { return __unary_op(*__i); }, __init, __binary_op,\n             [__unary_op, __binary_op, __is_vector](_ForwardIterator __i, _ForwardIterator __j, _Tp __init) {\n-                return __brick_transform_reduce(__i, __j, __init, __binary_op, __unary_op, __is_vector);\n+                return __internal::__brick_transform_reduce(__i, __j, __init, __binary_op, __unary_op, __is_vector);\n             });\n     });\n }\n@@ -201,7 +201,7 @@ __brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last, _Outpu\n                                         _Inclusive());\n #else\n     // We need to call serial brick here to call function for inclusive and exclusive scan that depends on _Inclusive() value\n-    return __brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(),\n+    return __internal::__brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(),\n                                   /*is_vector=*/std::false_type());\n #endif\n }\n@@ -213,7 +213,7 @@ __brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last, _Outpu\n                        _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op, _Inclusive,\n                        /*is_vector=*/std::true_type) noexcept\n {\n-    return __brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(),\n+    return __internal::__brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(),\n                                   /*is_vector=*/std::false_type());\n }\n \n@@ -224,7 +224,7 @@ __pattern_transform_scan(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardI\n                          _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op,\n                          _Inclusive, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n {\n-    return __brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(), __is_vector)\n+    return __internal::__brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(), __is_vector)\n         .first;\n }\n \n@@ -238,19 +238,19 @@ __pattern_transform_scan(_ExecutionPolicy&& __exec, _RandomAccessIterator __firs\n {\n     typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type _DifferenceType;\n \n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::__parallel_transform_scan(\n             std::forward<_ExecutionPolicy>(__exec), __last - __first,\n             [__first, __unary_op](_DifferenceType __i) mutable { return __unary_op(__first[__i]); }, __init,\n             __binary_op,\n             [__first, __unary_op, __binary_op](_DifferenceType __i, _DifferenceType __j, _Tp __init) {\n                 // Execute serial __brick_transform_reduce, due to the explicit SIMD vectorization (reduction) requires a commutative operation for the guarantee of correct scan.\n-                return __brick_transform_reduce(__first + __i, __first + __j, __init, __binary_op, __unary_op,\n+                return __internal::__brick_transform_reduce(__first + __i, __first + __j, __init, __binary_op, __unary_op,\n                                                 /*__is_vector*/ std::false_type());\n             },\n             [__first, __unary_op, __binary_op, __result, __is_vector](_DifferenceType __i, _DifferenceType __j,\n                                                                       _Tp __init) {\n-                return __brick_transform_scan(__first + __i, __first + __j, __result + __i, __unary_op, __init,\n+                return __internal::__brick_transform_scan(__first + __i, __first + __j, __result + __i, __unary_op, __init,\n                                               __binary_op, _Inclusive(), __is_vector)\n                     .second;\n             });\n@@ -274,11 +274,11 @@ __pattern_transform_scan(_ExecutionPolicy&& __exec, _RandomAccessIterator __firs\n     {\n         return __result;\n     }\n-    return __except_handler([&]() {\n+    return __internal::__except_handler([&]() {\n         __par_backend::parallel_strict_scan(\n             std::forward<_ExecutionPolicy>(__exec), __n, __init,\n             [__first, __unary_op, __binary_op, __result, __is_vector](_DifferenceType __i, _DifferenceType __len) {\n-                return __brick_transform_scan(__first + __i, __first + (__i + __len), __result + __i, __unary_op, _Tp{},\n+                return __internal::__brick_transform_scan(__first + __i, __first + (__i + __len), __result + __i, __unary_op, _Tp{},\n                                               __binary_op, _Inclusive(), __is_vector)\n                     .second;\n             },\n@@ -333,7 +333,7 @@ __pattern_adjacent_difference(_ExecutionPolicy&&, _ForwardIterator __first, _For\n                               _OutputIterator __d_first, _BinaryOperation __op, _IsVector __is_vector,\n                               /*is_parallel*/ std::false_type) noexcept\n {\n-    return __brick_adjacent_difference(__first, __last, __d_first, __op, __is_vector);\n+    return __internal::__brick_adjacent_difference(__first, __last, __d_first, __op, __is_vector);\n }\n \n #if __PSTL_USE_PAR_POLICIES\n@@ -353,7 +353,7 @@ __pattern_adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __fir\n         std::forward<_ExecutionPolicy>(__exec), __first, __last - 1,\n         [&__op, __is_vector, __d_first, __first](_ForwardIterator1 __b, _ForwardIterator1 __e) {\n             _ForwardIterator2 __d_b = __d_first + (__b - __first);\n-            __brick_walk3(\n+            __internal::__brick_walk3(\n                 __b, __e, __b + 1, __d_b + 1,\n                 [&__op](_ReferenceType1 __x, _ReferenceType1 __y, _ReferenceType2 __z) { __z = __op(__y, __x); },\n                 __is_vector);"}, {"sha": "f09f47a8a8923d146a42745075f9baf4e0e27956", "filename": "libstdc++-v3/include/pstl/parallel_backend_tbb.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -190,7 +190,7 @@ _Tp\n __parallel_transform_reduce(_ExecutionPolicy&&, _Index __first, _Index __last, _Up __u, _Tp __init, _Cp __combine,\n                             _Rp __brick_reduce)\n {\n-    __par_trans_red_body<_Index, _Up, _Tp, _Cp, _Rp> __body(__u, __init, __combine, __brick_reduce);\n+    __par_backend::__par_trans_red_body<_Index, _Up, _Tp, _Cp, _Rp> __body(__u, __init, __combine, __brick_reduce);\n     // The grain size of 3 is used in order to provide mininum 2 elements for each body\n     tbb::this_task_arena::isolate(\n         [__first, __last, &__body]() { tbb::parallel_reduce(tbb::blocked_range<_Index>(__first, __last, 3), __body); });\n@@ -234,7 +234,7 @@ class __trans_scan_body\n     sum() const\n     {\n         __TBB_ASSERT(_M_has_sum, \"sum expected\");\n-        return *(_Tp*)_M_sum_storage;\n+        return *const_cast<_Tp*>(reinterpret_cast<_Tp const*>(_M_sum_storage));\n     }\n \n     void\n@@ -304,8 +304,8 @@ __upsweep(_Index __i, _Index __m, _Index __tilesize, _Tp* __r, _Index __lastsize\n     {\n         _Index __k = __split(__m);\n         tbb::parallel_invoke(\n-            [=] { __upsweep(__i, __k, __tilesize, __r, __tilesize, __reduce, __combine); },\n-            [=] { __upsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize, __reduce, __combine); });\n+\t    [=] { __par_backend::__upsweep(__i, __k, __tilesize, __r, __tilesize, __reduce, __combine); },\n+            [=] { __par_backend::__upsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize, __reduce, __combine); });\n         if (__m == 2 * __k)\n             __r[__m - 1] = __combine(__r[__k - 1], __r[__m - 1]);\n     }\n@@ -321,11 +321,11 @@ __downsweep(_Index __i, _Index __m, _Index __tilesize, _Tp* __r, _Index __lastsi\n     else\n     {\n         const _Index __k = __split(__m);\n-        tbb::parallel_invoke([=] { __downsweep(__i, __k, __tilesize, __r, __tilesize, __initial, __combine, __scan); },\n+        tbb::parallel_invoke([=] { __par_backend::__downsweep(__i, __k, __tilesize, __r, __tilesize, __initial, __combine, __scan); },\n                              // Assumes that __combine never throws.\n                              //TODO: Consider adding a requirement for user functors to be constant.\n                              [=, &__combine] {\n-                                 __downsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize,\n+                                 __par_backend::__downsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize,\n                                              __combine(__initial, __r[__k - 1]), __combine, __scan);\n                              });\n     }\n@@ -358,7 +358,8 @@ parallel_strict_scan(_ExecutionPolicy&&, _Index __n, _Tp __initial, _Rp __reduce\n             _Index __m = (__n - 1) / __tilesize;\n             __buffer<_Tp> __buf(__m + 1);\n             _Tp* __r = __buf.get();\n-            __upsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __reduce, __combine);\n+            __par_backend::__upsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __reduce, __combine);\n+\n             // When __apex is a no-op and __combine has no side effects, a good optimizer\n             // should be able to eliminate all code between here and __apex.\n             // Alternatively, provide a default value for __apex that can be\n@@ -368,7 +369,7 @@ parallel_strict_scan(_ExecutionPolicy&&, _Index __n, _Tp __initial, _Rp __reduce\n             while ((__k &= __k - 1))\n                 __t = __combine(__r[__k - 1], __t);\n             __apex(__combine(__initial, __t));\n-            __downsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __initial, __combine,\n+            __par_backend::__downsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __initial, __combine,\n                         __scan);\n             return;\n         }\n@@ -522,7 +523,7 @@ __stable_sort_task<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, _Le\n     {\n         _M_leaf_sort(_M_xs, _M_xe, _M_comp);\n         if (_M_inplace != 2)\n-            __init_buf(_M_xs, _M_xe, _M_zs, _M_inplace == 0);\n+            __par_backend::__init_buf(_M_xs, _M_xe, _M_zs, _M_inplace == 0);\n         return NULL;\n     }\n     else\n@@ -535,19 +536,19 @@ __stable_sort_task<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, _Le\n         auto __move_sequences = [](_RandomAccessIterator2 __first1, _RandomAccessIterator2 __last1,\n                                    _RandomAccessIterator1 __first2) { return std::move(__first1, __last1, __first2); };\n         if (_M_inplace == 2)\n-            __m = new (allocate_continuation())\n+\t    __m = new (tbb::task::allocate_continuation())\n                 __merge_task<_RandomAccessIterator2, _RandomAccessIterator2, _RandomAccessIterator1, _Compare,\n                              __serial_destroy,\n-                             __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n+                             __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n                     _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __serial_destroy(),\n-                    __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n+                    __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n                                                                                              __move_sequences));\n         else if (_M_inplace)\n-            __m = new (allocate_continuation())\n+            __m = new (tbb::task::allocate_continuation())\n                 __merge_task<_RandomAccessIterator2, _RandomAccessIterator2, _RandomAccessIterator1, _Compare,\n-                             __binary_no_op, __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n-                    _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __binary_no_op(),\n-                    __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n+                             __par_backend::__binary_no_op, __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n+                    _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __par_backend::__binary_no_op(),\n+                    __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n                                                                                              __move_sequences));\n         else\n         {\n@@ -556,18 +557,18 @@ __stable_sort_task<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, _Le\n                                        _RandomAccessIterator2 __first2) {\n                 return std::move(__first1, __last1, __first2);\n             };\n-            __m = new (allocate_continuation())\n+            __m = new (tbb::task::allocate_continuation())\n                 __merge_task<_RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2, _Compare,\n-                             __binary_no_op, __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n-                    _M_xs, __xm, __xm, _M_xe, _M_zs, _M_comp, __binary_no_op(),\n-                    __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n+                             __par_backend::__binary_no_op, __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n+                    _M_xs, __xm, __xm, _M_xe, _M_zs, _M_comp, __par_backend::__binary_no_op(),\n+                    __par_backend::__serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n                                                                                              __move_sequences));\n         }\n         __m->set_ref_count(2);\n         task* __right = new (__m->allocate_child())\n             __stable_sort_task(__xm, _M_xe, __zm, !_M_inplace, _M_comp, _M_leaf_sort, __nmerge);\n-        spawn(*__right);\n-        recycle_as_child_of(*__m);\n+\ttbb::task::spawn(*__right);\n+\ttbb::task::recycle_as_child_of(*__m);\n         _M_xe = __xm;\n         _M_inplace = !_M_inplace;\n     }\n@@ -628,10 +629,10 @@ __parallel_merge(_ExecutionPolicy&&, _RandomAccessIterator1 __xs, _RandomAccessI\n     {\n         tbb::this_task_arena::isolate([=]() {\n             typedef __merge_task<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3, _Compare,\n-                                 __binary_no_op, _LeafMerge>\n+                                 __par_backend::__binary_no_op, _LeafMerge>\n                 _TaskType;\n             tbb::task::spawn_root_and_wait(*new (tbb::task::allocate_root()) _TaskType(\n-                __xs, __xe, __ys, __ye, __zs, __comp, __binary_no_op(), __leaf_merge));\n+                __xs, __xe, __ys, __ye, __zs, __comp, __par_backend::__binary_no_op(), __leaf_merge));\n         });\n     }\n }"}, {"sha": "6313890144a8b620019032cfed53f7d8d2ef4c6d", "filename": "libstdc++-v3/include/pstl/parallel_backend_utils.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -12,6 +12,7 @@\n \n #include <iterator>\n #include <utility>\n+#include <cassert>\n #include \"utils.h\"\n \n namespace __pstl"}, {"sha": "da1f7495d2a64ba0dcfc244f9028b02cb126742d", "filename": "libstdc++-v3/include/pstl/unseq_backend_simd.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0360f9ad4048ea54b123e3f7c5cc0696f37958a7/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h?ref=0360f9ad4048ea54b123e3f7c5cc0696f37958a7", "patch": "@@ -456,7 +456,7 @@ template <typename _Size, typename _Tp, typename _BinaryOperation, typename _Una\n typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value, _Tp>::type\n __simd_transform_reduce(_Size __n, _Tp __init, _BinaryOperation __binary_op, _UnaryOperation __f) noexcept\n {\n-    const std::size_t __block_size = __lane_size / sizeof(_Tp);\n+    const _Size __block_size = __lane_size / sizeof(_Tp);\n     if (__n > 2 * __block_size && __block_size > 1)\n     {\n         alignas(__lane_size) char __lane_[__lane_size];\n@@ -796,7 +796,7 @@ __simd_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last, _Forwa\n     {\n         for (; __first != __last; ++__first)\n         {\n-            if (__simd_or(__s_first, __n2,\n+  \t    if (__unseq_backend::__simd_or(__s_first, __n2,\n                           __internal::__equal_value_by_pred<decltype(*__first), _BinaryPredicate>(*__first, __pred)))\n             {\n                 return __first;\n@@ -807,7 +807,7 @@ __simd_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last, _Forwa\n     {\n         for (; __s_first != __s_last; ++__s_first)\n         {\n-            const auto __result = __simd_first(__first, _DifferencType(0), __n1,\n+  \t    const auto __result = __unseq_backend::__simd_first(__first, _DifferencType(0), __n1,\n                                                [__s_first, &__pred](_ForwardIterator1 __it, _DifferencType __i) {\n                                                    return __pred(__it[__i], *__s_first);\n                                                });\n@@ -826,7 +826,7 @@ __simd_remove_if(_RandomAccessIterator __first, _DifferenceType __n, _UnaryPredi\n {\n     // find first element we need to remove\n     auto __current =\n-        __simd_first(__first, _DifferenceType(0), __n,\n+        __unseq_backend::__simd_first(__first, _DifferenceType(0), __n,\n                      [&__pred](_RandomAccessIterator __it, _DifferenceType __i) { return __pred(__it[__i]); });\n     __n -= __current - __first;\n "}]}