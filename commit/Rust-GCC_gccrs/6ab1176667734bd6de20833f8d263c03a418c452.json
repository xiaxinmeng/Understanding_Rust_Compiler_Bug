{"sha": "6ab1176667734bd6de20833f8d263c03a418c452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiMTE3NjY2NzczNGJkNmRlMjA4MzNmOGQyNjNjMDNhNDE4YzQ1Mg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-11T02:38:34Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-11T02:38:34Z"}, "message": "c++: dependent operator expression lookup [PR51577]\n\nThis unconditionally enables the maybe_save_operator_binding mechanism\nfor all function templates, so that when resolving a dependent operator\nexpression from a function template we ignore later-declared\nnamespace-scope bindings that weren't visible at template definition\ntime.  This patch additionally makes the mechanism apply to dependent\ncomma and compound-assignment operator expressions.\n\nNote that this doesn't fix the testcases in PR83035 or PR99692 because\nthere the dependent operator expressions aren't at function scope.  I'm\nnot sure how adapt this mechanism for these testcases, since although\nwe'll in both testcases have a TEMPLATE_DECL to associate the lookup\nresult with, at instantiation time we won't have an appropriate binding\nlevel to push to.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/51577\n\t* name-lookup.c (maybe_save_operator_binding): Unconditionally\n\tenable for all function templates, not just generic lambdas.\n\tHandle compound-assignment operator expressions.\n\t* typeck.c (build_x_compound_expr): Call maybe_save_operator_binding\n\tin the type-dependent case.\n\t(build_x_modify_expr): Likewise.  Move declaration of 'op' closer\n\tto its first use.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/51577\n\t* g++.dg/lookup/operator-3.C: New test.", "tree": {"sha": "54a7d24547cd60bdd00ee67ea186c89dbfa4746b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54a7d24547cd60bdd00ee67ea186c89dbfa4746b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ab1176667734bd6de20833f8d263c03a418c452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab1176667734bd6de20833f8d263c03a418c452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab1176667734bd6de20833f8d263c03a418c452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab1176667734bd6de20833f8d263c03a418c452/comments", "author": null, "committer": null, "parents": [{"sha": "e7a9f085ffd34b0d7bc4b803c182b41494f609aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a9f085ffd34b0d7bc4b803c182b41494f609aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a9f085ffd34b0d7bc4b803c182b41494f609aa"}], "stats": {"total": 141, "additions": 128, "deletions": 13}, "files": [{"sha": "a6c9e68a19ee2682357a81fe17b69247e00209f1", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab1176667734bd6de20833f8d263c03a418c452/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab1176667734bd6de20833f8d263c03a418c452/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=6ab1176667734bd6de20833f8d263c03a418c452", "patch": "@@ -9116,21 +9116,20 @@ static const char *const op_bind_attrname = \"operator bindings\";\n void\n maybe_save_operator_binding (tree e)\n {\n-  /* This is only useful in a generic lambda.  */\n+  /* This is only useful in a template.  */\n   if (!processing_template_decl)\n     return;\n \n   tree cfn = current_function_decl;\n   if (!cfn)\n     return;\n \n-  /* Do this for lambdas and code that will emit a CMI.  In a module's\n-     GMF we don't yet know whether there will be a CMI.  */\n-  if (!module_has_cmi_p () && !global_purview_p () && !current_lambda_expr())\n-     return;\n-\n-  tree fnname = ovl_op_identifier (false, TREE_CODE (e));\n-  if (!fnname)\n+  tree fnname;\n+  if(TREE_CODE (e) == MODOP_EXPR)\n+    fnname = ovl_op_identifier (true, TREE_CODE (TREE_OPERAND (e, 1)));\n+  else\n+    fnname = ovl_op_identifier (false, TREE_CODE (e));\n+  if (!fnname || fnname == assign_op_identifier)\n     return;\n \n   tree attributes = DECL_ATTRIBUTES (cfn);"}, {"sha": "9002dd14faecc4bc831dfec8b660fda19c7e483e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab1176667734bd6de20833f8d263c03a418c452/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab1176667734bd6de20833f8d263c03a418c452/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6ab1176667734bd6de20833f8d263c03a418c452", "patch": "@@ -7274,7 +7274,11 @@ build_x_compound_expr (location_t loc, tree op1, tree op2,\n     {\n       if (type_dependent_expression_p (op1)\n \t  || type_dependent_expression_p (op2))\n-\treturn build_min_nt_loc (loc, COMPOUND_EXPR, op1, op2);\n+\t{\n+\t  result = build_min_nt_loc (loc, COMPOUND_EXPR, op1, op2);\n+\t  maybe_save_operator_binding (result);\n+\t  return result;\n+\t}\n       op1 = build_non_dependent_expr (op1);\n       op2 = build_non_dependent_expr (op2);\n     }\n@@ -8938,7 +8942,6 @@ build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n   tree orig_lhs = lhs;\n   tree orig_rhs = rhs;\n   tree overload = NULL_TREE;\n-  tree op = build_nt (modifycode, NULL_TREE, NULL_TREE);\n \n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return cp_expr (error_mark_node, loc);\n@@ -8948,16 +8951,20 @@ build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n       if (modifycode == NOP_EXPR\n \t  || type_dependent_expression_p (lhs)\n \t  || type_dependent_expression_p (rhs))\n-        return build_min_nt_loc (loc, MODOP_EXPR, lhs,\n-\t\t\t\t build_min_nt_loc (loc, modifycode, NULL_TREE,\n-\t\t\t\t\t\t   NULL_TREE), rhs);\n+\t{\n+\t  tree op = build_min_nt_loc (loc, modifycode, NULL_TREE, NULL_TREE);\n+\t  tree rval = build_min_nt_loc (loc, MODOP_EXPR, lhs, op, rhs);\n+\t  maybe_save_operator_binding (rval);\n+\t  return rval;\n+\t}\n \n       lhs = build_non_dependent_expr (lhs);\n       rhs = build_non_dependent_expr (rhs);\n     }\n \n   if (modifycode != NOP_EXPR)\n     {\n+      tree op = build_nt (modifycode, NULL_TREE, NULL_TREE);\n       tree rval = build_new_op (loc, MODIFY_EXPR, LOOKUP_NORMAL,\n \t\t\t\tlhs, rhs, op, &overload, complain);\n       if (rval)"}, {"sha": "bc5eb3d6693ebc48a367f0e8e2b851083807722c", "filename": "gcc/testsuite/g++.dg/lookup/operator-3.C", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab1176667734bd6de20833f8d263c03a418c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab1176667734bd6de20833f8d263c03a418c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-3.C?ref=6ab1176667734bd6de20833f8d263c03a418c452", "patch": "@@ -0,0 +1,109 @@\n+// PR c++/51577\n+\n+template <class T> void f (T x) {\n+  +x; // { dg-error \"no match\" }\n+  -x; // { dg-error \"no match\" }\n+  *x; // { dg-error \"no match\" }\n+  ~x; // { dg-error \"no match\" }\n+  &x;\n+  !x; // { dg-error \"no match\" }\n+  ++x; // { dg-error \"no match\" }\n+  --x; // { dg-error \"no match\" }\n+  x++; // { dg-error \"declared for postfix\" }\n+  x--; // { dg-error \"declared for postfix\" }\n+\n+  x->*x; // { dg-error \"no match\" }\n+  x / x; // { dg-error \"no match\" }\n+  x * x; // { dg-error \"no match\" }\n+  x + x; // { dg-error \"no match\" }\n+  x - x; // { dg-error \"no match\" }\n+  x % x; // { dg-error \"no match\" }\n+  x & x; // { dg-error \"no match\" }\n+  x | x; // { dg-error \"no match\" }\n+  x ^ x; // { dg-error \"no match\" }\n+  x << x; // { dg-error \"no match\" }\n+  x >> x; // { dg-error \"no match\" }\n+  x && x; // { dg-error \"no match\" }\n+  x || x; // { dg-error \"no match\" }\n+  x, x;\n+\n+  x == x; // { dg-error \"no match\" }\n+  x != x; // { dg-error \"no match\" }\n+  x < x; // { dg-error \"no match\" }\n+  x > x; // { dg-error \"no match\" }\n+  x <= x; // { dg-error \"no match\" }\n+  x >= x; // { dg-error \"no match\" }\n+#if __cplusplus > 201703L\n+  x <=> x; // { dg-error \"no match\" \"\" { target c++20 } }\n+#endif\n+\n+  x += x; // { dg-error \"no match\" }\n+  x -= x; // { dg-error \"no match\" }\n+  x *= x; // { dg-error \"no match\" }\n+  x /= x; // { dg-error \"no match\" }\n+  x %= x; // { dg-error \"no match\" }\n+  x |= x; // { dg-error \"no match\" }\n+  x ^= x; // { dg-error \"no match\" }\n+  x <<= x; // { dg-error \"no match\" }\n+  x >>= x; // { dg-error \"no match\" }\n+}\n+\n+namespace N { struct A { }; }\n+\n+void operator+(N::A);\n+void operator-(N::A);\n+void operator*(N::A);\n+void operator~(N::A);\n+#if __cplusplus >= 201103L\n+void operator&(N::A) = delete;\n+#else\n+void operator&(N::A);\n+#endif\n+void operator!(N::A);\n+void operator++(N::A);\n+void operator--(N::A);\n+void operator++(N::A, int);\n+void operator--(N::A, int);\n+\n+void operator->*(N::A, N::A);\n+void operator/(N::A, N::A);\n+void operator*(N::A, N::A);\n+void operator+(N::A, N::A);\n+void operator-(N::A, N::A);\n+void operator%(N::A, N::A);\n+void operator&(N::A, N::A);\n+void operator|(N::A, N::A);\n+void operator^(N::A, N::A);\n+void operator<<(N::A, N::A);\n+void operator>>(N::A, N::A);\n+void operator&&(N::A, N::A);\n+void operator||(N::A, N::A);\n+#if __cplusplus >= 201103L\n+void operator,(N::A, N::A) = delete;\n+#else\n+void operator,(N::A, N::A);\n+#endif\n+\n+void operator==(N::A, N::A);\n+void operator!=(N::A, N::A);\n+void operator<(N::A, N::A);\n+void operator>(N::A, N::A);\n+void operator<=(N::A, N::A);\n+void operator>=(N::A, N::A);\n+#if __cplusplus > 201703L\n+void operator<=>(N::A, N::A);\n+#endif\n+\n+void operator+=(N::A, N::A);\n+void operator-=(N::A, N::A);\n+void operator*=(N::A, N::A);\n+void operator/=(N::A, N::A);\n+void operator%=(N::A, N::A);\n+void operator|=(N::A, N::A);\n+void operator^=(N::A, N::A);\n+void operator<<=(N::A, N::A);\n+void operator>>=(N::A, N::A);\n+\n+int main() {\n+  f(N::A());\n+}"}]}