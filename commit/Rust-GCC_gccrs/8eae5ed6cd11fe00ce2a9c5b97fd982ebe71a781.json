{"sha": "8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVhZTVlZDZjZDExZmUwMGNlMmE5YzViOTdmZDk4MmViZTcxYTc4MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-01T01:13:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-01T01:13:57Z"}, "message": "(struct resources): New field unch_memory.\n\n(CLEAR_RESOURCES, mark_target_live_regs, dbr_schedule): Clear it.\n(mark_{referenced,set}_resources, redundant_insn): Set it.\n(fill_simple_delay_slots): Likewise.\n(resource_conflicts_p): Test it.\n\nFrom-SVN: r9860", "tree": {"sha": "6370677c56f71b700687dcb2c290ef11b43ac560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6370677c56f71b700687dcb2c290ef11b43ac560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781/comments", "author": null, "committer": null, "parents": [{"sha": "fd25a29a316f46d70e38e5cd31ff4f19219556f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd25a29a316f46d70e38e5cd31ff4f19219556f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd25a29a316f46d70e38e5cd31ff4f19219556f3"}], "stats": {"total": 14, "additions": 11, "deletions": 3}, "files": [{"sha": "c2586ddb39475c74402b38cfa8a8efc2aa60b912", "filename": "gcc/reorg.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=8eae5ed6cd11fe00ce2a9c5b97fd982ebe71a781", "patch": "@@ -162,14 +162,15 @@ static rtx *unfilled_firstobj;\n struct resources\n {\n   char memory;\t\t\t/* Insn sets or needs a memory location.  */\n+  char unch_memory;\t\t/* Insn sets of needs a \"unchanging\" MEM. */\n   char volatil;\t\t\t/* Insn sets or needs a volatile memory loc. */\n   char cc;\t\t\t/* Insn sets or needs the condition codes.  */\n   HARD_REG_SET regs;\t\t/* Which registers are set or needed.  */\n };\n \n /* Macro to clear all resources.  */\n #define CLEAR_RESOURCE(RES)\t\\\n- do { (RES)->memory = (RES)->volatil = (RES)->cc = 0;\t\\\n+ do { (RES)->memory = (RES)->unch_memory = (RES)->volatil = (RES)->cc = 0; \\\n       CLEAR_HARD_REG_SET ((RES)->regs); } while (0)\n \n /* Indicates what resources are required at the beginning of the epilogue.  */\n@@ -310,7 +311,9 @@ mark_referenced_resources (x, res, include_delayed_effects)\n     case MEM:\n       /* If this memory shouldn't change, it really isn't referencing\n \t memory.  */\n-      if (! RTX_UNCHANGING_P (x))\n+      if (RTX_UNCHANGING_P (x))\n+\tres->unch_memory = 1;\n+      else\n \tres->memory = 1;\n       res->volatil = MEM_VOLATILE_P (x);\n \n@@ -616,6 +619,7 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n       if (in_dest)\n \t{\n \t  res->memory = 1;\n+\t  res->unch_memory = RTX_UNCHANGING_P (x);\n \t  res->volatil = MEM_VOLATILE_P (x);\n \t}\n \n@@ -707,6 +711,7 @@ resource_conflicts_p (res1, res2)\n      struct resources *res1, *res2;\n {\n   if ((res1->cc && res2->cc) || (res1->memory && res2->memory)\n+      || (res1->unch_memory && res2->unch_memory)\n       || res1->volatil || res2->volatil)\n     return 1;\n \n@@ -2033,6 +2038,7 @@ redundant_insn (insn, target, delay_list)\n   /* Insns we pass may not set either NEEDED or SET, so merge them for\n      simpler tests.  */\n   needed.memory |= set.memory;\n+  needed.unch_memory |= set.unch_memory;\n   IOR_HARD_REG_SET (needed.regs, set.regs);\n \n   /* This insn isn't redundant if it conflicts with an insn that either is\n@@ -2454,7 +2460,7 @@ mark_target_live_regs (target, res)\n \n   /* We have to assume memory is needed, but the CC isn't.  */\n   res->memory = 1;\n-  res->volatil = 0;\n+  res->volatil = res->unch_memory = 0;\n   res->cc = 0;\n \n   /* See if we have computed this value already.  */\n@@ -3053,6 +3059,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t\t\t(next_active_insn (JUMP_LABEL (trial_delay)),\n \t\t\t &needed_at_jump);\n \t\t      needed.memory |= needed_at_jump.memory;\n+\t\t      needed.unch_memory |= needed_at_jump.unch_memory;\n \t\t      IOR_HARD_REG_SET (needed.regs, needed_at_jump.regs);\n \t\t    }\n \t\t}\n@@ -4260,6 +4267,7 @@ dbr_schedule (first, file)\n \n   end_of_function_needs.cc = 0;\n   end_of_function_needs.memory = 1;\n+  end_of_function_needs.unch_memory = 0;\n   CLEAR_HARD_REG_SET (end_of_function_needs.regs);\n \n   if (frame_pointer_needed)"}]}