{"sha": "f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdkOThkNThmYjU1YWQ0NDZjMzViMzA5Y2ZkZGVjZjVkOGVjNmJiZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-02-23T05:11:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-23T05:11:57Z"}, "message": "pt.c, [...]: Remove unused NARGS argument to tsubst and friends.\n\n\t* pt.c, call.c, decl.c, method.c, cp-tree.h: Remove unused NARGS\n\targument to tsubst and friends.\n\nFrom-SVN: r18201", "tree": {"sha": "29fb2ac908cc11fe4ce50d78d95d863f57102e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29fb2ac908cc11fe4ce50d78d95d863f57102e61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/comments", "author": null, "committer": null, "parents": [{"sha": "a221d52f5514b94d99add841b054731d7a932d3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a221d52f5514b94d99add841b054731d7a932d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a221d52f5514b94d99add841b054731d7a932d3e"}], "stats": {"total": 349, "additions": 159, "deletions": 190}, "files": [{"sha": "a1f882d13e75d109979e341bab8dd860ae32c321", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "patch": "@@ -1,4 +1,7 @@\n-Mon Feb 23 03:04:14 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+Mon Feb 23 05:08:55 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c, call.c, decl.c, method.c, cp-tree.h: Remove unused NARGS\n+\targument to tsubst and friends.\n \n \t* pt.c (tsubst, FUNCTION_DECL): Tidy.\n "}, {"sha": "6ef1a33ef38102a51b899c9ed827c50eb790db7a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "patch": "@@ -5523,8 +5523,7 @@ build_over_call (fn, convs, args, flags)\n       if (DECL_TEMPLATE_INFO (fn))\n \t/* This came from a template.  Instantiate the default arg here,\n \t   not in tsubst.  */\n-\targ = tsubst_expr (arg, DECL_TI_ARGS (fn),\n-\t\t\t   TREE_VEC_LENGTH (DECL_TI_ARGS (fn)), NULL_TREE);\n+\targ = tsubst_expr (arg, DECL_TI_ARGS (fn), NULL_TREE);\n       converted_args = expr_tree_cons\n \t(NULL_TREE, convert_default_arg (TREE_VALUE (parm), arg),\n \t converted_args);"}, {"sha": "22b41097dd5b0cc59353901694fba2ba47801efd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "patch": "@@ -2375,9 +2375,9 @@ extern void synthesize_method\t\t\tPROTO((tree));\n extern tree get_id_2\t\t\t\tPROTO((char *, tree));\n \n /* in pt.c */\n-extern tree tsubst\t\t\t\tPROTO ((tree, tree, int, tree));\n-extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, int, tree));\n-extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, int, tree));\n+extern tree tsubst\t\t\t\tPROTO ((tree, tree, tree));\n+extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, tree));\n+extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n extern void maybe_begin_member_template_processing PROTO((tree));\n extern void maybe_end_member_template_processing PROTO((tree));"}, {"sha": "7ba992a163edb2380cd249b44c5b9316deabc7ea", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "patch": "@@ -9235,10 +9235,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    && uses_template_parms (current_class_type))\n \t\t  {\n \t\t    tree args = current_template_args ();\n-\t\t    type = tsubst (type, args,\n-\t\t\t\t   TREE_VEC_LENGTH (TREE_VEC_ELT\n-\t\t\t\t\t\t    (args, 0)),\n-\t\t\t\t   NULL_TREE);\n+\t\t    type = tsubst (type, args, NULL_TREE);\n \t\t  }\n \n \t\t/* This pop_nested_class corresponds to the"}, {"sha": "1562f8070f1ec2665ccc8f9ac10de80301e0b403", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "patch": "@@ -899,8 +899,7 @@ build_template_parm_names (parmlist, arglist)\n \t}\n       else\n \t{\n-\t  parm = tsubst (parm, arglist,\n-\t\t\t TREE_VEC_LENGTH (arglist), NULL_TREE);\n+\t  parm = tsubst (parm, arglist, NULL_TREE);\n \t  /* It's a PARM_DECL.  */\n \t  build_mangled_name (TREE_TYPE (parm), 0, 0);\n \t  build_overload_value (parm, arg, uses_template_parms (arglist));"}, {"sha": "73a2207e67ed6ae7960508ed9689a880a96d7647", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 149, "deletions": 178, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f7d98d58fb55ad446c35b309cfddecf5d8ec6bbd", "patch": "@@ -79,7 +79,7 @@ static int comp_template_args PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n-static tree tsubst_enum\tPROTO((tree, tree, int, tree *));\n+static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n \t\t\t\t\t int, int, int));\n@@ -1901,9 +1901,9 @@ coerce_template_parms (parms, arglist, in_decl,\n \t      break;\n \t    }\n \t  else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n-\t    arg = tsubst (TREE_PURPOSE (parm), vec, i, in_decl);\n+\t    arg = tsubst (TREE_PURPOSE (parm), vec, in_decl);\n \t  else\n-\t    arg = tsubst_expr (TREE_PURPOSE (parm), vec, i, in_decl);\n+\t    arg = tsubst_expr (TREE_PURPOSE (parm), vec, in_decl);\n \n \t  TREE_VEC_ELT (vec, i) = arg;\n \t}\n@@ -2077,8 +2077,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t}\n       else\n \t{\n-\t  tree t = tsubst (TREE_TYPE (parm), vec,\n-\t\t\t   TREE_VEC_LENGTH (vec), in_decl);\n+\t  tree t = tsubst (TREE_TYPE (parm), vec, in_decl);\n \n \t  if (processing_template_decl)\n \t    arg = maybe_fold_nontype_arg (arg);\n@@ -2482,10 +2481,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n   else\n     {\n       tree type_ctx = TYPE_CONTEXT (TREE_TYPE (template));\n-      tree args = tsubst (CLASSTYPE_TI_ARGS (type_ctx),\n-\t\t\t  arglist,\n-\t\t\t  TREE_VEC_LENGTH (arglist),\n-\t\t\t  in_decl);\n+      tree args = tsubst (CLASSTYPE_TI_ARGS (type_ctx), arglist, in_decl);\n       tree ctx = lookup_template_class (type_ctx, args,\n \t\t\t\t\tin_decl, NULL_TREE);\n       id = d1;\n@@ -2849,19 +2845,15 @@ tsubst_friend_function (decl, args)\n \n       template_id\n \t= lookup_template_function (tsubst_expr (DECL_TI_TEMPLATE (decl),\n-\t\t\t\t\t\t args, \n-\t\t\t\t\t\t TREE_VEC_LENGTH (args),\n-\t\t\t\t\t\t NULL_TREE),\n+\t\t\t\t\t\t args, NULL_TREE),\n \t\t\t\t    tsubst (DECL_TI_ARGS (decl),\n-\t\t\t\t\t    args,\n-\t\t\t\t\t    TREE_VEC_LENGTH (decl),\n-\t\t\t\t\t    NULL_TREE));\n+\t\t\t\t\t    args, NULL_TREE));\n       \n       /* Temporarily remove the DECL_TEMPLATE_INFO so as not to\n \t confuse tsubst.  */\n       tinfo = DECL_TEMPLATE_INFO (decl);\n       DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n-      new_friend = tsubst (decl, args, TREE_VEC_LENGTH (args), NULL_TREE);\n+      new_friend = tsubst (decl, args, NULL_TREE);\n       DECL_TEMPLATE_INFO (decl) = tinfo;\n \n       tmpl = determine_specialization (template_id,\n@@ -2871,7 +2863,7 @@ tsubst_friend_function (decl, args)\n       return instantiate_template (tmpl, new_args);\n     }\n     else\n-      new_friend = tsubst (decl, args, TREE_VEC_LENGTH (args), NULL_TREE);\n+      new_friend = tsubst (decl, args, NULL_TREE);\n \t\n   /* The new_friend will look like an instantiation, to the\n      compiler, but is not an instantiation from the point of view of\n@@ -3034,8 +3026,7 @@ instantiate_class_template (type)\n \t    tree elt;\n \n \t    TREE_VEC_ELT (bases, i) = elt\n-\t      = tsubst (TREE_VEC_ELT (pbases, i), args,\n-\t\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n+\t      = tsubst (TREE_VEC_ELT (pbases, i), args, NULL_TREE);\n \t    BINFO_INHERITANCE_CHAIN (elt) = binfo;\n \n \t    if (! IS_AGGR_TYPE (TREE_TYPE (elt)))\n@@ -3065,8 +3056,7 @@ instantiate_class_template (type)\n       /* These will add themselves to CLASSTYPE_TAGS for the new type.  */\n       if (TREE_CODE (tag) == ENUMERAL_TYPE)\n \t{\n-\t  tree newtag =\n-\t    tsubst_enum (tag, args, TREE_VEC_LENGTH (args), field_chain);\n+\t  tree newtag = tsubst_enum (tag, args, field_chain);\n \n \t  while (*field_chain)\n \t    {\n@@ -3075,16 +3065,14 @@ instantiate_class_template (type)\n \t    }\n \t}\n       else\n-\ttsubst (tag, args,\n-\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n+\ttsubst (tag, args, NULL_TREE);\n     }\n \n   /* Don't replace enum constants here.  */\n   for (t = TYPE_FIELDS (pattern); t; t = TREE_CHAIN (t))\n     if (TREE_CODE (t) != CONST_DECL)\n       {\n-\ttree r = tsubst (t, args,\n-\t\t\t TREE_VEC_LENGTH (args), NULL_TREE);\n+\ttree r = tsubst (t, args, NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n \t    if (! uses_template_parms (r))\n@@ -3136,9 +3124,7 @@ instantiate_class_template (type)\n \t  else\n \t    {\n \t      TREE_VALUE (DECL_FRIENDLIST (typedecl))\n-\t\t= tree_cons (tsubst (TREE_PURPOSE (friends),\n-\t\t\t\t     args, TREE_VEC_LENGTH (args),\n-\t\t\t\t     NULL_TREE),\n+\t\t= tree_cons (tsubst (TREE_PURPOSE (friends), args, NULL_TREE),\n \t\t\t     NULL_TREE,\n \t\t\t     TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n \n@@ -3148,8 +3134,7 @@ instantiate_class_template (type)\n \n   {\n     tree d = CLASSTYPE_FRIEND_CLASSES (type)\n-      = tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), args,\n-\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n+      = tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), args, NULL_TREE);\n \n     /* This does injection for friend classes.  */\n     for (; d; d = TREE_CHAIN (d))\n@@ -3158,8 +3143,7 @@ instantiate_class_template (type)\n     /* This does injection for friend functions. */\n     if (!processing_template_decl)\n       {\n-\td = tsubst (DECL_TEMPLATE_INJECT (template), args,\n-\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n+\td = tsubst (DECL_TEMPLATE_INJECT (template), args, NULL_TREE);\n \n \tfor (; d; d = TREE_CHAIN (d))\n \t  {\n@@ -3284,16 +3268,15 @@ innermost_args (args, is_spec)\n }\n \n /* Take the tree structure T and replace template parameters used therein\n-   with the argument vector ARGS.  NARGS is the number of args; should\n-   be removed.  IN_DECL is an associated decl for diagnostics.\n+   with the argument vector ARGS.  IN_DECL is an associated decl for\n+   diagnostics.\n \n    tsubst is used for dealing with types, decls and the like; for\n    expressions, use tsubst_expr or tsubst_copy.  */\n \n tree\n-tsubst (t, args, nargs, in_decl)\n+tsubst (t, args, in_decl)\n      tree t, args;\n-     int nargs;\n      tree in_decl;\n {\n   tree type;\n@@ -3310,15 +3293,15 @@ tsubst (t, args, nargs, in_decl)\n   if (type && TREE_CODE (t) != FUNCTION_DECL\n       && TREE_CODE (t) != TYPENAME_TYPE\n       && TREE_CODE (t) != TEMPLATE_DECL)\n-    type = tsubst (type, args, nargs, in_decl);\n+    type = tsubst (type, args, in_decl);\n \n   switch (TREE_CODE (t))\n     {\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \t{\n \t  tree r = build_ptrmemfunc_type\n-\t    (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, nargs, in_decl));\n+\t    (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, in_decl));\n \t  return cp_build_type_variant (r, TYPE_READONLY (t),\n \t\t\t\t\tTYPE_VOLATILE (t));\n \t}\n@@ -3327,13 +3310,13 @@ tsubst (t, args, nargs, in_decl)\n     case UNION_TYPE:\n       if (uses_template_parms (t))\n \t{\n-\t  tree argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, nargs, in_decl);\n+\t  tree argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, in_decl);\n \t  tree context;\n \t  tree r;\n \n \t  context = \n \t    TYPE_CONTEXT (t) \n-\t    ? tsubst (TYPE_CONTEXT (t), args, nargs, in_decl) : NULL_TREE;\n+\t    ? tsubst (TYPE_CONTEXT (t), args, in_decl) : NULL_TREE;\n \n \t  r = lookup_template_class (t, argvec, in_decl, context);\n \n@@ -3356,7 +3339,7 @@ tsubst (t, args, nargs, in_decl)\n \n     case ENUMERAL_TYPE:\n       {\n-\ttree ctx = tsubst (TYPE_CONTEXT (t), args, nargs, in_decl);\n+\ttree ctx = tsubst (TYPE_CONTEXT (t), args, in_decl);\n \tif (ctx == NULL_TREE)\n \t  return t;\n \telse if (ctx == current_function_decl)\n@@ -3375,7 +3358,7 @@ tsubst (t, args, nargs, in_decl)\n \n       {\n \ttree max = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n-\tmax = tsubst_expr (max, args, nargs, in_decl);\n+\tmax = tsubst_expr (max, args, in_decl);\n \tif (processing_template_decl)\n \t  {\n \t    tree itype = make_node (INTEGER_TYPE);\n@@ -3435,7 +3418,7 @@ tsubst (t, args, nargs, in_decl)\n \t\t\t/* We are processing a type constructed from\n \t\t\t   a template template parameter */\n \t\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t),\n-\t\t\t\t\t      args, nargs, in_decl);\n+\t\t\t\t\t      args, in_decl);\n \t\t\ttree r;\n \n \t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n@@ -3531,11 +3514,11 @@ tsubst (t, args, nargs, in_decl)\n \tDECL_CHAIN (tmpl) = NULL_TREE;\n \tTREE_CHAIN (tmpl) = NULL_TREE;\n \tDECL_CONTEXT (tmpl) = tsubst (DECL_CONTEXT (t),\n-\t\t\t\t      args, nargs, in_decl);\n+\t\t\t\t      args, in_decl);\n \tDECL_CLASS_CONTEXT (tmpl) = tsubst (DECL_CLASS_CONTEXT (t),\n-\t\t\t\t\t    args, nargs, in_decl);\n+\t\t\t\t\t    args, in_decl);\n \tDECL_TEMPLATE_INFO (tmpl) = build_tree_list (t, args);\n-\tnew_decl = tsubst (decl, args, nargs, in_decl);\n+\tnew_decl = tsubst (decl, args, in_decl);\n \tDECL_RESULT (tmpl) = new_decl;\n \tDECL_TI_TEMPLATE (new_decl) = tmpl;\n \tTREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n@@ -3563,10 +3546,8 @@ tsubst (t, args, nargs, in_decl)\n \t\t  TREE_VALUE (TREE_VEC_ELT (TREE_VALUE (parms), i));\n \t\t  \n \t\tTREE_VEC_ELT (new_vec, i)\n-\t\t  = build_tree_list (tsubst (default_value, args,\n-\t\t\t\t\t     nargs, in_decl),\n-\t\t\t\t     tsubst (parm_decl, args, nargs,\n-\t\t\t\t\t     in_decl));\n+\t\t  = build_tree_list (tsubst (default_value, args, in_decl),\n+\t\t\t\t     tsubst (parm_decl, args, in_decl));\n \t\t  \n \t      }\n \n@@ -3624,9 +3605,9 @@ tsubst (t, args, nargs, in_decl)\n \t\t no concern to us.  */\n \t      continue;\n \n-\t    spec_args = tsubst (DECL_TI_ARGS (fn), args, nargs,\n+\t    spec_args = tsubst (DECL_TI_ARGS (fn), args,\n \t\t\t\tin_decl); \n-\t    new_fn = tsubst (DECL_RESULT (fn), args, nargs,\n+\t    new_fn = tsubst (DECL_RESULT (fn), args,\n \t\t\t     in_decl); \n \t    DECL_TEMPLATE_SPECIALIZATIONS (tmpl) = \n \t      perm_tree_cons (spec_args, new_fn, \n@@ -3654,14 +3635,14 @@ tsubst (t, args, nargs, in_decl)\n \t      member = 2;\n \t    else\n \t      member = 1;\n-\t    ctx = tsubst (DECL_CLASS_CONTEXT (t), args, nargs, t);\n-\t    type = tsubst (type, args, nargs, in_decl);\n+\t    ctx = tsubst (DECL_CLASS_CONTEXT (t), args, t);\n+\t    type = tsubst (type, args, in_decl);\n \t  }\n \telse\n \t  {\n \t    member = 0;\n \t    ctx = NULL_TREE;\n-\t    type = tsubst (type, args, nargs, in_decl);\n+\t    type = tsubst (type, args, in_decl);\n \t  }\n \n \t/* If we are instantiating a specialization, get the other args.  */\n@@ -3672,7 +3653,7 @@ tsubst (t, args, nargs, in_decl)\n \t    tmpl = DECL_TI_TEMPLATE (t);\n \n \t    /* Start by getting the innermost args.  */\n-\t    argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n+\t    argvec = tsubst (DECL_TI_ARGS (t), args, in_decl);\n \n \t    /* If tmpl is an instantiation of a member template, tack on\n \t       the args for the enclosing class.  NOTE: this will change\n@@ -3707,7 +3688,7 @@ tsubst (t, args, nargs, in_decl)\n \tTREE_TYPE (r) = type;\n \n \tDECL_CONTEXT (r)\n-\t  = tsubst (DECL_CONTEXT (t), args, nargs, t);\n+\t  = tsubst (DECL_CONTEXT (t), args, t);\n \tDECL_CLASS_CONTEXT (r) = ctx;\n \n \tif (member && !strncmp (OPERATOR_TYPENAME_FORMAT,\n@@ -3822,7 +3803,7 @@ tsubst (t, args, nargs, in_decl)\n \tDECL_RTL (r) = 0;\n \tmake_decl_rtl (r, NULL_PTR, 1);\n \n-\tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, nargs, t);\n+\tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, t);\n \tDECL_MAIN_VARIANT (r) = r;\n \tDECL_RESULT (r) = NULL_TREE;\n \tDECL_INITIAL (r) = NULL_TREE;\n@@ -3910,7 +3891,7 @@ tsubst (t, args, nargs, in_decl)\n \t  DECL_ARG_TYPE (r) = integer_type_node;\n #endif\n \tif (TREE_CHAIN (t))\n-\t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args, nargs, TREE_CHAIN (t));\n+\t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args, TREE_CHAIN (t));\n \treturn r;\n       }\n \n@@ -3920,9 +3901,9 @@ tsubst (t, args, nargs, in_decl)\n \tTREE_TYPE (r) = type;\n \tcopy_lang_decl (r);\n #if 0\n-\tDECL_FIELD_CONTEXT (r) = tsubst (DECL_FIELD_CONTEXT (t), args, nargs, in_decl);\n+\tDECL_FIELD_CONTEXT (r) = tsubst (DECL_FIELD_CONTEXT (t), args, in_decl);\n #endif\n-\tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args, nargs, in_decl);\n+\tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \treturn r;\n       }\n@@ -3931,15 +3912,15 @@ tsubst (t, args, nargs, in_decl)\n       {\n \ttree r = copy_node (t);\n \tDECL_INITIAL (r)\n-\t  = tsubst_copy (DECL_INITIAL (t), args, nargs, in_decl);\n+\t  = tsubst_copy (DECL_INITIAL (t), args, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \treturn r;\n       }\n \n     case VAR_DECL:\n       {\n \ttree r;\n-\ttree ctx = tsubst_copy (DECL_CONTEXT (t), args, nargs, in_decl);\n+\ttree ctx = tsubst_copy (DECL_CONTEXT (t), args, in_decl);\n \n \t/* Do we already have this instantiation?  */\n \tif (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n@@ -3976,7 +3957,7 @@ tsubst (t, args, nargs, in_decl)\n \t  {\n \t    tree tmpl = DECL_TI_TEMPLATE (t);\n \t    tree *declsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n-\t    tree argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n+\t    tree argvec = tsubst (DECL_TI_ARGS (t), args, in_decl);\n \n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \t    *declsp = perm_tree_cons (argvec, r, *declsp);\n@@ -4012,13 +3993,13 @@ tsubst (t, args, nargs, in_decl)\n \n \tpurpose = TREE_PURPOSE (t);\n \tif (purpose)\n-\t  purpose = tsubst (purpose, args, nargs, in_decl);\n+\t  purpose = tsubst (purpose, args, in_decl);\n \tvalue = TREE_VALUE (t);\n \tif (value)\n-\t  value = tsubst (value, args, nargs, in_decl);\n+\t  value = tsubst (value, args, in_decl);\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n-\t  chain = tsubst (chain, args, nargs, in_decl);\n+\t  chain = tsubst (chain, args, in_decl);\n \tif (purpose == TREE_PURPOSE (t)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n@@ -4059,7 +4040,7 @@ tsubst (t, args, nargs, in_decl)\n \tfor (i = 0; i < len; i++)\n \t  {\n \t    elts[i] = maybe_fold_nontype_arg\n-\t      (tsubst_expr (TREE_VEC_ELT (t, i), args, nargs, in_decl));\n+\t      (tsubst_expr (TREE_VEC_ELT (t, i), args, in_decl));\n \n \t    if (elts[i] != TREE_VEC_ELT (t, i))\n \t      need_new = 1;\n@@ -4122,7 +4103,7 @@ tsubst (t, args, nargs, in_decl)\n       }\n     case OFFSET_TYPE:\n       return build_offset_type\n-\t(tsubst (TYPE_OFFSET_BASETYPE (t), args, nargs, in_decl), type);\n+\t(tsubst (TYPE_OFFSET_BASETYPE (t), args, in_decl), type);\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n@@ -4143,7 +4124,7 @@ tsubst (t, args, nargs, in_decl)\n \t\t values = TREE_CHAIN (values))\n \t      {\n \t\ttree value = TYPE_MAIN_VARIANT (type_decays_to\n-\t\t  (tsubst (TREE_VALUE (values), args, nargs, in_decl)));\n+\t\t  (tsubst (TREE_VALUE (values), args, in_decl)));\n \t\t/* Don't instantiate default args unless they are used.\n \t\t   Handle it in build_over_call instead.  */\n \t\ttree purpose = TREE_PURPOSE (values);\n@@ -4162,7 +4143,7 @@ tsubst (t, args, nargs, in_decl)\n \t    values = first;\n \t  }\n \tif (context)\n-\t  context = tsubst (context, args, nargs, in_decl);\n+\t  context = tsubst (context, args, in_decl);\n \t/* Could also optimize cases where return value and\n \t   values have common elements (e.g., T min(const &T, const T&).  */\n \n@@ -4181,7 +4162,7 @@ tsubst (t, args, nargs, in_decl)\n \telse if (context == NULL_TREE)\n \t  {\n \t    tree base = tsubst (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))),\n-\t\t\t\targs, nargs, in_decl);\n+\t\t\t\targs, in_decl);\n \t    fntype = build_cplus_method_type (base, type,\n \t\t\t\t\t      TREE_CHAIN (values));\n \t  }\n@@ -4196,7 +4177,7 @@ tsubst (t, args, nargs, in_decl)\n \t    TYPE_MODE (fntype) = TYPE_MODE (t);\n \t    if (TYPE_METHOD_BASETYPE (t))\n \t      TYPE_METHOD_BASETYPE (fntype) = tsubst (TYPE_METHOD_BASETYPE (t),\n-\t\t\t\t\t\t      args, nargs, in_decl);\n+\t\t\t\t\t\t      args, in_decl);\n \t    /* Need to generate hash value.  */\n \t    my_friendly_abort (84);\n \t  }\n@@ -4205,14 +4186,14 @@ tsubst (t, args, nargs, in_decl)\n \t\t\t\t     TYPE_VOLATILE (t));\n \tif (raises)\n \t  {\n-\t    raises = tsubst (raises, args, nargs, in_decl);\n+\t    raises = tsubst (raises, args, in_decl);\n \t    fntype = build_exception_variant (fntype, raises);\n \t  }\n \treturn fntype;\n       }\n     case ARRAY_TYPE:\n       {\n-\ttree domain = tsubst (TYPE_DOMAIN (t), args, nargs, in_decl);\n+\ttree domain = tsubst (TYPE_DOMAIN (t), args, in_decl);\n \ttree r;\n \tif (type == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n@@ -4223,17 +4204,17 @@ tsubst (t, args, nargs, in_decl)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       return fold (build (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t  tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t\t\t  tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl)));\n+\t\t\t  tsubst (TREE_OPERAND (t, 0), args, in_decl),\n+\t\t\t  tsubst (TREE_OPERAND (t, 1), args, in_decl)));\n \n     case NEGATE_EXPR:\n     case NOP_EXPR:\n       return fold (build1 (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t   tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl)));\n+\t\t\t   tsubst (TREE_OPERAND (t, 0), args, in_decl)));\n \n     case TYPENAME_TYPE:\n       {\n-\ttree ctx = tsubst (TYPE_CONTEXT (t), args, nargs, in_decl);\n+\ttree ctx = tsubst (TYPE_CONTEXT (t), args, in_decl);\n \ttree f = make_typename_type (ctx, TYPE_IDENTIFIER (t));\n \treturn cp_build_type_variant\n \t  (f, TYPE_READONLY (f) || TYPE_READONLY (t),\n@@ -4242,28 +4223,28 @@ tsubst (t, args, nargs, in_decl)\n \n     case INDIRECT_REF:\n       return make_pointer_declarator\n-\t(type, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl));\n+\t(type, tsubst (TREE_OPERAND (t, 0), args, in_decl));\n       \n     case ADDR_EXPR:\n       return make_reference_declarator\n-\t(type, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl));\n+\t(type, tsubst (TREE_OPERAND (t, 0), args, in_decl));\n \n     case ARRAY_REF:\n       return build_parse_node\n-\t(ARRAY_REF, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\t(ARRAY_REF, tsubst (TREE_OPERAND (t, 0), args, in_decl),\n+\t tsubst_expr (TREE_OPERAND (t, 1), args, in_decl));\n \n     case CALL_EXPR:\n       return make_call_declarator\n-\t(tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl),\n+\t(tsubst (TREE_OPERAND (t, 0), args, in_decl),\n+\t tsubst (TREE_OPERAND (t, 1), args, in_decl),\n \t TREE_OPERAND (t, 2),\n-\t tsubst (TREE_TYPE (t), args, nargs, in_decl));\n+\t tsubst (TREE_TYPE (t), args, in_decl));\n \n     case SCOPE_REF:\n       return build_parse_node\n-\t(TREE_CODE (t), tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\t(TREE_CODE (t), tsubst (TREE_OPERAND (t, 0), args, in_decl),\n+\t tsubst (TREE_OPERAND (t, 1), args, in_decl));\n \n     default:\n       sorry (\"use of `%s' in template\",\n@@ -4306,9 +4287,8 @@ do_poplevel ()\n    tsubst_expr.  */\n \n tree\n-tsubst_copy (t, args, nargs, in_decl)\n+tsubst_copy (t, args, in_decl)\n      tree t, args;\n-     int nargs;\n      tree in_decl;\n {\n   enum tree_code code;\n@@ -4327,7 +4307,7 @@ tsubst_copy (t, args, nargs, in_decl)\n     case FIELD_DECL:\n       if (DECL_CONTEXT (t))\n \t{\n-\t  tree ctx = tsubst (DECL_CONTEXT (t), args, nargs, in_decl);\n+\t  tree ctx = tsubst (DECL_CONTEXT (t), args, in_decl);\n \t  if (ctx == current_function_decl)\n \t    return lookup_name (DECL_NAME (t), 0);\n \t  else if (ctx != DECL_CONTEXT (t))\n@@ -4338,13 +4318,13 @@ tsubst_copy (t, args, nargs, in_decl)\n     case VAR_DECL:\n     case FUNCTION_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n-\tt = tsubst (t, args, nargs, in_decl);\n+\tt = tsubst (t, args, in_decl);\n       mark_used (t);\n       return t;\n \n     case TEMPLATE_DECL:\n       if (is_member_template (t))\n-\treturn tsubst (t, args, nargs, in_decl);\n+\treturn tsubst (t, args, in_decl);\n       else\n \treturn t;\n \n@@ -4359,8 +4339,8 @@ tsubst_copy (t, args, nargs, in_decl)\n     case STATIC_CAST_EXPR:\n     case DYNAMIC_CAST_EXPR:\n       return build1\n-\t(code, tsubst (TREE_TYPE (t), args, nargs, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl));\n+\t(code, tsubst (TREE_TYPE (t), args, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 0), args, in_decl));\n \n     case INDIRECT_REF:\n     case PREDECREMENT_EXPR:\n@@ -4379,7 +4359,7 @@ tsubst_copy (t, args, nargs, in_decl)\n     case TYPEID_EXPR:\n       return build1\n \t(code, NULL_TREE,\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl));\n+\t tsubst_copy (TREE_OPERAND (t, 0), args, in_decl));\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -4418,19 +4398,19 @@ tsubst_copy (t, args, nargs, in_decl)\n     case DOTSTAR_EXPR:\n     case MEMBER_REF:\n       return build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, in_decl));\n \n     case CALL_EXPR:\n       {\n \ttree fn = TREE_OPERAND (t, 0);\n \tif (is_overloaded_fn (fn))\n-\t  fn = tsubst_copy (get_first_fn (fn), args, nargs, in_decl);\n+\t  fn = tsubst_copy (get_first_fn (fn), args, in_decl);\n \telse\n \t  /* Sometimes FN is a LOOKUP_EXPR.  */\n-\t  fn = tsubst_copy (fn, args, nargs, in_decl);\n+\t  fn = tsubst_copy (fn, args, in_decl);\n \treturn build_nt\n-\t  (code, fn, tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl),\n+\t  (code, fn, tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n \t   NULL_TREE);\n       }\n \n@@ -4439,23 +4419,23 @@ tsubst_copy (t, args, nargs, in_decl)\n \ttree name = TREE_OPERAND (t, 0);\n \tif (TREE_CODE (name) == BIT_NOT_EXPR)\n \t  {\n-\t    name = tsubst_copy (TREE_OPERAND (name, 0), args, nargs, in_decl);\n+\t    name = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, TYPE_MAIN_VARIANT (name));\n \t  }\n \telse if (TREE_CODE (name) == SCOPE_REF\n \t\t && TREE_CODE (TREE_OPERAND (name, 1)) == BIT_NOT_EXPR)\n \t  {\n-\t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args, nargs, in_decl);\n+\t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n \t    name = TREE_OPERAND (name, 1);\n-\t    name = tsubst_copy (TREE_OPERAND (name, 0), args, nargs, in_decl);\n+\t    name = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, TYPE_MAIN_VARIANT (name));\n \t    name = build_nt (SCOPE_REF, base, name);\n \t  }\n \telse\n-\t  name = tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+\t  name = tsubst_copy (TREE_OPERAND (t, 0), args, in_decl);\n \treturn build_nt\n-\t  (code, name, tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 2), args, nargs, in_decl),\n+\t  (code, name, tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 2), args, in_decl),\n \t   NULL_TREE);\n       }\n \n@@ -4464,9 +4444,9 @@ tsubst_copy (t, args, nargs, in_decl)\n     case MODOP_EXPR:\n       {\n \ttree r = build_nt\n-\t  (code, tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 2), args, nargs, in_decl));\n+\t  (code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 2), args, in_decl));\n \n \tif (code == BIND_EXPR && !processing_template_decl)\n \t  {\n@@ -4477,7 +4457,7 @@ tsubst_copy (t, args, nargs, in_decl)\n \t       build_expr_from_tree.  So, we need to expand the\n \t       BIND_EXPR here.  */ \n \t    tree rtl_exp = expand_start_stmt_expr();\n-\t    tsubst_expr (TREE_OPERAND (r, 1), args, nargs, in_decl);\n+\t    tsubst_expr (TREE_OPERAND (r, 1), args, in_decl);\n \t    rtl_exp = expand_end_stmt_expr (rtl_exp);\n \t    TREE_SIDE_EFFECTS (rtl_exp) = 1;\n \t    return build (BIND_EXPR, TREE_TYPE (rtl_exp), \n@@ -4490,18 +4470,18 @@ tsubst_copy (t, args, nargs, in_decl)\n     case NEW_EXPR:\n       {\n \ttree r = build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 2), args, nargs, in_decl));\n+\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 2), args, in_decl));\n \tNEW_EXPR_USE_GLOBAL (r) = NEW_EXPR_USE_GLOBAL (t);\n \treturn r;\n       }\n \n     case DELETE_EXPR:\n       {\n \ttree r = build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, in_decl));\n \tDELETE_EXPR_USE_GLOBAL (r) = DELETE_EXPR_USE_GLOBAL (t);\n \tDELETE_EXPR_USE_VEC (r) = DELETE_EXPR_USE_VEC (t);\n \treturn r;\n@@ -4510,13 +4490,13 @@ tsubst_copy (t, args, nargs, in_decl)\n     case TEMPLATE_ID_EXPR:\n       {\n         /* Substituted template arguments */\n-\ttree targs = tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+\ttree targs = tsubst_copy (TREE_OPERAND (t, 1), args, in_decl);\n \ttree chain;\n \tfor (chain = targs; chain; chain = TREE_CHAIN (chain))\n \t  TREE_VALUE (chain) = maybe_fold_nontype_arg (TREE_VALUE (chain));\n \n \treturn lookup_template_function\n-\t  (tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl), targs);\n+\t  (tsubst_copy (TREE_OPERAND (t, 0), args, in_decl), targs);\n       }\n \n     case TREE_LIST:\n@@ -4528,13 +4508,13 @@ tsubst_copy (t, args, nargs, in_decl)\n \n \tpurpose = TREE_PURPOSE (t);\n \tif (purpose)\n-\t  purpose = tsubst_copy (purpose, args, nargs, in_decl);\n+\t  purpose = tsubst_copy (purpose, args, in_decl);\n \tvalue = TREE_VALUE (t);\n \tif (value)\n-\t  value = tsubst_copy (value, args, nargs, in_decl);\n+\t  value = tsubst_copy (value, args, in_decl);\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n-\t  chain = tsubst_copy (chain, args, nargs, in_decl);\n+\t  chain = tsubst_copy (chain, args, in_decl);\n \tif (purpose == TREE_PURPOSE (t)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n@@ -4557,19 +4537,19 @@ tsubst_copy (t, args, nargs, in_decl)\n     case ARRAY_TYPE:\n     case TYPENAME_TYPE:\n     case TYPE_DECL:\n-      return tsubst (t, args, nargs, in_decl);\n+      return tsubst (t, args, in_decl);\n \n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n \treturn build_typename_overload\n-\t  (tsubst (TREE_TYPE (t), args, nargs, in_decl));\n+\t  (tsubst (TREE_TYPE (t), args, in_decl));\n       else\n \treturn t;\n \n     case CONSTRUCTOR:\n       return build\n-\t(CONSTRUCTOR, tsubst (TREE_TYPE (t), args, nargs, in_decl), NULL_TREE,\n-\t tsubst_copy (CONSTRUCTOR_ELTS (t), args, nargs, in_decl));\n+\t(CONSTRUCTOR, tsubst (TREE_TYPE (t), args, in_decl), NULL_TREE,\n+\t tsubst_copy (CONSTRUCTOR_ELTS (t), args, in_decl));\n \n     default:\n       return t;\n@@ -4579,31 +4559,30 @@ tsubst_copy (t, args, nargs, in_decl)\n /* Like tsubst_copy, but also does semantic processing and RTL expansion.  */\n \n tree\n-tsubst_expr (t, args, nargs, in_decl)\n+tsubst_expr (t, args, in_decl)\n      tree t, args;\n-     int nargs;\n      tree in_decl;\n {\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n   if (processing_template_decl)\n-    return tsubst_copy (t, args, nargs, in_decl);\n+    return tsubst_copy (t, args, in_decl);\n \n   switch (TREE_CODE (t))\n     {\n     case RETURN_STMT:\n       lineno = TREE_COMPLEXITY (t);\n       emit_line_note (input_filename, lineno);\n       c_expand_return\n-\t(tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl));\n+\t(tsubst_expr (TREE_OPERAND (t, 0), args, in_decl));\n       finish_stmt ();\n       break;\n \n     case EXPR_STMT:\n       lineno = TREE_COMPLEXITY (t);\n       emit_line_note (input_filename, lineno);\n-      t = tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+      t = tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n       /* Do default conversion if safe and possibly important,\n \t in case within ({...}).  */\n       if ((TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE && lvalue_p (t))\n@@ -4622,10 +4601,10 @@ tsubst_expr (t, args, nargs, in_decl)\n \tlineno = TREE_COMPLEXITY (t);\n \temit_line_note (input_filename, lineno);\n \tdcl = start_decl\n-\t  (tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t   tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl),\n+\t  (tsubst (TREE_OPERAND (t, 0), args, in_decl),\n+\t   tsubst (TREE_OPERAND (t, 1), args, in_decl),\n \t   TREE_OPERAND (t, 2) != 0);\n-\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, nargs, in_decl);\n+\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, in_decl);\n \tcp_finish_decl\n \t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n \tresume_momentary (i);\n@@ -4645,26 +4624,26 @@ tsubst_expr (t, args, nargs, in_decl)\n \tif (init_scope)\n \t  do_pushlevel ();\n \tfor (tmp = TREE_OPERAND (t, 0); tmp; tmp = TREE_CHAIN (tmp))\n-\t  tsubst_expr (tmp, args, nargs, in_decl);\n+\t  tsubst_expr (tmp, args, in_decl);\n \temit_nop ();\n \temit_line_note (input_filename, lineno);\n \texpand_start_loop_continue_elsewhere (1); \n \n \tif (cond_scope)\n \t  do_pushlevel ();\n-\ttmp = tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+\ttmp = tsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n \temit_line_note (input_filename, lineno);\n \tif (tmp)\n \t  expand_exit_loop_if_false (0, condition_conversion (tmp));\n \n \tif (! cond_scope)\n \t  do_pushlevel ();\n-\ttsubst_expr (TREE_OPERAND (t, 3), args, nargs, in_decl);\n+\ttsubst_expr (TREE_OPERAND (t, 3), args, in_decl);\n \tdo_poplevel ();\n \n \temit_line_note (input_filename, lineno);\n \texpand_loop_continue_here ();\n-\ttmp = tsubst_expr (TREE_OPERAND (t, 2), args, nargs, in_decl);\n+\ttmp = tsubst_expr (TREE_OPERAND (t, 2), args, in_decl);\n \tif (tmp)\n \t  cplus_expand_expr_stmt (tmp);\n \n@@ -4687,13 +4666,13 @@ tsubst_expr (t, args, nargs, in_decl)\n \tcond = TREE_OPERAND (t, 0);\n \tif (TREE_CODE (cond) == DECL_STMT)\n \t  do_pushlevel ();\n-\tcond = tsubst_expr (cond, args, nargs, in_decl);\n+\tcond = tsubst_expr (cond, args, in_decl);\n \temit_line_note (input_filename, lineno);\n \texpand_exit_loop_if_false (0, condition_conversion (cond));\n \n \tif (TREE_CODE (TREE_OPERAND (t, 0)) != DECL_STMT)\n \t  do_pushlevel ();\n-\ttsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+\ttsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n \tdo_poplevel ();\n \n \texpand_end_loop ();\n@@ -4710,10 +4689,10 @@ tsubst_expr (t, args, nargs, in_decl)\n \temit_line_note (input_filename, lineno);\n \texpand_start_loop_continue_elsewhere (1); \n \n-\ttsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+\ttsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n \texpand_loop_continue_here ();\n \n-\tcond = tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+\tcond = tsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n \temit_line_note (input_filename, lineno);\n \texpand_exit_loop_if_false (0, condition_conversion (cond));\n \texpand_end_loop ();\n@@ -4731,17 +4710,17 @@ tsubst_expr (t, args, nargs, in_decl)\n \tlineno = TREE_COMPLEXITY (t);\n \tif (cond_scope)\n \t  do_pushlevel ();\n-\ttmp = tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+\ttmp = tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n \temit_line_note (input_filename, lineno);\n \texpand_start_cond (condition_conversion (tmp), 0);\n \t\n \tif (tmp = TREE_OPERAND (t, 1), tmp)\n-\t  tsubst_expr (tmp, args, nargs, in_decl);\n+\t  tsubst_expr (tmp, args, in_decl);\n \n \tif (tmp = TREE_OPERAND (t, 2), tmp)\n \t  {\n \t    expand_start_else ();\n-\t    tsubst_expr (tmp, args, nargs, in_decl);\n+\t    tsubst_expr (tmp, args, in_decl);\n \t  }\n \n \texpand_end_cond ();\n@@ -4763,7 +4742,7 @@ tsubst_expr (t, args, nargs, in_decl)\n \t  do_pushlevel ();\n \n \tfor (; substmt; substmt = TREE_CHAIN (substmt))\n-\t  tsubst_expr (substmt, args, nargs, in_decl);\n+\t  tsubst_expr (substmt, args, in_decl);\n \n \tif (COMPOUND_STMT_NO_SCOPE (t) == 0)\n \t  do_poplevel ();\n@@ -4792,13 +4771,13 @@ tsubst_expr (t, args, nargs, in_decl)\n \tlineno = TREE_COMPLEXITY (t);\n \tif (cond_scope)\n \t  do_pushlevel ();\n-\tval = tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+\tval = tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n \temit_line_note (input_filename, lineno);\n \tc_expand_start_case (val);\n \tpush_switch ();\n \t\n \tif (tmp = TREE_OPERAND (t, 1), tmp)\n-\t  tsubst_expr (tmp, args, nargs, in_decl);\n+\t  tsubst_expr (tmp, args, in_decl);\n \n \texpand_end_case (val);\n \tpop_switch ();\n@@ -4811,8 +4790,8 @@ tsubst_expr (t, args, nargs, in_decl)\n       break;\n \n     case CASE_LABEL:\n-      do_case (tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t       tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+      do_case (tsubst_expr (TREE_OPERAND (t, 0), args, in_decl),\n+\t       tsubst_expr (TREE_OPERAND (t, 1), args, in_decl));\n       break;\n \n     case LABEL_DECL:\n@@ -4833,19 +4812,19 @@ tsubst_expr (t, args, nargs, in_decl)\n \t}\n       else\n \texpand_computed_goto\n-\t  (tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl));\n+\t  (tsubst_expr (TREE_OPERAND (t, 0), args, in_decl));\n       break;\n \n     case TRY_BLOCK:\n       lineno = TREE_COMPLEXITY (t);\n       emit_line_note (input_filename, lineno);\n       expand_start_try_stmts ();\n-      tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+      tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n       expand_start_all_catch ();\n       {\n \ttree handler = TREE_OPERAND (t, 1);\n \tfor (; handler; handler = TREE_CHAIN (handler))\n-\t  tsubst_expr (handler, args, nargs, in_decl);\n+\t  tsubst_expr (handler, args, in_decl);\n       }\n       expand_end_all_catch ();\n       break;\n@@ -4857,12 +4836,12 @@ tsubst_expr (t, args, nargs, in_decl)\n \t{\n \t  tree d = TREE_OPERAND (t, 0);\n \t  expand_start_catch_block\n-\t    (tsubst (TREE_OPERAND (d, 1), args, nargs, in_decl),\n-\t     tsubst (TREE_OPERAND (d, 0), args, nargs, in_decl));\n+\t    (tsubst (TREE_OPERAND (d, 1), args, in_decl),\n+\t     tsubst (TREE_OPERAND (d, 0), args, in_decl));\n \t}\n       else\n \texpand_start_catch_block (NULL_TREE, NULL_TREE);\n-      tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+      tsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n       expand_end_catch_block ();\n       do_poplevel ();\n       break;\n@@ -4871,11 +4850,11 @@ tsubst_expr (t, args, nargs, in_decl)\n       lineno = TREE_COMPLEXITY (t);\n       t = TREE_TYPE (t);\n       if (TREE_CODE (t) == ENUMERAL_TYPE)\n-\ttsubst_enum (t, args, nargs, NULL);\n+\ttsubst_enum (t, args, NULL);\n       break;\n \n     default:\n-      return build_expr_from_tree (tsubst_copy (t, args, nargs, in_decl));\n+      return build_expr_from_tree (tsubst_copy (t, args, in_decl));\n     }\n   return NULL_TREE;\n }\n@@ -4928,7 +4907,7 @@ instantiate_template (tmpl, targ_ptr)\n   targ_ptr = copy_to_permanent (targ_ptr);\n \n   /* substitute template parameters */\n-  fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr, len, tmpl);\n+  fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr, tmpl);\n \n   if (flag_external_templates)\n     add_pending_template (fndecl);\n@@ -5665,10 +5644,7 @@ get_bindings (fn, decl, explicit_args)\n   if (i == 0)\n     {\n       /* Check to see that the resulting return type is also OK.  */\n-      tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)),\n-\t\t       targs,\n-\t\t       DECL_NTPARMS (fn),\n-\t\t       NULL_TREE);\n+      tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)), targs, NULL_TREE);\n \n       if (!comptypes (t, TREE_TYPE (TREE_TYPE (decl)), 1))\n \treturn NULL_TREE;\n@@ -6055,7 +6031,7 @@ instantiate_decl (d)\n     {\n       pushclass (DECL_CONTEXT (d), 2);\n       DECL_INITIAL (d) = tsubst_expr (DECL_INITIAL (code_pattern), args,\n-\t\t\t\t      TREE_VEC_LENGTH (args), tmpl);\n+\t\t\t\t      tmpl);\n       cp_finish_decl (d, DECL_INITIAL (d), NULL_TREE, 0, LOOKUP_NORMAL);\n     }\n \n@@ -6105,7 +6081,7 @@ instantiate_decl (d)\n   save_ti = DECL_TEMPLATE_INFO (decl_pattern);\n   DECL_TEMPLATE_INFO (decl_pattern) = NULL_TREE;\n   temp = innermost_args (args, DECL_TEMPLATE_SPECIALIZATION (decl_pattern));\n-  td = tsubst (decl_pattern, temp, 0, tmpl);\n+  td = tsubst (decl_pattern, temp, tmpl);\n   SET_DECL_IMPLICIT_INSTANTIATION (td);\n   DECL_TEMPLATE_INFO (decl_pattern) = save_ti;\n \n@@ -6114,7 +6090,7 @@ instantiate_decl (d)\n     {\n       pushclass (DECL_CONTEXT (d), 2);\n       DECL_INITIAL (td) = tsubst_expr (DECL_INITIAL (code_pattern), args,\n-\t\t\t\t       TREE_VEC_LENGTH (args), tmpl);\n+\t\t\t\t       tmpl);\n       popclass (1);\n     }\n \n@@ -6155,8 +6131,7 @@ instantiate_decl (d)\n \t{\n \t  store_return_init\n \t    (TREE_OPERAND (t, 0),\n-\t     tsubst_expr (TREE_OPERAND (t, 1), args,\n-\t\t\t  TREE_VEC_LENGTH (args), tmpl));\n+\t     tsubst_expr (TREE_OPERAND (t, 1), args, tmpl));\n \t  t = TREE_CHAIN (t);\n \t}\n \n@@ -6176,7 +6151,7 @@ instantiate_decl (d)\n       keep_next_level ();\n \n       my_friendly_assert (TREE_CODE (t) == COMPOUND_STMT, 42);\n-      tsubst_expr (t, args, TREE_VEC_LENGTH (args), tmpl);\n+      tsubst_expr (t, args, tmpl);\n \n       finish_function (lineno, 0, nested);\n     }\n@@ -6197,13 +6172,12 @@ tsubst_chain (t, argvec)\n {\n   if (t)\n     {\n-      tree first = tsubst (t, argvec,\n-\t\t\t   TREE_VEC_LENGTH (argvec), NULL_TREE);\n+      tree first = tsubst (t, argvec, NULL_TREE);\n       tree last = first;\n \n       for (t = TREE_CHAIN (t); t; t = TREE_CHAIN (t))\n \t{\n-\t  tree x = tsubst (t, argvec, TREE_VEC_LENGTH (argvec), NULL_TREE);\n+\t  tree x = tsubst (t, argvec, NULL_TREE);\n \t  TREE_CHAIN (last) = x;\n \t  last = x;\n \t}\n@@ -6222,10 +6196,8 @@ tsubst_expr_values (t, argvec)\n \n   for (; t; t = TREE_CHAIN (t))\n     {\n-      tree pur = tsubst_copy (TREE_PURPOSE (t), argvec,\n-\t\t\t      TREE_VEC_LENGTH (argvec), NULL_TREE);\n-      tree val = tsubst_expr (TREE_VALUE (t), argvec,\n-\t\t\t      TREE_VEC_LENGTH (argvec), NULL_TREE);\n+      tree pur = tsubst_copy (TREE_PURPOSE (t), argvec, NULL_TREE);\n+      tree val = tsubst_expr (TREE_VALUE (t), argvec, NULL_TREE);\n       *p = build_tree_list (pur, val);\n       p = &TREE_CHAIN (*p);\n     }\n@@ -6291,9 +6263,8 @@ add_maybe_template (d, fns)\n    tsubst_expr.  */\n \n static tree\n-tsubst_enum (tag, args, nargs, field_chain)\n+tsubst_enum (tag, args, field_chain)\n      tree tag, args;\n-     int nargs;\n      tree * field_chain;\n {\n   extern tree current_local_enum;\n@@ -6306,7 +6277,7 @@ tsubst_enum (tag, args, nargs, field_chain)\n     {\n       tree elt = build_enumerator (TREE_PURPOSE (e),\n \t\t\t\t   tsubst_expr (TREE_VALUE (e), args,\n-\t\t\t\t\t\tnargs, NULL_TREE));\n+\t\t\t\t\t\tNULL_TREE));\n       TREE_CHAIN (elt) = values;\n       values = elt;\n     }"}]}