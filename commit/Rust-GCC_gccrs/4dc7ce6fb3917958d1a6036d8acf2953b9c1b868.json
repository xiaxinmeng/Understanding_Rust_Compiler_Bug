{"sha": "4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "node_id": "C_kwDOANBUbNoAKDRkYzdjZTZmYjM5MTc5NThkMWE2MDM2ZDhhY2YyOTUzYjljMWI4Njg", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-10-01T17:50:25Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-10-01T17:57:05Z"}, "message": "Enhance -Waddress to detect more suspicious expressions [PR102103].\n\nResolves:\nPR c/102103 - missing warning comparing array address to null\n\ngcc/ChangeLog:\n\n\tPR c/102103\n\t* doc/invoke.texi (-Waddress): Update.\n\t* gengtype.c (write_types): Avoid -Waddress.\n\t* poly-int.h (POLY_SET_COEFF): Avoid using null.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/102103\n\t* c-common.c (decl_with_nonnull_addr_p): Handle members.\n\tCheck and perform warning suppression.\n\t(c_common_truthvalue_conversion): Enhance warning suppression.\n\ngcc/c/ChangeLog:\n\n\tPR c/102103\n\t* c-typeck.c (maybe_warn_for_null_address): New function.\n\t(build_binary_op): Call it.\n\ngcc/cp/ChangeLog:\n\n\tPR c/102103\n\t* typeck.c (warn_for_null_address): Enhance.\n\t(cp_build_binary_op): Call it also for member pointers.\n\ngcc/fortran/ChangeLog:\n\n\tPR c/102103\n\t* array.c: Remove an unnecessary test.\n\t* trans-array.c: Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/102103\n\t* g++.dg/cpp0x/constexpr-array-ptr10.C: Suppress a valid warning.\n\t* g++.dg/warn/Wreturn-local-addr-6.C: Correct a cast.\n\t* gcc.dg/Waddress.c: Expect a warning.\n\t* c-c++-common/Waddress-3.c: New test.\n\t* c-c++-common/Waddress-4.c: New test.\n\t* g++.dg/warn/Waddress-5.C: New test.\n\t* g++.dg/warn/Waddress-6.C: New test.\n\t* g++.dg/warn/pr101219.C: Expect a warning.\n\t* gcc.dg/Waddress-3.c: New test.", "tree": {"sha": "dbf4c85270f34d710113d1bdeb3883cd32d6ff01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf4c85270f34d710113d1bdeb3883cd32d6ff01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1710910087fb1f4a7706e9ce838163ffcbc50b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1710910087fb1f4a7706e9ce838163ffcbc50b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1710910087fb1f4a7706e9ce838163ffcbc50b4"}], "stats": {"total": 797, "additions": 722, "deletions": 75}, "files": [{"sha": "9d19e3527258d08a54faa34f5ce30d4f072b548f", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -3393,14 +3393,16 @@ c_wrap_maybe_const (tree expr, bool non_const)\n   return expr;\n }\n \n-/* Return whether EXPR is a declaration whose address can never be\n-   NULL.  */\n+/* Return whether EXPR is a declaration whose address can never be NULL.\n+   The address of the first struct member could be NULL only if it were\n+   accessed through a NULL pointer, and such an access would be invalid.  */\n \n bool\n decl_with_nonnull_addr_p (const_tree expr)\n {\n   return (DECL_P (expr)\n-\t  && (TREE_CODE (expr) == PARM_DECL\n+\t  && (TREE_CODE (expr) == FIELD_DECL\n+\t      || TREE_CODE (expr) == PARM_DECL\n \t      || TREE_CODE (expr) == LABEL_DECL\n \t      || !DECL_WEAK (expr)));\n }\n@@ -3488,13 +3490,17 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n     case ADDR_EXPR:\n       {\n  \ttree inner = TREE_OPERAND (expr, 0);\n-\tif (decl_with_nonnull_addr_p (inner))\n+\tif (decl_with_nonnull_addr_p (inner)\n+\t    /* Check both EXPR and INNER for suppression.  */\n+\t    && !warning_suppressed_p (expr, OPT_Waddress)\n+\t    && !warning_suppressed_p (inner, OPT_Waddress))\n \t  {\n-\t    /* Common Ada programmer's mistake.  */\n+\t    /* Common Ada programmer's mistake.\t */\n \t    warning_at (location,\n \t\t\tOPT_Waddress,\n \t\t\t\"the address of %qD will always evaluate as %<true%>\",\n \t\t\tinner);\n+\t    suppress_warning (inner, OPT_Waddress);\n \t    return truthvalue_true_node;\n \t  }\n \tbreak;\n@@ -3627,8 +3633,17 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t  break;\n \t/* If this isn't narrowing the argument, we can ignore it.  */\n \tif (TYPE_PRECISION (totype) >= TYPE_PRECISION (fromtype))\n-\t  return c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t TREE_OPERAND (expr, 0));\n+\t  {\n+\t    tree op0 = TREE_OPERAND (expr, 0);\n+\t    if ((TREE_CODE (fromtype) == POINTER_TYPE\n+\t\t && TREE_CODE (totype) == INTEGER_TYPE)\n+\t\t|| warning_suppressed_p (expr, OPT_Waddress))\n+\t      /* Suppress -Waddress for casts to intptr_t, propagating\n+\t\t any suppression from the enclosing expression to its\n+\t\t operand.  */\n+\t      suppress_warning (op0, OPT_Waddress);\n+\t    return c_common_truthvalue_conversion (location, op0);\n+\t  }\n       }\n       break;\n "}, {"sha": "33963d7555ad7a819940ca848eaeeae56b7593b0", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 106, "deletions": 34, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -11554,6 +11554,110 @@ build_vec_cmp (tree_code code, tree type,\n   return build3 (VEC_COND_EXPR, type, cmp, minus_one_vec, zero_vec);\n }\n \n+/* Possibly warn about an address of OP never being NULL in a comparison\n+   operation CODE involving null.  */\n+\n+static void\n+maybe_warn_for_null_address (location_t loc, tree op, tree_code code)\n+{\n+  if (!warn_address || warning_suppressed_p (op, OPT_Waddress))\n+    return;\n+\n+  if (TREE_CODE (op) == NOP_EXPR)\n+    {\n+      /* Allow casts to intptr_t to suppress the warning.  */\n+      tree type = TREE_TYPE (op);\n+      if (TREE_CODE (type) == INTEGER_TYPE)\n+\treturn;\n+      op = TREE_OPERAND (op, 0);\n+    }\n+\n+  if (TREE_CODE (op) == POINTER_PLUS_EXPR)\n+    {\n+      /* Allow a cast to void* to suppress the warning.  */\n+      tree type = TREE_TYPE (TREE_TYPE (op));\n+      if (VOID_TYPE_P (type))\n+\treturn;\n+\n+      /* Adding any value to a null pointer, including zero, is undefined\n+\t in C.  This includes the expression &p[0] where p is the null\n+\t pointer, although &p[0] will have been folded to p by this point\n+\t and so not diagnosed.  */\n+      if (code == EQ_EXPR)\n+\twarning_at (loc, OPT_Waddress,\n+\t\t    \"the comparison will always evaluate as %<false%> \"\n+\t\t    \"for the pointer operand in %qE must not be NULL\",\n+\t\t    op);\n+      else\n+\twarning_at (loc, OPT_Waddress,\n+\t\t    \"the comparison will always evaluate as %<true%> \"\n+\t\t    \"for the pointer operand in %qE must not be NULL\",\n+\t\t    op);\n+\n+      return;\n+    }\n+\n+  if (TREE_CODE (op) != ADDR_EXPR)\n+    return;\n+\n+  op = TREE_OPERAND (op, 0);\n+\n+  if (TREE_CODE (op) == IMAGPART_EXPR\n+      || TREE_CODE (op) == REALPART_EXPR)\n+    {\n+      /* The address of either complex part may not be null.  */\n+      if (code == EQ_EXPR)\n+\twarning_at (loc, OPT_Waddress,\n+\t\t    \"the comparison will always evaluate as %<false%> \"\n+\t\t    \"for the address of %qE will never be NULL\",\n+\t\t    op);\n+      else\n+\twarning_at (loc, OPT_Waddress,\n+\t\t    \"the comparison will always evaluate as %<true%> \"\n+\t\t    \"for the address of %qE will never be NULL\",\n+\t\t    op);\n+      return;\n+    }\n+\n+  /* Set to true in the loop below if OP dereferences is operand.\n+     In such a case the ultimate target need not be a decl for\n+     the null [in]equality test to be constant.  */\n+  bool deref = false;\n+\n+  /* Get the outermost array or object, or member.  */\n+  while (handled_component_p (op))\n+    {\n+      if (TREE_CODE (op) == COMPONENT_REF)\n+\t{\n+\t  /* Get the member (its address is never null).  */\n+\t  op = TREE_OPERAND (op, 1);\n+\t  break;\n+\t}\n+\n+      /* Get the outer array/object to refer to in the warning.  */\n+      op = TREE_OPERAND (op, 0);\n+      deref = true;\n+    }\n+\n+  if ((!deref && !decl_with_nonnull_addr_p (op))\n+      || from_macro_expansion_at (loc))\n+    return;\n+\n+  if (code == EQ_EXPR)\n+    warning_at (loc, OPT_Waddress,\n+\t\t\"the comparison will always evaluate as %<false%> \"\n+\t\t\"for the address of %qE will never be NULL\",\n+\t\top);\n+  else\n+    warning_at (loc, OPT_Waddress,\n+\t\t\"the comparison will always evaluate as %<true%> \"\n+\t\t\"for the address of %qE will never be NULL\",\n+\t\top);\n+\n+  if (DECL_P (op))\n+    inform (DECL_SOURCE_LOCATION (op), \"%qD declared here\", op);\n+}\n+\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    LOCATION is the operator's location.\n@@ -12189,44 +12293,12 @@ build_binary_op (location_t location, enum tree_code code,\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n-\t  if (TREE_CODE (op0) == ADDR_EXPR\n-\t      && decl_with_nonnull_addr_p (TREE_OPERAND (op0, 0))\n-\t      && !from_macro_expansion_at (location))\n-\t    {\n-\t      if (code == EQ_EXPR)\n-\t\twarning_at (location,\n-\t\t\t    OPT_Waddress,\n-\t\t\t    \"the comparison will always evaluate as %<false%> \"\n-\t\t\t    \"for the address of %qD will never be NULL\",\n-\t\t\t    TREE_OPERAND (op0, 0));\n-\t      else\n-\t\twarning_at (location,\n-\t\t\t    OPT_Waddress,\n-\t\t\t    \"the comparison will always evaluate as %<true%> \"\n-\t\t\t    \"for the address of %qD will never be NULL\",\n-\t\t\t    TREE_OPERAND (op0, 0));\n-\t    }\n+\t  maybe_warn_for_null_address (location, op0, code);\n \t  result_type = type0;\n \t}\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n-\t  if (TREE_CODE (op1) == ADDR_EXPR\n-\t      && decl_with_nonnull_addr_p (TREE_OPERAND (op1, 0))\n-\t      && !from_macro_expansion_at (location))\n-\t    {\n-\t      if (code == EQ_EXPR)\n-\t\twarning_at (location,\n-\t\t\t    OPT_Waddress,\n-\t\t\t    \"the comparison will always evaluate as %<false%> \"\n-\t\t\t    \"for the address of %qD will never be NULL\",\n-\t\t\t    TREE_OPERAND (op1, 0));\n-\t      else\n-\t\twarning_at (location,\n-\t\t\t    OPT_Waddress,\n-\t\t\t    \"the comparison will always evaluate as %<true%> \"\n-\t\t\t    \"for the address of %qD will never be NULL\",\n-\t\t\t    TREE_OPERAND (op1, 0));\n-\t    }\n+\t  maybe_warn_for_null_address (location, op1, code);\n \t  result_type = type1;\n \t}\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)"}, {"sha": "e880d34dcfe60907d29d33532877b27482bcb6bf", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 82, "deletions": 12, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -4603,25 +4603,93 @@ warn_for_null_address (location_t location, tree op, tsubst_flags_t complain)\n       || warning_suppressed_p (op, OPT_Waddress))\n     return;\n \n+  if (TREE_CODE (op) == NON_DEPENDENT_EXPR)\n+    op = TREE_OPERAND (op, 0);\n+\n   tree cop = fold_for_warn (op);\n \n-  if (TREE_CODE (cop) == ADDR_EXPR\n-      && decl_with_nonnull_addr_p (TREE_OPERAND (cop, 0))\n-      && !warning_suppressed_p (cop, OPT_Waddress))\n-    warning_at (location, OPT_Waddress, \"the address of %qD will never \"\n-\t\t\"be NULL\", TREE_OPERAND (cop, 0));\n+  if (TREE_CODE (cop) == NON_LVALUE_EXPR)\n+    /* Unwrap the expression for C++ 98.  */\n+    cop = TREE_OPERAND (cop, 0);\n \n-  if (CONVERT_EXPR_P (op)\n+  if (TREE_CODE (cop) == PTRMEM_CST)\n+    {\n+      /* The address of a nonstatic data member is never null.  */\n+      warning_at (location, OPT_Waddress,\n+\t\t  \"the address %qE will never be NULL\",\n+\t\t  cop);\n+      return;\n+    }\n+\n+  if (TREE_CODE (cop) == NOP_EXPR)\n+    {\n+      /* Allow casts to intptr_t to suppress the warning.  */\n+      tree type = TREE_TYPE (cop);\n+      if (TREE_CODE (type) == INTEGER_TYPE)\n+\treturn;\n+\n+      STRIP_NOPS (cop);\n+    }\n+\n+  bool warned = false;\n+  if (TREE_CODE (cop) == ADDR_EXPR)\n+    {\n+      cop = TREE_OPERAND (cop, 0);\n+\n+      /* Set to true in the loop below if OP dereferences its operand.\n+\t In such a case the ultimate target need not be a decl for\n+\t the null [in]equality test to be necessarily constant.  */\n+      bool deref = false;\n+\n+      /* Get the outermost array or object, or member.  */\n+      while (handled_component_p (cop))\n+\t{\n+\t  if (TREE_CODE (cop) == COMPONENT_REF)\n+\t    {\n+\t      /* Get the member (its address is never null).  */\n+\t      cop = TREE_OPERAND (cop, 1);\n+\t      break;\n+\t    }\n+\n+\t  /* Get the outer array/object to refer to in the warning.  */\n+\t  cop = TREE_OPERAND (cop, 0);\n+\t  deref = true;\n+\t}\n+\n+      if ((!deref && !decl_with_nonnull_addr_p (cop))\n+\t  || from_macro_expansion_at (location)\n+\t  || warning_suppressed_p (cop, OPT_Waddress))\n+\treturn;\n+\n+      warned = warning_at (location, OPT_Waddress,\n+\t\t\t   \"the address of %qD will never be NULL\", cop);\n+      op = cop;\n+    }\n+  else if (TREE_CODE (cop) == POINTER_PLUS_EXPR)\n+    {\n+      /* Adding zero to the null pointer is well-defined in C++.  When\n+\t the offset is unknown (i.e., not a constant) warn anyway since\n+\t it's less likely that the pointer operand is null than not.  */\n+      tree off = TREE_OPERAND (cop, 1);\n+      if (!integer_zerop (off)\n+\t  && !warning_suppressed_p (cop, OPT_Waddress))\n+\twarning_at (location, OPT_Waddress, \"comparing the result of pointer \"\n+\t\t    \"addition %qE and NULL\", cop);\n+      return;\n+    }\n+  else if (CONVERT_EXPR_P (op)\n       && TYPE_REF_P (TREE_TYPE (TREE_OPERAND (op, 0))))\n     {\n-      tree inner_op = op;\n-      STRIP_NOPS (inner_op);\n+      STRIP_NOPS (op);\n \n-      if (DECL_P (inner_op))\n-\twarning_at (location, OPT_Waddress,\n-\t\t    \"the compiler can assume that the address of \"\n-\t\t    \"%qD will never be NULL\", inner_op);\n+      if (DECL_P (op))\n+\twarned = warning_at (location, OPT_Waddress,\n+\t\t\t     \"the compiler can assume that the address of \"\n+\t\t\t     \"%qD will never be NULL\", op);\n     }\n+\n+  if (warned && DECL_P (op))\n+    inform (DECL_SOURCE_LOCATION (op), \"%qD declared here\", op);\n }\n \n /* Warn about [expr.arith.conv]/2: If one operand is of enumeration type and\n@@ -5411,6 +5479,8 @@ cp_build_binary_op (const op_location_t &location,\n \t      op1 = cp_convert (TREE_TYPE (op0), op1, complain);\n \t    }\n \t  result_type = TREE_TYPE (op0);\n+\n+\t  warn_for_null_address (location, orig_op0, complain);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (orig_op0))\n \treturn cp_build_binary_op (location, code, op1, op0, complain);"}, {"sha": "d35114c0727d4db8c462653107d0b54baaf50120", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -8551,17 +8551,43 @@ by @option{-Wall}.\n @item -Waddress\n @opindex Waddress\n @opindex Wno-address\n-Warn about suspicious uses of memory addresses. These include using\n-the address of a function in a conditional expression, such as\n-@code{void func(void); if (func)}, and comparisons against the memory\n-address of a string literal, such as @code{if (x == \"abc\")}.  Such\n-uses typically indicate a programmer error: the address of a function\n-always evaluates to true, so their use in a conditional usually\n-indicate that the programmer forgot the parentheses in a function\n-call; and comparisons against string literals result in unspecified\n-behavior and are not portable in C, so they usually indicate that the\n-programmer intended to use @code{strcmp}.  This warning is enabled by\n-@option{-Wall}.\n+Warn about suspicious uses of address expressions. These include comparing\n+the address of a function or a declared object to the null pointer constant\n+such as in\n+@smallexample\n+void f (void);\n+void g (void)\n+@{\n+  if (!func)   // warning: expression evaluates to false\n+    abort ();\n+@}\n+@end smallexample\n+comparisons of a pointer to a string literal, such as in\n+@smallexample\n+void f (const char *x)\n+@{\n+  if (x == \"abc\")   // warning: expression evaluates to false\n+    puts (\"equal\");\n+@}\n+@end smallexample\n+and tests of the results of pointer addition or subtraction for equality\n+to null, such as in\n+@smallexample\n+void f (const int *p, int i)\n+@{\n+  return p + i == NULL;\n+@}\n+@end smallexample\n+Such uses typically indicate a programmer error: the address of most\n+functions and objects necessarily evaluates to true (the exception are\n+weak symbols), so their use in a conditional might indicate missing\n+parentheses in a function call or a missing dereference in an array\n+expression.  The subset of the warning for object pointers can be\n+suppressed by casting the pointer operand to an integer type such\n+as @code{inptr_t} or @code{uinptr_t}.\n+Comparisons against string literals result in unspecified behavior\n+and are not portable, and suggest the intent was to call @code{strcmp}.\n+@option{-Waddress} warning is enabled by @option{-Wall}.\n \n @item -Wno-address-of-packed-member\n @opindex Waddress-of-packed-member"}, {"sha": "6552eaf3b0ca5c7f74bb5d7060b2a79dd119a6c9", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -2581,7 +2581,7 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n \t    }\n \t}\n \n-      if (array->shape && array->shape[dimen])\n+      if (array->shape)\n \t{\n \t  mpz_init_set (*result, array->shape[dimen]);\n \t  return true;"}, {"sha": "e2f59e0823c1dbe01aa90b6026e766a70660551e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -5104,7 +5104,6 @@ set_loop_bounds (gfc_loopinfo *loop)\n \n \t  if (info->shape)\n \t    {\n-\t      gcc_assert (info->shape[dim]);\n \t      /* The frontend has worked out the size for us.  */\n \t      if (!loopspec[n]\n \t\t  || !specinfo->shape"}, {"sha": "a77cfd92bfab30d92d2bf075307c2dbd28dc6783", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -3685,8 +3685,8 @@ write_types (outf_p output_header, type_p structures,\n \toutput_mangled_typename (output_header, s);\n \toprintf (output_header, \"(X) do { \\\\\\n\");\n \toprintf (output_header,\n-\t\t \"  if (X != NULL) gt_%sx_%s (X);\\\\\\n\", wtd->prefix,\n-\t\t s_id_for_tag);\n+\t\t \"  if ((intptr_t)(X) != 0) gt_%sx_%s (X);\\\\\\n\",\n+\t\t wtd->prefix, s_id_for_tag);\n \toprintf (output_header, \"  } while (0)\\n\");\n \n \tfor (opt = s->u.s.opt; opt; opt = opt->next)"}, {"sha": "94e7b701f64ef9b986ac20db23eface010762aa1", "filename": "gcc/poly-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -324,10 +324,10 @@ struct poly_result<T1, T2, 2>\n    routine can take the address of RES rather than the address of\n    a temporary.\n \n-   The dummy comparison against a null C * is just a way of checking\n+   The dummy self-comparison against C * is just a way of checking\n    that C gives the right type.  */\n #define POLY_SET_COEFF(C, RES, I, VALUE) \\\n-  ((void) (&(RES).coeffs[0] == (C *) 0), \\\n+  ((void) (&(RES).coeffs[0] == (C *) (void *) &(RES).coeffs[0]), \\\n    wi::int_traits<C>::precision_type == wi::FLEXIBLE_PRECISION \\\n    ? (void) ((RES).coeffs[I] = VALUE) \\\n    : (void) ((RES).coeffs[I].~C (), new (&(RES).coeffs[I]) C (VALUE)))"}, {"sha": "9a13a444045cce02425b4b6b2ea9f8b67ce4ba1c", "filename": "gcc/testsuite/c-c++-common/Waddress-3.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWaddress-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWaddress-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWaddress-3.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -0,0 +1,125 @@\n+/* PR c/102103 - missing warning comparing array address to null\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __INTPTR_TYPE__  intptr_t;\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+#ifndef __cplusplus\n+#  define bool _Bool\n+#endif\n+\n+struct S { void *p, *a1[2], *a2[2][2]; } s, *p;\n+\n+extern const void *a1[2];\n+extern void *a2[2][2], *ax[];\n+\n+void T (bool);\n+\n+void test_array_eq_0 (int i)\n+{\n+  // Verify that casts intptr_t suppress the warning.\n+  T ((intptr_t)a1 == 0);\n+  T ((uintptr_t)a1 == 0);\n+  T (a1 == 0);          // { dg-warning \"-Waddress\" }\n+  T (0 == &a1);         // { dg-warning \"-Waddress\" }\n+  // Verify that casts to other pointer types don't suppress it.\n+  T ((void *)a1 == 0);  // { dg-warning \"-Waddress\" }\n+  T ((char *)a1 == 0);  // { dg-warning \"-Waddress\" }\n+  T (a1[0] == 0);\n+  T (0 == (intptr_t)&a1[0]);\n+  T (0 == &a1[0]);      // { dg-warning \"-Waddress\" }\n+  T (a1[i] == 0);\n+  T (0 == (uintptr_t)&a1[i]);\n+  T (0 == &a1[i]);      // { dg-warning \"-Waddress\" }\n+\n+  T ((intptr_t)a2 == 0);\n+  T (a2 == 0);          // { dg-warning \"-Waddress\" }\n+  T (0 == &a2);         // { dg-warning \"-Waddress\" }\n+  T (a2[0] == 0);       // { dg-warning \"-Waddress\" }\n+  T (0 == &a1[0]);      // { dg-warning \"-Waddress\" }\n+  T (a2[i] == 0);       // { dg-warning \"-Waddress\" }\n+  T (0 == &a2[i]);      // { dg-warning \"-Waddress\" }\n+  T (a2[0][0] == 0);\n+  T (0 == &a2[0][0]);   // { dg-warning \"-Waddress\" }\n+  T (&ax == 0);         // { dg-warning \"-Waddress\" }\n+  T (0 == &ax);         // { dg-warning \"-Waddress\" }\n+  T (&ax[0] == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == ax[0]);\n+}\n+\n+\n+void test_array_neq_0 (int i)\n+{\n+  // Verify that casts to intptr_t suppress the warning.\n+  T ((uintptr_t)a1);\n+\n+  T (a1);               // { dg-warning \"-Waddress\" }\n+  T ((void *)a1);       // { dg-warning \"-Waddress\" }\n+  T (&a1 != 0);         // { dg-warning \"-Waddress\" }\n+  T (a1[0]);\n+  T (&a1[0] != 0);      // { dg-warning \"-Waddress\" }\n+  T (a1[i]);\n+  T (&a1[i] != 0);      // { dg-warning \"-Waddress\" }\n+\n+  T ((intptr_t)a2);\n+  T (a2);               // { dg-warning \"-Waddress\" }\n+  T ((void *)a2);       // { dg-warning \"-Waddress\" }\n+  T ((char *)a2);       // { dg-warning \"-Waddress\" }\n+  T (&a2 != 0);         // { dg-warning \"-Waddress\" }\n+  T (a2[0]);            // { dg-warning \"-Waddress\" }\n+  T (&a1[0] != 0);      // { dg-warning \"-Waddress\" }\n+  T (a2[i]);            // { dg-warning \"-Waddress\" }\n+  T (&a2[i] != 0);      // { dg-warning \"-Waddress\" }\n+  T (a2[0][0]);\n+  T (&a2[0][0] != 0);   // { dg-warning \"-Waddress\" }\n+}\n+\n+\n+void test_member_array_eq_0 (int i)\n+{\n+  // Verify that casts to intptr_t suppress the warning.\n+  T ((intptr_t)s.a1 == 0);\n+  T (s.a1 == 0);        // { dg-warning \"-Waddress\" }\n+  T (0 == &a1);         // { dg-warning \"-Waddress\" }\n+  T (s.a1[0] == 0);\n+  T ((void*)s.a1);      // { dg-warning \"-Waddress\" }\n+  T (0 == &a1[0]);      // { dg-warning \"-Waddress\" }\n+  T (s.a1[i] == 0);\n+  T (0 == &a1[i]);      // { dg-warning \"-Waddress\" }\n+\n+  T ((uintptr_t)s.a2 == 0);\n+  T (s.a2 == 0);        // { dg-warning \"-Waddress\" }\n+  T (0 == &a2);         // { dg-warning \"-Waddress\" }\n+  T ((void *)s.a2 == 0);// { dg-warning \"-Waddress\" }\n+  T (s.a2[0] == 0);     // { dg-warning \"-Waddress\" }\n+  T (0 == &a1[0]);      // { dg-warning \"-Waddress\" }\n+  T (s.a2[i] == 0);     // { dg-warning \"-Waddress\" }\n+  T (0 == &a2[i]);      // { dg-warning \"-Waddress\" }\n+  T (s.a2[0][0] == 0);\n+  T (0 == &a2[0][0]); // { dg-warning \"-Waddress\" }\n+}\n+\n+\n+void test_member_array_neq_0 (int i)\n+{\n+  // Verify that casts to intptr_t suppress the warning.\n+  T ((uintptr_t)s.a1);\n+  T (s.a1);             // { dg-warning \"-Waddress\" }\n+  T (&s.a1 != 0);       // { dg-warning \"-Waddress\" }\n+  T ((void *)&s.a1[0]); // { dg-warning \"-Waddress\" }\n+  T (s.a1[0]);\n+  T (&s.a1[0] != 0);    // { dg-warning \"-Waddress\" }\n+  T (s.a1[i]);\n+  T (&s.a1[i] != 0);    // { dg-warning \"-Waddress\" }\n+\n+  T ((intptr_t)s.a2);\n+  T (s.a2);             // { dg-warning \"-Waddress\" }\n+  T (&s.a2 != 0);       // { dg-warning \"-Waddress\" }\n+  T (s.a2[0]);          // { dg-warning \"-Waddress\" }\n+  T (&s.a1[0] != 0);    // { dg-warning \"-Waddress\" }\n+  T (s.a2[i]);          // { dg-warning \"-Waddress\" }\n+  T (&s.a2[i] != 0);    // { dg-warning \"-Waddress\" }\n+  T (s.a2[0][0]);\n+  T (&s.a2[0][0] != 0); // { dg-warning \"-Waddress\" }\n+}"}, {"sha": "489a0cd717c3c521024becfffaa03ff60da336c7", "filename": "gcc/testsuite/c-c++-common/Waddress-4.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWaddress-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWaddress-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWaddress-4.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -0,0 +1,106 @@\n+/* PR c/102103 - missing warning comparing array address to null\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __INTPTR_TYPE__ uintptr_t;\n+\n+extern char *ax[], *a2[][2];\n+\n+void T (int);\n+\n+void test_ax_plus_eq_0 (int i)\n+{\n+  // Verify that casts to intptr_t suppress the warning.\n+  T ((intptr_t)(ax + 0) == 0);\n+  T ((uintptr_t)(ax + 1) == 0);\n+\n+  T (ax + 0 == 0);      // { dg-warning \"-Waddress\" }\n+  T (&ax[0] == 0);      // { dg-warning \"-Waddress\" }\n+  T (ax - 1 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &ax[-1]);     // { dg-warning \"-Waddress\" }\n+  T ((void *)(&ax[0] + 2) == 0);  // { dg-warning \"-Waddress\" }\n+  T (&ax[0] + 2 == 0);  // { dg-warning \"-Waddress\" }\n+  T (ax + 3 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &ax[-4]);     // { dg-warning \"-Waddress\" }\n+  T (ax - i == 0);      // { dg-warning \"-Waddress\" }\n+  T (&ax[i] == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &ax[1] + i);  // { dg-warning \"-Waddress\" }\n+}\n+\n+void test_a2_plus_eq_0 (int i)\n+{\n+  // Verify that casts to intptr_t suppress the warning.\n+  T ((intptr_t)(a2 + 0) == 0);\n+  T ((uintptr_t)(a2 + 1) == 0);\n+\n+  T (a2 + 0 == 0);      // { dg-warning \"-Waddress\" }\n+  // Verify that a cast to another pointer type doesn't suppress it.\n+  T ((void*)(a2 + 0) == 0);       // { dg-warning \"-Waddress\" }\n+  T ((char*)a2 + 1 == 0);         // { dg-warning \"-Waddress\" }\n+  T (&a2[0] == 0);      // { dg-warning \"-Waddress\" }\n+  T (a2 - 1 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &a2[-1]);     // { dg-warning \"-Waddress\" }\n+  T (a2 + 2 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &a2[-2]);     // { dg-warning \"-Waddress\" }\n+  T (a2 - i == 0);      // { dg-warning \"-Waddress\" }\n+  T (&a2[i] == 0);      // { dg-warning \"-Waddress\" }\n+}\n+\n+// Exercise a pointer.\n+void test_p_plus_eq_0 (int *p, int i)\n+{\n+  /* P + 0 and equivalently &P[0] are invalid for a null P but they're\n+     folded to p before the warning has a chance to trigger.  */\n+  T (p + 0 == 0);       // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+  T (&p[0] == 0);       // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+\n+  T (p - 1 == 0);       // { dg-warning \"-Waddress\" }\n+  T (0 == &p[-1]);      // { dg-warning \"-Waddress\" }\n+  T (p + 2 == 0);       // { dg-warning \"-Waddress\" }\n+  T (0 == &p[-2]);      // { dg-warning \"-Waddress\" }\n+  T (p - i == 0);       // { dg-warning \"-Waddress\" }\n+  T (&p[i] == 0);       // { dg-warning \"-Waddress\" }\n+}\n+\n+// Exercise pointer to array.\n+void test_pa_plus_eq_0 (int (*p)[], int (*p2)[][2], int i)\n+{\n+  // The array pointer may be null.\n+  T (*p == 0);\n+  /* &**P is equivalent to *P and might be the result od macro expansion.\n+     Verify it doesn't cause a warning.  */\n+  T (&**p == 0);\n+\n+  /* *P + 0 is invalid but folded to *P before the warning has a chance\n+     to trigger.  */\n+  T (*p + 0 == 0);      // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+\n+  T (&(*p)[0] == 0);    // { dg-warning \"-Waddress\" }\n+  T (*p - 1 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &(*p)[-1]);   // { dg-warning \"-Waddress\" }\n+  T (*p + 2 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &(*p)[-2]);   // { dg-warning \"-Waddress\" }\n+  T (*p - i == 0);      // { dg-warning \"-Waddress\" }\n+  T (&(*p)[i] == 0);    // { dg-warning \"-Waddress\" }\n+\n+\n+  /* Similar to the above but for a pointer to a two-dimensional array,\n+     referring to the higher-level element (i.e., an array itself).  */\n+  T (*p2 == 0);\n+  T (**p2 == 0);         // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+  T (&**p2 == 0);        // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+  T (&***p2 == 0);       // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+  T (&**p2 == 0);\n+\n+  T (*p2 + 0 == 0);      // { dg-warning \"-Waddress\" \"pr102555\" { xfail *-*-* } }\n+  T (&(*p2)[0] == 0);    // { dg-warning \"-Waddress\" }\n+  T (&(*p2)[0][1] == 0); // { dg-warning \"-Waddress\" }\n+  T (*p2 - 1 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &(*p2)[-1]);   // { dg-warning \"-Waddress\" }\n+  T (0 == &(*p2)[1][2]); // { dg-warning \"-Waddress\" }\n+  T (*p2 + 2 == 0);      // { dg-warning \"-Waddress\" }\n+  T (0 == &(*p2)[-2]);   // { dg-warning \"-Waddress\" }\n+  T (*p2 - i == 0);      // { dg-warning \"-Waddress\" }\n+  T (&(*p2)[i] == 0);    // { dg-warning \"-Waddress\" }\n+}"}, {"sha": "63295230d51cf0ca4d01b8957fa9c7e569ec220a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr10.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -85,8 +85,11 @@ extern __attribute__ ((weak)) int i;\n constexpr int *p1 = &i + 1;\n \n #pragma GCC diagnostic push\n+// Suppress warning: ordered comparison of pointer with integer zero.\n #pragma GCC diagnostic ignored \"-Wextra\"\n-// Suppress warning: ordered comparison of pointer with integer zero\n+// Also suppress -Waddress for comparisons of constant addresses to\n+// to null.\n+#pragma GCC diagnostic ignored \"-Waddress\"\n \n constexpr bool b0  = p1;        // { dg-error \"not a constant expression\" }\n constexpr bool b1  = p1 == 0;   // { dg-error \"not a constant expression\" }"}, {"sha": "b1ad38a811220b557e053e1bc8e0124113f7aa3a", "filename": "gcc/testsuite/g++.dg/warn/Waddress-5.C", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWaddress-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWaddress-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWaddress-5.C?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -0,0 +1,115 @@\n+/* PR c/102103 - missing warning comparing array address to null\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#if __cplusplus < 201103L\n+# define nullptr __null\n+#endif\n+\n+struct A\n+{\n+  void f ();\n+  virtual void vf ();\n+  virtual void pvf () = 0;\n+\n+  void sf ();\n+\n+  int *p;\n+  int a[2];\n+};\n+\n+void T (bool);\n+\n+void warn_memptr_if ()\n+{\n+  // Exercise warnings for addresses of nonstatic member functions.\n+  if (&A::f == 0)         // { dg-warning \"the address '&A::f'\" }\n+    T (0);\n+\n+  if (&A::vf)             // { dg-warning \"-Waddress\" }\n+    T (0);\n+\n+  if (&A::pvf != 0)       // { dg-warning \"-Waddress\" }\n+    T (0);\n+\n+  // Exercise warnings for addresses of static member functions.\n+  if (&A::sf == 0)        // { dg-warning \"-Waddress\" }\n+    T (0);\n+\n+  if (&A::sf)             // { dg-warning \"-Waddress\" }\n+    T (0);\n+\n+  // Exercise warnings for addresses of nonstatic data members.\n+  if (&A::p == 0)         // { dg-warning \"the address '&A::p'\" }\n+    T (0);\n+\n+  if (&A::a == nullptr)   // { dg-warning \"-Waddress\" }\n+    T (0);\n+}\n+\n+void warn_memptr_bool ()\n+{\n+  // Exercise warnings for addresses of nonstatic member functions.\n+  T (&A::f == 0);         // { dg-warning \"-Waddress\" }\n+  T (&A::vf);             // { dg-warning \"-Waddress\" }\n+  T (&A::pvf != 0);       // { dg-warning \"-Waddress\" }\n+\n+  // Exercise warnings for addresses of static member functions.\n+  T (&A::sf == 0);        // { dg-warning \"-Waddress\" }\n+  T (&A::sf);             // { dg-warning \"-Waddress\" }\n+\n+  // Exercise warnings for addresses of nonstatic data members.\n+  T (&A::p == 0);         // { dg-warning \"-Waddress\" }\n+  T (&A::a == nullptr);   // { dg-warning \"-Waddress\" }\n+}\n+\n+\n+/* Verify that no warnings are issued for a dependent expression in\n+   a template.  */\n+\n+template <int>\n+struct B\n+{\n+  // This is why.\n+  struct F { void* operator& () const { return 0; } } f;\n+};\n+\n+template <class Type, int N>\n+void nowarn_dependent (Type targ)\n+{\n+  T (&Type::x == 0);\n+  T (&targ == 0);\n+\n+  Type tarr[1];\n+  T (&tarr[0] == nullptr);\n+\n+  T (&B<N>::f == 0);\n+\n+  /* Like in the case above, the address-of operator could be a member\n+     of B<N>::vf that returns zero.  */\n+  T (&B<N>::vf);\n+  T (&B<N>::pvf != 0);\n+  T (&B<N>::p == 0);\n+  T (&B<N>::a == 0);\n+}\n+\n+\n+/* Verify that in an uninstantiated template warnings are not issued\n+   for dependent expressions but are issued otherwise.  */\n+\n+template <class Type>\n+void warn_non_dependent (Type targ, Type *tptr, int i)\n+{\n+  /* The address of a pointer to a dependent type cannot be null but\n+     the warning doesn't have a chance to see it.  */\n+  T (&tptr == 0);       // { dg-warning \"-Waddress\" \"pr102378\" { xfail *-*-* } }\n+  T (&i == 0);          // { dg-warning \"-Waddress\" }\n+\n+  int iarr[1];\n+  T (&iarr == 0);       // { dg-warning \"-Waddress\" }\n+  T (&*iarr != 0);      // { dg-warning \"-Waddress\" \"pr102378\" { xfail *-*-* } }\n+  T (&iarr[0] == 0);    // { dg-warning \"-Waddress\" }\n+\n+  Type tarr[1];\n+  T (&tarr == nullptr);   // { dg-warning \"-Waddress\" \"pr102378\" { xfail *-*-* } }\n+}"}, {"sha": "c22a83a0dd7aade6bd17ad80954db89a21b69b31", "filename": "gcc/testsuite/g++.dg/warn/Waddress-6.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWaddress-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWaddress-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWaddress-6.C?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -0,0 +1,79 @@\n+/* PR c/102103 - missing warning comparing array address to null\n+   { dg-do compile }\n+   Verify -Waddress for member arrays of structs and notes.\n+   { dg-options \"-Wall\" } */\n+\n+#if __cplusplus < 201103L\n+# define nullptr __null\n+#endif\n+\n+void T (bool);\n+\n+struct A\n+{\n+  int n;\n+  int ia[];                   // { dg-message \"'A::ia' declared here\" }\n+};\n+\n+struct B\n+{\n+  A a[3];                     // { dg-message \"'B::a' declared here\" }\n+};\n+\n+struct C\n+{\n+  B b[3];                     // { dg-message \"'C::b' declared here\" }\n+};\n+\n+struct D\n+{\n+  C c[3];                     // { dg-message \"'D::c' declared here\" }\n+};\n+\n+\n+void test_waddress_1d ()\n+{\n+  D d[2];                     // { dg-message \"'d' declared here\" }\n+\n+  T (d);                      // { dg-warning \"address of 'd'\" }\n+  T (d == nullptr);           // { dg-warning \"address of 'd'\" }\n+  T (&d);                     // { dg-warning \"address of 'd'\" }\n+  T (d->c);                   // { dg-warning \"address of 'D::c'\" }\n+  T (d->c != nullptr);        // { dg-warning \"address of 'D::c'\" }\n+  T (d->c->b);                // { dg-warning \"address of 'C::b'\" }\n+  T (d->c[1].b->a);           // { dg-warning \"address of 'B::a'\" }\n+  T (d->c->b[2].a->ia);       // { dg-warning \"address of 'A::ia'\" }\n+\n+  if (d->c->b[2].a[1].ia)     // { dg-warning \"address of 'A::ia'\" }\n+    T (0);\n+\n+  if (bool b = d->c->b[1].a)  // { dg-warning \"address of 'B::a'\" }\n+    T (b);\n+\n+  /* The following is represented as a declaration of P followed\n+     by an if statement and so it isn't diagnosed.  It's not clear\n+     that it should be since the pointer is then used.\n+       void *p = d->c->b[2].a;\n+       if (p) ...\n+  */\n+  if (void *p = d->c->b[2].a) // { dg-warning \"address of 'A::ia'\" \"\" { xfail *-*-* } }\n+    T (p);\n+}\n+\n+\n+void test_waddress_2d (int i)\n+{\n+  D d[2][3];                  // { dg-message \"'d' declared here\" }\n+\n+  T (d);                      // { dg-warning \"address of 'd'\" }\n+  T (d == nullptr);           // { dg-warning \"address of 'd'\" }\n+  T (&d);                     // { dg-warning \"address of 'd'\" }\n+  T (*d);                     // { dg-warning \"address of 'd'\" }\n+  T (d[1] != nullptr);        // { dg-warning \"address of 'd'\" }\n+  T (&d[1]->c);               // { dg-warning \"address of 'D::c'\" }\n+  T (d[1]->c);                // { dg-warning \"address of 'D::c'\" }\n+  T (d[1]->c == nullptr);     // { dg-warning \"address of 'D::c'\" }\n+  T (d[i]->c[1].b);           // { dg-warning \"address of 'C::b'\" }\n+  T ((*(d + i))->c->b->a);    // { dg-warning \"address of 'B::a'\" }\n+  T (d[1][2].c->b->a->ia);    // { dg-warning \"address of 'A::ia'\" }\n+}"}, {"sha": "fae8b7e766f6b53e6327572d35e7be0ad527f1ce", "filename": "gcc/testsuite/g++.dg/warn/Wreturn-local-addr-6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-local-addr-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-local-addr-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-local-addr-6.C?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -9,7 +9,7 @@ const intptr_t&\n return_addr_label_as_intref (void)\n {\n  label:\n-  if ((const intptr_t*)&&label == 0)\n+  if ((const intptr_t)&&label == 0)\n     __builtin_exit (1);\n \n   return *(const intptr_t*)&&label;   // { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n@@ -19,7 +19,7 @@ const intptr_t&\n return_addr_local_as_intref (void)\n {\n   int a[1];\n-  if ((const intptr_t*)a == 0)\n+  if ((const intptr_t)a == 0)\n     __builtin_exit (1);\n \n   return (const intptr_t&)a;   // { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */"}, {"sha": "d5d44e44852fc3ceb7b22eca08372a0836cf36cf", "filename": "gcc/testsuite/g++.dg/warn/pr101219.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr101219.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr101219.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr101219.C?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -7,5 +7,7 @@ struct S { void m(); };\n template <int> bool f() {\n   void (S::*mp)();\n \n-  return &S::m == mp; // no warning emitted here (no instantiation)\n+  /* The expression below isn't type-dependent so also verify\n+     it's diagnosed even though the template isn't instantiated.  */\n+  return &S::m == mp; // { dg-warning \"\\\\\\[-Waddress\" }\n }"}, {"sha": "c404f6bf6510bf81b3e1eb0cb72edef48a59f95e", "filename": "gcc/testsuite/gcc.dg/Waddress-3.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fgcc.dg%2FWaddress-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fgcc.dg%2FWaddress-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWaddress-3.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -0,0 +1,35 @@\n+/* PR c/102103 - missing warning comparing array address to null\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef _Complex float Cflt;\n+\n+extern Cflt cf, cfa[], cfa2[][2];\n+\n+Cflt *pcf (void);\n+\n+void T (int);\n+\n+void test_complex (Cflt *p, int i)\n+{\n+  T (&__real__ cf == 0);              // { dg-warning \"address of '__real__ cf'\" }\n+  T (&__imag__ cf == 0);              // { dg-warning \"address of '__imag__ cf'\" }\n+\n+  T (0 != &__real__ cf);              // { dg-warning \"-Waddress\" }\n+  T (0 != &__imag__ cf);              // { dg-warning \"-Waddress\" }\n+\n+  T (&__real__ cfa[0] == 0);          // { dg-warning \"-Waddress\" }\n+  T (&__imag__ cfa[1] == 0);          // { dg-warning \"-Waddress\" }\n+\n+  T (0 != &__real__ cfa2[i][i]);      // { dg-warning \"-Waddress\" }\n+  T (0 != &__imag__ cfa2[i][i]);      // { dg-warning \"-Waddress\" }\n+\n+  T (0 == &__real__ *p);              // { dg-warning \"-Waddress\" }\n+  T (0 == &__imag__ *p);              // { dg-warning \"-Waddress\" }\n+\n+  T (0 == &__real__ p[i]);            // { dg-warning \"-Waddress\" }\n+  T (0 == &__imag__ p[i]);            // { dg-warning \"-Waddress\" }\n+\n+  T (&__real__ *pcf () == 0);         // { dg-warning \"-Waddress\" }\n+  T (0 != &__imag__ *pcf ());         // { dg-warning \"-Waddress\" }\n+}"}, {"sha": "b26e7b1f3294710bef15d9982d5cb1638ab92592", "filename": "gcc/testsuite/gcc.dg/Waddress.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fgcc.dg%2FWaddress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc7ce6fb3917958d1a6036d8acf2953b9c1b868/gcc%2Ftestsuite%2Fgcc.dg%2FWaddress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWaddress.c?ref=4dc7ce6fb3917958d1a6036d8acf2953b9c1b868", "patch": "@@ -6,5 +6,5 @@ int\n foo(void)\n {\n   char a[1];\n-  return a == 0;\n+  return a == 0;    // { dg-warning \"-Waddress\" }\n }"}]}