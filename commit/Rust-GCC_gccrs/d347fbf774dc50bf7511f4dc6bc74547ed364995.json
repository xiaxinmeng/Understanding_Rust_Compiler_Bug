{"sha": "d347fbf774dc50bf7511f4dc6bc74547ed364995", "node_id": "C_kwDOANBUbNoAKGQzNDdmYmY3NzRkYzUwYmY3NTExZjRkYzZiYzc0NTQ3ZWQzNjQ5OTU", "commit": {"author": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2022-11-10T15:56:51Z"}, "committer": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2023-01-16T10:40:51Z"}, "message": "Add cltz_complement idiom recognition\n\nThis recognises patterns of the form:\nwhile (n) { n >>= 1 }\n\nThis patch results in improved (but still suboptimal) codegen:\n\nfoo (unsigned int b) {\n    int c = 0;\n\n    while (b) {\n        b >>= 1;\n        c++;\n    }\n\n    return c;\n}\n\nfoo:\n.LFB11:\n        .cfi_startproc\n        cbz     w0, .L3\n        clz     w1, w0\n        tst     x0, 1\n        mov     w0, 32\n        sub     w0, w0, w1\n        csel    w0, w0, wzr, ne\n        ret\n\nThe conditional is unnecessary. phiopt could recognise a redundant csel\n(using cond_removal_in_builtin_zero_pattern) when one of the inputs is a\nclz call, but it cannot recognise the redunancy when the input is (e.g.)\n(32 - clz).\n\nI could perhaps extend this function to recognise this pattern in a later\npatch, if this is a good place to recognise more patterns.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/94793\n\t* tree-scalar-evolution.cc (expression_expensive_p): Add checks\n\tfor c[lt]z optabs.\n\t* tree-ssa-loop-niter.cc (build_cltz_expr): New.\n\t(number_of_iterations_cltz_complement): New.\n\t(number_of_iterations_bitcount): Add call to the above.\n\ngcc/testsuite/ChangeLog:\n\n\t* lib/target-supports.exp (check_effective_target_clz)\n\t(check_effective_target_clzl, check_effective_target_clzll)\n\t(check_effective_target_ctz, check_effective_target_clzl)\n\t(check_effective_target_ctzll): New.\n\t* gcc.dg/tree-ssa/cltz-complement-max.c: New test.\n\t* gcc.dg/tree-ssa/clz-complement-char.c: New test.\n\t* gcc.dg/tree-ssa/clz-complement-int.c: New test.\n\t* gcc.dg/tree-ssa/clz-complement-long-long.c: New test.\n\t* gcc.dg/tree-ssa/clz-complement-long.c: New test.\n\t* gcc.dg/tree-ssa/ctz-complement-char.c: New test.\n\t* gcc.dg/tree-ssa/ctz-complement-int.c: New test.\n\t* gcc.dg/tree-ssa/ctz-complement-long-long.c: New test.\n\t* gcc.dg/tree-ssa/ctz-complement-long.c: New test.", "tree": {"sha": "03691316894f8649107eb81f2f362db4cc156fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03691316894f8649107eb81f2f362db4cc156fc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d347fbf774dc50bf7511f4dc6bc74547ed364995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d347fbf774dc50bf7511f4dc6bc74547ed364995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d347fbf774dc50bf7511f4dc6bc74547ed364995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d347fbf774dc50bf7511f4dc6bc74547ed364995/comments", "author": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e087d9ab8247fa866945f156cfe3aa6dc7039ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e087d9ab8247fa866945f156cfe3aa6dc7039ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e087d9ab8247fa866945f156cfe3aa6dc7039ff"}], "stats": {"total": 609, "additions": 606, "deletions": 3}, "files": [{"sha": "1a29ca52e42e50822e4e3213b2cb008b766d0318", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cltz-complement-max.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcltz-complement-max.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcltz-complement-max.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcltz-complement-max.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-loop-optimize -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int clz_complement_count1 (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+    if (c <= PREC)\n+      return 0;\n+    else\n+      return 34567;\n+}\n+\n+int clz_complement_count2 (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 1)\n+      return 0;\n+    else\n+      return 76543;\n+}\n+\n+int ctz_complement_count1 (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+    if (c <= PREC)\n+      return 0;\n+    else\n+      return 23456;\n+}\n+\n+int ctz_complement_count2 (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 1)\n+      return 0;\n+    else\n+      return 65432;\n+}\n+/* { dg-final { scan-tree-dump-times \"34567\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"76543\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"23456\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"65432\" 1 \"optimized\" } } */"}, {"sha": "2ebe8fabcaf0ce88f3a6a46e9ba4ba79b7d3672e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-complement-char.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-char.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clz } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(5) != 3)\n+    __builtin_abort ();\n+  if (foo(255) != 8)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "f2c5c23f6a7d84ecb637c6961698b0fc30d7426b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-complement-int.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-int.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clz } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_INT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned int b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(5) != 3)\n+    __builtin_abort ();\n+  if (foo(1 << (PREC - 1)) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "7f7793f0efac1f0d793e6e99b84988e5cc5221c9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-complement-long-long.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-long-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-long-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-long-long.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clzll } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long long b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(5) != 3)\n+    __builtin_abort ();\n+  if (foo(1LL << (PREC - 1)) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "97161bb7a74260bea20e325ebab64acb33a2b696", "filename": "gcc/testsuite/gcc.dg/tree-ssa/clz-complement-long.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fclz-complement-long.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target clzl } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb >>= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(5) != 3)\n+    __builtin_abort ();\n+  if (foo(1L << (PREC - 1)) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_clz|\\\\.CLZ\" 1 \"optimized\" } } */"}, {"sha": "b9afe8852d8ffbc7ee9a0760cf04b8f98af293a2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-complement-char.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-char.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctz } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(96) != PREC - 5)\n+    __builtin_abort ();\n+  if (foo(35) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "d2702a65daf34db66550d2255395db68a29a4797", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-complement-int.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-int.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctz } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_INT__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned int b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(96) != PREC - 5)\n+    __builtin_abort ();\n+  if (foo(35) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "1ea0d5d7d9f8be1824c4177c33edd91e66b4ddab", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-complement-long-long.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-long-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-long-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-long-long.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctzll } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long long b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(96) != PREC - 5)\n+    __builtin_abort ();\n+  if (foo(35) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "80fb02dcfa68bc022ae69b26fb189323e01fc6fc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ctz-complement-long.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fctz-complement-long.c?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ctzl } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__ * __SIZEOF_LONG__)\n+\n+int\n+__attribute__ ((noinline, noclone))\n+foo (unsigned long b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb <<= 1;\n+\tc++;\n+    }\n+\n+    return c;\n+}\n+\n+int main()\n+{\n+  if (foo(0) != 0)\n+    __builtin_abort ();\n+  if (foo(96) != PREC - 5)\n+    __builtin_abort ();\n+  if (foo(35) != PREC)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_ctz|\\\\.CTZ\" 1 \"optimized\" } } */"}, {"sha": "a5176e746b955c49b6910226e91c38f0716c6287", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -8708,6 +8708,72 @@ proc check_effective_target_popcount { } {\n     } \"\" ]\n }\n \n+# Return 1 if the target supports clz on int.\n+\n+proc check_effective_target_clz { } {\n+    return [check_no_messages_and_pattern clz \"!\\\\(call\" rtl-expand {\n+        int foo (int b)\n+          {\n+            return __builtin_clz (b);\n+          }\n+    } \"\" ]\n+}\n+\n+# Return 1 if the target supports clz on long.\n+\n+proc check_effective_target_clzl { } {\n+    return [check_no_messages_and_pattern clzl \"!\\\\(call\" rtl-expand {\n+\tint foo (long b)\n+\t  {\n+\t    return __builtin_clzl (b);\n+\t  }\n+    } \"\" ]\n+}\n+\n+# Return 1 if the target supports clz on long long.\n+\n+proc check_effective_target_clzll { } {\n+    return [check_no_messages_and_pattern clzll \"!\\\\(call\" rtl-expand {\n+        int foo (long long b)\n+          {\n+            return __builtin_clzll (b);\n+          }\n+    } \"\" ]\n+}\n+\n+# Return 1 if the target supports ctz on int.\n+\n+proc check_effective_target_ctz { } {\n+    return [check_no_messages_and_pattern ctz \"!\\\\(call\" rtl-expand {\n+        int foo (int b)\n+          {\n+            return __builtin_ctz (b);\n+          }\n+    } \"\" ]\n+}\n+\n+# Return 1 if the target supports ctz on long.\n+\n+proc check_effective_target_ctzl { } {\n+    return [check_no_messages_and_pattern ctzl \"!\\\\(call\" rtl-expand {\n+\tint foo (long b)\n+\t  {\n+\t    return __builtin_ctzl (b);\n+\t  }\n+    } \"\" ]\n+}\n+\n+# Return 1 if the target supports ctz on long long.\n+\n+proc check_effective_target_ctzll { } {\n+    return [check_no_messages_and_pattern ctzll \"!\\\\(call\" rtl-expand {\n+        int foo (long long b)\n+          {\n+            return __builtin_ctzll (b);\n+          }\n+    } \"\" ]\n+}\n+\n # Return 1 if the target supports atomic operations on \"long long\"\n # and can execute them.\n #"}, {"sha": "526b7f68768a9b6261b2c8d20d4abd0cd18a5036", "filename": "gcc/tree-scalar-evolution.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftree-scalar-evolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftree-scalar-evolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.cc?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -3397,12 +3397,21 @@ expression_expensive_p (tree expr, hash_map<tree, uint64_t> &cache,\n \t library call for popcount when backend does not have an instruction\n \t to do so.  We consider this to be expensive and generate\n \t __builtin_popcount only when backend defines it.  */\n+      optab optab;\n       combined_fn cfn = get_call_combined_fn (expr);\n       switch (cfn)\n \t{\n \tCASE_CFN_POPCOUNT:\n+\t  optab = popcount_optab;\n+\t  goto bitcount_call;\n+\tCASE_CFN_CLZ:\n+\t  optab = clz_optab;\n+\t  goto bitcount_call;\n+\tCASE_CFN_CTZ:\n+\t  optab = ctz_optab;\n+bitcount_call:\n \t  /* Check if opcode for popcount is available in the mode required.  */\n-\t  if (optab_handler (popcount_optab,\n+\t  if (optab_handler (optab,\n \t\t\t     TYPE_MODE (TREE_TYPE (CALL_EXPR_ARG (expr, 0))))\n \t      == CODE_FOR_nothing)\n \t    {\n@@ -3415,7 +3424,7 @@ expression_expensive_p (tree expr, hash_map<tree, uint64_t> &cache,\n \t\t instructions.  */\n \t      if (is_a <scalar_int_mode> (mode, &int_mode)\n \t\t  && GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n-\t\t  && (optab_handler (popcount_optab, word_mode)\n+\t\t  && (optab_handler (optab, word_mode)\n \t\t      != CODE_FOR_nothing))\n \t\t  break;\n \t      return true;"}, {"sha": "c1ca20c2926a309955b9e68a6327416937ea8302", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 221, "deletions": 1, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d347fbf774dc50bf7511f4dc6bc74547ed364995/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=d347fbf774dc50bf7511f4dc6bc74547ed364995", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-dfa.h\"\n+#include \"internal-fn.h\"\n #include \"gimple-range.h\"\n \n \n@@ -2198,6 +2199,224 @@ number_of_iterations_popcount (loop_p loop, edge exit,\n   return true;\n }\n \n+/* Return an expression that counts the leading/trailing zeroes of src.\n+\n+   If define_at_zero is true, then the built expression will be defined to\n+   return the precision of src when src == 0 (using either a conditional\n+   expression or a suitable internal function).\n+   Otherwise, we can elide the conditional expression and let src = 0 invoke\n+   undefined behaviour.  */\n+\n+static tree\n+build_cltz_expr (tree src, bool leading, bool define_at_zero)\n+{\n+  tree fn;\n+  internal_fn ifn = leading ? IFN_CLZ : IFN_CTZ;\n+  bool use_ifn = false;\n+  int prec = TYPE_PRECISION (TREE_TYPE (src));\n+  int i_prec = TYPE_PRECISION (integer_type_node);\n+  int li_prec = TYPE_PRECISION (long_integer_type_node);\n+  int lli_prec = TYPE_PRECISION (long_long_integer_type_node);\n+\n+  tree utype = unsigned_type_for (TREE_TYPE (src));\n+  src = fold_convert (utype, src);\n+\n+  if (direct_internal_fn_supported_p (ifn, utype, OPTIMIZE_FOR_BOTH))\n+    use_ifn = true;\n+  else if (prec <= i_prec)\n+    fn = leading ? builtin_decl_implicit (BUILT_IN_CLZ)\n+\t\t : builtin_decl_implicit (BUILT_IN_CTZ);\n+  else if (prec == li_prec)\n+    fn = leading ? builtin_decl_implicit (BUILT_IN_CLZL)\n+\t\t : builtin_decl_implicit (BUILT_IN_CTZL);\n+  else if (prec == lli_prec || prec == 2 * lli_prec)\n+    fn = leading ? builtin_decl_implicit (BUILT_IN_CLZLL)\n+\t\t : builtin_decl_implicit (BUILT_IN_CTZLL);\n+  else\n+    return NULL_TREE;\n+\n+  tree call;\n+  if (use_ifn)\n+    {\n+      call = build_call_expr_internal_loc (UNKNOWN_LOCATION, ifn,\n+\t\t\t\t\t   integer_type_node, 1, src);\n+      int val;\n+      scalar_int_mode mode = SCALAR_INT_TYPE_MODE (utype);\n+      int optab_defined_at_zero\n+\t= leading ? CLZ_DEFINED_VALUE_AT_ZERO (mode, val)\n+\t\t  : CTZ_DEFINED_VALUE_AT_ZERO (mode, val);\n+      if (define_at_zero && !(optab_defined_at_zero == 2 && val == prec))\n+\t{\n+\t  tree is_zero = fold_build2 (NE_EXPR, boolean_type_node, src,\n+\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n+\t  call = fold_build3(COND_EXPR, integer_type_node, is_zero, call,\n+\t\t\t     build_int_cst (integer_type_node, prec));\n+\t}\n+    }\n+  else if (prec == 2 * lli_prec)\n+    {\n+      tree src1 = fold_convert (long_long_unsigned_type_node,\n+\t\t\t\tfold_build2 (RSHIFT_EXPR, TREE_TYPE (src),\n+\t\t\t\t\t     unshare_expr (src),\n+\t\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t    lli_prec)));\n+      tree src2 = fold_convert (long_long_unsigned_type_node, src);\n+      /* We count the zeroes in src1, and add the number in src2 when src1\n+\t is 0.  */\n+      if (!leading)\n+\tstd::swap(src1, src2);\n+      tree call1 = build_call_expr (fn, 1, src1);\n+      tree call2 = build_call_expr (fn, 1, src2);\n+      if (define_at_zero)\n+\t{\n+\t  tree is_zero2 = fold_build2 (NE_EXPR, boolean_type_node, src2,\n+\t\t\t\t       build_zero_cst (TREE_TYPE (src2)));\n+\t  call2 = fold_build3(COND_EXPR, integer_type_node, is_zero2, call2,\n+\t\t\t      build_int_cst (integer_type_node, lli_prec));\n+\t}\n+      tree is_zero1 = fold_build2 (NE_EXPR, boolean_type_node, src1,\n+\t\t\t\t   build_zero_cst (TREE_TYPE (src1)));\n+      call = fold_build3(COND_EXPR, integer_type_node, is_zero1, call1,\n+\t\t\t fold_build2 (PLUS_EXPR, integer_type_node, call2,\n+\t\t\t\t      build_int_cst (integer_type_node,\n+\t\t\t\t\t\t     lli_prec)));\n+    }\n+  else\n+    {\n+      if (prec < i_prec)\n+\tsrc = fold_convert (unsigned_type_node, src);\n+\n+      call = build_call_expr (fn, 1, src);\n+      if (define_at_zero)\n+\t{\n+\t  tree is_zero = fold_build2 (NE_EXPR, boolean_type_node, src,\n+\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n+\t  call = fold_build3(COND_EXPR, integer_type_node, is_zero, call,\n+\t\t\t     build_int_cst (integer_type_node, prec));\n+\t}\n+\n+      if (leading && prec < i_prec)\n+\tcall = fold_build2(MINUS_EXPR, integer_type_node, call,\n+\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t  i_prec - prec));\n+    }\n+\n+  return call;\n+}\n+\n+/* See comment below for number_of_iterations_bitcount.\n+   For c[lt]z complement, we have:\n+\n+   modify:\n+   iv_2 = iv_1 >> 1 OR iv_1 << 1\n+\n+   test:\n+   if (iv != 0)\n+\n+   modification count:\n+   src precision - c[lt]z (src)\n+\n+ */\n+\n+static bool\n+number_of_iterations_cltz_complement (loop_p loop, edge exit,\n+\t\t\t       enum tree_code code,\n+\t\t\t       class tree_niter_desc *niter)\n+{\n+  bool modify_before_test = true;\n+  HOST_WIDE_INT max;\n+\n+  /* Check that condition for staying inside the loop is like\n+     if (iv != 0).  */\n+  gimple *cond_stmt = last_stmt (exit->src);\n+  if (!cond_stmt\n+      || gimple_code (cond_stmt) != GIMPLE_COND\n+      || code != NE_EXPR\n+      || !integer_zerop (gimple_cond_rhs (cond_stmt))\n+      || TREE_CODE (gimple_cond_lhs (cond_stmt)) != SSA_NAME)\n+    return false;\n+\n+  tree iv_2 = gimple_cond_lhs (cond_stmt);\n+  gimple *iv_2_stmt = SSA_NAME_DEF_STMT (iv_2);\n+\n+  /* If the test comes before the iv modification, then these will actually be\n+     iv_1 and a phi node.  */\n+  if (gimple_code (iv_2_stmt) == GIMPLE_PHI\n+      && gimple_bb (iv_2_stmt) == loop->header\n+      && gimple_phi_num_args (iv_2_stmt) == 2\n+      && (TREE_CODE (gimple_phi_arg_def (iv_2_stmt,\n+\t\t\t\t\t loop_latch_edge (loop)->dest_idx))\n+\t  == SSA_NAME))\n+    {\n+      /* iv_2 is actually one of the inputs to the phi.  */\n+      iv_2 = gimple_phi_arg_def (iv_2_stmt, loop_latch_edge (loop)->dest_idx);\n+      iv_2_stmt = SSA_NAME_DEF_STMT (iv_2);\n+      modify_before_test = false;\n+    }\n+\n+  /* Make sure iv_2_stmt is a logical shift by one stmt:\n+     iv_2 = iv_1 {>>|<<} 1  */\n+  if (!is_gimple_assign (iv_2_stmt)\n+      || (gimple_assign_rhs_code (iv_2_stmt) != LSHIFT_EXPR\n+\t  && (gimple_assign_rhs_code (iv_2_stmt) != RSHIFT_EXPR\n+\t      || !TYPE_UNSIGNED (TREE_TYPE (gimple_assign_lhs (iv_2_stmt)))))\n+      || !integer_onep (gimple_assign_rhs2 (iv_2_stmt)))\n+    return false;\n+\n+  bool left_shift = (gimple_assign_rhs_code (iv_2_stmt) == LSHIFT_EXPR);\n+\n+  tree iv_1 = gimple_assign_rhs1 (iv_2_stmt);\n+\n+  /* Check the recurrence.  */\n+  gimple *phi = SSA_NAME_DEF_STMT (iv_1);\n+  if (gimple_code (phi) != GIMPLE_PHI\n+      || (gimple_bb (phi) != loop_latch_edge (loop)->dest)\n+      || (iv_2 != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n+    return false;\n+\n+  /* We found a match.  */\n+  tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n+  int src_precision = TYPE_PRECISION (TREE_TYPE (src));\n+\n+  /* Get the corresponding c[lt]z builtin.  */\n+  tree expr = build_cltz_expr (src, !left_shift, true);\n+\n+  if (!expr)\n+    return false;\n+\n+  expr = fold_build2 (MINUS_EXPR, integer_type_node,\n+\t\t      build_int_cst (integer_type_node, src_precision),\n+\t\t      expr);\n+\n+  max = src_precision;\n+\n+  tree may_be_zero = boolean_false_node;\n+\n+  if (modify_before_test)\n+    {\n+      expr = fold_build2 (MINUS_EXPR, integer_type_node, expr,\n+\t\t\t  integer_one_node);\n+      max = max - 1;\n+      may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n+\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n+    }\n+\n+  expr = fold_convert (unsigned_type_node, expr);\n+\n+  niter->assumptions = boolean_true_node;\n+  niter->may_be_zero = simplify_using_initial_conditions (loop, may_be_zero);\n+  niter->niter = simplify_using_initial_conditions (loop, expr);\n+\n+  if (TREE_CODE (niter->niter) == INTEGER_CST)\n+    niter->max = tree_to_uhwi (niter->niter);\n+  else\n+    niter->max = max;\n+\n+  niter->bound = NULL_TREE;\n+  niter->cmp = ERROR_MARK;\n+  return true;\n+}\n+\n /* See if LOOP contains a bit counting idiom. The idiom consists of two parts:\n    1. A modification to the induction variabler;.\n    2. A test to determine whether or not to exit the loop.\n@@ -2244,7 +2463,8 @@ number_of_iterations_bitcount (loop_p loop, edge exit,\n \t\t\t       enum tree_code code,\n \t\t\t       class tree_niter_desc *niter)\n {\n-  return number_of_iterations_popcount (loop, exit, code, niter);\n+  return (number_of_iterations_popcount (loop, exit, code, niter)\n+\t  || number_of_iterations_cltz_complement (loop, exit, code, niter));\n }\n \n /* Substitute NEW_TREE for OLD in EXPR and fold the result."}]}