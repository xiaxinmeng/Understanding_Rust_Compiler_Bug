{"sha": "ffe9c0a0d3564a6083ea6194eb3374a89c29c085", "node_id": "C_kwDOANBUbNoAKGZmZTljMGEwZDM1NjRhNjA4M2VhNjE5NGViMzM3NGE4OWMyOWMwODU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-15T12:50:24Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-15T12:50:24Z"}, "message": "c++: extraneous access error with ambiguous lookup [PR103177]\n\nWhen a lookup is ambiguous, lookup_member still attempts to check\naccess of the first member found before diagnosing the ambiguity and\npropagating the error, and this may cause us to issue an extraneous\naccess error as in the testcase below (for B1::foo).\n\nThis patch fixes this by swapping the order of the ambiguity and access\nchecks within lookup_member.  In passing, since the only thing that could\ngo wrong during lookup_field_r is ambiguity, we might as well hardcode\nthat in lookup_member and get rid of lookup_field_info::errstr.\n\n\tPR c++/103177\n\ngcc/cp/ChangeLog:\n\n\t* search.cc (lookup_field_info::errstr): Remove this data\n\tmember.\n\t(lookup_field_r): Don't set errstr.\n\t(lookup_member): Check ambiguity before checking access.\n\tSimplify accordingly after errstr removal.  Exit early upon\n\terror or empty result.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/lookup/ambig6.C: New test.", "tree": {"sha": "b2274a0a892c74c22dcc13065f892be7baaa105d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2274a0a892c74c22dcc13065f892be7baaa105d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe9c0a0d3564a6083ea6194eb3374a89c29c085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe9c0a0d3564a6083ea6194eb3374a89c29c085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe9c0a0d3564a6083ea6194eb3374a89c29c085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe9c0a0d3564a6083ea6194eb3374a89c29c085/comments", "author": null, "committer": null, "parents": [{"sha": "98afdc3e2bfccf0a1337013b54f2c5634ef40ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98afdc3e2bfccf0a1337013b54f2c5634ef40ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98afdc3e2bfccf0a1337013b54f2c5634ef40ee5"}], "stats": {"total": 55, "additions": 34, "deletions": 21}, "files": [{"sha": "85e3e7cb48778dbe4a109a2920ee72f5615b9d66", "filename": "gcc/cp/search.cc", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9c0a0d3564a6083ea6194eb3374a89c29c085/gcc%2Fcp%2Fsearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9c0a0d3564a6083ea6194eb3374a89c29c085/gcc%2Fcp%2Fsearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.cc?ref=ffe9c0a0d3564a6083ea6194eb3374a89c29c085", "patch": "@@ -941,8 +941,6 @@ struct lookup_field_info {\n   tree ambiguous;\n   /* If nonzero, we are looking for types, not data members.  */\n   int want_type;\n-  /* If something went wrong, a message indicating what.  */\n-  const char *errstr;\n };\n \n /* True for a class member means that it is shared between all objects\n@@ -1055,7 +1053,6 @@ lookup_field_r (tree binfo, void *data)\n \t  /* Add the new value.  */\n \t  lfi->ambiguous = tree_cons (NULL_TREE, nval, lfi->ambiguous);\n \t  TREE_TYPE (lfi->ambiguous) = error_mark_node;\n-\t  lfi->errstr = G_(\"request for member %qD is ambiguous\");\n \t}\n     }\n   else\n@@ -1127,8 +1124,6 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n      checks.  Whereas rval is only set if a proper (not hidden)\n      non-function member is found.  */\n \n-  const char *errstr = 0;\n-\n   if (name == error_mark_node\n       || xbasetype == NULL_TREE\n       || xbasetype == error_mark_node)\n@@ -1172,7 +1167,6 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n   rval_binfo = lfi.rval_binfo;\n   if (rval_binfo)\n     type = BINFO_TYPE (rval_binfo);\n-  errstr = lfi.errstr;\n \n   /* If we are not interested in ambiguities, don't report them;\n      just return NULL_TREE.  */\n@@ -1187,6 +1181,19 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n \tprotect = 0;\n     }\n \n+  if (protect == 1 && lfi.ambiguous)\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  error (\"request for member %qD is ambiguous\", name);\n+\t  print_candidates (lfi.ambiguous);\n+\t}\n+      return error_mark_node;\n+    }\n+\n+  if (!rval)\n+    return NULL_TREE;\n+\n   /* [class.access]\n \n      In the case of overloaded function names, access control is\n@@ -1206,8 +1213,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n \n     only the first call to \"f\" is valid.  However, if the function is\n     static, we can check.  */\n-  if (rval && protect \n-      && !really_overloaded_fn (rval))\n+  if (protect && !really_overloaded_fn (rval))\n     {\n       tree decl = is_overloaded_fn (rval) ? get_first_fn (rval) : rval;\n       decl = strip_using_decl (decl);\n@@ -1216,21 +1222,10 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n \t  && !DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n \t  && !perform_or_defer_access_check (basetype_path, decl, decl,\n \t\t\t\t\t     complain, afi))\n-\trval = error_mark_node;\n-    }\n-\n-  if (errstr && protect)\n-    {\n-      if (complain & tf_error)\n-\t{\n-\t  error (errstr, name, type);\n-\t  if (lfi.ambiguous)\n-\t    print_candidates (lfi.ambiguous);\n-\t}\n-      rval = error_mark_node;\n+\treturn error_mark_node;\n     }\n \n-  if (rval && is_overloaded_fn (rval)\n+  if (is_overloaded_fn (rval)\n       /* Don't use a BASELINK for class-scope deduction guides since\n \t they're not actually member functions.  */\n       && !dguide_name_p (name))"}, {"sha": "eeef45e64148ef2d74b2514bddd190daf864caba", "filename": "gcc/testsuite/g++.dg/lookup/ambig6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe9c0a0d3564a6083ea6194eb3374a89c29c085/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe9c0a0d3564a6083ea6194eb3374a89c29c085/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig6.C?ref=ffe9c0a0d3564a6083ea6194eb3374a89c29c085", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/103177\n+\n+struct B1 {\n+private:\n+  static int foo();\n+};\n+\n+struct B2 {\n+  int foo();\n+};\n+\n+struct D : B1, B2 { };\n+\n+void f() {\n+  D d;\n+  d.foo(); // { dg-error \"ambiguous\" }\n+           // { dg-bogus \"private\" \"\" { target *-*-* } .-1 }\n+}"}]}