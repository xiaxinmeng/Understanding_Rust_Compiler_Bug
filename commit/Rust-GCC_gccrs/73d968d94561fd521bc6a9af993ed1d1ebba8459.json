{"sha": "73d968d94561fd521bc6a9af993ed1d1ebba8459", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNkOTY4ZDk0NTYxZmQ1MjFiYzZhOWFmOTkzZWQxZDFlYmJhODQ1OQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-01-04T14:03:59Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-01-04T14:03:59Z"}, "message": "Fix bugs in filesystem::path::lexically_normal()\n\nUsing path::_List::erase(const_iterator) to remove a non-final component\nin path::lexically_normal() is a bug, because it leaves the following\ncomponent with an incorrect _M_pos value.\n\nInstead of providing erase members that allow removing components from\nthe middle, replace them with pop_back() and\n_M_erase_from(const_iterator) which only allow removing elements at the\nend. Most uses of erase are unaffected, because they only remove\nelements from the end anyway. The one use of erasure from the middle in\nlexically_normal() is replaced by calls to pop_back() and/or clearing\nthe last component to leave it as an empty final filename.\n\nAlso replace the \"???\" comment in lexically_normal() to document when\nthat branch is taken.\n\n\t* include/bits/fs_path.h (path::_List::erase): Replace both overloads\n\twith ...\n\t(path::pop_back(), path::_M_erase_from(const_iterator)): New member\n\tfunctions that will only erase elements at the end.\n\t* src/filesystem/std-path.cc (path::_List::_Impl::pop_back()): Define.\n\t(path::_List::_Impl::_M_erase_from(const_iterator)): Define.\n\t(path::_List::operator=(const _List&)): Use _M_erase_from(p) instead\n\tof erase(p, end()).\n\t(path::_List::pop_back()): Define.\n\t(path::_List::_M_erase_from(const_iterator)): Define.\n\t(path::operator/=(const path&)): Use pop_back to remove last component\n\tand _M_erase_from to remove multiple components.\n\t(path::_M_append(basic_string_view<value_type>)): Likewise.\n\t(path::operator+=(const path&)): Likewise.\n\t(path::_M_concat(basic_string_view<value_type>)): Likewise.\n\t(path::remove_filename()): Likewise.\n\t(path::lexically_normal()): Use _List::_Impl iterators instead of\n\tpath::iterator. Use pop_back to remove components from the end. Clear\n\ttrailing filename, instead of using erase(const_iterator) to remove\n\ta non-final component.\n\t* testsuite/27_io/filesystem/path/generation/normal.cc: Test\n\tadditional cases.\n\t* testsuite/27_io/filesystem/path/generation/normal2.cc: New test.\n\nFrom-SVN: r267576", "tree": {"sha": "367ab721427f3648ac6801f1673f52a761409aa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/367ab721427f3648ac6801f1673f52a761409aa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73d968d94561fd521bc6a9af993ed1d1ebba8459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d968d94561fd521bc6a9af993ed1d1ebba8459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73d968d94561fd521bc6a9af993ed1d1ebba8459", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d968d94561fd521bc6a9af993ed1d1ebba8459/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d4c371efa1451279764e9768d7efa2edfa02e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4c371efa1451279764e9768d7efa2edfa02e59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4c371efa1451279764e9768d7efa2edfa02e59"}], "stats": {"total": 155, "additions": 121, "deletions": 34}, "files": [{"sha": "499812cbad6a7096278b3e2ead59d92ab92c4822", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=73d968d94561fd521bc6a9af993ed1d1ebba8459", "patch": "@@ -1,5 +1,29 @@\n 2019-01-04  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/fs_path.h (path::_List::erase): Replace both overloads\n+\twith ...\n+\t(path::pop_back(), path::_M_erase_from(const_iterator)): New member\n+\tfunctions that will only erase elements at the end.\n+\t* src/filesystem/std-path.cc (path::_List::_Impl::pop_back()): Define.\n+\t(path::_List::_Impl::_M_erase_from(const_iterator)): Define.\n+\t(path::_List::operator=(const _List&)): Use _M_erase_from(p) instead\n+\tof erase(p, end()).\n+\t(path::_List::pop_back()): Define.\n+\t(path::_List::_M_erase_from(const_iterator)): Define.\n+\t(path::operator/=(const path&)): Use pop_back to remove last component\n+\tand _M_erase_from to remove multiple components.\n+\t(path::_M_append(basic_string_view<value_type>)): Likewise.\n+\t(path::operator+=(const path&)): Likewise.\n+\t(path::_M_concat(basic_string_view<value_type>)): Likewise.\n+\t(path::remove_filename()): Likewise.\n+\t(path::lexically_normal()): Use _List::_Impl iterators instead of\n+\tpath::iterator. Use pop_back to remove components from the end. Clear\n+\ttrailing filename, instead of using erase(const_iterator) to remove\n+\ta non-final component.\n+\t* testsuite/27_io/filesystem/path/generation/normal.cc: Test\n+\tadditional cases.\n+\t* testsuite/27_io/filesystem/path/generation/normal2.cc: New test.\n+\n \t* src/filesystem/std-path.cc (path::operator+=(const path&)): Fix\n \tincorrect treatment of empty filename after trailing slash.\n \t* testsuite/27_io/filesystem/path/concat/path.cc: Test problem case."}, {"sha": "34a5d324ce01e9dfc307812bf8054653dc840ec7", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=73d968d94561fd521bc6a9af993ed1d1ebba8459", "patch": "@@ -544,8 +544,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       const value_type& front() const noexcept;\n       const value_type& back() const noexcept;\n \n-      void erase(const_iterator);\n-      void erase(const_iterator, const_iterator);\n+      void pop_back();\n+      void _M_erase_from(const_iterator __pos); // erases [__pos,end())\n \n       struct _Impl;\n       struct _Impl_deleter"}, {"sha": "34de52f3a0ffa23f4b4543e75ac43d3e9d30b6d7", "filename": "libstdc++-v3/src/filesystem/std-path.cc", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc?ref=73d968d94561fd521bc6a9af993ed1d1ebba8459", "patch": "@@ -207,22 +207,17 @@ struct path::_List::_Impl\n \n   void clear() { std::destroy_n(begin(), _M_size); _M_size = 0; }\n \n-  void erase(const_iterator cpos)\n+  void pop_back()\n   {\n-    iterator pos = begin() + (cpos - begin());\n-    if (pos + 1 != end())\n-      std::move(pos + 1, end(), pos);\n-    pos->~_Cmpt();\n+    back().~_Cmpt();\n     --_M_size;\n   }\n \n-  void erase(const_iterator cfirst, const_iterator clast)\n+  void _M_erase_from(const_iterator pos)\n   {\n-    iterator first = begin() + (cfirst - begin());\n-    iterator last = begin() + (clast - begin());\n-    if (last != end())\n-      std::move(last, end(), first);\n-    std::destroy(first + (end() - last), end());\n+    iterator first = begin() + (pos - begin());\n+    iterator last = end();\n+    std::destroy(first, last);\n     _M_size -= last - first;\n   }\n \n@@ -288,7 +283,7 @@ path::_List::operator=(const _List& other)\n \t      impl->_M_size = newsize;\n \t    }\n \t  else if (newsize < oldsize)\n-\t    impl->erase(impl->begin() + newsize, impl->end());\n+\t    impl->_M_erase_from(impl->begin() + newsize);\n \t  std::copy_n(from, minsize, to);\n \t  type(_Type::_Multi);\n \t}\n@@ -401,15 +396,16 @@ path::_List::back() const noexcept\n }\n \n inline void\n-path::_List::erase(const_iterator pos)\n+path::_List::pop_back()\n {\n-  _M_impl->erase(pos);\n+  __glibcxx_assert(size() > 0);\n+  _M_impl->pop_back();\n }\n \n inline void\n-path::_List::erase(const_iterator first, const_iterator last)\n+path::_List::_M_erase_from(const_iterator pos)\n {\n-  _M_impl->erase(first, last);\n+  _M_impl->_M_erase_from(pos);\n }\n \n inline void\n@@ -591,7 +587,10 @@ path::operator/=(const path& __p)\n \t{\n \t  // Remove empty final component\n \t  if (_M_cmpts._M_impl->back().empty())\n-\t    _M_cmpts._M_impl->erase(--output);\n+\t    {\n+\t      _M_cmpts.pop_back();\n+\t      --output;\n+\t    }\n \t}\n       else if (orig_pathlen != 0)\n \t{\n@@ -629,7 +628,7 @@ path::operator/=(const path& __p)\n     {\n       _M_pathname.resize(orig_pathlen);\n       if (orig_type == _Type::_Multi)\n-\t_M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+\t_M_cmpts._M_erase_from(_M_cmpts.begin() + orig_size);\n       else\n \t_M_cmpts.clear();\n       _M_cmpts.type(orig_type);\n@@ -774,7 +773,10 @@ path::_M_append(basic_string_view<value_type> s)\n \t{\n \t  // Remove empty final component\n \t  if (_M_cmpts._M_impl->back().empty())\n-\t    _M_cmpts._M_impl->erase(--output);\n+\t    {\n+\t      _M_cmpts.pop_back();\n+\t      --output;\n+\t    }\n \t}\n       else if (orig_pathlen != 0)\n \t{\n@@ -818,7 +820,7 @@ path::_M_append(basic_string_view<value_type> s)\n     {\n       _M_pathname.resize(orig_pathlen);\n       if (orig_type == _Type::_Multi)\n-\t_M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+\t_M_cmpts._M_erase_from(_M_cmpts.begin() + orig_size);\n       else\n \t_M_cmpts.clear();\n       _M_cmpts.type(orig_type);\n@@ -945,7 +947,8 @@ path::operator+=(const path& p)\n       else if (orig_filenamelen == 0 && it != last)\n \t{\n \t  // Remove empty filename at end of original path.\n-\t  _M_cmpts.erase(--output);\n+\t  _M_cmpts.pop_back();\n+\t  --output;\n \t}\n \n       if (it != last && it->_M_type() == _Type::_Root_name)\n@@ -995,7 +998,7 @@ path::operator+=(const path& p)\n       if (orig_type == _Type::_Multi)\n \t{\n \t  if (_M_cmpts.size() > orig_size)\n-\t    _M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+\t    _M_cmpts._M_erase_from(_M_cmpts.begin() + orig_size);\n \t  if (orig_filenamelen != -1)\n \t    {\n \t      if (_M_cmpts.size() == orig_size)\n@@ -1182,7 +1185,7 @@ path::_M_concat(basic_string_view<value_type> s)\n       _M_pathname.resize(orig_pathlen);\n       if (orig_type == _Type::_Multi)\n \t{\n-\t  _M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+\t  _M_cmpts._M_erase_from(_M_cmpts.begin() + orig_size);\n \t  if (orig_filenamelen != -1)\n \t    {\n \t      auto& back = _M_cmpts.back();\n@@ -1213,7 +1216,7 @@ path::remove_filename()\n \t      if (prev->_M_type() == _Type::_Root_dir\n \t\t  || prev->_M_type() == _Type::_Root_name)\n \t\t{\n-\t\t  _M_cmpts.erase(cmpt);\n+\t\t  _M_cmpts.pop_back();\n \t\t  if (_M_cmpts.size() == 1)\n \t\t    {\n \t\t      _M_cmpts.type(_M_cmpts.front()._M_type());\n@@ -1681,25 +1684,30 @@ path::lexically_normal() const\n \t      // Got a path with a relative path (i.e. at least one non-root\n \t      // element) and no filename at the end (i.e. empty last element),\n \t      // so must have a trailing slash. See what is before it.\n-\t      auto elem = std::prev(ret.end(), 2);\n+\t      auto elem = ret._M_cmpts.end() - 2;\n \t      if (elem->has_filename() && !is_dotdot(*elem))\n \t\t{\n \t\t  // Remove the filename before the trailing slash\n \t\t  // (equiv. to ret = ret.parent_path().remove_filename())\n \n-\t\t  if (elem == ret.begin())\n+\t\t  if (elem == ret._M_cmpts.begin())\n \t\t    ret.clear();\n \t\t  else\n \t\t    {\n-\t\t      ret._M_pathname.erase(elem._M_cur->_M_pos);\n-\t\t      // Do we still have a trailing slash?\n+\t\t      ret._M_pathname.erase(elem->_M_pos);\n+\t\t      // Remove empty filename at the end:\n+\t\t      ret._M_cmpts.pop_back();\n+\t\t      // If we still have a trailing non-root dir separator\n+\t\t      // then leave an empty filename at the end:\n \t\t      if (std::prev(elem)->_M_type() == _Type::_Filename)\n-\t\t\tret._M_cmpts.erase(elem._M_cur);\n-\t\t      else\n-\t\t\tret._M_cmpts.erase(elem._M_cur, ret._M_cmpts.end());\n+\t\t\telem->clear();\n+\t\t      else // remove the component completely:\n+\t\t\tret._M_cmpts.pop_back();\n \t\t    }\n \t\t}\n-\t      else // ???\n+\t      else\n+\t\t// Append the \"..\" to something ending in \"../\" which happens\n+\t\t// when normalising paths like \".././..\" and \"../a/../..\"\n \t\tret /= p;\n \t    }\n \t}"}, {"sha": "844168352c895ae31b22e40be4fe8aa8a51fe861", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/generation/normal.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal.cc?ref=73d968d94561fd521bc6a9af993ed1d1ebba8459", "patch": "@@ -125,6 +125,8 @@ test03()\n     {\"../foo/../foo/..\"   , \"..\" },\n     {\"../.f/../f\"   , \"../f\" },\n     {\"../f/../.f\"   , \"../.f\" },\n+    {\"../..\"        , \"../..\" },\n+    {\"../../.\"      , \"../..\" },\n     {\".././../.\"    , \"../..\" },\n     {\".././.././\"   , \"../..\" },\n     {\"/..\"          , \"/\" },"}, {"sha": "f78f5dd8a9f6d7fdc86349707472c6ed37e35396", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/generation/normal2.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d968d94561fd521bc6a9af993ed1d1ebba8459/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fgeneration%2Fnormal2.cc?ref=73d968d94561fd521bc6a9af993ed1d1ebba8459", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#undef _GLIBCXX_USE_CXX11_ABI\n+#define _GLIBCXX_USE_CXX11_ABI 0\n+#include <filesystem>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+void\n+compare_paths(path p, std::string expected)\n+{\n+#if defined(_WIN32) && !defined(__CYGWIN__)\n+  for (auto& c : expected)\n+    if (c == '/')\n+      c = '\\\\';\n+#endif\n+  __gnu_test::compare_paths(p, expected);\n+}\n+\n+void\n+test02()\n+{\n+  path p = \"./a/b/c/../.././b/c\";\n+  // For the COW string this used to produce incorrect results:\n+  auto norm = p.lexically_normal();\n+  compare_paths( norm, \"a/b/c\" );\n+}\n+\n+int\n+main()\n+{\n+  test02();\n+}"}]}