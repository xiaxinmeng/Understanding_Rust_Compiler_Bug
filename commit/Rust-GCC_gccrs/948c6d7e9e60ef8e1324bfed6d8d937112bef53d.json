{"sha": "948c6d7e9e60ef8e1324bfed6d8d937112bef53d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4YzZkN2U5ZTYwZWY4ZTEzMjRiZmVkNmQ4ZDkzNzExMmJlZjUzZA==", "commit": {"author": {"name": "Dmitriy Anisimkov", "email": "anisimko@adacore.com", "date": "2020-08-03T06:18:20Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-21T07:22:46Z"}, "message": "[Ada] Improve precision of Ada.Directories.Modification_Time\n\ngcc/ada/\n\n\t* adaint.c (__gnat_file_time): New routine.\n\t(__gnat_copy_attribs): Copy timestamps in nanoseconds.\n\t* libgnat/a-direct.adb (C_Modification_Time): Bind to\n\t__gnat_file_time.\n\t(Modification_Time): Call to C_Modification_Time.", "tree": {"sha": "51081b2563e9c596fb544ef368107c495e64dc49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51081b2563e9c596fb544ef368107c495e64dc49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/948c6d7e9e60ef8e1324bfed6d8d937112bef53d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948c6d7e9e60ef8e1324bfed6d8d937112bef53d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948c6d7e9e60ef8e1324bfed6d8d937112bef53d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948c6d7e9e60ef8e1324bfed6d8d937112bef53d/comments", "author": {"login": "anisimkov", "id": 15864134, "node_id": "MDQ6VXNlcjE1ODY0MTM0", "avatar_url": "https://avatars.githubusercontent.com/u/15864134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anisimkov", "html_url": "https://github.com/anisimkov", "followers_url": "https://api.github.com/users/anisimkov/followers", "following_url": "https://api.github.com/users/anisimkov/following{/other_user}", "gists_url": "https://api.github.com/users/anisimkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/anisimkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anisimkov/subscriptions", "organizations_url": "https://api.github.com/users/anisimkov/orgs", "repos_url": "https://api.github.com/users/anisimkov/repos", "events_url": "https://api.github.com/users/anisimkov/events{/privacy}", "received_events_url": "https://api.github.com/users/anisimkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b612313b6e67dd01159cd8ceeafeac9f9e6dd04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b612313b6e67dd01159cd8ceeafeac9f9e6dd04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b612313b6e67dd01159cd8ceeafeac9f9e6dd04"}], "stats": {"total": 139, "additions": 115, "deletions": 24}, "files": [{"sha": "9ef02438308de7014380a86f9fb79d27b90f0975", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 97, "deletions": 5, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948c6d7e9e60ef8e1324bfed6d8d937112bef53d/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948c6d7e9e60ef8e1324bfed6d8d937112bef53d/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=948c6d7e9e60ef8e1324bfed6d8d937112bef53d", "patch": "@@ -60,6 +60,7 @@\n /* We want to use the POSIX variants of include files.  */\n #define POSIX\n #include \"vxWorks.h\"\n+#include <sys/time.h>\n \n #if defined (__mips_vxworks)\n #include \"cacheLib.h\"\n@@ -1474,6 +1475,74 @@ __gnat_file_time_fd (int fd)\n    return __gnat_file_time_fd_attr (fd, &attr);\n }\n \n+extern long long __gnat_file_time(char* name)\n+{\n+  long long result;\n+\n+  if (name == NULL) {\n+    return LLONG_MIN;\n+  }\n+  /* Number of seconds between <Jan 1st 1970> and <Jan 1st 2150>. */\n+  static const long long ada_epoch_offset = (136 * 365 + 44 * 366) * 86400LL;\n+#if defined(_WIN32)\n+\n+  /* Number of 100 nanoseconds between <Jan 1st 1601> and <Jan 1st 2150>. */\n+  static const long long w32_epoch_offset =\n+  (11644473600LL + ada_epoch_offset) * 1E7;\n+\n+  WIN32_FILE_ATTRIBUTE_DATA fad;\n+  union\n+  {\n+    FILETIME ft_time;\n+    long long ll_time;\n+  } t_write;\n+\n+  if (!GetFileAttributesExA(name, GetFileExInfoStandard, &fad)) {\n+    return LLONG_MIN;\n+  }\n+\n+  t_write.ft_time = fad.ftLastWriteTime;\n+\n+  /* Next code similar to (t_write.ll_time - w32_epoch_offset) * 100\n+     but on overflow returns LLONG_MIN value. */\n+\n+  if (__builtin_ssubll_overflow(t_write.ll_time, w32_epoch_offset, &result)) {\n+    return LLONG_MIN;\n+  }\n+\n+  if (__builtin_smulll_overflow(result, 100, &result)) {\n+    return LLONG_MIN;\n+  }\n+\n+#else\n+\n+  struct stat sb;\n+  if (stat(name, &sb) != 0) {\n+    return LLONG_MIN;\n+  }\n+\n+  /* Next code similar to\n+     (sb.st_mtime - ada_epoch_offset) * 1E9 + sb.st_mtim.tv_nsec\n+     but on overflow returns LLONG_MIN value. */\n+\n+  if (__builtin_ssubll_overflow(sb.st_mtime, ada_epoch_offset, &result)) {\n+    return LLONG_MIN;\n+  }\n+\n+  if (__builtin_smulll_overflow(result, 1E9, &result)) {\n+    return LLONG_MIN;\n+  }\n+\n+#if defined(st_mtime)\n+  if (__builtin_saddll_overflow(result, sb.st_mtim.tv_nsec, &result)) {\n+    return LLONG_MIN;\n+  }\n+#endif\n+\n+#endif\n+  return result;\n+}\n+\n /* Set the file time stamp.  */\n \n void\n@@ -3173,22 +3242,45 @@ __gnat_copy_attribs (char *from ATTRIBUTE_UNUSED, char *to ATTRIBUTE_UNUSED,\n \n #else\n   GNAT_STRUCT_STAT fbuf;\n-  struct utimbuf tbuf;\n \n   if (GNAT_STAT (from, &fbuf) == -1) {\n      return -1;\n   }\n \n-  /* Do we need to copy timestamp ? */\n+#if _POSIX_C_SOURCE >= 200809L\n+  struct timespec tbuf[2];\n+\n   if (mode != 2) {\n-     tbuf.actime = fbuf.st_atime;\n-     tbuf.modtime = fbuf.st_mtime;\n+     tbuf[0] = fbuf.st_atim;\n+     tbuf[1] = fbuf.st_mtim;\n \n-     if (utime (to, &tbuf) == -1) {\n+     if (utimensat (AT_FDCWD, to, tbuf, 0) == -1) {\n         return -1;\n      }\n   }\n \n+#else\n+  struct timeval tbuf[2];\n+  /* Do we need to copy timestamp ? */\n+\n+  if (mode != 2) {\n+     tbuf[0].tv_sec  = fbuf.st_atime;\n+     tbuf[1].tv_sec  = fbuf.st_mtime;\n+\n+     #if defined(st_mtime)\n+     tbuf[0].tv_usec = fbuf.st_atim.tv_nsec / 1000;\n+     tbuf[1].tv_usec = fbuf.st_mtim.tv_nsec / 1000;\n+     #else\n+     tbuf[0].tv_usec = 0;\n+     tbuf[1].tv_usec = 0;\n+     #endif\n+\n+     if (utimes (to, tbuf) == -1) {\n+        return -1;\n+     }\n+  }\n+#endif\n+\n   /* Do we need to copy file permissions ? */\n   if (mode != 0 && (chmod (to, fbuf.st_mode) == -1)) {\n \t  return -1;"}, {"sha": "162ace919f9e54e4f9aae4650ec381d337d68b6a", "filename": "gcc/ada/libgnat/a-direct.adb", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948c6d7e9e60ef8e1324bfed6d8d937112bef53d/gcc%2Fada%2Flibgnat%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948c6d7e9e60ef8e1324bfed6d8d937112bef53d/gcc%2Fada%2Flibgnat%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-direct.adb?ref=948c6d7e9e60ef8e1324bfed6d8d937112bef53d", "patch": "@@ -30,7 +30,6 @@\n ------------------------------------------------------------------------------\n \n with Ada.Calendar;               use Ada.Calendar;\n-with Ada.Calendar.Formatting;    use Ada.Calendar.Formatting;\n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n with Ada.Directories.Validity;   use Ada.Directories.Validity;\n with Ada.Directories.Hierarchical_File_Names;\n@@ -70,6 +69,15 @@ package body Ada.Directories is\n    pragma Import (C, Max_Path, \"__gnat_max_path_len\");\n    --  The maximum length of a path\n \n+   function C_Modification_Time (N : System.Address) return Ada.Calendar.Time;\n+   pragma Import (C, C_Modification_Time, \"__gnat_file_time\");\n+   --  Get modification time for file with name referenced by N\n+\n+   Invalid_Time : constant Ada.Calendar.Time :=\n+                    C_Modification_Time (System.Null_Address);\n+   --  Result returned from C_Modification_Time call when routine unable to get\n+   --  file modification time.\n+\n    type Search_Data is record\n       Is_Valid      : Boolean := False;\n       Name          : Unbounded_String;\n@@ -991,34 +999,25 @@ package body Ada.Directories is\n    -----------------------\n \n    function Modification_Time (Name : String) return Time is\n-      Date   : OS_Time;\n-      Year   : Year_Type;\n-      Month  : Month_Type;\n-      Day    : Day_Type;\n-      Hour   : Hour_Type;\n-      Minute : Minute_Type;\n-      Second : Second_Type;\n \n+      Date   : Time;\n+      C_Name : aliased String (1 .. Name'Length + 1);\n    begin\n       --  First, the invalid cases\n \n       if not (Is_Regular_File (Name) or else Is_Directory (Name)) then\n          raise Name_Error with '\"' & Name & \"\"\" not a file or directory\";\n \n       else\n-         Date := File_Time_Stamp (Name);\n-\n-         --  Break down the time stamp into its constituents relative to GMT.\n-         --  This version of Split does not recognize leap seconds or buffer\n-         --  space for time zone processing.\n+         C_Name := Name & ASCII.NUL;\n+         Date := C_Modification_Time (C_Name'Address);\n \n-         GM_Split (Date, Year, Month, Day, Hour, Minute, Second);\n-\n-         --  The result must be in GMT. Ada.Calendar.\n-         --  Formatting.Time_Of with default time zone of zero (0) is the\n-         --  routine of choice.\n+         if Date = Invalid_Time then\n+            raise Use_Error with\n+              \"Unable to get modification time of the file \"\"\" & Name & '\"';\n+         end if;\n \n-         return Time_Of (Year, Month, Day, Hour, Minute, Second, 0.0);\n+         return Date;\n       end if;\n    end Modification_Time;\n "}]}