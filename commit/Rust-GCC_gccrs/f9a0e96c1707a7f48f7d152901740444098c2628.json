{"sha": "f9a0e96c1707a7f48f7d152901740444098c2628", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlhMGU5NmMxNzA3YTdmNDhmN2QxNTI5MDE3NDA0NDQwOThjMjYyOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-13T02:32:41Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-13T02:32:41Z"}, "message": "cppexp.c, [...]: Eradicate all traces of code dependent on traditional, lang_chill, or lang_fortran.\n\n\t* cppexp.c, cpphash.c, cpphash.h, cppinit.c, cpplex.c,\n\tcpplib.c, cpplib.h: Eradicate all traces of code dependent on\n\ttraditional, lang_chill, or lang_fortran.\n\n\t* cppfiles.c: #undef strcmp to suppress warning about macros\n\tused without arguments.\n\t(_cpp_execute_include): Use f, not fname, in \"No include path\"\n\terror.\n\t(_cpp_pop_file_buffer): New function.\n\t* cpplib.c: Don't include <sys/mman.h>.\n\t(cpp_push_buffer): Set line_base and lineno in new buffer.\n\t(cpp_pop_buffer): Use _cpp_pop_file_buffer.\n\n\t* cpplex.c: Move all prototypes and structure declarations to the\n\ttop of the file.  Properly parenthesise some macro arguments.\n\t(cpp_scan_line): New function.\n\t(special_symbol [case T_INCLUDE_DEPTH]): Use pfile->include_depth,\n\tdon't need to walk up the stack counting.\n\nFrom-SVN: r35003", "tree": {"sha": "f6656bb21e208ce3d9194a471d84e8b7a0fdac65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6656bb21e208ce3d9194a471d84e8b7a0fdac65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9a0e96c1707a7f48f7d152901740444098c2628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9a0e96c1707a7f48f7d152901740444098c2628", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9a0e96c1707a7f48f7d152901740444098c2628", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9a0e96c1707a7f48f7d152901740444098c2628/comments", "author": null, "committer": null, "parents": [{"sha": "d55bb5be913e11b1ba639c124403ef0cd7e11517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55bb5be913e11b1ba639c124403ef0cd7e11517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d55bb5be913e11b1ba639c124403ef0cd7e11517"}], "stats": {"total": 484, "additions": 219, "deletions": 265}, "files": [{"sha": "44811ccc4fe6ea78ca85d3f7fc0253f9bb05c837", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -1,3 +1,24 @@\n+2000-07-12  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppexp.c, cpphash.c, cpphash.h, cppinit.c, cpplex.c,\n+\tcpplib.c, cpplib.h: Eradicate all traces of code dependent on\n+\ttraditional, lang_chill, or lang_fortran.\n+\n+\t* cppfiles.c: #undef strcmp to suppress warning about macros\n+\tused without arguments.\n+\t(_cpp_execute_include): Use f, not fname, in \"No include path\"\n+\terror.\n+\t(_cpp_pop_file_buffer): New function.\n+\t* cpplib.c: Don't include <sys/mman.h>.\n+\t(cpp_push_buffer): Set line_base and lineno in new buffer.\n+\t(cpp_pop_buffer): Use _cpp_pop_file_buffer.\n+\n+\t* cpplex.c: Move all prototypes and structure declarations to the\n+\ttop of the file.  Properly parenthesise some macro arguments.\n+\t(cpp_scan_line): New function.\n+\t(special_symbol [case T_INCLUDE_DEPTH]): Use pfile->include_depth,\n+\tdon't need to walk up the stack counting.\n+\n 2000-07-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-common.c (combine_strings): Emit a pedantic warning when a"}, {"sha": "ce1d82b5cc5b286b4cc75e2be68c079d7d2b6c64", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -298,7 +298,7 @@ parse_charconst (pfile, tok)\n     SYNTAX_ERROR (\"empty character constant\");\n   else if (num_chars > max_chars)\n     SYNTAX_ERROR (\"character constant too long\");\n-  else if (num_chars != 1 && ! CPP_TRADITIONAL (pfile))\n+  else if (num_chars != 1)\n     cpp_warning (pfile, \"multi-character character constant\");\n \n   /* If char type is signed, sign-extend the constant.  */"}, {"sha": "2b153719e5c6d95f69409f3f2a6919cb4b0cb276", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -43,6 +43,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n # define O_BINARY 0\n #endif\n \n+/* Suppress warning about function macros used w/o arguments in traditional\n+   C.  It is unlikely that glibc's strcmp macro helps this file at all.  */\n+#undef strcmp\n+\n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));\n@@ -423,7 +427,7 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)\n \n   if (!search_start)\n     {\n-      cpp_error (pfile, \"No include path in which to find %s\", fname);\n+      cpp_error (pfile, \"No include path in which to find %s\", f);\n       return;\n     }\n \n@@ -762,6 +766,44 @@ read_with_read (fp, fd, size)\n   return offset;\n }\n \n+/* Do appropriate cleanup when a file buffer is popped off the input\n+   stack.  */\n+void\n+_cpp_pop_file_buffer (pfile, buf)\n+     cpp_reader *pfile;\n+     cpp_buffer *buf;\n+{\n+  struct include_file *inc = buf->inc;\n+\n+  if (pfile->system_include_depth)\n+    pfile->system_include_depth--;\n+  if (pfile->include_depth)\n+    pfile->include_depth--;\n+  if (pfile->potential_control_macro)\n+    {\n+      if (inc->cmacro != NEVER_REREAD)\n+\tinc->cmacro = pfile->potential_control_macro;\n+      pfile->potential_control_macro = 0;\n+    }\n+  pfile->input_stack_listing_current = 0;\n+\n+  /* Discard file buffer.  XXX Would be better to cache these instead\n+     of the file descriptors.  */\n+#ifdef HAVE_MMAP_FILE\n+  if (buf->mapped)\n+    munmap ((caddr_t) buf->buf, buf->rlimit - buf->buf);\n+  else\n+#endif\n+    free ((PTR) buf->buf);\n+\n+  /* If the file will not be included again, close it.  */\n+  if (DO_NOT_REREAD (inc))\n+    {\n+      close (inc->fd);\n+      inc->fd = -1;\n+    }\n+}\n+\n /* The file_name_map structure holds a mapping of file names for a\n    particular directory.  This mapping is read from the file named\n    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to"}, {"sha": "749187fa90ef3353c0aa1ad217317f1f45511ac9", "filename": "gcc/cpphash.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -502,34 +502,33 @@ save_expansion (pfile, first, first_param, info)\n   ntokens = len = 0;\n   for (token = first; token->type != CPP_EOF; token++)\n     {\n-      const char *msg;\n-\n       if (token->type == CPP_PASTE)\n \t{\n-\t  /* Token-paste ##, but is a normal token if traditional.  */\n-\t  if (! CPP_TRADITIONAL (pfile))\n+\t  /* Token-paste ##, can appear in both object-like and\n+\t     function-like macros, but not at the ends.  Constraint\n+\t     6.10.3.3.1 */\n+\t  if (token == first || token[1].type == CPP_EOF)\n \t    {\n-\t      msg = \"\\\"##\\\" cannot appear at either end of a macro expansion\";\n-\t      /* Constraint 6.10.3.3.1  */\n-\t      if (token == first || token[1].type == CPP_EOF)\n-\t\tgoto error;\n-\t      continue;\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\"'##' cannot appear at either end of a macro expansion\");\n+\t      return 0;\n \t    }\n+\t  continue;\n \t}\n       else if (token->type == CPP_HASH)\n \t{\n-\t  /* Stringifying #, but is a normal character if traditional,\n-\t     or in object-like macros.  Constraint 6.10.3.2.1.  */\n-\t  if (info->paramc >= 0 && ! CPP_TRADITIONAL (pfile))\n+\t  /* Stringifying #, but a normal character in object-like\n+             macros.  Must come before a parameter name.  Constraint\n+             6.10.3.2.1.  */\n+\t  if (info->paramc >= 0)\n \t    {\n \t      if (token[1].type == CPP_NAME\n \t\t  && find_param (first_param, token + 1))\n \t\tcontinue;\n \t      if (! CPP_OPTION (pfile, lang_asm))\n \t\t{\n-\t\t  msg = \"'#' is not followed by a macro parameter\";\n-\t\terror:\n-\t\t  cpp_error_with_line (pfile, token->line, token->col, msg);\n+\t\t  cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t       \"'#' is not followed by a macro parameter\");\n \t\t  return 0;\n \t\t}\n \t    }\n@@ -583,25 +582,20 @@ save_expansion (pfile, first, first_param, info)\n \t  dest->val.aux = param_no - 1;\n \n \t  dest->type = CPP_MACRO_ARG;\n-\t  if (token[-1].type == CPP_HASH && ! CPP_TRADITIONAL (pfile))\n+\t  if (token[-1].type == CPP_HASH)\n \t    dest->flags = token[-1].flags | STRINGIFY_ARG;\n \t  else\n \t    dest->flags = token->flags;  /* Particularly PREV_WHITE.  */\n \t  dest++;\n \t  continue;\n \n \tcase CPP_PASTE:\n-\t  if (! CPP_TRADITIONAL (pfile))\n-\t    {\n-\t      dest[-1].flags |= PASTE_LEFT;\n-\t      continue;\n-\t    }\n-\t  break;\n+\t  dest[-1].flags |= PASTE_LEFT;\n+\t  continue;\n \n \tcase CPP_HASH:\n \t  /* Stringifying #.  Constraint 6.10.3.2.1  */\n-\t  if (list->paramc >= 0 && ! CPP_TRADITIONAL (pfile)\n-\t      && token[1].type == CPP_NAME\n+\t  if (list->paramc >= 0 && token[1].type == CPP_NAME\n \t      && find_param (first_param, token + 1))\n \t    continue;\n \t  break;"}, {"sha": "5f4f86bedb656b70322604fa19f90627321bbf92", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -194,7 +194,6 @@ extern unsigned char _cpp_IStable[256];\n \n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n-#define CPP_TRADITIONAL(PFILE) CPP_OPTION (PFILE, traditional)\n #define CPP_IN_SYSTEM_HEADER(PFILE) \\\n   (CPP_BUFFER (PFILE) && CPP_BUFFER (PFILE)->inc \\\n    && CPP_BUFFER (PFILE)->inc->sysp)\n@@ -228,6 +227,7 @@ extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\n extern const char *_cpp_fake_include\tPARAMS ((cpp_reader *, const char *));\n+extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *, cpp_buffer *));\n \n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));"}, {"sha": "476d396f170600987021fee78420a135f3abe309", "filename": "gcc/cppinit.c", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -571,12 +571,7 @@ initialize_builtins (pfile)\n \t}\n       else\n \t{\n-\t  cpp_hashnode *hp;\n-\t  \n-\t  if (b->type == T_STDC && CPP_TRADITIONAL (pfile))\n-\t    continue;\n-\n-\t  hp = cpp_lookup (pfile, b->name, b->len);\n+\t  cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);\n \t  hp->type = b->type;\n \t}\n     }\n@@ -762,22 +757,12 @@ cpp_start_read (pfile, print, fname)\n       return 0;\n     }\n \n-  /* Chill should not be used with -trigraphs. */\n-  if (CPP_OPTION (pfile, chill) && CPP_OPTION (pfile, trigraphs))\n-    {\n-      cpp_warning (pfile, \"-lang-chill and -trigraphs are mutually exclusive\");\n-      CPP_OPTION (pfile, trigraphs) = 0;\n-    }\n-\n   /* -Wtraditional is not useful in C++ mode.  */\n   if (CPP_OPTION (pfile, cplusplus))\n     CPP_OPTION (pfile, warn_traditional) = 0;\n \n-  /* Do not warn about illegal token pasting if -traditional,\n-     -lang-fortran, or -lang-asm.  */\n-  if (CPP_OPTION (pfile, traditional)\n-      || CPP_OPTION (pfile, lang_fortran)\n-      || CPP_OPTION (pfile, lang_asm))\n+  /* Do not warn about illegal token pasting if -lang-asm.  */\n+  if (CPP_OPTION (pfile, lang_asm))\n     CPP_OPTION (pfile, warn_paste) = 0;\n \n   /* Set this if it hasn't been set already. */\n@@ -1028,8 +1013,6 @@ new_pending_directive (pend, text, handler)\n   DEF_OPT(\"lang-c\",                   0,      OPT_lang_c)                     \\\n   DEF_OPT(\"lang-c++\",                 0,      OPT_lang_cplusplus)             \\\n   DEF_OPT(\"lang-c89\",                 0,      OPT_lang_c89)                   \\\n-  DEF_OPT(\"lang-chill\",               0,      OPT_lang_chill)                 \\\n-  DEF_OPT(\"lang-fortran\",             0,      OPT_lang_fortran)               \\\n   DEF_OPT(\"lang-objc\",                0,      OPT_lang_objc)                  \\\n   DEF_OPT(\"lang-objc++\",              0,      OPT_lang_objcplusplus)          \\\n   DEF_OPT(\"nostdinc\",                 0,      OPT_nostdinc)                   \\\n@@ -1048,7 +1031,6 @@ new_pending_directive (pend, text, handler)\n   DEF_OPT(\"std=iso9899:199409\",       0,      OPT_std_iso9899_199409)         \\\n   DEF_OPT(\"std=iso9899:1999\",         0,      OPT_std_iso9899_1999)           \\\n   DEF_OPT(\"std=iso9899:199x\",         0,      OPT_std_iso9899_199x)           \\\n-  DEF_OPT(\"traditional\",              0,      OPT_traditional)                \\\n   DEF_OPT(\"trigraphs\",                0,      OPT_trigraphs)                  \\\n   DEF_OPT(\"v\",                        0,      OPT_v)                          \\\n   DEF_OPT(\"w\",                        0,      OPT_w)\n@@ -1267,13 +1249,6 @@ handle_option (pfile, argc, argv)\n \tcase OPT_pedantic:\n  \t  CPP_OPTION (pfile, pedantic) = 1;\n \t  break;\n-\tcase OPT_traditional:\n-\t  CPP_OPTION (pfile, traditional) = 1;\n-\t  CPP_OPTION (pfile, cplusplus_comments) = 0;\n-\t  CPP_OPTION (pfile, trigraphs) = 0;\n-\t  CPP_OPTION (pfile, digraphs) = 0;\n-\t  CPP_OPTION (pfile, warn_trigraphs) = 0;\n-\t  break;\n \tcase OPT_trigraphs:\n  \t  CPP_OPTION (pfile, trigraphs) = 1;\n \t  break;\n@@ -1321,18 +1296,6 @@ handle_option (pfile, argc, argv)\n \t  CPP_OPTION (pfile, dollars_in_ident) = 0;\n \t  new_pending_directive (pend, \"__ASSEMBLER__\", cpp_define);\n \t  break;\n-\tcase OPT_lang_fortran:\n- \t  CPP_OPTION (pfile, lang_fortran) = 1;\n-\t  CPP_OPTION (pfile, traditional) = 1;\n-\t  CPP_OPTION (pfile, cplusplus_comments) = 0;\n-\t  new_pending_directive (pend, \"_LANGUAGE_FORTRAN\", cpp_define);\n-\t  break;\n-\tcase OPT_lang_chill:\n-\t  CPP_OPTION (pfile, objc) = 0;\n-\t  CPP_OPTION (pfile, cplusplus) = 0;\n-\t  CPP_OPTION (pfile, chill) = 1;\n-\t  CPP_OPTION (pfile, traditional) = 1;\n-\t  break;\n \tcase OPT_nostdinc:\n \t  /* -nostdinc causes no default include directories.\n \t     You must specify all include-file directories with -I.  */\n@@ -1721,18 +1684,15 @@ Switches:\\n\\\n   fputs (_(\"\\\n   -pedantic                 Issue all warnings demanded by strict ISO C\\n\\\n   -pedantic-errors          Issue -pedantic warnings as errors instead\\n\\\n-  -traditional              Follow K&R pre-processor behaviour\\n\\\n   -trigraphs                Support ISO C trigraphs\\n\\\n   -lang-c                   Assume that the input sources are in C\\n\\\n   -lang-c89                 Assume that the input sources are in C89\\n\\\n-  -lang-c++                 Assume that the input sources are in C++\\n\\\n \"), stdout);\n   fputs (_(\"\\\n+  -lang-c++                 Assume that the input sources are in C++\\n\\\n   -lang-objc                Assume that the input sources are in ObjectiveC\\n\\\n   -lang-objc++              Assume that the input sources are in ObjectiveC++\\n\\\n   -lang-asm                 Assume that the input sources are in assembler\\n\\\n-  -lang-fortran\t\t    Assume that the input sources are in Fortran\\n\\\n-  -lang-chill               Assume that the input sources are in Chill\\n\\\n \"), stdout);\n   fputs (_(\"\\\n   -std=<std name>           Specify the conformance standard; one of:\\n\\\n@@ -1746,9 +1706,8 @@ Switches:\\n\\\n \"), stdout);\n   fputs (_(\"\\\n   -Wno-comment{s}           Do not warn about comments\\n\\\n-  -Wtraditional             Warn if a macro argument is/would be turned into\\n\\\n-                             a string if -traditional is specified\\n\\\n-  -Wno-traditional          Do not warn about stringification\\n\\\n+  -Wtraditional             Warn about features not present in traditional C\\n\\\n+  -Wno-traditional          Do not warn about traditional C\\n\\\n   -Wundef                   Warn if an undefined macro is used by #if\\n\\\n   -Wno-undef                Do not warn about testing undefined macros\\n\\\n   -Wimport                  Warn about the use of the #import directive\\n\\"}, {"sha": "6c401733665036593fe97abb80d009608ad2bcc7", "filename": "gcc/cpplex.c", "status": "modified", "additions": 115, "deletions": 127, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -50,6 +50,54 @@ o Correct pastability test for CPP_NAME and CPP_NUMBER.\n #include \"cpphash.h\"\n #include \"symcat.h\"\n \n+static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER, 0 UNION_INIT_ZERO};\n+static const cpp_token eof_token = {0, 0, CPP_EOF, 0 UNION_INIT_ZERO};\n+\n+/* Flags for cpp_context.  */\n+#define CONTEXT_PASTEL\t(1 << 0) /* An argument context on LHS of ##.  */\n+#define CONTEXT_PASTER\t(1 << 1) /* An argument context on RHS of ##.  */\n+#define CONTEXT_RAW\t(1 << 2) /* If argument tokens already expanded.  */\n+#define CONTEXT_ARG\t(1 << 3) /* If an argument context.  */\n+\n+typedef struct cpp_context cpp_context;\n+struct cpp_context\n+{\n+  union\n+  {\n+    const cpp_toklist *list;\t/* Used for macro contexts only.  */\n+    const cpp_token **arg;\t/* Used for arg contexts only.  */\n+  } u;\n+\n+  /* Pushed token to be returned by next call to get_raw_token.  */\n+  const cpp_token *pushed_token;\n+\n+  struct macro_args *args;\t/* 0 for arguments and object-like macros.  */\n+  unsigned short posn;\t\t/* Current posn, index into u.  */\n+  unsigned short count;\t\t/* No. of tokens in u.  */\n+  unsigned short level;\n+  unsigned char flags;\n+};\n+\n+typedef struct macro_args macro_args;\n+struct macro_args\n+{\n+  unsigned int *ends;\n+  const cpp_token **tokens;\n+  unsigned int capacity;\n+  unsigned int used;\n+  unsigned short level;\n+};\n+\n+static const cpp_token *get_raw_token PARAMS ((cpp_reader *));\n+static const cpp_token *parse_arg PARAMS ((cpp_reader *, int, unsigned int,\n+\t\t\t\t\t   macro_args *, unsigned int *));\n+static int parse_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_args *));\n+static void save_token PARAMS ((macro_args *, const cpp_token *));\n+static int pop_context PARAMS ((cpp_reader *));\n+static int push_macro_context PARAMS ((cpp_reader *, const cpp_token *));\n+static void push_arg_context PARAMS ((cpp_reader *, const cpp_token *));\n+static void free_macro_args PARAMS ((macro_args *));\n+\n #define auto_expand_name_space(list) \\\n     _cpp_expand_name_space ((list), 1 + (list)->name_cap / 2)\n static void safe_fwrite\t\tPARAMS ((cpp_reader *, const U_CHAR *,\n@@ -131,9 +179,9 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n #define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITE))\n #define PREV_TOKEN_TYPE (cur_token[-1].type)\n \n-#define PUSH_TOKEN(ttype) cur_token++->type = ttype\n-#define REVISE_TOKEN(ttype) cur_token[-1].type = ttype\n-#define BACKUP_TOKEN(ttype) (--cur_token)->type = ttype\n+#define PUSH_TOKEN(ttype) cur_token++->type = (ttype)\n+#define REVISE_TOKEN(ttype) cur_token[-1].type = (ttype)\n+#define BACKUP_TOKEN(ttype) (--cur_token)->type = (ttype)\n #define BACKUP_DIGRAPH(ttype) do { \\\n   BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n \n@@ -145,6 +193,20 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \t\t\t\t  ? (token)->val.node->length\t\t\\\n \t\t\t\t  : 0)))\n \n+#define IS_ARG_CONTEXT(c) ((c)->flags & CONTEXT_ARG)\n+#define CURRENT_CONTEXT(pfile) ((pfile)->contexts + (pfile)->cur_context)\n+\n+#define ASSIGN_FLAGS_AND_POS(d, s) \\\n+  do {(d)->flags = (s)->flags & (PREV_WHITE | BOL | PASTE_LEFT); \\\n+      if ((d)->flags & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n+  } while (0)\n+\n+/* f is flags, just consisting of PREV_WHITE | BOL.  */\n+#define MODIFY_FLAGS_AND_POS(d, s, f) \\\n+  do {(d)->flags &= ~(PREV_WHITE | BOL); (d)->flags |= (f); \\\n+      if ((f) & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n+  } while (0)\n+\n #define T(e, s) {SPELL_OPERATOR, (const U_CHAR *) s},\n #define I(e, s) {SPELL_IDENT, s},\n #define S(e, s) {SPELL_STRING, s},\n@@ -368,7 +430,6 @@ cpp_scan_buffer_nooutput (pfile)\n }\n \n /* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.  */\n-\n void\n cpp_scan_buffer (pfile, print)\n      cpp_reader *pfile;\n@@ -401,6 +462,29 @@ cpp_scan_buffer (pfile, print)\n     }\n }\n \n+/* Scan a single line of the input into the token_buffer.  */\n+void\n+cpp_scan_line (pfile)\n+     cpp_reader *pfile;\n+{\n+  const cpp_token *token, *prev = 0;\n+\n+  do\n+    {\n+      token = cpp_get_token (pfile);\n+      if (token->type == CPP_EOF)\n+\t{\n+\t  cpp_pop_buffer (pfile);\n+\t  break;\n+\t}\n+\n+      output_token (pfile, token, prev);\n+      prev = token;\n+    }\n+  while (pfile->cur_context > 0\n+\t || pfile->contexts[0].posn < pfile->contexts[0].count);\n+}\n+\n /* Helper routine used by parse_include, which can't see spell_token.\n    Reinterpret the current line as an h-char-sequence (< ... >); we are\n    looking at the first token after the <.  */\n@@ -872,8 +956,8 @@ skip_block_comment (pfile)\n   return seen_eof;\n }\n \n-/* Skip a C++ or Chill line comment.  Handles escaped newlines.\n-   Returns non-zero if a multiline comment.  */\n+/* Skip a C++ line comment.  Handles escaped newlines.  Returns\n+   non-zero if a multiline comment.  */\n static int\n skip_line_comment (pfile)\n      cpp_reader *pfile;\n@@ -1092,19 +1176,17 @@ parse_string (pfile, list, token, terminator)\n \n \t      cur--;\n \n-\t      /* In Fortran and assembly language, silently terminate\n-\t\t strings of either variety at end of line.  This is a\n-\t\t kludge around not knowing where comments are in these\n-\t\t languages.  */\n-\t      if (CPP_OPTION (pfile, lang_fortran)\n-\t\t  || CPP_OPTION (pfile, lang_asm))\n+\t      /* In assembly language, silently terminate strings of\n+\t\t either variety at end of line.  This is a kludge\n+\t\t around not knowing where comments are.  */\n+\t      if (CPP_OPTION (pfile, lang_asm))\n \t\tgoto out;\n \n-\t      /* Character constants, headers and asserts may not\n-\t\t extend over multiple lines.  In Standard C, neither\n-\t\t may strings.  We accept multiline strings as an\n+\t      /* Character constants and header names may not extend\n+\t\t over multiple lines.  In Standard C, neither may\n+\t\t strings.  We accept multiline strings as an\n \t\t extension.  (Even in directives - otherwise, glibc's\n-\t         longlong.h breaks.)  */\n+\t\t longlong.h breaks.)  */\n \t      if (terminator != '\"')\n \t\tgoto unterminated;\n \t\t\n@@ -1175,8 +1257,8 @@ parse_string (pfile, list, token, terminator)\n }\n \n /* The character TYPE helps us distinguish comment types: '*' = C\n-   style, '-' = Chill-style and '/' = C++ style.  For code simplicity,\n-   the stored comment includes the comment start and any terminator.  */\n+   style, '/' = C++ style.  For code simplicity, the stored comment\n+   includes the comment start and any terminator.  */\n \n #define COMMENT_START_LEN 2\n static void\n@@ -1352,26 +1434,12 @@ lex_line (pfile, list)\n \t  break;\n \n \tcase '\\'':\n-\t  /* Character constants are not recognized when processing Fortran,\n-\t     or if -traditional.  */\n-\t  if (CPP_OPTION (pfile, lang_fortran) || CPP_TRADITIONAL (pfile))\n-\t    goto other;\n-\n-\t  /* Fall through.  */\n \tcase '\\\"':\n-\t  /* Traditionally, escaped strings are not strings.  */\n-\t  if (CPP_TRADITIONAL (pfile) && IMMED_TOKEN ()\n-\t      && PREV_TOKEN_TYPE == CPP_BACKSLASH)\n-\t    goto other;\n-\n \t  cur_token->type = c == '\\'' ? CPP_CHAR : CPP_STRING;\n \t  /* Do we have a wide string?  */\n \t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n-\t      && cur_token[-1].val.node == pfile->spec_nodes->n_L\n-\t      && !CPP_TRADITIONAL (pfile))\n-\t    {\n-\t      (--cur_token)->type = (c == '\\'' ? CPP_WCHAR : CPP_WSTRING);\n-\t    }\n+\t      && cur_token[-1].val.node == pfile->spec_nodes->n_L)\n+\t    BACKUP_TOKEN (c == '\\'' ? CPP_WCHAR : CPP_WSTRING);\n \n \tdo_parse_string:\n \t  /* Here c is one of ' \" or >.  */\n@@ -1423,7 +1491,7 @@ lex_line (pfile, list)\n \t\t\t      || (list->directive->flags & COMMENTS)))\n \t\t\tsave_comment (list, cur_token++, cur,\n \t\t\t\t      buffer->cur - cur, c);\n-\t\t      else if (!CPP_OPTION (pfile, traditional))\n+\t\t      else\n \t\t\tflags = PREV_WHITE;\n \n \t\t      cur = buffer->cur;\n@@ -1461,7 +1529,7 @@ lex_line (pfile, list)\n \t\t\t  || (list->directive->flags & COMMENTS)))\n \t\t    save_comment (list, cur_token++, cur,\n \t\t\t\t  buffer->cur - cur, c);\n-\t\t  else if (!CPP_OPTION (pfile, traditional))\n+\t\t  else\n \t\t    flags = PREV_WHITE;\n \n \t\t  cur = buffer->cur;\n@@ -1524,14 +1592,9 @@ lex_line (pfile, list)\n \t\t But it is still a directive, and therefore disappears\n \t\t from the output. */\n \t      cur_token--;\n-\t      if (cur_token->flags & PREV_WHITE)\n-\t\t{\n-\t\t  if (CPP_WTRADITIONAL (pfile))\n-\t\t    cpp_warning (pfile,\n-\t\t\t\t \"K+R C ignores #\\\\n with the # indented\");\n-\t\t  if (CPP_TRADITIONAL (pfile))\n-\t\t    cur_token++;\n-\t\t}\n+\t      if (cur_token->flags & PREV_WHITE\n+\t\t  && CPP_WTRADITIONAL (pfile))\n+\t\tcpp_warning (pfile, \"K+R C ignores #\\\\n with the # indented\");\n \t    }\n \n \t  /* Skip vertical space until we have at least one token to\n@@ -1543,11 +1606,7 @@ lex_line (pfile, list)\n \n \tcase '-':\n \t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_MINUS)\n-\t    {\n-\t      if (CPP_OPTION (pfile, chill))\n-\t\tgoto do_line_comment;\n-\t      REVISE_TOKEN (CPP_MINUS_MINUS);\n-\t    }\n+\t    REVISE_TOKEN (CPP_MINUS_MINUS);\n \t  else\n \t    PUSH_TOKEN (CPP_MINUS);\n \t  break;\n@@ -1734,7 +1793,6 @@ lex_line (pfile, list)\n \t  if (CPP_OPTION (pfile, dollars_in_ident))\n \t    goto letter;\n \t  /* Fall through */\n-\tother:\n \tdefault:\n \t  cur_token->val.aux = c;\n \t  PUSH_TOKEN (CPP_OTHER);\n@@ -1829,13 +1887,12 @@ output_token (pfile, token, prev)\n     }\n   else if (token->flags & PREV_WHITE)\n     CPP_PUTC (pfile, ' ');\n-  /* Check for and prevent accidental token pasting, in ANSI mode.  */\n-\n-  else if (!CPP_TRADITIONAL (pfile) && prev)\n+  else if (prev)\n     {\n+      /* Check for and prevent accidental token pasting.  */\n       if (can_paste (pfile, prev, token, &dummy) != CPP_EOF)\n \tCPP_PUTC (pfile, ' ');\n-      /* can_paste catches most of the accidental paste cases, but not all.\n+      /* can_paste doesn't catch all the accidental pastes.\n \t Consider a + ++b - if there is not a space between the + and ++, it\n \t will be misparsed as a++ + b.  */\n       else if ((prev->type == CPP_PLUS && token->type == CPP_PLUS_PLUS)\n@@ -1927,67 +1984,6 @@ _cpp_spell_operator (type)\n \n /* Macro expansion algorithm.  TODO.  */\n \n-static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER, 0 UNION_INIT_ZERO};\n-static const cpp_token eof_token = {0, 0, CPP_EOF, 0 UNION_INIT_ZERO};\n-\n-#define IS_ARG_CONTEXT(c) ((c)->flags & CONTEXT_ARG)\n-#define CURRENT_CONTEXT(pfile) ((pfile)->contexts + (pfile)->cur_context)\n-\n-/* Flags for cpp_context.  */\n-#define CONTEXT_PASTEL\t(1 << 0) /* An argument context on LHS of ##.  */\n-#define CONTEXT_PASTER\t(1 << 1) /* An argument context on RHS of ##.  */\n-#define CONTEXT_RAW\t(1 << 2) /* If argument tokens already expanded.  */\n-#define CONTEXT_ARG\t(1 << 3) /* If an argument context.  */\n-\n-#define ASSIGN_FLAGS_AND_POS(d, s) \\\n-  do {(d)->flags = (s)->flags & (PREV_WHITE | BOL | PASTE_LEFT); \\\n-      if ((d)->flags & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n-  } while (0)\n-\n-/* f is flags, just consisting of PREV_WHITE | BOL.  */\n-#define MODIFY_FLAGS_AND_POS(d, s, f) \\\n-  do {(d)->flags &= ~(PREV_WHITE | BOL); (d)->flags |= (f); \\\n-      if ((f) & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n-  } while (0)\n-\n-typedef struct cpp_context cpp_context;\n-struct cpp_context\n-{\n-  union\n-  {\n-    const cpp_toklist *list;\t/* Used for macro contexts only.  */\n-    const cpp_token **arg;\t/* Used for arg contexts only.  */\n-  } u;\n-\n-  /* Pushed token to be returned by next call to get_raw_token.  */\n-  const cpp_token *pushed_token;\n-\n-  struct macro_args *args;\t/* 0 for arguments and object-like macros.  */\n-  unsigned short posn;\t\t/* Current posn, index into u.  */\n-  unsigned short count;\t\t/* No. of tokens in u.  */\n-  unsigned short level;\n-  unsigned char flags;\n-};\n-\n-typedef struct macro_args macro_args;\n-struct macro_args\n-{\n-  unsigned int *ends;\n-  const cpp_token **tokens;\n-  unsigned int capacity;\n-  unsigned int used;\n-  unsigned short level;\n-};\n-\n-static const cpp_token *get_raw_token PARAMS ((cpp_reader *));\n-static const cpp_token *parse_arg PARAMS ((cpp_reader *, int, unsigned int,\n-\t\t\t\t\t   macro_args *, unsigned int *));\n-static int parse_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_args *));\n-static void save_token PARAMS ((macro_args *, const cpp_token *));\n-static int pop_context PARAMS ((cpp_reader *));\n-static int push_macro_context PARAMS ((cpp_reader *, const cpp_token *));\n-static void push_arg_context PARAMS ((cpp_reader *, const cpp_token *));\n-static void free_macro_args PARAMS ((macro_args *));\n \n /* Free the storage allocated for macro arguments.  */\n static void\n@@ -3179,18 +3175,10 @@ special_symbol (pfile, node, token)\n       break;\n \t\n     case T_INCLUDE_LEVEL:\n-      {\n-\tint true_indepth = 0;\n-\n-\t/* Do not count the primary source file in the include level.  */\n-\tip = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-\twhile (ip)\n-\t  {\n-\t    true_indepth++;\n-\t    ip = CPP_PREV_BUFFER (ip);\n-\t  }\n-\tresult = alloc_number_token (pfile, true_indepth);\n-      }\n+      /* pfile->include_depth counts the primary source as level 1,\n+\t but historically __INCLUDE_DEPTH__ has called the primary\n+\t source level 0.  */\n+      result = alloc_number_token (pfile, pfile->include_depth - 1);\n       break;\n \n     case T_SPECLINE:"}, {"sha": "565c5133784ef363403a4a4c3cb0a3f1c4334ba5", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 49, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -28,10 +28,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"symcat.h\"\n \n-#ifdef HAVE_MMAP_FILE\n-# include <sys/mman.h>\n-#endif\n-\n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n \n@@ -168,9 +164,6 @@ _cpp_check_directive (pfile, token, bol)\n \tif (!bol && dtable[i].origin == KANDR && CPP_WTRADITIONAL (pfile))\n \t  cpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n \t\t       dtable[i].name);\n-\t      \n-\tif (!bol && CPP_TRADITIONAL (pfile))\n-\t  return 0;\n \n \t/* Issue -pedantic warnings for extended directives.   */\n \tif (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n@@ -212,10 +205,7 @@ _cpp_check_linemarker (pfile, token, bol)\n   if (!bol && CPP_WTRADITIONAL (pfile))\n     cpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n \t\t dtable[T_LINE].name);\n-\t      \n-  if (!bol && CPP_TRADITIONAL (pfile))\n-    return 0;\n-  \n+\n   return &dtable[T_LINE];\n }  \n \n@@ -977,15 +967,12 @@ parse_ifdef (pfile, name)\n   const cpp_token *token = _cpp_get_token (pfile);\n   type = token->type;\n \n-  if (!CPP_TRADITIONAL (pfile))\n-    {\n-      if (type == CPP_EOF)\n-\tcpp_pedwarn (pfile, \"#%s with no argument\", name);\n-      else if (type != CPP_NAME)\n-\tcpp_pedwarn (pfile, \"#%s with invalid argument\", name);\n-      else if (_cpp_get_token (pfile)->type != CPP_EOF)\n-\tcpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n-    }\n+  if (type == CPP_EOF)\n+    cpp_pedwarn (pfile, \"#%s with no argument\", name);\n+  else if (type != CPP_NAME)\n+    cpp_pedwarn (pfile, \"#%s with invalid argument\", name);\n+  else if (_cpp_get_token (pfile)->type != CPP_EOF)\n+    cpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n \n   if (type == CPP_NAME)\n     node = token->val.node;\n@@ -995,7 +982,7 @@ parse_ifdef (pfile, name)\n \t\t node->name);\n       node = 0;\n     }\n-    \n+\n   return node;\n }\n \n@@ -1527,9 +1514,10 @@ cpp_push_buffer (pfile, buffer, length)\n   new = xobnew (pfile->buffer_ob, cpp_buffer);\n   memset (new, 0, sizeof (cpp_buffer));\n \n-  new->buf = new->cur = buffer;\n+  new->line_base = new->buf = new->cur = buffer;\n   new->rlimit = buffer + length;\n   new->prev = buf;\n+  new->lineno = 1;\n \n   CPP_BUFFER (pfile) = new;\n   return new;\n@@ -1542,34 +1530,8 @@ cpp_pop_buffer (pfile)\n   cpp_buffer *buf = CPP_BUFFER (pfile);\n \n   unwind_if_stack (pfile, buf);\n-#ifdef HAVE_MMAP_FILE\n-  if (buf->mapped)\n-    munmap ((caddr_t) buf->buf, buf->rlimit - buf->buf);\n-  else\n-#endif\n-    if (buf->inc)\n-      free ((PTR) buf->buf);\n-\n   if (buf->inc)\n-    {\n-      if (pfile->system_include_depth)\n-\tpfile->system_include_depth--;\n-      if (pfile->include_depth)\n-\tpfile->include_depth--;\n-      if (pfile->potential_control_macro)\n-\t{\n-\t  if (buf->inc->cmacro != NEVER_REREAD)\n-\t    buf->inc->cmacro = pfile->potential_control_macro;\n-\t  pfile->potential_control_macro = 0;\n-\t}\n-      pfile->input_stack_listing_current = 0;\n-      /* If the file will not be included again, then close it.  */\n-      if (DO_NOT_REREAD (buf->inc))\n-\t{\n-\t  close (buf->inc->fd);\n-\t  buf->inc->fd = -1;\n-\t}\n-    }\n+    _cpp_pop_file_buffer (pfile, buf);\n \n   CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n   obstack_free (pfile->buffer_ob, buf);"}, {"sha": "88c06485199e131bc07788199f94219c51183eb5", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9a0e96c1707a7f48f7d152901740444098c2628/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f9a0e96c1707a7f48f7d152901740444098c2628", "patch": "@@ -314,15 +314,6 @@ struct cpp_options\n      likely to be in comments).  */\n   unsigned char lang_asm;\n \n-  /* Nonzero means this is Fortran, and we don't know where the\n-     comments are, so permit unbalanced ' strings.  Unlike lang_asm,\n-     this does not ignore unrecognized directives.  */\n-  unsigned char lang_fortran;\n-\n-  /* Nonzero means handle CHILL comment syntax and output CHILL string\n-     delimiters for __DATE__ etc. */\n-  unsigned char chill;\n-\n   /* Nonzero means don't copy comments into the output file.  */\n   unsigned char discard_comments;\n \n@@ -366,9 +357,8 @@ struct cpp_options\n   /* Nonzero means warn if #import is used.  */\n   unsigned char warn_import;\n \n-  /* Nonzero means warn if a macro argument is (or would be)\n-     stringified with -traditional, and warn about directives\n-     with the # indented from the beginning of the line.  */\n+  /* Nonzero means warn about various incompatibilities with\n+     traditional C.  */\n   unsigned char warn_traditional;\n \n   /* Nonzero means warn if ## is applied to two tokens that cannot be\n@@ -396,9 +386,6 @@ struct cpp_options\n   /* Zero means dollar signs are punctuation. */\n   unsigned char dollars_in_ident;\n \n-  /* Nonzero means try to imitate old fashioned non-ISO preprocessor.  */\n-  unsigned char traditional;\n-\n   /* Nonzero means warn if undefined identifiers are evaluated in an #if.  */\n   unsigned char warn_undef;\n \n@@ -701,6 +688,7 @@ extern cpp_buffer *cpp_push_buffer\tPARAMS ((cpp_reader *,\n extern cpp_buffer *cpp_pop_buffer\tPARAMS ((cpp_reader *));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *, cpp_printer *));\n extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n+extern void cpp_scan_line\t\tPARAMS ((cpp_reader *));\n extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const char *));\n "}]}