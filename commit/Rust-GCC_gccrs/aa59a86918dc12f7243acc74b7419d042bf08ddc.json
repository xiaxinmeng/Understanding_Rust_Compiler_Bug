{"sha": "aa59a86918dc12f7243acc74b7419d042bf08ddc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1OWE4NjkxOGRjMTJmNzI0M2FjYzc0Yjc0MTlkMDQyYmYwOGRkYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-10-02T01:07:59Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-10-02T01:07:59Z"}, "message": "Undo some of the index changes, and write our own index/rindex.\n\nFrom-SVN: r2304", "tree": {"sha": "12ea0069c9f60a8b0ade80f0f85c25308f3782c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12ea0069c9f60a8b0ade80f0f85c25308f3782c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa59a86918dc12f7243acc74b7419d042bf08ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa59a86918dc12f7243acc74b7419d042bf08ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa59a86918dc12f7243acc74b7419d042bf08ddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa59a86918dc12f7243acc74b7419d042bf08ddc/comments", "author": null, "committer": null, "parents": [{"sha": "d4099651d502ce0921fe56dc255e97632da8320d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4099651d502ce0921fe56dc255e97632da8320d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4099651d502ce0921fe56dc255e97632da8320d"}], "stats": {"total": 84, "additions": 61, "deletions": 23}, "files": [{"sha": "8fa7e9b8a9365511e143fa645792cf40c997e1a0", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa59a86918dc12f7243acc74b7419d042bf08ddc/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa59a86918dc12f7243acc74b7419d042bf08ddc/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=aa59a86918dc12f7243acc74b7419d042bf08ddc", "patch": "@@ -659,13 +659,6 @@ extern void\txfree\t\t__proto((PTR_T));\n extern void\tfatal();\t/* can't use prototypes here */\n extern void\terror();\n \n-#if !defined(__OSF1__) && !defined(__OSF__) && !defined(__osf__)\n-extern char *index ();\n-extern char *rindex ();\n-#else\n-#undef rindex\n-#undef index\n-#endif\n \f\n #ifndef MIPS_DEBUGGING_INFO\n \n@@ -685,6 +678,11 @@ main ()\n \n #else\t\t\t\t/* MIPS_DEBUGGING defined */\n \f\n+/* The local and global symbols have a field index, so undo any defines\n+   of index -> strchr and rindex -> strrchr.  */\n+\n+#undef rindex\n+#undef index\n \n #include <sys/types.h>\n #include <a.out.h>\n@@ -1728,6 +1726,9 @@ STATIC void\t  free_scope\t\t__proto((scope_t *));\n STATIC void\t  free_tag\t\t__proto((tag_t *));\n STATIC void\t  free_thead\t\t__proto((thead_t *));\n \n+STATIC char\t *local_index\t\t__proto((const char *, int));\n+STATIC char\t *local_rindex\t\t__proto((const char *, int));\n+\n extern char  *sbrk\t\t\t__proto((int));\n extern PTR_T  malloc\t\t\t__proto((Size_t));\n extern PTR_T  calloc\t\t\t__proto((Size_t, Size_t));\n@@ -1927,7 +1928,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n   psym->value = value;\n   psym->st = (unsigned) type;\n   psym->sc = (unsigned) storage;\n-  psym->indx = indx;\n+  psym->index = indx;\n   psym->iss = (str_start == (const char *)0)\n \t\t? 0\n \t\t: add_string (&cur_file_ptr->strings,\n@@ -2015,13 +2016,13 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \t    }\n \n \t  cur_file_ptr->cur_scope = pscope->prev;\n-\t  psym->indx = pscope->lnumber;\t\t/* blk end gets begin sym # */\n+\t  psym->index = pscope->lnumber;\t/* blk end gets begin sym # */\n \n \t  if (storage != sc_Info)\n \t    psym->iss = pscope->lsym->iss;\t/* blk end gets same name */\n \n \t  if (begin_type == st_File || begin_type == st_Block)\n-\t    pscope->lsym->indx = ret+1;\t\t/* block begin gets next sym # */\n+\t    pscope->lsym->index = ret+1;\t/* block begin gets next sym # */\n \n \t  /* Functions push two or more aux words as follows:\n \t     1st word: index+1 of the end symbol\n@@ -2030,14 +2031,14 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \t  else\n \t    {\n \t      symint_t type;\n-\t      pscope->lsym->indx = add_aux_sym_symint (ret+1);\n+\t      pscope->lsym->index = add_aux_sym_symint (ret+1);\n \t      type = add_aux_sym_tir (&last_func_type_info,\n \t\t\t\t      hash_no,\n \t\t\t\t      &cur_file_ptr->thash_head[0]);\n \t      if (last_func_eptr)\n \t\t{\n \t\t  last_func_eptr->ifd = cur_file_ptr->file_index;\n-\t\t  last_func_eptr->asym.indx = type;\n+\t\t  last_func_eptr->asym.index = type;\n \t\t}\n \t    }\n \n@@ -2112,7 +2113,7 @@ add_ext_symbol (str_start, str_end_p1, type, storage, value, indx, ifd)\n   psym->asym.value = value;\n   psym->asym.st    = (unsigned) type;\n   psym->asym.sc    = (unsigned) storage;\n-  psym->asym.indx  = indx;\n+  psym->asym.index = indx;\n   psym->asym.iss   = (str_start == (const char *)0)\n \t\t\t? 0\n \t\t\t: add_string (&ext_strings,\n@@ -2431,7 +2432,7 @@ add_unknown_tag (ptag)\n       f_next = f_next->next;\n \n       f_cur->ifd_ptr->isym = file_index;\n-      f_cur->index_ptr->rndx.indx = sym_index;\n+      f_cur->index_ptr->rndx.index = sym_index;\n \n       free_forward (f_cur);\n     }\n@@ -3339,10 +3340,10 @@ parse_def (name_start)\n      external symbol.  */\n \n   if (eptr != (EXTR *)0\n-      && (eptr->asym.indx == indexNil || cur_proc_ptr == (PDR *)0))\n+      && (eptr->asym.index == indexNil || cur_proc_ptr == (PDR *)0))\n     {\n       eptr->ifd = cur_file_ptr->file_index;\n-      eptr->asym.indx = indx;\n+      eptr->asym.index = indx;\n     }\n \n \n@@ -3429,7 +3430,7 @@ parse_def (name_start)\n \t      f_next = f_next->next;\n \n \t      f_cur->ifd_ptr->isym = file_index;\n-\t      f_cur->index_ptr->rndx.indx = isym;\n+\t      f_cur->index_ptr->rndx.index = isym;\n \n \t      free_forward (f_cur);\n \t    }\n@@ -3563,8 +3564,8 @@ parse_file (start)\n \n   (void) strtol (start, &p, 0);\n   if (start == p\n-      || (start_name = index (p, '\"')) == (char *)0\n-      || (end_name_p1 = rindex (++start_name, '\"')) == (char *)0)\n+      || (start_name = local_index (p, '\"')) == (char *)0\n+      || (end_name_p1 = local_rindex (++start_name, '\"')) == (char *)0)\n     {\n       error (\"Illegal .file directive\");\n       return;\n@@ -3817,7 +3818,7 @@ STATIC void\n parse_stabs (start)\n      const char *start;\t\t\t/* start of directive */\n {\n-  const char *end = index (start+1, '\"');\n+  const char *end = local_index (start+1, '\"');\n \n   if (*start != '\"' || end == (const char *)0 || end[1] != ',')\n     {\n@@ -4515,7 +4516,7 @@ copy_object __proto((void))\n       && orig_files->caux == 0)\n     {\n       char *filename = orig_local_strs + (orig_files->issBase + orig_files->rss);\n-      char *suffix = rindex (filename, '.');\n+      char *suffix = local_rindex (filename, '.');\n \n       if (suffix != (char *)0 && strcmp (suffix, \".s\") == 0)\n \tdelete_ifd = 1;\n@@ -4564,7 +4565,7 @@ copy_object __proto((void))\n \t\t\t     (st_t) eptr->asym.st,\n \t\t\t     (sc_t) eptr->asym.sc,\n \t\t\t     eptr->asym.value,\n-\t\t\t     (symint_t)((eptr->asym.indx == indexNil) ? indexNil : 0),\n+\t\t\t     (symint_t)((eptr->asym.index == indexNil) ? indexNil : 0),\n \t\t\t     (ifd < orig_sym_hdr.ifdMax) ? remap_file_number[ ifd ] : ifd);\n     }\n \n@@ -4749,7 +4750,7 @@ main (argc, argv)\n      char *argv[];\n {\n   int iflag = 0;\n-  char *p = rindex (argv[0], '/');\n+  char *p = local_rindex (argv[0], '/');\n   char *num_end;\n   int option;\n   int i;\n@@ -5621,3 +5622,40 @@ xfree (ptr)\n \n   free (ptr);\n }\n+\n+\f\n+/* Define our own index/rindex, since the local and global symbol\n+   structures as defined by MIPS has an 'index' field.  */\n+\n+STATIC char *\n+local_index (str, sentinel)\n+     const char *str;\n+     int sentinel;\n+{\n+  int ch;\n+\n+  for ( ; (ch = *str) != sentinel; str++)\n+    {\n+      if (ch == '\\0')\n+\treturn (char *)0;\n+    }\n+\n+  return (char *)str;\n+}\n+\n+STATIC char *\n+local_rindex (str, sentinel)\n+     const char *str;\n+     int sentinel;\n+{\n+  int ch;\n+  const char *ret = (const char *)0;\n+\n+  for ( ; (ch = *str) != '\\0'; str++)\n+    {\n+      if (ch == sentinel)\n+\tret = str;\n+    }\n+\n+  return (char *)ret;\n+}"}]}