{"sha": "8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "node_id": "C_kwDOANBUbNoAKDhkOWUyNzc2YTZkMmJmZTY2NjJmNzkxODJlODVhYjc5ZjNjYzk1MjI", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-15T15:47:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-16T20:59:19Z"}, "message": "libstdc++: Add monadic operations to std::expected for C++23 (P2505R5)\n\nThis was approved for C++23 last month in Kona.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/expected (expected): Add monadic operations.\n\t(expected<void, E>): Likewise.\n\t* include/std/version (__cpp_lib_expected): Bump value.\n\t* testsuite/20_util/expected/synopsis.cc: Adjust expected macro\n\tvalue.\n\t* testsuite/20_util/expected/version.cc: Likewise.\n\t* testsuite/20_util/expected/illformed_neg.cc: Prune additional\n\terrors from ill-formed monadic operations.\n\t* testsuite/20_util/expected/observers.cc: Check error_or.\n\t* testsuite/20_util/expected/monadic.cc: New test.", "tree": {"sha": "7b22eb46864c3f12e0b90766c27b22ce8155d424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b22eb46864c3f12e0b90766c27b22ce8155d424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59822c39207c9e8be576e9d6c3370bd85ddaf886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59822c39207c9e8be576e9d6c3370bd85ddaf886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59822c39207c9e8be576e9d6c3370bd85ddaf886"}], "stats": {"total": 886, "additions": 882, "deletions": 4}, "files": [{"sha": "555779581f2cd1fb7115a5a10cc19a22f3003337", "filename": "libstdc++-v3/include/std/expected", "status": "modified", "additions": 578, "deletions": 1, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -35,6 +35,7 @@\n \n #include <initializer_list>\n #include <bits/exception.h>\t// exception\n+#include <bits/invoke.h>\t// __invoke\n #include <bits/stl_construct.h>\t// construct_at\n #include <bits/utility.h>\t// in_place_t\n \n@@ -49,7 +50,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-#define __cpp_lib_expected 202202L\n+#define __cpp_lib_expected 202211L\n \n   /// Discriminated union that holds an expected value or an error value.\n   /**\n@@ -151,11 +152,20 @@ namespace __expected\n   template<typename _Tp>\n     constexpr bool __is_unexpected<unexpected<_Tp>> = true;\n \n+  template<typename _Fn, typename _Tp>\n+    using __result = remove_cvref_t<invoke_result_t<_Fn&&, _Tp&&>>;\n+  template<typename _Fn>\n+    using __result0 = remove_cvref_t<invoke_result_t<_Fn&&>>;\n+\n   template<typename _Er>\n     concept __can_be_unexpected\n       = is_object_v<_Er> && (!is_array_v<_Er>)\n \t  && (!__expected::__is_unexpected<_Er>)\n \t  && (!is_const_v<_Er>) && (!is_volatile_v<_Er>);\n+\n+  // Tag types for in-place construction from an invocation result.\n+  struct __in_place_inv { };\n+  struct __unexpect_inv { };\n }\n /// @endcond\n \n@@ -334,6 +344,14 @@ namespace __expected\n \t\t   __not_<is_convertible<_Err, _Er>>\n \t\t  >;\n \n+      template<typename _Up>\n+\tstatic constexpr bool __same_val\n+\t  = is_same_v<typename _Up::value_type, _Tp>;\n+\n+      template<typename _Up>\n+\tstatic constexpr bool __same_err\n+\t  = is_same_v<typename _Up::error_type, _Er>;\n+\n     public:\n       using value_type = _Tp;\n       using error_type = _Er;\n@@ -791,6 +809,274 @@ namespace __expected\n \t  return static_cast<_Tp>(std::forward<_Up>(__v));\n \t}\n \n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) const&\n+\t{\n+\t  static_assert( is_copy_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return _M_unex;\n+\t}\n+\n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) &&\n+\t{\n+\t  static_assert( is_move_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return std::move(_M_unex);\n+\t}\n+\n+      // monadic operations\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), value());\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), value());\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp&&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(value()));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp&&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(value()));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, value());\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, value());\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, std::move(value()));\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, std::move(value()));\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp&>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_val);\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp&>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_val);\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_val));\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_val));\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, value());\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, value());\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, std::move(value()));\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, std::move(value()));\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n       // equality operators\n \n       template<typename _Up, typename _Er2>\n@@ -888,6 +1174,21 @@ namespace __expected\n \t  }\n       }\n \n+      using __in_place_inv = __expected::__in_place_inv;\n+      using __unexpect_inv = __expected::__unexpect_inv;\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__in_place_inv, _Fn&& __fn)\n+\t: _M_val(std::forward<_Fn>(__fn)()), _M_has_value(true)\n+\t{ }\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__unexpect_inv, _Fn&& __fn)\n+\t: _M_unex(std::forward<_Fn>(__fn)()), _M_has_value(false)\n+\t{ }\n+\n       union {\n \t_Tp _M_val;\n \t_Er _M_unex;\n@@ -910,6 +1211,14 @@ namespace __expected\n \t\t   is_constructible<_Unex, const expected<_Up, _Err>>\n \t\t  >;\n \n+      template<typename _Up>\n+\tstatic constexpr bool __same_val\n+\t  = is_same_v<typename _Up::value_type, _Tp>;\n+\n+      template<typename _Up>\n+\tstatic constexpr bool __same_err\n+\t  = is_same_v<typename _Up::error_type, _Er>;\n+\n     public:\n       using value_type = _Tp;\n       using error_type = _Er;\n@@ -1180,6 +1489,260 @@ namespace __expected\n \treturn std::move(_M_unex);\n       }\n \n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) const&\n+\t{\n+\t  static_assert( is_copy_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return _M_unex;\n+\t}\n+\n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) &&\n+\t{\n+\t  static_assert( is_move_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return std::move(_M_unex);\n+\t}\n+\n+      // monadic operations\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+     template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+       template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n       // equality operators\n \n       template<typename _Up, typename _Er2>\n@@ -1223,6 +1786,20 @@ namespace __expected\n \t    _M_unex = std::forward<_Vp>(__v);\n \t}\n \n+      using __in_place_inv = __expected::__in_place_inv;\n+      using __unexpect_inv = __expected::__unexpect_inv;\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__in_place_inv, _Fn&& __fn)\n+\t: _M_void(), _M_has_value(true)\n+\t{ std::forward<_Fn>(__fn)(); }\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__unexpect_inv, _Fn&& __fn)\n+\t: _M_unex(std::forward<_Fn>(__fn)()), _M_has_value(false)\n+\t{ }\n \n       union {\n \tstruct { } _M_void;"}, {"sha": "576eebc7dc8271820b3f9bd653f2ab1875cbc7b0", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -306,7 +306,7 @@\n #define __cpp_lib_constexpr_charconv 202207L\n #define __cpp_lib_constexpr_typeinfo 202106L\n #if __cpp_concepts >= 202002L\n-# define __cpp_lib_expected 202202L\n+# define __cpp_lib_expected 202211L\n #endif\n #define __cpp_lib_invoke_r 202106L\n #define __cpp_lib_is_scoped_enum 202011L"}, {"sha": "f1b0771aeb993a2f2704cd2e7d4ef7b7f085bc73", "filename": "libstdc++-v3/testsuite/20_util/expected/illformed_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -65,3 +65,4 @@ test_expected_error()\n }\n \n // { dg-prune-output \"static assertion failed\" }\n+// { dg-prune-output \"function returning an array\" }"}, {"sha": "d82774b0e1fd0dde3f03f71a8bc59305fa82f5e4", "filename": "libstdc++-v3/testsuite/20_util/expected/monadic.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fmonadic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fmonadic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fmonadic.cc?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -0,0 +1,280 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_and_then()\n+{\n+  std::expected<int, int> e1(1);\n+  VERIFY( e1.and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(100);\n+  }).value() == 100 );\n+  VERIFY( std::move(e1).and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(101);\n+  }).value() == 101 );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(102);\n+  }).value() == 102 );\n+  VERIFY( std::move(ce1).and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(103);\n+  }).value() == 103 );\n+\n+  auto fail = [] (auto&&) -> std::expected<void, int> { throw 1; };\n+  std::expected<int, int> e2(std::unexpect, 2);\n+  VERIFY( e2.and_then(fail).error() == 2 );\n+  VERIFY( std::move(e2).and_then(fail).error() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.and_then(fail).error() == 2 );\n+  VERIFY( std::move(ce2).and_then(fail).error() == 2 );\n+\n+  int i = 100;\n+  auto vpass = [&] -> std::expected<int, int> { return i++; };\n+  std::expected<void, int> v1;\n+  VERIFY( v1.and_then(vpass).value() == 100 );\n+  VERIFY( std::move(v1).and_then(vpass).value() == 101 );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.and_then(vpass).value() == 102 );\n+  VERIFY( std::move(cv1).and_then(vpass).value() == 103 );\n+\n+  auto vfail = [] -> std::expected<int, int> { throw 1; };\n+  std::expected<void, int> v2(std::unexpect, 2);\n+  VERIFY( v2.and_then(vfail).error() == 2 );\n+  VERIFY( std::move(v2).and_then(vfail).error() == 2 );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.and_then(vfail).error() == 2 );\n+  VERIFY( std::move(cv2).and_then(vfail).error() == 2 );\n+\n+  static_assert(std::is_same_v<decltype(v1.and_then(vpass)),\n+\t\t\t       decltype(vpass())>);\n+  static_assert(std::is_same_v<decltype(cv1.and_then(vpass)),\n+\t\t\t       decltype(vpass())>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_or_else()\n+{\n+  std::expected<int, int> e1(std::unexpect, 1);\n+  VERIFY( e1.or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(100);\n+  }).value() == 100 );\n+  VERIFY( std::move(e1).or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(101);\n+  }).value() == 101 );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(102);\n+  }).value() == 102 );\n+  VERIFY( std::move(ce1).or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(103);\n+  }).value() == 103 );\n+\n+  auto f = [] (auto) -> std::expected<int, long> { throw 1; };\n+  std::expected<int, int> e2(2);\n+  VERIFY( e2.or_else(f).value() == 2 );\n+  VERIFY( std::move(e2).or_else(f).value() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.or_else(f).value() == 2 );\n+  VERIFY( std::move(ce2).or_else(f).value() == 2 );\n+\n+  auto vf = [] (auto) -> std::expected<void, long> { return {}; };\n+  std::expected<void, int> v1(std::unexpect, 1);\n+  VERIFY( v1.or_else(vf).has_value() );\n+  VERIFY( std::move(v1).or_else(vf).has_value() );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.or_else(vf).has_value() );\n+  VERIFY( std::move(cv1).or_else(vf).has_value() );\n+\n+  auto vfail = [] (auto) -> std::expected<void, long> { throw 1; };\n+  std::expected<void, int> v2;\n+  VERIFY( v2.or_else(vfail).has_value() );\n+  VERIFY( std::move(v2).or_else(vfail).has_value() );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.or_else(vfail).has_value() );\n+  VERIFY( std::move(cv2).or_else(vfail).has_value() );\n+\n+  static_assert(std::is_same_v<decltype(v1.or_else(vf)), decltype(vf(1))>);\n+  static_assert(std::is_same_v<decltype(cv1.or_else(vf)), decltype(vf(1))>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_transform()\n+{\n+  std::expected<int, int> e1(1);\n+  VERIFY( e1.transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"100\");\n+  }).value() == \"100\" );\n+  VERIFY( std::move(e1).transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"101\");\n+  }).value() == \"101\" );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"102\");\n+  }).value() == \"102\" );\n+  VERIFY( std::move(ce1).transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"103\");\n+  }).value() == \"103\" );\n+\n+  auto fail = [] (auto&&) -> std::string_view { throw 1; };\n+  std::expected<int, int> e2(std::unexpect, 2);\n+  VERIFY( e2.transform(fail).error() == 2 );\n+  VERIFY( std::move(e2).transform(fail).error() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.transform(fail).error() == 2 );\n+  VERIFY( std::move(ce2).transform(fail).error() == 2 );\n+\n+  auto vpass = [&] -> std::string_view { return \"ok\"; };\n+  std::expected<void, int> v1;\n+  VERIFY( v1.transform(vpass).value() == \"ok\" );\n+  VERIFY( std::move(v1).transform(vpass).value() == \"ok\" );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.transform(vpass).value() == \"ok\" );\n+  VERIFY( std::move(cv1).transform(vpass).value() == \"ok\" );\n+\n+  auto vfail = [] -> std::string_view { throw 1; };\n+  std::expected<void, int> v2(std::unexpect, 2);\n+  VERIFY( v2.transform(vfail).error() == 2 );\n+  VERIFY( std::move(v2).transform(vfail).error() == 2 );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.transform(vfail).error() == 2 );\n+  VERIFY( std::move(cv2).transform(vfail).error() == 2 );\n+\n+  static_assert(std::is_same_v<decltype(v1.transform(vpass)),\n+\t\t\t       std::expected<decltype(vpass()), int>>);\n+  static_assert(std::is_same_v<decltype(cv1.transform(vpass)),\n+\t\t\t       std::expected<decltype(vpass()), int>>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_transform_error()\n+{\n+  std::expected<int, int> e1(std::unexpect, 1);\n+  VERIFY( e1.transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"100\");\n+  }).error() == \"100\" );\n+  VERIFY( std::move(e1).transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"101\");\n+  }).error() == \"101\" );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"102\");\n+  }).error() == \"102\" );\n+  VERIFY( std::move(ce1).transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"103\");\n+  }).error() == \"103\" );\n+\n+  auto fail = [] (auto&&) -> std::string_view { throw 1; };\n+  std::expected<int, int> e2(2);\n+  VERIFY( e2.transform_error(fail).value() == 2 );\n+  VERIFY( std::move(e2).transform_error(fail).value() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.transform_error(fail).value() == 2 );\n+  VERIFY( std::move(ce2).transform_error(fail).value() == 2 );\n+\n+  auto vpass = [&] (auto) -> std::string_view { return \"ok\"; };\n+  std::expected<void, int> v1(std::unexpect, 1);\n+  VERIFY( v1.transform_error(vpass).error() == \"ok\" );\n+  VERIFY( std::move(v1).transform_error(vpass).error() == \"ok\" );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.transform_error(vpass).error() == \"ok\" );\n+  VERIFY( std::move(cv1).transform_error(vpass).error() == \"ok\" );\n+\n+  auto vfail = [] (auto) -> std::string_view { throw 1; };\n+  std::expected<void, int> v2;\n+  VERIFY( v2.transform_error(vfail).has_value() );\n+  VERIFY( std::move(v2).transform_error(vfail).has_value() );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.transform_error(vfail).has_value() );\n+  VERIFY( std::move(cv2).transform_error(vfail).has_value() );\n+\n+  static_assert(std::is_same_v<decltype(v1.transform_error(vpass)),\n+\t\t\t       std::expected<void, decltype(vpass(1))>>);\n+  static_assert(std::is_same_v<decltype(cv1.transform_error(vpass)),\n+\t\t\t       std::expected<void, decltype(vpass(1))>>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_temporary_materialization()\n+{\n+  struct NonCopyable {\n+    constexpr NonCopyable(int i) : i(i) { }\n+    NonCopyable(const NonCopyable&) = delete;\n+    int i;\n+  };\n+\n+  auto xform = [](int i) { return NonCopyable(i); };\n+\n+  std::expected<int, int> e1(1);\n+  std::expected<NonCopyable, int> n1 = e1.transform(xform);\n+  VERIFY( n1.value().i == 1 );\n+  std::expected<int, int> e2(std::unexpected<int>(2));\n+  std::expected<int, NonCopyable> n2 = e2.transform_error(xform);\n+  VERIFY( n2.error().i == 2 );\n+\n+  auto vxform = [] { return NonCopyable(999); };\n+  std::expected<void, int> v1;\n+  std::expected<NonCopyable, int> nv1 = v1.transform(vxform);\n+  VERIFY( nv1.value().i == 999 );\n+  std::expected<void, int> v2(std::unexpected<int>(22));\n+  std::expected<void, NonCopyable> nv2 = v2.transform_error(xform);\n+  VERIFY( nv2.error().i == 22 );\n+\n+  return true;\n+}\n+\n+int main()\n+{\n+  static_assert( test_and_then() );\n+  test_and_then();\n+  static_assert( test_or_else() );\n+  test_or_else();\n+  static_assert( test_transform() );\n+  test_transform();\n+  static_assert( test_transform_error() );\n+  test_transform_error();\n+  static_assert( test_temporary_materialization() );\n+  test_temporary_materialization();\n+}"}, {"sha": "9bcd9edb80915648d80de1e910646080be79a662", "filename": "libstdc++-v3/testsuite/20_util/expected/observers.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -191,6 +191,24 @@ test_value_or()\n   return true;\n }\n \n+constexpr bool\n+test_error_or()\n+{\n+  std::expected<int, int> e1(1), e2(std::unexpect, 3);\n+  VERIFY( e1.error_or(2) == 2 );\n+  VERIFY( std::move(e1).error_or(2) == 2 );\n+  VERIFY( e2.error_or(2) == 3 );\n+  VERIFY( std::move(e2).error_or(2) == 3 );\n+\n+  std::expected<void, int> e3, e4(std::unexpect, 3);\n+  VERIFY( e3.error_or(2) == 2 );\n+  VERIFY( std::move(e3).error_or(2) == 2 );\n+  VERIFY( e4.error_or(2) == 3 );\n+  VERIFY( std::move(e4).error_or(2) == 3 );\n+\n+  return true;\n+}\n+\n int main()\n {\n   static_assert( test_arrow() );\n@@ -206,4 +224,6 @@ int main()\n   test_error();\n   static_assert( test_value_or() );\n   test_value_or();\n+  static_assert( test_error_or() );\n+  test_error_or();\n }"}, {"sha": "b0439614a27077405ce45a8511df07e0935af06e", "filename": "libstdc++-v3/testsuite/20_util/expected/synopsis.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -6,7 +6,7 @@\n \n #ifndef __cpp_lib_expected\n # error \"Feature-test macro for expected missing in <expected>\"\n-#elif __cpp_lib_expected != 202202L\n+#elif __cpp_lib_expected != 202211L\n # error \"Feature-test macro for expected has wrong value in <expected>\"\n #endif\n "}, {"sha": "98fccf73dc100e58df96407b4322f9b86c9c1f27", "filename": "libstdc++-v3/testsuite/20_util/expected/version.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9e2776a6d2bfe6662f79182e85ab79f3cc9522/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc?ref=8d9e2776a6d2bfe6662f79182e85ab79f3cc9522", "patch": "@@ -5,6 +5,6 @@\n \n #ifndef __cpp_lib_expected\n # error \"Feature-test macro for expected missing in <version>\"\n-#elif __cpp_lib_expected != 202202L\n+#elif __cpp_lib_expected != 202211L\n # error \"Feature-test macro for expected has wrong value in <version>\"\n #endif"}]}