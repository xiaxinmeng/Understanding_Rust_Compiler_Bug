{"sha": "fcae0292de06aeb54c44d26cfb80d798df60e339", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNhZTAyOTJkZTA2YWViNTRjNDRkMjZjZmI4MGQ3OThkZjYwZTMzOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-06-18T09:18:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-06-18T09:18:17Z"}, "message": "Restore correct iv step for fully-masked loops\n\nr272233 introduced a large number of execution failures on SVE.\nThe patch hard-coded an IV step of VF, but for SLP groups it needs\nto be VF * group size.\n\nAlso, iv_precision had type widest_int but only needs to be unsigned int.\n\n2019-06-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop-manip.c (vect_set_loop_masks_directly): Remove\n\tvf parameter.  Restore the previous iv step of nscalars_step,\n\tbut give it iv_type rather than compare_type.  Tweak code order\n\tto match the comments.\n\t(vect_set_loop_condition_masked): Update accordingly.\n\t* tree-vect-loop.c (vect_verify_full_masking): Use \"unsigned int\"\n\tfor iv_precision.  Tweak comment formatting.\n\nFrom-SVN: r272411", "tree": {"sha": "f98a62e46bca2b433c2c6b950f710a6af3f1183c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f98a62e46bca2b433c2c6b950f710a6af3f1183c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcae0292de06aeb54c44d26cfb80d798df60e339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcae0292de06aeb54c44d26cfb80d798df60e339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcae0292de06aeb54c44d26cfb80d798df60e339", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcae0292de06aeb54c44d26cfb80d798df60e339/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9e47ccf267fb088b004461c29e2daf9167bd102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e47ccf267fb088b004461c29e2daf9167bd102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9e47ccf267fb088b004461c29e2daf9167bd102"}], "stats": {"total": 69, "additions": 37, "deletions": 32}, "files": [{"sha": "15bc6d734ad90749e8896677c939d4eb5833eff0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae0292de06aeb54c44d26cfb80d798df60e339/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae0292de06aeb54c44d26cfb80d798df60e339/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcae0292de06aeb54c44d26cfb80d798df60e339", "patch": "@@ -1,3 +1,13 @@\n+2019-06-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop-manip.c (vect_set_loop_masks_directly): Remove\n+\tvf parameter.  Restore the previous iv step of nscalars_step,\n+\tbut give it iv_type rather than compare_type.  Tweak code order\n+\tto match the comments.\n+\t(vect_set_loop_condition_masked): Update accordingly.\n+\t* tree-vect-loop.c (vect_verify_full_masking): Use \"unsigned int\"\n+\tfor iv_precision.  Tweak comment formatting.\n+\n 2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>\n \n         * config/darwin.c: Strip trailing whitespace."}, {"sha": "9cf1d48bda0ec65ac965dd7aaab3bd18780b7d81", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae0292de06aeb54c44d26cfb80d798df60e339/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae0292de06aeb54c44d26cfb80d798df60e339/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=fcae0292de06aeb54c44d26cfb80d798df60e339", "patch": "@@ -382,8 +382,7 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n    Use LOOP_COND_GSI to insert code before the exit gcond.\n \n    RGM belongs to loop LOOP.  The loop originally iterated NITERS\n-   times and has been vectorized according to LOOP_VINFO.  Each iteration\n-   of the vectorized loop handles VF iterations of the scalar loop.\n+   times and has been vectorized according to LOOP_VINFO.\n \n    If NITERS_SKIP is nonnull, the first iteration of the vectorized loop\n    starts with NITERS_SKIP dummy iterations of the scalar loop before\n@@ -410,35 +409,36 @@ static tree\n vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n \t\t\t      gimple_seq *preheader_seq,\n \t\t\t      gimple_stmt_iterator loop_cond_gsi,\n-\t\t\t      rgroup_masks *rgm, tree vf,\n-\t\t\t      tree niters, tree niters_skip,\n+\t\t\t      rgroup_masks *rgm, tree niters, tree niters_skip,\n \t\t\t      bool might_wrap_p)\n {\n   tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n   tree iv_type = LOOP_VINFO_MASK_IV_TYPE (loop_vinfo);\n   tree mask_type = rgm->mask_type;\n   unsigned int nscalars_per_iter = rgm->max_nscalars_per_iter;\n   poly_uint64 nscalars_per_mask = TYPE_VECTOR_SUBPARTS (mask_type);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   /* Calculate the maximum number of scalar values that the rgroup\n      handles in total, the number that it handles for each iteration\n      of the vector loop, and the number that it should skip during the\n      first iteration of the vector loop.  */\n   tree nscalars_total = niters;\n-  tree nscalars_step = vf;\n+  tree nscalars_step = build_int_cst (iv_type, vf);\n   tree nscalars_skip = niters_skip;\n   if (nscalars_per_iter != 1)\n     {\n       /* We checked before choosing to use a fully-masked loop that these\n \t multiplications don't overflow.  */\n-      tree factor = build_int_cst (compare_type, nscalars_per_iter);\n+      tree compare_factor = build_int_cst (compare_type, nscalars_per_iter);\n+      tree iv_factor = build_int_cst (iv_type, nscalars_per_iter);\n       nscalars_total = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n-\t\t\t\t     nscalars_total, factor);\n-      nscalars_step = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n-\t\t\t\t    nscalars_step, factor);\n+\t\t\t\t     nscalars_total, compare_factor);\n+      nscalars_step = gimple_build (preheader_seq, MULT_EXPR, iv_type,\n+\t\t\t\t    nscalars_step, iv_factor);\n       if (nscalars_skip)\n \tnscalars_skip = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n-\t\t\t\t      nscalars_skip, factor);\n+\t\t\t\t      nscalars_skip, compare_factor);\n     }\n \n   /* Create an induction variable that counts the number of scalars\n@@ -447,15 +447,10 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n   standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n+  create_iv (build_int_cst (iv_type, 0), nscalars_step, NULL_TREE, loop,\n+\t     &incr_gsi, insert_after, &index_before_incr, &index_after_incr);\n \n-  tree zero_index = build_int_cst (iv_type, 0);\n-  tree step = build_int_cst (iv_type,\n-\t\t\t     LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-  /* Create IV of iv_type.  */\n-  create_iv (zero_index, step, NULL_TREE, loop, &incr_gsi,\n-\t     insert_after, &index_before_incr, &index_after_incr);\n-\n-  zero_index = build_int_cst (compare_type, 0);\n+  tree zero_index = build_int_cst (compare_type, 0);\n   tree test_index, test_limit, first_limit;\n   gimple_stmt_iterator *test_gsi;\n   if (might_wrap_p)\n@@ -487,7 +482,8 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n \t where the rightmost subtraction can be done directly in\n \t COMPARE_TYPE.  */\n       test_index = index_before_incr;\n-      tree adjust = nscalars_step;\n+      tree adjust = gimple_convert (preheader_seq, compare_type,\n+\t\t\t\t    nscalars_step);\n       if (nscalars_skip)\n \tadjust = gimple_build (preheader_seq, MINUS_EXPR, compare_type,\n \t\t\t       adjust, nscalars_skip);\n@@ -531,14 +527,16 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n       first_limit = test_limit;\n     }\n \n-  /* Provide a definition of each mask in the group.  */\n-  tree next_mask = NULL_TREE;\n-  tree mask;\n-  unsigned int i;\n+  /* Convert the IV value to the comparison type (either a no-op or\n+     a demotion).  */\n   gimple_seq test_seq = NULL;\n   test_index = gimple_convert (&test_seq, compare_type, test_index);\n   gsi_insert_seq_before (test_gsi, test_seq, GSI_SAME_STMT);\n \n+  /* Provide a definition of each mask in the group.  */\n+  tree next_mask = NULL_TREE;\n+  tree mask;\n+  unsigned int i;\n   FOR_EACH_VEC_ELT_REVERSE (rgm->masks, i, mask)\n     {\n       /* Previous masks will cover BIAS scalars.  This mask covers the\n@@ -672,9 +670,6 @@ vect_set_loop_condition_masked (struct loop *loop, loop_vec_info loop_vinfo,\n     niters = gimple_convert (&preheader_seq, compare_type, niters);\n \n   widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n-  /* Get the vectorization factor in tree form.  */\n-  tree vf = build_int_cst (compare_type,\n-\t\t\t   LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n \n   /* Iterate over all the rgroups and fill in their masks.  We could use\n      the first mask from any rgroup for the loop condition; here we\n@@ -709,7 +704,7 @@ vect_set_loop_condition_masked (struct loop *loop, loop_vec_info loop_vinfo,\n \t/* Set up all masks for this group.  */\n \ttest_mask = vect_set_loop_masks_directly (loop, loop_vinfo,\n \t\t\t\t\t\t  &preheader_seq,\n-\t\t\t\t\t\t  loop_cond_gsi, rgm, vf,\n+\t\t\t\t\t\t  loop_cond_gsi, rgm,\n \t\t\t\t\t\t  niters, niters_skip,\n \t\t\t\t\t\t  might_wrap_p);\n       }"}, {"sha": "d3facf67bf951ce6c3bacd8c0d5baeacb4d36503", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae0292de06aeb54c44d26cfb80d798df60e339/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae0292de06aeb54c44d26cfb80d798df60e339/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=fcae0292de06aeb54c44d26cfb80d798df60e339", "patch": "@@ -1062,7 +1062,7 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n   tree cmp_type = NULL_TREE;\n   tree iv_type = NULL_TREE;\n   widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n-  widest_int iv_precision = UINT_MAX;\n+  unsigned int iv_precision = UINT_MAX;\n \n   if (iv_limit != -1)\n     iv_precision = wi::min_precision (iv_limit * max_nscalars_per_iter,\n@@ -1083,12 +1083,12 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n \t\t best choice:\n \n \t\t - An IV that's Pmode or wider is more likely to be reusable\n-\t\t in address calculations than an IV that's narrower than\n-\t\t Pmode.\n+\t\t   in address calculations than an IV that's narrower than\n+\t\t   Pmode.\n \n \t\t - Doing the comparison in IV_PRECISION or wider allows\n-\t\t a natural 0-based IV, whereas using a narrower comparison\n-\t\t type requires mitigations against wrap-around.\n+\t\t   a natural 0-based IV, whereas using a narrower comparison\n+\t\t   type requires mitigations against wrap-around.\n \n \t\t Conversely, if the IV limit is variable, doing the comparison\n \t\t in a wider type than the original type can introduce"}]}