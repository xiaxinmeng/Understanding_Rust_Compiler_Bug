{"sha": "4b17187f237160e6b3d536f7843d4f3a7d258a23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIxNzE4N2YyMzcxNjBlNmIzZDUzNmY3ODQzZDRmM2E3ZDI1OGEyMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T15:11:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T15:11:29Z"}, "message": "[multiple changes]\n\n2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-coormu.ads, a-coormu.adb: Add Indexing aspect, Reference_Type,\n\tand Reference_Control_Type to support element iterators over\n\tordered multisets.\n\t* a-ciormu.ads, a-ciormu.adb: Ditto for\n\tindefinite_ordered_multisets.\n\n2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Force\n\tthe evaluation of the EWA expression.  Code cleanup.\n\t(Process_Transient_Object): Code cleanup.\n\t* exp_util.adb (Is_Aliased): Controlled transient objects found\n\twithin EWA nodes are not aliased.\n\t(Is_Finalizable_Transient): Iterators are not finalizable transients.\n\nFrom-SVN: r223076", "tree": {"sha": "0c7c2fa1b2b4bddd3beb35a7614adfb86bef56a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c7c2fa1b2b4bddd3beb35a7614adfb86bef56a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b17187f237160e6b3d536f7843d4f3a7d258a23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b17187f237160e6b3d536f7843d4f3a7d258a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b17187f237160e6b3d536f7843d4f3a7d258a23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b17187f237160e6b3d536f7843d4f3a7d258a23/comments", "author": null, "committer": null, "parents": [{"sha": "7858300e044409a95307ea40622812190032015b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7858300e044409a95307ea40622812190032015b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7858300e044409a95307ea40622812190032015b"}], "stats": {"total": 509, "additions": 372, "deletions": 137}, "files": [{"sha": "e12294194c14e9a06b9da472a34a08fa09f66fca", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -1,3 +1,20 @@\n+2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-coormu.ads, a-coormu.adb: Add Indexing aspect, Reference_Type,\n+\tand Reference_Control_Type to support element iterators over\n+\tordered multisets.\n+\t* a-ciormu.ads, a-ciormu.adb: Ditto for\n+\tindefinite_ordered_multisets.\n+\n+2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Force\n+\tthe evaluation of the EWA expression.  Code cleanup.\n+\t(Process_Transient_Object): Code cleanup.\n+\t* exp_util.adb (Is_Aliased): Controlled transient objects found\n+\twithin EWA nodes are not aliased.\n+\t(Is_Finalizable_Transient): Iterators are not finalizable transients.\n+\n 2015-05-12  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb (Process_Atomic_Independent_Shared_Volatile):"}, {"sha": "38dd5ae6a40bca5f98efb03920d3b3f595dd4087", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -353,6 +353,45 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Constant_Reference\");\n+\n+      --  Note: in predefined container units, the creation of a reference\n+      --  increments the busy bit of the container, and its finalization\n+      --  decrements it. In the absence of control machinery, this tampering\n+      --  protection is missing.\n+\n+      declare\n+         T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+         pragma Unreferenced (T);\n+      begin\n+         return R : constant Constant_Reference_Type :=\n+           (Element => Position.Node.Element,\n+            Control => (Container => Container'Unrestricted_Access))\n+         do\n+            null;\n+         end return;\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1730,6 +1769,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -2055,4 +2102,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "68d1835bed9a49eec4f4360b87480847a0504052", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,8 +52,9 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    --  otherwise, it returns True.\n \n    type Set is tagged private\n-   with Default_Iterator => Iterate,\n-        Iterator_Element => Element_Type;\n+   with Constant_Indexing => Constant_Reference,\n+        Default_Iterator  => Iterate,\n+        Iterator_Element  => Element_Type;\n \n    pragma Preelaborable_Initialization (Set);\n \n@@ -128,6 +129,15 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    --  change the value of the element while Process is executing (to \"tamper\n    --  with elements\") will raise Program_Error.\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type;\n+   pragma Inline (Constant_Reference);\n+\n    procedure Assign (Target : in out Set; Source : Set);\n \n    function Copy (Source : Set) return Set;\n@@ -469,6 +479,19 @@ private\n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n \n+   --  In all predefined libraries the following type is controlled, for proper\n+   --  management of tampering checks. For performance reason we omit this\n+   --  machinery for multisets, which are used in a number of our tools.\n+\n+   type Reference_Control_Type is record\n+      Container : Set_Access;\n+   end record;\n+\n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is record\n+      Control : Reference_Control_Type;\n+   end record;\n+\n    type Cursor is record\n       Container : Set_Access;\n       Node      : Node_Access;\n@@ -500,6 +523,18 @@ private\n \n    for Set'Read use Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n    Empty_Set : constant Set :=\n                  (Controlled with Tree => (First  => null,\n                                            Last   => null,"}, {"sha": "c3e4fce66e420f82ba5c261e82bd8514d9d26eaa", "filename": "gcc/ada/a-coormu.adb", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -321,6 +321,45 @@ package body Ada.Containers.Ordered_Multisets is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Constant_Reference\");\n+\n+      --  Note: in predefined container units, the creation of a reference\n+      --  increments the busy bit of the container, and its finalization\n+      --  decrements it. In the absence of control machinery, this tampering\n+      --  protection is missing.\n+\n+      declare\n+         T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+         pragma Unreferenced (T);\n+      begin\n+         return R : constant Constant_Reference_Type :=\n+           (Element => Position.Node.Element'Unrestricted_Access,\n+            Control => (Container => Container'Unrestricted_Access))\n+         do\n+            null;\n+         end return;\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1638,6 +1677,14 @@ package body Ada.Containers.Ordered_Multisets is\n       raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1937,4 +1984,11 @@ package body Ada.Containers.Ordered_Multisets is\n       raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n end Ada.Containers.Ordered_Multisets;"}, {"sha": "d7e7b94152b57fbb03d626bccfdbc9f9b7b731d0", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,8 +51,9 @@ package Ada.Containers.Ordered_Multisets is\n    --  otherwise, it returns True.\n \n    type Set is tagged private\n-   with Default_Iterator => Iterate,\n-        Iterator_Element => Element_Type;\n+   with Constant_Indexing => Constant_Reference,\n+        Default_Iterator  => Iterate,\n+        Iterator_Element  => Element_Type;\n \n    pragma Preelaborable_Initialization (Set);\n \n@@ -127,6 +128,15 @@ package Ada.Containers.Ordered_Multisets is\n    --  change the value of the element while Process is executing (to \"tamper\n    --  with elements\") will raise Program_Error.\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is private\n+        with Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type;\n+   pragma Inline (Constant_Reference);\n+\n    procedure Assign (Target : in out Set; Source : Set);\n \n    function Copy (Source : Set) return Set;\n@@ -473,6 +483,19 @@ private\n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n \n+   --  In all predefined libraries the following type is controlled, for proper\n+   --  management of tampering checks. For performance reason we omit this\n+   --  machinery for multisets, which are used in a number of our tools.\n+\n+   type Reference_Control_Type is record\n+      Container : Set_Access;\n+   end record;\n+\n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is record\n+      Control : Reference_Control_Type;\n+   end record;\n+\n    type Cursor is record\n       Container : Set_Access;\n       Node      : Node_Access;\n@@ -504,6 +527,18 @@ private\n \n    for Set'Read use Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n    Empty_Set : constant Set :=\n                  (Controlled with Tree => (First  => null,\n                                            Last   => null,"}, {"sha": "8b3e0ea511b03697c181e0b28f4c1b5a060eb070", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 109, "deletions": 108, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -5090,7 +5090,6 @@ package body Exp_Ch4 is\n    --------------------------------------\n \n    procedure Expand_N_Expression_With_Actions (N : Node_Id) is\n-\n       function Process_Action (Act : Node_Id) return Traverse_Result;\n       --  Inspect and process a single action of an expression_with_actions for\n       --  transient controlled objects. If such objects are found, the routine\n@@ -5129,14 +5128,57 @@ package body Exp_Ch4 is\n \n       --  Local variables\n \n-      Act : Node_Id;\n+      Acts : constant List_Id := Actions (N);\n+      Expr : constant Node_Id := Expression (N);\n+      Act  : Node_Id;\n \n    --  Start of processing for Expand_N_Expression_With_Actions\n \n    begin\n-      --  Process the actions as described above\n+      --  Do not evaluate the expression when it denotes an entity because the\n+      --  expression_with_actions node will be replaced by the reference.\n+\n+      if Is_Entity_Name (Expr) then\n+         null;\n+\n+      --  Do not evaluate the expression when there are no actions because the\n+      --  expression_with_actions node will be replaced by the expression.\n+\n+      elsif No (Acts) or else Is_Empty_List (Acts) then\n+         null;\n+\n+      --  Force the evaluation of the expression by capturing its value in a\n+      --  temporary. This ensures that aliases of transient controlled objects\n+      --  do not leak to the expression of the expression_with_actions node:\n+\n+      --    do\n+      --       Trans_Id : Ctrl_Typ : ...;\n+      --       Alias : ... := Trans_Id;\n+      --    in ... Alias ... end;\n+\n+      --  In the example above, Trans_Id cannot be finalized at the end of the\n+      --  actions list because this may affect the alias and the final value of\n+      --  the expression_with_actions. Forcing the evaluation encapsulates the\n+      --  reference to the Alias within the actions list:\n+\n+      --    do\n+      --       Trans_Id : Ctrl_Typ : ...;\n+      --       Alias : ... := Trans_Id;\n+      --       Val : constant Boolean := ... Alias ...;\n+      --       <finalize Trans_Id>\n+      --    in Val end;\n \n-      Act := First (Actions (N));\n+      --  It is now safe to finalize the transient controlled object at the end\n+      --  of the actions list.\n+\n+      else\n+         Force_Evaluation (Expr);\n+      end if;\n+\n+      --  Process all transient controlled objects found within the actions of\n+      --  the EWA node.\n+\n+      Act := First (Acts);\n       while Present (Act) loop\n          Process_Single_Action (Act);\n          Next (Act);\n@@ -5151,7 +5193,7 @@ package body Exp_Ch4 is\n       --  tree in cases like this. This raises a whole lot of issues of whether\n       --  we have problems elsewhere, which will be addressed in the future???\n \n-      if Is_Empty_List (Actions (N)) then\n+      if Is_Empty_List (Acts) then\n          Rewrite (N, Relocate_Node (Expression (N)));\n       end if;\n    end Expand_N_Expression_With_Actions;\n@@ -11406,9 +11448,10 @@ package body Exp_Ch4 is\n          --  problems for coverage analysis.\n \n          Rewrite (Right,\n-                  Make_Expression_With_Actions (LocR,\n-                    Expression => Relocate_Node (Right),\n-                    Actions    => Actlist));\n+           Make_Expression_With_Actions (LocR,\n+             Expression => Relocate_Node (Right),\n+             Actions    => Actlist));\n+\n          Set_Actions (N, No_List);\n          Analyze_And_Resolve (Right, Standard_Boolean);\n \n@@ -12620,72 +12663,28 @@ package body Exp_Ch4 is\n      (Decl     : Node_Id;\n       Rel_Node : Node_Id)\n    is\n-      Loc       : constant Source_Ptr := Sloc (Decl);\n-      Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n-      Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n-      Desig_Typ : Entity_Id;\n-      Expr      : Node_Id;\n-      Fin_Stmts : List_Id;\n-      Ptr_Id    : Entity_Id;\n-      Temp_Id   : Entity_Id;\n-      Temp_Ins  : Node_Id;\n+      Loc         : constant Source_Ptr := Sloc (Decl);\n+      Obj_Id      : constant Entity_Id  := Defining_Identifier (Decl);\n+      Obj_Typ     : constant Node_Id    := Etype (Obj_Id);\n+      Desig_Typ   : Entity_Id;\n+      Expr        : Node_Id;\n+      Hook_Id     : Entity_Id;\n+      Hook_Insert : Node_Id;\n+      Ptr_Id      : Entity_Id;\n \n       Hook_Context : constant Node_Id := Find_Hook_Context (Rel_Node);\n-      --  Node on which to insert the hook pointer (as an action): the\n-      --  innermost enclosing non-transient scope.\n-\n-      Finalization_Context : Node_Id;\n-      --  Node after which to insert finalization actions\n+      --  The node on which to insert the hook as an action. This is usually\n+      --  the innermost enclosing non-transient construct.\n \n-      Finalize_Always : Boolean;\n-      --  If False, call to finalizer includes a test of whether the hook\n-      --  pointer is null.\n+      Fin_Context : Node_Id;\n+      --  The node after which to insert the finalization actions of the\n+      --  transient controlled object.\n \n    begin\n-      --  Step 0: determine where to attach finalization actions in the tree\n-\n-      --  Special case for Boolean EWAs: capture expression in a temporary,\n-      --  whose declaration will serve as the context around which to insert\n-      --  finalization code. The finalization thus remains local to the\n-      --  specific condition being evaluated.\n-\n       if Is_Boolean_Type (Etype (Rel_Node)) then\n-\n-         --  In this case, the finalization context is chosen so that we know\n-         --  at finalization point that the hook pointer is never null, so no\n-         --  need for a test, we can call the finalizer unconditionally, except\n-         --  in the case where the object is created in a specific branch of a\n-         --  conditional expression.\n-\n-         Finalize_Always :=\n-           not Within_Case_Or_If_Expression (Rel_Node)\n-             and then not Nkind_In\n-                            (Original_Node (Rel_Node), N_Case_Expression,\n-                                                       N_If_Expression);\n-\n-         declare\n-            Loc  : constant Source_Ptr := Sloc (Rel_Node);\n-            Temp : constant Entity_Id := Make_Temporary (Loc, 'E', Rel_Node);\n-\n-         begin\n-            Append_To (Actions (Rel_Node),\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Constant_Present    => True,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (Etype (Rel_Node), Loc),\n-                Expression          => Expression (Rel_Node)));\n-            Finalization_Context := Last (Actions (Rel_Node));\n-\n-            Analyze (Last (Actions (Rel_Node)));\n-\n-            Set_Expression (Rel_Node, New_Occurrence_Of (Temp, Loc));\n-            Analyze (Expression (Rel_Node));\n-         end;\n-\n+         Fin_Context := Last (Actions (Rel_Node));\n       else\n-         Finalize_Always := False;\n-         Finalization_Context := Hook_Context;\n+         Fin_Context := Hook_Context;\n       end if;\n \n       --  Step 1: Create the access type which provides a reference to the\n@@ -12715,23 +12714,23 @@ package body Exp_Ch4 is\n       --  Step 2: Create a temporary which acts as a hook to the transient\n       --  controlled object. Generate:\n \n-      --    Temp : Ptr_Id := null;\n+      --    Hook : Ptr_Id := null;\n \n-      Temp_Id := Make_Temporary (Loc, 'T');\n+      Hook_Id := Make_Temporary (Loc, 'T');\n \n       Insert_Action (Hook_Context,\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => Temp_Id,\n+          Defining_Identifier => Hook_Id,\n           Object_Definition   => New_Occurrence_Of (Ptr_Id, Loc)));\n \n-      --  Mark the temporary as created for the purposes of exporting the\n-      --  transient controlled object out of the expression_with_action or if\n-      --  expression. This signals the machinery in Build_Finalizer to treat\n-      --  this case specially.\n+      --  Mark the hook as created for the purposes of exporting the transient\n+      --  controlled object out of the expression_with_action or if expression.\n+      --  This signals the machinery in Build_Finalizer to treat this case in\n+      --  a special manner.\n \n-      Set_Status_Flag_Or_Transient_Decl (Temp_Id, Decl);\n+      Set_Status_Flag_Or_Transient_Decl (Hook_Id, Decl);\n \n-      --  Step 3: Hook the transient object to the temporary\n+      --  Step 3: Associate the transient object to the hook\n \n       --  This must be inserted right after the object declaration, so that\n       --  the assignment is executed if, and only if, the object is actually\n@@ -12747,7 +12746,9 @@ package body Exp_Ch4 is\n \n       if Is_Access_Type (Obj_Typ) then\n          Expr :=\n-           Unchecked_Convert_To (Ptr_Id, New_Occurrence_Of (Obj_Id, Loc));\n+           Unchecked_Convert_To\n+             (Typ  => Ptr_Id,\n+              Expr => New_Occurrence_Of (Obj_Id, Loc));\n       else\n          Expr :=\n            Make_Attribute_Reference (Loc,\n@@ -12756,9 +12757,9 @@ package body Exp_Ch4 is\n       end if;\n \n       --  Generate:\n-      --    Temp := Ptr_Id (Obj_Id);\n+      --    Hook := Ptr_Id (Obj_Id);\n       --      <or>\n-      --    Temp := Obj_Id'Unrestricted_Access;\n+      --    Hook := Obj_Id'Unrestricted_Access;\n \n       --  When the transient object is initialized by an aggregate, the hook\n       --  must capture the object after the last component assignment takes\n@@ -12767,25 +12768,25 @@ package body Exp_Ch4 is\n       if Ekind (Obj_Id) = E_Variable\n         and then Present (Last_Aggregate_Assignment (Obj_Id))\n       then\n-         Temp_Ins := Last_Aggregate_Assignment (Obj_Id);\n+         Hook_Insert := Last_Aggregate_Assignment (Obj_Id);\n \n       --  Otherwise the hook seizes the related object immediately\n \n       else\n-         Temp_Ins := Decl;\n+         Hook_Insert := Decl;\n       end if;\n \n-      Insert_After_And_Analyze (Temp_Ins,\n+      Insert_After_And_Analyze (Hook_Insert,\n         Make_Assignment_Statement (Loc,\n-          Name       => New_Occurrence_Of (Temp_Id, Loc),\n+          Name       => New_Occurrence_Of (Hook_Id, Loc),\n           Expression => Expr));\n \n-      --  Step 4: Finalize the transient controlled object after the context\n-      --  has been evaluated/elaborated. Generate:\n+      --  Step 4: Finalize the hook after the context has been evaluated or\n+      --  elaborated. Generate:\n \n-      --    if Temp /= null then\n-      --       [Deep_]Finalize (Temp.all);\n-      --       Temp := null;\n+      --    if Hook /= null then\n+      --       [Deep_]Finalize (Hook.all);\n+      --       Hook := null;\n       --    end if;\n \n       --  When the node is part of a return statement, there is no need to\n@@ -12795,29 +12796,29 @@ package body Exp_Ch4 is\n       --  insert the finalization code after the return statement as this will\n       --  render it unreachable.\n \n-      if Nkind (Finalization_Context) /= N_Simple_Return_Statement then\n-         Fin_Stmts := New_List (\n-           Make_Final_Call\n-             (Obj_Ref =>\n-                Make_Explicit_Dereference (Loc,\n-                  Prefix => New_Occurrence_Of (Temp_Id, Loc)),\n-              Typ     => Desig_Typ),\n+      if Nkind (Fin_Context) = N_Simple_Return_Statement then\n+         null;\n \n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Occurrence_Of (Temp_Id, Loc),\n-             Expression => Make_Null (Loc)));\n+      --  Otherwise finalize the hook\n \n-         if not Finalize_Always then\n-            Fin_Stmts := New_List (\n-              Make_Implicit_If_Statement (Decl,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd  => New_Occurrence_Of (Temp_Id, Loc),\n-                    Right_Opnd => Make_Null (Loc)),\n-                Then_Statements => Fin_Stmts));\n-         end if;\n+      else\n+         Insert_Action_After (Fin_Context,\n+           Make_Implicit_If_Statement (Decl,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Hook_Id, Loc),\n+                 Right_Opnd => Make_Null (Loc)),\n+\n+             Then_Statements => New_List (\n+               Make_Final_Call\n+                 (Obj_Ref =>\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix => New_Occurrence_Of (Hook_Id, Loc)),\n+                  Typ     => Desig_Typ),\n \n-         Insert_Actions_After (Finalization_Context, Fin_Stmts);\n+               Make_Assignment_Statement (Loc,\n+                 Name       => New_Occurrence_Of (Hook_Id, Loc),\n+                 Expression => Make_Null (Loc)))));\n       end if;\n    end Process_Transient_Object;\n "}, {"sha": "5b86d419a99cda79a385c17d84a801e8f6b77424", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 60, "deletions": 21, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b17187f237160e6b3d536f7843d4f3a7d258a23/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=4b17187f237160e6b3d536f7843d4f3a7d258a23", "patch": "@@ -4713,7 +4713,6 @@ package body Exp_Util is\n    is\n       Obj_Id  : constant Entity_Id := Defining_Identifier (Decl);\n       Obj_Typ : constant Entity_Id := Base_Type (Etype (Obj_Id));\n-      Desig   : Entity_Id := Obj_Typ;\n \n       function Initialized_By_Access (Trans_Id : Entity_Id) return Boolean;\n       --  Determine whether transient object Trans_Id is initialized either\n@@ -4916,31 +4915,61 @@ package body Exp_Util is\n       --  Start of processing for Is_Aliased\n \n       begin\n-         Stmt := First_Stmt;\n-         while Present (Stmt) loop\n-            if Nkind (Stmt) = N_Object_Declaration then\n-               Expr := Expression (Stmt);\n-\n-               if Present (Expr)\n-                 and then Nkind (Expr) = N_Reference\n-                 and then Nkind (Prefix (Expr)) = N_Identifier\n-                 and then Entity (Prefix (Expr)) = Trans_Id\n-               then\n-                  return True;\n-               end if;\n+         --  A controlled transient object is not considered aliased when it\n+         --  appears inside an expression_with_actions node even when there are\n+         --  explicit aliases of it:\n+\n+         --    do\n+         --       Trans_Id : Ctrl_Typ ...;  --  controlled transient object\n+         --       Alias : ... := Trans_Id;  --  object is aliased\n+         --       Val : constant Boolean :=\n+         --               ... Alias ...;    --  aliasing ends\n+         --       <finalize Trans_Id>       --  object safe to finalize\n+         --    in Val end;\n+\n+         --  Expansion ensures that all aliases are encapsulated in the actions\n+         --  list and do not leak to the expression by forcing the evaluation\n+         --  of the expression.\n+\n+         if Nkind (Rel_Node) = N_Expression_With_Actions then\n+            return False;\n \n-            elsif Nkind (Stmt) = N_Object_Renaming_Declaration then\n-               Ren_Obj := Find_Renamed_Object (Stmt);\n+         --  Otherwise examine the statements after the controlled transient\n+         --  object and look for various forms of aliasing.\n \n-               if Present (Ren_Obj) and then Ren_Obj = Trans_Id then\n-                  return True;\n+         else\n+            Stmt := First_Stmt;\n+            while Present (Stmt) loop\n+               if Nkind (Stmt) = N_Object_Declaration then\n+                  Expr := Expression (Stmt);\n+\n+                  --  Aliasing of the form:\n+                  --    Obj : ... := Trans_Id'reference;\n+\n+                  if Present (Expr)\n+                    and then Nkind (Expr) = N_Reference\n+                    and then Nkind (Prefix (Expr)) = N_Identifier\n+                    and then Entity (Prefix (Expr)) = Trans_Id\n+                  then\n+                     return True;\n+                  end if;\n+\n+               elsif Nkind (Stmt) = N_Object_Renaming_Declaration then\n+                  Ren_Obj := Find_Renamed_Object (Stmt);\n+\n+                  --  Aliasing of the form:\n+                  --    Obj : ... renames ... Trans_Id ...;\n+\n+                  if Present (Ren_Obj) and then Ren_Obj = Trans_Id then\n+                     return True;\n+                  end if;\n                end if;\n-            end if;\n \n-            Next (Stmt);\n-         end loop;\n+               Next (Stmt);\n+            end loop;\n \n-         return False;\n+            return False;\n+         end if;\n       end Is_Aliased;\n \n       ------------------\n@@ -5041,6 +5070,10 @@ package body Exp_Util is\n          return False;\n       end Is_Iterated_Container;\n \n+      --  Local variables\n+\n+      Desig : Entity_Id := Obj_Typ;\n+\n    --  Start of processing for Is_Finalizable_Transient\n \n    begin\n@@ -5083,6 +5116,12 @@ package body Exp_Util is\n \n           and then not Is_Tag_To_Class_Wide_Conversion (Obj_Id)\n \n+          --  Do not consider iterators because those are treated as normal\n+          --  controlled objects and are processed by the usual finalization\n+          --  machinery. This avoids the double finalization of an iterator.\n+\n+          and then not Is_Iterator (Desig)\n+\n           --  Do not consider containers in the context of iterator loops. Such\n           --  transient objects must exist for as long as the loop is around,\n           --  otherwise any operation carried out by the iterator will fail."}]}