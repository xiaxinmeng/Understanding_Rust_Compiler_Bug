{"sha": "b11550aa902ed4dca28bea67dcf81cfefe64847e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExNTUwYWE5MDJlZDRkY2EyOGJlYTY3ZGNmODFjZmVmZTY0ODQ3ZQ==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2006-05-23T20:49:11Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2006-05-23T20:49:11Z"}, "message": "df-core.c: Added to header comments.\n\n2006-05-23  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n        * df-core.c: Added to header comments.\n\t* df.h (df_ru_bb_info, df_rd_bb_info, df_lr_bb_info,\n\tdf_ur_bb_info, df_urec_bb_info): Added comments.\n\t* df-problems (df_ref_bitmap, ru, rd, lr, ur, \n\turec, ri problems): Fixed header comments.\n\t(df_ru_transfer_function): Fixed in-out set dyslexia when copying \n\tcode from df_rd_transfer_function.\n\nFrom-SVN: r114024", "tree": {"sha": "14e72d251b2751b6da44611981541d07057f5a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14e72d251b2751b6da44611981541d07057f5a7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b11550aa902ed4dca28bea67dcf81cfefe64847e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11550aa902ed4dca28bea67dcf81cfefe64847e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11550aa902ed4dca28bea67dcf81cfefe64847e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11550aa902ed4dca28bea67dcf81cfefe64847e/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29a1da1c303b0bca58faf0963ae250eb460c66ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a1da1c303b0bca58faf0963ae250eb460c66ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a1da1c303b0bca58faf0963ae250eb460c66ba"}], "stats": {"total": 182, "additions": 142, "deletions": 40}, "files": [{"sha": "d5ed078e9f51a22046b7718e90a5626f0cfe0890", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b11550aa902ed4dca28bea67dcf81cfefe64847e", "patch": "@@ -1,3 +1,13 @@\n+2006-05-23  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+        * df-core.c: Added to header comments.\n+\t* df.h (df_ru_bb_info, df_rd_bb_info, df_lr_bb_info,\n+\tdf_ur_bb_info, df_urec_bb_info): Added comments.\n+\t* df-problems (df_ref_bitmap, ru, rd, lr, ur, \n+\turec, ri problems): Fixed header comments.\n+\t(df_ru_transfer_function): Fixed in-out set dyslexia when copying \n+\tcode from df_rd_transfer_function.\n+\t\n 2006-05-23  Richard Sandiford  <richard@codesourcery.com>\n \n \t* libgcc2.c (LIBGCC2_MAX_UNITS_PER_WORD): New macro."}, {"sha": "f0c62c91c1efb61232578e05a1c3f68232b2da18", "filename": "gcc/df-core.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=b11550aa902ed4dca28bea67dcf81cfefe64847e", "patch": "@@ -113,7 +113,10 @@ df_set_blocks, these blocks are added to the set of blocks.\n \n DF_ANALYZE causes all of the defined problems to be (re)solved.  It\n does not cause blocks to be (re)scanned at the rtl level unless no\n-prior call is made to df_rescan_blocks.\n+prior call is made to df_rescan_blocks.  When DF_ANALYZE is completes,\n+the IN and OUT sets for each basic block contain the computer\n+information.  The DF_*_BB_INFO macros can be used to access these\n+bitvectors.\n \n \n DF_DUMP can then be called to dump the information produce to some"}, {"sha": "e12c28a132ec37514839bc531a3666fb3d9baad0", "filename": "gcc/df-problems.c", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=b11550aa902ed4dca28bea67dcf81cfefe64847e", "patch": "@@ -239,7 +239,9 @@ df_print_bb_index (basic_block bb, FILE *file)\n }\n \n \n-/* Return the set of reference ids in CHAIN, caching the result in *BMAP.  */\n+/* Return a bitmap for REGNO from the cache MAPS.  The bitmap is to\n+   contain COUNT bits starting at START.  These bitmaps are not to be\n+   changed since there is a cache of them.  */\n \n static inline bitmap\n df_ref_bitmap (bitmap *maps, unsigned int regno, int start, int count)\n@@ -282,12 +284,41 @@ df_unset_seen (void)\n    REACHING USES\n \n    Find the locations in the function where each use site for a pseudo\n-   can reach backwards.\n+   can reach backwards.  In and out bitvectors are built for each basic\n+   block.  The id field in the ref is used to index into these sets.\n+   See df.h for details.\n \n ----------------------------------------------------------------------------*/\n \n+/* This problem plays a large number of games for the sake of\n+   efficiency.  \n+   \n+   1) The order of the bits in the bitvectors.  After the scanning\n+   phase, all of the uses are sorted.  All of the uses for the reg 0\n+   are first, followed by all uses for reg 1 and so on.\n+   \n+   2) There are two kill sets, one if the number of uses is less or\n+   equal to DF_SPARSE_THRESHOLD and another if it is greater.\n+\n+   <= : There is a bitmap for each register, uses_sites[N], that is\n+   built on demand.  This bitvector contains a 1 for each use or reg\n+   N.\n+\n+   > : One level of indirection is used to keep from generating long\n+   strings of 1 bits in the kill sets.  Bitvectors that are indexed\n+   by the regnum are used to represent that there is a killing def\n+   for the register.  The confluence and transfer functions use\n+   these along with the bitmap_clear_range call to remove ranges of\n+   bits without actually generating a knockout vector.\n+\n+   The kill and sparse_kill and the dense_invalidated_by_call and\n+   sparse_invalidated_by call both play this game.  */\n+\n+/* Private data used to compute the solution for this problem.  These\n+   data structures are not accessable outside of this module.  */\n struct df_ru_problem_data\n {\n+\n   bitmap *use_sites;            /* Bitmap of uses for each pseudo.  */\n   unsigned int use_sites_size;  /* Size of use_sites.  */\n   /* The set of defs to regs invalidated by call.  */\n@@ -656,7 +687,7 @@ df_ru_transfer_function (struct dataflow *dflow, int bb_index)\n       struct df *df = dflow->df;\n       bool changed = false;\n       bitmap tmp = BITMAP_ALLOC (NULL);\n-      bitmap_copy (tmp, in);\n+      bitmap_copy (tmp, out);\n       EXECUTE_IF_SET_IN_BITMAP (sparse_kill, 0, regno, bi)\n \t{\n \t  bitmap_clear_range (tmp, \n@@ -668,7 +699,7 @@ df_ru_transfer_function (struct dataflow *dflow, int bb_index)\n       changed = !bitmap_equal_p (tmp, in);\n       if (changed)\n \t{\n-\t  BITMAP_FREE (out);\n+\t  BITMAP_FREE (in);\n \t  bb_info->in = tmp;\n \t}\n       else \n@@ -810,16 +841,29 @@ df_ru_add_problem (struct df *df, int flags)\n    REACHING DEFINITIONS\n \n    Find the locations in the function where each definition site for a\n-   pseudo reaches.\n-----------------------------------------------------------------------------*/\n+   pseudo reaches.  In and out bitvectors are built for each basic\n+   block.  The id field in the ref is used to index into these sets.\n+   See df.h for details.\n+   ----------------------------------------------------------------------------*/\n+\n+/* See the comment at the top of the Reaching Uses problem for how the\n+   uses are represented in the kill sets. The same games are played\n+   here for the defs.  */\n \n+/* Private data used to compute the solution for this problem.  These\n+   data structures are not accessable outside of this module.  */\n struct df_rd_problem_data\n {\n+  /* If the number of defs for regnum N is less than\n+     DF_SPARSE_THRESHOLD, uses_sites[N] contains a mask of the all of\n+     the defs of reg N indexed by the id in the ref structure.  If\n+     there are more than DF_SPARSE_THRESHOLD defs for regnum N a\n+     different mechanism is used to mask the def.  */\n   bitmap *def_sites;            /* Bitmap of defs for each pseudo.  */\n   unsigned int def_sites_size;  /* Size of def_sites.  */\n   /* The set of defs to regs invalidated by call.  */\n   bitmap sparse_invalidated_by_call;  \n-  /* The set of defs to regs invalidate by call for ru.  */  \n+  /* The set of defs to regs invalidate by call for rd.  */  \n   bitmap dense_invalidated_by_call;   \n };\n \n@@ -1321,9 +1365,11 @@ df_rd_add_problem (struct df *df, int flags)\n /*----------------------------------------------------------------------------\n    LIVE REGISTERS\n \n-   Find the locations in the function where any use of a pseudo can reach\n-   in the backwards direction.\n-----------------------------------------------------------------------------*/\n+   Find the locations in the function where any use of a pseudo can\n+   reach in the backwards direction.  In and out bitvectors are built\n+   for each basic block.  The regnum is used to index into these sets.\n+   See df.h for details.\n+   ----------------------------------------------------------------------------*/\n \n /* Get basic block info.  */\n \n@@ -1734,7 +1780,9 @@ df_lr_add_problem (struct df *df, int flags)\n    UNINITIALIZED REGISTERS\n \n    Find the set of uses for registers that are reachable from the entry\n-   block without passing thru a definition.\n+   block without passing thru a definition.  In and out bitvectors are built\n+   for each basic block.  The regnum is used to index into these sets.\n+   See df.h for details.\n ----------------------------------------------------------------------------*/\n \n /* Get basic block info.  */\n@@ -2088,12 +2136,18 @@ df_ur_add_problem (struct df *df, int flags)\n    UNINITIALIZED REGISTERS WITH EARLYCLOBBER\n \n    Find the set of uses for registers that are reachable from the entry\n-   block without passing thru a definition.\n+   block without passing thru a definition.  In and out bitvectors are built\n+   for each basic block.  The regnum is used to index into these sets.\n+   See df.h for details.\n \n    This is a variant of the UR problem above that has a lot of special\n-   features just for the register allocation phase.\n-----------------------------------------------------------------------------*/\n+   features just for the register allocation phase.  This problem\n+   should go a away if someone would fix the interference graph.\n+\n+   ----------------------------------------------------------------------------*/\n \n+/* Private data used to compute the solution for this problem.  These\n+   data structures are not accessable outside of this module.  */\n struct df_urec_problem_data\n {\n   bool earlyclobbers_found;     /* True if any instruction contains an\n@@ -3089,8 +3143,13 @@ df_chain_add_problem (struct df *df, int flags)\n /*----------------------------------------------------------------------------\n    REGISTER INFORMATION\n \n-   Currently this consists of only lifetime information and reg_dead\n-   and reg_unused.  \n+   This pass properly computes REG_DEAD and REG_UNUSED notes.\n+\n+   If the DF_RI_LIFE flag is set the following vectors containing\n+   information about register usage are properly set: REG_N_REFS,\n+   REG_N_DEATHS, REG_N_SETS, REG_LIVE_LENGTH, REG_N_CALLS_CROSSED,\n+   REG_N_THROWING_CALLS_CROSSED and REG_BASIC_BLOCK.\n+\n    ----------------------------------------------------------------------------*/\n \n #ifdef REG_DEAD_DEBUGGING"}, {"sha": "c27bbdcbba9df586e5027c31a1a6baf53aa1e235", "filename": "gcc/df.h", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11550aa902ed4dca28bea67dcf81cfefe64847e/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=b11550aa902ed4dca28bea67dcf81cfefe64847e", "patch": "@@ -491,55 +491,85 @@ struct df_scan_bb_info\n };\n \n \n-/* Reaching uses.  */\n+/* Reaching uses.  All bitmaps are indexed by the id field of the ref\n+   except sparse_kill (see below).  */\n struct df_ru_bb_info \n {\n+  /* Local sets to describe the basic blocks.  */\n+  /* The kill set is the set of uses that are killed in this block.\n+     However, if the number of uses for this register is greater than\n+     DF_SPARSE_THRESHOLD, the sparse_kill is used instead. In\n+     sparse_kill, each register gets a slot and a 1 in this bitvector\n+     means that all of the uses of that register are killed.  This is\n+     a very useful efficiency hack in that it keeps from having push\n+     around big groups of 1s.  This is implemened by the\n+     bitmap_clear_range call.  */\n+\n   bitmap kill;\n   bitmap sparse_kill;\n-  bitmap gen;\n-  bitmap in;\n-  bitmap out;\n+  bitmap gen;   /* The set of uses generated in this block.  */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* At the top of the block.  */\n+  bitmap out;   /* At the bottom of the block.  */\n };\n \n \n-/* Reaching definitions.  */\n+/* Reaching definitions.  All bitmaps are indexed by the id field of\n+   the ref except sparse_kill (see above).  */\n struct df_rd_bb_info \n {\n-  bitmap kill;\n+  /* Local sets to describe the basic blocks.  See the note in the RU\n+     datastructures for kill and sparse_kill.  */\n+  bitmap kill;  \n   bitmap sparse_kill;\n-  bitmap gen;\n-  bitmap in;\n-  bitmap out;\n+  bitmap gen;   /* The set of defs generated in this block.  */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* At the top of the block.  */\n+  bitmap out;   /* At the bottom of the block.  */\n };\n \n \n-/* Live registers.  */\n+/* Live registers.  All bitmaps are referenced by the register number.  */\n struct df_lr_bb_info \n {\n-  bitmap def;\n-  bitmap use;\n-  bitmap in;\n-  bitmap out;\n+  /* Local sets to describe the basic blocks.  */\n+  bitmap def;   /* The set of registers set in this block.  */\n+  bitmap use;   /* The set of registers used in this block.  */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* At the top of the block.  */\n+  bitmap out;   /* At the bottom of the block.  */\n };\n \n \n-/* Uninitialized registers.  */\n+/* Uninitialized registers.  All bitmaps are referenced by the register number.  */\n struct df_ur_bb_info \n {\n-  bitmap kill;\n-  bitmap gen;\n-  bitmap in;\n-  bitmap out;\n+  /* Local sets to describe the basic blocks.  */\n+  bitmap kill;  /* The set of registers unset in this block.  Calls,\n+\t\t   for instance, unset registers.  */\n+  bitmap gen;   /* The set of registers set in this block.  */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* At the top of the block.  */\n+  bitmap out;   /* At the bottom of the block.  */\n };\n \n-/* Uninitialized registers.  */\n+/* Uninitialized registers.  All bitmaps are referenced by the register number.  */\n struct df_urec_bb_info \n {\n-  bitmap earlyclobber;\n+  /* Local sets to describe the basic blocks.  */\n+  bitmap earlyclobber;  /* The set of registers that are referenced\n+\t\t\t   with an an early clobber mode.  */\n+  /* Kill and gen are defined as in the UR problem.  */\n   bitmap kill;\n   bitmap gen;\n-  bitmap in;\n-  bitmap out;\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* At the top of the block.  */\n+  bitmap out;   /* At the bottom of the block.  */\n };\n \n "}]}