{"sha": "924326b3e0d75dbb246a4fbabfdd8be417788db8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI0MzI2YjNlMGQ3NWRiYjI0NmE0ZmJhYmZkZDhiZTQxNzc4OGRiOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-13T09:22:18Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-13T11:31:35Z"}, "message": "Move pointer_equiv_analyzer to new file.\n\nWe need to use the pointer equivalence tracking from evrp in the jump\nthreader.  Instead of moving it to some *evrp.h header, it's cleaner for\nit to live in its own file, since it's completely independent and not\nevrp specific.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (OBJS): Add value-pointer-equiv.o.\n\t* gimple-ssa-evrp.c (class ssa_equiv_stack): Move to\n\tvalue-pointer-equiv.*.\n\t(ssa_equiv_stack::ssa_equiv_stack): Same.\n\t(ssa_equiv_stack::enter): Same.\n\t(ssa_equiv_stack::leave): Same.\n\t(ssa_equiv_stack::push_replacement): Same.\n\t(ssa_equiv_stack::get_replacement): Same.\n\t(is_pointer_ssa): Same.\n\t(class pointer_equiv_analyzer): Same.\n\t(pointer_equiv_analyzer::pointer_equiv_analyzer): Same.\n\t(pointer_equiv_analyzer::~pointer_equiv_analyzer): Same.\n\t(pointer_equiv_analyzer::set_global_equiv): Same.\n\t(pointer_equiv_analyzer::set_cond_equiv): Same.\n\t(pointer_equiv_analyzer::get_equiv): Same.\n\t(pointer_equiv_analyzer::enter): Same.\n\t(pointer_equiv_analyzer::leave): Same.\n\t(pointer_equiv_analyzer::get_equiv_expr): Same.\n\t(pta_valueize): Same.\n\t(pointer_equiv_analyzer::visit_stmt): Same.\n\t(pointer_equiv_analyzer::visit_edge): Same.\n\t(hybrid_folder::value_of_expr): Same.\n\t(hybrid_folder::value_on_edge): Same.\n\t* value-pointer-equiv.cc: New file.\n\t* value-pointer-equiv.h: New file.", "tree": {"sha": "948c65db71bcb31c0c6ade4a01a409e9c1e55e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/948c65db71bcb31c0c6ade4a01a409e9c1e55e6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/924326b3e0d75dbb246a4fbabfdd8be417788db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924326b3e0d75dbb246a4fbabfdd8be417788db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924326b3e0d75dbb246a4fbabfdd8be417788db8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924326b3e0d75dbb246a4fbabfdd8be417788db8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f6a6c91d7c592cb49f7c519f289777eac09bb74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6a6c91d7c592cb49f7c519f289777eac09bb74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6a6c91d7c592cb49f7c519f289777eac09bb74"}], "stats": {"total": 667, "additions": 370, "deletions": 297}, "files": [{"sha": "f3877128524c6252950f0064cbe37995d49c3353", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=924326b3e0d75dbb246a4fbabfdd8be417788db8", "patch": "@@ -1698,6 +1698,7 @@ OBJS = \\\n \ttyped-splay-tree.o \\\n \tunique-ptr-tests.o \\\n \tvaltrack.o \\\n+\tvalue-pointer-equiv.o \\\n \tvalue-query.o \\\n \tvalue-range.o \\\n \tvalue-range-equiv.o \\"}, {"sha": "254542ef4ccb7c39e3bdb444d947e401fcdeffa1", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 5, "deletions": 297, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=924326b3e0d75dbb246a4fbabfdd8be417788db8", "patch": "@@ -43,299 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa-evrp-analyze.h\"\n #include \"gimple-range.h\"\n #include \"fold-const.h\"\n-\n-// Unwindable SSA equivalence table for pointers.\n-//\n-// The main query point is get_replacement() which returns what a\n-// given SSA can be replaced with in the current scope.\n-\n-class ssa_equiv_stack\n-{\n-public:\n-  ssa_equiv_stack ();\n-  void enter (basic_block);\n-  void leave (basic_block);\n-  void push_replacement (tree name, tree replacement);\n-  tree get_replacement (tree name) const;\n-\n-private:\n-  auto_vec<std::pair <tree, tree>> m_stack;\n-  auto_vec<tree> m_replacements;\n-  const std::pair <tree, tree> m_marker = std::make_pair (NULL, NULL);\n-};\n-\n-ssa_equiv_stack::ssa_equiv_stack ()\n-{\n-  m_replacements.safe_grow_cleared (num_ssa_names);\n-}\n-\n-// Pushes a marker at the given point.\n-\n-void\n-ssa_equiv_stack::enter (basic_block)\n-{\n-  m_stack.safe_push (m_marker);\n-}\n-\n-// Pops the stack to the last marker, while performing replacements\n-// along the way.\n-\n-void\n-ssa_equiv_stack::leave (basic_block)\n-{\n-  gcc_checking_assert (!m_stack.is_empty ());\n-  while (m_stack.last () != m_marker)\n-    {\n-      std::pair<tree, tree> e = m_stack.pop ();\n-      m_replacements[SSA_NAME_VERSION (e.first)] = e.second;\n-    }\n-  m_stack.pop ();\n-}\n-\n-// Set the equivalence of NAME to REPLACEMENT.\n-\n-void\n-ssa_equiv_stack::push_replacement (tree name, tree replacement)\n-{\n-  tree old = m_replacements[SSA_NAME_VERSION (name)];\n-  m_replacements[SSA_NAME_VERSION (name)] = replacement;\n-  m_stack.safe_push (std::make_pair (name, old));\n-}\n-\n-// Return the equivalence of NAME.\n-\n-tree\n-ssa_equiv_stack::get_replacement (tree name) const\n-{\n-  return m_replacements[SSA_NAME_VERSION (name)];\n-}\n-\n-// Return TRUE if EXPR is an SSA holding a pointer.\n-\n-static bool inline\n-is_pointer_ssa (tree expr)\n-{\n-  return TREE_CODE (expr) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (expr));\n-}\n-\n-// Simple context-aware pointer equivalency analyzer that returns what\n-// a pointer SSA name is equivalent to at a given point during a walk\n-// of the IL.\n-//\n-// Note that global equivalency take priority over conditional\n-// equivalency.  That is, p = &q takes priority over a later p == &t.\n-//\n-// This class is meant to be called during a DOM walk.\n-\n-class pointer_equiv_analyzer\n-{\n-public:\n-  pointer_equiv_analyzer (gimple_ranger *r);\n-  ~pointer_equiv_analyzer ();\n-  void enter (basic_block);\n-  void leave (basic_block);\n-  void visit_stmt (gimple *stmt);\n-  tree get_equiv (tree ssa) const;\n-\n-private:\n-  void visit_edge (edge e);\n-  tree get_equiv_expr (tree_code code, tree expr) const;\n-  void set_global_equiv (tree ssa, tree pointee);\n-  void set_cond_equiv (tree ssa, tree pointee);\n-\n-  gimple_ranger *m_ranger;\n-  // Global pointer equivalency indexed by SSA_NAME_VERSION.\n-  tree *m_global_points;\n-  // Conditional pointer equivalency.\n-  ssa_equiv_stack m_cond_points;\n-};\n-\n-pointer_equiv_analyzer::pointer_equiv_analyzer (gimple_ranger *r)\n-{\n-  m_ranger = r;\n-  m_global_points = new tree[num_ssa_names] ();\n-}\n-\n-pointer_equiv_analyzer::~pointer_equiv_analyzer ()\n-{\n-  delete[] m_global_points;\n-}\n-\n-// Set the global pointer equivalency for SSA to POINTEE.\n-\n-void\n-pointer_equiv_analyzer::set_global_equiv (tree ssa, tree pointee)\n-{\n-  m_global_points[SSA_NAME_VERSION (ssa)] = pointee;\n-}\n-\n-// Set the conditional pointer equivalency for SSA to POINTEE.\n-\n-void\n-pointer_equiv_analyzer::set_cond_equiv (tree ssa, tree pointee)\n-{\n-  m_cond_points.push_replacement (ssa, pointee);\n-}\n-\n-// Return the current pointer equivalency info for SSA, or NULL if\n-// none is available.  Note that global info takes priority over\n-// conditional info.\n-\n-tree\n-pointer_equiv_analyzer::get_equiv (tree ssa) const\n-{\n-  tree ret = m_global_points[SSA_NAME_VERSION (ssa)];\n-  if (ret)\n-    return ret;\n-  return m_cond_points.get_replacement (ssa);\n-}\n-\n-// Method to be called on entry to a BB.\n-\n-void\n-pointer_equiv_analyzer::enter (basic_block bb)\n-{\n-  m_cond_points.enter (bb);\n-\n-  for (gphi_iterator iter = gsi_start_phis (bb);\n-       !gsi_end_p (iter);\n-       gsi_next (&iter))\n-    {\n-      gphi *phi = iter.phi ();\n-      tree lhs = gimple_phi_result (phi);\n-      if (!POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\tcontinue;\n-      tree arg0 = gimple_phi_arg_def (phi, 0);\n-      if (TREE_CODE (arg0) == SSA_NAME && !is_gimple_min_invariant (arg0))\n-\targ0 = get_equiv (arg0);\n-      if (arg0 && is_gimple_min_invariant (arg0))\n-\t{\n-\t  // If all the PHI args point to the same place, set the\n-\t  // pointer equivalency info for the PHI result.  This can\n-\t  // happen for passes that create redundant PHIs like\n-\t  // PHI<&foo, &foo> or PHI<&foo>.\n-\t  for (size_t i = 1; i < gimple_phi_num_args (phi); ++i)\n-\t    {\n-\t      tree argi = gimple_phi_arg_def (phi, i);\n-\t      if (TREE_CODE (argi) == SSA_NAME\n-\t\t  && !is_gimple_min_invariant (argi))\n-\t\targi = get_equiv (argi);\n-\t      if (!argi || !operand_equal_p (arg0, argi))\n-\t\treturn;\n-\t    }\n-\t  set_global_equiv (lhs, arg0);\n-\t}\n-    }\n-\n-  edge pred = single_pred_edge_ignoring_loop_edges (bb, false);\n-  if (pred)\n-    visit_edge (pred);\n-}\n-\n-// Method to be called on exit from a BB.\n-\n-void\n-pointer_equiv_analyzer::leave (basic_block bb)\n-{\n-  m_cond_points.leave (bb);\n-}\n-\n-// Helper function to return the pointer equivalency information for\n-// EXPR from a gimple statement with CODE.  This returns either the\n-// cached pointer equivalency info for an SSA, or an invariant in case\n-// EXPR is one (i.e. &foo).  Returns NULL if EXPR is neither an SSA\n-// nor an invariant.\n-\n-tree\n-pointer_equiv_analyzer::get_equiv_expr (tree_code code, tree expr) const\n-{\n-  if (code == SSA_NAME)\n-    return get_equiv (expr);\n-\n-  if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS\n-      && is_gimple_min_invariant (expr))\n-    return expr;\n-\n-  return NULL;\n-}\n-\n-// Hack to provide context to the gimple fold callback.\n-static struct\n-{\n-  gimple *m_stmt;\n-  gimple_ranger *m_ranger;\n-  pointer_equiv_analyzer *m_pta;\n-} x_fold_context;\n-\n-// Gimple fold callback.\n-static tree\n-pta_valueize (tree name)\n-{\n-  tree ret\n-    = x_fold_context.m_ranger->value_of_expr (name, x_fold_context.m_stmt);\n-\n-  if (!ret && is_pointer_ssa (name))\n-    ret = x_fold_context.m_pta->get_equiv (name);\n-\n-  return ret ? ret : name;\n-}\n-\n-// Method to be called on gimple statements during traversal of the IL.\n-\n-void\n-pointer_equiv_analyzer::visit_stmt (gimple *stmt)\n-{\n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n-    return;\n-\n-  tree lhs = gimple_assign_lhs (stmt);\n-  if (!is_pointer_ssa (lhs))\n-    return;\n-\n-  tree rhs = gimple_assign_rhs1 (stmt);\n-  rhs = get_equiv_expr (gimple_assign_rhs_code (stmt), rhs);\n-  if (rhs)\n-    {\n-      set_global_equiv (lhs, rhs);\n-      return;\n-    }\n-\n-  // If we couldn't find anything, try fold.\n-  x_fold_context = { stmt, m_ranger, this};\n-  rhs = gimple_fold_stmt_to_constant_1 (stmt, pta_valueize, pta_valueize);\n-  if (rhs)\n-    {\n-      rhs = get_equiv_expr (TREE_CODE (rhs), rhs);\n-      if (rhs)\n-\t{\n-\t  set_global_equiv (lhs, rhs);\n-\t  return;\n-\t}\n-    }\n-}\n-\n-// If the edge in E is a conditional that sets a pointer equality, set the\n-// conditional pointer equivalency information.\n-\n-void\n-pointer_equiv_analyzer::visit_edge (edge e)\n-{\n-  gimple *stmt = last_stmt (e->src);\n-  tree lhs;\n-  // Recognize: x_13 [==,!=] &foo.\n-  if (stmt\n-      && gimple_code (stmt) == GIMPLE_COND\n-      && (lhs = gimple_cond_lhs (stmt))\n-      && TREE_CODE (lhs) == SSA_NAME\n-      && POINTER_TYPE_P (TREE_TYPE (lhs))\n-      && TREE_CODE (gimple_cond_rhs (stmt)) == ADDR_EXPR)\n-    {\n-      tree_code code = gimple_cond_code (stmt);\n-      if ((code == EQ_EXPR && e->flags & EDGE_TRUE_VALUE)\n-\t  || ((code == NE_EXPR && e->flags & EDGE_FALSE_VALUE)))\n-\tset_cond_equiv (lhs, gimple_cond_rhs (stmt));\n-    }\n-}\n+#include \"value-pointer-equiv.h\"\n \n // This is the classic EVRP folder which uses a dominator walk and pushes\n // ranges into the next block if it is a single predecessor block.\n@@ -430,15 +138,15 @@ class rvrp_folder : public substitute_and_fold_engine\n   tree value_of_expr (tree name, gimple *s = NULL) OVERRIDE\n   {\n     tree ret = m_ranger->value_of_expr (name, s);\n-    if (!ret && is_pointer_ssa (name))\n+    if (!ret && supported_pointer_equiv_p (name))\n       ret = m_pta->get_equiv (name);\n     return ret;\n   }\n \n   tree value_on_edge (edge e, tree name) OVERRIDE\n   {\n     tree ret = m_ranger->value_on_edge (e, name);\n-    if (!ret && is_pointer_ssa (name))\n+    if (!ret && supported_pointer_equiv_p (name))\n       ret = m_pta->get_equiv (name);\n     return ret;\n   }\n@@ -570,7 +278,7 @@ hybrid_folder::value_of_expr (tree op, gimple *stmt)\n {\n   tree evrp_ret = evrp_folder::value_of_expr (op, stmt);\n   tree ranger_ret = m_ranger->value_of_expr (op, stmt);\n-  if (!ranger_ret && is_pointer_ssa (op))\n+  if (!ranger_ret && supported_pointer_equiv_p (op))\n     ranger_ret = m_pta->get_equiv (op);\n   return choose_value (evrp_ret, ranger_ret);\n }\n@@ -582,7 +290,7 @@ hybrid_folder::value_on_edge (edge e, tree op)\n   // via hybrid_folder::value_of_expr, but without an edge.\n   tree evrp_ret = evrp_folder::value_of_expr (op, NULL);\n   tree ranger_ret = m_ranger->value_on_edge (e, op);\n-  if (!ranger_ret && is_pointer_ssa (op))\n+  if (!ranger_ret && supported_pointer_equiv_p (op))\n     ranger_ret = m_pta->get_equiv (op);\n   return choose_value (evrp_ret, ranger_ret);\n }"}, {"sha": "7d2658b77a49b2e59f5b5a4e4ee7366f3c55dd5d", "filename": "gcc/value-pointer-equiv.cc", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2Fvalue-pointer-equiv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2Fvalue-pointer-equiv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-pointer-equiv.cc?ref=924326b3e0d75dbb246a4fbabfdd8be417788db8", "patch": "@@ -0,0 +1,302 @@\n+/* Context-aware pointer equivalence tracker.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfganal.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"alloc-pool.h\"\n+#include \"domwalk.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n+#include \"gimple-range.h\"\n+#include \"fold-const.h\"\n+#include \"value-pointer-equiv.h\"\n+\n+// Unwindable SSA equivalence table for pointers.\n+//\n+// The main query point is get_replacement() which returns what a\n+// given SSA can be replaced with in the current scope.\n+\n+class ssa_equiv_stack\n+{\n+public:\n+  ssa_equiv_stack ();\n+  void enter (basic_block);\n+  void leave (basic_block);\n+  void push_replacement (tree name, tree replacement);\n+  tree get_replacement (tree name) const;\n+\n+private:\n+  auto_vec<std::pair <tree, tree>> m_stack;\n+  auto_vec<tree> m_replacements;\n+  const std::pair <tree, tree> m_marker = std::make_pair (NULL, NULL);\n+};\n+\n+ssa_equiv_stack::ssa_equiv_stack ()\n+{\n+  m_replacements.safe_grow_cleared (num_ssa_names);\n+}\n+\n+// Pushes a marker at the given point.\n+\n+void\n+ssa_equiv_stack::enter (basic_block)\n+{\n+  m_stack.safe_push (m_marker);\n+}\n+\n+// Pops the stack to the last marker, while performing replacements\n+// along the way.\n+\n+void\n+ssa_equiv_stack::leave (basic_block)\n+{\n+  gcc_checking_assert (!m_stack.is_empty ());\n+  while (m_stack.last () != m_marker)\n+    {\n+      std::pair<tree, tree> e = m_stack.pop ();\n+      m_replacements[SSA_NAME_VERSION (e.first)] = e.second;\n+    }\n+  m_stack.pop ();\n+}\n+\n+// Set the equivalence of NAME to REPLACEMENT.\n+\n+void\n+ssa_equiv_stack::push_replacement (tree name, tree replacement)\n+{\n+  tree old = m_replacements[SSA_NAME_VERSION (name)];\n+  m_replacements[SSA_NAME_VERSION (name)] = replacement;\n+  m_stack.safe_push (std::make_pair (name, old));\n+}\n+\n+// Return the equivalence of NAME.\n+\n+tree\n+ssa_equiv_stack::get_replacement (tree name) const\n+{\n+  return m_replacements[SSA_NAME_VERSION (name)];\n+}\n+\n+pointer_equiv_analyzer::pointer_equiv_analyzer (gimple_ranger *r)\n+{\n+  m_ranger = r;\n+  m_global_points = new tree[num_ssa_names] ();\n+  m_cond_points = new ssa_equiv_stack;\n+}\n+\n+pointer_equiv_analyzer::~pointer_equiv_analyzer ()\n+{\n+  delete[] m_global_points;\n+  delete m_cond_points;\n+}\n+\n+// Set the global pointer equivalency for SSA to POINTEE.\n+\n+void\n+pointer_equiv_analyzer::set_global_equiv (tree ssa, tree pointee)\n+{\n+  m_global_points[SSA_NAME_VERSION (ssa)] = pointee;\n+}\n+\n+// Set the conditional pointer equivalency for SSA to POINTEE.\n+\n+void\n+pointer_equiv_analyzer::set_cond_equiv (tree ssa, tree pointee)\n+{\n+  m_cond_points->push_replacement (ssa, pointee);\n+}\n+\n+// Return the current pointer equivalency info for SSA, or NULL if\n+// none is available.  Note that global info takes priority over\n+// conditional info.\n+\n+tree\n+pointer_equiv_analyzer::get_equiv (tree ssa) const\n+{\n+  tree ret = m_global_points[SSA_NAME_VERSION (ssa)];\n+  if (ret)\n+    return ret;\n+  return m_cond_points->get_replacement (ssa);\n+}\n+\n+// Method to be called on entry to a BB.\n+\n+void\n+pointer_equiv_analyzer::enter (basic_block bb)\n+{\n+  m_cond_points->enter (bb);\n+\n+  for (gphi_iterator iter = gsi_start_phis (bb);\n+       !gsi_end_p (iter);\n+       gsi_next (&iter))\n+    {\n+      gphi *phi = iter.phi ();\n+      tree lhs = gimple_phi_result (phi);\n+      if (!POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\tcontinue;\n+      tree arg0 = gimple_phi_arg_def (phi, 0);\n+      if (TREE_CODE (arg0) == SSA_NAME && !is_gimple_min_invariant (arg0))\n+\targ0 = get_equiv (arg0);\n+      if (arg0 && is_gimple_min_invariant (arg0))\n+\t{\n+\t  // If all the PHI args point to the same place, set the\n+\t  // pointer equivalency info for the PHI result.  This can\n+\t  // happen for passes that create redundant PHIs like\n+\t  // PHI<&foo, &foo> or PHI<&foo>.\n+\t  for (size_t i = 1; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      tree argi = gimple_phi_arg_def (phi, i);\n+\t      if (TREE_CODE (argi) == SSA_NAME\n+\t\t  && !is_gimple_min_invariant (argi))\n+\t\targi = get_equiv (argi);\n+\t      if (!argi || !operand_equal_p (arg0, argi))\n+\t\treturn;\n+\t    }\n+\t  set_global_equiv (lhs, arg0);\n+\t}\n+    }\n+\n+  edge pred = single_pred_edge_ignoring_loop_edges (bb, false);\n+  if (pred)\n+    visit_edge (pred);\n+}\n+\n+// Method to be called on exit from a BB.\n+\n+void\n+pointer_equiv_analyzer::leave (basic_block bb)\n+{\n+  m_cond_points->leave (bb);\n+}\n+\n+// Helper function to return the pointer equivalency information for\n+// EXPR from a gimple statement with CODE.  This returns either the\n+// cached pointer equivalency info for an SSA, or an invariant in case\n+// EXPR is one (i.e. &foo).  Returns NULL if EXPR is neither an SSA\n+// nor an invariant.\n+\n+tree\n+pointer_equiv_analyzer::get_equiv_expr (tree_code code, tree expr) const\n+{\n+  if (code == SSA_NAME)\n+    return get_equiv (expr);\n+\n+  if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS\n+      && is_gimple_min_invariant (expr))\n+    return expr;\n+\n+  return NULL;\n+}\n+\n+// Hack to provide context to the gimple fold callback.\n+static struct\n+{\n+  gimple *m_stmt;\n+  gimple_ranger *m_ranger;\n+  pointer_equiv_analyzer *m_pta;\n+} x_fold_context;\n+\n+// Gimple fold callback.\n+static tree\n+pta_valueize (tree name)\n+{\n+  tree ret\n+    = x_fold_context.m_ranger->value_of_expr (name, x_fold_context.m_stmt);\n+\n+  if (!ret && supported_pointer_equiv_p (name))\n+    ret = x_fold_context.m_pta->get_equiv (name);\n+\n+  return ret ? ret : name;\n+}\n+\n+// Method to be called on gimple statements during traversal of the IL.\n+\n+void\n+pointer_equiv_analyzer::visit_stmt (gimple *stmt)\n+{\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+    return;\n+\n+  tree lhs = gimple_assign_lhs (stmt);\n+  if (!supported_pointer_equiv_p (lhs))\n+    return;\n+\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  rhs = get_equiv_expr (gimple_assign_rhs_code (stmt), rhs);\n+  if (rhs)\n+    {\n+      set_global_equiv (lhs, rhs);\n+      return;\n+    }\n+\n+  // If we couldn't find anything, try fold.\n+  x_fold_context = { stmt, m_ranger, this};\n+  rhs = gimple_fold_stmt_to_constant_1 (stmt, pta_valueize, pta_valueize);\n+  if (rhs)\n+    {\n+      rhs = get_equiv_expr (TREE_CODE (rhs), rhs);\n+      if (rhs)\n+\t{\n+\t  set_global_equiv (lhs, rhs);\n+\t  return;\n+\t}\n+    }\n+}\n+\n+// If the edge in E is a conditional that sets a pointer equality, set the\n+// conditional pointer equivalency information.\n+\n+void\n+pointer_equiv_analyzer::visit_edge (edge e)\n+{\n+  gimple *stmt = last_stmt (e->src);\n+  tree lhs;\n+  // Recognize: x_13 [==,!=] &foo.\n+  if (stmt\n+      && gimple_code (stmt) == GIMPLE_COND\n+      && (lhs = gimple_cond_lhs (stmt))\n+      && TREE_CODE (lhs) == SSA_NAME\n+      && POINTER_TYPE_P (TREE_TYPE (lhs))\n+      && TREE_CODE (gimple_cond_rhs (stmt)) == ADDR_EXPR)\n+    {\n+      tree_code code = gimple_cond_code (stmt);\n+      if ((code == EQ_EXPR && e->flags & EDGE_TRUE_VALUE)\n+\t  || ((code == NE_EXPR && e->flags & EDGE_FALSE_VALUE)))\n+\tset_cond_equiv (lhs, gimple_cond_rhs (stmt));\n+    }\n+}"}, {"sha": "0921579d52a40bf0c873194e70c3562e41b5acd8", "filename": "gcc/value-pointer-equiv.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2Fvalue-pointer-equiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/924326b3e0d75dbb246a4fbabfdd8be417788db8/gcc%2Fvalue-pointer-equiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-pointer-equiv.h?ref=924326b3e0d75dbb246a4fbabfdd8be417788db8", "patch": "@@ -0,0 +1,62 @@\n+/* Header file for the context-aware pointer equivalence tracker.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VALUE_POINTER_EQUIV_H\n+#define GCC_VALUE_POINTER_EQUIV_H\n+\n+// Simple context-aware pointer equivalency analyzer that returns what\n+// a pointer SSA name is equivalent to at a given point during a walk\n+// of the IL.\n+//\n+// Note that global equivalency take priority over conditional\n+// equivalency.  That is, p = &q takes priority over a later p == &t.\n+//\n+// This class is meant to be called during a DOM walk.\n+\n+class pointer_equiv_analyzer\n+{\n+public:\n+  pointer_equiv_analyzer (gimple_ranger *r);\n+  ~pointer_equiv_analyzer ();\n+  void enter (basic_block);\n+  void leave (basic_block);\n+  void visit_stmt (gimple *stmt);\n+  tree get_equiv (tree ssa) const;\n+\n+private:\n+  void visit_edge (edge e);\n+  tree get_equiv_expr (tree_code code, tree expr) const;\n+  void set_global_equiv (tree ssa, tree pointee);\n+  void set_cond_equiv (tree ssa, tree pointee);\n+\n+  gimple_ranger *m_ranger;\n+  // Global pointer equivalency indexed by SSA_NAME_VERSION.\n+  tree *m_global_points;\n+  // Conditional pointer equivalency.\n+  class ssa_equiv_stack *m_cond_points;\n+};\n+\n+inline bool\n+supported_pointer_equiv_p (tree expr)\n+{\n+  return TREE_CODE (expr) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (expr));\n+}\n+\n+#endif // GCC_VALUE_POINTER_EQUIV_H"}]}