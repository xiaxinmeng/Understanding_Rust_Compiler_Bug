{"sha": "7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyYTI1YWI0ZjMwY2M4MzFjMjdmNmY1Y2YyMmZjNGJlODU4ZDBhNQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-02-23T04:49:21Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-02-23T04:49:21Z"}, "message": "builtins.c (fold_builtin_frexp): New.\n\n\t* builtins.c (fold_builtin_frexp): New.\n\t(fold_builtin_2): Use it.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-frexp-1.c: New test.\n\nFrom-SVN: r122249", "tree": {"sha": "9706519ce079df42783b918a0128eb2ee24cb68c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9706519ce079df42783b918a0128eb2ee24cb68c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/comments", "author": null, "committer": null, "parents": [{"sha": "03d12b648e5fe9cafe390deac7918e22b032322f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d12b648e5fe9cafe390deac7918e22b032322f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d12b648e5fe9cafe390deac7918e22b032322f"}], "stats": {"total": 186, "additions": 186, "deletions": 0}, "files": [{"sha": "cd1e85d088142ac9d747a4fc46f071a71e5f739e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "patch": "@@ -1,3 +1,8 @@\n+2007-02-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (fold_builtin_frexp): New.\n+\t(fold_builtin_2): Use it.\n+\n 2007-02-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* doc/invoke.texi (Spec Files): Document getenv spec function."}, {"sha": "5c6dd4d930cf27075d0081c7f5dfe6cee4caff2f", "filename": "gcc/builtins.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "patch": "@@ -9017,6 +9017,62 @@ fold_builtin_carg (tree arg, tree type)\n   return NULL_TREE;\n }\n \n+/* Fold a call to builtin frexp, we can assume the base is 2.  */\n+\n+static tree\n+fold_builtin_frexp (tree arg0, tree arg1, tree rettype)\n+{\n+  if (! validate_arg (arg0, REAL_TYPE) || ! validate_arg (arg1, POINTER_TYPE))\n+    return NULL_TREE;\n+  \n+  STRIP_NOPS (arg0);\n+      \n+  if (!(TREE_CODE (arg0) == REAL_CST && ! TREE_OVERFLOW (arg0)))\n+    return NULL_TREE;\n+  \n+  arg1 = build_fold_indirect_ref (arg1);\n+\n+  /* Proceed if a valid pointer type was passed in.  */\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (arg1)) == integer_type_node)\n+    {\n+      const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg0);\n+      tree frac, exp;\n+\t  \n+      switch (value->cl)\n+      {\n+      case rvc_zero:\n+\t/* For +-0, return (*exp = 0, +-0).  */\n+\texp = integer_zero_node;\n+\tfrac = arg0;\n+\tbreak;\n+      case rvc_nan:\n+      case rvc_inf:\n+\t/* For +-NaN or +-Inf, *exp is unspecified, return arg0.  */\n+\treturn omit_one_operand (rettype, arg0, arg1);\n+      case rvc_normal:\n+\t{\n+\t  /* Since the frexp function always expects base 2, and in\n+\t     GCC normalized significands are already in the range\n+\t     [0.5, 1.0), we have exactly what frexp wants.  */\n+\t  REAL_VALUE_TYPE frac_rvt = *value;\n+\t  SET_REAL_EXP (&frac_rvt, 0);\n+\t  frac = build_real (rettype, frac_rvt);\n+\t  exp = build_int_cst (NULL_TREE, REAL_EXP (value));\n+\t}\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\t\t\n+      /* Create the COMPOUND_EXPR (*arg1 = trunc, frac). */\n+      arg1 = fold_build2 (MODIFY_EXPR, rettype, arg1, exp);\n+      TREE_SIDE_EFFECTS (arg1) = 1;\n+      return fold_build2 (COMPOUND_EXPR, rettype, arg1, frac);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold a call to builtin ldexp or scalbn/scalbln.  If LDEXP is true\n    then we can assume the base is two.  If it's false, then we have to\n    check the mode of the TYPE parameter in certain cases.  */\n@@ -9544,6 +9600,9 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n     CASE_FLT_FN (BUILT_IN_SCALBLN):\n       return fold_builtin_load_exponent (arg0, arg1, type, /*ldexp=*/false);\n \n+    CASE_FLT_FN (BUILT_IN_FREXP):\n+      return fold_builtin_frexp (arg0, arg1, type);\n+\n     case BUILT_IN_BZERO:\n       return fold_builtin_bzero (arg0, arg1, ignore);\n "}, {"sha": "dd2deb419b4f29ac3d2a9d04c399e3d74d0b610c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "patch": "@@ -1,3 +1,7 @@\n+2007-02-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-frexp-1.c: New test.\n+\n 2007-02-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/opt/switch4.C: Pass -fshort-enums -w."}, {"sha": "d0662d77444bd83a612732a8d18e47cc14c60db5", "filename": "gcc/testsuite/gcc.dg/torture/builtin-frexp-1.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-frexp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-frexp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-frexp-1.c?ref=7a2a25ab4f30cc831c27f6f5cf22fc4be858d0a5", "patch": "@@ -0,0 +1,118 @@\n+/* Copyright (C) 2007  Free Software Foundation.\n+\n+   Verify that built-in folding of frexp is correctly performed by the\n+   compiler.\n+\n+   Origin: Kaveh R. Ghazi,  February 21, 2007.  */\n+\n+/* { dg-do link } */\n+\n+extern void link_error(int);\n+\n+/* Return TRUE if the sign of X != sign of Y.  This is important when\n+   comparing signed zeros.  */\n+#define CKSGN_F(X,Y) \\\n+  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+#define CKSGN(X,Y) \\\n+  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+#define CKSGN_L(X,Y) \\\n+  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+\n+/* We can only check the exponent when optimizing since we rely on\n+   other optimizations to propagate the value.  TRUE means an error\n+   occurred.  */\n+#ifdef __OPTIMIZE__\n+#define CKEXP(X,Y) X != Y\n+#else\n+#define CKEXP(X,Y) 0\n+#endif\n+\n+/* Test that frexp(ARG,&i) == RES && i == EXP.  Check the sign in\n+   case we get -0.0.  */\n+#define TESTIT_FREXP(ARG,RES,EXP) do { \\\n+  int i = 123456; \\\n+  if (__builtin_frexpf(ARG##f,&i) != RES##f \\\n+      || CKEXP(i,EXP) \\\n+      || CKSGN_F(__builtin_frexpf(ARG##f,&i),RES##f)) \\\n+    link_error(__LINE__); \\\n+  i = 123456; \\\n+  if (__builtin_frexp(ARG,&i) != RES \\\n+      || CKEXP(i,EXP) \\\n+      || CKSGN(__builtin_frexp(ARG,&i),RES)) \\\n+    link_error(__LINE__); \\\n+  i = 123456; \\\n+  if (__builtin_frexpl(ARG##l,&i) != RES##l \\\n+      || CKEXP(i,EXP) \\\n+      || CKSGN_L(__builtin_frexpl(ARG##l,&i),RES##l)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that FUNCRES(frexp(NEG FUNCARG(ARGARG),&i)) is false.  Check\n+   the sign as well.  Ensure side-effects are evaluated in i.  */\n+#define TESTIT_FREXP2(NEG,FUNCARG,ARGARG,FUNCRES) do { \\\n+  int i=5; \\\n+  if (!__builtin_##FUNCRES##f(__builtin_frexpf(NEG __builtin_##FUNCARG##f(ARGARG),&i)) \\\n+      || CKSGN_F(__builtin_frexpf(NEG __builtin_##FUNCARG##f(ARGARG),(i++,&i)), NEG __builtin_##FUNCARG##f(ARGARG)) \\\n+      || CKEXP(i,6)) \\\n+    link_error(__LINE__); \\\n+  if (!__builtin_##FUNCRES(__builtin_frexp(NEG __builtin_##FUNCARG(ARGARG),&i)) \\\n+      || CKSGN(__builtin_frexp(NEG __builtin_##FUNCARG(ARGARG),(i++,&i)), NEG __builtin_##FUNCARG(ARGARG)) \\\n+      || CKEXP(i,7)) \\\n+    link_error(__LINE__); \\\n+  if (!__builtin_##FUNCRES##l(__builtin_frexpl(NEG __builtin_##FUNCARG##l(ARGARG),&i)) \\\n+      || CKSGN_L(__builtin_frexpl(NEG __builtin_##FUNCARG##l(ARGARG),(i++,&i)), NEG __builtin_##FUNCARG##l(ARGARG)) \\\n+      || CKEXP(i,8)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+void __attribute__ ((__noinline__))\n+foo(void)\n+{\n+  /* Test that frexp(ARG1,&i) -> ARG2 && i == ARG3.  */\n+  TESTIT_FREXP (-0x1p40, -0.5, 41);\n+  TESTIT_FREXP (-0x1p30, -0.5, 31);\n+  TESTIT_FREXP (-0x1p20, -0.5, 21);\n+  TESTIT_FREXP (-0x1p10, -0.5, 11);\n+  TESTIT_FREXP (-0x1p5, -0.5, 6);\n+  TESTIT_FREXP (-100/3.0, -100/192.0, 6);\n+  TESTIT_FREXP (-1.5, -0.75, 1);\n+  TESTIT_FREXP (-1.0, -0.5, 1);\n+  TESTIT_FREXP (-1/3.0, -2/3.0, -1);\n+  TESTIT_FREXP (-1/9.0, -8/9.0, -3);\n+  TESTIT_FREXP (-0x1p-5, -0.5, -4);\n+  TESTIT_FREXP (-0x1p-10, -0.5, -9);\n+  TESTIT_FREXP (-0x1p-20, -0.5, -19);\n+  TESTIT_FREXP (-0x1p-30, -0.5, -29);\n+  TESTIT_FREXP (-0x1p-40, -0.5, -39);\n+  TESTIT_FREXP (-0.0, -0.0, 0);\n+  TESTIT_FREXP (0.0, 0.0, 0);\n+  TESTIT_FREXP (0x1p-40, 0.5, -39);\n+  TESTIT_FREXP (0x1p-30, 0.5, -29);\n+  TESTIT_FREXP (0x1p-20, 0.5, -19);\n+  TESTIT_FREXP (0x1p-10, 0.5, -9);\n+  TESTIT_FREXP (0x1p-5, 0.5, -4);\n+  TESTIT_FREXP (1/9.0, 8/9.0, -3);\n+  TESTIT_FREXP (1/3.0, 2/3.0, -1);\n+  TESTIT_FREXP (1.0, 0.5, 1);\n+  TESTIT_FREXP (1.5, 0.75, 1);\n+  TESTIT_FREXP (100/3.0, 100/192.0, 6);\n+  TESTIT_FREXP (0x1p5, 0.5, 6);\n+  TESTIT_FREXP (0x1p10, 0.5, 11);\n+  TESTIT_FREXP (0x1p20, 0.5, 21);\n+  TESTIT_FREXP (0x1p30, 0.5, 31);\n+  TESTIT_FREXP (0x1p40, 0.5, 41);\n+\n+  /* Test for frexp(+-Inf,&i) -> +-Inf and frexp(+-NaN,&i) -> +-NaN.\n+     Exponent is left unspecified, but we test for side-effects.  */\n+  TESTIT_FREXP2 ( ,inf, , isinf);\n+  TESTIT_FREXP2 (- ,inf, , isinf);\n+  TESTIT_FREXP2 ( ,nan, \"\", isnan);\n+  TESTIT_FREXP2 (- ,nan, \"\", isnan);\n+}\n+\n+int main()\n+{\n+  foo ();\n+  \n+  return 0;\n+}"}]}