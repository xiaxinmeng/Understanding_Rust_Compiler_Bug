{"sha": "34050b6bee181a12099a9bc31a4d25469573bc6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwNTBiNmJlZTE4MWExMjA5OWE5YmMzMWE0ZDI1NDY5NTczYmM2ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-01T07:54:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-01T07:54:26Z"}, "message": "gimple-match.h (mprts_hook): Declare.\n\n2015-10-01  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-match.h (mprts_hook): Declare.\n\t* gimple-match.head.c (mprts_hook): Define.\n\t(maybe_push_res_to_seq): Use new hook.\n\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Likewise.\n\t* tree-ssa-sccvn.h (vn_ssa_aux::expr): Change to a gimple_seq.\n\t(vn_ssa_aux::has_constants): Remove.\n\t* tree-ssa-sccvn.c: Include gimple-match.h.\n\t(VN_INFO_GET): Assert we don't re-use SSA names.\n\t(vn_get_expr_for): Remove.\n\t(expr_has_constants): Likewise.\n\t(stmt_has_constants): Likewise.\n\t(simplify_binary_expression): Likewise.\n\t(simplify_unary_expression): Likewise.\n\t(vn_lookup_simplify_result): New hook.\n\t(visit_copy): Adjust.\n\t(visit_reference_op_call): Likewise.\n\t(visit_phi): Likewise.\n\t(visit_use): Likewise.\n\t(process_scc): Likewise.\n\t(init_scc_vn): Likewise.\n\t(visit_reference_op_load): Likewise.  Use match-and-simplify and\n\ta gimple seq for inserted expressions.\n\t(try_to_simplify): Remove GENERIC stmt combining code.\n\t(sccvn_dom_walker::before_dom_children): Use match-and-simplify.\n\t* tree-ssa-pre.c (eliminate_insert): Adjust.\n\t(eliminate_dom_walker::before_dom_children): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-fre-7.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-fre-8.c: Likewise.\n\nFrom-SVN: r228320", "tree": {"sha": "84b464b97cc715dd2e30f73f4fc420d296b60500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84b464b97cc715dd2e30f73f4fc420d296b60500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34050b6bee181a12099a9bc31a4d25469573bc6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34050b6bee181a12099a9bc31a4d25469573bc6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34050b6bee181a12099a9bc31a4d25469573bc6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34050b6bee181a12099a9bc31a4d25469573bc6d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e01c66ca3083cf998d7e2f568ff6227f86727499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01c66ca3083cf998d7e2f568ff6227f86727499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01c66ca3083cf998d7e2f568ff6227f86727499"}], "stats": {"total": 599, "additions": 148, "deletions": 451}, "files": [{"sha": "122f3b410dce330166a2b1846568fcbe31325fd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -1,3 +1,32 @@\n+2015-10-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-match.h (mprts_hook): Declare.\n+\t* gimple-match.head.c (mprts_hook): Define.\n+\t(maybe_push_res_to_seq): Use new hook.\n+\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Likewise.\n+\t* tree-ssa-sccvn.h (vn_ssa_aux::expr): Change to a gimple_seq.\n+\t(vn_ssa_aux::has_constants): Remove.\n+\t* tree-ssa-sccvn.c: Include gimple-match.h.\n+\t(VN_INFO_GET): Assert we don't re-use SSA names.\n+\t(vn_get_expr_for): Remove.\n+\t(expr_has_constants): Likewise.\n+\t(stmt_has_constants): Likewise.\n+\t(simplify_binary_expression): Likewise.\n+\t(simplify_unary_expression): Likewise.\n+\t(vn_lookup_simplify_result): New hook.\n+\t(visit_copy): Adjust.\n+\t(visit_reference_op_call): Likewise.\n+\t(visit_phi): Likewise.\n+\t(visit_use): Likewise.\n+\t(process_scc): Likewise.\n+\t(init_scc_vn): Likewise.\n+\t(visit_reference_op_load): Likewise.  Use match-and-simplify and\n+\ta gimple seq for inserted expressions.\n+\t(try_to_simplify): Remove GENERIC stmt combining code.\n+\t(sccvn_dom_walker::before_dom_children): Use match-and-simplify.\n+\t* tree-ssa-pre.c (eliminate_insert): Adjust.\n+\t(eliminate_dom_walker::before_dom_children): Likewise.\n+\n 2015-10-01  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* doc/invoke.texi (Optimization Options): Add"}, {"sha": "9f5e4e99a2c7cbff9f748ea58751ccc0bfa4b03c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -4877,22 +4877,28 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n      edges if there are intermediate VARYING defs.  For this reason\n      do not follow SSA edges here even though SCCVN can technically\n      just deal fine with that.  */\n-  if (gimple_simplify (stmt, &rcode, ops, NULL, gvalueize, valueize)\n-      && rcode.is_tree_code ()\n-      && (TREE_CODE_LENGTH ((tree_code) rcode) == 0\n-\t  || ((tree_code) rcode) == ADDR_EXPR)\n-      && is_gimple_val (ops[0]))\n-    {\n-      tree res = ops[0];\n-      if (dump_file && dump_flags & TDF_DETAILS)\n+  if (gimple_simplify (stmt, &rcode, ops, NULL, gvalueize, valueize))\n+    {\n+      tree res = NULL_TREE;\n+      if (rcode.is_tree_code ()\n+\t  && (TREE_CODE_LENGTH ((tree_code) rcode) == 0\n+\t      || ((tree_code) rcode) == ADDR_EXPR)\n+\t  && is_gimple_val (ops[0]))\n+\tres = ops[0];\n+      else if (mprts_hook)\n+\tres = mprts_hook (rcode, gimple_expr_type (stmt), ops);\n+      if (res)\n \t{\n-\t  fprintf (dump_file, \"Match-and-simplified \");\n-\t  print_gimple_expr (dump_file, stmt, 0, TDF_SLIM);\n-\t  fprintf (dump_file, \" to \");\n-\t  print_generic_expr (dump_file, res, 0);\n-\t  fprintf (dump_file, \"\\n\");\n+\t  if (dump_file && dump_flags & TDF_DETAILS)\n+\t    {\n+\t      fprintf (dump_file, \"Match-and-simplified \");\n+\t      print_gimple_expr (dump_file, stmt, 0, TDF_SLIM);\n+\t      fprintf (dump_file, \" to \");\n+\t      print_generic_expr (dump_file, res, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return res;\n \t}\n-      return res;\n     }\n \n   location_t loc = gimple_location (stmt);"}, {"sha": "cab77a4e18db931e2df5a1f1e7f09eab5a48966f", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -293,6 +293,8 @@ maybe_build_generic_op (enum tree_code code, tree type,\n     }\n }\n \n+tree (*mprts_hook) (code_helper, tree, tree *);\n+\n /* Push the exploded expression described by RCODE, TYPE and OPS\n    as a statement to SEQ if necessary and return a gimple value\n    denoting the value of the expression.  If RES is not NULL\n@@ -310,6 +312,12 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n \t      || ((tree_code) rcode) == ADDR_EXPR)\n \t  && is_gimple_val (ops[0]))\n \treturn ops[0];\n+      if (mprts_hook)\n+\t{\n+\t  tree tem = mprts_hook (rcode, type, ops);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n       if (!seq)\n \treturn NULL_TREE;\n       /* Play safe and do not allow abnormals to be mentioned in"}, {"sha": "4663a34b8f9d0ede5a5cb4cbd1b94d5b7b5e8736", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -40,6 +40,8 @@ class code_helper\n   int rep;\n };\n \n+extern tree (*mprts_hook) (code_helper, tree, tree *);\n+\n bool gimple_simplify (gimple *, code_helper *, tree *, gimple_seq *,\n \t\t      tree (*)(tree), tree (*)(tree));\n tree maybe_push_res_to_seq (code_helper, tree, tree *,"}, {"sha": "a8a3481389abfcf55185f26771f165df9a05f527", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -1,3 +1,8 @@\n+2015-10-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-fre-7.c: Adjust.\n+\t* gcc.dg/tree-ssa/ssa-fre-8.c: Likewise.\n+\n 2015-09-30  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/ssa-dom-branch-1.c: New test."}, {"sha": "2b2353172cfc23e196a5cc43d33914f5d3d3a368", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-7.c?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -29,8 +29,8 @@ intflt foo(intflt j)\n   return a.u.k;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Inserted pretmp\" 1 \"fre1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Replaced a.u.f with pretmp\" 3 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inserted\" 1 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replaced a.u.f with\" 3 \"fre1\" } } */\n /* { dg-final { scan-tree-dump-times \"Replaced a.u.k with j\" 1 \"fre1\" } } */\n /* { dg-final { scan-tree-dump \"= VIEW_CONVERT_EXPR<float>\\\\\\(j_\" \"fre1\" } } */\n /* { dg-final { scan-tree-dump \"return j\" \"optimized\" } } */"}, {"sha": "1a537d8beeaf8b8b2ce920a4792bad91ab11e540", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-8.c?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -28,5 +28,5 @@ intflt foo(int i, int b)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replaced u.f with pretmp\" 2 \"fre1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Inserted pretmp\" 2 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replaced u.f with\" 2 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inserted\" 2 \"fre1\" } } */"}, {"sha": "f8feaa19c16ba9414951a408e57b4a67b099b5b1", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -3945,21 +3945,23 @@ eliminate_push_avail (tree op)\n static tree\n eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n {\n-  tree expr = vn_get_expr_for (val);\n-  if (!CONVERT_EXPR_P (expr)\n-      && TREE_CODE (expr) != VIEW_CONVERT_EXPR)\n+  gimple *stmt = gimple_seq_first_stmt (VN_INFO (val)->expr);\n+  if (!is_gimple_assign (stmt)\n+      || (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n+\t  && gimple_assign_rhs_code (stmt) != VIEW_CONVERT_EXPR))\n     return NULL_TREE;\n \n-  tree op = TREE_OPERAND (expr, 0);\n+  tree op = gimple_assign_rhs1 (stmt);\n+  if (gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR)\n+    op = TREE_OPERAND (op, 0);\n   tree leader = TREE_CODE (op) == SSA_NAME ? eliminate_avail (op) : op;\n   if (!leader)\n     return NULL_TREE;\n \n-  tree res = make_temp_ssa_name (TREE_TYPE (val), NULL, \"pretmp\");\n-  gassign *tem = gimple_build_assign (res,\n-\t\t\t\t      fold_build1 (TREE_CODE (expr),\n-\t\t\t\t\t\t   TREE_TYPE (expr), leader));\n-  gsi_insert_before (gsi, tem, GSI_SAME_STMT);\n+  gimple_seq stmts = NULL;\n+  tree res = gimple_build (&stmts, gimple_assign_rhs_code (stmt),\n+\t\t\t   TREE_TYPE (val), leader);\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n   VN_INFO_GET (res)->valnum = val;\n \n   if (TREE_CODE (leader) == SSA_NAME)\n@@ -3969,7 +3971,7 @@ eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Inserted \");\n-      print_gimple_stmt (dump_file, tem, 0, 0);\n+      print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (res), 0, 0);\n     }\n \n   return res;\n@@ -4093,7 +4095,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      if (val != VN_TOP\n \t\t  && TREE_CODE (val) == SSA_NAME\n \t\t  && VN_INFO (val)->needs_insertion\n-\t\t  && VN_INFO (val)->expr != NULL_TREE\n+\t\t  && VN_INFO (val)->expr != NULL\n \t\t  && (sprime = eliminate_insert (&gsi, val)) != NULL_TREE)\n \t\teliminate_push_avail (sprime);\n \t    }"}, {"sha": "9db5a7fc0ec1b13d1207f36a56305c677c247d9e", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 65, "deletions": 418, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"cgraph.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimple-match.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n    Cooper and L. Taylor Simpson in \"SCC-Based Value numbering\"\n@@ -391,6 +392,8 @@ VN_INFO_GET (tree name)\n {\n   vn_ssa_aux_t newinfo;\n \n+  gcc_assert (SSA_NAME_VERSION (name) >= vn_ssa_aux_table.length ()\n+\t      || vn_ssa_aux_table[SSA_NAME_VERSION (name)] == NULL);\n   newinfo = XOBNEW (&vn_ssa_aux_obstack, struct vn_ssa_aux);\n   memset (newinfo, 0, sizeof (struct vn_ssa_aux));\n   if (SSA_NAME_VERSION (name) >= vn_ssa_aux_table.length ())\n@@ -400,92 +403,6 @@ VN_INFO_GET (tree name)\n }\n \n \n-/* Get the representative expression for the SSA_NAME NAME.  Returns\n-   the representative SSA_NAME if there is no expression associated with it.  */\n-\n-tree\n-vn_get_expr_for (tree name)\n-{\n-  vn_ssa_aux_t vn = VN_INFO (name);\n-  gimple *def_stmt;\n-  tree expr = NULL_TREE;\n-  enum tree_code code;\n-\n-  if (vn->valnum == VN_TOP)\n-    return name;\n-\n-  /* If the value-number is a constant it is the representative\n-     expression.  */\n-  if (TREE_CODE (vn->valnum) != SSA_NAME)\n-    return vn->valnum;\n-\n-  /* Get to the information of the value of this SSA_NAME.  */\n-  vn = VN_INFO (vn->valnum);\n-\n-  /* If the value-number is a constant it is the representative\n-     expression.  */\n-  if (TREE_CODE (vn->valnum) != SSA_NAME)\n-    return vn->valnum;\n-\n-  /* Else if we have an expression, return it.  */\n-  if (vn->expr != NULL_TREE)\n-    return vn->expr;\n-\n-  /* Otherwise use the defining statement to build the expression.  */\n-  def_stmt = SSA_NAME_DEF_STMT (vn->valnum);\n-\n-  /* If the value number is not an assignment use it directly.  */\n-  if (!is_gimple_assign (def_stmt))\n-    return vn->valnum;\n-\n-  /* Note that we can valueize here because we clear the cached\n-     simplified expressions after each optimistic iteration.  */\n-  code = gimple_assign_rhs_code (def_stmt);\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_reference:\n-      if ((code == REALPART_EXPR\n-\t   || code == IMAGPART_EXPR\n-\t   || code == VIEW_CONVERT_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (gimple_assign_rhs1 (def_stmt),\n-\t\t\t\t      0)) == SSA_NAME)\n-\texpr = fold_build1 (code,\n-\t\t\t    gimple_expr_type (def_stmt),\n-\t\t\t    vn_valueize (TREE_OPERAND\n-\t\t\t\t\t   (gimple_assign_rhs1 (def_stmt), 0)));\n-      break;\n-\n-    case tcc_unary:\n-      expr = fold_build1 (code,\n-\t\t\t  gimple_expr_type (def_stmt),\n-\t\t\t  vn_valueize (gimple_assign_rhs1 (def_stmt)));\n-      break;\n-\n-    case tcc_binary:\n-      expr = fold_build2 (code,\n-\t\t\t  gimple_expr_type (def_stmt),\n-\t\t\t  vn_valueize (gimple_assign_rhs1 (def_stmt)),\n-\t\t\t  vn_valueize (gimple_assign_rhs2 (def_stmt)));\n-      break;\n-\n-    case tcc_exceptional:\n-      if (code == CONSTRUCTOR\n-\t  && TREE_CODE\n-\t       (TREE_TYPE (gimple_assign_rhs1 (def_stmt))) == VECTOR_TYPE)\n-\texpr = gimple_assign_rhs1 (def_stmt);\n-      break;\n-\n-    default:;\n-    }\n-  if (expr == NULL_TREE)\n-    return vn->valnum;\n-\n-  /* Cache the expression.  */\n-  vn->expr = expr;\n-\n-  return expr;\n-}\n-\n /* Return the vn_kind the expression computed by the stmt should be\n    associated with.  */\n \n@@ -2629,6 +2546,18 @@ vn_nary_op_lookup_stmt (gimple *stmt, vn_nary_op_t *vnresult)\n   return vn_nary_op_lookup_1 (vno1, vnresult);\n }\n \n+/* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */\n+\n+static tree\n+vn_lookup_simplify_result (code_helper rcode, tree type, tree *ops)\n+{\n+  if (!rcode.is_tree_code ())\n+    return NULL_TREE;\n+  vn_nary_op_t vnresult = NULL;\n+  return vn_nary_op_lookup_pieces (TREE_CODE_LENGTH ((tree_code) rcode),\n+\t\t\t\t   (tree_code) rcode, type, ops, &vnresult);\n+}\n+\n /* Allocate a vn_nary_op_t with LENGTH operands on STACK.  */\n \n static vn_nary_op_t\n@@ -2991,20 +2920,13 @@ defs_to_varying (gimple *stmt)\n   return changed;\n }\n \n-static bool expr_has_constants (tree expr);\n-\n /* Visit a copy between LHS and RHS, return true if the value number\n    changed.  */\n \n static bool\n visit_copy (tree lhs, tree rhs)\n {\n-  /* The copy may have a more interesting constant filled expression\n-     (we don't, since we know our RHS is just an SSA name).  */\n-  VN_INFO (lhs)->has_constants = VN_INFO (rhs)->has_constants;\n-  VN_INFO (lhs)->expr = VN_INFO (rhs)->expr;\n-\n-  /* And finally valueize.  */\n+  /* Valueize.  */\n   rhs = SSA_VAL (rhs);\n \n   return set_ssa_val_to (lhs, rhs);\n@@ -3055,12 +2977,7 @@ visit_reference_op_call (tree lhs, gcall *stmt)\n \tvnresult->result = lhs;\n \n       if (vnresult->result && lhs)\n-\t{\n-\t  changed |= set_ssa_val_to (lhs, vnresult->result);\n-\n-\t  if (VN_INFO (vnresult->result)->has_constants)\n-\t    VN_INFO (lhs)->has_constants = true;\n-\t}\n+\tchanged |= set_ssa_val_to (lhs, vnresult->result);\n     }\n   else\n     {\n@@ -3116,33 +3033,38 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)\n \t of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).\n \t So first simplify and lookup this expression to see if it\n \t is already available.  */\n-      tree val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (op), result);\n-      if ((CONVERT_EXPR_P (val)\n-\t   || TREE_CODE (val) == VIEW_CONVERT_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (val, 0)) == SSA_NAME)\n-        {\n-\t  tree tem = vn_get_expr_for (TREE_OPERAND (val, 0));\n-\t  if ((CONVERT_EXPR_P (tem)\n-\t       || TREE_CODE (tem) == VIEW_CONVERT_EXPR)\n-\t      && (tem = fold_unary_ignore_overflow (TREE_CODE (val),\n-\t\t\t\t\t\t    TREE_TYPE (val), tem)))\n-\t    val = tem;\n+      gimple_seq stmts = NULL;\n+      mprts_hook = vn_lookup_simplify_result;\n+      tree val = gimple_simplify (VIEW_CONVERT_EXPR, TREE_TYPE (op),\n+\t\t\t\t  result, &stmts, vn_valueize);\n+      mprts_hook = NULL;\n+      if (!val)\n+\t{\n+\t  val = vn_nary_op_lookup_pieces (1, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t  TREE_TYPE (op), &result, NULL);\n+\t  if (!val)\n+\t    {\n+\t      val = make_ssa_name (TREE_TYPE (op));\n+\t      gimple *new_stmt = gimple_build_assign (val, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t      build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t      TREE_TYPE (op),\n+\t\t\t\t\t\t\t      result));\n+\t      gimple_seq_add_stmt_without_update (&stmts, new_stmt);\n+\t    }\n \t}\n-      result = val;\n-      if (!is_gimple_min_invariant (val)\n-\t  && TREE_CODE (val) != SSA_NAME)\n-\tresult = vn_nary_op_lookup (val, NULL);\n-      /* If the expression is not yet available, value-number lhs to\n-\t a new SSA_NAME we create.  */\n-      if (!result)\n-        {\n-\t  result = make_temp_ssa_name (TREE_TYPE (lhs), gimple_build_nop (),\n-\t\t\t\t       \"vntemp\");\n+      if (gimple_seq_empty_p (stmts))\n+\t/* The expression is already available.  */\n+\tresult = val;\n+      else\n+\t{\n+\t  gcc_assert (gimple_seq_singleton_p (stmts));\n+\t  /* The expression is not yet available, value-number lhs to\n+\t     the new SSA_NAME we created.  */\n+\t  result = val;\n \t  /* Initialize value-number information properly.  */\n \t  VN_INFO_GET (result)->valnum = result;\n \t  VN_INFO (result)->value_id = get_next_value_id ();\n-\t  VN_INFO (result)->expr = val;\n-\t  VN_INFO (result)->has_constants = expr_has_constants (val);\n+\t  VN_INFO (result)->expr = stmts;\n \t  VN_INFO (result)->needs_insertion = true;\n \t  /* As all \"inserted\" statements are singleton SCCs, insert\n \t     to the valid table.  This is strictly needed to\n@@ -3154,32 +3076,25 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)\n \t  if (current_info == optimistic_info)\n \t    {\n \t      current_info = valid_info;\n-\t      vn_nary_op_insert (val, result);\n+\t      vn_nary_op_insert_stmt (gimple_seq_first_stmt (stmts), result);\n \t      current_info = optimistic_info;\n \t    }\n \t  else\n-\t    vn_nary_op_insert (val, result);\n+\t    vn_nary_op_insert_stmt (gimple_seq_first_stmt (stmts), result);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"Inserting name \");\n \t      print_generic_expr (dump_file, result, 0);\n \t      fprintf (dump_file, \" for expression \");\n-\t      print_generic_expr (dump_file, val, 0);\n+\t      print_gimple_expr (dump_file, gimple_seq_first_stmt (stmts),\n+\t\t\t\t 0, TDF_SLIM);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t}\n     }\n \n   if (result)\n-    {\n-      changed = set_ssa_val_to (lhs, result);\n-      if (TREE_CODE (result) == SSA_NAME\n-\t  && VN_INFO (result)->has_constants)\n-\t{\n-\t  VN_INFO (lhs)->expr = VN_INFO (result)->expr;\n-\t  VN_INFO (lhs)->has_constants = true;\n-\t}\n-    }\n+    changed = set_ssa_val_to (lhs, result);\n   else\n     {\n       changed = set_ssa_val_to (lhs, lhs);\n@@ -3346,208 +3261,12 @@ visit_phi (gimple *phi)\n   else\n     {\n       vn_phi_insert (phi, PHI_RESULT (phi));\n-      VN_INFO (PHI_RESULT (phi))->has_constants = false;\n-      VN_INFO (PHI_RESULT (phi))->expr = PHI_RESULT (phi);\n       changed = set_ssa_val_to (PHI_RESULT (phi), PHI_RESULT (phi));\n     }\n \n   return changed;\n }\n \n-/* Return true if EXPR contains constants.  */\n-\n-static bool\n-expr_has_constants (tree expr)\n-{\n-  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n-    {\n-    case tcc_unary:\n-      return is_gimple_min_invariant (TREE_OPERAND (expr, 0));\n-\n-    case tcc_binary:\n-      return is_gimple_min_invariant (TREE_OPERAND (expr, 0))\n-\t|| is_gimple_min_invariant (TREE_OPERAND (expr, 1));\n-      /* Constants inside reference ops are rarely interesting, but\n-\t it can take a lot of looking to find them.  */\n-    case tcc_reference:\n-    case tcc_declaration:\n-      return false;\n-    default:\n-      return is_gimple_min_invariant (expr);\n-    }\n-  return false;\n-}\n-\n-/* Return true if STMT contains constants.  */\n-\n-static bool\n-stmt_has_constants (gimple *stmt)\n-{\n-  tree tem;\n-\n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n-    return false;\n-\n-  switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n-    {\n-    case GIMPLE_TERNARY_RHS:\n-      tem = gimple_assign_rhs3 (stmt);\n-      if (TREE_CODE (tem) == SSA_NAME)\n-\ttem = SSA_VAL (tem);\n-      if (is_gimple_min_invariant (tem))\n-\treturn true;\n-      /* Fallthru.  */\n-\n-    case GIMPLE_BINARY_RHS:\n-      tem = gimple_assign_rhs2 (stmt);\n-      if (TREE_CODE (tem) == SSA_NAME)\n-\ttem = SSA_VAL (tem);\n-      if (is_gimple_min_invariant (tem))\n-\treturn true;\n-      /* Fallthru.  */\n-\n-    case GIMPLE_SINGLE_RHS:\n-      /* Constants inside reference ops are rarely interesting, but\n-\t it can take a lot of looking to find them.  */\n-    case GIMPLE_UNARY_RHS:\n-      tem = gimple_assign_rhs1 (stmt);\n-      if (TREE_CODE (tem) == SSA_NAME)\n-\ttem = SSA_VAL (tem);\n-      return is_gimple_min_invariant (tem);\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return false;\n-}\n-\n-/* Simplify the binary expression RHS, and return the result if\n-   simplified. */\n-\n-static tree\n-simplify_binary_expression (gimple *stmt)\n-{\n-  tree result = NULL_TREE;\n-  tree op0 = gimple_assign_rhs1 (stmt);\n-  tree op1 = gimple_assign_rhs2 (stmt);\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-\n-  /* This will not catch every single case we could combine, but will\n-     catch those with constants.  The goal here is to simultaneously\n-     combine constants between expressions, but avoid infinite\n-     expansion of expressions during simplification.  */\n-  op0 = vn_valueize (op0);\n-  if (TREE_CODE (op0) == SSA_NAME\n-      && (VN_INFO (op0)->has_constants\n-\t  || TREE_CODE_CLASS (code) == tcc_comparison\n-\t  || code == COMPLEX_EXPR))\n-    op0 = vn_get_expr_for (op0);\n-\n-  op1 = vn_valueize (op1);\n-  if (TREE_CODE (op1) == SSA_NAME\n-      && (VN_INFO (op1)->has_constants\n-\t  || code == COMPLEX_EXPR))\n-    op1 = vn_get_expr_for (op1);\n-\n-  /* Pointer plus constant can be represented as invariant address.\n-     Do so to allow further propatation, see also tree forwprop.  */\n-  if (code == POINTER_PLUS_EXPR\n-      && tree_fits_uhwi_p (op1)\n-      && TREE_CODE (op0) == ADDR_EXPR\n-      && is_gimple_min_invariant (op0))\n-    return build_invariant_address (TREE_TYPE (op0),\n-\t\t\t\t    TREE_OPERAND (op0, 0),\n-\t\t\t\t    tree_to_uhwi (op1));\n-\n-  /* Avoid folding if nothing changed.  */\n-  if (op0 == gimple_assign_rhs1 (stmt)\n-      && op1 == gimple_assign_rhs2 (stmt))\n-    return NULL_TREE;\n-\n-  fold_defer_overflow_warnings ();\n-\n-  result = fold_binary (code, gimple_expr_type (stmt), op0, op1);\n-  if (result)\n-    STRIP_USELESS_TYPE_CONVERSION (result);\n-\n-  fold_undefer_overflow_warnings (result && valid_gimple_rhs_p (result),\n-\t\t\t\t  stmt, 0);\n-\n-  /* Make sure result is not a complex expression consisting\n-     of operators of operators (IE (a + b) + (a + c))\n-     Otherwise, we will end up with unbounded expressions if\n-     fold does anything at all.  */\n-  if (result && valid_gimple_rhs_p (result))\n-    return result;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Simplify the unary expression RHS, and return the result if\n-   simplified. */\n-\n-static tree\n-simplify_unary_expression (gassign *stmt)\n-{\n-  tree result = NULL_TREE;\n-  tree orig_op0, op0 = gimple_assign_rhs1 (stmt);\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-\n-  /* We handle some tcc_reference codes here that are all\n-     GIMPLE_ASSIGN_SINGLE codes.  */\n-  if (code == REALPART_EXPR\n-      || code == IMAGPART_EXPR\n-      || code == VIEW_CONVERT_EXPR\n-      || code == BIT_FIELD_REF)\n-    op0 = TREE_OPERAND (op0, 0);\n-\n-  orig_op0 = op0;\n-  op0 = vn_valueize (op0);\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    {\n-      if (VN_INFO (op0)->has_constants)\n-\top0 = vn_get_expr_for (op0);\n-      else if (CONVERT_EXPR_CODE_P (code)\n-\t       || code == REALPART_EXPR\n-\t       || code == IMAGPART_EXPR\n-\t       || code == VIEW_CONVERT_EXPR\n-\t       || code == BIT_FIELD_REF)\n-\t{\n-\t  /* We want to do tree-combining on conversion-like expressions.\n-\t     Make sure we feed only SSA_NAMEs or constants to fold though.  */\n-\t  tree tem = vn_get_expr_for (op0);\n-\t  if (UNARY_CLASS_P (tem)\n-\t      || BINARY_CLASS_P (tem)\n-\t      || TREE_CODE (tem) == VIEW_CONVERT_EXPR\n-\t      || TREE_CODE (tem) == SSA_NAME\n-\t      || TREE_CODE (tem) == CONSTRUCTOR\n-\t      || is_gimple_min_invariant (tem))\n-\t    op0 = tem;\n-\t}\n-    }\n-\n-  /* Avoid folding if nothing changed, but remember the expression.  */\n-  if (op0 == orig_op0)\n-    return NULL_TREE;\n-\n-  if (code == BIT_FIELD_REF)\n-    {\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-      result = fold_ternary (BIT_FIELD_REF, TREE_TYPE (rhs),\n-\t\t\t     op0, TREE_OPERAND (rhs, 1), TREE_OPERAND (rhs, 2));\n-    }\n-  else\n-    result = fold_unary_ignore_overflow (code, gimple_expr_type (stmt), op0);\n-  if (result)\n-    {\n-      STRIP_USELESS_TYPE_CONVERSION (result);\n-      if (valid_gimple_rhs_p (result))\n-        return result;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Try to simplify RHS using equivalences and constant folding.  */\n \n static tree\n@@ -3562,35 +3281,14 @@ try_to_simplify (gassign *stmt)\n     return NULL_TREE;\n \n   /* First try constant folding based on our current lattice.  */\n+  mprts_hook = vn_lookup_simplify_result;\n   tem = gimple_fold_stmt_to_constant_1 (stmt, vn_valueize, vn_valueize);\n+  mprts_hook = NULL;\n   if (tem\n       && (TREE_CODE (tem) == SSA_NAME\n \t  || is_gimple_min_invariant (tem)))\n     return tem;\n \n-  /* If that didn't work try combining multiple statements.  */\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_reference:\n-      /* Fallthrough for some unary codes that can operate on registers.  */\n-      if (!(code == REALPART_EXPR\n-\t    || code == IMAGPART_EXPR\n-\t    || code == VIEW_CONVERT_EXPR\n-\t    || code == BIT_FIELD_REF))\n-\tbreak;\n-      /* We could do a little more with unary ops, if they expand\n-\t into binary ops, but it's debatable whether it is worth it. */\n-    case tcc_unary:\n-      return simplify_unary_expression (stmt);\n-\n-    case tcc_comparison:\n-    case tcc_binary:\n-      return simplify_binary_expression (stmt);\n-\n-    default:\n-      break;\n-    }\n-\n   return NULL_TREE;\n }\n \n@@ -3648,11 +3346,7 @@ visit_use (tree use)\n \t\t  print_gimple_expr (dump_file, stmt, 0, 0);\n \t\t  fprintf (dump_file, \" simplified to \");\n \t\t  print_generic_expr (dump_file, simplified, 0);\n-\t\t  if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t    fprintf (dump_file, \" has constants %d\\n\",\n-\t\t\t     expr_has_constants (simplified));\n-\t\t  else\n-\t\t    fprintf (dump_file, \"\\n\");\n+\t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t    }\n \t  /* Setting value numbers to constants will occasionally\n@@ -3663,8 +3357,6 @@ visit_use (tree use)\n \t      && is_gimple_min_invariant (simplified)\n \t      && TREE_CODE (lhs) == SSA_NAME)\n \t    {\n-\t      VN_INFO (lhs)->expr = simplified;\n-\t      VN_INFO (lhs)->has_constants = true;\n \t      changed = set_ssa_val_to (lhs, simplified);\n \t      goto done;\n \t    }\n@@ -3675,29 +3367,6 @@ visit_use (tree use)\n \t      changed = visit_copy (lhs, simplified);\n \t      goto done;\n \t    }\n-\t  else if (simplified)\n-\t    {\n-\t      if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t{\n-\t\t  VN_INFO (lhs)->has_constants = expr_has_constants (simplified);\n-\t\t  /* We have to unshare the expression or else\n-\t\t     valuizing may change the IL stream.  */\n-\t\t  VN_INFO (lhs)->expr = unshare_expr (simplified);\n-\t\t}\n-\t    }\n-\t  else if (stmt_has_constants (stmt)\n-\t\t   && TREE_CODE (lhs) == SSA_NAME)\n-\t    VN_INFO (lhs)->has_constants = true;\n-\t  else if (TREE_CODE (lhs) == SSA_NAME)\n-\t    {\n-\t      /* We reset expr and constantness here because we may\n-\t\t have been value numbering optimistically, and\n-\t\t iterating. They may become non-constant in this case,\n-\t\t even if they were optimistically constant. */\n-\n-\t      VN_INFO (lhs)->has_constants = false;\n-\t      VN_INFO (lhs)->expr = NULL_TREE;\n-\t    }\n \n \t  if ((TREE_CODE (lhs) == SSA_NAME\n \t       /* We can substitute SSA_NAMEs that are live over\n@@ -3722,7 +3391,6 @@ visit_use (tree use)\n \t\t  || (simplified\n \t\t      && is_gimple_min_invariant (simplified)))\n \t\t{\n-\t\t  VN_INFO (lhs)->has_constants = true;\n \t\t  if (simplified)\n \t\t    changed = set_ssa_val_to (lhs, simplified);\n \t\t  else\n@@ -3785,11 +3453,7 @@ visit_use (tree use)\n \t\t      print_gimple_expr (dump_file, stmt, 0, 0);\n \t\t      fprintf (dump_file, \" simplified to \");\n \t\t      print_generic_expr (dump_file, simplified, 0);\n-\t\t      if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t\tfprintf (dump_file, \" has constants %d\\n\",\n-\t\t\t\t expr_has_constants (simplified));\n-\t\t      else\n-\t\t\tfprintf (dump_file, \"\\n\");\n+\t\t      fprintf (dump_file, \"\\n\");\n \t\t    }\n \t\t}\n \t      /* Setting value numbers to constants will occasionally\n@@ -3799,8 +3463,6 @@ visit_use (tree use)\n \t      if (simplified\n \t\t  && is_gimple_min_invariant (simplified))\n \t\t{\n-\t\t  VN_INFO (lhs)->expr = simplified;\n-\t\t  VN_INFO (lhs)->has_constants = true;\n \t\t  changed = set_ssa_val_to (lhs, simplified);\n \t\t  if (gimple_vdef (stmt))\n \t\t    changed |= set_ssa_val_to (gimple_vdef (stmt),\n@@ -3818,18 +3480,6 @@ visit_use (tree use)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (stmt_has_constants (stmt))\n-\t\t    VN_INFO (lhs)->has_constants = true;\n-\t\t  else\n-\t\t    {\n-\t\t      /* We reset expr and constantness here because we may\n-\t\t\t have been value numbering optimistically, and\n-\t\t\t iterating.  They may become non-constant in this case,\n-\t\t\t even if they were optimistically constant.  */\n-\t\t      VN_INFO (lhs)->has_constants = false;\n-\t\t      VN_INFO (lhs)->expr = NULL_TREE;\n-\t\t    }\n-\n \t\t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n \t\t    {\n \t\t      changed = defs_to_varying (stmt);\n@@ -4028,7 +3678,8 @@ process_scc (vec<tree> scc)\n       optimistic_info->phis_pool->release ();\n       optimistic_info->references_pool->release ();\n       FOR_EACH_VEC_ELT (scc, i, var)\n-\tVN_INFO (var)->expr = NULL_TREE;\n+\tgcc_assert (!VN_INFO (var)->needs_insertion\n+\t\t    && VN_INFO (var)->expr == NULL);\n       FOR_EACH_VEC_ELT (scc, i, var)\n \tchanged |= visit_use (var);\n     }\n@@ -4283,7 +3934,8 @@ init_scc_vn (void)\n \tcontinue;\n \n       VN_INFO_GET (name)->valnum = VN_TOP;\n-      VN_INFO (name)->expr = NULL_TREE;\n+      VN_INFO (name)->needs_insertion = false;\n+      VN_INFO (name)->expr = NULL;\n       VN_INFO (name)->value_id = 0;\n \n       if (!SSA_NAME_IS_DEFAULT_DEF (name))\n@@ -4638,23 +4290,18 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n     {\n     case GIMPLE_COND:\n       {\n-\ttree lhs = gimple_cond_lhs (stmt);\n-\ttree rhs = gimple_cond_rhs (stmt);\n-\t/* Work hard in computing the condition and take into account\n-\t   the valueization of the defining stmt.  */\n-\tif (TREE_CODE (lhs) == SSA_NAME)\n-\t  lhs = vn_get_expr_for (lhs);\n-\tif (TREE_CODE (rhs) == SSA_NAME)\n-\t  rhs = vn_get_expr_for (rhs);\n-\tval = fold_binary (gimple_cond_code (stmt),\n-\t\t\t   boolean_type_node, lhs, rhs);\n+\ttree lhs = vn_valueize (gimple_cond_lhs (stmt));\n+\ttree rhs = vn_valueize (gimple_cond_rhs (stmt));\n+\tval = gimple_simplify (gimple_cond_code (stmt),\n+\t\t\t       boolean_type_node, lhs, rhs,\n+\t\t\t       NULL, vn_valueize);\n \t/* If that didn't simplify to a constant see if we have recorded\n \t   temporary expressions from taken edges.  */\n \tif (!val || TREE_CODE (val) != INTEGER_CST)\n \t  {\n \t    tree ops[2];\n-\t    ops[0] = gimple_cond_lhs (stmt);\n-\t    ops[1] = gimple_cond_rhs (stmt);\n+\t    ops[0] = lhs;\n+\t    ops[1] = rhs;\n \t    val = vn_nary_op_lookup_pieces (2, gimple_cond_code (stmt),\n \t\t\t\t\t    boolean_type_node, ops, NULL);\n \t  }"}, {"sha": "c8b918aa4e998c137f9dfa4be6b8e5a2481ffcbf", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34050b6bee181a12099a9bc31a4d25469573bc6d/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=34050b6bee181a12099a9bc31a4d25469573bc6d", "patch": "@@ -165,8 +165,8 @@ typedef struct vn_ssa_aux\n {\n   /* Value number. This may be an SSA name or a constant.  */\n   tree valnum;\n-  /* Representative expression, if not a direct constant. */\n-  tree expr;\n+  /* Statements to insert if needs_insertion is true.  */\n+  gimple_seq expr;\n \n   /* Unique identifier that all expressions with the same value have. */\n   unsigned int value_id;\n@@ -177,8 +177,6 @@ typedef struct vn_ssa_aux\n   unsigned visited : 1;\n   unsigned on_sccstack : 1;\n \n-  /* Whether the representative expression contains constants.  */\n-  unsigned has_constants : 1;\n   /* Whether the SSA_NAME has been value numbered already.  This is\n      only saying whether visit_use has been called on it at least\n      once.  It cannot be used to avoid visitation for SSA_NAME's"}]}