{"sha": "951553afd9a7d171eb5a4633e813209c89183901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUxNTUzYWZkOWE3ZDE3MWViNWE0NjMzZTgxMzIwOWM4OTE4MzkwMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-12-28T12:44:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-12-28T12:44:42Z"}, "message": "Add a few missing HOST_WIDE_INT casts.\n\nRename references to `significant' bits to be `nonzero' bits;\nspecifically the following, but also local vars and comments:\n(reg_nonzero_bits): Renamed from reg_significant.\n(nonzero_bits): Renamed from significant_bits.\n(nonzero_sign_valid): Renamed from significant_valid.\n(set_nonzero_bits_and_sign_copies): Renamed from set_significant.\n\nFrom-SVN: r2975", "tree": {"sha": "0fb6f15441e8b3e86ae70c7d9b8aeac1878b9b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fb6f15441e8b3e86ae70c7d9b8aeac1878b9b85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/951553afd9a7d171eb5a4633e813209c89183901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951553afd9a7d171eb5a4633e813209c89183901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/951553afd9a7d171eb5a4633e813209c89183901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951553afd9a7d171eb5a4633e813209c89183901/comments", "author": null, "committer": null, "parents": [{"sha": "accdfaab89e2650d31adc0ea4f50205e11b58e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/accdfaab89e2650d31adc0ea4f50205e11b58e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/accdfaab89e2650d31adc0ea4f50205e11b58e43"}], "stats": {"total": 400, "additions": 195, "deletions": 205}, "files": [{"sha": "1ca0f0b01d5a0f98a9c0d16e2ba84679719a63e0", "filename": "gcc/combine.c", "status": "modified", "additions": 195, "deletions": 205, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951553afd9a7d171eb5a4633e813209c89183901/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951553afd9a7d171eb5a4633e813209c89183901/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=951553afd9a7d171eb5a4633e813209c89183901", "patch": "@@ -243,29 +243,29 @@ static short label_tick;\n    a QImode register may be loaded from memory in two places on a machine\n    where byte loads zero extend.\n \n-   We record in the following array what we know about the significant\n+   We record in the following array what we know about the nonzero\n    bits of a register, specifically which bits are known to be zero.\n \n    If an entry is zero, it means that we don't know anything special.  */\n \n-static HOST_WIDE_INT *reg_significant;\n+static HOST_WIDE_INT *reg_nonzero_bits;\n \n-/* Mode used to compute significance in reg_significant.  It is the largest\n+/* Mode used to compute significance in reg_nonzero_bits.  It is the largest\n    integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n-static enum machine_mode significant_mode;\n+static enum machine_mode nonzero_bits_mode;\n \n /* Nonzero if we know that a register has some leading bits that are always\n    equal to the sign bit.  */\n \n static char *reg_sign_bit_copies;\n \n-/* Nonzero when reg_significant and reg_sign_bit_copies can be safely used.\n+/* Nonzero when reg_nonzero_bits and reg_sign_bit_copies can be safely used.\n    It is zero while computing them and after combine has completed.  This\n    former test prevents propagating values based on previously set values,\n    which can be incorrect if a variable is modified in a loop.  */\n \n-static int significant_valid;\n+static int nonzero_sign_valid;\n \f\n /* Record one modification to rtl structure\n    to be undone by storing old_contents into *where.\n@@ -339,7 +339,7 @@ static struct undobuf undobuf;\n \n static int n_occurrences;\n \n-static void set_significant ();\n+static void set_nonzero_bits_and_sign_copies ();\n static void move_deaths ();\n rtx remove_death ();\n static void record_value_for_reg ();\n@@ -360,7 +360,7 @@ static rtx make_field_assignment ();\n static rtx make_compound_operation ();\n static rtx apply_distributive_law ();\n static rtx simplify_and_const_int ();\n-static unsigned HOST_WIDE_INT significant_bits ();\n+static unsigned HOST_WIDE_INT nonzero_bits ();\n static int num_sign_bit_copies ();\n static int merge_outer_ops ();\n static rtx simplify_shift_const ();\n@@ -401,15 +401,15 @@ combine_instructions (f, nregs)\n   reg_last_set_table_tick = (short *) alloca (nregs * sizeof (short));\n   reg_last_set_label = (short *) alloca (nregs * sizeof (short));\n   reg_last_set_invalid = (char *) alloca (nregs * sizeof (char));\n-  reg_significant = (HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n+  reg_nonzero_bits = (HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n   reg_sign_bit_copies = (char *) alloca (nregs * sizeof (char));\n \n   bzero (reg_last_death, nregs * sizeof (rtx));\n   bzero (reg_last_set, nregs * sizeof (rtx));\n   bzero (reg_last_set_value, nregs * sizeof (rtx));\n   bzero (reg_last_set_table_tick, nregs * sizeof (short));\n   bzero (reg_last_set_invalid, nregs * sizeof (char));\n-  bzero (reg_significant, nregs * sizeof (HOST_WIDE_INT));\n+  bzero (reg_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n   bzero (reg_sign_bit_copies, nregs * sizeof (char));\n \n   init_recog_no_volatile ();\n@@ -422,28 +422,29 @@ combine_instructions (f, nregs)\n \n   uid_cuid = (int *) alloca ((i + 1) * sizeof (int));\n \n-  significant_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n+  nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n-  /* Don't use reg_significant when computing it.  This can cause problems\n+  /* Don't use reg_nonzero_bits when computing it.  This can cause problems\n      when, for example, we have j <<= 1 in a loop.  */\n \n-  significant_valid = 0;\n+  nonzero_sign_valid = 0;\n \n   /* Compute the mapping from uids to cuids.\n      Cuids are numbers assigned to insns, like uids,\n      except that cuids increase monotonically through the code. \n \n      Scan all SETs and see if we can deduce anything about what\n-     bits are significant for some registers.  */\n+     bits are known to be zero for some registers and how many copies\n+     of the sign bit are known to exist for those registers.  */\n \n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       INSN_CUID (insn) = ++i;\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tnote_stores (PATTERN (insn), set_significant);\n+\tnote_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies);\n     }\n \n-  significant_valid = 1;\n+  nonzero_sign_valid = 1;\n \n   /* Now scan all the insns in forward order.  */\n \n@@ -554,12 +555,12 @@ combine_instructions (f, nregs)\n   total_extras += combine_extras;\n   total_successes += combine_successes;\n \n-  significant_valid = 0;\n+  nonzero_sign_valid = 0;\n }\n \f\n /* Called via note_stores.  If X is a pseudo that is used in more than\n    one basic block, is narrower that HOST_BITS_PER_WIDE_INT, and is being\n-   set, record what bits are significant.  If we are clobbering X,\n+   set, record what bits are known zero.  If we are clobbering X,\n    ignore this \"set\" because the clobbered value won't be used. \n \n    If we are setting only a portion of X and we can't figure out what\n@@ -571,7 +572,7 @@ combine_instructions (f, nregs)\n    by any set of X.  */\n \n static void\n-set_significant (x, set)\n+set_nonzero_bits_and_sign_copies (x, set)\n      rtx x;\n      rtx set;\n {\n@@ -591,16 +592,16 @@ set_significant (x, set)\n       set = expand_field_assignment (set);\n       if (SET_DEST (set) == x)\n \t{\n-\t  reg_significant[REGNO (x)]\n-\t    |= significant_bits (SET_SRC (set), significant_mode);\n+\t  reg_nonzero_bits[REGNO (x)]\n+\t    |= nonzero_bits (SET_SRC (set), nonzero_bits_mode);\n \t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n \t  if (reg_sign_bit_copies[REGNO (x)] == 0\n \t      || reg_sign_bit_copies[REGNO (x)] > num)\n \t    reg_sign_bit_copies[REGNO (x)] = num;\n \t}\n       else\n \t{\n-\t  reg_significant[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n \t  reg_sign_bit_copies[REGNO (x)] = 0;\n \t}\n     }\n@@ -2082,12 +2083,12 @@ try_combine (i3, i2, i1)\n \t  }\n       }\n \n-    /* Update reg_significant et al for any changes that may have been made\n+    /* Update reg_nonzero_bits et al for any changes that may have been made\n        to this insn.  */\n \n-    note_stores (newpat, set_significant);\n+    note_stores (newpat, set_nonzero_bits_and_sign_copies);\n     if (newi2pat)\n-      note_stores (newi2pat, set_significant);\n+      note_stores (newi2pat, set_nonzero_bits_and_sign_copies);\n \n     /* If I3 is now an unconditional jump, ensure that it has a \n        BARRIER following it since it may have initially been a\n@@ -3092,7 +3093,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1. */\n       if (GET_CODE (XEXP (x, 0)) == XOR && XEXP (XEXP (x, 0), 1) == const1_rtx\n-\t  && significant_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n+\t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n \t{\n \t  x = gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n \t  goto restart;\n@@ -3128,7 +3129,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n-      /* If X has only a single bit significant, say, bit I, convert\n+      /* If X has only a single bit that might be nonzero, say, bit I, convert\n \t (neg X) to (ashiftrt (ashift X C-I) C-I) where C is the bitsize of\n \t MODE minus 1.  This will convert (neg (zero_extract X 1 Y)) to\n \t (sign_extract X 1 Y).  But only do this if TEMP isn't a register\n@@ -3138,7 +3139,7 @@ subst (x, from, to, in_dest, unique_copy)\n       if (GET_CODE (temp) != REG\n \t  && ! (GET_CODE (temp) == SUBREG\n \t\t&& GET_CODE (SUBREG_REG (temp)) == REG)\n-\t  && (i = exact_log2 (significant_bits (temp, mode))) >= 0)\n+\t  && (i = exact_log2 (nonzero_bits (temp, mode))) >= 0)\n \t{\n \t  rtx temp1 = simplify_shift_const\n \t    (NULL_RTX, ASHIFTRT, mode,\n@@ -3240,15 +3241,15 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n-      /* If only the low-order bit of X is significant, (plus x -1)\n+      /* If only the low-order bit of X is possible nonzero, (plus x -1)\n \t can become (ashiftrt (ashift (xor x 1) C) C) where C is\n \t the bitsize of the mode - 1.  This allows simplification of\n \t \"a = (b & 8) == 0;\"  */\n       if (XEXP (x, 1) == constm1_rtx\n \t  && GET_CODE (XEXP (x, 0)) != REG\n \t  && ! (GET_CODE (XEXP (x,0)) == SUBREG\n \t\t&& GET_CODE (SUBREG_REG (XEXP (x, 0))) == REG)\n-\t  && significant_bits (XEXP (x, 0), mode) == 1)\n+\t  && nonzero_bits (XEXP (x, 0), mode) == 1)\n \t{\n \t  x = simplify_shift_const\n \t    (NULL_RTX, ASHIFTRT, mode,\n@@ -3266,8 +3267,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t become a & 3.  */\n \n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (significant_bits (XEXP (x, 0), mode)\n-\t      & significant_bits (XEXP (x, 1), mode)) == 0)\n+\t  && (nonzero_bits (XEXP (x, 0), mode)\n+\t      & nonzero_bits (XEXP (x, 1), mode)) == 0)\n \t{\n \t  x = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n \t  goto restart;\n@@ -3368,7 +3369,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n #if STORE_FLAG_VALUE == 1\n \t  /* If STORE_FLAG_VALUE is 1, we can convert (ne x 0) to simply X\n-\t     if only the low-order bit is significant in X (such as when\n+\t     if only the low-order bit is possibly nonzero in X (such as when\n \t     X is a ZERO_EXTRACT of one bit.  Similarly, we can convert\n \t     EQ to (xor X 1).  Remove any ZERO_EXTRACT we made when thinking\n \t     this was a comparison.  It may now be simpler to use, e.g., an\n@@ -3377,12 +3378,12 @@ subst (x, from, to, in_dest, unique_copy)\n \t     SET case.  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n-\t      && significant_bits (op0, GET_MODE (op0)) == 1)\n+\t      && nonzero_bits (op0, GET_MODE (op0)) == 1)\n \t    return gen_lowpart_for_combine (mode,\n \t\t\t\t\t    expand_compound_operation (op0));\n \t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n-\t\t   && significant_bits (op0, GET_MODE (op0)) == 1)\n+\t\t   && nonzero_bits (op0, GET_MODE (op0)) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \n@@ -3395,12 +3396,12 @@ subst (x, from, to, in_dest, unique_copy)\n \n #if STORE_FLAG_VALUE == -1\n \t  /* If STORE_FLAG_VALUE is -1, we can convert (ne x 0)\n-\t     to (neg x) if only the low-order bit of X is significant.\n+\t     to (neg x) if only the low-order bit of X can be nonzero.\n \t     This converts (ne (zero_extract X 1 Y) 0) to\n \t     (sign_extract X 1 Y).  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n-\t      && significant_bits (op0, GET_MODE (op0)) == 1)\n+\t      && nonzero_bits (op0, GET_MODE (op0)) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      x = gen_rtx_combine (NEG, mode,\n@@ -3410,17 +3411,17 @@ subst (x, from, to, in_dest, unique_copy)\n #endif\n \n \t  /* If STORE_FLAG_VALUE says to just test the sign bit and X has just\n-\t     one significant bit, we can convert (ne x 0) to (ashift x c)\n-\t     where C puts the bit in the sign bit.  Remove any AND with\n-\t     STORE_FLAG_VALUE when we are done, since we are only going to\n-\t     test the sign bit.  */\n+\t     one bit that might be nonzero, we can convert (ne x 0) to\n+\t     (ashift x c) where C puts the bit in the sign bit.  Remove any\n+\t     AND with STORE_FLAG_VALUE when we are done, since we are only\n+\t     going to test the sign bit.  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && (STORE_FLAG_VALUE\n \t\t  == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n-\t      && (i = exact_log2 (significant_bits (op0, GET_MODE (op0)))) >= 0)\n+\t      && (i = exact_log2 (nonzero_bits (op0, GET_MODE (op0)))) >= 0)\n \t    {\n \t      x = simplify_shift_const (NULL_RTX, ASHIFT, mode,\n \t\t\t\t\texpand_compound_operation (op0),\n@@ -3452,7 +3453,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && reversible_comparison_p (XEXP (x, 0))\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n \t{\n-\t  HOST_WIDE_INT sig;\n+\t  HOST_WIDE_INT nzb;\n \t  rtx from = XEXP (XEXP (x, 0), 0);\n \t  enum rtx_code true_code = GET_CODE (XEXP (x, 0));\n \t  enum rtx_code false_code = reverse_condition (true_code);\n@@ -3471,13 +3472,13 @@ subst (x, from, to, in_dest, unique_copy)\n \t    }\n \n \t  /* If we are comparing against zero and the expression being tested\n-\t     has only a single significant bit, that is its value when it is \n-\t     not equal to zero.  Similarly if it is known to be -1 or 0.  */\n+\t     has only a single bit that might be nonzero, that is its value\n+\t     when it is not equal to zero.  Similarly if it is known to be\n+\t     -1 or 0.  */\n \n \t  if (true_code == EQ && true_val == const0_rtx\n-\t      && exact_log2 (sig = significant_bits (from,\n-\t\t\t\t\t\t     GET_MODE (from))) >= 0)\n-\t    false_code = EQ, false_val = GEN_INT (sig);\n+\t      && exact_log2 (nzb = nonzero_bits (from, GET_MODE (from))) >= 0)\n+\t    false_code = EQ, false_val = GEN_INT (nzb);\n \t  else if (true_code == EQ && true_val == const0_rtx\n \t\t   && (num_sign_bit_copies (from, GET_MODE (from))\n \t\t       == GET_MODE_BITSIZE (GET_MODE (from))))\n@@ -3584,14 +3585,14 @@ subst (x, from, to, in_dest, unique_copy)\n       if (mode != VOIDmode\n \t  && (GET_CODE (XEXP (x, 0)) == EQ || GET_CODE (XEXP (x, 0)) == NE)\n \t  && XEXP (XEXP (x, 0), 1) == const0_rtx\n-\t  && (significant_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n+\t  && (nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n \t      || (num_sign_bit_copies (XEXP (XEXP (x, 0), 0), mode)\n \t\t  == GET_MODE_BITSIZE (mode))))\n \t{\n \t  rtx nz = make_compound_operation (GET_CODE (XEXP (x, 0)) == NE\n \t\t\t\t\t    ? XEXP (x, 1) : XEXP (x, 2));\n \t  rtx z = GET_CODE (XEXP (x, 0)) == NE ? XEXP (x, 2) : XEXP (x, 1);\n-\t  rtx dir = (significant_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n+\t  rtx dir = (nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n \t\t     ? const1_rtx : constm1_rtx);\n \t  rtx c = 0;\n \t  enum machine_mode m = mode;\n@@ -3635,7 +3636,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t\t   && subreg_lowpart_p (XEXP (XEXP (nz, 0), 0))\n \t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (nz, 0), 0)), z)\n-\t\t   && ((significant_bits (z, GET_MODE (z))\n+\t\t   && ((nonzero_bits (z, GET_MODE (z))\n \t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (nz, 0), 0))))\n \t\t       == 0))\n \t    {\n@@ -3746,13 +3747,13 @@ subst (x, from, to, in_dest, unique_copy)\n \t     in undobuf.other_insn.  */\n \t  if (new_code != old_code)\n \t    {\n-\t      unsigned mask;\n+\t      unsigned HOST_WIDE_INT mask;\n \n \t      SUBST (*cc_use, gen_rtx_combine (new_code, GET_MODE (*cc_use),\n \t\t\t\t\t       SET_DEST (x), const0_rtx));\n \n \t      /* If the only change we made was to change an EQ into an\n-\t\t NE or vice versa, OP0 has only one significant bit,\n+\t\t NE or vice versa, OP0 has only one bit that might be nonzero,\n \t\t and OP1 is zero, check if changing the user of the condition\n \t\t code will produce a valid insn.  If it won't, we can keep\n \t\t the original code in that insn by surrounding our operation\n@@ -3763,8 +3764,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t  && ! other_changed && op1 == const0_rtx\n \t\t  && (GET_MODE_BITSIZE (GET_MODE (op0))\n \t\t      <= HOST_BITS_PER_WIDE_INT)\n-\t\t  && (exact_log2 (mask = significant_bits (op0,\n-\t\t\t\t\t\t\t   GET_MODE (op0)))\n+\t\t  && (exact_log2 (mask = nonzero_bits (op0, GET_MODE (op0)))\n \t\t      >= 0))\n \t\t{\n \t\t  rtx pat = PATTERN (other_insn), note = 0;\n@@ -4087,11 +4087,10 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \n     case IOR:\n-      /* (ior A C) is C if all significant bits of A are on in C.  */\n+      /* (ior A C) is C if all bits of A that might be nonzero are on in C.  */\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (significant_bits (XEXP (x, 0), mode)\n-\t      & ~ INTVAL (XEXP (x, 1))) == 0)\n+\t  && (nonzero_bits (XEXP (x, 0), mode) & ~ INTVAL (XEXP (x, 1))) == 0)\n \treturn XEXP (x, 1);\n \n       /* Convert (A & B) | A to A.  */\n@@ -4238,7 +4237,7 @@ subst (x, from, to, in_dest, unique_copy)\n       if (GET_CODE (XEXP (x, 0)) == FFS || GET_CODE (XEXP (x, 0)) == ABS\n \t  || ((GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t       <= HOST_BITS_PER_WIDE_INT)\n-\t      && ((significant_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n+\t      && ((nonzero_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n \t\t   & ((HOST_WIDE_INT) 1\n \t\t      << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1)))\n \t\t  == 0)))\n@@ -4961,8 +4960,7 @@ make_compound_operation (x, in_code)\n       if (ashr_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing\n \t  && lshr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t  && (significant_bits (XEXP (x, 0), mode)\n-\t      & (1 << (mode_width - 1))) == 0)\n+\t  && (nonzero_bits (XEXP (x, 0), mode) & (1 << (mode_width - 1))) == 0)\n \t{\n \t  new = gen_rtx_combine (ASHIFTRT, mode, XEXP (x, 0), XEXP (x, 1));\n \t  break;\n@@ -5473,7 +5471,7 @@ make_field_assignment (x)\n   pos = get_pos_from_mask (~c1, &len);\n   if (pos < 0 || pos + len > GET_MODE_BITSIZE (GET_MODE (dest))\n       || (GET_MODE_BITSIZE (GET_MODE (other)) <= HOST_BITS_PER_WIDE_INT\n-\t  && (c1 & significant_bits (other, GET_MODE (other))) != 0))\n+\t  && (c1 & nonzero_bits (other, GET_MODE (other))) != 0))\n     return x;\n \n   assign = make_extraction (VOIDmode, dest, pos, NULL_RTX, len, 1, 1, 0);\n@@ -5626,7 +5624,7 @@ simplify_and_const_int (x, mode, varop, constop)\n {\n   register enum machine_mode tmode;\n   register rtx temp;\n-  unsigned HOST_WIDE_INT significant;\n+  unsigned HOST_WIDE_INT nonzero;\n \n   /* There is a large class of optimizations based on the principle that\n      some operations produce results where certain bits are known to be zero,\n@@ -5725,8 +5723,7 @@ simplify_and_const_int (x, mode, varop, constop)\n \t      && INTVAL (XEXP (XEXP (varop, 0), 1)) < HOST_BITS_PER_WIDE_INT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && (INTVAL (XEXP (varop, 1))\n-\t\t  & ~ significant_bits (XEXP (varop, 0),\n-\t\t\t\t\tGET_MODE (varop)) == 0))\n+\t\t  & ~ nonzero_bits (XEXP (varop, 0), GET_MODE (varop)) == 0))\n \t    {\n \t      temp = GEN_INT ((INTVAL (XEXP (varop, 1)) & constop)\n \t\t\t      << INTVAL (XEXP (XEXP (varop, 0), 1)));\n@@ -5793,10 +5790,10 @@ simplify_and_const_int (x, mode, varop, constop)\n \t    {\n \t      int i = -1;\n \n-\t      significant = GET_MODE_MASK (GET_MODE (varop));\n-\t      significant >>= INTVAL (XEXP (varop, 1));\n+\t      nonzero = GET_MODE_MASK (GET_MODE (varop));\n+\t      nonzero >>= INTVAL (XEXP (varop, 1));\n \n-\t      if ((constop & ~significant) == 0\n+\t      if ((constop & ~ nonzero) == 0\n \t\t  || (i = exact_log2 (constop)) >= 0)\n \t\t{\n \t\t  varop = simplify_shift_const\n@@ -5817,11 +5814,11 @@ simplify_and_const_int (x, mode, varop, constop)\n \n \tcase NE:\n \t  /* (and (ne FOO 0) CONST) can be (and FOO CONST) if CONST is\n-\t     included in STORE_FLAG_VALUE and FOO has no significant bits\n-\t     not in CONST.  */\n+\t     included in STORE_FLAG_VALUE and FOO has no bits that might be\n+\t     nonzero not in CONST.  */\n \t  if ((constop & ~ STORE_FLAG_VALUE) == 0\n \t      && XEXP (varop, 0) == const0_rtx\n-\t      && (significant_bits (XEXP (varop, 0), mode) & ~ constop) == 0)\n+\t      && (nonzero_bits (XEXP (varop, 0), mode) & ~ constop) == 0)\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -5835,7 +5832,7 @@ simplify_and_const_int (x, mode, varop, constop)\n \t     and possibly the PLUS if it is now adding zero.  */\n \t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && exact_log2 (-constop) >= 0\n-\t      && (significant_bits (XEXP (varop, 0), mode) & ~ constop) == 0)\n+\t      && (nonzero_bits (XEXP (varop, 0), mode) & ~ constop) == 0)\n \t    {\n \t      varop = plus_constant (XEXP (varop, 0),\n \t\t\t\t     INTVAL (XEXP (varop, 1)) & constop);\n@@ -5872,14 +5869,14 @@ simplify_and_const_int (x, mode, varop, constop)\n   if (GET_CODE (varop) == CONST_INT)\n     return GEN_INT (constop & INTVAL (varop));\n \n-  /* See what bits are significant in VAROP.  */\n-  significant = significant_bits (varop, mode);\n+  /* See what bits may be nonzero in VAROP.  */\n+  nonzero = nonzero_bits (varop, mode);\n \n   /* Turn off all bits in the constant that are known to already be zero.\n-     Thus, if the AND isn't needed at all, we will have CONSTOP == SIGNIFICANT\n+     Thus, if the AND isn't needed at all, we will have CONSTOP == NONZERO_BITS\n      which is tested below.  */\n \n-  constop &= significant;\n+  constop &= nonzero;\n \n   /* If we don't have any bits left, return zero.  */\n   if (constop == 0)\n@@ -5899,7 +5896,7 @@ simplify_and_const_int (x, mode, varop, constop)\n     return x ? x : varop;\n \n   /* If we are only masking insignificant bits, return VAROP.  */\n-  if (constop == significant)\n+  if (constop == nonzero)\n     x = varop;\n \n   /* Otherwise, return an AND.  See how much, if any, of X we can use.  */\n@@ -5925,12 +5922,12 @@ simplify_and_const_int (x, mode, varop, constop)\n    a shift, AND, or zero_extract, we can do better.  */\n \n static unsigned HOST_WIDE_INT\n-significant_bits (x, mode)\n+nonzero_bits (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n-  unsigned HOST_WIDE_INT significant = GET_MODE_MASK (mode);\n-  unsigned HOST_WIDE_INT inner_sig;\n+  unsigned HOST_WIDE_INT nonzero = GET_MODE_MASK (mode);\n+  unsigned HOST_WIDE_INT inner_nz;\n   enum rtx_code code;\n   int mode_width = GET_MODE_BITSIZE (mode);\n   rtx tem;\n@@ -5939,14 +5936,14 @@ significant_bits (x, mode)\n   if (GET_MODE_BITSIZE (GET_MODE (x)) > mode_width)\n     {\n       mode = GET_MODE (x);\n-      significant = GET_MODE_MASK (mode);\n+      nonzero = GET_MODE_MASK (mode);\n       mode_width = GET_MODE_BITSIZE (mode);\n     }\n \n   if (mode_width > HOST_BITS_PER_WIDE_INT)\n     /* Our only callers in this case look for single bit values.  So\n        just return the mode mask.  Those tests will then be false.  */\n-    return significant;\n+    return nonzero;\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -5966,21 +5963,21 @@ significant_bits (x, mode)\n \t  sp_alignment = MIN (PUSH_ROUNDING (1), sp_alignment);\n #endif\n \n-\t  return significant & ~ (sp_alignment - 1);\n+\t  return nonzero & ~ (sp_alignment - 1);\n \t}\n #endif\n \n       /* If X is a register whose value we can find, use that value.  \n-\t Otherwise, use the previously-computed significant bits for this\n+\t Otherwise, use the previously-computed nonzero bits for this\n \t register.  */\n \n       tem = get_last_value (x);\n       if (tem)\n-\treturn significant_bits (tem, mode);\n-      else if (significant_valid && reg_significant[REGNO (x)])\n-\treturn reg_significant[REGNO (x)] & significant;\n+\treturn nonzero_bits (tem, mode);\n+      else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n+\treturn reg_nonzero_bits[REGNO (x)] & nonzero;\n       else\n-\treturn significant;\n+\treturn nonzero;\n \n     case CONST_INT:\n       return INTVAL (x);\n@@ -5990,7 +5987,7 @@ significant_bits (x, mode)\n       /* In many, if not most, RISC machines, reading a byte from memory\n \t zeros the rest of the register.  Noticing that fact saves a lot\n \t of extra zero-extends.  */\n-      significant &= GET_MODE_MASK (GET_MODE (x));\n+      nonzero &= GET_MODE_MASK (GET_MODE (x));\n       break;\n #endif\n \n@@ -6002,68 +5999,67 @@ significant_bits (x, mode)\n     case LE:  case LEU:\n \n       if (GET_MODE_CLASS (mode) == MODE_INT)\n-\tsignificant = 1;\n+\tnonzero = 1;\n \n       /* A comparison operation only sets the bits given by its mode.  The\n \t rest are set undefined.  */\n       if (GET_MODE_SIZE (GET_MODE (x)) < mode_width)\n-\tsignificant |= (GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x)));\n+\tnonzero |= (GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x)));\n       break;\n #endif\n \n     case NEG:\n       if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x))\n \t  == GET_MODE_BITSIZE (GET_MODE (x)))\n-\tsignificant = 1;\n+\tnonzero = 1;\n \n       if (GET_MODE_SIZE (GET_MODE (x)) < mode_width)\n-\tsignificant |= (GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x)));\n+\tnonzero |= (GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x)));\n       break;\n \n     case ABS:\n       if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x))\n \t  == GET_MODE_BITSIZE (GET_MODE (x)))\n-\tsignificant = 1;\n+\tnonzero = 1;\n       break;\n \n     case TRUNCATE:\n-      significant &= (significant_bits (XEXP (x, 0), mode)\n-\t\t      & GET_MODE_MASK (mode));\n+      nonzero &= (nonzero_bits (XEXP (x, 0), mode) & GET_MODE_MASK (mode));\n       break;\n \n     case ZERO_EXTEND:\n-      significant &= significant_bits (XEXP (x, 0), mode);\n+      nonzero &= nonzero_bits (XEXP (x, 0), mode);\n       if (GET_MODE (XEXP (x, 0)) != VOIDmode)\n-\tsignificant &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n+\tnonzero &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n       break;\n \n     case SIGN_EXTEND:\n       /* If the sign bit is known clear, this is the same as ZERO_EXTEND.\n \t Otherwise, show all the bits in the outer mode but not the inner\n \t may be non-zero.  */\n-      inner_sig = significant_bits (XEXP (x, 0), mode);\n+      inner_nz = nonzero_bits (XEXP (x, 0), mode);\n       if (GET_MODE (XEXP (x, 0)) != VOIDmode)\n \t{\n-\t  inner_sig &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n-\t  if (inner_sig &\n+\t  inner_nz &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n+\t  if (inner_nz &\n \t      (((HOST_WIDE_INT) 1\n \t\t<< (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1))))\n-\t    inner_sig |= (GET_MODE_MASK (mode)\n+\t    inner_nz |= (GET_MODE_MASK (mode)\n \t\t\t  & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0))));\n \t}\n \n-      significant &= inner_sig;\n+      nonzero &= inner_nz;\n       break;\n \n     case AND:\n-      significant &= (significant_bits (XEXP (x, 0), mode)\n-\t\t      & significant_bits (XEXP (x, 1), mode));\n+      nonzero &= (nonzero_bits (XEXP (x, 0), mode)\n+\t\t  & nonzero_bits (XEXP (x, 1), mode));\n       break;\n \n     case XOR:   case IOR:\n     case UMIN:  case UMAX:  case SMIN:  case SMAX:\n-      significant &= (significant_bits (XEXP (x, 0), mode)\n-\t\t      | significant_bits (XEXP (x, 1), mode));\n+      nonzero &= (nonzero_bits (XEXP (x, 0), mode)\n+\t\t  | nonzero_bits (XEXP (x, 1), mode));\n       break;\n \n     case PLUS:  case MINUS:\n@@ -6075,14 +6071,14 @@ significant_bits (x, mode)\n \t computing the width (position of the highest-order non-zero bit)\n \t and the number of low-order zero bits for each value.  */\n       {\n-\tunsigned HOST_WIDE_INT sig0 = significant_bits (XEXP (x, 0), mode);\n-\tunsigned HOST_WIDE_INT sig1 = significant_bits (XEXP (x, 1), mode);\n-\tint width0 = floor_log2 (sig0) + 1;\n-\tint width1 = floor_log2 (sig1) + 1;\n-\tint low0 = floor_log2 (sig0 & -sig0);\n-\tint low1 = floor_log2 (sig1 & -sig1);\n-\tint op0_maybe_minusp = (sig0 & (1 << (mode_width - 1)));\n-\tint op1_maybe_minusp = (sig1 & (1 << (mode_width - 1)));\n+\tunsigned HOST_WIDE_INT nz0 = nonzero_bits (XEXP (x, 0), mode);\n+\tunsigned HOST_WIDE_INT nz1 = nonzero_bits (XEXP (x, 1), mode);\n+\tint width0 = floor_log2 (nz0) + 1;\n+\tint width1 = floor_log2 (nz1) + 1;\n+\tint low0 = floor_log2 (nz0 & -nz0);\n+\tint low1 = floor_log2 (nz1 & -nz1);\n+\tint op0_maybe_minusp = (nz0 & ((HOST_WIDE_INT) 1 << (mode_width - 1)));\n+\tint op1_maybe_minusp = (nz1 & ((HOST_WIDE_INT) 1 << (mode_width - 1)));\n \tint result_width = mode_width;\n \tint result_low = 0;\n \n@@ -6118,17 +6114,17 @@ significant_bits (x, mode)\n \t  }\n \n \tif (result_width < mode_width)\n-\t  significant &= ((HOST_WIDE_INT) 1 << result_width) - 1;\n+\t  nonzero &= ((HOST_WIDE_INT) 1 << result_width) - 1;\n \n \tif (result_low > 0)\n-\t  significant &= ~ (((HOST_WIDE_INT) 1 << result_low) - 1);\n+\t  nonzero &= ~ (((HOST_WIDE_INT) 1 << result_low) - 1);\n       }\n       break;\n \n     case ZERO_EXTRACT:\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n-\tsignificant &= ((HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n+\tnonzero &= ((HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n       break;\n \n     case SUBREG:\n@@ -6137,25 +6133,25 @@ significant_bits (x, mode)\n \t are zero, though others might be too.  */\n \n       if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x))\n-\tsignificant = (GET_MODE_MASK (GET_MODE (x))\n-\t\t       & significant_bits (SUBREG_REG (x), GET_MODE (x)));\n+\tnonzero = (GET_MODE_MASK (GET_MODE (x))\n+\t\t   & nonzero_bits (SUBREG_REG (x), GET_MODE (x)));\n \n       /* If the inner mode is a single word for both the host and target\n \t machines, we can compute this from which bits of the inner\n-\t object are known significant.  */\n+\t object might be nonzero.  */\n       if (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) <= BITS_PER_WORD\n \t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n \t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n-\t  significant &= significant_bits (SUBREG_REG (x), mode);\n+\t  nonzero &= nonzero_bits (SUBREG_REG (x), mode);\n #if ! defined(BYTE_LOADS_ZERO_EXTEND) && ! defined(BYTE_LOADS_SIGN_EXTEND)\n \t  /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n \t  if (GET_MODE_SIZE (GET_MODE (x))\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t    significant |= (GET_MODE_MASK (GET_MODE (x))\n-\t\t\t    & ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x))));\n+\t    nonzero |= (GET_MODE_MASK (GET_MODE (x))\n+\t\t\t& ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x))));\n #endif\n \t}\n       break;\n@@ -6165,9 +6161,9 @@ significant_bits (x, mode)\n     case ASHIFT:\n     case LSHIFT:\n     case ROTATE:\n-      /* The significant bits are in two classes: any bits within MODE\n+      /* The nonzero bits are in two classes: any bits within MODE\n \t that aren't in GET_MODE (x) are always significant.  The rest of the\n-\t significant bits are those that are significant in the operand of\n+\t nonzero bits are those that are significant in the operand of\n \t the shift when shifted the appropriate number of bits.  This\n \t shows that high-order bits are cleared by the right shift and\n \t low-order bits by left shifts.  */\n@@ -6179,23 +6175,22 @@ significant_bits (x, mode)\n \t  int width = GET_MODE_BITSIZE (inner_mode);\n \t  int count = INTVAL (XEXP (x, 1));\n \t  unsigned HOST_WIDE_INT mode_mask = GET_MODE_MASK (inner_mode);\n-\t  unsigned HOST_WIDE_INT op_significant\n-\t    = significant_bits (XEXP (x, 0), mode);\n-\t  unsigned HOST_WIDE_INT inner = op_significant & mode_mask;\n+\t  unsigned HOST_WIDE_INT op_nonzero = nonzero_bits (XEXP (x, 0), mode);\n+\t  unsigned HOST_WIDE_INT inner = op_nonzero & mode_mask;\n \t  unsigned HOST_WIDE_INT outer = 0;\n \n \t  if (mode_width > width)\n-\t    outer = (op_significant & significant & ~ mode_mask);\n+\t    outer = (op_nonzero & nonzero & ~ mode_mask);\n \n \t  if (code == LSHIFTRT)\n \t    inner >>= count;\n \t  else if (code == ASHIFTRT)\n \t    {\n \t      inner >>= count;\n \n-\t      /* If the sign bit was significant at before the shift, we\n+\t      /* If the sign bit may have been nonzero before the shift, we\n \t\t need to mark all the places it could have been copied to\n-\t\t by the shift significant.  */\n+\t\t by the shift as possibly nonzero.  */\n \t      if (inner & ((HOST_WIDE_INT) 1 << (width - 1 - count)))\n \t\tinner |= (((HOST_WIDE_INT) 1 << count) - 1) << (width - count);\n \t    }\n@@ -6205,22 +6200,22 @@ significant_bits (x, mode)\n \t    inner = ((inner << (count % width)\n \t\t      | (inner >> (width - (count % width)))) & mode_mask);\n \n-\t  significant &= (outer | inner);\n+\t  nonzero &= (outer | inner);\n \t}\n       break;\n \n     case FFS:\n       /* This is at most the number of bits in the mode.  */\n-      significant = ((HOST_WIDE_INT) 1 << (floor_log2 (mode_width) + 1)) - 1;\n+      nonzero = ((HOST_WIDE_INT) 1 << (floor_log2 (mode_width) + 1)) - 1;\n       break;\n \n     case IF_THEN_ELSE:\n-      significant &= (significant_bits (XEXP (x, 1), mode)\n-\t\t      | significant_bits (XEXP (x, 2), mode));\n+      nonzero &= (nonzero_bits (XEXP (x, 1), mode)\n+\t\t  | nonzero_bits (XEXP (x, 2), mode));\n       break;\n     }\n \n-  return significant;\n+  return nonzero;\n }\n \f\n /* Return the number of bits at the high-order end of X that are known to\n@@ -6236,7 +6231,7 @@ num_sign_bit_copies (x, mode)\n   enum rtx_code code = GET_CODE (x);\n   int bitwidth;\n   int num0, num1, result;\n-  unsigned HOST_WIDE_INT sig;\n+  unsigned HOST_WIDE_INT nonzero;\n   rtx tem;\n \n   /* If we weren't given a mode, use the mode of X.  If the mode is still\n@@ -6253,7 +6248,7 @@ num_sign_bit_copies (x, mode)\n   switch (code)\n     {\n     case REG:\n-      if (significant_valid && reg_sign_bit_copies[REGNO (x)] != 0)\n+      if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0)\n \treturn reg_sign_bit_copies[REGNO (x)];\n \n       tem =  get_last_value (x);\n@@ -6270,12 +6265,12 @@ num_sign_bit_copies (x, mode)\n     case CONST_INT:\n       /* If the constant is negative, take its 1's complement and remask.\n \t Then see how many zero bits we have.  */\n-      sig = INTVAL (x) & GET_MODE_MASK (mode);\n+      nonzero = INTVAL (x) & GET_MODE_MASK (mode);\n       if (bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (sig & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n-\tsig = (~ sig) & GET_MODE_MASK (mode);\n+\t  && (nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\tnonzero = (~ nonzero) & GET_MODE_MASK (mode);\n \n-      return (sig == 0 ? bitwidth : bitwidth - floor_log2 (sig) - 1);\n+      return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n \n     case SUBREG:\n       /* If this is a SUBREG for a promoted object that is sign-extended\n@@ -6343,16 +6338,16 @@ num_sign_bit_copies (x, mode)\n     case NEG:\n       /* In general, this subtracts one sign bit copy.  But if the value\n \t is known to be positive, the number of sign bit copies is the\n-\t same as that of the input.  Finally, if the input has just one\n-\t significant bit, all the bits are copies of the sign bit.  */\n-      sig = significant_bits (XEXP (x, 0), mode);\n-      if (sig == 1)\n+\t same as that of the input.  Finally, if the input has just one bit\n+\t that might be nonzero, all the bits are copies of the sign bit.  */\n+      nonzero = nonzero_bits (XEXP (x, 0), mode);\n+      if (nonzero == 1)\n \treturn bitwidth;\n \n       num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n       if (num0 > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (((HOST_WIDE_INT) 1 << (bitwidth - 1)) & sig))\n+\t  && (((HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero))\n \tnum0--;\n \n       return num0;\n@@ -6372,16 +6367,12 @@ num_sign_bit_copies (x, mode)\n \t be 0 or 1, we know the result is either -1 or 0.  */\n \n       if (code == PLUS && XEXP (x, 1) == constm1_rtx\n-\t  /* Don't do this if XEXP (x, 0) is a paradoxical subreg\n-\t     because in principle we don't know what the high bits are.  */\n-\t  && !(GET_CODE (XEXP (x, 0)) == SUBREG\n-\t       && (GET_MODE_SIZE (GET_MODE (XEXP (XEXP (x, 0), 0)))\n-\t\t   < GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))))\n+\t  && bitwidth <= HOST_BITS_PER_INT)\n \t{\n-\t  sig = significant_bits (XEXP (x, 0), mode);\n-\t  if ((((HOST_WIDE_INT) 1 << (bitwidth - 1)) & sig) == 0)\n-\t    return (sig == 1 || sig == 0 ? bitwidth\n-\t\t    : bitwidth - floor_log2 (sig) - 1);\n+\t  nonzero = nonzero_bits (XEXP (x, 0), mode);\n+\t  if ((((HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero) == 0)\n+\t    return (nonzero == 1 || nonzero == 0 ? bitwidth\n+\t\t    : bitwidth - floor_log2 (nonzero) - 1);\n \t}\n \n       num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n@@ -6400,9 +6391,9 @@ num_sign_bit_copies (x, mode)\n       result = bitwidth - (bitwidth - num0) - (bitwidth - num1);\n       if (result > 0\n \t  && bitwidth <= HOST_BITS_PER_INT\n-\t  && ((significant_bits (XEXP (x, 0), mode)\n+\t  && ((nonzero_bits (XEXP (x, 0), mode)\n \t       & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n-\t  && (significant_bits (XEXP (x, 1), mode)\n+\t  && (nonzero_bits (XEXP (x, 1), mode)\n \t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1)) != 0))\n \tresult--;\n \n@@ -6423,7 +6414,7 @@ num_sign_bit_copies (x, mode)\n       result = num_sign_bit_copies (XEXP (x, 0), mode);\n       if (result > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (significant_bits (XEXP (x, 1), mode)\n+\t  && (nonzero_bits (XEXP (x, 1), mode)\n \t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tresult --;\n \n@@ -6433,7 +6424,7 @@ num_sign_bit_copies (x, mode)\n       result = num_sign_bit_copies (XEXP (x, 1), mode);\n       if (result > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (significant_bits (XEXP (x, 1), mode)\n+\t  && (nonzero_bits (XEXP (x, 1), mode)\n \t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tresult --;\n \n@@ -6480,8 +6471,9 @@ num_sign_bit_copies (x, mode)\n   if (bitwidth > HOST_BITS_PER_WIDE_INT)\n     return 1;\n \n-  sig = significant_bits (x, mode);\n-  return sig == GET_MODE_MASK (mode) ? 1 : bitwidth - floor_log2 (sig) - 1;\n+  nonzero = nonzero_bits (x, mode);\n+  return (nonzero == GET_MODE_MASK (mode)\n+\t  ? 1 : bitwidth - floor_log2 (nonzero) - 1);\n }\n \f\n /* Return the number of \"extended\" bits there are in X, when interpreted\n@@ -6501,13 +6493,13 @@ extended_count (x, mode, unsignedp)\n      enum machine_mode mode;\n      int unsignedp;\n {\n-  if (significant_valid == 0)\n+  if (nonzero_sign_valid == 0)\n     return 0;\n \n   return (unsignedp\n \t  ? (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t     && (GET_MODE_BITSIZE (mode) - 1\n-\t\t - floor_log2 (significant_bits (x, mode))))\n+\t\t - floor_log2 (nonzero_bits (x, mode))))\n \t  : num_sign_bit_copies (x, mode) - 1);\n }\n \f\n@@ -6755,7 +6747,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t those machines (such as Vax) that don't have a LSHIFTRT.  */\n       if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && code == ASHIFTRT\n-\t  && ((significant_bits (varop, shift_mode)\n+\t  && ((nonzero_bits (varop, shift_mode)\n \t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (shift_mode) - 1)))\n \t      == 0))\n \tcode = LSHIFTRT;\n@@ -6980,10 +6972,10 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\tbreak;\n \n \t      /* To compute the mask to apply after the shift, shift the\n-\t\t significant bits of the inner shift the same way the \n+\t\t nonzero bits of the inner shift the same way the \n \t\t outer shift will.  */\n \n-\t      mask_rtx = GEN_INT (significant_bits (varop, GET_MODE (varop)));\n+\t      mask_rtx = GEN_INT (nonzero_bits (varop, GET_MODE (varop)));\n \n \t      mask_rtx\n \t\t= simplify_binary_operation (code, result_mode, mask_rtx,\n@@ -7107,15 +7099,15 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  /* convert (lshift (eq FOO 0) C) to (xor FOO 1) if STORE_FLAG_VALUE\n \t     says that the sign bit can be tested, FOO has mode MODE, C is\n \t     GET_MODE_BITSIZE (MODE) - 1, and FOO has only the low-order bit\n-\t     significant.  */\n+\t     may be nonzero.  */\n \t  if (code == LSHIFT\n \t      && XEXP (varop, 1) == const0_rtx\n \t      && GET_MODE (XEXP (varop, 0)) == result_mode\n \t      && count == GET_MODE_BITSIZE (result_mode) - 1\n \t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((STORE_FLAG_VALUE\n \t\t   & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (result_mode) - 1))))\n-\t      && significant_bits (XEXP (varop, 0), result_mode) == 1\n+\t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n \t\t\t\t  &complement_p))\n@@ -7130,7 +7122,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  /* (lshiftrt (neg A) C) where A is either 0 or 1 and C is one less\n \t     than the number of bits in the mode is equivalent to A.  */\n \t  if (code == LSHIFTRT && count == GET_MODE_BITSIZE (result_mode) - 1\n-\t      && significant_bits (XEXP (varop, 0), result_mode) == 1)\n+\t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1)\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      count = 0;\n@@ -7155,7 +7147,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t     equivalent to (xor A 1).  */\n \t  if (code == LSHIFTRT && count == GET_MODE_BITSIZE (result_mode) - 1\n \t      && XEXP (varop, 1) == constm1_rtx\n-\t      && significant_bits (XEXP (varop, 0), result_mode) == 1\n+\t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n \t\t\t\t  &complement_p))\n@@ -7166,27 +7158,27 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t    }\n \n \t  /* If we have (xshiftrt (plus FOO BAR) C), and the only bits\n-\t     significant in BAR are those being shifted out and those\n+\t     that might be nonzero in BAR are those being shifted out and those\n \t     bits are known zero in FOO, we can replace the PLUS with FOO.\n \t     Similarly in the other operand order.  This code occurs when\n \t     we are computing the size of a variable-size array.  */\n \n \t  if ((code == ASHIFTRT || code == LSHIFTRT)\n \t      && count < HOST_BITS_PER_WIDE_INT\n-\t      && significant_bits (XEXP (varop, 1), result_mode) >> count == 0\n-\t      && (significant_bits (XEXP (varop, 1), result_mode)\n-\t\t  & significant_bits (XEXP (varop, 0), result_mode)) == 0)\n+\t      && nonzero_bits (XEXP (varop, 1), result_mode) >> count == 0\n+\t      && (nonzero_bits (XEXP (varop, 1), result_mode)\n+\t\t  & nonzero_bits (XEXP (varop, 0), result_mode)) == 0)\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n \t    }\n \t  else if ((code == ASHIFTRT || code == LSHIFTRT)\n \t\t   && count < HOST_BITS_PER_WIDE_INT\n \t\t   && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n+\t\t   && 0 == (nonzero_bits (XEXP (varop, 0), result_mode)\n \t\t\t    >> count)\n-\t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n-\t\t\t    & significant_bits (XEXP (varop, 1),\n+\t\t   && 0 == (nonzero_bits (XEXP (varop, 0), result_mode)\n+\t\t\t    & nonzero_bits (XEXP (varop, 1),\n \t\t\t\t\t\t result_mode)))\n \t    {\n \t      varop = XEXP (varop, 1);\n@@ -7659,7 +7651,7 @@ simplify_comparison (code, pop0, pop1)\n     {\n       /* If both operands are the same constant shift, see if we can ignore the\n \t shift.  We can if the shift is a rotate or if the bits shifted out of\n-\t this shift are not significant for either input and if the type of\n+\t this shift are known to be zero for both inputs and if the type of\n \t comparison is compatible with the shift.  */\n       if (GET_CODE (op0) == GET_CODE (op1)\n \t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n@@ -7684,8 +7676,8 @@ simplify_comparison (code, pop0, pop1)\n \t  else if (GET_CODE (op0) == ASHIFT || GET_CODE (op0) == LSHIFT)\n \t    mask = (mask & (mask << shift_count)) >> shift_count;\n \n-\t  if ((significant_bits (XEXP (op0, 0), mode) & ~ mask) == 0\n-\t      && (significant_bits (XEXP (op1, 0), mode) & ~ mask) == 0)\n+\t  if ((nonzero_bits (XEXP (op0, 0), mode) & ~ mask) == 0\n+\t      && (nonzero_bits (XEXP (op1, 0), mode) & ~ mask) == 0)\n \t    op0 = XEXP (op0, 0), op1 = XEXP (op1, 0);\n \t  else\n \t    break;\n@@ -7695,9 +7687,9 @@ simplify_comparison (code, pop0, pop1)\n \t SUBREGs are of the same mode, and, in both cases, the AND would\n \t be redundant if the comparison was done in the narrower mode,\n \t do the comparison in the narrower mode (e.g., we are AND'ing with 1\n-\t and the operand's significant bits are 0xffffff01; in that case if\n-\t we only care about QImode, we don't need the AND).  This case occurs\n-\t if the output mode of an scc insn is not SImode and\n+\t and the operand's possibly nonzero bits are 0xffffff01; in that case\n+\t if we only care about QImode, we don't need the AND).  This case\n+\t occurs if the output mode of an scc insn is not SImode and\n \t STORE_FLAG_VALUE == 1 (e.g., the 386).  */\n \n       else if  (GET_CODE (op0) == AND && GET_CODE (op1) == AND\n@@ -7711,10 +7703,10 @@ simplify_comparison (code, pop0, pop1)\n \t\t    == GET_MODE (SUBREG_REG (XEXP (op1, 0))))\n \t\t&& (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n \t\t    <= HOST_BITS_PER_WIDE_INT)\n-\t\t&& (significant_bits (SUBREG_REG (XEXP (op0, 0)),\n+\t\t&& (nonzero_bits (SUBREG_REG (XEXP (op0, 0)),\n \t\t\t\t      GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n \t\t    & ~ INTVAL (XEXP (op0, 1))) == 0\n-\t\t&& (significant_bits (SUBREG_REG (XEXP (op1, 0)),\n+\t\t&& (nonzero_bits (SUBREG_REG (XEXP (op1, 0)),\n \t\t\t\t      GET_MODE (SUBREG_REG (XEXP (op1, 0))))\n \t\t    & ~ INTVAL (XEXP (op1, 1))) == 0)\n \t{\n@@ -7770,15 +7762,15 @@ simplify_comparison (code, pop0, pop1)\n \tconst_op &= mask;\n \n       /* If we are comparing against a constant power of two and the value\n-\t being compared has only that single significant bit (e.g., it was\n+\t being compared can only have that single bit nonzero (e.g., it was\n \t `and'ed with that bit), we can replace this with a comparison\n \t with zero.  */\n       if (const_op\n \t  && (code == EQ || code == NE || code == GE || code == GEU\n \t      || code == LT || code == LTU)\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && exact_log2 (const_op) >= 0\n-\t  && significant_bits (op0, mode) == const_op)\n+\t  && nonzero_bits (op0, mode) == const_op)\n \t{\n \t  code = (code == EQ || code == GE || code == GEU ? NE : EQ);\n \t  op1 = const0_rtx, const_op = 0;\n@@ -7827,7 +7819,7 @@ simplify_comparison (code, pop0, pop1)\n \t     a zero sign bit, we can replace this with == 0.  */\n \t  else if (const_op == 0\n \t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (significant_bits (op0, mode)\n+\t\t   && (nonzero_bits (op0, mode)\n \t\t       & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)\n \t    code = EQ;\n \t  break;\n@@ -7857,7 +7849,7 @@ simplify_comparison (code, pop0, pop1)\n \t     a zero sign bit, we can replace this with != 0.  */\n \t  else if (const_op == 0\n \t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (significant_bits (op0, mode)\n+\t\t   && (nonzero_bits (op0, mode)\n \t\t       & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)\n \t    code = NE;\n \t  break;\n@@ -8021,7 +8013,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (sign_bit_comparison_p\n \t      && (GET_CODE (XEXP (op0, 0)) == ABS\n \t\t  || (mode_width <= HOST_BITS_PER_WIDE_INT\n-\t\t      && (significant_bits (XEXP (op0, 0), mode)\n+\t\t      && (nonzero_bits (XEXP (op0, 0), mode)\n \t\t\t  & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n@@ -8113,8 +8105,8 @@ simplify_comparison (code, pop0, pop1)\n \t      && (- INTVAL (XEXP (SUBREG_REG (op0), 1))\n \t\t  < GET_MODE_MASK (mode) / 2)\n \t      && (unsigned) const_op < GET_MODE_MASK (mode) / 2\n-\t      && (0 == (significant_bits (XEXP (SUBREG_REG (op0), 0),\n-\t\t\t\t\t  GET_MODE (SUBREG_REG (op0)))\n+\t      && (0 == (nonzero_bits (XEXP (SUBREG_REG (op0), 0),\n+\t\t\t\t      GET_MODE (SUBREG_REG (op0)))\n \t\t\t& ~ GET_MODE_MASK (mode))\n \t\t  || (num_sign_bit_copies (XEXP (SUBREG_REG (op0), 0),\n \t\t\t\t\t   GET_MODE (SUBREG_REG (op0)))\n@@ -8322,7 +8314,7 @@ simplify_comparison (code, pop0, pop1)\n \tcase LSHIFT:\n \t  /* If we have (compare (xshift FOO N) (const_int C)) and\n \t     the high order N bits of FOO (N+1 if an inequality comparison)\n-\t     are not significant, we can do this by comparing FOO with C\n+\t     are known to be zero, we can do this by comparing FOO with C\n \t     shifted right N bits so long as the low-order N bits of C are\n \t     zero.  */\n \t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n@@ -8332,7 +8324,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && ((const_op\n \t\t   &  ((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1) == 0)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t      && (significant_bits (XEXP (op0, 0), mode)\n+\t      && (nonzero_bits (XEXP (op0, 0), mode)\n \t\t  & ~ (mask >> (INTVAL (XEXP (op0, 1))\n \t\t\t\t+ ! equality_comparison_p))) == 0)\n \t    {\n@@ -8399,14 +8391,14 @@ simplify_comparison (code, pop0, pop1)\n \t  /* ... fall through ... */\n \tcase LSHIFTRT:\n \t  /* If we have (compare (xshiftrt FOO N) (const_int C)) and\n-\t     the low order N bits of FOO are not significant, we can do this\n+\t     the low order N bits of FOO are known to be zero, we can do this\n \t     by comparing FOO with C shifted left N bits so long as no\n \t     overflow occurs.  */\n \t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && INTVAL (XEXP (op0, 1)) >= 0\n \t      && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t      && (significant_bits (XEXP (op0, 0), mode)\n+\t      && (nonzero_bits (XEXP (op0, 0), mode)\n \t\t  & (((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1)) == 0\n \t      && (const_op == 0\n \t\t  || (floor_log2 (const_op) + INTVAL (XEXP (op0, 1))\n@@ -8460,11 +8452,11 @@ simplify_comparison (code, pop0, pop1)\n \t   && (code == NE || code == EQ)\n \t   && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n \t       <= HOST_BITS_PER_WIDE_INT)\n-\t   && (significant_bits (SUBREG_REG (op0), GET_MODE (SUBREG_REG (op0)))\n+\t   && (nonzero_bits (SUBREG_REG (op0), GET_MODE (SUBREG_REG (op0)))\n \t       & ~ GET_MODE_MASK (GET_MODE (op0))) == 0\n \t   && (tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)),\n \t\t\t\t\t      op1),\n-\t       (significant_bits (tem, GET_MODE (SUBREG_REG (op0)))\n+\t       (nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n \t\t& ~ GET_MODE_MASK (GET_MODE (op0))) == 0))\n     op0 = SUBREG_REG (op0), op1 = tem;\n \n@@ -8484,16 +8476,14 @@ simplify_comparison (code, pop0, pop1)\n \t tmode = GET_MODE_WIDER_MODE (tmode))\n       if (cmp_optab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n \t{\n-\t  /* If the only significant bits in OP0 and OP1 are those in the\n+\t  /* If the only nonzero bits in OP0 and OP1 are those in the\n \t     narrower mode and this is an equality or unsigned comparison,\n \t     we can use the wider mode.  Similarly for sign-extended\n \t     values and equality or signed comparisons.  */\n \t  if (((code == EQ || code == NE\n \t\t|| code == GEU || code == GTU || code == LEU || code == LTU)\n-\t       && ((significant_bits (op0, tmode) & ~ GET_MODE_MASK (mode))\n-\t\t   == 0)\n-\t       && ((significant_bits (op1, tmode) & ~ GET_MODE_MASK (mode))\n-\t\t   == 0))\n+\t       && (nonzero_bits (op0, tmode) & ~ GET_MODE_MASK (mode)) == 0\n+\t       && (nonzero_bits (op1, tmode) & ~ GET_MODE_MASK (mode)) == 0)\n \t      || ((code == EQ || code == NE\n \t\t   || code == GE || code == GT || code == LE || code == LT)\n \t\t  && (num_sign_bit_copies (op0, tmode)"}]}