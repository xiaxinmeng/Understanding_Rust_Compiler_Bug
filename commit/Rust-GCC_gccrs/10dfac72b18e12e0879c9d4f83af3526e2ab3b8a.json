{"sha": "10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBkZmFjNzJiMThlMTJlMDg3OWM5ZDRmODNhZjM1MjZlMmFiM2I4YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-07T10:26:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-07T10:26:56Z"}, "message": "[multiple changes]\n\n2015-01-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Predicated_Loop): Handle properly loops\n\tover static predicates when the loop parameter specification\n\tcarries a Reverse indicator.\n\n2015-01-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Instantiate_Object): If formal has a default,\n\tactual is missing and formal has an anonymous access type, copy\n\taccess definition in full so that tree for instance is properly\n\tformatted for ASIS use.\n\n2015-01-07  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Check_Internal_Call_Continue): Give a warning\n\tfor P'Access, where P is a subprogram in the same package as\n\tthe P'Access, and the P'Access is evaluated at elaboration\n\ttime, and occurs before the body of P. For example, \"X : T :=\n\tP'Access;\" would allow a subsequent call to X.all to be an\n\taccess-before-elaboration error; hence the warning. This warning\n\tis enabled by the -gnatw.f switch.\n\t* opt.ads (Warn_On_Elab_Access): New flag for warning switch.\n\t* warnsw.adb (Set_Dot_Warning_Switch): Set Warn_On_Elab_Access.\n\t* gnat_ugn.texi: Document the new warning.\n\nFrom-SVN: r219293", "tree": {"sha": "f501ba9ae8ea2bfa09e47d1a4bffbe9b637ac839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f501ba9ae8ea2bfa09e47d1a4bffbe9b637ac839"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/comments", "author": null, "committer": null, "parents": [{"sha": "ccfe725bc63fb3e3f279f1995a13b8b585bd6468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccfe725bc63fb3e3f279f1995a13b8b585bd6468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccfe725bc63fb3e3f279f1995a13b8b585bd6468"}], "stats": {"total": 227, "additions": 178, "deletions": 49}, "files": [{"sha": "82a7b793b7ce45c06f46303aeb56c2e59d3691da", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -1,3 +1,29 @@\n+2015-01-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Predicated_Loop): Handle properly loops\n+\tover static predicates when the loop parameter specification\n+\tcarries a Reverse indicator.\n+\n+2015-01-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Instantiate_Object): If formal has a default,\n+\tactual is missing and formal has an anonymous access type, copy\n+\taccess definition in full so that tree for instance is properly\n+\tformatted for ASIS use.\n+\n+2015-01-07  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Check_Internal_Call_Continue): Give a warning\n+\tfor P'Access, where P is a subprogram in the same package as\n+\tthe P'Access, and the P'Access is evaluated at elaboration\n+\ttime, and occurs before the body of P. For example, \"X : T :=\n+\tP'Access;\" would allow a subsequent call to X.all to be an\n+\taccess-before-elaboration error; hence the warning. This warning\n+\tis enabled by the -gnatw.f switch.\n+\t* opt.ads (Warn_On_Elab_Access): New flag for warning switch.\n+\t* warnsw.adb (Set_Dot_Warning_Switch): Set Warn_On_Elab_Access.\n+\t* gnat_ugn.texi: Document the new warning.\n+\n 2015-01-07  Johannes Kanig  <kanig@adacore.com>\n \n \t* lib-xref-spark_specific.adb (Collect_SPARK_Xrefs): Skip unneeded"}, {"sha": "5e7f79e15698de37e02d2126130b2edf459bf2d9", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 85, "deletions": 34, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -4120,11 +4120,14 @@ package body Exp_Ch5 is\n       --        end loop;\n       --     end;\n \n+      --  with min-val replaced by max-val and Succ replaced by Pred if the\n+      --  loop parameter specification carries a Reverse indicator.\n+\n       --  To make this a little clearer, let's take a specific example:\n \n       --        type Int is range 1 .. 10;\n-      --        subtype L is Int with\n-      --          predicate => L in 3 | 10 | 5 .. 7;\n+      --        subtype StaticP is Int with\n+      --          predicate => StaticP in 3 | 10 | 5 .. 7;\n       --          ...\n       --        for L in StaticP loop\n       --           Put_Line (\"static:\" & J'Img);\n@@ -4210,38 +4213,91 @@ package body Exp_Ch5 is\n             --  Loop to create branches of case statement\n \n             Alts := New_List;\n-            P := First (Stat);\n-            while Present (P) loop\n-               if No (Next (P)) then\n-                  S := Make_Exit_Statement (Loc);\n-               else\n-                  S :=\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Loop_Id, Loc),\n-                      Expression => Lo_Val (Next (P)));\n-                  Set_Suppress_Assignment_Checks (S);\n-               end if;\n \n-               Append_To (Alts,\n-                 Make_Case_Statement_Alternative (Loc,\n-                   Statements       => New_List (S),\n-                   Discrete_Choices => New_List (Hi_Val (P))));\n+            if Reverse_Present (LPS) then\n \n-               Next (P);\n-            end loop;\n+               --  Initial value is largest value in predicate.\n+\n+               D :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Loop_Id,\n+                   Object_Definition   => New_Occurrence_Of (Ltype, Loc),\n+                   Expression          => Hi_Val (Last (Stat)));\n+\n+               P := Last (Stat);\n+               while Present (P) loop\n+                  if No (Prev (P)) then\n+                     S := Make_Exit_Statement (Loc);\n+                  else\n+                     S :=\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Occurrence_Of (Loop_Id, Loc),\n+                         Expression => Hi_Val (Prev (P)));\n+                     Set_Suppress_Assignment_Checks (S);\n+                  end if;\n+\n+                  Append_To (Alts,\n+                    Make_Case_Statement_Alternative (Loc,\n+                      Statements       => New_List (S),\n+                      Discrete_Choices => New_List (Lo_Val (P))));\n+\n+                  Prev (P);\n+               end loop;\n+\n+            else\n+\n+               --  Initial value is smallest value in predicate.\n+\n+               D :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Loop_Id,\n+                   Object_Definition   => New_Occurrence_Of (Ltype, Loc),\n+                   Expression          => Lo_Val (First (Stat)));\n+\n+               P := First (Stat);\n+               while Present (P) loop\n+                  if No (Next (P)) then\n+                     S := Make_Exit_Statement (Loc);\n+                  else\n+                     S :=\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Occurrence_Of (Loop_Id, Loc),\n+                         Expression => Lo_Val (Next (P)));\n+                     Set_Suppress_Assignment_Checks (S);\n+                  end if;\n+\n+                  Append_To (Alts,\n+                    Make_Case_Statement_Alternative (Loc,\n+                      Statements       => New_List (S),\n+                      Discrete_Choices => New_List (Hi_Val (P))));\n+\n+                  Next (P);\n+               end loop;\n+            end if;\n \n             --  Add others choice\n \n-            S :=\n-               Make_Assignment_Statement (Loc,\n-                 Name       => New_Occurrence_Of (Loop_Id, Loc),\n-                 Expression =>\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix => New_Occurrence_Of (Ltype, Loc),\n-                     Attribute_Name => Name_Succ,\n-                     Expressions    => New_List (\n-                       New_Occurrence_Of (Loop_Id, Loc))));\n-            Set_Suppress_Assignment_Checks (S);\n+            declare\n+               Name_Next : Name_Id;\n+\n+            begin\n+               if Reverse_Present (LPS) then\n+                  Name_Next := Name_Pred;\n+               else\n+                  Name_Next := Name_Succ;\n+               end if;\n+\n+               S :=\n+                  Make_Assignment_Statement (Loc,\n+                    Name       => New_Occurrence_Of (Loop_Id, Loc),\n+                    Expression =>\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix => New_Occurrence_Of (Ltype, Loc),\n+                        Attribute_Name => Name_Next,\n+                        Expressions    => New_List (\n+                          New_Occurrence_Of (Loop_Id, Loc))));\n+               Set_Suppress_Assignment_Checks (S);\n+            end;\n \n             Append_To (Alts,\n               Make_Case_Statement_Alternative (Loc,\n@@ -4258,11 +4314,6 @@ package body Exp_Ch5 is\n \n             --  Rewrite the loop\n \n-            D :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Loop_Id,\n-                Object_Definition   => New_Occurrence_Of (Ltype, Loc),\n-                Expression          => Lo_Val (First (Stat)));\n             Set_Suppress_Assignment_Checks (D);\n \n             Rewrite (N,"}, {"sha": "17f2414ea4923642cb8abe828fc15c66b04bc3c3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -5048,6 +5048,23 @@ combination @option{-gnatwu} followed by @option{-gnatwF} has the\n effect of warning on unreferenced entities other than subprogram\n formals.\n \n+@item -gnatw.f\n+@emph{Activate warnings on suspicious subprogram 'Access.}\n+@cindex @option{-gnatw.f} (@command{gcc})\n+This switch causes a warning to be generated if @code{P'Access} occurs\n+in the same package where subprogram P is declared, and the\n+@code{P'Access} is evaluated at elaboration time, and occurs before\n+the body of P has been elaborated. For example, if we have\n+@code{X : T := P'Access;}, then if X.all is subsequently called before\n+the body of P is elaborated, it could cause\n+access-before-elaboration. The default is that these warnings are not\n+generated.\n+\n+@item -gnatw.F\n+@emph{Suppress warnings on suspicious subprogram 'Access.}\n+@cindex @option{-gnatw.F} (@command{gcc})\n+This switch suppresses warnings for suspicious subprogram 'Access.\n+\n @item -gnatwg\n @emph{Activate warnings on unrecognized pragmas.}\n @cindex @option{-gnatwg} (@command{gcc})"}, {"sha": "e30af5c9cc406f2bd70440eaa9a65c487d6be504", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -1669,6 +1669,13 @@ package Opt is\n    --  Set to True to generate warnings for suspicious use of export or\n    --  import pragmas. Modified by use of -gnatwx/X.\n \n+   Warn_On_Elab_Access : Boolean := False;\n+   --  GNAT\n+   --  Set to True to generate warnings for P'Access in the case where\n+   --  subprogram P is in the same package as the P'Access, and the P'Access is\n+   --  evaluated at package elaboration time, and occurs before the body of P\n+   --  has been elaborated.\n+\n    Warn_On_Hiding : Boolean := False;\n    --  GNAT\n    --  Set to True to generate warnings if a declared entity hides another"}, {"sha": "e65b9095c96cd0f95c8778dddef05765f87f2c8f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -9884,6 +9884,8 @@ package body Sem_Ch12 is\n       Subt_Mark   : Node_Id             := Empty;\n \n    begin\n+      --  Formal may be an anonymous access\n+\n       if Present (Subtype_Mark (Formal)) then\n          Subt_Mark := Subtype_Mark (Formal);\n       else\n@@ -10140,29 +10142,32 @@ package body Sem_Ch12 is\n             --  Use default to construct declaration\n \n             if Present (Subt_Mark) then\n-               Def := Subt_Mark;\n+               Def := New_Copy (Subt_Mark);\n+\n             else pragma Assert (Present (Acc_Def));\n-               Def := Acc_Def;\n+\n+               --  If formal is an anonymous access, copy access definition of\n+               --  formal for object declaration.\n+\n+               Def := New_Copy_Tree (Acc_Def);\n             end if;\n \n             Decl_Node :=\n               Make_Object_Declaration (Sloc (Formal),\n                 Defining_Identifier    => New_Copy (Gen_Obj),\n                 Constant_Present       => True,\n                 Null_Exclusion_Present => Null_Exclusion_Present (Formal),\n-                Object_Definition      => New_Copy (Def),\n+                Object_Definition      => Def,\n                 Expression             => New_Copy_Tree\n                                             (Default_Expression (Formal)));\n \n             Append (Decl_Node, List);\n             Set_Analyzed (Expression (Decl_Node), False);\n \n          else\n-            Error_Msg_NE\n-              (\"missing actual&\",\n-                Instantiation_Node, Gen_Obj);\n+            Error_Msg_NE (\"missing actual&\", Instantiation_Node, Gen_Obj);\n             Error_Msg_NE (\"\\in instantiation of & declared#\",\n-              Instantiation_Node, Scope (A_Gen_Obj));\n+                          Instantiation_Node, Scope (A_Gen_Obj));\n \n             if Is_Scalar_Type (Etype (A_Gen_Obj)) then\n "}, {"sha": "227469a1c27f9c52f1f064d952e552731f21d3c2", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -1990,18 +1990,29 @@ package body Sem_Elab is\n       Inst_Case : constant Boolean := Nkind (N) in N_Generic_Instantiation;\n \n    begin\n-      --  If not function or procedure call or instantiation, then ignore\n-      --  call (this happens in some error cases and rewriting cases).\n+      --  For P'Access, we want to warn if the -gnatw.f switch is set, and the\n+      --  node comes from source.\n \n-      if not Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement)\n+      if Nkind (N) = N_Attribute_Reference and then\n+        (not Warn_On_Elab_Access or else not Comes_From_Source (N))\n+      then\n+         return;\n+\n+      --  If not function or procedure call, instantiation, or 'Access, then\n+      --  ignore call (this happens in some error cases and rewriting cases).\n+\n+      elsif not Nkind_In\n+               (N, N_Function_Call,\n+                   N_Procedure_Call_Statement,\n+                   N_Attribute_Reference)\n         and then not Inst_Case\n       then\n          return;\n \n       --  Nothing to do if this is a call or instantiation that has already\n       --  been found to be a sure ABE.\n \n-      elsif ABE_Is_Certain (N) then\n+      elsif Nkind (N) /= N_Attribute_Reference and then ABE_Is_Certain (N) then\n          return;\n \n       --  Nothing to do if errors already detected (avoid cascaded errors)\n@@ -2323,21 +2334,27 @@ package body Sem_Elab is\n       --  Not that special case, warning and dynamic check is required\n \n       --  If we have nothing in the call stack, then this is at the outer\n-      --  level, and the ABE is bound to occur.\n+      --  level, and the ABE is bound to occur, unless it's a 'Access.\n \n       if Elab_Call.Last = 0 then\n          Error_Msg_Warn := SPARK_Mode /= On;\n \n          if Inst_Case then\n             Error_Msg_NE\n               (\"cannot instantiate& before body seen<<\", N, Orig_Ent);\n-         else\n+         elsif Nkind (N) /= N_Attribute_Reference then\n             Error_Msg_NE\n               (\"cannot call& before body seen<<\", N, Orig_Ent);\n+         else\n+            Error_Msg_NE\n+              (\"Access attribute of & before body seen<<\", N, Orig_Ent);\n+            Error_Msg_N (\"\\possible Program_Error on later references<\", N);\n          end if;\n \n-         Error_Msg_N (\"\\Program_Error [<<\", N);\n-         Insert_Elab_Check (N);\n+         if Nkind (N) /= N_Attribute_Reference then\n+            Error_Msg_N (\"\\Program_Error [<<\", N);\n+            Insert_Elab_Check (N);\n+         end if;\n \n       --  Call is not at outer level\n "}, {"sha": "38f7d39b1e435737a0976804cc732383ce40defe", "filename": "gcc/ada/warnsw.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fwarnsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dfac72b18e12e0879c9d4f83af3526e2ab3b8a/gcc%2Fada%2Fwarnsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.adb?ref=10dfac72b18e12e0879c9d4f83af3526e2ab3b8a", "patch": "@@ -326,6 +326,12 @@ package body Warnsw is\n          when 'e' =>\n             All_Warnings (True);\n \n+         when 'f' =>\n+            Warn_On_Elab_Access                 := True;\n+\n+         when 'F' =>\n+            Warn_On_Elab_Access                 := False;\n+\n          when 'g' =>\n             Set_GNAT_Mode_Warnings;\n "}]}