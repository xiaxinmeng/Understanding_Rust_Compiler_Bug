{"sha": "7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjNTJiYzg1ZTkwZWQ3MWU2N2M0NDNmMTQxMzdmMmZjZjZhZGYzYw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-11T19:10:42Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-13T07:34:48Z"}, "message": "Refactor VRP threading code into vrp_jump_threader class.\n\ngcc/ChangeLog:\n\n\t* tree-vrp.c (identify_jump_threads): Refactor to..\n\t(vrp_jump_threader::vrp_jump_threader): ...here\n\t(vrp_jump_threader::~vrp_jump_threader): ...and here.\n\t(vrp_jump_threader::after_dom_children): Rename vr_values to\n\tm_vr_values.\n\t(execute_vrp): Use vrp_jump_threader.", "tree": {"sha": "e0a0d23d1701a01278b0611f4b8e9c5fa5dc73ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0a0d23d1701a01278b0611f4b8e9c5fa5dc73ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39"}], "stats": {"total": 144, "additions": 72, "deletions": 72}, "files": [{"sha": "6b77c357a8f7bea8ceb334c1832f56fd30f81005", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc52bc85e90ed71e67c443f14137f2fcf6adf3c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7cc52bc85e90ed71e67c443f14137f2fcf6adf3c", "patch": "@@ -4152,32 +4152,87 @@ vrp_prop::finalize ()\n     }\n }\n \n+/* Blocks which have more than one predecessor and more than\n+   one successor present jump threading opportunities, i.e.,\n+   when the block is reached from a specific predecessor, we\n+   may be able to determine which of the outgoing edges will\n+   be traversed.  When this optimization applies, we are able\n+   to avoid conditionals at runtime and we may expose secondary\n+   optimization opportunities.\n+\n+   This class is effectively a driver for the generic jump\n+   threading code.  It basically just presents the generic code\n+   with edges that may be suitable for jump threading.\n+\n+   Unlike DOM, we do not iterate VRP if jump threading was successful.\n+   While iterating may expose new opportunities for VRP, it is expected\n+   those opportunities would be very limited and the compile time cost\n+   to expose those opportunities would be significant.\n+\n+   As jump threading opportunities are discovered, they are registered\n+   for later realization.  */\n+\n class vrp_jump_threader : public dom_walker\n {\n public:\n-  vrp_jump_threader (cdi_direction direction,\n-\t\t     class const_and_copies *const_and_copies,\n-\t\t     class avail_exprs_stack *avail_exprs_stack)\n-    : dom_walker (direction, REACHABLE_BLOCKS),\n-      m_const_and_copies (const_and_copies),\n-      m_avail_exprs_stack (avail_exprs_stack),\n-      m_dummy_cond (NULL) {}\n-\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n+  vrp_jump_threader (struct function *, vr_values *);\n+  ~vrp_jump_threader ();\n \n-  class vr_values *vr_values;\n+  void thread_jumps ()\n+  {\n+    walk (m_fun->cfg->x_entry_block_ptr);\n+  }\n \n private:\n   static tree simplify_stmt (gimple *stmt, gimple *within_stmt,\n \t\t\t     avail_exprs_stack *, basic_block);\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n \n-  class const_and_copies *m_const_and_copies;\n-  class avail_exprs_stack *m_avail_exprs_stack;\n-\n+  function *m_fun;\n+  vr_values *m_vr_values;\n+  const_and_copies *m_const_and_copies;\n+  avail_exprs_stack *m_avail_exprs_stack;\n+  hash_table<expr_elt_hasher> *m_avail_exprs;\n   gcond *m_dummy_cond;\n };\n \n+vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n+  : dom_walker (CDI_DOMINATORS, REACHABLE_BLOCKS)\n+{\n+  /* Ugh.  When substituting values earlier in this pass we can wipe\n+     the dominance information.  So rebuild the dominator information\n+     as we need it within the jump threading code.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* We do not allow VRP information to be used for jump threading\n+     across a back edge in the CFG.  Otherwise it becomes too\n+     difficult to avoid eliminating loop exit tests.  Of course\n+     EDGE_DFS_BACK is not accurate at this time so we have to\n+     recompute it.  */\n+  mark_dfs_back_edges ();\n+\n+  /* Allocate our unwinder stack to unwind any temporary equivalences\n+     that might be recorded.  */\n+  m_const_and_copies = new const_and_copies ();\n+\n+  m_dummy_cond = NULL;\n+  m_fun = fun;\n+  m_vr_values = v;\n+  m_avail_exprs = new hash_table<expr_elt_hasher> (1024);\n+  m_avail_exprs_stack = new avail_exprs_stack (m_avail_exprs);\n+}\n+\n+vrp_jump_threader::~vrp_jump_threader ()\n+{\n+  /* We do not actually update the CFG or SSA graphs at this point as\n+     ASSERT_EXPRs are still in the IL and cfg cleanup code does not\n+     yet handle ASSERT_EXPRs gracefully.  */\n+  delete m_const_and_copies;\n+  delete m_avail_exprs;\n+  delete m_avail_exprs_stack;\n+}\n+\n /* Called before processing dominator children of BB.  We want to look\n    at ASSERT_EXPRs and record information from them in the appropriate\n    tables.\n@@ -4295,7 +4350,7 @@ vrp_jump_threader::after_dom_children (basic_block bb)\n \t\t\t\t      integer_zero_node, integer_zero_node,\n \t\t\t\t      NULL, NULL);\n \n-  x_vr_values = vr_values;\n+  x_vr_values = m_vr_values;\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack, NULL,\n \t\t\t simplify_stmt);\n@@ -4305,62 +4360,6 @@ vrp_jump_threader::after_dom_children (basic_block bb)\n   m_const_and_copies->pop_to_marker ();\n }\n \n-/* Blocks which have more than one predecessor and more than\n-   one successor present jump threading opportunities, i.e.,\n-   when the block is reached from a specific predecessor, we\n-   may be able to determine which of the outgoing edges will\n-   be traversed.  When this optimization applies, we are able\n-   to avoid conditionals at runtime and we may expose secondary\n-   optimization opportunities.\n-\n-   This routine is effectively a driver for the generic jump\n-   threading code.  It basically just presents the generic code\n-   with edges that may be suitable for jump threading.\n-\n-   Unlike DOM, we do not iterate VRP if jump threading was successful.\n-   While iterating may expose new opportunities for VRP, it is expected\n-   those opportunities would be very limited and the compile time cost\n-   to expose those opportunities would be significant.\n-\n-   As jump threading opportunities are discovered, they are registered\n-   for later realization.  */\n-\n-static void\n-identify_jump_threads (struct function *fun, class vr_values *vr_values)\n-{\n-  /* Ugh.  When substituting values earlier in this pass we can\n-     wipe the dominance information.  So rebuild the dominator\n-     information as we need it within the jump threading code.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* We do not allow VRP information to be used for jump threading\n-     across a back edge in the CFG.  Otherwise it becomes too\n-     difficult to avoid eliminating loop exit tests.  Of course\n-     EDGE_DFS_BACK is not accurate at this time so we have to\n-     recompute it.  */\n-  mark_dfs_back_edges ();\n-\n-  /* Allocate our unwinder stack to unwind any temporary equivalences\n-     that might be recorded.  */\n-  const_and_copies *equiv_stack = new const_and_copies ();\n-\n-  hash_table<expr_elt_hasher> *avail_exprs\n-    = new hash_table<expr_elt_hasher> (1024);\n-  avail_exprs_stack *avail_exprs_stack\n-    = new class avail_exprs_stack (avail_exprs);\n-\n-  vrp_jump_threader walker (CDI_DOMINATORS, equiv_stack, avail_exprs_stack);\n-  walker.vr_values = vr_values;\n-  walker.walk (fun->cfg->x_entry_block_ptr);\n-\n-  /* We do not actually update the CFG or SSA graphs at this point as\n-     ASSERT_EXPRs are still in the IL and cfg cleanup code does not yet\n-     handle ASSERT_EXPRs gracefully.  */\n-  delete equiv_stack;\n-  delete avail_exprs;\n-  delete avail_exprs_stack;\n-}\n-\n /* STMT is a conditional at the end of a basic block.\n \n    If the conditional is of the form SSA_NAME op constant and the SSA_NAME\n@@ -4516,7 +4515,8 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n \n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */\n-  identify_jump_threads (fun, &vrp_prop.vr_values);\n+  vrp_jump_threader threader (fun, &vrp_prop.vr_values);\n+  threader.thread_jumps ();\n \n   /* A comparison of an SSA_NAME against a constant where the SSA_NAME\n      was set by a type conversion can often be rewritten to use the"}]}