{"sha": "3e6688a77f7b7279b5f11407e19280c772e6236d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2Njg4YTc3ZjdiNzI3OWI1ZjExNDA3ZTE5MjgwYzc3MmU2MjM2ZA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-29T19:47:32Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-29T19:47:32Z"}, "message": "fold-const.c (tree_swap_operands_p): Remove duplicated code.\n\n2004-09-29  Eric Christopher  <echristo@redhat.com>\n\n\t* fold-const.c (tree_swap_operands_p): Remove duplicated code.\n\nFrom-SVN: r88299", "tree": {"sha": "d32f998219a04ba25caf6dd4d1906be5618d1477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d32f998219a04ba25caf6dd4d1906be5618d1477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e6688a77f7b7279b5f11407e19280c772e6236d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6688a77f7b7279b5f11407e19280c772e6236d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e6688a77f7b7279b5f11407e19280c772e6236d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6688a77f7b7279b5f11407e19280c772e6236d/comments", "author": null, "committer": null, "parents": [{"sha": "8820e4bed84ebc9fdd23f394ec55e0faeac5fce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8820e4bed84ebc9fdd23f394ec55e0faeac5fce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8820e4bed84ebc9fdd23f394ec55e0faeac5fce9"}], "stats": {"total": 83, "additions": 39, "deletions": 44}, "files": [{"sha": "ef37139c795d9ebe48ee50feb1abdecd3a06b8d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6688a77f7b7279b5f11407e19280c772e6236d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6688a77f7b7279b5f11407e19280c772e6236d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e6688a77f7b7279b5f11407e19280c772e6236d", "patch": "@@ -1,3 +1,7 @@\n+2004-09-29  Eric Christopher  <echristo@redhat.com>\n+\n+\t* fold-const.c (tree_swap_operands_p): Remove duplicated code.\n+\n 2004-09-29  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.md (moverside, movemside): With MEM, make sure\n@@ -155,7 +159,7 @@\n \t* config/s390/s390.c (s390_adjust_cost): Remove.\n \t(TARGET_SCHED_ADJUST_COST): Do not redefine.\n \t(s390_adjust_priority): Handle TYPE_STM like TYPE_STORE.\n-\t* config/s390/s390.md (\"main_pool\"): Use \"larl\" type \n+\t* config/s390/s390.md (\"main_pool\"): Use \"larl\" type\n \tattribute if TARGET_CPU_ZARCH.\n \n 2004-09-28  Jakub Jelinek  <jakub@redhat.com>\n@@ -204,7 +208,7 @@\n 2004-09-28  Devang Patel  <dpatel@apple.com>\n \n \t* tree-pretty-print.c (dump_generic_node): Print vector types.\n-\t\n+\n 2004-09-28  Nick Clifton  <nickc@redhat.com>\n \n \t* config/sh/sh.h (INIT_CUMULATIVE_ARGS): Replace with an\n@@ -561,7 +565,7 @@\n \t* tree-ssa-propagate.c (simulate_stmt): Likewise.\n \t(simulate_block): Likewise.\n \t(ssa_prop_init): Likewise.\n-\t* tree-ssa-threadupdate.c (thread_block): Likewise.\t\n+\t* tree-ssa-threadupdate.c (thread_block): Likewise.\n \t(create_block_for_threading): Likewise.\n \t(remove_last_stmt_and_useless_edges): Likewise.\n \t* tree-ssa.c (verify_phi_args): Likewise.\n@@ -683,7 +687,7 @@\n 2004-09-27  Devang Patel  <dpatel@apple.com>\n \n \t* tree-pretty-print.c (dump_generic_node): Print VEC_COND_EXPR.\n-\t\n+\n 2004-09-27  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (athlon_cost, k8_cost): Set BRANCH_COST to 5.\n@@ -700,7 +704,7 @@\n \n \t* ggc-page.c (GGC_QUIRE_SIZE): Bump up from 16 to 256 if we're\n \tusing mmap.\n-\t\n+\n 2004-09-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* bitmap.h (EXECUTE_IF_SET_IN_BITMAP, EXECUTE_IF_AND_COMPL_IN_BITMAP,\n@@ -898,7 +902,7 @@\n \tonly if compiling with back chain.\n \t(\"save_stack_nonlocal\", \"restore_stack_nonlocal\"): Save/restore\n \tback chain only if back chain enabled.  Use s390_back_chain_rtx.\n-\t\n+\n 2004-09-25  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/trouble.texi: Remove obsolete information.  Update\n@@ -980,7 +984,7 @@\n \t* tree-if-conv.c (tree_if_convert_cond_expr0: Create temp. variable\n \tonly when necesssary.\n \t(combine_blocks): Combine loop header and exit block.\n-\t\n+\n 2004-09-24  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* hooks.c (hook_tree_tree_bool_null): New.\n@@ -1087,7 +1091,7 @@\n \tPR c++/13989\n \tPR c++/9844\n \t* tree.c (reconstruct_complex_type): Remove extra \"this\".\n-\t* config/rs6000/rs6000.c (rs6000_handle_altivec_attribute): \n+\t* config/rs6000/rs6000.c (rs6000_handle_altivec_attribute):\n \tAdd V4SFmode to case statement.\n \n 2004-09-23  Joseph S. Myers  <jsm@polyomino.org.uk>\n@@ -1105,7 +1109,7 @@\n \tdominance data during error message printing.\n \t* tree-mudflap.c (mf_build_check_statement_for): Build basic blocks\n \tand edges more correctly.\n-\t\n+\n 2004-09-23  Dorit Naishlos <dorit@il.ibm.com>\n \n \t* tree.def (ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF):"}, {"sha": "595d8c1d83ebea4b0a40005c632963f802109bf8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6688a77f7b7279b5f11407e19280c772e6236d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6688a77f7b7279b5f11407e19280c772e6236d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3e6688a77f7b7279b5f11407e19280c772e6236d", "patch": "@@ -209,7 +209,7 @@ force_fit_type (tree t, int overflowable,\n   int sign_extended_type;\n \n   gcc_assert (TREE_CODE (t) == INTEGER_CST);\n-  \n+\n   low = TREE_INT_CST_LOW (t);\n   high = TREE_INT_CST_HIGH (t);\n \n@@ -267,7 +267,7 @@ force_fit_type (tree t, int overflowable,\n       || low != TREE_INT_CST_LOW (t) || high != TREE_INT_CST_HIGH (t))\n     {\n       t = build_int_cst_wide (TREE_TYPE (t), low, high);\n-      \n+\n       if (overflowed\n \t  || overflowable < 0\n \t  || (overflowable > 0 && sign_extended_type))\n@@ -282,7 +282,7 @@ force_fit_type (tree t, int overflowable,\n \t  TREE_CONSTANT_OVERFLOW (t) = 1;\n \t}\n     }\n-  \n+\n   return t;\n }\n \f\n@@ -1451,7 +1451,7 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t\t\t| TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2),\n \t\t\tTREE_CONSTANT_OVERFLOW (arg1)\n \t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n-  \n+\n   return t;\n }\n \n@@ -1890,7 +1890,7 @@ fold_convert (tree type, tree arg)\n       gcc_assert (TREE_CODE (orig) == VECTOR_TYPE\n \t\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));\n       return fold (build1 (NOP_EXPR, type, arg));\n-      \n+\n     case REAL_TYPE:\n       if (TREE_CODE (arg) == INTEGER_CST)\n \t{\n@@ -1911,19 +1911,19 @@ fold_convert (tree type, tree arg)\n \tcase BOOLEAN_TYPE: case ENUMERAL_TYPE:\n \tcase POINTER_TYPE: case REFERENCE_TYPE:\n \t  return fold (build1 (FLOAT_EXPR, type, arg));\n-\t  \n+\n \tcase REAL_TYPE:\n \t  return fold (build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n \t\t\t       type, arg));\n-\t  \n+\n \tcase COMPLEX_TYPE:\n \t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n \t  return fold_convert (type, tem);\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      \n+\n     case COMPLEX_TYPE:\n       switch (TREE_CODE (orig))\n \t{\n@@ -1937,26 +1937,26 @@ fold_convert (tree type, tree arg)\n \tcase COMPLEX_TYPE:\n \t  {\n \t    tree rpart, ipart;\n-\t    \n+\n \t    if (TREE_CODE (arg) == COMPLEX_EXPR)\n \t      {\n \t\trpart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 0));\n \t\tipart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 1));\n \t\treturn fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n \t      }\n-\t    \n+\n \t    arg = save_expr (arg);\n \t    rpart = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n \t    ipart = fold (build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg));\n \t    rpart = fold_convert (TREE_TYPE (type), rpart);\n \t    ipart = fold_convert (TREE_TYPE (type), ipart);\n \t    return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n \t  }\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      \n+\n     case VECTOR_TYPE:\n       if (integer_zerop (arg))\n \treturn build_zero_vector (type);\n@@ -3310,7 +3310,7 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \n   mask = build_int_cst (unsigned_type, -1);\n   mask = force_fit_type (mask, 0, false, false);\n-  \n+\n   mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n   mask = const_binop (RSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n \n@@ -3336,7 +3336,7 @@ all_ones_mask_p (tree mask, int size)\n \n   tmask = build_int_cst (lang_hooks.types.signed_type (type), -1);\n   tmask = force_fit_type (tmask, 0, false, false);\n-  \n+\n   return\n     tree_int_cst_equal (mask,\n \t\t\tconst_binop (RSHIFT_EXPR,\n@@ -5902,7 +5902,7 @@ static bool\n reorder_operands_p (tree arg0, tree arg1)\n {\n   if (! flag_evaluation_order)\n-    return true;\n+      return true;\n   if (TREE_CONSTANT (arg0) || TREE_CONSTANT (arg1))\n     return true;\n   return ! TREE_SIDE_EFFECTS (arg0)\n@@ -5952,15 +5952,6 @@ tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n   if (DECL_P (arg0))\n     return 1;\n \n-  if (reorder && flag_evaluation_order\n-      && (TREE_SIDE_EFFECTS (arg0) || TREE_SIDE_EFFECTS (arg1)))\n-    return 0;\n-\n-  if (DECL_P (arg1))\n-    return 0;\n-  if (DECL_P (arg0))\n-    return 1;\n-\n   /* It is preferable to swap two SSA_NAME to ensure a canonical form\n      for commutative and comparison operators.  Ensuring a canonical\n      form allows the optimizers to find additional redundancies without\n@@ -10288,15 +10279,15 @@ fold_negate_const (tree arg0, tree type)\n \t\t\t    TREE_CONSTANT_OVERFLOW (arg0));\n \tbreak;\n       }\n-      \n+\n     case REAL_CST:\n       t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n-  \n+\n   return t;\n }\n \n@@ -10334,18 +10325,18 @@ fold_abs_const (tree arg0, tree type)\n \t\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n \t}\n       break;\n-      \n+\n     case REAL_CST:\n       if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg0)))\n \tt = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n       else\n \tt =  arg0;\n       break;\n-      \n+\n     default:\n       gcc_unreachable ();\n     }\n-  \n+\n   return t;\n }\n \n@@ -10358,13 +10349,13 @@ fold_not_const (tree arg0, tree type)\n   tree t = NULL_TREE;\n \n   gcc_assert (TREE_CODE (arg0) == INTEGER_CST);\n-  \n+\n   t = build_int_cst_wide (type,\n \t\t\t  ~ TREE_INT_CST_LOW (arg0),\n \t\t\t  ~ TREE_INT_CST_HIGH (arg0));\n   t = force_fit_type (t, 0, TREE_OVERFLOW (arg0),\n \t\t      TREE_CONSTANT_OVERFLOW (arg0));\n-  \n+\n   return t;\n }\n \n@@ -10630,7 +10621,7 @@ round_up (tree value, int divisor)\n   if (divisor == (divisor & -divisor))\n     {\n       tree t;\n-      \n+\n       t = build_int_cst (TREE_TYPE (value), divisor - 1);\n       value = size_binop (PLUS_EXPR, value, t);\n       t = build_int_cst (TREE_TYPE (value), -divisor);\n@@ -10674,7 +10665,7 @@ round_down (tree value, int divisor)\n   if (divisor == (divisor & -divisor))\n     {\n       tree t;\n-      \n+\n       t = build_int_cst (TREE_TYPE (value), -divisor);\n       value = size_binop (BIT_AND_EXPR, value, t);\n     }\n@@ -10701,7 +10692,7 @@ ptr_difference_const (tree e1, tree e2, HOST_WIDE_INT *diff)\n   tree toffset1, toffset2, tdiff, type;\n   enum machine_mode mode1, mode2;\n   int unsignedp1, unsignedp2, volatilep1, volatilep2;\n-  \n+\n   core1 = get_inner_reference (e1, &bitsize1, &bitpos1, &toffset1, &mode1,\n \t\t\t       &unsignedp1, &volatilep1);\n   core2 = get_inner_reference (e2, &bitsize2, &bitpos2, &toffset2, &mode2,"}]}