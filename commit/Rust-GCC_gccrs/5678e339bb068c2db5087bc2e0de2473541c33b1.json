{"sha": "5678e339bb068c2db5087bc2e0de2473541c33b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3OGUzMzliYjA2OGMyZGI1MDg3YmMyZTBkZTI0NzM1NDFjMzNiMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2018-11-29T04:59:19Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2018-11-29T04:59:19Z"}, "message": "[RS6000] CONST_DOUBLE tidy\n\nOnce upon a time CONST_DOUBLE was used to hold large integer constants\nthat didn't fit into a CONST_INT.  Now that CONST_INT is always at\nleast 64 bits, and the rs6000 backend uses CONST_WIDE_INT for larger\nintegers, there is no need for old code dealing with integers in\nCONST_DOUBLE.  The rs6000 backend also doesn't create DImode subregs\nof TFmode CONST_DOUBLE, as once we did.  This patch cleans up a few\nleftovers from the past.\n\n\t* config/rs6000/predicates.md (easy_fp_constant): Remove code\n\tdealing with integers in const_double.  Assert on unexpected\n\tmodes.  Delete superfluous ABI_V4 test.\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Comment fixes.\n\tDon't call easy_fp_constant for Pmode.\n\t(rs6000_hash_constant): Remove code dealing with integers in\n\tconst_double.\n\t(rs6000_legitimate_constant_p): Likewise.\n\t(output_toc): Formatting, use CONST_DOUBLE_P.\n\nFrom-SVN: r266608", "tree": {"sha": "de9b0e6a904db54b48f69ba6e4e0dc0055dfa989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de9b0e6a904db54b48f69ba6e4e0dc0055dfa989"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5678e339bb068c2db5087bc2e0de2473541c33b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5678e339bb068c2db5087bc2e0de2473541c33b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5678e339bb068c2db5087bc2e0de2473541c33b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5678e339bb068c2db5087bc2e0de2473541c33b1/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8529a062e9f2b74733c3ada515e02b30380be7d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8529a062e9f2b74733c3ada515e02b30380be7d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8529a062e9f2b74733c3ada515e02b30380be7d6"}], "stats": {"total": 104, "additions": 43, "deletions": 61}, "files": [{"sha": "e31f2be276e89d7696f36d060b168bcd6995edf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5678e339bb068c2db5087bc2e0de2473541c33b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5678e339bb068c2db5087bc2e0de2473541c33b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5678e339bb068c2db5087bc2e0de2473541c33b1", "patch": "@@ -1,3 +1,15 @@\n+2018-11-29  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/predicates.md (easy_fp_constant): Remove code\n+\tdealing with integers in const_double.  Assert on unexpected\n+\tmodes.  Delete superfluous ABI_V4 test.\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Comment fixes.\n+\tDon't call easy_fp_constant for Pmode.\n+\t(rs6000_hash_constant): Remove code dealing with integers in\n+\tconst_double.\n+\t(rs6000_legitimate_constant_p): Likewise.\n+\t(output_toc): Formatting, use CONST_DOUBLE_P.\n+\n 2018-11-29  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/constraints.md (G, H): Comment on purpose of"}, {"sha": "cf07d5c6372cc6157a94ed06d2b733959e9d7210", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5678e339bb068c2db5087bc2e0de2473541c33b1/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5678e339bb068c2db5087bc2e0de2473541c33b1/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=5678e339bb068c2db5087bc2e0de2473541c33b1", "patch": "@@ -562,50 +562,26 @@\n (define_predicate \"easy_fp_constant\"\n   (match_code \"const_double\")\n {\n-  if (GET_MODE (op) != mode\n-      || (!SCALAR_FLOAT_MODE_P (mode) && mode != DImode))\n-    return 0;\n+  gcc_assert (GET_MODE (op) == mode && SCALAR_FLOAT_MODE_P (mode));\n \n   /* Consider all constants with -msoft-float to be easy.  */\n-  if (TARGET_SOFT_FLOAT && mode != DImode)\n+  if (TARGET_SOFT_FLOAT)\n     return 1;\n \n   /* 0.0D is not all zero bits.  */\n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return 0;\n \n   /* The constant 0.0 is easy under VSX.  */\n-  if (TARGET_VSX && SCALAR_FLOAT_MODE_P (mode) && op == CONST0_RTX (mode))\n+  if (TARGET_VSX && op == CONST0_RTX (mode))\n     return 1;\n \n-  /* If we are using V.4 style PIC, consider all constants to be hard.  */\n-  if (flag_pic && DEFAULT_ABI == ABI_V4)\n-    return 0;\n-\n-  /* If we have real FPRs, consider floating point constants hard (other than\n-     0.0 under VSX), so that the constant gets pushed to memory during the\n-     early RTL phases.  This has the advantage that double precision constants\n-     that can be represented in single precision without a loss of precision\n-     will use single precision loads.  */\n-\n-  switch (mode)\n-    {\n-    case E_KFmode:\n-    case E_IFmode:\n-    case E_TFmode:\n-    case E_DFmode:\n-    case E_SFmode:\n-      return 0;\n-\n-    case E_DImode:\n-      return (num_insns_constant (op, DImode) <= 2);\n-\n-    case E_SImode:\n-      return 1;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  /* Otherwise consider floating point constants hard, so that the\n+     constant gets pushed to memory during the early RTL phases.  This\n+     has the advantage that double precision constants that can be\n+     represented in single precision without a loss of precision will\n+     use single precision loads.  */\n+   return 0;\n })\n \n ;; Return 1 if the operand is a constant that can loaded with a XXSPLTIB"}, {"sha": "93d58a2855fd2b1848df80a86557901b1393dbef", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5678e339bb068c2db5087bc2e0de2473541c33b1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5678e339bb068c2db5087bc2e0de2473541c33b1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5678e339bb068c2db5087bc2e0de2473541c33b1", "patch": "@@ -9883,13 +9883,10 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       debug_rtx (source);\n     }\n \n-  /* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */\n+  /* Check that we get CONST_WIDE_INT only when we should.  */\n   if (CONST_WIDE_INT_P (operands[1])\n       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-    {\n-      /* This should be fixed with the introduction of CONST_WIDE_INT.  */\n-      gcc_unreachable ();\n-    }\n+    gcc_unreachable ();\n \n #ifdef HAVE_AS_GNU_ATTRIBUTE\n   /* If we use a long double type, set the flags in .gnu_attribute that say\n@@ -10228,13 +10225,11 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       else if (mode == Pmode\n \t       && CONSTANT_P (operands[1])\n \t       && GET_CODE (operands[1]) != HIGH\n-\t       && ((GET_CODE (operands[1]) != CONST_INT\n-\t\t    && ! easy_fp_constant (operands[1], mode))\n-\t\t   || (GET_CODE (operands[1]) == CONST_INT\n-\t\t       && (num_insns_constant (operands[1], mode)\n-\t\t\t   > (TARGET_CMODEL != CMODEL_SMALL ? 3 : 2)))\n-\t\t   || (GET_CODE (operands[0]) == REG\n-\t\t       && FP_REGNO_P (REGNO (operands[0]))))\n+\t       && ((REG_P (operands[0])\n+\t\t    && FP_REGNO_P (REGNO (operands[0])))\n+\t\t   || !CONST_INT_P (operands[1])\n+\t\t   || (num_insns_constant (operands[1], mode)\n+\t\t       > (TARGET_CMODEL != CMODEL_SMALL ? 3 : 2)))\n \t       && !toc_relative_expr_p (operands[1], false, NULL, NULL)\n \t       && (TARGET_CMODEL == CMODEL_SMALL\n \t\t   || can_create_pseudo_p ()\n@@ -29453,10 +29448,7 @@ rs6000_hash_constant (rtx k)\n       }\n \n     case CONST_DOUBLE:\n-      if (mode != VOIDmode)\n-\treturn real_hash (CONST_DOUBLE_REAL_VALUE (k)) * result;\n-      flen = 2;\n-      break;\n+      return real_hash (CONST_DOUBLE_REAL_VALUE (k)) * result;\n \n     case CODE_LABEL:\n       fidx = 3;\n@@ -29661,9 +29653,9 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n   /* Handle FP constants specially.  Note that if we have a minimal\n      TOC, things we put here aren't actually in the TOC, so we can allow\n      FP constants.  */\n-  if (GET_CODE (x) == CONST_DOUBLE &&\n-      (GET_MODE (x) == TFmode || GET_MODE (x) == TDmode\n-       || GET_MODE (x) == IFmode || GET_MODE (x) == KFmode))\n+  if (CONST_DOUBLE_P (x)\n+      && (GET_MODE (x) == TFmode || GET_MODE (x) == TDmode\n+\t  || GET_MODE (x) == IFmode || GET_MODE (x) == KFmode))\n     {\n       long k[4];\n \n@@ -29701,8 +29693,8 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n \t  return;\n \t}\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE &&\n-\t   (GET_MODE (x) == DFmode || GET_MODE (x) == DDmode))\n+  else if (CONST_DOUBLE_P (x)\n+\t   && (GET_MODE (x) == DFmode || GET_MODE (x) == DDmode))\n     {\n       long k[2];\n \n@@ -29735,8 +29727,8 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n \t  return;\n \t}\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE &&\n-\t   (GET_MODE (x) == SFmode || GET_MODE (x) == SDmode))\n+  else if (CONST_DOUBLE_P (x)\n+\t   && (GET_MODE (x) == SFmode || GET_MODE (x) == SDmode))\n     {\n       long l;\n \n@@ -37638,11 +37630,13 @@ rs6000_legitimate_constant_p (machine_mode mode, rtx x)\n   if (TARGET_ELF && tls_referenced_p (x))\n     return false;\n \n-  return ((GET_CODE (x) != CONST_DOUBLE && GET_CODE (x) != CONST_VECTOR)\n-\t  || GET_MODE (x) == VOIDmode\n-\t  || (TARGET_POWERPC64 && mode == DImode)\n-\t  || easy_fp_constant (x, mode)\n-\t  || easy_vector_constant (x, mode));\n+  if (CONST_DOUBLE_P (x))\n+    return easy_fp_constant (x, mode);\n+\n+  if (GET_CODE (x) == CONST_VECTOR)\n+    return easy_vector_constant (x, mode);\n+\n+  return true;\n }\n \n \f"}]}