{"sha": "dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFjMjYzN2I3NTFiNzI2MTJkOTA5YjVjYzc4ZWQwNmQ2YzlmOGQ5YQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-02-26T19:14:23Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-02-26T19:14:23Z"}, "message": "re PR target/61142 ([SH] QImode/HImode @(R0,Rm),Rn does not load to Rn = R0)\n\ngcc/\n\tPR target/61142\n\t* config/sh/sh.c (sh_check_add_incdec_notes): New function.\n\t* config/sh/sh-protos.h (sh_check_add_incdec_notes): Declare it.\n\t* config/sh/predicates.md (const_logical_operand): New predicate.\n\t* config/sh/sh.md: Add new peephole2 patterns.\n\nFrom-SVN: r221026", "tree": {"sha": "f65c4a3120c0b65a672807f5c2cfd6c19173875f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f65c4a3120c0b65a672807f5c2cfd6c19173875f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/comments", "author": null, "committer": null, "parents": [{"sha": "1cf06f1e2512b55a55f837b43c1ff235a9be1992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cf06f1e2512b55a55f837b43c1ff235a9be1992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cf06f1e2512b55a55f837b43c1ff235a9be1992"}], "stats": {"total": 217, "additions": 217, "deletions": 0}, "files": [{"sha": "4e8f5478b46540a957043f073cf9592e16134945", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "patch": "@@ -1,3 +1,11 @@\n+2015-02-26  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/61142\n+\t* config/sh/sh.c (sh_check_add_incdec_notes): New function.\n+\t* config/sh/sh-protos.h (sh_check_add_incdec_notes): Declare it.\n+\t* config/sh/predicates.md (const_logical_operand): New predicate.\n+\t* config/sh/sh.md: Add new peephole2 patterns.\n+\n 2015-02-26  Marek Polacek  <polacek@redhat.com>\n \n \tPR ipa/65008"}, {"sha": "8d876b65d4b669683b76e824d14a530d42887d78", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "patch": "@@ -798,6 +798,12 @@\n   return 0;\n })\n \n+;; Returns true if OP is a valid constant source operand for a logical\n+;; operations tst/and/or/xor #imm,r0.\n+(define_predicate \"const_logical_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_K08 (op)\")))\n+\n ;; Like logical_operand but allows additional constant values which can be\n ;; done with zero extensions.  Used for the second operand of and insns.\n (define_predicate \"logical_and_operand\""}, {"sha": "5a552e2be81425b792b1aff76905e3b400b9707c", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "patch": "@@ -309,6 +309,7 @@ extern bool sh_insn_operands_modified_between_p (rtx_insn* operands_insn,\n \n extern bool sh_reg_dead_or_unused_after_insn (const rtx_insn* i, int regno);\n extern void sh_remove_reg_dead_or_unused_notes (rtx_insn* i, int regno);\n+extern rtx_insn* sh_check_add_incdec_notes (rtx_insn* i);\n \n extern bool sh_in_recog_treg_set_expr (void);\n extern bool sh_recog_treg_set_expr (rtx op, machine_mode mode);"}, {"sha": "1cf6ed0a9cae2c79647bf030aea2bd1dbc648449", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "patch": "@@ -13757,6 +13757,35 @@ sh_remove_reg_dead_or_unused_notes (rtx_insn* i, int regno)\n     remove_note (i, n);\n }\n \n+/* Given an insn check if it contains any post/pre inc/dec mem operands and\n+   add the REG_INC notes accordingly.\n+   FIXME: This function is very similar to lra.c (add_auto_inc_notes).\n+   FIXME: This function is currently used by peephole2 patterns because\n+\t  the peephole2 pass does not preserve REG_INC notes.  If the notes\n+\t  are dropped the following passes will do wrong things.  */\n+rtx_insn*\n+sh_check_add_incdec_notes (rtx_insn* i)\n+{\n+  struct for_each_inc_dec_clb\n+  {\n+    static int func (rtx mem ATTRIBUTE_UNUSED, rtx op ATTRIBUTE_UNUSED,\n+\t\t     rtx dest, rtx src ATTRIBUTE_UNUSED,\n+\t\t     rtx srcoff ATTRIBUTE_UNUSED, void* arg)\n+    {\n+      gcc_assert (REG_P (dest));\n+\n+      rtx_insn* i = (rtx_insn*)arg;\n+      if (find_regno_note (i, REG_INC, REGNO (dest)) == NULL)\n+\tadd_reg_note (i, REG_INC, dest);\n+\n+      return 0;\n+    }\n+  };\n+\n+  for_each_inc_dec (PATTERN (i), for_each_inc_dec_clb::func, i);\n+  return i;\n+}\n+\n /* Given an op rtx and an insn, try to find out whether the result of the\n    specified op consists only of logical operations on T bit stores.  */\n bool"}, {"sha": "2435ec94a029b6d04b8c7dd7514ef1048163ede5", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac2637b751b72612d909b5cc78ed06d6c9f8d9a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=dac2637b751b72612d909b5cc78ed06d6c9f8d9a", "patch": "@@ -14532,6 +14532,179 @@ label:\n \t(mem:HI (plus:SI (match_dup 1) (match_dup 2))))]\n   \"\")\n \n+;;\textu.bw\ta,b\n+;;\tmov\tb,c\t->\textu.bw\ta,c\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(zero_extend:SI (match_operand:QIHI 1 \"arith_reg_operand\")))\n+   (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t(match_dup 0))]\n+  \"TARGET_SH1 && peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 2) (zero_extend:SI (match_dup 1)))])\n+\n+;;\tmov\tr0,r1\n+;;\textu.bw\tr1,r1   ->\textu.bw\tr0,r1\n+(define_peephole2\n+  [(set (match_operand 0 \"arith_reg_dest\")\n+\t(match_operand 1 \"arith_reg_operand\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t(zero_extend:SI (match_operand:QIHI 3 \"arith_reg_operand\")))]\n+  \"TARGET_SH1\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && (REGNO (operands[0]) == REGNO (operands[2])\n+       || peep2_reg_dead_p (2, operands[0]))\"\n+  [(set (match_dup 2) (zero_extend:SI (match_dup 1)))]\n+{\n+  operands[1] = gen_rtx_REG (<MODE>mode, REGNO (operands[1]));\n+})\n+\n+;;\tmov\ta,b\n+;;\tmov\tb,a\t->\t< nop >\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\")\n+\t(match_operand 1 \"register_operand\"))\n+   (set (match_operand 2 \"register_operand\")\n+\t(match_operand 3 \"register_operand\"))]\n+  \"TARGET_SH1\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && REGNO (operands[1]) == REGNO (operands[2])\n+   && peep2_reg_dead_p (2, operands[3])\"\n+  [(const_int 0)])\n+\n+;;\tmov\t#3,r4\n+;;\tand\tr4,r1\t->\tmov\tr1,r0\n+;;\tmov\tr1,r0\t\tand\t#3,r0\n+(define_code_iterator ANDIORXOR [and ior xor])\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operand:SI 1 \"const_logical_operand\"))\n+   (set (match_operand:SI 2) (ANDIORXOR:SI (match_dup 2) (match_dup 0)))\n+   (set (reg:SI R0_REG) (match_dup 2))]\n+  \"TARGET_SH1\n+   && peep2_reg_dead_p (3, operands[0]) && peep2_reg_dead_p (3, operands[2])\"\n+  [(set (reg:SI R0_REG) (match_dup 2))\n+   (set (reg:SI R0_REG) (ANDIORXOR:SI (reg:SI R0_REG) (match_dup 1)))])\n+\n+;;\t...\tr2,r0\t\t...\tr2,r0\n+;;\tor\tr1,r0\t->\tor\tr0,r1\n+;;\tmov\tr0,r1\n+;;\t(r0 dead)\n+(define_code_iterator ANDIORXORPLUS [and ior xor plus])\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ANDIORXORPLUS:SI (match_dup 0) (match_operand:SI 1 \"arith_reg_dest\")))\n+   (set (match_dup 1) (match_dup 0))]\n+  \"TARGET_SH1 && peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 1) (ANDIORXORPLUS:SI (match_dup 1) (match_dup 0)))])\n+\n+;;\tmov\tr12,r0\n+;;\tadd\t#-48,r0     ->\tadd\t#-48,r12\n+;;\tmov.l\tr0,@(4,r10)\tmov.l\tr12,@(4,r10)\n+;;\t(r12 dead)\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operand:SI 1 \"arith_reg_dest\"))\n+   (set (match_dup 0) (plus:SI (match_dup 0)\n+\t\t\t       (match_operand:SI 2 \"const_int_operand\")))\n+   (set (match_operand:SI 3 \"general_movdst_operand\") (match_dup 0))]\n+  \"TARGET_SH1\n+   && peep2_reg_dead_p (2, operands[1]) && peep2_reg_dead_p (3, operands[0])\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_addsi3 (operands[1], operands[1], operands[2]));\n+  sh_check_add_incdec_notes (emit_move_insn (operands[3], operands[1]));\n+})\n+\n+;;\tmov.l\t@(r0,r9),r1\n+;;\tmov\tr1,r0\t    ->\tmov\t@(r0,r9),r0\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t(match_dup 0))]\n+  \"TARGET_SH1 && peep2_reg_dead_p (2, operands[0])\"\n+  [(const_int 0)]\n+{\n+  sh_check_add_incdec_notes (emit_move_insn (operands[2], operands[1]));\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:QIHI 0 \"register_operand\")\n+\t(match_operand:QIHI 1 \"movsrc_no_disp_mem_operand\"))\n+   (set (match_operand:QIHI 2 \"register_operand\")\n+\t(match_dup 0))]\n+  \"TARGET_SH1 && peep2_reg_dead_p (2, operands[0])\"\n+  [(const_int 0)]\n+{\n+  sh_check_add_incdec_notes (emit_move_insn (operands[2], operands[1]));\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(sign_extend:SI (match_operand:QIHI 1 \"movsrc_no_disp_mem_operand\")))\n+   (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t(match_dup 0))]\n+  \"TARGET_SH1 && peep2_reg_dead_p (2, operands[0])\"\n+  [(const_int 0)]\n+{\n+  sh_check_add_incdec_notes (emit_insn (gen_extend<mode>si2 (operands[2],\n+\t\t\t\t\t\t\t     operands[1])));\n+})\n+\n+;;\tmov.w\t@(18,r1),r0 (r0 = HImode)\n+;;\tmov\tr0,r1       (r0 = r1 = HImode)\t\tmov.w\t@(18,r1),r0\n+;;\t...\t..,r13      (r13 = SImode)\t-> \t...\t..,r13\n+;;\ttst\tr1,r13\t\t\t\t\ttst\tr0,r13\n+(define_peephole2\n+  [(set (match_operand 0 \"arith_reg_dest\")\n+\t(match_operand 1 \"arith_reg_dest\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t(match_operand:SI 3))\n+   (set (reg:SI T_REG)\n+\t(eq:SI (and:SI (match_operand:SI 4 \"arith_reg_operand\")\n+\t\t       (match_operand:SI 5 \"arith_reg_operand\"))\n+\t       (const_int 0)))]\n+  \"TARGET_SH1\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[3])\n+   && (REGNO (operands[0]) == REGNO (operands[4])\n+       || REGNO (operands[0]) == REGNO (operands[5]))\n+   && (REGNO (operands[2]) == REGNO (operands[4])\n+       || REGNO (operands[2]) == REGNO (operands[5]))\"\n+  [(const_int 0)]\n+{\n+  sh_check_add_incdec_notes (emit_move_insn (operands[2], operands[3]));\n+  emit_insn (gen_tstsi_t (operands[2],\n+\t\t\t  gen_rtx_REG (SImode, (REGNO (operands[1])))));\n+})\n+\n+;;\tmov.w\t@(18,r1),r0 (r0 = HImode)\n+;;\t...\t..,r13\t    (r13 = SImode)\t\tmov.w\t@(18,r1),r0\n+;;\tmov\tr0,r1       (r0 = r1 = HImode)\t->\t...\t..,r13\n+;;\ttst\tr1,r13\t\t\t\t\ttst\tr0,r13\n+(define_peephole2\n+  [(set (match_operand:SI 2 \"arith_reg_dest\")\n+\t(match_operand:SI 3))\n+   (set (match_operand 0 \"arith_reg_dest\")\n+\t(match_operand 1 \"arith_reg_operand\"))\n+   (set (reg:SI T_REG)\n+\t(eq:SI (and:SI (match_operand:SI 4 \"arith_reg_operand\")\n+\t\t       (match_operand:SI 5 \"arith_reg_operand\"))\n+\t       (const_int 0)))]\n+  \"TARGET_SH1\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[3])\n+   && (REGNO (operands[0]) == REGNO (operands[4])\n+       || REGNO (operands[0]) == REGNO (operands[5]))\n+   && (REGNO (operands[2]) == REGNO (operands[4])\n+       || REGNO (operands[2]) == REGNO (operands[5]))\"\n+  [(const_int 0)]\n+{\n+  sh_check_add_incdec_notes (emit_move_insn (operands[2], operands[3]));\n+  emit_insn (gen_tstsi_t (operands[2],\n+\t\t\t  gen_rtx_REG (SImode, (REGNO (operands[1])))));\n+})\n+\n (define_peephole\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))"}]}