{"sha": "093c7153029151d28e4f60d9204d0edc31e7e3a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzYzcxNTMwMjkxNTFkMjhlNGY2MGQ5MjA0ZDBlZGMzMWU3ZTNhMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-18T01:20:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-18T01:20:53Z"}, "message": "c-common.c (flag_objc_sjlj_exceptions): New.\n\n\t* c-common.c (flag_objc_sjlj_exceptions): New.\n\t* c-common.h (flag_objc_sjlj_exceptions): Declare.\n\t* c-opts.c (c_common_handle_option): Set it.\n\t(c_common_post_options): Handle interation of different\n\tobjective-c exception and runtime switches.\n\t* c-decl.c (c_eh_initialized_p): New.\n\t(finish_decl): Use it instead of local eh_initialized_p.\n\t* c-parse.in (nested_function, notype_nested_function): Record\n\tthe result of compstmt.\n\t(compstmt_or_error): Likewise.\n\t(compstmt): Don't add_stmt the result.\n\t(stmt): Don't return anything.  Rewrite objc try and sync rules.\n\t(objc_try_stmt, objc_catch_list): Remove.\n\t(objc_catch_block, objc_finally_block): Remove.\n\t(objc_catch_prefix, objc_catch_clause, objc_opt_catch_list): New.\n\t(objc_try_catch_clause, objc_finally_clause): New.\n\t(objc_try_catch_stmt): Rewrite.\n\t* c-tree.h (c_eh_initialized_p): Declare.\n\t* c-opt (fobjc-sjlj-exceptions): New.\n\t* except.c (output_function_exception_table): Don't call cgraph\n\ton non-decls.\n\t* objc/objc-act.c (UTAG_EXCDATA_VAR, UTAG_CAUGHTEXC_VAR,\n\tUTAG_RETHROWEXC_VAR, UTAG_EVALONCE_VAR, struct val_stack,\n\tcatch_count_stack, exc_binding_stack, if_nesting_count,\n\tblk_nesting_count, objc_enter_block, objc_exit_block,\n\tobjc_declare_variable, val_stack_push, val_stack_pop,\n\tobjc_build_try_enter_fragment, objc_build_extract_expr,\n\tobjc_build_try_exit_fragment, objc_build_extract_fragment,\n\tobjc_build_try_prologue, objc_build_try_epilogue,\n\tobjc_build_catch_stmt, objc_build_catch_epilogue,\n\tobjc_build_finally_prologue, objc_build_finally_epilogue,\n\tobjc_build_try_catch_finally_stmt, objc_build_synchronized_prologue,\n\tobjc_build_synchronized_epilogue): Remove.\n\t(objc_create_temporary_var, struct objc_try_context, cur_try_context,\n\tobjc_eh_runtime_type, objc_init_exceptions, objc_build_exc_ptr,\n\tnext_sjlj_build_try_exit, next_sjlj_build_enter_and_setjmp,\n\tnext_sjlj_build_exc_extract, next_sjlj_build_catch_list,\n\tnext_sjlj_build_try_catch_finally, objc_begin_try_stmt,\n\tobjc_begin_catch_clause, objc_finish_catch_clause,\n\tobjc_build_finally_clause, objc_finish_try_stmt,\n\tobjc_build_synchronized): New.\n\t(objc_is_object_id, objc_is_class_id): New.\n\t(objc_comptypes): Use them.\n\t(build_next_objc_exception_stuff): Break NeXT sjlj out from\n\tbuild_objc_exception_stuff.\n\t(synth_module_prologue): Update to match.\n\t(objc_build_throw_stmt): Use cur_try_context to decide if\n\twe're in a @catch.\n\t* objc/objc-act.h: Update prototypes.\n\t(OCTI_EXCEPTION_BLK_STACK, objc_exception_block_stack): Remove.\ntestsuite/\n        * objc.dg/sync-1.m: New.\n        * objc.dg/try-catch-1.m: Don't force next runtime.\n        * objc.dg/try-catch-3.m, objc.dg/try-catch-4.m: Likewise.\n        * objc.dg/try-catch-2.m: Likewise.  Enable everywhere.  Remove\n        shadowed catch clause.\n        * objc.dg/try-catch-5.m: New.\n\nFrom-SVN: r83332", "tree": {"sha": "76b8fd18403158028bfbeeb8db6ac71d470a33aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76b8fd18403158028bfbeeb8db6ac71d470a33aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/093c7153029151d28e4f60d9204d0edc31e7e3a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093c7153029151d28e4f60d9204d0edc31e7e3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093c7153029151d28e4f60d9204d0edc31e7e3a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093c7153029151d28e4f60d9204d0edc31e7e3a2/comments", "author": null, "committer": null, "parents": [{"sha": "a776161b8bb455734cb3019976b5718bc208ba8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a776161b8bb455734cb3019976b5718bc208ba8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a776161b8bb455734cb3019976b5718bc208ba8f"}], "stats": {"total": 1338, "additions": 717, "deletions": 621}, "files": [{"sha": "b1c4f8d8b410723fad80e4c1a33973473a1fc53b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -1,3 +1,56 @@\n+2004-06-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.c (flag_objc_sjlj_exceptions): New.\n+\t* c-common.h (flag_objc_sjlj_exceptions): Declare.\n+\t* c-opts.c (c_common_handle_option): Set it.\n+\t(c_common_post_options): Handle interation of different\n+\tobjective-c exception and runtime switches.\n+\t* c-decl.c (c_eh_initialized_p): New.\n+\t(finish_decl): Use it instead of local eh_initialized_p.\n+\t* c-parse.in (nested_function, notype_nested_function): Record\n+\tthe result of compstmt.\n+\t(compstmt_or_error): Likewise.\n+\t(compstmt): Don't add_stmt the result.\n+\t(stmt): Don't return anything.  Rewrite objc try and sync rules.\n+\t(objc_try_stmt, objc_catch_list): Remove.\n+\t(objc_catch_block, objc_finally_block): Remove.\n+\t(objc_catch_prefix, objc_catch_clause, objc_opt_catch_list): New.\n+\t(objc_try_catch_clause, objc_finally_clause): New.\n+\t(objc_try_catch_stmt): Rewrite.\n+\t* c-tree.h (c_eh_initialized_p): Declare.\n+\t* c-opt (fobjc-sjlj-exceptions): New.\n+\t* except.c (output_function_exception_table): Don't call cgraph\n+\ton non-decls.\n+\t* objc/objc-act.c (UTAG_EXCDATA_VAR, UTAG_CAUGHTEXC_VAR,\n+\tUTAG_RETHROWEXC_VAR, UTAG_EVALONCE_VAR, struct val_stack,\n+\tcatch_count_stack, exc_binding_stack, if_nesting_count,\n+\tblk_nesting_count, objc_enter_block, objc_exit_block,\n+\tobjc_declare_variable, val_stack_push, val_stack_pop, \n+\tobjc_build_try_enter_fragment, objc_build_extract_expr,\n+\tobjc_build_try_exit_fragment, objc_build_extract_fragment,\n+\tobjc_build_try_prologue, objc_build_try_epilogue, \n+\tobjc_build_catch_stmt, objc_build_catch_epilogue,\n+\tobjc_build_finally_prologue, objc_build_finally_epilogue,\n+\tobjc_build_try_catch_finally_stmt, objc_build_synchronized_prologue,\n+\tobjc_build_synchronized_epilogue): Remove.\n+\t(objc_create_temporary_var, struct objc_try_context, cur_try_context,\n+\tobjc_eh_runtime_type, objc_init_exceptions, objc_build_exc_ptr,\n+\tnext_sjlj_build_try_exit, next_sjlj_build_enter_and_setjmp,\n+\tnext_sjlj_build_exc_extract, next_sjlj_build_catch_list,\n+\tnext_sjlj_build_try_catch_finally, objc_begin_try_stmt,\n+\tobjc_begin_catch_clause, objc_finish_catch_clause,\n+\tobjc_build_finally_clause, objc_finish_try_stmt,\n+\tobjc_build_synchronized): New.\n+\t(objc_is_object_id, objc_is_class_id): New.\n+\t(objc_comptypes): Use them.\n+\t(build_next_objc_exception_stuff): Break NeXT sjlj out from\n+\tbuild_objc_exception_stuff.\n+\t(synth_module_prologue): Update to match.\n+\t(objc_build_throw_stmt): Use cur_try_context to decide if\n+\twe're in a @catch.\n+\t* objc/objc-act.h: Update prototypes.\n+\t(OCTI_EXCEPTION_BLK_STACK, objc_exception_block_stack): Remove.\n+\n 2004-06-17  Andrew Pinski <apinski@apple.com>\n \n \t* c-typeck.c (tagged_types_tu_compatible_p <case UNION_TYPE>):"}, {"sha": "d25dde3a3297a68a209c4db91574e14de650532b", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -361,6 +361,9 @@ int flag_nil_receivers = 1;\n    @try, etc.) in source code.  */\n int flag_objc_exceptions = 0;\n \n+/* Nonzero means that we generate NeXT setjmp based exceptions.  */\n+int flag_objc_sjlj_exceptions = -1;\n+\n /* Nonzero means that code generation will be altered to support\n    \"zero-link\" execution.  This currently affects ObjC only, but may\n    affect other languages in the future.  */"}, {"sha": "337eb6d83d1b1b03d666118705e8710daffb9e82", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -321,6 +321,9 @@ extern int flag_nil_receivers;\n    @try, etc.) in source code.  */\n extern int flag_objc_exceptions;\n \n+/* Nonzero means that we generate NeXT setjmp based exceptions.  */\n+extern int flag_objc_sjlj_exceptions;\n+\n /* Nonzero means that code generation will be altered to support\n    \"zero-link\" execution.  This currently affects ObjC only, but may\n    affect other languages in the future.  */"}, {"sha": "ac8c5b7847d8694e8348676140a80bb9de5bd837", "filename": "gcc/c-decl.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -71,11 +71,14 @@ enum decl_context\n \f\n /* Nonzero if we have seen an invalid cross reference\n    to a struct, union, or enum, but not yet printed the message.  */\n-\n tree pending_invalid_xref;\n+\n /* File and line to appear in the eventual error message.  */\n location_t pending_invalid_xref_location;\n \n+/* True means we've initialized exception handling.  */\n+bool c_eh_initialized_p;\n+\n /* While defining an enum type, this is 1 plus the last enumerator\n    constant value.  Note that will do not have to save this or `enum_overflow'\n    around nested function definition since such a definition could only\n@@ -2982,8 +2985,6 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       tree attr = lookup_attribute (\"cleanup\", DECL_ATTRIBUTES (decl));\n       if (attr)\n \t{\n-\t  static bool eh_initialized_p;\n-\n \t  tree cleanup_id = TREE_VALUE (TREE_VALUE (attr));\n \t  tree cleanup_decl = lookup_name (cleanup_id);\n \t  tree cleanup;\n@@ -2998,9 +2999,9 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  TREE_USED (cleanup_decl) = 1;\n \n \t  /* Initialize EH, if we've been told to do so.  */\n-\t  if (flag_exceptions && !eh_initialized_p)\n+\t  if (flag_exceptions && !c_eh_initialized_p)\n \t    {\n-\t      eh_initialized_p = true;\n+\t      c_eh_initialized_p = true;\n \t      eh_personality_libfunc\n \t\t= init_one_libfunc (USING_SJLJ_EXCEPTIONS\n \t\t\t\t    ? \"__gcc_personality_sj0\""}, {"sha": "8025cd7897cfff5f0ed9682c00e0165ec3385c62", "filename": "gcc/c-opts.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -863,6 +863,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       flag_objc_exceptions = value;\n       break;\n \n+    case OPT_fobjc_sjlj_exceptions:\n+      flag_objc_sjlj_exceptions = value;\n+      break;\n+\n     case OPT_foperator_names:\n       cpp_opts->operator_names = value;\n       break;\n@@ -1109,6 +1113,12 @@ c_common_post_options (const char **pfilename)\n       flag_inline_functions = 0;\n     }\n \n+  /* Default to ObjC sjlj exception handling if NeXT runtime.  */\n+  if (flag_objc_sjlj_exceptions < 0)\n+    flag_objc_sjlj_exceptions = flag_next_runtime;\n+  if (flag_objc_exceptions && !flag_objc_sjlj_exceptions)\n+    flag_exceptions = 1;\n+\n   /* -Wextra implies -Wsign-compare, but not if explicitly\n       overridden.  */\n   if (warn_sign_compare == -1)"}, {"sha": "d3e39af6858583f1a3d2e286f6a69f4b9315bf8e", "filename": "gcc/c-parse.in", "status": "modified", "additions": 61, "deletions": 83, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -251,7 +251,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> CLASSNAME OBJECTNAME OBJC_STRING\n \n %type <ttype> superclass\n-%type <itype> objc_try_catch_stmt objc_finally_block\n @@end_ifobjc\n \f\n %{\n@@ -1515,7 +1514,7 @@ designator:\n \t;\n \f\n nested_function:\n-\t  declarator\n+\tdeclarator\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids nested functions\");\n \n@@ -1527,25 +1526,25 @@ nested_function:\n \t\t      YYERROR1;\n \t\t    }\n \t\t}\n-\t   old_style_parm_decls save_location\n+\told_style_parm_decls save_location\n \t\t{ tree decl = current_function_decl;\n \t\t  DECL_SOURCE_LOCATION (decl) = $4;\n \t\t  store_parm_decls (); }\n-/* This used to use compstmt_or_error.\n-   That caused a bug with input `f(g) int g {}',\n-   where the use of YYERROR1 above caused an error\n-   which then was handled by compstmt_or_error.\n-   There followed a repeated execution of that same rule,\n-   which called YYERROR1 again, and so on.  */\n-\t  compstmt\n+\t/* This used to use compstmt_or_error.  That caused a bug with\n+\t   input `f(g) int g {}', where the use of YYERROR1 above caused\n+\t   an error which then was handled by compstmt_or_error.  There\n+\t   followed a repeated execution of that same rule, which called\n+\t   YYERROR1 again, and so on.  */\n+\tcompstmt\n \t\t{ tree decl = current_function_decl;\n+\t\t  add_stmt ($6);\n \t\t  finish_function ();\n \t\t  pop_function_context ();\n \t\t  add_decl_stmt (decl); }\n \t;\n \n notype_nested_function:\n-\t  notype_declarator\n+\tnotype_declarator\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids nested functions\");\n \n@@ -1557,18 +1556,18 @@ notype_nested_function:\n \t\t      YYERROR1;\n \t\t    }\n \t\t}\n-\t  old_style_parm_decls save_location\n+\told_style_parm_decls save_location\n \t\t{ tree decl = current_function_decl;\n \t\t  DECL_SOURCE_LOCATION (decl) = $4;\n \t\t  store_parm_decls (); }\n-/* This used to use compstmt_or_error.\n-   That caused a bug with input `f(g) int g {}',\n-   where the use of YYERROR1 above caused an error\n-   which then was handled by compstmt_or_error.\n-   There followed a repeated execution of that same rule,\n-   which called YYERROR1 again, and so on.  */\n-\t  compstmt\n+\t/* This used to use compstmt_or_error.  That caused a bug with\n+\t   input `f(g) int g {}', where the use of YYERROR1 above caused\n+\t   an error which then was handled by compstmt_or_error.  There\n+\t   followed a repeated execution of that same rule, which called\n+\t   YYERROR1 again, and so on.  */\n+\tcompstmt\n \t\t{ tree decl = current_function_decl;\n+\t\t  add_stmt ($6);\n \t\t  finish_function ();\n \t\t  pop_function_context ();\n \t\t  add_decl_stmt (decl); }\n@@ -2029,7 +2028,7 @@ label_decl:\n    It causes syntax errors to ignore to the next openbrace.  */\n compstmt_or_error:\n \t  compstmt\n-\t\t{}\n+\t\t{ add_stmt ($1); }\n \t| error compstmt\n \t;\n \n@@ -2060,8 +2059,7 @@ compstmt_primary_start:\n         ;\n \n compstmt: compstmt_start compstmt_nostart\n-\t\t{ add_stmt (c_end_compound_stmt ($1, true));\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ $$ = c_end_compound_stmt ($1, true); }\n \t;\n \n if_prefix:\n@@ -2226,37 +2224,27 @@ xexpr:\n /* Parse a single real statement, not including any labels.  */\n stmt:\n \t  compstmt\n-\t\t{ stmt_count++; $$ = $1; }\n+\t\t{ stmt_count++; add_stmt ($1); }\n \t| expr ';'\n-\t\t{ stmt_count++;\n-\t\t  $$ = c_expand_expr_stmt ($1); }\n+\t\t{ stmt_count++; c_expand_expr_stmt ($1); }\n \t| c99_block_start select_or_iter_stmt\n-                { add_stmt (c_end_compound_stmt ($1, flag_isoc99));\n-\t\t  $$ = NULL_TREE; }\n+                { add_stmt (c_end_compound_stmt ($1, flag_isoc99)); }\n \t| BREAK ';'\n \t        { stmt_count++;\n \t\t  if (!(c_in_iteration_stmt || c_in_case_stmt))\n-\t\t    {\n-\t\t      error (\"break statement not within loop or switch\");\n-\t\t      $$ = NULL_TREE;\n-\t\t    }\n+\t\t    error (\"break statement not within loop or switch\");\n \t\t  else\n-\t\t    $$ = add_stmt (build_break_stmt ()); }\n+\t\t    add_stmt (build_break_stmt ()); }\n \t| CONTINUE ';'\n                 { stmt_count++;\n \t\t  if (!c_in_iteration_stmt)\n-\t\t    {\n-\t\t      error (\"continue statement not within a loop\");\n-\t\t      $$ = NULL_TREE;\n-\t\t    }\n+\t\t    error (\"continue statement not within a loop\");\n \t\t  else\n-\t\t    $$ = add_stmt (build_continue_stmt ()); }\n+\t\t    add_stmt (build_continue_stmt ()); }\n \t| RETURN ';'\n-                { stmt_count++;\n-\t\t  $$ = c_expand_return (NULL_TREE); }\n+                { stmt_count++; c_expand_return (NULL_TREE); }\n \t| RETURN expr ';'\n-                { stmt_count++;\n-\t\t  $$ = c_expand_return ($2); }\n+                { stmt_count++; c_expand_return ($2); }\n \t| asm_stmt\n \t| GOTO identifier ';'\n \t\t{ tree decl;\n@@ -2265,71 +2253,61 @@ stmt:\n \t\t  if (decl != 0)\n \t\t    {\n \t\t      TREE_USED (decl) = 1;\n-\t\t      $$ = add_stmt (build_stmt (GOTO_EXPR, decl));\n+\t\t      add_stmt (build_stmt (GOTO_EXPR, decl));\n \t\t    }\n-\t\t  else\n-\t\t    $$ = NULL_TREE;\n \t\t}\n \t| GOTO '*' expr ';'\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids `goto *expr;'\");\n \t\t  stmt_count++;\n \t\t  $3 = convert (ptr_type_node, $3);\n-\t\t  $$ = add_stmt (build_stmt (GOTO_EXPR, $3)); }\n+\t\t  add_stmt (build_stmt (GOTO_EXPR, $3)); }\n \t| ';'\n-\t\t{ $$ = NULL_TREE; }\n+\t\t{ }\n @@ifobjc\n \t| AT_THROW expr ';'\n-\t\t{ stmt_count++;\n-\t\t  $$ = objc_build_throw_stmt ($2);\n-\t\t}\n+\t\t{ stmt_count++; objc_build_throw_stmt ($2); }\n \t| AT_THROW ';'\n-\t\t{ stmt_count++;\n-\t\t  $$ = objc_build_throw_stmt (NULL_TREE);\n-\t\t}\n+\t\t{ stmt_count++; objc_build_throw_stmt (NULL_TREE); }\n \t| objc_try_catch_stmt\n-\t\t{ objc_build_finally_prologue (); }\n-\t  objc_finally_block\n-\t\t{ $$ = objc_build_try_catch_finally_stmt ($1, $3); }\n-\t| AT_SYNCHRONIZED '(' expr ')'\n-\t\t{ objc_build_synchronized_prologue ($3); }\n-\t  compstmt\n-\t\t{ $$ = objc_build_synchronized_epilogue (); }\n+\t\t{ }\n+\t| AT_SYNCHRONIZED '(' expr ')' save_location compstmt\n+\t\t{ stmt_count++; objc_build_synchronized ($5, $3, $6); }\n \t;\n \n-objc_try_catch_stmt:\n-\t  objc_try_stmt\n-\t\t{ objc_build_try_epilogue (1); }\n-\t  objc_catch_list\n-\t\t{ objc_build_catch_epilogue (); $$ = 1; }\n-\t| objc_try_stmt\n-\t\t{ objc_build_try_epilogue (0); $$ = 0; }\n+objc_catch_prefix:\n+\tAT_CATCH '(' parm ')'\n+\t\t{ objc_begin_catch_clause ($3); }\n \t;\n \n+objc_catch_clause:\n+\t  objc_catch_prefix '{' compstmt_nostart\n+\t\t{ objc_finish_catch_clause (); }\n+\t| objc_catch_prefix '{' error '}'\n+\t\t{ objc_finish_catch_clause (); }\n+\t;\n \n-objc_try_stmt:\n-\t  AT_TRY\n-\t\t{ objc_build_try_prologue (); }\n-\t  compstmt\n+objc_opt_catch_list:\n+\t  /* empty */\n+\t| objc_opt_catch_list objc_catch_clause\n \t;\n \n-objc_catch_list:\n-\t  objc_catch_list objc_catch_block\n-\t| objc_catch_block\n+objc_try_catch_clause:\n+\tAT_TRY save_location compstmt\n+\t\t{ stmt_count++; objc_begin_try_stmt ($2, $3); }\n+\tobjc_opt_catch_list\n \t;\n \n-objc_catch_block:\n-\t  AT_CATCH '(' parm ')'\n-\t\t{ objc_build_catch_stmt ($3); }\n-\t  compstmt\n-\t\t{ stmt_count++; }\n+objc_finally_clause:\n+\tAT_FINALLY save_location compstmt\n+\t\t{ objc_build_finally_clause ($2, $3); }\n \t;\n \n-objc_finally_block:\n-\t  AT_FINALLY compstmt\n-\t    { $$ = 1; }\n-\t| /* NULL */\n-\t    { $$ = 0; }\n+objc_try_catch_stmt:\n+\t  objc_try_catch_clause\n+\t\t{ objc_finish_try_stmt (); }\n+\t| objc_try_catch_clause objc_finally_clause\n+\t\t{ objc_finish_try_stmt (); }\n @@end_ifobjc\n \t;\n "}, {"sha": "92a5b7144784abb0b95734e2dda568e9dd1a36e1", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -298,6 +298,9 @@ extern int system_header_p;\n \n extern bool c_override_global_bindings_to_false;\n \n+/* True means we've initialized exception handling.  */\n+extern bool c_eh_initialized_p;\n+\n /* In c-decl.c */\n extern void c_finish_incomplete_decl (tree);\n extern void *get_current_scope (void);"}, {"sha": "f162803009024b9ec6db5792283aaeda9cdbf928", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -584,6 +584,10 @@ fobjc-exceptions\n ObjC ObjC++\n Enable Objective-C exception and synchronization syntax\n \n+fobjc-sjlj-exceptions\n+ObjC ObjC++\n+Enable Objective-C setjmp exception handling runtime\n+\n foperator-names\n C++ ObjC++\n Recognize C++ kewords like \\\"compl\\\" and \\\"xor\\\""}, {"sha": "21ade90cb60d46ddd681086e1b0be6911f3c4f91", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -4085,9 +4085,12 @@ output_function_exception_table (void)\n \t  if (TREE_CODE (type) == ADDR_EXPR)\n \t    {\n \t      type = TREE_OPERAND (type, 0);\n-\t      node = cgraph_varpool_node (type);\n-\t      if (node)\n-\t\tcgraph_varpool_mark_needed_node (node);\n+\t      if (TREE_CODE (type) == VAR_DECL)\n+\t\t{\n+\t          node = cgraph_varpool_node (type);\n+\t          if (node)\n+\t\t    cgraph_varpool_mark_needed_node (node);\n+\t\t}\n \t    }\n \t  else if (TREE_CODE (type) != INTEGER_CST)\n \t    abort ();"}, {"sha": "c2cfa4d6fe18c3d58e37660e91da000d6b5d9014", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 507, "deletions": 503, "changes": 1010, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -63,6 +63,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"diagnostic.h\"\n #include \"cgraph.h\"\n+#include \"tree-iterator.h\"\n+#include \"libfuncs.h\"\n \n /* This is the default way of generating a method name.  */\n /* I am not sure it is really correct.\n@@ -134,13 +136,7 @@ static void build_selector_translation_table (void);\n static tree objc_add_static_instance (tree, tree);\n \n static void build_objc_exception_stuff (void);\n-static tree objc_declare_variable (enum rid, tree, tree, tree);\n-static tree objc_enter_block (void);\n-static tree objc_exit_block (void);\n-static void objc_build_try_enter_fragment (void);\n-static void objc_build_try_exit_fragment (void);\n-static void objc_build_extract_fragment (void);\n-static tree objc_build_extract_expr (void);\n+static void build_next_objc_exception_stuff (void);\n \n static tree build_ivar_template (void);\n static tree build_method_template (void);\n@@ -365,23 +361,6 @@ static const char *default_constant_string_class_name;\n #define TAG_RETURN_STRUCT\t\t\"objc_return_struct\"\n \n #define UTAG_EXCDATA\t\t\t\"_objc_exception_data\"\n-#define UTAG_EXCDATA_VAR\t\t\"_stackExceptionData\"\n-#define UTAG_CAUGHTEXC_VAR\t\t\"_caughtException\"\n-#define UTAG_RETHROWEXC_VAR\t\t\"_rethrowException\"\n-#define UTAG_EVALONCE_VAR\t\t\"_eval_once\"\n-\n-struct val_stack {\n-  long val;\n-  struct val_stack *next;\n-};\n-static struct val_stack *catch_count_stack, *exc_binding_stack;\n-\n-/* useful for debugging */\n-static int if_nesting_count;\n-static int blk_nesting_count;\n-\n-static void val_stack_push (struct val_stack **, long);\n-static void val_stack_pop (struct val_stack **);\n \n /* The OCTI_... enumeration itself is in objc/objc-act.h.  */\n tree objc_global_trees[OCTI_MAX];\n@@ -626,6 +605,20 @@ lookup_protocol_in_reflist (tree rproto_list, tree lproto)\n   return 0;\n }\n \n+/* Return true if TYPE is 'id'.  */\n+\n+static bool\n+objc_is_object_id (tree type)\n+{\n+  return OBJC_TYPE_NAME (type) == objc_object_id;\n+}\n+\n+static bool\n+objc_is_class_id (tree type)\n+{\n+  return OBJC_TYPE_NAME (type) == objc_class_id;\n+}\n+\n /* Return 1 if LHS and RHS are compatible types for assignment or\n    various other operations.  Return 0 if they are incompatible, and\n    return -1 if we choose to not decide (because the types are really\n@@ -777,12 +770,12 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \t      return 1;\n \t    }\n \t  /* <Protocol> = id */\n-\t  else if (OBJC_TYPE_NAME (TREE_TYPE (rhs)) == objc_object_id)\n+\t  else if (objc_is_object_id (TREE_TYPE (rhs)))\n \t    {\n \t      return 1;\n \t    }\n \t  /* <Protocol> = Class */\n-\t  else if (OBJC_TYPE_NAME (TREE_TYPE (rhs)) == objc_class_id)\n+\t  else if (objc_is_class_id (TREE_TYPE (rhs)))\n \t    {\n \t      return 0;\n \t    }\n@@ -854,12 +847,12 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n \t\treturn 0;\n \t    }\n \t  /* id = <Protocol> */\n-\t  else if (OBJC_TYPE_NAME (TREE_TYPE (lhs)) == objc_object_id)\n+\t  else if (objc_is_object_id (TREE_TYPE (lhs)))\n \t    {\n \t      return 1;\n \t    }\n \t  /* Class = <Protocol> */\n-\t  else if (OBJC_TYPE_NAME (TREE_TYPE (lhs)) == objc_class_id)\n+\t  else if (objc_is_class_id (TREE_TYPE (lhs)))\n \t    {\n \t      return 0;\n \t    }\n@@ -892,16 +885,14 @@ objc_comptypes (tree lhs, tree rhs, int reflexive)\n      'Object *o = [[Object alloc] init]; falls\n      in the case <class> * = `id'.\n   */\n-  if ((OBJC_TYPE_NAME (lhs) == objc_object_id && TYPED_OBJECT (rhs))\n-      || (OBJC_TYPE_NAME (rhs) == objc_object_id && TYPED_OBJECT (lhs)))\n+  if ((objc_is_object_id (lhs) && TYPED_OBJECT (rhs))\n+      || (objc_is_object_id (rhs) && TYPED_OBJECT (lhs)))\n     return 1;\n \n   /* `id' = `Class', `Class' = `id' */\n \n-  else if ((OBJC_TYPE_NAME (lhs) == objc_object_id\n-\t    && OBJC_TYPE_NAME (rhs) == objc_class_id)\n-\t   || (OBJC_TYPE_NAME (lhs) == objc_class_id\n-\t       && OBJC_TYPE_NAME (rhs) == objc_object_id))\n+  else if ((objc_is_object_id (lhs) && objc_is_class_id (rhs))\n+\t   || (objc_is_class_id (lhs) && objc_is_object_id (rhs)))\n     return 1;\n \n   /* `Class' != `<class> *' && `<class> *' != `Class'!  */\n@@ -1273,8 +1264,9 @@ synth_module_prologue (void)\n     = builtin_function (TAG_GETMETACLASS, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n \n   build_super_template ();\n+  build_objc_exception_stuff ();\n   if (flag_next_runtime)\n-    build_objc_exception_stuff ();\n+    build_next_objc_exception_stuff ();\n \n   /* static SEL _OBJC_SELECTOR_TABLE[]; */\n \n@@ -2682,563 +2674,561 @@ get_class_ivars (tree interface, int raw)\n }\n \n static tree\n-objc_enter_block (void)\n+objc_create_temporary_var (tree type)\n {\n-  tree block;\n-\n-#ifdef OBJCPLUS\n-  block = begin_compound_stmt (0);\n-#else\n-  block = c_begin_compound_stmt (1);\n-#endif\n-\n-  objc_exception_block_stack = tree_cons (NULL_TREE, block,\n-\t\t\t\t\t  objc_exception_block_stack);\n+  tree decl;\n+ \n+  decl = build_decl (VAR_DECL, NULL_TREE, type);\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  DECL_CONTEXT (decl) = current_function_decl;\n \n-  blk_nesting_count++;\n-  return block;\n+  return decl;\n }\n+\f\n+/* Exception handling constructs.  We begin by having the parser do most\n+   of the work and passing us blocks.  What we do next depends on whether\n+   we're doing \"native\" exception handling or legacy Darwin setjmp exceptions.\n+   We abstract all of this in a handful of appropriately named routines.  */\n \n-static tree\n-objc_exit_block (void)\n+/* Stack of open try blocks.  */\n+\n+struct objc_try_context\n {\n-  tree block = TREE_VALUE (objc_exception_block_stack);\n-  objc_exception_block_stack = TREE_CHAIN (objc_exception_block_stack);\t\n+  struct objc_try_context *outer;\n \n-  objc_clear_super_receiver ();\n-#ifdef OBJCPLUS\n-  finish_compound_stmt (block);\n-#else\n-  block = c_end_compound_stmt (block, 1);\n-#endif\n+  /* Statements (or statement lists) as processed by the parser.  */\n+  tree try_body;\n+  tree finally_body;\n \n-  blk_nesting_count--;\n-  return block;\n-}\n+  /* Some file position locations.  */\n+  location_t try_locus;\n+  location_t end_try_locus;\n+  location_t end_catch_locus;\n+  location_t finally_locus;\n+  location_t end_finally_locus;\n+\n+  /* A STATEMENT_LIST of CATCH_EXPRs, appropriate for sticking into op1\n+     of a TRY_CATCH_EXPR.  Even when doing Darwin setjmp.  */\n+  tree catch_list;\n+\n+  /* The CATCH_EXPR of an open @catch clause.  */\n+  tree current_catch;\n+\n+  /* The VAR_DECL holding the Darwin equivalent of EXC_PTR_EXPR.  */\n+  tree caught_decl;\n+  tree stack_decl;\n+  tree rethrow_decl;\n+};\n+\n+static struct objc_try_context *cur_try_context;\n+\n+/* This hook, called via lang_eh_runtime_type, generates a runtime object\n+   that represents TYPE.  For Objective-C, this is just the class name.  */\n+/* ??? Isn't there a class object or some such?  Is it easy to get?  */\n \n static tree\n-objc_declare_variable (enum rid scspec, tree name, tree type, tree init)\n+objc_eh_runtime_type (tree type)\n {\n-  tree decl;\n-\n-  type = tree_cons (NULL_TREE, type,\n-\t\t    tree_cons (NULL_TREE, ridpointers[(int) scspec],\n-\t\t\t       NULL_TREE));\n-  TREE_STATIC (type) = 1;\n-  decl = start_decl (name, type, (init != NULL_TREE), NULL_TREE);\n-  finish_decl (decl, init, NULL_TREE);\n-  /* This prevents `unused variable' warnings when compiling with -Wall.  */\n-  TREE_USED (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  return decl;\n+  return add_objc_string (OBJC_TYPE_NAME (TREE_TYPE (type)), class_names);\n }\n \n-tree\n-objc_build_throw_stmt (tree throw_expr)\n+/* Initialize exception handling.  */\n+\n+static void\n+objc_init_exceptions (void)\n {\n-  tree func_params;\n+  static bool done = false;\n+  if (done)\n+    return;\n+  done = true;\n \n+  /* Why?  */\n   if (!flag_objc_exceptions)\n-    fatal_error (\"Use `-fobjc-exceptions' to enable Objective-C exception syntax\");\n+    warning (\"use %<-fobjc-exceptions%> to enable Objective-C \"\n+\t     \"exception syntax\");\n \n-  if (!throw_expr && objc_caught_exception)\n-    throw_expr = TREE_VALUE (objc_caught_exception);\n-\n-  if (!throw_expr)\n+  if (!flag_objc_sjlj_exceptions)\n     {\n-      error (\"`@throw;' (rethrow) used outside of a `@catch' block\");\n-      return error_mark_node;\n+      c_eh_initialized_p = true;\n+      eh_personality_libfunc\n+\t= init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t    ? \"__gnu_objc_personality_sj0\"\n+\t\t\t    : \"__gnu_objc_personality_v0\");\n+      using_eh_for_cleanups ();\n+      lang_eh_runtime_type = objc_eh_runtime_type;\n     }\n-\n-  func_params = tree_cons (NULL_TREE, throw_expr, NULL_TREE);\n-\n-  assemble_external (objc_exception_throw_decl);\n-  return c_expand_expr_stmt (build_function_call (objc_exception_throw_decl,\n-\t\t\t\t\t\t  func_params));\n }\n \n-static void\n-val_stack_push (struct val_stack **nc, long val)\n+/* Build an EXC_PTR_EXPR, or the moral equivalent.  In the case of Darwin,\n+   we'll arrange for it to be initialized (and associated with a binding)\n+   later.  */\n+\n+static tree\n+objc_build_exc_ptr (void)\n {\n-  struct val_stack *new_elem = xmalloc (sizeof (struct val_stack));\n-  new_elem->val = val;\n-  new_elem->next = *nc;\n-  *nc = new_elem;\n+  if (flag_objc_sjlj_exceptions)\n+    {\n+      tree var = cur_try_context->caught_decl;\n+      if (!var)\n+\t{\n+\t  var = objc_create_temporary_var (id_type);\n+\t  cur_try_context->caught_decl = var;\n+\t}\n+      return var;\n+    }\n+  else\n+    return build (EXC_PTR_EXPR, id_type);\n }\n \n-static void\n-val_stack_pop (struct val_stack **nc)\n+/* Build \"objc_exception_try_exit(&_stack)\".  */\n+\n+static tree\n+next_sjlj_build_try_exit (void)\n {\n-  struct val_stack *old_elem = *nc;\n-  *nc = old_elem->next;\n-  free (old_elem);\n+  tree t;\n+  t = build_fold_addr_expr (cur_try_context->stack_decl);\n+  t = tree_cons (NULL, t, NULL);\n+  t = build_function_call (objc_exception_try_exit_decl, t);\n+  return t;\n }\n \n-static void\n-objc_build_try_enter_fragment (void)\n+/* Build\n+\tobjc_exception_try_enter (&_stack);\n+\tif (_setjmp(&_stack.buf))\n+\t  ;\n+\telse\n+\t  ;\n+   Return the COND_EXPR.  Note that the THEN and ELSE fields are left\n+   empty, ready for the caller to fill them in.  */\n+\n+static tree\n+next_sjlj_build_enter_and_setjmp (void)\n {\n-  /* objc_exception_try_enter(&_stackExceptionData);\n-     if (!_setjmp(&_stackExceptionData.buf)) {  */\n+  tree t, enter, sj, cond;\n \n-  tree func_params, cond;\n+  t = build_fold_addr_expr (cur_try_context->stack_decl);\n+  t = tree_cons (NULL, t, NULL);\n+  enter = build_function_call (objc_exception_try_enter_decl, t);\n \n-  func_params\n-    = tree_cons (NULL_TREE,\n-\t\t build_unary_op (ADDR_EXPR,\n-\t\t\t\t TREE_VALUE (objc_stack_exception_data),\n-\t\t\t\t 0),\n-\t\t NULL_TREE);\n+  t = build_component_ref (cur_try_context->stack_decl,\n+\t\t\t   get_identifier (\"buf\"));\n+  t = build_fold_addr_expr (t);\n+  t = convert (ptr_type_node, t);\n+  t = tree_cons (NULL, t, NULL);\n+  sj = build_function_call (objc_setjmp_decl, t);\n \n-  assemble_external (objc_exception_try_enter_decl);\n-  c_expand_expr_stmt (build_function_call\n-\t\t      (objc_exception_try_enter_decl, func_params));\n+  cond = build (COMPOUND_EXPR, TREE_TYPE (sj), enter, sj);\n+  cond = lang_hooks.truthvalue_conversion (cond);\n \n-#ifdef OBJCPLUS\n-  /* Um, C and C++ have very different statement construction functions.\n-     Partly because different scoping rules are in effect, but partly \n-     because of how their parsers are constructed.  I highly recommend\n-     simply constructing the statements by hand here.  You don't need\n-     any of the ancilliary tracking necessary for user parsing bits anyway.  */\n-#error\n-#endif\n-\n-  c_begin_if_stmt ();\n-  if_nesting_count++;\n-  /* If <setjmp.h> has been included, the _setjmp prototype has\n-     acquired a real, breathing type for its parameter.  Cast our\n-     argument to that type.  */\n-  func_params\n-    = tree_cons (NULL_TREE,\n-\t\t build_c_cast (TYPE_ARG_TYPES (TREE_TYPE (objc_setjmp_decl))\n-\t\t\t       ? TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (objc_setjmp_decl)))\n-\t\t\t       : ptr_type_node,\n-\t\t\t       build_unary_op\n-\t\t\t       (ADDR_EXPR,\n-\t\t\t\tbuild_component_ref (TREE_VALUE (objc_stack_exception_data),\n-\t\t\t\t\t\t     get_identifier (\"buf\")), 0)),\n-\t\t NULL_TREE);\n-  assemble_external (objc_setjmp_decl);\n-  cond = build_unary_op (TRUTH_NOT_EXPR,\n-\t\t\t build_function_call (objc_setjmp_decl, func_params),\n-\t\t\t 0);\n-  c_finish_if_cond (cond, 0, 0);\n-  objc_enter_block ();\n+  return build (COND_EXPR, void_type_node, cond, NULL, NULL);\n }\n \n+/* Build\n+\tDECL = objc_exception_extract(&_stack);\n+*/\n+   \n static tree\n-objc_build_extract_expr (void)\n+next_sjlj_build_exc_extract (tree decl)\n {\n-  /*\t... = objc_exception_extract(&_stackExceptionData);  */\n+  tree t;\n \n-  tree func_params\n-    = tree_cons (NULL_TREE,\n-\t\t build_unary_op (ADDR_EXPR,\n-\t\t\t\t TREE_VALUE (objc_stack_exception_data), 0),\n-\t\t NULL_TREE);\n+  t = build_fold_addr_expr (cur_try_context->stack_decl);\n+  t = tree_cons (NULL, t, NULL);\n+  t = build_function_call (objc_exception_extract_decl, t);\n+  t = convert (TREE_TYPE (decl), t);\n+  t = build (MODIFY_EXPR, void_type_node, decl, t);\n \n-  assemble_external (objc_exception_extract_decl);\n-  return build_function_call (objc_exception_extract_decl, func_params);\n+  return t;\n }\n \n-static void\n-objc_build_try_exit_fragment (void)\n-{\n-  /* objc_exception_try_exit(&_stackExceptionData); */\n-\n-  tree func_params\n-    = tree_cons (NULL_TREE,\n-\t\t build_unary_op (ADDR_EXPR,\n-\t\t\t\t TREE_VALUE (objc_stack_exception_data), 0),\n-\t\t NULL_TREE);\n-\n-    assemble_external (objc_exception_try_exit_decl);\n-    c_expand_expr_stmt (build_function_call (objc_exception_try_exit_decl,\n-\t\t\t\t\t     func_params));\n-}\n+/* Build\n+\tif (objc_exception_match(obj_get_class(TYPE), _caught)\n+\t  BODY\n+\telse if (...)\n+\t  ...\n+\telse\n+\t  {\n+\t    _rethrow = _caught;\n+\t    objc_exception_try_exit(&_stack);\n+\t  }\n+   from the sequence of CATCH_EXPRs in the current try context.  */\n \n-static void\n-objc_build_extract_fragment (void)\n+static tree\n+next_sjlj_build_catch_list (void)\n {\n-  /* } else {\n-      _rethrowException = objc_exception_extract(&_stackExceptionData);\n-     }  */\n+  tree_stmt_iterator i = tsi_start (cur_try_context->catch_list);\n+  tree catch_seq, t;\n+  tree *last = &catch_seq;\n+  bool saw_id = false;\n \n-  c_finish_then (objc_exit_block ());\n-\n-  c_begin_else (0);\n-  objc_enter_block ();\n-  c_expand_expr_stmt (build_modify_expr\n-\t\t      (TREE_VALUE (objc_rethrow_exception),\n-\t\t       NOP_EXPR,\n-\t\t       objc_build_extract_expr ()));\n-  c_finish_else (objc_exit_block ());\n-  c_finish_if_stmt (1);\n-  if_nesting_count--;\n-}\n+  for (; !tsi_end_p (i); tsi_next (&i))\n+    {\n+      tree stmt = tsi_stmt (i);\n+      tree type = CATCH_TYPES (stmt);\n+      tree body = CATCH_BODY (stmt);\n \n-tree\n-objc_build_try_prologue (void)\n-{\n-  /* { // new scope\n-       struct _objc_exception_data _stackExceptionData;\n-       volatile id _rethrowException = nil;\n-       { // begin TRY-CATCH scope\n-         objc_exception_try_enter(&_stackExceptionData);\n-\t if (!_setjmp(&_stackExceptionData.buf)) {  */\n+      if (type == NULL)\n+\t{\n+\t  *last = body;\n+\t  saw_id = true;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  tree args, cond;\n \n-  tree try_catch_block;\n+\t  if (type == error_mark_node)\n+\t    cond = error_mark_node;\n+\t  else\n+\t    {\n+\t      args = tree_cons (NULL, cur_try_context->caught_decl, NULL);\n+\t      t = get_class_reference (OBJC_TYPE_NAME (TREE_TYPE (type)));\n+\t      args = tree_cons (NULL, t, args);\n+\t      t = build_function_call (objc_exception_match_decl, args);\n+\t      cond = lang_hooks.truthvalue_conversion (t);\n+\t    }\n+\t  t = build (COND_EXPR, void_type_node, cond, body, NULL);\n+\t  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n \n-  if (!flag_objc_exceptions)\n-    fatal_error (\"Use `-fobjc-exceptions' to enable Objective-C exception syntax\");\n-\n-  objc_mark_locals_volatile ((void *)(exc_binding_stack\n-\t\t\t\t      ? exc_binding_stack->val\n-\t\t\t\t      : 0));\n-  objc_enter_block ();\n-  objc_stack_exception_data\n-    = tree_cons (NULL_TREE,\n-\t\t objc_declare_variable (RID_AUTO,\n-\t\t\t\t\tget_identifier (UTAG_EXCDATA_VAR),\n-\t\t\t\t\txref_tag (RECORD_TYPE,\n-\t\t\t\t\t\t  get_identifier (UTAG_EXCDATA)),\n-\t\t\t\t\tNULL_TREE),\n-\t\t objc_stack_exception_data);\n-  objc_rethrow_exception = tree_cons (NULL_TREE,\n-\t\t\t\t      objc_declare_variable (RID_VOLATILE,\n-\t\t\t\t\t\t\t     get_identifier (UTAG_RETHROWEXC_VAR),\n-\t\t\t\t\t\t\t     id_type,\n-\t\t\t\t\t\t\t     build_int_2 (0, 0)),\n-\t\t\t\t      objc_rethrow_exception);\n-\n-  try_catch_block = objc_enter_block ();\n-  val_stack_push (&exc_binding_stack, (long) get_current_scope ());\n-  objc_build_try_enter_fragment ();\n-\n-  return try_catch_block;\n-}\n+\t  *last = t;\n+\t  last = &COND_EXPR_ELSE (t);\n+\t}\n+    }\n \n-void\n-objc_build_try_epilogue (int also_catch_prologue)\n-{\n-  if (also_catch_prologue)\n+  if (!saw_id)\n     {\n-      /* } else {\n-\t   register id _caughtException = objc_exception_extract( &_stackExceptionData);\n-\t   objc_exception_try_enter(&_stackExceptionData);\n-\t   if(!_setjmp(&_stackExceptionData.buf)) {\n-\t     if (0) {  */\n+      t = build (MODIFY_EXPR, void_type_node, cur_try_context->rethrow_decl,\n+\t\t cur_try_context->caught_decl);\n+      annotate_with_locus (t, cur_try_context->end_catch_locus);\n+      append_to_statement_list (t, last);\n \n-      c_finish_then (objc_exit_block ());\n-    \t\t\n-      c_begin_else (0);\n-      objc_enter_block ();\n-      objc_caught_exception\n-\t= tree_cons (NULL_TREE,\n-\t\t     objc_declare_variable (RID_REGISTER,\n-\t\t\t\t\t    get_identifier (UTAG_CAUGHTEXC_VAR),\n-\t\t\t\t\t    id_type,\n-\t\t\t\t\t    objc_build_extract_expr ()),\n-\t\t     objc_caught_exception);\n-      objc_build_try_enter_fragment ();\n-      val_stack_push (&catch_count_stack, 1);\n-      c_begin_if_stmt ();\n-      if_nesting_count++;\n-      c_finish_if_cond (boolean_false_node, 0, 0);\n-      objc_enter_block ();\n-\n-      /* Start a new chain of @catch statements for this @try.  */\n-      objc_catch_type = tree_cons (objc_catch_type, NULL_TREE, NULL_TREE);\n+      t = next_sjlj_build_try_exit ();\n+      annotate_with_locus (t, cur_try_context->end_catch_locus);\n+      append_to_statement_list (t, last);\n     }\n-  else\n-    {  /* !also_catch_prologue */\n \n-      /* } else {\n-\t   _rethrowException = objc_exception_extract( &_stackExceptionData);\n-\t }\n-       }  */\n-      objc_build_extract_fragment ();\n-      objc_exit_block ();\n-    }\n+  return catch_seq;\n }\n \n-void\n-objc_build_catch_stmt (tree catch_expr)\n-{\n-  /* } else if (objc_exception_match(objc_get_class(\"SomeClass\"), _caughtException)) {\n-       register SomeClass *e = _caughtException;  */\n-\n-  tree cond, func_params, prev_catch, var_name, var_type;\n-  int catch_id;\n+/* Build a complete @try-@catch-@finally block for legacy Darwin setjmp\n+   exception handling.  We aim to build:\n \n-#ifndef OBJCPLUS\n-  /* Yet another C/C++ impedance mismatch.  */\n-  catch_expr = TREE_PURPOSE (catch_expr);\n-#endif\n+\t{\n+\t  struct _objc_exception_data _stack;\n+\t  id volatile _rethrow = 0;\n+\t  try\n+\t    {\n+\t      objc_exception_try_enter (&_stack);\n+\t      if (_setjmp(&_stack.buf))\n+\t        {\n+\t\t  id _caught = objc_exception_extract(&_stack);\n+\t\t  objc_exception_try_enter (&_stack);\n+\t\t  if (_setjmp(&_stack.buf))\n+\t\t    _rethrow = objc_exception_extract(&_stack);\n+\t\t  else\n+\t\t    CATCH-LIST\n+\t        }\n+\t      else\n+\t\tTRY-BLOCK\n+\t    }\n+\t  finally\n+\t    {\n+\t      if (!_rethrow)\n+\t\tobjc_exception_try_exit(&_stack);\n+\t      FINALLY-BLOCK\n+\t      if (_rethrow)\n+\t\tobjc_exception_throw(_rethrow);\n+\t    }\n+\t}\n \n-  var_name = TREE_VALUE (catch_expr);\n-  var_type = TREE_VALUE (TREE_PURPOSE (catch_expr));\n-  if (TREE_CODE (var_name) == INDIRECT_REF)\n-    var_name = TREE_OPERAND (var_name, 0);\n-  if (TREE_CODE (var_type) == TYPE_DECL\n-      || TREE_CODE (var_type) == POINTER_TYPE)\n-    var_type = TREE_TYPE (var_type);\n-  catch_id = (var_type == TREE_TYPE (id_type));\n+   If CATCH-LIST is empty, we can omit all of the block containing\n+   \"_caught\" except for the setting of _rethrow.  Note the use of\n+   a real TRY_FINALLY_EXPR here, which is not involved in EH per-se,\n+   but handles goto and other exits from the block.  */\n \n-  if (!flag_objc_exceptions)\n-    fatal_error (\"Use `-fobjc-exceptions' to enable Objective-C exception syntax\");\n+static tree\n+next_sjlj_build_try_catch_finally (void)\n+{\n+  tree rethrow_decl, stack_decl, t;\n+  tree catch_seq, try_fin, bind;\n \n-  if (!(catch_id || TYPED_OBJECT (var_type)))\n-    fatal_error (\"`@catch' parameter is not a known Objective-C class type\");\n+  /* Create the declarations involved.  */\n+  t = xref_tag (RECORD_TYPE, get_identifier (UTAG_EXCDATA));\n+  stack_decl = objc_create_temporary_var (t);\n+  cur_try_context->stack_decl = stack_decl;\n \n-  /* Examine previous @catch clauses for the current @try block for\n-     superclasses of the 'var_type' class.  */\n-  for (prev_catch = objc_catch_type; TREE_VALUE (prev_catch);\n-       prev_catch = TREE_CHAIN (prev_catch))\n-    {\n-      if (TREE_VALUE (prev_catch) == TREE_TYPE (id_type))\n-\t{\n-\t  warning (\"Exception already handled by preceding `@catch(id)'\");\n-\t  break;\n-\t}\n-      else if (!catch_id\n-\t       && objc_comptypes (TREE_VALUE (prev_catch), var_type, 0) == 1)\n-\twarning (\"Exception of type `%s *' already handled by `@catch (%s *)'\",\n-\t\t IDENTIFIER_POINTER (OBJC_TYPE_NAME (var_type)),\n-\t\t IDENTIFIER_POINTER (OBJC_TYPE_NAME (TREE_VALUE (prev_catch))));\n-    }\n+  rethrow_decl = objc_create_temporary_var (id_type);\n+  cur_try_context->rethrow_decl = rethrow_decl;\n+  TREE_THIS_VOLATILE (rethrow_decl) = 1;\n+  TREE_CHAIN (rethrow_decl) = stack_decl;\n \n-  objc_catch_type = tree_cons (NULL_TREE, var_type, objc_catch_type);\n+  /* Build the outermost varible binding level.  */\n+  bind = build (BIND_EXPR, void_type_node, rethrow_decl, NULL, NULL);\n+  annotate_with_locus (bind, cur_try_context->try_locus);\n+  TREE_SIDE_EFFECTS (bind) = 1;\n \n-  c_finish_then (objc_exit_block ());\n+  /* Initialize rethrow_decl.  */\n+  t = build (MODIFY_EXPR, void_type_node, rethrow_decl,\n+\t     convert (id_type, null_pointer_node));\n+  annotate_with_locus (t, cur_try_context->try_locus);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n \n-  c_begin_else (0);\n-  catch_count_stack->val++;\n-  c_begin_if_stmt ();\n-  if_nesting_count++;\n+  /* Build the outermost TRY_FINALLY_EXPR.  */\n+  try_fin = build (TRY_FINALLY_EXPR, void_type_node, NULL, NULL);\n+  annotate_with_locus (try_fin, cur_try_context->try_locus);\n+  TREE_SIDE_EFFECTS (try_fin) = 1;\n+  append_to_statement_list (try_fin, &BIND_EXPR_BODY (bind));\n \n-  if (catch_id)\n-    cond = integer_one_node;\n-  else\n+  /* Create the complete catch sequence.  */\n+  if (cur_try_context->catch_list)\n     {\n-      cond = get_class_reference (OBJC_TYPE_NAME (var_type));\n-\t\n-      func_params\n-\t= tree_cons (NULL_TREE, cond,\n-\t\t     tree_cons (NULL_TREE,\n-\t\t\t\tTREE_VALUE (objc_caught_exception),\n-\t\t\t\tNULL_TREE));\n-      assemble_external (objc_exception_match_decl);\n-      cond = build_function_call (objc_exception_match_decl, func_params);\n-    }\n+      tree caught_decl = objc_build_exc_ptr ();\n+      catch_seq = build_stmt (BIND_EXPR, caught_decl, NULL, NULL);\n \n-  c_finish_if_cond (cond, 0, 0);\n-  objc_enter_block ();\n-  objc_declare_variable (RID_REGISTER, var_name,\n-\t\t\t build_pointer_type (var_type),\n-\t\t\t TREE_VALUE (objc_caught_exception));\n-}\n+      t = next_sjlj_build_exc_extract (caught_decl);\n+      append_to_statement_list (t, &BIND_EXPR_BODY (catch_seq));\n \n-void\n-objc_build_catch_epilogue (void)\n-{\n-  /*     } else {\n-           _rethrowException = _caughtException;\n-           objc_exception_try_exit(&_stackExceptionData);\n-         }\n-       } else {\n-         _rethrowException = objc_exception_extract(&_stackExceptionData);\n-       }\n-     }\n-   } // end TRY-CATCH scope\n-  */\n+      t = next_sjlj_build_enter_and_setjmp ();\n+      COND_EXPR_THEN (t) = next_sjlj_build_exc_extract (rethrow_decl);\n+      COND_EXPR_ELSE (t) = next_sjlj_build_catch_list ();\n+      append_to_statement_list (t, &BIND_EXPR_BODY (catch_seq));\n+    }\n+  else\n+    catch_seq = next_sjlj_build_exc_extract (rethrow_decl);\n+  annotate_with_locus (catch_seq, cur_try_context->end_try_locus);\n \n-  c_finish_then (objc_exit_block ());\n+  /* Build the main register-and-try if statement.  */\n+  t = next_sjlj_build_enter_and_setjmp ();\n+  annotate_with_locus (t, cur_try_context->try_locus);\n+  COND_EXPR_THEN (t) = catch_seq;\n+  COND_EXPR_ELSE (t) = cur_try_context->try_body;\n+  TREE_OPERAND (try_fin, 0) = t;\n \n-  c_begin_else (0);\n-  objc_enter_block ();\n-  c_expand_expr_stmt\n-    (build_modify_expr\n-     (TREE_VALUE (objc_rethrow_exception),\n-      NOP_EXPR,\n-      TREE_VALUE (objc_caught_exception)));\n-  objc_build_try_exit_fragment ();\t\n-  objc_exit_block ();\n-  while (catch_count_stack->val--)\n-    {\n-      /* FIXME.  Need to have the block of each else that was opened.  */\n-      c_finish_else ((abort (), NULL)); /* close off all the nested ifs ! */\n-      c_finish_if_stmt (1);\n-      if_nesting_count--;\n-    }\n-  val_stack_pop (&catch_count_stack);\n-  objc_caught_exception = TREE_CHAIN (objc_caught_exception);\n+  /* Build the complete FINALLY statement list.  */\n+  t = next_sjlj_build_try_exit ();\n+  t = build_stmt (COND_EXPR,\n+\t\t  lang_hooks.truthvalue_conversion (rethrow_decl),\n+\t\t  NULL, t);\n+  annotate_with_locus (t, cur_try_context->finally_locus);\n+  append_to_statement_list (t, &TREE_OPERAND (try_fin, 1));\n \n-  objc_build_extract_fragment ();\n+  append_to_statement_list (cur_try_context->finally_body,\n+\t\t\t    &TREE_OPERAND (try_fin, 1));\n \n-  c_finish_else (objc_exit_block ());\n-  c_finish_if_stmt (1);\n-  if_nesting_count--;\n-  objc_exit_block ();\n+  t = tree_cons (NULL, rethrow_decl, NULL);\n+  t = build_function_call (objc_exception_throw_decl, t);\n+  t = build_stmt (COND_EXPR,\n+\t\t  lang_hooks.truthvalue_conversion (rethrow_decl),\n+\t\t  t, NULL);\n+  annotate_with_locus (t, cur_try_context->end_finally_locus);\n+  append_to_statement_list (t, &TREE_OPERAND (try_fin, 1));\n \n-  /* Return to enclosing chain of @catch statements (if any).  */\n-  while (TREE_VALUE (objc_catch_type))\n-    objc_catch_type = TREE_CHAIN (objc_catch_type);\n-  objc_catch_type = TREE_PURPOSE (objc_catch_type);\n+  return bind;\n }\n \n-tree\n-objc_build_finally_prologue (void)\n+/* Called just after parsing the @try and its associated BODY.  We now\n+   must prepare for the tricky bits -- handling the catches and finally.  */\n+\n+void\n+objc_begin_try_stmt (location_t try_locus, tree body)\n {\n-  /* { // begin FINALLY scope\n-       if (!_rethrowException) {\n-         objc_exception_try_exit(&_stackExceptionData);\n-       }  */\n+  struct objc_try_context *c = xcalloc (1, sizeof (*c));\n+  c->outer = cur_try_context;\n+  c->try_body = body;\n+  c->try_locus = try_locus;\n+  c->end_try_locus = input_location;\n+  cur_try_context = c;\n \n-  tree blk = objc_enter_block ();\n+  objc_init_exceptions ();\n+}\n+\n+/* Called just after parsing \"@catch (parm)\".  Open a binding level, \n+   enter PARM into the binding level, and initialize it.  Leave the\n+   binding level open while the body of the compound statement is parsed.  */\n+   \n+void\n+objc_begin_catch_clause (tree parm)\n+{\n+  tree compound, decl, type, t;\n \n-  c_begin_if_stmt ();\n-  if_nesting_count++;\n+  /* Begin a new scope that the entire catch clause will live in.  */\n+  compound = c_begin_compound_stmt (1);\n \n-  c_finish_if_cond (build_unary_op (TRUTH_NOT_EXPR,\n-\t\t\t\t    TREE_VALUE (objc_rethrow_exception), 0),\n-\t\t    0, 0);\n-  objc_enter_block ();\n-  objc_build_try_exit_fragment ();\n-  c_finish_then (objc_exit_block ());\n-  c_finish_if_stmt (1);\n-  if_nesting_count--;\n+  /* Turn the raw declarator/declspecs into a decl in the current scope.  */\n+  decl = define_decl (TREE_VALUE (TREE_PURPOSE (parm)),\n+\t\t      TREE_PURPOSE (TREE_PURPOSE (parm)));\n \n-  return blk;\n-}\n+  /* Since a decl is required here by syntax, don't warn if its unused.  */\n+  /* ??? As opposed to __attribute__((unused))?  Anyway, this appears to\n+     be what the previous objc implementation did.  */\n+  TREE_USED (decl) = 1;\n \n-tree\n-objc_build_finally_epilogue (void)\n-{\n-  /*    if (_rethrowException) {\n-\t  objc_exception_throw(_rethrowException);\n+  /* Verify that the type of the catch is valid.  It must be a pointer\n+     to an Objective-C class, or \"id\" (which is catch-all).  */\n+  type = TREE_TYPE (decl);\n+  if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n+    type = NULL;\n+  else if (!POINTER_TYPE_P (type) || !TYPED_OBJECT (TREE_TYPE (type)))\n+    {\n+      error (\"@catch parameter is not a known Objective-C class type\");\n+      type = error_mark_node;\n+    }\n+  else if (cur_try_context->catch_list)\n+    {\n+      /* Examine previous @catch clauses and see if we've already\n+\t caught the type in question.  */\n+      tree_stmt_iterator i = tsi_start (cur_try_context->catch_list);\n+      for (; !tsi_end_p (i); tsi_next (&i))\n+\t{\n+\t  tree stmt = tsi_stmt (i);\n+\t  t = CATCH_TYPES (stmt);\n+\t  if (t == error_mark_node)\n+\t    continue;\n+\t  if (!t || objc_comptypes (TREE_TYPE (t), TREE_TYPE (type), 0) == 1)\n+\t    {\n+\t      warning (\"exception of type %<%T%> will be caught\",\n+\t\t       TREE_TYPE (type));\n+\t      warning (\"%H   by earlier handler for %<%T%>\",\n+\t\t       EXPR_LOCUS (stmt), TREE_TYPE (t ? t : id_type));\n+\t      break;\n+\t    }\n \t}\n-      } // end FINALLY scope\n-    } */\n+    }\n \n-  c_begin_if_stmt ();\n-  if_nesting_count++;\n+  /* Record the data for the catch in the try context so that we can\n+     finalize it later.  */\n+  t = build_stmt (CATCH_EXPR, type, compound);\n+  cur_try_context->current_catch = t;\n \n-  c_finish_if_cond (TREE_VALUE (objc_rethrow_exception), 0, 0);\n-  objc_enter_block ();\n-  objc_build_throw_stmt (TREE_VALUE (objc_rethrow_exception));\n-  c_finish_then (objc_exit_block ());\n-  c_finish_if_stmt (1);\n-  if_nesting_count--;\n+  /* Initialize the decl from the EXC_PTR_EXPR we get from the runtime.  */\n+  t = objc_build_exc_ptr ();\n+  t = convert (TREE_TYPE (decl), t);\n+  t = build (MODIFY_EXPR, void_type_node, decl, t);\n+  add_stmt (t);\n+}\n \n-  objc_exit_block ();\n-  objc_rethrow_exception = TREE_CHAIN (objc_rethrow_exception);\n-  objc_stack_exception_data = TREE_CHAIN (objc_stack_exception_data);\n+/* Called just after parsing the closing brace of a @catch clause.  Close\n+   the open binding level, and record a CATCH_EXPR for it.  */\n \n-  val_stack_pop (&exc_binding_stack);\n-  return objc_exit_block ();\n+void\n+objc_finish_catch_clause (void)\n+{\n+  tree c = cur_try_context->current_catch;\n+  cur_try_context->current_catch = NULL;\n+  cur_try_context->end_catch_locus = input_location;\n+\n+  CATCH_BODY (c) = c_end_compound_stmt (CATCH_BODY (c), 1);\n+  append_to_statement_list (c, &cur_try_context->catch_list);\n }\n \n-tree\n-objc_build_try_catch_finally_stmt (int has_catch, int has_finally)\n-{\n-  /* NB: The operative assumption here is that TRY_FINALLY_EXPR will\n-     deal with all exits from 'try_catch_blk' and route them through\n-     'finally_blk'.  */\n-  /* ??? This is all crock.  What the hell is this trying to do?  */\n-  tree outer_blk = objc_build_finally_epilogue ();\n-  tree prec_stmt = TREE_CHAIN (TREE_CHAIN (outer_blk));\n-  tree try_catch_blk = TREE_CHAIN (prec_stmt), try_catch_expr;\n-  tree finally_blk = TREE_CHAIN (try_catch_blk), finally_expr;\n-  tree succ_stmt = TREE_CHAIN (finally_blk);\n-  tree try_finally_stmt, try_finally_expr;\n+/* Called after parsing a @finally clause and its associated BODY.\n+   Record the body for later placement.  */\n \n-  if (!flag_objc_exceptions)\n-    fatal_error (\"Use `-fobjc-exceptions' to enable Objective-C exception syntax\");\n+void\n+objc_build_finally_clause (location_t finally_locus, tree body)\n+{\n+  cur_try_context->finally_body = body;\n+  cur_try_context->finally_locus = finally_locus;\n+  cur_try_context->end_finally_locus = input_location;\n+}\n+\n+/* Called to finalize a @try construct.  */\n \n-  /* It is an error to have a @try block without a @catch and/or @finally\n-     (even though sensible code can be generated nonetheless).  */\n+void\n+objc_finish_try_stmt (void)\n+{\n+  struct objc_try_context *c = cur_try_context;\n+  tree stmt;\n \n-  if (!has_catch && !has_finally)\n+  if (c->catch_list == NULL && c->finally_body == NULL)\n     error (\"`@try' without `@catch' or `@finally'\");\n \n-  /* We shall now do something truly disgusting.  We shall remove the\n-     'try_catch_blk' and 'finally_blk' from the 'outer_blk' statement\n-     chain, and replace them with a TRY_FINALLY_EXPR statement!  If\n-     this doesn't work, we will have to learn (from Per/gcj) how to\n-     construct the 'outer_blk' lazily.  */\n-\n-  TREE_CHAIN (try_catch_blk) = TREE_CHAIN (finally_blk) = NULL_TREE;\n-  try_catch_expr = build1 (STMT_EXPR, void_type_node, try_catch_blk);\n-  TREE_SIDE_EFFECTS (try_catch_expr) = 1;\n-  finally_expr = build1 (STMT_EXPR, void_type_node, finally_blk);\n-  TREE_SIDE_EFFECTS (finally_expr) = 1;\n-  try_finally_expr = build (TRY_FINALLY_EXPR, void_type_node, try_catch_expr,\n-\t\t\t    finally_expr);\n-  TREE_SIDE_EFFECTS (try_finally_expr) = 1;\n-  try_finally_stmt = build_stmt (EXPR_STMT, try_finally_expr);\n-  TREE_CHAIN (prec_stmt) = try_finally_stmt;\n-  TREE_CHAIN (try_finally_stmt) = succ_stmt;\n-  \t\n-  return outer_blk;  /* the whole enchilada */\n+  /* If we're doing Darwin setjmp exceptions, build the big nasty.  */\n+  if (flag_objc_sjlj_exceptions)\n+    {\n+      if (!cur_try_context->finally_body)\n+\t{\n+\t  cur_try_context->finally_locus = input_location;\n+\t  cur_try_context->end_finally_locus = input_location;\n+\t}\n+      stmt = next_sjlj_build_try_catch_finally ();\n+    }\n+  else\n+    {\n+      /* Otherwise, nest the CATCH inside a FINALLY.  */\n+      stmt = c->try_body;\n+      if (c->catch_list)\n+\t{\n+          stmt = build_stmt (TRY_CATCH_EXPR, stmt, c->catch_list);\n+\t  annotate_with_locus (stmt, cur_try_context->try_locus);\n+\t}\n+      if (c->finally_body)\n+\t{\n+\t  stmt = build_stmt (TRY_FINALLY_EXPR, stmt, c->finally_body);\n+\t  annotate_with_locus (stmt, cur_try_context->try_locus);\n+\t}\n+    }\n+  add_stmt (stmt);\n+\n+  cur_try_context = c->outer;\n+  free (c);\n }\n \n void\n-objc_build_synchronized_prologue (tree sync_expr)\n+objc_build_throw_stmt (tree throw_expr)\n {\n-  /* {\n-       id _eval_once = <sync_expr>;\n-       @try {\n-              objc_sync_enter( _eval_once );  */\n-\n   tree func_params;\n \n-  if (!flag_objc_exceptions)\n-    fatal_error (\"Use `-fobjc-exceptions' to enable Objective-C exception syntax\");\n-\n-  objc_enter_block ();\n-  objc_eval_once\n-    = tree_cons (NULL_TREE,\n-\t\t objc_declare_variable (RID_AUTO,\n-\t\t\t\t\tget_identifier (UTAG_EVALONCE_VAR),\n-\t\t\t\t\tid_type,\n-\t\t\t\t\tsync_expr),\n-\t\t objc_eval_once);\n-  objc_build_try_prologue ();\n-  objc_enter_block ();\t\n-  func_params = tree_cons (NULL_TREE,\n-\t\t\t   TREE_VALUE (objc_eval_once),\n-\t\t\t   NULL_TREE);\n+  if (throw_expr == NULL)\n+    {\n+      /* If we're not inside a @catch block, there is no \"current\n+\t exception\" to be rethrown.  */\n+      if (cur_try_context == NULL\n+          || cur_try_context->current_catch == NULL)\n+\t{\n+\t  error (\"%<@throw%> (rethrow) used outside of a @catch block\");\n+\t  return;\n+\t}\n+\n+      /* Otherwise the object is still sitting in the EXC_PTR_EXPR\n+\t value that we get from the runtime.  */\n+      throw_expr = objc_build_exc_ptr ();\n+    }\n \n-  assemble_external (objc_sync_enter_decl);\n-  c_expand_expr_stmt (build_function_call\n-\t\t      (objc_sync_enter_decl, func_params));\n+  /* A throw is just a call to the runtime throw function with the\n+     object as a parameter.  */\n+  func_params = tree_cons (NULL, throw_expr, NULL);\n+  add_stmt (build_function_call (objc_exception_throw_decl, func_params));\n+\n+  objc_init_exceptions ();\n }\n \n-tree\n-objc_build_synchronized_epilogue (void)\n+void\n+objc_build_synchronized (location_t start_locus, tree mutex, tree body)\n {\n-  /* }\n-       @finally {\n-         objc_sync_exit( _eval_once );\n-       }\n-     }  */\n+  tree args, call;\n \n-  tree func_params;\n+  /* First lock the mutex.  */\n+  mutex = save_expr (mutex);\n+  args = tree_cons (NULL, mutex, NULL);\n+  call = build_function_call (objc_sync_enter_decl, args);\n+  annotate_with_locus (call, start_locus);\n+  add_stmt (call);\n \n-  objc_exit_block ();\t\n-  objc_build_try_epilogue (0);\n-  objc_build_finally_prologue ();\n-  func_params = tree_cons (NULL_TREE, TREE_VALUE (objc_eval_once),\n-\t\t\t   NULL_TREE);\n+  /* Build the mutex unlock.  */\n+  args = tree_cons (NULL, mutex, NULL);\n+  call = build_function_call (objc_sync_exit_decl, args);\n+  annotate_with_locus (call, input_location);\n \n-  assemble_external (objc_sync_exit_decl);\n-  c_expand_expr_stmt (build_function_call (objc_sync_exit_decl,\n-\t\t\t\t\t   func_params));\n-  objc_build_try_catch_finally_stmt (0, 1);\n-\n-  return objc_exit_block ();\n+  /* Put the that and the body in a TRY_FINALLY.  */\n+  objc_begin_try_stmt (start_locus, body);\n+  objc_build_finally_clause (input_location, call);\n+  objc_finish_try_stmt ();\n }\n \n+\f\n /* Predefine the following data type:\n \n    struct _objc_exception_data\n@@ -3259,7 +3249,7 @@ objc_build_synchronized_epilogue (void)\n #endif\n \n static void\n-build_objc_exception_stuff (void)\n+build_next_objc_exception_stuff (void)\n {\n   tree field_decl, field_decl_chain, index, temp_type;\n \n@@ -3270,6 +3260,7 @@ build_objc_exception_stuff (void)\n \n   write_symbols = NO_DEBUG;\n   debug_hooks = &do_nothing_debug_hooks;\n+\n   objc_exception_data_template\n     = start_struct (RECORD_TYPE, get_identifier (UTAG_EXCDATA));\n \n@@ -3317,20 +3308,7 @@ build_objc_exception_stuff (void)\n     = builtin_function (TAG_EXCEPTIONTRYENTER, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n   objc_exception_try_exit_decl\n     = builtin_function (TAG_EXCEPTIONTRYEXIT, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  /* void objc_exception_throw(id) __attribute__((noreturn)); */\n-  /* void objc_sync_enter(id); */\n-  /* void objc_sync_exit(id); */\n-  temp_type = build_function_type (void_type_node,\n-\t\t\t\t   tree_cons (NULL_TREE, id_type,\n-\t\t\t\t\t      void_list_node));\n-  objc_exception_throw_decl\n-    = builtin_function (TAG_EXCEPTIONTHROW, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_ATTRIBUTES (objc_exception_throw_decl)\n-    = tree_cons (get_identifier (\"noreturn\"), NULL_TREE, NULL_TREE);\n-  objc_sync_enter_decl\n-    = builtin_function (TAG_SYNCENTER, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  objc_sync_exit_decl\n-    = builtin_function (TAG_SYNCEXIT, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n+\n   /* int objc_exception_match(id, id); */\n   temp_type = build_function_type (integer_type_node,\n \t\t\t\t   tree_cons (NULL_TREE, id_type,\n@@ -3343,6 +3321,32 @@ build_objc_exception_stuff (void)\n   debug_hooks = save_hooks;\n }\n \n+static void\n+build_objc_exception_stuff (void)\n+{\n+  tree noreturn_list, nothrow_list, temp_type;\n+\n+  noreturn_list = tree_cons (get_identifier (\"noreturn\"), NULL, NULL);\n+  nothrow_list = tree_cons (get_identifier (\"nothrow\"), NULL, NULL);\n+\n+  /* void objc_exception_throw(id) __attribute__((noreturn)); */\n+  /* void objc_sync_enter(id); */\n+  /* void objc_sync_exit(id); */\n+  temp_type = build_function_type (void_type_node,\n+\t\t\t\t   tree_cons (NULL_TREE, id_type,\n+\t\t\t\t\t      void_list_node));\n+  objc_exception_throw_decl\n+    = builtin_function (TAG_EXCEPTIONTHROW, temp_type, 0, NOT_BUILT_IN, NULL,\n+\t\t\tnoreturn_list);\n+  objc_sync_enter_decl\n+    = builtin_function (TAG_SYNCENTER, temp_type, 0, NOT_BUILT_IN,\n+\t\t\tNULL, nothrow_list);\n+  objc_sync_exit_decl\n+    = builtin_function (TAG_SYNCEXIT, temp_type, 0, NOT_BUILT_IN,\n+\t\t\tNULL, nothrow_list);\n+}\n+\n+\n /* struct <classname> {\n      struct objc_class *isa;\n      ..."}, {"sha": "8794aa432524e9fe471d28a2830e368f5e6fff43", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -39,16 +39,13 @@ void finish_method_def (void);\n tree start_protocol (enum tree_code, tree, tree);\n void finish_protocol (tree);\n \n-tree objc_build_throw_stmt (tree);\n-tree objc_build_try_catch_finally_stmt (int, int);\n-void objc_build_synchronized_prologue (tree);\n-tree objc_build_synchronized_epilogue (void);\n-tree objc_build_try_prologue (void);\n-void objc_build_try_epilogue (int);\n-void objc_build_catch_stmt (tree);\n-void objc_build_catch_epilogue (void);\n-tree objc_build_finally_prologue (void);\n-tree objc_build_finally_epilogue (void);\n+void objc_build_throw_stmt (tree);\n+void objc_begin_try_stmt (location_t, tree);\n+void objc_begin_catch_clause (tree);\n+void objc_finish_catch_clause (void);\n+void objc_build_finally_clause (location_t, tree);\n+void objc_finish_try_stmt (void);\n+void objc_build_synchronized (location_t, tree, tree);\n \n tree is_ivar (tree, tree);\n int is_private (tree);\n@@ -282,7 +279,6 @@ enum objc_tree_index\n     OCTI_LOCAL_EXCEPTION_DECL,\n     OCTI_RETHROW_EXCEPTION_DECL,\n     OCTI_EVAL_ONCE_DECL,\n-    OCTI_EXCEPTION_BLK_STACK,\n     OCTI_CATCH_TYPE,\n \n     OCTI_MAX\n@@ -402,8 +398,6 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n #define objc_caught_exception\tobjc_global_trees[OCTI_LOCAL_EXCEPTION_DECL]\t\n #define objc_rethrow_exception\tobjc_global_trees[OCTI_RETHROW_EXCEPTION_DECL]\t\n #define objc_eval_once\t\tobjc_global_trees[OCTI_EVAL_ONCE_DECL]\t\n-#define objc_exception_block_stack\t\t\\\n-\t\t\t\tobjc_global_trees[OCTI_EXCEPTION_BLK_STACK]\n #define objc_catch_type\t\tobjc_global_trees[OCTI_CATCH_TYPE]\n \n #define objc_method_template\tobjc_global_trees[OCTI_METH_TEMPL]"}, {"sha": "c2bbd33d1520d152ea394c9a303d9f82a80bce1b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -1,3 +1,12 @@\n+2004-06-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* objc.dg/sync-1.m: New.\n+\t* objc.dg/try-catch-1.m: Don't force next runtime.\n+\t* objc.dg/try-catch-3.m, objc.dg/try-catch-4.m: Likewise.\n+\t* objc.dg/try-catch-2.m: Likewise.  Enable everywhere.  Remove\n+\tshadowed catch clause.\n+\t* objc.dg/try-catch-5.m: New.\n+\n 2004-06-17  Zack Weinberg  <zack@codesourcery.com>\n \n \tBug 14610"}, {"sha": "d7035c715b50293f1f9b807acc09588dc2b35640", "filename": "gcc/testsuite/objc.dg/sync-1.m", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Fsync-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Fsync-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fsync-1.m?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -0,0 +1,12 @@\n+/* Make sure that @synchronized parses.  */\n+/* { dg-options \"-fnext-runtime -fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+#include <objc/Object.h>\n+\n+void foo(id sem)\n+{\n+  @synchronized (sem) { \n+    return;\n+  }\n+}"}, {"sha": "c47e41c96015617970c8fad03ecb8ab8bf3c8f11", "filename": "gcc/testsuite/objc.dg/try-catch-1.m", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-1.m?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -1,8 +1,6 @@\n-/* Test if the compiler accepts @throw / @try..@catch..@finally \n-   syntax.  This will only be usable on MacOS X 10.3 and later,\n-   but may be compiled on all targets.  */\n+/* Test if the compiler accepts @throw / @try..@catch..@finally syntax.  */\n /* Developed by Ziemowit Laski <zlaski@apple.com>.  */\n-/* { dg-options \"-fnext-runtime -fobjc-exceptions\" } */\n+/* { dg-options \"-fobjc-exceptions\" } */\n /* { dg-do compile } */\n \n #include <objc/Object.h>"}, {"sha": "b2550da11480f00d57964af89382f58d73822ac5", "filename": "gcc/testsuite/objc.dg/try-catch-2.m", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-2.m?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -2,11 +2,9 @@\n    all uncaught exceptions.  */\n /* Developed by Ziemowit Laski <zlaski@apple.com>.  */\n \n-/* { dg-options \"-fobjc-exceptions -lobjc\" } */\n-/* { dg-do run { target *-*-darwin* } } */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do run } */\n \n-#include <objc/objc.h>\n-#include <objc/objc-runtime.h>\n #include <objc/Object.h>\n #include <stdio.h>\n \n@@ -72,10 +70,6 @@ void test (Object* sendPort)\n \t\tCHECK_IF(!sendPort);\n \t\tCHECK_IF(!cleanupPorts);\n \t}\n-        @catch(Object *obj) { /* { dg-warning \"Exception already handled by preceding .\\\\@catch\\\\(id\\\\).\" } */\n-                printf (\"Exception caught by incorrect handler!\\n\");\n-                CHECK_IF(0);\n-        }\n }\n \n int main (void) {"}, {"sha": "af2829e2c2facea36a4f9482f2d7406c8b1c2bb3", "filename": "gcc/testsuite/objc.dg/try-catch-3.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-3.m?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -3,7 +3,7 @@\n /* Author: Ziemowit Laski <zlaski@apple.com> */\n \n /* { dg-do compile } */\n-/* { dg-options \"-fnext-runtime -fobjc-exceptions\" } */\n+/* { dg-options \"-fobjc-exceptions\" } */\n \n #include <objc/Object.h>\n "}, {"sha": "dedcc4ec4f7d0690a0a9edfb7f7b38fd121a18c5", "filename": "gcc/testsuite/objc.dg/try-catch-4.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-4.m?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -3,7 +3,7 @@\n /* Author: Ziemowit Laski <zlaski@apple.com> */\n \n /* { dg-do compile } */\n-/* { dg-options \"-Wall -fnext-runtime -fobjc-exceptions\" } */\n+/* { dg-options \"-Wall -fobjc-exceptions\" } */\n \n @interface Exception\n @end"}, {"sha": "f833bc2c74904dbce3906b4fbcb0dd7f317204a4", "filename": "gcc/testsuite/objc.dg/try-catch-5.m", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftry-catch-5.m?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -0,0 +1,27 @@\n+/* Check that the compiler does correctly complain about\n+   exceptions being caught by previous @catch blocks.  */\n+/* Force the use of NeXT runtime to see that we don't ICE after\n+   generating the warning message.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -fnext-runtime -fobjc-exceptions\" } */\n+\n+@interface Exception\n+@end\n+\n+@interface FooException : Exception\n+@end\n+\n+extern void foo();\n+\n+void test()\n+{\n+    @try {\n+        foo();\n+    }\n+    @catch (Exception* e) {\t/* { dg-warning \"earlier handler\" } */\n+    }\n+    @catch (FooException* fe) {\t/* { dg-warning \"will be caught\" } */\n+    }\n+}\n+"}]}