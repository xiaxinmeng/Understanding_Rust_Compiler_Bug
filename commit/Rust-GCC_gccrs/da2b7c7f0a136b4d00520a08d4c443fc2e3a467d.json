{"sha": "da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEyYjdjN2YwYTEzNmI0ZDAwNTIwYTA4ZDRjNDQzZmMyZTNhNDY3ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-03-25T13:42:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-18T10:05:37Z"}, "message": "remove SLP_TREE_TWO_OPERATORS, add SLP permutation node\n\nThis removes the SLP_TREE_TWO_OPERATORS hack in favor of having\nexplicit SLP nodes for both computations and the blend operation.\nFor this introduce a generic merge + select + permute SLP node\n(with implementation limits).\n\nBuilding upon earlier patches it adds vect_stmt_dominates_stmt_p\nand the ability to compute a vector insertion place from\nvectorized stmts (which now have UID zero) as needed for\nthe permute node.\n\n2020-06-17  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::two_operators): Remove.\n\t(_slp_tree::lane_permutation): New member.\n\t(_slp_tree::code): Likewise.\n\t(SLP_TREE_TWO_OPERATORS): Remove.\n\t(SLP_TREE_LANE_PERMUTATION): New.\n\t(SLP_TREE_CODE): Likewise.\n\t(vect_stmt_dominates_stmt_p): Declare.\n\t* tree-vectorizer.c (vect_stmt_dominates_stmt_p): New function.\n\t* tree-vect-stmts.c (vect_model_simple_cost): Remove\n\tSLP_TREE_TWO_OPERATORS handling.\n\t* tree-vect-slp.c (_slp_tree::_slp_tree): Amend.\n\t(_slp_tree::~_slp_tree): Likewise.\n\t(vect_two_operations_perm_ok_p): Remove.\n\t(vect_build_slp_tree_1): Remove verification of two-operator\n\tpermutation here.\n\t(vect_build_slp_tree_2): When we have two different operators\n\tbuild two computation SLP nodes and a blend.\n\t(vect_print_slp_tree): Print the lane permutation if it exists.\n\t(slp_copy_subtree): Copy it.\n\t(vect_slp_rearrange_stmts): Re-arrange it.\n\t(vect_slp_analyze_node_operations_1): Handle SLP_TREE_CODE\n\tVEC_PERM_EXPR explicitely.\n\t(vect_schedule_slp_instance): Likewise.  Remove old\n\tSLP_TREE_TWO_OPERATORS code.\n\t(vectorizable_slp_permutation): New function.", "tree": {"sha": "93af9b90f477e9e91da6c5a873dc5286340212bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93af9b90f477e9e91da6c5a873dc5286340212bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab42c70a62fe10f40a623adf48002ac8cdb9bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab42c70a62fe10f40a623adf48002ac8cdb9bf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab42c70a62fe10f40a623adf48002ac8cdb9bf8"}], "stats": {"total": 520, "additions": 378, "deletions": 142}, "files": [{"sha": "e33b42fbc681a21255e1ecbab1b306dfc7d7085d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 312, "deletions": 130, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "patch": "@@ -47,6 +47,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dump-context.h\"\n \n \n+static bool vectorizable_slp_permutation (vec_info *, gimple_stmt_iterator *,\n+\t\t\t\t\t  slp_tree, stmt_vector_for_cost *);\n+\n /* Initialize a SLP node.  */\n \n _slp_tree::_slp_tree ()\n@@ -58,8 +61,9 @@ _slp_tree::_slp_tree ()\n   SLP_TREE_NUMBER_OF_VEC_STMTS (this) = 0;\n   SLP_TREE_CHILDREN (this) = vNULL;\n   SLP_TREE_LOAD_PERMUTATION (this) = vNULL;\n-  SLP_TREE_TWO_OPERATORS (this) = false;\n+  SLP_TREE_LANE_PERMUTATION (this) = vNULL;\n   SLP_TREE_DEF_TYPE (this) = vect_uninitialized_def;\n+  SLP_TREE_CODE (this) = ERROR_MARK;\n   SLP_TREE_VECTYPE (this) = NULL_TREE;\n   SLP_TREE_REPRESENTATIVE (this) = NULL;\n   this->refcnt = 1;\n@@ -77,6 +81,7 @@ _slp_tree::~_slp_tree ()\n   SLP_TREE_VEC_STMTS (this).release ();\n   SLP_TREE_VEC_DEFS (this).release ();\n   SLP_TREE_LOAD_PERMUTATION (this).release ();\n+  SLP_TREE_LANE_PERMUTATION (this).release ();\n }\n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.\n@@ -697,35 +702,6 @@ vect_record_max_nunits (vec_info *vinfo, stmt_vec_info stmt_info,\n   return true;\n }\n \n-/* STMTS is a group of GROUP_SIZE SLP statements in which some\n-   statements do the same operation as the first statement and in which\n-   the others do ALT_STMT_CODE.  Return true if we can take one vector\n-   of the first operation and one vector of the second and permute them\n-   to get the required result.  VECTYPE is the type of the vector that\n-   would be permuted.  */\n-\n-static bool\n-vect_two_operations_perm_ok_p (vec<stmt_vec_info> stmts,\n-\t\t\t       unsigned int group_size, tree vectype,\n-\t\t\t       tree_code alt_stmt_code)\n-{\n-  unsigned HOST_WIDE_INT count;\n-  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&count))\n-    return false;\n-\n-  vec_perm_builder sel (count, count, 1);\n-  for (unsigned int i = 0; i < count; ++i)\n-    {\n-      unsigned int elt = i;\n-      gassign *stmt = as_a <gassign *> (stmts[i % group_size]->stmt);\n-      if (gimple_assign_rhs_code (stmt) == alt_stmt_code)\n-\telt += count;\n-      sel.quick_push (elt);\n-    }\n-  vec_perm_indices indices (sel, 2, count);\n-  return can_vec_perm_const_p (TYPE_MODE (vectype), indices);\n-}\n-\n /* Verify if the scalar stmts STMTS are isomorphic, require data\n    permutation or are of unsupported types of operation.  Return\n    true if they are, otherwise return false and indicate in *MATCHES\n@@ -1089,24 +1065,6 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   if (alt_stmt_code != ERROR_MARK\n       && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n     {\n-      if (!vect_two_operations_perm_ok_p (stmts, group_size,\n-\t\t\t\t\t  vectype, alt_stmt_code))\n-\t{\n-\t  for (i = 0; i < group_size; ++i)\n-\t    if (gimple_assign_rhs_code (stmts[i]->stmt) == alt_stmt_code)\n-\t      {\n-\t\tmatches[i] = false;\n-\t\tif (dump_enabled_p ())\n-\t\t  {\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"Build SLP failed: different operation \"\n-\t\t\t\t     \"in stmt %G\", stmts[i]->stmt);\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"original stmt %G\", first_stmt_info->stmt);\n-\t\t  }\n-\t      }\n-\t  return false;\n-\t}\n       *two_operators = true;\n     }\n \n@@ -1512,8 +1470,59 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   *tree_size += this_tree_size + 1;\n   *max_nunits = this_max_nunits;\n \n+  if (two_operators)\n+    {\n+      /* ???  We'd likely want to either cache in bst_map sth like\n+\t { a+b, NULL, a+b, NULL } and { NULL, a-b, NULL, a-b } or\n+\t the true { a+b, a+b, a+b, a+b } ... but there we don't have\n+\t explicit stmts to put in so the keying on 'stmts' doesn't\n+\t work (but we have the same issue with nodes that use 'ops').  */\n+      slp_tree one = new _slp_tree;\n+      slp_tree two = new _slp_tree;\n+      SLP_TREE_DEF_TYPE (one) = vect_internal_def;\n+      SLP_TREE_DEF_TYPE (two) = vect_internal_def;\n+      SLP_TREE_VECTYPE (one) = vectype;\n+      SLP_TREE_VECTYPE (two) = vectype;\n+      SLP_TREE_CHILDREN (one).safe_splice (children);\n+      SLP_TREE_CHILDREN (two).safe_splice (children);\n+      slp_tree child;\n+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (two), i, child)\n+\tchild->refcnt++;\n+\n+      /* Here we record the original defs since this\n+\t node represents the final lane configuration.  */\n+      node = vect_create_new_slp_node (stmts, 2);\n+      SLP_TREE_VECTYPE (node) = vectype;\n+      SLP_TREE_CODE (node) = VEC_PERM_EXPR;\n+      SLP_TREE_CHILDREN (node).quick_push (one);\n+      SLP_TREE_CHILDREN (node).quick_push (two);\n+      gassign *stmt = as_a <gassign *> (stmts[0]->stmt);\n+      enum tree_code code0 = gimple_assign_rhs_code (stmt);\n+      enum tree_code ocode = ERROR_MARK;\n+      stmt_vec_info ostmt_info;\n+      unsigned j = 0;\n+      FOR_EACH_VEC_ELT (stmts, i, ostmt_info)\n+\t{\n+\t  gassign *ostmt = as_a <gassign *> (ostmt_info->stmt);\n+\t  if (gimple_assign_rhs_code (ostmt) != code0)\n+\t    {\n+\t      SLP_TREE_LANE_PERMUTATION (node).safe_push (std::make_pair (1, i));\n+\t      ocode = gimple_assign_rhs_code (ostmt);\n+\t      j = i;\n+\t    }\n+\t  else\n+\t    SLP_TREE_LANE_PERMUTATION (node).safe_push (std::make_pair (0, i));\n+\t}\n+      SLP_TREE_CODE (one) = code0;\n+      SLP_TREE_CODE (two) = ocode;\n+      SLP_TREE_LANES (one) = stmts.length ();\n+      SLP_TREE_LANES (two) = stmts.length ();\n+      SLP_TREE_REPRESENTATIVE (one) = stmts[0];\n+      SLP_TREE_REPRESENTATIVE (two) = stmts[j];\n+      return node;\n+    }\n+\n   node = vect_create_new_slp_node (stmts, nops);\n-  SLP_TREE_TWO_OPERATORS (node) = two_operators;\n   SLP_TREE_VECTYPE (node) = vectype;\n   SLP_TREE_CHILDREN (node).splice (children);\n   return node;\n@@ -1557,6 +1566,15 @@ vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n \tdump_printf (dump_kind, \" %u\", j);\n       dump_printf (dump_kind, \" }\\n\");\n     }\n+  if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n+    {\n+      dump_printf_loc (metadata, user_loc, \"\\tlane permutation {\");\n+      for (i = 0; i < SLP_TREE_LANE_PERMUTATION (node).length (); ++i)\n+\tdump_printf (dump_kind, \" %u[%u]\",\n+\t\t     SLP_TREE_LANE_PERMUTATION (node)[i].first,\n+\t\t     SLP_TREE_LANE_PERMUTATION (node)[i].second);\n+      dump_printf (dump_kind, \" }\\n\");\n+    }\n   if (SLP_TREE_CHILDREN (node).is_empty ())\n     return;\n   dump_printf_loc (metadata, user_loc, \"\\tchildren\");\n@@ -1693,6 +1711,8 @@ slp_copy_subtree (slp_tree node, hash_map<slp_tree, slp_tree> &map)\n     SLP_TREE_SCALAR_OPS (copy) = SLP_TREE_SCALAR_OPS (node).copy ();\n   if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n     SLP_TREE_LOAD_PERMUTATION (copy) = SLP_TREE_LOAD_PERMUTATION (node).copy ();\n+  if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n+    SLP_TREE_LANE_PERMUTATION (copy) = SLP_TREE_LANE_PERMUTATION (node).copy ();\n   if (SLP_TREE_CHILDREN (node).exists ())\n     SLP_TREE_CHILDREN (copy) = SLP_TREE_CHILDREN (node).copy ();\n   gcc_assert (!SLP_TREE_VEC_STMTS (node).exists ());\n@@ -1746,6 +1766,13 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n       SLP_TREE_SCALAR_OPS (node).release ();\n       SLP_TREE_SCALAR_OPS (node) = tmp_ops;\n     }\n+  if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n+    {\n+      gcc_assert (group_size == SLP_TREE_LANE_PERMUTATION (node).length ());\n+      for (i = 0; i < group_size; ++i)\n+\tSLP_TREE_LANE_PERMUTATION (node)[i].second\n+\t  = permutation[SLP_TREE_LANE_PERMUTATION (node)[i].second];\n+    }\n }\n \n \n@@ -2632,6 +2659,10 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n \t= vect_get_num_vectors (vf * group_size, vectype);\n     }\n \n+  /* Handle purely internal nodes.  */\n+  if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n+    return vectorizable_slp_permutation (vinfo, NULL, node, cost_vec);\n+\n   bool dummy;\n   return vect_analyze_stmt (vinfo, stmt_info, &dummy,\n \t\t\t    node, node_instance, cost_vec);\n@@ -3933,6 +3964,197 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n   return true;\n }\n \n+\n+/* Vectorize the SLP permutations in NODE as specified\n+   in SLP_TREE_LANE_PERMUTATION which is a vector of pairs of SLP\n+   child number and lane number.\n+   Interleaving of two two-lane two-child SLP subtrees (not supported):\n+     [ { 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 } ]\n+   A blend of two four-lane two-child SLP subtrees:\n+     [ { 0, 0 }, { 1, 1 }, { 0, 2 }, { 1, 3 } ]\n+   Highpart of a four-lane one-child SLP subtree (not supported):\n+     [ { 0, 2 }, { 0, 3 } ]\n+   Where currently only a subset is supported by code generating below.  */\n+\n+static bool\n+vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n+\t\t\t      slp_tree node, stmt_vector_for_cost *cost_vec)\n+{\n+  tree vectype = SLP_TREE_VECTYPE (node);\n+\n+  /* ???  We currently only support all same vector input and output types\n+     while the SLP IL should really do a concat + select and thus accept\n+     arbitrary mismatches.  */\n+  slp_tree child;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (!types_compatible_p (SLP_TREE_VECTYPE (child), vectype))\n+      {\n+\tif (dump_enabled_p ())\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"Unsupported lane permutation\\n\");\n+\treturn false;\n+      }\n+\n+  vec<std::pair<unsigned, unsigned> > &perm = SLP_TREE_LANE_PERMUTATION (node);\n+  gcc_assert (perm.length () == SLP_TREE_LANES (node));\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"vectorizing permutation\");\n+      for (unsigned i = 0; i < perm.length (); ++i)\n+\tdump_printf (MSG_NOTE, \" op%u[%u]\", perm[i].first, perm[i].second);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  if (!nunits.is_constant ())\n+    return false;\n+  unsigned HOST_WIDE_INT vf = 1;\n+  if (loop_vec_info linfo = dyn_cast <loop_vec_info> (vinfo))\n+    if (!LOOP_VINFO_VECT_FACTOR (linfo).is_constant (&vf))\n+      return false;\n+  unsigned olanes = vf * SLP_TREE_LANES (node);\n+  gcc_assert (multiple_p (olanes, nunits));\n+\n+  /* Compute the { { SLP operand, vector index}, lane } permutation sequence\n+     from the { SLP operand, scalar lane } permutation as recorded in the\n+     SLP node as intermediate step.  This part should already work\n+     with SLP children with arbitrary number of lanes.  */\n+  auto_vec<std::pair<std::pair<unsigned, unsigned>, unsigned> > vperm;\n+  auto_vec<unsigned> active_lane;\n+  vperm.create (olanes);\n+  active_lane.safe_grow_cleared (SLP_TREE_CHILDREN (node).length ());\n+  for (unsigned i = 0; i < vf; ++i)\n+    {\n+      for (unsigned pi = 0; pi < perm.length (); ++pi)\n+\t{\n+\t  std::pair<unsigned, unsigned> p = perm[pi];\n+\t  tree vtype = SLP_TREE_VECTYPE (SLP_TREE_CHILDREN (node)[p.first]);\n+\t  unsigned vnunits = TYPE_VECTOR_SUBPARTS (vtype).to_constant ();\n+\t  unsigned vi = (active_lane[p.first] + p.second) / vnunits;\n+\t  unsigned vl = (active_lane[p.first] + p.second) % vnunits;\n+\t  vperm.quick_push (std::make_pair (std::make_pair (p.first, vi), vl));\n+\t}\n+      /* Advance to the next group.  */\n+      for (unsigned j = 0; j < SLP_TREE_CHILDREN (node).length (); ++j)\n+\tactive_lane[j] += SLP_TREE_LANES (SLP_TREE_CHILDREN (node)[j]);\n+    }\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"as\");\n+      for (unsigned i = 0; i < vperm.length (); ++i)\n+\t{\n+\t  if (i != 0 && multiple_p (i, TYPE_VECTOR_SUBPARTS (vectype)))\n+\t    dump_printf (MSG_NOTE, \",\");\n+\t  dump_printf (MSG_NOTE, \" vops%u[%u][%u]\",\n+\t\t       vperm[i].first.first, vperm[i].first.second,\n+\t\t       vperm[i].first.second);\n+\t}\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  /* We can only handle two-vector permutes, everything else should\n+     be lowered on the SLP level.  The following is closely inspired\n+     by vect_transform_slp_perm_load and is supposed to eventually\n+     replace it.\n+     ???   As intermediate step do code-gen in the SLP tree representation\n+     somehow?  */\n+  std::pair<unsigned, unsigned> first_vec = std::make_pair (-1U, -1U);\n+  std::pair<unsigned, unsigned> second_vec = std::make_pair (-1U, -1U);\n+  unsigned int const_nunits = nunits.to_constant ();\n+  unsigned int index = 0;\n+  unsigned int mask_element;\n+  vec_perm_builder mask;\n+  mask.new_vector (const_nunits, const_nunits, 1);\n+  unsigned int count = mask.encoded_nelts ();\n+  mask.quick_grow (count);\n+  vec_perm_indices indices;\n+  unsigned nperms = 0;\n+  for (unsigned i = 0; i < vperm.length (); ++i)\n+    {\n+      mask_element = vperm[i].second;\n+      if (first_vec.first == -1U\n+\t  || first_vec == vperm[i].first)\n+\tfirst_vec = vperm[i].first;\n+      else if (second_vec.first == -1U\n+\t       || second_vec == vperm[i].first)\n+\t{\n+\t  second_vec = vperm[i].first;\n+\t  mask_element += const_nunits;\n+\t}\n+      else\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"permutation requires at \"\n+\t\t\t     \"least three vectors\");\n+\t  gcc_assert (!gsi);\n+\t  return false;\n+\t}\n+\n+      mask[index++] = mask_element;\n+\n+      if (index == count)\n+\t{\n+\t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2,\n+\t\t\t      const_nunits);\n+\t  if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t   vect_location,\n+\t\t\t\t   \"unsupported vect permute { \");\n+\t\t  for (i = 0; i < count; ++i)\n+\t\t    {\n+\t\t      dump_dec (MSG_MISSED_OPTIMIZATION, mask[i]);\n+\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" \");\n+\t\t    }\n+\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n+\t\t}\n+\t      gcc_assert (!gsi);\n+\t      return false;\n+\t    }\n+\n+\t  nperms++;\n+\t  if (gsi)\n+\t    {\n+\t      tree mask_vec = vect_gen_perm_mask_checked (vectype, indices);\n+\n+\t      if (second_vec.first == -1U)\n+\t\tsecond_vec = first_vec;\n+\n+\t      /* Generate the permute statement if necessary.  */\n+\t      slp_tree first_node = SLP_TREE_CHILDREN (node)[first_vec.first];\n+\t      tree first_def\n+\t\t= vect_get_slp_vect_def (first_node, first_vec.second);\n+\t      slp_tree second_node = SLP_TREE_CHILDREN (node)[second_vec.first];\n+\t      tree second_def\n+\t\t= vect_get_slp_vect_def (second_node, second_vec.second);\n+\t      tree perm_dest = make_ssa_name (vectype);\n+\t      gassign *perm_stmt\n+\t\t= gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n+\t\t\t\t       first_def, second_def,\n+\t\t\t\t       mask_vec);\n+\t      vect_finish_stmt_generation (vinfo, NULL, perm_stmt, gsi);\n+\t      /* Store the vector statement in NODE.  */\n+\t      SLP_TREE_VEC_STMTS (node).quick_push (perm_stmt);\n+\t    }\n+\n+\t  index = 0;\n+\t  first_vec = std::make_pair (-1U, -1U);\n+\t  second_vec = std::make_pair (-1U, -1U);\n+\t}\n+    }\n+\n+  if (!gsi)\n+    record_stmt_cost (cost_vec, nperms, vec_perm, NULL, vectype, 0, vect_body);\n+\n+  return true;\n+}\n+\n /* Vectorize SLP instance tree in postorder.  */\n \n static void\n@@ -3967,16 +4189,10 @@ vect_schedule_slp_instance (vec_info *vinfo,\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_schedule_slp_instance (vinfo, child, instance);\n \n-  stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n-\n-  /* VECTYPE is the type of the destination.  */\n-  tree vectype = SLP_TREE_VECTYPE (node);\n-  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n-\n   gcc_assert (SLP_TREE_NUMBER_OF_VEC_STMTS (node) != 0);\n   SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n \n+  stmt_vec_info stmt_info = SLP_TREE_REPRESENTATIVE (node);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"------>vectorizing SLP node starting from: %G\",\n@@ -3985,84 +4201,50 @@ vect_schedule_slp_instance (vec_info *vinfo,\n   /* Vectorized stmts go before the last scalar stmt which is where\n      all uses are ready.  */\n   stmt_vec_info last_stmt_info = vect_find_last_scalar_stmt_in_slp (node);\n-  si = gsi_for_stmt (last_stmt_info->stmt);\n-\n-  /* Handle two-operation SLP nodes by vectorizing the group with\n-     both operations and then performing a merge.  */\n-  bool done_p = false;\n-  if (SLP_TREE_TWO_OPERATORS (node))\n+  if (last_stmt_info)\n+    si = gsi_for_stmt (last_stmt_info->stmt);\n+  else\n     {\n-      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n-      enum tree_code code0 = gimple_assign_rhs_code (stmt);\n-      enum tree_code ocode = ERROR_MARK;\n-      stmt_vec_info ostmt_info;\n-      vec_perm_builder mask (group_size, group_size, 1);\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, ostmt_info)\n-\t{\n-\t  gassign *ostmt = as_a <gassign *> (ostmt_info->stmt);\n-\t  if (gimple_assign_rhs_code (ostmt) != code0)\n-\t    {\n-\t      mask.quick_push (1);\n-\t      ocode = gimple_assign_rhs_code (ostmt);\n-\t    }\n-\t  else\n-\t    mask.quick_push (0);\n-\t}\n-      if (ocode != ERROR_MARK)\n+      /* Or if we do not have 1:1 matching scalar stmts emit after the\n+\t children vectorized defs.  */\n+      gimple *last_in_child;\n+      gimple *last_stmt = NULL;\n+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+\t/* ???  With only external defs the following breaks.  Note\n+\t   external defs do not get all vector init stmts generated\n+\t   at the same place.  */\n+\tif (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+\t  {\n+\t    /* We are emitting all vectorized stmts in the same place and\n+\t       the last one is the last.  */\n+\t    last_in_child = SLP_TREE_VEC_STMTS (child).last ();\n+\t    if (!last_stmt\n+\t\t|| vect_stmt_dominates_stmt_p (last_stmt, last_in_child))\n+\t      last_stmt = last_in_child;\n+\t  }\n+      if (is_a <gphi *> (last_stmt))\n+\tsi = gsi_after_labels (gimple_bb (last_stmt));\n+      else\n \t{\n-\t  vec<gimple *> v0;\n-\t  vec<gimple *> v1;\n-\t  unsigned j;\n-\t  tree tmask = NULL_TREE;\n-\t  vect_transform_stmt (vinfo, stmt_info, &si, node, instance);\n-\t  v0 = SLP_TREE_VEC_STMTS (node).copy ();\n-\t  SLP_TREE_VEC_STMTS (node).truncate (0);\n-\t  gimple_assign_set_rhs_code (stmt, ocode);\n-\t  vect_transform_stmt (vinfo, stmt_info, &si, node, instance);\n-\t  gimple_assign_set_rhs_code (stmt, code0);\n-\t  v1 = SLP_TREE_VEC_STMTS (node).copy ();\n-\t  SLP_TREE_VEC_STMTS (node).truncate (0);\n-\t  tree meltype = build_nonstandard_integer_type\n-\t      (GET_MODE_BITSIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype))), 1);\n-\t  tree mvectype = get_same_sized_vectype (meltype, vectype);\n-\t  unsigned k = 0, l;\n-\t  for (j = 0; j < v0.length (); ++j)\n-\t    {\n-\t      /* Enforced by vect_build_slp_tree, which rejects variable-length\n-\t\t vectors for SLP_TREE_TWO_OPERATORS.  */\n-\t      unsigned int const_nunits = nunits.to_constant ();\n-\t      tree_vector_builder melts (mvectype, const_nunits, 1);\n-\t      for (l = 0; l < const_nunits; ++l)\n-\t\t{\n-\t\t  if (k >= group_size)\n-\t\t    k = 0;\n-\t\t  tree t = build_int_cst (meltype,\n-\t\t\t\t\t  mask[k++] * const_nunits + l);\n-\t\t  melts.quick_push (t);\n-\t\t}\n-\t      tmask = melts.build ();\n-\n-\t      /* ???  Not all targets support a VEC_PERM_EXPR with a\n-\t         constant mask that would translate to a vec_merge RTX\n-\t\t (with their vec_perm_const_ok).  We can either not\n-\t\t vectorize in that case or let veclower do its job.\n-\t\t Unfortunately that isn't too great and at least for\n-\t\t plus/minus we'd eventually like to match targets\n-\t\t vector addsub instructions.  */\n-\t      gimple *vstmt;\n-\t      vstmt = gimple_build_assign (make_ssa_name (vectype),\n-\t\t\t\t\t   VEC_PERM_EXPR,\n-\t\t\t\t\t   gimple_assign_lhs (v0[j]),\n-\t\t\t\t\t   gimple_assign_lhs (v1[j]),\n-\t\t\t\t\t   tmask);\n-\t      vect_finish_stmt_generation (vinfo, stmt_info, vstmt, &si);\n-\t      SLP_TREE_VEC_STMTS (node).quick_push (vstmt);\n-\t    }\n-\t  v0.release ();\n-\t  v1.release ();\n-\t  done_p = true;\n+\t  si = gsi_for_stmt (last_stmt);\n+\t  gsi_next (&si);\n \t}\n     }\n+\n+  bool done_p = false;\n+\n+  /* Handle purely internal nodes.  */\n+  if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n+    {\n+      /* ???  the transform kind is stored to STMT_VINFO_TYPE which might\n+\t be shared with different SLP nodes (but usually it's the same\n+\t operation apart from the case the stmt is only there for denoting\n+\t the actual scalar lane defs ...).  So do not call vect_transform_stmt\n+\t but open-code it here (partly).  */\n+      bool done = vectorizable_slp_permutation (vinfo, &si, node, NULL);\n+      gcc_assert (done);\n+      done_p = true;\n+    }\n   if (!done_p)\n     vect_transform_stmt (vinfo, stmt_info, &si, node, instance);\n }"}, {"sha": "23799f0ac187a65d548e6539bd8ab67e0245a8c6", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "patch": "@@ -820,14 +820,6 @@ vect_model_simple_cost (vec_info *,\n \tprologue_cost += record_stmt_cost (cost_vec, 1, scalar_to_vec,\n \t\t\t\t\t   stmt_info, 0, vect_prologue);\n \n-  /* Adjust for two-operator SLP nodes.  */\n-  if (node && SLP_TREE_TWO_OPERATORS (node))\n-    {\n-      ncopies *= 2;\n-      inside_cost += record_stmt_cost (cost_vec, ncopies, vec_perm,\n-\t\t\t\t       stmt_info, 0, vect_body);\n-    }\n-\n   /* Pass the inside-of-loop statements to the target-specific cost model.  */\n   inside_cost += record_stmt_cost (cost_vec, ncopies, kind,\n \t\t\t\t   stmt_info, 0, vect_body);"}, {"sha": "e262ba0580e707aec44eb9181a54ed8ab9119f4f", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "patch": "@@ -711,6 +711,63 @@ vec_info::free_stmt_vec_info (stmt_vec_info stmt_info)\n   free (stmt_info);\n }\n \n+/* Returns true if S1 dominates S2.  */\n+\n+bool\n+vect_stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n+{\n+  basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);\n+\n+  /* If bb1 is NULL, it should be a GIMPLE_NOP def stmt of an (D)\n+     SSA_NAME.  Assume it lives at the beginning of function and\n+     thus dominates everything.  */\n+  if (!bb1 || s1 == s2)\n+    return true;\n+\n+  /* If bb2 is NULL, it doesn't dominate any stmt with a bb.  */\n+  if (!bb2)\n+    return false;\n+\n+  if (bb1 != bb2)\n+    return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n+\n+  /* PHIs in the same basic block are assumed to be\n+     executed all in parallel, if only one stmt is a PHI,\n+     it dominates the other stmt in the same basic block.  */\n+  if (gimple_code (s1) == GIMPLE_PHI)\n+    return true;\n+\n+  if (gimple_code (s2) == GIMPLE_PHI)\n+    return false;\n+\n+  /* Inserted vectorized stmts all have UID 0 while the original stmts\n+     in the IL have UID increasing within a BB.  Walk from both sides\n+     until we find the other stmt or a stmt with UID != 0.  */\n+  gimple_stmt_iterator gsi1 = gsi_for_stmt (s1);\n+  while (gimple_uid (gsi_stmt (gsi1)) == 0)\n+    {\n+      gsi_next (&gsi1);\n+      if (gsi_end_p (gsi1))\n+\treturn false;\n+      if (gsi_stmt (gsi1) == s2)\n+\treturn true;\n+    }\n+\n+  gimple_stmt_iterator gsi2 = gsi_for_stmt (s2);\n+  while (gimple_uid (gsi_stmt (gsi2)) == 0)\n+    {\n+      gsi_prev (&gsi2);\n+      if (gsi_end_p (gsi2))\n+\treturn false;\n+      if (gsi_stmt (gsi2) == s1)\n+\treturn true;\n+    }\n+\n+  if (gimple_uid (gsi_stmt (gsi1)) <= gimple_uid (gsi_stmt (gsi2)))\n+    return true;\n+  return false;\n+}\n+\n /* A helper function to free scev and LOOP niter information, as well as\n    clear loop constraint LOOP_C_FINITE.  */\n "}, {"sha": "a2009913d804a02cc15a8976728b12751d0d62c8", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2b7c7f0a136b4d00520a08d4c443fc2e3a467d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=da2b7c7f0a136b4d00520a08d4c443fc2e3a467d", "patch": "@@ -135,6 +135,10 @@ struct _slp_tree {\n   /* Load permutation relative to the stores, NULL if there is no\n      permutation.  */\n   vec<unsigned> load_permutation;\n+  /* Lane permutation of the operands scalar lanes encoded as pairs\n+     of { operand number, lane number }.  The number of elements\n+     denotes the number of output lanes.  */\n+  vec<std::pair<unsigned, unsigned> > lane_permutation;\n \n   tree vectype;\n   /* Vectorized stmt/s.  */\n@@ -151,12 +155,12 @@ struct _slp_tree {\n   /* The maximum number of vector elements for the subtree rooted\n      at this node.  */\n   poly_uint64 max_nunits;\n-  /* Whether the scalar computations use two different operators.  */\n-  bool two_operators;\n   /* The DEF type of this node.  */\n   enum vect_def_type def_type;\n   /* The number of scalar lanes produced by this node.  */\n   unsigned int lanes;\n+  /* The operation of this node.  */\n+  enum tree_code code;\n };\n \n \n@@ -195,11 +199,12 @@ typedef class _slp_instance {\n #define SLP_TREE_VEC_DEFS(S)                     (S)->vec_defs\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n-#define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators\n+#define SLP_TREE_LANE_PERMUTATION(S)             (S)->lane_permutation\n #define SLP_TREE_DEF_TYPE(S)\t\t\t (S)->def_type\n #define SLP_TREE_VECTYPE(S)\t\t\t (S)->vectype\n #define SLP_TREE_REPRESENTATIVE(S)\t\t (S)->representative\n #define SLP_TREE_LANES(S)\t\t\t (S)->lanes\n+#define SLP_TREE_CODE(S)\t\t\t (S)->code\n \n /* Key for map that records association between\n    scalar conditions and corresponding loop mask, and\n@@ -1932,6 +1937,6 @@ void vect_pattern_recog (vec_info *);\n unsigned vectorize_loops (void);\n void vect_free_loop_info_assumptions (class loop *);\n gimple *vect_loop_vectorized_call (class loop *, gcond **cond = NULL);\n-\n+bool vect_stmt_dominates_stmt_p (gimple *, gimple *);\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}