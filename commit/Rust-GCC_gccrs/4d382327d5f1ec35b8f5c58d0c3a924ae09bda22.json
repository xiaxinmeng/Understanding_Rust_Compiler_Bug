{"sha": "4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzODIzMjdkNWYxZWMzNWI4ZjVjNThkMGMzYTkyNGFlMDliZGEyMg==", "commit": {"author": {"name": "Alessandro Fanfarillo", "email": "alessandro.fanfarillo@gmail.com", "date": "2012-12-01T08:00:22Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-12-01T08:00:22Z"}, "message": "re PR fortran/46897 ([OOP] type-bound defined ASSIGNMENT(=) not used for derived type component in intrinsic assign)\n\n2012-12-01   Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n             Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/46897\n\t* gfortran.h : Add bit field 'defined_assign_comp' to\n\tsymbol_attribute structure.\n\tAdd primitive for gfc_add_full_array_ref.\n\t* expr.c (gfc_add_full_array_ref): New function.\n\t(gfc_lval_expr_from_sym): Call new function.\n\t* resolve.c (add_comp_ref): New function.\n\t(build_assignment): New function.\n\t(get_temp_from_expr): New function\n\t(add_code_to_chain): New function\n\t(generate_component_assignments): New function that calls all\n\tthe above new functions.\n\t(resolve_code): Call generate_component_assignments.\n\t(check_defined_assignments): New function.\n\t(resolve_fl_derived0): Call check_defined_assignments.\n\t(gfc_resolve): Reset component_assignment_level in case it is\n\tleft in a bad state by errors.\n\n\n\t* resolve.c (is_sym_host_assoc, resolve_procedure_interface,\n\tresolve_contained_fntype, resolve_procedure_expression,\n\tresolve_elemental_actual, resolve_global_procedure,\n\tis_scalar_expr_ptr, gfc_iso_c_func_interface, resolve_function,\n\tset_name_and_label, gfc_iso_c_sub_interface,\n\tresolve_specific_s0, resolve_operator, compare_bound_mpz_t,\n\tgfc_resolve_character_operator, resolve_typebound_function,\n\tgfc_resolve_expr, forall_index, remove_last_array_ref,\n\tconformable_arrays, resolve_allocate_expr,\n\tresolve_allocate_deallocate, resolve_select_type,\n\tresolve_transfer, resolve_where,\n\tgfc_resolve_where_code_in_forall, gfc_resolve_forall_body,\n\tgfc_count_forall_iterators, resolve_values,\n\tresolve_bind_c_comms, resolve_bind_c_derived_types,\n\tgfc_verify_binding_labels, apply_default_init,\n\tbuild_default_init_expr, apply_default_init_local,\n\tresolve_fl_var_and_proc, resolve_fl_procedure,\n\tgfc_resolve_finalizers, check_generic_tbp_ambiguity,\n\tresolve_typebound_intrinsic_op, resolve_typebound_procedure,\n\tresolve_typebound_procedures, ensure_not_abstract,\n\tresolve_fl_derived0, resolve_fl_parameter, resolve_symbol,\n\tresolve_equivalence_derived): Remove trailing white space.\n\t* gfortran.h : Remove trailing white space.\n\n2012-12-01   Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n             Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/46897\n\t* gfortran.dg/defined_assignment_1.f90: New test.\n\t* gfortran.dg/defined_assignment_2.f90: New test.\n\t* gfortran.dg/defined_assignment_3.f90: New test.\n\t* gfortran.dg/defined_assignment_4.f90: New test.\n\t* gfortran.dg/defined_assignment_5.f90: New test.\n\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\n\nFrom-SVN: r194016", "tree": {"sha": "767e7c8adc92ca36bda76bd7f0a52db9ac0ff0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/767e7c8adc92ca36bda76bd7f0a52db9ac0ff0c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/comments", "author": {"login": "afanfa", "id": 8441559, "node_id": "MDQ6VXNlcjg0NDE1NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8441559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/afanfa", "html_url": "https://github.com/afanfa", "followers_url": "https://api.github.com/users/afanfa/followers", "following_url": "https://api.github.com/users/afanfa/following{/other_user}", "gists_url": "https://api.github.com/users/afanfa/gists{/gist_id}", "starred_url": "https://api.github.com/users/afanfa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/afanfa/subscriptions", "organizations_url": "https://api.github.com/users/afanfa/orgs", "repos_url": "https://api.github.com/users/afanfa/repos", "events_url": "https://api.github.com/users/afanfa/events{/privacy}", "received_events_url": "https://api.github.com/users/afanfa/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2eb342ee03024e1e85816cfe1de188d326eaeae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb342ee03024e1e85816cfe1de188d326eaeae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb342ee03024e1e85816cfe1de188d326eaeae8"}], "stats": {"total": 1131, "additions": 983, "deletions": 148}, "files": [{"sha": "f9b6be75285e65090f7ebc1f8a1c73f7373f19c7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -1,3 +1,49 @@\n+2012-12-01   Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n+             Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/46897\n+\t* gfortran.h : Add bit field 'defined_assign_comp' to\n+\tsymbol_attribute structure.\n+\tAdd primitive for gfc_add_full_array_ref.\n+\t* expr.c (gfc_add_full_array_ref): New function.\n+\t(gfc_lval_expr_from_sym): Call new function.\n+\t* resolve.c (add_comp_ref): New function.\n+\t(build_assignment): New function.\n+\t(get_temp_from_expr): New function\n+\t(add_code_to_chain): New function\n+\t(generate_component_assignments): New function that calls all\n+\tthe above new functions.\n+\t(resolve_code): Call generate_component_assignments.\n+\t(check_defined_assignments): New function.\n+\t(resolve_fl_derived0): Call check_defined_assignments.\n+\t(gfc_resolve): Reset component_assignment_level in case it is\n+\tleft in a bad state by errors.\n+\n+\n+\t* resolve.c (is_sym_host_assoc, resolve_procedure_interface,\n+\tresolve_contained_fntype, resolve_procedure_expression,\n+\tresolve_elemental_actual, resolve_global_procedure,\n+\tis_scalar_expr_ptr, gfc_iso_c_func_interface, resolve_function,\n+\tset_name_and_label, gfc_iso_c_sub_interface,\n+\tresolve_specific_s0, resolve_operator, compare_bound_mpz_t,\n+\tgfc_resolve_character_operator, resolve_typebound_function,\n+\tgfc_resolve_expr, forall_index, remove_last_array_ref,\n+\tconformable_arrays, resolve_allocate_expr,\n+\tresolve_allocate_deallocate, resolve_select_type,\n+\tresolve_transfer, resolve_where,\n+\tgfc_resolve_where_code_in_forall, gfc_resolve_forall_body,\n+\tgfc_count_forall_iterators, resolve_values,\n+\tresolve_bind_c_comms, resolve_bind_c_derived_types,\n+\tgfc_verify_binding_labels, apply_default_init,\n+\tbuild_default_init_expr, apply_default_init_local,\n+\tresolve_fl_var_and_proc, resolve_fl_procedure,\n+\tgfc_resolve_finalizers, check_generic_tbp_ambiguity,\n+\tresolve_typebound_intrinsic_op, resolve_typebound_procedure,\n+\tresolve_typebound_procedures, ensure_not_abstract,\n+\tresolve_fl_derived0, resolve_fl_parameter, resolve_symbol,\n+\tresolve_equivalence_derived): Remove trailing white space.\n+\t* gfortran.h : Remove trailing white space.\n+\n 2012-11-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52161"}, {"sha": "b535e8adf5dd665b9f9dbd06dab164da5cea1054", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -3899,6 +3899,33 @@ gfc_get_variable_expr (gfc_symtree *var)\n }\n \n \n+/* Adds a full array reference to an expression, as needed.  */\n+\n+void\n+gfc_add_full_array_ref (gfc_expr *e, gfc_array_spec *as)\n+{\n+  gfc_ref *ref;\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (!ref->next)\n+      break;\n+  if (ref)\n+    {\n+      ref->next = gfc_get_ref ();\n+      ref = ref->next;\n+    }\n+  else\n+    {\n+      e->ref = gfc_get_ref ();\n+      ref = e->ref;\n+    }\n+  ref->type = REF_ARRAY;\n+  ref->u.ar.type = AR_FULL;\n+  ref->u.ar.dimen = e->rank;\n+  ref->u.ar.where = e->where;\n+  ref->u.ar.as = as;\n+}\n+\n+\n gfc_expr *\n gfc_lval_expr_from_sym (gfc_symbol *sym)\n {\n@@ -3912,16 +3939,8 @@ gfc_lval_expr_from_sym (gfc_symbol *sym)\n   /* It will always be a full array.  */\n   lval->rank = sym->as ? sym->as->rank : 0;\n   if (lval->rank)\n-    {\n-      lval->ref = gfc_get_ref ();\n-      lval->ref->type = REF_ARRAY;\n-      lval->ref->u.ar.type = AR_FULL;\n-      lval->ref->u.ar.dimen = lval->rank;\n-      lval->ref->u.ar.where = sym->declared_at;\n-      lval->ref->u.ar.as = sym->ts.type == BT_CLASS\n-\t\t\t   ? CLASS_DATA (sym)->as : sym->as;\n-    }\n-\n+    gfc_add_full_array_ref (lval, sym->ts.type == BT_CLASS ?\n+\t\t\t    CLASS_DATA (sym)->as : sym->as);\n   return lval;\n }\n "}, {"sha": "4942c1c920e959f2938de822086417a6cc52a034", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -98,7 +98,7 @@ gfc_try;\n \n /* These are flags for identifying whether we are reading a character literal\n    between quotes or normal source code.  */\n-   \n+\n typedef enum\n { NONSTRING = 0, INSTRING_WARN, INSTRING_NOWARN }\n gfc_instring;\n@@ -162,11 +162,11 @@ typedef enum\n   INTRINSIC_AND, INTRINSIC_OR, INTRINSIC_EQV, INTRINSIC_NEQV,\n   /* ==, /=, >, >=, <, <=  */\n   INTRINSIC_EQ, INTRINSIC_NE, INTRINSIC_GT, INTRINSIC_GE,\n-  INTRINSIC_LT, INTRINSIC_LE, \n+  INTRINSIC_LT, INTRINSIC_LE,\n   /* .EQ., .NE., .GT., .GE., .LT., .LE. (OS = Old-Style)  */\n   INTRINSIC_EQ_OS, INTRINSIC_NE_OS, INTRINSIC_GT_OS, INTRINSIC_GE_OS,\n-  INTRINSIC_LT_OS, INTRINSIC_LE_OS, \n-  INTRINSIC_NOT, INTRINSIC_USER, INTRINSIC_ASSIGN, \n+  INTRINSIC_LT_OS, INTRINSIC_LE_OS,\n+  INTRINSIC_NOT, INTRINSIC_USER, INTRINSIC_ASSIGN,\n   INTRINSIC_PARENTHESES, GFC_INTRINSIC_END /* Sentinel */\n }\n gfc_intrinsic_op;\n@@ -199,7 +199,7 @@ typedef enum\n   ST_INQUIRE, ST_INTERFACE, ST_SYNC_ALL, ST_SYNC_MEMORY, ST_SYNC_IMAGES,\n   ST_PARAMETER, ST_MODULE, ST_MODULE_PROC, ST_NAMELIST, ST_NULLIFY, ST_OPEN,\n   ST_PAUSE, ST_PRIVATE, ST_PROGRAM, ST_PUBLIC, ST_READ, ST_RETURN, ST_REWIND,\n-  ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT, \n+  ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT,\n   ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n   ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n@@ -624,7 +624,7 @@ iso_fortran_env_symbol;\n #define NAMED_FUNCTION(a,b,c,d) a,\n typedef enum\n {\n-  ISOCBINDING_INVALID = -1, \n+  ISOCBINDING_INVALID = -1,\n #include \"iso-c-binding.def\"\n   ISOCBINDING_LAST,\n   ISOCBINDING_NUMBER = ISOCBINDING_LAST\n@@ -707,7 +707,7 @@ typedef struct\n     use_only:1,\t\t\t/* Symbol has been use-associated, with ONLY.  */\n     use_rename:1,\t\t/* Symbol has been use-associated and renamed.  */\n     imported:1,\t\t\t/* Symbol has been associated by IMPORT.  */\n-    host_assoc:1;\t\t/* Symbol has been host associated.  */ \n+    host_assoc:1;\t\t/* Symbol has been host associated.  */\n \n   unsigned in_namelist:1, in_common:1, in_equivalence:1;\n   unsigned function:1, subroutine:1, procedure:1;\n@@ -783,12 +783,14 @@ typedef struct\n   /* Special attributes for Cray pointers, pointees.  */\n   unsigned cray_pointer:1, cray_pointee:1;\n \n-  /* The symbol is a derived type with allocatable components, pointer \n+  /* The symbol is a derived type with allocatable components, pointer\n      components or private components, procedure pointer components,\n      possibly nested.  zero_comp is true if the derived type has no\n-     component at all.  */\n+     component at all.  defined_assign_comp is true if the derived\n+     type or a (sub-)component has a typebound defined assignment.  */\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n-\t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1;\n+\t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,\n+\t   defined_assign_comp:1;\n \n   /* This is a temporary selector for SELECT TYPE.  */\n   unsigned select_type_temporary:1;\n@@ -1240,7 +1242,7 @@ typedef struct gfc_symbol\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n \n   tree backend_decl;\n-   \n+\n   /* Identity of the intrinsic module the symbol comes from, or\n      INTMOD_NONE if it's not imported from a intrinsic module.  */\n   intmod_id from_intmod;\n@@ -1655,7 +1657,7 @@ typedef struct gfc_intrinsic_sym\n   const char *name, *lib_name;\n   gfc_intrinsic_arg *formal;\n   gfc_typespec ts;\n-  unsigned elemental:1, inquiry:1, transformational:1, pure:1, \n+  unsigned elemental:1, inquiry:1, transformational:1, pure:1,\n     generic:1, specific:1, actual_ok:1, noreturn:1, conversion:1,\n     from_module:1;\n \n@@ -1722,14 +1724,14 @@ typedef struct gfc_expr\n   /* Sometimes, when an error has been emitted, it is necessary to prevent\n       it from recurring.  */\n   unsigned int error : 1;\n-  \n+\n   /* Mark an expression where a user operator has been substituted by\n      a function call in interface.c(gfc_extend_expr).  */\n   unsigned int user_operator : 1;\n \n   /* Mark an expression as being a MOLD argument of ALLOCATE.  */\n   unsigned int mold : 1;\n-  \n+\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from\n@@ -2040,7 +2042,7 @@ gfc_forall_iterator;\n \n typedef struct gfc_association_list\n {\n-  struct gfc_association_list *next; \n+  struct gfc_association_list *next;\n \n   /* Whether this is association to a variable that can be changed; otherwise,\n      it's association to an expression and the name may not be used as\n@@ -2351,7 +2353,7 @@ typedef struct gfc_finalizer\n      still referenced or not for dereferencing it on deleting a gfc_finalizer\n      structure.  */\n   gfc_symbol*  proc_sym;\n-  gfc_symtree* proc_tree; \n+  gfc_symtree* proc_tree;\n }\n gfc_finalizer;\n #define gfc_get_finalizer() XCNEW (gfc_finalizer)\n@@ -2761,6 +2763,7 @@ gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n bool gfc_has_default_initializer (gfc_symbol *);\n gfc_expr *gfc_default_initializer (gfc_typespec *);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n+void gfc_add_full_array_ref (gfc_expr *, gfc_array_spec *);\n gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);\n \n gfc_array_spec *gfc_get_full_arrayspec_from_expr (gfc_expr *expr);"}, {"sha": "92df38c3ad7798451f32d0d6852c2fcb27c7db06", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 566, "deletions": 122, "changes": 688, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -104,7 +104,7 @@ static bool\n is_sym_host_assoc (gfc_symbol *sym, gfc_namespace *ns)\n {\n   for (ns = ns->parent; ns; ns = ns->parent)\n-    {      \n+    {\n       if (sym->ns == ns)\n \treturn true;\n     }\n@@ -220,7 +220,7 @@ resolve_procedure_interface (gfc_symbol *sym)\n \t  sym->ts = ifc->result->ts;\n \t  sym->result = sym;\n \t}\n-      else   \n+      else\n \tsym->ts = ifc->ts;\n       sym->ts.interface = ifc;\n       sym->attr.function = ifc->attr.function;\n@@ -580,7 +580,7 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n \t}\n     }\n \n-  /* Fortran 95 Draft Standard, page 51, Section 5.1.1.5, on the Character \n+  /* Fortran 95 Draft Standard, page 51, Section 5.1.1.5, on the Character\n      type, lists the only ways a character length value of * can be used:\n      dummy arguments of procedures, named constants, and function results\n      in external functions.  Internal function results and results of module\n@@ -1323,7 +1323,7 @@ generic_sym (gfc_symbol *sym)\n     return 0;\n \n   gfc_find_symbol (sym->name, sym->ns->parent, 1, &s);\n-  \n+\n   if (s != NULL)\n     {\n       if (s == sym)\n@@ -1444,7 +1444,7 @@ count_specific_procs (gfc_expr *e)\n   int n;\n   gfc_interface *p;\n   gfc_symbol *sym;\n-\t\n+\n   n = 0;\n   sym = e->symtree->n.sym;\n \n@@ -1647,7 +1647,7 @@ resolve_procedure_expression (gfc_expr* expr)\n     gfc_warning (\"Non-RECURSIVE procedure '%s' at %L is possibly calling\"\n \t\t \" itself recursively.  Declare it RECURSIVE or use\"\n \t\t \" -frecursive\", sym->name, &expr->where);\n-  \n+\n   return SUCCESS;\n }\n \n@@ -1955,7 +1955,7 @@ resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n   else if (c && c->ext.actual != NULL)\n     {\n       arg0 = c->ext.actual;\n-      \n+\n       if (c->resolved_sym)\n \tesym = c->resolved_sym;\n       else\n@@ -2371,7 +2371,7 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n \t      && !(gfc_option.warn_std & GFC_STD_GNU)))\n \tgfc_errors_to_warnings (1);\n \n-      if (sym->attr.if_source != IFSRC_IFBODY)  \n+      if (sym->attr.if_source != IFSRC_IFBODY)\n \tgfc_procedure_use (def_sym, actual, where);\n \n       gfc_errors_to_warnings (0);\n@@ -2774,7 +2774,7 @@ is_scalar_expr_ptr (gfc_expr *expr)\n \t\t    {\n \t\t      /* We have constant lower and upper bounds.  If the\n \t\t\t difference between is 1, it can be considered a\n-\t\t\t scalar.  \n+\t\t\t scalar.\n \t\t\t FIXME: Use gfc_dep_compare_expr instead.  */\n \t\t      start = (int) mpz_get_si\n \t\t\t\t(ref->u.ar.as->lower[0]->value.integer);\n@@ -2841,7 +2841,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n      the actual expression could be a part-ref of the expr symbol.  */\n   arg_ts = &(args->expr->ts);\n   arg_attr = gfc_expr_attr (args->expr);\n-    \n+\n   if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n     {\n       /* If the user gave two args then they are providing something for\n@@ -2930,7 +2930,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \t  if (seen_section && retval == SUCCESS)\n \t    gfc_warning (\"Array section in '%s' call at %L\", name,\n \t\t\t &(args->expr->where));\n-\t\t\t \n+\n           /* See if we have interoperable type and type param.  */\n           if (gfc_verify_c_interop (arg_ts) == SUCCESS\n               || gfc_check_any_c_kind (arg_ts) == SUCCESS)\n@@ -2944,7 +2944,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                      is not an array of zero size.  */\n                   if (args_sym->attr.allocatable == 1)\n                     {\n-                      if (args_sym->attr.dimension != 0 \n+                      if (args_sym->attr.dimension != 0\n                           && (args_sym->as && args_sym->as->rank == 0))\n                         {\n                           gfc_error_now (\"Allocatable variable '%s' used as a \"\n@@ -2983,7 +2983,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \t\t\t      retval = FAILURE;\n \t\t\t    }\n \t\t\t}\n-                              \n+\n                       /* Make sure it's not a character string.  Arrays of\n                          any type should be ok if the variable is of a C\n                          interoperable type.  */\n@@ -3023,15 +3023,15 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                  with no length type parameters.  It still must have either\n                  the pointer or target attribute, and it can be\n                  allocatable (but must be allocated when c_loc is called).  */\n-              if (args->expr->rank != 0 \n+              if (args->expr->rank != 0\n                   && is_scalar_expr_ptr (args->expr) != SUCCESS)\n                 {\n                   gfc_error_now (\"Parameter '%s' to '%s' at %L must be a \"\n                                  \"scalar\", args_sym->name, sym->name,\n                                  &(args->expr->where));\n                   retval = FAILURE;\n                 }\n-              else if (arg_ts->type == BT_CHARACTER \n+              else if (arg_ts->type == BT_CHARACTER\n                        && is_scalar_expr_ptr (args->expr) != SUCCESS)\n                 {\n                   gfc_error_now (\"CHARACTER argument '%s' to '%s' at \"\n@@ -3068,7 +3068,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \t\t\t\t      &(args->expr->where)) == FAILURE)\n \t    retval = FAILURE;\n         }\n-      \n+\n       /* for c_loc/c_funloc, the new symbol is the same as the old one */\n       *new_sym = sym;\n     }\n@@ -3148,20 +3148,20 @@ resolve_function (gfc_expr *expr)\n     }\n \n   inquiry_argument = false;\n- \n+\n   /* Need to setup the call to the correct c_associated, depending on\n      the number of cptrs to user gives to compare.  */\n   if (sym && sym->attr.is_iso_c == 1)\n     {\n       if (gfc_iso_c_func_interface (sym, expr->value.function.actual, &sym)\n           == FAILURE)\n         return FAILURE;\n-      \n+\n       /* Get the symtree for the new symbol (resolved func).\n          the old one will be freed later, when it's no longer used.  */\n       gfc_find_sym_tree (sym->name, sym->ns, 1, &(expr->symtree));\n     }\n-  \n+\n   /* Resume assumed_size checking.  */\n   need_full_assumed_size--;\n \n@@ -3490,7 +3490,7 @@ set_name_and_label (gfc_code *c, gfc_symbol *sym,\n       sprintf (name, \"%s_%c%d\", sym->name, type, kind);\n       /* Set up the binding label as the given symbol's label plus\n          the type and kind.  */\n-      *binding_label = gfc_get_string (\"%s_%c%d\", sym->binding_label, type, \n+      *binding_label = gfc_get_string (\"%s_%c%d\", sym->binding_label, type,\n \t\t\t\t       kind);\n     }\n   else\n@@ -3501,7 +3501,7 @@ set_name_and_label (gfc_code *c, gfc_symbol *sym,\n       sprintf (name, \"%s\", sym->name);\n       *binding_label = sym->binding_label;\n     }\n-   \n+\n   return;\n }\n \n@@ -3525,7 +3525,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n   /* default to success; will override if find error */\n   match m = MATCH_YES;\n \n-  /* Make sure the actual arguments are in the necessary order (based on the \n+  /* Make sure the actual arguments are in the necessary order (based on the\n      formal args) before resolving.  */\n   if (gfc_procedure_use (sym, &c->ext.actual, &(c->loc)) == FAILURE)\n     {\n@@ -3537,7 +3537,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n       (sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n     {\n       set_name_and_label (c, sym, name, &binding_label);\n-      \n+\n       if (sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n \t{\n \t  if (c->ext.actual != NULL && c->ext.actual->next != NULL)\n@@ -3572,7 +3572,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n \t\t  if (arg3 == NULL || arg3->expr == NULL)\n \t\t    {\n \t\t      m = MATCH_ERROR;\n-\t\t      gfc_error (\"Missing SHAPE argument for call to %s at %L\", \n+\t\t      gfc_error (\"Missing SHAPE argument for call to %s at %L\",\n \t\t\t\t sym->name, &c->loc);\n \t\t    }\n \t\t  else if (arg3->expr->ts.type != BT_INTEGER\n@@ -3609,7 +3609,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n \t{\n \t  /* the 1 means to add the optional arg to formal list */\n \t  new_sym = get_iso_c_sym (sym, name, binding_label, 1);\n-\t \n+\n \t  /* for error reporting, say it's declared where the original was */\n \t  new_sym->declared_at = sym->declared_at;\n \t}\n@@ -3625,7 +3625,7 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n     c->resolved_sym = new_sym;\n   else\n     c->resolved_sym = sym;\n-  \n+\n   return m;\n }\n \n@@ -3642,7 +3642,7 @@ resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n       m = gfc_iso_c_sub_interface (c,sym);\n       return m;\n     }\n-  \n+\n   if (sym->attr.external || sym->attr.if_source == IFSRC_IFBODY)\n     {\n       if (sym->attr.dummy)\n@@ -4072,7 +4072,7 @@ resolve_operator (gfc_expr *e)\n \t\t    msg = \"Equality comparison for %s at %L\";\n \t\t  else\n \t\t    msg = \"Inequality comparison for %s at %L\";\n-\t\t  \n+\n \t\t  gfc_warning (msg, gfc_typename (&op1->ts), &op1->where);\n \t\t}\n \t    }\n@@ -4083,7 +4083,7 @@ resolve_operator (gfc_expr *e)\n       if (op1->ts.type == BT_LOGICAL && op2->ts.type == BT_LOGICAL)\n \tsprintf (msg,\n \t\t _(\"Logicals at %%L must be compared with %s instead of %s\"),\n-\t\t (e->value.op.op == INTRINSIC_EQ \n+\t\t (e->value.op.op == INTRINSIC_EQ\n \t\t  || e->value.op.op == INTRINSIC_EQ_OS)\n \t\t ? \".eqv.\" : \".neqv.\", gfc_op2string (e->value.op.op));\n       else\n@@ -4323,7 +4323,7 @@ compare_bound_mpz_t (gfc_expr *a, mpz_t b)\n }\n \n \n-/* Compute the last value of a sequence given by a triplet.  \n+/* Compute the last value of a sequence given by a triplet.\n    Return 0 if it wasn't able to compute the last value, or if the\n    sequence if empty, and 1 otherwise.  */\n \n@@ -5620,7 +5620,7 @@ gfc_resolve_character_operator (gfc_expr *e)\n     {\n       gfc_free_expr (e1);\n       gfc_free_expr (e2);\n-      \n+\n       return;\n     }\n \n@@ -6281,7 +6281,7 @@ resolve_typebound_function (gfc_expr* e)\n       e->value.function.esym = NULL;\n       e->symtree = st;\n \n-      if (new_ref)  \n+      if (new_ref)\n \te->ref = new_ref;\n \n       /* '_vptr' points to the vtab, which contains the procedure pointers.  */\n@@ -6607,7 +6607,7 @@ gfc_resolve_expr (gfc_expr *e)\n       if (t == SUCCESS && e->ts.type == BT_CHARACTER)\n         {\n \t  /* For efficiency, we call gfc_expand_constructor for BT_CHARACTER\n-\t     here rather then add a duplicate test for it above.  */ \n+\t     here rather then add a duplicate test for it above.  */\n \t  gfc_expand_constructor (e, false);\n \t  t = gfc_resolve_character_array_constructor (e);\n \t}\n@@ -6769,7 +6769,7 @@ forall_index (gfc_expr *expr, gfc_symbol *sym, int *f)\n {\n   if (expr->expr_type != EXPR_VARIABLE)\n     return false;\n-  \n+\n   /* A scalar assignment  */\n   if (!expr->ref || *f == 1)\n     {\n@@ -7052,15 +7052,15 @@ remove_last_array_ref (gfc_expr* e)\n \n \n /* Used in resolve_allocate_expr to check that a allocation-object and\n-   a source-expr are conformable.  This does not catch all possible \n+   a source-expr are conformable.  This does not catch all possible\n    cases; in particular a runtime checking is needed.  */\n \n static gfc_try\n conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n {\n   gfc_ref *tail;\n   for (tail = e2->ref; tail && tail->next; tail = tail->next);\n-  \n+\n   /* First compare rank.  */\n   if (tail && e1->rank != tail->u.ar.as->rank)\n     {\n@@ -7324,7 +7324,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t using _copy and trans_call. It is convenient to exploit that\n \t when the allocated type is different from the declared type but\n \t no SOURCE exists by setting expr3.  */\n-      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts); \n+      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts);\n     }\n   else if (!code->expr3)\n     {\n@@ -7586,7 +7586,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \t      /* This is a potential collision.  */\n \t      gfc_ref *pr = pe->ref;\n \t      gfc_ref *qr = qe->ref;\n-\t      \n+\n \t      /* Follow the references  until\n \t\t a) They start to differ, in which case there is no error;\n \t\t you can deallocate a%b and a%c in a single statement\n@@ -7622,31 +7622,23 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \n \t\t      if (pr->next && qr->next)\n \t\t\t{\n-\t\t\t  int i;\n \t\t\t  gfc_array_ref *par = &(pr->u.ar);\n \t\t\t  gfc_array_ref *qar = &(qr->u.ar);\n-\n-\t\t\t  for (i=0; i<par->dimen; i++)\n-\t\t\t    {\n-\t\t\t      if ((par->start[i] != NULL\n-\t\t\t\t   || qar->start[i] != NULL)\n-\t\t\t\t  && gfc_dep_compare_expr (par->start[i],\n-\t\t\t\t\t\t\t   qar->start[i]) != 0)\n-\t\t\t\tgoto break_label;\n-\t\t\t    }\n+\t\t\t  if ((par->start[0] != NULL || qar->start[0] != NULL)\n+\t\t\t      && gfc_dep_compare_expr (par->start[0],\n+\t\t\t\t\t\t       qar->start[0]) != 0)\n+\t\t\t    break;\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      if (pr->u.c.component->name != qr->u.c.component->name)\n \t\t\tbreak;\n \t\t    }\n-\t\t  \n+\n \t\t  pr = pr->next;\n \t\t  qr = qr->next;\n \t\t}\n-\t    break_label:\n-\t      ;\n \t    }\n \t}\n     }\n@@ -7668,7 +7660,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \n /* Callback function for our mergesort variant.  Determines interval\n    overlaps for CASEs. Return <0 if op1 < op2, 0 for overlap, >0 for\n-   op1 > op2.  Assumes we're not dealing with the default case.  \n+   op1 > op2.  Assumes we're not dealing with the default case.\n    We have op1 = (:L), (K:L) or (K:) and op2 = (:N), (M:N) or (M:).\n    There are nine situations to check.  */\n \n@@ -8376,7 +8368,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t  default_case = body;\n \t}\n     }\n-    \n+\n   if (error > 0)\n     return;\n \n@@ -8395,7 +8387,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n       assoc->target = gfc_copy_expr (code->expr2);\n       assoc->target->where = code->expr2->where;\n       /* assoc->variable will be set by resolve_assoc_var.  */\n-      \n+\n       code->ext.block.assoc = assoc;\n       code->expr1->symtree->n.sym->assoc = assoc;\n \n@@ -8466,7 +8458,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n       resolve_assoc_var (st->n.sym, false);\n     }\n-    \n+\n   /* Take out CLASS IS cases for separate treatment.  */\n   body = code;\n   while (body && body->block)\n@@ -8475,7 +8467,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t{\n \t  /* Add to class_is list.  */\n \t  if (class_is == NULL)\n-\t    { \n+\t    {\n \t      class_is = body->block;\n \t      tail = class_is;\n \t    }\n@@ -8496,7 +8488,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   if (class_is)\n     {\n       gfc_symbol *vtab;\n-      \n+\n       if (!default_case)\n \t{\n \t  /* Add a default case to hold the CLASS IS cases.  */\n@@ -8544,7 +8536,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t    }\n \t  while (swapped);\n \t}\n-\t\n+\n       /* Generate IF chain.  */\n       if_st = gfc_get_code ();\n       if_st->op = EXEC_IF;\n@@ -8580,7 +8572,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t    new_st->op = EXEC_IF;\n \t    new_st->next = default_case->next;\n \t  }\n-\t  \n+\n \t/* Replace CLASS DEFAULT code by the IF chain.  */\n \tdefault_case->next = if_st;\n     }\n@@ -8597,7 +8589,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n /* Resolve a transfer statement. This is making sure that:\n    -- a derived type being transferred has only non-pointer components\n-   -- a derived type being transferred doesn't have private components, unless \n+   -- a derived type being transferred doesn't have private components, unless\n       it's being transferred from the module where the type was defined\n    -- we're not trying to transfer a whole assumed size array.  */\n \n@@ -8701,7 +8693,7 @@ resolve_transfer (gfc_code *code)\n \n /* Find the set of labels that are reachable from this block.  We also\n    record the last statement in each block.  */\n-     \n+\n static void\n find_reachable_labels (gfc_code *block)\n {\n@@ -9007,7 +8999,7 @@ resolve_where (gfc_code *code, gfc_expr *mask)\n \t\t\t  \"inconsistent shape\", &cnext->expr1->where);\n \t      break;\n \n-  \n+\n \t    case EXEC_ASSIGN_CALL:\n \t      resolve_call (cnext);\n \t      if (!cnext->resolved_sym->attr.elemental)\n@@ -9093,7 +9085,7 @@ gfc_resolve_where_code_in_forall (gfc_code *code, int nvar,\n \t    case EXEC_ASSIGN:\n \t      gfc_resolve_assign_in_forall (cnext, nvar, var_expr);\n \t      break;\n-  \n+\n \t    /* WHERE operator assignment statement */\n \t    case EXEC_ASSIGN_CALL:\n \t      resolve_call (cnext);\n@@ -9161,10 +9153,10 @@ gfc_resolve_forall_body (gfc_code *code, int nvar, gfc_expr **var_expr)\n \n \n /* Counts the number of iterators needed inside a forall construct, including\n-   nested forall constructs. This is used to allocate the needed memory \n+   nested forall constructs. This is used to allocate the needed memory\n    in gfc_resolve_forall.  */\n \n-static int \n+static int\n gfc_count_forall_iterators (gfc_code *code)\n {\n   int max_iters, sub_iters, current_iters;\n@@ -9176,11 +9168,11 @@ gfc_count_forall_iterators (gfc_code *code)\n \n   for (fa = code->ext.forall_iterator; fa; fa = fa->next)\n     current_iters ++;\n-  \n+\n   code = code->block->next;\n \n   while (code)\n-    {          \n+    {\n       if (code->op == EXEC_FORALL)\n         {\n           sub_iters = gfc_count_forall_iterators (code);\n@@ -9561,6 +9553,408 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n }\n \n \n+/* Add a component reference onto an expression.  */\n+\n+static void\n+add_comp_ref (gfc_expr *e, gfc_component *c)\n+{\n+  gfc_ref **ref;\n+  ref = &(e->ref);\n+  while (*ref)\n+    ref = &((*ref)->next);\n+  *ref = gfc_get_ref ();\n+  (*ref)->type = REF_COMPONENT;\n+  (*ref)->u.c.sym = e->ts.u.derived;\n+  (*ref)->u.c.component = c;\n+  e->ts = c->ts;\n+\n+  /* Add a full array ref, as necessary.  */\n+  if (c->as)\n+    {\n+      gfc_add_full_array_ref (e, c->as);\n+      e->rank = c->as->rank;\n+    }\n+}\n+\n+\n+/* Build an assignment.  Keep the argument 'op' for future use, so that\n+   pointer assignments can be made.  */\n+\n+static gfc_code *\n+build_assignment (gfc_exec_op op, gfc_expr *expr1, gfc_expr *expr2,\n+\t\t  gfc_component *comp1, gfc_component *comp2, locus loc)\n+{\n+  gfc_code *this_code;\n+\n+  this_code = gfc_get_code ();\n+  this_code->op = op;\n+  this_code->next = NULL;\n+  this_code->expr1 = gfc_copy_expr (expr1);\n+  this_code->expr2 = gfc_copy_expr (expr2);\n+  this_code->loc = loc;\n+  if (comp1 && comp2)\n+    {\n+      add_comp_ref (this_code->expr1, comp1);\n+      add_comp_ref (this_code->expr2, comp2);\n+    }\n+\n+  return this_code;\n+}\n+\n+\n+/* Makes a temporary variable expression based on the characteristics of\n+   a given variable expression.  */\n+\n+static gfc_expr*\n+get_temp_from_expr (gfc_expr *e, gfc_namespace *ns)\n+{\n+  static int serial = 0;\n+  char name[GFC_MAX_SYMBOL_LEN];\n+  gfc_symtree *tmp;\n+  gfc_array_spec *as;\n+  gfc_array_ref *aref;\n+  gfc_ref *ref;\n+\n+  sprintf (name, \"DA@%d\", serial++);\n+  gfc_get_sym_tree (name, ns, &tmp, false);\n+  gfc_add_type (tmp->n.sym, &e->ts, NULL);\n+\n+  as = NULL;\n+  ref = NULL;\n+  aref = NULL;\n+\n+  /* This function could be expanded to support other expression type\n+     but this is not needed here.  */\n+  gcc_assert (e->expr_type == EXPR_VARIABLE);\n+\n+  /* Obtain the arrayspec for the temporary.  */\n+  if (e->rank)\n+    {\n+      aref = gfc_find_array_ref (e);\n+      if (e->expr_type == EXPR_VARIABLE\n+\t  && e->symtree->n.sym->as == aref->as)\n+\tas = aref->as;\n+      else\n+\t{\n+\t  for (ref = e->ref; ref; ref = ref->next)\n+\t    if (ref->type == REF_COMPONENT\n+\t\t&& ref->u.c.component->as == aref->as)\n+\t      {\n+\t\tas = aref->as;\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n+  /* Add the attributes and the arrayspec to the temporary.  */\n+  tmp->n.sym->attr = gfc_expr_attr (e);\n+  if (as)\n+    {\n+      tmp->n.sym->as = gfc_copy_array_spec (as);\n+      if (!ref)\n+\tref = e->ref;\n+      if (as->type == AS_DEFERRED)\n+\ttmp->n.sym->attr.allocatable = 1;\n+    }\n+  else\n+    tmp->n.sym->attr.dimension = 0;\n+\n+  gfc_set_sym_referenced (tmp->n.sym);\n+  gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n+  e = gfc_lval_expr_from_sym (tmp->n.sym);\n+\n+  /* Should the lhs be a section, use its array ref for the\n+     temporary expression.  */\n+  if (aref && aref->type != AR_FULL)\n+    {\n+      gfc_free_ref_list (e->ref);\n+      e->ref = gfc_copy_ref (ref);\n+    }\n+  return e;\n+}\n+\n+\n+/* Add one line of code to the code chain, making sure that 'head' and\n+   'tail' are appropriately updated.  */\n+\n+static void\n+add_code_to_chain (gfc_code **this_code, gfc_code **head, gfc_code **tail)\n+{\n+  gcc_assert (this_code);\n+  if (*head == NULL)\n+    *head = *tail = *this_code;\n+  else\n+    *tail = gfc_append_code (*tail, *this_code);\n+  *this_code = NULL;\n+}\n+\n+\n+/* Counts the potential number of part array references that would\n+   result from resolution of typebound defined assignments.  */\n+\n+static int\n+nonscalar_typebound_assign (gfc_symbol *derived, int depth)\n+{\n+  gfc_component *c;\n+  int c_depth = 0, t_depth;\n+\n+  for (c= derived->components; c; c = c->next)\n+    {\n+      if ((c->ts.type != BT_DERIVED\n+\t    || c->attr.pointer\n+\t    || c->attr.allocatable\n+\t    || c->attr.proc_pointer_comp\n+\t    || c->attr.class_pointer\n+\t    || c->attr.proc_pointer)\n+\t  && !c->attr.defined_assign_comp)\n+\tcontinue;\n+\n+      if (c->as && c_depth == 0)\n+\tc_depth = 1;\n+\n+      if (c->ts.u.derived->attr.defined_assign_comp)\n+\tt_depth = nonscalar_typebound_assign (c->ts.u.derived,\n+\t\t\t\t\t      c->as ? 1 : 0);\n+      else\n+\tt_depth = 0;\n+\n+      c_depth = t_depth > c_depth ? t_depth : c_depth;\n+    }\n+  return depth + c_depth;\n+}\n+\n+\n+/* Implement 7.2.1.3 of the F08 standard:\n+   \"An intrinsic assignment where the variable is of derived type is\n+   performed as if each component of the variable were assigned from the\n+   corresponding component of expr using pointer assignment (7.2.2) for\n+   each pointer component, de\ufb01ned assignment for each nonpointer\n+   nonallocatable component of a type that has a type-bound de\ufb01ned\n+   assignment consistent with the component, intrinsic assignment for\n+   each other nonpointer nonallocatable component, ...\"\n+\n+   The pointer assignments are taken care of by the intrinsic\n+   assignment of the structure itself.  This function recursively adds\n+   defined assignments where required.  The recursion is accomplished\n+   by calling resolve_code.\n+\n+   When the lhs in a defined assignment has intent INOUT, we need a\n+   temporary for the lhs.  In pseudo-code:\n+\n+   ! Only call function lhs once.\n+      if (lhs is not a constant or an variable)\n+\t  temp_x = expr2\n+          expr2 => temp_x\n+   ! Do the intrinsic assignment\n+      expr1 = expr2\n+   ! Now do the defined assignments\n+      do over components with typebound defined assignment [%cmp]\n+\t#if one component's assignment procedure is INOUT\n+\t  t1 = expr1\n+\t  #if expr2 non-variable\n+\t    temp_x = expr2\n+\t    expr2 => temp_x\n+\t  # endif\n+\t  expr1 = expr2\n+\t  # for each cmp\n+\t    t1%cmp {defined=} expr2%cmp\n+\t    expr1%cmp = t1%cmp\n+\t#else\n+\t  expr1 = expr2\n+\n+\t# for each cmp\n+\t  expr1%cmp {defined=} expr2%cmp\n+\t#endif\n+   */\n+\n+/* The temporary assignments have to be put on top of the additional\n+   code to avoid the result being changed by the intrinsic assignment.\n+   */\n+static int component_assignment_level = 0;\n+static gfc_code *tmp_head = NULL, *tmp_tail = NULL;\n+\n+static void\n+generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n+{\n+  gfc_component *comp1, *comp2;\n+  gfc_code *this_code = NULL, *head = NULL, *tail = NULL;\n+  gfc_expr *t1;\n+  int error_count, depth;\n+\n+  gfc_get_errors (NULL, &error_count);\n+\n+  /* Filter out continuing processing after an error.  */\n+  if (error_count\n+      || (*code)->expr1->ts.type != BT_DERIVED\n+      || (*code)->expr2->ts.type != BT_DERIVED)\n+    return;\n+\n+  /* TODO: Handle more than one part array reference in assignments.  */\n+  depth = nonscalar_typebound_assign ((*code)->expr1->ts.u.derived,\n+\t\t\t\t      (*code)->expr1->rank ? 1 : 0);\n+  if (depth > 1)\n+    {\n+      gfc_warning (\"TODO: type-bound de\ufb01ned assignment(s) at %L not \"\n+\t\t   \"done because multiple part array references would \"\n+\t\t   \"occur in intermediate expressions.\", &(*code)->loc);\n+      return;\n+    }\n+\n+  component_assignment_level++;\n+\n+  /* Create a temporary so that functions get called only once.  */\n+  if ((*code)->expr2->expr_type != EXPR_VARIABLE\n+      && (*code)->expr2->expr_type != EXPR_CONSTANT)\n+    {\n+      gfc_expr *tmp_expr;\n+\n+      /* Assign the rhs to the temporary.  */\n+      tmp_expr = get_temp_from_expr ((*code)->expr1, ns);\n+      this_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\t    tmp_expr, (*code)->expr2,\n+\t\t\t\t    NULL, NULL, (*code)->loc);\n+      /* Add the code and substitute the rhs expression.  */\n+      add_code_to_chain (&this_code, &tmp_head, &tmp_tail);\n+      gfc_free_expr ((*code)->expr2);\n+      (*code)->expr2 = tmp_expr;\n+    }\n+\n+  /* Do the intrinsic assignment.  This is not needed if the lhs is one\n+     of the temporaries generated here, since the intrinsic assignment\n+     to the final result already does this.  */\n+  if ((*code)->expr1->symtree->n.sym->name[2] != '@')\n+    {\n+      this_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\t    (*code)->expr1, (*code)->expr2,\n+\t\t\t\t    NULL, NULL, (*code)->loc);\n+      add_code_to_chain (&this_code, &head, &tail);\n+    }\n+\n+  comp1 = (*code)->expr1->ts.u.derived->components;\n+  comp2 = (*code)->expr2->ts.u.derived->components;\n+\n+  t1 = NULL;\n+  for (; comp1; comp1 = comp1->next, comp2 = comp2->next)\n+    {\n+      bool inout = false;\n+\n+      /* The intrinsic assignment does the right thing for pointers\n+\t of all kinds and allocatable components.  */\n+      if (comp1->ts.type != BT_DERIVED\n+\t  || comp1->attr.pointer\n+\t  || comp1->attr.allocatable\n+\t  || comp1->attr.proc_pointer_comp\n+\t  || comp1->attr.class_pointer\n+\t  || comp1->attr.proc_pointer)\n+\tcontinue;\n+\n+      /* Make an assigment for this component.  */\n+      this_code = gfc_get_code ();\n+      this_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\t    (*code)->expr1, (*code)->expr2,\n+\t\t\t\t    comp1, comp2, (*code)->loc);\n+\n+      /* Convert the assignment if there is a defined assignment for\n+\t this type.  Otherwise, using the call from resolve_code,\n+\t recurse into its components.  */\n+      resolve_code (this_code, ns);\n+\n+      if (this_code->op == EXEC_ASSIGN_CALL)\n+\t{\n+\t  gfc_symbol *rsym;\n+\t  /* Check that there is a typebound defined assignment.  If not,\n+\t     then this must be a module defined assignment.  We cannot\n+\t     use the defined_assign_comp attribute here because it must\n+\t     be this derived type that has the defined assignment and not\n+\t     a parent type.  */\n+\t  if (!(comp1->ts.u.derived->f2k_derived\n+\t\t&& comp1->ts.u.derived->f2k_derived\n+\t\t\t\t\t->tb_op[INTRINSIC_ASSIGN]))\n+\t    {\n+\t      gfc_free_statements (this_code);\n+\t      this_code = NULL;\n+\t      continue;\n+\t    }\n+\n+\t  /* If the first argument of the subroutine has intent INOUT\n+\t     a temporary must be generated and used instead.  */\n+\t  rsym = this_code->resolved_sym;\n+\t  if (rsym->formal\n+\t      && rsym->formal->sym->attr.intent == INTENT_INOUT)\n+\t    {\n+\t      gfc_code *temp_code;\n+\t      inout = true;\n+\n+\t      /* Build the temporary required for the assignment and put\n+\t\t it at the head of the generated code.  */\n+\t      if (!t1)\n+\t\t{\n+\t\t  t1 = get_temp_from_expr ((*code)->expr1, ns);\n+\t\t  temp_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\t\t\tt1, (*code)->expr1,\n+\t\t\t\tNULL, NULL, (*code)->loc);\n+\t\t  add_code_to_chain (&temp_code, &tmp_head, &tmp_tail);\n+\t\t}\n+\n+\t      /* Replace the first actual arg with the component of the\n+\t\t temporary.  */\n+\t      gfc_free_expr (this_code->ext.actual->expr);\n+\t      this_code->ext.actual->expr = gfc_copy_expr (t1);\n+\t      add_comp_ref (this_code->ext.actual->expr, comp1);\n+\t    }\n+\t  }\n+      else if (this_code->op == EXEC_ASSIGN && !this_code->next)\n+\t{\n+\t  /* Don't add intrinsic assignments since they are already\n+\t     effected by the intrinsic assignment of the structure.  */\n+\t  gfc_free_statements (this_code);\n+\t  this_code = NULL;\n+\t  continue;\n+\t}\n+\n+      add_code_to_chain (&this_code, &head, &tail);\n+\n+      if (t1 && inout)\n+\t{\n+\t  /* Transfer the value to the final result.  */\n+\t  this_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\t\t(*code)->expr1, t1,\n+\t\t\t\t\tcomp1, comp2, (*code)->loc);\n+\t  add_code_to_chain (&this_code, &head, &tail);\n+\t}\n+    }\n+\n+  /* This is probably not necessary.  */\n+  if (this_code)\n+    {\n+      gfc_free_statements (this_code);\n+      this_code = NULL;\n+    }\n+\n+  /* Put the temporary assignments at the top of the generated code.  */\n+  if (tmp_head && component_assignment_level == 1)\n+    {\n+      gfc_append_code (tmp_head, head);\n+      head = tmp_head;\n+      tmp_head = tmp_tail = NULL;\n+    }\n+\n+  /* Now attach the remaining code chain to the input code.  Step on\n+     to the end of the new code since resolution is complete.  */\n+  gcc_assert ((*code)->op == EXEC_ASSIGN);\n+  tail->next = (*code)->next;\n+  /* Overwrite 'code' because this would place the intrinsic assignment\n+     before the temporary for the lhs is created.  */\n+  gfc_free_expr ((*code)->expr1);\n+  gfc_free_expr ((*code)->expr2);\n+  **code = *head;\n+  free (head);\n+  *code = tail;\n+\n+  component_assignment_level--;\n+}\n+\n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -9723,6 +10117,12 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      else\n \t\tgoto call;\n \t    }\n+\n+\t  /* F03 7.4.1.3 for non-allocatable, non-pointer components.  */\n+\t  if (code->expr1->ts.type == BT_DERIVED\n+\t      && code->expr1->ts.u.derived->attr.defined_assign_comp)\n+\t    generate_component_assignments (&code, ns);\n+\n \t  break;\n \n \tcase EXEC_LABEL_ASSIGN:\n@@ -9963,7 +10363,7 @@ resolve_values (gfc_symbol *sym)\n \n   if (sym->value->expr_type == EXPR_STRUCTURE)\n     t= resolve_structure_cons (sym->value, 1);\n-  else \n+  else\n     t = gfc_resolve_expr (sym->value);\n \n   if (t == FAILURE)\n@@ -9985,7 +10385,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n     {\n       gfc_gsymbol *binding_label_gsym;\n       gfc_gsymbol *comm_name_gsym;\n-      const char * bind_label = comm_block_tree->n.common->binding_label \n+      const char * bind_label = comm_block_tree->n.common->binding_label\n \t? comm_block_tree->n.common->binding_label : \"\";\n \n       /* See if a global symbol exists by the common block's name.  It may\n@@ -10028,7 +10428,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n          check and nothing to add as a global symbol for the label.  */\n       if (!comm_block_tree->n.common->binding_label)\n         return;\n-      \n+\n       binding_label_gsym =\n         gfc_find_gsymbol (gfc_gsym_root,\n                           comm_block_tree->n.common->binding_label);\n@@ -10065,7 +10465,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n                        comm_name_gsym->name, &(comm_name_gsym->where));\n         }\n     }\n-  \n+\n   return;\n }\n \n@@ -10079,34 +10479,34 @@ resolve_bind_c_derived_types (gfc_symbol *derived_sym)\n   if (derived_sym != NULL && derived_sym->attr.flavor == FL_DERIVED\n       && derived_sym->attr.is_bind_c == 1)\n     verify_bind_c_derived_type (derived_sym);\n-  \n+\n   return;\n }\n \n \n-/* Verify that any binding labels used in a given namespace do not collide \n+/* Verify that any binding labels used in a given namespace do not collide\n    with the names or binding labels of any global symbols.  */\n \n static void\n gfc_verify_binding_labels (gfc_symbol *sym)\n {\n   int has_error = 0;\n-  \n-  if (sym != NULL && sym->attr.is_bind_c && sym->attr.is_iso_c == 0 \n+\n+  if (sym != NULL && sym->attr.is_bind_c && sym->attr.is_iso_c == 0\n       && sym->attr.flavor != FL_DERIVED && sym->binding_label)\n     {\n       gfc_gsymbol *bind_c_sym;\n \n       bind_c_sym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);\n-      if (bind_c_sym != NULL \n+      if (bind_c_sym != NULL\n           && strcmp (bind_c_sym->name, sym->binding_label) == 0)\n         {\n-          if (sym->attr.if_source == IFSRC_DECL \n-              && (bind_c_sym->type != GSYM_SUBROUTINE \n-                  && bind_c_sym->type != GSYM_FUNCTION) \n-              && ((sym->attr.contained == 1 \n-                   && strcmp (bind_c_sym->sym_name, sym->name) != 0) \n-                  || (sym->attr.use_assoc == 1 \n+          if (sym->attr.if_source == IFSRC_DECL\n+              && (bind_c_sym->type != GSYM_SUBROUTINE\n+                  && bind_c_sym->type != GSYM_FUNCTION)\n+              && ((sym->attr.contained == 1\n+                   && strcmp (bind_c_sym->sym_name, sym->name) != 0)\n+                  || (sym->attr.use_assoc == 1\n                       && (strcmp (bind_c_sym->mod_name, sym->module) != 0))))\n             {\n               /* Make sure global procedures don't collide with anything.  */\n@@ -10116,10 +10516,10 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n                          &(bind_c_sym->where));\n               has_error = 1;\n             }\n-          else if (sym->attr.contained == 0 \n-                   && (sym->attr.if_source == IFSRC_IFBODY \n-                       && sym->attr.flavor == FL_PROCEDURE) \n-                   && (bind_c_sym->sym_name != NULL \n+          else if (sym->attr.contained == 0\n+                   && (sym->attr.if_source == IFSRC_IFBODY\n+                       && sym->attr.flavor == FL_PROCEDURE)\n+                   && (bind_c_sym->sym_name != NULL\n                        && strcmp (bind_c_sym->sym_name, sym->name) != 0))\n             {\n               /* Make sure procedures in interface bodies don't collide.  */\n@@ -10130,10 +10530,10 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n                          &(bind_c_sym->where));\n               has_error = 1;\n             }\n-          else if (sym->attr.contained == 0 \n+          else if (sym->attr.contained == 0\n                    && sym->attr.if_source == IFSRC_UNKNOWN)\n \t    if ((sym->attr.use_assoc && bind_c_sym->mod_name\n-\t\t && strcmp (bind_c_sym->mod_name, sym->module) != 0) \n+\t\t && strcmp (bind_c_sym->mod_name, sym->module) != 0)\n \t\t|| sym->attr.use_assoc == 0)\n               {\n                 gfc_error (\"Binding label '%s' at %L collides with global \"\n@@ -10350,7 +10750,7 @@ apply_default_init (gfc_symbol *sym)\n \n /* Build an initializer for a local integer, real, complex, logical, or\n    character variable, based on the command line flags finit-local-zero,\n-   finit-integer=, finit-real=, finit-logical=, and finit-runtime.  Returns \n+   finit-integer=, finit-real=, finit-logical=, and finit-runtime.  Returns\n    null if the symbol should not have a default initialization.  */\n static gfc_expr *\n build_default_init_expr (gfc_symbol *sym)\n@@ -10381,10 +10781,10 @@ build_default_init_expr (gfc_symbol *sym)\n      characters, and only if the corresponding command-line flags\n      were set.  Otherwise, we free init_expr and return null.  */\n   switch (sym->ts.type)\n-    {    \n+    {\n     case BT_INTEGER:\n       if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)\n-\tmpz_set_si (init_expr->value.integer, \n+\tmpz_set_si (init_expr->value.integer,\n \t\t\t gfc_option.flag_init_integer_value);\n       else\n \t{\n@@ -10421,7 +10821,7 @@ build_default_init_expr (gfc_symbol *sym)\n \t  break;\n \t}\n       break;\n-\t  \n+\n     case BT_COMPLEX:\n       switch (gfc_option.flag_init_real)\n \t{\n@@ -10453,7 +10853,7 @@ build_default_init_expr (gfc_symbol *sym)\n \t  break;\n \t}\n       break;\n-\t  \n+\n     case BT_LOGICAL:\n       if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)\n \tinit_expr->value.logical = 0;\n@@ -10465,9 +10865,9 @@ build_default_init_expr (gfc_symbol *sym)\n \t  init_expr = NULL;\n \t}\n       break;\n-\t  \n+\n     case BT_CHARACTER:\n-      /* For characters, the length must be constant in order to \n+      /* For characters, the length must be constant in order to\n \t create a default initializer.  */\n       if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON\n \t  && sym->ts.u.cl->length\n@@ -10506,7 +10906,7 @@ build_default_init_expr (gfc_symbol *sym)\n \t  init_expr->value.function.actual = arg;\n \t}\n       break;\n-\t  \n+\n     default:\n      gfc_free_expr (init_expr);\n      init_expr = NULL;\n@@ -10534,7 +10934,7 @@ apply_default_init_local (gfc_symbol *sym)\n   /* For saved variables, we don't want to add an initializer at function\n      entry, so we just add a static initializer. Note that automatic variables\n      are stack allocated even with -fno-automatic.  */\n-  if (sym->attr.save || sym->ns->save_all \n+  if (sym->attr.save || sym->ns->save_all\n       || (gfc_option.flag_max_stack_var_size == 0\n \t  && (!sym->attr.dimension || !is_non_constant_shape_array (sym))))\n     {\n@@ -10639,7 +11039,7 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t  return FAILURE;\n \t}\n     }\n-    \n+\n   return SUCCESS;\n }\n \n@@ -11075,7 +11475,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n           sym->attr.is_c_interop = 1;\n           sym->ts.is_c_interop = 1;\n         }\n-      \n+\n       curr_arg = sym->formal;\n       while (curr_arg != NULL)\n         {\n@@ -11087,7 +11487,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t BIND(C) to try and prevent multiple errors being\n \t\t reported.  */\n \t      has_non_interop_arg = 1;\n-          \n+\n           curr_arg = curr_arg->next;\n         }\n \n@@ -11100,7 +11500,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t  sym->attr.is_bind_c = 0;\n \t}\n     }\n-  \n+\n   if (!sym->attr.proc_pointer)\n     {\n       if (sym->attr.save == SAVE_EXPLICIT)\n@@ -11251,7 +11651,7 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \t\t{\n \t\t  gfc_error (\"FINAL procedure '%s' declared at %L has the same\"\n \t\t\t     \" rank (%d) as '%s'\",\n-\t\t\t     list->proc_sym->name, &list->where, my_rank, \n+\t\t\t     list->proc_sym->name, &list->where, my_rank,\n \t\t\t     i->proc_sym->name);\n \t\t  goto error;\n \t\t}\n@@ -11337,7 +11737,7 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n   else if (t2->specific->pass_arg)\n     pass2 = t2->specific->pass_arg;\n   else\n-    pass2 = t2->specific->u.specific->n.sym->formal->sym->name;  \n+    pass2 = t2->specific->u.specific->n.sym->formal->sym->name;\n   if (gfc_compare_interfaces (sym1, sym2, sym2->name, !t1->is_operator, 0,\n \t\t\t      NULL, 0, pass1, pass2))\n     {\n@@ -11514,7 +11914,7 @@ resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n {\n   gfc_symbol* super_type;\n   gfc_tbp_generic* target;\n-  \n+\n   /* If there's already an error here, do nothing (but don't fail again).  */\n   if (p->error)\n     return SUCCESS;\n@@ -11548,7 +11948,7 @@ resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n \n       /* Add target to non-typebound operator list.  */\n       if (!target->specific->deferred && !derived->attr.use_assoc\n-\t  && p->access != ACCESS_PRIVATE && derived->ns == gfc_current_ns)\n+\t  && p->access != ACCESS_PRIVATE)\n \t{\n \t  gfc_interface *head, *intr;\n \t  if (gfc_check_new_interface (derived->ns->op[op], target_proc,\n@@ -11764,7 +12164,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t\t     me_arg->name, &where, resolve_bindings_derived->name);\n \t  goto error;\n \t}\n-  \n+\n       gcc_assert (me_arg->ts.type == BT_CLASS);\n       if (CLASS_DATA (me_arg)->as && CLASS_DATA (me_arg)->as->rank != 0)\n \t{\n@@ -11841,7 +12241,7 @@ resolve_typebound_procedures (gfc_symbol* derived)\n \n   if (!derived->f2k_derived || !derived->f2k_derived->tb_sym_root)\n     return SUCCESS;\n-  \n+\n   super_type = gfc_get_derived_super_type (derived);\n   if (super_type)\n     resolve_typebound_procedures (super_type);\n@@ -11934,7 +12334,7 @@ ensure_not_abstract (gfc_symbol* sub, gfc_symbol* ancestor)\n      clearer than something sophisticated.  */\n \n   gcc_assert (ancestor && !sub->attr.abstract);\n-  \n+\n   if (!ancestor->attr.abstract)\n     return SUCCESS;\n \n@@ -11956,6 +12356,43 @@ ensure_not_abstract (gfc_symbol* sub, gfc_symbol* ancestor)\n }\n \n \n+/* This check for typebound defined assignments is done recursively\n+   since the order in which derived types are resolved is not always in\n+   order of the declarations.  */\n+\n+static void\n+check_defined_assignments (gfc_symbol *derived)\n+{\n+  gfc_component *c;\n+\n+  for (c = derived->components; c; c = c->next)\n+    {\n+      if (c->ts.type != BT_DERIVED\n+\t  || c->attr.pointer\n+\t  || c->attr.allocatable\n+\t  || c->attr.proc_pointer_comp\n+\t  || c->attr.class_pointer\n+\t  || c->attr.proc_pointer)\n+\tcontinue;\n+\n+      if (c->ts.u.derived->attr.defined_assign_comp\n+\t  || (c->ts.u.derived->f2k_derived\n+\t     && c->ts.u.derived->f2k_derived->tb_op[INTRINSIC_ASSIGN]))\n+\t{\n+\t  derived->attr.defined_assign_comp = 1;\n+\t  return;\n+\t}\n+\n+      check_defined_assignments (c->ts.u.derived);\n+      if (c->ts.u.derived->attr.defined_assign_comp)\n+\t{\n+\t  derived->attr.defined_assign_comp = 1;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+\n /* Resolve the components of a derived type. This does not have to wait until\n    resolution stage, but can be done as soon as the dt declaration has been\n    parsed.  */\n@@ -12069,7 +12506,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t\t  c->attr.class_ok = ifc->result->attr.class_ok;\n \t\t}\n \t      else\n-\t\t{   \n+\t\t{\n \t\t  c->ts = ifc->ts;\n \t\t  c->attr.allocatable = ifc->attr.allocatable;\n \t\t  c->attr.pointer = ifc->attr.pointer;\n@@ -12232,7 +12669,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      || (!sym->attr.is_class && c == sym->components))\n \t  && strcmp (super_type->name, c->name) == 0)\n \tc->attr.access = super_type->attr.access;\n-      \n+\n       /* If this type is an extension, see if this component has the same name\n \t as an inherited type-bound procedure.  */\n       if (super_type && !sym->attr.is_class\n@@ -12353,6 +12790,12 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \treturn FAILURE;\n     }\n \n+  check_defined_assignments (sym);\n+\n+  if (!sym->attr.defined_assign_comp && super_type)\n+    sym->attr.defined_assign_comp\n+\t\t\t= super_type->attr.defined_assign_comp;\n+\n   /* If this is a non-ABSTRACT type extending an ABSTRACT one, ensure that\n      all DEFERRED bindings are overridden.  */\n   if (super_type && super_type->attr.abstract && !sym->attr.abstract\n@@ -12397,7 +12840,7 @@ resolve_fl_derived (gfc_symbol *sym)\n   /* Resolve the finalizer procedures.  */\n   if (gfc_resolve_finalizers (sym) == FAILURE)\n     return FAILURE;\n-  \n+\n   if (sym->attr.is_class && sym->ts.u.derived == NULL)\n     {\n       /* Fix up incomplete CLASS symbols.  */\n@@ -12410,10 +12853,10 @@ resolve_fl_derived (gfc_symbol *sym)\n \t  vptr->ts.u.derived = vtab->ts.u.derived;\n \t}\n     }\n-  \n+\n   if (resolve_fl_derived0 (sym) == FAILURE)\n     return FAILURE;\n-  \n+\n   /* Resolve the type-bound procedures.  */\n   if (resolve_typebound_procedures (sym) == FAILURE)\n     return FAILURE;\n@@ -12564,7 +13007,7 @@ static gfc_try\n resolve_fl_parameter (gfc_symbol *sym)\n {\n   /* A parameter array's shape needs to be constant.  */\n-  if (sym->as != NULL \n+  if (sym->as != NULL\n       && (sym->as->type == AS_DEFERRED\n           || is_non_constant_shape_array (sym)))\n     {\n@@ -12686,8 +13129,8 @@ resolve_symbol (gfc_symbol *sym)\n      can.  */\n   mp_flag = (sym->result != NULL && sym->result != sym);\n \n-  /* Make sure that the intrinsic is consistent with its internal \n-     representation. This needs to be done before assigning a default \n+  /* Make sure that the intrinsic is consistent with its internal\n+     representation. This needs to be done before assigning a default\n      type to avoid spurious warnings.  */\n   if (sym->attr.flavor != FL_MODULE && sym->attr.intrinsic\n       && gfc_resolve_intrinsic (sym, &sym->declared_at) == FAILURE)\n@@ -12854,7 +13297,7 @@ resolve_symbol (gfc_symbol *sym)\n     }\n \n   if (sym->ts.type == BT_ASSUMED)\n-    { \n+    {\n       /* TS 29113, C407a.  */\n       if (!sym->attr.dummy)\n \t{\n@@ -12898,7 +13341,7 @@ resolve_symbol (gfc_symbol *sym)\n       sym->attr.flavor != FL_PROCEDURE && sym->attr.flavor != FL_DERIVED)\n     {\n       gfc_try t = SUCCESS;\n-      \n+\n       /* First, make sure the variable is declared at the\n \t module-level scope (J3/04-007, Section 15.3).\t*/\n       if (sym->ns->proc_name->attr.flavor != FL_MODULE &&\n@@ -12928,7 +13371,7 @@ resolve_symbol (gfc_symbol *sym)\n                 verify_bind_c_derived_type (sym->ts.u.derived);\n               t = FAILURE;\n             }\n-\t  \n+\n \t  /* Verify the variable itself as C interoperable if it\n              is BIND(C).  It is not possible for this to succeed if\n              the verify_bind_c_derived_type failed, so don't have to handle\n@@ -13704,12 +14147,12 @@ gfc_implicit_pure (gfc_symbol *sym)\n \t  sym = ns->proc_name;\n \t  if (sym == NULL)\n \t    return 0;\n-\t  \n+\n \t  if (sym->attr.flavor == FL_PROCEDURE)\n \t    break;\n \t}\n     }\n-  \n+\n   return sym->attr.flavor == FL_PROCEDURE && sym->attr.implicit_pure\n     && !sym->attr.pure;\n }\n@@ -13880,7 +14323,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n }\n \n \n-/* Resolve equivalence object. \n+/* Resolve equivalence object.\n    An EQUIVALENCE object shall not be a dummy argument, a pointer, a target,\n    an allocatable array, an object of nonsequence derived type, an object of\n    sequence derived type containing a pointer at any level of component\n@@ -14410,6 +14853,7 @@ gfc_resolve (gfc_namespace *ns)\n   old_cs_base = cs_base;\n \n   resolve_types (ns);\n+  component_assignment_level = 0;\n   resolve_codes (ns);\n \n   gfc_current_ns = old_ns;"}, {"sha": "38193deb82e5085dd285118d0737f0e4acf2507f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -1,3 +1,13 @@\n+2012-12-01   Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n+             Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/46897\n+\t* gfortran.dg/defined_assignment_1.f90: New test.\n+\t* gfortran.dg/defined_assignment_2.f90: New test.\n+\t* gfortran.dg/defined_assignment_3.f90: New test.\n+\t* gfortran.dg/defined_assignment_4.f90: New test.\n+\t* gfortran.dg/defined_assignment_5.f90: New test.\n+\n 2012-12-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/55542"}, {"sha": "da06f26d1910ce159ff2d86caba41787e473191e", "filename": "gcc/testsuite/gfortran.dg/defined_assignment_1.f90", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_1.f90?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do run }\n+! Test the fix for PR46897.\n+!\n+! Contributed by Rouson Damian <rouson@sandia.gov>\n+!\n+module m0\n+  implicit none\n+  type component\n+    integer :: i = 0\n+  contains\n+    procedure :: assign0\n+    generic :: assignment(=)=>assign0\n+  end type\n+  type parent\n+    type(component) :: foo\n+  end type\n+  type, extends(parent) :: child\n+    integer :: j\n+  end type\n+contains\n+  subroutine assign0(lhs,rhs)\n+    class(component), intent(out) :: lhs\n+    class(component), intent(in) :: rhs\n+    lhs%i = 20\n+  end subroutine \n+  type(child) function new_child()\n+  end function\n+end module \n+\n+module m1\n+  implicit none\n+  type component1\n+    integer :: i = 1\n+  contains\n+    procedure :: assign1\n+    generic :: assignment(=)=>assign1\n+  end type\n+  type t\n+    type(component1) :: foo\n+  end type\n+contains\n+  subroutine assign1(lhs,rhs)\n+    class(component1), intent(out) :: lhs\n+    class(component1), intent(in) :: rhs\n+    lhs%i = 21\n+  end subroutine\n+end module\n+\n+module m2\n+  implicit none\n+  type component2\n+    integer :: i = 2\n+  end type\n+  interface assignment(=)\n+    module procedure assign2\n+  end interface\n+  type t2\n+    type(component2) :: foo\n+  end type\n+contains\n+  subroutine assign2(lhs,rhs)\n+    type(component2), intent(out) :: lhs\n+    type(component2), intent(in) :: rhs\n+    lhs%i = 22\n+  end subroutine\n+end module \n+\n+program main\n+  use m0\n+  use m1\n+  use m2\n+  implicit none\n+  type(child) :: infant0\n+  type(t) :: infant1, newchild1\n+  type(t2) :: infant2, newchild2\n+\n+! Test the reported problem.\n+  infant0 = new_child()\n+  if (infant0%parent%foo%i .ne. 20) call abort\n+\n+! Test the case of comment #1 of the PR.\n+  infant1 = newchild1\n+  if (infant1%foo%i .ne. 21) call abort\n+\n+! Test the case of comment #2 of the PR.\n+  infant2 = newchild2\n+  if (infant2%foo%i .ne. 2) call abort\n+end\n+\n+"}, {"sha": "78f2abb22fee6d9e3f35e7bb05c350a3289aa5a3", "filename": "gcc/testsuite/gfortran.dg/defined_assignment_2.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_2.f90?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do run }\n+! Test the fix for PR46897. defined_assignment_1.f90 checks that the PR\n+! testcases run correctly, this checks that other requirements of the\n+! standard are satisfied.\n+!\n+module m0\n+  implicit none\n+  type component\n+    integer :: i = 0\n+    integer, allocatable :: j(:)\n+  contains\n+    procedure :: assign0\n+    generic :: assignment(=)=>assign0\n+  end type\n+  type parent\n+    type(component) :: foo1\n+  end type\n+  type, extends(parent) :: child\n+    integer :: k = 1000\n+    integer, allocatable :: l(:)\n+    type(component) :: foo2\n+  end type\n+contains\n+  subroutine assign0(lhs,rhs)\n+    class(component), intent(inout) :: lhs\n+    class(component), intent(in) :: rhs\n+    if (lhs%i .eq. 0) then\n+      lhs%i = rhs%i\n+      lhs%j = rhs%j\n+    else\n+      lhs%i = rhs%i*2\n+      lhs%j = [rhs%j, rhs%j*2]\n+    end if\n+  end subroutine\n+  type(child) function new_child()\n+    new_child%parent%foo1%i = 20\n+    new_child%foo2%i = 21\n+    new_child%parent%foo1%j = [99,199]\n+    new_child%foo2%j = [199,299]\n+    new_child%l = [299,399]\n+    new_child%k = 1001\n+  end function\n+end module\n+\n+program main\n+  use m0\n+  implicit none\n+  type(child) :: infant0\n+\n+! Check that the INTENT(INOUT) of assign0 is respected and that the\n+! correct thing is done with allocatable components.\n+  infant0 = new_child()\n+  if (infant0%parent%foo1%i .ne. 20) call abort\n+  if (infant0%foo2%i .ne. 21) call abort\n+  if (any (infant0%parent%foo1%j .ne. [99,199])) call abort\n+  if (any (infant0%foo2%j .ne. [199,299])) call abort\n+  if (infant0%foo2%i .ne. 21) call abort\n+  if (any (infant0%l .ne. [299,399])) call abort\n+\n+! Now, since the defined assignment depends on whether or not the 'i'\n+! component is the default initialization value, the result will be\n+! different.\n+  infant0 = new_child()\n+  if (infant0%parent%foo1%i .ne. 40) call abort\n+  if (any (infant0%parent%foo1%j .ne. [99,199,198,398])) call abort\n+  if (any (infant0%foo2%j .ne. [199,299,398,598])) call abort\n+  if (infant0%foo2%i .ne. 42) call abort\n+  if (any (infant0%l .ne. [299,399])) call abort\n+\n+! Finally, make sure that normal components of the declared type survive.\n+  if (infant0%k .ne. 1001) call abort\n+end\n+\n+"}, {"sha": "81a9841434fd49d3479b7ce733a9c30566e1faf1", "filename": "gcc/testsuite/gfortran.dg/defined_assignment_3.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_3.f90?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! Test the fix for PR46897. defined_assignment_1.f90 checks that the PR\n+! testcases run correctly, this checks array components are OK.\n+!\n+module m0\n+  implicit none\n+  type component\n+    integer :: i = 0\n+  contains\n+    procedure :: assign0\n+    generic :: assignment(=)=>assign0\n+  end type\n+  type parent\n+    type(component) :: foo(2)\n+  end type\n+  type, extends(parent) :: child\n+    integer :: j\n+  end type\n+contains\n+  elemental subroutine assign0(lhs,rhs)\n+    class(component), intent(out) :: lhs\n+    class(component), intent(in) :: rhs\n+    lhs%i = 20\n+  end subroutine\n+end module\n+\n+\n+program main\n+  use m0\n+  implicit none\n+  type(child) :: infant0, infant1(2)\n+\n+  infant0 = child([component(1),component(2)], 99)\n+  if (any (infant0%parent%foo%i .ne. [20, 20])) call abort\n+\n+end\n+\n+"}, {"sha": "e7a1b8e0f6427cc2c1ece421fd676085e59c0985", "filename": "gcc/testsuite/gfortran.dg/defined_assignment_4.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_4.f90?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+! Test the fix for PR46897. First patch did not run this case correctly.\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module a_mod\n+  type :: a\n+    integer :: i = 99\n+  contains\n+     procedure :: a_ass\n+     generic :: assignment(=) => a_ass\n+  end type a\n+\n+  type c\n+    type(a) :: ta\n+  end type c\n+\n+  type :: b\n+    type(c) :: tc\n+  end type b\n+\n+contains\n+  elemental subroutine a_ass(out, in)\n+    class(a), intent(INout) :: out\n+    type(a), intent(in)  :: in\n+      out%i = 2*in%i\n+  end subroutine a_ass\n+end module a_mod\n+\n+program assign\n+  use a_mod\n+  type(b) :: tt\n+  type(b) :: tb1\n+  tt = tb1\n+  if (tt%tc%ta%i .ne. 198) call abort\n+end program assign"}, {"sha": "faf38298e4267fab03fdd12cb0f639e692324991", "filename": "gcc/testsuite/gfortran.dg/defined_assignment_5.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d382327d5f1ec35b8f5c58d0c3a924ae09bda22/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefined_assignment_5.f90?ref=4d382327d5f1ec35b8f5c58d0c3a924ae09bda22", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do run }\n+! Further test of typebound defined assignment\n+!\n+module m0\n+  implicit none\n+  type component\n+    integer :: i = 0\n+  contains\n+    procedure :: assign0\n+    generic :: assignment(=)=>assign0\n+  end type\n+  type parent\n+    type(component) :: foo(2)\n+  end type\n+  type, extends(parent) :: child\n+    integer :: j\n+  end type\n+contains\n+  elemental subroutine assign0(lhs,rhs)\n+    class(component), intent(INout) :: lhs\n+    class(component), intent(in) :: rhs\n+    lhs%i = 20\n+  end subroutine\n+end module\n+\n+module m1\n+  implicit none\n+  type component1\n+    integer :: i = 0\n+  contains\n+    procedure :: assign1\n+    generic :: assignment(=)=>assign1\n+  end type\n+  type parent1\n+    type(component1) :: foo\n+  end type\n+  type, extends(parent1) :: child1\n+    integer :: j = 7\n+  end type\n+contains\n+  elemental subroutine assign1(lhs,rhs)\n+    class(component1), intent(out) :: lhs\n+    class(component1), intent(in) :: rhs\n+    lhs%i = 30\n+  end subroutine\n+end module\n+\n+\n+program main\n+  use m0\n+  use m1\n+  implicit none\n+  type(child) :: infant(2)\n+  type(parent) :: dad, mum\n+  type(child1) :: orphan(5)\n+  type(child1), allocatable :: annie(:)\n+  integer :: i, j, k\n+\n+  dad = parent ([component (3), component (4)])\n+  mum = parent ([component (5), component (6)])\n+  infant = [child(dad, 999), child(mum, 9999)]  ! { dg-warning \"multiple part array references\" }\n+\n+! Check that array sections are OK\n+  i = 3\n+  j = 4\n+  orphan(i:j) = child1(component1(777), 1)\n+  if (any (orphan%parent1%foo%i .ne. [0,0,30,30,0])) call abort\n+  if (any (orphan%j .ne. [7,7,1,1,7])) call abort\n+\n+! Check that allocatable lhs's work OK.\n+  annie = [(child1(component1(k), 2*k), k = 1,3)]\n+  if (any (annie%parent1%foo%i .ne. [30,30,30])) call abort\n+  if (any (annie%j .ne. [2,4,6])) call abort\n+end\n+\n+"}]}