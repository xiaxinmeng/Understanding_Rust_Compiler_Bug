{"sha": "1fe37220afe33a180e8fcfaae485fe878a62938e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZlMzcyMjBhZmUzM2ExODBlOGZjZmFhZTQ4NWZlODc4YTYyOTM4ZQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-11-17T16:14:46Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-11-17T16:14:46Z"}, "message": "gimple.h: Reorder prototypes to match .c declaration order...\n\n\n\n\t* gimple.h: Reorder prototypes to match .c declaration order, and remove\n\tprotyotypes for functions not in gimple.c.\n\t(LABEL): Move to tree-into-ssa.c.\n\t* gimple.c: Remove unused prototypes.\n\t(get_base_address): Move to tree.c.\n\t* tree.c (get_base_address): Relocate from gimple.c.\n\t* builtins.h (validate_gimple_arglist): Add prototype.\n\t* trans-mem.h (compute_transaction_bits, is_tm_ending): Add prototype.\n\t* cfgexpand.h: New File.\n\t(gimple_assign_rhs_to_tree, estimated_stack_frame_size): Add protoype.\n\t* tree.h (build_addr): Move to tree-nested.h.\n\t* tree-nested.h: New File.\n\t(build_addr, lower_nested_functions, insert_field_into_struct): Add\n\tprototypes.\n\t* tree-inline.h (estimated_stack_frame_size): Remove prototype.\n\t* ipa-inline-analysis.c: Include cfgexpand.h.\n\t* cgraphunit.c: Include tree-nested.h.\n\t* omp-low.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* gimple-low.h: Likewise.\n\t* tree-profile.h: Likewise.\n\t* expr.c: Include cfgexpand.h.\n\t* tree-affine.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-ssa-loop-im.c: Include trans-mem.h.\n\t* tree-ssa-tail-merge.c: Likewise.\n\t* value-prof.c: Include builtins.h and tree-nested.h.\n\t* tree-into-ssa.c (LABEL): Define here.\n\n\t* fortran/trans-intrinsic.c: Include tree-nested.h.\n\nFrom-SVN: r204919", "tree": {"sha": "86e0ab203b8850bdf532fcbf7bc776dcbb9acde7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86e0ab203b8850bdf532fcbf7bc776dcbb9acde7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fe37220afe33a180e8fcfaae485fe878a62938e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe37220afe33a180e8fcfaae485fe878a62938e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fe37220afe33a180e8fcfaae485fe878a62938e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe37220afe33a180e8fcfaae485fe878a62938e/comments", "author": null, "committer": null, "parents": [{"sha": "fd4da58cd8bee25149f50a249073b20487b5bb41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4da58cd8bee25149f50a249073b20487b5bb41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd4da58cd8bee25149f50a249073b20487b5bb41"}], "stats": {"total": 293, "additions": 177, "deletions": 116}, "files": [{"sha": "0edc5879cbdc8b0a034b911057d56d2013d25cfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -1,3 +1,34 @@\n+2013-11-17  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* gimple.h: Reorder prototypes to match .c declaration order, and remove\n+\tprotyotypes for functions not in gimple.c.\n+\t(LABEL): Move to tree-into-ssa.c.\n+\t* gimple.c: Remove unused prototypes.\n+\t(get_base_address): Move to tree.c.\n+\t* tree.c (get_base_address): Relocate from gimple.c.\n+\t* builtins.h (validate_gimple_arglist): Add prototype.\n+\t* trans-mem.h (compute_transaction_bits, is_tm_ending): Add prototype.\n+\t* cfgexpand.h: New File.\n+\t(gimple_assign_rhs_to_tree, estimated_stack_frame_size): Add protoype.\n+\t* tree.h (build_addr): Move to tree-nested.h.\n+\t* tree-nested.h: New File.\n+\t(build_addr, lower_nested_functions, insert_field_into_struct): Add\n+\tprototypes.\n+\t* tree-inline.h (estimated_stack_frame_size): Remove prototype.\n+\t* ipa-inline-analysis.c: Include cfgexpand.h.\n+\t* cgraphunit.c: Include tree-nested.h.\n+\t* omp-low.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* gimple-low.h: Likewise.\n+\t* tree-profile.h: Likewise.\n+\t* expr.c: Include cfgexpand.h.\n+\t* tree-affine.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-ssa-loop-im.c: Include trans-mem.h.\n+\t* tree-ssa-tail-merge.c: Likewise.\n+\t* value-prof.c: Include builtins.h and tree-nested.h.\n+\t* tree-into-ssa.c (LABEL): Define here.\n+\n 2013-11-16  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* config/arc/arc.c (arc_predicate_delay_insns): New function."}, {"sha": "0ed9479bdbf9e4c47d5c8befaa72129ca3790137", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -44,4 +44,6 @@ extern struct target_builtins *this_target_builtins;\n #define this_target_builtins (&default_target_builtins)\n #endif\n \n+extern bool validate_gimple_arglist (const_gimple, ...);\n+\n #endif"}, {"sha": "04517a3e3f926854d55beb434a125ccd50182a8e", "filename": "gcc/cfgexpand.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fcfgexpand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fcfgexpand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -0,0 +1,26 @@\n+/* Header file for lowering trees to RTL.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CFGEXPAND_H\n+#define GCC_CFGEXPAND_H\n+\n+extern tree gimple_assign_rhs_to_tree (gimple);\n+extern HOST_WIDE_INT estimated_stack_frame_size (struct cgraph_node *);\n+\n+#endif /* GCC_CFGEXPAND_H */"}, {"sha": "863b81e72c0ceeafbb7a33ead42e5262f9c2ca81", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -201,6 +201,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regset.h\"     /* FIXME: For reg_obstack.  */\n #include \"context.h\"\n #include \"pass_manager.h\"\n+#include \"tree-nested.h\"\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that"}, {"sha": "e8c022c45eb3eb5fc7d6474ecbe55fc5ae852064", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target-globals.h\"\n #include \"params.h\"\n #include \"tree-ssa-address.h\"\n+#include \"cfgexpand.h\"\n \n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first."}, {"sha": "16e8915c0c58f292c26843ef32542b7a432aa322", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -1,3 +1,7 @@\n+2013-11-17  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* fortran/trans-intrinsic.c: Include tree-nested.h.\n+\n 2013-11-14  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* trans-expr.c: Include only gimplify.h and gimple.h as needed."}, {"sha": "042911f8ea1d897d67d51acd9f46918ff24aae82", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-array.h\"\n /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */\n #include \"trans-stmt.h\"\n+#include \"tree-nested.h\"\n \n /* This maps Fortran intrinsic math functions to external library or GCC\n    builtin functions.  */"}, {"sha": "3f9ac575e64f58ad94ad93f396a8d76ed014d7d6", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"langhooks.h\"\n #include \"gimple-low.h\"\n+#include \"tree-nested.h\"\n \n /* The differences between High GIMPLE and Low GIMPLE are the\n    following:"}, {"sha": "f42d921fa0f3f424309f3dcd7927c459af2faded", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -84,11 +84,6 @@ static const char * const gimple_alloc_kind_names[] = {\n     \"everything else\"\n };\n \n-/* Private API manipulation functions shared only with some\n-   other files.  */\n-extern void gimple_set_stored_syms (gimple, bitmap, bitmap_obstack *);\n-extern void gimple_set_loaded_syms (gimple, bitmap, bitmap_obstack *);\n-\n /* Gimple tuple constructors.\n    Note: Any constructor taking a ``gimple_seq'' as a parameter, can\n    be passed a NULL to start with an empty sequence.  */\n@@ -1958,34 +1953,6 @@ const unsigned char gimple_rhs_class_table[] = {\n #undef DEFTREECODE\n #undef END_OF_BASE_TREE_CODES\n \n-/* Given a memory reference expression T, return its base address.\n-   The base address of a memory reference expression is the main\n-   object being referenced.  For instance, the base address for\n-   'array[i].fld[j]' is 'array'.  You can think of this as stripping\n-   away the offset part from a memory address.\n-\n-   This function calls handled_component_p to strip away all the inner\n-   parts of the memory reference until it reaches the base object.  */\n-\n-tree\n-get_base_address (tree t)\n-{\n-  while (handled_component_p (t))\n-    t = TREE_OPERAND (t, 0);\n-\n-  if ((TREE_CODE (t) == MEM_REF\n-       || TREE_CODE (t) == TARGET_MEM_REF)\n-      && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n-    t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-\n-  /* ???  Either the alias oracle or all callers need to properly deal\n-     with WITH_SIZE_EXPRs before we can look through those.  */\n-  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n-    return NULL_TREE;\n-\n-  return t;\n-}\n-\n void\n recalculate_side_effects (tree t)\n {"}, {"sha": "022bac93aaf290cd9106514658069509e1c34da9", "filename": "gcc/gimple.h", "status": "modified", "additions": 41, "deletions": 78, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -727,32 +727,26 @@ extern enum gimple_statement_structure_enum const gss_for_code_[];\n    of comminucating the profile info to the builtin expanders.  */\n extern gimple currently_expanding_gimple_stmt;\n \n+#define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n+gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n gimple gimple_build_return (tree);\n-\n-gimple gimple_build_assign_stat (tree, tree MEM_STAT_DECL);\n-#define gimple_build_assign(l,r) gimple_build_assign_stat (l, r MEM_STAT_INFO)\n-\n-gimple\n-gimple_build_assign_with_ops (enum tree_code, tree,\n-\t\t\t      tree, tree CXX_MEM_STAT_INFO);\n-gimple\n-gimple_build_assign_with_ops (enum tree_code, tree,\n-\t\t\t      tree, tree, tree CXX_MEM_STAT_INFO);\n-\n-gimple gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n-#define gimple_build_debug_bind(var,val,stmt)\t\t\t\\\n-  gimple_build_debug_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n-gimple gimple_build_debug_source_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n-#define gimple_build_debug_source_bind(var,val,stmt)\t\t\t\\\n-  gimple_build_debug_source_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n-\n+void gimple_call_reset_alias_info (gimple);\n gimple gimple_build_call_vec (tree, vec<tree> );\n gimple gimple_build_call (tree, unsigned, ...);\n gimple gimple_build_call_valist (tree, unsigned, va_list);\n gimple gimple_build_call_internal (enum internal_fn, unsigned, ...);\n gimple gimple_build_call_internal_vec (enum internal_fn, vec<tree> );\n gimple gimple_build_call_from_tree (tree);\n+extern unsigned gimple_call_get_nobnd_arg_index (const_gimple, unsigned);\n+gimple gimple_build_assign_stat (tree, tree MEM_STAT_DECL);\n+#define gimple_build_assign(l,r) gimple_build_assign_stat (l, r MEM_STAT_INFO)\n+gimple gimple_build_assign_with_ops (enum tree_code, tree,\n+\t\t\t\t     tree, tree, tree CXX_MEM_STAT_INFO);\n+gimple gimple_build_assign_with_ops (enum tree_code, tree,\n+\t\t\t\t     tree, tree CXX_MEM_STAT_INFO);\n gimple gimple_build_cond (enum tree_code, tree, tree, tree, tree);\n+gimple gimple_build_cond_from_tree (tree, tree, tree);\n+void gimple_cond_set_condition_from_tree (gimple, tree);\n gimple gimple_build_label (tree label);\n gimple gimple_build_goto (tree dest);\n gimple gimple_build_nop (void);\n@@ -767,39 +761,46 @@ gimple gimple_build_eh_else (gimple_seq, gimple_seq);\n gimple gimple_build_try (gimple_seq, gimple_seq, enum gimple_try_flags);\n gimple gimple_build_wce (gimple_seq);\n gimple gimple_build_resx (int);\n-gimple gimple_build_eh_dispatch (int);\n gimple gimple_build_switch_nlabels (unsigned, tree, tree);\n gimple gimple_build_switch (tree, tree, vec<tree> );\n+gimple gimple_build_eh_dispatch (int);\n+gimple gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n+#define gimple_build_debug_bind(var,val,stmt)\t\t\t\\\n+  gimple_build_debug_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n+gimple gimple_build_debug_source_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n+#define gimple_build_debug_source_bind(var,val,stmt)\t\t\t\\\n+  gimple_build_debug_source_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n+gimple gimple_build_omp_critical (gimple_seq, tree);\n+gimple gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n gimple gimple_build_omp_parallel (gimple_seq, tree, tree, tree);\n gimple gimple_build_omp_task (gimple_seq, tree, tree, tree, tree, tree, tree);\n-gimple gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n-gimple gimple_build_omp_critical (gimple_seq, tree);\n gimple gimple_build_omp_section (gimple_seq);\n-gimple gimple_build_omp_continue (tree, tree);\n gimple gimple_build_omp_master (gimple_seq);\n gimple gimple_build_omp_taskgroup (gimple_seq);\n-gimple gimple_build_omp_return (bool);\n+gimple gimple_build_omp_continue (tree, tree);\n gimple gimple_build_omp_ordered (gimple_seq);\n+gimple gimple_build_omp_return (bool);\n gimple gimple_build_omp_sections (gimple_seq, tree);\n gimple gimple_build_omp_sections_switch (void);\n gimple gimple_build_omp_single (gimple_seq, tree);\n gimple gimple_build_omp_target (gimple_seq, int, tree);\n gimple gimple_build_omp_teams (gimple_seq, tree);\n-gimple gimple_build_cdt (tree, tree);\n gimple gimple_build_omp_atomic_load (tree, tree);\n gimple gimple_build_omp_atomic_store (tree);\n gimple gimple_build_transaction (gimple_seq, tree);\n gimple gimple_build_predict (enum br_predictor, enum prediction);\n-enum gimple_statement_structure_enum gss_for_assign (enum tree_code);\n-gimple_seq gimple_seq_alloc (void);\n-void gimple_seq_free (gimple_seq);\n+extern void gimple_seq_add_stmt (gimple_seq *, gimple);\n+extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n+extern void annotate_all_with_location_after (gimple_seq, gimple_stmt_iterator,\n+\t\t\t\t\t      location_t);\n+extern void annotate_all_with_location (gimple_seq, location_t);\n+bool empty_body_p (gimple_seq);\n gimple_seq gimple_seq_copy (gimple_seq);\n bool gimple_call_same_target_p (const_gimple, const_gimple);\n int gimple_call_flags (const_gimple);\n-int gimple_call_return_flags (const_gimple);\n int gimple_call_arg_flags (const_gimple, unsigned);\n-void gimple_call_reset_alias_info (gimple);\n+int gimple_call_return_flags (const_gimple);\n bool gimple_assign_copy_p (gimple);\n bool gimple_assign_ssa_name_copy_p (gimple);\n bool gimple_assign_unary_nop_p (gimple);\n@@ -809,35 +810,31 @@ void gimple_assign_set_rhs_with_ops_1 (gimple_stmt_iterator *, enum tree_code,\n \t\t\t\t       tree, tree, tree);\n tree gimple_get_lhs (const_gimple);\n void gimple_set_lhs (gimple, tree);\n-void gimple_replace_lhs (gimple, tree);\n gimple gimple_copy (gimple);\n-gimple gimple_build_cond_from_tree (tree, tree, tree);\n-void gimple_cond_set_condition_from_tree (gimple, tree);\n bool gimple_has_side_effects (const_gimple);\n-bool gimple_could_trap_p (gimple);\n bool gimple_could_trap_p_1 (gimple, bool, bool);\n+bool gimple_could_trap_p (gimple);\n bool gimple_assign_rhs_could_trap_p (gimple);\n-bool empty_body_p (gimple_seq);\n-extern void annotate_all_with_location_after (gimple_seq, gimple_stmt_iterator,\n-\t\t\t\t\t      location_t);\n-extern void annotate_all_with_location (gimple_seq, location_t);\n+extern void dump_gimple_statistics (void);\n unsigned get_gimple_rhs_num_ops (enum tree_code);\n-#define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n-gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n-\n-/* Return TRUE iff stmt is a call to a built-in function.  */\n-extern bool is_gimple_builtin_call (gimple stmt);\n-\n extern void recalculate_side_effects (tree);\n+extern tree canonicalize_cond_expr_cond (tree);\n+gimple gimple_call_copy_skip_args (gimple, bitmap);\n extern bool gimple_compare_field_offset (tree, tree);\n extern tree gimple_unsigned_type (tree);\n extern tree gimple_signed_type (tree);\n extern alias_set_type gimple_get_alias_set (tree);\n extern bool gimple_ior_addresses_taken (bitmap, gimple);\n+extern bool is_gimple_builtin_call (gimple stmt);\n extern bool gimple_call_builtin_p (gimple, enum built_in_class);\n extern bool gimple_call_builtin_p (gimple, enum built_in_function);\n extern bool gimple_asm_clobbers_memory_p (const_gimple);\n-extern unsigned gimple_call_get_nobnd_arg_index (const_gimple, unsigned);\n+extern void dump_decl_set (FILE *, bitmap);\n+extern bool nonfreeing_call_p (gimple);\n+extern bool infer_nonnull_range (gimple, tree);\n+extern void sort_case_labels (vec<tree> );\n+extern void preprocess_case_label_vec_for_gimple (vec<tree> , tree, tree *);\n+extern void gimple_seq_set_location (gimple_seq , location_t);\n \n /* Formal (expression) temporary table handling: multiple occurrences of\n    the same scalar expression are evaluated into the same temporary.  */\n@@ -869,27 +866,6 @@ inc_gimple_stmt_max_uid (struct function *fn)\n   return fn->last_stmt_uid++;\n }\n \n-/* Miscellaneous helpers.  */\n-extern tree canonicalize_cond_expr_cond (tree);\n-extern void dump_decl_set (FILE *, bitmap);\n-extern bool nonfreeing_call_p (gimple);\n-extern bool infer_nonnull_range (gimple, tree);\n-\n-/* In trans-mem.c.  */\n-extern void diagnose_tm_safe_errors (tree);\n-extern void compute_transaction_bits (void);\n-extern bool is_tm_ending (gimple);\n-\n-/* In tree-nested.c.  */\n-extern void lower_nested_functions (tree);\n-extern void insert_field_into_struct (tree, tree);\n-\n-/* In cfgexpand.c.  */\n-extern tree gimple_assign_rhs_to_tree (gimple);\n-\n-/* In builtins.c  */\n-extern bool validate_gimple_arglist (const_gimple, ...);\n-\n /* Return the first node in GIMPLE sequence S.  */\n \n static inline gimple_seq_node\n@@ -954,9 +930,6 @@ gimple_seq_empty_p (gimple_seq s)\n   return s == NULL;\n }\n \n-extern void gimple_seq_add_stmt (gimple_seq *, gimple);\n-extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple);\n-\n /* Allocate a new sequence and initialize its first element with STMT.  */\n \n static inline gimple_seq\n@@ -5123,8 +5096,6 @@ gimple_expr_type (const_gimple stmt)\n     return void_type_node;\n }\n \n-gimple gimple_call_copy_skip_args (gimple, bitmap);\n-\n /* Enum and arrays used for allocation stats.  Keep in sync with\n    gimple.c:gimple_alloc_kind_names.  */\n enum gimple_alloc_kind\n@@ -5156,8 +5127,6 @@ gimple_alloc_kind (enum gimple_code code)\n     }\n }\n \n-extern void dump_gimple_statistics (void);\n-\n /* Return true if a location should not be emitted for this statement\n    by annotate_all_with_location.  */\n \n@@ -5188,10 +5157,4 @@ gimple_set_do_not_emit_location (gimple g)\n \n #define LABEL(x) ((x) < 1024*10 ? 'b' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n \n-#define PERCENT(x,y) ((float)(x) * 100.0 / (float)(y))\n-\n-extern void sort_case_labels (vec<tree> );\n-extern void preprocess_case_label_vec_for_gimple (vec<tree> , tree, tree *);\n-extern void gimple_seq_set_location (gimple_seq , location_t);\n-\n #endif  /* GCC_GIMPLE_H */"}, {"sha": "52878b30957183362bbb242d31143cfc592515e7", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -97,6 +97,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"ipa-utils.h\"\n #include \"cilk.h\"\n+#include \"cfgexpand.h\"\n \n /* Estimate runtime of function can easilly run into huge numbers with many\n    nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE * 2 in an"}, {"sha": "8d5de21bd4bd0de5c585af2fb65badbfecea2933", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"tree-nested.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two"}, {"sha": "09f0b4d66e4d2e8a0ae11fe950285ef9e65594cb", "filename": "gcc/trans-mem.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftrans-mem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftrans-mem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -34,3 +34,6 @@\n #define PR_EXCEPTIONBLOCK\t0x1000\n #define PR_HASELSE\t\t0x2000\n #define PR_READONLY\t\t0x4000\n+\n+extern void compute_transaction_bits (void);\n+extern bool is_tm_ending (gimple);"}, {"sha": "25fd7f287e0e1414a6372f5fb994147573fb9e9c", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"flags.h\"\n #include \"dumpfile.h\"\n+#include \"cfgexpand.h\"\n \n /* Extends CST as appropriate for the affine combinations COMB.  */\n "}, {"sha": "50ccaab42fc3acd577cbbfe557636c4049ba5da7", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -202,6 +202,4 @@ extern tree remap_decl (tree decl, copy_body_data *id);\n extern tree remap_type (tree type, copy_body_data *id);\n extern gimple_seq copy_gimple_seq_and_replace_locals (gimple_seq seq);\n \n-extern HOST_WIDE_INT estimated_stack_frame_size (struct cgraph_node *);\n-\n #endif /* GCC_TREE_INLINE_H */"}, {"sha": "ee86f2cfa9ddd0e7aa79bf36155d85404b245233", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"tree-into-ssa.h\"\n \n+#define PERCENT(x,y) ((float)(x) * 100.0 / (float)(y))\n \n /* This file builds the SSA form for a function as described in:\n    R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K. Zadeck. Efficiently"}, {"sha": "bfaa65315d7768f685b2303576a8efcd3c641be7", "filename": "gcc/tree-nested.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-nested.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-nested.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -0,0 +1,27 @@\n+/* Header file for Nested function decomposition for GIMPLE.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_NESTED_H\n+#define GCC_TREE_NESTED_H\n+\n+extern tree build_addr (tree, tree);\n+extern void insert_field_into_struct (tree, tree);\n+extern void lower_nested_functions (tree);\n+\n+#endif /* GCC_TREE_NESTED_H */"}, {"sha": "648331cc767a3b0b1dc76d52a485c2a4bc9aade3", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-hasher.h\"\n #include \"tree-parloops.h\"\n #include \"omp-low.h\"\n+#include \"tree-nested.h\"\n \n /* This pass tries to distribute iterations of loops into several threads.\n    The implementation is straightforward -- for each loop we test whether its"}, {"sha": "132ce0d4d13957c9bf0b02d053d81b44cd7bcffb", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"profile.h\"\n #include \"target.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"tree-nested.h\"\n \n static GTY(()) tree gcov_type_node;\n static GTY(()) tree tree_interval_profiler_fn;"}, {"sha": "1c6113e6c638331d371bf280bd7afbbf8f99bd9e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-affine.h\"\n #include \"pointer-set.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"trans-mem.h\"\n \n /* TODO:  Support for predicated code motion.  I.e.\n "}, {"sha": "8d81f57daf54cd5c6f1b07f146482dff47efb043", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -209,6 +209,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n+#include \"trans-mem.h\"\n \n /* Describes a group of bbs with the same successors.  The successor bbs are\n    cached in succs, and the successor edge flags are cached in succ_flags."}, {"sha": "d2552361a66ed401e0bc4c39152c131f33334a75", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"diagnostic-core.h\"\n #include \"cfgloop.h\"\n+#include \"cfgexpand.h\"\n \n /* Pointer map of variable mappings, keyed by edge.  */\n static struct pointer_map_t *edge_var_maps;"}, {"sha": "34bc8ac73a54814611f5a631ba9f60ebdd1c5dc3", "filename": "gcc/tree.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -12267,4 +12267,32 @@ drop_tree_overflow (tree t)\n   return t;\n }\n \n+/* Given a memory reference expression T, return its base address.\n+   The base address of a memory reference expression is the main\n+   object being referenced.  For instance, the base address for\n+   'array[i].fld[j]' is 'array'.  You can think of this as stripping\n+   away the offset part from a memory address.\n+\n+   This function calls handled_component_p to strip away all the inner\n+   parts of the memory reference until it reaches the base object.  */\n+\n+tree\n+get_base_address (tree t)\n+{\n+  while (handled_component_p (t))\n+    t = TREE_OPERAND (t, 0);\n+\n+  if ((TREE_CODE (t) == MEM_REF\n+       || TREE_CODE (t) == TARGET_MEM_REF)\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n+    t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\n+  /* ???  Either the alias oracle or all callers need to properly deal\n+     with WITH_SIZE_EXPRs before we can look through those.  */\n+  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n+    return NULL_TREE;\n+\n+  return t;\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "bc6699dca98a6a214b7adbddad83e8fbde3be601", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -4597,9 +4597,6 @@ extern bool using_eh_for_cleanups_p (void);\n \n extern const char *get_tree_code_name (enum tree_code);\n \n-/* In tree-nested.c */\n-extern tree build_addr (tree, tree);\n-\n /* In function.c */\n extern void expand_function_end (void);\n extern void expand_function_start (tree);"}, {"sha": "ad70ceaea4ab9e719abbc93bf2ed1f8f32d66afa", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe37220afe33a180e8fcfaae485fe878a62938e/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=1fe37220afe33a180e8fcfaae485fe878a62938e", "patch": "@@ -51,6 +51,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"profile.h\"\n #include \"data-streamer.h\"\n+#include \"builtins.h\"\n+#include \"tree-nested.h\"\n \n /* In this file value profile based optimizations are placed.  Currently the\n    following optimizations are implemented (for more detailed descriptions"}]}