{"sha": "3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2ZGI3Zjg0ZGQ0ZGQ1MmViYzk0MzZiNDYyZjU5OWQ5ZmIwNTY0Yg==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2012-11-06T10:22:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T10:22:42Z"}, "message": "exp_attr.adb (Expand_N_Attribute_Reference): Apply a predicate check when evaluating the attribute Valid...\n\n2012-11-06  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Apply a predicate\n\tcheck when evaluating the attribute Valid, and issue a warning\n\tabout infinite recursion when the check occurs within the\n\tpredicate function of the prefix's subtype.\n\t* exp_ch4.adb (Expand_N_In): Remove test for Is_Discrete_Type\n\twhen we're checking that there's no predicate check function as a\n\tcondition for substituting a Valid check for a scalar membership\n\ttest (substitution should be suppressed for any kind of scalar\n\tsubtype with a predicate check). Also, don't emit a predicate\n\tcheck when the right operand is a range.\n\nFrom-SVN: r193228", "tree": {"sha": "b41ad66af2ac765d8c0d188a4f2e96c2fe27d1f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b41ad66af2ac765d8c0d188a4f2e96c2fe27d1f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "150ac76e0e29ec57850fca545b0e26530adf9adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150ac76e0e29ec57850fca545b0e26530adf9adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150ac76e0e29ec57850fca545b0e26530adf9adc"}], "stats": {"total": 47, "additions": 45, "deletions": 2}, "files": [{"sha": "7493c6d61a0ae54b25f7996cc2578bfec1494da3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "patch": "@@ -1,3 +1,16 @@\n+2012-11-06  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Apply a predicate\n+\tcheck when evaluating the attribute Valid, and issue a warning\n+\tabout infinite recursion when the check occurs within the\n+\tpredicate function of the prefix's subtype.\n+\t* exp_ch4.adb (Expand_N_In): Remove test for Is_Discrete_Type\n+\twhen we're checking that there's no predicate check function as a\n+\tcondition for substituting a Valid check for a scalar membership\n+\ttest (substitution should be suppressed for any kind of scalar\n+\tsubtype with a predicate check). Also, don't emit a predicate\n+\tcheck when the right operand is a range.\n+\n 2012-11-06  Robert Dewar  <dewar@adacore.com>\n \n \t* par_sco.adb, bindgen.adb, exp_vfpt.adb, exp_vfpt.ads, exp_ch2.adb,"}, {"sha": "d94ae8896f2c1de19a11af75d98bf6171802ccd0", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "patch": "@@ -27,6 +27,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Errout;   use Errout;\n with Exp_Atag; use Exp_Atag;\n with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch3;  use Exp_Ch3;\n@@ -5608,6 +5609,32 @@ package body Exp_Attr is\n             Rewrite (N, Make_Range_Test);\n          end if;\n \n+         --  If a predicate is present, then we do the predicate test, even if\n+         --  within the predicate function (infinite recursion is warned about\n+         --  in that case).\n+\n+         declare\n+            Pred_Func : constant Entity_Id := Predicate_Function (Ptyp);\n+\n+         begin\n+            if Present (Pred_Func) then\n+               Rewrite (N,\n+                 Make_And_Then (Loc,\n+                   Left_Opnd  => Relocate_Node (N),\n+                   Right_Opnd => Make_Predicate_Call (Ptyp, Pref)));\n+\n+               --  If the attribute appears within the subtype's own predicate\n+               --  function, then issue a warning that this will cause infinite\n+               --  recursion.\n+\n+               if Current_Scope = Pred_Func then\n+                  Error_Msg_N\n+                    (\"attribute Valid requires a predicate check?\", N);\n+                  Error_Msg_N (\"\\and will result in infinite recursion?\", N);\n+               end if;\n+            end if;\n+         end;\n+\n          Analyze_And_Resolve (N, Standard_Boolean);\n          Validity_Checks_On := Save_Validity_Checks_On;\n       end Valid;"}, {"sha": "d9bdebd290077b540e38e289e24a7ecefd9ad596", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "patch": "@@ -5565,8 +5565,7 @@ package body Exp_Ch4 is\n         --  Skip this for predicated types, where such expressions are a\n         --  reasonable way of testing if something meets the predicate.\n \n-        and then not (Is_Discrete_Type (Ltyp)\n-                       and then Present (Predicate_Function (Ltyp)))\n+        and then not Present (Predicate_Function (Ltyp))\n       then\n          Substitute_Valid_Check;\n          return;\n@@ -6103,13 +6102,17 @@ package body Exp_Ch4 is\n       --  If a predicate is present, then we do the predicate test, but we\n       --  most certainly want to omit this if we are within the predicate\n       --  function itself, since otherwise we have an infinite recursion!\n+      --  The check should also not be emitted when testing against a range\n+      --  (the check is only done when the right operand is a subtype; see\n+      --  RM12-4.5.2 (28.1/3-30/3)).\n \n       declare\n          PFunc : constant Entity_Id := Predicate_Function (Rtyp);\n \n       begin\n          if Present (PFunc)\n            and then Current_Scope /= PFunc\n+           and then Nkind (Rop) /= N_Range\n          then\n             Rewrite (N,\n               Make_And_Then (Loc,"}]}