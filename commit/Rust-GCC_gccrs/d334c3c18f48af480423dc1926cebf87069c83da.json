{"sha": "d334c3c18f48af480423dc1926cebf87069c83da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMzNGMzYzE4ZjQ4YWY0ODA0MjNkYzE5MjZjZWJmODcwNjljODNkYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-06-09T07:01:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-06-09T07:01:24Z"}, "message": "mips.c (mips_reg_names): Change hilo entry to \"\".\n\n\t* config/mips/mips.c (mips_reg_names): Change hilo entry to \"\".\n\t(mips_sw_reg_names): Likewise.\n\t(mips_regno_to_class): Change hilo entry to NO_REGS.\n\t(hilo_operand): Use MD_REG_P.\n\t(extend_operator): New predicate.\n\t(override_options): Remove 'a' constraint.\n\t(mips_secondary_reload_class): Remove hilo handling.  Also remove\n\thandling of (plus sp reg) reloads for mips16.\n\t(mips_register_move_cost): Remove hilo handling.\n\t* config/mips/mips.h (FIXED_REGISTERS): Make hilo entry fixed.\n\t(MD_REG_LAST): Remove hilo from range.\n\t(HILO_REGNUM): Delete.\n\t(reg_class): Remove HILO_REG and HILO_AND_GR_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update accordingly.\n\t(PREDICATE_CODES): Add entry for extend_operator.\n\t(DEBUG_REGISTER_NAMES): Change hilo entry to \"\".\n\t* config/mips/mips.md: Remove hilo clobbers wherever they occur.\n\tRemove constraints from multiplication define_expands.  Remove\n\tclobbers from \"decorative\" define_expand patterns.\n\t(UNSPEC_HILO_DELAY): Delete.\n\t(*mul_acc_si, *mul_sub_si): Add early-clobber to operand 6.\n\t(mulsidi3, umulsidi3): Change pattern to match the TARGET_64BIT case.\n\tAdjust C code to just emit insns for !TARGET_64BIT.\n\t(mulsidi3_internal): Rename to mulsidi3_32bit.\n\t(mulsidi3_64bit): Use a \"d\" constraint for the destination.\n\tUse extend_operator so that the pattern can handle umulsidi3 as well.\n\tSplit the instruction after reload.\n\t(*mulsidi3_64bit_parts): New pattern, generated by mulsidi3_64bit.\n\t(umulsidi3_internal): Rename to umulsidi3_32bit.\n\t(umulsidi3_64bit): Remove.\n\t(*smsac_di, *umsac_di): Line-wrap fixes.\n\t(udivsi3_internal): Don't allow operand 2 to be constant.\n\t(udivdi3_internal, umodsi3_internal, umoddi3_internal): Likewise.\n\t(movdi_internal2, movsi_internal): Remove hilo alternatives.\n\t(reload_in[sd]i, reload_out[sd]i, hilo_delay): Remove.\n\nFrom-SVN: r67654", "tree": {"sha": "b91dcdf20d875be00b0e1652876e452720e93c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b91dcdf20d875be00b0e1652876e452720e93c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d334c3c18f48af480423dc1926cebf87069c83da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d334c3c18f48af480423dc1926cebf87069c83da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d334c3c18f48af480423dc1926cebf87069c83da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d334c3c18f48af480423dc1926cebf87069c83da/comments", "author": null, "committer": null, "parents": [{"sha": "20db0e3c83848146de105a34a5fc35f7383731b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20db0e3c83848146de105a34a5fc35f7383731b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20db0e3c83848146de105a34a5fc35f7383731b5"}], "stats": {"total": 999, "additions": 327, "deletions": 672}, "files": [{"sha": "5811a449d9ce54778dac479f76d1a7e7e61fae66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d334c3c18f48af480423dc1926cebf87069c83da", "patch": "@@ -1,3 +1,41 @@\n+2003-06-09  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_reg_names): Change hilo entry to \"\".\n+\t(mips_sw_reg_names): Likewise.\n+\t(mips_regno_to_class): Change hilo entry to NO_REGS.\n+\t(hilo_operand): Use MD_REG_P.\n+\t(extend_operator): New predicate.\n+\t(override_options): Remove 'a' constraint.\n+\t(mips_secondary_reload_class): Remove hilo handling.  Also remove\n+\thandling of (plus sp reg) reloads for mips16.\n+\t(mips_register_move_cost): Remove hilo handling.\n+\t* config/mips/mips.h (FIXED_REGISTERS): Make hilo entry fixed.\n+\t(MD_REG_LAST): Remove hilo from range.\n+\t(HILO_REGNUM): Delete.\n+\t(reg_class): Remove HILO_REG and HILO_AND_GR_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update accordingly.\n+\t(PREDICATE_CODES): Add entry for extend_operator.\n+\t(DEBUG_REGISTER_NAMES): Change hilo entry to \"\".\n+\t* config/mips/mips.md: Remove hilo clobbers wherever they occur.\n+\tRemove constraints from multiplication define_expands.  Remove\n+\tclobbers from \"decorative\" define_expand patterns.\n+\t(UNSPEC_HILO_DELAY): Delete.\n+\t(*mul_acc_si, *mul_sub_si): Add early-clobber to operand 6.\n+\t(mulsidi3, umulsidi3): Change pattern to match the TARGET_64BIT case.\n+\tAdjust C code to just emit insns for !TARGET_64BIT.\n+\t(mulsidi3_internal): Rename to mulsidi3_32bit.\n+\t(mulsidi3_64bit): Use a \"d\" constraint for the destination.\n+\tUse extend_operator so that the pattern can handle umulsidi3 as well.\n+\tSplit the instruction after reload.\n+\t(*mulsidi3_64bit_parts): New pattern, generated by mulsidi3_64bit.\n+\t(umulsidi3_internal): Rename to umulsidi3_32bit.\n+\t(umulsidi3_64bit): Remove.\n+\t(*smsac_di, *umsac_di): Line-wrap fixes.\n+\t(udivsi3_internal): Don't allow operand 2 to be constant.\n+\t(udivdi3_internal, umodsi3_internal, umoddi3_internal): Likewise.\n+\t(movdi_internal2, movsi_internal): Remove hilo alternatives.\n+\t(reload_in[sd]i, reload_out[sd]i, hilo_delay): Remove.\n+\n 2003-06-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR target/10913"}, {"sha": "605f3aef3d96f7297e983a60a6b5710b4f4864d4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d334c3c18f48af480423dc1926cebf87069c83da", "patch": "@@ -592,7 +592,7 @@ char mips_reg_names[][8] =\n  \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n  \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n- \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n+ \"hi\",   \"lo\",   \"\",     \"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"\", \"\",     \"\",     \"\",     \"\",\n  \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\n  \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\n@@ -621,7 +621,7 @@ char mips_sw_reg_names[][8] =\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n-  \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n+  \"hi\",   \"lo\",   \"\",     \"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n   \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\", \"\",     \"\",     \"\",     \"\",\n   \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\n   \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\n@@ -656,7 +656,7 @@ const enum reg_class mips_regno_to_class[] =\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  HI_REG,\tLO_REG,\t\tHILO_REG,\tST_REGS,\n+  HI_REG,\tLO_REG,\t\tNO_REGS,\tST_REGS,\n   ST_REGS,\tST_REGS,\tST_REGS,\tST_REGS,\n   ST_REGS,\tST_REGS,\tST_REGS,\tNO_REGS,\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n@@ -1518,8 +1518,18 @@ hilo_operand (op, mode)\n      enum machine_mode mode;\n {\n   return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && REG_P (op)\n-\t  && (REGNO (op) == HI_REGNUM || REGNO (op) == LO_REGNUM));\n+\t  && REG_P (op) && MD_REG_P (REGNO (op)));\n+}\n+\n+/* Return true if OP is an extension operator.  */\n+\n+int\n+extend_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND));\n }\n \n /* Return nonzero if the code of this rtx pattern is EQ or NE.  */\n@@ -5555,7 +5565,6 @@ override_options ()\n   mips_char_to_class['f'] = (TARGET_HARD_FLOAT ? FP_REGS : NO_REGS);\n   mips_char_to_class['h'] = HI_REG;\n   mips_char_to_class['l'] = LO_REG;\n-  mips_char_to_class['a'] = HILO_REG;\n   mips_char_to_class['x'] = MD_REGS;\n   mips_char_to_class['b'] = ALL_REGS;\n   mips_char_to_class['c'] = (TARGET_ABICALLS ? PIC_FN_ADDR_REG :\n@@ -8541,20 +8550,6 @@ mips_secondary_reload_class (class, mode, x, in_p)\n       && DANGEROUS_FOR_LA25_P (x))\n     return LEA_REGS;\n \n-  /* We always require a general register when copying anything to\n-     HILO_REGNUM, except when copying an SImode value from HILO_REGNUM\n-     to a general register, or when copying from register 0.  */\n-  if (class == HILO_REG && regno != GP_REG_FIRST + 0)\n-    return ((! in_p\n-\t     && gp_reg_p\n-\t     && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (SImode))\n-\t    ? NO_REGS : gr_regs);\n-  else if (regno == HILO_REGNUM)\n-    return ((in_p\n-\t     && class == gr_regs\n-\t     && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (SImode))\n-\t    ? NO_REGS : gr_regs);\n-\n   /* Copying from HI or LO to anywhere other than a general register\n      requires a general register.  */\n   if (class == HI_REG || class == LO_REG || class == MD_REGS)\n@@ -8636,19 +8631,6 @@ mips_secondary_reload_class (class, mode, x, in_p)\n \t}\n       if (! gp_reg_p)\n \t{\n-\t  /* The stack pointer isn't a valid operand to an add instruction,\n-\t     so we need to load it into M16_REGS first.  This can happen as\n-\t     a result of register elimination and form_sum converting\n-\t     (plus reg (plus SP CONST)) to (plus (plus reg SP) CONST).  We\n-\t     need an extra register if the dest is the same as the other\n-\t     register.  In that case, we can't fix the problem by loading SP\n-\t     into the dest first.  */\n-\t  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == REG\n-\t      && GET_CODE (XEXP (x, 1)) == REG\n-\t      && (XEXP (x, 0) == stack_pointer_rtx\n-\t\t  || XEXP (x, 1) == stack_pointer_rtx))\n-\t    return (class == M16_REGS ? M16_NA_REGS : M16_REGS);\n-\n \t  if (class == M16_REGS || class == M16_NA_REGS)\n \t    return NO_REGS;\n \t  return M16_REGS;\n@@ -9775,10 +9757,10 @@ mips_reorg ()\n    should do this if the `movM' pattern's constraints do not allow\n    such copying.\n \n-   ??? We make make the cost of moving from HI/LO/HILO/MD into general\n+   ??? We make the cost of moving from HI/LO into general\n    registers the same as for one of moving general registers to\n-   HI/LO/HILO/MD for TARGET_MIPS16 in order to prevent allocating a\n-   pseudo to HI/LO/HILO/MD.  This might hurt optimizations though, it\n+   HI/LO for TARGET_MIPS16 in order to prevent allocating a\n+   pseudo to HI/LO.  This might hurt optimizations though, it\n    isn't clear if it is wise.  And it might not work in all cases.  We\n    could solve the DImode LO reg problem by using a multiply, just\n    like reload_{in,out}si.  We could solve the SImode/HImode HI reg\n@@ -9813,8 +9795,7 @@ mips_register_move_cost (mode, to, from)\n \t}\n       else if (to == FP_REGS)\n \treturn 4;\n-      else if (to == HI_REG || to == LO_REG || to == MD_REGS\n-\t       || to == HILO_REG)\n+      else if (to == HI_REG || to == LO_REG || to == MD_REGS)\n \t{\n \t  if (TARGET_MIPS16)\n \t    return 12;\n@@ -9835,8 +9816,7 @@ mips_register_move_cost (mode, to, from)\n       else if (to == ST_REGS)\n \treturn 8;\n     }  /* from == FP_REGS */\n-  else if (from == HI_REG || from == LO_REG || from == MD_REGS\n-\t   || from == HILO_REG)\n+  else if (from == HI_REG || from == LO_REG || from == MD_REGS)\n     {\n       if (GR_REG_CLASS_P (to))\n \t{"}, {"sha": "865603d50c5a0db95aaed5396234396e4901c51a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d334c3c18f48af480423dc1926cebf87069c83da", "patch": "@@ -1683,14 +1683,9 @@ do {\t\t\t\t\t\t\t\\\n \n    On the Mips, we have 32 integer registers, 32 floating point\n    registers, 8 condition code registers, and the special registers\n-   hi, lo, hilo, and rap.  Afetr that we have 32 COP0 registers, 32\n-   COP2 registers, and 32 COp3 registers.  (COP1 is the floating-point\n-   processor.)  The 8 condition code registers are only used if\n-   mips_isa >= 4.  The hilo register is only used in 64 bit mode.  It\n-   represents a 64 bit value stored as two 32 bit values in the hi and\n-   lo registers; this is the result of the mult instruction.  rap is a\n-   pointer to the stack where the return address reg ($31) was stored.\n-   This is needed for C++ exception handling.  */\n+   hi and lo.  After that we have 32 COP0 registers, 32 COP2 registers,\n+   and 32 COP3 registers.  (COP1 is the floating-point processor.)\n+   The 8 condition code registers are only used if mips_isa >= 4.  */\n \n #define FIRST_PSEUDO_REGISTER 176\n \n@@ -1711,7 +1706,7 @@ do {\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\t\t\t\\\n+  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\t\t\t\\\n   /* COP0 registers */\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n@@ -1795,7 +1790,7 @@ do {\t\t\t\t\t\t\t\\\n #define FP_DBX_FIRST ((write_symbols == DBX_DEBUG) ? 38 : 32)\n \n #define MD_REG_FIRST 64\n-#define MD_REG_LAST  66\n+#define MD_REG_LAST  65\n #define MD_REG_NUM   (MD_REG_LAST - MD_REG_FIRST + 1)\n #define MD_DBX_FIRST (FP_DBX_FIRST + FP_REG_NUM)\n \n@@ -1822,7 +1817,6 @@ do {\t\t\t\t\t\t\t\\\n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n-#define HILO_REGNUM\t(MD_REG_FIRST + 2)\n \n /* FPSW_REGNUM is the single condition code used if mips_isa < 4.  If\n    mips_isa >= 4, it should not be used, and an arbitrary ST_REG\n@@ -2002,14 +1996,12 @@ enum reg_class\n   FP_REGS,\t\t\t/* floating point registers */\n   HI_REG,\t\t\t/* hi register */\n   LO_REG,\t\t\t/* lo register */\n-  HILO_REG,\t\t\t/* hilo register pair for 64 bit mode mult */\n   MD_REGS,\t\t\t/* multiply/divide registers (hi/lo) */\n   COP0_REGS,\t\t\t/* generic coprocessor classes */\n   COP2_REGS,\n   COP3_REGS,\n   HI_AND_GR_REGS,\t\t/* union classes */\n   LO_AND_GR_REGS,\n-  HILO_AND_GR_REGS,\n   HI_AND_FP_REGS,\n   COP0_AND_GR_REGS,\n   COP2_AND_GR_REGS,\n@@ -2042,15 +2034,13 @@ enum reg_class\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"HI_REG\",\t\t\t\t\t\t\t\t\\\n   \"LO_REG\",\t\t\t\t\t\t\t\t\\\n-  \"HILO_REG\",\t\t\t\t\t\t\t\t\\\n   \"MD_REGS\",\t\t\t\t\t\t\t\t\\\n   /* coprocessor registers */\t\t\t\t\t\t\\\n   \"COP0_REGS\",\t\t\t\t\t\t\t\t\\\n   \"COP2_REGS\",\t\t\t\t\t\t\t\t\\\n   \"COP3_REGS\",\t\t\t\t\t\t\t\t\\\n   \"HI_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"LO_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n-  \"HILO_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"HI_AND_FP_REGS\",\t\t\t\t\t\t\t\\\n   \"COP0_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"COP2_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n@@ -2085,14 +2075,12 @@ enum reg_class\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* floating registers*/\t\\\n   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* hi register */\t\\\n   { 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },\t/* lo register */\t\\\n-  { 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000 },\t/* hilo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x00000000 },\t/* mul/div registers */\t\\\n   { 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 }, /* cop0 registers */ \\\n   { 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 }, /* cop2 registers */ \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff }, /* cop3 registers */ \\\n   { 0xffffffff, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* union classes */     \\\n   { 0xffffffff, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n-  { 0xffffffff, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n   { 0x00000000, 0xffffffff, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n   { 0xffffffff, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 },\t\t\t\\\n   { 0xffffffff, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 },\t\\\n@@ -2186,7 +2174,6 @@ extern const enum reg_class mips_regno_to_class[];\n    'h'\tHi register\n    'l'\tLo register\n    'x'\tMultiply/divide registers\n-   'a'\tHILO_REG\n    'z'\tFP Status register\n    'B'  Cop0 register\n    'C'  Cop2 register\n@@ -3312,7 +3299,8 @@ typedef struct mips_args {\n   {\"consttable_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n \t\t\t\t  CONST_DOUBLE, CONST }},\t\t\\\n   {\"fcc_register_operand\",\t{ REG, SUBREG }},\t\t\t\\\n-  {\"hilo_operand\",\t\t{ REG }},\n+  {\"hilo_operand\",\t\t{ REG }},\t\t\t\t\\\n+  {\"extend_operator\",\t\t{ ZERO_EXTEND, SIGN_EXTEND }},\n \n /* A list of predicates that do special things with modes, and so\n    should not elicit warnings for VOIDmode match_operand.  */\n@@ -3546,7 +3534,7 @@ typedef struct mips_args {\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\\\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t\\\n-  \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\t\\\n+  \"hi\",   \"lo\",   \"\",     \"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\t\\\n   \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\", \"\",     \"\",     \"\",     \"\",\t\t\\\n   \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\\\n   \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\\"}, {"sha": "10a3da04e10821d087c607b97059e8c7610ae574", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 261, "deletions": 612, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d334c3c18f48af480423dc1926cebf87069c83da/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=d334c3c18f48af480423dc1926cebf87069c83da", "patch": "@@ -31,7 +31,6 @@\n    (UNSPEC_LOAD_DF_HIGH\t\t 1)\n    (UNSPEC_STORE_DF_HIGH\t 2)\n    (UNSPEC_GET_FNADDR\t\t 4)\n-   (UNSPEC_HILO_DELAY\t\t 5)\n    (UNSPEC_BLOCKAGE\t\t 6)\n    (UNSPEC_LOADGP\t\t 7)\n    (UNSPEC_SETJMP\t\t 8)\n@@ -1847,11 +1846,9 @@\n ;; this by keeping the mflo with the mult on the R4000.\n \n (define_expand \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -1869,8 +1866,7 @@\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d,d\")))\n    (clobber (match_scratch:SI 3 \"=h,h\"))\n-   (clobber (match_scratch:SI 4 \"=l,X\"))\n-   (clobber (match_scratch:SI 5 \"=a,a\"))]\n+   (clobber (match_scratch:SI 4 \"=l,X\"))]\n   \"GENERATE_MULT3_SI\n    || TARGET_MAD\"\n   \"*\n@@ -1897,36 +1893,32 @@\n ;; Operand 1: GPR (1st multiplication operand)\n ;; Operand 2: GPR (2nd multiplication operand)\n ;; Operand 3: HI\n-;; Operand 4: HILO\n-;; Operand 5: GPR (destination)\n+;; Operand 4: GPR (destination)\n (define_peephole2\n   [(parallel\n        [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t     (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t      (match_operand:SI 2 \"register_operand\" \"\")))\n         (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n-        (clobber (scratch:SI))\n-        (clobber (match_operand:SI 4 \"register_operand\" \"\"))])\n-   (set (match_operand:SI 5 \"register_operand\" \"\")\n+        (clobber (scratch:SI))])\n+   (set (match_operand:SI 4 \"register_operand\" \"\")\n         (match_dup 0))]\n   \"GENERATE_MULT3_SI\n    && true_regnum (operands[0]) == LO_REGNUM\n-   && GP_REG_P (true_regnum (operands[5]))\n+   && GP_REG_P (true_regnum (operands[4]))\n    && peep2_reg_dead_p (2, operands[0])\"\n   [(parallel\n-       [(set (match_dup 5)\n+       [(set (match_dup 4)\n \t     (mult:SI (match_dup 1)\n \t\t      (match_dup 2)))\n         (clobber (match_dup 3))\n-        (clobber (match_dup 0))\n-        (clobber (match_dup 4))])])\n+        (clobber (match_dup 0))])])\n \n (define_insn \"mulsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"!TARGET_MIPS4000 || TARGET_MIPS16\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -1937,8 +1929,7 @@\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=l\"))\n-   (clobber (match_scratch:SI 5 \"=a\"))]\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n   \"TARGET_MIPS4000 && !TARGET_MIPS16\"\n   \"mult\\t%1,%2\\;mflo\\t%0\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -1964,8 +1955,7 @@\n \t\t (match_operand:SI 3 \"register_operand\" \"0,l,*d\")))\n    (clobber (match_scratch:SI 4 \"=h,h,h\"))\n    (clobber (match_scratch:SI 5 \"=X,3,l\"))\n-   (clobber (match_scratch:SI 6 \"=a,a,a\"))\n-   (clobber (match_scratch:SI 7 \"=X,X,d\"))]\n+   (clobber (match_scratch:SI 6 \"=X,X,&d\"))]\n   \"(TARGET_MIPS3900\n    || ISA_HAS_MADD_MSUB)\n    && !TARGET_MIPS16\"\n@@ -1990,17 +1980,15 @@\n \t\t (match_operand:SI 3 \"register_operand\" \"\")))\n    (clobber (match_scratch:SI 4 \"\"))\n    (clobber (match_scratch:SI 5 \"\"))\n-   (clobber (match_scratch:SI 6 \"\"))\n-   (clobber (match_scratch:SI 7 \"\"))]\n+   (clobber (match_scratch:SI 6 \"\"))]\n   \"reload_completed && !TARGET_DEBUG_D_MODE\n    && GP_REG_P (true_regnum (operands[0]))\n    && GP_REG_P (true_regnum (operands[3]))\"\n-  [(parallel [(set (match_dup 7)\n+  [(parallel [(set (match_dup 6)\n \t\t   (mult:SI (match_dup 1) (match_dup 2)))\n \t      (clobber (match_dup 4))\n-\t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 6))])\n-   (set (match_dup 0) (plus:SI (match_dup 7) (match_dup 3)))]\n+\t      (clobber (match_dup 5))])\n+   (set (match_dup 0) (plus:SI (match_dup 6) (match_dup 3)))]\n   \"\")\n \n ;; Splitter to copy result of MADD to a general register\n@@ -2011,8 +1999,7 @@\n                  (match_operand:SI          3 \"register_operand\" \"\")))\n    (clobber (match_scratch:SI               4 \"\"))\n    (clobber (match_scratch:SI               5 \"\"))\n-   (clobber (match_scratch:SI               6 \"\"))\n-   (clobber (match_scratch:SI               7 \"\"))]\n+   (clobber (match_scratch:SI               6 \"\"))]\n   \"reload_completed && !TARGET_DEBUG_D_MODE\n    && GP_REG_P (true_regnum (operands[0]))\n    && true_regnum (operands[3]) == LO_REGNUM\"\n@@ -2021,8 +2008,7 @@\n                             (match_dup 3)))\n               (clobber (match_dup 4))\n               (clobber (match_dup 5))\n-              (clobber (match_dup 6))\n-              (clobber (match_dup 7))])\n+              (clobber (match_dup 6))])\n    (set (match_dup 0) (match_dup 3))]\n   \"\")\n \n@@ -2032,8 +2018,7 @@\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d\"))\n \t\t (match_operand:SI 3 \"register_operand\" \"0,l\")))\n    (clobber (match_scratch:SI 4 \"=h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,3\"))\n-   (clobber (match_scratch:SI 6 \"=a,a\"))]\n+   (clobber (match_scratch:SI 5 \"=X,3\"))]\n   \"ISA_HAS_MACC\"\n   \"*\n {\n@@ -2057,8 +2042,7 @@\n \t(plus:SI (mult:SI (match_dup 1)\n \t\t\t  (match_dup 2))\n \t\t (match_dup 0)))\n-   (clobber (match_scratch:SI 4 \"=h\"))\n-   (clobber (match_scratch:SI 5 \"=a\"))]\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n   \"ISA_HAS_MACC && reload_completed\"\n   \"macc\\\\t%3,%1,%2\"\n   [(set_attr \"type\"\t\"imadd\")\n@@ -2070,32 +2054,29 @@\n ;; Operand 1: GPR (1st multiplication operand)\n ;; Operand 2: GPR (2nd multiplication operand)\n ;; Operand 3: HI\n-;; Operand 4: HILO\n-;; Operand 5: GPR (destination)\n+;; Operand 4: GPR (destination)\n (define_peephole2\n   [(parallel\n        [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t     (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t       (match_operand:SI 2 \"register_operand\" \"\"))\n \t\t      (match_dup 0)))\n \t(clobber (match_operand:SI 3 \"register_operand\" \"\"))\n-\t(clobber (scratch:SI))\n-\t(clobber (match_operand:SI 4 \"register_operand\" \"\"))])\n-   (set (match_operand:SI 5 \"register_operand\" \"\")\n+\t(clobber (scratch:SI))])\n+   (set (match_operand:SI 4 \"register_operand\" \"\")\n \t(match_dup 0))]\n   \"ISA_HAS_MACC\n    && true_regnum (operands[0]) == LO_REGNUM\n-   && GP_REG_P (true_regnum (operands[5]))\"\n+   && GP_REG_P (true_regnum (operands[4]))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (plus:SI (mult:SI (match_dup 1)\n \t\t\t\t     (match_dup 2))\n \t\t\t    (match_dup 0)))\n-\t      (set (match_dup 5)\n+\t      (set (match_dup 4)\n \t\t   (plus:SI (mult:SI (match_dup 1)\n \t\t\t\t     (match_dup 2))\n \t\t\t    (match_dup 0)))\n-\t      (clobber (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+\t      (clobber (match_dup 3))])]\n   \"\")\n \n ;; When we have a three-address multiplication instruction, it should\n@@ -2112,7 +2093,6 @@\n ;; Operand 4: GPR (1st multiplication operand)\n ;; Operand 5: GPR (2nd multiplication operand)\n ;; Operand 6: HI\n-;; Operand 7: HILO\n (define_peephole2\n   [(match_scratch:SI 0 \"d\")\n    (set (match_operand:SI 1 \"register_operand\" \"\")\n@@ -2124,8 +2104,7 @@\n \t\t\t       (match_operand:SI 5 \"register_operand\" \"\"))\n \t\t      (match_dup 1)))\n \t(clobber (match_operand:SI 6 \"register_operand\" \"\"))\n-\t(clobber (match_dup 1))\n-\t(clobber (match_operand:SI 7 \"register_operand\" \"\"))])]\n+\t(clobber (match_dup 1))])]\n   \"ISA_HAS_MACC && GENERATE_MULT3_SI\n    && true_regnum (operands[1]) == LO_REGNUM\n    && peep2_reg_dead_p (2, operands[1])\n@@ -2134,8 +2113,7 @@\n \t\t   (mult:SI (match_dup 4)\n \t\t\t    (match_dup 5)))\n \t      (clobber (match_dup 6))\n-\t      (clobber (match_dup 1))\n-\t      (clobber (match_dup 7))])\n+\t      (clobber (match_dup 1))])\n    (set (match_dup 3)\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 2)))]\n@@ -2149,8 +2127,7 @@\n ;; Operand 3: GPR (1st multiplication operand)\n ;; Operand 4: GPR (2nd multiplication operand)\n ;; Operand 5: HI\n-;; Operand 6: HILO\n-;; Operand 7: GPR (destination)\n+;; Operand 6: GPR (destination)\n (define_peephole2\n   [(match_scratch:SI 0 \"d\")\n    (set (match_operand:SI 1 \"register_operand\" \"\")\n@@ -2162,22 +2139,20 @@\n \t\t\t       (match_operand:SI 4 \"register_operand\" \"\"))\n \t\t      (match_dup 1)))\n \t(clobber (match_operand:SI 5 \"register_operand\" \"\"))\n-\t(clobber (scratch:SI))\n-\t(clobber (match_operand:SI 6 \"register_operand\" \"\"))])\n+\t(clobber (scratch:SI))])\n    (match_dup 0)\n-   (set (match_operand:SI 7 \"register_operand\" \"\")\n+   (set (match_operand:SI 6 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"ISA_HAS_MACC && GENERATE_MULT3_SI\n    && true_regnum (operands[1]) == LO_REGNUM\n    && peep2_reg_dead_p (3, operands[1])\n-   && GP_REG_P (true_regnum (operands[7]))\"\n+   && GP_REG_P (true_regnum (operands[6]))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (mult:SI (match_dup 3)\n \t\t\t    (match_dup 4)))\n \t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 1))\n-\t      (clobber (match_dup 6))])\n-   (set (match_dup 7)\n+\t      (clobber (match_dup 1))])\n+   (set (match_dup 6)\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 2)))]\n   \"\")\n@@ -2189,8 +2164,7 @@\n                            (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n    (clobber (match_scratch:SI 4 \"=h,h,h\"))\n    (clobber (match_scratch:SI 5 \"=X,1,l\"))\n-   (clobber (match_scratch:SI 6 \"=a,a,a\"))\n-   (clobber (match_scratch:SI 7 \"=X,X,d\"))]\n+   (clobber (match_scratch:SI 6 \"=X,X,&d\"))]\n   \"ISA_HAS_MADD_MSUB\"\n   \"*\n {\n@@ -2210,17 +2184,15 @@\n                            (match_operand:SI 3 \"register_operand\" \"\"))))\n    (clobber (match_scratch:SI 4 \"\"))\n    (clobber (match_scratch:SI 5 \"\"))\n-   (clobber (match_scratch:SI 6 \"\"))\n-   (clobber (match_scratch:SI 7 \"\"))]\n+   (clobber (match_scratch:SI 6 \"\"))]\n   \"reload_completed && !TARGET_DEBUG_D_MODE\n    && GP_REG_P (true_regnum (operands[0]))\n    && GP_REG_P (true_regnum (operands[1]))\"\n-  [(parallel [(set (match_dup 7)\n+  [(parallel [(set (match_dup 6)\n                    (mult:SI (match_dup 2) (match_dup 3)))\n               (clobber (match_dup 4))\n-              (clobber (match_dup 5))\n-              (clobber (match_dup 6))])\n-   (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 7)))]\n+              (clobber (match_dup 5))])\n+   (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 6)))]\n   \"\")\n \n ;; Splitter to copy result of MSUB to a general register\n@@ -2231,8 +2203,7 @@\n                            (match_operand:SI 3 \"register_operand\" \"\"))))\n    (clobber (match_scratch:SI 4 \"\"))\n    (clobber (match_scratch:SI 5 \"\"))\n-   (clobber (match_scratch:SI 6 \"\"))\n-   (clobber (match_scratch:SI 7 \"\"))]\n+   (clobber (match_scratch:SI 6 \"\"))]\n   \"reload_completed && !TARGET_DEBUG_D_MODE\n    && GP_REG_P (true_regnum (operands[0]))\n    && true_regnum (operands[1]) == LO_REGNUM\"\n@@ -2241,8 +2212,7 @@\n                              (mult:SI (match_dup 2) (match_dup 3))))\n               (clobber (match_dup 4))\n               (clobber (match_dup 5))\n-              (clobber (match_dup 6))\n-              (clobber (match_dup 7))])\n+              (clobber (match_dup 6))])\n    (set (match_dup 0) (match_dup 1))]\n   \"\")\n \n@@ -2251,8 +2221,7 @@\n         (neg:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n                          (match_operand:SI 2 \"register_operand\" \"d,d\"))))\n    (clobber (match_scratch:SI              3                    \"=h,h\"))\n-   (clobber (match_scratch:SI              4                    \"=a,a\"))\n-   (clobber (match_scratch:SI              5                    \"=X,l\"))]\n+   (clobber (match_scratch:SI              4                    \"=X,l\"))]\n   \"ISA_HAS_MULS\"\n   \"@\n    muls\\\\t$0,%1,%2\n@@ -2266,8 +2235,7 @@\n                   (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n                            (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n    (clobber (match_scratch:SI 4 \"=h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,1\"))\n-   (clobber (match_scratch:SI 6 \"=a,a\"))]\n+   (clobber (match_scratch:SI 5 \"=X,1\"))]\n   \"ISA_HAS_MSAC\"\n   \"*\n {\n@@ -2282,11 +2250,9 @@\n    (set_attr \"mode\"     \"SI\")])\n \n (define_expand \"muldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:DI 3 \"=h\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"TARGET_64BIT\"\n \n   \"\n@@ -2302,8 +2268,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:DI 3 \"=h\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+   (clobber (match_scratch:DI 3 \"=h\"))]\n   \"TARGET_64BIT && !TARGET_MIPS4000\"\n   \"dmult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -2314,8 +2279,7 @@\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:DI 3 \"=h\"))\n-   (clobber (match_scratch:DI 4 \"=l\"))\n-   (clobber (match_scratch:DI 5 \"=a\"))]\n+   (clobber (match_scratch:DI 4 \"=l\"))]\n   \"TARGET_64BIT && (GENERATE_MULT3_DI || TARGET_MIPS4000)\"\n   {\n     if (GENERATE_MULT3_DI)\n@@ -2333,86 +2297,139 @@\n ;; ??? We could define a mulditi3 pattern when TARGET_64BIT.\n \n (define_expand \"mulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  [(parallel\n+      [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t    (mult:DI\n+\t       (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))\n+       (clobber (scratch:DI))\n+       (clobber (scratch:DI))\n+       (clobber (scratch:DI))])]\n   \"\"\n-  \"\n-{\n-  if (TARGET_64BIT)\n-    emit_insn (gen_mulsidi3_64bit (operands[0], operands[1], operands[2]));\n-  else\n-    emit_insn (gen_mulsidi3_internal (operands[0], operands[1], operands[2]));\n-  DONE;\n-}\")\n+  {\n+    if (!TARGET_64BIT)\n+      {\n+\temit_insn (gen_mulsidi3_32bit (operands[0], operands[1], operands[2]));\n+\tDONE;\n+      }\n+   })\n \n-(define_insn \"mulsidi3_internal\"\n+(define_insn \"mulsidi3_32bit\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (match_scratch:SI 3 \"=a\"))]\n+\t(mult:DI\n+\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"!TARGET_64BIT\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_insn \"mulsidi3_64bit\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))]\n-  \"TARGET_64BIT\"\n-  \"mult\\\\t%1,%2\"\n-  [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"SI\")])\n+(define_insn_and_split \"*mulsidi3_64bit\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(mult:DI (match_operator:DI 1 \"extend_operator\"\n+\t\t    [(match_operand:SI 3 \"register_operand\" \"d\")])\n+\t\t (match_operator:DI 2 \"extend_operator\"\n+\t\t    [(match_operand:SI 4 \"register_operand\" \"d\")])))\n+   (clobber (match_scratch:DI 5 \"=l\"))\n+   (clobber (match_scratch:DI 6 \"=h\"))\n+   (clobber (match_scratch:DI 7 \"=d\"))]\n+  \"TARGET_64BIT && GET_CODE (operands[1]) == GET_CODE (operands[2])\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+       [(set (match_dup 5)\n+\t     (sign_extend:DI\n+\t\t(mult:SI (match_dup 3)\n+\t\t         (match_dup 4))))\n+\t(set (match_dup 6)\n+\t     (ashiftrt:DI\n+\t\t(mult:DI (match_dup 1)\n+\t\t\t (match_dup 2))\n+\t\t(const_int 32)))])\n+\n+   ;; OP7 <- LO, OP0 <- HI\n+   (set (match_dup 7) (match_dup 5))\n+   (set (match_dup 0) (match_dup 6))\n+\n+   ;; Zero-extend OP7.\n+   (set (match_dup 7)\n+\t(ashift:DI (match_dup 7)\n+\t\t   (const_int 32)))\n+   (set (match_dup 7)\n+\t(lshiftrt:DI (match_dup 7)\n+\t\t     (const_int 32)))\n \n-(define_expand \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+   ;; Shift OP0 into place.\n+   (set (match_dup 0)\n+\t(ashift:DI (match_dup 0)\n+\t\t   (const_int 32)))\n+\n+   ;; OR the two halves together\n+   (set (match_dup 0)\n+\t(ior:DI (match_dup 0)\n+\t\t(match_dup 7)))]\n   \"\"\n-  \"\n-{\n-  if (TARGET_64BIT)\n-    emit_insn (gen_umulsidi3_64bit (operands[0], operands[1], operands[2]));\n-  else\n-    emit_insn (gen_umulsidi3_internal (operands[0], operands[1], operands[2]));\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"24\")])\n \n-  DONE;\n-}\")\n+(define_insn \"*mulsidi3_64bit_parts\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(sign_extend:DI\n+\t   (mult:SI (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand:SI 3 \"register_operand\" \"d\"))))\n+   (set (match_operand:DI 1 \"register_operand\" \"=h\")\n+\t(ashiftrt:DI\n+\t   (mult:DI\n+\t      (match_operator:DI 4 \"extend_operator\" [(match_dup 2)])\n+\t      (match_operator:DI 5 \"extend_operator\" [(match_dup 3)]))\n+\t   (const_int 32)))]\n+  \"TARGET_64BIT && GET_CODE (operands[4]) == GET_CODE (operands[5])\"\n+  {\n+    if (GET_CODE (operands[4]) == SIGN_EXTEND)\n+      return \"mult\\t%2,%3\";\n+    else\n+      return \"multu\\t%2,%3\";\n+  }\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"SI\")])\n \n+(define_expand \"umulsidi3\"\n+  [(parallel\n+      [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t    (mult:DI\n+\t       (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))\n+       (clobber (scratch:DI))\n+       (clobber (scratch:DI))\n+       (clobber (scratch:DI))])]\n+  \"\"\n+  {\n+    if (!TARGET_64BIT)\n+      {\n+        emit_insn (gen_umulsidi3_32bit (operands[0], operands[1],\n+\t\t\t\t\toperands[2]));\n+\tDONE;\n+      }\n+  })\n \n-(define_insn \"umulsidi3_internal\"\n+(define_insn \"umulsidi3_32bit\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (match_scratch:SI 3 \"=a\"))]\n+\t(mult:DI\n+\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"!TARGET_64BIT\"\n   \"multu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_insn \"umulsidi3_64bit\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))]\n-  \"TARGET_64BIT\"\n-  \"multu\\\\t%1,%2\"\n-  [(set_attr \"type\"\t\"imul\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-;; Widening multiply with negation.  It isn't worth using this pattern\n-;; for 64-bit code since the reload sequence for HILO_REGNUM is so long.\n+;; Widening multiply with negation.\n (define_insn \"*muls_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n         (neg:DI\n \t (mult:DI\n \t  (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t  (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))\n-   (clobber (match_scratch:SI 3 \"=a\"))]\n+\t  (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))]\n   \"!TARGET_64BIT && ISA_HAS_MULS\"\n   \"muls\\\\t$0,%1,%2\"\n   [(set_attr \"type\"     \"imul\")\n@@ -2424,22 +2441,20 @@\n \t(neg:DI\n \t (mult:DI\n \t  (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))\n-   (clobber (match_scratch:SI 3 \"=a\"))]\n+\t  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))]\n   \"!TARGET_64BIT && ISA_HAS_MULS\"\n   \"mulsu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"     \"imul\")\n    (set_attr \"length\"   \"4\")\n    (set_attr \"mode\"     \"SI\")])\n \n-;; Not used for 64-bit code: see comment for *muls_di.\n (define_insn \"*smsac_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (minus:DI (match_operand:DI 3 \"register_operand\" \"0\")\n-\t\t  (mult:DI\n-\t\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+        (minus:DI\n+\t   (match_operand:DI 3 \"register_operand\" \"0\")\n+\t   (mult:DI\n+\t      (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t      (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))]\n   \"!TARGET_64BIT && ISA_HAS_MSAC\"\n   \"*\n {\n@@ -2454,11 +2469,11 @@\n \n (define_insn \"*umsac_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-\t(minus:DI (match_operand:DI 3 \"register_operand\" \"0\")\n-\t\t  (mult:DI\n-\t\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t(minus:DI\n+\t   (match_operand:DI 3 \"register_operand\" \"0\")\n+\t   (mult:DI\n+\t      (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t      (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))))]\n   \"!TARGET_64BIT && ISA_HAS_MSAC\"\n   \"*\n {\n@@ -2473,11 +2488,11 @@\n \n ;; _highpart patterns\n (define_expand \"umulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(truncate:SI\n \t (lshiftrt:DI\n-\t  (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t  (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\")))\n \t  (const_int 32))))]\n   \"\"\n   \"\n@@ -2498,8 +2513,7 @@\n \t  (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"!ISA_HAS_MULHI\"\n   \"multu\\\\t%1,%2\"\n   [(set_attr \"type\"   \"imul\")\n@@ -2514,8 +2528,7 @@\n \t\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d,d\")))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=l,l\"))\n-   (clobber (match_scratch:SI 4 \"=a,a\"))\n-   (clobber (match_scratch:SI 5 \"=X,h\"))]\n+   (clobber (match_scratch:SI 4 \"=X,h\"))]\n   \"ISA_HAS_MULHI\"\n   \"@\n    multu\\\\t%1,%2\n@@ -2533,8 +2546,7 @@\n \t\t    (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d,d\"))))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=l,l\"))\n-   (clobber (match_scratch:SI 4 \"=a,a\"))\n-   (clobber (match_scratch:SI 5 \"=X,h\"))]\n+   (clobber (match_scratch:SI 4 \"=X,h\"))]\n   \"ISA_HAS_MULHI\"\n   \"@\n    mulshiu\\\\t%.,%1,%2\n@@ -2544,11 +2556,11 @@\n    (set_attr \"length\" \"4\")])\n \n (define_expand \"smulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(truncate:SI\n \t (lshiftrt:DI\n-\t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"\")))\n          (const_int 32))))]\n   \"\"\n   \"\n@@ -2569,8 +2581,7 @@\n \t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"!ISA_HAS_MULHI\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -2585,8 +2596,7 @@\n \t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d,d\")))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=l,l\"))\n-   (clobber (match_scratch:SI 4 \"=a,a\"))\n-   (clobber (match_scratch:SI 5 \"=X,h\"))]\n+   (clobber (match_scratch:SI 4 \"=X,h\"))]\n   \"ISA_HAS_MULHI\"\n   \"@\n    mult\\\\t%1,%2\n@@ -2604,8 +2614,7 @@\n \t\t    (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d,d\"))))\n \t  (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=l,l\"))\n-   (clobber (match_scratch:SI 4 \"=a,a\"))\n-   (clobber (match_scratch:SI 5 \"=X,h\"))]\n+   (clobber (match_scratch:SI 4 \"=X,h\"))]\n   \"ISA_HAS_MULHI\"\n   \"@\n    mulshi\\\\t%.,%1,%2\n@@ -2621,8 +2630,7 @@\n \t   (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n \t   (sign_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n          (const_int 64))))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+   (clobber (match_scratch:DI 3 \"=l\"))]\n   \"TARGET_64BIT\"\n   \"dmult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -2636,8 +2644,7 @@\n \t   (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n \t   (zero_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n \t  (const_int 64))))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+   (clobber (match_scratch:DI 3 \"=l\"))]\n   \"TARGET_64BIT\"\n   \"dmultu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -2652,21 +2659,18 @@\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d\"))\n \t\t (match_dup 0)))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_MAD\"\n   \"mad\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imadd\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-;; Only use this pattern in 32-bit code: see *muls_di.\n (define_insn \"*umul_acc_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n \t(plus:DI\n \t (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t (match_operand:DI 3 \"register_operand\" \"0\")))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t (match_operand:DI 3 \"register_operand\" \"0\")))]\n   \"(TARGET_MAD || ISA_HAS_MACC)\n    && !TARGET_64BIT\"\n   \"*\n@@ -2687,8 +2691,7 @@\n \t(plus:DI\n \t (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t  (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t (match_operand:DI 3 \"register_operand\" \"0\")))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t (match_operand:DI 3 \"register_operand\" \"0\")))]\n   \"(TARGET_MAD || ISA_HAS_MACC)\n    && !TARGET_64BIT\"\n   \"*\n@@ -2844,15 +2847,12 @@\n ;; available.\n \n (define_expand \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n \t(mod:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:SI 4 \"=l\"))\n-   (clobber (match_scratch:SI 5 \"=h\"))\n-   (clobber (match_scratch:SI 6 \"=a\"))]\n+\t\t(match_dup 2)))]\n   \"optimize\"\n   \"\n {\n@@ -2886,23 +2886,19 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=h\")\n \t(mod:SI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t(match_dup 2)))]\n   \"optimize\"\n   \"div\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"divmoddi4\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n-   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"\")\n \t(mod:DI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:DI 4 \"=l\"))\n-   (clobber (match_scratch:DI 5 \"=h\"))\n-   (clobber (match_scratch:DI 6 \"=a\"))]\n+\t\t(match_dup 2)))]\n   \"TARGET_64BIT && optimize\"\n   \"\n {\n@@ -2934,23 +2930,19 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n    (set (match_operand:DI 3 \"register_operand\" \"=h\")\n \t(mod:DI (match_dup 1)\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+\t\t(match_dup 2)))]\n   \"TARGET_64BIT && optimize\"\n   \"ddiv\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"udivmodsi4\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n \t(umod:SI (match_dup 1)\n-\t\t (match_dup 2)))\n-   (clobber (match_scratch:SI 4 \"=l\"))\n-   (clobber (match_scratch:SI 5 \"=h\"))\n-   (clobber (match_scratch:SI 6 \"=a\"))]\n+\t\t (match_dup 2)))]\n   \"optimize\"\n   \"\n {\n@@ -2972,23 +2964,19 @@\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=h\")\n \t(umod:SI (match_dup 1)\n-\t\t (match_dup 2)))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t (match_dup 2)))]\n   \"optimize\"\n   \"divu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"udivmoddi4\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"\")\n \t(umod:DI (match_dup 1)\n-\t\t (match_dup 2)))\n-   (clobber (match_scratch:DI 4 \"=l\"))\n-   (clobber (match_scratch:DI 5 \"=h\"))\n-   (clobber (match_scratch:DI 6 \"=a\"))]\n+\t\t (match_dup 2)))]\n   \"TARGET_64BIT && optimize\"\n   \"\n {\n@@ -3010,8 +2998,7 @@\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n    (set (match_operand:DI 3 \"register_operand\" \"=h\")\n \t(umod:DI (match_dup 1)\n-\t\t (match_dup 2)))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+\t\t (match_dup 2)))]\n   \"TARGET_64BIT && optimize\"\n   \"ddivu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -3111,11 +3098,9 @@\n    (set_attr \"length\" \"12\")])\n \n (define_expand \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"\")))]\n   \"!optimize\"\n   \"\n {\n@@ -3146,20 +3131,17 @@\n (define_insn \"divsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"!optimize\"\n   \"div\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"divdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:DI 3 \"=h\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n@@ -3187,20 +3169,17 @@\n (define_insn \"divdi3_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddiv\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")])\n \n (define_expand \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n-\t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mod:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"\")))]\n   \"!optimize\"\n   \"\n {\n@@ -3230,20 +3209,17 @@\n (define_insn \"modsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"!optimize\"\n   \"div\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"moddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n-\t(mod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(mod:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n@@ -3271,20 +3247,17 @@\n (define_insn \"moddi3_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(mod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddiv\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")])\n \n (define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n   \"!optimize\"\n   \"\n {\n@@ -3302,20 +3275,17 @@\n (define_insn \"udivsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"!optimize\"\n   \"divu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"udivdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"di\")))\n-   (clobber (match_scratch:DI 3 \"=h\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n@@ -3333,20 +3303,17 @@\n (define_insn \"udivdi3_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddivu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")])\n \n (define_expand \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n-\t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(umod:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n   \"!optimize\"\n   \"\n {\n@@ -3364,20 +3331,17 @@\n (define_insn \"umodsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"!optimize\"\n   \"divu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n (define_expand \"umoddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n-\t(umod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"di\")))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=a\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(umod:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n@@ -3395,9 +3359,8 @@\n (define_insn \"umoddi3_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(umod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=a\"))]\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddivu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -5143,17 +5106,17 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"length\"\t\"8,8,8,8,12,*,*,8\")])\n \n (define_insn \"movdi_internal2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*x,*d,*x,*a,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*J,*x,*d,*J,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*x,*d,*x,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*J,*x,*d,*d,*m,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,move,xfer,load,xfer,store,hilo,hilo,hilo,hilo,xfer,load,xfer,store\")\n+  [(set_attr \"type\"\t\"move,const,const,load,store,move,xfer,load,xfer,store,hilo,hilo,hilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,8,8,*,8,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,8,*,8,*\")])\n \n (define_insn \"*movdi_internal2_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m,*d\")\n@@ -5224,168 +5187,6 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-;; Handle input reloads in DImode.\n-;; This is mainly to handle reloading HILO_REGNUM.  Note that we may\n-;; see it as the source or the destination, depending upon which way\n-;; reload handles the instruction.\n-;; Making the second operand TImode is a trick.  The compiler may\n-;; reuse the same register for operand 0 and operand 2.  Using TImode\n-;; gives us two registers, so we can always use the one which is not\n-;; used.\n-\n-(define_expand \"reload_indi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=b\")\n-\t(match_operand:DI 1 \"\" \"b\"))\n-   (clobber (match_operand:TI 2 \"register_operand\" \"=&d\"))]\n-  \"TARGET_64BIT\"\n-  \"\n-{\n-  rtx scratch = gen_rtx_REG (DImode,\n-\t\t\t     (REGNO (operands[0]) == REGNO (operands[2])\n-\t\t\t      ? REGNO (operands[2]) + 1\n-\t\t\t      : REGNO (operands[2])));\n-\n-  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n-    {\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  rtx memword, offword, hi_word, lo_word;\n-\t  rtx addr = find_replacement (&XEXP (operands[1], 0));\n-\t  rtx op1 = replace_equiv_address (operands[1], addr);\n-\n-\t  scratch = gen_rtx_REG (SImode, REGNO (scratch));\n-\t  memword = adjust_address (op1, SImode, 0);\n-\t  offword = adjust_address (op1, SImode, 4);\n-\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      hi_word = memword;\n-\t      lo_word = offword;\n-\t    }\n-\t  else\n-\t    {\n-\t      hi_word = offword;\n-\t      lo_word = memword;\n-\t    }\n-\t  emit_move_insn (scratch, hi_word);\n-\t  emit_move_insn (gen_rtx_REG (SImode, 64), scratch);\n-\t  emit_move_insn (scratch, lo_word);\n-\t  emit_move_insn (gen_rtx (REG, SImode, 65), scratch);\n-\t  emit_insn (gen_hilo_delay (operands[0]));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_ashrdi3 (scratch, operands[1], GEN_INT (32)));\n-\t  emit_insn (gen_movdi (gen_rtx_REG (DImode, 64), scratch));\n-\t  emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n-\t  emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n-\t  emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n-          emit_insn (gen_hilo_delay (operands[0]));\n-\t}\n-      DONE;\n-    }\n-  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n-    {\n-      emit_insn (gen_movdi (scratch, gen_rtx_REG (DImode, 65)));\n-      emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n-      emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n-      emit_insn (gen_movdi (operands[0], gen_rtx_REG (DImode, 64)));\n-      emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n-      emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n-      emit_insn (gen_hilo_delay (operands[1]));\n-      DONE;\n-    }\n-  /* This handles moves between a float register and HI/LO.  */\n-  emit_move_insn (scratch, operands[1]);\n-  emit_move_insn (operands[0], scratch);\n-  DONE;\n-}\")\n-\n-;; Handle output reloads in DImode.\n-\n-;; Reloading HILO_REG in MIPS16 mode requires two scratch registers, so we\n-;; use a TImode scratch reg.\n-\n-(define_expand \"reload_outdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=b\")\n-\t(match_operand:DI 1 \"register_operand\" \"b\"))\n-   (clobber (match_operand:TI 2 \"register_operand\" \"=&d\"))]\n-  \"TARGET_64BIT\"\n-  \"\n-{\n-  rtx scratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n-\n-  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n-    {\n-      emit_insn (gen_ashrdi3 (scratch, operands[1], GEN_INT (32)));\n-      emit_insn (gen_movdi (gen_rtx (REG, DImode, 64), scratch));\n-      emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n-      emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n-      emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n-      emit_insn (gen_hilo_delay (operands[0]));\n-      DONE;\n-    }\n-  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n-    {\n-      if (GET_CODE (operands[0]) == MEM)\n-\t{\n-\t  rtx scratch, memword, offword, hi_word, lo_word;\n-\t  rtx addr = find_replacement (&XEXP (operands[0], 0));\n-\t  rtx op0 = replace_equiv_address (operands[0], addr);\n-\n-\t  scratch = gen_rtx_REG (SImode, REGNO (operands[2]));\n-\t  memword = adjust_address (op0, SImode, 0);\n-\t  offword = adjust_address (op0, SImode, 4);\n-\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      hi_word = memword;\n-\t      lo_word = offword;\n-\t    }\n-\t  else\n-\t    {\n-\t      hi_word = offword;\n-\t      lo_word = memword;\n-\t    }\n-\t  emit_move_insn (scratch, gen_rtx_REG (SImode, 64));\n-\t  emit_move_insn (hi_word, scratch);\n-\t  emit_move_insn (scratch, gen_rtx_REG (SImode, 65));\n-\t  emit_move_insn (lo_word, scratch);\n-\t  emit_insn (gen_hilo_delay (operands[1]));\n-\t}\n-      else if (TARGET_MIPS16 && ! M16_REG_P (REGNO (operands[0])))\n-\t{\n-\t  /* Handle the case where operand[0] is not a 'd' register,\n-\t     and hence we can not directly move from the HILO register\n-\t     into it.  */\n-\t  rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n-\t  emit_insn (gen_movdi (scratch, gen_rtx (REG, DImode, 65)));\n-\t  emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n-\t  emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n-\t  emit_insn (gen_movdi (scratch2, gen_rtx (REG, DImode, 64)));\n-\t  emit_insn (gen_ashldi3 (scratch2, scratch2, GEN_INT (32)));\n-\t  emit_insn (gen_iordi3 (scratch, scratch, scratch2));\n-\t  emit_insn (gen_movdi (operands[0], scratch));\n-\t  emit_insn (gen_hilo_delay (operands[1]));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_movdi (scratch, gen_rtx (REG, DImode, 65)));\n-\t  emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n-\t  emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n-\t  emit_insn (gen_movdi (operands[0], gen_rtx (REG, DImode, 64)));\n-\t  emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n-\t  emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n-\t  emit_insn (gen_hilo_delay (operands[1]));\n-\t}\n-      DONE;\n-    }\n-  /* This handles moves between a float register and HI/LO.  */\n-  emit_move_insn (scratch, operands[1]);\n-  emit_move_insn (operands[0], scratch);\n-  DONE;\n-}\")\n-\n ;; 32-bit Integer moves\n \n ;; Unlike most other insns, the move insns can't be split with\n@@ -5443,25 +5244,25 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*x,*d,*x,*d,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,J,*x,*d,*a,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*x,*d,*x,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,J,*x,*d,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,move,xfer,load,xfer,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,xfer,store\")\n+  [(set_attr \"type\"\t\"move,const,const,load,store,move,xfer,load,xfer,store,xfer,xfer,hilo,hilo,hilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,4,4,4,*,4,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,4,4,*,4,*\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m,*d,*d\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,U,m,d,*x,*a\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m,*d\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,U,m,d,*x\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,const,load,store,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,move,move,arith,arith,const,load,store,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n@@ -5476,7 +5277,6 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t (const_string \"*\")\n \t\t (const_string \"*\")\n \t\t (const_string \"*\")\n-\t\t (const_int 4)\n \t\t (const_int 4)])])\n \n ;; On the mips16, we can split lw $r,N($r) into an add and a load,\n@@ -5564,157 +5364,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = GEN_INT (- INTVAL (operands[1]));\n }\")\n \n-;; Reload HILO_REGNUM in SI mode.  This needs a scratch register in\n-;; order to set the sign bit correctly in the HI register.\n-\n-(define_expand \"reload_outsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=b\")\n-\t(match_operand:SI 1 \"register_operand\" \"b\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=&d\"))]\n-  \"TARGET_64BIT || TARGET_MIPS16\"\n-  \"\n-{\n-  if (TARGET_64BIT\n-      && GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n-    {\n-      emit_insn (gen_movsi (gen_rtx_REG (SImode, 65), operands[1]));\n-      emit_insn (gen_ashrsi3 (operands[2], operands[1], GEN_INT (31)));\n-      emit_insn (gen_movsi (gen_rtx (REG, SImode, 64), operands[2]));\n-      emit_insn (gen_hilo_delay (operands[0]));\n-      DONE;\n-    }\n-  /* Use a mult to reload LO on mips16.  ??? This is hideous.  */\n-  if (TARGET_MIPS16\n-      && GET_CODE (operands[0]) == REG && REGNO (operands[0]) == LO_REGNUM)\n-    {\n-      emit_insn (gen_movsi (operands[2], GEN_INT (1)));\n-      /* This is gen_mulsi3_internal, but we need to fill in the\n-\t scratch registers.  */\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t  gen_rtvec (3,\n-\t\t\t\t     gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t      operands[0],\n-\t\t\t\t\t      gen_rtx (MULT, SImode,\n-\t\t\t\t\t\t       operands[1],\n-\t\t\t\t\t\t       operands[2])),\n-\t\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t      gen_rtx (REG, SImode, 64)),\n-\t\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t      gen_rtx (REG, SImode, 66)))));\n-      DONE;\n-    }\n-  /* FIXME: I don't know how to get a value into the HI register.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && (TARGET_MIPS16 ? M16_REG_P (REGNO (operands[0]))\n-\t  : GP_REG_P (REGNO (operands[0]))))\n-    {\n-      emit_move_insn (operands[0], operands[1]);\n-      DONE;\n-    }\n-  /* This handles moves between a float register and HI/LO.  */\n-  emit_move_insn (operands[2], operands[1]);\n-  emit_move_insn (operands[0], operands[2]);\n-  DONE;\n-}\")\n-\n-;; Reload a value into HI or LO.  There is no mthi or mtlo on mips16,\n-;; so we use a mult.  ??? This is hideous, and we ought to figure out\n-;; something better.\n-\n-;; We use no predicate for operand1, because it may be a PLUS, and there\n-;; is no convenient predicate for that.\n-\n-(define_expand \"reload_insi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n-\t(match_operand:SI 1 \"\" \"b\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=&d\"))]\n-  \"TARGET_MIPS16\"\n-  \"\n-{\n-  if (TARGET_MIPS16\n-      && GET_CODE (operands[0]) == REG && REGNO (operands[0]) == LO_REGNUM)\n-    {\n-      emit_insn (gen_movsi (operands[2], GEN_INT (1)));\n-      /* This is gen_mulsi3_internal, but we need to fill in the\n-\t scratch registers.  */\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t  gen_rtvec (3,\n-\t\t\t\t     gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t      operands[0],\n-\t\t\t\t\t      gen_rtx (MULT, SImode,\n-\t\t\t\t\t\t       operands[1],\n-\t\t\t\t\t\t       operands[2])),\n-\t\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t      gen_rtx (REG, SImode, 64)),\n-\t\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t      gen_rtx (REG, SImode, 66)))));\n-      DONE;\n-    }\n-\n-  /* If this is a plus, then this must be an add of the stack pointer against\n-     either a hard register or a pseudo.  */\n-  if (TARGET_MIPS16 && GET_CODE (operands[1]) == PLUS)\n-    {\n-      rtx plus_op;\n-\n-      if (XEXP (operands[1], 0) == stack_pointer_rtx)\n-\tplus_op = XEXP (operands[1], 1);\n-      else if (XEXP (operands[1], 1) == stack_pointer_rtx)\n-\tplus_op = XEXP (operands[1], 0);\n-      else\n-\tabort ();\n-\n-      /* We should have a register now.  */\n-      if (GET_CODE (plus_op) != REG)\n-\tabort ();\n-\n-      if (REGNO (plus_op) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  /* We have to have at least one temporary register which is not\n-\t     overlapping plus_op.  */\n-\t  if (! rtx_equal_p (plus_op, operands[0]))\n-\t    {\n-\t      emit_move_insn (operands[0], stack_pointer_rtx);\n-\t      emit_insn (gen_addsi3 (operands[0], operands[0], plus_op));\n-\t    }\n-\t  else if (! rtx_equal_p (plus_op, operands[2]))\n-\t    {\n-\t      emit_move_insn (operands[2], stack_pointer_rtx);\n-\t      emit_insn (gen_addsi3 (operands[0], plus_op, operands[2]));\n-\t    }\n-\t  else\n-\t    abort ();\n-\t}\n-      else\n-\t{\n-\t  /* We need two registers in this case.  */\n-\t  if (! rtx_equal_p (operands[0], operands[2]))\n-\t    {\n-\t      emit_move_insn (operands[0], stack_pointer_rtx);\n-\t      emit_move_insn (operands[2], plus_op);\n-\t      emit_insn (gen_addsi3 (operands[0], operands[0], operands[2]));\n-\t    }\n-\t  else\n-\t    abort ();\n-\t}\n-      DONE;\n-    }\n-\n-  /* FIXME: I don't know how to get a value into the HI register.  */\n-  emit_move_insn (operands[0], operands[1]);\n-  DONE;\n-}\")\n-\n-;; This insn is for the unspec delay for HILO.\n-\n-(define_insn \"hilo_delay\"\n-  [(unspec [(match_operand 0 \"register_operand\" \"=b\")] UNSPEC_HILO_DELAY)]\n-  \"\"\n-  \"\"\n-  [(set_attr \"type\" \"nop\")\n-   (set_attr \"mode\" \"none\")\n-   (set_attr \"can_delay\" \"no\")])\n-\n ;; This insn handles moving CCmode values.  It's really just a\n ;; slightly simplified copy of movsi_internal2, with additional cases\n ;; to move a condition register to a general register and to move"}]}