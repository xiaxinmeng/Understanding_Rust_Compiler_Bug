{"sha": "f86624d85f937e03110eb044e438d8316d860501", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg2NjI0ZDg1ZjkzN2UwMzExMGViMDQ0ZTQzOGQ4MzE2ZDg2MDUwMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-02-27T08:41:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-02-27T08:41:01Z"}, "message": "re PR tree-optimization/89280 (ICE: Segmentation fault (in is_gimple_reg_type))\n\n\tPR tree-optimization/89280\n\t* tree-cfgcleanup.c (maybe_dead_abnormal_edge_p,\n\tbuiltin_setjmp_setup_bb): New functions.\n\t(cleanup_control_flow_pre): Ignore maybe_dead_abnormal_edge_p edges.\n\tWhen visiting __builtin_setjmp_setup block, queue in special\n\tsetjmp_vec vector edges from .ABNORMAL_DISPATCHER to corresponding\n\t__builtin_setjmp_receiver.  Remove .ABNORMAL_DISPATCHER basic blocks\n\tfrom visited after the loop if they don't have any visited successor\n\tblocks.\n\n\t* gcc.c-torture/compile/pr89280.c: New test.\n\t* gcc.dg/torture/pr57147-2.c: Don't expect a setjmp after noreturn\n\tfunction.  Skip the test for -O0.\n\nFrom-SVN: r269243", "tree": {"sha": "66c4d0dd87dc43efd7efd427e5e150dfad26917e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66c4d0dd87dc43efd7efd427e5e150dfad26917e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f86624d85f937e03110eb044e438d8316d860501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f86624d85f937e03110eb044e438d8316d860501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f86624d85f937e03110eb044e438d8316d860501", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f86624d85f937e03110eb044e438d8316d860501/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e0ed736065afad7da7850f508f316f2954d8960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0ed736065afad7da7850f508f316f2954d8960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0ed736065afad7da7850f508f316f2954d8960"}], "stats": {"total": 217, "additions": 213, "deletions": 4}, "files": [{"sha": "961131bcf03b286b4c7a438dbb37e13abbc62014", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86624d85f937e03110eb044e438d8316d860501/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86624d85f937e03110eb044e438d8316d860501/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f86624d85f937e03110eb044e438d8316d860501", "patch": "@@ -1,3 +1,15 @@\n+2019-02-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/89280\n+\t* tree-cfgcleanup.c (maybe_dead_abnormal_edge_p,\n+\tbuiltin_setjmp_setup_bb): New functions.\n+\t(cleanup_control_flow_pre): Ignore maybe_dead_abnormal_edge_p edges.\n+\tWhen visiting __builtin_setjmp_setup block, queue in special\n+\tsetjmp_vec vector edges from .ABNORMAL_DISPATCHER to corresponding\n+\t__builtin_setjmp_receiver.  Remove .ABNORMAL_DISPATCHER basic blocks\n+\tfrom visited after the loop if they don't have any visited successor\n+\tblocks.\n+\n 2018-02-26  Steve Ellcey  <sellcey@marvell.com>\n \n \t* config/aarch64/aarch64.c (aarch64_get_multilib_abi_name):"}, {"sha": "71ff3fa9aa99abe6191cf6d6d524e4289cc93e1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f86624d85f937e03110eb044e438d8316d860501", "patch": "@@ -1,3 +1,10 @@\n+2019-02-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/89280\n+\t* gcc.c-torture/compile/pr89280.c: New test.\n+\t* gcc.dg/torture/pr57147-2.c: Don't expect a setjmp after noreturn\n+\tfunction.  Skip the test for -O0.\n+\n 2018-02-26  Steve Ellcey  <sellcey@marvell.com>\n \n \t* gfortran.dg/simd-builtins-1.f90: Update for aarch64*-*-*."}, {"sha": "9db9965172fb831c011c794da28a96dd795bb241", "filename": "gcc/testsuite/gcc.c-torture/compile/pr89280.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr89280.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr89280.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr89280.c?ref=f86624d85f937e03110eb044e438d8316d860501", "patch": "@@ -0,0 +1,48 @@\n+/* PR tree-optimization/89280 */\n+\n+int a;\n+void foo (void);\n+__attribute__ ((returns_twice)) int bar (void);\n+void baz (int, int);\n+void *buf[5];\n+\n+static inline void\n+inl (int x)\n+{\n+  while (x)\n+    foo ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  for (;;)\n+    foo ();\n+  baz (bar (), a);\n+}\n+\n+void\n+test2 (void)\n+{\n+  for (;;)\n+    foo ();\n+  baz (__builtin_setjmp (buf), a);\n+  if (a)\n+    __builtin_longjmp (buf, 1);\n+}\n+\n+void\n+test3 (void)\n+{\n+  inl (1);\n+  baz (bar (), a);\n+}\n+\n+void\n+test4 (void)\n+{\n+  inl (2);\n+  baz (__builtin_setjmp (buf), a);\n+  if (a)\n+    __builtin_longjmp (buf, 1);\n+}"}, {"sha": "bbfd13d2932b7f0329a6b985f81373e05b2eb994", "filename": "gcc/testsuite/gcc.dg/torture/pr57147-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-2.c?ref=f86624d85f937e03110eb044e438d8316d860501", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-fdump-tree-optimized\" } */\n /* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n /* { dg-require-effective-target indirect_jumps } */\n \n struct __jmp_buf_tag {};\n@@ -19,4 +20,4 @@ void TestSyscall(void)\n   _setjmp (g_return_jmp_buf);\n }\n \n-/* { dg-final { scan-tree-dump \"setjmp\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"setjmp\" \"optimized\" } } */"}, {"sha": "63db3308344341cbcae1ca1694aa4070684ea571", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 144, "deletions": 3, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f86624d85f937e03110eb044e438d8316d860501/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=f86624d85f937e03110eb044e438d8316d860501", "patch": "@@ -723,6 +723,97 @@ cleanup_tree_cfg_bb (basic_block bb)\n   return false;\n }\n \n+/* Return true if E is an EDGE_ABNORMAL edge for returns_twice calls,\n+   i.e. one going from .ABNORMAL_DISPATCHER to basic block which doesn't\n+   start with a forced or nonlocal label.  Calls which return twice can return\n+   the second time only if they are called normally the first time, so basic\n+   blocks which can be only entered through these abnormal edges but not\n+   normally are effectively unreachable as well.  Additionally ignore\n+   __builtin_setjmp_receiver starting blocks, which have one FORCED_LABEL\n+   and which are always only reachable through EDGE_ABNORMAL edge.  They are\n+   handled in cleanup_control_flow_pre.  */\n+\n+static bool\n+maybe_dead_abnormal_edge_p (edge e)\n+{\n+  if ((e->flags & (EDGE_ABNORMAL | EDGE_EH)) != EDGE_ABNORMAL)\n+    return false;\n+\n+  gimple_stmt_iterator gsi = gsi_start_nondebug_after_labels_bb (e->src);\n+  gimple *g = gsi_stmt (gsi);\n+  if (!g || !gimple_call_internal_p (g, IFN_ABNORMAL_DISPATCHER))\n+    return false;\n+\n+  tree target = NULL_TREE;\n+  for (gsi = gsi_start_bb (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gsi)))\n+      {\n+\ttree this_target = gimple_label_label (label_stmt);\n+\tif (DECL_NONLOCAL (this_target))\n+\t  return false;\n+\tif (FORCED_LABEL (this_target))\n+\t  {\n+\t    if (target)\n+\t      return false;\n+\t    target = this_target;\n+\t  }\n+      }\n+    else\n+      break;\n+\n+  if (target)\n+    {\n+      /* If there was a single FORCED_LABEL, check for\n+\t __builtin_setjmp_receiver with address of that label.  */\n+      if (!gsi_end_p (gsi) && is_gimple_debug (gsi_stmt (gsi)))\n+\tgsi_next_nondebug (&gsi);\n+      if (gsi_end_p (gsi))\n+\treturn false;\n+      if (!gimple_call_builtin_p (gsi_stmt (gsi), BUILT_IN_SETJMP_RECEIVER))\n+\treturn false;\n+\n+      tree arg = gimple_call_arg (gsi_stmt (gsi), 0);\n+      if (TREE_CODE (arg) != ADDR_EXPR || TREE_OPERAND (arg, 0) != target)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* If BB is a basic block ending with __builtin_setjmp_setup, return edge\n+   from .ABNORMAL_DISPATCHER basic block to corresponding\n+   __builtin_setjmp_receiver basic block, otherwise return NULL.  */\n+static edge\n+builtin_setjmp_setup_bb (basic_block bb)\n+{\n+  if (EDGE_COUNT (bb->succs) != 2\n+      || ((EDGE_SUCC (bb, 0)->flags\n+\t   & (EDGE_ABNORMAL | EDGE_EH)) != EDGE_ABNORMAL\n+\t  && (EDGE_SUCC (bb, 1)->flags\n+\t      & (EDGE_ABNORMAL | EDGE_EH)) != EDGE_ABNORMAL))\n+    return NULL;\n+\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n+  if (gsi_end_p (gsi)\n+      || !gimple_call_builtin_p (gsi_stmt (gsi), BUILT_IN_SETJMP_SETUP))\n+    return NULL;\n+\n+  tree arg = gimple_call_arg (gsi_stmt (gsi), 1);\n+  if (TREE_CODE (arg) != ADDR_EXPR\n+      || TREE_CODE (TREE_OPERAND (arg, 0)) != LABEL_DECL)\n+    return NULL;\n+\n+  basic_block recv_bb = label_to_block (cfun, TREE_OPERAND (arg, 0));\n+  if (EDGE_COUNT (recv_bb->preds) != 1\n+      || (EDGE_PRED (recv_bb, 0)->flags\n+\t  & (EDGE_ABNORMAL | EDGE_EH)) != EDGE_ABNORMAL\n+      || (EDGE_SUCC (bb, 0)->dest != EDGE_PRED (recv_bb, 0)->src\n+\t  && EDGE_SUCC (bb, 1)->dest != EDGE_PRED (recv_bb, 0)->src))\n+    return NULL;\n+\n+  /* EDGE_PRED (recv_bb, 0)->src should be the .ABNORMAL_DISPATCHER bb.  */\n+  return EDGE_PRED (recv_bb, 0);\n+}\n+\n /* Do cleanup_control_flow_bb in PRE order.  */\n \n static bool\n@@ -736,10 +827,13 @@ cleanup_control_flow_pre ()\n   dom_state saved_state = dom_info_state (CDI_DOMINATORS);\n   set_dom_info_availability (CDI_DOMINATORS, DOM_NONE);\n \n-  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n+  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 2);\n   auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n \n+  vec<edge, va_gc> *setjmp_vec = NULL;\n+  auto_vec<basic_block, 4> abnormal_dispatchers;\n+\n   stack.quick_push (ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs));\n \n   while (! stack.is_empty ())\n@@ -749,12 +843,37 @@ cleanup_control_flow_pre ()\n       basic_block dest = ei_edge (ei)->dest;\n \n       if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t  && ! bitmap_bit_p (visited, dest->index))\n+\t  && !bitmap_bit_p (visited, dest->index)\n+\t  && (ei_container (ei) == setjmp_vec\n+\t      || !maybe_dead_abnormal_edge_p (ei_edge (ei))))\n \t{\n \t  bitmap_set_bit (visited, dest->index);\n \t  /* We only possibly remove edges from DEST here, leaving\n \t     possibly unreachable code in the IL.  */\n \t  retval |= cleanup_control_flow_bb (dest);\n+\n+\t  /* Check for __builtin_setjmp_setup.  Edges from .ABNORMAL_DISPATCH\n+\t     to __builtin_setjmp_receiver will be normally ignored by\n+\t     maybe_dead_abnormal_edge_p.  If DEST is a visited\n+\t     __builtin_setjmp_setup, queue edge from .ABNORMAL_DISPATCH\n+\t     to __builtin_setjmp_receiver, so that it will be visited too.  */\n+\t  if (edge e = builtin_setjmp_setup_bb (dest))\n+\t    {\n+\t      vec_safe_push (setjmp_vec, e);\n+\t      if (vec_safe_length (setjmp_vec) == 1)\n+\t\tstack.quick_push (ei_start (setjmp_vec));\n+\t    }\n+\n+\t  if ((ei_edge (ei)->flags\n+\t       & (EDGE_ABNORMAL | EDGE_EH)) == EDGE_ABNORMAL)\n+\t    {\n+\t      gimple_stmt_iterator gsi\n+\t\t= gsi_start_nondebug_after_labels_bb (dest);\n+\t      gimple *g = gsi_stmt (gsi);\n+\t      if (g && gimple_call_internal_p (g, IFN_ABNORMAL_DISPATCHER))\n+\t\tabnormal_dispatchers.safe_push (dest);\n+\t    }\n+\n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    stack.quick_push (ei_start (dest->succs));\n \t}\n@@ -763,10 +882,32 @@ cleanup_control_flow_pre ()\n \t  if (!ei_one_before_end_p (ei))\n \t    ei_next (&stack.last ());\n \t  else\n-\t    stack.pop ();\n+\t    {\n+\t      if (ei_container (ei) == setjmp_vec)\n+\t\tvec_safe_truncate (setjmp_vec, 0);\n+\t      stack.pop ();\n+\t    }\n \t}\n     }\n \n+  vec_free (setjmp_vec);\n+\n+  /* If we've marked .ABNORMAL_DISPATCHER basic block(s) as visited\n+     above, but haven't marked any of their successors as visited,\n+     unmark them now, so that they can be removed as useless.  */\n+  basic_block dispatcher_bb;\n+  unsigned int k;\n+  FOR_EACH_VEC_ELT (abnormal_dispatchers, k, dispatcher_bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, dispatcher_bb->succs)\n+\tif (bitmap_bit_p (visited, e->dest->index))\n+\t  break;\n+      if (e == NULL)\n+\tbitmap_clear_bit (visited, dispatcher_bb->index);\n+    }\n+\n   set_dom_info_availability (CDI_DOMINATORS, saved_state);\n \n   /* We are deleting BBs in non-reverse dominator order, make sure"}]}