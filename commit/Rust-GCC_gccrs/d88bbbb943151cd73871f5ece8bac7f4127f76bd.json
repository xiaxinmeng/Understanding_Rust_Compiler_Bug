{"sha": "d88bbbb943151cd73871f5ece8bac7f4127f76bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg4YmJiYjk0MzE1MWNkNzM4NzFmNWVjZThiYWM3ZjQxMjdmNzZiZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-16T11:54:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-16T11:54:51Z"}, "message": "ada-tree.def (LOOP_STMT): Change to 4-operand nodes.\n\n\t* gcc-interface/ada-tree.def (LOOP_STMT): Change to 4-operand nodes.\n\t* gcc-interface/ada-tree.h (LOOP_STMT_TOP_COND, LOOP_STMT_BOT_COND):\n\tMerge into...\n\t(LOOP_STMT_COND): ...this.\n\t(LOOP_STMT_BOTTOM_COND_P): New flag.\n\t(LOOP_STMT_TOP_UPDATE_P): Likewise.\n\t* gcc-interface/trans.c (can_equal_min_or_max_val_p): New function.\n\t(can_equal_min_val_p): New static inline function.\n\t(can_equal_max_val_p): Likewise.\n\t(Loop_Statement_to_gnu): Use build4 in lieu of build5 and adjust to\n\tnew LOOP_STMT semantics.  Use two different strategies depending on\n\twhether optimization is enabled to translate the loop.\n\t(gnat_gimplify_stmt) <LOOP_STMT>: Adjust to new LOOP_STMT semantics.\n\nFrom-SVN: r158410", "tree": {"sha": "6a87c87320850dbe05f19ab839a5e767dc0c7bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a87c87320850dbe05f19ab839a5e767dc0c7bd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d88bbbb943151cd73871f5ece8bac7f4127f76bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88bbbb943151cd73871f5ece8bac7f4127f76bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d88bbbb943151cd73871f5ece8bac7f4127f76bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88bbbb943151cd73871f5ece8bac7f4127f76bd/comments", "author": null, "committer": null, "parents": [{"sha": "586388fd723b7c59d97304607357ca13dd3d20d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586388fd723b7c59d97304607357ca13dd3d20d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586388fd723b7c59d97304607357ca13dd3d20d9"}], "stats": {"total": 296, "additions": 229, "deletions": 67}, "files": [{"sha": "e14bd9af418ef74fb9c58788f80b8d64a6ac4060", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d88bbbb943151cd73871f5ece8bac7f4127f76bd", "patch": "@@ -1,3 +1,19 @@\n+2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.def (LOOP_STMT): Change to 4-operand nodes.\n+\t* gcc-interface/ada-tree.h (LOOP_STMT_TOP_COND, LOOP_STMT_BOT_COND):\n+\tMerge into...\n+\t(LOOP_STMT_COND): ...this.\n+\t(LOOP_STMT_BOTTOM_COND_P): New flag.\n+\t(LOOP_STMT_TOP_UPDATE_P): Likewise.\n+\t* gcc-interface/trans.c (can_equal_min_or_max_val_p): New function.\n+\t(can_equal_min_val_p): New static inline function.\n+\t(can_equal_max_val_p): Likewise.\n+\t(Loop_Statement_to_gnu): Use build4 in lieu of build5 and adjust to\n+\tnew LOOP_STMT semantics.  Use two different strategies depending on\n+\twhether optimization is enabled to translate the loop.\n+\t(gnat_gimplify_stmt) <LOOP_STMT>: Adjust to new LOOP_STMT semantics.\n+\n 2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* uintp.adb (UI_From_Dint): Remove useless code."}, {"sha": "93967b58cb33622820a9d762f0f798f46d9a4d2f", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=d88bbbb943151cd73871f5ece8bac7f4127f76bd", "patch": "@@ -61,12 +61,11 @@ DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", tcc_reference, 1)\n    just returning the inner statement.  */\n DEFTREECODE (STMT_STMT, \"stmt_stmt\", tcc_statement, 1)\n \n-/* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n-   loop at the top and bottom respectively.  LOOP_STMT_UPDATE is the statement\n-   to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n-   statements in the body of the loop.  LOOP_STMT_LABEL points to the\n-   LABEL_DECL of the end label of the loop.  */\n-DEFTREECODE (LOOP_STMT, \"loop_stmt\", tcc_statement, 5)\n+/* A loop.  LOOP_STMT_COND is the test to exit the loop.  LOOP_STMT_UPDATE\n+   is the statement to update the loop iteration variable at the continue\n+   point.  LOOP_STMT_BODY are the statements in the body of the loop.  And\n+   LOOP_STMT_LABEL points to the LABEL_DECL of the end label of the loop.  */\n+DEFTREECODE (LOOP_STMT, \"loop_stmt\", tcc_statement, 4)\n \n /* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n    true, will cause the loop to be exited.  If no condition is specified,"}, {"sha": "60a5595fe22c3609fababc8740c06bf6e59029b9", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=d88bbbb943151cd73871f5ece8bac7f4127f76bd", "patch": "@@ -417,10 +417,28 @@ do {\t\t\t\t\t\t   \\\n   (STATEMENT_CLASS_P (NODE) && TREE_CODE (NODE) >= STMT_STMT)\n \n #define STMT_STMT_STMT(NODE)     TREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n-#define LOOP_STMT_TOP_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n-#define LOOP_STMT_BOT_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)\n-#define LOOP_STMT_UPDATE(NODE)   TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n-#define LOOP_STMT_BODY(NODE)     TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n-#define LOOP_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n+\n+#define LOOP_STMT_COND(NODE)     TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n+#define LOOP_STMT_UPDATE(NODE)   TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)\n+#define LOOP_STMT_BODY(NODE)     TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n+#define LOOP_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n+\n+/* A loop statement is conceptually made up of 6 sub-statements:\n+\n+    loop:\n+      TOP_CONDITION\n+      TOP_UPDATE\n+      BODY\n+      BOTTOM_CONDITION\n+      BOTTOM_UPDATE\n+      GOTO loop\n+\n+  However, only 4 of them can exist for a given loop, the pair of conditions\n+  and the pair of updates being mutually exclusive.  The default setting is\n+  TOP_CONDITION and BOTTOM_UPDATE and the following couple of flags are used\n+  to toggle the individual settings.  */\n+#define LOOP_STMT_BOTTOM_COND_P(NODE) TREE_LANG_FLAG_0 (LOOP_STMT_CHECK (NODE))\n+#define LOOP_STMT_TOP_UPDATE_P(NODE)  TREE_LANG_FLAG_1 (LOOP_STMT_CHECK (NODE))\n+\n #define EXIT_STMT_COND(NODE)     TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n #define EXIT_STMT_LABEL(NODE)    TREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)"}, {"sha": "144d8c53d1b617c42659f5e3f2061061b9fe7081", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 185, "deletions": 56, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88bbbb943151cd73871f5ece8bac7f4127f76bd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=d88bbbb943151cd73871f5ece8bac7f4127f76bd", "patch": "@@ -2046,15 +2046,55 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n+/* Return true if VAL (of type TYPE) can equal the minimum value if MAX is\n+   false, or the maximum value if MAX is true, of TYPE.  */\n+\n+static bool\n+can_equal_min_or_max_val_p (tree val, tree type, bool max)\n+{\n+  tree min_or_max_val = (max ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type));\n+\n+  if (TREE_CODE (min_or_max_val) != INTEGER_CST)\n+    return true;\n+\n+  if (TREE_CODE (val) == NOP_EXPR)\n+    val = (max\n+\t   ? TYPE_MAX_VALUE (TREE_TYPE (TREE_OPERAND (val, 0)))\n+\t   : TYPE_MIN_VALUE (TREE_TYPE (TREE_OPERAND (val, 0))));\n+\n+  if (TREE_CODE (val) != INTEGER_CST)\n+    return true;\n+\n+  return tree_int_cst_equal (val, min_or_max_val) == 1;\n+}\n+\n+/* Return true if VAL (of type TYPE) can equal the minimum value of TYPE.\n+   If REVERSE is true, minimum value is taken as maximum value.  */\n+\n+static inline bool\n+can_equal_min_val_p (tree val, tree type, bool reverse)\n+{\n+  return can_equal_min_or_max_val_p (val, type, reverse);\n+}\n+\n+/* Return true if VAL (of type TYPE) can equal the maximum value of TYPE.\n+   If REVERSE is true, maximum value is taken as minimum value.  */\n+\n+static inline bool\n+can_equal_max_val_p (tree val, tree type, bool reverse)\n+{\n+  return can_equal_min_or_max_val_p (val, type, !reverse);\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n    to a GCC tree, which is returned.  */\n \n static tree\n Loop_Statement_to_gnu (Node_Id gnat_node)\n {\n   const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n-  tree gnu_loop_stmt = build5 (LOOP_STMT, void_type_node, NULL_TREE,\n-\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n+  tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n+\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n   tree gnu_loop_label = create_artificial_label (input_location);\n   tree gnu_loop_var = NULL_TREE, gnu_cond_expr = NULL_TREE;\n   tree gnu_result;\n@@ -2076,7 +2116,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n   /* For the case \"WHILE condition LOOP ..... END LOOP;\" it's immediate.  */\n   else if (Present (Condition (gnat_iter_scheme)))\n-    LOOP_STMT_TOP_COND (gnu_loop_stmt)\n+    LOOP_STMT_COND (gnu_loop_stmt)\n       = gnat_to_gnu (Condition (gnat_iter_scheme));\n \n   /* Otherwise we have an iteration scheme and the condition is given by the\n@@ -2090,44 +2130,139 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       tree gnu_low = TYPE_MIN_VALUE (gnu_type);\n       tree gnu_high = TYPE_MAX_VALUE (gnu_type);\n       tree gnu_base_type = get_base_type (gnu_type);\n-      tree gnu_first, gnu_last, gnu_limit, gnu_test;\n-      enum tree_code update_code, test_code;\n+      tree gnu_one_node = convert (gnu_base_type, integer_one_node);\n+      tree gnu_first, gnu_last;\n+      enum tree_code update_code, test_code, shift_code;\n+      bool reverse = Reverse_Present (gnat_loop_spec), fallback = false;\n \n       /* We must disable modulo reduction for the iteration variable, if any,\n \t in order for the loop comparison to be effective.  */\n-      if (Reverse_Present (gnat_loop_spec))\n+      if (reverse)\n \t{\n \t  gnu_first = gnu_high;\n \t  gnu_last = gnu_low;\n \t  update_code = MINUS_NOMOD_EXPR;\n \t  test_code = GE_EXPR;\n-\t  gnu_limit = TYPE_MIN_VALUE (gnu_base_type);\n+\t  shift_code = PLUS_NOMOD_EXPR;\n \t}\n       else\n \t{\n \t  gnu_first = gnu_low;\n \t  gnu_last = gnu_high;\n \t  update_code = PLUS_NOMOD_EXPR;\n \t  test_code = LE_EXPR;\n-\t  gnu_limit = TYPE_MAX_VALUE (gnu_base_type);\n+\t  shift_code = MINUS_NOMOD_EXPR;\n+\t}\n+\n+      /* We use two different strategies to translate the loop, depending on\n+\t whether optimization is enabled.\n+\n+\t If it is, we try to generate the canonical form of loop expected by\n+\t the loop optimizer, which is the do-while form:\n+\n+\t     ENTRY_COND\n+\t   loop:\n+\t     TOP_UPDATE\n+\t     BODY\n+\t     BOTTOM_COND\n+\t     GOTO loop\n+\n+\t This makes it possible to bypass loop header copying and to turn the\n+\t BOTTOM_COND into an inequality test.  This should catch (almost) all\n+\t loops with constant starting point.  If we cannot, we try to generate\n+\t the default form, which is:\n+\n+\t   loop:\n+\t     TOP_COND\n+\t     BODY\n+\t     BOTTOM_UPDATE\n+\t     GOTO loop\n+\n+\t It will be rotated during loop header copying and an entry test added\n+\t to yield the do-while form.  This should catch (almost) all loops with\n+\t constant ending point.  If we cannot, we generate the fallback form:\n+\n+\t     ENTRY_COND\n+\t   loop:\n+\t     BODY\n+\t     BOTTOM_COND\n+\t     BOTTOM_UPDATE\n+\t     GOTO loop\n+\n+\t which works in all cases but for which loop header copying will copy\n+\t the BOTTOM_COND, thus adding a third conditional branch.\n+\n+\t If optimization is disabled, loop header copying doesn't come into\n+\t play and we try to generate the loop forms with the less conditional\n+\t branches directly.  First, the default form, it should catch (almost)\n+\t all loops with constant ending point.  Then, if we cannot, we try to\n+\t generate the shifted form:\n+\n+\t   loop:\n+\t     TOP_COND\n+\t     TOP_UPDATE\n+\t     BODY\n+\t     GOTO loop\n+\n+\t which should catch loops with constant starting point.  Otherwise, if\n+\t we cannot, we generate the fallback form.  */\n+\n+      if (optimize)\n+\t{\n+\t  /* We can use the do-while form if GNU_FIRST-1 doesn't overflow.  */\n+\t  if (!can_equal_min_val_p (gnu_first, gnu_base_type, reverse))\n+\t    {\n+\t      gnu_first = build_binary_op (shift_code, gnu_base_type,\n+\t\t\t\t\t   gnu_first, gnu_one_node);\n+\t      LOOP_STMT_TOP_UPDATE_P (gnu_loop_stmt) = 1;\n+\t      LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n+\t    }\n+\n+\t  /* Otherwise, we can use the default form if GNU_LAST+1 doesn't.  */\n+\t  else if (!can_equal_max_val_p (gnu_last, gnu_base_type, reverse))\n+\t    ;\n+\n+\t  /* Otherwise, use the fallback form.  */\n+\t  else\n+\t    fallback = true;\n+\t}\n+      else\n+\t{\n+\t  /* We can use the default form if GNU_LAST+1 doesn't overflow.  */\n+\t  if (!can_equal_max_val_p (gnu_last, gnu_base_type, reverse))\n+\t    ;\n+\n+\t  /* Otherwise, we can use the shifted form if neither GNU_FIRST-1 nor\n+\t     GNU_LAST-1 does.  */\n+\t  else if (!can_equal_min_val_p (gnu_first, gnu_base_type, reverse)\n+\t\t   && !can_equal_min_val_p (gnu_last, gnu_base_type, reverse))\n+\t    {\n+\t      gnu_first = build_binary_op (shift_code, gnu_base_type,\n+\t\t\t\t\t   gnu_first, gnu_one_node);\n+\t      gnu_last = build_binary_op (shift_code, gnu_base_type,\n+\t\t\t\t          gnu_last, gnu_one_node);\n+\t      LOOP_STMT_TOP_UPDATE_P (gnu_loop_stmt) = 1;\n+\t    }\n+\n+\t  /* Otherwise, use the fallback form.  */\n+\t  else\n+\t    fallback = true;\n \t}\n \n-      /* We know that the iteration variable will not overflow if GNU_LAST is\n-\t a constant and is not equal to GNU_LIMIT.  If it might overflow, we\n-\t have to turn the limit test into an inequality test and move it to\n-\t the end of the loop; as a consequence, we also have to test for an\n-\t empty loop before entering it.  */\n-      if (TREE_CODE (gnu_last) != INTEGER_CST\n-\t  || TREE_CODE (gnu_limit) != INTEGER_CST\n-\t  || tree_int_cst_equal (gnu_last, gnu_limit))\n+      if (fallback)\n+\tLOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n+\n+      /* If we use the BOTTOM_COND, we can turn the test into an inequality\n+\t test but we have to add an ENTRY_COND to protect the empty loop.  */\n+      if (LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt))\n \t{\n+\t  test_code = NE_EXPR;\n \t  gnu_cond_expr\n \t    = build3 (COND_EXPR, void_type_node,\n \t\t      build_binary_op (LE_EXPR, integer_type_node,\n \t\t\t\t       gnu_low, gnu_high),\n \t\t      NULL_TREE, alloc_stmt_list ());\n \t  set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n-\t  test_code = NE_EXPR;\n \t}\n \n       /* Open a new nesting level that will surround the loop to declare the\n@@ -2143,23 +2278,17 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       /* Do all the arithmetics in the base type.  */\n       gnu_loop_var = convert (gnu_base_type, gnu_loop_var);\n \n-      /* Set either the top or bottom exit condition as appropriate depending\n-\t on whether or not we know an overflow cannot occur.  */\n-      gnu_test = build_binary_op (test_code, integer_type_node, gnu_loop_var,\n-\t\t\t\t  gnu_last);\n-      if (gnu_cond_expr)\n-\tLOOP_STMT_BOT_COND (gnu_loop_stmt) = gnu_test;\n-      else\n-\tLOOP_STMT_TOP_COND (gnu_loop_stmt) = gnu_test;\n+      /* Set either the top or bottom exit condition.  */\n+      LOOP_STMT_COND (gnu_loop_stmt)\n+\t= build_binary_op (test_code, integer_type_node, gnu_loop_var,\n+\t\t\t   gnu_last);\n \n+      /* Set either the top or bottom update statement and give it the source\n+\t location of the iteration for better coverage info.  */\n       LOOP_STMT_UPDATE (gnu_loop_stmt)\n-\t= build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t   gnu_loop_var,\n-\t\t\t   build_binary_op (update_code,\n-\t\t\t\t\t    TREE_TYPE (gnu_loop_var),\n-\t\t\t\t\t    gnu_loop_var,\n-\t\t\t\t\t    convert (TREE_TYPE (gnu_loop_var),\n-\t\t\t\t\t\t     integer_one_node)));\n+\t= build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_loop_var,\n+\t\t\t   build_binary_op (update_code, gnu_base_type,\n+\t\t\t\t\t    gnu_loop_var, gnu_one_node));\n       set_expr_location_from_node (LOOP_STMT_UPDATE (gnu_loop_stmt),\n \t\t\t\t   gnat_iter_scheme);\n     }\n@@ -6001,43 +6130,43 @@ gnat_gimplify_stmt (tree *stmt_p)\n     case LOOP_STMT:\n       {\n \ttree gnu_start_label = create_artificial_label (input_location);\n+\ttree gnu_cond = LOOP_STMT_COND (stmt);\n+\ttree gnu_update = LOOP_STMT_UPDATE (stmt);\n \ttree gnu_end_label = LOOP_STMT_LABEL (stmt);\n \ttree t;\n \n+\t/* Build the condition expression from the test, if any.  */\n+\tif (gnu_cond)\n+\t  gnu_cond\n+\t    = build3 (COND_EXPR, void_type_node, gnu_cond, alloc_stmt_list (),\n+\t\t      build1 (GOTO_EXPR, void_type_node, gnu_end_label));\n+\n \t/* Set to emit the statements of the loop.  */\n \t*stmt_p = NULL_TREE;\n \n-\t/* We first emit the start label and then a conditional jump to\n-\t   the end label if there's a top condition, then the body of the\n-\t   loop, then a conditional branch to the end label, then the update,\n-\t   if any, and finally a jump to the start label and the definition\n-\t   of the end label.  */\n+\t/* We first emit the start label and then a conditional jump to the\n+\t   end label if there's a top condition, then the update if it's at\n+\t   the top, then the body of the loop, then a conditional jump to\n+\t   the end label if there's a bottom condition, then the update if\n+\t   it's at the bottom, and finally a jump to the start label and the\n+\t   definition of the end label.  */\n \tappend_to_statement_list (build1 (LABEL_EXPR, void_type_node,\n \t\t\t\t\t  gnu_start_label),\n \t\t\t\t  stmt_p);\n \n-\tif (LOOP_STMT_TOP_COND (stmt))\n-\t  append_to_statement_list (build3 (COND_EXPR, void_type_node,\n-\t\t\t\t\t    LOOP_STMT_TOP_COND (stmt),\n-\t\t\t\t\t    alloc_stmt_list (),\n-\t\t\t\t\t    build1 (GOTO_EXPR,\n-\t\t\t\t\t\t    void_type_node,\n-\t\t\t\t\t\t    gnu_end_label)),\n-\t\t\t\t    stmt_p);\n+        if (gnu_cond && !LOOP_STMT_BOTTOM_COND_P (stmt))\n+\t  append_to_statement_list (gnu_cond, stmt_p);\n+\n+        if (gnu_update && LOOP_STMT_TOP_UPDATE_P (stmt))\n+\t  append_to_statement_list (gnu_update, stmt_p);\n \n \tappend_to_statement_list (LOOP_STMT_BODY (stmt), stmt_p);\n \n-\tif (LOOP_STMT_BOT_COND (stmt))\n-\t  append_to_statement_list (build3 (COND_EXPR, void_type_node,\n-\t\t\t\t\t    LOOP_STMT_BOT_COND (stmt),\n-\t\t\t\t\t    alloc_stmt_list (),\n-\t\t\t\t\t    build1 (GOTO_EXPR,\n-\t\t\t\t\t\t    void_type_node,\n-\t\t\t\t\t\t    gnu_end_label)),\n-\t\t\t\t    stmt_p);\n-\n-\tif (LOOP_STMT_UPDATE (stmt))\n-\t  append_to_statement_list (LOOP_STMT_UPDATE (stmt), stmt_p);\n+        if (gnu_cond && LOOP_STMT_BOTTOM_COND_P (stmt))\n+\t  append_to_statement_list (gnu_cond, stmt_p);\n+\n+        if (gnu_update && !LOOP_STMT_TOP_UPDATE_P (stmt))\n+\t  append_to_statement_list (gnu_update, stmt_p);\n \n \tt = build1 (GOTO_EXPR, void_type_node, gnu_start_label);\n \tSET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (gnu_end_label));"}]}