{"sha": "a15350157862db3631772b4ae69a9c9e3b0fab6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE1MzUwMTU3ODYyZGIzNjMxNzcyYjRhZTY5YTljOWUzYjBmYWI2ZQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-11T22:14:22Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-28T14:33:03Z"}, "message": "libstdc++: Memoize {drop,drop_while,filter,reverse}_view::begin\n\nThis patch adds memoization to these four views so that their begin() has the\nrequired amortized constant time complexity.\n\nThe cache is enabled only for forward_ranges and above because we need the\nunderlying iterator to be copyable and multi-pass in order for the cache to be\nusable.  In the general case we represent the cached result of begin() as a bare\niterator.  This takes advantage of the fact that value-initialized forward\niterators can be compared to as per N3644, so we can use a value-initialized\niterator to denote the \"empty\" state of the cache.\n\nAs a special case, when the underlying range models random_access_range and when\nit's profitable size-wise, then we cache the offset of the iterator from the\nbeginning of the range instead of caching the iterator itself.\n\nAdditionally, in drop_view and reverse_view we disable the cache when the\nunderlying range models random_access_range, because in these cases recomputing\nbegin() takes O(1) time anyway.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__detail::_CachedPosition): New struct.\n\t(views::filter_view::_S_needs_cached_begin): New member variable.\n\t(views::filter_view::_M_cached_begin): New member variable.\n\t(views::filter_view::begin): Use _M_cached_begin to cache its\n\tresult.\n\t(views::drop_view::_S_needs_cached_begin): New static member variable.\n\t(views::drop_view::_M_cached_begin): New member variable.\n\t(views::drop_view::begin): Use _M_cached_begin to cache its result\n\twhen _S_needs_cached_begin.\n\t(views::drop_while_view::_M_cached_begin): New member variable.\n\t(views::drop_while_view::begin): Use _M_cached_begin to cache its\n\tresult.\n\t(views::reverse_view::_S_needs_cached_begin): New static member\n\tvariable.\n\t(views::reverse_view::_M_cached_begin): New member variable.\n\t(views::reverse_view::begin): Use _M_cached_begin to cache its result\n\twhen _S_needs_cached_begin.\n\t* testsuite/std/ranges/adaptors/drop.cc: Augment test to check that\n\tdrop_view::begin caches its result.\n\t* testsuite/std/ranges/adaptors/drop_while.cc: Augment test to check\n\tthat drop_while_view::begin caches its result.\n\t* testsuite/std/ranges/adaptors/filter.cc: Augment test to check that\n\tfilter_view::begin caches its result.\n\t* testsuite/std/ranges/adaptors/reverse.cc: Augment test to check that\n\treverse_view::begin caches its result.", "tree": {"sha": "703d6013dfaa6ab7236a014c8d100cf9bbfed274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/703d6013dfaa6ab7236a014c8d100cf9bbfed274"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a15350157862db3631772b4ae69a9c9e3b0fab6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a15350157862db3631772b4ae69a9c9e3b0fab6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a15350157862db3631772b4ae69a9c9e3b0fab6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a15350157862db3631772b4ae69a9c9e3b0fab6e/comments", "author": null, "committer": null, "parents": [{"sha": "a51a546c1704cd572c35c11e539568c04d99e7d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51a546c1704cd572c35c11e539568c04d99e7d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51a546c1704cd572c35c11e539568c04d99e7d1"}], "stats": {"total": 351, "additions": 336, "deletions": 15}, "files": [{"sha": "89e1f5bf952cd6476d4e360637fd71be914d1dfd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a15350157862db3631772b4ae69a9c9e3b0fab6e", "patch": "@@ -1,3 +1,31 @@\n+2020-02-28  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* include/std/ranges (__detail::_CachedPosition): New struct.\n+\t(views::filter_view::_S_needs_cached_begin): New member variable.\n+\t(views::filter_view::_M_cached_begin): New member variable.\n+\t(views::filter_view::begin): Use _M_cached_begin to cache its\n+\tresult.\n+\t(views::drop_view::_S_needs_cached_begin): New static member variable.\n+\t(views::drop_view::_M_cached_begin): New member variable.\n+\t(views::drop_view::begin): Use _M_cached_begin to cache its result\n+\twhen _S_needs_cached_begin.\n+\t(views::drop_while_view::_M_cached_begin): New member variable.\n+\t(views::drop_while_view::begin): Use _M_cached_begin to cache its\n+\tresult.\n+\t(views::reverse_view::_S_needs_cached_begin): New static member\n+\tvariable.\n+\t(views::reverse_view::_M_cached_begin): New member variable.\n+\t(views::reverse_view::begin): Use _M_cached_begin to cache its result\n+\twhen _S_needs_cached_begin.\n+\t* testsuite/std/ranges/adaptors/drop.cc: Augment test to check that\n+\tdrop_view::begin caches its result.\n+\t* testsuite/std/ranges/adaptors/drop_while.cc: Augment test to check\n+\tthat drop_while_view::begin caches its result.\n+\t* testsuite/std/ranges/adaptors/filter.cc: Augment test to check that\n+\tfilter_view::begin caches its result.\n+\t* testsuite/std/ranges/adaptors/reverse.cc: Augment test to check that\n+\treverse_view::begin caches its result.\n+\n 2020-02-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/27_io/filesystem/operations/last_write_time.cc: Fixes for"}, {"sha": "2f77313097971c0cfcd23a0461682be5ad520bc8", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 122, "deletions": 14, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=a15350157862db3631772b4ae69a9c9e3b0fab6e", "patch": "@@ -1334,6 +1334,83 @@ namespace views\n       }\n   } // namespace __detail\n \n+  namespace __detail\n+  {\n+    template<range _Range>\n+      struct _CachedPosition\n+      {\n+\tconstexpr bool\n+\t_M_has_value() const\n+\t{ return false; }\n+\n+\tconstexpr iterator_t<_Range>\n+\t_M_get(const _Range&) const\n+\t{\n+\t  __glibcxx_assert(false);\n+\t  return {};\n+\t}\n+\n+\tconstexpr void\n+\t_M_set(const _Range&, const iterator_t<_Range>&) const\n+\t{ }\n+      };\n+\n+    template<forward_range _Range>\n+      struct _CachedPosition<_Range>\n+      {\n+      private:\n+\titerator_t<_Range> _M_iter{};\n+\n+      public:\n+\tconstexpr bool\n+\t_M_has_value() const\n+\t{ return _M_iter != iterator_t<_Range>{}; }\n+\n+\tconstexpr iterator_t<_Range>\n+\t_M_get(const _Range&) const\n+\t{\n+\t  __glibcxx_assert(_M_has_value());\n+\t  return _M_iter;\n+\t}\n+\n+\tconstexpr void\n+\t_M_set(const _Range&, const iterator_t<_Range>& __it)\n+\t{\n+\t  __glibcxx_assert(!_M_has_value());\n+\t  _M_iter = __it;\n+\t}\n+      };\n+\n+    template<random_access_range _Range>\n+      requires (sizeof(range_difference_t<_Range>)\n+\t\t<= sizeof(iterator_t<_Range>))\n+      struct _CachedPosition<_Range>\n+      {\n+      private:\n+\trange_difference_t<_Range> _M_offset = -1;\n+\n+      public:\n+\tconstexpr bool\n+\t_M_has_value() const\n+\t{ return _M_offset >= 0; }\n+\n+\tconstexpr iterator_t<_Range>\n+\t_M_get(_Range& __r) const\n+\t{\n+\t  __glibcxx_assert(_M_has_value());\n+\t  return ranges::begin(__r) + _M_offset;\n+\t}\n+\n+\tconstexpr void\n+\t_M_set(_Range& __r, const iterator_t<_Range>& __it)\n+\t{\n+\t  __glibcxx_assert(!_M_has_value());\n+\t  _M_offset = __it - ranges::begin(__r);\n+\t}\n+      };\n+\n+  } // namespace __detail\n+\n   template<input_range _Vp,\n \t   indirect_unary_predicate<iterator_t<_Vp>> _Pred>\n     requires view<_Vp> && is_object_v<_Pred>\n@@ -1491,6 +1568,7 @@ namespace views\n \n       _Vp _M_base = _Vp();\n       __detail::__box<_Pred> _M_pred;\n+      [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;\n \n     public:\n       filter_view() = default;\n@@ -1515,11 +1593,15 @@ namespace views\n       constexpr _Iterator\n       begin()\n       {\n-\t// XXX: we need to cache the result here as per [range.filter.view]\n+\tif (_M_cached_begin._M_has_value())\n+\t  return {*this, _M_cached_begin._M_get(_M_base)};\n+\n \t__glibcxx_assert(_M_pred.has_value());\n-\treturn {*this, __detail::find_if(ranges::begin(_M_base),\n-\t\t\t\t\t ranges::end(_M_base),\n-\t\t\t\t\t std::ref(*_M_pred))};\n+\tauto __it = __detail::find_if(ranges::begin(_M_base),\n+\t\t\t\t      ranges::end(_M_base),\n+\t\t\t\t      std::ref(*_M_pred));\n+\t_M_cached_begin._M_set(_M_base, __it);\n+\treturn {*this, std::move(__it)};\n       }\n \n       constexpr auto\n@@ -2127,6 +2209,11 @@ namespace views\n       _Vp _M_base = _Vp();\n       range_difference_t<_Vp> _M_count = 0;\n \n+      static constexpr bool _S_needs_cached_begin = !random_access_range<_Vp>;\n+      [[no_unique_address]]\n+\t__detail::__maybe_empty_t<_S_needs_cached_begin,\n+\t\t\t\t  __detail::_CachedPosition<_Vp>> _M_cached_begin;\n+\n     public:\n       drop_view() = default;\n \n@@ -2147,9 +2234,15 @@ namespace views\n       begin() requires (!(__detail::__simple_view<_Vp>\n \t\t\t  && random_access_range<_Vp>))\n       {\n-\t// XXX: we need to cache the result here as per [range.drop.view]\n-\treturn ranges::next(ranges::begin(_M_base), _M_count,\n-\t\t\t    ranges::end(_M_base));\n+\tif constexpr (_S_needs_cached_begin)\n+\t  if (_M_cached_begin._M_has_value())\n+\t    return _M_cached_begin._M_get(_M_base);\n+\n+\tauto __it = ranges::next(ranges::begin(_M_base),\n+\t\t\t\t _M_count, ranges::end(_M_base));\n+\tif constexpr (_S_needs_cached_begin)\n+\t  _M_cached_begin._M_set(_M_base, __it);\n+\treturn __it;\n       }\n \n       constexpr auto\n@@ -2205,6 +2298,7 @@ namespace views\n     private:\n       _Vp _M_base = _Vp();\n       __detail::__box<_Pred> _M_pred;\n+      [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;\n \n     public:\n       drop_while_view() = default;\n@@ -2229,10 +2323,14 @@ namespace views\n       constexpr auto\n       begin()\n       {\n-\t// XXX: we need to cache the result here as per [range.drop.while.view]\n-\treturn __detail::find_if_not(ranges::begin(_M_base),\n-\t\t\t\t     ranges::end(_M_base),\n-\t\t\t\t     std::cref(*_M_pred));\n+\tif (_M_cached_begin._M_has_value())\n+\t  return _M_cached_begin._M_get(_M_base);\n+\n+\tauto __it = __detail::find_if_not(ranges::begin(_M_base),\n+\t\t\t\t\t  ranges::end(_M_base),\n+\t\t\t\t\t  std::cref(*_M_pred));\n+\t_M_cached_begin._M_set(_M_base, __it);\n+\treturn __it;\n       }\n \n       constexpr auto\n@@ -3079,6 +3177,11 @@ namespace views\n     private:\n       _Vp _M_base = _Vp();\n \n+      static constexpr bool _S_needs_cached_begin = !random_access_range<_Vp>;\n+      [[no_unique_address]]\n+\t__detail::__maybe_empty_t<_S_needs_cached_begin,\n+\t\t\t\t  __detail::_CachedPosition<_Vp>> _M_cached_begin;\n+\n     public:\n       reverse_view() = default;\n \n@@ -3098,9 +3201,14 @@ namespace views\n       constexpr reverse_iterator<iterator_t<_Vp>>\n       begin()\n       {\n-\t// XXX: we need to cache the result here as per [range.reverse.view]\n-\treturn make_reverse_iterator(ranges::next(ranges::begin(_M_base),\n-\t\t\t\t\t\t  ranges::end(_M_base)));\n+\tif constexpr (_S_needs_cached_begin)\n+\t  if (_M_cached_begin._M_has_value())\n+\t    return make_reverse_iterator(_M_cached_begin._M_get(_M_base));\n+\n+\tauto __it = ranges::next(ranges::begin(_M_base), ranges::end(_M_base));\n+\tif constexpr (_S_needs_cached_begin)\n+\t  _M_cached_begin._M_set(_M_base, __it);\n+\treturn make_reverse_iterator(std::move(__it));\n       }\n \n       constexpr auto"}, {"sha": "3c82caea772d83e87a35f8277744018c63568323", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc?ref=a15350157862db3631772b4ae69a9c9e3b0fab6e", "patch": "@@ -24,6 +24,7 @@\n #include <testsuite_iterators.h>\n \n using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n using __gnu_test::bidirectional_iterator_wrapper;\n \n namespace ranges = std::ranges;\n@@ -95,6 +96,61 @@ test06()\n   VERIFY( ranges::empty(x | views::drop(10)) );\n }\n \n+// The following tests that drop_view::begin caches its result.\n+\n+template<typename T>\n+struct test_wrapper : forward_iterator_wrapper<T>\n+{\n+  static inline int increment_count = 0;\n+\n+  using forward_iterator_wrapper<T>::forward_iterator_wrapper;\n+\n+  test_wrapper() : forward_iterator_wrapper<T>()\n+  { }\n+\n+  test_wrapper\n+  operator++(int)\n+  {\n+    auto tmp = *this;\n+    ++*this;\n+    return tmp;\n+  }\n+\n+  test_wrapper&\n+  operator++()\n+  {\n+    ++increment_count;\n+    forward_iterator_wrapper<T>::operator++();\n+    return *this;\n+  }\n+\n+  test_wrapper\n+  operator--(int)\n+  {\n+    auto tmp = *this;\n+    --*this;\n+    return tmp;\n+  }\n+\n+  test_wrapper&\n+  operator--()\n+  {\n+    forward_iterator_wrapper<T>::operator--();\n+    return *this;\n+  }\n+};\n+\n+void\n+test07()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, test_wrapper> rx(x);\n+  auto v = rx | views::drop(3);\n+  VERIFY( ranges::equal(v, (int[]){4,5}) );\n+  VERIFY( ranges::equal(v, (int[]){4,5}) );\n+  VERIFY( test_wrapper<int>::increment_count == 7 );\n+}\n+\n int\n main()\n {\n@@ -104,4 +160,5 @@ main()\n   test04();\n   test05();\n   test06();\n+  test07();\n }"}, {"sha": "4d8bb109fae0cf5d698137b20722a1bcdad5b205", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc?ref=a15350157862db3631772b4ae69a9c9e3b0fab6e", "patch": "@@ -25,6 +25,8 @@\n \n using __gnu_test::test_range;\n using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n \n namespace ranges = std::ranges;\n namespace views = std::ranges::views;\n@@ -54,10 +56,44 @@ test02()\n   static_assert(ranges::bidirectional_range<R>);\n }\n \n+// The following tests that drop_while_view::begin caches its result.\n+\n+template<template<typename> typename wrapper>\n+struct test_view : ranges::view_base\n+{\n+  bool begin_already_called = false;\n+  static inline int x[] = {1,2,3,4,5};\n+  test_range<int, wrapper> rx{x};\n+\n+  auto\n+  begin()\n+  {\n+    if (begin_already_called)\n+      x[0] = 10;\n+    begin_already_called = true;\n+    return rx.begin();\n+  }\n+\n+  auto\n+  end()\n+  { return rx.end(); }\n+};\n+\n+template<template<typename> typename wrapper>\n+void\n+test03()\n+{\n+  auto v\n+    = test_view<wrapper>{} | views::drop_while([] (int i) { return i<3; });\n+  VERIFY( ranges::equal(v, (int[]){3,4,5}) );\n+  VERIFY( ranges::equal(v, (int[]){3,4,5}) );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03<forward_iterator_wrapper>();\n+  test03<random_access_iterator_wrapper>();\n }\n-"}, {"sha": "58d898fb207bd2187b2b9a6dbd05a7c2c4427f0d", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc?ref=a15350157862db3631772b4ae69a9c9e3b0fab6e", "patch": "@@ -25,6 +25,8 @@\n \n using __gnu_test::test_range;\n using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n \n namespace ranges = std::ranges;\n namespace views = std::ranges::views;\n@@ -89,11 +91,45 @@ test04()\n \t\t\t(int[]){0}) );\n }\n \n+// The following tests that filter_view::begin caches its result.\n+\n+template<template<typename> typename wrapper>\n+struct test_view : ranges::view_base\n+{\n+  bool begin_already_called = false;\n+  static inline int x[] = {1,2,3,4,5};\n+  test_range<int, wrapper> rx{x};\n+\n+  auto\n+  begin()\n+  {\n+    if (begin_already_called)\n+      x[0] = 10;\n+    begin_already_called = true;\n+    return rx.begin();\n+  }\n+\n+  auto\n+  end()\n+  { return rx.end(); }\n+};\n+\n+template<template<typename> typename wrapper>\n+void\n+test05()\n+{\n+  auto v = test_view<wrapper>{} | views::filter([] (int i) { return i%2 == 0; });\n+  VERIFY( ranges::equal(v, (int[]){2,4}) );\n+  VERIFY( ranges::equal(v, (int[]){2,4}) );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n+  test05<forward_iterator_wrapper>();\n+  test05<random_access_iterator_wrapper>();\n }"}, {"sha": "ceaaf3e9e008c250e0d63de42e978241258f089f", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15350157862db3631772b4ae69a9c9e3b0fab6e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc?ref=a15350157862db3631772b4ae69a9c9e3b0fab6e", "patch": "@@ -76,11 +76,67 @@ test04()\n \t\t\t(int[]){5,4,3,2,1}) );\n }\n \n+// The following tests that reverse_view::begin caches its result.\n+\n+template<typename T>\n+struct test_wrapper : bidirectional_iterator_wrapper<T>\n+{\n+  static inline int increment_count = 0;\n+\n+  using bidirectional_iterator_wrapper<T>::bidirectional_iterator_wrapper;\n+\n+  test_wrapper() : bidirectional_iterator_wrapper<T>()\n+  { }\n+\n+  test_wrapper\n+  operator++(int)\n+  {\n+    auto tmp = *this;\n+    ++*this;\n+    return tmp;\n+  }\n+\n+  test_wrapper&\n+  operator++()\n+  {\n+    ++increment_count;\n+    bidirectional_iterator_wrapper<T>::operator++();\n+    return *this;\n+  }\n+\n+  test_wrapper\n+  operator--(int)\n+  {\n+    auto tmp = *this;\n+    --*this;\n+    return tmp;\n+  }\n+\n+  test_wrapper&\n+  operator--()\n+  {\n+    bidirectional_iterator_wrapper<T>::operator--();\n+    return *this;\n+  }\n+};\n+\n+void\n+test05()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, test_wrapper> rx(x);\n+  auto v = rx | views::reverse;\n+  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );\n+  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );\n+  VERIFY( test_wrapper<int>::increment_count == 5 );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n+  test05();\n }"}]}