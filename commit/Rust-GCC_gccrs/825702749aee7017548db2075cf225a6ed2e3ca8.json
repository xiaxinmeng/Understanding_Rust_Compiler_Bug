{"sha": "825702749aee7017548db2075cf225a6ed2e3ca8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1NzAyNzQ5YWVlNzAxNzU0OGRiMjA3NWNmMjI1YTZlZDJlM2NhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:25:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:25:25Z"}, "message": "[31/46] Use stmt_vec_info in function interfaces (part 1)\n\nThis first (less mechanical) part handles cases that involve changes in\nthe callers or non-trivial changes in the functions themselves.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-data-refs.c (vect_describe_gather_scatter_call): Take\n\ta stmt_vec_info instead of a gcall.\n\t(vect_check_gather_scatter): Update call accordingly.\n\t* tree-vect-loop-manip.c (iv_phi_p): Take a stmt_vec_info instead\n\tof a gphi.\n\t(vect_can_advance_ivs_p, vect_update_ivs_after_vectorizer)\n\t(slpeel_update_phi_nodes_for_loops):): Update calls accordingly.\n\t* tree-vect-loop.c (vect_transform_loop_stmt): Take a stmt_vec_info\n\tinstead of a gimple stmt.\n\t(vect_transform_loop): Update calls accordingly.\n\t* tree-vect-slp.c (vect_split_slp_store_group): Take and return\n\tstmt_vec_infos instead of gimple stmts.\n\t(vect_analyze_slp_instance): Update use accordingly.\n\t* tree-vect-stmts.c (read_vector_array, write_vector_array)\n\t(vect_clobber_variable, vect_stmt_relevant_p, permute_vec_elements)\n\t(vect_use_strided_gather_scatters_p, vect_build_all_ones_mask)\n\t(vect_build_zero_merge_argument, vect_get_gather_scatter_ops)\n\t(vect_gen_widened_results_half, vect_get_loop_based_defs)\n\t(vect_create_vectorized_promotion_stmts, can_vectorize_live_stmts):\n\tTake a stmt_vec_info instead of a gimple stmt and pass stmt_vec_infos\n\tdown to subroutines.\n\nFrom-SVN: r263146", "tree": {"sha": "b3fda8f76e10befacf3793ee21527d74c5d32c6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3fda8f76e10befacf3793ee21527d74c5d32c6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/825702749aee7017548db2075cf225a6ed2e3ca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825702749aee7017548db2075cf225a6ed2e3ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825702749aee7017548db2075cf225a6ed2e3ca8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825702749aee7017548db2075cf225a6ed2e3ca8/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eca52fdd6c570658e417ab38d25e0874d0c9c044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca52fdd6c570658e417ab38d25e0874d0c9c044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca52fdd6c570658e417ab38d25e0874d0c9c044"}], "stats": {"total": 223, "additions": 128, "deletions": 95}, "files": [{"sha": "87bdc43d06fb6c75c7c46a4c4bb30eb33e96cf60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=825702749aee7017548db2075cf225a6ed2e3ca8", "patch": "@@ -1,3 +1,27 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_describe_gather_scatter_call): Take\n+\ta stmt_vec_info instead of a gcall.\n+\t(vect_check_gather_scatter): Update call accordingly.\n+\t* tree-vect-loop-manip.c (iv_phi_p): Take a stmt_vec_info instead\n+\tof a gphi.\n+\t(vect_can_advance_ivs_p, vect_update_ivs_after_vectorizer)\n+\t(slpeel_update_phi_nodes_for_loops):): Update calls accordingly.\n+\t* tree-vect-loop.c (vect_transform_loop_stmt): Take a stmt_vec_info\n+\tinstead of a gimple stmt.\n+\t(vect_transform_loop): Update calls accordingly.\n+\t* tree-vect-slp.c (vect_split_slp_store_group): Take and return\n+\tstmt_vec_infos instead of gimple stmts.\n+\t(vect_analyze_slp_instance): Update use accordingly.\n+\t* tree-vect-stmts.c (read_vector_array, write_vector_array)\n+\t(vect_clobber_variable, vect_stmt_relevant_p, permute_vec_elements)\n+\t(vect_use_strided_gather_scatters_p, vect_build_all_ones_mask)\n+\t(vect_build_zero_merge_argument, vect_get_gather_scatter_ops)\n+\t(vect_gen_widened_results_half, vect_get_loop_based_defs)\n+\t(vect_create_vectorized_promotion_stmts, can_vectorize_live_stmts):\n+\tTake a stmt_vec_info instead of a gimple stmt and pass stmt_vec_infos\n+\tdown to subroutines.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-loop.c (vect_analyze_scalar_cycles_1): Change the type"}, {"sha": "3d0760375048a7c579d15a1f6cc8dead2a97bc35", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=825702749aee7017548db2075cf225a6ed2e3ca8", "patch": "@@ -3621,13 +3621,14 @@ vect_gather_scatter_fn_p (bool read_p, bool masked_p, tree vectype,\n   return true;\n }\n \n-/* CALL is a call to an internal gather load or scatter store function.\n+/* STMT_INFO is a call to an internal gather load or scatter store function.\n    Describe the operation in INFO.  */\n \n static void\n-vect_describe_gather_scatter_call (gcall *call, gather_scatter_info *info)\n+vect_describe_gather_scatter_call (stmt_vec_info stmt_info,\n+\t\t\t\t   gather_scatter_info *info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (call);\n+  gcall *call = as_a <gcall *> (stmt_info->stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n \n@@ -3672,7 +3673,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n       ifn = gimple_call_internal_fn (call);\n       if (internal_gather_scatter_fn_p (ifn))\n \t{\n-\t  vect_describe_gather_scatter_call (call, info);\n+\t  vect_describe_gather_scatter_call (stmt_info, info);\n \t  return true;\n \t}\n       masked_p = (ifn == IFN_MASK_LOAD || ifn == IFN_MASK_STORE);"}, {"sha": "251fc81015abeab9732634092f9a3e8957b89536", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=825702749aee7017548db2075cf225a6ed2e3ca8", "patch": "@@ -1335,16 +1335,16 @@ find_loop_location (struct loop *loop)\n   return dump_user_location_t ();\n }\n \n-/* Return true if PHI defines an IV of the loop to be vectorized.  */\n+/* Return true if the phi described by STMT_INFO defines an IV of the\n+   loop to be vectorized.  */\n \n static bool\n-iv_phi_p (gphi *phi)\n+iv_phi_p (stmt_vec_info stmt_info)\n {\n+  gphi *phi = as_a <gphi *> (stmt_info->stmt);\n   if (virtual_operand_p (PHI_RESULT (phi)))\n     return false;\n \n-  stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n-  gcc_assert (stmt_info != NULL_STMT_VEC_INFO);\n   if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n     return false;\n@@ -1388,7 +1388,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \t virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.\n \n \t Skip reduction phis.  */\n-      if (!iv_phi_p (phi))\n+      if (!iv_phi_p (phi_info))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1509,7 +1509,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n \t}\n \n       /* Skip reduction and virtual phis.  */\n-      if (!iv_phi_p (phi))\n+      if (!iv_phi_p (phi_info))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2088,7 +2088,8 @@ slpeel_update_phi_nodes_for_loops (loop_vec_info loop_vinfo,\n       tree arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, first_latch_e);\n       /* Generate lcssa PHI node for the first loop.  */\n       gphi *vect_phi = (loop == first) ? orig_phi : update_phi;\n-      if (create_lcssa_for_iv_phis || !iv_phi_p (vect_phi))\n+      stmt_vec_info vect_phi_info = loop_vinfo->lookup_stmt (vect_phi);\n+      if (create_lcssa_for_iv_phis || !iv_phi_p (vect_phi_info))\n \t{\n \t  tree new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n \t  gphi *lcssa_phi = create_phi_node (new_res, between_bb);"}, {"sha": "da2a2eeb2bd7cdb829e4d4be5512a5907294903d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=825702749aee7017548db2075cf225a6ed2e3ca8", "patch": "@@ -8207,21 +8207,18 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n     scale_bbs_frequencies (&loop->latch, 1, exit_l->probability / prob);\n }\n \n-/* Vectorize STMT if relevant, inserting any new instructions before GSI.\n-   When vectorizing STMT as a store, set *SEEN_STORE to its stmt_vec_info.\n+/* Vectorize STMT_INFO if relevant, inserting any new instructions before GSI.\n+   When vectorizing STMT_INFO as a store, set *SEEN_STORE to its stmt_vec_info.\n    *SLP_SCHEDULE is a running record of whether we have called\n    vect_schedule_slp.  */\n \n static void\n-vect_transform_loop_stmt (loop_vec_info loop_vinfo, gimple *stmt,\n+vect_transform_loop_stmt (loop_vec_info loop_vinfo, stmt_vec_info stmt_info,\n \t\t\t  gimple_stmt_iterator *gsi,\n \t\t\t  stmt_vec_info *seen_store, bool *slp_scheduled)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n-  if (!stmt_info)\n-    return;\n \n   if (dump_enabled_p ())\n     {\n@@ -8476,15 +8473,19 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t      gimple *def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n \t\t      for (gimple_stmt_iterator subsi = gsi_start (def_seq);\n \t\t\t   !gsi_end_p (subsi); gsi_next (&subsi))\n-\t\t\tvect_transform_loop_stmt (loop_vinfo,\n-\t\t\t\t\t\t  gsi_stmt (subsi), &si,\n-\t\t\t\t\t\t  &seen_store,\n-\t\t\t\t\t\t  &slp_scheduled);\n-\t\t      gimple *pat_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-\t\t      vect_transform_loop_stmt (loop_vinfo, pat_stmt, &si,\n+\t\t\t{\n+\t\t\t  stmt_vec_info pat_stmt_info\n+\t\t\t    = loop_vinfo->lookup_stmt (gsi_stmt (subsi));\n+\t\t\t  vect_transform_loop_stmt (loop_vinfo, pat_stmt_info,\n+\t\t\t\t\t\t    &si, &seen_store,\n+\t\t\t\t\t\t    &slp_scheduled);\n+\t\t\t}\n+\t\t      stmt_vec_info pat_stmt_info\n+\t\t\t= STMT_VINFO_RELATED_STMT (stmt_info);\n+\t\t      vect_transform_loop_stmt (loop_vinfo, pat_stmt_info, &si,\n \t\t\t\t\t\t&seen_store, &slp_scheduled);\n \t\t    }\n-\t\t  vect_transform_loop_stmt (loop_vinfo, stmt, &si,\n+\t\t  vect_transform_loop_stmt (loop_vinfo, stmt_info, &si,\n \t\t\t\t\t    &seen_store, &slp_scheduled);\n \t\t}\n \t      if (seen_store)"}, {"sha": "c36d130804be3adb8d9765e018bf5a1508e721f5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=825702749aee7017548db2075cf225a6ed2e3ca8", "patch": "@@ -1856,16 +1856,15 @@ vect_find_last_scalar_stmt_in_slp (slp_tree node)\n   return last;\n }\n \n-/* Splits a group of stores, currently beginning at FIRST_STMT, into two groups:\n-   one (still beginning at FIRST_STMT) of size GROUP1_SIZE (also containing\n-   the first GROUP1_SIZE stmts, since stores are consecutive), the second\n-   containing the remainder.\n+/* Splits a group of stores, currently beginning at FIRST_VINFO, into\n+   two groups: one (still beginning at FIRST_VINFO) of size GROUP1_SIZE\n+   (also containing the first GROUP1_SIZE stmts, since stores are\n+   consecutive), the second containing the remainder.\n    Return the first stmt in the second group.  */\n \n-static gimple *\n-vect_split_slp_store_group (gimple *first_stmt, unsigned group1_size)\n+static stmt_vec_info\n+vect_split_slp_store_group (stmt_vec_info first_vinfo, unsigned group1_size)\n {\n-  stmt_vec_info first_vinfo = vinfo_for_stmt (first_stmt);\n   gcc_assert (DR_GROUP_FIRST_ELEMENT (first_vinfo) == first_vinfo);\n   gcc_assert (group1_size > 0);\n   int group2_size = DR_GROUP_SIZE (first_vinfo) - group1_size;\n@@ -2174,7 +2173,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n \t  unsigned group1_size = i & ~(const_nunits - 1);\n \n-\t  gimple *rest = vect_split_slp_store_group (stmt_info, group1_size);\n+\t  stmt_vec_info rest = vect_split_slp_store_group (stmt_info,\n+\t\t\t\t\t\t\t   group1_size);\n \t  bool res = vect_analyze_slp_instance (vinfo, stmt_info,\n \t\t\t\t\t\tmax_tree_size);\n \t  /* If the first non-match was in the middle of a vector,"}, {"sha": "5353e721a0e20ecf0286c98939fe02cc6c6d2afa", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 69, "deletions": 63, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825702749aee7017548db2075cf225a6ed2e3ca8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=825702749aee7017548db2075cf225a6ed2e3ca8", "patch": "@@ -117,12 +117,12 @@ create_vector_array (tree elem_type, unsigned HOST_WIDE_INT nelems)\n \n /* ARRAY is an array of vectors created by create_vector_array.\n    Return an SSA_NAME for the vector in index N.  The reference\n-   is part of the vectorization of STMT and the vector is associated\n+   is part of the vectorization of STMT_INFO and the vector is associated\n    with scalar destination SCALAR_DEST.  */\n \n static tree\n-read_vector_array (gimple *stmt, gimple_stmt_iterator *gsi, tree scalar_dest,\n-\t\t   tree array, unsigned HOST_WIDE_INT n)\n+read_vector_array (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n+\t\t   tree scalar_dest, tree array, unsigned HOST_WIDE_INT n)\n {\n   tree vect_type, vect, vect_name, array_ref;\n   gimple *new_stmt;\n@@ -137,18 +137,18 @@ read_vector_array (gimple *stmt, gimple_stmt_iterator *gsi, tree scalar_dest,\n   new_stmt = gimple_build_assign (vect, array_ref);\n   vect_name = make_ssa_name (vect, new_stmt);\n   gimple_assign_set_lhs (new_stmt, vect_name);\n-  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \n   return vect_name;\n }\n \n /* ARRAY is an array of vectors created by create_vector_array.\n    Emit code to store SSA_NAME VECT in index N of the array.\n-   The store is part of the vectorization of STMT.  */\n+   The store is part of the vectorization of STMT_INFO.  */\n \n static void\n-write_vector_array (gimple *stmt, gimple_stmt_iterator *gsi, tree vect,\n-\t\t    tree array, unsigned HOST_WIDE_INT n)\n+write_vector_array (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n+\t\t    tree vect, tree array, unsigned HOST_WIDE_INT n)\n {\n   tree array_ref;\n   gimple *new_stmt;\n@@ -158,7 +158,7 @@ write_vector_array (gimple *stmt, gimple_stmt_iterator *gsi, tree vect,\n \t\t      NULL_TREE, NULL_TREE);\n \n   new_stmt = gimple_build_assign (array_ref, vect);\n-  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n }\n \n /* PTR is a pointer to an array of type TYPE.  Return a representation\n@@ -176,15 +176,16 @@ create_array_ref (tree type, tree ptr, tree alias_ptr_type)\n   return mem_ref;\n }\n \n-/* Add a clobber of variable VAR to the vectorization of STMT.\n+/* Add a clobber of variable VAR to the vectorization of STMT_INFO.\n    Emit the clobber before *GSI.  */\n \n static void\n-vect_clobber_variable (gimple *stmt, gimple_stmt_iterator *gsi, tree var)\n+vect_clobber_variable (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n+\t\t       tree var)\n {\n   tree clobber = build_clobber (TREE_TYPE (var));\n   gimple *new_stmt = gimple_build_assign (var, clobber);\n-  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n }\n \n /* Utility functions used by vect_mark_stmts_to_be_vectorized.  */\n@@ -281,8 +282,8 @@ is_simple_and_all_uses_invariant (gimple *stmt, loop_vec_info loop_vinfo)\n \n /* Function vect_stmt_relevant_p.\n \n-   Return true if STMT in loop that is represented by LOOP_VINFO is\n-   \"relevant for vectorization\".\n+   Return true if STMT_INFO, in the loop that is represented by LOOP_VINFO,\n+   is \"relevant for vectorization\".\n \n    A stmt is considered \"relevant for vectorization\" if:\n    - it has uses outside the loop.\n@@ -292,7 +293,7 @@ is_simple_and_all_uses_invariant (gimple *stmt, loop_vec_info loop_vinfo)\n    CHECKME: what other side effects would the vectorizer allow?  */\n \n static bool\n-vect_stmt_relevant_p (gimple *stmt, loop_vec_info loop_vinfo,\n+vect_stmt_relevant_p (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \t\t      enum vect_relevant *relevant, bool *live_p)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -305,15 +306,14 @@ vect_stmt_relevant_p (gimple *stmt, loop_vec_info loop_vinfo,\n   *live_p = false;\n \n   /* cond stmt other than loop exit cond.  */\n-  if (is_ctrl_stmt (stmt)\n-      && STMT_VINFO_TYPE (vinfo_for_stmt (stmt))\n-         != loop_exit_ctrl_vec_info_type)\n+  if (is_ctrl_stmt (stmt_info->stmt)\n+      && STMT_VINFO_TYPE (stmt_info) != loop_exit_ctrl_vec_info_type)\n     *relevant = vect_used_in_scope;\n \n   /* changing memory.  */\n-  if (gimple_code (stmt) != GIMPLE_PHI)\n-    if (gimple_vdef (stmt)\n-\t&& !gimple_clobber_p (stmt))\n+  if (gimple_code (stmt_info->stmt) != GIMPLE_PHI)\n+    if (gimple_vdef (stmt_info->stmt)\n+\t&& !gimple_clobber_p (stmt_info->stmt))\n       {\n \tif (dump_enabled_p ())\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n@@ -322,7 +322,7 @@ vect_stmt_relevant_p (gimple *stmt, loop_vec_info loop_vinfo,\n       }\n \n   /* uses outside the loop.  */\n-  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, op_iter, SSA_OP_DEF)\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt_info->stmt, op_iter, SSA_OP_DEF)\n     {\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, DEF_FROM_PTR (def_p))\n \t{\n@@ -347,7 +347,7 @@ vect_stmt_relevant_p (gimple *stmt, loop_vec_info loop_vinfo,\n     }\n \n   if (*live_p && *relevant == vect_unused_in_scope\n-      && !is_simple_and_all_uses_invariant (stmt, loop_vinfo))\n+      && !is_simple_and_all_uses_invariant (stmt_info, loop_vinfo))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n@@ -1838,7 +1838,7 @@ vectorizable_internal_function (combined_fn cfn, tree fndecl,\n }\n \n \n-static tree permute_vec_elements (tree, tree, tree, gimple *,\n+static tree permute_vec_elements (tree, tree, tree, stmt_vec_info,\n \t\t\t\t  gimple_stmt_iterator *);\n \n /* Check whether a load or store statement in the loop described by\n@@ -2072,19 +2072,19 @@ vect_truncate_gather_scatter_offset (gimple *stmt, loop_vec_info loop_vinfo,\n }\n \n /* Return true if we can use gather/scatter internal functions to\n-   vectorize STMT, which is a grouped or strided load or store.\n+   vectorize STMT_INFO, which is a grouped or strided load or store.\n    MASKED_P is true if load or store is conditional.  When returning\n    true, fill in GS_INFO with the information required to perform the\n    operation.  */\n \n static bool\n-vect_use_strided_gather_scatters_p (gimple *stmt, loop_vec_info loop_vinfo,\n-\t\t\t\t    bool masked_p,\n+vect_use_strided_gather_scatters_p (stmt_vec_info stmt_info,\n+\t\t\t\t    loop_vec_info loop_vinfo, bool masked_p,\n \t\t\t\t    gather_scatter_info *gs_info)\n {\n-  if (!vect_check_gather_scatter (stmt, loop_vinfo, gs_info)\n+  if (!vect_check_gather_scatter (stmt_info, loop_vinfo, gs_info)\n       || gs_info->decl)\n-    return vect_truncate_gather_scatter_offset (stmt, loop_vinfo,\n+    return vect_truncate_gather_scatter_offset (stmt_info, loop_vinfo,\n \t\t\t\t\t\tmasked_p, gs_info);\n \n   scalar_mode element_mode = SCALAR_TYPE_MODE (gs_info->element_type);\n@@ -2613,20 +2613,20 @@ vect_check_store_rhs (gimple *stmt, tree rhs, vect_def_type *rhs_dt_out,\n   return true;\n }\n \n-/* Build an all-ones vector mask of type MASKTYPE while vectorizing STMT.\n+/* Build an all-ones vector mask of type MASKTYPE while vectorizing STMT_INFO.\n    Note that we support masks with floating-point type, in which case the\n    floats are interpreted as a bitmask.  */\n \n static tree\n-vect_build_all_ones_mask (gimple *stmt, tree masktype)\n+vect_build_all_ones_mask (stmt_vec_info stmt_info, tree masktype)\n {\n   if (TREE_CODE (masktype) == INTEGER_TYPE)\n     return build_int_cst (masktype, -1);\n   else if (TREE_CODE (TREE_TYPE (masktype)) == INTEGER_TYPE)\n     {\n       tree mask = build_int_cst (TREE_TYPE (masktype), -1);\n       mask = build_vector_from_val (masktype, mask);\n-      return vect_init_vector (stmt, mask, masktype, NULL);\n+      return vect_init_vector (stmt_info, mask, masktype, NULL);\n     }\n   else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (masktype)))\n     {\n@@ -2637,16 +2637,16 @@ vect_build_all_ones_mask (gimple *stmt, tree masktype)\n       real_from_target (&r, tmp, TYPE_MODE (TREE_TYPE (masktype)));\n       tree mask = build_real (TREE_TYPE (masktype), r);\n       mask = build_vector_from_val (masktype, mask);\n-      return vect_init_vector (stmt, mask, masktype, NULL);\n+      return vect_init_vector (stmt_info, mask, masktype, NULL);\n     }\n   gcc_unreachable ();\n }\n \n /* Build an all-zero merge value of type VECTYPE while vectorizing\n-   STMT as a gather load.  */\n+   STMT_INFO as a gather load.  */\n \n static tree\n-vect_build_zero_merge_argument (gimple *stmt, tree vectype)\n+vect_build_zero_merge_argument (stmt_vec_info stmt_info, tree vectype)\n {\n   tree merge;\n   if (TREE_CODE (TREE_TYPE (vectype)) == INTEGER_TYPE)\n@@ -2663,7 +2663,7 @@ vect_build_zero_merge_argument (gimple *stmt, tree vectype)\n   else\n     gcc_unreachable ();\n   merge = build_vector_from_val (vectype, merge);\n-  return vect_init_vector (stmt, merge, vectype, NULL);\n+  return vect_init_vector (stmt_info, merge, vectype, NULL);\n }\n \n /* Build a gather load call while vectorizing STMT.  Insert new instructions\n@@ -2871,11 +2871,12 @@ vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* Prepare the base and offset in GS_INFO for vectorization.\n    Set *DATAREF_PTR to the loop-invariant base address and *VEC_OFFSET\n-   to the vectorized offset argument for the first copy of STMT.  STMT\n-   is the statement described by GS_INFO and LOOP is the containing loop.  */\n+   to the vectorized offset argument for the first copy of STMT_INFO.\n+   STMT_INFO is the statement described by GS_INFO and LOOP is the\n+   containing loop.  */\n \n static void\n-vect_get_gather_scatter_ops (struct loop *loop, gimple *stmt,\n+vect_get_gather_scatter_ops (struct loop *loop, stmt_vec_info stmt_info,\n \t\t\t     gather_scatter_info *gs_info,\n \t\t\t     tree *dataref_ptr, tree *vec_offset)\n {\n@@ -2890,7 +2891,7 @@ vect_get_gather_scatter_ops (struct loop *loop, gimple *stmt,\n     }\n   tree offset_type = TREE_TYPE (gs_info->offset);\n   tree offset_vectype = get_vectype_for_scalar_type (offset_type);\n-  *vec_offset = vect_get_vec_def_for_operand (gs_info->offset, stmt,\n+  *vec_offset = vect_get_vec_def_for_operand (gs_info->offset, stmt_info,\n \t\t\t\t\t      offset_vectype);\n }\n \n@@ -4403,14 +4404,14 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n    VEC_OPRND0 and VEC_OPRND1.  The new vector stmt is to be inserted at BSI.\n    In the case that CODE is a CALL_EXPR, this means that a call to DECL\n    needs to be created (DECL is a function-decl of a target-builtin).\n-   STMT is the original scalar stmt that we are vectorizing.  */\n+   STMT_INFO is the original scalar stmt that we are vectorizing.  */\n \n static gimple *\n vect_gen_widened_results_half (enum tree_code code,\n \t\t\t       tree decl,\n                                tree vec_oprnd0, tree vec_oprnd1, int op_type,\n \t\t\t       tree vec_dest, gimple_stmt_iterator *gsi,\n-\t\t\t       gimple *stmt)\n+\t\t\t       stmt_vec_info stmt_info)\n {\n   gimple *new_stmt;\n   tree new_temp;\n@@ -4436,30 +4437,31 @@ vect_gen_widened_results_half (enum tree_code code,\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n     }\n-  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+  vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n \n   return new_stmt;\n }\n \n \n-/* Get vectorized definitions for loop-based vectorization.  For the first\n-   operand we call vect_get_vec_def_for_operand() (with OPRND containing\n-   scalar operand), and for the rest we get a copy with\n+/* Get vectorized definitions for loop-based vectorization of STMT_INFO.\n+   For the first operand we call vect_get_vec_def_for_operand (with OPRND\n+   containing scalar operand), and for the rest we get a copy with\n    vect_get_vec_def_for_stmt_copy() using the previous vector definition\n    (stored in OPRND). See vect_get_vec_def_for_stmt_copy() for details.\n    The vectors are collected into VEC_OPRNDS.  */\n \n static void\n-vect_get_loop_based_defs (tree *oprnd, gimple *stmt, enum vect_def_type dt,\n-\t\t\t  vec<tree> *vec_oprnds, int multi_step_cvt)\n+vect_get_loop_based_defs (tree *oprnd, stmt_vec_info stmt_info,\n+\t\t\t  enum vect_def_type dt, vec<tree> *vec_oprnds,\n+\t\t\t  int multi_step_cvt)\n {\n   tree vec_oprnd;\n \n   /* Get first vector operand.  */\n   /* All the vector operands except the very first one (that is scalar oprnd)\n      are stmt copies.  */\n   if (TREE_CODE (TREE_TYPE (*oprnd)) != VECTOR_TYPE)\n-    vec_oprnd = vect_get_vec_def_for_operand (*oprnd, stmt);\n+    vec_oprnd = vect_get_vec_def_for_operand (*oprnd, stmt_info);\n   else\n     vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, *oprnd);\n \n@@ -4474,7 +4476,8 @@ vect_get_loop_based_defs (tree *oprnd, gimple *stmt, enum vect_def_type dt,\n   /* For conversion in multiple steps, continue to get operands\n      recursively.  */\n   if (multi_step_cvt)\n-    vect_get_loop_based_defs (oprnd, stmt, dt, vec_oprnds,  multi_step_cvt - 1);\n+    vect_get_loop_based_defs (oprnd, stmt_info, dt, vec_oprnds,\n+\t\t\t      multi_step_cvt - 1);\n }\n \n \n@@ -4549,13 +4552,14 @@ vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n \n \n /* Create vectorized promotion statements for vector operands from VEC_OPRNDS0\n-   and VEC_OPRNDS1 (for binary operations).  For multi-step conversions store\n-   the resulting vectors and call the function recursively.  */\n+   and VEC_OPRNDS1, for a binary operation associated with scalar statement\n+   STMT_INFO.  For multi-step conversions store the resulting vectors and\n+   call the function recursively.  */\n \n static void\n vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n \t\t\t\t\tvec<tree> *vec_oprnds1,\n-\t\t\t\t\tgimple *stmt, tree vec_dest,\n+\t\t\t\t\tstmt_vec_info stmt_info, tree vec_dest,\n \t\t\t\t\tgimple_stmt_iterator *gsi,\n \t\t\t\t\tenum tree_code code1,\n \t\t\t\t\tenum tree_code code2, tree decl1,\n@@ -4576,9 +4580,11 @@ vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n \n       /* Generate the two halves of promotion operation.  */\n       new_stmt1 = vect_gen_widened_results_half (code1, decl1, vop0, vop1,\n-\t\t\t\t\t\t op_type, vec_dest, gsi, stmt);\n+\t\t\t\t\t\t op_type, vec_dest, gsi,\n+\t\t\t\t\t\t stmt_info);\n       new_stmt2 = vect_gen_widened_results_half (code2, decl2, vop0, vop1,\n-\t\t\t\t\t\t op_type, vec_dest, gsi, stmt);\n+\t\t\t\t\t\t op_type, vec_dest, gsi,\n+\t\t\t\t\t\t stmt_info);\n       if (is_gimple_call (new_stmt1))\n \t{\n \t  new_tmp1 = gimple_call_lhs (new_stmt1);\n@@ -7318,19 +7324,19 @@ vect_gen_perm_mask_checked (tree vectype, const vec_perm_indices &sel)\n }\n \n /* Given a vector variable X and Y, that was generated for the scalar\n-   STMT, generate instructions to permute the vector elements of X and Y\n+   STMT_INFO, generate instructions to permute the vector elements of X and Y\n    using permutation mask MASK_VEC, insert them at *GSI and return the\n    permuted vector variable.  */\n \n static tree\n-permute_vec_elements (tree x, tree y, tree mask_vec, gimple *stmt,\n+permute_vec_elements (tree x, tree y, tree mask_vec, stmt_vec_info stmt_info,\n \t\t      gimple_stmt_iterator *gsi)\n {\n   tree vectype = TREE_TYPE (x);\n   tree perm_dest, data_ref;\n   gimple *perm_stmt;\n \n-  tree scalar_dest = gimple_get_lhs (stmt);\n+  tree scalar_dest = gimple_get_lhs (stmt_info->stmt);\n   if (TREE_CODE (scalar_dest) == SSA_NAME)\n     perm_dest = vect_create_destination_var (scalar_dest, vectype);\n   else\n@@ -7339,7 +7345,7 @@ permute_vec_elements (tree x, tree y, tree mask_vec, gimple *stmt,\n \n   /* Generate the permute statement.  */\n   perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, x, y, mask_vec);\n-  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+  vect_finish_stmt_generation (stmt_info, perm_stmt, gsi);\n \n   return data_ref;\n }\n@@ -9409,11 +9415,11 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* If SLP_NODE is nonnull, return true if vectorizable_live_operation\n    can handle all live statements in the node.  Otherwise return true\n-   if STMT is not live or if vectorizable_live_operation can handle it.\n+   if STMT_INFO is not live or if vectorizable_live_operation can handle it.\n    GSI and VEC_STMT are as for vectorizable_live_operation.  */\n \n static bool\n-can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n+can_vectorize_live_stmts (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t  slp_tree slp_node, stmt_vec_info *vec_stmt,\n \t\t\t  stmt_vector_for_cost *cost_vec)\n {\n@@ -9429,9 +9435,9 @@ can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    return false;\n \t}\n     }\n-  else if (STMT_VINFO_LIVE_P (vinfo_for_stmt (stmt))\n-\t   && !vectorizable_live_operation (stmt, gsi, slp_node, -1, vec_stmt,\n-\t\t\t\t\t    cost_vec))\n+  else if (STMT_VINFO_LIVE_P (stmt_info)\n+\t   && !vectorizable_live_operation (stmt_info, gsi, slp_node, -1,\n+\t\t\t\t\t    vec_stmt, cost_vec))\n     return false;\n \n   return true;"}]}