{"sha": "af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY0YmE0MjMwOGMxN2NkOWUzNWRiNDZiZmJjMjAzNmZjNDVhMTJiMg==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2012-05-01T14:45:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-01T14:45:24Z"}, "message": "Makefile.in (lower-subreg.o, [...]): Depend on lower-subreg.h.\n\ngcc/\n2012-03-31  Kenneth Zadeck  <zadeck@naturalbridge.com>\n\t    Richard Sandiford  <r.sandiford@uk.ibm.com>\n\n\t* Makefile.in (lower-subreg.o, target-globals.o): Depend on\n\tlower-subreg.h.\n\t* lower-subreg.h: New file.\n\t* target-globals.h (this_target_lower_subreg): Declare.\n\t(target_globals): Add lower_subreg;\n\t(restore_target_globals): Restore this_target_lower_subreg.\n\t* target-globals.c: Include it.\n\t(default_target_globals): Add default_target_lower_subreg.\n\t(save_target_globals): Initialize target_lower_subreg.\n\t* rtl.h (init_lower_subreg): Added declaration.\n\t* toplev.c (backend_init_target): Call initializer for lower-subreg\n\tpass.\n\t* lower-subreg.c (LOG_COSTS, FORCE_LOWERING): New macros.\n\t(default_target_lower_subreg): New variable.\n\t(this_target_lower_subreg): Likewise.\n\t(twice_word_mode, choices): New macros.\n\t(shift_cost, compute_splitting_shift, compute_costs)\n\t(init_lower_subreg): New functions.\n\t(resolve_simple_move): Add speed_p argument.  Check choices.\n\t(find_pseudo_copy): Don't check the mode size here.\n\t(resolve_simple_move): Assert the mode size.\n\t(find_decomposable_shift_zext): Add speed_p argument and return\n\ta bool.  Check choices.\n\t(resolve_shift_zext): Add comment.\n\t(dump_shift_choices, dump_choices): New functions.\n\t(decompose_multiword_subregs): Dump list of profitable\n\ttransformations.  Add code to skip non profitable transformations.\n\tUpdate calls to simple_move and find_decomposable_shift_zext.\n\nCo-Authored-By: Richard Sandiford <r.sandiford@uk.ibm.com>\n\nFrom-SVN: r187015", "tree": {"sha": "4e8ab9b9d983a212b8aa35ed9a63c7bffb107ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e8ab9b9d983a212b8aa35ed9a63c7bffb107ef5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "90911ab64f49da361102ebc7c9996765beb507ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90911ab64f49da361102ebc7c9996765beb507ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90911ab64f49da361102ebc7c9996765beb507ce"}], "stats": {"total": 500, "additions": 449, "deletions": 51}, "files": [{"sha": "e7851b47ae77ec344c64605686703f4681d41d81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -1,3 +1,35 @@\n+2012-05-01  Kenneth Zadeck  <zadeck@naturalbridge.com>\n+\t    Richard Sandiford  <r.sandiford@uk.ibm.com>\n+\n+\t* Makefile.in (lower-subreg.o, target-globals.o): Depend on\n+\tlower-subreg.h.\n+\t* lower-subreg.h: New file.\n+\t* target-globals.h (this_target_lower_subreg): Declare.\n+\t(target_globals): Add lower_subreg;\n+\t(restore_target_globals): Restore this_target_lower_subreg.\n+\t* target-globals.c: Include it.\n+\t(default_target_globals): Add default_target_lower_subreg.\n+\t(save_target_globals): Initialize target_lower_subreg.\n+\t* rtl.h (init_lower_subreg): Added declaration.\n+\t* toplev.c (backend_init_target): Call initializer for lower-subreg\n+\tpass.\n+\t* lower-subreg.c (LOG_COSTS, FORCE_LOWERING): New macros.\n+\t(default_target_lower_subreg): New variable.\n+\t(this_target_lower_subreg): Likewise.\n+\t(twice_word_mode, choices): New macros.\n+\t(shift_cost, compute_splitting_shift, compute_costs)\n+\t(init_lower_subreg): New functions.\n+\t(resolve_simple_move): Add speed_p argument.  Check choices.\n+\t(find_pseudo_copy): Don't check the mode size here.\n+\t(resolve_simple_move): Assert the mode size.\n+\t(find_decomposable_shift_zext): Add speed_p argument and return\n+\ta bool.  Check choices.\n+\t(resolve_shift_zext): Add comment.\n+\t(dump_shift_choices, dump_choices): New functions.\n+\t(decompose_multiword_subregs): Dump list of profitable\n+\ttransformations.  Add code to skip non profitable transformations.\n+\tUpdate calls to simple_move and find_decomposable_shift_zext.\n+\n 2012-05-01  Ian Bolton  <ian.bolton@arm.com>\n             Sameera Deshpande  <sameera.deshpande@arm.com>\n             Greta Yorsh  <greta.yorsh@arm.com>"}, {"sha": "d35d110e920f989a0df3985b0e3f9cb4f3f2dd03", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -3428,11 +3428,13 @@ dbgcnt.o: dbgcnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) $(DB\n lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(MACHMODE_H) $(TM_H) $(RTL_H) $(TM_P_H) $(TIMEVAR_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) $(OBSTACK_H) $(BITMAP_H) \\\n-   $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H) dce.h\n+   $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H) dce.h \\\n+   lower-subreg.h\n target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) toplev.h target-globals.h \\\n    $(FLAGS_H) $(REGS_H) $(RTL_H) reload.h expmed.h $(EXPR_H) $(OPTABS_H) \\\n-   $(LIBFUNCS_H) $(CFGLOOP_H) $(IRA_INT_H) builtins.h gcse.h bb-reorder.h\n+   $(LIBFUNCS_H) $(CFGLOOP_H) $(IRA_INT_H) builtins.h gcse.h bb-reorder.h \\\n+   lower-subreg.h\n hw-doloop.o : hw-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n    $(DF_H) $(CFGLAYOUT_H) $(CFGLOOP_H) output.h $(RECOG_H) $(TARGET_H) \\"}, {"sha": "a11b33d1391cccb4997d1832ef61af9a4ff77ae5", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 343, "deletions": 48, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regs.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n+#include \"lower-subreg.h\"\n \n #ifdef STACK_GROWS_DOWNWARD\n # undef STACK_GROWS_DOWNWARD\n@@ -52,10 +53,35 @@ DEF_VEC_P (bitmap);\n DEF_VEC_ALLOC_P (bitmap,heap);\n \n /* Decompose multi-word pseudo-registers into individual\n-   pseudo-registers when possible.  This is possible when all the uses\n-   of a multi-word register are via SUBREG, or are copies of the\n-   register to another location.  Breaking apart the register permits\n-   more CSE and permits better register allocation.  */\n+   pseudo-registers when possible and profitable.  This is possible\n+   when all the uses of a multi-word register are via SUBREG, or are\n+   copies of the register to another location.  Breaking apart the\n+   register permits more CSE and permits better register allocation.\n+   This is profitable if the machine does not have move instructions\n+   to do this.\n+\n+   This pass only splits moves with modes that are wider than\n+   word_mode and ASHIFTs, LSHIFTRTs and ZERO_EXTENDs with integer\n+   modes that are twice the width of word_mode.  The latter could be\n+   generalized if there was a need to do this, but the trend in\n+   architectures is to not need this.\n+\n+   There are two useful preprocessor defines for use by maintainers:\n+\n+   #define LOG_COSTS 1\n+\n+   if you wish to see the actual cost estimates that are being used\n+   for each mode wider than word mode and the cost estimates for zero\n+   extension and the shifts.   This can be useful when port maintainers\n+   are tuning insn rtx costs.\n+\n+   #define FORCE_LOWERING 1\n+\n+   if you wish to test the pass with all the transformation forced on.\n+   This can be useful for finding bugs in the transformations.  */\n+\n+#define LOG_COSTS 0\n+#define FORCE_LOWERING 0\n \n /* Bit N in this bitmap is set if regno N is used in a context in\n    which we can decompose it.  */\n@@ -75,8 +101,190 @@ static bitmap subreg_context;\n    copy from reg M to reg N.  */\n static VEC(bitmap,heap) *reg_copy_graph;\n \n-/* Return whether X is a simple object which we can take a word_mode\n-   subreg of.  */\n+struct target_lower_subreg default_target_lower_subreg;\n+#if SWITCHABLE_TARGET\n+struct target_lower_subreg *this_target_lower_subreg\n+  = &default_target_lower_subreg;\n+#endif\n+\n+#define twice_word_mode \\\n+  this_target_lower_subreg->x_twice_word_mode\n+#define choices \\\n+  this_target_lower_subreg->x_choices\n+\n+/* RTXes used while computing costs.  */\n+struct cost_rtxes {\n+  /* Source and target registers.  */\n+  rtx source;\n+  rtx target;\n+\n+  /* A twice_word_mode ZERO_EXTEND of SOURCE.  */\n+  rtx zext;\n+\n+  /* A shift of SOURCE.  */\n+  rtx shift;\n+\n+  /* A SET of TARGET.  */\n+  rtx set;\n+};\n+\n+/* Return the cost of a CODE shift in mode MODE by OP1 bits, using the\n+   rtxes in RTXES.  SPEED_P selects between the speed and size cost.  */\n+\n+static int\n+shift_cost (bool speed_p, struct cost_rtxes *rtxes, enum rtx_code code,\n+\t    enum machine_mode mode, int op1)\n+{\n+  PUT_MODE (rtxes->target, mode);\n+  PUT_CODE (rtxes->shift, code);\n+  PUT_MODE (rtxes->shift, mode);\n+  PUT_MODE (rtxes->source, mode);\n+  XEXP (rtxes->shift, 1) = GEN_INT (op1);\n+  SET_SRC (rtxes->set) = rtxes->shift;\n+  return insn_rtx_cost (rtxes->set, speed_p);\n+}\n+\n+/* For each X in the range [0, BITS_PER_WORD), set SPLITTING[X]\n+   to true if it is profitable to split a double-word CODE shift\n+   of X + BITS_PER_WORD bits.  SPEED_P says whether we are testing\n+   for speed or size profitability.\n+\n+   Use the rtxes in RTXES to calculate costs.  WORD_MOVE_ZERO_COST is\n+   the cost of moving zero into a word-mode register.  WORD_MOVE_COST\n+   is the cost of moving between word registers.  */\n+\n+static void\n+compute_splitting_shift (bool speed_p, struct cost_rtxes *rtxes,\n+\t\t\t bool *splitting, enum rtx_code code,\n+\t\t\t int word_move_zero_cost, int word_move_cost)\n+{\n+  int wide_cost, narrow_cost, i;\n+\n+  for (i = 0; i < BITS_PER_WORD; i++)\n+    {\n+      wide_cost = shift_cost (speed_p, rtxes, code, twice_word_mode,\n+\t\t\t      i + BITS_PER_WORD);\n+      if (i == 0)\n+\tnarrow_cost = word_move_cost;\n+      else\n+\tnarrow_cost = shift_cost (speed_p, rtxes, code, word_mode, i);\n+\n+      if (LOG_COSTS)\n+\tfprintf (stderr, \"%s %s by %d: original cost %d, split cost %d + %d\\n\",\n+\t\t GET_MODE_NAME (twice_word_mode), GET_RTX_NAME (code),\n+\t\t i + BITS_PER_WORD, wide_cost, narrow_cost,\n+\t\t word_move_zero_cost);\n+\n+      if (FORCE_LOWERING || wide_cost >= narrow_cost + word_move_zero_cost)\n+\tsplitting[i] = true;\n+    }\n+}\n+\n+/* Compute what we should do when optimizing for speed or size; SPEED_P\n+   selects which.  Use RTXES for computing costs.  */\n+\n+static void\n+compute_costs (bool speed_p, struct cost_rtxes *rtxes)\n+{\n+  unsigned int i;\n+  int word_move_zero_cost, word_move_cost;\n+\n+  SET_SRC (rtxes->set) = CONST0_RTX (word_mode);\n+  word_move_zero_cost = insn_rtx_cost (rtxes->set, speed_p);\n+\n+  SET_SRC (rtxes->set) = rtxes->source;\n+  word_move_cost = insn_rtx_cost (rtxes->set, speed_p);\n+\n+  if (LOG_COSTS)\n+    fprintf (stderr, \"%s move: from zero cost %d, from reg cost %d\\n\",\n+\t     GET_MODE_NAME (word_mode), word_move_zero_cost, word_move_cost);\n+\n+  for (i = 0; i < MAX_MACHINE_MODE; i++)\n+    {\n+      enum machine_mode mode = (enum machine_mode) i;\n+      int factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+      if (factor > 1)\n+\t{\n+\t  int mode_move_cost;\n+\n+\t  PUT_MODE (rtxes->target, mode);\n+\t  PUT_MODE (rtxes->source, mode);\n+\t  mode_move_cost = insn_rtx_cost (rtxes->set, speed_p);\n+\n+\t  if (LOG_COSTS)\n+\t    fprintf (stderr, \"%s move: original cost %d, split cost %d * %d\\n\",\n+\t\t     GET_MODE_NAME (mode), mode_move_cost,\n+\t\t     word_move_cost, factor);\n+\n+\t  if (FORCE_LOWERING || mode_move_cost >= word_move_cost * factor)\n+\t    {\n+\t      choices[speed_p].move_modes_to_split[i] = true;\n+\t      choices[speed_p].something_to_do = true;\n+\t    }\n+\t}\n+    }\n+\n+  /* For the moves and shifts, the only case that is checked is one\n+     where the mode of the target is an integer mode twice the width\n+     of the word_mode.\n+\n+     If it is not profitable to split a double word move then do not\n+     even consider the shifts or the zero extension.  */\n+  if (choices[speed_p].move_modes_to_split[(int) twice_word_mode])\n+    {\n+      int zext_cost;\n+\n+      /* The only case here to check to see if moving the upper part with a\n+\t zero is cheaper than doing the zext itself.  */\n+      PUT_MODE (rtxes->target, twice_word_mode);\n+      PUT_MODE (rtxes->source, word_mode);\n+      SET_SRC (rtxes->set) = rtxes->zext;\n+      zext_cost = insn_rtx_cost (rtxes->set, speed_p);\n+\n+      if (LOG_COSTS)\n+\tfprintf (stderr, \"%s %s: original cost %d, split cost %d + %d\\n\",\n+\t\t GET_MODE_NAME (twice_word_mode), GET_RTX_NAME (ZERO_EXTEND),\n+\t\t zext_cost, word_move_cost, word_move_zero_cost);\n+\n+      if (FORCE_LOWERING || zext_cost >= word_move_cost + word_move_zero_cost)\n+\tchoices[speed_p].splitting_zext = true;\n+\n+      compute_splitting_shift (speed_p, rtxes,\n+\t\t\t       choices[speed_p].splitting_ashift, ASHIFT,\n+\t\t\t       word_move_zero_cost, word_move_cost);\n+      compute_splitting_shift (speed_p, rtxes,\n+\t\t\t       choices[speed_p].splitting_lshiftrt, LSHIFTRT,\n+\t\t\t       word_move_zero_cost, word_move_cost);\n+    }\n+}\n+\n+/* Do one-per-target initialisation.  This involves determining\n+   which operations on the machine are profitable.  If none are found,\n+   then the pass just returns when called.  */\n+\n+void\n+init_lower_subreg (void)\n+{\n+  struct cost_rtxes rtxes;\n+\n+  memset (this_target_lower_subreg, 0, sizeof (*this_target_lower_subreg));\n+\n+  twice_word_mode = GET_MODE_2XWIDER_MODE (word_mode);\n+\n+  rtxes.target = gen_rtx_REG (word_mode, FIRST_PSEUDO_REGISTER);\n+  rtxes.source = gen_rtx_REG (word_mode, FIRST_PSEUDO_REGISTER + 1);\n+  rtxes.set = gen_rtx_SET (VOIDmode, rtxes.target, rtxes.source);\n+  rtxes.zext = gen_rtx_ZERO_EXTEND (twice_word_mode, rtxes.source);\n+  rtxes.shift = gen_rtx_ASHIFT (twice_word_mode, rtxes.source, const0_rtx);\n+\n+  if (LOG_COSTS)\n+    fprintf (stderr, \"\\nSize costs\\n==========\\n\\n\");\n+  compute_costs (false, &rtxes);\n+\n+  if (LOG_COSTS)\n+    fprintf (stderr, \"\\nSpeed costs\\n===========\\n\\n\");\n+  compute_costs (true, &rtxes);\n+}\n \n static bool\n simple_move_operand (rtx x)\n@@ -101,12 +309,15 @@ simple_move_operand (rtx x)\n   return true;\n }\n \n-/* If INSN is a single set between two objects, return the single set.\n-   Such an insn can always be decomposed.  INSN should have been\n-   passed to recog and extract_insn before this is called.  */\n+/* If INSN is a single set between two objects that we want to split,\n+   return the single set.  SPEED_P says whether we are optimizing\n+   INSN for speed or size.\n+\n+   INSN should have been passed to recog and extract_insn before this\n+   is called.  */\n \n static rtx\n-simple_move (rtx insn)\n+simple_move (rtx insn, bool speed_p)\n {\n   rtx x;\n   rtx set;\n@@ -150,6 +361,9 @@ simple_move (rtx insn)\n   if (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n     return NULL_RTX;\n \n+  if (!choices[speed_p].move_modes_to_split[(int) mode])\n+    return NULL_RTX;\n+\n   return set;\n }\n \n@@ -173,9 +387,6 @@ find_pseudo_copy (rtx set)\n   if (HARD_REGISTER_NUM_P (rd) || HARD_REGISTER_NUM_P (rs))\n     return false;\n \n-  if (GET_MODE_SIZE (GET_MODE (dest)) <= UNITS_PER_WORD)\n-    return false;\n-\n   b = VEC_index (bitmap, reg_copy_graph, rs);\n   if (b == NULL)\n     {\n@@ -668,8 +879,7 @@ resolve_simple_move (rtx set, rtx insn)\n   orig_mode = GET_MODE (dest);\n \n   words = (GET_MODE_SIZE (orig_mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  if (words <= 1)\n-    return insn;\n+  gcc_assert (words > 1);\n \n   start_sequence ();\n \n@@ -931,54 +1141,58 @@ resolve_debug (rtx insn)\n   resolve_reg_notes (insn);\n }\n \n-/* Checks if INSN is a decomposable multiword-shift or zero-extend and\n-   sets the decomposable_context bitmap accordingly.  A non-zero value\n-   is returned if a decomposable insn has been found.  */\n+/* Check if INSN is a decomposable multiword-shift or zero-extend and\n+   set the decomposable_context bitmap accordingly.  SPEED_P is true\n+   if we are optimizing INSN for speed rather than size.  Return true\n+   if INSN is decomposable.  */\n \n-static int\n-find_decomposable_shift_zext (rtx insn)\n+static bool\n+find_decomposable_shift_zext (rtx insn, bool speed_p)\n {\n   rtx set;\n   rtx op;\n   rtx op_operand;\n \n   set = single_set (insn);\n   if (!set)\n-    return 0;\n+    return false;\n \n   op = SET_SRC (set);\n   if (GET_CODE (op) != ASHIFT\n       && GET_CODE (op) != LSHIFTRT\n       && GET_CODE (op) != ZERO_EXTEND)\n-    return 0;\n+    return false;\n \n   op_operand = XEXP (op, 0);\n   if (!REG_P (SET_DEST (set)) || !REG_P (op_operand)\n       || HARD_REGISTER_NUM_P (REGNO (SET_DEST (set)))\n       || HARD_REGISTER_NUM_P (REGNO (op_operand))\n-      || !SCALAR_INT_MODE_P (GET_MODE (op)))\n-    return 0;\n+      || GET_MODE (op) != twice_word_mode)\n+    return false;\n \n   if (GET_CODE (op) == ZERO_EXTEND)\n     {\n       if (GET_MODE (op_operand) != word_mode\n-\t  || GET_MODE_BITSIZE (GET_MODE (op)) != 2 * BITS_PER_WORD)\n-\treturn 0;\n+\t  || !choices[speed_p].splitting_zext)\n+\treturn false;\n     }\n   else /* left or right shift */\n     {\n+      bool *splitting = (GET_CODE (op) == ASHIFT\n+\t\t\t ? choices[speed_p].splitting_ashift\n+\t\t\t : choices[speed_p].splitting_lshiftrt);\n       if (!CONST_INT_P (XEXP (op, 1))\n-\t  || INTVAL (XEXP (op, 1)) < BITS_PER_WORD\n-\t  || GET_MODE_BITSIZE (GET_MODE (op_operand)) != 2 * BITS_PER_WORD)\n-\treturn 0;\n+\t  || !IN_RANGE (INTVAL (XEXP (op, 1)), BITS_PER_WORD,\n+\t\t\t2 * BITS_PER_WORD - 1)\n+\t  || !splitting[INTVAL (XEXP (op, 1)) - BITS_PER_WORD])\n+\treturn false;\n+\n+      bitmap_set_bit (decomposable_context, REGNO (op_operand));\n     }\n \n   bitmap_set_bit (decomposable_context, REGNO (SET_DEST (set)));\n \n-  if (GET_CODE (op) != ZERO_EXTEND)\n-    bitmap_set_bit (decomposable_context, REGNO (op_operand));\n-\n-  return 1;\n+  return true;\n }\n \n /* Decompose a more than word wide shift (in INSN) of a multiword\n@@ -1008,6 +1222,8 @@ resolve_shift_zext (rtx insn)\n \n   op_operand = XEXP (op, 0);\n \n+  /* We can tear this operation apart only if the regs were already\n+     torn apart.  */\n   if (!resolve_reg_p (SET_DEST (set)) && !resolve_reg_p (op_operand))\n     return NULL_RTX;\n \n@@ -1073,6 +1289,56 @@ resolve_shift_zext (rtx insn)\n   return insns;\n }\n \n+/* Print to dump_file a description of what we're doing with shift code CODE.\n+   SPLITTING[X] is true if we are splitting shifts by X + BITS_PER_WORD.  */\n+\n+static void\n+dump_shift_choices (enum rtx_code code, bool *splitting)\n+{\n+  int i;\n+  const char *sep;\n+\n+  fprintf (dump_file,\n+\t   \"  Splitting mode %s for %s lowering with shift amounts = \",\n+\t   GET_MODE_NAME (twice_word_mode), GET_RTX_NAME (code));\n+  sep = \"\";\n+  for (i = 0; i < BITS_PER_WORD; i++)\n+    if (splitting[i])\n+      {\n+\tfprintf (dump_file, \"%s%d\", sep, i + BITS_PER_WORD);\n+\tsep = \",\";\n+      }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Print to dump_file a description of what we're doing when optimizing\n+   for speed or size; SPEED_P says which.  DESCRIPTION is a description\n+   of the SPEED_P choice.  */\n+\n+static void\n+dump_choices (bool speed_p, const char *description)\n+{\n+  unsigned int i;\n+\n+  fprintf (dump_file, \"Choices when optimizing for %s:\\n\", description);\n+\n+  for (i = 0; i < MAX_MACHINE_MODE; i++)\n+    if (GET_MODE_SIZE (i) > UNITS_PER_WORD)\n+      fprintf (dump_file, \"  %s mode %s for copy lowering.\\n\",\n+\t       choices[speed_p].move_modes_to_split[i]\n+\t       ? \"Splitting\"\n+\t       : \"Skipping\",\n+\t       GET_MODE_NAME ((enum machine_mode) i));\n+\n+  fprintf (dump_file, \"  %s mode %s for zero_extend lowering.\\n\",\n+\t   choices[speed_p].splitting_zext ? \"Splitting\" : \"Skipping\",\n+\t   GET_MODE_NAME (twice_word_mode));\n+\n+  dump_shift_choices (ASHIFT, choices[speed_p].splitting_ashift);\n+  dump_shift_choices (LSHIFTRT, choices[speed_p].splitting_ashift);\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n /* Look for registers which are always accessed via word-sized SUBREGs\n    or via copies.  Decompose these registers into several word-sized\n    pseudo-registers.  */\n@@ -1082,9 +1348,21 @@ decompose_multiword_subregs (void)\n {\n   unsigned int max;\n   basic_block bb;\n+  bool speed_p;\n \n-  if (df)\n-    df_set_flags (DF_DEFER_INSN_RESCAN);\n+  if (dump_file)\n+    {\n+      dump_choices (false, \"size\");\n+      dump_choices (true, \"speed\");\n+    }\n+\n+  /* Check if this target even has any modes to consider lowering.   */\n+  if (!choices[false].something_to_do && !choices[true].something_to_do)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Nothing to do!\\n\");\n+      return;\n+    }\n \n   max = max_reg_num ();\n \n@@ -1094,24 +1372,38 @@ decompose_multiword_subregs (void)\n      all the insns.  */\n   {\n     unsigned int i;\n+    bool useful_modes_seen = false;\n \n     for (i = FIRST_PSEUDO_REGISTER; i < max; ++i)\n+      if (regno_reg_rtx[i] != NULL)\n+\t{\n+\t  enum machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n+\t  if (choices[false].move_modes_to_split[(int) mode]\n+\t      || choices[true].move_modes_to_split[(int) mode])\n+\t    {\n+\t      useful_modes_seen = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+    if (!useful_modes_seen)\n       {\n-\tif (regno_reg_rtx[i] != NULL\n-\t    && GET_MODE_SIZE (GET_MODE (regno_reg_rtx[i])) > UNITS_PER_WORD)\n-\t  break;\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"Nothing to lower in this function.\\n\");\n+\treturn;\n       }\n-    if (i == max)\n-      return;\n   }\n \n   if (df)\n-    run_word_dce ();\n+    {\n+      df_set_flags (DF_DEFER_INSN_RESCAN);\n+      run_word_dce ();\n+    }\n \n-  /* FIXME: When the dataflow branch is merged, we can change this\n-     code to look for each multi-word pseudo-register and to find each\n-     insn which sets or uses that register.  That should be faster\n-     than scanning all the insns.  */\n+  /* FIXME: It may be possible to change this code to look for each\n+     multi-word pseudo-register and to find each insn which sets or\n+     uses that register.  That should be faster than scanning all the\n+     insns.  */\n \n   decomposable_context = BITMAP_ALLOC (NULL);\n   non_decomposable_context = BITMAP_ALLOC (NULL);\n@@ -1121,6 +1413,7 @@ decompose_multiword_subregs (void)\n   VEC_safe_grow (bitmap, heap, reg_copy_graph, max);\n   memset (VEC_address (bitmap, reg_copy_graph), 0, sizeof (bitmap) * max);\n \n+  speed_p = optimize_function_for_speed_p (cfun);\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n@@ -1138,12 +1431,12 @@ decompose_multiword_subregs (void)\n \n \t  recog_memoized (insn);\n \n-\t  if (find_decomposable_shift_zext (insn))\n+\t  if (find_decomposable_shift_zext (insn, speed_p))\n \t    continue;\n \n \t  extract_insn (insn);\n \n-\t  set = simple_move (insn);\n+\t  set = simple_move (insn, speed_p);\n \n \t  if (!set)\n \t    cmi = NOT_SIMPLE_MOVE;\n@@ -1197,7 +1490,9 @@ decompose_multiword_subregs (void)\n       FOR_EACH_BB (bb)\n \t{\n \t  rtx insn;\n+\t  bool speed_p;\n \n+\t  speed_p = optimize_bb_for_speed_p (bb);\n \t  FOR_BB_INSNS (bb, insn)\n \t    {\n \t      rtx pat;\n@@ -1220,7 +1515,7 @@ decompose_multiword_subregs (void)\n \t\t  recog_memoized (insn);\n \t\t  extract_insn (insn);\n \n-\t\t  set = simple_move (insn);\n+\t\t  set = simple_move (insn, speed_p);\n \t\t  if (set)\n \t\t    {\n \t\t      rtx orig_insn = insn;"}, {"sha": "5c960dbfd09a5bb7e245b9cae0b5728c20aee1bc", "filename": "gcc/lower-subreg.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Flower-subreg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Flower-subreg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.h?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -0,0 +1,59 @@\n+/* Target-dependent costs for lower-subreg.c.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option; any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LOWER_SUBREG_H\n+#define LOWER_SUBREG_H 1\n+\n+/* Information about whether, and where, lower-subreg should be applied.  */\n+struct lower_subreg_choices {\n+  /* A boolean vector for move splitting that is indexed by mode and is\n+     true for each mode that is to have its copies split.  */\n+  bool move_modes_to_split[MAX_MACHINE_MODE];\n+\n+  /* True if zero-extensions from word_mode to twice_word_mode should\n+     be split.  */\n+  bool splitting_zext;\n+\n+  /* Index X is true if twice_word_mode shifts by X + BITS_PER_WORD\n+     should be split.  */\n+  bool splitting_ashift[MAX_BITS_PER_WORD];\n+  bool splitting_lshiftrt[MAX_BITS_PER_WORD];\n+\n+  /* True if there is at least one mode that is worth splitting.  */\n+  bool something_to_do;\n+};\n+\n+/* Target-specific information for the subreg lowering pass.  */\n+struct target_lower_subreg {\n+  /* An integer mode that is twice as wide as word_mode.  */\n+  enum machine_mode x_twice_word_mode;\n+\n+  /* What we have decided to do when optimizing for size (index 0)\n+     and speed (index 1).  */\n+  struct lower_subreg_choices x_choices[2];\n+};\n+\n+extern struct target_lower_subreg default_target_lower_subreg;\n+#if SWITCHABLE_TARGET\n+extern struct target_lower_subreg *this_target_lower_subreg;\n+#else\n+#define this_target_lower_subreg (&default_target_lower_subreg)\n+#endif\n+\n+#endif"}, {"sha": "86c56acc197d7a5ad9a65d37c1d37d10d844bbc3", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -2526,6 +2526,9 @@ extern void init_expmed (void);\n extern void expand_inc (rtx, rtx);\n extern void expand_dec (rtx, rtx);\n \n+/* In lower-subreg.c */\n+extern void init_lower_subreg (void);\n+\n /* In gcse.c */\n extern bool can_copy_p (enum machine_mode);\n extern bool can_assign_to_reg_without_clobbers_p (rtx);"}, {"sha": "e679f21614ed8c75bca3cf9e774d6316b5b70c45", "filename": "gcc/target-globals.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"gcse.h\"\n #include \"bb-reorder.h\"\n+#include \"lower-subreg.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n@@ -56,7 +57,8 @@ struct target_globals default_target_globals = {\n   &default_target_ira_int,\n   &default_target_builtins,\n   &default_target_gcse,\n-  &default_target_bb_reorder\n+  &default_target_bb_reorder,\n+  &default_target_lower_subreg\n };\n \n struct target_globals *\n@@ -79,6 +81,7 @@ save_target_globals (void)\n   g->builtins = XCNEW (struct target_builtins);\n   g->gcse = XCNEW (struct target_gcse);\n   g->bb_reorder = XCNEW (struct target_bb_reorder);\n+  g->lower_subreg = XCNEW (struct target_lower_subreg);\n   restore_target_globals (g);\n   init_reg_sets ();\n   target_reinit ();"}, {"sha": "fb0f260c0c9ca3f3efecfafcbd8d10890edfc46a", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -35,6 +35,7 @@ extern struct target_ira_int *this_target_ira_int;\n extern struct target_builtins *this_target_builtins;\n extern struct target_gcse *this_target_gcse;\n extern struct target_bb_reorder *this_target_bb_reorder;\n+extern struct target_lower_subreg *this_target_lower_subreg;\n \n struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n@@ -51,6 +52,7 @@ struct GTY(()) target_globals {\n   struct target_builtins *GTY((skip)) builtins;\n   struct target_gcse *GTY((skip)) gcse;\n   struct target_bb_reorder *GTY((skip)) bb_reorder;\n+  struct target_lower_subreg *GTY((skip)) lower_subreg;\n };\n \n extern struct target_globals default_target_globals;\n@@ -74,6 +76,7 @@ restore_target_globals (struct target_globals *g)\n   this_target_builtins = g->builtins;\n   this_target_gcse = g->gcse;\n   this_target_bb_reorder = g->bb_reorder;\n+  this_target_lower_subreg = g->lower_subreg;\n }\n #endif\n "}, {"sha": "d9aaa429f6507b6a6a2ed128e19448106c3fb868", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4ba42308c17cd9e35db46bfbc2036fc45a12b2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=af4ba42308c17cd9e35db46bfbc2036fc45a12b2", "patch": "@@ -1601,6 +1601,7 @@ backend_init_target (void)\n   /* rtx_cost is mode-dependent, so cached values need to be recomputed\n      on a mode change.  */\n   init_expmed ();\n+  init_lower_subreg ();\n \n   /* We may need to recompute regno_save_code[] and regno_restore_code[]\n      after a mode change as well.  */"}]}