{"sha": "8813a647b5f81fb32955f8ec2438d73e9e6280d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxM2E2NDdiNWY4MWZiMzI5NTVmOGVjMjQzOGQ3M2U5ZTYyODBkNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-09T11:19:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-09T11:19:48Z"}, "message": "tree-ssa.c (target_for_debug_bind, [...]): Use VAR_P and/or VAR_OR_FUNCTION_DECL_P macros.\n\n\t* tree-ssa.c (target_for_debug_bind, verify_phi_args,\n\tssa_undefined_value_p, maybe_optimize_var): Use VAR_P and/or\n\tVAR_OR_FUNCTION_DECL_P macros.\n\t* tree-chkp.c (chkp_register_var_initializer, chkp_make_static_bounds,\n\tchkp_get_bounds_for_decl_addr, chkp_parse_array_and_component_ref,\n\tchkp_find_bounds_1): Likewise.\n\t* ipa-polymorphic-call.c (decl_maybe_in_construction_p): Likewise.\n\t* hsa-gen.c (get_symbol_for_decl): Likewise.\n\t* cgraphunit.c (check_global_declaration, analyze_functions,\n\thandle_alias_pairs, thunk_adjust, cgraph_node::expand_thunk):\n\tLikewise.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p,\n\tcanonicalize_constructor_val, gimple_get_virt_method_for_vtable):\n\tLikewise.\n\t* tree.c (set_decl_section_name, copy_node_stat,\n\tneed_assembler_name_p, free_lang_data_in_decl, find_decls_types_r,\n\tmerge_dllimport_decl_attributes, handle_dll_attribute,\n\tdecl_init_priority_insert, auto_var_in_fn_p, array_at_struct_end_p,\n\tverify_type): Likewise.\n\t* gimple-ssa-isolate-paths.c (find_implicit_erroneous_behavior,\n\tfind_explicit_erroneous_behavior): Likewise.\n\t* sdbout.c (sdbout_toplevel_data, sdbout_late_global_decl): Likewise.\n\t* ipa.c (process_references): Likewise.\n\t* tree-chkp-opt.c (chkp_get_check_result): Likewise.\n\t* varasm.c (get_block_for_decl, use_blocks_for_decl_p, make_decl_rtl,\n\tnotice_global_symbol, assemble_variable, mark_decl_referenced,\n\tbuild_constant_desc, output_constant_def_contents, do_assemble_alias,\n\tmake_decl_one_only, default_section_type_flags,\n\tcategorize_decl_for_section, default_encode_section_info): Likewise.\n\t* trans-mem.c (requires_barrier): Likewise.\n\t* gimple-expr.c (mark_addressable): Likewise.\n\t* cfgexpand.c (add_scope_conflicts_1, expand_one_var,\n\texpand_used_vars_for_block, clear_tree_used, stack_protect_decl_p,\n\texpand_debug_expr): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* ubsan.c (instrument_bool_enum_load): Likewise.\n\t* tree-pretty-print.c (print_declaration): Likewise.\n\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n\t* tree-ssa-uninit.c (warn_uninitialized_vars): Likewise.\n\t* asan.c (asan_protect_global, instrument_derefs): Likewise.\n\t* tree-into-ssa.c (rewrite_stmt, maybe_register_def,\n\tpass_build_ssa::execute): Likewise.\n\t* var-tracking.c (var_debug_decl, track_expr_p): Likewise.\n\t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost, split_address_cost):\n\tLikewise.\n\t* ipa-split.c (test_nonssa_use, consider_split, mark_nonssa_use):\n\tLikewise.\n\t* tree-inline.c (insert_debug_decl_map, remap_ssa_name,\n\tcan_be_nonlocal, remap_decls, copy_debug_stmt,\n\tinitialize_inlined_parameters, add_local_variables,\n\treset_debug_binding, replace_locals_op): Likewise.\n\t* dse.c (can_escape): Likewise.\n\t* ipa-devirt.c (compare_virtual_tables, referenced_from_vtable_p):\n\tLikewise.\n\t* tree-diagnostic.c (default_tree_printer): Likewise.\n\t* tree-streamer-in.c (unpack_ts_decl_common_value_fields,\n\tunpack_ts_decl_with_vis_value_fields,\n\tlto_input_ts_decl_common_tree_pointers): Likewise.\n\t* builtins.c (builtin_save_expr, fold_builtin_expect,\n\treadonly_data_expr): Likewise.\n\t* tree-ssa-structalias.c (new_var_info, get_constraint_for_ssa_var,\n\tcreate_variable_info_for, set_uids_in_ptset, visit_loadstore):\n\tLikewise.\n\t* gimple-streamer-out.c (output_gimple_stmt): Likewise.\n\t* gimplify.c (force_constant_size, gimplify_bind_expr,\n\tgimplify_decl_expr, gimplify_var_or_parm_decl,\n\tgimplify_compound_lval, gimplify_init_constructor,\n\tgimplify_modify_expr, gimplify_asm_expr, gimplify_oacc_declare,\n\tgimplify_type_sizes): Likewise.\n\t* cgraphbuild.c (record_reference, record_type_list, mark_address,\n\tmark_load, mark_store, pass_build_cgraph_edges::execute): Likewise.\n\t* tree-ssa-live.c (mark_all_vars_used_1, remove_unused_scope_block_p,\n\tremove_unused_locals): Likewise.\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p, ptrs_compare_unequal,\n\tref_maybe_used_by_call_p_1, call_may_clobber_ref_p_1): Likewise.\n\t* function.c (instantiate_expr, instantiate_decls_1,\n\tsetjmp_vars_warning, add_local_decl): Likewise.\n\t* alias.c (ao_ref_from_mem, get_alias_set, compare_base_symbol_refs):\n\tLikewise.\n\t* tree-stdarg.c (find_va_list_reference, va_list_counter_struct_op,\n\tva_list_ptr_read, va_list_ptr_write, check_all_va_list_escapes,\n\toptimize_va_list_gpr_fpr_size): Likewise.\n\t* tree-nrv.c (pass_nrv::execute): Likewise.\n\t* tsan.c (instrument_expr): Likewise.\n\t* tree-ssa-dce.c (remove_dead_stmt): Likewise.\n\t* vtable-verify.c (verify_bb_vtables): Likewise.\n\t* tree-dfa.c (ssa_default_def, set_ssa_default_def,\n\tget_ref_base_and_extent): Likewise.\n\t* toplev.c (wrapup_global_declaration_1, wrapup_global_declaration_2):\n\tLikewise.\n\t* tree-sra.c (static bool constant_decl_p, find_var_candidates,\n\tanalyze_all_variable_accesses): Likewise.\n\t* tree-nested.c (get_nonlocal_debug_decl,\n\tconvert_nonlocal_omp_clauses, note_nonlocal_vla_type,\n\tnote_nonlocal_block_vlas, convert_nonlocal_reference_stmt,\n\tget_local_debug_decl, convert_local_omp_clauses,\n\tconvert_local_reference_stmt, nesting_copy_decl, remap_vla_decls):\n\tLikewise.\n\t* tree-vect-data-refs.c (vect_can_force_dr_alignment_p): Likewise.\n\t* stmt.c (decl_overlaps_hard_reg_set_p): Likewise.\n\t* dbxout.c (dbxout_late_global_decl, dbxout_type_fields,\n\tdbxout_symbol, dbxout_common_check): Likewise.\n\t* expr.c (expand_assignment, expand_expr_real_2, expand_expr_real_1,\n\tstring_constant): Likewise.\n\t* hsa.c (hsa_get_declaration_name): Likewise.\n\t* passes.c (rest_of_decl_compilation): Likewise.\n\t* tree-ssanames.c (make_ssa_name_fn): Likewise.\n\t* tree-streamer-out.c (pack_ts_decl_common_value_fields,\n\tpack_ts_decl_with_vis_value_fields,\n\twrite_ts_decl_common_tree_pointers): Likewise.\n\t* stor-layout.c (place_field): Likewise.\n\t* symtab.c (symtab_node::maybe_create_reference,\n\tsymtab_node::verify_base, symtab_node::make_decl_local,\n\tsymtab_node::copy_visibility_from,\n\tsymtab_node::can_increase_alignment_p): Likewise.\n\t* dwarf2out.c (add_var_loc_to_decl, tls_mem_loc_descriptor,\n\tdecl_by_reference_p, reference_to_unused, rtl_for_decl_location,\n\tfortran_common, add_location_or_const_value_attribute,\n\tadd_scalar_info, add_linkage_name, set_block_abstract_flags,\n\tlocal_function_static, gen_variable_die, dwarf2out_late_global_decl,\n\toptimize_one_addr_into_implicit_ptr,\n\toptimize_location_into_implicit_ptr): Likewise.\n\t* gimple-low.c (record_vars_into): Likewise.\n\t* ipa-visibility.c (update_vtable_references): Likewise.\n\t* tree-ssa-address.c (fixed_address_object_p, copy_ref_info):\n\tLikewise.\n\t* lto-streamer-out.c (tree_is_indexable, get_symbol_initial_value,\n\tDFS::DFS_write_tree_body, write_symbol): Likewise.\n\t* langhooks.c (lhd_warn_unused_global_decl,\n\tlhd_set_decl_assembler_name): Likewise.\n\t* attribs.c (decl_attributes): Likewise.\n\t* except.c (output_ttype): Likewise.\n\t* varpool.c (varpool_node::get_create, ctor_for_folding,\n\tvarpool_node::assemble_decl, varpool_node::create_alias): Likewise.\n\t* fold-const.c (fold_unary_loc): Likewise.\n\t* ipa-prop.c (ipa_compute_jump_functions_for_edge,\n\tipa_find_agg_cst_from_init): Likewise.\n\t* omp-low.c (expand_omp_regimplify_p, expand_omp_taskreg,\n\texpand_omp_target, lower_omp_regimplify_p,\n\tgrid_reg_assignment_to_local_var_p, grid_remap_prebody_decls,\n\tfind_link_var_op): Likewise.\n\t* tree-chrec.c (chrec_contains_symbols): Likewise.\n\t* tree-cfg.c (verify_address, verify_expr, verify_expr_location_1,\n\tgimple_duplicate_bb, move_stmt_op, replace_block_vars_by_duplicates,\n\texecute_fixup_cfg): Likewise.\n\nFrom-SVN: r240900", "tree": {"sha": "bb47c0f2b3de57441fea91a09bfa180b2faaa381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb47c0f2b3de57441fea91a09bfa180b2faaa381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8813a647b5f81fb32955f8ec2438d73e9e6280d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8813a647b5f81fb32955f8ec2438d73e9e6280d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8813a647b5f81fb32955f8ec2438d73e9e6280d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8813a647b5f81fb32955f8ec2438d73e9e6280d4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4dfb8a2a60a582b0a1cab65f34d706cf961c9d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dfb8a2a60a582b0a1cab65f34d706cf961c9d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dfb8a2a60a582b0a1cab65f34d706cf961c9d20"}], "stats": {"total": 852, "additions": 460, "deletions": 392}, "files": [{"sha": "efa0b76539eab281581f2c6bb914524e5e0d70e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1,5 +1,151 @@\n 2016-10-09  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* tree-ssa.c (target_for_debug_bind, verify_phi_args,\n+\tssa_undefined_value_p, maybe_optimize_var): Use VAR_P and/or\n+\tVAR_OR_FUNCTION_DECL_P macros.\n+\t* tree-chkp.c (chkp_register_var_initializer, chkp_make_static_bounds,\n+\tchkp_get_bounds_for_decl_addr, chkp_parse_array_and_component_ref,\n+\tchkp_find_bounds_1): Likewise.\n+\t* ipa-polymorphic-call.c (decl_maybe_in_construction_p): Likewise.\n+\t* hsa-gen.c (get_symbol_for_decl): Likewise.\n+\t* cgraphunit.c (check_global_declaration, analyze_functions,\n+\thandle_alias_pairs, thunk_adjust, cgraph_node::expand_thunk):\n+\tLikewise.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p,\n+\tcanonicalize_constructor_val, gimple_get_virt_method_for_vtable):\n+\tLikewise.\n+\t* tree.c (set_decl_section_name, copy_node_stat,\n+\tneed_assembler_name_p, free_lang_data_in_decl, find_decls_types_r,\n+\tmerge_dllimport_decl_attributes, handle_dll_attribute,\n+\tdecl_init_priority_insert, auto_var_in_fn_p, array_at_struct_end_p,\n+\tverify_type): Likewise.\n+\t* gimple-ssa-isolate-paths.c (find_implicit_erroneous_behavior,\n+\tfind_explicit_erroneous_behavior): Likewise.\n+\t* sdbout.c (sdbout_toplevel_data, sdbout_late_global_decl): Likewise.\n+\t* ipa.c (process_references): Likewise.\n+\t* tree-chkp-opt.c (chkp_get_check_result): Likewise.\n+\t* varasm.c (get_block_for_decl, use_blocks_for_decl_p, make_decl_rtl,\n+\tnotice_global_symbol, assemble_variable, mark_decl_referenced,\n+\tbuild_constant_desc, output_constant_def_contents, do_assemble_alias,\n+\tmake_decl_one_only, default_section_type_flags,\n+\tcategorize_decl_for_section, default_encode_section_info): Likewise.\n+\t* trans-mem.c (requires_barrier): Likewise.\n+\t* gimple-expr.c (mark_addressable): Likewise.\n+\t* cfgexpand.c (add_scope_conflicts_1, expand_one_var,\n+\texpand_used_vars_for_block, clear_tree_used, stack_protect_decl_p,\n+\texpand_debug_expr): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* ubsan.c (instrument_bool_enum_load): Likewise.\n+\t* tree-pretty-print.c (print_declaration): Likewise.\n+\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n+\t* tree-ssa-uninit.c (warn_uninitialized_vars): Likewise.\n+\t* asan.c (asan_protect_global, instrument_derefs): Likewise.\n+\t* tree-into-ssa.c (rewrite_stmt, maybe_register_def,\n+\tpass_build_ssa::execute): Likewise.\n+\t* var-tracking.c (var_debug_decl, track_expr_p): Likewise.\n+\t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost, split_address_cost):\n+\tLikewise.\n+\t* ipa-split.c (test_nonssa_use, consider_split, mark_nonssa_use):\n+\tLikewise.\n+\t* tree-inline.c (insert_debug_decl_map, remap_ssa_name,\n+\tcan_be_nonlocal, remap_decls, copy_debug_stmt,\n+\tinitialize_inlined_parameters, add_local_variables,\n+\treset_debug_binding, replace_locals_op): Likewise.\n+\t* dse.c (can_escape): Likewise.\n+\t* ipa-devirt.c (compare_virtual_tables, referenced_from_vtable_p):\n+\tLikewise.\n+\t* tree-diagnostic.c (default_tree_printer): Likewise.\n+\t* tree-streamer-in.c (unpack_ts_decl_common_value_fields,\n+\tunpack_ts_decl_with_vis_value_fields,\n+\tlto_input_ts_decl_common_tree_pointers): Likewise.\n+\t* builtins.c (builtin_save_expr, fold_builtin_expect,\n+\treadonly_data_expr): Likewise.\n+\t* tree-ssa-structalias.c (new_var_info, get_constraint_for_ssa_var,\n+\tcreate_variable_info_for, set_uids_in_ptset, visit_loadstore):\n+\tLikewise.\n+\t* gimple-streamer-out.c (output_gimple_stmt): Likewise.\n+\t* gimplify.c (force_constant_size, gimplify_bind_expr,\n+\tgimplify_decl_expr, gimplify_var_or_parm_decl,\n+\tgimplify_compound_lval, gimplify_init_constructor,\n+\tgimplify_modify_expr, gimplify_asm_expr, gimplify_oacc_declare,\n+\tgimplify_type_sizes): Likewise.\n+\t* cgraphbuild.c (record_reference, record_type_list, mark_address,\n+\tmark_load, mark_store, pass_build_cgraph_edges::execute): Likewise.\n+\t* tree-ssa-live.c (mark_all_vars_used_1, remove_unused_scope_block_p,\n+\tremove_unused_locals): Likewise.\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p, ptrs_compare_unequal,\n+\tref_maybe_used_by_call_p_1, call_may_clobber_ref_p_1): Likewise.\n+\t* function.c (instantiate_expr, instantiate_decls_1,\n+\tsetjmp_vars_warning, add_local_decl): Likewise.\n+\t* alias.c (ao_ref_from_mem, get_alias_set, compare_base_symbol_refs):\n+\tLikewise.\n+\t* tree-stdarg.c (find_va_list_reference, va_list_counter_struct_op,\n+\tva_list_ptr_read, va_list_ptr_write, check_all_va_list_escapes,\n+\toptimize_va_list_gpr_fpr_size): Likewise.\n+\t* tree-nrv.c (pass_nrv::execute): Likewise.\n+\t* tsan.c (instrument_expr): Likewise.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Likewise.\n+\t* vtable-verify.c (verify_bb_vtables): Likewise.\n+\t* tree-dfa.c (ssa_default_def, set_ssa_default_def,\n+\tget_ref_base_and_extent): Likewise.\n+\t* toplev.c (wrapup_global_declaration_1, wrapup_global_declaration_2):\n+\tLikewise.\n+\t* tree-sra.c (static bool constant_decl_p, find_var_candidates,\n+\tanalyze_all_variable_accesses): Likewise.\n+\t* tree-nested.c (get_nonlocal_debug_decl,\n+\tconvert_nonlocal_omp_clauses, note_nonlocal_vla_type,\n+\tnote_nonlocal_block_vlas, convert_nonlocal_reference_stmt,\n+\tget_local_debug_decl, convert_local_omp_clauses,\n+\tconvert_local_reference_stmt, nesting_copy_decl, remap_vla_decls):\n+\tLikewise.\n+\t* tree-vect-data-refs.c (vect_can_force_dr_alignment_p): Likewise.\n+\t* stmt.c (decl_overlaps_hard_reg_set_p): Likewise.\n+\t* dbxout.c (dbxout_late_global_decl, dbxout_type_fields,\n+\tdbxout_symbol, dbxout_common_check): Likewise.\n+\t* expr.c (expand_assignment, expand_expr_real_2, expand_expr_real_1,\n+\tstring_constant): Likewise.\n+\t* hsa.c (hsa_get_declaration_name): Likewise.\n+\t* passes.c (rest_of_decl_compilation): Likewise.\n+\t* tree-ssanames.c (make_ssa_name_fn): Likewise.\n+\t* tree-streamer-out.c (pack_ts_decl_common_value_fields,\n+\tpack_ts_decl_with_vis_value_fields,\n+\twrite_ts_decl_common_tree_pointers): Likewise.\n+\t* stor-layout.c (place_field): Likewise.\n+\t* symtab.c (symtab_node::maybe_create_reference,\n+\tsymtab_node::verify_base, symtab_node::make_decl_local,\n+\tsymtab_node::copy_visibility_from,\n+\tsymtab_node::can_increase_alignment_p): Likewise.\n+\t* dwarf2out.c (add_var_loc_to_decl, tls_mem_loc_descriptor,\n+\tdecl_by_reference_p, reference_to_unused, rtl_for_decl_location,\n+\tfortran_common, add_location_or_const_value_attribute,\n+\tadd_scalar_info, add_linkage_name, set_block_abstract_flags,\n+\tlocal_function_static, gen_variable_die, dwarf2out_late_global_decl,\n+\toptimize_one_addr_into_implicit_ptr,\n+\toptimize_location_into_implicit_ptr): Likewise.\n+\t* gimple-low.c (record_vars_into): Likewise.\n+\t* ipa-visibility.c (update_vtable_references): Likewise.\n+\t* tree-ssa-address.c (fixed_address_object_p, copy_ref_info):\n+\tLikewise.\n+\t* lto-streamer-out.c (tree_is_indexable, get_symbol_initial_value,\n+\tDFS::DFS_write_tree_body, write_symbol): Likewise.\n+\t* langhooks.c (lhd_warn_unused_global_decl,\n+\tlhd_set_decl_assembler_name): Likewise.\n+\t* attribs.c (decl_attributes): Likewise.\n+\t* except.c (output_ttype): Likewise.\n+\t* varpool.c (varpool_node::get_create, ctor_for_folding,\n+\tvarpool_node::assemble_decl, varpool_node::create_alias): Likewise.\n+\t* fold-const.c (fold_unary_loc): Likewise.\n+\t* ipa-prop.c (ipa_compute_jump_functions_for_edge,\n+\tipa_find_agg_cst_from_init): Likewise.\n+\t* omp-low.c (expand_omp_regimplify_p, expand_omp_taskreg,\n+\texpand_omp_target, lower_omp_regimplify_p,\n+\tgrid_reg_assignment_to_local_var_p, grid_remap_prebody_decls,\n+\tfind_link_var_op): Likewise.\n+\t* tree-chrec.c (chrec_contains_symbols): Likewise.\n+\t* tree-cfg.c (verify_address, verify_expr, verify_expr_location_1,\n+\tgimple_duplicate_bb, move_stmt_op, replace_block_vars_by_duplicates,\n+\texecute_fixup_cfg): Likewise.\n+\n \tPR tree-optimization/77901\n \t* tree-ssa-reassoc.c (optimize_range_tests_var_bound): Only optimize\n \tif ranges[i].exp is SSA_NAME when looking for >= and only when"}, {"sha": "19e9208ac976e86e4f085a4b39bb20b206d9ed24", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -310,7 +310,7 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n   /* If this is a reference based on a partitioned decl replace the\n      base with a MEM_REF of the pointer representative we\n      created during stack slot partitioning.  */\n-  if (TREE_CODE (base) == VAR_DECL\n+  if (VAR_P (base)\n       && ! is_global_var (base)\n       && cfun->gimple_df->decls_to_pointers != NULL)\n     {\n@@ -870,7 +870,7 @@ get_alias_set (tree t)\n       /* If we've already determined the alias set for a decl, just return\n \t it.  This is necessary for C++ anonymous unions, whose component\n \t variables don't look like union members (boo!).  */\n-      if (TREE_CODE (t) == VAR_DECL\n+      if (VAR_P (t)\n \t  && DECL_RTL_SET_P (t) && MEM_P (DECL_RTL (t)))\n \treturn MEM_ALIAS_SET (DECL_RTL (t));\n \n@@ -2087,7 +2087,7 @@ compare_base_symbol_refs (const_rtx x_base, const_rtx y_base)\n         return -1;\n       /* Anchors contains static VAR_DECLs and CONST_DECLs.  We are safe\n \t to ignore CONST_DECLs because they are readonly.  */\n-      if (TREE_CODE (x_decl) != VAR_DECL\n+      if (!VAR_P (x_decl)\n \t  || (!TREE_STATIC (x_decl) && !TREE_PUBLIC (x_decl)))\n \treturn 0;\n "}, {"sha": "3a4b5f708dcb40a552e690e869c2fd7d79c65c09", "filename": "gcc/asan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1351,7 +1351,7 @@ asan_protect_global (tree decl)\n \treturn false;\n       return true;\n     }\n-  if (TREE_CODE (decl) != VAR_DECL\n+  if (!VAR_P (decl)\n       /* TLS vars aren't statically protectable.  */\n       || DECL_THREAD_LOCAL_P (decl)\n       /* Externs will be protected elsewhere.  */\n@@ -1810,7 +1810,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n       || bitsize != size_in_bytes * BITS_PER_UNIT)\n     return;\n \n-  if (TREE_CODE (inner) == VAR_DECL\n+  if (VAR_P (inner)\n       && offset == NULL_TREE\n       && bitpos >= 0\n       && DECL_SIZE (inner)"}, {"sha": "e66349a13259bab69c8e339a614dde017c677752", "filename": "gcc/attribs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -553,7 +553,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n \n       /* Layout the decl in case anything changed.  */\n       if (spec->type_required && DECL_P (*node)\n-\t  && (TREE_CODE (*node) == VAR_DECL\n+\t  && (VAR_P (*node)\n \t      || TREE_CODE (*node) == PARM_DECL\n \t      || TREE_CODE (*node) == RESULT_DECL))\n \trelayout_decl (*node);"}, {"sha": "6c68198fcc5cf48423108e68cfda00cd9ec9250d", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -691,7 +691,7 @@ builtin_save_expr (tree exp)\n   if (TREE_CODE (exp) == SSA_NAME\n       || (TREE_ADDRESSABLE (exp) == 0\n \t  && (TREE_CODE (exp) == PARM_DECL\n-\t      || (TREE_CODE (exp) == VAR_DECL && !TREE_STATIC (exp)))))\n+\t      || (VAR_P (exp) && !TREE_STATIC (exp)))))\n     return exp;\n \n   return save_expr (exp);\n@@ -7141,9 +7141,7 @@ fold_builtin_expect (location_t loc, tree arg0, tree arg1, tree arg2)\n \t}\n       while (TREE_CODE (inner) == COMPONENT_REF\n \t     || TREE_CODE (inner) == ARRAY_REF);\n-      if ((TREE_CODE (inner) == VAR_DECL\n-           || TREE_CODE (inner) == FUNCTION_DECL)\n-\t  && DECL_WEAK (inner))\n+      if (VAR_OR_FUNCTION_DECL_P (inner) && DECL_WEAK (inner))\n \treturn NULL_TREE;\n     }\n \n@@ -8813,7 +8811,7 @@ readonly_data_expr (tree exp)\n      understand).  */\n   if (TREE_CODE (exp) == STRING_CST\n       || TREE_CODE (exp) == CONSTRUCTOR\n-      || (TREE_CODE (exp) == VAR_DECL && TREE_STATIC (exp)))\n+      || (VAR_P (exp) && TREE_STATIC (exp)))\n     return decl_readonly_section (exp, 0);\n   else\n     return false;"}, {"sha": "c7a2faa72006908221d1094c4d71f57e084bf147", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -576,7 +576,7 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \t  size_t *v;\n \t  /* Nested function lowering might introduce LHSs\n \t     that are COMPONENT_REFs.  */\n-\t  if (TREE_CODE (lhs) != VAR_DECL)\n+\t  if (!VAR_P (lhs))\n \t    continue;\n \t  if (DECL_RTL_IF_SET (lhs) == pc_rtx\n \t      && (v = decl_to_stack_part->get (lhs)))\n@@ -1571,7 +1571,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \n   var = SSAVAR (var);\n \n-  if (TREE_TYPE (var) != error_mark_node && TREE_CODE (var) == VAR_DECL)\n+  if (TREE_TYPE (var) != error_mark_node && VAR_P (var))\n     {\n       if (is_global_var (var))\n \treturn 0;\n@@ -1608,15 +1608,15 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \n   if (TREE_CODE (origvar) == SSA_NAME)\n     {\n-      gcc_assert (TREE_CODE (var) != VAR_DECL\n+      gcc_assert (!VAR_P (var)\n \t\t  || (!DECL_EXTERNAL (var)\n \t\t      && !DECL_HAS_VALUE_EXPR_P (var)\n \t\t      && !TREE_STATIC (var)\n \t\t      && TREE_TYPE (var) != error_mark_node\n \t\t      && !DECL_HARD_REGISTER (var)\n \t\t      && really_expand));\n     }\n-  if (TREE_CODE (var) != VAR_DECL && TREE_CODE (origvar) != SSA_NAME)\n+  if (!VAR_P (var) && TREE_CODE (origvar) != SSA_NAME)\n     ;\n   else if (DECL_EXTERNAL (var))\n     ;\n@@ -1631,7 +1631,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n       if (really_expand)\n         expand_one_error_var (var);\n     }\n-  else if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n+  else if (VAR_P (var) && DECL_HARD_REGISTER (var))\n     {\n       if (really_expand)\n \t{\n@@ -1689,7 +1689,7 @@ expand_used_vars_for_block (tree block, bool toplevel)\n   /* Expand all variables at this level.  */\n   for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n     if (TREE_USED (t)\n-        && ((TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != RESULT_DECL)\n+        && ((!VAR_P (t) && TREE_CODE (t) != RESULT_DECL)\n \t    || !DECL_NONSHAREABLE (t)))\n       expand_one_var (t, toplevel, true);\n \n@@ -1708,7 +1708,7 @@ clear_tree_used (tree block)\n \n   for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n     /* if (!TREE_STATIC (t) && !DECL_EXTERNAL (t)) */\n-    if ((TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != RESULT_DECL)\n+    if ((!VAR_P (t) && TREE_CODE (t) != RESULT_DECL)\n \t|| !DECL_NONSHAREABLE (t))\n       TREE_USED (t) = 0;\n \n@@ -1984,7 +1984,7 @@ stack_protect_decl_p ()\n     if (!is_global_var (var))\n       {\n \ttree var_type = TREE_TYPE (var);\n-\tif (TREE_CODE (var) == VAR_DECL\n+\tif (VAR_P (var)\n \t    && (TREE_CODE (var_type) == ARRAY_TYPE\n \t\t|| TREE_ADDRESSABLE (var)\n \t\t|| (RECORD_OR_UNION_TYPE_P (var_type)\n@@ -4275,7 +4275,7 @@ expand_debug_expr (tree exp)\n       /* This decl was probably optimized away.  */\n       if (!op0)\n \t{\n-\t  if (TREE_CODE (exp) != VAR_DECL\n+\t  if (!VAR_P (exp)\n \t      || DECL_EXTERNAL (exp)\n \t      || !TREE_STATIC (exp)\n \t      || !DECL_NAME (exp)\n@@ -4876,7 +4876,7 @@ expand_debug_expr (tree exp)\n \t      tree decl\n \t\t= get_ref_base_and_extent (TREE_OPERAND (exp, 0), &bitoffset,\n \t\t\t\t\t   &bitsize, &maxsize, &reverse);\n-\t      if ((TREE_CODE (decl) == VAR_DECL\n+\t      if ((VAR_P (decl)\n \t\t   || TREE_CODE (decl) == PARM_DECL\n \t\t   || TREE_CODE (decl) == RESULT_DECL)\n \t\t  && (!TREE_ADDRESSABLE (decl)"}, {"sha": "4df5fe0ce4d3cc2ae908c023f2b15dae97046348", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -77,7 +77,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  ctx->varpool_node->create_reference (node, IPA_REF_ADDR);\n \t}\n \n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \t{\n \t  varpool_node *vnode = varpool_node::get_create (decl);\n \t  ctx->varpool_node->create_reference (vnode, IPA_REF_ADDR);\n@@ -114,7 +114,7 @@ record_type_list (cgraph_node *node, tree list)\n       if (TREE_CODE (type) == ADDR_EXPR)\n \t{\n \t  type = TREE_OPERAND (type, 0);\n-\t  if (TREE_CODE (type) == VAR_DECL)\n+\t  if (VAR_P (type))\n \t    {\n \t      varpool_node *vnode = varpool_node::get_create (type);\n \t      node->create_reference (vnode, IPA_REF_ADDR);\n@@ -219,7 +219,7 @@ mark_address (gimple *stmt, tree addr, tree, void *data)\n       node->mark_address_taken ();\n       ((symtab_node *)data)->create_reference (node, IPA_REF_ADDR, stmt);\n     }\n-  else if (addr && TREE_CODE (addr) == VAR_DECL\n+  else if (addr && VAR_P (addr)\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n       varpool_node *vnode = varpool_node::get_create (addr);\n@@ -244,8 +244,7 @@ mark_load (gimple *stmt, tree t, tree, void *data)\n       node->mark_address_taken ();\n       ((symtab_node *)data)->create_reference (node, IPA_REF_ADDR, stmt);\n     }\n-  else if (t && TREE_CODE (t) == VAR_DECL\n-\t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n+  else if (t && VAR_P (t) && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       varpool_node *vnode = varpool_node::get_create (t);\n \n@@ -260,8 +259,7 @@ static bool\n mark_store (gimple *stmt, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n-  if (t && TREE_CODE (t) == VAR_DECL\n-      && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n+  if (t && VAR_P (t) && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       varpool_node *vnode = varpool_node::get_create (t);\n \n@@ -369,7 +367,7 @@ pass_build_cgraph_edges::execute (function *fun)\n \n   /* Look for initializers of constant variables and private statics.  */\n   FOR_EACH_LOCAL_DECL (fun, ix, decl)\n-    if (TREE_CODE (decl) == VAR_DECL\n+    if (VAR_P (decl)\n \t&& (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n \t&& !DECL_HAS_VALUE_EXPR_P (decl)\n \t&& TREE_TYPE (decl) != error_mark_node)"}, {"sha": "abcb35dea63b70656908310add499a3a2f111857", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -662,7 +662,7 @@ symbol_table::process_same_body_aliases (void)\n   FOR_EACH_SYMBOL (node)\n     if (node->cpp_implicit_alias && !node->analyzed)\n       node->resolve_alias\n-\t(TREE_CODE (node->alias_target) == VAR_DECL\n+\t(VAR_P (node->alias_target)\n \t ? (symtab_node *)varpool_node::get_create (node->alias_target)\n \t : (symtab_node *)cgraph_node::get_create (node->alias_target));\n   cpp_implicit_aliases_done = true;\n@@ -950,7 +950,7 @@ check_global_declaration (symtab_node *snode)\n \t\t\t&& (decl_file = DECL_SOURCE_FILE (decl)) != NULL\n \t\t\t&& filename_cmp (main_input_filename,\n \t\t\t\t\t decl_file) == 0))))\n-\t   && TREE_CODE (decl) == VAR_DECL))\n+\t   && VAR_P (decl)))\n       && ! DECL_IN_SYSTEM_HEADER (decl)\n       && ! snode->referred_to_p (/*include_self=*/false)\n       /* This TREE_USED check is needed in addition to referred_to_p\n@@ -967,7 +967,7 @@ check_global_declaration (symtab_node *snode)\n       /* A volatile variable might be used in some non-obvious way.  */\n       && (! VAR_P (decl) || ! TREE_THIS_VOLATILE (decl))\n       /* Global register variables must be declared to reserve them.  */\n-      && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n+      && ! (VAR_P (decl) && DECL_REGISTER (decl))\n       /* Global ctors and dtors are called by the runtime.  */\n       && (TREE_CODE (decl) != FUNCTION_DECL\n \t  || (!DECL_STATIC_CONSTRUCTOR (decl)\n@@ -1194,7 +1194,7 @@ analyze_functions (bool first_time)\n \t     at looking at optimized away DECLs, since\n \t     late_global_decl will subsequently be called from the\n \t     contents of the now pruned symbol table.  */\n-\t  if (TREE_CODE (node->decl) == VAR_DECL\n+\t  if (VAR_P (node->decl)\n \t      && !decl_function_context (node->decl))\n \t    {\n \t      /* We are reclaiming totally unreachable code and variables\n@@ -1305,7 +1305,7 @@ handle_alias_pairs (void)\n \t  cgraph_node::create_alias (p->decl, target_node->decl);\n \t  alias_pairs->unordered_remove (i);\n \t}\n-      else if (TREE_CODE (p->decl) == VAR_DECL\n+      else if (VAR_P (p->decl)\n \t       && target_node && is_a <varpool_node *> (target_node))\n \t{\n \t  varpool_node::create_alias (p->decl, target_node->decl);\n@@ -1559,7 +1559,7 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n     {\n       tree ptrtmp;\n \n-      if (TREE_CODE (ptr) == VAR_DECL)\n+      if (VAR_P (ptr))\n         ptrtmp = ptr;\n       else\n         {\n@@ -1738,7 +1738,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t{\n \t\t  restmp = resdecl;\n \n-\t\t  if (TREE_CODE (restmp) == VAR_DECL)\n+\t\t  if (VAR_P (restmp))\n \t\t    add_local_decl (cfun, restmp);\n \t\t  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;\n \t\t}"}, {"sha": "52307f3cd3e3613ba87928a59b4a80323ce1e19a", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1333,7 +1333,7 @@ dbxout_early_global_decl (tree decl ATTRIBUTE_UNUSED)\n static void\n dbxout_late_global_decl (tree decl)\n {\n-  if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+  if (VAR_P (decl) && !DECL_EXTERNAL (decl))\n     {\n       int saved_tree_used = TREE_USED (decl);\n       TREE_USED (decl) = 1;\n@@ -1511,7 +1511,7 @@ dbxout_type_fields (tree type)\n \t\t\t&& DECL_BIT_FIELD_TYPE (tem))\n \t\t       ? DECL_BIT_FIELD_TYPE (tem) : TREE_TYPE (tem), 0);\n \n-\t  if (TREE_CODE (tem) == VAR_DECL)\n+\t  if (VAR_P (tem))\n \t    {\n \t      if (TREE_STATIC (tem) && use_gnu_debug_info_extensions)\n \t\t{\n@@ -2610,7 +2610,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \n   if (flag_debug_only_used_symbols\n       && (!TREE_USED (decl)\n-          && (TREE_CODE (decl) != VAR_DECL || !DECL_INITIAL (decl))))\n+          && (!VAR_P (decl) || !DECL_INITIAL (decl))))\n     DBXOUT_DECR_NESTING_AND_RETURN (0);\n \n   /* If dbxout_init has not yet run, queue this symbol for later.  */\n@@ -2865,7 +2865,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n       /* PARM_DECLs go in their own separate chain and are output by\n \t dbxout_reg_parms and dbxout_parms, except for those that are\n \t disguised VAR_DECLs like Out parameters in Ada.  */\n-      gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+      gcc_assert (VAR_P (decl));\n \n       /* fall through */\n \n@@ -3272,7 +3272,7 @@ dbxout_common_check (tree decl, int *value)\n      ??? DECL_THREAD_LOCAL_P check prevents problems with improper .stabs\n      for thread-local symbols.  Can be handled via same mechanism as used\n      in dwarf2out.c.  */\n-  if (TREE_CODE (decl) != VAR_DECL\n+  if (!VAR_P (decl)\n       || !TREE_STATIC (decl)\n       || !DECL_HAS_VALUE_EXPR_P (decl)\n       || DECL_THREAD_LOCAL_P (decl)"}, {"sha": "9d222a947a18249b58b13705b95b6db72f76d0c0", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -911,7 +911,7 @@ can_escape (tree expr)\n   base = get_base_address (expr);\n   if (DECL_P (base)\n       && !may_be_aliased (base)\n-      && !(TREE_CODE (base) == VAR_DECL\n+      && !(VAR_P (base)\n \t   && !DECL_EXTERNAL (base)\n \t   && !TREE_STATIC (base)\n \t   && local_variable_can_escape (base)))"}, {"sha": "4a3df339df2c6a6816ac8b8dbdb2466a7492c592", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -5359,8 +5359,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n   struct var_loc_node *loc = NULL;\n   HOST_WIDE_INT bitsize = -1, bitpos = -1;\n \n-  if (TREE_CODE (decl) == VAR_DECL\n-      && DECL_HAS_DEBUG_EXPR_P (decl))\n+  if (VAR_P (decl) && DECL_HAS_DEBUG_EXPR_P (decl))\n     {\n       tree realdecl = DECL_DEBUG_EXPR (decl);\n       if (handled_component_p (realdecl)\n@@ -12385,7 +12384,7 @@ tls_mem_loc_descriptor (rtx mem)\n \n   base = get_base_address (MEM_EXPR (mem));\n   if (base == NULL\n-      || TREE_CODE (base) != VAR_DECL\n+      || !VAR_P (base)\n       || !DECL_THREAD_LOCAL_P (base))\n     return NULL;\n \n@@ -14632,7 +14631,7 @@ static bool\n decl_by_reference_p (tree decl)\n {\n   return ((TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL\n-  \t   || TREE_CODE (decl) == VAR_DECL)\n+  \t   || VAR_P (decl))\n \t  && DECL_BY_REFERENCE (decl));\n }\n \n@@ -17261,10 +17260,9 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n   /* ???  The C++ FE emits debug information for using decls, so\n      putting gcc_unreachable here falls over.  See PR31899.  For now\n      be conservative.  */\n-  else if (!symtab->global_info_ready\n-\t   && (TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == FUNCTION_DECL))\n+  else if (!symtab->global_info_ready && VAR_OR_FUNCTION_DECL_P (*tp))\n     return *tp;\n-  else if (TREE_CODE (*tp) == VAR_DECL)\n+  else if (VAR_P (*tp))\n     {\n       varpool_node *node = varpool_node::get (*tp);\n       if (!node || !node->definition)\n@@ -17472,7 +17470,7 @@ rtl_for_decl_location (tree decl)\n \t      || (MEM_P (rtl)\n \t          && CONSTANT_P (XEXP (rtl, 0)))\n \t      || (REG_P (rtl)\n-\t          && TREE_CODE (decl) == VAR_DECL\n+\t          && VAR_P (decl)\n \t\t  && TREE_STATIC (decl))))\n \t{\n \t  rtl = targetm.delegitimize_address (rtl);\n@@ -17554,7 +17552,7 @@ rtl_for_decl_location (tree decl)\n \t\t\t     plus_constant (addr_mode, XEXP (rtl, 0), offset));\n \t}\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL\n+  else if (VAR_P (decl)\n \t   && rtl\n \t   && MEM_P (rtl)\n \t   && GET_MODE (rtl) != TYPE_MODE (TREE_TYPE (decl))\n@@ -17579,7 +17577,7 @@ rtl_for_decl_location (tree decl)\n   /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,\n      and will have been substituted directly into all expressions that use it.\n      C does not have such a concept, but C++ and other languages do.  */\n-  if (!rtl && TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n+  if (!rtl && VAR_P (decl) && DECL_INITIAL (decl))\n     rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));\n \n   if (rtl)\n@@ -17595,7 +17593,7 @@ rtl_for_decl_location (tree decl)\n      in the current CU, resolve_addr will remove the expression referencing\n      it.  */\n   if (rtl == NULL_RTX\n-      && TREE_CODE (decl) == VAR_DECL\n+      && VAR_P (decl)\n       && !DECL_EXTERNAL (decl)\n       && TREE_STATIC (decl)\n       && DECL_NAME (decl)\n@@ -17629,7 +17627,7 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n      it does not have a value (the offset into the common area), or if it\n      is thread local (as opposed to global) then it isn't common, and shouldn't\n      be handled as such.  */\n-  if (TREE_CODE (decl) != VAR_DECL\n+  if (!VAR_P (decl)\n       || !TREE_STATIC (decl)\n       || !DECL_HAS_VALUE_EXPR_P (decl)\n       || !is_fortran ())\n@@ -17643,7 +17641,7 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n \t\t\t      &unsignedp, &reversep, &volatilep);\n \n   if (cvar == NULL_TREE\n-      || TREE_CODE (cvar) != VAR_DECL\n+      || !VAR_P (cvar)\n       || DECL_ARTIFICIAL (cvar)\n       || !TREE_PUBLIC (cvar))\n     return NULL_TREE;\n@@ -17695,7 +17693,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p)\n       || get_AT (die, DW_AT_const_value))\n     return true;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL\n+  gcc_assert (VAR_P (decl) || TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n \n   /* Try to get some constant RTL for this decl, and use that as the value of\n@@ -17958,10 +17956,8 @@ tree_add_const_value_attribute_for_decl (dw_die_ref var_die, tree decl)\n {\n \n   if (!decl\n-      || (TREE_CODE (decl) != VAR_DECL\n-\t  && TREE_CODE (decl) != CONST_DECL)\n-      || (TREE_CODE (decl) == VAR_DECL\n-\t  && !TREE_STATIC (decl)))\n+      || (!VAR_P (decl) && TREE_CODE (decl) != CONST_DECL)\n+      || (VAR_P (decl) && !TREE_STATIC (decl)))\n     return false;\n \n   if (TREE_READONLY (decl)\n@@ -18303,7 +18299,7 @@ add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n \t  && TREE_CODE (TREE_OPERAND (value, 1)) == FIELD_DECL)\n \tdecl = TREE_OPERAND (value, 1);\n \n-      else if (TREE_CODE (value) == VAR_DECL\n+      else if (VAR_P (value)\n \t       || TREE_CODE (value) == PARM_DECL\n \t       || TREE_CODE (value) == RESULT_DECL)\n \tdecl = value;\n@@ -18839,9 +18835,9 @@ static void\n add_linkage_name (dw_die_ref die, tree decl)\n {\n   if (debug_info_level > DINFO_LEVEL_NONE\n-      && (TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n+      && VAR_OR_FUNCTION_DECL_P (decl)\n       && TREE_PUBLIC (decl)\n-      && !(TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n+      && !(VAR_P (decl) && DECL_REGISTER (decl))\n       && die->die_tag != DW_TAG_member)\n     add_linkage_name_raw (die, decl);\n }\n@@ -20121,7 +20117,7 @@ set_block_abstract_flags (tree stmt, vec<tree> &abstract_vec)\n   for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n     {\n       local_decl = BLOCK_NONLOCALIZED_VAR (stmt, i);\n-      if ((TREE_CODE (local_decl) == VAR_DECL && !TREE_STATIC (local_decl))\n+      if ((VAR_P (local_decl) && !TREE_STATIC (local_decl))\n \t  || TREE_CODE (local_decl) == PARM_DECL)\n \tset_decl_abstract_flags (local_decl, abstract_vec);\n     }\n@@ -21205,7 +21201,7 @@ decl_will_get_specification_p (dw_die_ref old_die, tree decl, bool declaration)\n static inline bool\n local_function_static (tree decl)\n {\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n   return TREE_STATIC (decl)\n     && DECL_CONTEXT (decl)\n     && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL;\n@@ -21456,7 +21452,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t  /* Local static vars are shared between all clones/inlines,\n \t     so emit DW_AT_location on the abstract DIE if DECL_RTL is\n \t     already set.  */\n-\t  || (TREE_CODE (decl_or_origin) == VAR_DECL\n+\t  || (VAR_P (decl_or_origin)\n \t      && TREE_STATIC (decl_or_origin)\n \t      && DECL_RTL_SET_P (decl_or_origin)))\n       /* When abstract origin already has DW_AT_location attribute, no need\n@@ -23889,8 +23885,7 @@ dwarf2out_late_global_decl (tree decl)\n {\n   /* Fill-in any location information we were unable to determine\n      on the first pass.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && !POINTER_BOUNDS_P (decl))\n+  if (VAR_P (decl) && !POINTER_BOUNDS_P (decl))\n     {\n       dw_die_ref die = lookup_decl_die (decl);\n \n@@ -26649,7 +26644,7 @@ optimize_one_addr_into_implicit_ptr (dw_loc_descr_ref loc)\n   if (GET_CODE (rtl) == SYMBOL_REF && SYMBOL_REF_DECL (rtl))\n     {\n       decl = SYMBOL_REF_DECL (rtl);\n-      if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+      if (VAR_P (decl) && !DECL_EXTERNAL (decl))\n \t{\n \t  ref = lookup_decl_die (decl);\n \t  if (ref && (get_AT (ref, DW_AT_location)\n@@ -26811,7 +26806,7 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n static void\n optimize_location_into_implicit_ptr (dw_die_ref die, tree decl)\n {\n-  if (TREE_CODE (decl) != VAR_DECL\n+  if (!VAR_P (decl)\n       || lookup_decl_die (decl) != die\n       || DECL_EXTERNAL (decl)\n       || !TREE_STATIC (decl)"}, {"sha": "800ca2a27bad30e7b0d9ea1f1f2894ae0e1c8251", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -2898,7 +2898,7 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n       if (TREE_CODE (type) == ADDR_EXPR)\n \t{\n \t  type = TREE_OPERAND (type, 0);\n-\t  if (TREE_CODE (type) == VAR_DECL)\n+\t  if (VAR_P (type))\n \t    is_public = TREE_PUBLIC (type);\n \t}\n       else"}, {"sha": "e6d110dd027bd3e8ee9eb8d7f0bda8a6ad2cfe04", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -5186,7 +5186,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)\n       && COMPLETE_TYPE_P (TREE_TYPE (from))\n       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST\n-      && ! (((TREE_CODE (to) == VAR_DECL\n+      && ! (((VAR_P (to)\n \t      || TREE_CODE (to) == PARM_DECL\n \t      || TREE_CODE (to) == RESULT_DECL)\n \t     && REG_P (DECL_RTL (to)))\n@@ -8421,7 +8421,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \n       if (TREE_CODE (treeop0) == PLUS_EXPR\n \t  && TREE_CODE (TREE_OPERAND (treeop0, 1)) == INTEGER_CST\n-\t  && TREE_CODE (treeop1) == VAR_DECL\n+\t  && VAR_P (treeop1)\n \t  && (DECL_RTL (treeop1) == frame_pointer_rtx\n \t      || DECL_RTL (treeop1) == stack_pointer_rtx\n \t      || DECL_RTL (treeop1) == arg_pointer_rtx))\n@@ -10201,8 +10201,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t && modifier != EXPAND_MEMORY\n \t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n \t\t && TREE_CODE (index) == INTEGER_CST\n-\t\t && (TREE_CODE (array) == VAR_DECL\n-\t\t     || TREE_CODE (array) == CONST_DECL)\n+\t\t && (VAR_P (array) || TREE_CODE (array) == CONST_DECL)\n \t\t && (init = ctor_for_folding (array)) != error_mark_node)\n \t  {\n \t    if (init == NULL_TREE)\n@@ -11112,8 +11111,7 @@ string_constant (tree arg, tree *ptr_offset)\n \t{\n \t  array = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t  offset = TREE_OPERAND (TREE_OPERAND (arg, 0), 1);\n-\t  if (TREE_CODE (array) != STRING_CST\n-\t      && TREE_CODE (array) != VAR_DECL)\n+\t  if (TREE_CODE (array) != STRING_CST && !VAR_P (array))\n \t    return 0;\n \n \t  /* Check if the array has a nonzero lower bound.  */\n@@ -11137,8 +11135,7 @@ string_constant (tree arg, tree *ptr_offset)\n \t  if (TREE_CODE (array) != ADDR_EXPR)\n \t    return 0;\n \t  array = TREE_OPERAND (array, 0);\n-\t  if (TREE_CODE (array) != STRING_CST\n-\t      && TREE_CODE (array) != VAR_DECL)\n+\t  if (TREE_CODE (array) != STRING_CST && !VAR_P (array))\n \t    return 0;\n \t}\n       else\n@@ -11177,8 +11174,7 @@ string_constant (tree arg, tree *ptr_offset)\n       *ptr_offset = fold_convert (sizetype, offset);\n       return array;\n     }\n-  else if (TREE_CODE (array) == VAR_DECL\n-\t   || TREE_CODE (array) == CONST_DECL)\n+  else if (VAR_P (array) || TREE_CODE (array) == CONST_DECL)\n     {\n       int length;\n       tree init = ctor_for_folding (array);"}, {"sha": "02aa484a72745360d1308f864c31b0a6d57b4f9b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -7942,7 +7942,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n       if (TREE_CODE (op0) == ADDR_EXPR)\n \t{\n \t  tree op00 = TREE_OPERAND (op0, 0);\n-\t  if ((TREE_CODE (op00) == VAR_DECL\n+\t  if ((VAR_P (op00)\n \t       || TREE_CODE (op00) == PARM_DECL\n \t       || TREE_CODE (op00) == RESULT_DECL)\n \t      && !TREE_READONLY (op00))"}, {"sha": "cdd2721cdf904be6457d090fe20345d3dee0b4dd", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1826,8 +1826,7 @@ instantiate_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t  if (TREE_CODE (t) == PARM_DECL && DECL_NAMELESS (t)\n \t      && DECL_INCOMING_RTL (t))\n \t    instantiate_decl_rtl (DECL_INCOMING_RTL (t));\n-\t  if ((TREE_CODE (t) == VAR_DECL\n-\t       || TREE_CODE (t) == RESULT_DECL)\n+\t  if ((VAR_P (t) || TREE_CODE (t) == RESULT_DECL)\n \t      && DECL_HAS_VALUE_EXPR_P (t))\n \t    {\n \t      tree v = DECL_VALUE_EXPR (t);\n@@ -1850,7 +1849,7 @@ instantiate_decls_1 (tree let)\n     {\n       if (DECL_RTL_SET_P (t))\n \tinstantiate_decl_rtl (DECL_RTL (t));\n-      if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n+      if (VAR_P (t) && DECL_HAS_VALUE_EXPR_P (t))\n \t{\n \t  tree v = DECL_VALUE_EXPR (t);\n \t  walk_tree (&v, instantiate_expr, NULL, NULL);\n@@ -4374,7 +4373,7 @@ setjmp_vars_warning (bitmap setjmp_crosses, tree block)\n \n   for (decl = BLOCK_VARS (block); decl; decl = DECL_CHAIN (decl))\n     {\n-      if (TREE_CODE (decl) == VAR_DECL\n+      if (VAR_P (decl)\n \t  && DECL_RTL_SET_P (decl)\n \t  && REG_P (DECL_RTL (decl))\n \t  && regno_clobbered_at_setjmp (setjmp_crosses, REGNO (DECL_RTL (decl))))\n@@ -6581,7 +6580,7 @@ match_asm_constraints_1 (rtx_insn *insn, rtx *p_sets, int noutputs)\n void\n add_local_decl (struct function *fun, tree d)\n {\n-  gcc_assert (TREE_CODE (d) == VAR_DECL);\n+  gcc_assert (VAR_P (d));\n   vec_safe_push (fun->local_decls, d);\n }\n "}, {"sha": "de5cce1f7cca15d3b240c362cd21652b85405758", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -888,7 +888,7 @@ mark_addressable (tree x)\n   if (TREE_CODE (x) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (x, 0)) == ADDR_EXPR)\n     x = TREE_OPERAND (TREE_OPERAND (x, 0), 0);\n-  if (TREE_CODE (x) != VAR_DECL\n+  if (!VAR_P (x)\n       && TREE_CODE (x) != PARM_DECL\n       && TREE_CODE (x) != RESULT_DECL)\n     return;"}, {"sha": "3aaa09c0bef6906a81b20f8a3005b393cc4c7feb", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -105,7 +105,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n \n   /* We are concerned only about static/external vars and functions.  */\n   if ((!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n-      || (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL))\n+      || !VAR_OR_FUNCTION_DECL_P (decl))\n     return true;\n \n   /* Static objects can be referred only if they was not optimized out yet.  */\n@@ -126,7 +126,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n      So we are concerned only when DECL comes from initializer of\n      external var or var that has been optimized out.  */\n   if (!from_decl\n-      || TREE_CODE (from_decl) != VAR_DECL\n+      || !VAR_P (from_decl)\n       || (!DECL_EXTERNAL (from_decl)\n \t  && (vnode = varpool_node::get (from_decl)) != NULL\n \t  && vnode->definition)\n@@ -206,13 +206,12 @@ canonicalize_constructor_val (tree cval, tree from_decl)\n       if (!base)\n \treturn NULL_TREE;\n \n-      if ((TREE_CODE (base) == VAR_DECL\n-\t   || TREE_CODE (base) == FUNCTION_DECL)\n+      if (VAR_OR_FUNCTION_DECL_P (base)\n \t  && !can_refer_decl_in_current_unit_p (base, from_decl))\n \treturn NULL_TREE;\n       if (TREE_TYPE (base) == error_mark_node)\n \treturn NULL_TREE;\n-      if (TREE_CODE (base) == VAR_DECL)\n+      if (VAR_P (base))\n \tTREE_ADDRESSABLE (base) = 1;\n       else if (TREE_CODE (base) == FUNCTION_DECL)\n \t{\n@@ -6057,8 +6056,7 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n     *can_refer = true;\n \n   /* First of all double check we have virtual table.  */\n-  if (TREE_CODE (v) != VAR_DECL\n-      || !DECL_VIRTUAL_P (v))\n+  if (!VAR_P (v) || !DECL_VIRTUAL_P (v))\n     {\n       /* Pass down that we lost track of the target.  */\n       if (can_refer)"}, {"sha": "8e98762e6fd27cec9fc6a7e76e2f566bba43905c", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -885,7 +885,7 @@ record_vars_into (tree vars, tree fn)\n \n       /* BIND_EXPRs contains also function/type/constant declarations\n          we don't need to care about.  */\n-      if (TREE_CODE (var) != VAR_DECL)\n+      if (!VAR_P (var))\n \tcontinue;\n \n       /* Nothing to do in this case.  */"}, {"sha": "9d2fc8a30c0de4759da7bf990262fc7f9a553cac", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -268,8 +268,7 @@ find_implicit_erroneous_behavior (void)\n \t      if (TREE_CODE (op) == ADDR_EXPR)\n \t\t{\n \t\t  tree valbase = get_base_address (TREE_OPERAND (op, 0));\n-\t\t  if ((TREE_CODE (valbase) == VAR_DECL\n-\t\t       && !is_global_var (valbase))\n+\t\t  if ((VAR_P (valbase) && !is_global_var (valbase))\n \t\t      || TREE_CODE (valbase) == PARM_DECL)\n \t\t    {\n \t\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n@@ -426,8 +425,7 @@ find_explicit_erroneous_behavior (void)\n \t      if (val && TREE_CODE (val) == ADDR_EXPR)\n \t\t{\n \t\t  tree valbase = get_base_address (TREE_OPERAND (val, 0));\n-\t\t  if ((TREE_CODE (valbase) == VAR_DECL\n-\t\t       && !is_global_var (valbase))\n+\t\t  if ((VAR_P (valbase) && !is_global_var (valbase))\n \t\t      || TREE_CODE (valbase) == PARM_DECL)\n \t\t    {\n \t\t      /* We only need it for this particular case.  */"}, {"sha": "5441f69ca1559eb5a1c8a417936432d6fde2d12d", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -145,7 +145,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)\n \t\tbasep = &TREE_OPERAND (*basep, 0);\n \t      while (handled_component_p (*basep))\n \t\tbasep = &TREE_OPERAND (*basep, 0);\n-\t      if (TREE_CODE (*basep) == VAR_DECL\n+\t      if (VAR_P (*basep)\n \t\t  && !auto_var_in_fn_p (*basep, current_function_decl)\n \t\t  && !DECL_REGISTER (*basep))\n \t\t{"}, {"sha": "0b1a0beccf5225fcd71609acfe0df9ba9027ed41", "filename": "gcc/gimplify.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -665,7 +665,7 @@ force_constant_size (tree var)\n \n   HOST_WIDE_INT max_size;\n \n-  gcc_assert (TREE_CODE (var) == VAR_DECL);\n+  gcc_assert (VAR_P (var));\n \n   max_size = max_int_size_in_bytes (TREE_TYPE (var));\n \n@@ -1108,7 +1108,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   /* Mark variables seen in this bind expr.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = DECL_CHAIN (t))\n     {\n-      if (TREE_CODE (t) == VAR_DECL)\n+      if (VAR_P (t))\n \t{\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n \n@@ -1138,7 +1138,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n       if ((TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n \t   || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n \t  && !TREE_THIS_VOLATILE (t)\n-\t  && (TREE_CODE (t) == VAR_DECL && !DECL_HARD_REGISTER (t))\n+\t  && (VAR_P (t) && !DECL_HARD_REGISTER (t))\n \t  && !needs_to_live_in_memory (t))\n \tDECL_GIMPLE_REG_P (t) = 1;\n     }\n@@ -1190,7 +1190,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   /* Add clobbers for all variables that go out of scope.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = DECL_CHAIN (t))\n     {\n-      if (TREE_CODE (t) == VAR_DECL\n+      if (VAR_P (t)\n \t  && !is_global_var (t)\n \t  && DECL_CONTEXT (t) == current_function_decl\n \t  && !DECL_HARD_REGISTER (t)\n@@ -1450,7 +1450,7 @@ gimplify_decl_expr (tree *stmt_p, gimple_seq *seq_p)\n     return GS_ERROR;\n \n   if ((TREE_CODE (decl) == TYPE_DECL\n-       || TREE_CODE (decl) == VAR_DECL)\n+       || VAR_P (decl))\n       && !TYPE_SIZES_GIMPLIFIED (TREE_TYPE (decl)))\n     {\n       gimplify_type_sizes (TREE_TYPE (decl), seq_p);\n@@ -1469,7 +1469,7 @@ gimplify_decl_expr (tree *stmt_p, gimple_seq *seq_p)\n \tgimplify_type_sizes (TREE_TYPE (DECL_ORIGINAL_TYPE (decl)), seq_p);\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+  if (VAR_P (decl) && !DECL_EXTERNAL (decl))\n     {\n       tree init = DECL_INITIAL (decl);\n \n@@ -2378,7 +2378,7 @@ gimplify_var_or_parm_decl (tree *expr_p)\n      be really nice if the front end wouldn't leak these at all.\n      Currently the only known culprit is C++ destructors, as seen\n      in g++.old-deja/g++.jason/binding.C.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && !DECL_SEEN_IN_BIND_EXPR_P (decl)\n       && !TREE_STATIC (decl) && !DECL_EXTERNAL (decl)\n       && decl_function_context (decl) == current_function_decl)\n@@ -2398,7 +2398,7 @@ gimplify_var_or_parm_decl (tree *expr_p)\n \n       /* For referenced nonlocal VLAs add a decl for debugging purposes\n \t to the current function.  */\n-      if (TREE_CODE (decl) == VAR_DECL\n+      if (VAR_P (decl)\n \t  && TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST\n \t  && nonlocal_vlas != NULL\n \t  && TREE_CODE (value_expr) == INDIRECT_REF\n@@ -2533,7 +2533,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t;\n       /* Expand DECL_VALUE_EXPR now.  In some cases that may expose\n \t additional COMPONENT_REFs.  */\n-      else if ((TREE_CODE (*p) == VAR_DECL || TREE_CODE (*p) == PARM_DECL)\n+      else if ((VAR_P (*p) || TREE_CODE (*p) == PARM_DECL)\n \t       && gimplify_var_or_parm_decl (p) == GS_OK)\n \tgoto restart;\n       else\n@@ -4447,7 +4447,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tif (valid_const_initializer\n \t    && num_nonzero_elements > 1\n \t    && TREE_READONLY (object)\n-\t    && TREE_CODE (object) == VAR_DECL\n+\t    && VAR_P (object)\n \t    && (flag_merge_constants >= 2 || !TREE_ADDRESSABLE (object)))\n \t  {\n \t    if (notify_temp_creation)\n@@ -5200,8 +5200,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       if (ret == GS_ERROR)\n \treturn ret;\n       gcc_assert (!want_value\n-\t\t  && (TREE_CODE (*to_p) == VAR_DECL\n-\t\t      || TREE_CODE (*to_p) == MEM_REF));\n+\t\t  && (VAR_P (*to_p) || TREE_CODE (*to_p) == MEM_REF));\n       gimplify_seq_add_stmt (pre_p, gimple_build_assign (*to_p, *from_p));\n       *expr_p = NULL;\n       return GS_ALL_DONE;\n@@ -5349,7 +5348,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n      temporaries (see for example is_gimple_reg_rhs) on the debug info, but\n      make sure not to create DECL_DEBUG_EXPR links across functions.  */\n   if (!gimplify_ctxp->into_ssa\n-      && TREE_CODE (*from_p) == VAR_DECL\n+      && VAR_P (*from_p)\n       && DECL_IGNORED_P (*from_p)\n       && DECL_P (*to_p)\n       && !DECL_IGNORED_P (*to_p)\n@@ -5935,7 +5934,7 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t      if (TREE_CODE (x) == MEM_REF\n \t\t  && TREE_CODE (TREE_OPERAND (x, 0)) == ADDR_EXPR)\n \t\tx = TREE_OPERAND (TREE_OPERAND (x, 0), 0);\n-\t      if ((TREE_CODE (x) == VAR_DECL\n+\t      if ((VAR_P (x)\n \t\t   || TREE_CODE (x) == PARM_DECL\n \t\t   || TREE_CODE (x) == RESULT_DECL)\n \t\t  && !TREE_ADDRESSABLE (x)\n@@ -9055,7 +9054,7 @@ gimplify_oacc_declare (tree *expr_p, gimple_seq *pre_p)\n       if (TREE_CODE (decl) == MEM_REF)\n \tcontinue;\n \n-      if (TREE_CODE (decl) == VAR_DECL\n+      if (VAR_P (decl)\n \t  && !is_global_var (decl)\n \t  && DECL_CONTEXT (decl) == current_function_decl)\n \t{\n@@ -12045,10 +12044,10 @@ gimplify_type_sizes (tree type, gimple_seq *list_p)\n \t  && INTEGRAL_TYPE_P (TYPE_DOMAIN (type)))\n \t{\n \t  t = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n-\t  if (t && TREE_CODE (t) == VAR_DECL && DECL_ARTIFICIAL (t))\n+\t  if (t && VAR_P (t) && DECL_ARTIFICIAL (t))\n \t    DECL_IGNORED_P (t) = 0;\n \t  t = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t  if (t && TREE_CODE (t) == VAR_DECL && DECL_ARTIFICIAL (t))\n+\t  if (t && VAR_P (t) && DECL_ARTIFICIAL (t))\n \t    DECL_IGNORED_P (t) = 0;\n \t}\n       break;"}, {"sha": "6f7083a15c997b25468c03bb8dbfc5c096b673a1", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -883,12 +883,11 @@ get_symbol_for_decl (tree decl)\n \n   gcc_assert (TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL\n-\t      || TREE_CODE (decl) == VAR_DECL);\n+\t      || VAR_P (decl));\n \n   dummy.m_decl = decl;\n \n-  bool is_in_global_vars\n-    = TREE_CODE (decl) == VAR_DECL && is_global_var (decl);\n+  bool is_in_global_vars = VAR_P (decl) && is_global_var (decl);\n \n   if (is_in_global_vars)\n     slot = hsa_global_variable_symbols->find_slot (&dummy, INSERT);\n@@ -925,7 +924,7 @@ get_symbol_for_decl (tree decl)\n   else\n     {\n       hsa_symbol *sym;\n-      gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+      gcc_assert (VAR_P (decl));\n       BrigAlignment8_t align = hsa_object_alignment (decl);\n \n       if (is_in_global_vars)\n@@ -952,7 +951,7 @@ get_symbol_for_decl (tree decl)\n \t    align = MAX ((BrigAlignment8_t) BRIG_ALIGNMENT_8, align);\n \n \t  /* PARM_DECL and RESULT_DECL should be already in m_local_symbols.  */\n-\t  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+\t  gcc_assert (VAR_P (decl));\n \n \t  sym = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_PRIVATE,\n \t\t\t\tBRIG_LINKAGE_FUNCTION);"}, {"sha": "168cfe373c033096b2b623b7e1eb8ef1141b57fe", "filename": "gcc/hsa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fhsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fhsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -798,7 +798,7 @@ hsa_get_declaration_name (tree decl)\n \n   tree name_tree;\n   if (TREE_CODE (decl) == FUNCTION_DECL\n-      || (TREE_CODE (decl) == VAR_DECL && is_global_var (decl)))\n+      || (VAR_P (decl) && is_global_var (decl)))\n     name_tree = DECL_ASSEMBLER_NAME (decl);\n   else\n     name_tree = DECL_NAME (decl);"}, {"sha": "49e219557d57594e927038425f865235ffda633a", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -877,9 +877,9 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t  if (TREE_CODE (ref1->referred->decl)\n \t      != TREE_CODE (ref2->referred->decl))\n \t    {\n-\t      if (TREE_CODE (ref1->referred->decl) == VAR_DECL)\n+\t      if (VAR_P (ref1->referred->decl))\n \t\tend1 = true;\n-\t      else if (TREE_CODE (ref2->referred->decl) == VAR_DECL)\n+\t      else if (VAR_P (ref2->referred->decl))\n \t\tend2 = true;\n \t    }\n \t}\n@@ -2342,7 +2342,7 @@ referenced_from_vtable_p (struct cgraph_node *node)\n     if ((ref->use == IPA_REF_ALIAS\n \t && referenced_from_vtable_p (dyn_cast<cgraph_node *> (ref->referring)))\n \t|| (ref->use == IPA_REF_ADDR\n-\t    && TREE_CODE (ref->referring->decl) == VAR_DECL\n+\t    && VAR_P (ref->referring->decl)\n \t    && DECL_VIRTUAL_P (ref->referring->decl)))\n       {\n \tfound = true;"}, {"sha": "8d9f22af0559ac4e74fddcc62c73049007f0aa89", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -575,7 +575,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n \t  return true;\n       }\n \n-  if (!base || (TREE_CODE (base) == VAR_DECL && is_global_var (base)))\n+  if (!base || (VAR_P (base) && is_global_var (base)))\n     {\n       if (TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n \t  || (!DECL_CXX_CONSTRUCTOR_P (function)"}, {"sha": "e2d3ead065c16277a2d364d86200b3f26d11695a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1729,7 +1729,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \tgcc_assert (!jfunc->bits.known);\n \n       if (is_gimple_ip_invariant (arg)\n-\t  || (TREE_CODE (arg) == VAR_DECL\n+\t  || (VAR_P (arg)\n \t      && is_global_var (arg)\n \t      && TREE_READONLY (arg)))\n \tipa_set_jf_constant (jfunc, arg, cs);\n@@ -2861,7 +2861,7 @@ ipa_find_agg_cst_from_init (tree scalar, HOST_WIDE_INT offset, bool by_ref)\n       scalar = TREE_OPERAND (scalar, 0);\n     }\n \n-  if (TREE_CODE (scalar) != VAR_DECL\n+  if (!VAR_P (scalar)\n       || !is_global_var (scalar)\n       || !TREE_READONLY (scalar)\n       || !DECL_INITIAL (scalar)"}, {"sha": "d3916d5ac2a97f0b97fe36a5ecafe04ff670d19e", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -160,7 +160,7 @@ test_nonssa_use (gimple *, tree t, tree, void *data)\n     return false;\n \n   if (TREE_CODE (t) == PARM_DECL\n-      || (TREE_CODE (t) == VAR_DECL\n+      || (VAR_P (t)\n \t  && auto_var_in_fn_p (t, current_function_decl))\n       || TREE_CODE (t) == RESULT_DECL\n \t /* Normal labels are part of CFG and will be handled gratefuly.\n@@ -656,7 +656,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n       = split_part_set_ssa_name_p (retval, current, return_bb);\n   else if (TREE_CODE (retval) == PARM_DECL)\n     current->split_part_set_retval = false;\n-  else if (TREE_CODE (retval) == VAR_DECL\n+  else if (VAR_P (retval)\n \t   || TREE_CODE (retval) == RESULT_DECL)\n     current->split_part_set_retval\n       = bitmap_bit_p (non_ssa_vars, DECL_UID (retval));\n@@ -848,11 +848,9 @@ mark_nonssa_use (gimple *, tree t, tree, void *data)\n       return true;\n     }\n \n-  if ((TREE_CODE (t) == VAR_DECL\n-       && auto_var_in_fn_p (t, current_function_decl))\n+  if ((VAR_P (t) && auto_var_in_fn_p (t, current_function_decl))\n       || TREE_CODE (t) == RESULT_DECL\n-      || (TREE_CODE (t) == LABEL_DECL\n-\t  && FORCED_LABEL (t)))\n+      || (TREE_CODE (t) == LABEL_DECL && FORCED_LABEL (t)))\n     bitmap_set_bit ((bitmap)data, DECL_UID (t));\n \n   /* For DECL_BY_REFERENCE, the return value is actually a pointer.  We want"}, {"sha": "e8f579504a4af6922ba3a7455e0eaabebf648ce3", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -367,8 +367,7 @@ static tree\n update_vtable_references (tree *tp, int *walk_subtrees,\n \t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n-  if (TREE_CODE (*tp) == VAR_DECL\n-      || TREE_CODE (*tp) == FUNCTION_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (*tp))\n     {\n       if (can_replace_by_local_alias_in_vtable (symtab_node::get (*tp)))\n \t*tp = symtab_node::get (*tp)->noninterposable_alias ()->decl;"}, {"sha": "e20e4953e8fdc3d3fa319fba67f2f80114f2d459", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -128,7 +128,7 @@ process_references (symtab_node *snode,\n \t\t  /* We use variable constructors during late compilation for\n \t\t     constant folding.  Keep references alive so partitioning\n \t\t     knows about potential references.  */\n-\t\t  || (TREE_CODE (node->decl) == VAR_DECL\n+\t\t  || (VAR_P (node->decl)\n \t\t      && flag_wpa\n \t\t      && ctor_for_folding (node->decl)\n \t\t         != error_mark_node))))"}, {"sha": "69cdb944948b466fca9b5f275168de5fcdc1c8c6", "filename": "gcc/langhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -128,7 +128,7 @@ lhd_warn_unused_global_decl (const_tree decl)\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl))\n     return false;\n-  if (TREE_CODE (decl) == VAR_DECL && TREE_READONLY (decl))\n+  if (VAR_P (decl) && TREE_READONLY (decl))\n     return false;\n   if (DECL_IN_SYSTEM_HEADER (decl))\n     return false;\n@@ -152,7 +152,7 @@ lhd_set_decl_assembler_name (tree decl)\n      VAR_DECLs for variables with static storage duration need a real\n      DECL_ASSEMBLER_NAME.  */\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t      || (TREE_CODE (decl) == VAR_DECL\n+\t      || (VAR_P (decl)\n \t\t  && (TREE_STATIC (decl)\n \t\t      || DECL_EXTERNAL (decl)\n \t\t      || TREE_PUBLIC (decl))));"}, {"sha": "2bb0c5042775d107ec9969d5059c39eef72d39c0", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -131,7 +131,7 @@ tree_is_indexable (tree t)\n   /* IMPORTED_DECL is put into BLOCK and thus it never can be shared.  */\n   else if (TREE_CODE (t) == IMPORTED_DECL)\n     return false;\n-  else if (((TREE_CODE (t) == VAR_DECL && !TREE_STATIC (t))\n+  else if (((VAR_P (t) && !TREE_STATIC (t))\n \t    || TREE_CODE (t) == TYPE_DECL\n \t    || TREE_CODE (t) == CONST_DECL\n \t    || TREE_CODE (t) == NAMELIST_DECL)\n@@ -357,7 +357,7 @@ get_symbol_initial_value (lto_symtab_encoder_t encoder, tree expr)\n \n   /* Handle DECL_INITIAL for symbols.  */\n   tree initial = DECL_INITIAL (expr);\n-  if (TREE_CODE (expr) == VAR_DECL\n+  if (VAR_P (expr)\n       && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n       && !DECL_IN_CONSTANT_POOL (expr)\n       && initial)\n@@ -766,11 +766,11 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \t leaks to this point.  */\n       gcc_assert (DECL_ABSTRACT_ORIGIN (expr) != error_mark_node);\n \n-      if ((TREE_CODE (expr) == VAR_DECL\n+      if ((VAR_P (expr)\n \t   || TREE_CODE (expr) == PARM_DECL)\n \t  && DECL_HAS_VALUE_EXPR_P (expr))\n \tDFS_follow_tree_edge (DECL_VALUE_EXPR (expr));\n-      if (TREE_CODE (expr) == VAR_DECL)\n+      if (VAR_P (expr))\n \tDFS_follow_tree_edge (DECL_DEBUG_EXPR (expr));\n     }\n \n@@ -2509,12 +2509,10 @@ write_symbol (struct streamer_tree_cache_d *cache,\n   if (!TREE_PUBLIC (t)\n       || is_builtin_fn (t)\n       || DECL_ABSTRACT_P (t)\n-      || (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t)))\n+      || (VAR_P (t) && DECL_HARD_REGISTER (t)))\n     return;\n-  gcc_assert (TREE_CODE (t) != RESULT_DECL);\n \n-  gcc_assert (TREE_CODE (t) == VAR_DECL\n-\t      || TREE_CODE (t) == FUNCTION_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (t));\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n \n@@ -2545,8 +2543,7 @@ write_symbol (struct streamer_tree_cache_d *cache,\n \tkind = GCCPK_DEF;\n \n       /* When something is defined, it should have node attached.  */\n-      gcc_assert (alias || TREE_CODE (t) != VAR_DECL\n-\t\t  || varpool_node::get (t)->definition);\n+      gcc_assert (alias || !VAR_P (t) || varpool_node::get (t)->definition);\n       gcc_assert (alias || TREE_CODE (t) != FUNCTION_DECL\n \t\t  || (cgraph_node::get (t)\n \t\t      && cgraph_node::get (t)->definition));"}, {"sha": "202f0bd5f2a81890fc3f98b5b7e048dafcf5eccd", "filename": "gcc/omp-low.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -7106,7 +7106,7 @@ expand_omp_regimplify_p (tree *tp, int *walk_subtrees, void *)\n   tree t = *tp;\n \n   /* Any variable with DECL_VALUE_EXPR needs to be regimplified.  */\n-  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n+  if (VAR_P (t) && DECL_HAS_VALUE_EXPR_P (t))\n     return t;\n \n   if (TREE_CODE (t) == ADDR_EXPR)\n@@ -7287,9 +7287,7 @@ expand_omp_taskreg (struct omp_region *region)\n \t rather than in containing function's local_decls chain,\n \t which would mean cgraph missed finalizing them.  Do it now.  */\n       for (t = BLOCK_VARS (block); t; t = DECL_CHAIN (t))\n-\tif (TREE_CODE (t) == VAR_DECL\n-\t    && TREE_STATIC (t)\n-\t    && !DECL_EXTERNAL (t))\n+\tif (VAR_P (t) && TREE_STATIC (t) && !DECL_EXTERNAL (t))\n \t  varpool_node::finalize_decl (t);\n       DECL_SAVED_TREE (child_fn) = NULL;\n       /* We'll create a CFG for child_fn, so no gimple body is needed.  */\n@@ -13129,9 +13127,7 @@ expand_omp_target (struct omp_region *region)\n \t rather than in containing function's local_decls chain,\n \t which would mean cgraph missed finalizing them.  Do it now.  */\n       for (t = BLOCK_VARS (block); t; t = DECL_CHAIN (t))\n-\tif (TREE_CODE (t) == VAR_DECL\n-\t    && TREE_STATIC (t)\n-\t    && !DECL_EXTERNAL (t))\n+\tif (VAR_P (t) && TREE_STATIC (t) && !DECL_EXTERNAL (t))\n \t  varpool_node::finalize_decl (t);\n       DECL_SAVED_TREE (child_fn) = NULL;\n       /* We'll create a CFG for child_fn, so no gimple body is needed.  */\n@@ -16892,7 +16888,7 @@ lower_omp_regimplify_p (tree *tp, int *walk_subtrees,\n   tree t = *tp;\n \n   /* Any variable with DECL_VALUE_EXPR needs to be regimplified.  */\n-  if (TREE_CODE (t) == VAR_DECL && data == NULL && DECL_HAS_VALUE_EXPR_P (t))\n+  if (VAR_P (t) && data == NULL && DECL_HAS_VALUE_EXPR_P (t))\n     return t;\n \n   if (task_shared_vars\n@@ -17196,7 +17192,7 @@ grid_reg_assignment_to_local_var_p (gimple *stmt)\n   if (!assign)\n     return false;\n   tree lhs = gimple_assign_lhs (assign);\n-  if (TREE_CODE (lhs) != VAR_DECL\n+  if (!VAR_P (lhs)\n       || !is_gimple_reg_type (TREE_TYPE (lhs))\n       || is_global_var (lhs))\n     return false;\n@@ -17634,7 +17630,7 @@ grid_remap_prebody_decls (tree *tp, int *walk_subtrees, void *data)\n   else\n     *walk_subtrees = 1;\n \n-  if (TREE_CODE (t) == VAR_DECL)\n+  if (VAR_P (t))\n     {\n       struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n       hash_map<tree, tree> *declmap = (hash_map<tree, tree> *) wi->info;\n@@ -18449,7 +18445,7 @@ add_decls_addresses_to_decl_constructor (vec<tree, va_gc> *v_decls,\n   for (unsigned i = 0; i < len; i++)\n     {\n       tree it = (*v_decls)[i];\n-      bool is_var = TREE_CODE (it) == VAR_DECL;\n+      bool is_var = VAR_P (it);\n       bool is_link_var\n \t= is_var\n #ifdef ACCEL_COMPILER\n@@ -19920,7 +19916,7 @@ find_link_var_op (tree *tp, int *walk_subtrees, void *)\n {\n   tree t = *tp;\n \n-  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t)\n+  if (VAR_P (t) && DECL_HAS_VALUE_EXPR_P (t)\n       && lookup_attribute (\"omp declare target link\", DECL_ATTRIBUTES (t)))\n     {\n       *walk_subtrees = 0;"}, {"sha": "881f2293daef96bab99ecdbc31a4e9d41fd0ae7f", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -211,7 +211,7 @@ rest_of_decl_compilation (tree decl,\n       if ((at_end\n \t   || !DECL_DEFER_OUTPUT (decl)\n \t   || DECL_INITIAL (decl))\n-\t  && (TREE_CODE (decl) != VAR_DECL || !DECL_HAS_VALUE_EXPR_P (decl))\n+\t  && (!VAR_P (decl) || !DECL_HAS_VALUE_EXPR_P (decl))\n \t  && !DECL_EXTERNAL (decl))\n \t{\n \t  /* When reading LTO unit, we also read varpool, so do not\n@@ -250,7 +250,7 @@ rest_of_decl_compilation (tree decl,\n   /* Let cgraph know about the existence of variables.  */\n   if (in_lto_p && !at_end)\n     ;\n-  else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl)\n+  else if (VAR_P (decl) && !DECL_EXTERNAL (decl)\n \t   && TREE_STATIC (decl))\n     varpool_node::get_create (decl);\n \n@@ -311,7 +311,7 @@ rest_of_decl_compilation (tree decl,\n \t     called from varpool node removal fails to handle it\n \t     properly.  */\n \t  || (finalize\n-\t      && TREE_CODE (decl) == VAR_DECL\n+\t      && VAR_P (decl)\n \t      && TREE_STATIC (decl) && !DECL_EXTERNAL (decl)))\n       /* Avoid confusing the debug information machinery when there are\n \t errors.  */"}, {"sha": "039d945d12ae57167eac7a7a11d2265b61b3d724", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -906,7 +906,7 @@ sdbout_toplevel_data (tree decl)\n   if (DECL_IGNORED_P (decl))\n     return;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n   gcc_assert (MEM_P (DECL_RTL (decl)));\n   gcc_assert (DECL_INITIAL (decl));\n \n@@ -1434,9 +1434,7 @@ sdbout_early_global_decl (tree decl ATTRIBUTE_UNUSED)\n static void\n sdbout_late_global_decl (tree decl)\n {\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && !DECL_EXTERNAL (decl)\n-      && DECL_RTL_SET_P (decl))\n+  if (VAR_P (decl) && !DECL_EXTERNAL (decl) && DECL_RTL_SET_P (decl))\n     {\n       /* The COFF linker can move initialized global vars to the end.\n \t And that can screw up the symbol ordering.  Defer those for"}, {"sha": "cd3e2d08d6fabc399ccc97a33c4dbe8ce7f75c18", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -321,7 +321,7 @@ delegitimize_mem_from_attrs (rtx x)\n \n       if (decl\n \t  && mode == GET_MODE (x)\n-\t  && TREE_CODE (decl) == VAR_DECL\n+\t  && VAR_P (decl)\n \t  && (TREE_STATIC (decl)\n \t      || DECL_THREAD_LOCAL_P (decl))\n \t  && DECL_RTL_SET_P (decl)"}, {"sha": "39fa5e19db35aa7551614c302076e40fd10e3488", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -458,7 +458,7 @@ decl_overlaps_hard_reg_set_p (tree *declp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   tree decl = *declp;\n   const HARD_REG_SET *const regs = (const HARD_REG_SET *) data;\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       if (DECL_HARD_REGISTER (decl)\n \t  && REG_P (DECL_RTL (decl))"}, {"sha": "63a1454b6297c2bd4cdce50b4e353820ddcfa572", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1137,7 +1137,7 @@ place_field (record_layout_info rli, tree field)\n      really like a structure field.  If it is a FUNCTION_DECL, it's a\n      method.  In both cases, all we do is lay out the decl, and we do\n      it *after* the record is laid out.  */\n-  if (TREE_CODE (field) == VAR_DECL)\n+  if (VAR_P (field))\n     {\n       vec_safe_push (rli->pending_statics, field);\n       return;"}, {"sha": "73168a8db0933bceb7baa9ef9c7292ae19521dc4", "filename": "gcc/symtab.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -273,8 +273,7 @@ symbol_table::change_decl_assembler_name (tree decl, tree name)\n \n   /* We can have user ASM names on things, like global register variables, that\n      are not in the symbol table.  */\n-  if ((TREE_CODE (decl) == VAR_DECL\n-       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+  if ((VAR_P (decl) && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n       || TREE_CODE (decl) == FUNCTION_DECL)\n     node = symtab_node::get (decl);\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n@@ -602,8 +601,7 @@ symtab_node::maybe_create_reference (tree val, enum ipa_ref_use use_type,\n   if (TREE_CODE (val) != ADDR_EXPR)\n     return NULL;\n   val = get_base_var (val);\n-  if (val && (TREE_CODE (val) == FUNCTION_DECL\n-\t       || TREE_CODE (val) == VAR_DECL))\n+  if (val && VAR_OR_FUNCTION_DECL_P (val))\n     {\n       symtab_node *referred = symtab_node::get (val);\n       gcc_checking_assert (referred);\n@@ -967,7 +965,7 @@ symtab_node::verify_base (void)\n     }\n   else if (is_a <varpool_node *> (this))\n     {\n-      if (TREE_CODE (decl) != VAR_DECL)\n+      if (!VAR_P (decl))\n \t{\n           error (\"variable symbol is not variable\");\n           error_found = true;\n@@ -1254,7 +1252,7 @@ symtab_node::make_decl_local (void)\n \talias->make_decl_local ();\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       DECL_COMMON (decl) = 0;\n       /* ADDRESSABLE flag is not defined for public symbols.  */\n@@ -1303,7 +1301,7 @@ symtab_node::copy_visibility_from (symtab_node *n)\n \talias->copy_visibility_from (n);\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       DECL_COMMON (decl) = DECL_COMMON (n->decl);\n       /* ADDRESSABLE flag is not defined for public symbols.  */\n@@ -2099,7 +2097,7 @@ symtab_node::can_increase_alignment_p (void)\n   symtab_node *target = ultimate_alias_target ();\n \n   /* For now support only variables.  */\n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     return false;\n \n   /* With -fno-toplevel-reorder we may have already output the constant.  */"}, {"sha": "570f4cfee6cafb4ee6940497328fe8241446cef9", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -350,7 +350,7 @@ wrapup_global_declaration_1 (tree decl)\n       && DECL_DEFER_OUTPUT (decl) != 0)\n     DECL_DEFER_OUTPUT (decl) = 0;\n \n-  if (TREE_CODE (decl) == VAR_DECL && DECL_SIZE (decl) == 0)\n+  if (VAR_P (decl) && DECL_SIZE (decl) == 0)\n     lang_hooks.finish_incomplete_decl (decl);\n }\n \n@@ -361,7 +361,7 @@ bool\n wrapup_global_declaration_2 (tree decl)\n {\n   if (TREE_ASM_WRITTEN (decl) || DECL_EXTERNAL (decl)\n-      || (TREE_CODE (decl) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (decl)))\n+      || (VAR_P (decl) && DECL_HAS_VALUE_EXPR_P (decl)))\n     return false;\n \n   /* Don't write out static consts, unless we still need them.\n@@ -389,7 +389,7 @@ wrapup_global_declaration_2 (tree decl)\n      to force a constant to be written if and only if it is\n      defined in a main file, as opposed to an include file.  */\n \n-  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+  if (VAR_P (decl) && TREE_STATIC (decl))\n     {\n       varpool_node *node;\n       bool needed = true;"}, {"sha": "a82d3629c19417e5fe850907c5d6b37f443b3897", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1545,7 +1545,7 @@ requires_barrier (basic_block entry_block, tree x, gimple *stmt)\n       x = TREE_OPERAND (TMR_BASE (x), 0);\n       if (TREE_CODE (x) == PARM_DECL)\n \treturn false;\n-      gcc_assert (TREE_CODE (x) == VAR_DECL);\n+      gcc_assert (VAR_P (x));\n       /* FALLTHRU */\n \n     case PARM_DECL:"}, {"sha": "dfa82aaef7375eb3529f2e16abf19dae891566d3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -2786,7 +2786,7 @@ verify_address (tree t, tree base)\n       return t;\n     }\n \n-  if (!(TREE_CODE (base) == VAR_DECL\n+  if (!(VAR_P (base)\n \t|| TREE_CODE (base) == PARM_DECL\n \t|| TREE_CODE (base) == RESULT_DECL))\n     return NULL_TREE;\n@@ -2902,7 +2902,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \tif ((tem = verify_address (t, x)))\n \t  return tem;\n \n-\tif (!(TREE_CODE (x) == VAR_DECL\n+\tif (!(VAR_P (x)\n \t      || TREE_CODE (x) == PARM_DECL\n \t      || TREE_CODE (x) == RESULT_DECL))\n \t  return NULL;\n@@ -4982,15 +4982,14 @@ verify_expr_location_1 (tree *tp, int *walk_subtrees, void *data)\n {\n   hash_set<tree> *blocks = (hash_set<tree> *) data;\n \n-  if (TREE_CODE (*tp) == VAR_DECL\n-      && DECL_HAS_DEBUG_EXPR_P (*tp))\n+  if (VAR_P (*tp) && DECL_HAS_DEBUG_EXPR_P (*tp))\n     {\n       tree t = DECL_DEBUG_EXPR (*tp);\n       tree addr = walk_tree (&t, verify_expr_no_block, NULL, NULL);\n       if (addr)\n \treturn addr;\n     }\n-  if ((TREE_CODE (*tp) == VAR_DECL\n+  if ((VAR_P (*tp)\n        || TREE_CODE (*tp) == PARM_DECL\n        || TREE_CODE (*tp) == RESULT_DECL)\n       && DECL_HAS_VALUE_EXPR_P (*tp))\n@@ -5989,13 +5988,11 @@ gimple_duplicate_bb (basic_block bb)\n \t{\n \t  tree base = get_base_address (lhs);\n \t  if (base\n-\t      && (TREE_CODE (base) == VAR_DECL\n-\t\t  || TREE_CODE (base) == RESULT_DECL)\n+\t      && (VAR_P (base) || TREE_CODE (base) == RESULT_DECL)\n \t      && DECL_IGNORED_P (base)\n \t      && !TREE_STATIC (base)\n \t      && !DECL_EXTERNAL (base)\n-\t      && (TREE_CODE (base) != VAR_DECL\n-\t\t  || !DECL_HAS_VALUE_EXPR_P (base)))\n+\t      && (!VAR_P (base) || !DECL_HAS_VALUE_EXPR_P (base)))\n \t    DECL_NONSHAREABLE (base) = 1;\n \t}\n \n@@ -6621,8 +6618,7 @@ move_stmt_op (tree *tp, int *walk_subtrees, void *data)\n \t     statements, and in alias lists of other variables.  It would be\n \t     quite difficult to expunge it from all those places.  ??? It might\n \t     suffice to do this for addressable variables.  */\n-\t  if ((TREE_CODE (t) == VAR_DECL\n-\t       && !is_global_var (t))\n+\t  if ((VAR_P (t) && !is_global_var (t))\n \t      || TREE_CODE (t) == CONST_DECL)\n \t    replace_by_duplicate_decl (tp, p->vars_map, p->to_context);\n \t}\n@@ -7008,12 +7004,12 @@ replace_block_vars_by_duplicates (tree block, hash_map<tree, tree> *vars_map,\n   for (tp = &BLOCK_VARS (block); *tp; tp = &DECL_CHAIN (*tp))\n     {\n       t = *tp;\n-      if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != CONST_DECL)\n+      if (!VAR_P (t) && TREE_CODE (t) != CONST_DECL)\n \tcontinue;\n       replace_by_duplicate_decl (&t, vars_map, to_context);\n       if (t != *tp)\n \t{\n-\t  if (TREE_CODE (*tp) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (*tp))\n+\t  if (VAR_P (*tp) && DECL_HAS_VALUE_EXPR_P (*tp))\n \t    {\n \t      tree x = DECL_VALUE_EXPR (*tp);\n \t      struct replace_decls_d rd = { vars_map, to_context };\n@@ -9035,7 +9031,7 @@ execute_fixup_cfg (void)\n \t    {\n \t      tree lhs = get_base_address (gimple_get_lhs (stmt));\n \n-\t      if (TREE_CODE (lhs) == VAR_DECL\n+\t      if (VAR_P (lhs)\n \t\t  && (TREE_STATIC (lhs) || DECL_EXTERNAL (lhs))\n \t\t  && varpool_node::get (lhs)->writeonly)\n \t\t{\n@@ -9053,7 +9049,7 @@ execute_fixup_cfg (void)\n \t    {\n \t      tree lhs = get_base_address (gimple_get_lhs (stmt));\n \n-\t      if (TREE_CODE (lhs) == VAR_DECL\n+\t      if (VAR_P (lhs)\n \t\t  && (TREE_STATIC (lhs) || DECL_EXTERNAL (lhs))\n \t\t  && varpool_node::get (lhs)->writeonly)\n \t\t{"}, {"sha": "780b5acb7b76dc363ab472198e9854255f632a96", "filename": "gcc/tree-chkp-opt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-chkp-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-chkp-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp-opt.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -610,7 +610,7 @@ chkp_get_check_result (struct check_info *ci, tree bounds)\n       chkp_collect_value (DECL_INITIAL (bnd_var), bound_val);\n       if (ci->type == CHECK_UPPER_BOUND)\n \t{\n-\t  if (TREE_CODE (var) == VAR_DECL)\n+\t  if (VAR_P (var))\n \t    {\n \t      if (DECL_SIZE (var)\n \t\t  && !chkp_variable_size_type (TREE_TYPE (var)))"}, {"sha": "27696828716dd439154cec193ac4bb6a8ba610c6", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1002,7 +1002,7 @@ chkp_register_var_initializer (tree var)\n       || DECL_INITIAL (var) == error_mark_node)\n     return false;\n \n-  gcc_assert (TREE_CODE (var) == VAR_DECL);\n+  gcc_assert (VAR_P (var));\n   gcc_assert (DECL_INITIAL (var));\n \n   if (TREE_STATIC (var)\n@@ -2936,7 +2936,7 @@ chkp_make_static_bounds (tree obj)\n \t chkp_static_var_bounds map.  It allows to\n \t avoid duplicating bound vars for decls\n \t sharing assembler name.  */\n-      if (TREE_CODE (obj) == VAR_DECL)\n+      if (VAR_P (obj))\n \t{\n \t  tree name = DECL_ASSEMBLER_NAME (obj);\n \t  slot = chkp_static_var_bounds->get (name);\n@@ -2952,7 +2952,7 @@ chkp_make_static_bounds (tree obj)\n     }\n \n   /* Build decl for bounds var.  */\n-  if (TREE_CODE (obj) == VAR_DECL)\n+  if (VAR_P (obj))\n     {\n       if (DECL_IGNORED_P (obj))\n \t{\n@@ -3014,7 +3014,7 @@ chkp_make_static_bounds (tree obj)\n   if (!chkp_static_var_bounds)\n     chkp_static_var_bounds = new hash_map<tree, tree>;\n \n-  if (TREE_CODE (obj) == VAR_DECL)\n+  if (VAR_P (obj))\n     {\n       tree name = DECL_ASSEMBLER_NAME (obj);\n       chkp_static_var_bounds->put (name, bnd_var);\n@@ -3117,7 +3117,7 @@ chkp_get_bounds_for_decl_addr (tree decl)\n {\n   tree bounds;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n+  gcc_assert (VAR_P (decl)\n \t      || TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n \n@@ -3144,7 +3144,7 @@ chkp_get_bounds_for_decl_addr (tree decl)\n       return chkp_get_zero_bounds ();\n \n   if (flag_chkp_use_static_bounds\n-      && TREE_CODE (decl) == VAR_DECL\n+      && VAR_P (decl)\n       && (TREE_STATIC (decl)\n \t      || DECL_EXTERNAL (decl)\n \t      || TREE_PUBLIC (decl))\n@@ -3164,7 +3164,7 @@ chkp_get_bounds_for_decl_addr (tree decl)\n \t      || DECL_EXTERNAL (decl)\n \t      || TREE_PUBLIC (decl))))\n     {\n-      gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+      gcc_assert (VAR_P (decl));\n       bounds = chkp_generate_extern_var_bounds (decl);\n     }\n   else\n@@ -3399,7 +3399,7 @@ chkp_parse_array_and_component_ref (tree node, tree *ptr,\n     }\n   else\n     {\n-      gcc_assert (TREE_CODE (var) == VAR_DECL\n+      gcc_assert (VAR_P (var)\n \t\t  || TREE_CODE (var) == PARM_DECL\n \t\t  || TREE_CODE (var) == RESULT_DECL\n \t\t  || TREE_CODE (var) == STRING_CST\n@@ -3562,7 +3562,7 @@ chkp_find_bounds_1 (tree ptr, tree ptr_src, gimple_stmt_iterator *iter)\n     case MEM_REF:\n     case VAR_DECL:\n       if (BOUNDED_P (ptr_src))\n-\tif (TREE_CODE (ptr) == VAR_DECL && DECL_REGISTER (ptr))\n+\tif (VAR_P (ptr) && DECL_REGISTER (ptr))\n \t  bounds = chkp_get_zero_bounds ();\n \telse\n \t  {\n@@ -3581,7 +3581,7 @@ chkp_find_bounds_1 (tree ptr, tree ptr_src, gimple_stmt_iterator *iter)\n \t  || TREE_CODE (addr) == TARGET_MEM_REF)\n \t{\n \t  if (BOUNDED_P (ptr_src))\n-\t    if (TREE_CODE (ptr) == VAR_DECL && DECL_REGISTER (ptr))\n+\t    if (VAR_P (ptr) && DECL_REGISTER (ptr))\n \t      bounds = chkp_get_zero_bounds ();\n \t    else\n \t      {"}, {"sha": "cefac2c5ae3632147047838891e52c3b895520fc", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -942,7 +942,7 @@ chrec_contains_symbols (const_tree chrec)\n     return false;\n \n   if (TREE_CODE (chrec) == SSA_NAME\n-      || TREE_CODE (chrec) == VAR_DECL\n+      || VAR_P (chrec)\n       || TREE_CODE (chrec) == PARM_DECL\n       || TREE_CODE (chrec) == FUNCTION_DECL\n       || TREE_CODE (chrec) == LABEL_DECL"}, {"sha": "0396febc7304ab7325a90d94de54bc0fbf2344ae", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -302,7 +302,7 @@ ssa_default_def (struct function *fn, tree var)\n {\n   struct tree_decl_minimal ind;\n   struct tree_ssa_name in;\n-  gcc_assert (TREE_CODE (var) == VAR_DECL\n+  gcc_assert (VAR_P (var)\n \t      || TREE_CODE (var) == PARM_DECL\n \t      || TREE_CODE (var) == RESULT_DECL);\n   in.var = (tree)&ind;\n@@ -319,7 +319,7 @@ set_ssa_default_def (struct function *fn, tree var, tree def)\n   struct tree_decl_minimal ind;\n   struct tree_ssa_name in;\n \n-  gcc_assert (TREE_CODE (var) == VAR_DECL\n+  gcc_assert (VAR_P (var)\n \t      || TREE_CODE (var) == PARM_DECL\n \t      || TREE_CODE (var) == RESULT_DECL);\n   in.var = (tree)&ind;\n@@ -612,8 +612,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n   if (DECL_P (exp))\n     {\n-      if (flag_unconstrained_commons\n-\t  && TREE_CODE (exp) == VAR_DECL && DECL_COMMON (exp))\n+      if (flag_unconstrained_commons && VAR_P (exp) && DECL_COMMON (exp))\n \t{\n \t  tree sz_tree = TYPE_SIZE (TREE_TYPE (exp));\n \t  /* If size is unknown, or we have read to the end, assume there"}, {"sha": "8c9990fee6f26c298b42f18bea10ee500dfd5f98", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -266,7 +266,7 @@ default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n \n     case 'D':\n       t = va_arg (*text->args_ptr, tree);\n-      if (TREE_CODE (t) == VAR_DECL && DECL_HAS_DEBUG_EXPR_P (t))\n+      if (VAR_P (t) && DECL_HAS_DEBUG_EXPR_P (t))\n \tt = DECL_DEBUG_EXPR (t);\n       break;\n "}, {"sha": "df47181f4312669aa90b4fefb4de9a7331c72877", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -536,8 +536,7 @@ dequeue_and_dump (dump_info_p di)\n \t  if (DECL_FIELD_OFFSET (t))\n \t    dump_child (\"bpos\", bit_position (t));\n \t}\n-      else if (TREE_CODE (t) == VAR_DECL\n-\t       || TREE_CODE (t) == PARM_DECL)\n+      else if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t{\n \t  dump_int (di, \"used\", TREE_USED (t));\n \t  if (DECL_REGISTER (t))"}, {"sha": "de5e575708012b738ce507a1915abcdee2be700f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -163,7 +163,7 @@ insert_debug_decl_map (copy_body_data *id, tree key, tree value)\n     return;\n \n   gcc_assert (TREE_CODE (key) == PARM_DECL);\n-  gcc_assert (TREE_CODE (value) == VAR_DECL);\n+  gcc_assert (VAR_P (value));\n \n   if (!id->debug_map)\n     id->debug_map = new hash_map<tree, tree>;\n@@ -228,7 +228,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n   var = SSA_NAME_VAR (name);\n   if (!var\n       || (!SSA_NAME_IS_DEFAULT_DEF (name)\n-\t  && TREE_CODE (var) == VAR_DECL\n+\t  && VAR_P (var)\n \t  && !VAR_DECL_IS_VIRTUAL_OPERAND (var)\n \t  && DECL_ARTIFICIAL (var)\n \t  && DECL_IGNORED_P (var)\n@@ -264,7 +264,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n      Replace the SSA name representing RESULT_DECL by variable during\n      inlining:  this saves us from need to introduce PHI node in a case\n      return value is just partly initialized.  */\n-  if ((TREE_CODE (new_tree) == VAR_DECL || TREE_CODE (new_tree) == PARM_DECL)\n+  if ((VAR_P (new_tree) || TREE_CODE (new_tree) == PARM_DECL)\n       && (!SSA_NAME_VAR (name)\n \t  || TREE_CODE (SSA_NAME_VAR (name)) != RESULT_DECL\n \t  || !id->transform_return_to_modify))\n@@ -607,8 +607,7 @@ can_be_nonlocal (tree decl, copy_body_data *id)\n \n   /* Local static vars must be non-local or we get multiple declaration\n      problems.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && !auto_var_in_fn_p (decl, id->src_fn))\n+  if (VAR_P (decl) && !auto_var_in_fn_p (decl, id->src_fn))\n     return true;\n \n   return false;\n@@ -630,9 +629,7 @@ remap_decls (tree decls, vec<tree, va_gc> **nonlocalized_list,\n \t{\n \t  /* We need to add this variable to the local decls as otherwise\n \t     nothing else will do so.  */\n-\t  if (TREE_CODE (old_var) == VAR_DECL\n-\t      && ! DECL_EXTERNAL (old_var)\n-\t      && cfun)\n+\t  if (VAR_P (old_var) && ! DECL_EXTERNAL (old_var) && cfun)\n \t    add_local_decl (cfun, old_var);\n \t  if ((!optimize || debug_info_level > DINFO_LEVEL_TERSE)\n \t      && !DECL_IGNORED_P (old_var)\n@@ -664,8 +661,7 @@ remap_decls (tree decls, vec<tree, va_gc> **nonlocalized_list,\n \t  new_decls = new_var;\n  \n \t  /* Also copy value-expressions.  */\n-\t  if (TREE_CODE (new_var) == VAR_DECL\n-\t      && DECL_HAS_VALUE_EXPR_P (new_var))\n+\t  if (VAR_P (new_var) && DECL_HAS_VALUE_EXPR_P (new_var))\n \t    {\n \t      tree tem = DECL_VALUE_EXPR (new_var);\n \t      bool old_regimplify = id->regimplify;\n@@ -2876,12 +2872,10 @@ copy_debug_stmt (gdebug *stmt, copy_body_data *id)\n   if (TREE_CODE (t) == PARM_DECL && id->debug_map\n       && (n = id->debug_map->get (t)))\n     {\n-      gcc_assert (TREE_CODE (*n) == VAR_DECL);\n+      gcc_assert (VAR_P (*n));\n       t = *n;\n     }\n-  else if (TREE_CODE (t) == VAR_DECL\n-\t   && !is_global_var (t)\n-\t   && !id->decl_map->get (t))\n+  else if (VAR_P (t) && !is_global_var (t) && !id->decl_map->get (t))\n     /* T is a non-localized variable.  */;\n   else\n     walk_tree (&t, remap_gimple_op_r, &wi, NULL);\n@@ -3277,8 +3271,7 @@ initialize_inlined_parameters (copy_body_data *id, gimple *stmt,\n   for (p = parms, i = 0; p; p = DECL_CHAIN (p), i++)\n     {\n       tree *varp = id->decl_map->get (p);\n-      if (varp\n-\t  && TREE_CODE (*varp) == VAR_DECL)\n+      if (varp && VAR_P (*varp))\n \t{\n \t  tree def = (gimple_in_ssa_p (cfun) && is_gimple_reg (p)\n \t\t      ? ssa_default_def (id->src_cfun, p) : NULL);\n@@ -4297,7 +4290,7 @@ add_local_variables (struct function *callee, struct function *caller,\n         tree new_var = remap_decl (var, id);\n \n         /* Remap debug-expressions.  */\n-\tif (TREE_CODE (new_var) == VAR_DECL\n+\tif (VAR_P (new_var)\n \t    && DECL_HAS_DEBUG_EXPR_P (var)\n \t    && new_var != var)\n \t  {\n@@ -4325,7 +4318,7 @@ reset_debug_binding (copy_body_data *id, tree srcvar, gimple_seq *bindings)\n   if (!remappedvarp)\n     return;\n \n-  if (TREE_CODE (*remappedvarp) != VAR_DECL)\n+  if (!VAR_P (*remappedvarp))\n     return;\n \n   if (*remappedvarp == id->retvar || *remappedvarp == id->retbnd)\n@@ -5202,8 +5195,7 @@ replace_locals_op (tree *tp, int *walk_subtrees, void *data)\n \tSSA_NAME_DEF_STMT (*tp) = gsi_stmt (wi->gsi);\n     }\n   /* Only a local declaration (variable or label).  */\n-  else if ((TREE_CODE (expr) == VAR_DECL\n-\t    && !TREE_STATIC (expr))\n+  else if ((VAR_P (expr) && !TREE_STATIC (expr))\n \t   || TREE_CODE (expr) == LABEL_DECL)\n     {\n       /* Lookup the declaration.  */"}, {"sha": "e5b59a7a29f822508d239249cd331e4d14aeaf38", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1339,8 +1339,7 @@ rewrite_stmt (gimple_stmt_iterator *si)\n \t  {\n \t    /* If we rewrite a DECL into SSA form then drop its\n \t       clobber stmts and replace uses with a new default def.  */\n-\t    gcc_checking_assert (TREE_CODE (var) == VAR_DECL\n-\t\t\t\t && !gimple_vdef (stmt));\n+\t    gcc_checking_assert (VAR_P (var) && !gimple_vdef (stmt));\n \t    gsi_replace (si, gimple_build_nop (), true);\n \t    register_new_def (get_or_create_ssa_default_def (cfun, var), var);\n \t    break;\n@@ -1821,7 +1820,7 @@ maybe_register_def (def_operand_p def_p, gimple *stmt,\n \t{\n \t  if (gimple_clobber_p (stmt) && is_gimple_reg (sym))\n \t    {\n-\t      gcc_checking_assert (TREE_CODE (sym) == VAR_DECL);\n+\t      gcc_checking_assert (VAR_P (sym));\n \t      /* Replace clobber stmts with a default def. This new use of a\n \t\t default definition may make it look like SSA_NAMEs have\n \t\t conflicting lifetimes, so we need special code to let them\n@@ -2393,7 +2392,7 @@ pass_build_ssa::execute (function *fun)\n \tcontinue;\n       tree decl = SSA_NAME_VAR (name);\n       if (decl\n-\t  && TREE_CODE (decl) == VAR_DECL\n+\t  && VAR_P (decl)\n \t  && !VAR_DECL_IS_VIRTUAL_OPERAND (decl)\n \t  && DECL_IGNORED_P (decl))\n \tSET_SSA_NAME_VAR_OR_IDENTIFIER (name, DECL_NAME (decl));"}, {"sha": "465ae310b1767f069d78eeee1d7d3026cc58f2d5", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -856,7 +856,7 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   DECL_SEEN_IN_BIND_EXPR_P (new_decl) = 1;\n   if ((TREE_CODE (decl) == PARM_DECL\n        || TREE_CODE (decl) == RESULT_DECL\n-       || TREE_CODE (decl) == VAR_DECL)\n+       || VAR_P (decl))\n       && DECL_BY_REFERENCE (decl))\n     DECL_BY_REFERENCE (new_decl) = 1;\n \n@@ -1076,7 +1076,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tdo_decl_clause:\n \t  decl = OMP_CLAUSE_DECL (clause);\n-\t  if (TREE_CODE (decl) == VAR_DECL\n+\t  if (VAR_P (decl)\n \t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t    break;\n \t  if (decl_function_context (decl) != info->context)\n@@ -1175,7 +1175,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    }\n \t  /* Like do_decl_clause, but don't add any suppression.  */\n \t  decl = OMP_CLAUSE_DECL (clause);\n-\t  if (TREE_CODE (decl) == VAR_DECL\n+\t  if (VAR_P (decl)\n \t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t    break;\n \t  if (decl_function_context (decl) != info->context)\n@@ -1308,11 +1308,11 @@ note_nonlocal_vla_type (struct nesting_info *info, tree type)\n       if (domain)\n \t{\n \t  t = TYPE_MIN_VALUE (domain);\n-\t  if (t && (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+\t  if (t && (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t      && decl_function_context (t) != info->context)\n \t    get_nonlocal_debug_decl (info, t);\n \t  t = TYPE_MAX_VALUE (domain);\n-\t  if (t && (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+\t  if (t && (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t      && decl_function_context (t) != info->context)\n \t    get_nonlocal_debug_decl (info, t);\n \t}\n@@ -1328,7 +1328,7 @@ note_nonlocal_block_vlas (struct nesting_info *info, tree block)\n   tree var;\n \n   for (var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n-    if (TREE_CODE (var) == VAR_DECL\n+    if (VAR_P (var)\n \t&& variably_modified_type_p (TREE_TYPE (var), NULL)\n \t&& DECL_HAS_VALUE_EXPR_P (var)\n \t&& decl_function_context (var) != info->context)\n@@ -1492,7 +1492,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n \t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (decls), i, decl)\n \t      {\n-\t\tif (TREE_CODE (decl) == VAR_DECL\n+\t\tif (VAR_P (decl)\n \t\t    && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t\t  continue;\n \t\tif (decl_function_context (decl) != info->context)\n@@ -1554,7 +1554,7 @@ get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n   DECL_SEEN_IN_BIND_EXPR_P (new_decl) = 1;\n   if ((TREE_CODE (decl) == PARM_DECL\n        || TREE_CODE (decl) == RESULT_DECL\n-       || TREE_CODE (decl) == VAR_DECL)\n+       || VAR_P (decl))\n       && DECL_BY_REFERENCE (decl))\n     DECL_BY_REFERENCE (new_decl) = 1;\n \n@@ -1774,7 +1774,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tdo_decl_clause:\n \t  decl = OMP_CLAUSE_DECL (clause);\n-\t  if (TREE_CODE (decl) == VAR_DECL\n+\t  if (VAR_P (decl)\n \t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t    break;\n \t  if (decl_function_context (decl) == info->context\n@@ -1878,7 +1878,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    }\n \t  /* Like do_decl_clause, but don't add any suppression.  */\n \t  decl = OMP_CLAUSE_DECL (clause);\n-\t  if (TREE_CODE (decl) == VAR_DECL\n+\t  if (VAR_P (decl)\n \t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t    break;\n \t  if (decl_function_context (decl) == info->context\n@@ -2144,7 +2144,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n \t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (decls), i, decl)\n \t      {\n-\t\tif (TREE_CODE (decl) == VAR_DECL\n+\t\tif (VAR_P (decl)\n \t\t    && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t\t  continue;\n \t\tif (decl_function_context (decl) == info->context\n@@ -2685,7 +2685,7 @@ nesting_copy_decl (tree decl, copy_body_data *id)\n       return new_decl;\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       || TREE_CODE (decl) == PARM_DECL\n       || TREE_CODE (decl) == RESULT_DECL)\n     return decl;\n@@ -2728,7 +2728,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n     remap_vla_decls (subblock, root);\n \n   for (var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n-    if (TREE_CODE (var) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (var))\n+    if (VAR_P (var) && DECL_HAS_VALUE_EXPR_P (var))\n       {\n \tval = DECL_VALUE_EXPR (var);\n \ttype = TREE_TYPE (var);\n@@ -2752,7 +2752,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n   id.root = root;\n \n   for (; var; var = DECL_CHAIN (var))\n-    if (TREE_CODE (var) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (var))\n+    if (VAR_P (var) && DECL_HAS_VALUE_EXPR_P (var))\n       {\n \tstruct nesting_info *i;\n \ttree newt, context;"}, {"sha": "90d90af9d770df17a9b840209f7dc0b08dd18edd", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -202,7 +202,7 @@ pass_nrv::execute (function *fun)\n \n \t      /* The returned value must be a local automatic variable of the\n \t\t same type and alignment as the function's result.  */\n-\t      if (TREE_CODE (found) != VAR_DECL\n+\t      if (!VAR_P (found)\n \t\t  || TREE_THIS_VOLATILE (found)\n \t\t  || !auto_var_in_fn_p (found, current_function_decl)\n \t\t  || TREE_ADDRESSABLE (found)"}, {"sha": "ebbf606ff8b60682bad0235f19ac72398c160005", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -3284,7 +3284,7 @@ print_declaration (pretty_printer *pp, tree t, int spc, int flags)\n       dump_generic_node (pp, t, spc, flags, false);\n     }\n \n-  if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n+  if (VAR_P (t) && DECL_HARD_REGISTER (t))\n     {\n       pp_string (pp, \" __asm__ \");\n       pp_left_paren (pp);\n@@ -3307,7 +3307,7 @@ print_declaration (pretty_printer *pp, tree t, int spc, int flags)\n \t}\n     }\n \n-  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n+  if (VAR_P (t) && DECL_HAS_VALUE_EXPR_P (t))\n     {\n       pp_string (pp, \" [value-expr: \");\n       dump_generic_node (pp, DECL_VALUE_EXPR (t), spc, flags, false);"}, {"sha": "d4ccd91f851766ddccb54a2636e8e8d70be3a9ac", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -687,7 +687,7 @@ sra_deinitialize (void)\n \n static bool constant_decl_p (tree decl)\n {\n-  return TREE_CODE (decl) == VAR_DECL && DECL_IN_CONSTANT_POOL (decl);\n+  return VAR_P (decl) && DECL_IN_CONSTANT_POOL (decl);\n }\n \n /* Remove DECL from candidates for SRA and write REASON to the dump file if\n@@ -1965,7 +1965,7 @@ find_var_candidates (void)\n \n   FOR_EACH_LOCAL_DECL (cfun, i, var)\n     {\n-      if (TREE_CODE (var) != VAR_DECL)\n+      if (!VAR_P (var))\n         continue;\n \n       ret |= maybe_add_sra_candidate (var);\n@@ -2653,8 +2653,7 @@ analyze_all_variable_accesses (void)\n       {\n \ttree var = candidate (i);\n \n-\tif (TREE_CODE (var) == VAR_DECL\n-\t    && scalarizable_type_p (TREE_TYPE (var)))\n+\tif (VAR_P (var) && scalarizable_type_p (TREE_TYPE (var)))\n \t  {\n \t    if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var)))\n \t\t<= max_scalarization_size)"}, {"sha": "a53ade0600d01c9d48f6c789b78fd42d7a06a95b", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -400,9 +400,8 @@ create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr,\n static bool\n fixed_address_object_p (tree obj)\n {\n-  return (TREE_CODE (obj) == VAR_DECL\n-\t  && (TREE_STATIC (obj)\n-\t      || DECL_EXTERNAL (obj))\n+  return (VAR_P (obj)\n+\t  && (TREE_STATIC (obj) || DECL_EXTERNAL (obj))\n \t  && ! DECL_DLLIMPORT_P (obj));\n }\n \n@@ -893,7 +892,7 @@ copy_ref_info (tree new_ref, tree old_ref)\n \t  else\n \t    mark_ptr_info_alignment_unknown (new_pi);\n \t}\n-      else if (TREE_CODE (base) == VAR_DECL\n+      else if (VAR_P (base)\n \t       || TREE_CODE (base) == PARM_DECL\n \t       || TREE_CODE (base) == RESULT_DECL)\n \t{"}, {"sha": "01bef17cbfb558336a499e6754076589d3d2a6cf", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -167,7 +167,7 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n        && TREE_CODE (ptr) != ADDR_EXPR\n        && TREE_CODE (ptr) != POINTER_PLUS_EXPR)\n       || !POINTER_TYPE_P (TREE_TYPE (ptr))\n-      || (TREE_CODE (decl) != VAR_DECL\n+      || (!VAR_P (decl)\n \t  && TREE_CODE (decl) != PARM_DECL\n \t  && TREE_CODE (decl) != RESULT_DECL))\n     return true;\n@@ -338,7 +338,7 @@ ptrs_compare_unequal (tree ptr1, tree ptr2)\n       tree tem = get_base_address (TREE_OPERAND (ptr1, 0));\n       if (! tem)\n \treturn false;\n-      if (TREE_CODE (tem) == VAR_DECL\n+      if (VAR_P (tem)\n \t  || TREE_CODE (tem) == PARM_DECL\n \t  || TREE_CODE (tem) == RESULT_DECL)\n \tobj1 = tem;\n@@ -350,7 +350,7 @@ ptrs_compare_unequal (tree ptr1, tree ptr2)\n       tree tem = get_base_address (TREE_OPERAND (ptr2, 0));\n       if (! tem)\n \treturn false;\n-      if (TREE_CODE (tem) == VAR_DECL\n+      if (VAR_P (tem)\n \t  || TREE_CODE (tem) == PARM_DECL\n \t  || TREE_CODE (tem) == RESULT_DECL)\n \tobj2 = tem;\n@@ -1819,9 +1819,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)\n \n   /* Check if base is a global static variable that is not read\n      by the function.  */\n-  if (callee != NULL_TREE\n-      && TREE_CODE (base) == VAR_DECL\n-      && TREE_STATIC (base))\n+  if (callee != NULL_TREE && VAR_P (base) && TREE_STATIC (base))\n     {\n       struct cgraph_node *node = cgraph_node::get (callee);\n       bitmap not_read;\n@@ -2208,9 +2206,7 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n \n   /* Check if base is a global static variable that is not written\n      by the function.  */\n-  if (callee != NULL_TREE\n-      && TREE_CODE (base) == VAR_DECL\n-      && TREE_STATIC (base))\n+  if (callee != NULL_TREE && VAR_P (base) && TREE_STATIC (base))\n     {\n       struct cgraph_node *node = cgraph_node::get (callee);\n       bitmap not_written;"}, {"sha": "7b9814e1aa72b9b829701bb54f0d7438ba7e8a7f", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1093,7 +1093,7 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n       && is_gimple_val (gimple_assign_rhs1 (stmt)))\n     {\n       tree lhs = gimple_assign_lhs (stmt);\n-      if ((TREE_CODE (lhs) == VAR_DECL || TREE_CODE (lhs) == PARM_DECL)\n+      if ((VAR_P (lhs) || TREE_CODE (lhs) == PARM_DECL)\n \t  && !DECL_IGNORED_P (lhs)\n \t  && is_gimple_reg_type (TREE_TYPE (lhs))\n \t  && !is_global_var (lhs)"}, {"sha": "b9eef201ddd8ce1b9a96fc8b9a24dee3f3c6b438", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -329,7 +329,7 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n   /* Only need to mark VAR_DECLS; parameters and return results are not\n      eliminated as unused.  */\n-  if (TREE_CODE (t) == VAR_DECL)\n+  if (VAR_P (t))\n     {\n       /* When a global var becomes used for the first time also walk its\n          initializer (non global ones don't have any).  */\n@@ -425,7 +425,7 @@ remove_unused_scope_block_p (tree scope, bool in_ctor_dtor_block)\n \t SET_DEST overlaps with others, and if the value expr changes\n \t by virtual register instantiation, we may get end up with\n \t different results.  */\n-      else if (TREE_CODE (*t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (*t))\n+      else if (VAR_P (*t) && DECL_HAS_VALUE_EXPR_P (*t))\n \tunused = false;\n \n       /* Remove everything we don't generate debug info for.  */\n@@ -791,7 +791,7 @@ remove_unused_locals (void)\n \t\ttree base = get_base_address (lhs);\n \t\t/* Remove clobbers referencing unused vars, or clobbers\n \t\t   with MEM_REF lhs referencing uninitialized pointers.  */\n-\t\tif ((TREE_CODE (base) == VAR_DECL && !is_used_p (base))\n+\t\tif ((VAR_P (base) && !is_used_p (base))\n \t\t    || (TREE_CODE (lhs) == MEM_REF\n \t\t\t&& TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME\n \t\t\t&& SSA_NAME_IS_DEFAULT_DEF (TREE_OPERAND (lhs, 0))\n@@ -825,7 +825,7 @@ remove_unused_locals (void)\n   for (srcidx = 0, dstidx = 0; srcidx < num; srcidx++)\n     {\n       var = (*cfun->local_decls)[srcidx];\n-      if (TREE_CODE (var) == VAR_DECL)\n+      if (VAR_P (var))\n \t{\n \t  if (!is_used_p (var))\n \t    {\n@@ -842,9 +842,7 @@ remove_unused_locals (void)\n \t      continue;\n \t    }\n \t}\n-      if (TREE_CODE (var) == VAR_DECL\n-\t  && DECL_HARD_REGISTER (var)\n-\t  && !is_global_var (var))\n+      if (VAR_P (var) && DECL_HARD_REGISTER (var) && !is_global_var (var))\n \tcfun->has_local_explicit_reg_vars = true;\n \n       if (srcidx != dstidx)"}, {"sha": "93626fd028ff4da048627e61788cd7bcaa0a1f75", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -4383,7 +4383,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n \t{\n \t  tree obj = TREE_OPERAND (expr, 0);\n \n-\t  if (TREE_CODE (obj) == VAR_DECL\n+\t  if (VAR_P (obj)\n \t      || TREE_CODE (obj) == PARM_DECL\n \t      || TREE_CODE (obj) == RESULT_DECL)\n \t    return comp_cost (symbol_cost [speed], 0);\n@@ -4530,7 +4530,7 @@ split_address_cost (struct ivopts_data *data,\n   if (toffset != 0\n       || bitpos % BITS_PER_UNIT != 0\n       || reversep\n-      || TREE_CODE (core) != VAR_DECL)\n+      || !VAR_P (core))\n     {\n       *symbol_present = false;\n       *var_present = true;"}, {"sha": "2a4ab2f4dc639cf7e9e40ea45793a93704848256", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -385,8 +385,7 @@ new_var_info (tree t, const char *name, bool add_id)\n     ret->is_global_var = (is_global_var (t)\n \t\t\t  /* We have to treat even local register variables\n \t\t\t     as escape points.  */\n-\t\t\t  || (TREE_CODE (t) == VAR_DECL\n-\t\t\t      && DECL_HARD_REGISTER (t)));\n+\t\t\t  || (VAR_P (t) && DECL_HARD_REGISTER (t)));\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = NULL;\n   ret->next = 0;\n@@ -2929,8 +2928,7 @@ get_constraint_for_ssa_var (tree t, vec<ce_s> *results, bool address_p)\n     }\n \n   /* For global variables resort to the alias target.  */\n-  if (TREE_CODE (t) == VAR_DECL\n-      && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n+  if (VAR_P (t) && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       varpool_node *node = varpool_node::get (t);\n       if (node && node->alias && node->analyzed)\n@@ -6043,7 +6041,7 @@ create_variable_info_for (tree decl, const char *name, bool add_id)\n \n   insert_vi_for_tree (decl, vi);\n \n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     return id;\n \n   /* Create initial constraints for globals.  */\n@@ -6319,7 +6317,7 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt,\n       if (vi->is_restrict_var)\n \tpt->vars_contains_restrict = true;\n \n-      if (TREE_CODE (vi->decl) == VAR_DECL\n+      if (VAR_P (vi->decl)\n \t  || TREE_CODE (vi->decl) == PARM_DECL\n \t  || TREE_CODE (vi->decl) == RESULT_DECL)\n \t{\n@@ -7290,7 +7288,7 @@ visit_loadstore (gimple *, tree base, tree ref, void *data)\n \n   /* For plain decl accesses see whether they are accesses to globals\n      and rewrite them to MEM_REFs with { clique, 0 }.  */\n-  if (TREE_CODE (base) == VAR_DECL\n+  if (VAR_P (base)\n       && is_global_var (base)\n       /* ???  We can't rewrite a plain decl with the walk_stmt_load_store\n \t ops callback.  */\n@@ -7299,7 +7297,7 @@ visit_loadstore (gimple *, tree base, tree ref, void *data)\n       tree *basep = &ref;\n       while (handled_component_p (*basep))\n \tbasep = &TREE_OPERAND (*basep, 0);\n-      gcc_assert (TREE_CODE (*basep) == VAR_DECL);\n+      gcc_assert (VAR_P (*basep));\n       tree ptr = build_fold_addr_expr (*basep);\n       tree zero = build_int_cst (TREE_TYPE (ptr), 0);\n       *basep = build2 (MEM_REF, TREE_TYPE (*basep), ptr, zero);"}, {"sha": "13448548e0e00d5b61cdc1ebdcd75cb168a3f58b", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -244,7 +244,7 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t      tree base = get_base_address (rhs);\n \n \t      /* Do not warn if it can be initialized outside this function.  */\n-\t      if (TREE_CODE (base) != VAR_DECL\n+\t      if (!VAR_P (base)\n \t\t  || DECL_HARD_REGISTER (base)\n \t\t  || is_global_var (base))\n \t\tcontinue;"}, {"sha": "135952bc33949afe1a7e4faca6a09170d456ab3d", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -246,8 +246,7 @@ target_for_debug_bind (tree var)\n \treturn NULL_TREE;\n     }\n \n-  if ((TREE_CODE (var) != VAR_DECL\n-       || VAR_DECL_IS_VIRTUAL_OPERAND (var))\n+  if ((!VAR_P (var) || VAR_DECL_IS_VIRTUAL_OPERAND (var))\n       && TREE_CODE (var) != PARM_DECL)\n     return NULL_TREE;\n \n@@ -974,7 +973,7 @@ verify_phi_args (gphi *phi, basic_block bb, basic_block *definition_block)\n \t  tree base = TREE_OPERAND (op, 0);\n \t  while (handled_component_p (base))\n \t    base = TREE_OPERAND (base, 0);\n-\t  if ((TREE_CODE (base) == VAR_DECL\n+\t  if ((VAR_P (base)\n \t       || TREE_CODE (base) == PARM_DECL\n \t       || TREE_CODE (base) == RESULT_DECL)\n \t      && !TREE_ADDRESSABLE (base))\n@@ -1246,7 +1245,7 @@ ssa_undefined_value_p (tree t, bool partial)\n   else if (TREE_CODE (var) == RESULT_DECL && DECL_BY_REFERENCE (var))\n     return false;\n   /* Hard register variables get their initial value from the ether.  */\n-  else if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n+  else if (VAR_P (var) && DECL_HARD_REGISTER (var))\n     return false;\n \n   /* The value is undefined iff its definition statement is empty.  */\n@@ -1538,7 +1537,7 @@ maybe_optimize_var (tree var, bitmap addresses_taken, bitmap not_reg_needs,\n       && (TREE_CODE (TREE_TYPE (var)) == COMPLEX_TYPE\n \t  || TREE_CODE (TREE_TYPE (var)) == VECTOR_TYPE)\n       && !TREE_THIS_VOLATILE (var)\n-      && (TREE_CODE (var) != VAR_DECL || !DECL_HARD_REGISTER (var)))\n+      && (!VAR_P (var) || !DECL_HARD_REGISTER (var)))\n     {\n       DECL_GIMPLE_REG_P (var) = 1;\n       bitmap_set_bit (suitable_for_renaming, DECL_UID (var));"}, {"sha": "64ab13a20487e95541dcd8d39b4dea4bdd386c23", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -260,7 +260,7 @@ make_ssa_name_fn (struct function *fn, tree var, gimple *stmt)\n   tree t;\n   use_operand_p imm;\n \n-  gcc_assert (TREE_CODE (var) == VAR_DECL\n+  gcc_assert (VAR_P (var)\n \t      || TREE_CODE (var) == PARM_DECL\n \t      || TREE_CODE (var) == RESULT_DECL\n \t      || (TYPE_P (var) && is_gimple_reg_type (var)));"}, {"sha": "ba7ee8cdd7a6cab546fbe27f44bc53dfcf077343", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -273,7 +273,7 @@ find_va_list_reference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (bitmap_bit_p (va_list_vars, SSA_NAME_VERSION (var)))\n \treturn var;\n     }\n-  else if (TREE_CODE (var) == VAR_DECL)\n+  else if (VAR_P (var))\n     {\n       if (bitmap_bit_p (va_list_vars, DECL_UID (var) + num_ssa_names))\n \treturn var;\n@@ -358,7 +358,7 @@ va_list_counter_struct_op (struct stdarg_info *si, tree ap, tree var,\n     return false;\n \n   base = get_base_address (ap);\n-  if (TREE_CODE (base) != VAR_DECL\n+  if (!VAR_P (base)\n       || !bitmap_bit_p (si->va_list_vars, DECL_UID (base) + num_ssa_names))\n     return false;\n \n@@ -377,7 +377,7 @@ va_list_counter_struct_op (struct stdarg_info *si, tree ap, tree var,\n static bool\n va_list_ptr_read (struct stdarg_info *si, tree ap, tree tem)\n {\n-  if (TREE_CODE (ap) != VAR_DECL\n+  if (!VAR_P (ap)\n       || !bitmap_bit_p (si->va_list_vars, DECL_UID (ap) + num_ssa_names))\n     return false;\n \n@@ -427,7 +427,7 @@ va_list_ptr_write (struct stdarg_info *si, tree ap, tree tem2)\n {\n   unsigned HOST_WIDE_INT increment;\n \n-  if (TREE_CODE (ap) != VAR_DECL\n+  if (!VAR_P (ap)\n       || !bitmap_bit_p (si->va_list_vars, DECL_UID (ap) + num_ssa_names))\n     return false;\n \n@@ -622,7 +622,7 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t\t\t\t\t   SSA_NAME_VERSION (lhs)))\n \t\t\tcontinue;\n \n-\t\t      if (TREE_CODE (lhs) == VAR_DECL\n+\t\t      if (VAR_P (lhs)\n \t\t\t  && bitmap_bit_p (si->va_list_vars,\n \t\t\t\t\t   DECL_UID (lhs) + num_ssa_names))\n \t\t\tcontinue;\n@@ -731,7 +731,7 @@ optimize_va_list_gpr_fpr_size (function *fun)\n \t    }\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (ap))\n \t      != TYPE_MAIN_VARIANT (targetm.fn_abi_va_list (fun->decl))\n-\t      || TREE_CODE (ap) != VAR_DECL)\n+\t      || !VAR_P (ap))\n \t    {\n \t      va_list_escapes = true;\n \t      break;"}, {"sha": "e5cc5a05045de133d5823b9039e0ec0b042d84c9", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -251,19 +251,18 @@ unpack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n       expr->decl_common.off_align = bp_unpack_value (bp, 8);\n     }\n \n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     {\n       DECL_HAS_DEBUG_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n       DECL_NONLOCAL_FRAME (expr) = (unsigned) bp_unpack_value (bp, 1);\n     }\n \n   if (TREE_CODE (expr) == RESULT_DECL\n       || TREE_CODE (expr) == PARM_DECL\n-      || TREE_CODE (expr) == VAR_DECL)\n+      || VAR_P (expr))\n     {\n       DECL_BY_REFERENCE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  || TREE_CODE (expr) == PARM_DECL)\n+      if (VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n \tDECL_HAS_VALUE_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n     }\n }\n@@ -293,7 +292,7 @@ unpack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n   DECL_VISIBILITY (expr) = (enum symbol_visibility) bp_unpack_value (bp,  2);\n   DECL_VISIBILITY_SPECIFIED (expr) = (unsigned) bp_unpack_value (bp,  1);\n \n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     {\n       DECL_HARD_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n       DECL_IN_CONSTANT_POOL (expr) = (unsigned) bp_unpack_value (bp, 1);\n@@ -712,12 +711,11 @@ lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n \n-  if ((TREE_CODE (expr) == VAR_DECL\n-       || TREE_CODE (expr) == PARM_DECL)\n+  if ((VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))\n     SET_DECL_VALUE_EXPR (expr, stream_read_tree (ib, data_in));\n \n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     {\n       tree dexpr = stream_read_tree (ib, data_in);\n       if (dexpr)"}, {"sha": "cedeabc334b4e1f067fb381189339413f95a4042", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -214,19 +214,18 @@ pack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n       bp_pack_value (bp, expr->decl_common.off_align, 8);\n     }\n \n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     {\n       bp_pack_value (bp, DECL_HAS_DEBUG_EXPR_P (expr), 1);\n       bp_pack_value (bp, DECL_NONLOCAL_FRAME (expr), 1);\n     }\n \n   if (TREE_CODE (expr) == RESULT_DECL\n       || TREE_CODE (expr) == PARM_DECL\n-      || TREE_CODE (expr) == VAR_DECL)\n+      || VAR_P (expr))\n     {\n       bp_pack_value (bp, DECL_BY_REFERENCE (expr), 1);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  || TREE_CODE (expr) == PARM_DECL)\n+      if (VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n \tbp_pack_value (bp, DECL_HAS_VALUE_EXPR_P (expr), 1);\n     }\n }\n@@ -256,7 +255,7 @@ pack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n   bp_pack_value (bp, DECL_VISIBILITY (expr),  2);\n   bp_pack_value (bp, DECL_VISIBILITY_SPECIFIED (expr),  1);\n \n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     {\n       bp_pack_value (bp, DECL_HARD_REGISTER (expr), 1);\n       /* DECL_IN_TEXT_SECTION is set during final asm output only. */\n@@ -589,12 +588,11 @@ write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n \n-  if ((TREE_CODE (expr) == VAR_DECL\n-       || TREE_CODE (expr) == PARM_DECL)\n+  if ((VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))\n     stream_write_tree (ob, DECL_VALUE_EXPR (expr), ref_p);\n \n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     stream_write_tree (ob, DECL_DEBUG_EXPR (expr), ref_p);\n }\n "}, {"sha": "6cf26d9c367d6152f2c5cd8c598908d0af0005ca", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -5977,7 +5977,7 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n bool\n vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n {\n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     return false;\n \n   if (decl_in_symtab_p (decl)"}, {"sha": "949d2ebe7efd57b25b8458226d6ff9bcdf68493b", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -716,7 +716,7 @@ set_decl_section_name (tree node, const char *value)\n       if (!snode)\n \treturn;\n     }\n-  else if (TREE_CODE (node) == VAR_DECL)\n+  else if (VAR_P (node))\n     snode = varpool_node::get_create (node);\n   else\n     snode = cgraph_node::get_create (node);\n@@ -1156,19 +1156,19 @@ copy_node_stat (tree node MEM_STAT_DECL)\n \t  if (DECL_PT_UID_SET_P (node))\n \t    SET_DECL_PT_UID (t, DECL_PT_UID (node));\n \t}\n-      if ((TREE_CODE (node) == PARM_DECL || TREE_CODE (node) == VAR_DECL)\n+      if ((TREE_CODE (node) == PARM_DECL || VAR_P (node))\n \t  && DECL_HAS_VALUE_EXPR_P (node))\n \t{\n \t  SET_DECL_VALUE_EXPR (t, DECL_VALUE_EXPR (node));\n \t  DECL_HAS_VALUE_EXPR_P (t) = 1;\n \t}\n       /* DECL_DEBUG_EXPR is copied explicitely by callers.  */\n-      if (TREE_CODE (node) == VAR_DECL)\n+      if (VAR_P (node))\n \t{\n \t  DECL_HAS_DEBUG_EXPR_P (t) = 0;\n \t  t->decl_with_vis.symtab_node = NULL;\n \t}\n-      if (TREE_CODE (node) == VAR_DECL && DECL_HAS_INIT_PRIORITY_P (node))\n+      if (VAR_P (node) && DECL_HAS_INIT_PRIORITY_P (node))\n \t{\n \t  SET_DECL_INIT_PRIORITY (t, DECL_INIT_PRIORITY (node));\n \t  DECL_HAS_INIT_PRIORITY_P (t) = 1;\n@@ -5330,8 +5330,7 @@ need_assembler_name_p (tree decl)\n       && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n     return !DECL_ASSEMBLER_NAME_SET_P (decl);\n   /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n-  if (TREE_CODE (decl) != FUNCTION_DECL\n-      && TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (decl))\n     return false;\n \n   /* If DECL already has its assembler name set, it does not need a\n@@ -5346,7 +5345,7 @@ need_assembler_name_p (tree decl)\n \n   /* For VAR_DECLs, only static, public and external symbols need an\n      assembler name.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && !TREE_STATIC (decl)\n       && !TREE_PUBLIC (decl)\n       && !DECL_EXTERNAL (decl))\n@@ -5460,7 +5459,7 @@ free_lang_data_in_decl (tree decl)\n       if (DECL_VINDEX (decl) && !tree_fits_shwi_p (DECL_VINDEX (decl)))\n \tDECL_VINDEX (decl) = NULL_TREE;\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_P (decl))\n     {\n       if ((DECL_EXTERNAL (decl)\n \t   && (!TREE_STATIC (decl) || !TREE_READONLY (decl)))\n@@ -5632,7 +5631,7 @@ find_decls_types_r (tree *tp, int *ws, void *data)\n \t  fld_worklist_push (DECL_FCONTEXT (t), fld);\n \t}\n \n-      if ((TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+      if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t  && DECL_HAS_VALUE_EXPR_P (t))\n \tfld_worklist_push (DECL_VALUE_EXPR (t), fld);\n \n@@ -6329,14 +6328,13 @@ merge_dllimport_decl_attributes (tree old, tree new_tree)\n \t      decl may already have had TREE_CONSTANT computed.\n \t      We still remove the attribute so that assembler code refers\n \t      to '&foo rather than '_imp__foo'.  */\n-\t  if (TREE_CODE (old) == VAR_DECL && TREE_ADDRESSABLE (old))\n+\t  if (VAR_P (old) && TREE_ADDRESSABLE (old))\n \t    DECL_DLLIMPORT_P (new_tree) = 1;\n \t}\n \n       /* Let an inline definition silently override the external reference,\n \t but otherwise warn about attribute inconsistency.  */\n-      else if (TREE_CODE (new_tree) == VAR_DECL\n-\t       || !DECL_DECLARED_INLINE_P (new_tree))\n+      else if (VAR_P (new_tree) || !DECL_DECLARED_INLINE_P (new_tree))\n \twarning (OPT_Wattributes, \"%q+D redeclared without dllimport attribute: \"\n \t\t  \"previous dllimport ignored\", new_tree);\n     }\n@@ -6387,9 +6385,7 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n \t}\n     }\n \n-  if (TREE_CODE (node) != FUNCTION_DECL\n-      && TREE_CODE (node) != VAR_DECL\n-      && TREE_CODE (node) != TYPE_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (node) && TREE_CODE (node) != TYPE_DECL)\n     {\n       *no_add_attrs = true;\n       warning (OPT_Wattributes, \"%qE attribute ignored\",\n@@ -6432,7 +6428,7 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n \t  *no_add_attrs = true;\n \t}\n \n-     else if (TREE_CODE (node) == VAR_DECL)\n+     else if (VAR_P (node))\n \t{\n \t  if (DECL_INITIAL (node))\n \t    {\n@@ -6460,9 +6456,7 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n     DECL_EXTERNAL (node) = 0;\n \n   /*  Report error if symbol is not accessible at global scope.  */\n-  if (!TREE_PUBLIC (node)\n-      && (TREE_CODE (node) == VAR_DECL\n-\t  || TREE_CODE (node) == FUNCTION_DECL))\n+  if (!TREE_PUBLIC (node) && VAR_OR_FUNCTION_DECL_P (node))\n     {\n       error (\"external linkage required for symbol %q+D because of \"\n \t     \"%qE attribute\", node, name);\n@@ -6822,7 +6816,7 @@ decl_init_priority_insert (tree decl, priority_type priority)\n       if (!snode)\n \treturn;\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_P (decl))\n     snode = varpool_node::get_create (decl);\n   else\n     snode = cgraph_node::get_create (decl);\n@@ -9196,7 +9190,7 @@ bool\n auto_var_in_fn_p (const_tree var, const_tree fn)\n {\n   return (DECL_P (var) && DECL_CONTEXT (var) == fn\n-\t  && ((((TREE_CODE (var) == VAR_DECL && ! DECL_EXTERNAL (var))\n+\t  && ((((VAR_P (var) && ! DECL_EXTERNAL (var))\n \t\t|| TREE_CODE (var) == PARM_DECL)\n \t       && ! TREE_STATIC (var))\n \t      || TREE_CODE (var) == LABEL_DECL\n@@ -13139,7 +13133,7 @@ array_at_struct_end_p (tree ref)\n       && (!size || (DECL_SIZE (ref) != NULL\n \t\t    && operand_equal_p (DECL_SIZE (ref), size, 0)))\n       && !(flag_unconstrained_commons\n-\t   && TREE_CODE (ref) == VAR_DECL && DECL_COMMON (ref)))\n+\t   && VAR_P (ref) && DECL_COMMON (ref)))\n     return false;\n \n   return true;\n@@ -13971,7 +13965,7 @@ verify_type (const_tree t)\n \t    ;\n \t  else if (TREE_CODE (fld) == CONST_DECL)\n \t    ;\n-\t  else if (TREE_CODE (fld) == VAR_DECL)\n+\t  else if (VAR_P (fld))\n \t    ;\n \t  else if (TREE_CODE (fld) == TEMPLATE_DECL)\n \t    ;"}, {"sha": "317bf6d2dac464028a96413b6b938e6f0e1f692b", "filename": "gcc/tsan.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -128,9 +128,7 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n \treturn false;\n     }\n \n-  if (TREE_READONLY (base)\n-      || (TREE_CODE (base) == VAR_DECL\n-\t  && DECL_HARD_REGISTER (base)))\n+  if (TREE_READONLY (base) || (VAR_P (base) && DECL_HARD_REGISTER (base)))\n     return false;\n \n   stmt = gsi_stmt (gsi);"}, {"sha": "5fe6f3d0e2a393aee963974d7ab95256ad4b557d", "filename": "gcc/ubsan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1369,7 +1369,7 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n \t\t\t\t   &unsignedp, &reversep, &volatilep);\n   tree utype = build_nonstandard_integer_type (modebitsize, 1);\n \n-  if ((TREE_CODE (base) == VAR_DECL && DECL_HARD_REGISTER (base))\n+  if ((VAR_P (base) && DECL_HARD_REGISTER (base))\n       || (bitpos % modebitsize) != 0\n       || bitsize != modebitsize\n       || GET_MODE_BITSIZE (TYPE_MODE (utype)) != modebitsize"}, {"sha": "e405f0d81b3b07fdf9683c6f533a96df331e3aab", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -1810,8 +1810,7 @@ vars_copy (variable_table_type *dst, variable_table_type *src)\n static inline tree\n var_debug_decl (tree decl)\n {\n-  if (decl && TREE_CODE (decl) == VAR_DECL\n-      && DECL_HAS_DEBUG_EXPR_P (decl))\n+  if (decl && VAR_P (decl) && DECL_HAS_DEBUG_EXPR_P (decl))\n     {\n       tree debugdecl = DECL_DEBUG_EXPR (decl);\n       if (DECL_P (debugdecl))\n@@ -5145,7 +5144,7 @@ track_expr_p (tree expr, bool need_rtl)\n     return DECL_RTL_SET_P (expr);\n \n   /* If EXPR is not a parameter or a variable do not track it.  */\n-  if (TREE_CODE (expr) != VAR_DECL && TREE_CODE (expr) != PARM_DECL)\n+  if (!VAR_P (expr) && TREE_CODE (expr) != PARM_DECL)\n     return 0;\n \n   /* It also must have a name...  */\n@@ -5161,7 +5160,7 @@ track_expr_p (tree expr, bool need_rtl)\n      don't need to track this expression if the ultimate declaration is\n      ignored.  */\n   realdecl = expr;\n-  if (TREE_CODE (realdecl) == VAR_DECL && DECL_HAS_DEBUG_EXPR_P (realdecl))\n+  if (VAR_P (realdecl) && DECL_HAS_DEBUG_EXPR_P (realdecl))\n     {\n       realdecl = DECL_DEBUG_EXPR (realdecl);\n       if (!DECL_P (realdecl))"}, {"sha": "a03687210c0b3b7d62a8704ccfcf4f93acc2ed1f", "filename": "gcc/varasm.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -170,8 +170,7 @@ static GTY(()) section *unnamed_sections;\n \n /* Return a nonzero value if DECL has a section attribute.  */\n #define IN_NAMED_SECTION(DECL) \\\n-  ((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \\\n-   && DECL_SECTION_NAME (DECL) != NULL)\n+  (VAR_OR_FUNCTION_DECL_P (DECL) && DECL_SECTION_NAME (DECL) != NULL)\n \n struct section_hasher : ggc_ptr_hash<section>\n {\n@@ -1188,7 +1187,7 @@ get_block_for_decl (tree decl)\n {\n   section *sect;\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       /* The object must be defined in this translation unit.  */\n       if (DECL_EXTERNAL (decl))\n@@ -1209,7 +1208,7 @@ get_block_for_decl (tree decl)\n \n   /* Find out which section should contain DECL.  We cannot put it into\n      an object block if it requires a standalone definition.  */\n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n       align_variable (decl, 0);\n   sect = get_variable_section (decl, true);\n   if (SECTION_STYLE (sect) == SECTION_NOSWITCH)\n@@ -1238,7 +1237,7 @@ use_blocks_for_decl_p (tree decl)\n   struct symtab_node *snode;\n \n   /* Only data DECLs can be placed into object blocks.  */\n-  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != CONST_DECL)\n+  if (!VAR_P (decl) && TREE_CODE (decl) != CONST_DECL)\n     return false;\n \n   /* Detect decls created by dw2_force_const_mem.  Such decls are\n@@ -1250,7 +1249,7 @@ use_blocks_for_decl_p (tree decl)\n \n   /* If this decl is an alias, then we don't want to emit a\n      definition.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && (snode = symtab_node::get (decl)) != NULL\n       && snode->alias)\n     return false;\n@@ -1304,7 +1303,7 @@ make_decl_rtl (tree decl)\n \t      && TREE_CODE (decl) != RESULT_DECL);\n \n   /* A weak alias has TREE_PUBLIC set but not the other bits.  */\n-  gcc_assert (TREE_CODE (decl) != VAR_DECL\n+  gcc_assert (!VAR_P (decl)\n \t      || TREE_STATIC (decl)\n \t      || TREE_PUBLIC (decl)\n \t      || DECL_EXTERNAL (decl)\n@@ -1348,7 +1347,7 @@ make_decl_rtl (tree decl)\n \n   /* If this variable belongs to the global constant pool, retrieve the\n      pre-computed RTL or recompute it in LTO mode.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_IN_CONSTANT_POOL (decl))\n+  if (VAR_P (decl) && DECL_IN_CONSTANT_POOL (decl))\n     {\n       SET_DECL_RTL (decl, output_constant_def (DECL_INITIAL (decl), 1));\n       return;\n@@ -1457,15 +1456,15 @@ make_decl_rtl (tree decl)\n      visibility pass is doing the same work.  But notice_global_symbol\n      is called early and it needs to make DECL_RTL to get the name.\n      we take care of recomputing the DECL_RTL after visibility is changed.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n       && DECL_SECTION_NAME (decl) != NULL\n       && DECL_INITIAL (decl) == NULL_TREE\n       && DECL_COMMON (decl))\n     DECL_COMMON (decl) = 0;\n \n   /* Variables can't be both common and weak.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_WEAK (decl))\n+  if (VAR_P (decl) && DECL_WEAK (decl))\n     DECL_COMMON (decl) = 0;\n \n   if (use_object_blocks_p () && use_blocks_for_decl_p (decl))\n@@ -1639,9 +1638,9 @@ notice_global_symbol (tree decl)\n       || !TREE_PUBLIC (decl)\n       || DECL_EXTERNAL (decl)\n       || !DECL_NAME (decl)\n-      || (TREE_CODE (decl) == VAR_DECL && DECL_HARD_REGISTER (decl))\n+      || (VAR_P (decl) && DECL_HARD_REGISTER (decl))\n       || (TREE_CODE (decl) != FUNCTION_DECL\n-\t  && (TREE_CODE (decl) != VAR_DECL\n+\t  && (!VAR_P (decl)\n \t      || (DECL_COMMON (decl)\n \t\t  && (DECL_INITIAL (decl) == 0\n \t\t      || DECL_INITIAL (decl) == error_mark_node)))))\n@@ -2111,7 +2110,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   bool asan_protected = false;\n \n   /* This function is supposed to handle VARIABLES.  Ensure we have one.  */\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n \n   /* Emulated TLS had better not get this far.  */\n   gcc_checking_assert (targetm.have_tls || !DECL_THREAD_LOCAL_P (decl));\n@@ -2487,7 +2486,7 @@ mark_decl_referenced (tree decl)\n \t  && !node->definition)\n \tnode->mark_force_output ();\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_P (decl))\n     {\n       varpool_node *node = varpool_node::get_create (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n@@ -3272,8 +3271,7 @@ build_constant_desc (tree exp)\n   if (use_object_blocks_p ())\n     {\n       int align = (TREE_CODE (decl) == CONST_DECL\n-\t\t   || (TREE_CODE (decl) == VAR_DECL\n-\t\t       && DECL_IN_CONSTANT_POOL (decl))\n+\t\t   || (VAR_P (decl) && DECL_IN_CONSTANT_POOL (decl))\n \t\t   ? DECL_ALIGN (decl)\n \t\t   : symtab_node::get (decl)->definition_alignment ());\n       section *sect = get_constant_section (exp, align);\n@@ -3430,8 +3428,7 @@ output_constant_def_contents (rtx symbol)\n   else\n     {\n       int align = (TREE_CODE (decl) == CONST_DECL\n-\t\t   || (TREE_CODE (decl) == VAR_DECL\n-\t\t       && DECL_IN_CONSTANT_POOL (decl))\n+\t\t   || (VAR_P (decl) && DECL_IN_CONSTANT_POOL (decl))\n \t\t   ? DECL_ALIGN (decl)\n \t\t   : symtab_node::get (decl)->definition_alignment ());\n       switch_to_section (get_constant_section (exp, align));\n@@ -5619,7 +5616,7 @@ do_assemble_alias (tree decl, tree target)\n \n   /* Emulated TLS had better not get this var.  */\n   gcc_assert (!(!targetm.have_tls\n-\t\t&& TREE_CODE (decl) == VAR_DECL\n+\t\t&& VAR_P (decl)\n \t\t&& DECL_THREAD_LOCAL_P (decl)));\n \n   if (TREE_ASM_WRITTEN (decl))\n@@ -6022,12 +6019,11 @@ void\n make_decl_one_only (tree decl, tree comdat_group)\n {\n   struct symtab_node *symbol;\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      || TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n \n   TREE_PUBLIC (decl) = 1;\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     symbol = varpool_node::get_create (decl);\n   else\n     symbol = cgraph_node::get_create (decl);\n@@ -6039,7 +6035,7 @@ make_decl_one_only (tree decl, tree comdat_group)\n #endif\n       symbol->set_comdat_group (comdat_group);\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL\n+  else if (VAR_P (decl)\n            && (DECL_INITIAL (decl) == 0\n \t       || (!in_lto_p && DECL_INITIAL (decl) == error_mark_node)))\n     DECL_COMMON (decl) = 1;\n@@ -6190,7 +6186,7 @@ default_section_type_flags (tree decl, const char *name, int reloc)\n   if (strcmp (name, \".vtable_map_vars\") == 0)\n     flags |= SECTION_LINKONCE;\n \n-  if (decl && TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+  if (decl && VAR_P (decl) && DECL_THREAD_LOCAL_P (decl))\n     flags |= SECTION_TLS | SECTION_WRITE;\n \n   if (strcmp (name, \".bss\") == 0\n@@ -6412,7 +6408,7 @@ categorize_decl_for_section (const_tree decl, int reloc)\n       else\n \treturn SECCAT_RODATA_MERGE_STR;\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_P (decl))\n     {\n       if (bss_initializer_p (decl))\n \tret = SECCAT_BSS;\n@@ -6456,7 +6452,7 @@ categorize_decl_for_section (const_tree decl, int reloc)\n     ret = SECCAT_RODATA;\n \n   /* There are no read-only thread-local sections.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+  if (VAR_P (decl) && DECL_THREAD_LOCAL_P (decl))\n     {\n       /* Note that this would be *just* SECCAT_BSS, except that there's\n \t no concept of a read-only thread-local-data section.  */\n@@ -6732,7 +6728,7 @@ default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n     flags |= SYMBOL_FLAG_FUNCTION;\n   if (targetm.binds_local_p (decl))\n     flags |= SYMBOL_FLAG_LOCAL;\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+  if (VAR_P (decl) && DECL_THREAD_LOCAL_P (decl))\n     flags |= DECL_TLS_MODEL (decl) << SYMBOL_FLAG_TLS_SHIFT;\n   else if (targetm.in_small_data_p (decl))\n     flags |= SYMBOL_FLAG_SMALL;"}, {"sha": "78969d28c1c885500c8dc71edb4be38ff8b9c272", "filename": "gcc/varpool.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -142,7 +142,7 @@ varpool_node *\n varpool_node::get_create (tree decl)\n {\n   varpool_node *node = varpool_node::get (decl);\n-  gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_checking_assert (VAR_P (decl));\n   if (node)\n     return node;\n \n@@ -395,8 +395,7 @@ ctor_for_folding (tree decl)\n   varpool_node *node, *real_node;\n   tree real_decl;\n \n-  if (TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != CONST_DECL)\n+  if (!VAR_P (decl) && TREE_CODE (decl) != CONST_DECL)\n     return error_mark_node;\n \n   /* Static constant bounds are created to be\n@@ -420,7 +419,7 @@ ctor_for_folding (tree decl)\n       return error_mark_node;\n     }\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n \n   real_node = node = varpool_node::get (decl);\n   if (node)\n@@ -579,7 +578,7 @@ varpool_node::assemble_decl (void)\n     return false;\n \n   gcc_checking_assert (!TREE_ASM_WRITTEN (decl)\n-\t\t       && TREE_CODE (decl) == VAR_DECL\n+\t\t       && VAR_P (decl)\n \t\t       && !DECL_HAS_VALUE_EXPR_P (decl));\n \n   if (!in_other_partition\n@@ -713,7 +712,7 @@ varpool_node::finalize_named_section_flags (void)\n       && !alias\n       && !in_other_partition\n       && !DECL_EXTERNAL (decl)\n-      && TREE_CODE (decl) == VAR_DECL\n+      && VAR_P (decl)\n       && !DECL_HAS_VALUE_EXPR_P (decl)\n       && get_section ())\n     get_variable_section (decl, false);\n@@ -768,8 +767,8 @@ varpool_node::create_alias (tree alias, tree decl)\n {\n   varpool_node *alias_node;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n-  gcc_assert (TREE_CODE (alias) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n+  gcc_assert (VAR_P (alias));\n   alias_node = varpool_node::get_create (alias);\n   alias_node->alias = true;\n   alias_node->definition = true;"}, {"sha": "cd3841e533696595a45fad1548210ef1db2af4f9", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8813a647b5f81fb32955f8ec2438d73e9e6280d4/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=8813a647b5f81fb32955f8ec2438d73e9e6280d4", "patch": "@@ -718,7 +718,7 @@ verify_bb_vtables (basic_block bb)\n                   vtable_map_node->is_used = true;\n                   vtbl_var_decl = vtable_map_node->vtbl_map_decl;\n \n-                  if (TREE_CODE (vtbl_decl) == VAR_DECL)\n+                  if (VAR_P (vtbl_decl))\n                     vtable_name = IDENTIFIER_POINTER (DECL_NAME (vtbl_decl));\n \n                   /* Call different routines if we are interested in"}]}