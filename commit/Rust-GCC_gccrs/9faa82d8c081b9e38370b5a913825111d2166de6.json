{"sha": "9faa82d8c081b9e38370b5a913825111d2166de6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhYTgyZDhjMDgxYjllMzgzNzBiNWE5MTM4MjUxMTFkMjE2NmRlNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-16T12:39:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-16T12:39:54Z"}, "message": "Fix typos in comments.\n\nFrom-SVN: r9712", "tree": {"sha": "1e50640eecb618d0b3fa87607094528acb0add62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e50640eecb618d0b3fa87607094528acb0add62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9faa82d8c081b9e38370b5a913825111d2166de6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9faa82d8c081b9e38370b5a913825111d2166de6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9faa82d8c081b9e38370b5a913825111d2166de6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9faa82d8c081b9e38370b5a913825111d2166de6/comments", "author": null, "committer": null, "parents": [{"sha": "ddd5a7c1808995545ad5befaa7320135e60b5d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd5a7c1808995545ad5befaa7320135e60b5d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddd5a7c1808995545ad5befaa7320135e60b5d38"}], "stats": {"total": 190, "additions": 95, "deletions": 95}, "files": [{"sha": "f95678c4aef2b6660d982dd3cae89898d159e777", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -260,7 +260,7 @@ init_dummy ()\n \n    Note that we use some tricks here to get *just* the body and just\n    a function epilogue (but no function prologue) into the .init\n-   section of the crtend.o file.  Sepcifically, we switch to the .text\n+   section of the crtend.o file.  Specifically, we switch to the .text\n    section, start to define a function, and then we switch to the .init\n    section just before the body code.\n "}, {"sha": "7ada45eaa85965e681c89b06e05d4136bec0314b", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -4999,7 +4999,7 @@ fold_rtx (x, insn)\n \t    if (offset == 0 && mode == const_mode)\n \t      return constant;\n \n-\t    /* If this actually isn't a constant (wierd!), we can't do\n+\t    /* If this actually isn't a constant (weird!), we can't do\n \t       anything.  Otherwise, handle the two most common cases:\n \t       extracting a word from a multi-word constant, and extracting\n \t       the low-order bits.  Other cases don't seem common enough to\n@@ -6192,7 +6192,7 @@ cse_insn (insn, in_libcall_block)\n   /* Store the equivalent value in SRC_EQV, if different, or if the DEST\n      is a STRICT_LOW_PART.  The latter condition is necessary because SRC_EQV\n      is handled specially for this case, and if it isn't set, then there will\n-     be no equivalence for the destinatation.  */\n+     be no equivalence for the destination.  */\n   if (n_sets == 1 && REG_NOTES (insn) != 0\n       && (tem = find_reg_note (insn, REG_EQUAL, NULL_RTX)) != 0\n       && (! rtx_equal_p (XEXP (tem, 0), SET_SRC (sets[0].rtl))"}, {"sha": "296cbefda3d2ad17a66a4f6cb666ca677f469d1e", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1957,7 +1957,7 @@ location_attribute (rtl)\n      suppress the generation of the entire location attribute because\n      the absence of a location attribute in certain kinds of DIEs is\n      used to indicate something else entirely... i.e. that the DIE\n-     represents an object declaration, but not a definition.  So sayeth\n+     represents an object declaration, but not a definition.  So saith\n      the PLSIG.\n   */\n \n@@ -2414,7 +2414,7 @@ subscript_data_attribute (type)\n \t}\n     }\n \n-  /* Output the prefix byte that says that the element type is comming up.  */\n+  /* Output the prefix byte that says that the element type is coming up.  */\n \n   ASM_OUTPUT_DWARF_FMT_BYTE (asm_out_file, FMT_ET);\n \n@@ -4524,7 +4524,7 @@ output_decl (decl, containing_scope)\n               }\n             else\n               {\n-\t      /* this is unprotoyped, check for undefined (just declaration) */\n+\t      /* this is unprototyped, check for undefined (just declaration) */\n               if (!DECL_INITIAL (decl))\n                 output_die (output_unspecified_parameters_die, decl);\n               }\n@@ -4555,7 +4555,7 @@ output_decl (decl, containing_scope)\n \n \t       Just within the `outer_scope' there will be another BLOCK\n \t       node representing the function's outermost pair of curly\n-\t       braces.  We musn't generate a lexical_block DIE for this\n+\t       braces.  We mustn't generate a lexical_block DIE for this\n \t       outermost pair of curly braces because that is not really an\n \t       independent scope according to ANSI C rules.  Rather, it is\n \t       the same scope in which the parameters were declared.  */\n@@ -4756,12 +4756,12 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n       /* What we would really like to do here is to filter out all mere\n \t file-scope declarations of file-scope functions which are never\n \t referenced later within this translation unit (and keep all of\n-\t ones that *are* referenced later on) but we aren't clarvoiant,\n+\t ones that *are* referenced later on) but we aren't clairvoyant,\n \t so we have no idea which functions will be referenced in the\n \t future (i.e. later on within the current translation unit).\n \t So here we just ignore all file-scope function declarations\n \t which are not also definitions.  If and when the debugger needs\n-\t to know something about these funcstion, it wil have to hunt\n+\t to know something about these functions, it wil have to hunt\n \t around and find the DWARF information associated with the\n \t *definition* of the function.\n "}, {"sha": "383f1ea3e7b5306425999941a2a2d3c896431a23", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1598,7 +1598,7 @@ reset_used_flags (x)\n \n   code = GET_CODE (x);\n \n-  /* These types may be freely shared so we needn't do any reseting\n+  /* These types may be freely shared so we needn't do any resetting\n      for them.  */\n \n   switch (code)\n@@ -3060,8 +3060,8 @@ gen_sequence ()\n     sequence_result[len] = 0;\n   else\n     {\n-      /* Ensure that this rtl goes in saveable_obstack, since we may be\n-\t caching it.  */\n+      /* Ensure that this rtl goes in saveable_obstack, since we may\n+\t cache it.  */\n       push_obstacks_nochange ();\n       rtl_in_saveable_obstack ();\n       result = gen_rtx (SEQUENCE, VOIDmode, rtvec_alloc (len));"}, {"sha": "2985db2b64e20deaa1b8fbd1ac0934e449edf023", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -982,7 +982,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n      int known_align;\n {\n   /* If we're asking for zero bytes, it doesn't matter what we point\n-     to since we can't derefference it.  But return a reasonable\n+     to since we can't dereference it.  But return a reasonable\n      address anyway.  */\n   if (size == const0_rtx)\n     return virtual_stack_dynamic_rtx;"}, {"sha": "3a7bbe75bf0552b96e35c9a6d5fd941aebe7c274", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2811,7 +2811,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n   last = get_last_insn ();\n \n-  /* Promote floor rouding to trunc rounding for unsigned operations.  */\n+  /* Promote floor rounding to trunc rounding for unsigned operations.  */\n   if (unsignedp)\n     {\n       if (code == FLOOR_DIV_EXPR)"}, {"sha": "d4fc8fe8176c1ed78e49644aa66d69d0db780719", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -3149,7 +3149,7 @@ store_constructor (exp, target)\n       tree domain = TYPE_DOMAIN (type);\n       tree domain_min, domain_max, bitlength;\n \n-      /* The default implementation stategy is to extract the constant\n+      /* The default implementation strategy is to extract the constant\n \t parts of the constructor, use that to initialize the target,\n \t and then \"or\" in whatever non-constant ranges we need in addition.\n \n@@ -3274,7 +3274,7 @@ store_constructor (exp, target)\n \n #ifdef TARGET_MEM_FUNCTIONS\n \t  /* Optimization:  If startbit and endbit are\n-\t     constants divisble by BITS_PER_UNIT,\n+\t     constants divisible by BITS_PER_UNIT,\n \t     call memset instead. */\n \t  if (TREE_CODE (startbit) == INTEGER_CST\n \t      && TREE_CODE (endbit) == INTEGER_CST\n@@ -7955,7 +7955,7 @@ static enum machine_mode apply_result_mode[FIRST_PSEUDO_REGISTER];\n \n /* For each register that may be used for calling a function, this\n    gives the offset of that register into the block returned by\n-   __bultin_apply_args.  0 indicates that the register is not\n+   __builtin_apply_args.  0 indicates that the register is not\n    used for calling a function. */\n static int apply_args_reg_offset[FIRST_PSEUDO_REGISTER];\n \n@@ -8475,7 +8475,7 @@ expand_increment (exp, post)\n   op0 = expand_expr (incremented, NULL_RTX, VOIDmode, 0);\n \n   /* If OP0 is a SUBREG made for a promoted variable, we cannot increment\n-     in place but intead must do sign- or zero-extension during assignment,\n+     in place but instead must do sign- or zero-extension during assignment,\n      so we copy it into a new register and let the code below use it as\n      a copy.\n "}, {"sha": "ac1757d1b30206ef224f3947987de9ad4dacf66b", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -643,7 +643,7 @@ extern rtx emit_move_insn_1 PROTO ((rtx, rtx));\n    and return an rtx to address the beginning of the block.  */\n extern rtx push_block PROTO((rtx, int, int));\n \n-/* Make an operand to push someting on the stack.  */\n+/* Make an operand to push something on the stack.  */\n extern rtx gen_push_operand PROTO((void));\n \n #ifdef TREE_CODE"}, {"sha": "e4d7d369a752873da264c932c71cb0a240a64d81", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -29,7 +29,7 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the empty parameter list with the argument lust from sys-protos.h.\n \n    * The program can be given a list of (names of) required standard\n-   functions (such as fclose for stdio.h).  If a reqquired function\n+   functions (such as fclose for stdio.h).  If a required function\n    is not seen in the input, then a prototype for it will be\n    written to the output.\n "}, {"sha": "e65eaa9676d56295c8a32200b887a695e09138e9", "filename": "gcc/fixinc.winnt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffixinc.winnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffixinc.winnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc.winnt?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -28,7 +28,7 @@\n #\tprovide many essential definitions and declarations if\n #\t__STDC__ is 1.  This script modifies the header files to check\n #\tfor __STRICT_ANSI__ being defined instead.  However the most \n-#\timportant modification is to change all occurences of __stdcall\n+#\timportant modification is to change all occurrences of __stdcall\n #\tand __cdecl to __attribute__((stdcall)) and __attribute__((cdecl)),\n #\trespectively.  Once munged, the\n #\tresulting new system include files are placed in a directory"}, {"sha": "251c2a88248afcd9b0c25315a17159ef70fc742b", "filename": "gcc/fixproto", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffixproto", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffixproto", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixproto?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -46,7 +46,7 @@\n #\tfiles are copied.  An earlier version just included the original\n #\tby \"reference\", using GNU cpp's #include_next mechanism.\n #\tThis is currently not done, partly because #include_next is\n-#\tfragile (susceptible to version incompatibilties, and depends\n+#\tfragile (susceptible to version incompatibilities, and depends\n #\tand GCC-specific features), and partly for performance reasons.\n #\n # AUTHORS"}, {"sha": "a5aa1fb133f73cc3438cbcd6cbe5a151568700bb", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -177,7 +177,7 @@ int *reg_basic_block;\n \n int *reg_n_refs;\n \n-/* Indexed by N; says whether a psuedo register N was ever used\n+/* Indexed by N; says whether a pseudo register N was ever used\n    within a SUBREG that changes the size of the reg.  Some machines prohibit\n    such objects to be in certain (usually floating-point) registers.  */\n \n@@ -727,14 +727,14 @@ find_basic_blocks (f, nonlocal_label_list)\n \t      }\n \t  }\n \n-      /* There are pathalogical cases where one function calling hundreds of\n+      /* There are pathological cases where one function calling hundreds of\n \t nested inline functions can generate lots and lots of unreachable\n \t blocks that jump can't delete.  Since we don't use sparse matrices\n \t a lot of memory will be needed to compile such functions.\n \t Implementing sparse matrices is a fair bit of work and it is not\n \t clear that they win more than they lose (we don't want to\n \t unnecessarily slow down compilation of normal code).  By making\n-\t another pass for the pathalogical case, we can greatly speed up\n+\t another pass for the pathological case, we can greatly speed up\n \t their compilation without hurting normal code.  This works because\n \t all the insns in the unreachable blocks have either been deleted or\n \t turned into notes."}, {"sha": "c51b8cddd7415a7380f908a2d4ae7e207bcd9096", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2631,7 +2631,7 @@ unextend (c, p, unsignedp)\n     c = convert (signed_type (type), c);\n \n   /* We work by getting just the sign bit into the low-order bit, then\n-     into the high-order bit, then sign-extened.  We then XOR that value\n+     into the high-order bit, then sign-extend.  We then XOR that value\n      with C.  */\n   temp = const_binop (RSHIFT_EXPR, c, size_int (p - 1), 0);\n   temp = const_binop (BIT_AND_EXPR, temp, size_int (1), 0);\n@@ -3277,7 +3277,7 @@ fold (expr)\n \t     succeed in folding one part to a constant, we do not need\n \t     to make this SAVE_EXPR.  Since we do this optimization\n \t     primarily to see if we do end up with constant and this\n-\t     SAVE_EXPR interfers with later optimizations, suppressing\n+\t     SAVE_EXPR interferes with later optimizations, suppressing\n \t     it when we can is important.  */\n \n \t  if (TREE_CODE (arg0) != SAVE_EXPR"}, {"sha": "904eff18f5e2c353281eadda5698be2b825adae3", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -60,7 +60,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or niether. */\n+   must define both, or neither. */\n #ifndef NAME__MAIN\n #define NAME__MAIN \"__main\"\n #define SYMBOL__MAIN __main\n@@ -978,7 +978,7 @@ find_temp_slot_from_address (x)\n   return 0;\n }\n       \n-/* Indicate that NEW is an alternate way of refering to the temp slot\n+/* Indicate that NEW is an alternate way of referring to the temp slot\n    that previous was known by OLD.  */\n \n void\n@@ -1002,7 +1002,7 @@ update_temp_slot_address (old, new)\n }\n \n /* If X could be a reference to a temporary slot, mark the fact that its\n-   adddress was taken.  */\n+   address was taken.  */\n \n void\n mark_temp_addr_taken (x)\n@@ -1470,7 +1470,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \n \t\t If we don't use an intermediate pseudo, such things as\n \t\t address computations to make the address of VAR valid\n-\t\t if it is not can be placed beween the CALL_INSN and INSN.\n+\t\t if it is not can be placed between the CALL_INSN and INSN.\n \n \t\t To make sure this doesn't happen, we record the destination\n \t\t of the CALL_INSN and see if the next insn uses both that\n@@ -5105,7 +5105,7 @@ expand_function_start (subr, parms_have_cleanups)\n   /* Fetch static chain values for containing functions.  */\n   tem = decl_function_context (current_function_decl);\n   /* If not doing stupid register allocation copy the static chain\n-     pointer into a psuedo.  If we have small register classes, copy the\n+     pointer into a pseudo.  If we have small register classes, copy the\n      value from memory if static_chain_incoming_rtx is a REG.  If we do\n      stupid register allocation, we use the stack address generated above.  */\n   if (tem && ! obey_regdecls)\n@@ -5452,7 +5452,7 @@ contains (insn, vec)\n   return 0;\n }\n \n-/* Generate the prologe and epilogue RTL if the machine supports it.  Thread\n+/* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n    the epilogue begins.  Update the basic block information when possible.  */\n "}, {"sha": "7266bc567c1f91e4e3ea9f833d64186784768f38", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -372,7 +372,7 @@ add_to_sequence (pattern, last, position)\n \n \t Finally, if we know that the predicate does not allow CONST_INT, we\n \t know that the only way the predicate can match is if the modes match\n-\t (here we use the kluge of relying on the fact that \"address_operand\"\n+\t (here we use the kludge of relying on the fact that \"address_operand\"\n \t accepts CONST_INT; otherwise, it would have to be a special case),\n \t so we can test the mode (but we need not).  This fact should\n \t considerably simplify the generated code.  */"}, {"sha": "b15c3a0bb7dcfd824a1a641fc76b878f664f098b", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2190,7 +2190,7 @@ copy_rtx_and_substitute (orig, map)\n \t\t && CODE_LABEL_NUMBER (XEXP (copy, 0)) < max_label_num ()));\n \n       /* If we have made a nonlocal label local, it means that this\n-\t inlined call will be refering to our nonlocal goto handler.\n+\t inlined call will be referring to our nonlocal goto handler.\n \t So make sure we create one for this block; we normally would\n \t not since this is not otherwise considered a \"call\".  */\n       if (LABEL_REF_NONLOCAL_P (orig) && ! LABEL_REF_NONLOCAL_P (copy))"}, {"sha": "8f3db8aef8b6ee6bf5f2338c2c1e429939483414", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1136,7 +1136,7 @@ __fixunssfsi (SFtype a)\n #ifdef L__gcc_bcmp\n \n /* Like bcmp except the sign is meaningful.\n-   Reult is negative if S1 is less than S2,\n+   Result is negative if S1 is less than S2,\n    positive if S1 is greater, 0 if S1 and S2 are equal.  */\n \n int\n@@ -1422,7 +1422,7 @@ BLOCK_PROFILER_CODE\n #ifndef inhibit_libc\n \n /* Simple minded basic block profiling output dumper for\n-   systems that don't provde tcov support.  At present,\n+   systems that don't provide tcov support.  At present,\n    it requires atexit and stdio.  */\n \n #undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n@@ -2017,7 +2017,7 @@ __enable_execute_stack ()\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or niether. */\n+   must define both, or neither. */\n #ifndef NAME__MAIN\n #define NAME__MAIN \"__main\"\n #define SYMBOL__MAIN __main"}, {"sha": "2e2d6714fbcd9d12f2287fd438075bc68cdd2180", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1625,7 +1625,7 @@ qty_compare_1 (q1, q2)\n    is called for quantities that have suggested hard registers.  First priority\n    goes to quantities that have copy preferences, then to those that have\n    normal preferences.  Within those groups, quantities with the lower\n-   number of preferenes have the highest priority.  Of those, we use the same\n+   number of preferences have the highest priority.  Of those, we use the same\n    algorithm as above.  */\n \n static int"}, {"sha": "5074e9bb7c4c0d2d30c5b863598e04beec3f371b", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2359,7 +2359,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t\t\t      : (t->sizes[i] * 8) / t->dimensions[i]);\n     };\n \n-  /* NOTE:  Mips documentation claism that the bitfield width goes here.\n+  /* NOTE:  Mips documentation claims that the bitfield width goes here.\n      But it needs to be emitted earlier. */\n \n   return ret;\n@@ -3332,7 +3332,7 @@ parse_def (name_start)\n     }\n \n   else if (symbol_type == st_Member && t.num_sizes - t.extra_sizes == 1)\n-    { /* Is this a bitfield?  This is indicated by a structure memeber\n+    { /* Is this a bitfield?  This is indicated by a structure member\n \t having a size field that isn't an array.  */\n \n       t.bitfield = 1;\n@@ -3632,7 +3632,7 @@ mark_stabs (start)\n {\n   if (!stabs_seen)\n     {\n-      /* Add a dummy @stabs dymbol. */\n+      /* Add a dummy @stabs symbol. */\n       stabs_seen = 1;\n       (void) add_local_symbol (stabs_symbol,\n \t\t\t       stabs_symbol + sizeof (stabs_symbol),"}, {"sha": "aeb228f48e017c47660cd6d027d8ae6879cae131", "filename": "gcc/objc/class.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -275,9 +275,9 @@ class_pose_as (Class impostor, Class super_class)\n \t    impostor->subclass_list = sub;\n \n \t    /* It will happen that SUB is not a class object if it is \n-\t       the top of the meta class hierachy chain.  (root\n-\t       meta-class objects inherit theit class object)  If that is\n-\t       the case... dont mess with the meta-meta class. */ \n+\t       the top of the meta class hierarchy chain.  (root\n+\t       meta-class objects inherit their class object)  If that is\n+\t       the case... don't mess with the meta-meta class. */ \n \t    if (CLS_ISCLASS (sub))\n \t      {\n \t\t/* meta classes */\n@@ -305,7 +305,7 @@ class_pose_as (Class impostor, Class super_class)\n \n   /* This is how to update the lookup table. Regardless of\n      what the keys of the hashtable is, change all values that are\n-     suprecalss into impostor. */\n+     superclass into impostor. */\n \n   for (node = hash_next (__objc_class_hash, NULL); node;\n        node = hash_next (__objc_class_hash, node))"}, {"sha": "66c817f05c42c104b15c257a4cca6d6d7c6bf83b", "filename": "gcc/objc/encoding.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fencoding.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -281,7 +281,7 @@ objc_promoted_size (const char* type)\n \n /*\n   Skip type qualifiers.  These may eventually precede typespecs\n-  occuring in method prototype encodings.\n+  occurring in method prototype encodings.\n */\n \n inline const char*"}, {"sha": "f78dbd6bed8398aa7846e904273906a8b33b0c11", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -113,7 +113,7 @@ cache_ptr hash_new (unsigned int size,\n void hash_delete (cache_ptr cache);\n \n /* Add the key/value pair to the hash table.  If the\n-   hash table reaches a level of fullnes then it will be resized. \n+   hash table reaches a level of fullness then it will be resized. \n                                                    \n    assert if the key is already in the hash.  */\n "}, {"sha": "d2bf1eee586940ae3144ef1ea5826294585b858d", "filename": "gcc/objc/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fmisc.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1,4 +1,4 @@\n-/* GNU Objective C Runtime Miscellanious \n+/* GNU Objective C Runtime Miscellaneous \n    Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n \n Author: Kresten Krab Thorup"}, {"sha": "f6b893672bf6ab3bb8c9e4764aaabcc1b88cdce6", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1115,7 +1115,7 @@ synth_module_prologue ()\n     {\n       if (flag_typed_selectors)\n \t{\n-\t  /* supress outputting debug symbols, because\n+\t  /* suppress outputting debug symbols, because\n \t     dbxout_init hasn'r been called yet... */\n \t  enum debug_info_type save_write_symbols = write_symbols;\n \t  write_symbols = NO_DEBUG;\n@@ -4839,7 +4839,7 @@ build_message_expr (mess)\n \t  warning (\"method `%s' not implemented by protocol.\",\n \t\t   IDENTIFIER_POINTER (sel_name));\n \n-          /* try and find the method signiture in the global pools! */\n+          /* try and find the method signature in the global pools! */\n \n           if (!(hsh = hash_lookup (nst_method_hash_list, sel_name)))\n \t    hsh = hash_lookup (cls_method_hash_list, sel_name);"}, {"sha": "e208ca9cb955a90b020ec019f164cbb4cac4ae1e", "filename": "gcc/objc/selector.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fselector.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -27,7 +27,7 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"objc/sarray.h\"\n #include \"encoding.h\"\n \n-/* Initial selector hash table size. Value doesnt matter much */\n+/* Initial selector hash table size. Value doesn't matter much */\n #define SELECTOR_HASH_SIZE 128\n \n /* Tables mapping selector names to uid and opposite */"}, {"sha": "36235405a915ea4e792846c519b4bb357747b069", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -285,7 +285,7 @@ __objc_install_dispatch_table_for_class (Class class)\n   if (super != 0 && (super->dtable == __objc_uninstalled_dtable))\n     __objc_install_dispatch_table_for_class (super);\n \n-  /* Allocate dtable if nessecary */\n+  /* Allocate dtable if necessary */\n   if (super == 0)\n     {\n       class->dtable = sarray_new (__objc_selector_max_index, 0);\n@@ -331,7 +331,7 @@ void __objc_update_dispatch_table_for_class (Class class)\n    such this function does not worry about thread safe issued.\n \n    This one is only called for categories. Class objects have their\n-   methods installed rightaway, and their selectors are made into\n+   methods installed right away, and their selectors are made into\n    SEL's by the function __objc_register_selectors_from_class. */ \n void\n class_add_method_list (Class class, MethodList_t list)\n@@ -351,7 +351,7 @@ class_add_method_list (Class class, MethodList_t list)\n \n       if (method->method_name)  /* Sometimes these are NULL */\n \t{\n-\t  /* This is where selector names are transmogriffed to SEL's */\n+\t  /* This is where selector names are transmogrified to SEL's */\n \t  method->method_name = \n \t    sel_register_typed_name ((const char*)method->method_name,\n \t\t\t\t     method->method_types);\n@@ -475,7 +475,7 @@ __objc_block_forward (id rcv, SEL op, ...)\n }\n \n \n-/* This fuction is installed in the dispatch table for all methods which are\n+/* This function is installed in the dispatch table for all methods which are\n    not implemented.  Thus, it is called when a selector is not recognized. */\n static retval_t\n __objc_forward (id object, SEL sel, arglist_t args)"}, {"sha": "95a1350487433a950bfdf87eb2c9a56d71ed884c", "filename": "gcc/objc/typedstream.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Ftypedstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fobjc%2Ftypedstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Ftypedstream.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -102,7 +102,7 @@ long objc_get_stream_class_version (TypedStream* stream, Class class);\n \n \n /*\n-** Convenience funtions\n+** Convenience functions\n */\n \n int objc_write_array (TypedStream* stream, const char* type,"}, {"sha": "bc28ad10c413f073f270c34fb3feadbed8f0a20e", "filename": "gcc/protoize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -3051,7 +3051,7 @@ output_string (str)\n    buffer (which may include original comments and preprocessing directives)\n    will be copied into the  output buffer.\n \n-   Note that the request implide when this routine is called includes the\n+   Note that the request implied when this routine is called includes the\n    byte pointed to by the argument pointer `p'.  */\n \n static void\n@@ -3848,7 +3848,7 @@ edit_fn_definition (def_dec_p, clean_text_p)\n       output_string (\"\\n\");\n   }\n #else /* !defined (UNPROTOIZE) */\n-  /* If we are protoizing, there may be some flotsum & jetsum (like comments\n+  /* If we are protoizing, there may be some flotsam & jetsam (like comments\n      and preprocessing directives) after the old formals list but before\n      the following { and we would like to preserve that stuff while effectively\n      deleting the existing K&R formal parameter declarations.  We do so here"}, {"sha": "79e59df1b318be165a9f09d55aea4765c330c824", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2585,7 +2585,7 @@ eadd1 (a, b, c)\n \t      return;\n \t    }\n \t  /* if same sign, result is double */\n-\t  /* double denomalized tiny number */\n+\t  /* double denormalized tiny number */\n \t  if ((bi[E] == 0) && ((bi[3] & 0x8000) == 0))\n \t    {\n \t      eshup1 (bi);"}, {"sha": "ff7792c208fdc9b082f7209d559ab460bf292686", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -84,7 +84,7 @@ init_recog ()\n \n /* Try recognizing the instruction INSN,\n    and return the code number that results.\n-   Remeber the code so that repeated calls do not\n+   Remember the code so that repeated calls do not\n    need to spend the time for actual rerecognition.\n \n    This function is the normal interface to instruction recognition."}, {"sha": "9242bf1964fb27110e78d46460ba92562c44d258", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -44,7 +44,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* If we have auto-increment or auto-decrement and we can have secondary\n    reloads, we are not allowed to use classes requiring secondary\n-   reloads for psuedos auto-incremented since reload can't handle it.  */\n+   reloads for pseudos auto-incremented since reload can't handle it.  */\n \n #ifdef AUTO_INC_DEC\n #if defined(SECONDARY_INPUT_RELOAD_CLASS) || defined(SECONDARY_OUTPUT_RELOAD_CLASS)\n@@ -410,7 +410,7 @@ init_reg_modes ()\n          ??? One situation in which we need to do this is on the mips where\n \t HARD_REGNO_NREGS (fpreg, [SD]Fmode) returns 2.  Ideally we'd like\n \t to use DF mode for the even registers and VOIDmode for the odd\n-\t (for the cpu models where the odd ones are inaccessable).  */\n+\t (for the cpu models where the odd ones are inaccessible).  */\n       if (reg_raw_mode[i] == VOIDmode)\n \treg_raw_mode[i] = word_mode;\n     }"}, {"sha": "ea3e155be4c52eab236cf96ce59f36dacc462c91", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -53,7 +53,7 @@ extern short *reg_n_sets;\n \n extern short *reg_n_deaths;\n \n-/* Indexed by N; says whether a psuedo register N was ever used\n+/* Indexed by N; says whether a pseudo register N was ever used\n    within a SUBREG that changes the size of the reg.  Some machines prohibit\n    such objects to be in certain (usually floating-point) registers.  */\n "}, {"sha": "c9a1ffa0544fed7f0a3cbc979a195e9413eb31c3", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -212,7 +212,7 @@ struct decomposition\n {\n   int reg_flag;\t\t/* Nonzero if referencing a register. */\n   int safe;\t\t/* Nonzero if this can't conflict with anything. */\n-  rtx base;\t\t/* Base adddress for MEM. */\n+  rtx base;\t\t/* Base address for MEM. */\n   HOST_WIDE_INT start;\t/* Starting offset or register number. */\n   HOST_WIDE_INT end;\t/* Endinf offset or register number.  */\n };"}, {"sha": "442a946b3b8cd4e0ef12903e93676c4bfb3928ca", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -923,7 +923,7 @@ reload (first, global, dumpfile)\n \t      int did_elimination = 0;\n \n \t      /* To compute the number of reload registers of each class \n-\t\t needed for an insn, we must similate what choose_reload_regs\n+\t\t needed for an insn, we must simulate what choose_reload_regs\n \t\t can do.  We do this by splitting an insn into an \"input\" and\n \t\t an \"output\" part.  RELOAD_OTHER reloads are used in both. \n \t\t The input part uses those reloads, RELOAD_FOR_INPUT reloads,\n@@ -1546,7 +1546,7 @@ reload (first, global, dumpfile)\n \n       /* Put all registers spilled so far back in potential_reload_regs, but\n \t put them at the front, since we've already spilled most of the\n-\t psuedos in them (we might have left some pseudos unspilled if they\n+\t pseudos in them (we might have left some pseudos unspilled if they\n \t were in a block that didn't need any spill registers of a conflicting\n \t class.  We used to try to mark off the need for those registers,\n \t but doing so properly is very complex and reallocating them is the\n@@ -2800,7 +2800,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* If this is the product of an eliminable register and a \n \t constant, apply the distribute law and move the constant out\n \t so that we have (plus (mult ..) ..).  This is needed in order\n-\t to keep load-address insns valid.   This case is pathalogical.\n+\t to keep load-address insns valid.   This case is pathological.\n \t We ignore the possibility of overflow here.  */\n       if (GET_CODE (XEXP (x, 0)) == REG\n \t  && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n@@ -3374,7 +3374,7 @@ eliminate_regs_in_insn (insn, replace)\n     }\n \n  done:\n-  /* If we changed something, perform elmination in REG_NOTES.  This is\n+  /* If we changed something, perform elimination in REG_NOTES.  This is\n      needed even when REPLACE is zero because a REG_DEAD note might refer\n      to a register that we eliminate and could cause a different number\n      of spill registers to be needed in the final reload pass than in"}, {"sha": "313e63e648bc5b07989db97bd8038026725b02e2", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -454,7 +454,7 @@ extern char *note_insn_name[];\n \n /* The rest is used instead of the above, in a CODE_LABEL,\n    if bytecode is being output.\n-   We make the slightly klugy assumption that a LABEL has enough slots\n+   We make the slightly kludgy assumption that a LABEL has enough slots\n    to hold these things.  That happens to be true.  */\n \n /* For static or external objects.  */"}, {"sha": "1632329ee528d59ec619928c22cc35594281d5bd", "filename": "gcc/sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -847,7 +847,7 @@ anti_dependence (mem, x)\n {\n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n-     have occured somewhere before MEM.  */\n+     have occurred somewhere before MEM.  */\n   if (RTX_UNCHANGING_P (mem))\n     return 0;\n \n@@ -2367,7 +2367,7 @@ sched_note_set (b, x, death)\n }\n \f\n /* Macros and functions for keeping the priority queue sorted, and\n-   dealing with queueing and unqueueing of instructions.  */\n+   dealing with queueing and dequeueing of instructions.  */\n \n #define SCHED_SORT(READY, NEW_READY, OLD_READY) \\\n   do { if ((NEW_READY) - (OLD_READY) == 1)\t\t\t\t\\"}, {"sha": "27f200c6d330ba53b6593bc6c0f5ba305144203a", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2715,7 +2715,7 @@ expand_return (retval)\n \t  /* Clobber REG and move each partword into it.  Ensure we don't\n \t     go past the end of the structure.  Note that the loop below\n \t     works because we've already verified that padding and\n-\t     endianness are compatable.  */\n+\t     endianness are compatible.  */\n \t  emit_insn (gen_rtx (CLOBBER, VOIDmode, reg));\n \n \t  for (bitpos = 0;\n@@ -4330,7 +4330,7 @@ all_cases_count (type, spareness)\n    has the given TYPE.\n    SPARSENESS is as determined by all_cases_count.\n \n-   The time needed is propotional to COUNT, unless\n+   The time needed is proportional to COUNT, unless\n    SPARSENESS is 2, in which case quadratic time is needed.  */\n \n void\n@@ -4547,7 +4547,7 @@ check_for_full_enumeration_handling (type)\n #if 0\n   /* ??? This optimization is disabled because it causes valid programs to\n      fail.  ANSI C does not guarantee that an expression with enum type\n-     will have a value that is the same as one of the enumation literals.  */\n+     will have a value that is the same as one of the enumeration literals.  */\n \n   /* If all values were found as case labels, make one of them the default\n      label.  Thus, this switch will never fall through.  We arbitrarily pick"}, {"sha": "745a0c7b9996166ded8c3c1526783750cadbe41d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -670,7 +670,7 @@ layout_type (type)\n     {\n     case LANG_TYPE:\n       /* This kind of type is the responsibility\n-\t of the languge-specific code.  */\n+\t of the language-specific code.  */\n       abort ();\n \n     case INTEGER_TYPE:"}, {"sha": "ada67c37d8ab6219b4837a56e47e7ad5a69ed8e1", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -2685,7 +2685,7 @@ rest_of_compilation (decl)\n \tTIMEVAR (integration_time,\n \t\t {\n \t\t   lose = function_cannot_inline_p (decl);\n-\t\t   /* If not optimzing, then make sure the DECL_INLINE\n+\t\t   /* If not optimizing, then make sure the DECL_INLINE\n \t\t      bit is off.  */\n \t\t   if (lose || ! optimize)\n \t\t     {"}, {"sha": "f97a95eec898df33b4202dcd6fe132abd2dd09f5", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -920,11 +920,11 @@ make_node (code)\n       /* PARM_DECLs go on the context of the parent. If this is a nested\n \t function, then we must allocate the PARM_DECL on the parent's\n \t obstack, so that they will live to the end of the parent's\n-\t closing brace.  This is neccesary in case we try to inline the\n+\t closing brace.  This is necessary in case we try to inline the\n \t function into its parent.\n \n \t PARM_DECLs of top-level functions do not have this problem.  However,\n-\t we allocate them where we put the FUNCTION_DECL for languauges such as\n+\t we allocate them where we put the FUNCTION_DECL for languages such as\n \t Ada that need to consult some flags in the PARM_DECLs of the function\n \t when calling it. \n \n@@ -4306,7 +4306,7 @@ get_file_function_name (kind)\n      constraints).  -- Raeburn@MIT.EDU, 10 Jan 1990.  */\n   sprintf (buf, FILE_FUNCTION_FORMAT, p);\n \n-  /* Don't need to pull wierd characters out of global names.  */\n+  /* Don't need to pull weird characters out of global names.  */\n   if (p != first_global_object_name)\n     {\n       for (p = buf+11; *p; p++)\n@@ -4332,7 +4332,7 @@ get_file_function_name (kind)\n   return get_identifier (buf);\n }\n \f\n-/* Expand (the constant part of) a SET_TYPE CONTRUCTOR node.\n+/* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.\n    The result is placed in BUFFER (which has length BIT_SIZE),\n    with one bit in each char ('\\000' or '\\001').\n \n@@ -4390,7 +4390,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n   return non_const_bits;\n }\n \n-/* Expand (the constant part of) a SET_TYPE CONTRUCTOR node.\n+/* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.\n    The result is placed in BUFFER (which is an array of bytes).\n    If the constructor is constant, NULL_TREE is returned.\n    Otherwise, a TREE_LIST of the non-constant elements is emitted. */"}, {"sha": "74246fe326f2706ac6e64efa2935a429ed7894f7", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -870,7 +870,7 @@ struct tree_type\n /* Nonzero for a given ..._DECL node means that this node represents an\n    \"abstract instance\" of the given declaration (e.g. in the original\n    declaration of an inline function).  When generating symbolic debugging\n-   information, we musn't try to generate any address information for nodes\n+   information, we mustn't try to generate any address information for nodes\n    marked as \"abstract instances\" because we don't actually generate\n    any code or allocate any data space for such instances.  */\n #define DECL_ABSTRACT(NODE) ((NODE)->decl.abstract_flag)\n@@ -1644,7 +1644,7 @@ extern void init_decl_processing\t\tPROTO((void));\n extern void lang_init\t\t\t\tPROTO((void));\n extern void lang_finish\t\t\t\tPROTO((void));\n \n-/* Funtion to identify which front-end produced the output file. */\n+/* Function to identify which front-end produced the output file. */\n extern char *lang_identify\t\t\tPROTO((void));\n \n /* Function to replace the DECL_LANG_SPECIFIC field of a DECL with a copy.  */"}, {"sha": "a08cfd1aa020e37b9e1f99f8f502eef13a82b1aa", "filename": "gcc/unroll.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1585,7 +1585,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t\t  dest_reg = XEXP (tv->dest_reg, 0);\n \t\t\t\n \t\t\t/* Check for shared address givs, and avoid\n-\t\t\t   incrementing the shared psuedo reg more than\n+\t\t\t   incrementing the shared pseudo reg more than\n \t\t\t   once.  */\n \t\t\tif (! tv->same_insn)\n \t\t\t  {\n@@ -1797,8 +1797,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t{\n \t\t  rtx jmp;\n \t\t  rtx lab = gen_label_rtx ();\n-\t\t  /* Can't do it by reversing the jump (probably becasue we\n-\t\t     couln't reverse the conditions), so emit a new\n+\t\t  /* Can't do it by reversing the jump (probably because we\n+\t\t     couldn't reverse the conditions), so emit a new\n \t\t     jump_insn after COPY, and redirect the jump around\n \t\t     that.  */\n \t\t  jmp = emit_jump_insn_after (gen_jump (exit_label), copy);\n@@ -2670,7 +2670,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t following cse pass.  */\n \t      \n \t      /* As a special case, if we have multiple identical address givs\n-\t\t within a single instruction, then we do use a single psuedo\n+\t\t within a single instruction, then we do use a single pseudo\n \t\t reg for both.  This is necessary in case one is a match_dup\n \t\t of the other.  */\n \n@@ -3376,7 +3376,7 @@ loop_iterations (loop_start, loop_end)\n   return tempu / i + ((tempu % i) != 0);\n }\n \n-/* Replace uses of split bivs with their split psuedo register.  This is\n+/* Replace uses of split bivs with their split pseudo register.  This is\n    for original instructions which remain after loop unrolling without\n    copying.  */\n "}, {"sha": "3876a720df74339f717c805d81a18c617c3f156a", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -1013,7 +1013,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n     }\n \n   /* Normally no need to say anything here for external references,\n-     since assemble_external is called by the langauge-specific code\n+     since assemble_external is called by the language-specific code\n      when a declaration is first seen.  */\n \n   if (DECL_EXTERNAL (decl))"}, {"sha": "a87e6c188107b0dd37c684fedf56252efa19ee3a", "filename": "gcc/vmsconfig.com", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fvmsconfig.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fvmsconfig.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsconfig.com?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -132,7 +132,7 @@ VARIABLE makefile_buf, opt_file_buf, complist_buf, extra_compilers; ! Globals.\n !!\n PROCEDURE process_makefile( )\n   !\n-  ! Intepret Makefile.in and subsidiary Make-lang.in templates.\n+  ! Interpret Makefile.in and subsidiary Make-lang.in templates.\n   !\n   LOCAL range1, cmark, makefilename;\n \n@@ -330,7 +330,7 @@ PROCEDURE fetch_tag( tag_n, punct )\n   mark0 := MARK (NONE);     ! Remember where we started; restore before return.\n   POSITION (BEGINNING_OF (makefile_buf));\n   ! The tag definition always starts in the first column, and might have\n-  ! optional space(es) before \"=\" or \":\" punctutation.\n+  ! optional space(es) before \"=\" or \":\" punctuation.\n   range2 := SEARCH_QUIETLY (LINE_BEGIN & tag_n & ((SPAN(\" \") & punct) | punct),\n \t\t\t    FORWARD, EXACT);\n   IF (range2 = 0) THEN\n@@ -360,7 +360,7 @@ ENDPROCEDURE; !fetch_tag\n \n PROCEDURE pat_replace( oldstring, newstring )\n   !\n-  ! Replace all occurences of a pattern.\n+  ! Replace all occurrences of a pattern.\n   !\n   LOCAL range1, range2, kill_it, count;\n "}, {"sha": "e5b900eda2bd13603ef4f21eb928567753ac1c26", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -483,7 +483,7 @@ xcoffout_declare_function (file, decl, name)\n \t}\n     }\n \n-  /* Any pending .bi or .ei must occur before the .function psuedo op.\n+  /* Any pending .bi or .ei must occur before the .function pseudo op.\n      Otherwise debuggers will think that the function is in the previous\n      file and/or at the wrong line number.  */\n   xcoffout_source_file (file, DECL_SOURCE_FILE (decl), 0);"}, {"sha": "36cef87b5d490ee6ee7ad739bc305dc4ebe38f19", "filename": "gcc/xcoffout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9faa82d8c081b9e38370b5a913825111d2166de6/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=9faa82d8c081b9e38370b5a913825111d2166de6", "patch": "@@ -145,7 +145,7 @@ extern char *xcoff_lastfile;\n /* Write out main source file name using \".file\" rather than \".stabs\".\n    We don't actually do this here, because the assembler gets confused if there\n    is more than one .file directive.  ASM_FILE_START in config/rs6000/rs6000.h\n-   is already emitting a .file direcgtory, so we don't output one here also.\n+   is already emitting a .file directory, so we don't output one here also.\n    Initialize xcoff_lastfile.  */\n #define DBX_OUTPUT_MAIN_SOURCE_FILENAME(FILE,FILENAME) \\\n   xcoff_lastfile = input_file_name"}]}