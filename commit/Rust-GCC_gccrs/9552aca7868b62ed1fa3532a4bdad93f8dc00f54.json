{"sha": "9552aca7868b62ed1fa3532a4bdad93f8dc00f54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU1MmFjYTc4NjhiNjJlZDFmYTM1MzJhNGJkYWQ5M2Y4ZGMwMGY1NA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-08-30T07:28:27Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-08-30T07:28:27Z"}, "message": "i386.md (zero_extendsidi2_1): Rename from zero_extendsidi2_32.\n\n\t* config/i386/i386.md (zero_extendsidi2_1): Rename from\n\tzero_extendsidi2_32.\n\t(zero_extend<mode>di2): Macroize insn from zero_extend{qi,hi}di2\n\tusing SWI12 mode iterator.\n\t(zero_extendhisi2_and): Merge insn pattern and corresponding spliter\n\tto define_insn_and_split pattern.\n\t(zero_extendqi<mode>2): Macroize expander from zero_extendqi{hi,si}2\n\tusing SWI24 mode iterator.\n\t(*zero_extendqi<mode>2_and): Macroize insn from\n\t*zero_extendqi{hi,si}2_and using SWI24 mode iterator.\n\t(*zero_extendqi<mode>2_movzbl_and): Macroize insn from\n\t*zero_extendqihi2_movzbw_and and *zero_extendqisi2_movzbl_and using\n\tSWI24 mode iterator.\n\t(*zero_extendqi<mode>2_movzbl): Ditto from\n\t*zero_extendqi{hi,si}2_movzbl.\n\t(extendsidi2_1): Rename from extendsidi2_32.\n\t(extend<mode>di2): Macroize insn from extend{qi,hi}di2 using\n\tSWI12 mode iterator.\n\nFrom-SVN: r163636", "tree": {"sha": "f52c63480e6912dd870ea834dd623e9454c9e25c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f52c63480e6912dd870ea834dd623e9454c9e25c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9552aca7868b62ed1fa3532a4bdad93f8dc00f54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9552aca7868b62ed1fa3532a4bdad93f8dc00f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9552aca7868b62ed1fa3532a4bdad93f8dc00f54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9552aca7868b62ed1fa3532a4bdad93f8dc00f54/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76c3beb77287256c92cdf16d461265e52f630776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76c3beb77287256c92cdf16d461265e52f630776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76c3beb77287256c92cdf16d461265e52f630776"}], "stats": {"total": 437, "additions": 181, "deletions": 256}, "files": [{"sha": "5a23b03dd397e5f5439756612f51cef1bdbd1b5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9552aca7868b62ed1fa3532a4bdad93f8dc00f54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9552aca7868b62ed1fa3532a4bdad93f8dc00f54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9552aca7868b62ed1fa3532a4bdad93f8dc00f54", "patch": "@@ -1,3 +1,24 @@\n+2010-08-30  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (zero_extendsidi2_1): Rename from\n+\tzero_extendsidi2_32.\n+\t(zero_extend<mode>di2): Macroize insn from zero_extend{qi,hi}di2\n+\tusing SWI12 mode iterator.\n+\t(zero_extendhisi2_and): Merge insn pattern and corresponding spliter\n+\tto define_insn_and_split pattern.\n+\t(zero_extendqi<mode>2): Macroize expander from zero_extendqi{hi,si}2\n+\tusing SWI24 mode iterator.\n+\t(*zero_extendqi<mode>2_and): Macroize insn from\n+\t*zero_extendqi{hi,si}2_and using SWI24 mode iterator.\n+\t(*zero_extendqi<mode>2_movzbl_and): Macroize insn from\n+\t*zero_extendqihi2_movzbw_and and *zero_extendqisi2_movzbl_and using\n+\tSWI24 mode iterator.\n+\t(*zero_extendqi<mode>2_movzbl): Ditto from\n+\t*zero_extendqi{hi,si}2_movzbl.\n+\t(extendsidi2_1): Rename from extendsidi2_32.\n+\t(extend<mode>di2): Macroize insn from extend{qi,hi}di2 using\n+\tSWI12 mode iterator.\n+\n 2010-08-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/ia64/ia64.h (HARD_REGNO_NREGS): Return 1 for CCImode in"}, {"sha": "2f288733f98081873cbcdced3840e38d74f3c97c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 160, "deletions": 256, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9552aca7868b62ed1fa3532a4bdad93f8dc00f54/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9552aca7868b62ed1fa3532a4bdad93f8dc00f54/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9552aca7868b62ed1fa3532a4bdad93f8dc00f54", "patch": "@@ -3587,9 +3587,92 @@\n \f\n ;; Zero extension instructions\n \n+(define_expand \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_64BIT)\n+    {\n+      emit_insn (gen_zero_extendsidi2_1 (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*zero_extendsidi2_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"  \"=r,o,?*Ym,?*y,?*Yi,*Y2\")\n+\t(zero_extend:DI\n+\t (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,r   ,m  ,r   ,m\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   mov\\t{%k1, %k0|%k0, %k1}\n+   #\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\n+   %vmovd\\t{%1, %0|%0, %1}\n+   %vmovd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx,imov,mmxmov,mmxmov,ssemov,ssemov\")\n+   (set_attr \"prefix\" \"orig,*,orig,orig,maybe_vex,maybe_vex\")\n+   (set_attr \"prefix_0f\" \"0,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,TI,TI\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+     \t(zero_extend:DI (match_dup 0)))]\n+  \"TARGET_64BIT\"\n+  [(set (match_dup 4) (const_int 0))]\n+  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+\n+;; %%% Kill me once multi-word ops are sane.\n+(define_insn \"zero_extendsidi2_1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?o,?*Ym,?*y,?*Yi,*Y2\")\n+\t(zero_extend:DI\n+\t (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r ,r   ,m  ,r   ,m\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT\"\n+  \"@\n+   #\n+   #\n+   #\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\n+   %vmovd\\t{%1, %0|%0, %1}\n+   %vmovd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"multi,multi,multi,mmxmov,mmxmov,ssemov,ssemov\")\n+   (set_attr \"prefix\" \"*,*,*,orig,orig,maybe_vex,maybe_vex\")\n+   (set_attr \"mode\" \"SI,SI,SI,DI,DI,TI,TI\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && reload_completed\n+   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n+  [(set (match_dup 4) (const_int 0))]\n+  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(zero_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && reload_completed\n+   && !(MMX_REG_P (operands[0]) || SSE_REG_P (operands[0]))\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 4) (const_int 0))]\n+  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+\n+(define_insn \"zero_extend<mode>di2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t (match_operand:SWI12 1 \"nonimmediate_operand\" \"<r>m\")))]\n+  \"TARGET_64BIT\"\n+  \"movz{<imodesuffix>l|x}\\t{%1, %k0|%k0, %1}\"\n+  [(set_attr \"type\" \"imovx\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-     (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n {\n   if (TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\n@@ -3600,299 +3683,118 @@\n     }\n })\n \n-(define_insn \"zero_extendhisi2_and\"\n+(define_insn_and_split \"zero_extendhisi2_and\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-     (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\"\n   \"#\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && TARGET_ZERO_EXTEND_WITH_AND\n-   && optimize_function_for_speed_p (cfun)\"\n+  \"&& reload_completed\"\n   [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 65535)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n+  \"\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*zero_extendhisi2_movzwl\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-     (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n   \"!TARGET_ZERO_EXTEND_WITH_AND\n    || optimize_function_for_size_p (cfun)\"\n   \"movz{wl|x}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"zero_extendqihi2\"\n+(define_expand \"zero_extendqi<mode>2\"\n   [(parallel\n-    [(set (match_operand:HI 0 \"register_operand\" \"\")\n-       (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n+    [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n+\t  (zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n   \"\")\n \n-(define_insn \"*zero_extendqihi2_and\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,?&q\")\n-     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n+(define_insn \"*zero_extendqi<mode>2_and\"\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"=r,?&q\")\n+\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\"\n   \"#\"\n   [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*zero_extendqihi2_movzbw_and\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"qm,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun)\"\n-  \"#\"\n-  [(set_attr \"type\" \"imovx,alu1\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-; zero extend to SImode here to avoid partial register stalls\n-(define_insn \"*zero_extendqihi2_movzbl\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-     (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n-  \"(!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun))\n-   && reload_completed\"\n-  \"movz{bl|x}\\t{%1, %k0|%k0, %1}\"\n-  [(set_attr \"type\" \"imovx\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; For the movzbw case strip only the clobber\n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && (!TARGET_ZERO_EXTEND_WITH_AND\n-       || optimize_function_for_size_p (cfun))\n-   && (!REG_P (operands[1]) || ANY_QI_REG_P (operands[1]))\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; When source and destination does not overlap, clear destination\n ;; first and then do the movb\n (define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n+\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"reload_completed\n+   && (TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\n    && ANY_QI_REG_P (operands[0])\n-   && (TARGET_ZERO_EXTEND_WITH_AND\n-       && optimize_function_for_speed_p (cfun))\n+   && (ANY_QI_REG_P (operands[1]) || MEM_P (operands[1]))\n    && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n   [(set (strict_low_part (match_dup 2)) (match_dup 1))]\n {\n   operands[2] = gen_lowpart (QImode, operands[0]);\n   ix86_expand_clear (operands[0]);\n })\n \n-;; Rest is handled by single and.\n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n-  [(parallel [(set (match_dup 0) (and:HI (match_dup 0) (const_int 255)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n-\n-(define_expand \"zero_extendqisi2\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"register_operand\" \"\")\n-       (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*zero_extendqisi2_and\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,?&q\")\n-     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,qm\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*zero_extendqisi2_movzbl_and\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm,0\")))\n+(define_insn \"*zero_extendqi<mode>2_movzbl_and\"\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"qm,0\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun)\"\n   \"#\"\n   [(set_attr \"type\" \"imovx,alu1\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*zero_extendqisi2_movzbl\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-     (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n-  \"(!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun))\n-   && reload_completed\"\n-  \"movz{bl|x}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imovx\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; For the movzbl case strip only the clobber\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n+\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"reload_completed\n    && (!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun))\n    && (!REG_P (operands[1]) || ANY_QI_REG_P (operands[1]))\"\n   [(set (match_dup 0)\n-\t(zero_extend:SI (match_dup 1)))])\n+\t(zero_extend:SWI24 (match_dup 1)))])\n \n-;; When source and destination does not overlap, clear destination\n-;; first and then do the movb\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+; zero extend to SImode to avoid partial register stalls\n+(define_insn \"*zero_extendqi<mode>2_movzbl\"\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SWI24 (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n   \"reload_completed\n-   && ANY_QI_REG_P (operands[0])\n-   && (ANY_QI_REG_P (operands[1]) || MEM_P (operands[1]))\n-   && (TARGET_ZERO_EXTEND_WITH_AND && optimize_function_for_speed_p (cfun))\n-   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (strict_low_part (match_dup 2)) (match_dup 1))]\n-{\n-  operands[2] = gen_lowpart (QImode, operands[0]);\n-  ix86_expand_clear (operands[0]);\n-})\n+   && (!TARGET_ZERO_EXTEND_WITH_AND || optimize_function_for_size_p (cfun))\"\n+  \"movz{bl|x}\\t{%1, %k0|%k0, %1}\"\n+  [(set_attr \"type\" \"imovx\")\n+   (set_attr \"mode\" \"SI\")])\n \n ;; Rest is handled by single and.\n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))\n+  [(set (match_operand:SWI24 0 \"register_operand\" \"\")\n+\t(zero_extend:SWI24 (match_operand:QI 1 \"register_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"reload_completed\n    && true_regnum (operands[0]) == true_regnum (operands[1])\"\n-  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (const_int 255)))\n+  [(parallel [(set (match_dup 0) (and:SWI24 (match_dup 0) (const_int 255)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\")\n-\n-;; %%% Kill me once multi-word ops are sane.\n-(define_expand \"zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-     (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!TARGET_64BIT)\n-    {\n-      emit_insn (gen_zero_extendsidi2_32 (operands[0], operands[1]));\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"zero_extendsidi2_32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?o,?*Ym,?*y,?*Yi,*Y2\")\n-\t(zero_extend:DI\n-\t (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r ,r   ,m  ,r   ,m\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\"\n-  \"@\n-   #\n-   #\n-   #\n-   movd\\t{%1, %0|%0, %1}\n-   movd\\t{%1, %0|%0, %1}\n-   %vmovd\\t{%1, %0|%0, %1}\n-   %vmovd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"multi,multi,multi,mmxmov,mmxmov,ssemov,ssemov\")\n-   (set_attr \"prefix\" \"*,*,*,orig,orig,maybe_vex,maybe_vex\")\n-   (set_attr \"mode\" \"SI,SI,SI,DI,DI,TI,TI\")])\n-\n-(define_insn \"zero_extendsidi2_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,?*Ym,?*y,?*Yi,*Y2\")\n-     (zero_extend:DI\n-       (match_operand:SI 1 \"nonimmediate_operand\"  \"rm,0,r   ,m  ,r   ,m\")))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   mov\\t{%k1, %k0|%k0, %k1}\n-   #\n-   movd\\t{%1, %0|%0, %1}\n-   movd\\t{%1, %0|%0, %1}\n-   %vmovd\\t{%1, %0|%0, %1}\n-   %vmovd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imovx,imov,mmxmov,mmxmov,ssemov,ssemov\")\n-   (set_attr \"prefix\" \"orig,*,orig,orig,maybe_vex,maybe_vex\")\n-   (set_attr \"prefix_0f\" \"0,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,TI,TI\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n-     (zero_extend:DI (match_dup 0)))]\n-  \"TARGET_64BIT\"\n-  [(set (match_dup 4) (const_int 0))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && reload_completed\n-   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n-  [(set (match_dup 4) (const_int 0))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && reload_completed\n-   && !(MMX_REG_P (operands[0]) || SSE_REG_P (operands[0]))\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (set (match_dup 4) (const_int 0))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n-\n-(define_insn \"zero_extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-     (zero_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"TARGET_64BIT\"\n-  \"movz{wl|x}\\t{%1, %k0|%k0, %1}\"\n-  [(set_attr \"type\" \"imovx\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"zero_extendqidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-     (zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"TARGET_64BIT\"\n-  \"movz{bl|x}\\t{%1, %k0|%k0, %1}\"\n-  [(set_attr \"type\" \"imovx\")\n-   (set_attr \"mode\" \"SI\")])\n \f\n ;; Sign extension instructions\n \n (define_expand \"extendsidi2\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))\n-\t      (clobber (match_scratch:SI 2 \"\"))])]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"\"\n {\n-  if (TARGET_64BIT)\n+  if (!TARGET_64BIT)\n     {\n-      emit_insn (gen_extendsidi2_rex64 (operands[0], operands[1]));\n+      emit_insn (gen_extendsidi2_1 (operands[0], operands[1]));\n       DONE;\n     }\n })\n \n-(define_insn \"*extendsidi2_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=*A,r,?r,?*o\")\n-\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0,0,r,r\")))\n-   (clobber (reg:CC FLAGS_REG))\n-   (clobber (match_scratch:SI 2 \"=X,X,X,&r\"))]\n-  \"!TARGET_64BIT\"\n-  \"#\")\n-\n-(define_insn \"extendsidi2_rex64\"\n+(define_insn \"*extendsidi2_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=*a,r\")\n \t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"*0,rm\")))]\n   \"TARGET_64BIT\"\n@@ -3904,21 +3806,13 @@\n    (set_attr \"prefix_0f\" \"0\")\n    (set_attr \"modrm\" \"0,1\")])\n \n-(define_insn \"extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"TARGET_64BIT\"\n-  \"movs{wq|x}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imovx\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"extendqidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n-  \"TARGET_64BIT\"\n-  \"movs{bq|x}\\t{%1, %0|%0, %1}\"\n-   [(set_attr \"type\" \"imovx\")\n-    (set_attr \"mode\" \"DI\")])\n+(define_insn \"extendsidi2_1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=*A,r,?r,?*o\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0,0,r,r\")))\n+   (clobber (reg:CC FLAGS_REG))\n+   (clobber (match_scratch:SI 2 \"=X,X,X,&r\"))]\n+  \"!TARGET_64BIT\"\n+  \"#\")\n \n ;; Extend to memory case when source register does die.\n (define_split\n@@ -3995,6 +3889,15 @@\n   DONE;\n })\n \n+(define_insn \"extend<mode>di2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t (match_operand:SWI12 1 \"nonimmediate_operand\" \"<r>m\")))]\n+  \"TARGET_64BIT\"\n+  \"movs{<imodesuffix>q|x}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=*a,r\")\n \t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"*0,rm\")))]\n@@ -4024,7 +3927,8 @@\n (define_insn \"*extendhisi2_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=*a,r\")\n \t(zero_extend:DI\n-\t  (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"*0,rm\"))))]\n+\t (sign_extend:SI\n+\t  (match_operand:HI 1 \"nonimmediate_operand\" \"*0,rm\"))))]\n   \"TARGET_64BIT\"\n {\n   switch (get_attr_prefix_0f (insn))\n@@ -4048,6 +3952,23 @@\n \t(const_string \"0\")\n \t(const_string \"1\")))])\n \n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n+  \"\"\n+  \"movs{bl|x}\\t{%1, %0|%0, %1}\"\n+   [(set_attr \"type\" \"imovx\")\n+    (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*extendqisi2_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\"))))]\n+  \"TARGET_64BIT\"\n+  \"movs{bl|x}\\t{%1, %k0|%k0, %1}\"\n+   [(set_attr \"type\" \"imovx\")\n+    (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=*a,r\")\n \t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"*0,qm\")))]\n@@ -4073,23 +3994,6 @@\n      (if_then_else (eq_attr \"prefix_0f\" \"0\")\n \t(const_string \"0\")\n \t(const_string \"1\")))])\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n-  \"\"\n-  \"movs{bl|x}\\t{%1, %0|%0, %1}\"\n-   [(set_attr \"type\" \"imovx\")\n-    (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*extendqisi2_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\"))))]\n-  \"TARGET_64BIT\"\n-  \"movs{bl|x}\\t{%1, %k0|%k0, %1}\"\n-   [(set_attr \"type\" \"imovx\")\n-    (set_attr \"mode\" \"SI\")])\n \f\n ;; Conversions between float and double.\n "}]}