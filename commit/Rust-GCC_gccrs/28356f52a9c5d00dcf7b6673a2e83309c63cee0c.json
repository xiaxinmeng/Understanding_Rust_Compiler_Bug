{"sha": "28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgzNTZmNTJhOWM1ZDAwZGNmN2I2NjczYTJlODMzMDljNjNjZWUwYw==", "commit": {"author": {"name": "Jan Beulich", "email": "jbeulich@novell.com", "date": "2005-07-18T06:39:20Z"}, "committer": {"name": "Jan Beulich", "email": "jbeulich@gcc.gnu.org", "date": "2005-07-18T06:39:20Z"}, "message": "i386.c (ix86_expand_branch, [...]): Handle TImode in 64-bit mode the same as DImode in 32-bit mode.\n\ngcc/\n2005-07-18  Jan Beulich  <jbeulich@novell.com>\n\n\t* config/i386/i386.c (ix86_expand_branch, ix86_expand_setcc,\n\tix86_expand_carry_flag_compare, ix86_expand_int_movcc): Handle TImode\n\tin 64-bit mode the same as DImode in 32-bit mode.\n\t(ix86_expand_ashl_const, ix86_split_ashl, ix86_split_ashr,\n\tix86_split_lshr): Likewise. Rename to no longer refer to a specific\n\tmode. Add new mode parameter.\n\t* config/i386/i386.h (CONST_OK_FOR_LETTER_P): Describe and handle 'O'.\n\t* config/i386/i386.md (cmpti, addti3, subti3, negti2, ashlti3, ashrti3,\n\tx86_64_shift_adj): New expanders.\n\t(*addti3_1, *subti3_1, *negti2_1, ashlti3_1, *ashlti3_2, ashrti3_1,\n\t*ashrti3_2, lshrti3_1, *lshrti3_2, x86_64_shld, x86_64_shrd): New\n\tinsns.\n\tRespective new splitters. Use renamed shift splitter helpers in 32-bit\n\tDImode shift splitters.\n\t* config/i386/i386-protos.h (ix86_split_ashl, ix86_split_ashr,\n\tix86_split_lshr): Renamed from ix86_split_[al]sh[rl]di. Added new\n\tmode parameter.\n\nFrom-SVN: r102129", "tree": {"sha": "151aba1a149c4300ec9d417932358767d50bb381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/151aba1a149c4300ec9d417932358767d50bb381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/comments", "author": null, "committer": null, "parents": [{"sha": "422edd6fff341fb237a5fab947a1356f94172953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422edd6fff341fb237a5fab947a1356f94172953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422edd6fff341fb237a5fab947a1356f94172953"}], "stats": {"total": 592, "additions": 510, "deletions": 82}, "files": [{"sha": "d23ed159a30c2de81a3ee05986e55bf2129887d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "patch": "@@ -1,3 +1,23 @@\n+2005-07-18  Jan Beulich  <jbeulich@novell.com>\n+\n+\t* config/i386/i386.c (ix86_expand_branch, ix86_expand_setcc,\n+\tix86_expand_carry_flag_compare, ix86_expand_int_movcc): Handle TImode\n+\tin 64-bit mode the same as DImode in 32-bit mode.\n+\t(ix86_expand_ashl_const, ix86_split_ashl, ix86_split_ashr,\n+\tix86_split_lshr): Likewise. Rename to no longer refer to a specific\n+\tmode. Add new mode parameter. \n+\t* config/i386/i386.h (CONST_OK_FOR_LETTER_P): Describe and handle 'O'.\n+\t* config/i386/i386.md (cmpti, addti3, subti3, negti2, ashlti3, ashrti3,\n+\tx86_64_shift_adj): New expanders.\n+\t(*addti3_1, *subti3_1, *negti2_1, ashlti3_1, *ashlti3_2, ashrti3_1,\n+\t*ashrti3_2, lshrti3_1, *lshrti3_2, x86_64_shld, x86_64_shrd): New\n+\tinsns.\n+\tRespective new splitters. Use renamed shift splitter helpers in 32-bit\n+\tDImode shift splitters.\n+\t* config/i386/i386-protos.h (ix86_split_ashl, ix86_split_ashr,\n+\tix86_split_lshr): Renamed from ix86_split_[al]sh[rl]di. Added new\n+\tmode parameter.\n+\n 2005-07-18  Jan Beulich  <jbeulich@novell.com>\n \n \t* i386.md (movdi_extzv_1): New."}, {"sha": "dfbf11ac25646ae99004ea7d89f68740e5699df2", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "patch": "@@ -155,9 +155,9 @@ extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);\n extern rtx ix86_zero_extend_to_Pmode (rtx);\n extern void ix86_split_long_move (rtx[]);\n-extern void ix86_split_ashldi (rtx *, rtx);\n-extern void ix86_split_ashrdi (rtx *, rtx);\n-extern void ix86_split_lshrdi (rtx *, rtx);\n+extern void ix86_split_ashl (rtx *, rtx, enum machine_mode);\n+extern void ix86_split_ashr (rtx *, rtx, enum machine_mode);\n+extern void ix86_split_lshr (rtx *, rtx, enum machine_mode);\n extern rtx ix86_find_base_term (rtx);\n extern int ix86_check_movabs (rtx, int);\n "}, {"sha": "8dd96986cf50e0f7cd87b87414d3f7f9b9c9a59f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 147, "deletions": 72, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "patch": "@@ -7200,7 +7200,7 @@ split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n \t}\n     }\n }\n-/* Split one or more TImode RTL references into pairs of SImode\n+/* Split one or more TImode RTL references into pairs of DImode\n    references.  The RTL can be REG, offsettable MEM, integer constant, or\n    CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n    split and \"num\" is its length.  lo_half and hi_half are output arrays\n@@ -9344,10 +9344,12 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n     case DImode:\n       if (TARGET_64BIT)\n \tgoto simple;\n+    case TImode:\n       /* Expand DImode branch into multiple compare+branch.  */\n       {\n \trtx lo[2], hi[2], label2;\n \tenum rtx_code code1, code2, code3;\n+\tenum machine_mode submode;\n \n \tif (CONSTANT_P (ix86_compare_op0) && ! CONSTANT_P (ix86_compare_op1))\n \t  {\n@@ -9356,8 +9358,18 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t    ix86_compare_op1 = tmp;\n \t    code = swap_condition (code);\n \t  }\n-\tsplit_di (&ix86_compare_op0, 1, lo+0, hi+0);\n-\tsplit_di (&ix86_compare_op1, 1, lo+1, hi+1);\n+\tif (GET_MODE (ix86_compare_op0) == DImode)\n+\t  {\n+\t    split_di (&ix86_compare_op0, 1, lo+0, hi+0);\n+\t    split_di (&ix86_compare_op1, 1, lo+1, hi+1);\n+\t    submode = SImode;\n+\t  }\n+\telse\n+\t  {\n+\t    split_ti (&ix86_compare_op0, 1, lo+0, hi+0);\n+\t    split_ti (&ix86_compare_op1, 1, lo+1, hi+1);\n+\t    submode = DImode;\n+\t  }\n \n \t/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to\n \t   avoid two branches.  This costs one extra insn, so disable when\n@@ -9371,15 +9383,15 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \n \t    xor1 = hi[0];\n \t    if (hi[1] != const0_rtx)\n-\t      xor1 = expand_binop (SImode, xor_optab, xor1, hi[1],\n+\t      xor1 = expand_binop (submode, xor_optab, xor1, hi[1],\n \t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \n \t    xor0 = lo[0];\n \t    if (lo[1] != const0_rtx)\n-\t      xor0 = expand_binop (SImode, xor_optab, xor0, lo[1],\n+\t      xor0 = expand_binop (submode, xor_optab, xor0, lo[1],\n \t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \n-\t    tmp = expand_binop (SImode, ior_optab, xor1, xor0,\n+\t    tmp = expand_binop (submode, ior_optab, xor1, xor0,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \n \t    ix86_compare_op0 = tmp;\n@@ -9547,8 +9559,7 @@ ix86_expand_setcc (enum rtx_code code, rtx dest)\n   rtx ret, tmp, tmpreg, equiv;\n   rtx second_test, bypass_test;\n \n-  if (GET_MODE (ix86_compare_op0) == DImode\n-      && !TARGET_64BIT)\n+  if (GET_MODE (ix86_compare_op0) == (TARGET_64BIT ? TImode : DImode))\n     return 0; /* FAIL */\n \n   gcc_assert (GET_MODE (dest) == QImode);\n@@ -9603,7 +9614,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n \n   /* Do not handle DImode compares that go trought special path.  Also we can't\n      deal with FP compares yet.  This is possible to add.  */\n-  if ((mode == DImode && !TARGET_64BIT))\n+  if (mode == (TARGET_64BIT ? TImode : DImode))\n     return false;\n   if (FLOAT_MODE_P (mode))\n     {\n@@ -9743,7 +9754,7 @@ ix86_expand_int_movcc (rtx operands[])\n      HImode insns, we'd be swallowed in word prefix ops.  */\n \n   if ((mode != HImode || TARGET_FAST_PREFIX)\n-      && (mode != DImode || TARGET_64BIT)\n+      && (mode != (TARGET_64BIT ? TImode : DImode))\n       && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n     {\n@@ -11092,68 +11103,81 @@ ix86_split_long_move (rtx operands[])\n   return;\n }\n \n-/* Helper function of ix86_split_ashldi used to generate an SImode\n+/* Helper function of ix86_split_ashl used to generate an SImode/DImode\n    left shift by a constant, either using a single shift or\n    a sequence of add instructions.  */\n \n static void\n-ix86_expand_ashlsi3_const (rtx operand, int count)\n+ix86_expand_ashl_const (rtx operand, int count, enum machine_mode mode)\n {\n   if (count == 1)\n-    emit_insn (gen_addsi3 (operand, operand, operand));\n+    {\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_addsi3\n+\t\t  : gen_adddi3) (operand, operand, operand));\n+    }\n   else if (!optimize_size\n \t   && count * ix86_cost->add <= ix86_cost->shift_const)\n     {\n       int i;\n       for (i=0; i<count; i++)\n-\temit_insn (gen_addsi3 (operand, operand, operand));\n+\t{\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_addsi3\n+\t\t      : gen_adddi3) (operand, operand, operand));\n+\t}\n     }\n   else\n-    emit_insn (gen_ashlsi3 (operand, operand, GEN_INT (count)));\n+    emit_insn ((mode == DImode\n+\t\t? gen_ashlsi3\n+\t\t: gen_ashldi3) (operand, operand, GEN_INT (count)));\n }\n \n void\n-ix86_split_ashldi (rtx *operands, rtx scratch)\n+ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n {\n   rtx low[2], high[2];\n   int count;\n+  const int single_width = mode == DImode ? 32 : 64;\n \n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      split_di (operands, 2, low, high);\n-      count = INTVAL (operands[2]) & 63;\n+      (mode == DImode ? split_di : split_ti) (operands, 2, low, high);\n+      count = INTVAL (operands[2]) & (single_width * 2 - 1);\n \n-      if (count >= 32)\n+      if (count >= single_width)\n \t{\n \t  emit_move_insn (high[0], low[1]);\n \t  emit_move_insn (low[0], const0_rtx);\n \n-\t  if (count > 32)\n-\t    ix86_expand_ashlsi3_const (high[0], count - 32);\n+\t  if (count > single_width)\n+\t    ix86_expand_ashl_const (high[0], count - single_width, mode);\n \t}\n       else\n \t{\n \t  if (!rtx_equal_p (operands[0], operands[1]))\n \t    emit_move_insn (operands[0], operands[1]);\n-\t  emit_insn (gen_x86_shld_1 (high[0], low[0], GEN_INT (count)));\n-\t  ix86_expand_ashlsi3_const (low[0], count);\n+\t  emit_insn ((mode == DImode\n+\t\t     ? gen_x86_shld_1\n+\t\t     : gen_x86_64_shld) (high[0], low[0], GEN_INT (count)));\n+\t  ix86_expand_ashl_const (low[0], count, mode);\n \t}\n       return;\n     }\n \n-  split_di (operands, 1, low, high);\n+  (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n \n   if (operands[1] == const1_rtx)\n     {\n-      /* Assuming we've chosen a QImode capable registers, then 1LL << N\n-\t can be done with two 32-bit shifts, no branches, no cmoves.  */\n+      /* Assuming we've chosen a QImode capable registers, then 1 << N\n+\t can be done with two 32/64-bit shifts, no branches, no cmoves.  */\n       if (ANY_QI_REG_P (low[0]) && ANY_QI_REG_P (high[0]))\n \t{\n \t  rtx s, d, flags = gen_rtx_REG (CCZmode, FLAGS_REG);\n \n \t  ix86_expand_clear (low[0]);\n \t  ix86_expand_clear (high[0]);\n-\t  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (32)));\n+\t  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (single_width)));\n \t  \n \t  d = gen_lowpart (QImode, low[0]);\n \t  d = gen_rtx_STRICT_LOW_PART (VOIDmode, d);\n@@ -11167,7 +11191,7 @@ ix86_split_ashldi (rtx *operands, rtx scratch)\n \t}\n \n       /* Otherwise, we can get the same results by manually performing\n-\t a bit extract operation on bit 5, and then performing the two\n+\t a bit extract operation on bit 5/6, and then performing the two\n \t shifts.  The two methods of getting 0/1 into low/high are exactly\n \t the same size.  Avoiding the shift in the bit extract case helps\n \t pentium4 a bit; no one else seems to care much either way.  */\n@@ -11176,29 +11200,39 @@ ix86_split_ashldi (rtx *operands, rtx scratch)\n \t  rtx x;\n \n \t  if (TARGET_PARTIAL_REG_STALL && !optimize_size)\n-\t    x = gen_rtx_ZERO_EXTEND (SImode, operands[2]);\n+\t    x = gen_rtx_ZERO_EXTEND (mode == DImode ? SImode : DImode, operands[2]);\n \t  else\n-\t    x = gen_lowpart (SImode, operands[2]);\n+\t    x = gen_lowpart (mode == DImode ? SImode : DImode, operands[2]);\n \t  emit_insn (gen_rtx_SET (VOIDmode, high[0], x));\n \n-\t  emit_insn (gen_lshrsi3 (high[0], high[0], GEN_INT (5)));\n-\t  emit_insn (gen_andsi3 (high[0], high[0], GEN_INT (1)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_lshrsi3\n+\t\t      : gen_lshrdi3) (high[0], high[0], GEN_INT (mode == DImode ? 5 : 6)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_andsi3\n+\t\t      : gen_anddi3) (high[0], high[0], GEN_INT (1)));\n \t  emit_move_insn (low[0], high[0]);\n-\t  emit_insn (gen_xorsi3 (low[0], low[0], GEN_INT (1)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_xorsi3\n+\t\t      : gen_xordi3) (low[0], low[0], GEN_INT (1)));\n \t}\n \n-      emit_insn (gen_ashlsi3 (low[0], low[0], operands[2]));\n-      emit_insn (gen_ashlsi3 (high[0], high[0], operands[2]));\n+      emit_insn ((mode == DImode\n+\t\t    ? gen_ashlsi3\n+\t\t    : gen_ashldi3) (low[0], low[0], operands[2]));\n+      emit_insn ((mode == DImode\n+\t\t    ? gen_ashlsi3\n+\t\t    : gen_ashldi3) (high[0], high[0], operands[2]));\n       return;\n     }\n \n   if (operands[1] == constm1_rtx)\n     {\n-      /* For -1LL << N, we can avoid the shld instruction, because we\n-\t know that we're shifting 0...31 ones into a -1.  */\n+      /* For -1 << N, we can avoid the shld instruction, because we\n+\t know that we're shifting 0...31/63 ones into a -1.  */\n       emit_move_insn (low[0], constm1_rtx);\n       if (optimize_size)\n-        emit_move_insn (high[0], low[0]);\n+\temit_move_insn (high[0], low[0]);\n       else\n \temit_move_insn (high[0], constm1_rtx);\n     }\n@@ -11207,120 +11241,161 @@ ix86_split_ashldi (rtx *operands, rtx scratch)\n       if (!rtx_equal_p (operands[0], operands[1]))\n \temit_move_insn (operands[0], operands[1]);\n \n-      split_di (operands, 1, low, high);\n-      emit_insn (gen_x86_shld_1 (high[0], low[0], operands[2]));\n+      (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_x86_shld_1\n+\t\t  : gen_x86_64_shld) (high[0], low[0], operands[2]));\n     }\n \n-  emit_insn (gen_ashlsi3 (low[0], low[0], operands[2]));\n+  emit_insn ((mode == DImode ? gen_ashlsi3 : gen_ashldi3) (low[0], low[0], operands[2]));\n \n   if (TARGET_CMOVE && scratch)\n     {\n       ix86_expand_clear (scratch);\n-      emit_insn (gen_x86_shift_adj_1 (high[0], low[0], operands[2], scratch));\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_x86_shift_adj_1\n+\t\t  : gen_x86_64_shift_adj) (high[0], low[0], operands[2], scratch));\n     }\n   else\n     emit_insn (gen_x86_shift_adj_2 (high[0], low[0], operands[2]));\n }\n \n void\n-ix86_split_ashrdi (rtx *operands, rtx scratch)\n+ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n {\n   rtx low[2], high[2];\n   int count;\n+  const int single_width = mode == DImode ? 32 : 64;\n \n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      split_di (operands, 2, low, high);\n-      count = INTVAL (operands[2]) & 63;\n+      (mode == DImode ? split_di : split_ti) (operands, 2, low, high);\n+      count = INTVAL (operands[2]) & (single_width * 2 - 1);\n \n-      if (count == 63)\n+      if (count == single_width * 2 - 1)\n \t{\n \t  emit_move_insn (high[0], high[1]);\n-\t  emit_insn (gen_ashrsi3 (high[0], high[0], GEN_INT (31)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_ashrsi3\n+\t\t      : gen_ashrdi3) (high[0], high[0],\n+\t\t\t\t      GEN_INT (single_width - 1)));\n \t  emit_move_insn (low[0], high[0]);\n \n \t}\n-      else if (count >= 32)\n+      else if (count >= single_width)\n \t{\n \t  emit_move_insn (low[0], high[1]);\n \t  emit_move_insn (high[0], low[0]);\n-\t  emit_insn (gen_ashrsi3 (high[0], high[0], GEN_INT (31)));\n-\t  if (count > 32)\n-\t    emit_insn (gen_ashrsi3 (low[0], low[0], GEN_INT (count - 32)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_ashrsi3\n+\t\t      : gen_ashrdi3) (high[0], high[0],\n+\t\t\t\t      GEN_INT (single_width - 1)));\n+\t  if (count > single_width)\n+\t    emit_insn ((mode == DImode\n+\t\t\t? gen_ashrsi3\n+\t\t\t: gen_ashrdi3) (low[0], low[0],\n+\t\t\t\t\tGEN_INT (count - single_width)));\n \t}\n       else\n \t{\n \t  if (!rtx_equal_p (operands[0], operands[1]))\n \t    emit_move_insn (operands[0], operands[1]);\n-\t  emit_insn (gen_x86_shrd_1 (low[0], high[0], GEN_INT (count)));\n-\t  emit_insn (gen_ashrsi3 (high[0], high[0], GEN_INT (count)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_x86_shrd_1\n+\t\t      : gen_x86_64_shrd) (low[0], high[0], GEN_INT (count)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_ashrsi3\n+\t\t      : gen_ashrdi3) (high[0], high[0], GEN_INT (count)));\n \t}\n     }\n   else\n     {\n       if (!rtx_equal_p (operands[0], operands[1]))\n \temit_move_insn (operands[0], operands[1]);\n \n-      split_di (operands, 1, low, high);\n+      (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n \n-      emit_insn (gen_x86_shrd_1 (low[0], high[0], operands[2]));\n-      emit_insn (gen_ashrsi3 (high[0], high[0], operands[2]));\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_x86_shrd_1\n+\t\t  : gen_x86_64_shrd) (low[0], high[0], operands[2]));\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_ashrsi3\n+\t\t  : gen_ashrdi3)  (high[0], high[0], operands[2]));\n \n       if (TARGET_CMOVE && scratch)\n \t{\n \t  emit_move_insn (scratch, high[0]);\n-\t  emit_insn (gen_ashrsi3 (scratch, scratch, GEN_INT (31)));\n-\t  emit_insn (gen_x86_shift_adj_1 (low[0], high[0], operands[2],\n-\t\t\t\t\t  scratch));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_ashrsi3\n+\t\t      : gen_ashrdi3) (scratch, scratch,\n+\t\t\t\t      GEN_INT (single_width - 1)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_x86_shift_adj_1\n+\t\t      : gen_x86_64_shift_adj) (low[0], high[0], operands[2],\n+\t\t\t\t\t scratch));\n \t}\n       else\n \temit_insn (gen_x86_shift_adj_3 (low[0], high[0], operands[2]));\n     }\n }\n \n void\n-ix86_split_lshrdi (rtx *operands, rtx scratch)\n+ix86_split_lshr (rtx *operands, rtx scratch, enum machine_mode mode)\n {\n   rtx low[2], high[2];\n   int count;\n+  const int single_width = mode == DImode ? 32 : 64;\n \n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      split_di (operands, 2, low, high);\n-      count = INTVAL (operands[2]) & 63;\n+      (mode == DImode ? split_di : split_ti) (operands, 2, low, high);\n+      count = INTVAL (operands[2]) & (single_width * 2 - 1);\n \n-      if (count >= 32)\n+      if (count >= single_width)\n \t{\n \t  emit_move_insn (low[0], high[1]);\n \t  ix86_expand_clear (high[0]);\n \n-\t  if (count > 32)\n-\t    emit_insn (gen_lshrsi3 (low[0], low[0], GEN_INT (count - 32)));\n+\t  if (count > single_width)\n+\t    emit_insn ((mode == DImode\n+\t\t\t? gen_lshrsi3\n+\t\t\t: gen_lshrdi3) (low[0], low[0],\n+\t\t\t\t\tGEN_INT (count - single_width)));\n \t}\n       else\n \t{\n \t  if (!rtx_equal_p (operands[0], operands[1]))\n \t    emit_move_insn (operands[0], operands[1]);\n-\t  emit_insn (gen_x86_shrd_1 (low[0], high[0], GEN_INT (count)));\n-\t  emit_insn (gen_lshrsi3 (high[0], high[0], GEN_INT (count)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_x86_shrd_1\n+\t\t      : gen_x86_64_shrd) (low[0], high[0], GEN_INT (count)));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_lshrsi3\n+\t\t      : gen_lshrdi3) (high[0], high[0], GEN_INT (count)));\n \t}\n     }\n   else\n     {\n       if (!rtx_equal_p (operands[0], operands[1]))\n \temit_move_insn (operands[0], operands[1]);\n \n-      split_di (operands, 1, low, high);\n+      (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n \n-      emit_insn (gen_x86_shrd_1 (low[0], high[0], operands[2]));\n-      emit_insn (gen_lshrsi3 (high[0], high[0], operands[2]));\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_x86_shrd_1\n+\t\t  : gen_x86_64_shrd) (low[0], high[0], operands[2]));\n+      emit_insn ((mode == DImode\n+\t\t  ? gen_lshrsi3\n+\t\t  : gen_lshrdi3) (high[0], high[0], operands[2]));\n \n       /* Heh.  By reversing the arguments, we can reuse this pattern.  */\n       if (TARGET_CMOVE && scratch)\n \t{\n \t  ix86_expand_clear (scratch);\n-\t  emit_insn (gen_x86_shift_adj_1 (low[0], high[0], operands[2],\n-\t\t\t\t\t  scratch));\n+\t  emit_insn ((mode == DImode\n+\t\t      ? gen_x86_shift_adj_1\n+\t\t      : gen_x86_64_shift_adj) (low[0], high[0], operands[2],\n+\t\t\t\t\t       scratch));\n \t}\n       else\n \temit_insn (gen_x86_shift_adj_2 (low[0], high[0], operands[2]));"}, {"sha": "e140bd291a238a094548702003d225bb14cf5851", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "patch": "@@ -1218,7 +1218,7 @@ enum reg_class\n    (C) == 'l' ? INDEX_REGS :\t\t\t\t\t\\\n    NO_REGS)\n \n-/* The letters I, J, K, L and M in a register constraint string\n+/* The letters I, J, K, L, M, N, and O in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n    This macro defines what the ranges are.\n    C is the letter, and VALUE is a constant value.\n@@ -1230,6 +1230,7 @@ enum reg_class\n    L is for andsi as zero-extending move.\n    M is for shifts that can be executed by the \"lea\" opcode.\n    N is for immediate operands for out/in instructions (0-255)\n+   O is for TImode shifts.\n    */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n@@ -1239,6 +1240,7 @@ enum reg_class\n    : (C) == 'L' ? (VALUE) == 0xff || (VALUE) == 0xffff\t\t\\\n    : (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3\t\t\t\\\n    : (C) == 'N' ? (VALUE) >= 0 && (VALUE) <= 255\t\t\\\n+   : (C) == 'O' ? (VALUE) >= 0 && (VALUE) <= 127\t\t\\\n    : 0)\n \n /* Similar, but for floating constants, and defining letters G and H."}, {"sha": "ba35331189ec71016e0d3ac24106f5fe95288de8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 337, "deletions": 6, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28356f52a9c5d00dcf7b6673a2e83309c63cee0c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=28356f52a9c5d00dcf7b6673a2e83309c63cee0c", "patch": "@@ -478,6 +478,19 @@\n ;; actually generating RTL.  The bCOND or sCOND (emitted immediately\n ;; after the cmp) will actually emit the cmpM.\n \n+(define_expand \"cmpti\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:TI 1 \"x86_64_general_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    operands[0] = force_reg (TImode, operands[0]);\n+  ix86_compare_op0 = operands[0];\n+  ix86_compare_op1 = operands[1];\n+  DONE;\n+})\n+\n (define_expand \"cmpdi\"\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n@@ -4694,6 +4707,42 @@\n \f\n ;; Add instructions\n \n+;; %%% splits for addditi3\n+\n+(define_expand \"addti3\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t(plus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:TI 2 \"x86_64_general_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_binary_operator (PLUS, TImode, operands); DONE;\")\n+\n+(define_insn \"*addti3_1\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(plus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:TI 2 \"general_operand\" \"roiF,riF\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, TImode, operands)\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t(plus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:TI 2 \"general_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (reg:CC FLAGS_REG) (unspec:CC [(match_dup 1) (match_dup 2)]\n+\t\t\t\t\t  UNSPEC_ADD_CARRY))\n+\t      (set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))])\n+   (parallel [(set (match_dup 3)\n+\t\t   (plus:DI (plus:DI (ltu:DI (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t\t     (match_dup 4))\n+\t\t\t    (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"split_ti (operands+0, 1, operands+0, operands+3);\n+   split_ti (operands+1, 1, operands+1, operands+4);\n+   split_ti (operands+2, 1, operands+2, operands+5);\")\n+\n ;; %%% splits for addsidi3\n ;  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n ;\t(plus:DI (match_operand:DI 1 \"general_operand\" \"\")\n@@ -6392,6 +6441,41 @@\n \f\n ;; Subtract instructions\n \n+;; %%% splits for subditi3\n+\n+(define_expand \"subti3\"\n+  [(parallel [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (minus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"\")\n+\t\t\t     (match_operand:TI 2 \"x86_64_general_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_binary_operator (MINUS, TImode, operands); DONE;\")\n+\n+(define_insn \"*subti3_1\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(minus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t  (match_operand:TI 2 \"general_operand\" \"roiF,riF\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, TImode, operands)\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t(minus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:TI 2 \"general_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (reg:CC FLAGS_REG) (compare:CC (match_dup 1) (match_dup 2)))\n+\t      (set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))])\n+   (parallel [(set (match_dup 3)\n+\t\t   (minus:DI (match_dup 4)\n+\t\t\t     (plus:DI (ltu:DI (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t\t      (match_dup 5))))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"split_ti (operands+0, 1, operands+0, operands+3);\n+   split_ti (operands+1, 1, operands+1, operands+4);\n+   split_ti (operands+2, 1, operands+2, operands+5);\")\n+\n ;; %%% splits for subsidi3\n \n (define_expand \"subdi3\"\n@@ -9198,6 +9282,43 @@\n \f\n ;; Negation instructions\n \n+(define_expand \"negti2\"\n+  [(parallel [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:TI (match_operand:TI 1 \"nonimmediate_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_unary_operator (NEG, TImode, operands); DONE;\")\n+\n+(define_insn \"*negti2_1\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=ro\")\n+\t(neg:TI (match_operand:TI 1 \"general_operand\" \"0\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && ix86_unary_operator_ok (NEG, TImode, operands)\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t(neg:TI (match_operand:TI 1 \"general_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel\n+    [(set (reg:CCZ FLAGS_REG)\n+\t  (compare:CCZ (neg:DI (match_dup 2)) (const_int 0)))\n+     (set (match_dup 0) (neg:DI (match_dup 2)))])\n+   (parallel\n+    [(set (match_dup 1)\n+\t  (plus:DI (plus:DI (ltu:DI (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t    (match_dup 3))\n+\t\t   (const_int 0)))\n+     (clobber (reg:CC FLAGS_REG))])\n+   (parallel\n+    [(set (match_dup 1)\n+\t  (neg:DI (match_dup 1)))\n+     (clobber (reg:CC FLAGS_REG))])]\n+  \"split_ti (operands+1, 1, operands+2, operands+3);\n+   split_ti (operands+0, 1, operands+0, operands+1);\")\n+\n (define_expand \"negdi2\"\n   [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t\t   (neg:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")))\n@@ -10079,6 +10200,92 @@\n ;; shift pair, instead using moves and sign extension for counts greater\n ;; than 31.\n \n+(define_expand \"ashlti3\"\n+  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t\t   (ashift:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT\"\n+{\n+  if (! immediate_operand (operands[2], QImode))\n+    {\n+      emit_insn (gen_ashlti3_1 (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  ix86_expand_binary_operator (ASHIFT, TImode, operands);\n+  DONE;\n+})\n+\n+(define_insn \"ashlti3_1\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(ashift:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"register_operand\" \"c\")))\n+   (clobber (match_scratch:DI 3 \"=&r\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*ashlti3_2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(ashift:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"immediate_operand\" \"O\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(ashift:TI (match_operand:TI 1 \"nonmemory_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"register_operand\" \"\")))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_ashl (operands, operands[3], TImode); DONE;\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(ashift:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_ashl (operands, NULL_RTX, TImode); DONE;\")\n+\n+(define_insn \"x86_64_shld\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"+r*m,r*m\")\n+        (ior:DI (ashift:DI (match_dup 0)\n+\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"J,c\"))\n+\t\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t  (minus:QI (const_int 64) (match_dup 2)))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   shld{q}\\t{%2, %1, %0|%0, %1, %2}\n+   shld{q}\\t{%s2%1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"ishift\")\n+   (set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n+\n+(define_expand \"x86_64_shift_adj\"\n+  [(set (reg:CCZ FLAGS_REG)\n+\t(compare:CCZ (and:QI (match_operand:QI 2 \"register_operand\" \"\")\n+\t\t\t     (const_int 64))\n+\t\t     (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+        (if_then_else:DI (ne (reg:CCZ FLAGS_REG) (const_int 0))\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t (match_dup 0)))\n+   (set (match_dup 1)\n+\t(if_then_else:DI (ne (reg:CCZ FLAGS_REG) (const_int 0))\n+\t\t\t (match_operand:DI 3 \"register_operand\" \"r\")\n+\t\t\t (match_dup 1)))]\n+  \"TARGET_64BIT\"\n+  \"\")\n+\n (define_expand \"ashldi3\"\n   [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n \t(ashift:DI (match_operand:DI 1 \"ashldi_input_operand\" \"\")\n@@ -10203,7 +10410,7 @@\n    (match_dup 3)]\n   \"!TARGET_64BIT && TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_ashldi (operands, operands[3]); DONE;\")\n+  \"ix86_split_ashl (operands, operands[3], DImode); DONE;\")\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -10212,7 +10419,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\"\n   [(const_int 0)]\n-  \"ix86_split_ashldi (operands, NULL_RTX); DONE;\")\n+  \"ix86_split_ashl (operands, NULL_RTX, DImode); DONE;\")\n \n (define_insn \"x86_shld_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+r*m,r*m\")\n@@ -10778,6 +10985,76 @@\n \n ;; See comment above `ashldi3' about how this works.\n \n+(define_expand \"ashrti3\"\n+  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT\"\n+{\n+  if (! immediate_operand (operands[2], QImode))\n+    {\n+      emit_insn (gen_ashrti3_1 (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  ix86_expand_binary_operator (ASHIFTRT, TImode, operands);\n+  DONE;\n+})\n+\n+(define_insn \"ashrti3_1\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))\n+   (clobber (match_scratch:DI 3 \"=&r\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*ashrti3_2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"O\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"register_operand\" \"\")))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_ashr (operands, operands[3], TImode); DONE;\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_ashr (operands, NULL_RTX, TImode); DONE;\")\n+\n+(define_insn \"x86_64_shrd\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"+r*m,r*m\")\n+        (ior:DI (ashiftrt:DI (match_dup 0)\n+\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"J,c\"))\n+\t\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t  (minus:QI (const_int 64) (match_dup 2)))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   shrd{q}\\t{%2, %1, %0|%0, %1, %2}\n+   shrd{q}\\t{%s2%1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"ishift\")\n+   (set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n+\n (define_expand \"ashrdi3\"\n   [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n \t(ashiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n@@ -10887,7 +11164,7 @@\n    (match_dup 3)]\n   \"!TARGET_64BIT && TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_ashrdi (operands, operands[3]); DONE;\")\n+  \"ix86_split_ashr (operands, operands[3], DImode); DONE;\")\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -10896,7 +11173,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\"\n   [(const_int 0)]\n-  \"ix86_split_ashrdi (operands, NULL_RTX); DONE;\")\n+  \"ix86_split_ashr (operands, NULL_RTX, DImode); DONE;\")\n \n (define_insn \"x86_shrd_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+r*m,r*m\")\n@@ -11275,6 +11552,60 @@\n \n ;; See comment above `ashldi3' about how this works.\n \n+(define_expand \"lshrti3\"\n+  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT\"\n+{\n+  if (! immediate_operand (operands[2], QImode))\n+    {\n+      emit_insn (gen_lshrti3_1 (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  ix86_expand_binary_operator (LSHIFTRT, TImode, operands);\n+  DONE;\n+})\n+\n+(define_insn \"lshrti3_1\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))\n+   (clobber (match_scratch:DI 3 \"=&r\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*lshrti3_2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"O\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split \n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"register_operand\" \"\")))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_lshr (operands, operands[3], TImode); DONE;\")\n+\n+(define_split \n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_lshr (operands, NULL_RTX, TImode); DONE;\")\n+\n (define_expand \"lshrdi3\"\n   [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n \t(lshiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n@@ -11367,7 +11698,7 @@\n    (match_dup 3)]\n   \"!TARGET_64BIT && TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_lshrdi (operands, operands[3]); DONE;\")\n+  \"ix86_split_lshr (operands, operands[3], DImode); DONE;\")\n \n (define_split \n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -11376,7 +11707,7 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\"\n   [(const_int 0)]\n-  \"ix86_split_lshrdi (operands, NULL_RTX); DONE;\")\n+  \"ix86_split_lshr (operands, NULL_RTX, DImode); DONE;\")\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")"}]}