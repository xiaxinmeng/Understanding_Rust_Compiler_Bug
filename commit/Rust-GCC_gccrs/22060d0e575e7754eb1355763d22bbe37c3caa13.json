{"sha": "22060d0e575e7754eb1355763d22bbe37c3caa13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwNjBkMGU1NzVlNzc1NGViMTM1NTc2M2QyMmJiZTM3YzNjYWExMw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:03:35Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:03:35Z"}, "message": "[arm] Improve handling of DImode comparisions against constants.\n\nIn almost all cases it is better to handle inequality handling against constants\nby transforming comparisons of the form (reg <GE/LT/GEU/LTU> const) into\n(reg <GT/LE/GTU/LEU> (const+1)).  However, there are many cases that we could\nhandle but currently failed to do so because we forced the constant into a\nregister too early in the pattern expansion.  To permit this to be done we need\nto defer forcing the constant into a register until after we've had the chance\nto do the transform - in some cases that may even mean that we no-longer need\nto force the constant into a register at all.  For example, on Arm, the case:\n\n_Bool f8 (unsigned long long a) { return a > 0xffffffff; }\n\npreviously compiled to\n\n        mov     r3, #0\n        cmp     r1, r3\n        mvn     r2, #0\n        cmpeq   r0, r2\n        movhi   r0, #1\n        movls   r0, #0\n        bx      lr\n\nBut now compiles to\n\n        cmp     r1, #1\n        cmpeq   r0, #0\n        movcs   r0, #1\n        movcc   r0, #0\n        bx      lr\n\nWhich although not yet completely optimal, is certainly better than\npreviously.\n\n\t* config/arm/arm.md (cbranchdi4): Accept reg_or_int_operand for\n\toperand 2.\n\t(cstoredi4): Similarly, but for operand 3.\n\t* config/arm/arm.c (arm_canoncialize_comparison): Allow canonicalization\n\tof unsigned compares with a constant on Arm.  Prefer using const+1 and\n\tadjusting the comparison over swapping the operands whenever the\n\toriginal constant was not valid.\n\t(arm_gen_dicompare_reg): If Y is not a valid operand, force it to a\n\tregister here.\n\t(arm_validize_comparison): Do not force invalid DImode operands to\n\tregisters here.\n\nFrom-SVN: r277178", "tree": {"sha": "3b043d4b797da18e48a2963b8c3b12f8102d6769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b043d4b797da18e48a2963b8c3b12f8102d6769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22060d0e575e7754eb1355763d22bbe37c3caa13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22060d0e575e7754eb1355763d22bbe37c3caa13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22060d0e575e7754eb1355763d22bbe37c3caa13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22060d0e575e7754eb1355763d22bbe37c3caa13/comments", "author": null, "committer": null, "parents": [{"sha": "5899656b61231cc0e2dac4d7a58fab58674ba344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5899656b61231cc0e2dac4d7a58fab58674ba344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5899656b61231cc0e2dac4d7a58fab58674ba344"}], "stats": {"total": 55, "additions": 39, "deletions": 16}, "files": [{"sha": "52d14e92e64557456ecfc40d4a7ec5df09162771", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22060d0e575e7754eb1355763d22bbe37c3caa13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22060d0e575e7754eb1355763d22bbe37c3caa13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22060d0e575e7754eb1355763d22bbe37c3caa13", "patch": "@@ -1,3 +1,17 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.md (cbranchdi4): Accept reg_or_int_operand for\n+\toperand 2.\n+\t(cstoredi4): Similarly, but for operand 3.\n+\t* config/arm/arm.c (arm_canoncialize_comparison): Allow\n+\tcanonicalization of unsigned compares with a constant on Arm.\n+\tPrefer using const+1 and adjusting the comparison over swapping the\n+\toperands whenever the original constant was not valid.\n+\t(arm_gen_dicompare_reg): If Y is not a valid operand, force it to a\n+\tregister here.\n+\t(arm_validize_comparison): Do not force invalid DImode operands to\n+\tregisters here.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.c (arm_select_cc_mode): For DImode equality tests"}, {"sha": "e7924df9b809d0f52e27159f8c64c69e17b852b5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22060d0e575e7754eb1355763d22bbe37c3caa13/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22060d0e575e7754eb1355763d22bbe37c3caa13/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=22060d0e575e7754eb1355763d22bbe37c3caa13", "patch": "@@ -5372,15 +5372,16 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \n   maxval = (HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n \n-  /* For DImode, we have GE/LT/GEU/LTU comparisons.  In ARM mode\n-     we can also use cmp/cmpeq for GTU/LEU.  GT/LE must be either\n-     reversed or (for constant OP1) adjusted to GE/LT.  Similarly\n-     for GTU/LEU in Thumb mode.  */\n+  /* For DImode, we have GE/LT/GEU/LTU comparisons (with cmp/sbc).  In\n+     ARM mode we can also use cmp/cmpeq for GTU/LEU.  GT/LE must be\n+     either reversed or (for constant OP1) adjusted to GE/LT.\n+     Similarly for GTU/LEU in Thumb mode.  */\n   if (mode == DImode)\n     {\n \n       if (*code == GT || *code == LE\n-\t  || (!TARGET_ARM && (*code == GTU || *code == LEU)))\n+\t  || ((!TARGET_ARM || CONST_INT_P (*op1))\n+\t      && (*code == GTU || *code == LEU)))\n \t{\n \t  /* Missing comparison.  First try to use an available\n \t     comparison.  */\n@@ -5392,23 +5393,27 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\tcase GT:\n \t\tcase LE:\n \t\t  if (i != maxval\n-\t\t      && arm_const_double_by_immediates (GEN_INT (i + 1)))\n+\t\t      && (!arm_const_double_by_immediates (*op1)\n+\t\t\t  || arm_const_double_by_immediates (GEN_INT (i + 1))))\n \t\t    {\n \t\t      *op1 = GEN_INT (i + 1);\n \t\t      *code = *code == GT ? GE : LT;\n \t\t      return;\n \t\t    }\n \t\t  break;\n+\n \t\tcase GTU:\n \t\tcase LEU:\n \t\t  if (i != ~((unsigned HOST_WIDE_INT) 0)\n-\t\t      && arm_const_double_by_immediates (GEN_INT (i + 1)))\n+\t\t      && (!arm_const_double_by_immediates (*op1)\n+\t\t\t  || arm_const_double_by_immediates (GEN_INT (i + 1))))\n \t\t    {\n \t\t      *op1 = GEN_INT (i + 1);\n \t\t      *code = *code == GTU ? GEU : LTU;\n \t\t      return;\n \t\t    }\n \t\t  break;\n+\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n@@ -15436,7 +15441,7 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \t\tscratch = gen_reg_rtx (SImode);\n \t      if (ylo == const0_rtx)\n \t\t{\n-\t\t  yhi = GEN_INT (-INTVAL(yhi));\n+\t\t  yhi = gen_int_mode (-INTVAL (yhi), SImode);\n \t\t  if (!arm_add_operand (yhi, SImode))\n \t\t    yhi = force_reg (SImode, yhi);\n \t\t  emit_insn (gen_addsi3 (scratch, xhi, yhi));\n@@ -15445,7 +15450,7 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \t      else\n \t\t{\n \t\t  gcc_assert (yhi == const0_rtx);\n-\t\t  ylo = GEN_INT (-INTVAL(ylo));\n+\t\t  ylo = gen_int_mode (-INTVAL (ylo), SImode);\n \t\t  if (!arm_add_operand (ylo, SImode))\n \t\t    ylo = force_reg (SImode, ylo);\n \t\t  emit_insn (gen_addsi3 (scratch, xlo, ylo));\n@@ -15458,6 +15463,8 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \t    x = gen_rtx_IOR (SImode, gen_lowpart (SImode, x),\n \t\t\t     gen_highpart (SImode, x));\n \t}\n+      else if (!cmpdi_operand (y, mode))\n+\ty = force_reg (DImode, y);\n \n       /* A scratch register is required.  */\n       if (reload_completed)\n@@ -15470,7 +15477,12 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n     }\n   else\n-    emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+    {\n+      if (!cmpdi_operand (y, mode))\n+\ty = force_reg (DImode, y);\n+\n+      emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+    }\n \n   return cc_reg;\n }\n@@ -30479,10 +30491,7 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n       return true;\n \n     case E_DImode:\n-      if (!cmpdi_operand (*op1, mode))\n-\t*op1 = force_reg (mode, *op1);\n-      if (!cmpdi_operand (*op2, mode))\n-\t*op2 = force_reg (mode, *op2);\n+      /* gen_compare_reg() will sort out any invalid operands.  */\n       return true;\n \n     case E_HFmode:"}, {"sha": "9d8b137651f30957dd0b2dd656dd11b792157448", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22060d0e575e7754eb1355763d22bbe37c3caa13/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22060d0e575e7754eb1355763d22bbe37c3caa13/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=22060d0e575e7754eb1355763d22bbe37c3caa13", "patch": "@@ -6397,7 +6397,7 @@\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"expandable_comparison_operator\"\n \t       [(match_operand:DI 1 \"s_register_operand\")\n-\t        (match_operand:DI 2 \"cmpdi_operand\")])\n+\t        (match_operand:DI 2 \"reg_or_int_operand\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"TARGET_32BIT\"\n@@ -6862,7 +6862,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\")\n \t(match_operator:SI 1 \"expandable_comparison_operator\"\n \t [(match_operand:DI 2 \"s_register_operand\")\n-\t  (match_operand:DI 3 \"cmpdi_operand\")]))]\n+\t  (match_operand:DI 3 \"reg_or_int_operand\")]))]\n   \"TARGET_32BIT\"\n   \"{\n      if (!arm_validize_comparison (&operands[1],"}]}