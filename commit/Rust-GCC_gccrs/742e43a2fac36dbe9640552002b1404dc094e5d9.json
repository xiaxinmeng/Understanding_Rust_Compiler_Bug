{"sha": "742e43a2fac36dbe9640552002b1404dc094e5d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyZTQzYTJmYWMzNmRiZTk2NDA1NTIwMDJiMTQwNGRjMDk0ZTVkOQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-03-03T20:35:27Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-03-03T20:35:27Z"}, "message": "Define and use new function build_range_type.\n\nFrom-SVN: r3624", "tree": {"sha": "fb9a1258971ad5cf440bfcc8e336363205d7b673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb9a1258971ad5cf440bfcc8e336363205d7b673"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/742e43a2fac36dbe9640552002b1404dc094e5d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742e43a2fac36dbe9640552002b1404dc094e5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742e43a2fac36dbe9640552002b1404dc094e5d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742e43a2fac36dbe9640552002b1404dc094e5d9/comments", "author": null, "committer": null, "parents": [{"sha": "c8d6697caa95cb93f1105a904fbcf0bd8a3dc3ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8d6697caa95cb93f1105a904fbcf0bd8a3dc3ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8d6697caa95cb93f1105a904fbcf0bd8a3dc3ea"}], "stats": {"total": 35, "additions": 25, "deletions": 10}, "files": [{"sha": "8fe09a10daf7e1cff80310bc2ca9400eacadefbb", "filename": "gcc/tree.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742e43a2fac36dbe9640552002b1404dc094e5d9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742e43a2fac36dbe9640552002b1404dc094e5d9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=742e43a2fac36dbe9640552002b1404dc094e5d9", "patch": "@@ -2688,20 +2688,25 @@ build_index_type (maxval)\n     return itype;\n }\n \n-/* Just like build_index_type, but takes lowval and highval instead\n-   of just highval (maxval). */\n+/* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n+   ENUMERAL_TYPE, BOOLEAN_TYPE, or VHAR_TYPE), with\n+   low bound LOWVAL and high bound HIGHVAL.\n+   if TYPE==NULL_TREE, sizetype is used. */\n \n tree\n-build_index_2_type (lowval,highval)\n-     tree lowval, highval;\n+build_range_type (type, lowval, highval)\n+     tree type, lowval, highval;\n {\n   register tree itype = make_node (INTEGER_TYPE);\n-  TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n-  TYPE_MIN_VALUE (itype) = convert (sizetype, lowval);\n-  TYPE_MAX_VALUE (itype) = convert (sizetype, highval);\n-  TYPE_MODE (itype) = TYPE_MODE (sizetype);\n-  TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n-  TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n+  TREE_TYPE (itype) = type;\n+  if (type == NULL_TREE)\n+    type = sizetype;\n+  TYPE_PRECISION (itype) = TYPE_PRECISION (type);\n+  TYPE_MIN_VALUE (itype) = convert (type, lowval);\n+  TYPE_MAX_VALUE (itype) = convert (type, highval);\n+  TYPE_MODE (itype) = TYPE_MODE (type);\n+  TYPE_SIZE (itype) = TYPE_SIZE (type);\n+  TYPE_ALIGN (itype) = TYPE_ALIGN (type);\n   if ((TREE_CODE (lowval) == INTEGER_CST)\n       && (TREE_CODE (highval) == INTEGER_CST))\n     {\n@@ -2714,6 +2719,16 @@ build_index_2_type (lowval,highval)\n     return itype;\n }\n \n+/* Just like build_index_type, but takes lowval and highval instead\n+   of just highval (maxval). */\n+\n+tree\n+build_index_2_type (lowval,highval)\n+     tree lowval, highval;\n+{\n+  return build_range_type (NULL_TREE, lowval, highval);\n+}\n+\n /* Return nonzero iff ITYPE1 and ITYPE2 are equal (in the LISP sense).\n    Needed because when index types are not hashed, equal index types\n    built at different times appear distinct, even though structurally,"}]}