{"sha": "a71751232c9ef260162f2ff0ec75272633a39feb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcxNzUxMjMyYzllZjI2MDE2MmYyZmYwZWM3NTI3MjYzM2EzOWZlYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-04-01T19:05:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-04-01T19:05:12Z"}, "message": "call.c (add_function_candidate): Take the address of 'this' here.\n\n\t* call.c (add_function_candidate): Take the address of 'this' here.\n\t(build_over_call): And here.\n\t(build_new_method_call_1, build_op_call_1): Not here.\n\t(build_user_type_conversion_1): Or here.\n\t(add_candidates): Adjust.\n\nFrom-SVN: r197317", "tree": {"sha": "65e6c84f29f82faa6bc302861242974c097c1862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65e6c84f29f82faa6bc302861242974c097c1862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a71751232c9ef260162f2ff0ec75272633a39feb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71751232c9ef260162f2ff0ec75272633a39feb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a71751232c9ef260162f2ff0ec75272633a39feb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71751232c9ef260162f2ff0ec75272633a39feb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4101929ef37bbc91668b2ba5bd22a5361448700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4101929ef37bbc91668b2ba5bd22a5361448700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4101929ef37bbc91668b2ba5bd22a5361448700"}], "stats": {"total": 77, "additions": 45, "deletions": 32}, "files": [{"sha": "ac22dc2344520f94cde05009949860d4bd2fa5bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71751232c9ef260162f2ff0ec75272633a39feb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71751232c9ef260162f2ff0ec75272633a39feb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a71751232c9ef260162f2ff0ec75272633a39feb", "patch": "@@ -1,5 +1,11 @@\n 2013-04-01  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (add_function_candidate): Take the address of 'this' here.\n+\t(build_over_call): And here.\n+\t(build_new_method_call_1, build_op_call_1): Not here.\n+\t(build_user_type_conversion_1): Or here.\n+\t(add_candidates): Adjust.\n+\n \t* cxx-pretty-print.h (pp_cxx_cv_qualifiers): New.\n \t* class.c (same_signature_p): Use type_memfn_quals.\n \t* cp-tree.h (TYPE_RAISES_EXCEPTIONS): Use"}, {"sha": "b75ca974e045e466dace4b8ad047d4a7e285bb09", "filename": "gcc/cp/call.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71751232c9ef260162f2ff0ec75272633a39feb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71751232c9ef260162f2ff0ec75272633a39feb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a71751232c9ef260162f2ff0ec75272633a39feb", "patch": "@@ -1959,11 +1959,13 @@ add_function_candidate (struct z_candidate **candidates,\n \t\t     object parameter has reference type.  */\n \t\t  bool rv = FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (fn));\n \t\t  parmtype = cp_build_reference_type (parmtype, rv);\n-\t\t  arg = build_fold_indirect_ref (arg);\n-\t\t  argtype = lvalue_type (arg);\n \t\t}\n \t      else\n-\t\tparmtype = build_pointer_type (parmtype);\n+\t\t{\n+\t\t  parmtype = build_pointer_type (parmtype);\n+\t\t  arg = build_this (arg);\n+\t\t  argtype = lvalue_type (arg);\n+\t\t}\n \t    }\n \n \t  /* Core issue 899: When [copy-]initializing a temporary to be bound\n@@ -3460,6 +3462,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n       int ctorflags = flags;\n \n       first_arg = build_int_cst (build_pointer_type (totype), 0);\n+      first_arg = build_fold_indirect_ref (first_arg);\n \n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n@@ -3501,7 +3504,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n     }\n \n   if (conv_fns)\n-    first_arg = build_this (expr);\n+    first_arg = expr;\n \n   for (; conv_fns; conv_fns = TREE_CHAIN (conv_fns))\n     {\n@@ -4079,7 +4082,7 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \n   if (fns)\n     {\n-      first_mem_arg = build_this (obj);\n+      first_mem_arg = obj;\n \n       add_candidates (BASELINK_FUNCTIONS (fns),\n \t\t      first_mem_arg, *args, NULL_TREE,\n@@ -4936,7 +4939,7 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t is considered to be a member of the class of the implicit\n \t object argument for the purpose of defining the type of\n \t the implicit object parameter.  */\n-      ctype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (first_arg)));\n+      ctype = TYPE_MAIN_VARIANT (TREE_TYPE (first_arg));\n     }\n   else\n     {\n@@ -4990,7 +4993,7 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t      for (ix = 1; args->iterate (ix, &arg); ++ix)\n \t\ttempvec->quick_push (arg);\n \t      non_static_args = tempvec;\n-\t      first_arg = build_this ((*args)[0]);\n+\t      first_arg = (*args)[0];\n \t    }\n \n \t  fn_first_arg = first_arg;\n@@ -6722,16 +6725,18 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n      resolution, and must be of the proper type.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n+      tree object_arg;\n       if (first_arg != NULL_TREE)\n \t{\n-\t  argarray[j++] = first_arg;\n+\t  object_arg = first_arg;\n \t  first_arg = NULL_TREE;\n \t}\n       else\n \t{\n-\t  argarray[j++] = (*args)[arg_index];\n+\t  object_arg = (*args)[arg_index];\n \t  ++arg_index;\n \t}\n+      argarray[j++] = build_this (object_arg);\n       parm = TREE_CHAIN (parm);\n       /* We should never try to call the abstract constructor.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (fn));\n@@ -6747,9 +6752,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n     {\n       tree parmtype = TREE_VALUE (parm);\n-      tree arg = (first_arg != NULL_TREE\n-\t\t  ? first_arg\n-\t\t  : (*args)[arg_index]);\n+      tree arg = build_this (first_arg != NULL_TREE\n+\t\t\t     ? first_arg\n+\t\t\t     : (*args)[arg_index]);\n       tree argtype = TREE_TYPE (arg);\n       tree converted_arg;\n       tree base_binfo;\n@@ -7411,7 +7416,6 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n   tree access_binfo;\n   tree optype;\n   tree first_mem_arg = NULL_TREE;\n-  tree instance_ptr;\n   tree name;\n   bool skip_first_for_error;\n   vec<tree, va_gc> *user_args;\n@@ -7519,22 +7523,27 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \treturn error_mark_node;\n     }\n \n-  instance_ptr = build_this (instance);\n+  /* Consider the object argument to be used even if we end up selecting a\n+     static member function.  */\n+  instance = mark_type_use (instance);\n \n   /* It's OK to call destructors and constructors on cv-qualified objects.\n-     Therefore, convert the INSTANCE_PTR to the unqualified type, if\n+     Therefore, convert the INSTANCE to the unqualified type, if\n      necessary.  */\n   if (DECL_DESTRUCTOR_P (fn)\n       || DECL_CONSTRUCTOR_P (fn))\n     {\n-      tree type = build_pointer_type (basetype);\n-      if (!same_type_p (type, TREE_TYPE (instance_ptr)))\n-\tinstance_ptr = build_nop (type, instance_ptr);\n+      if (!same_type_p (basetype, TREE_TYPE (instance)))\n+\t{\n+\t  instance = build_this (instance);\n+\t  instance = build_nop (build_pointer_type (basetype), instance);\n+\t  instance = build_fold_indirect_ref (instance);\n+\t}\n     }\n   if (DECL_DESTRUCTOR_P (fn))\n     name = complete_dtor_identifier;\n \n-  first_mem_arg = instance_ptr;\n+  first_mem_arg = instance;\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n@@ -7570,11 +7579,10 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \n       if (init)\n \t{\n-\t  tree ob;\n-\t  if (integer_zerop (instance_ptr))\n+\t  if (TREE_CODE (instance) == INDIRECT_REF\n+\t      && integer_zerop (TREE_OPERAND (instance, 0)))\n \t    return get_target_expr_sfinae (init, complain);\n-\t  ob = build_fold_indirect_ref (instance_ptr);\n-\t  init = build2 (INIT_EXPR, TREE_TYPE (ob), ob, init);\n+\t  init = build2 (INIT_EXPR, TREE_TYPE (instance), instance, init);\n \t  TREE_SIDE_EFFECTS (init) = true;\n \t  return init;\n \t}\n@@ -7599,11 +7607,11 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n       if (complain & tf_error)\n \t{\n \t  if (!COMPLETE_OR_OPEN_TYPE_P (basetype))\n-\t    cxx_incomplete_type_error (instance_ptr, basetype);\n+\t    cxx_incomplete_type_error (instance, basetype);\n \t  else if (optype)\n \t    error (\"no matching function for call to %<%T::operator %T(%A)%#V%>\",\n \t\t   basetype, optype, build_tree_list_vec (user_args),\n-\t\t   TREE_TYPE (TREE_TYPE (instance_ptr)));\n+\t\t   TREE_TYPE (instance));\n \t  else\n \t    {\n \t      char *pretty_name;\n@@ -7616,7 +7624,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\targlist = TREE_CHAIN (arglist);\n \t      error (\"no matching function for call to %<%T::%s(%A)%#V%>\",\n \t\t     basetype, pretty_name, arglist,\n-\t\t     TREE_TYPE (TREE_TYPE (instance_ptr)));\n+\t\t     TREE_TYPE (instance));\n \t      if (free_p)\n \t\tfree (pretty_name);\n \t    }\n@@ -7666,7 +7674,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t     fn);\n \n \t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n-\t      && is_dummy_object (instance_ptr))\n+\t      && is_dummy_object (instance))\n \t    {\n \t      instance = maybe_resolve_dummy (instance);\n \t      if (instance == error_mark_node)\n@@ -7675,8 +7683,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t{\n \t\t  /* We captured 'this' in the current lambda now that\n \t\t     we know we really need it.  */\n-\t\t  instance_ptr = build_this (instance);\n-\t\t  cand->first_arg = instance_ptr;\n+\t\t  cand->first_arg = instance;\n \t\t}\n \t      else\n \t\t{\n@@ -7711,10 +7718,10 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t out to be a static member function, `a' is\n \t\t none-the-less evaluated.  */\n \t      if (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n-\t\t  && !is_dummy_object (instance_ptr)\n-\t\t  && TREE_SIDE_EFFECTS (instance_ptr))\n+\t\t  && !is_dummy_object (instance)\n+\t\t  && TREE_SIDE_EFFECTS (instance))\n \t\tcall = build2 (COMPOUND_EXPR, TREE_TYPE (call),\n-\t\t\t       instance_ptr, call);\n+\t\t\t       instance, call);\n \t      else if (call != error_mark_node\n \t\t       && DECL_DESTRUCTOR_P (cand->fn)\n \t\t       && !VOID_TYPE_P (TREE_TYPE (call)))"}]}